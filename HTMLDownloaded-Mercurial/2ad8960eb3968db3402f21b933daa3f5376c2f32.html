<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 15975:2ad8960eb3968db3402f21b933daa3f5376c2f32</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 2ad8960eb3968db3402f21b933daa3f5376c2f32" />
<meta property="og:url" content="/comm-central/rev/2ad8960eb3968db3402f21b933daa3f5376c2f32" />
<meta property="og:description" content="Bug 959309: Import JSMime 0.2 into comm-central, r=irving, sr=Standard8" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 2ad8960eb3968db3402f21b933daa3f5376c2f32 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/2ad8960eb3968db3402f21b933daa3f5376c2f32">shortlog</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/2ad8960eb3968db3402f21b933daa3f5376c2f32">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32">files</a> |
changeset |
<a href="/comm-central/raw-rev/2ad8960eb3968db3402f21b933daa3f5376c2f32">raw</a>  | <a href="/comm-central/archive/2ad8960eb3968db3402f21b933daa3f5376c2f32.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=959309">Bug 959309</a>: Import JSMime 0.2 into comm-central, r=irving, sr=Standard8
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#115;&#104;&#117;&#97;&#32;&#67;&#114;&#97;&#110;&#109;&#101;&#114;&#32;&#60;&#80;&#105;&#100;&#103;&#101;&#111;&#116;&#49;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 04 Apr 2014 19:51:37 -0500</td></tr>

<tr>
 <td>changeset 15975</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/2ad8960eb3968db3402f21b933daa3f5376c2f32">2ad8960eb3968db3402f21b933daa3f5376c2f32</a></td>
</tr>



<tr>
<td>parent 15974</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/ff757dfd6501b532036c111d9d44f44ffbf51fbd">ff757dfd6501b532036c111d9d44f44ffbf51fbd</a>
</td>
</tr>

<tr>
<td>child 15976</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/c7154af5cfaa16e769d06d24c00fabf59b9292af">c7154af5cfaa16e769d06d24c00fabf59b9292af</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=2ad8960eb3968db3402f21b933daa3f5376c2f32">10006</a></td></tr>
<tr><td>push user</td><td>Pidgeot18@gmail.com</td></tr>
<tr><td>push date</td><td class="date age">Sat, 05 Apr 2014 01:11:10 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@c7154af5cfaa [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=c7154af5cfaa16e769d06d24c00fabf59b9292af">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=c7154af5cfaa16e769d06d24c00fabf59b9292af&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=c7154af5cfaa16e769d06d24c00fabf59b9292af&newProject=comm-central&newRevision=2ad8960eb3968db3402f21b933daa3f5376c2f32&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=c7154af5cfaa16e769d06d24c00fabf59b9292af&newProject=comm-central&newRevision=2ad8960eb3968db3402f21b933daa3f5376c2f32&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=c7154af5cfaa16e769d06d24c00fabf59b9292af&newProject=comm-central&newRevision=2ad8960eb3968db3402f21b933daa3f5376c2f32&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28irving%29&revcount=50">irving</a>, <a href="/comm-central/log?rev=reviewer%28Standard8%29&revcount=50">Standard8</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=959309">959309</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=959309">Bug 959309</a>: Import JSMime 0.2 into comm-central, r=irving, sr=Standard8</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/Makefile.in">mailnews/mime/Makefile.in</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/Makefile.in">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/Makefile.in">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/Makefile.in">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/LICENSE">mailnews/mime/jsmime/LICENSE</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/LICENSE">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/LICENSE">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/LICENSE">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/LICENSE">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/LICENSE">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README">mailnews/mime/jsmime/README</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README.md">mailnews/mime/jsmime/README.md</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README.md">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README.md">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README.md">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README.md">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/README.md">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/jsmime.js">mailnews/mime/jsmime/jsmime.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/jsmime.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/jsmime.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/jsmime.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/jsmime.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/jsmime.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParser.jsm">mailnews/mime/jsmime/mimeParser.jsm</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParser.jsm">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParser.jsm">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParser.jsm">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParserCore.js">mailnews/mime/jsmime/mimeParserCore.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParserCore.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParserCore.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/mimeParserCore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-1">mailnews/mime/jsmime/test/data/base64-1</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-1">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-1">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-1">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-1">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-1">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-2">mailnews/mime/jsmime/test/data/base64-2</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-2">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-2">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-2">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-2">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/base64-2">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/basic1">mailnews/mime/jsmime/test/data/basic1</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/basic1">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/basic1">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/basic1">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/basic1">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/basic1">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bug505221">mailnews/mime/jsmime/test/data/bug505221</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bug505221">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bug505221">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bug505221">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bug505221">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bug505221">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bugmail11">mailnews/mime/jsmime/test/data/bugmail11</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bugmail11">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bugmail11">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bugmail11">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bugmail11">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/bugmail11">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/charsets">mailnews/mime/jsmime/test/data/charsets</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/charsets">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/charsets">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/charsets">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/charsets">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/charsets">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/message-encoded">mailnews/mime/jsmime/test/data/message-encoded</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/message-encoded">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/message-encoded">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/message-encoded">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/message-encoded">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/message-encoded">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/mime-torture">mailnews/mime/jsmime/test/data/mime-torture</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/mime-torture">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/mime-torture">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/mime-torture">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/mime-torture">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/mime-torture">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-1">mailnews/mime/jsmime/test/data/multipart-base64-1</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-1">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-1">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-1">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-1">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-1">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-2">mailnews/mime/jsmime/test/data/multipart-base64-2</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-2">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-2">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-2">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-2">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-2">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-3">mailnews/mime/jsmime/test/data/multipart-base64-3</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-3">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-3">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-3">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-3">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-base64-3">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex1">mailnews/mime/jsmime/test/data/multipart-complex1</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex1">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex1">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex1">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex1">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex1">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex2">mailnews/mime/jsmime/test/data/multipart-complex2</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex2">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex2">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex2">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex2">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart-complex2">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart1">mailnews/mime/jsmime/test/data/multipart1</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart1">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart1">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart1">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart1">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart1">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart2">mailnews/mime/jsmime/test/data/multipart2</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart2">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart2">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart2">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart2">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart2">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart3">mailnews/mime/jsmime/test/data/multipart3</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart3">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart3">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart3">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart3">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart3">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart4">mailnews/mime/jsmime/test/data/multipart4</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart4">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart4">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart4">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart4">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipart4">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipartmalt-detach">mailnews/mime/jsmime/test/data/multipartmalt-detach</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipartmalt-detach">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipartmalt-detach">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipartmalt-detach">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipartmalt-detach">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/multipartmalt-detach">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/shift-jis-image">mailnews/mime/jsmime/test/data/shift-jis-image</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/shift-jis-image">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/shift-jis-image">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/shift-jis-image">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/shift-jis-image">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/data/shift-jis-image">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/head_xpcshell_glue.js">mailnews/mime/jsmime/test/head_xpcshell_glue.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/head_xpcshell_glue.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/head_xpcshell_glue.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/head_xpcshell_glue.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/head_xpcshell_glue.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/head_xpcshell_glue.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_custom_headers.js">mailnews/mime/jsmime/test/test_custom_headers.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_custom_headers.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_custom_headers.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_custom_headers.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_custom_headers.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_custom_headers.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header.js">mailnews/mime/jsmime/test/test_header.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header_emitter.js">mailnews/mime/jsmime/test/test_header_emitter.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header_emitter.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header_emitter.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header_emitter.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header_emitter.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_header_emitter.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_mime_tree.js">mailnews/mime/jsmime/test/test_mime_tree.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_mime_tree.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_mime_tree.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_mime_tree.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_mime_tree.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_mime_tree.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_header_emitters.js">mailnews/mime/jsmime/test/test_structured_header_emitters.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_header_emitters.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_header_emitters.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_header_emitters.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_header_emitters.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_header_emitters.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_headers.js">mailnews/mime/jsmime/test/test_structured_headers.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_headers.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_headers.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_headers.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_headers.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/test_structured_headers.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/xpcshell.ini">mailnews/mime/jsmime/test/xpcshell.ini</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/xpcshell.ini">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/xpcshell.ini">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/xpcshell.ini">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/xpcshell.ini">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/jsmime/test/xpcshell.ini">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/moz.build">mailnews/mime/moz.build</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/moz.build">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/moz.build">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/moz.build">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/moz.build">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/moz.build">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/jsmime.jsm">mailnews/mime/src/jsmime.jsm</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/jsmime.jsm">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/jsmime.jsm">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/jsmime.jsm">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/jsmime.jsm">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/jsmime.jsm">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeJSComponents.js">mailnews/mime/src/mimeJSComponents.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeJSComponents.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeJSComponents.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeJSComponents.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeJSComponents.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeJSComponents.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeParser.jsm">mailnews/mime/src/mimeParser.jsm</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeParser.jsm">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeParser.jsm">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeParser.jsm">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeParser.jsm">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/mimeParser.jsm">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/moz.build">mailnews/mime/src/moz.build</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/moz.build">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/moz.build">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/moz.build">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/moz.build">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/src/moz.build">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/test/unit/test_parser.js">mailnews/mime/test/unit/test_parser.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/test/unit/test_parser.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/test/unit/test_parser.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/test/unit/test_parser.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/test/unit/test_parser.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/mime/test/unit/test_parser.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/imapd.js">mailnews/test/fakeserver/imapd.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/imapd.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/imapd.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/imapd.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/imapd.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/imapd.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/nntpd.js">mailnews/test/fakeserver/nntpd.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/nntpd.js">file</a> |
<a href="/comm-central/annotate/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/nntpd.js">annotate</a> |
<a href="/comm-central/diff/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/nntpd.js">diff</a> |
<a href="/comm-central/comparison/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/nntpd.js">comparison</a> |
<a href="/comm-central/log/2ad8960eb3968db3402f21b933daa3f5376c2f32/mailnews/test/fakeserver/nntpd.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1">deleted file mode 100644</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineminus">--- a/mailnews/mime/Makefile.in</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineplus">+++ /dev/null</span>
<a href="#l1.4"></a><span id="l1.4" class="difflineat">@@ -1,17 +0,0 @@</span>
<a href="#l1.5"></a><span id="l1.5" class="difflineminus">-#</span>
<a href="#l1.6"></a><span id="l1.6" class="difflineminus">-# This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l1.7"></a><span id="l1.7" class="difflineminus">-# License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l1.8"></a><span id="l1.8" class="difflineminus">-# file, You can obtain one at http://mozilla.org/MPL/2.0/.</span>
<a href="#l1.9"></a><span id="l1.9" class="difflineminus">-</span>
<a href="#l1.10"></a><span id="l1.10" class="difflineminus">-DEPTH		= @DEPTH@</span>
<a href="#l1.11"></a><span id="l1.11" class="difflineminus">-topsrcdir	= @top_srcdir@</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-srcdir		= @srcdir@</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-VPATH		= @srcdir@</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineminus">-</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-include $(DEPTH)/config/autoconf.mk</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineminus">-</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineminus">-libs:: jsmime/mimeParser.jsm</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineminus">-	$(call install_cmd,$(IFLAGS1) $^ $(FINAL_TARGET)/modules)</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineminus">-</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineminus">-include $(topsrcdir)/config/rules.mk</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineminus">-</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1">new file mode 100644</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineminus">--- /dev/null</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineplus">+++ b/mailnews/mime/jsmime/LICENSE</span>
<a href="#l2.4"></a><span id="l2.4" class="difflineat">@@ -0,0 +1,19 @@</span>
<a href="#l2.5"></a><span id="l2.5" class="difflineplus">+Copyright (c) 2013 Joshua Cranmer</span>
<a href="#l2.6"></a><span id="l2.6" class="difflineplus">+</span>
<a href="#l2.7"></a><span id="l2.7" class="difflineplus">+Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<a href="#l2.8"></a><span id="l2.8" class="difflineplus">+of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineplus">+in the Software without restriction, including without limitation the rights</span>
<a href="#l2.10"></a><span id="l2.10" class="difflineplus">+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<a href="#l2.11"></a><span id="l2.11" class="difflineplus">+copies of the Software, and to permit persons to whom the Software is</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+furnished to do so, subject to the following conditions:</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+The above copyright notice and this permission notice shall be included in</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+all copies or substantial portions of the Software.</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+THE SOFTWARE.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">rename from mailnews/mime/jsmime/README</span>
<a href="#l3.2"></a><span id="l3.2">rename to mailnews/mime/jsmime/README.md</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineminus">--- a/mailnews/mime/jsmime/README</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineplus">+++ b/mailnews/mime/jsmime/README.md</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineat">@@ -1,89 +1,59 @@</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineminus">-===============</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineminus">-= Code Layout =</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineminus">-===============</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+Code Layout</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+===========</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-This directory consists of a MIME parser which is primarily implemented in JS</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-and is designed to use either HTML 5 specifications or texts that are intendend</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-to become HTML 5 specifications.</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+JSMime is a MIME parsing and composition library that is written completely in</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+JavaScript using ES6 functionality and WebAPIs (where such APIs exist). There</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+are a few features for which a standardized WebAPI does not exist; for these,</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+external JavaScript libraries are used.</span>
<a href="#l3.19"></a><span id="l3.19"> </span>
<a href="#l3.20"></a><span id="l3.20"> The MIME parser consists of three logical phases of translation:</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+</span>
<a href="#l3.22"></a><span id="l3.22"> 1. Build the MIME (and pseudo-MIME) tree.</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineminus">-2. Convert the MIME tree into a body-and-attachments view.</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineminus">-3. Use the result to drive the message view.</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+2. Convert the MIME tree into a list of body parts and attachments.</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+3. Use the result to drive a displayed version of the message.</span>
<a href="#l3.27"></a><span id="l3.27"> </span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-The first stage is located in mimeParserCore.js. The later stages are not yet</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineminus">-implemented in JS. This file should not be included directly by consumers, who</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-should instead use mimeParser.jsm, which contains easier-to-use APIs and also</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-necessary glue components for use in JS modules or component contexts.</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+The first stage is located in `mimeparser.js`. The latter stages have yet to be</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+implemented.</span>
<a href="#l3.34"></a><span id="l3.34"> </span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-=============================</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineminus">-= Underlying specifications =</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineminus">-=============================</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+Dependencies</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+============</span>
<a href="#l3.40"></a><span id="l3.40"> </span>
<a href="#l3.41"></a><span id="l3.41" class="difflineminus">-The specification of MIME is complicated and is spread around a very large</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-number of references. For a single guide to everywhere, what follows is a list</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-of all references used in the course of this parser, structured roughly</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineminus">-according to how they are used:</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineminus">-[NOTE: specifications which are marked with an X instead are not integrated</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineminus">-       in this version of the code, but will be supported in a later version]</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineminus">-Basic format of bodies:</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineminus">-* RFC 2045 -- MIME Part 1, Format of Internet Message Bodies</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineminus">-* RFC 2046 -- MIME Part 2, Media Types</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+This code depends on the following ES6 features and Web APIs:</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+* ES6 generators</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+* ES6 Map and Set</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+* ES6 @@iterator support (especially for Map and Set)</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+* ES6 let</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+* ES6 let-destructuring</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+* ES6 const</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+* Typed arrays (predominantly Uint8Array)</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+* btoa, atob (found on global Windows or WorkerScopes)</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+* TextDecoder</span>
<a href="#l3.60"></a><span id="l3.60"> </span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-Structured header interpretation:</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineminus">-X RFC 2047 -- MIME Part 3, Message Header Extensions for Non-ASCII Text</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineminus">-X RFC 2231 -- MIME Parameter Value and Encoded Word Extensions</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineminus">-* RFC 5322 -- Internet Message Format (see also RFC 2822, RFC 822)</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineminus">-* RFC 5536 -- Netnews Article Format (see also RFC 1036)</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineminus">-X RFC 6532 -- Internationalized Email Headers (see also RFC 5335)</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineminus">-</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-Body decoding:</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-X &lt;http://pubs.opengroup.org/onlinepubs/7908799/xcu/uuencode.html&gt; -- Uuencode</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-X &lt;http://www.yenc.org/yenc-draft.1.3.txt&gt; -- yEnc</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-X RFC 1741 -- BinHex</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-X &lt;http://msdn.microsoft.com/en-us/library/cc425498%28v=exchg.80%29.aspx&gt; --</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineminus">-  TNEF</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineminus">-X RFC 3165 -- MIME security with PGP</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineminus">-X RFC 4880 -- OpenPGP (see also RFC 2440)</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineminus">-X RFC 5751 -- S/MIME (see also RFC 3851, RFC 2633)</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+Versions and API stability</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+==========================</span>
<a href="#l3.79"></a><span id="l3.79"> </span>
<a href="#l3.80"></a><span id="l3.80" class="difflineminus">-Other:</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineminus">-X RFC 2387 -- multipart/related</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineminus">-X RFC 2392 -- Content-ID and Message-ID  URLs</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineminus">-X RFC 2557 -- MIME-encapsulated aggegrate documents</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineminus">-* RFC 3501 -- IMAPv4rev1 [partial basis for part numbering]</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineminus">-X RFC 3676 -- text/plain format (format=flowed) (see also RFC 2646)</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineminus">-X RFC 3798 -- Message delivery notification (see also RFC 5337 and RFC 6533)</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineminus">-</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineminus">-While the above is a fairly comprehensive list of specifications, it turns</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineminus">-out that a somewhat different structure can be found in practice. Following</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineminus">-the general principle of &quot;Be liberal in what you accept and conservative in</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineminus">-what you send,&quot; this parser will attempt to make some sense of anything</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineminus">-passed into it. Some pathologically bad cases that the specification gives no</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineminus">-guidance to (such as having nested multipart/* bodies with the same boundary</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineminus">-permitted) are likely to provide inconsistent results with different parsers.</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+As APIs require some use and experimentation to get a feel for what works best,</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+the APIs may change between successive version updates as uses indicate</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+substandard or error-prone APIs. Therefore, there will be no guarantee of API</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+stability until version 1.0 is released.</span>
<a href="#l3.99"></a><span id="l3.99"> </span>
<a href="#l3.100"></a><span id="l3.100" class="difflineminus">-However, what follows is a list of modifications to the above specifications</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineminus">-that are necessary to account for messages which have been observed to cause</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineminus">-issues in the real world:</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineminus">-* All three line conventions are treated as a CRLF (\r, \n, \r\n). In this</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineminus">-  parser, it is possible to use a mixture of line endings in the same file,</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineminus">-  although this is highly unlikely to come up in practice.</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineminus">-* The input text need not be either ASCII or UTF-8 (permissible under the</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineminus">-  newer EAI specifications). Some tools that are insufficiently aware of i18n</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineminus">-  issues with respect to MIME may end up emitting non-ASCII (or non-UTF-8)</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineminus">-  data. In this parser, all header data is passed through as-is. Header names</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineminus">-  are canonicalized to lowercase using .toLowerCase(), which causes case</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineminus">-  conversion for non-ASCII charsets as well. However, even under EAI, header</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineminus">-  names are specified to be pure ASCII so this should not be an issue in</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineminus">-  practice. The body is left alone unless a charset is specified and recoding</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineminus">-  is explicitly requested.</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineminus">-* CFWS is permitted in fewer places than the specifications require. This was</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineminus">-  done to match other parsers (including the one this replaced, among others).</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineminus">-  In particular, the Content-Type parameter needs to be a single run of text, so</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineminus">-  &quot;multipart / mixed&quot; would be treated as an invalid type.</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineminus">-* If the first line of a headers block starts with the Berkely mailbox delimiter</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineminus">-  (From followed by a space), it is ignored.</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineminus">-* A message/rfc822-like part may be encoded in quoted-printable or base64, while</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineminus">-  RFC 6532 only permits this for message/global.</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineminus">-* XXX: RFC 2047 encoded words may contain embedded spaces.</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+This code is being initially developed as an effort to replace the MIME library</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineplus">+within Thunderbird. New versions will be released as needed to bring new support</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+into the Thunderbird codebase; version 1.0 will correspond to the version where</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+feature-parity with the old MIME library is reached. The set of features which</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+will be added before 1.0 are the following:</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+* S/MIME encryption and decryption</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+* PGP encryption and decryption</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+* IMAP parts-on-demand support</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+* Support for text/plain to HTML conversion for display</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+* Support for HTML downgrading and sanitization for display</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+* Support for all major multipart types</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+* Ability to convert HTML documents to text/plain and multipart/related</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+* Support for building outgoing messages</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+* Support for IDN and EAI</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+* yEnc and uuencode decoding support</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+* Support for date and Message-ID/References-like headers</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+Other features than these may be added before version 1.0 is released (most</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+notably TNEF decoding support), but they are not considered necessary to release</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+a version 1.0.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1">rename from mailnews/mime/jsmime/mimeParserCore.js</span>
<a href="#l4.2"></a><span id="l4.2">rename to mailnews/mime/jsmime/jsmime.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineminus">--- a/mailnews/mime/jsmime/mimeParserCore.js</span>
<a href="#l4.4"></a><span id="l4.4" class="difflineplus">+++ b/mailnews/mime/jsmime/jsmime.js</span>
<a href="#l4.5"></a><span id="l4.5" class="difflineat">@@ -1,36 +1,1202 @@</span>
<a href="#l4.6"></a><span id="l4.6" class="difflineminus">-/* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l4.7"></a><span id="l4.7" class="difflineminus">- * License, v. 2.0. If a copy of the MPL was not distributed with this file,</span>
<a href="#l4.8"></a><span id="l4.8" class="difflineminus">- * You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l4.9"></a><span id="l4.9" class="difflineplus">+(function (root, fn) {</span>
<a href="#l4.10"></a><span id="l4.10" class="difflineplus">+  if (typeof define === 'function' &amp;&amp; define.amd) {</span>
<a href="#l4.11"></a><span id="l4.11" class="difflineplus">+    define(fn);</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+  } else if (typeof module !== 'undefined' &amp;&amp; module.exports) {</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+    module.exports = fn();</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+  } else {</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+    root.jsmime = fn();</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+  }</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+}(this, function() {</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+  var mods = {};</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+  function req(id) {</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+    return mods[id.replace(/^\.\//, '')];</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+  }</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+  function def(id, fn) {</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+    mods[id] = fn(req);</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+  }</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+def('mimeutils', function() {</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+/**</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+ * Decode a quoted-printable buffer into a binary string.</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+ *</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+ * @param buffer {BinaryString} The string to decode.</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+ * @param more   {Boolean}      This argument is ignored.</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+ * @returns {Array(BinaryString, BinaryString)} The first element of the array</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+ *          is the decoded string. The second element is always the empty</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+ *          string.</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+ */</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+function decode_qp(buffer, more) {</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+  // Unlike base64, quoted-printable isn't stateful across multiple lines, so</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+  // there is no need to buffer input, so we can always ignore more.</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+  let decoded = buffer.replace(</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+    // Replace either =&lt;hex&gt;&lt;hex&gt; or =&lt;wsp&gt;CRLF</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+    /=([0-9A-F][0-9A-F]|[ \t]*(\r\n|[\r\n]|$))/gi,</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+    function replace_chars(match, param) {</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+      // If trailing text matches [ \t]*CRLF, drop everything, since it's a</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+      // soft line break.</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+      if (param.trim().length == 0)</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+        return '';</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+      return String.fromCharCode(parseInt(param, 16));</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+    });</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+  return [decoded, ''];</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+}</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+/**</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+ * Decode a base64 buffer into a binary string. Unlike window.atob, the buffer</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+ * may contain non-base64 characters that will be ignored.</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+ *</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+ * @param buffer {BinaryString} The string to decode.</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+ * @param more   {Boolean}      If true, we expect that this function could be</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+ *                              called again and should retain extra data. If</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+ *                              false, we should flush all pending output.</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+ * @returns {Array(BinaryString, BinaryString)} The first element of the array</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+ *          is the decoded string. The second element contains the data that</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+ *          could not be decoded and needs to be retained for the next call.</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineplus">+ */</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+function decode_base64(buffer, more) {</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+  // Drop all non-base64 characters</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+  let sanitize = buffer.replace(/[^A-Za-z0-9+\/=]/g,'');</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+  // We need to encode in groups of 4 chars. If we don't have enough, leave the</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+  // excess for later. If there aren't any more, drop enough to make it 4.</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+  let excess = sanitize.length % 4;</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineplus">+  if (excess != 0 &amp;&amp; more)</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+    buffer = sanitize.slice(-excess);</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+  else</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+    buffer = '';</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+  sanitize = sanitize.substring(0, sanitize.length - excess);</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+  // Use the atob function we (ought to) have in global scope.</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+  return [atob(sanitize), buffer];</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+}</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+/**</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+ * Converts a binary string into a Uint8Array buffer.</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+ *</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+ * @param buffer {BinaryString} The string to convert.</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+ * @returns {Uint8Array} The converted data.</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+ */</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+function stringToTypedArray(buffer) {</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+  var typedarray = new Uint8Array(buffer.length);</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+  for (var i = 0; i &lt; buffer.length; i++)</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+    typedarray[i] = buffer.charCodeAt(i);</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+  return typedarray;</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+}</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+/**</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+ * Converts a Uint8Array buffer to a binary string.</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+ *</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+ * @param buffer {BinaryString} The string to convert.</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+ * @returns {Uint8Array} The converted data.</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+ */</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+function typedArrayToString(buffer) {</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+  var string = '';</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+  for (var i = 0; i &lt; buffer.length; i+= 100)</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+    string += String.fromCharCode.apply(undefined, buffer.subarray(i, i + 100));</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+  return string;</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+}</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+return {</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+  decode_base64: decode_base64,</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+  decode_qp: decode_qp,</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+  stringToTypedArray: stringToTypedArray,</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+  typedArrayToString: typedArrayToString,</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineplus">+};</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+});</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineplus">+/**</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineplus">+ * This file implements knowledge of how to encode or decode structured headers</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineplus">+ * for several key headers. It is not meant to be used externally to jsmime.</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineplus">+ */</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineplus">+</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineplus">+def('structuredHeaders', function (require) {</span>
<a href="#l4.120"></a><span id="l4.120" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l4.121"></a><span id="l4.121" class="difflineplus">+</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineplus">+var structuredDecoders = new Map();</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineplus">+var structuredEncoders = new Map();</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+var preferredSpellings = new Map();</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineplus">+function addHeader(name, decoder, encoder) {</span>
<a href="#l4.127"></a><span id="l4.127" class="difflineplus">+  var lowerName = name.toLowerCase();</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineplus">+  structuredDecoders.set(lowerName, decoder);</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineplus">+  structuredEncoders.set(lowerName, encoder);</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineplus">+  preferredSpellings.set(lowerName, name);</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineplus">+}</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineplus">+</span>
<a href="#l4.133"></a><span id="l4.133" class="difflineplus">+</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineplus">+// Addressing headers: We assume that they can be specified in 1* form (this is</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineplus">+// false for From, but it's close enough to the truth that it shouldn't matter).</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineplus">+// There is no need to specialize the results for the header, so just pun it</span>
<a href="#l4.137"></a><span id="l4.137" class="difflineplus">+// back to parseAddressingHeader.</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineplus">+function parseAddress(value) {</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineplus">+  let results = [];</span>
<a href="#l4.140"></a><span id="l4.140" class="difflineplus">+  let headerparser = this;</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineplus">+  return value.reduce(function (results, header) {</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineplus">+    return results.concat(headerparser.parseAddressingHeader(header, true));</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineplus">+  }, []);</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineplus">+}</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineplus">+function writeAddress(value) {</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineplus">+  // Make sure the input is an array (accept a single entry)</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineplus">+  if (!Array.isArray(value))</span>
<a href="#l4.148"></a><span id="l4.148" class="difflineplus">+    value = [value];</span>
<a href="#l4.149"></a><span id="l4.149" class="difflineplus">+  this.addAddresses(value);</span>
<a href="#l4.150"></a><span id="l4.150" class="difflineplus">+}</span>
<a href="#l4.151"></a><span id="l4.151" class="difflineplus">+</span>
<a href="#l4.152"></a><span id="l4.152" class="difflineplus">+// Addressing headers from RFC 5322:</span>
<a href="#l4.153"></a><span id="l4.153" class="difflineplus">+addHeader(&quot;Bcc&quot;, parseAddress, writeAddress);</span>
<a href="#l4.154"></a><span id="l4.154" class="difflineplus">+addHeader(&quot;Cc&quot;, parseAddress, writeAddress);</span>
<a href="#l4.155"></a><span id="l4.155" class="difflineplus">+addHeader(&quot;From&quot;, parseAddress, writeAddress);</span>
<a href="#l4.156"></a><span id="l4.156" class="difflineplus">+addHeader(&quot;Reply-To&quot;, parseAddress, writeAddress);</span>
<a href="#l4.157"></a><span id="l4.157" class="difflineplus">+addHeader(&quot;Resent-Bcc&quot;, parseAddress, writeAddress);</span>
<a href="#l4.158"></a><span id="l4.158" class="difflineplus">+addHeader(&quot;Resent-Cc&quot;, parseAddress, writeAddress);</span>
<a href="#l4.159"></a><span id="l4.159" class="difflineplus">+addHeader(&quot;Resent-From&quot;, parseAddress, writeAddress);</span>
<a href="#l4.160"></a><span id="l4.160" class="difflineplus">+addHeader(&quot;Resent-Sender&quot;, parseAddress, writeAddress);</span>
<a href="#l4.161"></a><span id="l4.161" class="difflineplus">+addHeader(&quot;Resent-To&quot;, parseAddress, writeAddress);</span>
<a href="#l4.162"></a><span id="l4.162" class="difflineplus">+addHeader(&quot;Sender&quot;, parseAddress, writeAddress);</span>
<a href="#l4.163"></a><span id="l4.163" class="difflineplus">+addHeader(&quot;To&quot;, parseAddress, writeAddress);</span>
<a href="#l4.164"></a><span id="l4.164" class="difflineplus">+// From RFC 5536:</span>
<a href="#l4.165"></a><span id="l4.165" class="difflineplus">+addHeader(&quot;Approved&quot;, parseAddress, writeAddress);</span>
<a href="#l4.166"></a><span id="l4.166" class="difflineplus">+// From RFC 3798:</span>
<a href="#l4.167"></a><span id="l4.167" class="difflineplus">+addHeader(&quot;Disposition-Notification-To&quot;, parseAddress, writeAddress);</span>
<a href="#l4.168"></a><span id="l4.168" class="difflineplus">+// Non-standard headers:</span>
<a href="#l4.169"></a><span id="l4.169" class="difflineplus">+addHeader(&quot;Delivered-To&quot;, parseAddress, writeAddress);</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineplus">+addHeader(&quot;Return-Receipt-To&quot;, parseAddress, writeAddress);</span>
<a href="#l4.171"></a><span id="l4.171" class="difflineplus">+</span>
<a href="#l4.172"></a><span id="l4.172" class="difflineplus">+</span>
<a href="#l4.173"></a><span id="l4.173" class="difflineplus">+// Parameter-based headers. Note that all parameters are slightly different, so</span>
<a href="#l4.174"></a><span id="l4.174" class="difflineplus">+// we use slightly different variants here.</span>
<a href="#l4.175"></a><span id="l4.175" class="difflineplus">+function parseParameterHeader(value, do2231, do2047) {</span>
<a href="#l4.176"></a><span id="l4.176" class="difflineplus">+  // Only use the first header for parameters; ignore subsequent redefinitions.</span>
<a href="#l4.177"></a><span id="l4.177" class="difflineplus">+  return this.parseParameterHeader(value[0], do2231, do2047);</span>
<a href="#l4.178"></a><span id="l4.178" class="difflineplus">+}</span>
<a href="#l4.179"></a><span id="l4.179" class="difflineplus">+</span>
<a href="#l4.180"></a><span id="l4.180" class="difflineplus">+// RFC 2045</span>
<a href="#l4.181"></a><span id="l4.181" class="difflineplus">+function parseContentType(value) {</span>
<a href="#l4.182"></a><span id="l4.182" class="difflineplus">+  let params = parseParameterHeader.call(this, value, false, false);</span>
<a href="#l4.183"></a><span id="l4.183" class="difflineplus">+  let origtype = params.preSemi;</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineplus">+  let parts = origtype.split('/');</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineplus">+  if (parts.length != 2) {</span>
<a href="#l4.186"></a><span id="l4.186" class="difflineplus">+    // Malformed. Return to text/plain. Evil, ain't it?</span>
<a href="#l4.187"></a><span id="l4.187" class="difflineplus">+    params = new Map();</span>
<a href="#l4.188"></a><span id="l4.188" class="difflineplus">+    parts = [&quot;text&quot;, &quot;plain&quot;];</span>
<a href="#l4.189"></a><span id="l4.189" class="difflineplus">+  }</span>
<a href="#l4.190"></a><span id="l4.190" class="difflineplus">+  let mediatype = parts[0].toLowerCase();</span>
<a href="#l4.191"></a><span id="l4.191" class="difflineplus">+  let subtype = parts[1].toLowerCase();</span>
<a href="#l4.192"></a><span id="l4.192" class="difflineplus">+  let type = mediatype + '/' + subtype;</span>
<a href="#l4.193"></a><span id="l4.193" class="difflineplus">+  let structure = new Map();</span>
<a href="#l4.194"></a><span id="l4.194" class="difflineplus">+  structure.mediatype = mediatype;</span>
<a href="#l4.195"></a><span id="l4.195" class="difflineplus">+  structure.subtype = subtype;</span>
<a href="#l4.196"></a><span id="l4.196" class="difflineplus">+  structure.type = type;</span>
<a href="#l4.197"></a><span id="l4.197" class="difflineplus">+  params.forEach(function (value, name) {</span>
<a href="#l4.198"></a><span id="l4.198" class="difflineplus">+    structure.set(name.toLowerCase(), value);</span>
<a href="#l4.199"></a><span id="l4.199" class="difflineplus">+  });</span>
<a href="#l4.200"></a><span id="l4.200" class="difflineplus">+  return structure;</span>
<a href="#l4.201"></a><span id="l4.201" class="difflineplus">+}</span>
<a href="#l4.202"></a><span id="l4.202" class="difflineplus">+structuredDecoders.set(&quot;Content-Type&quot;, parseContentType);</span>
<a href="#l4.203"></a><span id="l4.203" class="difflineplus">+</span>
<a href="#l4.204"></a><span id="l4.204" class="difflineplus">+// Unstructured headers (just decode RFC 2047 for the first header value)</span>
<a href="#l4.205"></a><span id="l4.205" class="difflineplus">+function parseUnstructured(values) {</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineplus">+  return this.decodeRFC2047Words(values[0]);</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineplus">+}</span>
<a href="#l4.208"></a><span id="l4.208" class="difflineplus">+function writeUnstructured(value) {</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineplus">+  this.addUnstructured(value);</span>
<a href="#l4.210"></a><span id="l4.210" class="difflineplus">+}</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineplus">+</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+// RFC 5322</span>
<a href="#l4.213"></a><span id="l4.213" class="difflineplus">+addHeader(&quot;Comments&quot;, parseUnstructured, writeUnstructured);</span>
<a href="#l4.214"></a><span id="l4.214" class="difflineplus">+addHeader(&quot;Keywords&quot;, parseUnstructured, writeUnstructured);</span>
<a href="#l4.215"></a><span id="l4.215" class="difflineplus">+addHeader(&quot;Subject&quot;, parseUnstructured, writeUnstructured);</span>
<a href="#l4.216"></a><span id="l4.216" class="difflineplus">+</span>
<a href="#l4.217"></a><span id="l4.217" class="difflineplus">+// RFC 2045</span>
<a href="#l4.218"></a><span id="l4.218" class="difflineplus">+addHeader(&quot;Content-Description&quot;, parseUnstructured, writeUnstructured);</span>
<a href="#l4.219"></a><span id="l4.219" class="difflineplus">+</span>
<a href="#l4.220"></a><span id="l4.220" class="difflineplus">+</span>
<a href="#l4.221"></a><span id="l4.221" class="difflineplus">+</span>
<a href="#l4.222"></a><span id="l4.222" class="difflineplus">+// Miscellaneous headers (those that don't fall under the above schemes):</span>
<a href="#l4.223"></a><span id="l4.223" class="difflineplus">+</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineplus">+// RFC 2047</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineplus">+structuredDecoders.set(&quot;Content-Transfer-Encoding&quot;, function (values) {</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+  return values[0].toLowerCase();</span>
<a href="#l4.227"></a><span id="l4.227" class="difflineplus">+});</span>
<a href="#l4.228"></a><span id="l4.228" class="difflineplus">+structuredEncoders.set(&quot;Content-Transfer-Encoding&quot;, writeUnstructured);</span>
<a href="#l4.229"></a><span id="l4.229" class="difflineplus">+</span>
<a href="#l4.230"></a><span id="l4.230" class="difflineplus">+return Object.freeze({</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineplus">+  decoders: structuredDecoders,</span>
<a href="#l4.232"></a><span id="l4.232" class="difflineplus">+  encoders: structuredEncoders,</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineplus">+  spellings: preferredSpellings,</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineplus">+});</span>
<a href="#l4.235"></a><span id="l4.235" class="difflineplus">+</span>
<a href="#l4.236"></a><span id="l4.236" class="difflineplus">+});</span>
<a href="#l4.237"></a><span id="l4.237" class="difflineplus">+def('headerparser', function(require) {</span>
<a href="#l4.238"></a><span id="l4.238" class="difflineplus">+/**</span>
<a href="#l4.239"></a><span id="l4.239" class="difflineplus">+ * This file implements the structured decoding of message header fields. It is</span>
<a href="#l4.240"></a><span id="l4.240" class="difflineplus">+ * part of the same system as found in mimemimeutils.js, and occasionally makes</span>
<a href="#l4.241"></a><span id="l4.241" class="difflineplus">+ * references to globals defined in that file or other dependencies thereof. See</span>
<a href="#l4.242"></a><span id="l4.242" class="difflineplus">+ * documentation in that file for more information about external dependencies.</span>
<a href="#l4.243"></a><span id="l4.243" class="difflineplus">+ */</span>
<a href="#l4.244"></a><span id="l4.244" class="difflineplus">+</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineplus">+var mimeutils = require('./mimeutils');</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineplus">+</span>
<a href="#l4.248"></a><span id="l4.248" class="difflineplus">+/**</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineplus">+ * This is the API that we ultimately return.</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+ *</span>
<a href="#l4.251"></a><span id="l4.251" class="difflineplus">+ * We define it as a global here, because we need to pass it as a |this|</span>
<a href="#l4.252"></a><span id="l4.252" class="difflineplus">+ * argument to a few functions.</span>
<a href="#l4.253"></a><span id="l4.253" class="difflineplus">+ */</span>
<a href="#l4.254"></a><span id="l4.254" class="difflineplus">+var headerparser = {};</span>
<a href="#l4.255"></a><span id="l4.255" class="difflineplus">+</span>
<a href="#l4.256"></a><span id="l4.256" class="difflineplus">+/**</span>
<a href="#l4.257"></a><span id="l4.257" class="difflineplus">+ * Tokenizes a message header into a stream of tokens as a generator.</span>
<a href="#l4.258"></a><span id="l4.258" class="difflineplus">+ *</span>
<a href="#l4.259"></a><span id="l4.259" class="difflineplus">+ * The low-level tokens are meant to be loosely correspond to the tokens as</span>
<a href="#l4.260"></a><span id="l4.260" class="difflineplus">+ * defined in RFC 5322. For reasons of saner error handling, however, the two</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineplus">+ * definitions are not exactly equivalent. The tokens we emit are the following:</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineplus">+ * 1. Special delimiters: Any char in the delimiters string is emitted as a</span>
<a href="#l4.263"></a><span id="l4.263" class="difflineplus">+ *    string by itself. Parsing parameter headers, for example, would use &quot;;=&quot;</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineplus">+ *    for the delimiter string.</span>
<a href="#l4.265"></a><span id="l4.265" class="difflineplus">+ * 2. Quoted-strings (if opt.qstring is true): A string which is surrounded by</span>
<a href="#l4.266"></a><span id="l4.266" class="difflineplus">+ *    double quotes. Escapes in the string are omitted when returning.</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineplus">+ * 3. Domain Literals (if opt.dliteral is true): A string which matches the</span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+ *    dliteral construct in RFC 5322. Escapes here are NOT omitted.</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineplus">+ * 4. Comments (if opt.comments is true): Comments are handled specially. In</span>
<a href="#l4.270"></a><span id="l4.270" class="difflineplus">+ *    practice, decoding the comments in To headers appears to be necessary, so</span>
<a href="#l4.271"></a><span id="l4.271" class="difflineplus">+ *    comments are not stripped in the output value. Instead, they are emitted</span>
<a href="#l4.272"></a><span id="l4.272" class="difflineplus">+ *    as if they are a special delimiter. However, all delimiters found within a</span>
<a href="#l4.273"></a><span id="l4.273" class="difflineplus">+ *    comment are returned as if they were a quoted string, so that consumers</span>
<a href="#l4.274"></a><span id="l4.274" class="difflineplus">+ *    ignore delimiters within comments. If ignoring comment text completely is</span>
<a href="#l4.275"></a><span id="l4.275" class="difflineplus">+ *    desired, upon seeing a &quot;(&quot; token, consumers should ignore all tokens until</span>
<a href="#l4.276"></a><span id="l4.276" class="difflineplus">+ *    a matching &quot;)&quot; is found (note that comments can be nested).</span>
<a href="#l4.277"></a><span id="l4.277" class="difflineplus">+ * 5. RFC 2047 encoded-words (if opts.rfc2047 is true): These are strings which</span>
<a href="#l4.278"></a><span id="l4.278" class="difflineplus">+ *    are the decoded contents of RFC 2047's =?UTF-8?Q?blah?=-style words.</span>
<a href="#l4.279"></a><span id="l4.279" class="difflineplus">+ * 6. Atoms: Atoms are defined not in the RFC 5322 sense, but rather as the</span>
<a href="#l4.280"></a><span id="l4.280" class="difflineplus">+ *    longest sequence of characters that is neither whitespace nor any of the</span>
<a href="#l4.281"></a><span id="l4.281" class="difflineplus">+ *    special characters above.</span>
<a href="#l4.282"></a><span id="l4.282" class="difflineplus">+ *</span>
<a href="#l4.283"></a><span id="l4.283" class="difflineplus">+ * The intended interpretation of the stream of output tokens is that they are</span>
<a href="#l4.284"></a><span id="l4.284" class="difflineplus">+ * the portions of text which can be safely wrapped in whitespace with no ill</span>
<a href="#l4.285"></a><span id="l4.285" class="difflineplus">+ * effect. The output tokens are either strings (which represent individual</span>
<a href="#l4.286"></a><span id="l4.286" class="difflineplus">+ * delimiter tokens) or instances of a class that has a customized .toString()</span>
<a href="#l4.287"></a><span id="l4.287" class="difflineplus">+ * for output (for quoted strings, atoms, domain literals, and encoded-words).</span>
<a href="#l4.288"></a><span id="l4.288" class="difflineplus">+ * Checking for a delimiter MUST use the strictly equals operator (===). For</span>
<a href="#l4.289"></a><span id="l4.289" class="difflineplus">+ * example, the proper way to call this method is as follows:</span>
<a href="#l4.290"></a><span id="l4.290" class="difflineplus">+ *</span>
<a href="#l4.291"></a><span id="l4.291" class="difflineplus">+ *    for (let token of getHeaderTokens(rest, &quot;;=&quot;, opts)) {</span>
<a href="#l4.292"></a><span id="l4.292" class="difflineplus">+ *      if (token === ';') {</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineplus">+ *        // This represents a literal ';' in the string</span>
<a href="#l4.294"></a><span id="l4.294" class="difflineplus">+ *      } else if (token === '=') {</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+ *        // This represents a literal '=' in the string</span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+ *      } else {</span>
<a href="#l4.297"></a><span id="l4.297" class="difflineplus">+ *        // If a &quot;;&quot; qstring was parsed, we fall through to here!</span>
<a href="#l4.298"></a><span id="l4.298" class="difflineplus">+ *        token = token.toString();</span>
<a href="#l4.299"></a><span id="l4.299" class="difflineplus">+ *      }</span>
<a href="#l4.300"></a><span id="l4.300" class="difflineplus">+ *    }</span>
<a href="#l4.301"></a><span id="l4.301" class="difflineplus">+ *</span>
<a href="#l4.302"></a><span id="l4.302" class="difflineplus">+ * This method does not properly tokenize 5322 in all corner cases; however,</span>
<a href="#l4.303"></a><span id="l4.303" class="difflineplus">+ * this is equivalent in those corner cases to an older header parsing</span>
<a href="#l4.304"></a><span id="l4.304" class="difflineplus">+ * algorithm, so the algorithm should be correct for all real-world cases. The</span>
<a href="#l4.305"></a><span id="l4.305" class="difflineplus">+ * corner cases are as follows:</span>
<a href="#l4.306"></a><span id="l4.306" class="difflineplus">+ * 1. Quoted-strings and domain literals are parsed even if they are within a</span>
<a href="#l4.307"></a><span id="l4.307" class="difflineplus">+ *    comment block (we effectively treat ctext as containing qstring).</span>
<a href="#l4.308"></a><span id="l4.308" class="difflineplus">+ * 2. WSP need not be between a qstring and an atom (a&quot;b&quot; produces two tokens,</span>
<a href="#l4.309"></a><span id="l4.309" class="difflineplus">+ *    a and b). This is an error case, though.</span>
<a href="#l4.310"></a><span id="l4.310" class="difflineplus">+ *</span>
<a href="#l4.311"></a><span id="l4.311" class="difflineplus">+ * @param {String} value      The header value, post charset conversion but</span>
<a href="#l4.312"></a><span id="l4.312" class="difflineplus">+ *                            before RFC 2047 decoding, to be parsed.</span>
<a href="#l4.313"></a><span id="l4.313" class="difflineplus">+ * @param {String} delimiters A set of delimiters to include as individual</span>
<a href="#l4.314"></a><span id="l4.314" class="difflineplus">+ *                            tokens.</span>
<a href="#l4.315"></a><span id="l4.315" class="difflineplus">+ * @param {Object} opts       A set of options selecting what to parse.</span>
<a href="#l4.316"></a><span id="l4.316" class="difflineplus">+ * @param {Boolean} [opts.qstring]  If true, recognize quoted strings.</span>
<a href="#l4.317"></a><span id="l4.317" class="difflineplus">+ * @param {Boolean} [opts.dliteral] If true, recognize domain literals.</span>
<a href="#l4.318"></a><span id="l4.318" class="difflineplus">+ * @param {Boolean} [opts.comments] If true, recognize comments.</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineplus">+ * @param {Boolean} [opts.rfc2047]  If true, parse and decode RFC 2047</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineplus">+ *                                  encoded-words.</span>
<a href="#l4.321"></a><span id="l4.321" class="difflineplus">+ * @returns {(Token|String)*} A sequence of Token objects (which have a</span>
<a href="#l4.322"></a><span id="l4.322" class="difflineplus">+ *                            toString method returning their value) or String</span>
<a href="#l4.323"></a><span id="l4.323" class="difflineplus">+ *                            objects (representing delimiters).</span>
<a href="#l4.324"></a><span id="l4.324" class="difflineplus">+ */</span>
<a href="#l4.325"></a><span id="l4.325" class="difflineplus">+function* getHeaderTokens(value, delimiters, opts) {</span>
<a href="#l4.326"></a><span id="l4.326" class="difflineplus">+  /// Represents a non-delimiter token</span>
<a href="#l4.327"></a><span id="l4.327" class="difflineplus">+  function Token(token) {</span>
<a href="#l4.328"></a><span id="l4.328" class="difflineplus">+    // Unescape all quoted pairs. Any trailing \ is deleted.</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineplus">+    this.token = token.replace(/\\(.?)/g, &quot;$1&quot;);</span>
<a href="#l4.330"></a><span id="l4.330" class="difflineplus">+  }</span>
<a href="#l4.331"></a><span id="l4.331" class="difflineplus">+  Token.prototype.toString = function () { return this.token; };</span>
<a href="#l4.332"></a><span id="l4.332" class="difflineplus">+</span>
<a href="#l4.333"></a><span id="l4.333" class="difflineplus">+  // The start of the current token (e.g., atoms, strings)</span>
<a href="#l4.334"></a><span id="l4.334" class="difflineplus">+  let tokenStart = undefined;</span>
<a href="#l4.335"></a><span id="l4.335" class="difflineplus">+  // The set of whitespace characters, as defined by RFC 5322</span>
<a href="#l4.336"></a><span id="l4.336" class="difflineplus">+  let wsp = &quot; \t\r\n&quot;;</span>
<a href="#l4.337"></a><span id="l4.337" class="difflineplus">+  // If we are a domain literal ([]) or a quoted string (&quot;), this is set to the</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineplus">+  // character to look for at the end.</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineplus">+  let endQuote = undefined;</span>
<a href="#l4.340"></a><span id="l4.340" class="difflineplus">+  // The current depth of comments, since they can be nested. A value 0 means we</span>
<a href="#l4.341"></a><span id="l4.341" class="difflineplus">+  // are not in a comment.</span>
<a href="#l4.342"></a><span id="l4.342" class="difflineplus">+  let commentDepth = 0;</span>
<a href="#l4.343"></a><span id="l4.343" class="difflineplus">+</span>
<a href="#l4.344"></a><span id="l4.344" class="difflineplus">+  // Iterate over every character one character at a time.</span>
<a href="#l4.345"></a><span id="l4.345" class="difflineplus">+  let length = value.length;</span>
<a href="#l4.346"></a><span id="l4.346" class="difflineplus">+  for (let i = 0; i &lt; length; i++) {</span>
<a href="#l4.347"></a><span id="l4.347" class="difflineplus">+    let ch = value[i];</span>
<a href="#l4.348"></a><span id="l4.348" class="difflineplus">+    // If we see a \, no matter what context we are in, ignore the next</span>
<a href="#l4.349"></a><span id="l4.349" class="difflineplus">+    // character.</span>
<a href="#l4.350"></a><span id="l4.350" class="difflineplus">+    if (ch == '\\') {</span>
<a href="#l4.351"></a><span id="l4.351" class="difflineplus">+      i++;</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineplus">+      continue;</span>
<a href="#l4.353"></a><span id="l4.353" class="difflineplus">+    }</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineplus">+</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineplus">+    // If we are in a qstring or a dliteral, process the character only if it is</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineplus">+    // what we are looking for to end the quote.</span>
<a href="#l4.357"></a><span id="l4.357" class="difflineplus">+    if (endQuote !== undefined) {</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineplus">+      if (ch == endQuote &amp;&amp; ch == '&quot;') {</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineplus">+        // Quoted strings don't include their delimiters.</span>
<a href="#l4.360"></a><span id="l4.360" class="difflineplus">+        let text = value.slice(tokenStart + 1, i);</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineplus">+</span>
<a href="#l4.362"></a><span id="l4.362" class="difflineplus">+        // If RFC 2047 is enabled, decode the qstring only if the entire string</span>
<a href="#l4.363"></a><span id="l4.363" class="difflineplus">+        // appears to be a 2047 token. Don't unquote just yet (this will better</span>
<a href="#l4.364"></a><span id="l4.364" class="difflineplus">+        // match people who incorrectly treat RFC 2047 decoding as a separate,</span>
<a href="#l4.365"></a><span id="l4.365" class="difflineplus">+        // earlier step).</span>
<a href="#l4.366"></a><span id="l4.366" class="difflineplus">+        if (opts.rfc2047 &amp;&amp; text.startsWith(&quot;=?&quot;) &amp;&amp; text.endsWith(&quot;?=&quot;))</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineplus">+          text = decodeRFC2047Words(text);</span>
<a href="#l4.368"></a><span id="l4.368" class="difflineplus">+</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineplus">+        yield new Token(text);</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineplus">+        endQuote = undefined;</span>
<a href="#l4.371"></a><span id="l4.371" class="difflineplus">+        tokenStart = undefined;</span>
<a href="#l4.372"></a><span id="l4.372" class="difflineplus">+      } else if (ch == endQuote &amp;&amp; ch == ']') {</span>
<a href="#l4.373"></a><span id="l4.373" class="difflineplus">+        // Domain literals include their delimiters.</span>
<a href="#l4.374"></a><span id="l4.374" class="difflineplus">+        yield new Token(value.slice(tokenStart, i + 1));</span>
<a href="#l4.375"></a><span id="l4.375" class="difflineplus">+        endQuote = undefined;</span>
<a href="#l4.376"></a><span id="l4.376" class="difflineplus">+        tokenStart = undefined;</span>
<a href="#l4.377"></a><span id="l4.377" class="difflineplus">+      }</span>
<a href="#l4.378"></a><span id="l4.378" class="difflineplus">+      // Avoid any further processing.</span>
<a href="#l4.379"></a><span id="l4.379" class="difflineplus">+      continue;</span>
<a href="#l4.380"></a><span id="l4.380" class="difflineplus">+    }</span>
<a href="#l4.381"></a><span id="l4.381" class="difflineplus">+</span>
<a href="#l4.382"></a><span id="l4.382" class="difflineplus">+    // If we can match the RFC 2047 encoded-word pattern, we need to decode the</span>
<a href="#l4.383"></a><span id="l4.383" class="difflineplus">+    // entire word or set of words.</span>
<a href="#l4.384"></a><span id="l4.384" class="difflineplus">+    if (opts.rfc2047 &amp;&amp; ch == '=' &amp;&amp; i + 1 &lt; value.length &amp;&amp; value[i + 1] == '?') {</span>
<a href="#l4.385"></a><span id="l4.385" class="difflineplus">+      // RFC 2047 tokens separated only by whitespace are conceptually part of</span>
<a href="#l4.386"></a><span id="l4.386" class="difflineplus">+      // the same output token, so we need to decode them all at once.</span>
<a href="#l4.387"></a><span id="l4.387" class="difflineplus">+      let encodedWordsRE = /([ \t\r\n]*=\?[^?]*\?[BbQq]\?[^?]*\?=)+/;</span>
<a href="#l4.388"></a><span id="l4.388" class="difflineplus">+      let result = encodedWordsRE.exec(value.slice(i));</span>
<a href="#l4.389"></a><span id="l4.389" class="difflineplus">+      if (result !== null) {</span>
<a href="#l4.390"></a><span id="l4.390" class="difflineplus">+        // If we were in the middle of a prior token (i.e., something like</span>
<a href="#l4.391"></a><span id="l4.391" class="difflineplus">+        // foobar=?UTF-8?Q?blah?=), yield the previous segment as a token.</span>
<a href="#l4.392"></a><span id="l4.392" class="difflineplus">+        if (tokenStart !== undefined) {</span>
<a href="#l4.393"></a><span id="l4.393" class="difflineplus">+          yield new Token(value.slice(tokenStart, i));</span>
<a href="#l4.394"></a><span id="l4.394" class="difflineplus">+          tokenStart = undefined;</span>
<a href="#l4.395"></a><span id="l4.395" class="difflineplus">+        }</span>
<a href="#l4.396"></a><span id="l4.396" class="difflineplus">+</span>
<a href="#l4.397"></a><span id="l4.397" class="difflineplus">+        // Find out how much we need to decode...</span>
<a href="#l4.398"></a><span id="l4.398" class="difflineplus">+        let encWordsLen = result[0].length;</span>
<a href="#l4.399"></a><span id="l4.399" class="difflineplus">+        let string = decodeRFC2047Words(value.slice(i, i + encWordsLen),</span>
<a href="#l4.400"></a><span id="l4.400" class="difflineplus">+          &quot;UTF-8&quot;);</span>
<a href="#l4.401"></a><span id="l4.401" class="difflineplus">+        // Don't make a new Token variable, since we do not want to unescape the</span>
<a href="#l4.402"></a><span id="l4.402" class="difflineplus">+        // decoded string.</span>
<a href="#l4.403"></a><span id="l4.403" class="difflineplus">+        yield { toString: function() { return string; }};</span>
<a href="#l4.404"></a><span id="l4.404" class="difflineplus">+</span>
<a href="#l4.405"></a><span id="l4.405" class="difflineplus">+        // Skip everything we decoded. The -1 is because we don't want to</span>
<a href="#l4.406"></a><span id="l4.406" class="difflineplus">+        // include the starting character.</span>
<a href="#l4.407"></a><span id="l4.407" class="difflineplus">+        i += encWordsLen - 1;</span>
<a href="#l4.408"></a><span id="l4.408" class="difflineplus">+        continue;</span>
<a href="#l4.409"></a><span id="l4.409" class="difflineplus">+      }</span>
<a href="#l4.410"></a><span id="l4.410" class="difflineplus">+</span>
<a href="#l4.411"></a><span id="l4.411" class="difflineplus">+      // If we are here, then we failed to match the simple 2047 encoded-word</span>
<a href="#l4.412"></a><span id="l4.412" class="difflineplus">+      // regular expression, despite the fact that it matched the =? at the</span>
<a href="#l4.413"></a><span id="l4.413" class="difflineplus">+      // beginning. Fall through and treat the text as if we aren't trying to</span>
<a href="#l4.414"></a><span id="l4.414" class="difflineplus">+      // decode RFC 2047.</span>
<a href="#l4.415"></a><span id="l4.415" class="difflineplus">+    }</span>
<a href="#l4.416"></a><span id="l4.416" class="difflineplus">+</span>
<a href="#l4.417"></a><span id="l4.417" class="difflineplus">+    // If we reach this point, we're not inside of quoted strings, domain</span>
<a href="#l4.418"></a><span id="l4.418" class="difflineplus">+    // literals, or RFC 2047 encoded-words. This means that the characters we</span>
<a href="#l4.419"></a><span id="l4.419" class="difflineplus">+    // parse are potential delimiters (unless we're in comments, where</span>
<a href="#l4.420"></a><span id="l4.420" class="difflineplus">+    // everything starts to go really wonky). Several things could happen,</span>
<a href="#l4.421"></a><span id="l4.421" class="difflineplus">+    // depending on the kind of character we read and whether or not we were in</span>
<a href="#l4.422"></a><span id="l4.422" class="difflineplus">+    // the middle of a token. The three values here tell us what we could need</span>
<a href="#l4.423"></a><span id="l4.423" class="difflineplus">+    // to do at this point:</span>
<a href="#l4.424"></a><span id="l4.424" class="difflineplus">+    // tokenIsEnding: The current character is not able to be accumulated to an</span>
<a href="#l4.425"></a><span id="l4.425" class="difflineplus">+    // atom, so we need to flush the atom if there is one.</span>
<a href="#l4.426"></a><span id="l4.426" class="difflineplus">+    // tokenIsStarting: The current character could begin an atom (or</span>
<a href="#l4.427"></a><span id="l4.427" class="difflineplus">+    // anything that requires us to mark the starting point), so we need to save</span>
<a href="#l4.428"></a><span id="l4.428" class="difflineplus">+    // the location.</span>
<a href="#l4.429"></a><span id="l4.429" class="difflineplus">+    // isSpecial: The current character is a delimiter that needs to be output.</span>
<a href="#l4.430"></a><span id="l4.430" class="difflineplus">+    let tokenIsEnding = false, tokenIsStarting = false, isSpecial = false;</span>
<a href="#l4.431"></a><span id="l4.431" class="difflineplus">+    if (wsp.contains(ch)) {</span>
<a href="#l4.432"></a><span id="l4.432" class="difflineplus">+      // Whitespace ends current tokens, doesn't emit anything.</span>
<a href="#l4.433"></a><span id="l4.433" class="difflineplus">+      tokenIsEnding = true;</span>
<a href="#l4.434"></a><span id="l4.434" class="difflineplus">+    } else if (commentDepth == 0 &amp;&amp; delimiters.contains(ch)) {</span>
<a href="#l4.435"></a><span id="l4.435" class="difflineplus">+      // Delimiters end the current token, and need to be output. They do not</span>
<a href="#l4.436"></a><span id="l4.436" class="difflineplus">+      // apply within comments.</span>
<a href="#l4.437"></a><span id="l4.437" class="difflineplus">+      tokenIsEnding = true;</span>
<a href="#l4.438"></a><span id="l4.438" class="difflineplus">+      isSpecial = true;</span>
<a href="#l4.439"></a><span id="l4.439" class="difflineplus">+    } else if (opts.qstring &amp;&amp; ch == '&quot;') {</span>
<a href="#l4.440"></a><span id="l4.440" class="difflineplus">+      // Quoted strings end the last token and start a new one.</span>
<a href="#l4.441"></a><span id="l4.441" class="difflineplus">+      tokenIsEnding = true;</span>
<a href="#l4.442"></a><span id="l4.442" class="difflineplus">+      tokenIsStarting = true;</span>
<a href="#l4.443"></a><span id="l4.443" class="difflineplus">+      endQuote = ch;</span>
<a href="#l4.444"></a><span id="l4.444" class="difflineplus">+    } else if (opts.dliteral &amp;&amp; ch == '[') {</span>
<a href="#l4.445"></a><span id="l4.445" class="difflineplus">+      // Domain literals end the last token and start a new one.</span>
<a href="#l4.446"></a><span id="l4.446" class="difflineplus">+      tokenIsEnding = true;</span>
<a href="#l4.447"></a><span id="l4.447" class="difflineplus">+      tokenIsStarting = true;</span>
<a href="#l4.448"></a><span id="l4.448" class="difflineplus">+      endQuote = ']';</span>
<a href="#l4.449"></a><span id="l4.449" class="difflineplus">+    } else if (opts.comments &amp;&amp; ch == '(') {</span>
<a href="#l4.450"></a><span id="l4.450" class="difflineplus">+      // Comments are nested (oh joy). They also end the prior token, and need</span>
<a href="#l4.451"></a><span id="l4.451" class="difflineplus">+      // to be output if the consumer requests it.</span>
<a href="#l4.452"></a><span id="l4.452" class="difflineplus">+      commentDepth++;</span>
<a href="#l4.453"></a><span id="l4.453" class="difflineplus">+      tokenIsEnding = true;</span>
<a href="#l4.454"></a><span id="l4.454" class="difflineplus">+      isSpecial = true;</span>
<a href="#l4.455"></a><span id="l4.455" class="difflineplus">+    } else if (opts.comments &amp;&amp; ch == ')') {</span>
<a href="#l4.456"></a><span id="l4.456" class="difflineplus">+      // Comments are nested (oh joy). They also end the prior token, and need</span>
<a href="#l4.457"></a><span id="l4.457" class="difflineplus">+      // to be output if the consumer requests it.</span>
<a href="#l4.458"></a><span id="l4.458" class="difflineplus">+      if (commentDepth &gt; 0)</span>
<a href="#l4.459"></a><span id="l4.459" class="difflineplus">+        commentDepth--;</span>
<a href="#l4.460"></a><span id="l4.460" class="difflineplus">+      tokenIsEnding = true;</span>
<a href="#l4.461"></a><span id="l4.461" class="difflineplus">+      isSpecial = true;</span>
<a href="#l4.462"></a><span id="l4.462" class="difflineplus">+    } else {</span>
<a href="#l4.463"></a><span id="l4.463" class="difflineplus">+      // Not a delimiter, whitespace, comment, domain literal, or quoted string.</span>
<a href="#l4.464"></a><span id="l4.464" class="difflineplus">+      // Must be part of an atom then!</span>
<a href="#l4.465"></a><span id="l4.465" class="difflineplus">+      tokenIsStarting = true;</span>
<a href="#l4.466"></a><span id="l4.466" class="difflineplus">+    }</span>
<a href="#l4.467"></a><span id="l4.467" class="difflineplus">+</span>
<a href="#l4.468"></a><span id="l4.468" class="difflineplus">+    // If our analysis concluded that we closed an open token, and there is an</span>
<a href="#l4.469"></a><span id="l4.469" class="difflineplus">+    // open token, then yield that token.</span>
<a href="#l4.470"></a><span id="l4.470" class="difflineplus">+    if (tokenIsEnding &amp;&amp; tokenStart !== undefined) {</span>
<a href="#l4.471"></a><span id="l4.471" class="difflineplus">+      yield new Token(value.slice(tokenStart, i));</span>
<a href="#l4.472"></a><span id="l4.472" class="difflineplus">+      tokenStart = undefined;</span>
<a href="#l4.473"></a><span id="l4.473" class="difflineplus">+    }</span>
<a href="#l4.474"></a><span id="l4.474" class="difflineplus">+    // If we need to output a delimiter, do so.</span>
<a href="#l4.475"></a><span id="l4.475" class="difflineplus">+    if (isSpecial)</span>
<a href="#l4.476"></a><span id="l4.476" class="difflineplus">+      yield ch;</span>
<a href="#l4.477"></a><span id="l4.477" class="difflineplus">+    // If our analysis concluded that we could open a token, and no token is</span>
<a href="#l4.478"></a><span id="l4.478" class="difflineplus">+    // opened yet, then start the token.</span>
<a href="#l4.479"></a><span id="l4.479" class="difflineplus">+    if (tokenIsStarting &amp;&amp; tokenStart === undefined) {</span>
<a href="#l4.480"></a><span id="l4.480" class="difflineplus">+      tokenStart = i;</span>
<a href="#l4.481"></a><span id="l4.481" class="difflineplus">+    }</span>
<a href="#l4.482"></a><span id="l4.482" class="difflineplus">+  }</span>
<a href="#l4.483"></a><span id="l4.483" class="difflineplus">+</span>
<a href="#l4.484"></a><span id="l4.484" class="difflineplus">+  // That concludes the loop! If there is a currently open token, close that</span>
<a href="#l4.485"></a><span id="l4.485" class="difflineplus">+  // token now.</span>
<a href="#l4.486"></a><span id="l4.486" class="difflineplus">+  if (tokenStart !== undefined) {</span>
<a href="#l4.487"></a><span id="l4.487" class="difflineplus">+    // Error case: a partially-open quoted string is assumed to have a trailing</span>
<a href="#l4.488"></a><span id="l4.488" class="difflineplus">+    // &quot; character.</span>
<a href="#l4.489"></a><span id="l4.489" class="difflineplus">+    if (endQuote == '&quot;')</span>
<a href="#l4.490"></a><span id="l4.490" class="difflineplus">+      yield new Token(value.slice(tokenStart + 1));</span>
<a href="#l4.491"></a><span id="l4.491" class="difflineplus">+    else</span>
<a href="#l4.492"></a><span id="l4.492" class="difflineplus">+      yield new Token(value.slice(tokenStart));</span>
<a href="#l4.493"></a><span id="l4.493" class="difflineplus">+  }</span>
<a href="#l4.494"></a><span id="l4.494" class="difflineplus">+}</span>
<a href="#l4.495"></a><span id="l4.495" class="difflineplus">+</span>
<a href="#l4.496"></a><span id="l4.496" class="difflineplus">+/**</span>
<a href="#l4.497"></a><span id="l4.497" class="difflineplus">+ * Convert a header value into UTF-16 strings by attempting to decode as UTF-8</span>
<a href="#l4.498"></a><span id="l4.498" class="difflineplus">+ * or another legacy charset. If the header is valid UTF-8, it will be decoded</span>
<a href="#l4.499"></a><span id="l4.499" class="difflineplus">+ * as UTF-8; if it is not, the fallbackCharset will be attempted instead.</span>
<a href="#l4.500"></a><span id="l4.500" class="difflineplus">+ *</span>
<a href="#l4.501"></a><span id="l4.501" class="difflineplus">+ * @param {String} headerValue       The header (as a binary string) to attempt</span>
<a href="#l4.502"></a><span id="l4.502" class="difflineplus">+ *                                   to convert to UTF-16.</span>
<a href="#l4.503"></a><span id="l4.503" class="difflineplus">+ * @param {String} [fallbackCharset] The optional charset to try if UTF-8</span>
<a href="#l4.504"></a><span id="l4.504" class="difflineplus">+ *                                   doesn't work.</span>
<a href="#l4.505"></a><span id="l4.505" class="difflineplus">+ * @returns {String} The UTF-16 representation of the string above.</span>
<a href="#l4.506"></a><span id="l4.506" class="difflineplus">+ */</span>
<a href="#l4.507"></a><span id="l4.507" class="difflineplus">+function convert8BitHeader(headerValue, fallbackCharset) {</span>
<a href="#l4.508"></a><span id="l4.508" class="difflineplus">+  // Only attempt to convert the headerValue if it contains non-ASCII</span>
<a href="#l4.509"></a><span id="l4.509" class="difflineplus">+  // characters.</span>
<a href="#l4.510"></a><span id="l4.510" class="difflineplus">+  if (/[\x80-\xff]/.exec(headerValue)) {</span>
<a href="#l4.511"></a><span id="l4.511" class="difflineplus">+    // First convert the value to a typed-array for TextDecoder.</span>
<a href="#l4.512"></a><span id="l4.512" class="difflineplus">+    let typedarray = mimeutils.stringToTypedArray(headerValue);</span>
<a href="#l4.513"></a><span id="l4.513" class="difflineplus">+</span>
<a href="#l4.514"></a><span id="l4.514" class="difflineplus">+    // Don't try UTF-8 as fallback (redundant), and don't try UTF-16 or UTF-32</span>
<a href="#l4.515"></a><span id="l4.515" class="difflineplus">+    // either, since they radically change header interpretation.</span>
<a href="#l4.516"></a><span id="l4.516" class="difflineplus">+    // If we have a fallback charset, we want to know if decoding will fail;</span>
<a href="#l4.517"></a><span id="l4.517" class="difflineplus">+    // otherwise, we want to replace with substitution chars.</span>
<a href="#l4.518"></a><span id="l4.518" class="difflineplus">+    let hasFallback = fallbackCharset &amp;&amp;</span>
<a href="#l4.519"></a><span id="l4.519" class="difflineplus">+                      !fallbackCharset.toLowerCase().startsWith(&quot;utf&quot;);</span>
<a href="#l4.520"></a><span id="l4.520" class="difflineplus">+    let utf8Decoder = new TextDecoder(&quot;utf-8&quot;, {fatal: hasFallback});</span>
<a href="#l4.521"></a><span id="l4.521" class="difflineplus">+    try {</span>
<a href="#l4.522"></a><span id="l4.522" class="difflineplus">+      headerValue = utf8Decoder.decode(typedarray);</span>
<a href="#l4.523"></a><span id="l4.523" class="difflineplus">+    } catch (e) {</span>
<a href="#l4.524"></a><span id="l4.524" class="difflineplus">+      // Failed, try the fallback</span>
<a href="#l4.525"></a><span id="l4.525" class="difflineplus">+      let decoder = new TextDecoder(fallbackCharset, {fatal: false});</span>
<a href="#l4.526"></a><span id="l4.526" class="difflineplus">+      headerValue = decoder.decode(typedarray);</span>
<a href="#l4.527"></a><span id="l4.527" class="difflineplus">+    }</span>
<a href="#l4.528"></a><span id="l4.528" class="difflineplus">+  }</span>
<a href="#l4.529"></a><span id="l4.529" class="difflineplus">+  return headerValue;</span>
<a href="#l4.530"></a><span id="l4.530" class="difflineplus">+}</span>
<a href="#l4.531"></a><span id="l4.531" class="difflineplus">+</span>
<a href="#l4.532"></a><span id="l4.532" class="difflineplus">+/**</span>
<a href="#l4.533"></a><span id="l4.533" class="difflineplus">+ * Decodes all RFC 2047 encoded-words in the input string. The string does not</span>
<a href="#l4.534"></a><span id="l4.534" class="difflineplus">+ * necessarily have to contain any such words. This is useful, for example, for</span>
<a href="#l4.535"></a><span id="l4.535" class="difflineplus">+ * parsing unstructured headers.</span>
<a href="#l4.536"></a><span id="l4.536" class="difflineplus">+ *</span>
<a href="#l4.537"></a><span id="l4.537" class="difflineplus">+ * @param {String} headerValue The header which may contain RFC 2047 encoded-</span>
<a href="#l4.538"></a><span id="l4.538" class="difflineplus">+ *                             words.</span>
<a href="#l4.539"></a><span id="l4.539" class="difflineplus">+ * @returns {String} A full UTF-16 string with all encoded words expanded.</span>
<a href="#l4.540"></a><span id="l4.540" class="difflineplus">+ */</span>
<a href="#l4.541"></a><span id="l4.541" class="difflineplus">+function decodeRFC2047Words(headerValue) {</span>
<a href="#l4.542"></a><span id="l4.542" class="difflineplus">+  // Unfortunately, many implementations of RFC 2047 encoding are actually wrong</span>
<a href="#l4.543"></a><span id="l4.543" class="difflineplus">+  // in that they split over-long encoded words without regard for whether or</span>
<a href="#l4.544"></a><span id="l4.544" class="difflineplus">+  // not the split point is in the middle of a multibyte character. Therefore,</span>
<a href="#l4.545"></a><span id="l4.545" class="difflineplus">+  // we need to be able to handle these situations gracefully. This is done by</span>
<a href="#l4.546"></a><span id="l4.546" class="difflineplus">+  // using the decoder in streaming mode so long as the next token is another</span>
<a href="#l4.547"></a><span id="l4.547" class="difflineplus">+  // 2047 token with the same charset.</span>
<a href="#l4.548"></a><span id="l4.548" class="difflineplus">+  let lastCharset = '', currentDecoder = undefined;</span>
<a href="#l4.549"></a><span id="l4.549" class="difflineplus">+</span>
<a href="#l4.550"></a><span id="l4.550" class="difflineplus">+  /**</span>
<a href="#l4.551"></a><span id="l4.551" class="difflineplus">+   * Decode a single RFC 2047 token. This function is inline so that we can</span>
<a href="#l4.552"></a><span id="l4.552" class="difflineplus">+   * easily close over the lastCharset/currentDecoder variables, needed for</span>
<a href="#l4.553"></a><span id="l4.553" class="difflineplus">+   * handling bad RFC 2047 productions properly.</span>
<a href="#l4.554"></a><span id="l4.554" class="difflineplus">+   */</span>
<a href="#l4.555"></a><span id="l4.555" class="difflineplus">+  function decode2047Token(token) {</span>
<a href="#l4.556"></a><span id="l4.556" class="difflineplus">+    let tokenParts = token.split(&quot;?&quot;);</span>
<a href="#l4.557"></a><span id="l4.557" class="difflineplus">+</span>
<a href="#l4.558"></a><span id="l4.558" class="difflineplus">+    // If it's obviously not a valid token, return false immediately.</span>
<a href="#l4.559"></a><span id="l4.559" class="difflineplus">+    if (tokenParts.length != 5 || tokenParts[4] != '=')</span>
<a href="#l4.560"></a><span id="l4.560" class="difflineplus">+      return false;</span>
<a href="#l4.561"></a><span id="l4.561" class="difflineplus">+</span>
<a href="#l4.562"></a><span id="l4.562" class="difflineplus">+    // The charset parameter is defined in RFC 2231 to be charset or</span>
<a href="#l4.563"></a><span id="l4.563" class="difflineplus">+    // charset*language. We only care about the charset here, so ignore any</span>
<a href="#l4.564"></a><span id="l4.564" class="difflineplus">+    // language parameter that gets passed in.</span>
<a href="#l4.565"></a><span id="l4.565" class="difflineplus">+    let charset = tokenParts[1].split('*', 1)[0];</span>
<a href="#l4.566"></a><span id="l4.566" class="difflineplus">+    let encoding = tokenParts[2], text = tokenParts[3];</span>
<a href="#l4.567"></a><span id="l4.567" class="difflineplus">+</span>
<a href="#l4.568"></a><span id="l4.568" class="difflineplus">+    let buffer;</span>
<a href="#l4.569"></a><span id="l4.569" class="difflineplus">+    if (encoding == 'B' || encoding == 'b') {</span>
<a href="#l4.570"></a><span id="l4.570" class="difflineplus">+      // Decode base64. If there's any non-base64 data, treat the string as</span>
<a href="#l4.571"></a><span id="l4.571" class="difflineplus">+      // an illegal token.</span>
<a href="#l4.572"></a><span id="l4.572" class="difflineplus">+      if (/[^A-Za-z0-9+\/=]/.exec(text))</span>
<a href="#l4.573"></a><span id="l4.573" class="difflineplus">+        return false;</span>
<a href="#l4.574"></a><span id="l4.574" class="difflineplus">+</span>
<a href="#l4.575"></a><span id="l4.575" class="difflineplus">+      // Base64 strings must be a length of multiple 4, but it seems that some</span>
<a href="#l4.576"></a><span id="l4.576" class="difflineplus">+      // mailers accidentally insert one too many `=' chars. Gracefully handle</span>
<a href="#l4.577"></a><span id="l4.577" class="difflineplus">+      // this case; see bug 227290 for more information.</span>
<a href="#l4.578"></a><span id="l4.578" class="difflineplus">+      if (text.length % 4 == 1 &amp;&amp; text.charAt(text.length - 1) == '=')</span>
<a href="#l4.579"></a><span id="l4.579" class="difflineplus">+        text = text.slice(0, -1);</span>
<a href="#l4.580"></a><span id="l4.580" class="difflineplus">+</span>
<a href="#l4.581"></a><span id="l4.581" class="difflineplus">+      // Decode the string</span>
<a href="#l4.582"></a><span id="l4.582" class="difflineplus">+      buffer = mimeutils.decode_base64(text, false)[0];</span>
<a href="#l4.583"></a><span id="l4.583" class="difflineplus">+    } else if (encoding == 'Q' || encoding == 'q') {</span>
<a href="#l4.584"></a><span id="l4.584" class="difflineplus">+      // Q encoding here looks a lot like quoted-printable text. The differences</span>
<a href="#l4.585"></a><span id="l4.585" class="difflineplus">+      // between quoted-printable and this are that quoted-printable allows you</span>
<a href="#l4.586"></a><span id="l4.586" class="difflineplus">+      // to quote newlines (this doesn't), while this replaces spaces with _.</span>
<a href="#l4.587"></a><span id="l4.587" class="difflineplus">+      // We can reuse the decode_qp code here, since newlines are already</span>
<a href="#l4.588"></a><span id="l4.588" class="difflineplus">+      // stripped from the header. There is one edge case that could trigger a</span>
<a href="#l4.589"></a><span id="l4.589" class="difflineplus">+      // false positive, namely when you have a single = or an = followed by</span>
<a href="#l4.590"></a><span id="l4.590" class="difflineplus">+      // whitespace at the end of the string. Such an input string is already</span>
<a href="#l4.591"></a><span id="l4.591" class="difflineplus">+      // malformed to begin with, so stripping the = and following input in that</span>
<a href="#l4.592"></a><span id="l4.592" class="difflineplus">+      // case should not be an important loss.</span>
<a href="#l4.593"></a><span id="l4.593" class="difflineplus">+      buffer = mimeutils.decode_qp(text.replace('_', ' ', 'g'), false)[0];</span>
<a href="#l4.594"></a><span id="l4.594" class="difflineplus">+    } else {</span>
<a href="#l4.595"></a><span id="l4.595" class="difflineplus">+      return false;</span>
<a href="#l4.596"></a><span id="l4.596" class="difflineplus">+    }</span>
<a href="#l4.597"></a><span id="l4.597" class="difflineplus">+</span>
<a href="#l4.598"></a><span id="l4.598" class="difflineplus">+    // Make the buffer be a typed array for what follows</span>
<a href="#l4.599"></a><span id="l4.599" class="difflineplus">+    buffer = mimeutils.stringToTypedArray(buffer);</span>
<a href="#l4.600"></a><span id="l4.600" class="difflineplus">+</span>
<a href="#l4.601"></a><span id="l4.601" class="difflineplus">+    // If we cannot reuse the last decoder, flush out whatever remains.</span>
<a href="#l4.602"></a><span id="l4.602" class="difflineplus">+    var output = '';</span>
<a href="#l4.603"></a><span id="l4.603" class="difflineplus">+    if (charset != lastCharset &amp;&amp; currentDecoder) {</span>
<a href="#l4.604"></a><span id="l4.604" class="difflineplus">+      output += currentDecoder.decode();</span>
<a href="#l4.605"></a><span id="l4.605" class="difflineplus">+      currentDecoder = null;</span>
<a href="#l4.606"></a><span id="l4.606" class="difflineplus">+    }</span>
<a href="#l4.607"></a><span id="l4.607" class="difflineplus">+</span>
<a href="#l4.608"></a><span id="l4.608" class="difflineplus">+    // Initialize the decoder for this token.</span>
<a href="#l4.609"></a><span id="l4.609" class="difflineplus">+    lastCharset = charset;</span>
<a href="#l4.610"></a><span id="l4.610" class="difflineplus">+    if (!currentDecoder) {</span>
<a href="#l4.611"></a><span id="l4.611" class="difflineplus">+      try {</span>
<a href="#l4.612"></a><span id="l4.612" class="difflineplus">+        currentDecoder = new TextDecoder(charset, {fatal: false});</span>
<a href="#l4.613"></a><span id="l4.613" class="difflineplus">+      } catch (e) {</span>
<a href="#l4.614"></a><span id="l4.614" class="difflineplus">+        // We don't recognize the charset, so give up.</span>
<a href="#l4.615"></a><span id="l4.615" class="difflineplus">+        return false;</span>
<a href="#l4.616"></a><span id="l4.616" class="difflineplus">+      }</span>
<a href="#l4.617"></a><span id="l4.617" class="difflineplus">+    }</span>
<a href="#l4.618"></a><span id="l4.618" class="difflineplus">+</span>
<a href="#l4.619"></a><span id="l4.619" class="difflineplus">+    // Convert this token with the buffer. Note the stream parameter--although</span>
<a href="#l4.620"></a><span id="l4.620" class="difflineplus">+    // RFC 2047 tokens aren't supposed to break in the middle of a multibyte</span>
<a href="#l4.621"></a><span id="l4.621" class="difflineplus">+    // character, a lot of software messes up and does so because it's hard not</span>
<a href="#l4.622"></a><span id="l4.622" class="difflineplus">+    // to (see headeremitter.js for exactly how hard!).</span>
<a href="#l4.623"></a><span id="l4.623" class="difflineplus">+    return output + currentDecoder.decode(buffer, {stream: true});</span>
<a href="#l4.624"></a><span id="l4.624" class="difflineplus">+  }</span>
<a href="#l4.625"></a><span id="l4.625" class="difflineplus">+</span>
<a href="#l4.626"></a><span id="l4.626" class="difflineplus">+  // The first step of decoding is to split the string into RFC 2047 and</span>
<a href="#l4.627"></a><span id="l4.627" class="difflineplus">+  // non-RFC 2047 tokens. RFC 2047 tokens look like the following:</span>
<a href="#l4.628"></a><span id="l4.628" class="difflineplus">+  // =?charset?c?text?=, where c is one of B, b, Q, and q. The split regex does</span>
<a href="#l4.629"></a><span id="l4.629" class="difflineplus">+  // some amount of semantic checking, so that malformed RFC 2047 tokens will</span>
<a href="#l4.630"></a><span id="l4.630" class="difflineplus">+  // get ignored earlier.</span>
<a href="#l4.631"></a><span id="l4.631" class="difflineplus">+  let components = headerValue.split(/(=\?[^?]*\?[BQbq]\?[^?]*\?=)/);</span>
<a href="#l4.632"></a><span id="l4.632" class="difflineplus">+  for (let i = 0; i &lt; components.length; i++) {</span>
<a href="#l4.633"></a><span id="l4.633" class="difflineplus">+    if (components[i].substring(0, 2) == &quot;=?&quot;) {</span>
<a href="#l4.634"></a><span id="l4.634" class="difflineplus">+      let decoded = decode2047Token(components[i]);</span>
<a href="#l4.635"></a><span id="l4.635" class="difflineplus">+      if (decoded !== false) {</span>
<a href="#l4.636"></a><span id="l4.636" class="difflineplus">+        // If 2047 decoding succeeded for this bit, rewrite the original value</span>
<a href="#l4.637"></a><span id="l4.637" class="difflineplus">+        // with the proper decoding.</span>
<a href="#l4.638"></a><span id="l4.638" class="difflineplus">+        components[i] = decoded;</span>
<a href="#l4.639"></a><span id="l4.639" class="difflineplus">+</span>
<a href="#l4.640"></a><span id="l4.640" class="difflineplus">+        // We're done processing, so continue to the next link.</span>
<a href="#l4.641"></a><span id="l4.641" class="difflineplus">+        continue;</span>
<a href="#l4.642"></a><span id="l4.642" class="difflineplus">+      }</span>
<a href="#l4.643"></a><span id="l4.643" class="difflineplus">+    } else if (/^[ \t\r\n]*$/.exec(components[i])) {</span>
<a href="#l4.644"></a><span id="l4.644" class="difflineplus">+      // Whitespace-only tokens get squashed into nothing, so 2047 tokens will</span>
<a href="#l4.645"></a><span id="l4.645" class="difflineplus">+      // be concatenated together.</span>
<a href="#l4.646"></a><span id="l4.646" class="difflineplus">+      components[i] = '';</span>
<a href="#l4.647"></a><span id="l4.647" class="difflineplus">+      continue;</span>
<a href="#l4.648"></a><span id="l4.648" class="difflineplus">+    }</span>
<a href="#l4.649"></a><span id="l4.649" class="difflineplus">+</span>
<a href="#l4.650"></a><span id="l4.650" class="difflineplus">+    // If there was stuff left over from decoding the last 2047 token, flush it</span>
<a href="#l4.651"></a><span id="l4.651" class="difflineplus">+    // out.</span>
<a href="#l4.652"></a><span id="l4.652" class="difflineplus">+    lastCharset = '';</span>
<a href="#l4.653"></a><span id="l4.653" class="difflineplus">+    if (currentDecoder) {</span>
<a href="#l4.654"></a><span id="l4.654" class="difflineplus">+      components[i] = currentDecoder.decode() + components[i];</span>
<a href="#l4.655"></a><span id="l4.655" class="difflineplus">+      currentDecoder = null;</span>
<a href="#l4.656"></a><span id="l4.656" class="difflineplus">+    }</span>
<a href="#l4.657"></a><span id="l4.657" class="difflineplus">+  }</span>
<a href="#l4.658"></a><span id="l4.658" class="difflineplus">+</span>
<a href="#l4.659"></a><span id="l4.659" class="difflineplus">+  // After the for loop, we'll have a set of decoded strings. Concatenate them</span>
<a href="#l4.660"></a><span id="l4.660" class="difflineplus">+  // together to make the return value.</span>
<a href="#l4.661"></a><span id="l4.661" class="difflineplus">+  return components.join('');</span>
<a href="#l4.662"></a><span id="l4.662" class="difflineplus">+}</span>
<a href="#l4.663"></a><span id="l4.663" class="difflineplus">+</span>
<a href="#l4.664"></a><span id="l4.664" class="difflineplus">+///////////////////////////////</span>
<a href="#l4.665"></a><span id="l4.665" class="difflineplus">+// Structured field decoders //</span>
<a href="#l4.666"></a><span id="l4.666" class="difflineplus">+///////////////////////////////</span>
<a href="#l4.667"></a><span id="l4.667" class="difflineplus">+</span>
<a href="#l4.668"></a><span id="l4.668" class="difflineplus">+/**</span>
<a href="#l4.669"></a><span id="l4.669" class="difflineplus">+ * Extract a list of addresses from a header which matches the RFC 5322</span>
<a href="#l4.670"></a><span id="l4.670" class="difflineplus">+ * address-list production, possibly doing RFC 2047 decoding along the way.</span>
<a href="#l4.671"></a><span id="l4.671" class="difflineplus">+ *</span>
<a href="#l4.672"></a><span id="l4.672" class="difflineplus">+ * The output of this method is an array of elements corresponding to the</span>
<a href="#l4.673"></a><span id="l4.673" class="difflineplus">+ * addresses and the groups in the input header. An address is represented by</span>
<a href="#l4.674"></a><span id="l4.674" class="difflineplus">+ * an object of the form:</span>
<a href="#l4.675"></a><span id="l4.675" class="difflineplus">+ * {</span>
<a href="#l4.676"></a><span id="l4.676" class="difflineplus">+ *   name: The display name of the address</span>
<a href="#l4.677"></a><span id="l4.677" class="difflineplus">+ *   email: The address of the object</span>
<a href="#l4.678"></a><span id="l4.678" class="difflineplus">+ * }</span>
<a href="#l4.679"></a><span id="l4.679" class="difflineplus">+ * while a group is represented by an object of the form:</span>
<a href="#l4.680"></a><span id="l4.680" class="difflineplus">+ * {</span>
<a href="#l4.681"></a><span id="l4.681" class="difflineplus">+ *   name: The display name of the group</span>
<a href="#l4.682"></a><span id="l4.682" class="difflineplus">+ *   group: An array of address object for members in the group.</span>
<a href="#l4.683"></a><span id="l4.683" class="difflineplus">+ * }</span>
<a href="#l4.684"></a><span id="l4.684" class="difflineplus">+ *</span>
<a href="#l4.685"></a><span id="l4.685" class="difflineplus">+ * @param {String} header     The MIME header text to be parsed</span>
<a href="#l4.686"></a><span id="l4.686" class="difflineplus">+ * @param {Boolean} doRFC2047 If true, decode RFC 2047 parameters found in the</span>
<a href="#l4.687"></a><span id="l4.687" class="difflineplus">+ *                            header.</span>
<a href="#l4.688"></a><span id="l4.688" class="difflineplus">+ * @returns {(Address|Group)[]} An array of the addresses found in the header,</span>
<a href="#l4.689"></a><span id="l4.689" class="difflineplus">+ *                              where each element is of the form mentioned</span>
<a href="#l4.690"></a><span id="l4.690" class="difflineplus">+ *                              above.</span>
<a href="#l4.691"></a><span id="l4.691" class="difflineplus">+ */</span>
<a href="#l4.692"></a><span id="l4.692" class="difflineplus">+function parseAddressingHeader(header, doRFC2047) {</span>
<a href="#l4.693"></a><span id="l4.693" class="difflineplus">+  // Default to true</span>
<a href="#l4.694"></a><span id="l4.694" class="difflineplus">+  if (doRFC2047 === undefined)</span>
<a href="#l4.695"></a><span id="l4.695" class="difflineplus">+    doRFC2047 = true;</span>
<a href="#l4.696"></a><span id="l4.696" class="difflineplus">+</span>
<a href="#l4.697"></a><span id="l4.697" class="difflineplus">+  // The final (top-level) results list to append to.</span>
<a href="#l4.698"></a><span id="l4.698" class="difflineplus">+  let results = [];</span>
<a href="#l4.699"></a><span id="l4.699" class="difflineplus">+  // Temporary results</span>
<a href="#l4.700"></a><span id="l4.700" class="difflineplus">+  let addrlist = [];</span>
<a href="#l4.701"></a><span id="l4.701" class="difflineplus">+</span>
<a href="#l4.702"></a><span id="l4.702" class="difflineplus">+  // Build up all of the values</span>
<a href="#l4.703"></a><span id="l4.703" class="difflineplus">+  var name = '', groupName = '', address = '';</span>
<a href="#l4.704"></a><span id="l4.704" class="difflineplus">+  // Indicators of current state</span>
<a href="#l4.705"></a><span id="l4.705" class="difflineplus">+  var inAngle = false, needsSpace = false;</span>
<a href="#l4.706"></a><span id="l4.706" class="difflineplus">+  // Main parsing loop</span>
<a href="#l4.707"></a><span id="l4.707" class="difflineplus">+  for (let token of getHeaderTokens(header, &quot;:,;&lt;&gt;@&quot;,</span>
<a href="#l4.708"></a><span id="l4.708" class="difflineplus">+        {qstring: true, comments: true, dliteral: true, rfc2047: doRFC2047})) {</span>
<a href="#l4.709"></a><span id="l4.709" class="difflineplus">+    if (token === ':') {</span>
<a href="#l4.710"></a><span id="l4.710" class="difflineplus">+      groupName = name;</span>
<a href="#l4.711"></a><span id="l4.711" class="difflineplus">+      name = '';</span>
<a href="#l4.712"></a><span id="l4.712" class="difflineplus">+      // If we had prior email address results, commit them to the top-level.</span>
<a href="#l4.713"></a><span id="l4.713" class="difflineplus">+      if (addrlist.length &gt; 0)</span>
<a href="#l4.714"></a><span id="l4.714" class="difflineplus">+        results = results.concat(addrlist);</span>
<a href="#l4.715"></a><span id="l4.715" class="difflineplus">+      addrlist = [];</span>
<a href="#l4.716"></a><span id="l4.716" class="difflineplus">+    } else if (token === '&lt;') {</span>
<a href="#l4.717"></a><span id="l4.717" class="difflineplus">+      inAngle = true;</span>
<a href="#l4.718"></a><span id="l4.718" class="difflineplus">+    } else if (token === '&gt;') {</span>
<a href="#l4.719"></a><span id="l4.719" class="difflineplus">+      inAngle = false;</span>
<a href="#l4.720"></a><span id="l4.720" class="difflineplus">+    } else if (token === '@') {</span>
<a href="#l4.721"></a><span id="l4.721" class="difflineplus">+      // An @ means we see an email address. If we're not within &lt;&gt; brackets,</span>
<a href="#l4.722"></a><span id="l4.722" class="difflineplus">+      // then we just parsed an email address instead of a display name. Empty</span>
<a href="#l4.723"></a><span id="l4.723" class="difflineplus">+      // out the display name for the current production.</span>
<a href="#l4.724"></a><span id="l4.724" class="difflineplus">+      if (!inAngle) {</span>
<a href="#l4.725"></a><span id="l4.725" class="difflineplus">+        address = name;</span>
<a href="#l4.726"></a><span id="l4.726" class="difflineplus">+        name = '';</span>
<a href="#l4.727"></a><span id="l4.727" class="difflineplus">+      }</span>
<a href="#l4.728"></a><span id="l4.728" class="difflineplus">+      // Keep the local-part quoted if it needs to be.</span>
<a href="#l4.729"></a><span id="l4.729" class="difflineplus">+      if (/[ !()&lt;&gt;\[\]:;@\\,&quot;]/.exec(address) !== null)</span>
<a href="#l4.730"></a><span id="l4.730" class="difflineplus">+        address = '&quot;' + address.replace(/([\\&quot;])/g, &quot;\\$1&quot;) + '&quot;';</span>
<a href="#l4.731"></a><span id="l4.731" class="difflineplus">+      address += '@';</span>
<a href="#l4.732"></a><span id="l4.732" class="difflineplus">+    } else if (token === ',') {</span>
<a href="#l4.733"></a><span id="l4.733" class="difflineplus">+      // A comma ends the current name. If we have something that's kind of a</span>
<a href="#l4.734"></a><span id="l4.734" class="difflineplus">+      // name, add it to the result list. If we don't, then our input looks like</span>
<a href="#l4.735"></a><span id="l4.735" class="difflineplus">+      // To: , , -&gt; don't bother adding an empty entry.</span>
<a href="#l4.736"></a><span id="l4.736" class="difflineplus">+      if (name !== '' || address !== '')</span>
<a href="#l4.737"></a><span id="l4.737" class="difflineplus">+        addrlist.push({</span>
<a href="#l4.738"></a><span id="l4.738" class="difflineplus">+          name: name,</span>
<a href="#l4.739"></a><span id="l4.739" class="difflineplus">+          email: address</span>
<a href="#l4.740"></a><span id="l4.740" class="difflineplus">+        });</span>
<a href="#l4.741"></a><span id="l4.741" class="difflineplus">+      name = address = '';</span>
<a href="#l4.742"></a><span id="l4.742" class="difflineplus">+    } else if (token === ';') {</span>
<a href="#l4.743"></a><span id="l4.743" class="difflineplus">+      // Add pending name to the list</span>
<a href="#l4.744"></a><span id="l4.744" class="difflineplus">+      if (name !== '' || address !== '')</span>
<a href="#l4.745"></a><span id="l4.745" class="difflineplus">+        addrlist.push({name: name, email: address});</span>
<a href="#l4.746"></a><span id="l4.746" class="difflineplus">+</span>
<a href="#l4.747"></a><span id="l4.747" class="difflineplus">+      // If no group name was found, treat the ';' as a ','. In any case, we</span>
<a href="#l4.748"></a><span id="l4.748" class="difflineplus">+      // need to copy the results of addrlist into either a new group object or</span>
<a href="#l4.749"></a><span id="l4.749" class="difflineplus">+      // the main list.</span>
<a href="#l4.750"></a><span id="l4.750" class="difflineplus">+      if (groupName === '') {</span>
<a href="#l4.751"></a><span id="l4.751" class="difflineplus">+        results = results.concat(addrlist);</span>
<a href="#l4.752"></a><span id="l4.752" class="difflineplus">+      } else {</span>
<a href="#l4.753"></a><span id="l4.753" class="difflineplus">+        results.push({</span>
<a href="#l4.754"></a><span id="l4.754" class="difflineplus">+          name: groupName,</span>
<a href="#l4.755"></a><span id="l4.755" class="difflineplus">+          group: addrlist</span>
<a href="#l4.756"></a><span id="l4.756" class="difflineplus">+        });</span>
<a href="#l4.757"></a><span id="l4.757" class="difflineplus">+      }</span>
<a href="#l4.758"></a><span id="l4.758" class="difflineplus">+      // ... and reset every other variable.</span>
<a href="#l4.759"></a><span id="l4.759" class="difflineplus">+      addrlist = [];</span>
<a href="#l4.760"></a><span id="l4.760" class="difflineplus">+      groupName = name = address = '';</span>
<a href="#l4.761"></a><span id="l4.761" class="difflineplus">+    } else {</span>
<a href="#l4.762"></a><span id="l4.762" class="difflineplus">+      // This is either the comment delimiters, a quoted-string, or some span of</span>
<a href="#l4.763"></a><span id="l4.763" class="difflineplus">+      // dots and atoms.</span>
<a href="#l4.764"></a><span id="l4.764" class="difflineplus">+</span>
<a href="#l4.765"></a><span id="l4.765" class="difflineplus">+      // Ignore the needs space if we're a &quot;close&quot; delimiter token.</span>
<a href="#l4.766"></a><span id="l4.766" class="difflineplus">+      if (needsSpace &amp;&amp; token !== ')' &amp;&amp; token.toString()[0] != '.')</span>
<a href="#l4.767"></a><span id="l4.767" class="difflineplus">+        token = ' ' + token;</span>
<a href="#l4.768"></a><span id="l4.768" class="difflineplus">+</span>
<a href="#l4.769"></a><span id="l4.769" class="difflineplus">+      // Which field do we add this data to?</span>
<a href="#l4.770"></a><span id="l4.770" class="difflineplus">+      if (inAngle || address !== '')</span>
<a href="#l4.771"></a><span id="l4.771" class="difflineplus">+        address += token;</span>
<a href="#l4.772"></a><span id="l4.772" class="difflineplus">+      else</span>
<a href="#l4.773"></a><span id="l4.773" class="difflineplus">+        name += token;</span>
<a href="#l4.774"></a><span id="l4.774" class="difflineplus">+</span>
<a href="#l4.775"></a><span id="l4.775" class="difflineplus">+      // We need space for the next token if we aren't some kind of comment or</span>
<a href="#l4.776"></a><span id="l4.776" class="difflineplus">+      // . delimiter.</span>
<a href="#l4.777"></a><span id="l4.777" class="difflineplus">+      needsSpace = token !== '(' &amp;&amp; token !== ' (' &amp;&amp; token.toString()[0] != '.';</span>
<a href="#l4.778"></a><span id="l4.778" class="difflineplus">+      // The fall-through case after this resets needsSpace to false, and we</span>
<a href="#l4.779"></a><span id="l4.779" class="difflineplus">+      // don't want that!</span>
<a href="#l4.780"></a><span id="l4.780" class="difflineplus">+      continue;</span>
<a href="#l4.781"></a><span id="l4.781" class="difflineplus">+    }</span>
<a href="#l4.782"></a><span id="l4.782" class="difflineplus">+</span>
<a href="#l4.783"></a><span id="l4.783" class="difflineplus">+    // If we just parsed a delimiter, we don't need any space for the next</span>
<a href="#l4.784"></a><span id="l4.784" class="difflineplus">+    // token.</span>
<a href="#l4.785"></a><span id="l4.785" class="difflineplus">+    needsSpace = false;</span>
<a href="#l4.786"></a><span id="l4.786" class="difflineplus">+  }</span>
<a href="#l4.787"></a><span id="l4.787" class="difflineplus">+</span>
<a href="#l4.788"></a><span id="l4.788" class="difflineplus">+  // If we're missing the final ';' of a group, assume it was present. Also, add</span>
<a href="#l4.789"></a><span id="l4.789" class="difflineplus">+  // in the details of any email/address that we previously saw.</span>
<a href="#l4.790"></a><span id="l4.790" class="difflineplus">+  if (name !== '' || address !== '')</span>
<a href="#l4.791"></a><span id="l4.791" class="difflineplus">+    addrlist.push({name: name, email: address});</span>
<a href="#l4.792"></a><span id="l4.792" class="difflineplus">+  if (groupName !== '') {</span>
<a href="#l4.793"></a><span id="l4.793" class="difflineplus">+    results.push({name: groupName, group: addrlist});</span>
<a href="#l4.794"></a><span id="l4.794" class="difflineplus">+    addrlist = [];</span>
<a href="#l4.795"></a><span id="l4.795" class="difflineplus">+  }</span>
<a href="#l4.796"></a><span id="l4.796" class="difflineplus">+</span>
<a href="#l4.797"></a><span id="l4.797" class="difflineplus">+  // Add the current address list build-up to the list of addresses, and return</span>
<a href="#l4.798"></a><span id="l4.798" class="difflineplus">+  // the whole array to the caller.</span>
<a href="#l4.799"></a><span id="l4.799" class="difflineplus">+  return results.concat(addrlist);</span>
<a href="#l4.800"></a><span id="l4.800" class="difflineplus">+}</span>
<a href="#l4.801"></a><span id="l4.801" class="difflineplus">+</span>
<a href="#l4.802"></a><span id="l4.802" class="difflineplus">+/**</span>
<a href="#l4.803"></a><span id="l4.803" class="difflineplus">+ * Extract parameters from a header which is a series of ;-separated</span>
<a href="#l4.804"></a><span id="l4.804" class="difflineplus">+ * attribute=value tokens.</span>
<a href="#l4.805"></a><span id="l4.805" class="difflineplus">+ *</span>
<a href="#l4.806"></a><span id="l4.806" class="difflineplus">+ * @param {String} headerValue The MIME header value to parse.</span>
<a href="#l4.807"></a><span id="l4.807" class="difflineplus">+ * @param {Boolean} doRFC2047  If true, decode RFC 2047 encoded-words.</span>
<a href="#l4.808"></a><span id="l4.808" class="difflineplus">+ * @param {Boolean} doRFC2231  If true, decode RFC 2231 encoded parameters.</span>
<a href="#l4.809"></a><span id="l4.809" class="difflineplus">+ * @return {Map(String -&gt; String)} A map of parameter names to parameter values.</span>
<a href="#l4.810"></a><span id="l4.810" class="difflineplus">+ *                                 The property preSemi is set to the token that</span>
<a href="#l4.811"></a><span id="l4.811" class="difflineplus">+ *                                 precedes the first semicolon.</span>
<a href="#l4.812"></a><span id="l4.812" class="difflineplus">+ */</span>
<a href="#l4.813"></a><span id="l4.813" class="difflineplus">+function parseParameterHeader(headerValue, doRFC2047, doRFC2231) {</span>
<a href="#l4.814"></a><span id="l4.814" class="difflineplus">+  // The basic syntax of headerValue is token [; token = token-or-qstring]*</span>
<a href="#l4.815"></a><span id="l4.815" class="difflineplus">+  // Copying more or less liberally from nsMIMEHeaderParamImpl:</span>
<a href="#l4.816"></a><span id="l4.816" class="difflineplus">+  // The first token is the text to the first whitespace or semicolon.</span>
<a href="#l4.817"></a><span id="l4.817" class="difflineplus">+  var semi = headerValue.indexOf(&quot;;&quot;);</span>
<a href="#l4.818"></a><span id="l4.818" class="difflineplus">+  if (semi &lt; 0) {</span>
<a href="#l4.819"></a><span id="l4.819" class="difflineplus">+    var start = headerValue;</span>
<a href="#l4.820"></a><span id="l4.820" class="difflineplus">+    var rest = '';</span>
<a href="#l4.821"></a><span id="l4.821" class="difflineplus">+  } else {</span>
<a href="#l4.822"></a><span id="l4.822" class="difflineplus">+    var start = headerValue.substring(0, semi);</span>
<a href="#l4.823"></a><span id="l4.823" class="difflineplus">+    var rest = headerValue.substring(semi); // Include the semicolon</span>
<a href="#l4.824"></a><span id="l4.824" class="difflineplus">+  }</span>
<a href="#l4.825"></a><span id="l4.825" class="difflineplus">+  // Strip start to be &lt;WSP&gt;&lt;nowsp&gt;&lt;WSP&gt;.</span>
<a href="#l4.826"></a><span id="l4.826" class="difflineplus">+  start = start.trim().split(/[ \t\r\n]/)[0];</span>
<a href="#l4.827"></a><span id="l4.827" class="difflineplus">+</span>
<a href="#l4.828"></a><span id="l4.828" class="difflineplus">+  // Decode the the parameter tokens.</span>
<a href="#l4.829"></a><span id="l4.829" class="difflineplus">+  let opts = {qstring: true, rfc2047: doRFC2047};</span>
<a href="#l4.830"></a><span id="l4.830" class="difflineplus">+  // Name is the name of the parameter, inName is true iff we don't have a name</span>
<a href="#l4.831"></a><span id="l4.831" class="difflineplus">+  // yet.</span>
<a href="#l4.832"></a><span id="l4.832" class="difflineplus">+  let name = '', inName = true;</span>
<a href="#l4.833"></a><span id="l4.833" class="difflineplus">+  // Matches is a list of [name, value] pairs, where we found something that</span>
<a href="#l4.834"></a><span id="l4.834" class="difflineplus">+  // looks like name=value in the input string.</span>
<a href="#l4.835"></a><span id="l4.835" class="difflineplus">+  let matches = [];</span>
<a href="#l4.836"></a><span id="l4.836" class="difflineplus">+  for (let token of getHeaderTokens(rest, &quot;;=&quot;, opts)) {</span>
<a href="#l4.837"></a><span id="l4.837" class="difflineplus">+    if (token === ';') {</span>
<a href="#l4.838"></a><span id="l4.838" class="difflineplus">+      // If we didn't find a name yet (we have ... tokenA; tokenB), push the</span>
<a href="#l4.839"></a><span id="l4.839" class="difflineplus">+      // name with an empty token instead.</span>
<a href="#l4.840"></a><span id="l4.840" class="difflineplus">+      if (name != '' &amp;&amp; inName == false)</span>
<a href="#l4.841"></a><span id="l4.841" class="difflineplus">+        matches.push([name, '']);</span>
<a href="#l4.842"></a><span id="l4.842" class="difflineplus">+      name = '';</span>
<a href="#l4.843"></a><span id="l4.843" class="difflineplus">+      inName = true;</span>
<a href="#l4.844"></a><span id="l4.844" class="difflineplus">+    } else if (token === '=') {</span>
<a href="#l4.845"></a><span id="l4.845" class="difflineplus">+      inName = false;</span>
<a href="#l4.846"></a><span id="l4.846" class="difflineplus">+    } else if (inName &amp;&amp; name == '') {</span>
<a href="#l4.847"></a><span id="l4.847" class="difflineplus">+      name = token.toString();</span>
<a href="#l4.848"></a><span id="l4.848" class="difflineplus">+    } else if (!inName &amp;&amp; name != '') {</span>
<a href="#l4.849"></a><span id="l4.849" class="difflineplus">+      token = token.toString();</span>
<a href="#l4.850"></a><span id="l4.850" class="difflineplus">+      // RFC 2231 doesn't make it clear if %-encoding is supposed to happen</span>
<a href="#l4.851"></a><span id="l4.851" class="difflineplus">+      // within a quoted string, but this is very much required in practice. If</span>
<a href="#l4.852"></a><span id="l4.852" class="difflineplus">+      // it ends with a '*', then the string is an extended-value, which means</span>
<a href="#l4.853"></a><span id="l4.853" class="difflineplus">+      // that its value may be %-encoded.</span>
<a href="#l4.854"></a><span id="l4.854" class="difflineplus">+      if (doRFC2231 &amp;&amp; name.endsWith('*')) {</span>
<a href="#l4.855"></a><span id="l4.855" class="difflineplus">+        token = token.replace(/%([0-9A-Fa-f]{2})/g,</span>
<a href="#l4.856"></a><span id="l4.856" class="difflineplus">+          function percent_deencode(match, hexchars) {</span>
<a href="#l4.857"></a><span id="l4.857" class="difflineplus">+            return String.fromCharCode(parseInt(hexchars, 16));</span>
<a href="#l4.858"></a><span id="l4.858" class="difflineplus">+        });</span>
<a href="#l4.859"></a><span id="l4.859" class="difflineplus">+      }</span>
<a href="#l4.860"></a><span id="l4.860" class="difflineplus">+      matches.push([name, token]);</span>
<a href="#l4.861"></a><span id="l4.861" class="difflineplus">+      // Clear the name, so we ignore anything afterwards.</span>
<a href="#l4.862"></a><span id="l4.862" class="difflineplus">+      name = '';</span>
<a href="#l4.863"></a><span id="l4.863" class="difflineplus">+    } else if (inName) {</span>
<a href="#l4.864"></a><span id="l4.864" class="difflineplus">+      // We have ...; tokenA tokenB ... -&gt; ignore both tokens</span>
<a href="#l4.865"></a><span id="l4.865" class="difflineplus">+      name = ''; // Error recovery, ignore this one</span>
<a href="#l4.866"></a><span id="l4.866" class="difflineplus">+    }</span>
<a href="#l4.867"></a><span id="l4.867" class="difflineplus">+  }</span>
<a href="#l4.868"></a><span id="l4.868" class="difflineplus">+  // If we have a leftover ...; tokenA, push the tokenA</span>
<a href="#l4.869"></a><span id="l4.869" class="difflineplus">+  if (name != '' &amp;&amp; inName == false)</span>
<a href="#l4.870"></a><span id="l4.870" class="difflineplus">+    matches.push([name, '']);</span>
<a href="#l4.871"></a><span id="l4.871" class="difflineplus">+</span>
<a href="#l4.872"></a><span id="l4.872" class="difflineplus">+  // Now matches holds the parameters, so clean up for RFC 2231. There are three</span>
<a href="#l4.873"></a><span id="l4.873" class="difflineplus">+  // cases: param=val, param*=us-ascii'en-US'blah, and param*n= variants. The</span>
<a href="#l4.874"></a><span id="l4.874" class="difflineplus">+  // order of preference is to pick the middle, then the last, then the first.</span>
<a href="#l4.875"></a><span id="l4.875" class="difflineplus">+  // Note that we already unpacked %-encoded values.</span>
<a href="#l4.876"></a><span id="l4.876" class="difflineplus">+</span>
<a href="#l4.877"></a><span id="l4.877" class="difflineplus">+  // simpleValues is just a straight parameter -&gt; value map.</span>
<a href="#l4.878"></a><span id="l4.878" class="difflineplus">+  // charsetValues is the parameter -&gt; value map, although values are stored</span>
<a href="#l4.879"></a><span id="l4.879" class="difflineplus">+  // before charset decoding happens.</span>
<a href="#l4.880"></a><span id="l4.880" class="difflineplus">+  // continuationValues maps parameter -&gt; array of values, with extra properties</span>
<a href="#l4.881"></a><span id="l4.881" class="difflineplus">+  // valid (if we decided we couldn't do anything anymore) and hasCharset (which</span>
<a href="#l4.882"></a><span id="l4.882" class="difflineplus">+  // records if we need to decode the charset parameter or not).</span>
<a href="#l4.883"></a><span id="l4.883" class="difflineplus">+  var simpleValues = new Map(), charsetValues = new Map(),</span>
<a href="#l4.884"></a><span id="l4.884" class="difflineplus">+      continuationValues = new Map();</span>
<a href="#l4.885"></a><span id="l4.885" class="difflineplus">+  for (let pair of matches) {</span>
<a href="#l4.886"></a><span id="l4.886" class="difflineplus">+    let name = pair[0];</span>
<a href="#l4.887"></a><span id="l4.887" class="difflineplus">+    let value = pair[1];</span>
<a href="#l4.888"></a><span id="l4.888" class="difflineplus">+    // Get first index, not last index, so we match param*0*= like param*0=.</span>
<a href="#l4.889"></a><span id="l4.889" class="difflineplus">+    let star = name.indexOf('*');</span>
<a href="#l4.890"></a><span id="l4.890" class="difflineplus">+    if (star == -1) {</span>
<a href="#l4.891"></a><span id="l4.891" class="difflineplus">+      // This is the case of param=val. Select the first value here, if there</span>
<a href="#l4.892"></a><span id="l4.892" class="difflineplus">+      // are multiple ones.</span>
<a href="#l4.893"></a><span id="l4.893" class="difflineplus">+      if (!simpleValues.has(name))</span>
<a href="#l4.894"></a><span id="l4.894" class="difflineplus">+        simpleValues.set(name, value);</span>
<a href="#l4.895"></a><span id="l4.895" class="difflineplus">+    } else if (star == name.length - 1) {</span>
<a href="#l4.896"></a><span id="l4.896" class="difflineplus">+      // This is the case of param*=us-ascii'en-US'blah.</span>
<a href="#l4.897"></a><span id="l4.897" class="difflineplus">+      name = name.substring(0, star);</span>
<a href="#l4.898"></a><span id="l4.898" class="difflineplus">+      // Again, select only the first value here.</span>
<a href="#l4.899"></a><span id="l4.899" class="difflineplus">+      if (!charsetValues.has(name))</span>
<a href="#l4.900"></a><span id="l4.900" class="difflineplus">+        charsetValues.set(name, value);</span>
<a href="#l4.901"></a><span id="l4.901" class="difflineplus">+    } else {</span>
<a href="#l4.902"></a><span id="l4.902" class="difflineplus">+      // This is the case of param*0= or param*0*=.</span>
<a href="#l4.903"></a><span id="l4.903" class="difflineplus">+      let param = name.substring(0, star);</span>
<a href="#l4.904"></a><span id="l4.904" class="difflineplus">+      let entry = continuationValues.get(param);</span>
<a href="#l4.905"></a><span id="l4.905" class="difflineplus">+      // Did we previously find this one to be bungled? Then ignore it.</span>
<a href="#l4.906"></a><span id="l4.906" class="difflineplus">+      if (continuationValues.has(param) &amp;&amp; !entry.valid)</span>
<a href="#l4.907"></a><span id="l4.907" class="difflineplus">+        continue;</span>
<a href="#l4.908"></a><span id="l4.908" class="difflineplus">+</span>
<a href="#l4.909"></a><span id="l4.909" class="difflineplus">+      // If we haven't seen it yet, set up entry already. Note that entries are</span>
<a href="#l4.910"></a><span id="l4.910" class="difflineplus">+      // not straight string values but rather [valid, hasCharset, param0, ... ]</span>
<a href="#l4.911"></a><span id="l4.911" class="difflineplus">+      if (!continuationValues.has(param)) {</span>
<a href="#l4.912"></a><span id="l4.912" class="difflineplus">+        entry = new Array();</span>
<a href="#l4.913"></a><span id="l4.913" class="difflineplus">+        entry.valid = true;</span>
<a href="#l4.914"></a><span id="l4.914" class="difflineplus">+        entry.hasCharset = undefined;</span>
<a href="#l4.915"></a><span id="l4.915" class="difflineplus">+        continuationValues.set(param, entry);</span>
<a href="#l4.916"></a><span id="l4.916" class="difflineplus">+      }</span>
<a href="#l4.917"></a><span id="l4.917" class="difflineplus">+</span>
<a href="#l4.918"></a><span id="l4.918" class="difflineplus">+      // When the string ends in *, we need to charset decoding.</span>
<a href="#l4.919"></a><span id="l4.919" class="difflineplus">+      // Note that the star is only meaningful for the *0*= case.</span>
<a href="#l4.920"></a><span id="l4.920" class="difflineplus">+      let lastStar = name[name.length - 1] == '*';</span>
<a href="#l4.921"></a><span id="l4.921" class="difflineplus">+      let number = name.substring(star + 1, name.length - (lastStar ? 1 : 0));</span>
<a href="#l4.922"></a><span id="l4.922" class="difflineplus">+      if (number == '0')</span>
<a href="#l4.923"></a><span id="l4.923" class="difflineplus">+        entry.hasCharset = lastStar;</span>
<a href="#l4.924"></a><span id="l4.924" class="difflineplus">+</span>
<a href="#l4.925"></a><span id="l4.925" class="difflineplus">+      // Is the continuation number illegal?</span>
<a href="#l4.926"></a><span id="l4.926" class="difflineplus">+      else if ((number[0] == '0' &amp;&amp; number != '0') ||</span>
<a href="#l4.927"></a><span id="l4.927" class="difflineplus">+          !(/^[0-9]+$/.test(number))) {</span>
<a href="#l4.928"></a><span id="l4.928" class="difflineplus">+        entry.valid = false;</span>
<a href="#l4.929"></a><span id="l4.929" class="difflineplus">+        continue;</span>
<a href="#l4.930"></a><span id="l4.930" class="difflineplus">+      }</span>
<a href="#l4.931"></a><span id="l4.931" class="difflineplus">+      // Normalize to an integer</span>
<a href="#l4.932"></a><span id="l4.932" class="difflineplus">+      number = parseInt(number, 10);</span>
<a href="#l4.933"></a><span id="l4.933" class="difflineplus">+</span>
<a href="#l4.934"></a><span id="l4.934" class="difflineplus">+      // Is this a repeat? If so, bail.</span>
<a href="#l4.935"></a><span id="l4.935" class="difflineplus">+      if (entry[number] !== undefined) {</span>
<a href="#l4.936"></a><span id="l4.936" class="difflineplus">+        entry.valid = false;</span>
<a href="#l4.937"></a><span id="l4.937" class="difflineplus">+        continue;</span>
<a href="#l4.938"></a><span id="l4.938" class="difflineplus">+      }</span>
<a href="#l4.939"></a><span id="l4.939" class="difflineplus">+</span>
<a href="#l4.940"></a><span id="l4.940" class="difflineplus">+      // Set the value for this continuation index. JS's magic array setter will</span>
<a href="#l4.941"></a><span id="l4.941" class="difflineplus">+      // expand the array if necessary.</span>
<a href="#l4.942"></a><span id="l4.942" class="difflineplus">+      entry[number] = value;</span>
<a href="#l4.943"></a><span id="l4.943" class="difflineplus">+    }</span>
<a href="#l4.944"></a><span id="l4.944" class="difflineplus">+  }</span>
<a href="#l4.945"></a><span id="l4.945" class="difflineplus">+</span>
<a href="#l4.946"></a><span id="l4.946" class="difflineplus">+  // Build the actual parameter array from the parsed values</span>
<a href="#l4.947"></a><span id="l4.947" class="difflineplus">+  var values = new Map();</span>
<a href="#l4.948"></a><span id="l4.948" class="difflineplus">+  // Simple values have lowest priority, so just add everything into the result</span>
<a href="#l4.949"></a><span id="l4.949" class="difflineplus">+  // now.</span>
<a href="#l4.950"></a><span id="l4.950" class="difflineplus">+  for (let pair of simpleValues) {</span>
<a href="#l4.951"></a><span id="l4.951" class="difflineplus">+    values.set(pair[0], pair[1]);</span>
<a href="#l4.952"></a><span id="l4.952" class="difflineplus">+  }</span>
<a href="#l4.953"></a><span id="l4.953" class="difflineplus">+</span>
<a href="#l4.954"></a><span id="l4.954" class="difflineplus">+  if (doRFC2231) {</span>
<a href="#l4.955"></a><span id="l4.955" class="difflineplus">+    // Continuation values come next</span>
<a href="#l4.956"></a><span id="l4.956" class="difflineplus">+    for (let pair of continuationValues) {</span>
<a href="#l4.957"></a><span id="l4.957" class="difflineplus">+      let name = pair[0];</span>
<a href="#l4.958"></a><span id="l4.958" class="difflineplus">+      let entry = pair[1];</span>
<a href="#l4.959"></a><span id="l4.959" class="difflineplus">+      // If we never saw a param*0= or param*0*= value, then we can't do any</span>
<a href="#l4.960"></a><span id="l4.960" class="difflineplus">+      // reasoning about what it looks like, so bail out now.</span>
<a href="#l4.961"></a><span id="l4.961" class="difflineplus">+      if (entry.hasCharset === undefined) continue;</span>
<a href="#l4.962"></a><span id="l4.962" class="difflineplus">+</span>
<a href="#l4.963"></a><span id="l4.963" class="difflineplus">+      // Use as many entries in the array as are valid--if we are missing an</span>
<a href="#l4.964"></a><span id="l4.964" class="difflineplus">+      // entry, stop there.</span>
<a href="#l4.965"></a><span id="l4.965" class="difflineplus">+      let valid = true;</span>
<a href="#l4.966"></a><span id="l4.966" class="difflineplus">+      for (var i = 0; valid &amp;&amp; i &lt; entry.length; i++)</span>
<a href="#l4.967"></a><span id="l4.967" class="difflineplus">+        if (entry[i] === undefined)</span>
<a href="#l4.968"></a><span id="l4.968" class="difflineplus">+          valid = false;</span>
<a href="#l4.969"></a><span id="l4.969" class="difflineplus">+</span>
<a href="#l4.970"></a><span id="l4.970" class="difflineplus">+      // Concatenate as many parameters as are valid. If we need to decode thec</span>
<a href="#l4.971"></a><span id="l4.971" class="difflineplus">+      // charset, do so now.</span>
<a href="#l4.972"></a><span id="l4.972" class="difflineplus">+      var value = entry.slice(0, i).join('');</span>
<a href="#l4.973"></a><span id="l4.973" class="difflineplus">+      if (entry.hasCharset) {</span>
<a href="#l4.974"></a><span id="l4.974" class="difflineplus">+        try {</span>
<a href="#l4.975"></a><span id="l4.975" class="difflineplus">+          value = decode2231Value(value);</span>
<a href="#l4.976"></a><span id="l4.976" class="difflineplus">+        } catch (e) {</span>
<a href="#l4.977"></a><span id="l4.977" class="difflineplus">+          // Bad charset, don't add anything.</span>
<a href="#l4.978"></a><span id="l4.978" class="difflineplus">+          continue;</span>
<a href="#l4.979"></a><span id="l4.979" class="difflineplus">+        }</span>
<a href="#l4.980"></a><span id="l4.980" class="difflineplus">+      }</span>
<a href="#l4.981"></a><span id="l4.981" class="difflineplus">+      // Finally, add this to the output array.</span>
<a href="#l4.982"></a><span id="l4.982" class="difflineplus">+      values.set(name, value);</span>
<a href="#l4.983"></a><span id="l4.983" class="difflineplus">+    }</span>
<a href="#l4.984"></a><span id="l4.984" class="difflineplus">+</span>
<a href="#l4.985"></a><span id="l4.985" class="difflineplus">+    // Highest priority is the charset conversion.</span>
<a href="#l4.986"></a><span id="l4.986" class="difflineplus">+    for (let pair of charsetValues) {</span>
<a href="#l4.987"></a><span id="l4.987" class="difflineplus">+      try {</span>
<a href="#l4.988"></a><span id="l4.988" class="difflineplus">+        values.set(pair[0], decode2231Value(pair[1]));</span>
<a href="#l4.989"></a><span id="l4.989" class="difflineplus">+      } catch (e) {</span>
<a href="#l4.990"></a><span id="l4.990" class="difflineplus">+        // Bad charset, don't add anything.</span>
<a href="#l4.991"></a><span id="l4.991" class="difflineplus">+      }</span>
<a href="#l4.992"></a><span id="l4.992" class="difflineplus">+    }</span>
<a href="#l4.993"></a><span id="l4.993" class="difflineplus">+  }</span>
<a href="#l4.994"></a><span id="l4.994" class="difflineplus">+</span>
<a href="#l4.995"></a><span id="l4.995" class="difflineplus">+  // Finally, return the values computed above.</span>
<a href="#l4.996"></a><span id="l4.996" class="difflineplus">+  values.preSemi = start;</span>
<a href="#l4.997"></a><span id="l4.997" class="difflineplus">+  return values;</span>
<a href="#l4.998"></a><span id="l4.998" class="difflineplus">+}</span>
<a href="#l4.999"></a><span id="l4.999" class="difflineplus">+</span>
<a href="#l4.1000"></a><span id="l4.1000" class="difflineplus">+/**</span>
<a href="#l4.1001"></a><span id="l4.1001" class="difflineplus">+ * Convert a RFC 2231-encoded string parameter into a Unicode version of the</span>
<a href="#l4.1002"></a><span id="l4.1002" class="difflineplus">+ * string. This assumes that percent-decoding has already been applied.</span>
<a href="#l4.1003"></a><span id="l4.1003" class="difflineplus">+ *</span>
<a href="#l4.1004"></a><span id="l4.1004" class="difflineplus">+ * @param {String} value The RFC 2231-encoded string to decode.</span>
<a href="#l4.1005"></a><span id="l4.1005" class="difflineplus">+ * @return The Unicode version of the string.</span>
<a href="#l4.1006"></a><span id="l4.1006" class="difflineplus">+ */</span>
<a href="#l4.1007"></a><span id="l4.1007" class="difflineplus">+function decode2231Value(value) {</span>
<a href="#l4.1008"></a><span id="l4.1008" class="difflineplus">+  let quote1 = value.indexOf(&quot;'&quot;);</span>
<a href="#l4.1009"></a><span id="l4.1009" class="difflineplus">+  let quote2 = quote1 &gt;= 0 ? value.indexOf(&quot;'&quot;, quote1 + 1) : -1;</span>
<a href="#l4.1010"></a><span id="l4.1010" class="difflineplus">+</span>
<a href="#l4.1011"></a><span id="l4.1011" class="difflineplus">+  let charset = (quote1 &gt;= 0 ? value.substring(0, quote1) : &quot;&quot;);</span>
<a href="#l4.1012"></a><span id="l4.1012" class="difflineplus">+  // It turns out that the language isn't useful anywhere in our codebase for</span>
<a href="#l4.1013"></a><span id="l4.1013" class="difflineplus">+  // the present time, so we will safely ignore it.</span>
<a href="#l4.1014"></a><span id="l4.1014" class="difflineplus">+  //var language = (quote2 &gt;= 0 ? value.substring(quote1 + 2, quote2) : &quot;&quot;);</span>
<a href="#l4.1015"></a><span id="l4.1015" class="difflineplus">+  value = value.substring(Math.max(quote1, quote2) + 1);</span>
<a href="#l4.1016"></a><span id="l4.1016" class="difflineplus">+</span>
<a href="#l4.1017"></a><span id="l4.1017" class="difflineplus">+  // Convert the value into a typed array for decoding</span>
<a href="#l4.1018"></a><span id="l4.1018" class="difflineplus">+  let typedarray = mimeutils.stringToTypedArray(value);</span>
<a href="#l4.1019"></a><span id="l4.1019" class="difflineplus">+</span>
<a href="#l4.1020"></a><span id="l4.1020" class="difflineplus">+  // Decode the charset. If the charset isn't found, we throw an error. Try to</span>
<a href="#l4.1021"></a><span id="l4.1021" class="difflineplus">+  // fallback in that case.</span>
<a href="#l4.1022"></a><span id="l4.1022" class="difflineplus">+  return new TextDecoder(charset, {fatal: true})</span>
<a href="#l4.1023"></a><span id="l4.1023" class="difflineplus">+    .decode(typedarray, {stream: false});</span>
<a href="#l4.1024"></a><span id="l4.1024" class="difflineplus">+}</span>
<a href="#l4.1025"></a><span id="l4.1025" class="difflineplus">+</span>
<a href="#l4.1026"></a><span id="l4.1026" class="difflineplus">+////////////////////////////////////////</span>
<a href="#l4.1027"></a><span id="l4.1027" class="difflineplus">+// Structured header decoding support //</span>
<a href="#l4.1028"></a><span id="l4.1028" class="difflineplus">+////////////////////////////////////////</span>
<a href="#l4.1029"></a><span id="l4.1029" class="difflineplus">+</span>
<a href="#l4.1030"></a><span id="l4.1030" class="difflineplus">+// Load the default structured decoders</span>
<a href="#l4.1031"></a><span id="l4.1031" class="difflineplus">+var structuredDecoders = new Map();</span>
<a href="#l4.1032"></a><span id="l4.1032" class="difflineplus">+var structuredHeaders = require('./structuredHeaders');</span>
<a href="#l4.1033"></a><span id="l4.1033" class="difflineplus">+var preferredSpellings = structuredHeaders.spellings;</span>
<a href="#l4.1034"></a><span id="l4.1034" class="difflineplus">+var forbiddenHeaders = new Set();</span>
<a href="#l4.1035"></a><span id="l4.1035" class="difflineplus">+for (let pair of structuredHeaders.decoders) {</span>
<a href="#l4.1036"></a><span id="l4.1036" class="difflineplus">+  addStructuredDecoder(pair[0], pair[1]);</span>
<a href="#l4.1037"></a><span id="l4.1037" class="difflineplus">+  forbiddenHeaders.add(pair[0].toLowerCase());</span>
<a href="#l4.1038"></a><span id="l4.1038" class="difflineplus">+}</span>
<a href="#l4.1039"></a><span id="l4.1039" class="difflineplus">+</span>
<a href="#l4.1040"></a><span id="l4.1040" class="difflineplus">+/**</span>
<a href="#l4.1041"></a><span id="l4.1041" class="difflineplus">+ * Use an already-registered structured decoder to parse the value of the header</span>
<a href="#l4.1042"></a><span id="l4.1042" class="difflineplus">+ * into a structured representation.</span>
<a href="#l4.1043"></a><span id="l4.1043" class="difflineplus">+ *</span>
<a href="#l4.1044"></a><span id="l4.1044" class="difflineplus">+ * As this method is designed to be used for the internal MIME Parser to convert</span>
<a href="#l4.1045"></a><span id="l4.1045" class="difflineplus">+ * the raw header values to well-structured values, value is intended to be an</span>
<a href="#l4.1046"></a><span id="l4.1046" class="difflineplus">+ * array consisting of all occurences of the header in order. However, for ease</span>
<a href="#l4.1047"></a><span id="l4.1047" class="difflineplus">+ * of use by other callers, it can also be treated as a string.</span>
<a href="#l4.1048"></a><span id="l4.1048" class="difflineplus">+ *</span>
<a href="#l4.1049"></a><span id="l4.1049" class="difflineplus">+ * If the decoder for the header is not found, an exception will be thrown.</span>
<a href="#l4.1050"></a><span id="l4.1050" class="difflineplus">+ *</span>
<a href="#l4.1051"></a><span id="l4.1051" class="difflineplus">+ * A large set of headers have pre-defined structured decoders; these decoders</span>
<a href="#l4.1052"></a><span id="l4.1052" class="difflineplus">+ * cannot be overrided with addStructuredDecoder, as doing so could prevent the</span>
<a href="#l4.1053"></a><span id="l4.1053" class="difflineplus">+ * MIME or message parsers from working properly. The pre-defined structured</span>
<a href="#l4.1054"></a><span id="l4.1054" class="difflineplus">+ * headers break down into five clases of results, plus some ad-hoc</span>
<a href="#l4.1055"></a><span id="l4.1055" class="difflineplus">+ * representations. They are:</span>
<a href="#l4.1056"></a><span id="l4.1056" class="difflineplus">+ *</span>
<a href="#l4.1057"></a><span id="l4.1057" class="difflineplus">+ * Addressing headers (results are the same as parseAddressingHeader):</span>
<a href="#l4.1058"></a><span id="l4.1058" class="difflineplus">+ * - Approved</span>
<a href="#l4.1059"></a><span id="l4.1059" class="difflineplus">+ * - Bcc</span>
<a href="#l4.1060"></a><span id="l4.1060" class="difflineplus">+ * - Cc</span>
<a href="#l4.1061"></a><span id="l4.1061" class="difflineplus">+ * - Delivered-To</span>
<a href="#l4.1062"></a><span id="l4.1062" class="difflineplus">+ * - Disposition-Notification-To</span>
<a href="#l4.1063"></a><span id="l4.1063" class="difflineplus">+ * - From</span>
<a href="#l4.1064"></a><span id="l4.1064" class="difflineplus">+ * - Reply-To</span>
<a href="#l4.1065"></a><span id="l4.1065" class="difflineplus">+ * - Resent-Bcc</span>
<a href="#l4.1066"></a><span id="l4.1066" class="difflineplus">+ * - Resent-Cc</span>
<a href="#l4.1067"></a><span id="l4.1067" class="difflineplus">+ * - Resent-From</span>
<a href="#l4.1068"></a><span id="l4.1068" class="difflineplus">+ * - Resent-Sender</span>
<a href="#l4.1069"></a><span id="l4.1069" class="difflineplus">+ * - Resent-To</span>
<a href="#l4.1070"></a><span id="l4.1070" class="difflineplus">+ * - Return-Receipt-To</span>
<a href="#l4.1071"></a><span id="l4.1071" class="difflineplus">+ * - Sender</span>
<a href="#l4.1072"></a><span id="l4.1072" class="difflineplus">+ * - To</span>
<a href="#l4.1073"></a><span id="l4.1073" class="difflineplus">+ *</span>
<a href="#l4.1074"></a><span id="l4.1074" class="difflineplus">+ * Date headers (results are the same as parseDateHeader):</span>
<a href="#l4.1075"></a><span id="l4.1075" class="difflineplus">+ * - (TODO: Parsing support for these headers is currently unsupported)</span>
<a href="#l4.1076"></a><span id="l4.1076" class="difflineplus">+ *</span>
<a href="#l4.1077"></a><span id="l4.1077" class="difflineplus">+ * References headers (results are the same as parseReferencesHeader):</span>
<a href="#l4.1078"></a><span id="l4.1078" class="difflineplus">+ * - (TODO: Parsing support for these headers is currently unsupported)</span>
<a href="#l4.1079"></a><span id="l4.1079" class="difflineplus">+ *</span>
<a href="#l4.1080"></a><span id="l4.1080" class="difflineplus">+ * Message-ID headers (results are the first entry of the result of</span>
<a href="#l4.1081"></a><span id="l4.1081" class="difflineplus">+ * parseReferencesHeader):</span>
<a href="#l4.1082"></a><span id="l4.1082" class="difflineplus">+ * - (TODO: Parsing support for these headers is currently unsupported)</span>
<a href="#l4.1083"></a><span id="l4.1083" class="difflineplus">+ *</span>
<a href="#l4.1084"></a><span id="l4.1084" class="difflineplus">+ * Unstructured headers (results are merely decoded according to RFC 2047):</span>
<a href="#l4.1085"></a><span id="l4.1085" class="difflineplus">+ * - Comments</span>
<a href="#l4.1086"></a><span id="l4.1086" class="difflineplus">+ * - Content-Description</span>
<a href="#l4.1087"></a><span id="l4.1087" class="difflineplus">+ * - Keywords</span>
<a href="#l4.1088"></a><span id="l4.1088" class="difflineplus">+ * - Subject</span>
<a href="#l4.1089"></a><span id="l4.1089" class="difflineplus">+ *</span>
<a href="#l4.1090"></a><span id="l4.1090" class="difflineplus">+ * The ad-hoc headers and their resulting formats are as follows:</span>
<a href="#l4.1091"></a><span id="l4.1091" class="difflineplus">+ * Content-Type: returns a JS Map of parameter names (in lower case) to their</span>
<a href="#l4.1092"></a><span id="l4.1092" class="difflineplus">+ * values, along with the following extra properties defined on the map:</span>
<a href="#l4.1093"></a><span id="l4.1093" class="difflineplus">+ * - mediatype: the type to the left of '/' (e.g., 'text', 'message')</span>
<a href="#l4.1094"></a><span id="l4.1094" class="difflineplus">+ * - subtype: the type to the right of '/' (e.g., 'plain', 'rfc822')</span>
<a href="#l4.1095"></a><span id="l4.1095" class="difflineplus">+ * - type: the full typename (e.g., 'text/plain')</span>
<a href="#l4.1096"></a><span id="l4.1096" class="difflineplus">+ * RFC 2047 and RFC 2231 decoding is applied where appropriate. The values of</span>
<a href="#l4.1097"></a><span id="l4.1097" class="difflineplus">+ * the type, mediatype, and subtype attributes are all normalized to lower-case,</span>
<a href="#l4.1098"></a><span id="l4.1098" class="difflineplus">+ * as are the names of all parameters.</span>
<a href="#l4.1099"></a><span id="l4.1099" class="difflineplus">+ *</span>
<a href="#l4.1100"></a><span id="l4.1100" class="difflineplus">+ * Content-Transfer-Encoding: the first value is converted to lower-case.</span>
<a href="#l4.1101"></a><span id="l4.1101" class="difflineplus">+ *</span>
<a href="#l4.1102"></a><span id="l4.1102" class="difflineplus">+ * @param {String}       header The name of the header of the values.</span>
<a href="#l4.1103"></a><span id="l4.1103" class="difflineplus">+ * @param {String|Array} value  The value(s) of the headers, after charset</span>
<a href="#l4.1104"></a><span id="l4.1104" class="difflineplus">+ *                              conversion (if any) has been applied. If it is</span>
<a href="#l4.1105"></a><span id="l4.1105" class="difflineplus">+ *                              an array, the headers are listed in the order</span>
<a href="#l4.1106"></a><span id="l4.1106" class="difflineplus">+ *                              they appear in the message.</span>
<a href="#l4.1107"></a><span id="l4.1107" class="difflineplus">+ * @returns {Object} A structured representation of the header values.</span>
<a href="#l4.1108"></a><span id="l4.1108" class="difflineplus">+ */</span>
<a href="#l4.1109"></a><span id="l4.1109" class="difflineplus">+function parseStructuredHeader(header, value) {</span>
<a href="#l4.1110"></a><span id="l4.1110" class="difflineplus">+  // Enforce that the parameter is an array. If it's a string, make it a</span>
<a href="#l4.1111"></a><span id="l4.1111" class="difflineplus">+  // 1-element array.</span>
<a href="#l4.1112"></a><span id="l4.1112" class="difflineplus">+  if (typeof value === &quot;string&quot; || value instanceof String)</span>
<a href="#l4.1113"></a><span id="l4.1113" class="difflineplus">+    value = [value];</span>
<a href="#l4.1114"></a><span id="l4.1114" class="difflineplus">+  if (!Array.isArray(value))</span>
<a href="#l4.1115"></a><span id="l4.1115" class="difflineplus">+    throw new TypeError(&quot;Header value is not an array: &quot; + value);</span>
<a href="#l4.1116"></a><span id="l4.1116" class="difflineplus">+</span>
<a href="#l4.1117"></a><span id="l4.1117" class="difflineplus">+  // Lookup the header in our decoders; if present, use that to decode the</span>
<a href="#l4.1118"></a><span id="l4.1118" class="difflineplus">+  // header.</span>
<a href="#l4.1119"></a><span id="l4.1119" class="difflineplus">+  let lowerHeader = header.toLowerCase();</span>
<a href="#l4.1120"></a><span id="l4.1120" class="difflineplus">+  if (structuredDecoders.has(lowerHeader)) {</span>
<a href="#l4.1121"></a><span id="l4.1121" class="difflineplus">+    return structuredDecoders.get(lowerHeader).call(headerparser, value);</span>
<a href="#l4.1122"></a><span id="l4.1122" class="difflineplus">+  }</span>
<a href="#l4.1123"></a><span id="l4.1123" class="difflineplus">+</span>
<a href="#l4.1124"></a><span id="l4.1124" class="difflineplus">+  // If not present, throw an exception.</span>
<a href="#l4.1125"></a><span id="l4.1125" class="difflineplus">+  throw new Error(&quot;Unknown structured header: &quot; + header);</span>
<a href="#l4.1126"></a><span id="l4.1126" class="difflineplus">+}</span>
<a href="#l4.1127"></a><span id="l4.1127" class="difflineplus">+</span>
<a href="#l4.1128"></a><span id="l4.1128" class="difflineplus">+/**</span>
<a href="#l4.1129"></a><span id="l4.1129" class="difflineplus">+ * Add a custom structured MIME decoder to the set of known decoders. These</span>
<a href="#l4.1130"></a><span id="l4.1130" class="difflineplus">+ * decoders are used for {@link parseStructuredHeader} and similar functions to</span>
<a href="#l4.1131"></a><span id="l4.1131" class="difflineplus">+ * encode richer, more structured values instead of relying on string</span>
<a href="#l4.1132"></a><span id="l4.1132" class="difflineplus">+ * representations everywhere.</span>
<a href="#l4.1133"></a><span id="l4.1133" class="difflineplus">+ *</span>
<a href="#l4.1134"></a><span id="l4.1134" class="difflineplus">+ * Structured decoders are functions which take in a single parameter consisting</span>
<a href="#l4.1135"></a><span id="l4.1135" class="difflineplus">+ * of an array of the string values of the header, in order that they appear in</span>
<a href="#l4.1136"></a><span id="l4.1136" class="difflineplus">+ * the message. These headers have had the charset conversion (if necessary)</span>
<a href="#l4.1137"></a><span id="l4.1137" class="difflineplus">+ * applied to them already. The this parameter of the function is set to be the</span>
<a href="#l4.1138"></a><span id="l4.1138" class="difflineplus">+ * jsmime.headerparser module.</span>
<a href="#l4.1139"></a><span id="l4.1139" class="difflineplus">+ *</span>
<a href="#l4.1140"></a><span id="l4.1140" class="difflineplus">+ * There is a large set of structured decoders built-in to the jsmime library</span>
<a href="#l4.1141"></a><span id="l4.1141" class="difflineplus">+ * already. As these headers are fundamental to the workings of jsmime,</span>
<a href="#l4.1142"></a><span id="l4.1142" class="difflineplus">+ * attempting to replace them with a custom version will instead produce an</span>
<a href="#l4.1143"></a><span id="l4.1143" class="difflineplus">+ * exception.</span>
<a href="#l4.1144"></a><span id="l4.1144" class="difflineplus">+ *</span>
<a href="#l4.1145"></a><span id="l4.1145" class="difflineplus">+ * @param {String}                       header  The header name (in any case)</span>
<a href="#l4.1146"></a><span id="l4.1146" class="difflineplus">+ *                                               for which the decoder will be</span>
<a href="#l4.1147"></a><span id="l4.1147" class="difflineplus">+ *                                               used.</span>
<a href="#l4.1148"></a><span id="l4.1148" class="difflineplus">+ * @param {Function(String[] -&gt; Object)} decoder The structured decoder</span>
<a href="#l4.1149"></a><span id="l4.1149" class="difflineplus">+ *                                               function.</span>
<a href="#l4.1150"></a><span id="l4.1150" class="difflineplus">+ */</span>
<a href="#l4.1151"></a><span id="l4.1151" class="difflineplus">+function addStructuredDecoder(header, decoder) {</span>
<a href="#l4.1152"></a><span id="l4.1152" class="difflineplus">+  let lowerHeader = header.toLowerCase();</span>
<a href="#l4.1153"></a><span id="l4.1153" class="difflineplus">+  if (forbiddenHeaders.has(lowerHeader))</span>
<a href="#l4.1154"></a><span id="l4.1154" class="difflineplus">+    throw new Error(&quot;Cannot override header: &quot; + header);</span>
<a href="#l4.1155"></a><span id="l4.1155" class="difflineplus">+  structuredDecoders.set(lowerHeader, decoder);</span>
<a href="#l4.1156"></a><span id="l4.1156" class="difflineplus">+  if (!preferredSpellings.has(lowerHeader))</span>
<a href="#l4.1157"></a><span id="l4.1157" class="difflineplus">+    preferredSpellings.set(lowerHeader, header);</span>
<a href="#l4.1158"></a><span id="l4.1158" class="difflineplus">+}</span>
<a href="#l4.1159"></a><span id="l4.1159" class="difflineplus">+</span>
<a href="#l4.1160"></a><span id="l4.1160" class="difflineplus">+headerparser.addStructuredDecoder = addStructuredDecoder;</span>
<a href="#l4.1161"></a><span id="l4.1161" class="difflineplus">+headerparser.convert8BitHeader = convert8BitHeader;</span>
<a href="#l4.1162"></a><span id="l4.1162" class="difflineplus">+headerparser.decodeRFC2047Words = decodeRFC2047Words;</span>
<a href="#l4.1163"></a><span id="l4.1163" class="difflineplus">+headerparser.getHeaderTokens = getHeaderTokens;</span>
<a href="#l4.1164"></a><span id="l4.1164" class="difflineplus">+headerparser.parseAddressingHeader = parseAddressingHeader;</span>
<a href="#l4.1165"></a><span id="l4.1165" class="difflineplus">+headerparser.parseParameterHeader = parseParameterHeader;</span>
<a href="#l4.1166"></a><span id="l4.1166" class="difflineplus">+headerparser.parseStructuredHeader = parseStructuredHeader;</span>
<a href="#l4.1167"></a><span id="l4.1167" class="difflineplus">+return Object.freeze(headerparser);</span>
<a href="#l4.1168"></a><span id="l4.1168" class="difflineplus">+</span>
<a href="#l4.1169"></a><span id="l4.1169" class="difflineplus">+});</span>
<a href="#l4.1170"></a><span id="l4.1170" class="difflineplus">+</span>
<a href="#l4.1171"></a><span id="l4.1171"> ////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.1172"></a><span id="l4.1172"> //                        JavaScript Raw MIME Parser                          //</span>
<a href="#l4.1173"></a><span id="l4.1173"> ////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.1174"></a><span id="l4.1174"> </span>
<a href="#l4.1175"></a><span id="l4.1175"> /**</span>
<a href="#l4.1176"></a><span id="l4.1176">  * The parser implemented in this file produces a MIME part tree for a given</span>
<a href="#l4.1177"></a><span id="l4.1177">  * input message via a streaming callback interface. It does not, by itself,</span>
<a href="#l4.1178"></a><span id="l4.1178">  * understand concepts like attachments (hence the term 'Raw'); the consumer</span>
<a href="#l4.1179"></a><span id="l4.1179">  * must translate output into such a format.</span>
<a href="#l4.1180"></a><span id="l4.1180">  *</span>
<a href="#l4.1181"></a><span id="l4.1181" class="difflineminus">- * Dependencies:</span>
<a href="#l4.1182"></a><span id="l4.1182" class="difflineminus">- * This file requires some external code for processing. The following are</span>
<a href="#l4.1183"></a><span id="l4.1183" class="difflineminus">- * things that are presumed to exist in the global scope:</span>
<a href="#l4.1184"></a><span id="l4.1184" class="difflineminus">- * function atob(str): Converts a JS string to a JS binary string</span>
<a href="#l4.1185"></a><span id="l4.1185" class="difflineminus">- *</span>
<a href="#l4.1186"></a><span id="l4.1186">  * Charsets:</span>
<a href="#l4.1187"></a><span id="l4.1187">  * The MIME specifications permit a single message to contain multiple charsets</span>
<a href="#l4.1188"></a><span id="l4.1188">  * (or perhaps none) as raw octets. As JavaScript strings are implicitly</span>
<a href="#l4.1189"></a><span id="l4.1189">  * implemented in UTF-16, it is possible that some engines will attempt to</span>
<a href="#l4.1190"></a><span id="l4.1190">  * convert these strings using an incorrect charset or simply fail to convert</span>
<a href="#l4.1191"></a><span id="l4.1191">  * them at all. This parser assumes that its input is in the form of a &quot;binary</span>
<a href="#l4.1192"></a><span id="l4.1192">  * string&quot;, a string that uses only the first 256 characters of Unicode to</span>
<a href="#l4.1193"></a><span id="l4.1193" class="difflineminus">- * represent the individual octets. Even if this is the case, the data in the</span>
<a href="#l4.1194"></a><span id="l4.1194" class="difflineminus">- * strings are likely to be passed through unchanged no matter their charset</span>
<a href="#l4.1195"></a><span id="l4.1195" class="difflineminus">- * unless charset conversion happens on an 8-bit or binary string.</span>
<a href="#l4.1196"></a><span id="l4.1196" class="difflineplus">+ * represent the individual octets. To verify that charsets are not getting</span>
<a href="#l4.1197"></a><span id="l4.1197" class="difflineplus">+ * mangled elsewhere in the pipeline, the auxiliary test file test/data/charsets</span>
<a href="#l4.1198"></a><span id="l4.1198" class="difflineplus">+ * can be used.</span>
<a href="#l4.1199"></a><span id="l4.1199" class="difflineplus">+ *</span>
<a href="#l4.1200"></a><span id="l4.1200" class="difflineplus">+ * This parser attempts to hide the charset details from clients as much as</span>
<a href="#l4.1201"></a><span id="l4.1201" class="difflineplus">+ * possible. The resulting values of structured headers are always converted</span>
<a href="#l4.1202"></a><span id="l4.1202" class="difflineplus">+ * into proper Unicode strings before being exposed to clients; getting at the</span>
<a href="#l4.1203"></a><span id="l4.1203" class="difflineplus">+ * raw binary string data can only be done via getRawHeader. The .charset</span>
<a href="#l4.1204"></a><span id="l4.1204" class="difflineplus">+ * parameter on header objects, if changed, changes the fallback charset used</span>
<a href="#l4.1205"></a><span id="l4.1205" class="difflineplus">+ * for headers. It is initialized to the presumed charset of the corresponding</span>
<a href="#l4.1206"></a><span id="l4.1206" class="difflineplus">+ * part, taking into account the charset and force-charset options of the</span>
<a href="#l4.1207"></a><span id="l4.1207" class="difflineplus">+ * parser. Body parts are only converted into Unicode strings if the strformat</span>
<a href="#l4.1208"></a><span id="l4.1208" class="difflineplus">+ * option is set to Unicode. Even then, only the bodies of parts with a media</span>
<a href="#l4.1209"></a><span id="l4.1209" class="difflineplus">+ * type of text are converted to Unicode strings using available charset data;</span>
<a href="#l4.1210"></a><span id="l4.1210" class="difflineplus">+ * other parts are retained as Uint8Array objects.</span>
<a href="#l4.1211"></a><span id="l4.1211">  *</span>
<a href="#l4.1212"></a><span id="l4.1212">  * Part numbering:</span>
<a href="#l4.1213"></a><span id="l4.1213">  * Since the output is a streaming format, individual parts are identified by a</span>
<a href="#l4.1214"></a><span id="l4.1214">  * numbering scheme. The intent of the numbering scheme for parts is to comply</span>
<a href="#l4.1215"></a><span id="l4.1215">  * with the part numbers as dictated by RFC 3501 as much possible; however,</span>
<a href="#l4.1216"></a><span id="l4.1216">  * that scheme does have several edge cases which would, if strictly followed,</span>
<a href="#l4.1217"></a><span id="l4.1217">  * make it impossible to refer to certain parts of the message. In addition, we</span>
<a href="#l4.1218"></a><span id="l4.1218">  * wish to make it possible to refer to parts which are not discoverable in the</span>
<a href="#l4.1219"></a><span id="l4.1219" class="difflineat">@@ -43,18 +1209,325 @@</span>
<a href="#l4.1220"></a><span id="l4.1220">  * - The numbers of multipart/* parts are separated by `.' characters.</span>
<a href="#l4.1221"></a><span id="l4.1221">  * - The outermost message is referred to by use of the empty string.</span>
<a href="#l4.1222"></a><span id="l4.1222">  * --&gt; The following segments are not accounted for by IMAP part numbering. &lt;--</span>
<a href="#l4.1223"></a><span id="l4.1223">  * - The body of any message/rfc822 or similar part is distinguished from the</span>
<a href="#l4.1224"></a><span id="l4.1224">  *   message part as a whole by appending a `$' character. This does not apply</span>
<a href="#l4.1225"></a><span id="l4.1225">  *   to the outermost message/rfc822 envelope.</span>
<a href="#l4.1226"></a><span id="l4.1226">  */</span>
<a href="#l4.1227"></a><span id="l4.1227"> </span>
<a href="#l4.1228"></a><span id="l4.1228" class="difflineplus">+def('mimeparser', function(require) {</span>
<a href="#l4.1229"></a><span id="l4.1229"> &quot;use strict&quot;;</span>
<a href="#l4.1230"></a><span id="l4.1230"> </span>
<a href="#l4.1231"></a><span id="l4.1231" class="difflineplus">+var mimeutils = require('./mimeutils');</span>
<a href="#l4.1232"></a><span id="l4.1232" class="difflineplus">+var headerparser = require('./headerparser');</span>
<a href="#l4.1233"></a><span id="l4.1233" class="difflineplus">+var spellings = require('./structuredHeaders').spellings;</span>
<a href="#l4.1234"></a><span id="l4.1234" class="difflineplus">+</span>
<a href="#l4.1235"></a><span id="l4.1235" class="difflineplus">+/**</span>
<a href="#l4.1236"></a><span id="l4.1236" class="difflineplus">+ * An object that represents the structured MIME headers for a message.</span>
<a href="#l4.1237"></a><span id="l4.1237" class="difflineplus">+ *</span>
<a href="#l4.1238"></a><span id="l4.1238" class="difflineplus">+ * This class is primarily used as the 'headers' parameter in the startPart</span>
<a href="#l4.1239"></a><span id="l4.1239" class="difflineplus">+ * callback on handlers for MimeParser. As such, it is designed to do the right</span>
<a href="#l4.1240"></a><span id="l4.1240" class="difflineplus">+ * thing in common cases as much as possible, with some advanced customization</span>
<a href="#l4.1241"></a><span id="l4.1241" class="difflineplus">+ * possible for clients that need such flexibility.</span>
<a href="#l4.1242"></a><span id="l4.1242" class="difflineplus">+ *</span>
<a href="#l4.1243"></a><span id="l4.1243" class="difflineplus">+ * In a nutshell, this class stores the raw headers as an internal Map. The</span>
<a href="#l4.1244"></a><span id="l4.1244" class="difflineplus">+ * structured headers are not computed until they are actually used, which means</span>
<a href="#l4.1245"></a><span id="l4.1245" class="difflineplus">+ * that potentially expensive structuring (e.g., doing manual DKIM validation)</span>
<a href="#l4.1246"></a><span id="l4.1246" class="difflineplus">+ * can be performed as a structured decoder without impeding performance for</span>
<a href="#l4.1247"></a><span id="l4.1247" class="difflineplus">+ * those who just want a few common headers.</span>
<a href="#l4.1248"></a><span id="l4.1248" class="difflineplus">+ *</span>
<a href="#l4.1249"></a><span id="l4.1249" class="difflineplus">+ * The outer API of this class is intended to be similar to a read-only Map</span>
<a href="#l4.1250"></a><span id="l4.1250" class="difflineplus">+ * object (complete with iterability support), with a few extra properties to</span>
<a href="#l4.1251"></a><span id="l4.1251" class="difflineplus">+ * represent things that are hard to determine properly from headers. The keys</span>
<a href="#l4.1252"></a><span id="l4.1252" class="difflineplus">+ * used are &quot;preferred spellings&quot; of the headers, although the get and has</span>
<a href="#l4.1253"></a><span id="l4.1253" class="difflineplus">+ * methods will accept header parameters of any case. Preferred spellings are</span>
<a href="#l4.1254"></a><span id="l4.1254" class="difflineplus">+ * derived from the name passed to addStructuredDecoder/addStructuredEncoder; if</span>
<a href="#l4.1255"></a><span id="l4.1255" class="difflineplus">+ * no structured decoder has been registered, then the name capitalizes the</span>
<a href="#l4.1256"></a><span id="l4.1256" class="difflineplus">+ * first letter of every word in the header name.</span>
<a href="#l4.1257"></a><span id="l4.1257" class="difflineplus">+ *</span>
<a href="#l4.1258"></a><span id="l4.1258" class="difflineplus">+ * Extra properties compared to a Map object are:</span>
<a href="#l4.1259"></a><span id="l4.1259" class="difflineplus">+ * - charset: This field represents the assumed charset of the associated MIME</span>
<a href="#l4.1260"></a><span id="l4.1260" class="difflineplus">+ *   body. It is prefilled using a combination of the charset and force-charset</span>
<a href="#l4.1261"></a><span id="l4.1261" class="difflineplus">+ *   options on the associated MimeParser instance as well as attempting to find</span>
<a href="#l4.1262"></a><span id="l4.1262" class="difflineplus">+ *   a charset parameter in the Content-Type header.</span>
<a href="#l4.1263"></a><span id="l4.1263" class="difflineplus">+ *</span>
<a href="#l4.1264"></a><span id="l4.1264" class="difflineplus">+ *   If the force-charset option is false, the charset is guessed first using</span>
<a href="#l4.1265"></a><span id="l4.1265" class="difflineplus">+ *   the Content-Type header's charset parameter, falling back to the charset</span>
<a href="#l4.1266"></a><span id="l4.1266" class="difflineplus">+ *   option if it is present. If the force-charset option is true, the charset</span>
<a href="#l4.1267"></a><span id="l4.1267" class="difflineplus">+ *   is initially set to the charset option. This initial guessed value can be</span>
<a href="#l4.1268"></a><span id="l4.1268" class="difflineplus">+ *   overridden at any time by simply setting the field on this object.</span>
<a href="#l4.1269"></a><span id="l4.1269" class="difflineplus">+ *</span>
<a href="#l4.1270"></a><span id="l4.1270" class="difflineplus">+ *   The charset is better reflected as a parameter of the body rather than the</span>
<a href="#l4.1271"></a><span id="l4.1271" class="difflineplus">+ *   headers; this is ultimately the charset parameter that will be used if a</span>
<a href="#l4.1272"></a><span id="l4.1272" class="difflineplus">+ *   body part is being converted to a Unicode strformat. Headers are converted</span>
<a href="#l4.1273"></a><span id="l4.1273" class="difflineplus">+ *   using headerparser.convert8BitHeader, and this field is used as the</span>
<a href="#l4.1274"></a><span id="l4.1274" class="difflineplus">+ *   fallbackCharset parameter, which will always to attempt to decode as UTF-8</span>
<a href="#l4.1275"></a><span id="l4.1275" class="difflineplus">+ *   first (in accordance with RFC 6532) and will refuse to decode as UTF-16 or</span>
<a href="#l4.1276"></a><span id="l4.1276" class="difflineplus">+ *   UTF-32, as ASCII is not a subset of those charsets.</span>
<a href="#l4.1277"></a><span id="l4.1277" class="difflineplus">+ *</span>
<a href="#l4.1278"></a><span id="l4.1278" class="difflineplus">+ * - rawHeaderText: This read-only field contains the original header text from</span>
<a href="#l4.1279"></a><span id="l4.1279" class="difflineplus">+ *   which headers were parsed, preserving case and whitespace (including</span>
<a href="#l4.1280"></a><span id="l4.1280" class="difflineplus">+ *   alternate line endings instead of CRLF) exactly. If the header text begins</span>
<a href="#l4.1281"></a><span id="l4.1281" class="difflineplus">+ *   with the mbox delimiter (i.e., a line that begins with &quot;From &quot;), then that</span>
<a href="#l4.1282"></a><span id="l4.1282" class="difflineplus">+ *   is excluded from the rawHeaderText value and is not reflected anywhere in</span>
<a href="#l4.1283"></a><span id="l4.1283" class="difflineplus">+ *   this object.</span>
<a href="#l4.1284"></a><span id="l4.1284" class="difflineplus">+ *</span>
<a href="#l4.1285"></a><span id="l4.1285" class="difflineplus">+ * - contentType: This field contains the structured representation of the</span>
<a href="#l4.1286"></a><span id="l4.1286" class="difflineplus">+ *   Content-Type header, if it is present. If it is not present, it is set to</span>
<a href="#l4.1287"></a><span id="l4.1287" class="difflineplus">+ *   the structured representation of the default Content-Type for a part (as</span>
<a href="#l4.1288"></a><span id="l4.1288" class="difflineplus">+ *   this data is not easily guessed given only MIME tree events).</span>
<a href="#l4.1289"></a><span id="l4.1289" class="difflineplus">+ *</span>
<a href="#l4.1290"></a><span id="l4.1290" class="difflineplus">+ * The constructor for these objects is not externally exported, and thus they</span>
<a href="#l4.1291"></a><span id="l4.1291" class="difflineplus">+ * can only be created via MimeParser.</span>
<a href="#l4.1292"></a><span id="l4.1292" class="difflineplus">+ *</span>
<a href="#l4.1293"></a><span id="l4.1293" class="difflineplus">+ * @param rawHeaderText {BinaryString} The contents of the MIME headers to be</span>
<a href="#l4.1294"></a><span id="l4.1294" class="difflineplus">+ *                                     parsed.</span>
<a href="#l4.1295"></a><span id="l4.1295" class="difflineplus">+ * @param options    {Object}          Options for the header parser.</span>
<a href="#l4.1296"></a><span id="l4.1296" class="difflineplus">+ *   @param options.stripcontinuations {Boolean} If true, elide CRLFs from the</span>
<a href="#l4.1297"></a><span id="l4.1297" class="difflineplus">+ *                                               raw header output.</span>
<a href="#l4.1298"></a><span id="l4.1298" class="difflineplus">+ */</span>
<a href="#l4.1299"></a><span id="l4.1299" class="difflineplus">+function StructuredHeaders(rawHeaderText, options) {</span>
<a href="#l4.1300"></a><span id="l4.1300" class="difflineplus">+  // An individual header is terminated by a CRLF, except if the CRLF is</span>
<a href="#l4.1301"></a><span id="l4.1301" class="difflineplus">+  // followed by a SP or TAB. Use negative lookahead to capture the latter case,</span>
<a href="#l4.1302"></a><span id="l4.1302" class="difflineplus">+  // and don't capture the strings or else split results get nasty.</span>
<a href="#l4.1303"></a><span id="l4.1303" class="difflineplus">+  let values = rawHeaderText.split(/(?:\r\n|\n)(?![ \t])|\r(?![ \t\n])/);</span>
<a href="#l4.1304"></a><span id="l4.1304" class="difflineplus">+</span>
<a href="#l4.1305"></a><span id="l4.1305" class="difflineplus">+  // Ignore the first &quot;header&quot; if it begins with an mbox delimiter</span>
<a href="#l4.1306"></a><span id="l4.1306" class="difflineplus">+  if (values.length &gt; 0 &amp;&amp; values[0].substring(0, 5) == &quot;From &quot;) {</span>
<a href="#l4.1307"></a><span id="l4.1307" class="difflineplus">+    values.shift();</span>
<a href="#l4.1308"></a><span id="l4.1308" class="difflineplus">+    // Elide the mbox delimiter from this._headerData</span>
<a href="#l4.1309"></a><span id="l4.1309" class="difflineplus">+    if (values.length == 0)</span>
<a href="#l4.1310"></a><span id="l4.1310" class="difflineplus">+      rawHeaderText = '';</span>
<a href="#l4.1311"></a><span id="l4.1311" class="difflineplus">+    else</span>
<a href="#l4.1312"></a><span id="l4.1312" class="difflineplus">+      rawHeaderText = rawHeaderText.substring(rawHeaderText.indexOf(values[0]));</span>
<a href="#l4.1313"></a><span id="l4.1313" class="difflineplus">+  }</span>
<a href="#l4.1314"></a><span id="l4.1314" class="difflineplus">+</span>
<a href="#l4.1315"></a><span id="l4.1315" class="difflineplus">+  let headers = new Map();</span>
<a href="#l4.1316"></a><span id="l4.1316" class="difflineplus">+  for (let i = 0; i &lt; values.length; i++) {</span>
<a href="#l4.1317"></a><span id="l4.1317" class="difflineplus">+    // Look for a colon. If it's not present, this header line is malformed,</span>
<a href="#l4.1318"></a><span id="l4.1318" class="difflineplus">+    // perhaps by premature EOF or similar.</span>
<a href="#l4.1319"></a><span id="l4.1319" class="difflineplus">+    let colon = values[i].indexOf(&quot;:&quot;);</span>
<a href="#l4.1320"></a><span id="l4.1320" class="difflineplus">+    if (colon &gt;= 0) {</span>
<a href="#l4.1321"></a><span id="l4.1321" class="difflineplus">+      var header = values[i].substring(0, colon);</span>
<a href="#l4.1322"></a><span id="l4.1322" class="difflineplus">+      var val = values[i].substring(colon + 1).trim();</span>
<a href="#l4.1323"></a><span id="l4.1323" class="difflineplus">+      if (options.stripcontinuations)</span>
<a href="#l4.1324"></a><span id="l4.1324" class="difflineplus">+        val = val.replace(/[\r\n]/g, '');</span>
<a href="#l4.1325"></a><span id="l4.1325" class="difflineplus">+    } else {</span>
<a href="#l4.1326"></a><span id="l4.1326" class="difflineplus">+      var header = values[i];</span>
<a href="#l4.1327"></a><span id="l4.1327" class="difflineplus">+      var val = '';</span>
<a href="#l4.1328"></a><span id="l4.1328" class="difflineplus">+    }</span>
<a href="#l4.1329"></a><span id="l4.1329" class="difflineplus">+</span>
<a href="#l4.1330"></a><span id="l4.1330" class="difflineplus">+    // Canonicalize the header in lower-case form.</span>
<a href="#l4.1331"></a><span id="l4.1331" class="difflineplus">+    header = header.trim().toLowerCase();</span>
<a href="#l4.1332"></a><span id="l4.1332" class="difflineplus">+    // Omit &quot;empty&quot; headers</span>
<a href="#l4.1333"></a><span id="l4.1333" class="difflineplus">+    if (header == '')</span>
<a href="#l4.1334"></a><span id="l4.1334" class="difflineplus">+      continue;</span>
<a href="#l4.1335"></a><span id="l4.1335" class="difflineplus">+</span>
<a href="#l4.1336"></a><span id="l4.1336" class="difflineplus">+    // We keep an array of values for each header, since a given header may be</span>
<a href="#l4.1337"></a><span id="l4.1337" class="difflineplus">+    // repeated multiple times.</span>
<a href="#l4.1338"></a><span id="l4.1338" class="difflineplus">+    if (headers.has(header)) {</span>
<a href="#l4.1339"></a><span id="l4.1339" class="difflineplus">+      headers.get(header).push(val);</span>
<a href="#l4.1340"></a><span id="l4.1340" class="difflineplus">+    } else {</span>
<a href="#l4.1341"></a><span id="l4.1341" class="difflineplus">+      headers.set(header, [val]);</span>
<a href="#l4.1342"></a><span id="l4.1342" class="difflineplus">+    }</span>
<a href="#l4.1343"></a><span id="l4.1343" class="difflineplus">+  }</span>
<a href="#l4.1344"></a><span id="l4.1344" class="difflineplus">+</span>
<a href="#l4.1345"></a><span id="l4.1345" class="difflineplus">+  /**</span>
<a href="#l4.1346"></a><span id="l4.1346" class="difflineplus">+   * A map of header names to arrays of raw values found in this header block.</span>
<a href="#l4.1347"></a><span id="l4.1347" class="difflineplus">+   * @private</span>
<a href="#l4.1348"></a><span id="l4.1348" class="difflineplus">+   */</span>
<a href="#l4.1349"></a><span id="l4.1349" class="difflineplus">+  this._rawHeaders = headers;</span>
<a href="#l4.1350"></a><span id="l4.1350" class="difflineplus">+  /**</span>
<a href="#l4.1351"></a><span id="l4.1351" class="difflineplus">+   * Cached results of structured header parsing.</span>
<a href="#l4.1352"></a><span id="l4.1352" class="difflineplus">+   * @private</span>
<a href="#l4.1353"></a><span id="l4.1353" class="difflineplus">+   */</span>
<a href="#l4.1354"></a><span id="l4.1354" class="difflineplus">+  this._cachedHeaders = new Map();</span>
<a href="#l4.1355"></a><span id="l4.1355" class="difflineplus">+  Object.defineProperty(this, &quot;rawHeaderText&quot;,</span>
<a href="#l4.1356"></a><span id="l4.1356" class="difflineplus">+    {get: function () { return rawHeaderText; }});</span>
<a href="#l4.1357"></a><span id="l4.1357" class="difflineplus">+  Object.defineProperty(this, &quot;size&quot;,</span>
<a href="#l4.1358"></a><span id="l4.1358" class="difflineplus">+    {get: function () { return this._rawHeaders.size; }});</span>
<a href="#l4.1359"></a><span id="l4.1359" class="difflineplus">+  Object.defineProperty(this, &quot;charset&quot;, {</span>
<a href="#l4.1360"></a><span id="l4.1360" class="difflineplus">+    get: function () { return this._charset; },</span>
<a href="#l4.1361"></a><span id="l4.1361" class="difflineplus">+    set: function (value) {</span>
<a href="#l4.1362"></a><span id="l4.1362" class="difflineplus">+      this._charset = value;</span>
<a href="#l4.1363"></a><span id="l4.1363" class="difflineplus">+      // Clear the cached headers, since this could change their values</span>
<a href="#l4.1364"></a><span id="l4.1364" class="difflineplus">+      this._cachedHeaders.clear();</span>
<a href="#l4.1365"></a><span id="l4.1365" class="difflineplus">+    }</span>
<a href="#l4.1366"></a><span id="l4.1366" class="difflineplus">+  });</span>
<a href="#l4.1367"></a><span id="l4.1367" class="difflineplus">+</span>
<a href="#l4.1368"></a><span id="l4.1368" class="difflineplus">+  // Default to the charset, until the message parser overrides us.</span>
<a href="#l4.1369"></a><span id="l4.1369" class="difflineplus">+  if ('charset' in options)</span>
<a href="#l4.1370"></a><span id="l4.1370" class="difflineplus">+    this._charset = options.charset;</span>
<a href="#l4.1371"></a><span id="l4.1371" class="difflineplus">+  else</span>
<a href="#l4.1372"></a><span id="l4.1372" class="difflineplus">+    this._charset = null;</span>
<a href="#l4.1373"></a><span id="l4.1373" class="difflineplus">+</span>
<a href="#l4.1374"></a><span id="l4.1374" class="difflineplus">+  // If we have a Content-Type header, set contentType to return the structured</span>
<a href="#l4.1375"></a><span id="l4.1375" class="difflineplus">+  // representation. We don't set the value off the bat, since we want to let</span>
<a href="#l4.1376"></a><span id="l4.1376" class="difflineplus">+  // someone who changes the charset affect the values of 8-bit parameters.</span>
<a href="#l4.1377"></a><span id="l4.1377" class="difflineplus">+  Object.defineProperty(this, &quot;contentType&quot;, {</span>
<a href="#l4.1378"></a><span id="l4.1378" class="difflineplus">+    configurable: true,</span>
<a href="#l4.1379"></a><span id="l4.1379" class="difflineplus">+    get: function () { return this.get('Content-Type'); }</span>
<a href="#l4.1380"></a><span id="l4.1380" class="difflineplus">+  });</span>
<a href="#l4.1381"></a><span id="l4.1381" class="difflineplus">+}</span>
<a href="#l4.1382"></a><span id="l4.1382" class="difflineplus">+</span>
<a href="#l4.1383"></a><span id="l4.1383" class="difflineplus">+/**</span>
<a href="#l4.1384"></a><span id="l4.1384" class="difflineplus">+ * Get a raw header.</span>
<a href="#l4.1385"></a><span id="l4.1385" class="difflineplus">+ *</span>
<a href="#l4.1386"></a><span id="l4.1386" class="difflineplus">+ * Raw headers are an array of the header values, listed in order that they were</span>
<a href="#l4.1387"></a><span id="l4.1387" class="difflineplus">+ * specified in the header block, and without any attempt to convert charsets or</span>
<a href="#l4.1388"></a><span id="l4.1388" class="difflineplus">+ * apply RFC 2047 decoding. For example, in the following message (where the</span>
<a href="#l4.1389"></a><span id="l4.1389" class="difflineplus">+ * &lt;XX&gt; is meant to represent binary-octets):</span>
<a href="#l4.1390"></a><span id="l4.1390" class="difflineplus">+ *</span>
<a href="#l4.1391"></a><span id="l4.1391" class="difflineplus">+ * X-Header: Value A</span>
<a href="#l4.1392"></a><span id="l4.1392" class="difflineplus">+ * X-Header: V&lt;C3&gt;&lt;A5&gt;lue B</span>
<a href="#l4.1393"></a><span id="l4.1393" class="difflineplus">+ * Header2: Q</span>
<a href="#l4.1394"></a><span id="l4.1394" class="difflineplus">+ *</span>
<a href="#l4.1395"></a><span id="l4.1395" class="difflineplus">+ * the result of calling getRawHeader('X-Header') or getRawHeader('x-header')</span>
<a href="#l4.1396"></a><span id="l4.1396" class="difflineplus">+ * would be ['Value A', 'V\xC3\xA5lue B'] and the result of</span>
<a href="#l4.1397"></a><span id="l4.1397" class="difflineplus">+ * getRawHeader('Header2') would be ['Q'].</span>
<a href="#l4.1398"></a><span id="l4.1398" class="difflineplus">+ *</span>
<a href="#l4.1399"></a><span id="l4.1399" class="difflineplus">+ * @param headerName {String} The header name for which to get header values.</span>
<a href="#l4.1400"></a><span id="l4.1400" class="difflineplus">+ * @returns {BinaryString[]} The raw header values (with no charset conversion</span>
<a href="#l4.1401"></a><span id="l4.1401" class="difflineplus">+ *                           applied).</span>
<a href="#l4.1402"></a><span id="l4.1402" class="difflineplus">+ */</span>
<a href="#l4.1403"></a><span id="l4.1403" class="difflineplus">+StructuredHeaders.prototype.getRawHeader = function (headerName) {</span>
<a href="#l4.1404"></a><span id="l4.1404" class="difflineplus">+  return this._rawHeaders.get(headerName.toLowerCase());</span>
<a href="#l4.1405"></a><span id="l4.1405" class="difflineplus">+};</span>
<a href="#l4.1406"></a><span id="l4.1406" class="difflineplus">+</span>
<a href="#l4.1407"></a><span id="l4.1407" class="difflineplus">+/**</span>
<a href="#l4.1408"></a><span id="l4.1408" class="difflineplus">+ * Retrieve a structured version of the header.</span>
<a href="#l4.1409"></a><span id="l4.1409" class="difflineplus">+ *</span>
<a href="#l4.1410"></a><span id="l4.1410" class="difflineplus">+ * If there is a registered structured decoder (registration happens via</span>
<a href="#l4.1411"></a><span id="l4.1411" class="difflineplus">+ * headerparser.addStructuredDecoder), then the result of calling that decoder</span>
<a href="#l4.1412"></a><span id="l4.1412" class="difflineplus">+ * on the charset-corrected version of the header is returned. Otherwise, the</span>
<a href="#l4.1413"></a><span id="l4.1413" class="difflineplus">+ * values are charset-corrected and RFC 2047 decoding is applied as if the</span>
<a href="#l4.1414"></a><span id="l4.1414" class="difflineplus">+ * header were an unstructured header.</span>
<a href="#l4.1415"></a><span id="l4.1415" class="difflineplus">+ *</span>
<a href="#l4.1416"></a><span id="l4.1416" class="difflineplus">+ * A substantial set of headers have pre-registed structured decoders, which, in</span>
<a href="#l4.1417"></a><span id="l4.1417" class="difflineplus">+ * some cases, are unable to be overridden due to their importance in the</span>
<a href="#l4.1418"></a><span id="l4.1418" class="difflineplus">+ * functioning of the parser code itself.</span>
<a href="#l4.1419"></a><span id="l4.1419" class="difflineplus">+ *</span>
<a href="#l4.1420"></a><span id="l4.1420" class="difflineplus">+ * @param headerName {String} The header name for which to get the header value.</span>
<a href="#l4.1421"></a><span id="l4.1421" class="difflineplus">+ * @returns The structured header value of the output.</span>
<a href="#l4.1422"></a><span id="l4.1422" class="difflineplus">+ */</span>
<a href="#l4.1423"></a><span id="l4.1423" class="difflineplus">+StructuredHeaders.prototype.get = function (headerName) {</span>
<a href="#l4.1424"></a><span id="l4.1424" class="difflineplus">+  // Normalize the header name to lower case</span>
<a href="#l4.1425"></a><span id="l4.1425" class="difflineplus">+  headerName = headerName.toLowerCase();</span>
<a href="#l4.1426"></a><span id="l4.1426" class="difflineplus">+</span>
<a href="#l4.1427"></a><span id="l4.1427" class="difflineplus">+  // First, check the cache for the header value</span>
<a href="#l4.1428"></a><span id="l4.1428" class="difflineplus">+  if (this._cachedHeaders.has(headerName))</span>
<a href="#l4.1429"></a><span id="l4.1429" class="difflineplus">+    return this._cachedHeaders.get(headerName);</span>
<a href="#l4.1430"></a><span id="l4.1430" class="difflineplus">+</span>
<a href="#l4.1431"></a><span id="l4.1431" class="difflineplus">+  // Not cached? Grab it [propagating lack of header to caller]</span>
<a href="#l4.1432"></a><span id="l4.1432" class="difflineplus">+  let headerValue = this._rawHeaders.get(headerName);</span>
<a href="#l4.1433"></a><span id="l4.1433" class="difflineplus">+  if (headerValue === undefined)</span>
<a href="#l4.1434"></a><span id="l4.1434" class="difflineplus">+    return headerValue;</span>
<a href="#l4.1435"></a><span id="l4.1435" class="difflineplus">+</span>
<a href="#l4.1436"></a><span id="l4.1436" class="difflineplus">+  // Convert the header to Unicode</span>
<a href="#l4.1437"></a><span id="l4.1437" class="difflineplus">+  let charset = this.charset;</span>
<a href="#l4.1438"></a><span id="l4.1438" class="difflineplus">+  headerValue = headerValue.map(function (value) {</span>
<a href="#l4.1439"></a><span id="l4.1439" class="difflineplus">+    return headerparser.convert8BitHeader(value, charset);</span>
<a href="#l4.1440"></a><span id="l4.1440" class="difflineplus">+  });</span>
<a href="#l4.1441"></a><span id="l4.1441" class="difflineplus">+</span>
<a href="#l4.1442"></a><span id="l4.1442" class="difflineplus">+  // If there is a structured decoder, use that; otherwise, assume that the</span>
<a href="#l4.1443"></a><span id="l4.1443" class="difflineplus">+  // header is unstructured and only do RFC 2047 conversion</span>
<a href="#l4.1444"></a><span id="l4.1444" class="difflineplus">+  let structured;</span>
<a href="#l4.1445"></a><span id="l4.1445" class="difflineplus">+  try {</span>
<a href="#l4.1446"></a><span id="l4.1446" class="difflineplus">+    structured = headerparser.parseStructuredHeader(headerName, headerValue);</span>
<a href="#l4.1447"></a><span id="l4.1447" class="difflineplus">+  } catch (e) {</span>
<a href="#l4.1448"></a><span id="l4.1448" class="difflineplus">+    structured = headerValue.map(function (value) {</span>
<a href="#l4.1449"></a><span id="l4.1449" class="difflineplus">+      return headerparser.decodeRFC2047Words(value);</span>
<a href="#l4.1450"></a><span id="l4.1450" class="difflineplus">+    });</span>
<a href="#l4.1451"></a><span id="l4.1451" class="difflineplus">+  }</span>
<a href="#l4.1452"></a><span id="l4.1452" class="difflineplus">+</span>
<a href="#l4.1453"></a><span id="l4.1453" class="difflineplus">+  // Cache the result and return it</span>
<a href="#l4.1454"></a><span id="l4.1454" class="difflineplus">+  this._cachedHeaders.set(headerName, structured);</span>
<a href="#l4.1455"></a><span id="l4.1455" class="difflineplus">+  return structured;</span>
<a href="#l4.1456"></a><span id="l4.1456" class="difflineplus">+};</span>
<a href="#l4.1457"></a><span id="l4.1457" class="difflineplus">+</span>
<a href="#l4.1458"></a><span id="l4.1458" class="difflineplus">+/**</span>
<a href="#l4.1459"></a><span id="l4.1459" class="difflineplus">+ * Check if the message has the given header.</span>
<a href="#l4.1460"></a><span id="l4.1460" class="difflineplus">+ *</span>
<a href="#l4.1461"></a><span id="l4.1461" class="difflineplus">+ * @param headerName {String} The header name for which to get the header value.</span>
<a href="#l4.1462"></a><span id="l4.1462" class="difflineplus">+ * @returns {Boolean} True if the header is present in this header block.</span>
<a href="#l4.1463"></a><span id="l4.1463" class="difflineplus">+ */</span>
<a href="#l4.1464"></a><span id="l4.1464" class="difflineplus">+StructuredHeaders.prototype.has = function (headerName) {</span>
<a href="#l4.1465"></a><span id="l4.1465" class="difflineplus">+  // Check for presence in the raw headers instead of cached headers.</span>
<a href="#l4.1466"></a><span id="l4.1466" class="difflineplus">+  return this._rawHeaders.has(headerName.toLowerCase());</span>
<a href="#l4.1467"></a><span id="l4.1467" class="difflineplus">+};</span>
<a href="#l4.1468"></a><span id="l4.1468" class="difflineplus">+</span>
<a href="#l4.1469"></a><span id="l4.1469" class="difflineplus">+// Make a custom iterator. Presently, support for Symbol isn't yet present in</span>
<a href="#l4.1470"></a><span id="l4.1470" class="difflineplus">+// SpiderMonkey (or V8 for that matter), so type-pun the name for now.</span>
<a href="#l4.1471"></a><span id="l4.1471" class="difflineplus">+if (typeof Symbol === &quot;undefined&quot;) {</span>
<a href="#l4.1472"></a><span id="l4.1472" class="difflineplus">+  var Symbol = {iterator: &quot;@@iterator&quot;};</span>
<a href="#l4.1473"></a><span id="l4.1473" class="difflineplus">+}</span>
<a href="#l4.1474"></a><span id="l4.1474" class="difflineplus">+</span>
<a href="#l4.1475"></a><span id="l4.1475" class="difflineplus">+/**</span>
<a href="#l4.1476"></a><span id="l4.1476" class="difflineplus">+ * An equivalent of Map.@@iterator, applied to the structured header</span>
<a href="#l4.1477"></a><span id="l4.1477" class="difflineplus">+ * representations. This is the function that makes</span>
<a href="#l4.1478"></a><span id="l4.1478" class="difflineplus">+ * for (let [header, value] of headers) work properly.</span>
<a href="#l4.1479"></a><span id="l4.1479" class="difflineplus">+ */</span>
<a href="#l4.1480"></a><span id="l4.1480" class="difflineplus">+StructuredHeaders.prototype[Symbol.iterator] = function*() {</span>
<a href="#l4.1481"></a><span id="l4.1481" class="difflineplus">+  // Iterate over all the raw headers, and use the cached headers to retrieve</span>
<a href="#l4.1482"></a><span id="l4.1482" class="difflineplus">+  // them.</span>
<a href="#l4.1483"></a><span id="l4.1483" class="difflineplus">+  for (let headerName of this.keys()) {</span>
<a href="#l4.1484"></a><span id="l4.1484" class="difflineplus">+    yield [headerName, this.get(headerName)];</span>
<a href="#l4.1485"></a><span id="l4.1485" class="difflineplus">+  }</span>
<a href="#l4.1486"></a><span id="l4.1486" class="difflineplus">+};</span>
<a href="#l4.1487"></a><span id="l4.1487" class="difflineplus">+</span>
<a href="#l4.1488"></a><span id="l4.1488" class="difflineplus">+/**</span>
<a href="#l4.1489"></a><span id="l4.1489" class="difflineplus">+ * An equivalent of Map.forEach, applied to the structured header</span>
<a href="#l4.1490"></a><span id="l4.1490" class="difflineplus">+ * representations.</span>
<a href="#l4.1491"></a><span id="l4.1491" class="difflineplus">+ *</span>
<a href="#l4.1492"></a><span id="l4.1492" class="difflineplus">+ * @param callback {Function(value, name, headers)} The callback to call for</span>
<a href="#l4.1493"></a><span id="l4.1493" class="difflineplus">+ *                                                  each header/value combo.</span>
<a href="#l4.1494"></a><span id="l4.1494" class="difflineplus">+ * @param thisarg  {Object}                         The parameter that will be</span>
<a href="#l4.1495"></a><span id="l4.1495" class="difflineplus">+ *                                                  the |this| of the callback.</span>
<a href="#l4.1496"></a><span id="l4.1496" class="difflineplus">+ */</span>
<a href="#l4.1497"></a><span id="l4.1497" class="difflineplus">+StructuredHeaders.prototype.forEach = function (callback, thisarg) {</span>
<a href="#l4.1498"></a><span id="l4.1498" class="difflineplus">+  for (let [header, value] of this) {</span>
<a href="#l4.1499"></a><span id="l4.1499" class="difflineplus">+    callback.call(thisarg, value, header, this);</span>
<a href="#l4.1500"></a><span id="l4.1500" class="difflineplus">+  }</span>
<a href="#l4.1501"></a><span id="l4.1501" class="difflineplus">+};</span>
<a href="#l4.1502"></a><span id="l4.1502" class="difflineplus">+</span>
<a href="#l4.1503"></a><span id="l4.1503" class="difflineplus">+/**</span>
<a href="#l4.1504"></a><span id="l4.1504" class="difflineplus">+ * An equivalent of Map.entries, applied to the structured header</span>
<a href="#l4.1505"></a><span id="l4.1505" class="difflineplus">+ * representations.</span>
<a href="#l4.1506"></a><span id="l4.1506" class="difflineplus">+ */</span>
<a href="#l4.1507"></a><span id="l4.1507" class="difflineplus">+StructuredHeaders.prototype.entries =</span>
<a href="#l4.1508"></a><span id="l4.1508" class="difflineplus">+  StructuredHeaders.prototype[Symbol.iterator];</span>
<a href="#l4.1509"></a><span id="l4.1509" class="difflineplus">+</span>
<a href="#l4.1510"></a><span id="l4.1510" class="difflineplus">+/// This function maps lower case names to a pseudo-preferred spelling.</span>
<a href="#l4.1511"></a><span id="l4.1511" class="difflineplus">+function capitalize(headerName) {</span>
<a href="#l4.1512"></a><span id="l4.1512" class="difflineplus">+  return headerName.replace(/\b[a-z]/g, function (match) {</span>
<a href="#l4.1513"></a><span id="l4.1513" class="difflineplus">+    return match.toUpperCase();</span>
<a href="#l4.1514"></a><span id="l4.1514" class="difflineplus">+  });</span>
<a href="#l4.1515"></a><span id="l4.1515" class="difflineplus">+}</span>
<a href="#l4.1516"></a><span id="l4.1516" class="difflineplus">+</span>
<a href="#l4.1517"></a><span id="l4.1517" class="difflineplus">+/**</span>
<a href="#l4.1518"></a><span id="l4.1518" class="difflineplus">+ * An equivalent of Map.keys, applied to the structured header representations.</span>
<a href="#l4.1519"></a><span id="l4.1519" class="difflineplus">+ */</span>
<a href="#l4.1520"></a><span id="l4.1520" class="difflineplus">+StructuredHeaders.prototype.keys = function*() {</span>
<a href="#l4.1521"></a><span id="l4.1521" class="difflineplus">+  for (let name of this._rawHeaders.keys()) {</span>
<a href="#l4.1522"></a><span id="l4.1522" class="difflineplus">+    yield spellings.get(name) || capitalize(name);</span>
<a href="#l4.1523"></a><span id="l4.1523" class="difflineplus">+  }</span>
<a href="#l4.1524"></a><span id="l4.1524" class="difflineplus">+};</span>
<a href="#l4.1525"></a><span id="l4.1525" class="difflineplus">+</span>
<a href="#l4.1526"></a><span id="l4.1526" class="difflineplus">+/**</span>
<a href="#l4.1527"></a><span id="l4.1527" class="difflineplus">+ * An equivalent of Map.values, applied to the structured header</span>
<a href="#l4.1528"></a><span id="l4.1528" class="difflineplus">+ * representations.</span>
<a href="#l4.1529"></a><span id="l4.1529" class="difflineplus">+ */</span>
<a href="#l4.1530"></a><span id="l4.1530" class="difflineplus">+StructuredHeaders.prototype.values = function* () {</span>
<a href="#l4.1531"></a><span id="l4.1531" class="difflineplus">+  for (let [, value] of this) {</span>
<a href="#l4.1532"></a><span id="l4.1532" class="difflineplus">+    yield value;</span>
<a href="#l4.1533"></a><span id="l4.1533" class="difflineplus">+  }</span>
<a href="#l4.1534"></a><span id="l4.1534" class="difflineplus">+};</span>
<a href="#l4.1535"></a><span id="l4.1535" class="difflineplus">+</span>
<a href="#l4.1536"></a><span id="l4.1536" class="difflineplus">+</span>
<a href="#l4.1537"></a><span id="l4.1537"> /**</span>
<a href="#l4.1538"></a><span id="l4.1538">  * A MIME parser.</span>
<a href="#l4.1539"></a><span id="l4.1539">  *</span>
<a href="#l4.1540"></a><span id="l4.1540">  * The inputs to the constructor consist of a callback object which receives</span>
<a href="#l4.1541"></a><span id="l4.1541">  * information about the output data and an optional object containing the</span>
<a href="#l4.1542"></a><span id="l4.1542">  * settings for the parser.</span>
<a href="#l4.1543"></a><span id="l4.1543">  *</span>
<a href="#l4.1544"></a><span id="l4.1544">  * The first parameter, emitter, is an object which contains several callbacks.</span>
<a href="#l4.1545"></a><span id="l4.1545" class="difflineat">@@ -64,22 +1537,18 @@</span>
<a href="#l4.1546"></a><span id="l4.1546">  *      Called when the stream to be parsed has started delivering data. This</span>
<a href="#l4.1547"></a><span id="l4.1547">  *      will be called exactly once, before any other call.</span>
<a href="#l4.1548"></a><span id="l4.1548">  *   endMessage()</span>
<a href="#l4.1549"></a><span id="l4.1549">  *      Called after all data has been delivered and the message parsing has</span>
<a href="#l4.1550"></a><span id="l4.1550">  *      been completed. This will be called exactly once, after any other call.</span>
<a href="#l4.1551"></a><span id="l4.1551">  *   startPart(string partNum, object headers)</span>
<a href="#l4.1552"></a><span id="l4.1552">  *      Called after the headers for a body part (including the top-level</span>
<a href="#l4.1553"></a><span id="l4.1553">  *      message) have been parsed. The first parameter is the part number (see</span>
<a href="#l4.1554"></a><span id="l4.1554" class="difflineminus">- *      the discussion on part numbering). The second parameter is a JS Map</span>
<a href="#l4.1555"></a><span id="l4.1555" class="difflineminus">- *      object where the keys are lower-case header names and the values are</span>
<a href="#l4.1556"></a><span id="l4.1556" class="difflineminus">- *      arrays of strings of the header values with newlines stripped. In</span>
<a href="#l4.1557"></a><span id="l4.1557" class="difflineminus">- *      addition, the headers object also contains a property rawHeaderText</span>
<a href="#l4.1558"></a><span id="l4.1558" class="difflineminus">- *      whose value is the text of all MIME headers, with whitespace and case</span>
<a href="#l4.1559"></a><span id="l4.1559" class="difflineminus">- *      perfectly preserved.</span>
<a href="#l4.1560"></a><span id="l4.1560" class="difflineplus">+ *      the discussion on part numbering). The second parameter is an instance</span>
<a href="#l4.1561"></a><span id="l4.1561" class="difflineplus">+ *      of StructuredHeaders that represents all of the headers for the part.</span>
<a href="#l4.1562"></a><span id="l4.1562">  *   endPart(string partNum)</span>
<a href="#l4.1563"></a><span id="l4.1563">  *      Called after all of the data for a body part (including sub-parts) has</span>
<a href="#l4.1564"></a><span id="l4.1564">  *      been parsed. The first parameter is the part number.</span>
<a href="#l4.1565"></a><span id="l4.1565">  *   deliverPartData(string partNum, {string,typedarray} data)</span>
<a href="#l4.1566"></a><span id="l4.1566">  *      Called when some data for a body part has been delivered. The first</span>
<a href="#l4.1567"></a><span id="l4.1567">  *      parameter is the part number. The second parameter is the data which is</span>
<a href="#l4.1568"></a><span id="l4.1568">  *      being delivered; the exact type of this data depends on the options</span>
<a href="#l4.1569"></a><span id="l4.1569">  *      used. Note that data is only delivered for leaf body parts.</span>
<a href="#l4.1570"></a><span id="l4.1570" class="difflineat">@@ -90,51 +1559,69 @@</span>
<a href="#l4.1571"></a><span id="l4.1571">  *      Treat the message as starting at the given part number, so that no parts</span>
<a href="#l4.1572"></a><span id="l4.1572">  *      above &lt;string&gt; are returned.</span>
<a href="#l4.1573"></a><span id="l4.1573">  *    bodyformat: one of {none, raw, nodecode, decode} [default=nodecode]</span>
<a href="#l4.1574"></a><span id="l4.1574">  *      How to return the bodies of parts:</span>
<a href="#l4.1575"></a><span id="l4.1575">  *        none: no part data is returned</span>
<a href="#l4.1576"></a><span id="l4.1576">  *        raw: the body of the part is passed through raw</span>
<a href="#l4.1577"></a><span id="l4.1577">  *        nodecode: the body is passed through without decoding QP/Base64</span>
<a href="#l4.1578"></a><span id="l4.1578">  *        decode: quoted-printable and base64 are fully decoded</span>
<a href="#l4.1579"></a><span id="l4.1579" class="difflineplus">+ *    strformat: one of {binarystring, unicode, typedarray} [default=binarystring]</span>
<a href="#l4.1580"></a><span id="l4.1580" class="difflineplus">+ *      How to treat output strings:</span>
<a href="#l4.1581"></a><span id="l4.1581" class="difflineplus">+ *        binarystring: Data is a JS string with chars in the range [\x00-\xff]</span>
<a href="#l4.1582"></a><span id="l4.1582" class="difflineplus">+ *        unicode: Data for text parts is converted to UTF-16; data for other</span>
<a href="#l4.1583"></a><span id="l4.1583" class="difflineplus">+ *          parts is a typed array buffer, akin to typedarray.</span>
<a href="#l4.1584"></a><span id="l4.1584" class="difflineplus">+ *        typedarray: Data is a JS typed array buffer</span>
<a href="#l4.1585"></a><span id="l4.1585" class="difflineplus">+ *    charset: &lt;string&gt; [default=&quot;&quot;]</span>
<a href="#l4.1586"></a><span id="l4.1586" class="difflineplus">+ *      What charset to assume if no charset information is explicitly provided.</span>
<a href="#l4.1587"></a><span id="l4.1587" class="difflineplus">+ *      This only matters if strformat is unicode. See above note on charsets</span>
<a href="#l4.1588"></a><span id="l4.1588" class="difflineplus">+ *      for more details.</span>
<a href="#l4.1589"></a><span id="l4.1589" class="difflineplus">+ *    force-charset: &lt;boolean&gt; [default=false]</span>
<a href="#l4.1590"></a><span id="l4.1590" class="difflineplus">+ *      If true, this coerces all types to use the charset option, even if the</span>
<a href="#l4.1591"></a><span id="l4.1591" class="difflineplus">+ *      message specifies a different content-type.</span>
<a href="#l4.1592"></a><span id="l4.1592">  *    stripcontinuations: &lt;boolean&gt; [default=true]</span>
<a href="#l4.1593"></a><span id="l4.1593">  *      If true, then the newlines in headers are removed in the returned</span>
<a href="#l4.1594"></a><span id="l4.1594">  *      header objects.</span>
<a href="#l4.1595"></a><span id="l4.1595">  *    onerror: &lt;function(thrown error)&gt; [default = nop-function]</span>
<a href="#l4.1596"></a><span id="l4.1596">  *      An error function that is called if an emitter callback throws an error.</span>
<a href="#l4.1597"></a><span id="l4.1597">  *      By default, such errors are swallowed by the parser. If you want the</span>
<a href="#l4.1598"></a><span id="l4.1598">  *      parser itself to throw an error, rethrow it via the onerror function.</span>
<a href="#l4.1599"></a><span id="l4.1599">  */</span>
<a href="#l4.1600"></a><span id="l4.1600" class="difflineminus">-function Parser(emitter, options) {</span>
<a href="#l4.1601"></a><span id="l4.1601" class="difflineplus">+function MimeParser(emitter, options) {</span>
<a href="#l4.1602"></a><span id="l4.1602">   /// The actual emitter</span>
<a href="#l4.1603"></a><span id="l4.1603">   this._emitter = emitter;</span>
<a href="#l4.1604"></a><span id="l4.1604">   /// Options for the parser (those listed here are defaults)</span>
<a href="#l4.1605"></a><span id="l4.1605">   this._options = {</span>
<a href="#l4.1606"></a><span id="l4.1606">     pruneat: &quot;&quot;,</span>
<a href="#l4.1607"></a><span id="l4.1607">     bodyformat: &quot;nodecode&quot;,</span>
<a href="#l4.1608"></a><span id="l4.1608">     strformat: &quot;binarystring&quot;,</span>
<a href="#l4.1609"></a><span id="l4.1609">     stripcontinuations: true,</span>
<a href="#l4.1610"></a><span id="l4.1610" class="difflineplus">+    charset: &quot;&quot;,</span>
<a href="#l4.1611"></a><span id="l4.1611" class="difflineplus">+    &quot;force-charset&quot;: false,</span>
<a href="#l4.1612"></a><span id="l4.1612">     onerror: function swallow(error) {}</span>
<a href="#l4.1613"></a><span id="l4.1613">   };</span>
<a href="#l4.1614"></a><span id="l4.1614">   // Load the options as a copy here (prevents people from changing on the fly).</span>
<a href="#l4.1615"></a><span id="l4.1615">   if (options)</span>
<a href="#l4.1616"></a><span id="l4.1616">     for (var opt in options) {</span>
<a href="#l4.1617"></a><span id="l4.1617">       this._options[opt] = options[opt];</span>
<a href="#l4.1618"></a><span id="l4.1618">     }</span>
<a href="#l4.1619"></a><span id="l4.1619"> </span>
<a href="#l4.1620"></a><span id="l4.1620">   // Ensure that the error function is in fact a function</span>
<a href="#l4.1621"></a><span id="l4.1621">   if (typeof this._options.onerror != &quot;function&quot;)</span>
<a href="#l4.1622"></a><span id="l4.1622">     throw new Exception(&quot;onerror callback must be a function&quot;);</span>
<a href="#l4.1623"></a><span id="l4.1623"> </span>
<a href="#l4.1624"></a><span id="l4.1624">   // Reset the parser</span>
<a href="#l4.1625"></a><span id="l4.1625">   this.resetParser();</span>
<a href="#l4.1626"></a><span id="l4.1626"> }</span>
<a href="#l4.1627"></a><span id="l4.1627"> </span>
<a href="#l4.1628"></a><span id="l4.1628" class="difflineminus">-/// Resets the parser to read a new message.</span>
<a href="#l4.1629"></a><span id="l4.1629" class="difflineminus">-Parser.prototype.resetParser = function Parser_resetParser() {</span>
<a href="#l4.1630"></a><span id="l4.1630" class="difflineplus">+/**</span>
<a href="#l4.1631"></a><span id="l4.1631" class="difflineplus">+ * Resets the parser to read a new message. This method need not be called</span>
<a href="#l4.1632"></a><span id="l4.1632" class="difflineplus">+ * immediately after construction.</span>
<a href="#l4.1633"></a><span id="l4.1633" class="difflineplus">+ */</span>
<a href="#l4.1634"></a><span id="l4.1634" class="difflineplus">+MimeParser.prototype.resetParser = function () {</span>
<a href="#l4.1635"></a><span id="l4.1635">   /// Current parser state</span>
<a href="#l4.1636"></a><span id="l4.1636">   this._state = PARSING_HEADERS;</span>
<a href="#l4.1637"></a><span id="l4.1637">   /// Input data that needs to be held for buffer conditioning</span>
<a href="#l4.1638"></a><span id="l4.1638">   this._holdData = '';</span>
<a href="#l4.1639"></a><span id="l4.1639">   /// Complete collection of headers (also used to accumulate _headerData)</span>
<a href="#l4.1640"></a><span id="l4.1640">   this._headerData = '';</span>
<a href="#l4.1641"></a><span id="l4.1641">   /// Whether or not emitter.startMessage has been called</span>
<a href="#l4.1642"></a><span id="l4.1642">   this._triggeredCall = false;</span>
<a href="#l4.1643"></a><span id="l4.1643" class="difflineat">@@ -144,22 +1631,24 @@ Parser.prototype.resetParser = function </span>
<a href="#l4.1644"></a><span id="l4.1644">   /// Subparsing</span>
<a href="#l4.1645"></a><span id="l4.1645">   this._subparser = this._subPartNum = undefined;</span>
<a href="#l4.1646"></a><span id="l4.1646">   /// Data that has yet to be consumed by _convertData</span>
<a href="#l4.1647"></a><span id="l4.1647">   this._savedBuffer = '';</span>
<a href="#l4.1648"></a><span id="l4.1648">   /// Convert data</span>
<a href="#l4.1649"></a><span id="l4.1649">   this._convertData = undefined;</span>
<a href="#l4.1650"></a><span id="l4.1650">   /// String decoder</span>
<a href="#l4.1651"></a><span id="l4.1651">   this._decoder = undefined;</span>
<a href="#l4.1652"></a><span id="l4.1652" class="difflineminus">-}</span>
<a href="#l4.1653"></a><span id="l4.1653" class="difflineplus">+};</span>
<a href="#l4.1654"></a><span id="l4.1654"> </span>
<a href="#l4.1655"></a><span id="l4.1655"> /**</span>
<a href="#l4.1656"></a><span id="l4.1656">  * Deliver a buffer of data to the parser.</span>
<a href="#l4.1657"></a><span id="l4.1657" class="difflineplus">+ *</span>
<a href="#l4.1658"></a><span id="l4.1658" class="difflineplus">+ * @param buffer {BinaryString} The raw data to add to the message.</span>
<a href="#l4.1659"></a><span id="l4.1659">  */</span>
<a href="#l4.1660"></a><span id="l4.1660" class="difflineminus">-Parser.prototype.deliverData = function Parser_deliverData(buffer) {</span>
<a href="#l4.1661"></a><span id="l4.1661" class="difflineplus">+MimeParser.prototype.deliverData = function (buffer) {</span>
<a href="#l4.1662"></a><span id="l4.1662">   // In ideal circumstances, we'd like to parse the message all at once. In</span>
<a href="#l4.1663"></a><span id="l4.1663">   // reality, though, data will be coming to us in packets. To keep the amount</span>
<a href="#l4.1664"></a><span id="l4.1664">   // of saved state low, we want to make basic guarantees about how packets get</span>
<a href="#l4.1665"></a><span id="l4.1665">   // delivered. Our basic model is a twist on line-buffering, as the format of</span>
<a href="#l4.1666"></a><span id="l4.1666">   // MIME and messages make it hard to not do so: we can handle multiple lines</span>
<a href="#l4.1667"></a><span id="l4.1667">   // at once. To ensure this, we start by conditioning the packet by</span>
<a href="#l4.1668"></a><span id="l4.1668">   // withholding data to make sure that the internal deliveries have the</span>
<a href="#l4.1669"></a><span id="l4.1669">   // guarantees. This implies that we need to do the following steps:</span>
<a href="#l4.1670"></a><span id="l4.1670" class="difflineat">@@ -194,86 +1683,99 @@ Parser.prototype.deliverData = function </span>
<a href="#l4.1671"></a><span id="l4.1671">     this._callEmitter(&quot;startMessage&quot;);</span>
<a href="#l4.1672"></a><span id="l4.1672">     this._triggeredCall = true;</span>
<a href="#l4.1673"></a><span id="l4.1673">   }</span>
<a href="#l4.1674"></a><span id="l4.1674"> </span>
<a href="#l4.1675"></a><span id="l4.1675">   // Finally, send it the internal parser.</span>
<a href="#l4.1676"></a><span id="l4.1676">   this._dispatchData(&quot;&quot;, buffer, true);</span>
<a href="#l4.1677"></a><span id="l4.1677"> }</span>
<a href="#l4.1678"></a><span id="l4.1678"> </span>
<a href="#l4.1679"></a><span id="l4.1679" class="difflineminus">-/// This function returns [string that ends in CRLF, rest of string]</span>
<a href="#l4.1680"></a><span id="l4.1680" class="difflineplus">+/**</span>
<a href="#l4.1681"></a><span id="l4.1681" class="difflineplus">+ * Ensure that a set of data always ends in an end-of-line character.</span>
<a href="#l4.1682"></a><span id="l4.1682" class="difflineplus">+ *</span>
<a href="#l4.1683"></a><span id="l4.1683" class="difflineplus">+ * @param buffer {BinaryString} The data with no guarantees about where it ends.</span>
<a href="#l4.1684"></a><span id="l4.1684" class="difflineplus">+ * @returns {BinaryString[]} An array of 2 binary strings where the first string</span>
<a href="#l4.1685"></a><span id="l4.1685" class="difflineplus">+ *                           ends in a newline and the last string contains the</span>
<a href="#l4.1686"></a><span id="l4.1686" class="difflineplus">+ *                           text in buffer following the first string.</span>
<a href="#l4.1687"></a><span id="l4.1687" class="difflineplus">+ */</span>
<a href="#l4.1688"></a><span id="l4.1688"> function conditionToEndOnCRLF(buffer) {</span>
<a href="#l4.1689"></a><span id="l4.1689">   // Find the last occurrence of '\r' or '\n' to split the string. However, we</span>
<a href="#l4.1690"></a><span id="l4.1690">   // don't want to consider '\r' if it is the very last character, as we need</span>
<a href="#l4.1691"></a><span id="l4.1691">   // the next packet to tell if the '\r' is the beginning of a CRLF or a line</span>
<a href="#l4.1692"></a><span id="l4.1692">   // ending by itself.</span>
<a href="#l4.1693"></a><span id="l4.1693">   let lastCR = buffer.lastIndexOf('\r', buffer.length - 2);</span>
<a href="#l4.1694"></a><span id="l4.1694">   let lastLF = buffer.lastIndexOf('\n');</span>
<a href="#l4.1695"></a><span id="l4.1695">   let end = lastLF &gt; lastCR ? lastLF : lastCR;</span>
<a href="#l4.1696"></a><span id="l4.1696">   return [buffer.substring(0, end + 1), buffer.substring(end + 1)];</span>
<a href="#l4.1697"></a><span id="l4.1697" class="difflineminus">-}</span>
<a href="#l4.1698"></a><span id="l4.1698" class="difflineplus">+};</span>
<a href="#l4.1699"></a><span id="l4.1699"> </span>
<a href="#l4.1700"></a><span id="l4.1700"> /**</span>
<a href="#l4.1701"></a><span id="l4.1701">  * Tell the parser that all of the data has been delivered.</span>
<a href="#l4.1702"></a><span id="l4.1702">  *</span>
<a href="#l4.1703"></a><span id="l4.1703">  * This will flush all of the internal state of the parser.</span>
<a href="#l4.1704"></a><span id="l4.1704">  */</span>
<a href="#l4.1705"></a><span id="l4.1705" class="difflineminus">-Parser.prototype.deliverEOF = function Parser_deliverEOF() {</span>
<a href="#l4.1706"></a><span id="l4.1706" class="difflineplus">+MimeParser.prototype.deliverEOF = function () {</span>
<a href="#l4.1707"></a><span id="l4.1707">   // Start of input buffered too long? Call start message now.</span>
<a href="#l4.1708"></a><span id="l4.1708">   if (!this._triggeredCall) {</span>
<a href="#l4.1709"></a><span id="l4.1709">     this._triggeredCall = true;</span>
<a href="#l4.1710"></a><span id="l4.1710">     this._callEmitter(&quot;startMessage&quot;);</span>
<a href="#l4.1711"></a><span id="l4.1711">   }</span>
<a href="#l4.1712"></a><span id="l4.1712">   // Force a flush of all of the data.</span>
<a href="#l4.1713"></a><span id="l4.1713">   if (this._holdData)</span>
<a href="#l4.1714"></a><span id="l4.1714">     this._dispatchData(&quot;&quot;, this._holdData, true);</span>
<a href="#l4.1715"></a><span id="l4.1715">   this._dispatchEOF(&quot;&quot;);</span>
<a href="#l4.1716"></a><span id="l4.1716">   // Signal to the emitter that we're done.</span>
<a href="#l4.1717"></a><span id="l4.1717">   this._callEmitter(&quot;endMessage&quot;);</span>
<a href="#l4.1718"></a><span id="l4.1718" class="difflineminus">-}</span>
<a href="#l4.1719"></a><span id="l4.1719" class="difflineplus">+};</span>
<a href="#l4.1720"></a><span id="l4.1720"> </span>
<a href="#l4.1721"></a><span id="l4.1721"> /**</span>
<a href="#l4.1722"></a><span id="l4.1722">  * Calls a method on the emitter safely.</span>
<a href="#l4.1723"></a><span id="l4.1723">  *</span>
<a href="#l4.1724"></a><span id="l4.1724">  * This method ensures that errors in the emitter call won't cause the parser</span>
<a href="#l4.1725"></a><span id="l4.1725">  * to exit with an error, unless the user wants it to.</span>
<a href="#l4.1726"></a><span id="l4.1726" class="difflineplus">+ *</span>
<a href="#l4.1727"></a><span id="l4.1727" class="difflineplus">+ * @param funcname {String} The function name to call on the emitter.</span>
<a href="#l4.1728"></a><span id="l4.1728" class="difflineplus">+ * @param args...           Extra arguments to pass into the emitter callback.</span>
<a href="#l4.1729"></a><span id="l4.1729">  */</span>
<a href="#l4.1730"></a><span id="l4.1730" class="difflineminus">-Parser.prototype._callEmitter = function Parser_callEmitter(funcname) {</span>
<a href="#l4.1731"></a><span id="l4.1731" class="difflineplus">+MimeParser.prototype._callEmitter = function (funcname) {</span>
<a href="#l4.1732"></a><span id="l4.1732">   if (this._emitter &amp;&amp; funcname in this._emitter) {</span>
<a href="#l4.1733"></a><span id="l4.1733">     let args = Array.prototype.splice.call(arguments, 1);</span>
<a href="#l4.1734"></a><span id="l4.1734">     if (args.length &gt; 0 &amp;&amp; this._willIgnorePart(args[0])) {</span>
<a href="#l4.1735"></a><span id="l4.1735">       // partNum is always the first argument, so check to make sure that it</span>
<a href="#l4.1736"></a><span id="l4.1736">       // satisfies our emitter's pruneat requirement.</span>
<a href="#l4.1737"></a><span id="l4.1737">       return;</span>
<a href="#l4.1738"></a><span id="l4.1738">     }</span>
<a href="#l4.1739"></a><span id="l4.1739">     try {</span>
<a href="#l4.1740"></a><span id="l4.1740">       this._emitter[funcname].apply(this._emitter, args);</span>
<a href="#l4.1741"></a><span id="l4.1741">     } catch (e) {</span>
<a href="#l4.1742"></a><span id="l4.1742">       // We ensure that the onerror attribute in options is a function, so this</span>
<a href="#l4.1743"></a><span id="l4.1743">       // is always safe.</span>
<a href="#l4.1744"></a><span id="l4.1744">       this._options.onerror(e);</span>
<a href="#l4.1745"></a><span id="l4.1745">     }</span>
<a href="#l4.1746"></a><span id="l4.1746">   }</span>
<a href="#l4.1747"></a><span id="l4.1747" class="difflineminus">-}</span>
<a href="#l4.1748"></a><span id="l4.1748" class="difflineplus">+};</span>
<a href="#l4.1749"></a><span id="l4.1749"> </span>
<a href="#l4.1750"></a><span id="l4.1750"> /**</span>
<a href="#l4.1751"></a><span id="l4.1751">  * Helper function to decide if a part's output will never be seen.</span>
<a href="#l4.1752"></a><span id="l4.1752" class="difflineplus">+ *</span>
<a href="#l4.1753"></a><span id="l4.1753" class="difflineplus">+ * @param part {String} The number of the part.</span>
<a href="#l4.1754"></a><span id="l4.1754" class="difflineplus">+ * @returns {Boolean} True if the emitter is not interested in this part.</span>
<a href="#l4.1755"></a><span id="l4.1755">  */</span>
<a href="#l4.1756"></a><span id="l4.1756" class="difflineminus">-Parser.prototype._willIgnorePart = function Parser_willIgnorePart(part) {</span>
<a href="#l4.1757"></a><span id="l4.1757" class="difflineplus">+MimeParser.prototype._willIgnorePart = function (part) {</span>
<a href="#l4.1758"></a><span id="l4.1758">   if (this._options[&quot;pruneat&quot;]) {</span>
<a href="#l4.1759"></a><span id="l4.1759">     let match = this._options[&quot;pruneat&quot;];</span>
<a href="#l4.1760"></a><span id="l4.1760">     let start = part.substr(0, match.length);</span>
<a href="#l4.1761"></a><span id="l4.1761">     // It needs to start with and follow with a new part indicator</span>
<a href="#l4.1762"></a><span id="l4.1762">     // (i.e., don't let 10 match with 1, but let 1.1 or 1$ do so)</span>
<a href="#l4.1763"></a><span id="l4.1763">     if (start != match || (match.length &lt; part.length &amp;&amp;</span>
<a href="#l4.1764"></a><span id="l4.1764">           &quot;$.&quot;.indexOf(part[match.length]) == -1))</span>
<a href="#l4.1765"></a><span id="l4.1765">       return true;</span>
<a href="#l4.1766"></a><span id="l4.1766">   }</span>
<a href="#l4.1767"></a><span id="l4.1767">   return false;</span>
<a href="#l4.1768"></a><span id="l4.1768" class="difflineminus">-}</span>
<a href="#l4.1769"></a><span id="l4.1769" class="difflineplus">+};</span>
<a href="#l4.1770"></a><span id="l4.1770"> </span>
<a href="#l4.1771"></a><span id="l4.1771"> //////////////////////</span>
<a href="#l4.1772"></a><span id="l4.1772"> // MIME parser core //</span>
<a href="#l4.1773"></a><span id="l4.1773"> //////////////////////</span>
<a href="#l4.1774"></a><span id="l4.1774"> </span>
<a href="#l4.1775"></a><span id="l4.1775"> // This MIME parser is a stateful parser; handling of the MIME tree is mostly</span>
<a href="#l4.1776"></a><span id="l4.1776"> // done by creating new parsers and feeding data to them manually. In parallel</span>
<a href="#l4.1777"></a><span id="l4.1777"> // to the externally-visible deliverData and deliverEOF, the two methods</span>
<a href="#l4.1778"></a><span id="l4.1778" class="difflineat">@@ -326,19 +1828,25 @@ const SEND_TO_SUBPARSER = 4;</span>
<a href="#l4.1779"></a><span id="l4.1779"> /**</span>
<a href="#l4.1780"></a><span id="l4.1780">  * Main dispatch for incoming packet data.</span>
<a href="#l4.1781"></a><span id="l4.1781">  *</span>
<a href="#l4.1782"></a><span id="l4.1782">  * The incoming data needs to have been sanitized so that each packet begins on</span>
<a href="#l4.1783"></a><span id="l4.1783">  * a newline boundary. The part number for the current parser also needs to be</span>
<a href="#l4.1784"></a><span id="l4.1784">  * passed in. The checkSplit parameter controls whether or not the data in</span>
<a href="#l4.1785"></a><span id="l4.1785">  * buffer needs to be checked against _splitRegex; this is used internally for</span>
<a href="#l4.1786"></a><span id="l4.1786">  * the mechanics of splitting and should otherwise always be true.</span>
<a href="#l4.1787"></a><span id="l4.1787" class="difflineplus">+ *</span>
<a href="#l4.1788"></a><span id="l4.1788" class="difflineplus">+ * @param partNum    {String}       The part number being currently parsed.</span>
<a href="#l4.1789"></a><span id="l4.1789" class="difflineplus">+ * @param buffer     {BinaryString} The text (conditioned as mentioned above) to</span>
<a href="#l4.1790"></a><span id="l4.1790" class="difflineplus">+ *                                  pass to the parser.</span>
<a href="#l4.1791"></a><span id="l4.1791" class="difflineplus">+ * @param checkSplit {Boolean}      If true, split the text using _splitRegex.</span>
<a href="#l4.1792"></a><span id="l4.1792" class="difflineplus">+ *                                  This is set to false internally to handle</span>
<a href="#l4.1793"></a><span id="l4.1793" class="difflineplus">+ *                                  low-level splitting details.</span>
<a href="#l4.1794"></a><span id="l4.1794">  */</span>
<a href="#l4.1795"></a><span id="l4.1795" class="difflineminus">-Parser.prototype._dispatchData = function Parser_dispatchData(partNum, buffer,</span>
<a href="#l4.1796"></a><span id="l4.1796" class="difflineminus">-    checkSplit) {</span>
<a href="#l4.1797"></a><span id="l4.1797" class="difflineplus">+MimeParser.prototype._dispatchData = function (partNum, buffer, checkSplit) {</span>
<a href="#l4.1798"></a><span id="l4.1798">   // Are we parsing headers?</span>
<a href="#l4.1799"></a><span id="l4.1799">   if (this._state == PARSING_HEADERS) {</span>
<a href="#l4.1800"></a><span id="l4.1800">     this._headerData += buffer;</span>
<a href="#l4.1801"></a><span id="l4.1801">     // Find the end of the headers--either it's a CRLF at the beginning (in</span>
<a href="#l4.1802"></a><span id="l4.1802">     // which case we have no headers), or it's a pair of CRLFs.</span>
<a href="#l4.1803"></a><span id="l4.1803">     let result = /(?:^(?:\r\n|[\r\n]))|(\r\n|[\r\n])\1/.exec(this._headerData);</span>
<a href="#l4.1804"></a><span id="l4.1804">     if (result != null) {</span>
<a href="#l4.1805"></a><span id="l4.1805">       // If we found the end of headers, split the data at this point and send</span>
<a href="#l4.1806"></a><span id="l4.1806" class="difflineat">@@ -389,162 +1897,186 @@ Parser.prototype._dispatchData = functio</span>
<a href="#l4.1807"></a><span id="l4.1807">     buffer = this._applyDataConversion(buffer, this._options[&quot;strformat&quot;]);</span>
<a href="#l4.1808"></a><span id="l4.1808">     if (buffer.length &gt; 0)</span>
<a href="#l4.1809"></a><span id="l4.1809">       this._callEmitter(&quot;deliverPartData&quot;, partNum, buffer);</span>
<a href="#l4.1810"></a><span id="l4.1810">   } else if (this._state == SEND_TO_SUBPARSER) {</span>
<a href="#l4.1811"></a><span id="l4.1811">     buffer = this._applyDataConversion(buffer, &quot;binarystring&quot;);</span>
<a href="#l4.1812"></a><span id="l4.1812">     if (buffer.length &gt; 0)</span>
<a href="#l4.1813"></a><span id="l4.1813">       this._subparser._dispatchData(this._subPartNum, buffer, true);</span>
<a href="#l4.1814"></a><span id="l4.1814">   }</span>
<a href="#l4.1815"></a><span id="l4.1815" class="difflineminus">-}</span>
<a href="#l4.1816"></a><span id="l4.1816" class="difflineplus">+};</span>
<a href="#l4.1817"></a><span id="l4.1817"> </span>
<a href="#l4.1818"></a><span id="l4.1818" class="difflineminus">-/// Applies this._convertData(buffer, true) if necessary</span>
<a href="#l4.1819"></a><span id="l4.1819" class="difflineminus">-Parser.prototype._applyDataConversion = function Parser_convertData(buf, type) {</span>
<a href="#l4.1820"></a><span id="l4.1820" class="difflineplus">+/**</span>
<a href="#l4.1821"></a><span id="l4.1821" class="difflineplus">+ * Output data using the desired output format, saving data if data conversion</span>
<a href="#l4.1822"></a><span id="l4.1822" class="difflineplus">+ * needs extra data to be saved.</span>
<a href="#l4.1823"></a><span id="l4.1823" class="difflineplus">+ *</span>
<a href="#l4.1824"></a><span id="l4.1824" class="difflineplus">+ * @param buf  {BinaryString} The data to be sent to the output.</span>
<a href="#l4.1825"></a><span id="l4.1825" class="difflineplus">+ * @param type {String}       The type of the data to output. Valid values are</span>
<a href="#l4.1826"></a><span id="l4.1826" class="difflineplus">+ *                            the same as the strformat option.</span>
<a href="#l4.1827"></a><span id="l4.1827" class="difflineplus">+ * @returns Coerced and converted data that can be sent to the emitter or</span>
<a href="#l4.1828"></a><span id="l4.1828" class="difflineplus">+ *          subparser.</span>
<a href="#l4.1829"></a><span id="l4.1829" class="difflineplus">+ */</span>
<a href="#l4.1830"></a><span id="l4.1830" class="difflineplus">+MimeParser.prototype._applyDataConversion = function (buf, type) {</span>
<a href="#l4.1831"></a><span id="l4.1831">   // If we need to convert data, do so.</span>
<a href="#l4.1832"></a><span id="l4.1832">   if (this._convertData) {</span>
<a href="#l4.1833"></a><span id="l4.1833">     // Prepend leftover data from the last conversion.</span>
<a href="#l4.1834"></a><span id="l4.1834">     buf = this._savedBuffer + buf;</span>
<a href="#l4.1835"></a><span id="l4.1835">     [buf, this._savedBuffer] = this._convertData(buf, true);</span>
<a href="#l4.1836"></a><span id="l4.1836">   }</span>
<a href="#l4.1837"></a><span id="l4.1837">   return this._coerceData(buf, type, true);</span>
<a href="#l4.1838"></a><span id="l4.1838" class="difflineminus">-}</span>
<a href="#l4.1839"></a><span id="l4.1839" class="difflineplus">+};</span>
<a href="#l4.1840"></a><span id="l4.1840"> </span>
<a href="#l4.1841"></a><span id="l4.1841" class="difflineplus">+/**</span>
<a href="#l4.1842"></a><span id="l4.1842" class="difflineplus">+ * Coerce the input buffer into the given output type.</span>
<a href="#l4.1843"></a><span id="l4.1843" class="difflineplus">+ *</span>
<a href="#l4.1844"></a><span id="l4.1844" class="difflineplus">+ * @param buffer {BinaryString|Uint8Array} The data to be converted.</span>
<a href="#l4.1845"></a><span id="l4.1845" class="difflineplus">+ * @param type   {String}                  The type to convert the data to.</span>
<a href="#l4.1846"></a><span id="l4.1846" class="difflineplus">+ * @param more   {boolean}                 If true, this function will never be</span>
<a href="#l4.1847"></a><span id="l4.1847" class="difflineplus">+ *                                         called again.</span>
<a href="#l4.1848"></a><span id="l4.1848" class="difflineplus">+ * @returns {BinaryString|String|Uint8Array} The desired output format.</span>
<a href="#l4.1849"></a><span id="l4.1849" class="difflineplus">+ */</span>
<a href="#l4.1850"></a><span id="l4.1850"> /// Coerces the buffer (a string or typedarray) into a given type</span>
<a href="#l4.1851"></a><span id="l4.1851" class="difflineminus">-Parser.prototype._coerceData = function Parser_coerce(buffer, type, more) {</span>
<a href="#l4.1852"></a><span id="l4.1852" class="difflineminus">-  // Note: This function is a placeholder for later code primarily relating to</span>
<a href="#l4.1853"></a><span id="l4.1853" class="difflineminus">-  // charsets and strformat options.</span>
<a href="#l4.1854"></a><span id="l4.1854" class="difflineminus">-  return buffer;</span>
<a href="#l4.1855"></a><span id="l4.1855" class="difflineminus">-}</span>
<a href="#l4.1856"></a><span id="l4.1856" class="difflineplus">+MimeParser.prototype._coerceData = function (buffer, type, more) {</span>
<a href="#l4.1857"></a><span id="l4.1857" class="difflineplus">+  if (typeof buffer == &quot;string&quot;) {</span>
<a href="#l4.1858"></a><span id="l4.1858" class="difflineplus">+    // string -&gt; binarystring is a nop</span>
<a href="#l4.1859"></a><span id="l4.1859" class="difflineplus">+    if (type == &quot;binarystring&quot;)</span>
<a href="#l4.1860"></a><span id="l4.1860" class="difflineplus">+      return buffer;</span>
<a href="#l4.1861"></a><span id="l4.1861" class="difflineplus">+    // Either we're going to array or unicode. Both people need the array</span>
<a href="#l4.1862"></a><span id="l4.1862" class="difflineplus">+    var typedarray = mimeutils.stringToTypedArray(buffer);</span>
<a href="#l4.1863"></a><span id="l4.1863" class="difflineplus">+    // If it's unicode, do the coercion from the array</span>
<a href="#l4.1864"></a><span id="l4.1864" class="difflineplus">+    // If its typedarray, just return the synthesized one</span>
<a href="#l4.1865"></a><span id="l4.1865" class="difflineplus">+    return type == &quot;unicode&quot; ? this._coerceData(typedarray, &quot;unicode&quot;, more)</span>
<a href="#l4.1866"></a><span id="l4.1866" class="difflineplus">+                             : typedarray;</span>
<a href="#l4.1867"></a><span id="l4.1867" class="difflineplus">+  } else if (type == &quot;binarystring&quot;) {</span>
<a href="#l4.1868"></a><span id="l4.1868" class="difflineplus">+    // Doing array -&gt; binarystring</span>
<a href="#l4.1869"></a><span id="l4.1869" class="difflineplus">+    return mimeutils.typedArrayToString(buffer);</span>
<a href="#l4.1870"></a><span id="l4.1870" class="difflineplus">+  } else if (type == &quot;unicode&quot;) {</span>
<a href="#l4.1871"></a><span id="l4.1871" class="difflineplus">+    // Doing array-&gt; unicode: Use the decoder set up earlier to convert</span>
<a href="#l4.1872"></a><span id="l4.1872" class="difflineplus">+    if (this._decoder)</span>
<a href="#l4.1873"></a><span id="l4.1873" class="difflineplus">+      return this._decoder.decode(buffer, {stream: more});</span>
<a href="#l4.1874"></a><span id="l4.1874" class="difflineplus">+    // If there is no charset, just return the typed array instead.</span>
<a href="#l4.1875"></a><span id="l4.1875" class="difflineplus">+    return buffer;</span>
<a href="#l4.1876"></a><span id="l4.1876" class="difflineplus">+  }</span>
<a href="#l4.1877"></a><span id="l4.1877" class="difflineplus">+  throw new Error(&quot;Invalid type: &quot; + type);</span>
<a href="#l4.1878"></a><span id="l4.1878" class="difflineplus">+};</span>
<a href="#l4.1879"></a><span id="l4.1879"> </span>
<a href="#l4.1880"></a><span id="l4.1880"> /**</span>
<a href="#l4.1881"></a><span id="l4.1881">  * Signal that no more data will be dispatched to this parser.</span>
<a href="#l4.1882"></a><span id="l4.1882" class="difflineplus">+ *</span>
<a href="#l4.1883"></a><span id="l4.1883" class="difflineplus">+ * @param partNum {String} The part number being currently parsed.</span>
<a href="#l4.1884"></a><span id="l4.1884">  */</span>
<a href="#l4.1885"></a><span id="l4.1885" class="difflineminus">-Parser.prototype._dispatchEOF = function Parser_dispatchEOF(partNum) {</span>
<a href="#l4.1886"></a><span id="l4.1886" class="difflineplus">+MimeParser.prototype._dispatchEOF = function (partNum) {</span>
<a href="#l4.1887"></a><span id="l4.1887">   if (this._state == PARSING_HEADERS) {</span>
<a href="#l4.1888"></a><span id="l4.1888">     // Unexpected EOF in headers. Parse them now and call startPart/endPart</span>
<a href="#l4.1889"></a><span id="l4.1889">     this._headers = this._parseHeaders();</span>
<a href="#l4.1890"></a><span id="l4.1890">     this._callEmitter(&quot;startPart&quot;, partNum, this._headers);</span>
<a href="#l4.1891"></a><span id="l4.1891">   } else if (this._state == SEND_TO_SUBPARSER) {</span>
<a href="#l4.1892"></a><span id="l4.1892">     // Pass in any lingering data</span>
<a href="#l4.1893"></a><span id="l4.1893">     if (this._convertData &amp;&amp; this._savedBuffer)</span>
<a href="#l4.1894"></a><span id="l4.1894">       this._subparser._dispatchData(this._subPartNum,</span>
<a href="#l4.1895"></a><span id="l4.1895">         this._convertData(this._savedBuffer, false)[0], true);</span>
<a href="#l4.1896"></a><span id="l4.1896">     this._subparser._dispatchEOF(this._subPartNum);</span>
<a href="#l4.1897"></a><span id="l4.1897">     // Clean up after ourselves</span>
<a href="#l4.1898"></a><span id="l4.1898">     this._subparser = null;</span>
<a href="#l4.1899"></a><span id="l4.1899">   } else if (this._convertData &amp;&amp; this._savedBuffer) {</span>
<a href="#l4.1900"></a><span id="l4.1900">     // Convert lingering data</span>
<a href="#l4.1901"></a><span id="l4.1901" class="difflineminus">-    [buffer, ] = this._convertData(this._savedBuffer, false);</span>
<a href="#l4.1902"></a><span id="l4.1902" class="difflineplus">+    let [buffer, ] = this._convertData(this._savedBuffer, false);</span>
<a href="#l4.1903"></a><span id="l4.1903">     buffer = this._coerceData(buffer, this._options[&quot;strformat&quot;], false);</span>
<a href="#l4.1904"></a><span id="l4.1904">     if (buffer.length &gt; 0)</span>
<a href="#l4.1905"></a><span id="l4.1905">       this._callEmitter(&quot;deliverPartData&quot;, partNum, buffer);</span>
<a href="#l4.1906"></a><span id="l4.1906">   }</span>
<a href="#l4.1907"></a><span id="l4.1907"> </span>
<a href="#l4.1908"></a><span id="l4.1908">   // We've reached EOF for this part; tell the emitter</span>
<a href="#l4.1909"></a><span id="l4.1909">   this._callEmitter(&quot;endPart&quot;, partNum);</span>
<a href="#l4.1910"></a><span id="l4.1910" class="difflineminus">-}</span>
<a href="#l4.1911"></a><span id="l4.1911" class="difflineplus">+};</span>
<a href="#l4.1912"></a><span id="l4.1912"> </span>
<a href="#l4.1913"></a><span id="l4.1913"> /**</span>
<a href="#l4.1914"></a><span id="l4.1914">  * Produce a dictionary of all headers as if they were unstructured fields.</span>
<a href="#l4.1915"></a><span id="l4.1915" class="difflineplus">+ *</span>
<a href="#l4.1916"></a><span id="l4.1916" class="difflineplus">+ * @returns {StructuredHeaders} The structured header objects for the header</span>
<a href="#l4.1917"></a><span id="l4.1917" class="difflineplus">+ *                              block.</span>
<a href="#l4.1918"></a><span id="l4.1918">  */</span>
<a href="#l4.1919"></a><span id="l4.1919" class="difflineminus">-Parser.prototype._parseHeaders = function Parser_parseHeaders() {</span>
<a href="#l4.1920"></a><span id="l4.1920" class="difflineminus">-  // An individual header is terminated by a CRLF, except if the CRLF is</span>
<a href="#l4.1921"></a><span id="l4.1921" class="difflineminus">-  // followed by a SP or TAB. Use negative lookahead to capture the latter case,</span>
<a href="#l4.1922"></a><span id="l4.1922" class="difflineminus">-  // and don't capture the strings or else split results get nasty.</span>
<a href="#l4.1923"></a><span id="l4.1923" class="difflineminus">-  let values = this._headerData.split(/(?:\r\n|\n)(?![ \t])|\r(?![ \t\n])/);</span>
<a href="#l4.1924"></a><span id="l4.1924" class="difflineplus">+MimeParser.prototype._parseHeaders = function () {</span>
<a href="#l4.1925"></a><span id="l4.1925" class="difflineplus">+  let headers = new StructuredHeaders(this._headerData, this._options);</span>
<a href="#l4.1926"></a><span id="l4.1926"> </span>
<a href="#l4.1927"></a><span id="l4.1927" class="difflineminus">-  // Ignore the first &quot;header&quot; if it begins with an mbox delimiter</span>
<a href="#l4.1928"></a><span id="l4.1928" class="difflineminus">-  if (values.length &gt; 0 &amp;&amp; values[0].substring(0, 5) == &quot;From &quot;) {</span>
<a href="#l4.1929"></a><span id="l4.1929" class="difflineminus">-    values.shift();</span>
<a href="#l4.1930"></a><span id="l4.1930" class="difflineminus">-    // Elide the mbox delimiter from this._headerData</span>
<a href="#l4.1931"></a><span id="l4.1931" class="difflineminus">-    if (values.length == 0)</span>
<a href="#l4.1932"></a><span id="l4.1932" class="difflineminus">-      this._headerData = '';</span>
<a href="#l4.1933"></a><span id="l4.1933" class="difflineminus">-    else</span>
<a href="#l4.1934"></a><span id="l4.1934" class="difflineminus">-      this._headerData = this._headerData.substring(</span>
<a href="#l4.1935"></a><span id="l4.1935" class="difflineminus">-        this._headerData.indexOf(values[0]));</span>
<a href="#l4.1936"></a><span id="l4.1936" class="difflineplus">+  // Fill the headers.contentType parameter of headers.</span>
<a href="#l4.1937"></a><span id="l4.1937" class="difflineplus">+  let contentType = headers.get('Content-Type');</span>
<a href="#l4.1938"></a><span id="l4.1938" class="difflineplus">+  if (typeof contentType === &quot;undefined&quot;) {</span>
<a href="#l4.1939"></a><span id="l4.1939" class="difflineplus">+    contentType = headerparser.parseStructuredHeader('Content-Type',</span>
<a href="#l4.1940"></a><span id="l4.1940" class="difflineplus">+      this._defaultContentType || 'text/plain');</span>
<a href="#l4.1941"></a><span id="l4.1941" class="difflineplus">+    Object.defineProperty(headers, &quot;contentType&quot;, {</span>
<a href="#l4.1942"></a><span id="l4.1942" class="difflineplus">+      get: function () { return contentType; }</span>
<a href="#l4.1943"></a><span id="l4.1943" class="difflineplus">+    });</span>
<a href="#l4.1944"></a><span id="l4.1944" class="difflineplus">+  } else {</span>
<a href="#l4.1945"></a><span id="l4.1945" class="difflineplus">+    Object.defineProperty(headers, &quot;contentType&quot;, { configurable: false });</span>
<a href="#l4.1946"></a><span id="l4.1946">   }</span>
<a href="#l4.1947"></a><span id="l4.1947"> </span>
<a href="#l4.1948"></a><span id="l4.1948" class="difflineminus">-  let headers = new Map();</span>
<a href="#l4.1949"></a><span id="l4.1949" class="difflineminus">-  for (let i = 0; i &lt; values.length; i++) {</span>
<a href="#l4.1950"></a><span id="l4.1950" class="difflineminus">-    // Look for a colon. If it's not present, this header line is malformed,</span>
<a href="#l4.1951"></a><span id="l4.1951" class="difflineminus">-    // perhaps by premature EOF or similar. The value is null in this case.</span>
<a href="#l4.1952"></a><span id="l4.1952" class="difflineminus">-    let colon = values[i].indexOf(&quot;:&quot;);</span>
<a href="#l4.1953"></a><span id="l4.1953" class="difflineminus">-    if (colon &gt;= 0) {</span>
<a href="#l4.1954"></a><span id="l4.1954" class="difflineminus">-      var header = values[i].substring(0, colon);</span>
<a href="#l4.1955"></a><span id="l4.1955" class="difflineminus">-      var val = values[i].substring(colon + 1).trim();</span>
<a href="#l4.1956"></a><span id="l4.1956" class="difflineminus">-      if (this._options.stripcontinuations)</span>
<a href="#l4.1957"></a><span id="l4.1957" class="difflineminus">-        val = val.replace(/[\r\n]/g, '');</span>
<a href="#l4.1958"></a><span id="l4.1958" class="difflineminus">-    } else {</span>
<a href="#l4.1959"></a><span id="l4.1959" class="difflineminus">-      var header = values[i];</span>
<a href="#l4.1960"></a><span id="l4.1960" class="difflineminus">-      var val = null;</span>
<a href="#l4.1961"></a><span id="l4.1961" class="difflineminus">-    }</span>
<a href="#l4.1962"></a><span id="l4.1962" class="difflineplus">+  // Find the charset for the current part. If the user requested a forced</span>
<a href="#l4.1963"></a><span id="l4.1963" class="difflineplus">+  // conversion, use that first. Otherwise, check the content-type for one and</span>
<a href="#l4.1964"></a><span id="l4.1964" class="difflineplus">+  // fallback to a default if it is not present.</span>
<a href="#l4.1965"></a><span id="l4.1965" class="difflineplus">+  let charset = '';</span>
<a href="#l4.1966"></a><span id="l4.1966" class="difflineplus">+  if (this._options[&quot;force-charset&quot;])</span>
<a href="#l4.1967"></a><span id="l4.1967" class="difflineplus">+    charset = this._options[&quot;charset&quot;];</span>
<a href="#l4.1968"></a><span id="l4.1968" class="difflineplus">+  else if (contentType.has(&quot;charset&quot;))</span>
<a href="#l4.1969"></a><span id="l4.1969" class="difflineplus">+    charset = contentType.get(&quot;charset&quot;);</span>
<a href="#l4.1970"></a><span id="l4.1970" class="difflineplus">+  else</span>
<a href="#l4.1971"></a><span id="l4.1971" class="difflineplus">+    charset = this._options[&quot;charset&quot;];</span>
<a href="#l4.1972"></a><span id="l4.1972" class="difflineplus">+  headers.charset = charset;</span>
<a href="#l4.1973"></a><span id="l4.1973"> </span>
<a href="#l4.1974"></a><span id="l4.1974" class="difflineminus">-    // Canonicalize the header in lower-case form.</span>
<a href="#l4.1975"></a><span id="l4.1975" class="difflineminus">-    header = header.trim().toLowerCase();</span>
<a href="#l4.1976"></a><span id="l4.1976" class="difflineminus">-    // Omit &quot;empty&quot; headers</span>
<a href="#l4.1977"></a><span id="l4.1977" class="difflineminus">-    if (header == '')</span>
<a href="#l4.1978"></a><span id="l4.1978" class="difflineminus">-      continue;</span>
<a href="#l4.1979"></a><span id="l4.1979" class="difflineminus">-</span>
<a href="#l4.1980"></a><span id="l4.1980" class="difflineminus">-    // We keep an array of values for each header, since a given header may be</span>
<a href="#l4.1981"></a><span id="l4.1981" class="difflineminus">-    // repeated multiple times.</span>
<a href="#l4.1982"></a><span id="l4.1982" class="difflineminus">-    if (headers.has(header)) {</span>
<a href="#l4.1983"></a><span id="l4.1983" class="difflineminus">-      headers.get(header).push(val);</span>
<a href="#l4.1984"></a><span id="l4.1984" class="difflineminus">-    } else {</span>
<a href="#l4.1985"></a><span id="l4.1985" class="difflineminus">-      headers.set(header, [val]);</span>
<a href="#l4.1986"></a><span id="l4.1986" class="difflineminus">-    }</span>
<a href="#l4.1987"></a><span id="l4.1987" class="difflineminus">-  }</span>
<a href="#l4.1988"></a><span id="l4.1988" class="difflineminus">-</span>
<a href="#l4.1989"></a><span id="l4.1989" class="difflineminus">-  headers.rawHeaderText = this._headerData;</span>
<a href="#l4.1990"></a><span id="l4.1990" class="difflineplus">+  // Retain a copy of the charset so that users don't override our decision for</span>
<a href="#l4.1991"></a><span id="l4.1991" class="difflineplus">+  // decoding body parts.</span>
<a href="#l4.1992"></a><span id="l4.1992" class="difflineplus">+  this._charset = charset;</span>
<a href="#l4.1993"></a><span id="l4.1993">   return headers;</span>
<a href="#l4.1994"></a><span id="l4.1994" class="difflineminus">-}</span>
<a href="#l4.1995"></a><span id="l4.1995" class="difflineplus">+};</span>
<a href="#l4.1996"></a><span id="l4.1996"> </span>
<a href="#l4.1997"></a><span id="l4.1997"> /**</span>
<a href="#l4.1998"></a><span id="l4.1998">  * Initialize the parser state for the body of this message.</span>
<a href="#l4.1999"></a><span id="l4.1999" class="difflineplus">+ *</span>
<a href="#l4.2000"></a><span id="l4.2000" class="difflineplus">+ * @param partNum {String} The part number being currently parsed.</span>
<a href="#l4.2001"></a><span id="l4.2001">  */</span>
<a href="#l4.2002"></a><span id="l4.2002" class="difflineminus">-Parser.prototype._startBody = function Parser_startBody(partNum) {</span>
<a href="#l4.2003"></a><span id="l4.2003" class="difflineplus">+MimeParser.prototype._startBody = function Parser_startBody(partNum) {</span>
<a href="#l4.2004"></a><span id="l4.2004" class="difflineplus">+  let contentType = this._headers.contentType;</span>
<a href="#l4.2005"></a><span id="l4.2005" class="difflineplus">+</span>
<a href="#l4.2006"></a><span id="l4.2006">   // Should the bodyformat be raw, we just want to pass through all data without</span>
<a href="#l4.2007"></a><span id="l4.2007">   // trying to interpret it.</span>
<a href="#l4.2008"></a><span id="l4.2008">   if (this._options[&quot;bodyformat&quot;] == &quot;raw&quot; &amp;&amp;</span>
<a href="#l4.2009"></a><span id="l4.2009">       partNum == this._options[&quot;pruneat&quot;]) {</span>
<a href="#l4.2010"></a><span id="l4.2010">     this._state = SEND_TO_EMITTER;</span>
<a href="#l4.2011"></a><span id="l4.2011">     return;</span>
<a href="#l4.2012"></a><span id="l4.2012">   }</span>
<a href="#l4.2013"></a><span id="l4.2013" class="difflineminus">-  // What do we assume if there's no content-type?</span>
<a href="#l4.2014"></a><span id="l4.2014" class="difflineminus">-  let defaultContentType = this._defaultContentType || 'text/plain';</span>
<a href="#l4.2015"></a><span id="l4.2015" class="difflineminus">-  let contentType = this._extractHeader('content-type', defaultContentType);</span>
<a href="#l4.2016"></a><span id="l4.2016"> </span>
<a href="#l4.2017"></a><span id="l4.2017">   // The output depents on the content-type. Basic rule of thumb:</span>
<a href="#l4.2018"></a><span id="l4.2018">   // 1. Discrete media types (text, video, audio, image, application) are passed</span>
<a href="#l4.2019"></a><span id="l4.2019">   //    through with no alterations beyond Content-Transfer-Encoding unpacking.</span>
<a href="#l4.2020"></a><span id="l4.2020">   // 2. Everything with a media type of multipart is treated the same.</span>
<a href="#l4.2021"></a><span id="l4.2021">   // 3. Any message/* type that acts like a mail message (rfc822, news, global)</span>
<a href="#l4.2022"></a><span id="l4.2022">   //    is parsed as a header/body pair again. Most of the other message/* types</span>
<a href="#l4.2023"></a><span id="l4.2023">   //    have similar structures, but they don't have cascading child subparts,</span>
<a href="#l4.2024"></a><span id="l4.2024">   //    so it's better to pass their entire contents to the emitter and let the</span>
<a href="#l4.2025"></a><span id="l4.2025">   //    consumer deal with them.</span>
<a href="#l4.2026"></a><span id="l4.2026">   // 4. For untyped data, there needs to be no Content-Type header. This helps</span>
<a href="#l4.2027"></a><span id="l4.2027">   //    avoid false positives.</span>
<a href="#l4.2028"></a><span id="l4.2028">   if (contentType.mediatype == 'multipart') {</span>
<a href="#l4.2029"></a><span id="l4.2029">     // If there's no boundary type, everything will be part of the prologue of</span>
<a href="#l4.2030"></a><span id="l4.2030">     // the multipart message, so just feed everything into a black hole.</span>
<a href="#l4.2031"></a><span id="l4.2031" class="difflineminus">-    if (!('param-boundary' in contentType)) {</span>
<a href="#l4.2032"></a><span id="l4.2032" class="difflineplus">+    if (!contentType.has('boundary')) {</span>
<a href="#l4.2033"></a><span id="l4.2033">       this._state = SEND_TO_BLACK_HOLE;</span>
<a href="#l4.2034"></a><span id="l4.2034">       return;</span>
<a href="#l4.2035"></a><span id="l4.2035">     }</span>
<a href="#l4.2036"></a><span id="l4.2036">     // The boundary of a multipart message needs to start with -- and be at the</span>
<a href="#l4.2037"></a><span id="l4.2037">     // beginning of the line. If -- is after the boundary, it represents the</span>
<a href="#l4.2038"></a><span id="l4.2038">     // terminator of the multipart. After the line, there may be only whitespace</span>
<a href="#l4.2039"></a><span id="l4.2039">     // and then the CRLF at the end. Since the CRLFs in here are necessary for</span>
<a href="#l4.2040"></a><span id="l4.2040">     // distinguishing the parts, they are not included in the subparts, so we</span>
<a href="#l4.2041"></a><span id="l4.2041">     // need to capture them in the regex as well to prevent them leaking out.</span>
<a href="#l4.2042"></a><span id="l4.2042">     this._splitRegex = new RegExp('(\r\n|[\r\n]|^)--' +</span>
<a href="#l4.2043"></a><span id="l4.2043" class="difflineminus">-      contentType['param-boundary'].replace(/[\\^$*+?.()|{}[\]]/g, '\\$&amp;') +</span>
<a href="#l4.2044"></a><span id="l4.2044" class="difflineplus">+      contentType.get('boundary').replace(/[\\^$*+?.()|{}[\]]/g, '\\$&amp;') +</span>
<a href="#l4.2045"></a><span id="l4.2045">       '(--)?[ \t]*(?:\r\n|[\r\n]|$)');</span>
<a href="#l4.2046"></a><span id="l4.2046">     this._handleSplit = this._whenMultipart;</span>
<a href="#l4.2047"></a><span id="l4.2047" class="difflineminus">-    this._subparser = new Parser(this._emitter, this._options);</span>
<a href="#l4.2048"></a><span id="l4.2048" class="difflineplus">+    this._subparser = new MimeParser(this._emitter, this._options);</span>
<a href="#l4.2049"></a><span id="l4.2049">     // multipart/digest defaults to message/rfc822 instead of text/plain</span>
<a href="#l4.2050"></a><span id="l4.2050">     if (contentType.subtype == &quot;digest&quot;)</span>
<a href="#l4.2051"></a><span id="l4.2051">       this._subparser._defaultContentType = &quot;message/rfc822&quot;;</span>
<a href="#l4.2052"></a><span id="l4.2052"> </span>
<a href="#l4.2053"></a><span id="l4.2053">     // All text before the first boundary and after the closing boundary are</span>
<a href="#l4.2054"></a><span id="l4.2054">     // supposed to be ignored (&quot;must be ignored&quot;, according to RFC 2046 5.1.1);</span>
<a href="#l4.2055"></a><span id="l4.2055">     // in accordance with these wishes, ensure they don't get passed to any</span>
<a href="#l4.2056"></a><span id="l4.2056">     // deliverPartData.</span>
<a href="#l4.2057"></a><span id="l4.2057" class="difflineat">@@ -558,27 +2090,29 @@ Parser.prototype._startBody = function P</span>
<a href="#l4.2058"></a><span id="l4.2058">     this._convertData = function mpart_no_leak_crlf(buffer, more) {</span>
<a href="#l4.2059"></a><span id="l4.2059">       let splitPoint = buffer.length;</span>
<a href="#l4.2060"></a><span id="l4.2060">       if (more) {</span>
<a href="#l4.2061"></a><span id="l4.2061">         if (buffer.charAt(splitPoint - 1) == '\n')</span>
<a href="#l4.2062"></a><span id="l4.2062">           splitPoint--;</span>
<a href="#l4.2063"></a><span id="l4.2063">         if (splitPoint &gt;= 0 &amp;&amp; buffer.charAt(splitPoint - 1) == '\r')</span>
<a href="#l4.2064"></a><span id="l4.2064">           splitPoint--;</span>
<a href="#l4.2065"></a><span id="l4.2065">       }</span>
<a href="#l4.2066"></a><span id="l4.2066" class="difflineminus">-      let [preLF, rest] = conditionToEndOnCRLF(buffer.substring(0, splitPoint));</span>
<a href="#l4.2067"></a><span id="l4.2067" class="difflineplus">+      let res = conditionToEndOnCRLF(buffer.substring(0, splitPoint));</span>
<a href="#l4.2068"></a><span id="l4.2068" class="difflineplus">+      let preLF = res[0];</span>
<a href="#l4.2069"></a><span id="l4.2069" class="difflineplus">+      let rest = res[1];</span>
<a href="#l4.2070"></a><span id="l4.2070">       return [preLF, rest + buffer.substring(splitPoint)];</span>
<a href="#l4.2071"></a><span id="l4.2071">     }</span>
<a href="#l4.2072"></a><span id="l4.2072">   } else if (contentType.type == 'message/rfc822' ||</span>
<a href="#l4.2073"></a><span id="l4.2073">       contentType.type == 'message/global' ||</span>
<a href="#l4.2074"></a><span id="l4.2074">       contentType.type == 'message/news') {</span>
<a href="#l4.2075"></a><span id="l4.2075">     // The subpart is just another header/body pair that goes to EOF, so just</span>
<a href="#l4.2076"></a><span id="l4.2076">     // return the parse from that blob</span>
<a href="#l4.2077"></a><span id="l4.2077">     this._state = SEND_TO_SUBPARSER;</span>
<a href="#l4.2078"></a><span id="l4.2078">     this._subPartNum = partNum + &quot;$&quot;;</span>
<a href="#l4.2079"></a><span id="l4.2079" class="difflineminus">-    this._subparser = new Parser(this._emitter, this._options);</span>
<a href="#l4.2080"></a><span id="l4.2080" class="difflineplus">+    this._subparser = new MimeParser(this._emitter, this._options);</span>
<a href="#l4.2081"></a><span id="l4.2081"> </span>
<a href="#l4.2082"></a><span id="l4.2082">     // So, RFC 6532 happily allows message/global types to have CTE applied.</span>
<a href="#l4.2083"></a><span id="l4.2083">     // This means that subparts would need to be decoded to determine their</span>
<a href="#l4.2084"></a><span id="l4.2084">     // contents properly. There seems to be some evidence that message/rfc822</span>
<a href="#l4.2085"></a><span id="l4.2085">     // that is illegally-encoded exists in the wild, so be lenient and decode</span>
<a href="#l4.2086"></a><span id="l4.2086">     // for any message/* type that gets here.</span>
<a href="#l4.2087"></a><span id="l4.2087">     let cte = this._extractHeader('content-transfer-encoding', '');</span>
<a href="#l4.2088"></a><span id="l4.2088">     if (cte in ContentDecoders)</span>
<a href="#l4.2089"></a><span id="l4.2089" class="difflineat">@@ -588,20 +2122,48 @@ Parser.prototype._startBody = function P</span>
<a href="#l4.2090"></a><span id="l4.2090">     this._state = SEND_TO_EMITTER;</span>
<a href="#l4.2091"></a><span id="l4.2091">     if (this._options[&quot;bodyformat&quot;] == &quot;decode&quot;) {</span>
<a href="#l4.2092"></a><span id="l4.2092">       // If we wish to decode, look it up in one of our decoders.</span>
<a href="#l4.2093"></a><span id="l4.2093">       let cte = this._extractHeader('content-transfer-encoding', '');</span>
<a href="#l4.2094"></a><span id="l4.2094">       if (cte in ContentDecoders)</span>
<a href="#l4.2095"></a><span id="l4.2095">         this._convertData = ContentDecoders[cte];</span>
<a href="#l4.2096"></a><span id="l4.2096">     }</span>
<a href="#l4.2097"></a><span id="l4.2097">   }</span>
<a href="#l4.2098"></a><span id="l4.2098" class="difflineminus">-}</span>
<a href="#l4.2099"></a><span id="l4.2099" class="difflineplus">+</span>
<a href="#l4.2100"></a><span id="l4.2100" class="difflineplus">+  // Set up the encoder for charset conversions; only do this for text parts.</span>
<a href="#l4.2101"></a><span id="l4.2101" class="difflineplus">+  // Other parts are almost certainly binary, so no translation should be</span>
<a href="#l4.2102"></a><span id="l4.2102" class="difflineplus">+  // applied to them.</span>
<a href="#l4.2103"></a><span id="l4.2103" class="difflineplus">+  if (this._options[&quot;strformat&quot;] == &quot;unicode&quot; &amp;&amp;</span>
<a href="#l4.2104"></a><span id="l4.2104" class="difflineplus">+      contentType.mediatype == &quot;text&quot;) {</span>
<a href="#l4.2105"></a><span id="l4.2105" class="difflineplus">+    // If the charset is nonempty, initialize the decoder</span>
<a href="#l4.2106"></a><span id="l4.2106" class="difflineplus">+    if (this._charset !== &quot;&quot;) {</span>
<a href="#l4.2107"></a><span id="l4.2107" class="difflineplus">+      this._decoder = new TextDecoder(this._charset);</span>
<a href="#l4.2108"></a><span id="l4.2108" class="difflineplus">+    } else {</span>
<a href="#l4.2109"></a><span id="l4.2109" class="difflineplus">+      // There's no charset we can use for decoding, so pass through as an</span>
<a href="#l4.2110"></a><span id="l4.2110" class="difflineplus">+      // identity encoder or otherwise this._coerceData will complain.</span>
<a href="#l4.2111"></a><span id="l4.2111" class="difflineplus">+      this._decoder = {</span>
<a href="#l4.2112"></a><span id="l4.2112" class="difflineplus">+        decode: function identity_decoder(buffer) {</span>
<a href="#l4.2113"></a><span id="l4.2113" class="difflineplus">+          return MimeParser.prototype._coerceData(buffer, &quot;binarystring&quot;, true);</span>
<a href="#l4.2114"></a><span id="l4.2114" class="difflineplus">+        }</span>
<a href="#l4.2115"></a><span id="l4.2115" class="difflineplus">+      };</span>
<a href="#l4.2116"></a><span id="l4.2116" class="difflineplus">+    }</span>
<a href="#l4.2117"></a><span id="l4.2117" class="difflineplus">+  } else {</span>
<a href="#l4.2118"></a><span id="l4.2118" class="difflineplus">+    this._decoder = null;</span>
<a href="#l4.2119"></a><span id="l4.2119" class="difflineplus">+  }</span>
<a href="#l4.2120"></a><span id="l4.2120" class="difflineplus">+};</span>
<a href="#l4.2121"></a><span id="l4.2121"> </span>
<a href="#l4.2122"></a><span id="l4.2122"> // Internal split handling for multipart messages.</span>
<a href="#l4.2123"></a><span id="l4.2123" class="difflineminus">-Parser.prototype._whenMultipart = function Parser_mpart(partNum, lastResult) {</span>
<a href="#l4.2124"></a><span id="l4.2124" class="difflineplus">+/**</span>
<a href="#l4.2125"></a><span id="l4.2125" class="difflineplus">+ * When a multipary boundary is found, handle the process of managing the</span>
<a href="#l4.2126"></a><span id="l4.2126" class="difflineplus">+ * subparser state. This is meant to be used as a value for this._handleSplit.</span>
<a href="#l4.2127"></a><span id="l4.2127" class="difflineplus">+ *</span>
<a href="#l4.2128"></a><span id="l4.2128" class="difflineplus">+ * @param partNum    {String} The part number being currently parsed.</span>
<a href="#l4.2129"></a><span id="l4.2129" class="difflineplus">+ * @param lastResult {Array}  The result of the regular expression match.</span>
<a href="#l4.2130"></a><span id="l4.2130" class="difflineplus">+ */</span>
<a href="#l4.2131"></a><span id="l4.2131" class="difflineplus">+MimeParser.prototype._whenMultipart = function (partNum, lastResult) {</span>
<a href="#l4.2132"></a><span id="l4.2132">   // Fix up the part number (don't do '' -&gt; '.4' and don't do '1' -&gt; '14')</span>
<a href="#l4.2133"></a><span id="l4.2133">   if (partNum != &quot;&quot;) partNum += &quot;.&quot;;</span>
<a href="#l4.2134"></a><span id="l4.2134">   if (!this._subPartNum) {</span>
<a href="#l4.2135"></a><span id="l4.2135">     // No count? This means that this is the first time we've seen the boundary,</span>
<a href="#l4.2136"></a><span id="l4.2136">     // so do some initialization for later here.</span>
<a href="#l4.2137"></a><span id="l4.2137">     this._count = 1;</span>
<a href="#l4.2138"></a><span id="l4.2138">   } else {</span>
<a href="#l4.2139"></a><span id="l4.2139">     // If we did not match a CRLF at the beginning of the line, strip CRLF from</span>
<a href="#l4.2140"></a><span id="l4.2140" class="difflineat">@@ -632,145 +2194,744 @@ Parser.prototype._whenMultipart = functi</span>
<a href="#l4.2141"></a><span id="l4.2141">     this._state = SEND_TO_SUBPARSER;</span>
<a href="#l4.2142"></a><span id="l4.2142">     this._subPartNum = partNum + this._count;</span>
<a href="#l4.2143"></a><span id="l4.2143">     this._count += 1;</span>
<a href="#l4.2144"></a><span id="l4.2144">   } else {</span>
<a href="#l4.2145"></a><span id="l4.2145">     // Ignore the epilogue</span>
<a href="#l4.2146"></a><span id="l4.2146">     this._splitRegex = null;</span>
<a href="#l4.2147"></a><span id="l4.2147">     this._state = SEND_TO_BLACK_HOLE;</span>
<a href="#l4.2148"></a><span id="l4.2148">   }</span>
<a href="#l4.2149"></a><span id="l4.2149" class="difflineplus">+};</span>
<a href="#l4.2150"></a><span id="l4.2150" class="difflineplus">+</span>
<a href="#l4.2151"></a><span id="l4.2151" class="difflineplus">+/**</span>
<a href="#l4.2152"></a><span id="l4.2152" class="difflineplus">+ * Return the structured header from the current header block, or a default if</span>
<a href="#l4.2153"></a><span id="l4.2153" class="difflineplus">+ * it is not present.</span>
<a href="#l4.2154"></a><span id="l4.2154" class="difflineplus">+ *</span>
<a href="#l4.2155"></a><span id="l4.2155" class="difflineplus">+ * @param name {String} The header name to get.</span>
<a href="#l4.2156"></a><span id="l4.2156" class="difflineplus">+ * @param dflt {String} The default MIME value of the header.</span>
<a href="#l4.2157"></a><span id="l4.2157" class="difflineplus">+ * @returns The structured representation of the header.</span>
<a href="#l4.2158"></a><span id="l4.2158" class="difflineplus">+ */</span>
<a href="#l4.2159"></a><span id="l4.2159" class="difflineplus">+MimeParser.prototype._extractHeader = function (name, dflt) {</span>
<a href="#l4.2160"></a><span id="l4.2160" class="difflineplus">+  name = name.toLowerCase(); // Normalize name</span>
<a href="#l4.2161"></a><span id="l4.2161" class="difflineplus">+  return this._headers.has(name) ? this._headers.get(name) :</span>
<a href="#l4.2162"></a><span id="l4.2162" class="difflineplus">+    headerparser.parseStructuredHeader(name, [dflt]);</span>
<a href="#l4.2163"></a><span id="l4.2163" class="difflineplus">+};</span>
<a href="#l4.2164"></a><span id="l4.2164" class="difflineplus">+</span>
<a href="#l4.2165"></a><span id="l4.2165" class="difflineplus">+var ContentDecoders = {};</span>
<a href="#l4.2166"></a><span id="l4.2166" class="difflineplus">+ContentDecoders['quoted-printable'] = mimeutils.decode_qp;</span>
<a href="#l4.2167"></a><span id="l4.2167" class="difflineplus">+ContentDecoders['base64'] = mimeutils.decode_base64;</span>
<a href="#l4.2168"></a><span id="l4.2168" class="difflineplus">+</span>
<a href="#l4.2169"></a><span id="l4.2169" class="difflineplus">+return MimeParser;</span>
<a href="#l4.2170"></a><span id="l4.2170" class="difflineplus">+});</span>
<a href="#l4.2171"></a><span id="l4.2171" class="difflineplus">+def('headeremitter', function(require) {</span>
<a href="#l4.2172"></a><span id="l4.2172" class="difflineplus">+/**</span>
<a href="#l4.2173"></a><span id="l4.2173" class="difflineplus">+ * This module implements the code for emitting structured representations of</span>
<a href="#l4.2174"></a><span id="l4.2174" class="difflineplus">+ * MIME headers into their encoded forms. The code here is a companion to,</span>
<a href="#l4.2175"></a><span id="l4.2175" class="difflineplus">+ * but completely independent of, jsmime.headerparser: the structured</span>
<a href="#l4.2176"></a><span id="l4.2176" class="difflineplus">+ * representations that are used as input to the functions in this file are the</span>
<a href="#l4.2177"></a><span id="l4.2177" class="difflineplus">+ * same forms that would be parsed.</span>
<a href="#l4.2178"></a><span id="l4.2178" class="difflineplus">+ */</span>
<a href="#l4.2179"></a><span id="l4.2179" class="difflineplus">+</span>
<a href="#l4.2180"></a><span id="l4.2180" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l4.2181"></a><span id="l4.2181" class="difflineplus">+</span>
<a href="#l4.2182"></a><span id="l4.2182" class="difflineplus">+var mimeutils = require('./mimeutils');</span>
<a href="#l4.2183"></a><span id="l4.2183" class="difflineplus">+</span>
<a href="#l4.2184"></a><span id="l4.2184" class="difflineplus">+// Get the default structured encoders and add them to the map</span>
<a href="#l4.2185"></a><span id="l4.2185" class="difflineplus">+var structuredHeaders = require('structuredHeaders');</span>
<a href="#l4.2186"></a><span id="l4.2186" class="difflineplus">+var encoders = new Map();</span>
<a href="#l4.2187"></a><span id="l4.2187" class="difflineplus">+var preferredSpellings = structuredHeaders.spellings;</span>
<a href="#l4.2188"></a><span id="l4.2188" class="difflineplus">+for (let [header, encoder] of structuredHeaders.encoders) {</span>
<a href="#l4.2189"></a><span id="l4.2189" class="difflineplus">+  addStructuredEncoder(header, encoder);</span>
<a href="#l4.2190"></a><span id="l4.2190"> }</span>
<a href="#l4.2191"></a><span id="l4.2191"> </span>
<a href="#l4.2192"></a><span id="l4.2192" class="difflineminus">-// Extract a header. This is for internal purposes.</span>
<a href="#l4.2193"></a><span id="l4.2193" class="difflineminus">-// This calls the structured decoder if it exists. If it does not, it just trims</span>
<a href="#l4.2194"></a><span id="l4.2194" class="difflineminus">-// the value and makes it lower case.</span>
<a href="#l4.2195"></a><span id="l4.2195" class="difflineminus">-Parser.prototype._extractHeader = function extractHeader(name, dflt) {</span>
<a href="#l4.2196"></a><span id="l4.2196" class="difflineminus">-  let value = this._headers.has(name) ? this._headers.get(name)[0] : dflt;</span>
<a href="#l4.2197"></a><span id="l4.2197" class="difflineminus">-  if (name in StructuredDecoders)</span>
<a href="#l4.2198"></a><span id="l4.2198" class="difflineminus">-    return StructuredDecoders[name](value);</span>
<a href="#l4.2199"></a><span id="l4.2199" class="difflineminus">-  // In lieu of anything else, just return lower-case version</span>
<a href="#l4.2200"></a><span id="l4.2200" class="difflineminus">-  return value.trim().toLowerCase();</span>
<a href="#l4.2201"></a><span id="l4.2201" class="difflineplus">+/// Clamp a value in the range [min, max], defaulting to def if it is undefined.</span>
<a href="#l4.2202"></a><span id="l4.2202" class="difflineplus">+function clamp(value, min, max, def) {</span>
<a href="#l4.2203"></a><span id="l4.2203" class="difflineplus">+  if (value === undefined)</span>
<a href="#l4.2204"></a><span id="l4.2204" class="difflineplus">+    return def;</span>
<a href="#l4.2205"></a><span id="l4.2205" class="difflineplus">+  if (value &lt; min)</span>
<a href="#l4.2206"></a><span id="l4.2206" class="difflineplus">+    return min;</span>
<a href="#l4.2207"></a><span id="l4.2207" class="difflineplus">+  if (value &gt; max)</span>
<a href="#l4.2208"></a><span id="l4.2208" class="difflineplus">+    return max;</span>
<a href="#l4.2209"></a><span id="l4.2209" class="difflineplus">+  return value;</span>
<a href="#l4.2210"></a><span id="l4.2210"> }</span>
<a href="#l4.2211"></a><span id="l4.2211"> </span>
<a href="#l4.2212"></a><span id="l4.2212" class="difflineminus">-// Content transfer decoders</span>
<a href="#l4.2213"></a><span id="l4.2213" class="difflineminus">-var ContentDecoders = {};</span>
<a href="#l4.2214"></a><span id="l4.2214" class="difflineminus">-ContentDecoders['quoted-printable'] = function decode_qp(buffer, more) {</span>
<a href="#l4.2215"></a><span id="l4.2215" class="difflineminus">-  // Unlike base64, quoted-printable isn't stateful across multiple lines, so</span>
<a href="#l4.2216"></a><span id="l4.2216" class="difflineminus">-  // there is no need to buffer input, so we can always ignore more.</span>
<a href="#l4.2217"></a><span id="l4.2217" class="difflineminus">-  let decoded = buffer.replace(</span>
<a href="#l4.2218"></a><span id="l4.2218" class="difflineminus">-    // Replace either =&lt;hex&gt;&lt;hex&gt; or =&lt;wsp&gt;CRLF</span>
<a href="#l4.2219"></a><span id="l4.2219" class="difflineminus">-    /=([0-9A-F][0-9A-F]|[ \t]*(\r\n|[\r\n]|$))/gi,</span>
<a href="#l4.2220"></a><span id="l4.2220" class="difflineminus">-    function replace_chars(match, param) {</span>
<a href="#l4.2221"></a><span id="l4.2221" class="difflineminus">-      // If trailing text matches [ \t]*CRLF, drop everything, since it's a</span>
<a href="#l4.2222"></a><span id="l4.2222" class="difflineminus">-      // soft line break.</span>
<a href="#l4.2223"></a><span id="l4.2223" class="difflineminus">-      if (param.trim().length == 0)</span>
<a href="#l4.2224"></a><span id="l4.2224" class="difflineminus">-        return '';</span>
<a href="#l4.2225"></a><span id="l4.2225" class="difflineminus">-      return String.fromCharCode(parseInt(param, 16));</span>
<a href="#l4.2226"></a><span id="l4.2226" class="difflineminus">-    });</span>
<a href="#l4.2227"></a><span id="l4.2227" class="difflineminus">-  return [decoded, ''];</span>
<a href="#l4.2228"></a><span id="l4.2228" class="difflineminus">-}</span>
<a href="#l4.2229"></a><span id="l4.2229" class="difflineminus">-ContentDecoders['base64'] = function decode_base64(buffer, more) {</span>
<a href="#l4.2230"></a><span id="l4.2230" class="difflineminus">-  // Drop all non-base64 characters</span>
<a href="#l4.2231"></a><span id="l4.2231" class="difflineminus">-  let sanitize = buffer.replace(/[^A-Za-z0-9+\/=]/g,'');</span>
<a href="#l4.2232"></a><span id="l4.2232" class="difflineminus">-  // We need to encode in groups of 4 chars. If we don't have enough, leave the</span>
<a href="#l4.2233"></a><span id="l4.2233" class="difflineminus">-  // excess for later. If there aren't any more, drop enough to make it 4.</span>
<a href="#l4.2234"></a><span id="l4.2234" class="difflineminus">-  let excess = sanitize.length % 4;</span>
<a href="#l4.2235"></a><span id="l4.2235" class="difflineminus">-  if (excess != 0 &amp;&amp; more)</span>
<a href="#l4.2236"></a><span id="l4.2236" class="difflineminus">-    buffer = sanitize.slice(-excess);</span>
<a href="#l4.2237"></a><span id="l4.2237" class="difflineminus">-  else</span>
<a href="#l4.2238"></a><span id="l4.2238" class="difflineminus">-    buffer = '';</span>
<a href="#l4.2239"></a><span id="l4.2239" class="difflineminus">-  sanitize = sanitize.substring(0, sanitize.length - excess);</span>
<a href="#l4.2240"></a><span id="l4.2240" class="difflineminus">-  // Use the atob function we (ought to) have in global scope.</span>
<a href="#l4.2241"></a><span id="l4.2241" class="difflineminus">-  return [atob(sanitize), buffer];</span>
<a href="#l4.2242"></a><span id="l4.2242" class="difflineplus">+/**</span>
<a href="#l4.2243"></a><span id="l4.2243" class="difflineplus">+ * An object that can assemble structured header representations into their MIME</span>
<a href="#l4.2244"></a><span id="l4.2244" class="difflineplus">+ * representation.</span>
<a href="#l4.2245"></a><span id="l4.2245" class="difflineplus">+ *</span>
<a href="#l4.2246"></a><span id="l4.2246" class="difflineplus">+ * The character-counting portion of this class operates using individual JS</span>
<a href="#l4.2247"></a><span id="l4.2247" class="difflineplus">+ * characters as its representation of logical character, which is not the same</span>
<a href="#l4.2248"></a><span id="l4.2248" class="difflineplus">+ * as the number of octets used as UTF-8. If non-ASCII characters are to be</span>
<a href="#l4.2249"></a><span id="l4.2249" class="difflineplus">+ * included in headers without some form of encoding, then care should be taken</span>
<a href="#l4.2250"></a><span id="l4.2250" class="difflineplus">+ * to set the maximum line length to account for the mismatch between character</span>
<a href="#l4.2251"></a><span id="l4.2251" class="difflineplus">+ * counts and octet counts: the maximum line is 998 octets, which could be as</span>
<a href="#l4.2252"></a><span id="l4.2252" class="difflineplus">+ * few as 332 JS characters (non-BMP characters, although they take up 4 octets</span>
<a href="#l4.2253"></a><span id="l4.2253" class="difflineplus">+ * in UTF-8, count as 2 in JS strings).</span>
<a href="#l4.2254"></a><span id="l4.2254" class="difflineplus">+ *</span>
<a href="#l4.2255"></a><span id="l4.2255" class="difflineplus">+ * This code takes care to only insert line breaks at the higher-level breaking</span>
<a href="#l4.2256"></a><span id="l4.2256" class="difflineplus">+ * points in a header (as recommended by RFC 5322), but it may need to resort to</span>
<a href="#l4.2257"></a><span id="l4.2257" class="difflineplus">+ * including them more aggressively if this is not possible. If even aggressive</span>
<a href="#l4.2258"></a><span id="l4.2258" class="difflineplus">+ * line-breaking cannot allow a header to be emitted without violating line</span>
<a href="#l4.2259"></a><span id="l4.2259" class="difflineplus">+ * length restrictions, the methods will throw an exception to indicate this</span>
<a href="#l4.2260"></a><span id="l4.2260" class="difflineplus">+ * situation.</span>
<a href="#l4.2261"></a><span id="l4.2261" class="difflineplus">+ *</span>
<a href="#l4.2262"></a><span id="l4.2262" class="difflineplus">+ * In general, this code does not attempt to modify its input; for example, it</span>
<a href="#l4.2263"></a><span id="l4.2263" class="difflineplus">+ * does not attempt to change the case of any input characters, apply any</span>
<a href="#l4.2264"></a><span id="l4.2264" class="difflineplus">+ * Unicode normalization algorithms, or convert email addresses to ACE where</span>
<a href="#l4.2265"></a><span id="l4.2265" class="difflineplus">+ * applicable. The biggest exception to this rule is that most whitespace is</span>
<a href="#l4.2266"></a><span id="l4.2266" class="difflineplus">+ * collapsed to a single space, even in unstructured headers, while most leading</span>
<a href="#l4.2267"></a><span id="l4.2267" class="difflineplus">+ * and trailing whitespace is trimmed from inputs.</span>
<a href="#l4.2268"></a><span id="l4.2268" class="difflineplus">+ *</span>
<a href="#l4.2269"></a><span id="l4.2269" class="difflineplus">+ * @param {StreamHandler} handler The handler to which all output is sent.</span>
<a href="#l4.2270"></a><span id="l4.2270" class="difflineplus">+ *   @param {Function(String)} handler.deliverData Receives encoded data.</span>
<a href="#l4.2271"></a><span id="l4.2271" class="difflineplus">+ *   @param {Function()} handler.deliverEOF Sent when all text is sent.</span>
<a href="#l4.2272"></a><span id="l4.2272" class="difflineplus">+ * @param {Object} options Options for the emitter.</span>
<a href="#l4.2273"></a><span id="l4.2273" class="difflineplus">+ *   @param [options.softMargin=78] {30 &lt;= Integer &lt;= 900}</span>
<a href="#l4.2274"></a><span id="l4.2274" class="difflineplus">+ *     The ideal maximum number of logical characters to include in a line, not</span>
<a href="#l4.2275"></a><span id="l4.2275" class="difflineplus">+ *     including the final CRLF pair. Lines may exceed this margin if parameters</span>
<a href="#l4.2276"></a><span id="l4.2276" class="difflineplus">+ *     are excessively long.</span>
<a href="#l4.2277"></a><span id="l4.2277" class="difflineplus">+ *   @param [options.hardMargin=332] {softMargin &lt;= Integer &lt;= 998}</span>
<a href="#l4.2278"></a><span id="l4.2278" class="difflineplus">+ *     The maximum number of logical characters that can be included in a line,</span>
<a href="#l4.2279"></a><span id="l4.2279" class="difflineplus">+ *     not including the final CRLF pair. If this count would be exceeded, then</span>
<a href="#l4.2280"></a><span id="l4.2280" class="difflineplus">+ *     an error will be thrown and encoding will not be possible.</span>
<a href="#l4.2281"></a><span id="l4.2281" class="difflineplus">+ *   @param [options.useASCII=true] {Boolean}</span>
<a href="#l4.2282"></a><span id="l4.2282" class="difflineplus">+ *     If true, then RFC 2047 and RFC 2231 encoding of headers will be performed</span>
<a href="#l4.2283"></a><span id="l4.2283" class="difflineplus">+ *     as needed to retain headers as ASCII.</span>
<a href="#l4.2284"></a><span id="l4.2284" class="difflineplus">+ */</span>
<a href="#l4.2285"></a><span id="l4.2285" class="difflineplus">+function HeaderEmitter(handler, options) {</span>
<a href="#l4.2286"></a><span id="l4.2286" class="difflineplus">+  /// The inferred value of options.useASCII</span>
<a href="#l4.2287"></a><span id="l4.2287" class="difflineplus">+  this._useASCII = options.useASCII === undefined ? true : options.useASCII;</span>
<a href="#l4.2288"></a><span id="l4.2288" class="difflineplus">+  /// The handler to use.</span>
<a href="#l4.2289"></a><span id="l4.2289" class="difflineplus">+  this._handler = handler;</span>
<a href="#l4.2290"></a><span id="l4.2290" class="difflineplus">+  /**</span>
<a href="#l4.2291"></a><span id="l4.2291" class="difflineplus">+   * The current line being built; note that we may insert a line break in the</span>
<a href="#l4.2292"></a><span id="l4.2292" class="difflineplus">+   * middle to keep under the maximum line length.</span>
<a href="#l4.2293"></a><span id="l4.2293" class="difflineplus">+   *</span>
<a href="#l4.2294"></a><span id="l4.2294" class="difflineplus">+   * @type String</span>
<a href="#l4.2295"></a><span id="l4.2295" class="difflineplus">+   * @private</span>
<a href="#l4.2296"></a><span id="l4.2296" class="difflineplus">+   */</span>
<a href="#l4.2297"></a><span id="l4.2297" class="difflineplus">+  this._currentLine = &quot;&quot;;</span>
<a href="#l4.2298"></a><span id="l4.2298" class="difflineplus">+</span>
<a href="#l4.2299"></a><span id="l4.2299" class="difflineplus">+  // Our bounds for soft and margins are not completely arbitrary. The minimum</span>
<a href="#l4.2300"></a><span id="l4.2300" class="difflineplus">+  // amount we need to encode is 20 characters, which can encode a single</span>
<a href="#l4.2301"></a><span id="l4.2301" class="difflineplus">+  // non-BMP character with RFC 2047. The value of 30 is chosen to give some</span>
<a href="#l4.2302"></a><span id="l4.2302" class="difflineplus">+  // breathing room for delimiters or other unbreakable characters. The maximum</span>
<a href="#l4.2303"></a><span id="l4.2303" class="difflineplus">+  // length is 998 octets, per RFC 5322; soft margins are slightly lower to</span>
<a href="#l4.2304"></a><span id="l4.2304" class="difflineplus">+  // allow for breathing room as well. The default of 78 for the soft margin is</span>
<a href="#l4.2305"></a><span id="l4.2305" class="difflineplus">+  // recommended by RFC 5322; the default of 332 for the hard margin ensures</span>
<a href="#l4.2306"></a><span id="l4.2306" class="difflineplus">+  // that UTF-8 encoding the output never violates the 998 octet limit.</span>
<a href="#l4.2307"></a><span id="l4.2307" class="difflineplus">+  this._softMargin = clamp(options.softMargin, 30, 900, 78);</span>
<a href="#l4.2308"></a><span id="l4.2308" class="difflineplus">+  this._hardMargin = clamp(options.hardMargin, this._softMargin, 998, 332);</span>
<a href="#l4.2309"></a><span id="l4.2309" class="difflineplus">+</span>
<a href="#l4.2310"></a><span id="l4.2310" class="difflineplus">+  /**</span>
<a href="#l4.2311"></a><span id="l4.2311" class="difflineplus">+   * The index of the last preferred breakable position in the current line.</span>
<a href="#l4.2312"></a><span id="l4.2312" class="difflineplus">+   *</span>
<a href="#l4.2313"></a><span id="l4.2313" class="difflineplus">+   * @type Integer</span>
<a href="#l4.2314"></a><span id="l4.2314" class="difflineplus">+   * @private</span>
<a href="#l4.2315"></a><span id="l4.2315" class="difflineplus">+   */</span>
<a href="#l4.2316"></a><span id="l4.2316" class="difflineplus">+  this._preferredBreakpoint = 0;</span>
<a href="#l4.2317"></a><span id="l4.2317"> }</span>
<a href="#l4.2318"></a><span id="l4.2318"> </span>
<a href="#l4.2319"></a><span id="l4.2319" class="difflineminus">-///////////////////////////////</span>
<a href="#l4.2320"></a><span id="l4.2320" class="difflineminus">-// Structured field decoders //</span>
<a href="#l4.2321"></a><span id="l4.2321" class="difflineminus">-///////////////////////////////</span>
<a href="#l4.2322"></a><span id="l4.2322" class="difflineplus">+</span>
<a href="#l4.2323"></a><span id="l4.2323" class="difflineplus">+///////////////////////</span>
<a href="#l4.2324"></a><span id="l4.2324" class="difflineplus">+// Low-level methods //</span>
<a href="#l4.2325"></a><span id="l4.2325" class="difflineplus">+///////////////////////</span>
<a href="#l4.2326"></a><span id="l4.2326"> </span>
<a href="#l4.2327"></a><span id="l4.2327" class="difflineminus">-// Structured decoders exist in two pieces. There are the basic methods, for</span>
<a href="#l4.2328"></a><span id="l4.2328" class="difflineminus">-// decoding headers based on their type rather than full semantic decomposition.</span>
<a href="#l4.2329"></a><span id="l4.2329" class="difflineminus">-// All of these methods take as their first parameter the string to be parsed.</span>
<a href="#l4.2330"></a><span id="l4.2330" class="difflineminus">-// In addition to these, we have specific structurers for individual headers</span>
<a href="#l4.2331"></a><span id="l4.2331" class="difflineminus">-// that are useful for the parser (e.g., Content-Type).</span>
<a href="#l4.2332"></a><span id="l4.2332" class="difflineplus">+// Explanation of the emitter internals:</span>
<a href="#l4.2333"></a><span id="l4.2333" class="difflineplus">+// RFC 5322 requires that we wrap our lines, ideally at 78 characters and at</span>
<a href="#l4.2334"></a><span id="l4.2334" class="difflineplus">+// least by 998 octets. We can't wrap in arbitrary places, but wherever CFWS is</span>
<a href="#l4.2335"></a><span id="l4.2335" class="difflineplus">+// valid... and ideally wherever clients are likely to expect it. In theory, we</span>
<a href="#l4.2336"></a><span id="l4.2336" class="difflineplus">+// can break between every token (this is how RFC 822 operates), but, in RFC</span>
<a href="#l4.2337"></a><span id="l4.2337" class="difflineplus">+// 5322, many of those breaks are relegated to obsolete productions, mostly</span>
<a href="#l4.2338"></a><span id="l4.2338" class="difflineplus">+// because it is common to not properly handle breaks in those locations.</span>
<a href="#l4.2339"></a><span id="l4.2339" class="difflineplus">+//</span>
<a href="#l4.2340"></a><span id="l4.2340" class="difflineplus">+// So how do we do line breaking? The algorithm we implement is greedy, to</span>
<a href="#l4.2341"></a><span id="l4.2341" class="difflineplus">+// simplify implementation. There are two margins: the soft margin, which we</span>
<a href="#l4.2342"></a><span id="l4.2342" class="difflineplus">+// want to keep within, and the hard margin, which we absolutely have to keep</span>
<a href="#l4.2343"></a><span id="l4.2343" class="difflineplus">+// within. There are also two kinds of break points: preferred and emergency.</span>
<a href="#l4.2344"></a><span id="l4.2344" class="difflineplus">+// As long as we keep the line within the hard margin, we will only break at</span>
<a href="#l4.2345"></a><span id="l4.2345" class="difflineplus">+// preferred breakpoints; emergency breakpoints are only used if we would</span>
<a href="#l4.2346"></a><span id="l4.2346" class="difflineplus">+// otherwise exceed the hard margin.</span>
<a href="#l4.2347"></a><span id="l4.2347" class="difflineplus">+//</span>
<a href="#l4.2348"></a><span id="l4.2348" class="difflineplus">+// For illustration, here is an example header and where these break points are</span>
<a href="#l4.2349"></a><span id="l4.2349" class="difflineplus">+// located:</span>
<a href="#l4.2350"></a><span id="l4.2350" class="difflineplus">+//</span>
<a href="#l4.2351"></a><span id="l4.2351" class="difflineplus">+//            To: John &quot;The Rock&quot; Smith &lt;jsmith@a.long.domain.invalid&gt;</span>
<a href="#l4.2352"></a><span id="l4.2352" class="difflineplus">+// Preferred:         ^          ^     ^</span>
<a href="#l4.2353"></a><span id="l4.2353" class="difflineplus">+// Emergency:         ^    ^     ^     ^^      ^ ^    ^      ^       ^</span>
<a href="#l4.2354"></a><span id="l4.2354" class="difflineplus">+//</span>
<a href="#l4.2355"></a><span id="l4.2355" class="difflineplus">+// Preferred breakpoints are indicated by setting the mayBreakAfter parameter of</span>
<a href="#l4.2356"></a><span id="l4.2356" class="difflineplus">+// addText to true, while emergency breakpoints are set after every token passed</span>
<a href="#l4.2357"></a><span id="l4.2357" class="difflineplus">+// into addText. This is handled implicitly by only adding text to _currentLine</span>
<a href="#l4.2358"></a><span id="l4.2358" class="difflineplus">+// if it ends in an emergency breakpoint.</span>
<a href="#l4.2359"></a><span id="l4.2359" class="difflineplus">+//</span>
<a href="#l4.2360"></a><span id="l4.2360" class="difflineplus">+// Internally, the code keeps track of margins by use of two variables. The</span>
<a href="#l4.2361"></a><span id="l4.2361" class="difflineplus">+// _softMargin and _hardMargin variables encode the positions at which code must</span>
<a href="#l4.2362"></a><span id="l4.2362" class="difflineplus">+// absolutely break, and are set up from the initial options parameter. Breaking</span>
<a href="#l4.2363"></a><span id="l4.2363" class="difflineplus">+// happens when _currentLine.length approaches these values, as mentioned above.</span>
<a href="#l4.2364"></a><span id="l4.2364" class="difflineplus">+</span>
<a href="#l4.2365"></a><span id="l4.2365" class="difflineplus">+/**</span>
<a href="#l4.2366"></a><span id="l4.2366" class="difflineplus">+ * Send a header line consisting of the first N characters to the handler.</span>
<a href="#l4.2367"></a><span id="l4.2367" class="difflineplus">+ *</span>
<a href="#l4.2368"></a><span id="l4.2368" class="difflineplus">+ * If the count parameter is missing, then we presume that the current header</span>
<a href="#l4.2369"></a><span id="l4.2369" class="difflineplus">+ * value being emitted is done and therefore we should not send a continuation</span>
<a href="#l4.2370"></a><span id="l4.2370" class="difflineplus">+ * space. Otherwise, we presume that we're still working, so we will send the</span>
<a href="#l4.2371"></a><span id="l4.2371" class="difflineplus">+ * continuation space.</span>
<a href="#l4.2372"></a><span id="l4.2372" class="difflineplus">+ *</span>
<a href="#l4.2373"></a><span id="l4.2373" class="difflineplus">+ * @private</span>
<a href="#l4.2374"></a><span id="l4.2374" class="difflineplus">+ * @param [count] {Integer} The number of characters in the current line to</span>
<a href="#l4.2375"></a><span id="l4.2375" class="difflineplus">+ *   include before wrapping.</span>
<a href="#l4.2376"></a><span id="l4.2376" class="difflineplus">+ */</span>
<a href="#l4.2377"></a><span id="l4.2377" class="difflineplus">+HeaderEmitter.prototype._commitLine = function (count) {</span>
<a href="#l4.2378"></a><span id="l4.2378" class="difflineplus">+  let isContinuing = typeof count !== &quot;undefined&quot;;</span>
<a href="#l4.2379"></a><span id="l4.2379" class="difflineplus">+</span>
<a href="#l4.2380"></a><span id="l4.2380" class="difflineplus">+  // Split at the point, and lop off whitespace immediately before and after.</span>
<a href="#l4.2381"></a><span id="l4.2381" class="difflineplus">+  if (isContinuing) {</span>
<a href="#l4.2382"></a><span id="l4.2382" class="difflineplus">+    var firstN = this._currentLine.slice(0, count).trimRight();</span>
<a href="#l4.2383"></a><span id="l4.2383" class="difflineplus">+    var lastN = this._currentLine.slice(count).trimLeft();</span>
<a href="#l4.2384"></a><span id="l4.2384" class="difflineplus">+  } else {</span>
<a href="#l4.2385"></a><span id="l4.2385" class="difflineplus">+    var firstN = this._currentLine.trimRight();</span>
<a href="#l4.2386"></a><span id="l4.2386" class="difflineplus">+    var lastN = &quot;&quot;;</span>
<a href="#l4.2387"></a><span id="l4.2387" class="difflineplus">+  }</span>
<a href="#l4.2388"></a><span id="l4.2388" class="difflineplus">+</span>
<a href="#l4.2389"></a><span id="l4.2389" class="difflineplus">+  // How many characters do we need to shift preferred/emergency breakpoints?</span>
<a href="#l4.2390"></a><span id="l4.2390" class="difflineplus">+  let shift = this._currentLine.length - lastN.length;</span>
<a href="#l4.2391"></a><span id="l4.2391" class="difflineplus">+</span>
<a href="#l4.2392"></a><span id="l4.2392" class="difflineplus">+  // Send the line plus the final CRLF.</span>
<a href="#l4.2393"></a><span id="l4.2393" class="difflineplus">+  this._handler.deliverData(firstN + '\r\n');</span>
<a href="#l4.2394"></a><span id="l4.2394" class="difflineplus">+</span>
<a href="#l4.2395"></a><span id="l4.2395" class="difflineplus">+  // Fill the start of the line with the new data.</span>
<a href="#l4.2396"></a><span id="l4.2396" class="difflineplus">+  this._currentLine = lastN;</span>
<a href="#l4.2397"></a><span id="l4.2397"> </span>
<a href="#l4.2398"></a><span id="l4.2398" class="difflineminus">-function extractParameters(headerValue) {</span>
<a href="#l4.2399"></a><span id="l4.2399" class="difflineminus">-  // The basic syntax of headerValue is token [; token = token-or-qstring]*</span>
<a href="#l4.2400"></a><span id="l4.2400" class="difflineminus">-  // Copying more or less liberally from nsMIMEHeaderParamImpl:</span>
<a href="#l4.2401"></a><span id="l4.2401" class="difflineminus">-  // The first token is the text to the first whitespace or semicolon.</span>
<a href="#l4.2402"></a><span id="l4.2402" class="difflineminus">-  var semi = headerValue.indexOf(&quot;;&quot;);</span>
<a href="#l4.2403"></a><span id="l4.2403" class="difflineminus">-  if (semi &lt; 0) {</span>
<a href="#l4.2404"></a><span id="l4.2404" class="difflineminus">-    var start = headerValue;</span>
<a href="#l4.2405"></a><span id="l4.2405" class="difflineminus">-    var rest = '';</span>
<a href="#l4.2406"></a><span id="l4.2406" class="difflineminus">-  } else {</span>
<a href="#l4.2407"></a><span id="l4.2407" class="difflineminus">-    var start = headerValue.substring(0, semi);</span>
<a href="#l4.2408"></a><span id="l4.2408" class="difflineminus">-    var rest = headerValue.substring(semi); // Include the semicolon</span>
<a href="#l4.2409"></a><span id="l4.2409" class="difflineplus">+  // If this is a continuation, add an extra space at the beginning of the line.</span>
<a href="#l4.2410"></a><span id="l4.2410" class="difflineplus">+  // Adjust the breakpoint shift amount as well.</span>
<a href="#l4.2411"></a><span id="l4.2411" class="difflineplus">+  if (isContinuing) {</span>
<a href="#l4.2412"></a><span id="l4.2412" class="difflineplus">+    this._currentLine = ' ' + this._currentLine;</span>
<a href="#l4.2413"></a><span id="l4.2413" class="difflineplus">+    shift++;</span>
<a href="#l4.2414"></a><span id="l4.2414">   }</span>
<a href="#l4.2415"></a><span id="l4.2415" class="difflineminus">-  // Strip start to be &lt;WSP&gt;&lt;nowsp&gt;&lt;WSP&gt;</span>
<a href="#l4.2416"></a><span id="l4.2416" class="difflineminus">-  start = start.trim().split(/[ \t\r\n]/)[0];</span>
<a href="#l4.2417"></a><span id="l4.2417" class="difflineplus">+</span>
<a href="#l4.2418"></a><span id="l4.2418" class="difflineplus">+  // We will always break at a point at or after the _preferredBreakpoint, if it</span>
<a href="#l4.2419"></a><span id="l4.2419" class="difflineplus">+  // exists, so this always gets reset to 0.</span>
<a href="#l4.2420"></a><span id="l4.2420" class="difflineplus">+  this._preferredBreakpoint = 0;</span>
<a href="#l4.2421"></a><span id="l4.2421" class="difflineplus">+};</span>
<a href="#l4.2422"></a><span id="l4.2422" class="difflineplus">+</span>
<a href="#l4.2423"></a><span id="l4.2423" class="difflineplus">+/**</span>
<a href="#l4.2424"></a><span id="l4.2424" class="difflineplus">+ * Reserve at least length characters in the current line. If there aren't</span>
<a href="#l4.2425"></a><span id="l4.2425" class="difflineplus">+ * enough characters, insert a line break.</span>
<a href="#l4.2426"></a><span id="l4.2426" class="difflineplus">+ *</span>
<a href="#l4.2427"></a><span id="l4.2427" class="difflineplus">+ * @private</span>
<a href="#l4.2428"></a><span id="l4.2428" class="difflineplus">+ * @param length {Integer} The number of characters to reserve space for.</span>
<a href="#l4.2429"></a><span id="l4.2429" class="difflineplus">+ * @return {Boolean} Whether or not there is enough space for length characters.</span>
<a href="#l4.2430"></a><span id="l4.2430" class="difflineplus">+ */</span>
<a href="#l4.2431"></a><span id="l4.2431" class="difflineplus">+HeaderEmitter.prototype._reserveTokenSpace = function (length) {</span>
<a href="#l4.2432"></a><span id="l4.2432" class="difflineplus">+  // We are not going to do a sanity check that length is within the wrap</span>
<a href="#l4.2433"></a><span id="l4.2433" class="difflineplus">+  // margins. The rationale is that this lets code simply call this function to</span>
<a href="#l4.2434"></a><span id="l4.2434" class="difflineplus">+  // force a higher-level line break than normal preferred line breaks (see</span>
<a href="#l4.2435"></a><span id="l4.2435" class="difflineplus">+  // addAddress for an example use). The text that would be added may need to be</span>
<a href="#l4.2436"></a><span id="l4.2436" class="difflineplus">+  // itself broken up, so it might not need all the length anyways, but it</span>
<a href="#l4.2437"></a><span id="l4.2437" class="difflineplus">+  // starts the break already.</span>
<a href="#l4.2438"></a><span id="l4.2438" class="difflineplus">+</span>
<a href="#l4.2439"></a><span id="l4.2439" class="difflineplus">+  // If we have enough space, we don't need to do anything.</span>
<a href="#l4.2440"></a><span id="l4.2440" class="difflineplus">+  if (this._currentLine.length + length &lt;= this._softMargin)</span>
<a href="#l4.2441"></a><span id="l4.2441" class="difflineplus">+    return true;</span>
<a href="#l4.2442"></a><span id="l4.2442" class="difflineplus">+</span>
<a href="#l4.2443"></a><span id="l4.2443" class="difflineplus">+  // If we have a preferred breakpoint, commit the line at that point, and see</span>
<a href="#l4.2444"></a><span id="l4.2444" class="difflineplus">+  // if that is sufficient line-breaking.</span>
<a href="#l4.2445"></a><span id="l4.2445" class="difflineplus">+  if (this._preferredBreakpoint &gt; 0) {</span>
<a href="#l4.2446"></a><span id="l4.2446" class="difflineplus">+    this._commitLine(this._preferredBreakpoint);</span>
<a href="#l4.2447"></a><span id="l4.2447" class="difflineplus">+    if (this._currentLine.length + length &lt;= this._softMargin)</span>
<a href="#l4.2448"></a><span id="l4.2448" class="difflineplus">+      return true;</span>
<a href="#l4.2449"></a><span id="l4.2449" class="difflineplus">+  }</span>
<a href="#l4.2450"></a><span id="l4.2450" class="difflineplus">+</span>
<a href="#l4.2451"></a><span id="l4.2451" class="difflineplus">+  // At this point, we can no longer keep within the soft margin. Let us see if</span>
<a href="#l4.2452"></a><span id="l4.2452" class="difflineplus">+  // we can fit within the hard margin.</span>
<a href="#l4.2453"></a><span id="l4.2453" class="difflineplus">+  if (this._currentLine.length + length &lt;= this._hardMargin) {</span>
<a href="#l4.2454"></a><span id="l4.2454" class="difflineplus">+    return true;</span>
<a href="#l4.2455"></a><span id="l4.2455" class="difflineplus">+  }</span>
<a href="#l4.2456"></a><span id="l4.2456" class="difflineplus">+</span>
<a href="#l4.2457"></a><span id="l4.2457" class="difflineplus">+  // Adding the text to length would violate the hard margin as well. Break at</span>
<a href="#l4.2458"></a><span id="l4.2458" class="difflineplus">+  // the last emergency breakpoint.</span>
<a href="#l4.2459"></a><span id="l4.2459" class="difflineplus">+  if (this._currentLine.length &gt; 0) {</span>
<a href="#l4.2460"></a><span id="l4.2460" class="difflineplus">+    this._commitLine(this._currentLine.length);</span>
<a href="#l4.2461"></a><span id="l4.2461" class="difflineplus">+  }</span>
<a href="#l4.2462"></a><span id="l4.2462" class="difflineplus">+</span>
<a href="#l4.2463"></a><span id="l4.2463" class="difflineplus">+  // At this point, if there is still insufficient room in the hard margin, we</span>
<a href="#l4.2464"></a><span id="l4.2464" class="difflineplus">+  // can no longer do anything to encode this word. Bail.</span>
<a href="#l4.2465"></a><span id="l4.2465" class="difflineplus">+  return this._currentLine.length + length &lt;= this._hardMargin;</span>
<a href="#l4.2466"></a><span id="l4.2466" class="difflineplus">+};</span>
<a href="#l4.2467"></a><span id="l4.2467" class="difflineplus">+</span>
<a href="#l4.2468"></a><span id="l4.2468" class="difflineplus">+/**</span>
<a href="#l4.2469"></a><span id="l4.2469" class="difflineplus">+ * Adds a block of text to the current header, inserting a break if necessary.</span>
<a href="#l4.2470"></a><span id="l4.2470" class="difflineplus">+ * If mayBreakAfter is true and text does not end in whitespace, a single space</span>
<a href="#l4.2471"></a><span id="l4.2471" class="difflineplus">+ * character may be added to the output. If the text could not be added without</span>
<a href="#l4.2472"></a><span id="l4.2472" class="difflineplus">+ * violating line length restrictions, an error is thrown instead.</span>
<a href="#l4.2473"></a><span id="l4.2473" class="difflineplus">+ *</span>
<a href="#l4.2474"></a><span id="l4.2474" class="difflineplus">+ * @protected</span>
<a href="#l4.2475"></a><span id="l4.2475" class="difflineplus">+ * @param {String}  text          The text to add to the output.</span>
<a href="#l4.2476"></a><span id="l4.2476" class="difflineplus">+ * @param {Boolean} mayBreakAfter If true, the end of this text is a preferred</span>
<a href="#l4.2477"></a><span id="l4.2477" class="difflineplus">+ *                                breakpoint.</span>
<a href="#l4.2478"></a><span id="l4.2478" class="difflineplus">+ */</span>
<a href="#l4.2479"></a><span id="l4.2479" class="difflineplus">+HeaderEmitter.prototype.addText = function (text, mayBreakAfter) {</span>
<a href="#l4.2480"></a><span id="l4.2480" class="difflineplus">+  // Try to reserve space for the tokens. If we can't, give up.</span>
<a href="#l4.2481"></a><span id="l4.2481" class="difflineplus">+  if (!this._reserveTokenSpace(text.length))</span>
<a href="#l4.2482"></a><span id="l4.2482" class="difflineplus">+    throw new Error(&quot;Cannot encode &quot; + text + &quot; due to length.&quot;);</span>
<a href="#l4.2483"></a><span id="l4.2483"> </span>
<a href="#l4.2484"></a><span id="l4.2484" class="difflineminus">-  // Now, match parameters. The RFC 2231 processing comes later, just yank out</span>
<a href="#l4.2485"></a><span id="l4.2485" class="difflineminus">-  // all of the parameters for now. This is doing via a regex which is</span>
<a href="#l4.2486"></a><span id="l4.2486" class="difflineminus">-  // continually executed to find each pair. The match to try to find is this:</span>
<a href="#l4.2487"></a><span id="l4.2487" class="difflineminus">-  // ;&lt;WSP&gt;&lt;token&gt;&lt;WSP&gt;=&lt;WSP&gt;&lt;token&gt; or ;&lt;WSP&gt;&lt;token&gt;&lt;WSP&gt;=&lt;WSP&gt;&lt;quote string&gt;</span>
<a href="#l4.2488"></a><span id="l4.2488" class="difflineminus">-  // where the first token is any string that isn't whitespace and doesn't</span>
<a href="#l4.2489"></a><span id="l4.2489" class="difflineminus">-  // contain an = or ; and the second token merely doesn't contain ;.</span>
<a href="#l4.2490"></a><span id="l4.2490" class="difflineminus">-  var wsp = &quot;[ \t\r\n]*&quot;;</span>
<a href="#l4.2491"></a><span id="l4.2491" class="difflineminus">-  var token = &quot;[^ \t\r\n=;]*&quot;;</span>
<a href="#l4.2492"></a><span id="l4.2492" class="difflineminus">-  var qstring = '&quot;(?:[^\\\\&quot;]|\\\\.)*&quot;?';</span>
<a href="#l4.2493"></a><span id="l4.2493" class="difflineminus">-  var qstring_or_tok = qstring + &quot;|[^ \t\r\n;]*&quot;;</span>
<a href="#l4.2494"></a><span id="l4.2494" class="difflineminus">-  var regex = new RegExp(&quot;;&quot; + wsp + &quot;(&quot; + token + &quot;)&quot; + wsp + &quot;=&quot; + wsp +</span>
<a href="#l4.2495"></a><span id="l4.2495" class="difflineminus">-    &quot;(&quot; + qstring_or_tok + &quot;)&quot;, &quot;g&quot;);</span>
<a href="#l4.2496"></a><span id="l4.2496" class="difflineplus">+  this._currentLine += text;</span>
<a href="#l4.2497"></a><span id="l4.2497" class="difflineplus">+  if (mayBreakAfter) {</span>
<a href="#l4.2498"></a><span id="l4.2498" class="difflineplus">+    // Make sure that there is an extra space if text could break afterwards.</span>
<a href="#l4.2499"></a><span id="l4.2499" class="difflineplus">+    this._preferredBreakpoint = this._currentLine.length;</span>
<a href="#l4.2500"></a><span id="l4.2500" class="difflineplus">+    if (text[text.length - 1] != ' ') {</span>
<a href="#l4.2501"></a><span id="l4.2501" class="difflineplus">+      this._currentLine += ' ';</span>
<a href="#l4.2502"></a><span id="l4.2502" class="difflineplus">+    }</span>
<a href="#l4.2503"></a><span id="l4.2503" class="difflineplus">+  }</span>
<a href="#l4.2504"></a><span id="l4.2504" class="difflineplus">+};</span>
<a href="#l4.2505"></a><span id="l4.2505" class="difflineplus">+</span>
<a href="#l4.2506"></a><span id="l4.2506" class="difflineplus">+/**</span>
<a href="#l4.2507"></a><span id="l4.2507" class="difflineplus">+ * Adds a block of text that may need quoting if it contains some character in</span>
<a href="#l4.2508"></a><span id="l4.2508" class="difflineplus">+ * qchars. If it is already quoted, no quoting will be applied. If the text</span>
<a href="#l4.2509"></a><span id="l4.2509" class="difflineplus">+ * cannot be added without violating maximum line length, an error is thrown</span>
<a href="#l4.2510"></a><span id="l4.2510" class="difflineplus">+ * instead.</span>
<a href="#l4.2511"></a><span id="l4.2511" class="difflineplus">+ *</span>
<a href="#l4.2512"></a><span id="l4.2512" class="difflineplus">+ * @protected</span>
<a href="#l4.2513"></a><span id="l4.2513" class="difflineplus">+ * @param {String}  text          The text to add to the output.</span>
<a href="#l4.2514"></a><span id="l4.2514" class="difflineplus">+ * @param {String}  qchars        The set of characters that cannot appear</span>
<a href="#l4.2515"></a><span id="l4.2515" class="difflineplus">+ *                                outside of a quoted string.</span>
<a href="#l4.2516"></a><span id="l4.2516" class="difflineplus">+ * @param {Boolean} mayBreakAfter If true, the end of this text is a preferred</span>
<a href="#l4.2517"></a><span id="l4.2517" class="difflineplus">+ *                                breakpoint.</span>
<a href="#l4.2518"></a><span id="l4.2518" class="difflineplus">+ */</span>
<a href="#l4.2519"></a><span id="l4.2519" class="difflineplus">+HeaderEmitter.prototype.addQuotable = function (text, qchars, mayBreakAfter) {</span>
<a href="#l4.2520"></a><span id="l4.2520" class="difflineplus">+  // Figure out if we need to quote the string. Don't quote a string which</span>
<a href="#l4.2521"></a><span id="l4.2521" class="difflineplus">+  // already appears to be quoted.</span>
<a href="#l4.2522"></a><span id="l4.2522" class="difflineplus">+  let needsQuote = false;</span>
<a href="#l4.2523"></a><span id="l4.2523" class="difflineplus">+  if (!(text[0] == '&quot;' &amp;&amp; text[text.length - 1] == '&quot;') &amp;&amp; qchars != '') {</span>
<a href="#l4.2524"></a><span id="l4.2524" class="difflineplus">+    for (let i = 0; i &lt; text.length; i++) {</span>
<a href="#l4.2525"></a><span id="l4.2525" class="difflineplus">+      if (qchars.contains(text[i])) {</span>
<a href="#l4.2526"></a><span id="l4.2526" class="difflineplus">+        needsQuote = true;</span>
<a href="#l4.2527"></a><span id="l4.2527" class="difflineplus">+        break;</span>
<a href="#l4.2528"></a><span id="l4.2528" class="difflineplus">+      }</span>
<a href="#l4.2529"></a><span id="l4.2529" class="difflineplus">+    }</span>
<a href="#l4.2530"></a><span id="l4.2530" class="difflineplus">+  }</span>
<a href="#l4.2531"></a><span id="l4.2531" class="difflineplus">+</span>
<a href="#l4.2532"></a><span id="l4.2532" class="difflineplus">+  if (needsQuote)</span>
<a href="#l4.2533"></a><span id="l4.2533" class="difflineplus">+    text = '&quot;' + text.replace(/[&quot;\\]/g, &quot;\\$&amp;&quot;) + '&quot;';</span>
<a href="#l4.2534"></a><span id="l4.2534" class="difflineplus">+  this.addText(text, mayBreakAfter);</span>
<a href="#l4.2535"></a><span id="l4.2535" class="difflineplus">+};</span>
<a href="#l4.2536"></a><span id="l4.2536" class="difflineplus">+</span>
<a href="#l4.2537"></a><span id="l4.2537" class="difflineplus">+/**</span>
<a href="#l4.2538"></a><span id="l4.2538" class="difflineplus">+ * Adds a block of text that corresponds to the phrase production in RFC 5322.</span>
<a href="#l4.2539"></a><span id="l4.2539" class="difflineplus">+ * Such text is a sequence of atoms, quoted-strings, or RFC-2047 encoded-words.</span>
<a href="#l4.2540"></a><span id="l4.2540" class="difflineplus">+ * This method will preprocess input to normalize all space sequences to a</span>
<a href="#l4.2541"></a><span id="l4.2541" class="difflineplus">+ * single space. If the text cannot be added without violating maximum line</span>
<a href="#l4.2542"></a><span id="l4.2542" class="difflineplus">+ * length, an error is thrown instead.</span>
<a href="#l4.2543"></a><span id="l4.2543" class="difflineplus">+ *</span>
<a href="#l4.2544"></a><span id="l4.2544" class="difflineplus">+ * @protected</span>
<a href="#l4.2545"></a><span id="l4.2545" class="difflineplus">+ * @param {String}  text          The text to add to the output.</span>
<a href="#l4.2546"></a><span id="l4.2546" class="difflineplus">+ * @param {String}  qchars        The set of characters that cannot appear</span>
<a href="#l4.2547"></a><span id="l4.2547" class="difflineplus">+ *                                outside of a quoted string.</span>
<a href="#l4.2548"></a><span id="l4.2548" class="difflineplus">+ * @param {Boolean} mayBreakAfter If true, the end of this text is a preferred</span>
<a href="#l4.2549"></a><span id="l4.2549" class="difflineplus">+ *                                breakpoint.</span>
<a href="#l4.2550"></a><span id="l4.2550" class="difflineplus">+ */</span>
<a href="#l4.2551"></a><span id="l4.2551" class="difflineplus">+HeaderEmitter.prototype.addPhrase = function (text, qchars, mayBreakAfter) {</span>
<a href="#l4.2552"></a><span id="l4.2552" class="difflineplus">+  // Collapse all whitespace spans into a single whitespace node.</span>
<a href="#l4.2553"></a><span id="l4.2553" class="difflineplus">+  text = text.replace(/[ \t\r\n]+/g, &quot; &quot;);</span>
<a href="#l4.2554"></a><span id="l4.2554" class="difflineplus">+</span>
<a href="#l4.2555"></a><span id="l4.2555" class="difflineplus">+  // If we have non-ASCII text, encode it using RFC 2047.</span>
<a href="#l4.2556"></a><span id="l4.2556" class="difflineplus">+  if (this._useASCII &amp;&amp; nonAsciiRe.test(text)) {</span>
<a href="#l4.2557"></a><span id="l4.2557" class="difflineplus">+    this.encodeRFC2047Phrase(text, mayBreakAfter);</span>
<a href="#l4.2558"></a><span id="l4.2558" class="difflineplus">+    return;</span>
<a href="#l4.2559"></a><span id="l4.2559" class="difflineplus">+  }</span>
<a href="#l4.2560"></a><span id="l4.2560"> </span>
<a href="#l4.2561"></a><span id="l4.2561" class="difflineminus">-  // Actually do the matching</span>
<a href="#l4.2562"></a><span id="l4.2562" class="difflineminus">-  var matches = [], match;</span>
<a href="#l4.2563"></a><span id="l4.2563" class="difflineminus">-  while ((match = regex.exec(rest)) != null) {</span>
<a href="#l4.2564"></a><span id="l4.2564" class="difflineminus">-    var name = match[1];</span>
<a href="#l4.2565"></a><span id="l4.2565" class="difflineminus">-    var value = match[2];</span>
<a href="#l4.2566"></a><span id="l4.2566" class="difflineminus">-    if (value.length &gt; 0 &amp;&amp; value[0] == '&quot;') {</span>
<a href="#l4.2567"></a><span id="l4.2567" class="difflineminus">-      let end = value.length &gt; 1 &amp;&amp; value[value.length - 1] == '&quot;' ?</span>
<a href="#l4.2568"></a><span id="l4.2568" class="difflineminus">-        value.length - 1 : value.length;</span>
<a href="#l4.2569"></a><span id="l4.2569" class="difflineminus">-      value = value.substring(1, end).replace(/\\(.)/g, &quot;$1&quot;);</span>
<a href="#l4.2570"></a><span id="l4.2570" class="difflineplus">+  // If quoting the entire string at once could fit in the line length, then do</span>
<a href="#l4.2571"></a><span id="l4.2571" class="difflineplus">+  // so. The check here is very loose, but this will inform is if we are going</span>
<a href="#l4.2572"></a><span id="l4.2572" class="difflineplus">+  // to definitely overrun the soft margin.</span>
<a href="#l4.2573"></a><span id="l4.2573" class="difflineplus">+  if (text.length &lt; this._softMargin) {</span>
<a href="#l4.2574"></a><span id="l4.2574" class="difflineplus">+    try {</span>
<a href="#l4.2575"></a><span id="l4.2575" class="difflineplus">+      this.addQuotable(text, qchars, mayBreakAfter);</span>
<a href="#l4.2576"></a><span id="l4.2576" class="difflineplus">+      // If we don't have a breakpoint, and the text is encoded as a sequence of</span>
<a href="#l4.2577"></a><span id="l4.2577" class="difflineplus">+      // atoms (and not a quoted-string), then make the last space we added a</span>
<a href="#l4.2578"></a><span id="l4.2578" class="difflineplus">+      // breakpoint, regardless of the mayBreakAfter setting.</span>
<a href="#l4.2579"></a><span id="l4.2579" class="difflineplus">+      if (this._preferredBreakpoint == 0 &amp;&amp; text.contains(&quot; &quot;)) {</span>
<a href="#l4.2580"></a><span id="l4.2580" class="difflineplus">+        if (this._currentLine[this._currentLine.length - 1] != '&quot;')</span>
<a href="#l4.2581"></a><span id="l4.2581" class="difflineplus">+          this._preferredBreakpoint = this._currentLine.lastIndexOf(&quot; &quot;);</span>
<a href="#l4.2582"></a><span id="l4.2582" class="difflineplus">+      }</span>
<a href="#l4.2583"></a><span id="l4.2583" class="difflineplus">+      return;</span>
<a href="#l4.2584"></a><span id="l4.2584" class="difflineplus">+    } catch (e) {</span>
<a href="#l4.2585"></a><span id="l4.2585" class="difflineplus">+      // If we get an error at this point, we failed to add the quoted string</span>
<a href="#l4.2586"></a><span id="l4.2586" class="difflineplus">+      // because the string was too long. Fall through to the case where we know</span>
<a href="#l4.2587"></a><span id="l4.2587" class="difflineplus">+      // that the input was too long to begin with.</span>
<a href="#l4.2588"></a><span id="l4.2588">     }</span>
<a href="#l4.2589"></a><span id="l4.2589" class="difflineminus">-    matches.push([name, value]);</span>
<a href="#l4.2590"></a><span id="l4.2590" class="difflineplus">+  }</span>
<a href="#l4.2591"></a><span id="l4.2591" class="difflineplus">+</span>
<a href="#l4.2592"></a><span id="l4.2592" class="difflineplus">+  // If the text is too long, split the quotable string at space boundaries and</span>
<a href="#l4.2593"></a><span id="l4.2593" class="difflineplus">+  // add each word invidually. If we still can't add all those words, there is</span>
<a href="#l4.2594"></a><span id="l4.2594" class="difflineplus">+  // nothing that we can do.</span>
<a href="#l4.2595"></a><span id="l4.2595" class="difflineplus">+  let words = text.split(' ');</span>
<a href="#l4.2596"></a><span id="l4.2596" class="difflineplus">+  for (let i = 0; i &lt; words.length; i++) {</span>
<a href="#l4.2597"></a><span id="l4.2597" class="difflineplus">+    this.addQuotable(words[i], qchars,</span>
<a href="#l4.2598"></a><span id="l4.2598" class="difflineplus">+      i == words.length - 1 ? mayBreakAfter : true);</span>
<a href="#l4.2599"></a><span id="l4.2599" class="difflineplus">+  }</span>
<a href="#l4.2600"></a><span id="l4.2600" class="difflineplus">+};</span>
<a href="#l4.2601"></a><span id="l4.2601" class="difflineplus">+</span>
<a href="#l4.2602"></a><span id="l4.2602" class="difflineplus">+/// A regular expression for characters that need to be encoded.</span>
<a href="#l4.2603"></a><span id="l4.2603" class="difflineplus">+let nonAsciiRe = /[^\x20-\x7e]/;</span>
<a href="#l4.2604"></a><span id="l4.2604" class="difflineplus">+</span>
<a href="#l4.2605"></a><span id="l4.2605" class="difflineplus">+/// The beginnings of RFC 2047 encoded-word</span>
<a href="#l4.2606"></a><span id="l4.2606" class="difflineplus">+const b64Prelude = &quot;=?UTF-8?B?&quot;, qpPrelude = &quot;=?UTF-8?Q?&quot;;</span>
<a href="#l4.2607"></a><span id="l4.2607" class="difflineplus">+</span>
<a href="#l4.2608"></a><span id="l4.2608" class="difflineplus">+/// A list of ASCII characters forbidden in RFC 2047 encoded-words</span>
<a href="#l4.2609"></a><span id="l4.2609" class="difflineplus">+const qpForbidden = &quot;=?_()\&quot;&quot;;</span>
<a href="#l4.2610"></a><span id="l4.2610" class="difflineplus">+</span>
<a href="#l4.2611"></a><span id="l4.2611" class="difflineplus">+const hexString = &quot;0123456789abcdef&quot;;</span>
<a href="#l4.2612"></a><span id="l4.2612" class="difflineplus">+</span>
<a href="#l4.2613"></a><span id="l4.2613" class="difflineplus">+/**</span>
<a href="#l4.2614"></a><span id="l4.2614" class="difflineplus">+ * Add a block of text as a single RFC 2047 encoded word. This does not try to</span>
<a href="#l4.2615"></a><span id="l4.2615" class="difflineplus">+ * split words if they are too long.</span>
<a href="#l4.2616"></a><span id="l4.2616" class="difflineplus">+ *</span>
<a href="#l4.2617"></a><span id="l4.2617" class="difflineplus">+ * @private</span>
<a href="#l4.2618"></a><span id="l4.2618" class="difflineplus">+ * @param {Uint8Array} encodedText   The octets to encode.</span>
<a href="#l4.2619"></a><span id="l4.2619" class="difflineplus">+ * @param {Boolean}    useQP         If true, use quoted-printable; if false,</span>
<a href="#l4.2620"></a><span id="l4.2620" class="difflineplus">+ *                                   use base64.</span>
<a href="#l4.2621"></a><span id="l4.2621" class="difflineplus">+ * @param {Boolean}    mayBreakAfter If true, the end of this text is a</span>
<a href="#l4.2622"></a><span id="l4.2622" class="difflineplus">+ *                                   preferred breakpoint.</span>
<a href="#l4.2623"></a><span id="l4.2623" class="difflineplus">+ */</span>
<a href="#l4.2624"></a><span id="l4.2624" class="difflineplus">+HeaderEmitter.prototype._addRFC2047Word = function (encodedText, useQP,</span>
<a href="#l4.2625"></a><span id="l4.2625" class="difflineplus">+    mayBreakAfter) {</span>
<a href="#l4.2626"></a><span id="l4.2626" class="difflineplus">+  let binaryString = mimeutils.typedArrayToString(encodedText);</span>
<a href="#l4.2627"></a><span id="l4.2627" class="difflineplus">+  if (useQP) {</span>
<a href="#l4.2628"></a><span id="l4.2628" class="difflineplus">+    var token = qpPrelude;</span>
<a href="#l4.2629"></a><span id="l4.2629" class="difflineplus">+    for (let i = 0; i &lt; encodedText.length; i++) {</span>
<a href="#l4.2630"></a><span id="l4.2630" class="difflineplus">+      if (encodedText[i] &lt; 0x20 || encodedText[i] &gt;= 0x7F ||</span>
<a href="#l4.2631"></a><span id="l4.2631" class="difflineplus">+          qpForbidden.contains(binaryString[i])) {</span>
<a href="#l4.2632"></a><span id="l4.2632" class="difflineplus">+        let ch = encodedText[i];</span>
<a href="#l4.2633"></a><span id="l4.2633" class="difflineplus">+        token += &quot;=&quot; + hexString[(ch &amp; 0xf0) &gt;&gt; 4] + hexString[ch &amp; 0x0f];</span>
<a href="#l4.2634"></a><span id="l4.2634" class="difflineplus">+      } else if (binaryString[i] == &quot; &quot;) {</span>
<a href="#l4.2635"></a><span id="l4.2635" class="difflineplus">+        token += &quot;_&quot;;</span>
<a href="#l4.2636"></a><span id="l4.2636" class="difflineplus">+      } else {</span>
<a href="#l4.2637"></a><span id="l4.2637" class="difflineplus">+        token += binaryString[i];</span>
<a href="#l4.2638"></a><span id="l4.2638" class="difflineplus">+      }</span>
<a href="#l4.2639"></a><span id="l4.2639" class="difflineplus">+    }</span>
<a href="#l4.2640"></a><span id="l4.2640" class="difflineplus">+    token += &quot;?=&quot;;</span>
<a href="#l4.2641"></a><span id="l4.2641" class="difflineplus">+  } else {</span>
<a href="#l4.2642"></a><span id="l4.2642" class="difflineplus">+    var token = b64Prelude + btoa(binaryString) + &quot;?=&quot;;</span>
<a href="#l4.2643"></a><span id="l4.2643" class="difflineplus">+  }</span>
<a href="#l4.2644"></a><span id="l4.2644" class="difflineplus">+  this.addText(token, mayBreakAfter);</span>
<a href="#l4.2645"></a><span id="l4.2645" class="difflineplus">+};</span>
<a href="#l4.2646"></a><span id="l4.2646" class="difflineplus">+</span>
<a href="#l4.2647"></a><span id="l4.2647" class="difflineplus">+/**</span>
<a href="#l4.2648"></a><span id="l4.2648" class="difflineplus">+ * Add a block of text as potentially several RFC 2047 encoded-word tokens.</span>
<a href="#l4.2649"></a><span id="l4.2649" class="difflineplus">+ *</span>
<a href="#l4.2650"></a><span id="l4.2650" class="difflineplus">+ * @protected</span>
<a href="#l4.2651"></a><span id="l4.2651" class="difflineplus">+ * @param {String}  text          The text to add to the output.</span>
<a href="#l4.2652"></a><span id="l4.2652" class="difflineplus">+ * @param {Boolean} mayBreakAfter If true, the end of this text is a preferred</span>
<a href="#l4.2653"></a><span id="l4.2653" class="difflineplus">+ *                                breakpoint.</span>
<a href="#l4.2654"></a><span id="l4.2654" class="difflineplus">+ */</span>
<a href="#l4.2655"></a><span id="l4.2655" class="difflineplus">+HeaderEmitter.prototype.encodeRFC2047Phrase = function (text, mayBreakAfter) {</span>
<a href="#l4.2656"></a><span id="l4.2656" class="difflineplus">+  // Start by encoding the text into UTF-8 directly.</span>
<a href="#l4.2657"></a><span id="l4.2657" class="difflineplus">+  let encodedText = new TextEncoder(&quot;UTF-8&quot;).encode(text);</span>
<a href="#l4.2658"></a><span id="l4.2658" class="difflineplus">+</span>
<a href="#l4.2659"></a><span id="l4.2659" class="difflineplus">+  // Make sure there's enough room for a single token.</span>
<a href="#l4.2660"></a><span id="l4.2660" class="difflineplus">+  let minLineLen = b64Prelude.length + 10; // Eight base64 characters plus ?=</span>
<a href="#l4.2661"></a><span id="l4.2661" class="difflineplus">+  if (!this._reserveTokenSpace(minLineLen)) {</span>
<a href="#l4.2662"></a><span id="l4.2662" class="difflineplus">+    this._commitLine(this._currentLine.length);</span>
<a href="#l4.2663"></a><span id="l4.2663">   }</span>
<a href="#l4.2664"></a><span id="l4.2664"> </span>
<a href="#l4.2665"></a><span id="l4.2665" class="difflineminus">-  // Now matches holds the parameters. Clean up for RFC 2231. There are four</span>
<a href="#l4.2666"></a><span id="l4.2666" class="difflineminus">-  // cases: param=val, param*=us-ascii'en-US'blah, and param*n= variants. The</span>
<a href="#l4.2667"></a><span id="l4.2667" class="difflineminus">-  // order of preference is to pick the middle, then the last, then the first.</span>
<a href="#l4.2668"></a><span id="l4.2668" class="difflineminus">-  // TODO: RFC 2231 is yet to be implemented</span>
<a href="#l4.2669"></a><span id="l4.2669" class="difflineminus">-  var simpleValues = {};</span>
<a href="#l4.2670"></a><span id="l4.2670" class="difflineminus">-  for (let [name, value] of matches) {</span>
<a href="#l4.2671"></a><span id="l4.2671" class="difflineminus">-    // The first match of simple param=val wins.</span>
<a href="#l4.2672"></a><span id="l4.2672" class="difflineminus">-    if (!(name in simpleValues))</span>
<a href="#l4.2673"></a><span id="l4.2673" class="difflineminus">-      simpleValues[name] = value;</span>
<a href="#l4.2674"></a><span id="l4.2674" class="difflineplus">+  // Try to encode as much UTF-8 text as possible in each go.</span>
<a href="#l4.2675"></a><span id="l4.2675" class="difflineplus">+  let b64Len = 0, qpLen = 0, start = 0;</span>
<a href="#l4.2676"></a><span id="l4.2676" class="difflineplus">+  let maxChars = (this._softMargin - this._currentLine.length) -</span>
<a href="#l4.2677"></a><span id="l4.2677" class="difflineplus">+    (b64Prelude.length + 2);</span>
<a href="#l4.2678"></a><span id="l4.2678" class="difflineplus">+  for (let i = 0; i &lt; encodedText.length; i++) {</span>
<a href="#l4.2679"></a><span id="l4.2679" class="difflineplus">+    let b64Inc = 0, qpInc = 0;</span>
<a href="#l4.2680"></a><span id="l4.2680" class="difflineplus">+    // The length we need for base64 is ceil(length / 3) * 4...</span>
<a href="#l4.2681"></a><span id="l4.2681" class="difflineplus">+    if ((i - start) % 3 == 0)</span>
<a href="#l4.2682"></a><span id="l4.2682" class="difflineplus">+      b64Inc += 4;</span>
<a href="#l4.2683"></a><span id="l4.2683" class="difflineplus">+</span>
<a href="#l4.2684"></a><span id="l4.2684" class="difflineplus">+    // The length for quoted-printable is 3 chars only if encoded</span>
<a href="#l4.2685"></a><span id="l4.2685" class="difflineplus">+    if (encodedText[i] &lt; 0x20 || encodedText[i] &gt;= 0x7f ||</span>
<a href="#l4.2686"></a><span id="l4.2686" class="difflineplus">+        qpForbidden.contains(String.fromCharCode(encodedText[i]))) {</span>
<a href="#l4.2687"></a><span id="l4.2687" class="difflineplus">+      qpInc = 3;</span>
<a href="#l4.2688"></a><span id="l4.2688" class="difflineplus">+    } else {</span>
<a href="#l4.2689"></a><span id="l4.2689" class="difflineplus">+      qpInc = 1;</span>
<a href="#l4.2690"></a><span id="l4.2690" class="difflineplus">+    }</span>
<a href="#l4.2691"></a><span id="l4.2691" class="difflineplus">+</span>
<a href="#l4.2692"></a><span id="l4.2692" class="difflineplus">+    if (b64Len + b64Inc &gt; maxChars &amp;&amp; qpLen + qpInc &gt; maxChars) {</span>
<a href="#l4.2693"></a><span id="l4.2693" class="difflineplus">+      // Oops, we have too many characters! We need to encode everything through</span>
<a href="#l4.2694"></a><span id="l4.2694" class="difflineplus">+      // the current character. However, we can't split in the middle of a</span>
<a href="#l4.2695"></a><span id="l4.2695" class="difflineplus">+      // multibyte character. In UTF-8, characters that start with 10xx xxxx are</span>
<a href="#l4.2696"></a><span id="l4.2696" class="difflineplus">+      // the middle of multibyte characters, so backtrack until the start</span>
<a href="#l4.2697"></a><span id="l4.2697" class="difflineplus">+      // character is legal.</span>
<a href="#l4.2698"></a><span id="l4.2698" class="difflineplus">+      while ((encodedText[i] &amp; 0xC0) == 0x80)</span>
<a href="#l4.2699"></a><span id="l4.2699" class="difflineplus">+        --i;</span>
<a href="#l4.2700"></a><span id="l4.2700" class="difflineplus">+</span>
<a href="#l4.2701"></a><span id="l4.2701" class="difflineplus">+      // Add this part of the word and then make a continuation.</span>
<a href="#l4.2702"></a><span id="l4.2702" class="difflineplus">+      this._addRFC2047Word(encodedText.subarray(start, i), b64Len &gt;= qpLen,</span>
<a href="#l4.2703"></a><span id="l4.2703" class="difflineplus">+        true);</span>
<a href="#l4.2704"></a><span id="l4.2704" class="difflineplus">+</span>
<a href="#l4.2705"></a><span id="l4.2705" class="difflineplus">+      // Reset the array for parsing.</span>
<a href="#l4.2706"></a><span id="l4.2706" class="difflineplus">+      start = i;</span>
<a href="#l4.2707"></a><span id="l4.2707" class="difflineplus">+      --i; // Reparse this character as well</span>
<a href="#l4.2708"></a><span id="l4.2708" class="difflineplus">+      b64Len = qpLen = 0;</span>
<a href="#l4.2709"></a><span id="l4.2709" class="difflineplus">+      maxChars = this._softMargin - b64Prelude.length - 3;</span>
<a href="#l4.2710"></a><span id="l4.2710" class="difflineplus">+    } else {</span>
<a href="#l4.2711"></a><span id="l4.2711" class="difflineplus">+      // Add the counts for the current variable to the count to encode.</span>
<a href="#l4.2712"></a><span id="l4.2712" class="difflineplus">+      b64Len += b64Inc;</span>
<a href="#l4.2713"></a><span id="l4.2713" class="difflineplus">+      qpLen += qpInc;</span>
<a href="#l4.2714"></a><span id="l4.2714" class="difflineplus">+    }</span>
<a href="#l4.2715"></a><span id="l4.2715" class="difflineplus">+  }</span>
<a href="#l4.2716"></a><span id="l4.2716" class="difflineplus">+</span>
<a href="#l4.2717"></a><span id="l4.2717" class="difflineplus">+  // Add the entire array at this point.</span>
<a href="#l4.2718"></a><span id="l4.2718" class="difflineplus">+  this._addRFC2047Word(encodedText.subarray(start), b64Len &gt;= qpLen,</span>
<a href="#l4.2719"></a><span id="l4.2719" class="difflineplus">+    mayBreakAfter);</span>
<a href="#l4.2720"></a><span id="l4.2720" class="difflineplus">+};</span>
<a href="#l4.2721"></a><span id="l4.2721" class="difflineplus">+</span>
<a href="#l4.2722"></a><span id="l4.2722" class="difflineplus">+////////////////////////</span>
<a href="#l4.2723"></a><span id="l4.2723" class="difflineplus">+// High-level methods //</span>
<a href="#l4.2724"></a><span id="l4.2724" class="difflineplus">+////////////////////////</span>
<a href="#l4.2725"></a><span id="l4.2725" class="difflineplus">+</span>
<a href="#l4.2726"></a><span id="l4.2726" class="difflineplus">+/**</span>
<a href="#l4.2727"></a><span id="l4.2727" class="difflineplus">+ * Add the header name, with the colon and trailing space, to the output.</span>
<a href="#l4.2728"></a><span id="l4.2728" class="difflineplus">+ *</span>
<a href="#l4.2729"></a><span id="l4.2729" class="difflineplus">+ * @public</span>
<a href="#l4.2730"></a><span id="l4.2730" class="difflineplus">+ * @param {String} name The name of the header.</span>
<a href="#l4.2731"></a><span id="l4.2731" class="difflineplus">+ */</span>
<a href="#l4.2732"></a><span id="l4.2732" class="difflineplus">+HeaderEmitter.prototype.addHeaderName = function (name) {</span>
<a href="#l4.2733"></a><span id="l4.2733" class="difflineplus">+  this._currentLine = this._currentLine.trimRight();</span>
<a href="#l4.2734"></a><span id="l4.2734" class="difflineplus">+  if (this._currentLine.length &gt; 0) {</span>
<a href="#l4.2735"></a><span id="l4.2735" class="difflineplus">+    this._commitLine();</span>
<a href="#l4.2736"></a><span id="l4.2736" class="difflineplus">+  }</span>
<a href="#l4.2737"></a><span id="l4.2737" class="difflineplus">+  this.addText(name + &quot;: &quot;, true);</span>
<a href="#l4.2738"></a><span id="l4.2738" class="difflineplus">+};</span>
<a href="#l4.2739"></a><span id="l4.2739" class="difflineplus">+</span>
<a href="#l4.2740"></a><span id="l4.2740" class="difflineplus">+/**</span>
<a href="#l4.2741"></a><span id="l4.2741" class="difflineplus">+ * Add a header and its structured value to the output.</span>
<a href="#l4.2742"></a><span id="l4.2742" class="difflineplus">+ *</span>
<a href="#l4.2743"></a><span id="l4.2743" class="difflineplus">+ * The name can be any case-insensitive variant of a known structured header;</span>
<a href="#l4.2744"></a><span id="l4.2744" class="difflineplus">+ * the output will include the preferred name of the structure instead of the</span>
<a href="#l4.2745"></a><span id="l4.2745" class="difflineplus">+ * case put into the name. If no structured encoder can be found, and the input</span>
<a href="#l4.2746"></a><span id="l4.2746" class="difflineplus">+ * value is a string, then the header is assumed to be unstructured and the</span>
<a href="#l4.2747"></a><span id="l4.2747" class="difflineplus">+ * value is added as if {@link addUnstructured} were called.</span>
<a href="#l4.2748"></a><span id="l4.2748" class="difflineplus">+ *</span>
<a href="#l4.2749"></a><span id="l4.2749" class="difflineplus">+ * @public</span>
<a href="#l4.2750"></a><span id="l4.2750" class="difflineplus">+ * @param {String} name  The name of the header.</span>
<a href="#l4.2751"></a><span id="l4.2751" class="difflineplus">+ * @param          value The structured value of the header.</span>
<a href="#l4.2752"></a><span id="l4.2752" class="difflineplus">+ */</span>
<a href="#l4.2753"></a><span id="l4.2753" class="difflineplus">+HeaderEmitter.prototype.addStructuredHeader = function (name, value) {</span>
<a href="#l4.2754"></a><span id="l4.2754" class="difflineplus">+  let lowerName = name.toLowerCase();</span>
<a href="#l4.2755"></a><span id="l4.2755" class="difflineplus">+  if (encoders.has(lowerName)) {</span>
<a href="#l4.2756"></a><span id="l4.2756" class="difflineplus">+    this.addHeaderName(preferredSpellings.get(lowerName));</span>
<a href="#l4.2757"></a><span id="l4.2757" class="difflineplus">+    encoders.get(lowerName).call(this, value);</span>
<a href="#l4.2758"></a><span id="l4.2758" class="difflineplus">+  } else if (typeof value === &quot;string&quot;) {</span>
<a href="#l4.2759"></a><span id="l4.2759" class="difflineplus">+    // Assume it's an unstructured header</span>
<a href="#l4.2760"></a><span id="l4.2760" class="difflineplus">+    this.addHeaderName(name);</span>
<a href="#l4.2761"></a><span id="l4.2761" class="difflineplus">+    this.addUnstructured(value);</span>
<a href="#l4.2762"></a><span id="l4.2762" class="difflineplus">+  } else {</span>
<a href="#l4.2763"></a><span id="l4.2763" class="difflineplus">+    throw new Error(&quot;Unknown header &quot; + name);</span>
<a href="#l4.2764"></a><span id="l4.2764">   }</span>
<a href="#l4.2765"></a><span id="l4.2765" class="difflineminus">-  return [start, simpleValues];</span>
<a href="#l4.2766"></a><span id="l4.2766" class="difflineplus">+};</span>
<a href="#l4.2767"></a><span id="l4.2767" class="difflineplus">+</span>
<a href="#l4.2768"></a><span id="l4.2768" class="difflineplus">+/**</span>
<a href="#l4.2769"></a><span id="l4.2769" class="difflineplus">+ * Add a single address to the header. The address is an object consisting of a</span>
<a href="#l4.2770"></a><span id="l4.2770" class="difflineplus">+ * possibly-empty display name and an email address.</span>
<a href="#l4.2771"></a><span id="l4.2771" class="difflineplus">+ *</span>
<a href="#l4.2772"></a><span id="l4.2772" class="difflineplus">+ * @public</span>
<a href="#l4.2773"></a><span id="l4.2773" class="difflineplus">+ * @param Address addr The address to be added.</span>
<a href="#l4.2774"></a><span id="l4.2774" class="difflineplus">+ * @param {String} addr.name  The (possibly-empty) name of the address to add.</span>
<a href="#l4.2775"></a><span id="l4.2775" class="difflineplus">+ * @param {String} addr.email The email of the address to add.</span>
<a href="#l4.2776"></a><span id="l4.2776" class="difflineplus">+ * @see headerparser.parseAddressingHeader</span>
<a href="#l4.2777"></a><span id="l4.2777" class="difflineplus">+ */</span>
<a href="#l4.2778"></a><span id="l4.2778" class="difflineplus">+HeaderEmitter.prototype.addAddress = function (addr) {</span>
<a href="#l4.2779"></a><span id="l4.2779" class="difflineplus">+  // If we have a display name, add that first.</span>
<a href="#l4.2780"></a><span id="l4.2780" class="difflineplus">+  if (addr.name) {</span>
<a href="#l4.2781"></a><span id="l4.2781" class="difflineplus">+    // This is a simple estimate that keeps names on one line if possible.</span>
<a href="#l4.2782"></a><span id="l4.2782" class="difflineplus">+    this._reserveTokenSpace(addr.name.length + addr.email.length + 3);</span>
<a href="#l4.2783"></a><span id="l4.2783" class="difflineplus">+    this.addPhrase(addr.name, &quot;,()&lt;&gt;:;.\&quot;&quot;, true);</span>
<a href="#l4.2784"></a><span id="l4.2784" class="difflineplus">+    this.addText(&quot;&lt;&quot;, false);</span>
<a href="#l4.2785"></a><span id="l4.2785" class="difflineplus">+  }</span>
<a href="#l4.2786"></a><span id="l4.2786" class="difflineplus">+</span>
<a href="#l4.2787"></a><span id="l4.2787" class="difflineplus">+  // Find the local-part and domain of the address, since the local-part may</span>
<a href="#l4.2788"></a><span id="l4.2788" class="difflineplus">+  // need to be quoted separately. Note that the @ goes to the domain, so that</span>
<a href="#l4.2789"></a><span id="l4.2789" class="difflineplus">+  // the local-part may be quoted if it needs to be.</span>
<a href="#l4.2790"></a><span id="l4.2790" class="difflineplus">+  let at = addr.email.lastIndexOf(&quot;@&quot;);</span>
<a href="#l4.2791"></a><span id="l4.2791" class="difflineplus">+  let localpart = &quot;&quot;, domain = &quot;&quot;</span>
<a href="#l4.2792"></a><span id="l4.2792" class="difflineplus">+  if (at == -1)</span>
<a href="#l4.2793"></a><span id="l4.2793" class="difflineplus">+    localpart = addr.email;</span>
<a href="#l4.2794"></a><span id="l4.2794" class="difflineplus">+  else {</span>
<a href="#l4.2795"></a><span id="l4.2795" class="difflineplus">+    localpart = addr.email.slice(0, at);</span>
<a href="#l4.2796"></a><span id="l4.2796" class="difflineplus">+    domain = addr.email.slice(at);</span>
<a href="#l4.2797"></a><span id="l4.2797" class="difflineplus">+  }</span>
<a href="#l4.2798"></a><span id="l4.2798" class="difflineplus">+</span>
<a href="#l4.2799"></a><span id="l4.2799" class="difflineplus">+  this.addQuotable(localpart, &quot;()&lt;&gt;[]:;@\\,\&quot; !&quot;, false);</span>
<a href="#l4.2800"></a><span id="l4.2800" class="difflineplus">+  this.addText(domain + (addr.name ? &quot;&gt;&quot; : &quot;&quot;), false);</span>
<a href="#l4.2801"></a><span id="l4.2801" class="difflineplus">+};</span>
<a href="#l4.2802"></a><span id="l4.2802" class="difflineplus">+</span>
<a href="#l4.2803"></a><span id="l4.2803" class="difflineplus">+/**</span>
<a href="#l4.2804"></a><span id="l4.2804" class="difflineplus">+ * Add an array of addresses and groups to the output. Such an array may be</span>
<a href="#l4.2805"></a><span id="l4.2805" class="difflineplus">+ * found as the output of {@link headerparser.parseAddressingHeader}. Each</span>
<a href="#l4.2806"></a><span id="l4.2806" class="difflineplus">+ * element is either an address (an object with properties name and email), or a</span>
<a href="#l4.2807"></a><span id="l4.2807" class="difflineplus">+ * group (an object with properties name and group).</span>
<a href="#l4.2808"></a><span id="l4.2808" class="difflineplus">+ *</span>
<a href="#l4.2809"></a><span id="l4.2809" class="difflineplus">+ * @public</span>
<a href="#l4.2810"></a><span id="l4.2810" class="difflineplus">+ * @param {(Address|Group)[]} addrs A collection of addresses to add.</span>
<a href="#l4.2811"></a><span id="l4.2811" class="difflineplus">+ * @param {String}    addrs[i].name    The (possibly-empty) name of the</span>
<a href="#l4.2812"></a><span id="l4.2812" class="difflineplus">+ *                                     address or the group to add.</span>
<a href="#l4.2813"></a><span id="l4.2813" class="difflineplus">+ * @param {String}    [addrs[i].email] The email of the address to add.</span>
<a href="#l4.2814"></a><span id="l4.2814" class="difflineplus">+ * @param {Address[]} [addrs[i].group] A list of email addresses in the group.</span>
<a href="#l4.2815"></a><span id="l4.2815" class="difflineplus">+ * @see HeaderEmitter.addAddress</span>
<a href="#l4.2816"></a><span id="l4.2816" class="difflineplus">+ * @see headerparser.parseAddressingHeader</span>
<a href="#l4.2817"></a><span id="l4.2817" class="difflineplus">+ */</span>
<a href="#l4.2818"></a><span id="l4.2818" class="difflineplus">+HeaderEmitter.prototype.addAddresses = function (addresses) {</span>
<a href="#l4.2819"></a><span id="l4.2819" class="difflineplus">+  let needsComma = false;</span>
<a href="#l4.2820"></a><span id="l4.2820" class="difflineplus">+  for (let addr of addresses) {</span>
<a href="#l4.2821"></a><span id="l4.2821" class="difflineplus">+    // Ignore a dummy empty address.</span>
<a href="#l4.2822"></a><span id="l4.2822" class="difflineplus">+    if (&quot;email&quot; in addr &amp;&amp; addr.email === &quot;&quot;)</span>
<a href="#l4.2823"></a><span id="l4.2823" class="difflineplus">+      continue;</span>
<a href="#l4.2824"></a><span id="l4.2824" class="difflineplus">+</span>
<a href="#l4.2825"></a><span id="l4.2825" class="difflineplus">+    // Add a comma if this is not the first element.</span>
<a href="#l4.2826"></a><span id="l4.2826" class="difflineplus">+    if (needsComma)</span>
<a href="#l4.2827"></a><span id="l4.2827" class="difflineplus">+      this.addText(&quot;, &quot;, true);</span>
<a href="#l4.2828"></a><span id="l4.2828" class="difflineplus">+    needsComma = true;</span>
<a href="#l4.2829"></a><span id="l4.2829" class="difflineplus">+</span>
<a href="#l4.2830"></a><span id="l4.2830" class="difflineplus">+    if (&quot;email&quot; in addr) {</span>
<a href="#l4.2831"></a><span id="l4.2831" class="difflineplus">+      this.addAddress(addr);</span>
<a href="#l4.2832"></a><span id="l4.2832" class="difflineplus">+    } else {</span>
<a href="#l4.2833"></a><span id="l4.2833" class="difflineplus">+      // A group has format name: member, member;</span>
<a href="#l4.2834"></a><span id="l4.2834" class="difflineplus">+      // Note that we still add a comma after the group is completed.</span>
<a href="#l4.2835"></a><span id="l4.2835" class="difflineplus">+      this.addPhrase(addr.name, &quot;,()&lt;&gt;:;.\&quot;&quot;, false);</span>
<a href="#l4.2836"></a><span id="l4.2836" class="difflineplus">+      this.addText(&quot;:&quot;, true);</span>
<a href="#l4.2837"></a><span id="l4.2837" class="difflineplus">+</span>
<a href="#l4.2838"></a><span id="l4.2838" class="difflineplus">+      this.addAddresses(addr.group);</span>
<a href="#l4.2839"></a><span id="l4.2839" class="difflineplus">+      this.addText(&quot;;&quot;, true);</span>
<a href="#l4.2840"></a><span id="l4.2840" class="difflineplus">+    }</span>
<a href="#l4.2841"></a><span id="l4.2841" class="difflineplus">+  }</span>
<a href="#l4.2842"></a><span id="l4.2842" class="difflineplus">+};</span>
<a href="#l4.2843"></a><span id="l4.2843" class="difflineplus">+</span>
<a href="#l4.2844"></a><span id="l4.2844" class="difflineplus">+/**</span>
<a href="#l4.2845"></a><span id="l4.2845" class="difflineplus">+ * Add an unstructured header value to the output. This effectively means only</span>
<a href="#l4.2846"></a><span id="l4.2846" class="difflineplus">+ * inserting line breaks were necessary, and using RFC 2047 encoding where</span>
<a href="#l4.2847"></a><span id="l4.2847" class="difflineplus">+ * necessary.</span>
<a href="#l4.2848"></a><span id="l4.2848" class="difflineplus">+ *</span>
<a href="#l4.2849"></a><span id="l4.2849" class="difflineplus">+ * @public</span>
<a href="#l4.2850"></a><span id="l4.2850" class="difflineplus">+ * @param {String} text The text to add to the output.</span>
<a href="#l4.2851"></a><span id="l4.2851" class="difflineplus">+ */</span>
<a href="#l4.2852"></a><span id="l4.2852" class="difflineplus">+HeaderEmitter.prototype.addUnstructured = function (text) {</span>
<a href="#l4.2853"></a><span id="l4.2853" class="difflineplus">+  // Unstructured text is basically a phrase that can't be quoted. So, if we</span>
<a href="#l4.2854"></a><span id="l4.2854" class="difflineplus">+  // have nothing in qchars, nothing should be quoted.</span>
<a href="#l4.2855"></a><span id="l4.2855" class="difflineplus">+  this.addPhrase(text, &quot;&quot;, false);</span>
<a href="#l4.2856"></a><span id="l4.2856" class="difflineplus">+};</span>
<a href="#l4.2857"></a><span id="l4.2857" class="difflineplus">+</span>
<a href="#l4.2858"></a><span id="l4.2858" class="difflineplus">+/**</span>
<a href="#l4.2859"></a><span id="l4.2859" class="difflineplus">+ * Signal that the current header has been finished encoding.</span>
<a href="#l4.2860"></a><span id="l4.2860" class="difflineplus">+ *</span>
<a href="#l4.2861"></a><span id="l4.2861" class="difflineplus">+ * @public</span>
<a href="#l4.2862"></a><span id="l4.2862" class="difflineplus">+ * @param {Boolean} deliverEOF If true, signal to the handler that no more text</span>
<a href="#l4.2863"></a><span id="l4.2863" class="difflineplus">+ *                             will be arriving.</span>
<a href="#l4.2864"></a><span id="l4.2864" class="difflineplus">+ */</span>
<a href="#l4.2865"></a><span id="l4.2865" class="difflineplus">+HeaderEmitter.prototype.finish = function (deliverEOF) {</span>
<a href="#l4.2866"></a><span id="l4.2866" class="difflineplus">+  this._commitLine();</span>
<a href="#l4.2867"></a><span id="l4.2867" class="difflineplus">+  if (deliverEOF)</span>
<a href="#l4.2868"></a><span id="l4.2868" class="difflineplus">+    this._handler.deliverEOF();</span>
<a href="#l4.2869"></a><span id="l4.2869" class="difflineplus">+};</span>
<a href="#l4.2870"></a><span id="l4.2870" class="difflineplus">+</span>
<a href="#l4.2871"></a><span id="l4.2871" class="difflineplus">+/**</span>
<a href="#l4.2872"></a><span id="l4.2872" class="difflineplus">+ * Make a streaming header emitter that outputs on the given handler.</span>
<a href="#l4.2873"></a><span id="l4.2873" class="difflineplus">+ *</span>
<a href="#l4.2874"></a><span id="l4.2874" class="difflineplus">+ * @param {StreamHandler} handler The handler to consume output</span>
<a href="#l4.2875"></a><span id="l4.2875" class="difflineplus">+ * @param                 options Options to pass into the HeaderEmitter</span>
<a href="#l4.2876"></a><span id="l4.2876" class="difflineplus">+ *                                constructor.</span>
<a href="#l4.2877"></a><span id="l4.2877" class="difflineplus">+ * @returns {HeaderEmitter} A header emitter constructed with the given options.</span>
<a href="#l4.2878"></a><span id="l4.2878" class="difflineplus">+ */</span>
<a href="#l4.2879"></a><span id="l4.2879" class="difflineplus">+function makeStreamingEmitter(handler, options) {</span>
<a href="#l4.2880"></a><span id="l4.2880" class="difflineplus">+  return new HeaderEmitter(handler, options);</span>
<a href="#l4.2881"></a><span id="l4.2881"> }</span>
<a href="#l4.2882"></a><span id="l4.2882"> </span>
<a href="#l4.2883"></a><span id="l4.2883" class="difflineminus">-var StructuredDecoders = {};</span>
<a href="#l4.2884"></a><span id="l4.2884" class="difflineminus">-StructuredDecoders['content-type'] = function structure_content_type(value) {</span>
<a href="#l4.2885"></a><span id="l4.2885" class="difflineminus">-  let [type, params] = extractParameters(value);</span>
<a href="#l4.2886"></a><span id="l4.2886" class="difflineminus">-  let parts = type.split('/');</span>
<a href="#l4.2887"></a><span id="l4.2887" class="difflineminus">-  if (parts.length != 2) {</span>
<a href="#l4.2888"></a><span id="l4.2888" class="difflineminus">-    // Malformed. Return to text/plain. Evil, ain't it?</span>
<a href="#l4.2889"></a><span id="l4.2889" class="difflineminus">-    params = {};</span>
<a href="#l4.2890"></a><span id="l4.2890" class="difflineminus">-    parts = [&quot;text&quot;, &quot;plain&quot;];</span>
<a href="#l4.2891"></a><span id="l4.2891" class="difflineplus">+function StringHandler() {</span>
<a href="#l4.2892"></a><span id="l4.2892" class="difflineplus">+  this.value = &quot;&quot;;</span>
<a href="#l4.2893"></a><span id="l4.2893" class="difflineplus">+  this.deliverData = function (str) { this.value += str; };</span>
<a href="#l4.2894"></a><span id="l4.2894" class="difflineplus">+  this.deliverEOF = function () { };</span>
<a href="#l4.2895"></a><span id="l4.2895" class="difflineplus">+}</span>
<a href="#l4.2896"></a><span id="l4.2896" class="difflineplus">+</span>
<a href="#l4.2897"></a><span id="l4.2897" class="difflineplus">+/**</span>
<a href="#l4.2898"></a><span id="l4.2898" class="difflineplus">+ * Given a header name and its structured value, output a string containing its</span>
<a href="#l4.2899"></a><span id="l4.2899" class="difflineplus">+ * MIME-encoded value. The trailing CRLF for the header is included.</span>
<a href="#l4.2900"></a><span id="l4.2900" class="difflineplus">+ *</span>
<a href="#l4.2901"></a><span id="l4.2901" class="difflineplus">+ * @param {String} name    The name of the structured header.</span>
<a href="#l4.2902"></a><span id="l4.2902" class="difflineplus">+ * @param          value   The value of the structured header.</span>
<a href="#l4.2903"></a><span id="l4.2903" class="difflineplus">+ * @param          options Options for the HeaderEmitter constructor.</span>
<a href="#l4.2904"></a><span id="l4.2904" class="difflineplus">+ * @returns {String} A MIME-encoded representation of the structured header.</span>
<a href="#l4.2905"></a><span id="l4.2905" class="difflineplus">+ * @see HeaderEmitter.addStructuredHeader</span>
<a href="#l4.2906"></a><span id="l4.2906" class="difflineplus">+ */</span>
<a href="#l4.2907"></a><span id="l4.2907" class="difflineplus">+function emitStructuredHeader(name, value, options) {</span>
<a href="#l4.2908"></a><span id="l4.2908" class="difflineplus">+  let handler = new StringHandler();</span>
<a href="#l4.2909"></a><span id="l4.2909" class="difflineplus">+  let emitter = new HeaderEmitter(handler, options);</span>
<a href="#l4.2910"></a><span id="l4.2910" class="difflineplus">+  emitter.addStructuredHeader(name, value);</span>
<a href="#l4.2911"></a><span id="l4.2911" class="difflineplus">+  emitter.finish(true);</span>
<a href="#l4.2912"></a><span id="l4.2912" class="difflineplus">+  return handler.value;</span>
<a href="#l4.2913"></a><span id="l4.2913" class="difflineplus">+}</span>
<a href="#l4.2914"></a><span id="l4.2914" class="difflineplus">+</span>
<a href="#l4.2915"></a><span id="l4.2915" class="difflineplus">+/**</span>
<a href="#l4.2916"></a><span id="l4.2916" class="difflineplus">+ * Given a map of header names and their structured values, output a string</span>
<a href="#l4.2917"></a><span id="l4.2917" class="difflineplus">+ * containing all of their headers and their MIME-encoded values.</span>
<a href="#l4.2918"></a><span id="l4.2918" class="difflineplus">+ *</span>
<a href="#l4.2919"></a><span id="l4.2919" class="difflineplus">+ * This method is designed to be able to emit header values given the headerData</span>
<a href="#l4.2920"></a><span id="l4.2920" class="difflineplus">+ * values produced by MIME parsing. Thus, the values of the map are arrays</span>
<a href="#l4.2921"></a><span id="l4.2921" class="difflineplus">+ * corresponding to header multiplicity.</span>
<a href="#l4.2922"></a><span id="l4.2922" class="difflineplus">+ *</span>
<a href="#l4.2923"></a><span id="l4.2923" class="difflineplus">+ * @param {Map(String-&gt;Object[])} headerValues A map of header names to arrays</span>
<a href="#l4.2924"></a><span id="l4.2924" class="difflineplus">+ *                                             of their structured values.</span>
<a href="#l4.2925"></a><span id="l4.2925" class="difflineplus">+ * @param                         options      Options for the HeaderEmitter</span>
<a href="#l4.2926"></a><span id="l4.2926" class="difflineplus">+ *                                             constructor.</span>
<a href="#l4.2927"></a><span id="l4.2927" class="difflineplus">+ * @returns {String} A MIME-encoded representation of the structured header.</span>
<a href="#l4.2928"></a><span id="l4.2928" class="difflineplus">+ * @see HeaderEmitter.addStructuredHeader</span>
<a href="#l4.2929"></a><span id="l4.2929" class="difflineplus">+ */</span>
<a href="#l4.2930"></a><span id="l4.2930" class="difflineplus">+function emitStructuredHeaders(headerValues, options) {</span>
<a href="#l4.2931"></a><span id="l4.2931" class="difflineplus">+  let handler = new StringHandler();</span>
<a href="#l4.2932"></a><span id="l4.2932" class="difflineplus">+  let emitter = new HeaderEmitter(handler, options);</span>
<a href="#l4.2933"></a><span id="l4.2933" class="difflineplus">+  for (let instance of headerValues) {</span>
<a href="#l4.2934"></a><span id="l4.2934" class="difflineplus">+    instance[1].forEach(function (e) {</span>
<a href="#l4.2935"></a><span id="l4.2935" class="difflineplus">+      emitter.addStructuredHeader(instance[0], e)</span>
<a href="#l4.2936"></a><span id="l4.2936" class="difflineplus">+    });</span>
<a href="#l4.2937"></a><span id="l4.2937">   }</span>
<a href="#l4.2938"></a><span id="l4.2938" class="difflineminus">-  let mediatype = parts[0].toLowerCase();</span>
<a href="#l4.2939"></a><span id="l4.2939" class="difflineminus">-  let subtype = parts[1].toLowerCase();</span>
<a href="#l4.2940"></a><span id="l4.2940" class="difflineminus">-  let type = mediatype + '/' + subtype;</span>
<a href="#l4.2941"></a><span id="l4.2941" class="difflineminus">-  let structure = {</span>
<a href="#l4.2942"></a><span id="l4.2942" class="difflineminus">-    'mediatype': mediatype,</span>
<a href="#l4.2943"></a><span id="l4.2943" class="difflineminus">-    'subtype': subtype,</span>
<a href="#l4.2944"></a><span id="l4.2944" class="difflineminus">-    'type': type,</span>
<a href="#l4.2945"></a><span id="l4.2945" class="difflineminus">-  };</span>
<a href="#l4.2946"></a><span id="l4.2946" class="difflineminus">-  for (let name in params) {</span>
<a href="#l4.2947"></a><span id="l4.2947" class="difflineminus">-    structure['param-' + name.toLowerCase()] = params[name];</span>
<a href="#l4.2948"></a><span id="l4.2948" class="difflineplus">+  emitter.finish(true);</span>
<a href="#l4.2949"></a><span id="l4.2949" class="difflineplus">+  return handler.value;</span>
<a href="#l4.2950"></a><span id="l4.2950" class="difflineplus">+}</span>
<a href="#l4.2951"></a><span id="l4.2951" class="difflineplus">+</span>
<a href="#l4.2952"></a><span id="l4.2952" class="difflineplus">+/**</span>
<a href="#l4.2953"></a><span id="l4.2953" class="difflineplus">+ * Add a custom structured MIME encoder to the set of known encoders. These</span>
<a href="#l4.2954"></a><span id="l4.2954" class="difflineplus">+ * encoders are used for {@link emitStructuredHeader} and similar functions to</span>
<a href="#l4.2955"></a><span id="l4.2955" class="difflineplus">+ * encode richer, more structured values instead of relying on string</span>
<a href="#l4.2956"></a><span id="l4.2956" class="difflineplus">+ * representations everywhere.</span>
<a href="#l4.2957"></a><span id="l4.2957" class="difflineplus">+ *</span>
<a href="#l4.2958"></a><span id="l4.2958" class="difflineplus">+ * Structured encoders are functions which take in a single parameter</span>
<a href="#l4.2959"></a><span id="l4.2959" class="difflineplus">+ * representing their structured value. The this parameter is set to be an</span>
<a href="#l4.2960"></a><span id="l4.2960" class="difflineplus">+ * instance of {@link HeaderEmitter}, and it is intended that the several public</span>
<a href="#l4.2961"></a><span id="l4.2961" class="difflineplus">+ * or protected methods on that class are useful for encoding values.</span>
<a href="#l4.2962"></a><span id="l4.2962" class="difflineplus">+ *</span>
<a href="#l4.2963"></a><span id="l4.2963" class="difflineplus">+ * There is a large set of structured encoders built-in to the jsmime library</span>
<a href="#l4.2964"></a><span id="l4.2964" class="difflineplus">+ * already.</span>
<a href="#l4.2965"></a><span id="l4.2965" class="difflineplus">+ *</span>
<a href="#l4.2966"></a><span id="l4.2966" class="difflineplus">+ * @param {String}          header  The header name (in its preferred case) for</span>
<a href="#l4.2967"></a><span id="l4.2967" class="difflineplus">+ *                                  which the encoder will be used.</span>
<a href="#l4.2968"></a><span id="l4.2968" class="difflineplus">+ * @param {Function(Value)} encoder The structured encoder function.</span>
<a href="#l4.2969"></a><span id="l4.2969" class="difflineplus">+ */</span>
<a href="#l4.2970"></a><span id="l4.2970" class="difflineplus">+function addStructuredEncoder(header, encoder) {</span>
<a href="#l4.2971"></a><span id="l4.2971" class="difflineplus">+  let lowerName = header.toLowerCase();</span>
<a href="#l4.2972"></a><span id="l4.2972" class="difflineplus">+  encoders.set(lowerName, encoder);</span>
<a href="#l4.2973"></a><span id="l4.2973" class="difflineplus">+  if (!preferredSpellings.has(lowerName))</span>
<a href="#l4.2974"></a><span id="l4.2974" class="difflineplus">+    preferredSpellings.set(lowerName, header);</span>
<a href="#l4.2975"></a><span id="l4.2975" class="difflineplus">+}</span>
<a href="#l4.2976"></a><span id="l4.2976" class="difflineplus">+</span>
<a href="#l4.2977"></a><span id="l4.2977" class="difflineplus">+return Object.freeze({</span>
<a href="#l4.2978"></a><span id="l4.2978" class="difflineplus">+  addStructuredEncoder: addStructuredEncoder,</span>
<a href="#l4.2979"></a><span id="l4.2979" class="difflineplus">+  emitStructuredHeader: emitStructuredHeader,</span>
<a href="#l4.2980"></a><span id="l4.2980" class="difflineplus">+  emitStructuredHeaders: emitStructuredHeaders,</span>
<a href="#l4.2981"></a><span id="l4.2981" class="difflineplus">+  makeStreamingEmitter: makeStreamingEmitter</span>
<a href="#l4.2982"></a><span id="l4.2982" class="difflineplus">+});</span>
<a href="#l4.2983"></a><span id="l4.2983" class="difflineplus">+</span>
<a href="#l4.2984"></a><span id="l4.2984" class="difflineplus">+});</span>
<a href="#l4.2985"></a><span id="l4.2985" class="difflineplus">+</span>
<a href="#l4.2986"></a><span id="l4.2986" class="difflineplus">+def('jsmime', function(require) {</span>
<a href="#l4.2987"></a><span id="l4.2987" class="difflineplus">+  return {</span>
<a href="#l4.2988"></a><span id="l4.2988" class="difflineplus">+    MimeParser: require('./mimeparser'),</span>
<a href="#l4.2989"></a><span id="l4.2989" class="difflineplus">+    headerparser: require('./headerparser'),</span>
<a href="#l4.2990"></a><span id="l4.2990" class="difflineplus">+    headeremitter: require('./headeremitter')</span>
<a href="#l4.2991"></a><span id="l4.2991">   }</span>
<a href="#l4.2992"></a><span id="l4.2992" class="difflineminus">-  return structure;</span>
<a href="#l4.2993"></a><span id="l4.2993" class="difflineminus">-};</span>
<a href="#l4.2994"></a><span id="l4.2994" class="difflineminus">-</span>
<a href="#l4.2995"></a><span id="l4.2995" class="difflineminus">-</span>
<a href="#l4.2996"></a><span id="l4.2996" class="difflineminus">-// Gather up the header parsing things for easier export as symbols.</span>
<a href="#l4.2997"></a><span id="l4.2997" class="difflineminus">-var HeaderParser = Object.freeze({</span>
<a href="#l4.2998"></a><span id="l4.2998" class="difflineminus">-  extractParameters: extractParameters</span>
<a href="#l4.2999"></a><span id="l4.2999"> });</span>
<a href="#l4.3000"></a><span id="l4.3000" class="difflineplus">+  return mods['jsmime'];</span>
<a href="#l4.3001"></a><span id="l4.3001" class="difflineplus">+}));</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1">copy from mailnews/test/data/base64-1</span>
<a href="#l5.2"></a><span id="l5.2">copy to mailnews/mime/jsmime/test/data/base64-1</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1">copy from mailnews/test/data/base64-2</span>
<a href="#l6.2"></a><span id="l6.2">copy to mailnews/mime/jsmime/test/data/base64-2</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1">copy from mailnews/test/data/basic1</span>
<a href="#l7.2"></a><span id="l7.2">copy to mailnews/mime/jsmime/test/data/basic1</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1">copy from mailnews/test/data/bug505221</span>
<a href="#l8.2"></a><span id="l8.2">copy to mailnews/mime/jsmime/test/data/bug505221</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1">copy from mailnews/test/data/bugmail11</span>
<a href="#l9.2"></a><span id="l9.2">copy to mailnews/mime/jsmime/test/data/bugmail11</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..d33046820d2c9b173e86ecdf2c584d12f3d65efc</span>
<a href="#l10.3"></a><span id="l10.3">GIT binary patch
literal 1979
zc$}?O(N5bi6wPy_{Dak37HA=9Q;?-WVQg%SN$Uh}lat)EVU8Var=@*n(mr5F)84ne
z&gt;}@amh5gFL{$aLh5lDzN2r0h4zOnB)KG#lqoGD&lt;+?@vltM@2&lt;dUJ{{Jiu@GP4bMd}
zuUJaN1UKeh!*e~iKg=c44?zk}6)HeVG61B8M4=&amp;(h;k(n&amp;rmWXLW1@ynX&gt;^J5s~vs
zB47zmbwEBsihHh9LMQMQNVA%y)XcrUx)i(wK_|=TC08?;G3dD?n31M{qBvKcYv^lg
z45fLNfzX?~O0#^)9MI()A^&gt;qQAS|CkiZtnx&lt;U+3N?0_=uDWs{`k%WY67bp}apIK&lt;b
zqyS6a(7hcIX}F19Kqy5@5GE;6IcHX###5k_qcImWZRiZ1I~Rx&amp;HmJ0sRv&gt;PP`~JKF
zp4+=oHdBI?l9HTl%#rc4*9U$Sg&lt;ZdWZMK2e4E&gt;#%{OjnX(t4(Tskfj=Ou+!*WDP?H
zLx7VGUTxweGL9am-I)VnT{&gt;_2PyDDplQhC)&amp;EQ5IYXcjxtc(-QhF7oR?#+m{wW-Qs
zo~gITxvWn&amp;TE%h8*v#6bYa^NUQyjH6akq)dDvrp`!wVP_3GKk}2!h&gt;y5IomySLim&gt;
zZ4?B(t?)&amp;D7&gt;0-Yb+HF=D{8Ja7ep_UCE6i$Fz6TTfE&lt;lZ4tuoSKH95`TB*!$wT-e1
z!A_^!YX8-Eyfob&amp;nZ7;U-rL{AxGpSIiT_U2uYC;WqQv&amp;&lt;=v$IxI8N-7nH!@I&gt;}=S?
z5Zy&lt;LyNiGM?epA=^ACUCpZ`7obaD3c;`2wOyWc;~&gt;f*)uAY2IU+vZpH&lt;?;7l55J*X
zHP%ALDJELN5R=gOCKBOp+o;|Rag;2^&lt;WA_$Y;#+j9rH&gt;c{c9=o=O6BOfaCuh;GEfX
ep6hHm++ohKwv{6s&lt;WL8+Eo?M(ZovD#=l%n-Q&lt;NzH</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1">new file mode 100644</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineminus">--- /dev/null</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/data/message-encoded</span>
<a href="#l11.4"></a><span id="l11.4" class="difflineat">@@ -0,0 +1,24 @@</span>
<a href="#l11.5"></a><span id="l11.5" class="difflineplus">+Content-Type: multipart/mixed; boundary=&quot;iamaboundary&quot;</span>
<a href="#l11.6"></a><span id="l11.6" class="difflineplus">+</span>
<a href="#l11.7"></a><span id="l11.7" class="difflineplus">+This is a text message in MIME format.</span>
<a href="#l11.8"></a><span id="l11.8" class="difflineplus">+This part shouldn't appear in the output.</span>
<a href="#l11.9"></a><span id="l11.9" class="difflineplus">+</span>
<a href="#l11.10"></a><span id="l11.10" class="difflineplus">+--iamaboundary</span>
<a href="#l11.11"></a><span id="l11.11" class="difflineplus">+Content-Type: message/rfc822</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+Subject: I am a subject</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+This is a plain-text message.</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+--iamaboundary</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+Content-Type: message/global</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineplus">+Content-Transfer-Encoding: base64</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineplus">+U3ViamVjdDog56eB44Gv44CB5Lu25ZCN5Y2I5YmNDQoNCkkgYW0gYSBwbGFpbi10ZXh0IG1lc3NhZ2Uu</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineplus">+--iamaboundary</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+Content-Type: message/news</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+Content-Transfer-Encoding: quoted-printable</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineplus">+</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+Subject: =e7=a7=81=e3=81=af=e3=80=81=e4=bb=b6=e5=90=8d=e5=8d=88=e5=89=8d</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineplus">+I am an encoded plain-text message.</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+--iamaboundary--</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1">copy from mailnews/test/data/mime-torture</span>
<a href="#l12.2"></a><span id="l12.2">copy to mailnews/mime/jsmime/test/data/mime-torture</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1">copy from mailnews/test/data/multipart-base64-1</span>
<a href="#l13.2"></a><span id="l13.2">copy to mailnews/mime/jsmime/test/data/multipart-base64-1</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1">copy from mailnews/test/data/multipart-base64-2</span>
<a href="#l14.2"></a><span id="l14.2">copy to mailnews/mime/jsmime/test/data/multipart-base64-2</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">copy from mailnews/test/data/multipart-base64-3</span>
<a href="#l15.2"></a><span id="l15.2">copy to mailnews/mime/jsmime/test/data/multipart-base64-3</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1">copy from mailnews/test/data/multipart-complex1</span>
<a href="#l16.2"></a><span id="l16.2">copy to mailnews/mime/jsmime/test/data/multipart-complex1</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1">copy from mailnews/test/data/multipart-complex2</span>
<a href="#l17.2"></a><span id="l17.2">copy to mailnews/mime/jsmime/test/data/multipart-complex2</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1">copy from mailnews/test/data/multipart1</span>
<a href="#l18.2"></a><span id="l18.2">copy to mailnews/mime/jsmime/test/data/multipart1</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1">copy from mailnews/test/data/multipart2</span>
<a href="#l19.2"></a><span id="l19.2">copy to mailnews/mime/jsmime/test/data/multipart2</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1">copy from mailnews/test/data/multipart3</span>
<a href="#l20.2"></a><span id="l20.2">copy to mailnews/mime/jsmime/test/data/multipart3</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1">copy from mailnews/test/data/multipart4</span>
<a href="#l21.2"></a><span id="l21.2">copy to mailnews/mime/jsmime/test/data/multipart4</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1">copy from mailnews/test/data/multipartmalt-detach</span>
<a href="#l22.2"></a><span id="l22.2">copy to mailnews/mime/jsmime/test/data/multipartmalt-detach</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1">new file mode 100644</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineminus">--- /dev/null</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/data/shift-jis-image</span>
<a href="#l23.4"></a><span id="l23.4" class="difflineat">@@ -0,0 +1,21 @@</span>
<a href="#l23.5"></a><span id="l23.5" class="difflineplus">+Subject: Shift-JIS and PNG test</span>
<a href="#l23.6"></a><span id="l23.6" class="difflineplus">+Content-Type: multipart/mixed; boundary=&quot;vungrzvzr&quot;</span>
<a href="#l23.7"></a><span id="l23.7" class="difflineplus">+</span>
<a href="#l23.8"></a><span id="l23.8" class="difflineplus">+--vungrzvzr</span>
<a href="#l23.9"></a><span id="l23.9" class="difflineplus">+Content-Type: text/plain; charset=Shift-JIS</span>
<a href="#l23.10"></a><span id="l23.10" class="difflineplus">+Content-Transfer-Encoding: 8bit</span>
<a href="#l23.11"></a><span id="l23.11" class="difflineplus">+Content-Description: Pc@RAg</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineplus">+</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+Portable Network Graphicsi|[^uElbg[NEOtBbNXAPNGjRs[^rbg}bvt@CtH[}bgBkASYDeflatepAktkt@CtH[}bgB</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+--vungrzvzr</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineplus">+Content-Type: image/png</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineplus">+Content-Transfer-Encoding: base64</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+Content-Description: Pc@RAg</span>
<a href="#l23.19"></a><span id="l23.19" class="difflineplus">+</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineplus">+iVBORw0KGgoAAAANSUhEUgAAAIAAAABECAIAAADGJao+AAAAwklEQVR4Xu3UgQbDMBRA0bc03f//</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+b7N0VuqJEmwoc+KqNEkDh9b+2HuJu1KNO4f+AQCAAAAQAAACAEAAAAgAAAEAIAAABACAAAAQAAAC</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+AEAAAAgAAAEAIAAAANReamRLlPWYfNH0klxcPs+cP3NxWF+vi3lb7pa2R+vx6tHOtuN1O+a5lY3H</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+zgM5ya/GM5N7ZjfPq7/5yS8IgAAAEAAAAgBAAAAIAAABACAAAAQAgAAAEAAAAgBAAAAIAAABACAA</span>
<a href="#l23.24"></a><span id="l23.24" class="difflineplus">+AIw322gDIPvtlmUAAAAASUVORK5CYII=</span>
<a href="#l23.25"></a><span id="l23.25" class="difflineplus">+--vungrzvzr--</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1">new file mode 100644</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineminus">--- /dev/null</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/head_xpcshell_glue.js</span>
<a href="#l24.4"></a><span id="l24.4" class="difflineat">@@ -0,0 +1,167 @@</span>
<a href="#l24.5"></a><span id="l24.5" class="difflineplus">+// This file needs to contain glue to rephrase the Mocha testsuite framework in</span>
<a href="#l24.6"></a><span id="l24.6" class="difflineplus">+// a way that the xpcshell test suite can understand.</span>
<a href="#l24.7"></a><span id="l24.7" class="difflineplus">+</span>
<a href="#l24.8"></a><span id="l24.8" class="difflineplus">+Components.utils.import(&quot;resource://gre/modules/osfile.jsm&quot;);</span>
<a href="#l24.9"></a><span id="l24.9" class="difflineplus">+Components.utils.import(&quot;resource://gre/modules/Promise.jsm&quot;);</span>
<a href="#l24.10"></a><span id="l24.10" class="difflineplus">+Components.utils.import(&quot;resource://gre/modules/Services.jsm&quot;);</span>
<a href="#l24.11"></a><span id="l24.11" class="difflineplus">+Components.utils.import(&quot;resource://gre/modules/Task.jsm&quot;);</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineplus">+Components.utils.import(&quot;resource://testing-common/Assert.jsm&quot;);</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+var requireCache = new Map();</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineplus">+</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+// Preload an assert module</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+var assert = new Assert();</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+assert.doesNotThrow = function (block, message) {</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineplus">+  message = (message ? ' ' + message : '.');</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineplus">+  try {</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineplus">+    block();</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineplus">+  } catch (e) {</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+    this.report(true, e, null, 'Got unwanted exception' + message);</span>
<a href="#l24.23"></a><span id="l24.23" class="difflineplus">+  }</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineplus">+};</span>
<a href="#l24.25"></a><span id="l24.25" class="difflineplus">+requireCache.set(&quot;assert&quot;, assert);</span>
<a href="#l24.26"></a><span id="l24.26" class="difflineplus">+</span>
<a href="#l24.27"></a><span id="l24.27" class="difflineplus">+// Preload an fs module</span>
<a href="#l24.28"></a><span id="l24.28" class="difflineplus">+var Cc = Components.classes, Ci = Components.interfaces;</span>
<a href="#l24.29"></a><span id="l24.29" class="difflineplus">+var fs = {</span>
<a href="#l24.30"></a><span id="l24.30" class="difflineplus">+  readFile: function (filename, options, callback) {</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineplus">+    if (callback === undefined) {</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+      callback = options;</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineplus">+      options = {};</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineplus">+    }</span>
<a href="#l24.35"></a><span id="l24.35" class="difflineplus">+</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineplus">+    // Convert according to encoding. For the moment, we don't support this</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+    // node.js feature in the shim since we don't need to.</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+    var translator = (contents =&gt; contents);</span>
<a href="#l24.39"></a><span id="l24.39" class="difflineplus">+    if (options !== undefined &amp;&amp; 'encoding' in options) {</span>
<a href="#l24.40"></a><span id="l24.40" class="difflineplus">+      translator = function () {</span>
<a href="#l24.41"></a><span id="l24.41" class="difflineplus">+        throw new Error(&quot;I can't do this!&quot;);</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineplus">+      };</span>
<a href="#l24.43"></a><span id="l24.43" class="difflineplus">+    }</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineplus">+</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineplus">+    Promise.resolve(filename)</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+           .then(do_get_file)</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineplus">+           .then(file =&gt; OS.File.read(file.path))</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+           .then(translator)</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineplus">+           .then(contents =&gt; callback(undefined, contents), callback);</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+  },</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+};</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+requireCache.set(&quot;fs&quot;, fs);</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+Services.scriptloader.loadSubScript(&quot;resource:///modules/jsmime/jsmime.js&quot;);</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineplus">+requireCache.set(&quot;jsmime&quot;, jsmime);</span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineplus">+function require(path) {</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+  if (requireCache.has(path))</span>
<a href="#l24.58"></a><span id="l24.58" class="difflineplus">+    return requireCache.get(path);</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineplus">+</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineplus">+  var file = &quot;resource:///modules/jsmime/&quot; + path + &quot;.js&quot;;</span>
<a href="#l24.61"></a><span id="l24.61" class="difflineplus">+  var globalObject = {</span>
<a href="#l24.62"></a><span id="l24.62" class="difflineplus">+    define: innerDefine.bind(this, path),</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineplus">+  };</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineplus">+  Services.scriptloader.loadSubScript(file, globalObject);</span>
<a href="#l24.65"></a><span id="l24.65" class="difflineplus">+  return requireCache.get(path);</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineplus">+}</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineplus">+</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+function innerDefine(moduleName, dfn) {</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+  if (typeof dfn !== &quot;function&quot;)</span>
<a href="#l24.70"></a><span id="l24.70" class="difflineplus">+    throw new Error(&quot;What is going on here?&quot;);</span>
<a href="#l24.71"></a><span id="l24.71" class="difflineplus">+  function resolvingRequire(path) {</span>
<a href="#l24.72"></a><span id="l24.72" class="difflineplus">+    if (path.startsWith(&quot;./&quot;))</span>
<a href="#l24.73"></a><span id="l24.73" class="difflineplus">+      path = path.substring(2);</span>
<a href="#l24.74"></a><span id="l24.74" class="difflineplus">+    return require(path);</span>
<a href="#l24.75"></a><span id="l24.75" class="difflineplus">+  }</span>
<a href="#l24.76"></a><span id="l24.76" class="difflineplus">+  var result = dfn(resolvingRequire);</span>
<a href="#l24.77"></a><span id="l24.77" class="difflineplus">+  requireCache.set(moduleName, result);</span>
<a href="#l24.78"></a><span id="l24.78" class="difflineplus">+}</span>
<a href="#l24.79"></a><span id="l24.79" class="difflineplus">+</span>
<a href="#l24.80"></a><span id="l24.80" class="difflineplus">+var define = innerDefine.bind(this, &quot;xpcshell-test&quot;);</span>
<a href="#l24.81"></a><span id="l24.81" class="difflineplus">+</span>
<a href="#l24.82"></a><span id="l24.82" class="difflineplus">+///////////////////////////</span>
<a href="#l24.83"></a><span id="l24.83" class="difflineplus">+// Mocha TDD UI Bindings //</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineplus">+///////////////////////////</span>
<a href="#l24.85"></a><span id="l24.85" class="difflineplus">+</span>
<a href="#l24.86"></a><span id="l24.86" class="difflineplus">+/**</span>
<a href="#l24.87"></a><span id="l24.87" class="difflineplus">+ * A block of tests, from the suite class.</span>
<a href="#l24.88"></a><span id="l24.88" class="difflineplus">+ */</span>
<a href="#l24.89"></a><span id="l24.89" class="difflineplus">+function MochaSuite(name) {</span>
<a href="#l24.90"></a><span id="l24.90" class="difflineplus">+  this.name = name;</span>
<a href="#l24.91"></a><span id="l24.91" class="difflineplus">+  this.setup = [];</span>
<a href="#l24.92"></a><span id="l24.92" class="difflineplus">+  this.tests = [];</span>
<a href="#l24.93"></a><span id="l24.93" class="difflineplus">+  this.teardown = [];</span>
<a href="#l24.94"></a><span id="l24.94" class="difflineplus">+  this.suites = [];</span>
<a href="#l24.95"></a><span id="l24.95" class="difflineplus">+}</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineplus">+</span>
<a href="#l24.97"></a><span id="l24.97" class="difflineplus">+/// The real code for running a suite of tests, written as a generator.</span>
<a href="#l24.98"></a><span id="l24.98" class="difflineplus">+MochaSuite.prototype._runSuite = function *() {</span>
<a href="#l24.99"></a><span id="l24.99" class="difflineplus">+  do_print(&quot;Running suite &quot; + this.name);</span>
<a href="#l24.100"></a><span id="l24.100" class="difflineplus">+  for (let setup of this.setup) {</span>
<a href="#l24.101"></a><span id="l24.101" class="difflineplus">+    yield runFunction(setup);</span>
<a href="#l24.102"></a><span id="l24.102" class="difflineplus">+  }</span>
<a href="#l24.103"></a><span id="l24.103" class="difflineplus">+  for (let test of this.tests) {</span>
<a href="#l24.104"></a><span id="l24.104" class="difflineplus">+    do_print(&quot;Running test &quot; + test.name);</span>
<a href="#l24.105"></a><span id="l24.105" class="difflineplus">+    yield runFunction(test.test);</span>
<a href="#l24.106"></a><span id="l24.106" class="difflineplus">+  }</span>
<a href="#l24.107"></a><span id="l24.107" class="difflineplus">+  for (let suite of this.suites) {</span>
<a href="#l24.108"></a><span id="l24.108" class="difflineplus">+    yield suite.runSuite();</span>
<a href="#l24.109"></a><span id="l24.109" class="difflineplus">+  }</span>
<a href="#l24.110"></a><span id="l24.110" class="difflineplus">+  for (let fn of this.teardown) {</span>
<a href="#l24.111"></a><span id="l24.111" class="difflineplus">+    yield runFunction(fn);</span>
<a href="#l24.112"></a><span id="l24.112" class="difflineplus">+  }</span>
<a href="#l24.113"></a><span id="l24.113" class="difflineplus">+  do_print(&quot;Finished suite &quot; + this.name);</span>
<a href="#l24.114"></a><span id="l24.114" class="difflineplus">+};</span>
<a href="#l24.115"></a><span id="l24.115" class="difflineplus">+</span>
<a href="#l24.116"></a><span id="l24.116" class="difflineplus">+/// The outer call to run a test suite, which returns a promise of completion.</span>
<a href="#l24.117"></a><span id="l24.117" class="difflineplus">+MochaSuite.prototype.runSuite = function () {</span>
<a href="#l24.118"></a><span id="l24.118" class="difflineplus">+  return Task.spawn(this._runSuite.bind(this));</span>
<a href="#l24.119"></a><span id="l24.119" class="difflineplus">+};</span>
<a href="#l24.120"></a><span id="l24.120" class="difflineplus">+</span>
<a href="#l24.121"></a><span id="l24.121" class="difflineplus">+/// Run the given function, returning a promise of when the test will complete.</span>
<a href="#l24.122"></a><span id="l24.122" class="difflineplus">+function runFunction(fn) {</span>
<a href="#l24.123"></a><span id="l24.123" class="difflineplus">+  let completed = new Promise(function (resolve, reject) {</span>
<a href="#l24.124"></a><span id="l24.124" class="difflineplus">+    function onEnd(error) {</span>
<a href="#l24.125"></a><span id="l24.125" class="difflineplus">+      if (error !== undefined)</span>
<a href="#l24.126"></a><span id="l24.126" class="difflineplus">+        reject(error);</span>
<a href="#l24.127"></a><span id="l24.127" class="difflineplus">+      else</span>
<a href="#l24.128"></a><span id="l24.128" class="difflineplus">+        resolve();</span>
<a href="#l24.129"></a><span id="l24.129" class="difflineplus">+    }</span>
<a href="#l24.130"></a><span id="l24.130" class="difflineplus">+    // If the function is expecting an argument, that argument is the callback</span>
<a href="#l24.131"></a><span id="l24.131" class="difflineplus">+    // above. If it's not, then it may be returning a promise.</span>
<a href="#l24.132"></a><span id="l24.132" class="difflineplus">+    if (fn.length == 1) {</span>
<a href="#l24.133"></a><span id="l24.133" class="difflineplus">+      fn(onEnd);</span>
<a href="#l24.134"></a><span id="l24.134" class="difflineplus">+    } else {</span>
<a href="#l24.135"></a><span id="l24.135" class="difflineplus">+      // Promise.resolve nicely handles both promises and not-promise values for</span>
<a href="#l24.136"></a><span id="l24.136" class="difflineplus">+      // us.</span>
<a href="#l24.137"></a><span id="l24.137" class="difflineplus">+      resolve(fn());</span>
<a href="#l24.138"></a><span id="l24.138" class="difflineplus">+    }</span>
<a href="#l24.139"></a><span id="l24.139" class="difflineplus">+  });</span>
<a href="#l24.140"></a><span id="l24.140" class="difflineplus">+  return completed;</span>
<a href="#l24.141"></a><span id="l24.141" class="difflineplus">+}</span>
<a href="#l24.142"></a><span id="l24.142" class="difflineplus">+</span>
<a href="#l24.143"></a><span id="l24.143" class="difflineplus">+var currentSuite = new MochaSuite('');</span>
<a href="#l24.144"></a><span id="l24.144" class="difflineplus">+function suite(name, tests) {</span>
<a href="#l24.145"></a><span id="l24.145" class="difflineplus">+  name = name.toString();</span>
<a href="#l24.146"></a><span id="l24.146" class="difflineplus">+  if (/[\x80-]/.exec(name))</span>
<a href="#l24.147"></a><span id="l24.147" class="difflineplus">+    name = &quot;&lt;unprintable name&gt;&quot;;</span>
<a href="#l24.148"></a><span id="l24.148" class="difflineplus">+  let suiteParent = currentSuite;</span>
<a href="#l24.149"></a><span id="l24.149" class="difflineplus">+  currentSuite = new MochaSuite(name);</span>
<a href="#l24.150"></a><span id="l24.150" class="difflineplus">+  suiteParent.suites.push(currentSuite);</span>
<a href="#l24.151"></a><span id="l24.151" class="difflineplus">+  tests();</span>
<a href="#l24.152"></a><span id="l24.152" class="difflineplus">+  currentSuite = suiteParent;</span>
<a href="#l24.153"></a><span id="l24.153" class="difflineplus">+}</span>
<a href="#l24.154"></a><span id="l24.154" class="difflineplus">+function test(name, block) {</span>
<a href="#l24.155"></a><span id="l24.155" class="difflineplus">+  name = name.toString();</span>
<a href="#l24.156"></a><span id="l24.156" class="difflineplus">+  if (/[\x80-]/.exec(name))</span>
<a href="#l24.157"></a><span id="l24.157" class="difflineplus">+    name = &quot;&lt;unprintable name&gt;&quot;;</span>
<a href="#l24.158"></a><span id="l24.158" class="difflineplus">+  currentSuite.tests.push({name: name, test: block});</span>
<a href="#l24.159"></a><span id="l24.159" class="difflineplus">+}</span>
<a href="#l24.160"></a><span id="l24.160" class="difflineplus">+function setup(block) {</span>
<a href="#l24.161"></a><span id="l24.161" class="difflineplus">+  currentSetup.setup.push(block);</span>
<a href="#l24.162"></a><span id="l24.162" class="difflineplus">+}</span>
<a href="#l24.163"></a><span id="l24.163" class="difflineplus">+function teardown(block) {</span>
<a href="#l24.164"></a><span id="l24.164" class="difflineplus">+  currentSetup.teardown.push(block);</span>
<a href="#l24.165"></a><span id="l24.165" class="difflineplus">+}</span>
<a href="#l24.166"></a><span id="l24.166" class="difflineplus">+</span>
<a href="#l24.167"></a><span id="l24.167" class="difflineplus">+/// The actual binding xpcshell needs to do its work.</span>
<a href="#l24.168"></a><span id="l24.168" class="difflineplus">+function run_test() {</span>
<a href="#l24.169"></a><span id="l24.169" class="difflineplus">+  add_task(currentSuite.runSuite());</span>
<a href="#l24.170"></a><span id="l24.170" class="difflineplus">+  run_next_test();</span>
<a href="#l24.171"></a><span id="l24.171" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1">new file mode 100644</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineminus">--- /dev/null</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/test_custom_headers.js</span>
<a href="#l25.4"></a><span id="l25.4" class="difflineat">@@ -0,0 +1,69 @@</span>
<a href="#l25.5"></a><span id="l25.5" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l25.6"></a><span id="l25.6" class="difflineplus">+define(function (require) {</span>
<a href="#l25.7"></a><span id="l25.7" class="difflineplus">+</span>
<a href="#l25.8"></a><span id="l25.8" class="difflineplus">+var assert = require('assert');</span>
<a href="#l25.9"></a><span id="l25.9" class="difflineplus">+var jsmime = require('jsmime');</span>
<a href="#l25.10"></a><span id="l25.10" class="difflineplus">+</span>
<a href="#l25.11"></a><span id="l25.11" class="difflineplus">+function arrayTest(data, fn) {</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineplus">+  fn.toString = function () {</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+    let text = Function.prototype.toString.call(this);</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+    text = text.replace(/data\[([0-9]*)\]/g, function (m, p) {</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+      return JSON.stringify(data[p]);</span>
<a href="#l25.16"></a><span id="l25.16" class="difflineplus">+    });</span>
<a href="#l25.17"></a><span id="l25.17" class="difflineplus">+    return text;</span>
<a href="#l25.18"></a><span id="l25.18" class="difflineplus">+  };</span>
<a href="#l25.19"></a><span id="l25.19" class="difflineplus">+  return test(data[0], fn);</span>
<a href="#l25.20"></a><span id="l25.20" class="difflineplus">+}</span>
<a href="#l25.21"></a><span id="l25.21" class="difflineplus">+</span>
<a href="#l25.22"></a><span id="l25.22" class="difflineplus">+function testHeader(header, tests) {</span>
<a href="#l25.23"></a><span id="l25.23" class="difflineplus">+  suite(header, function () {</span>
<a href="#l25.24"></a><span id="l25.24" class="difflineplus">+    tests.forEach(function (data) {</span>
<a href="#l25.25"></a><span id="l25.25" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l25.26"></a><span id="l25.26" class="difflineplus">+        array.deepEqual(headerparser.parseStructuredHeader(header,</span>
<a href="#l25.27"></a><span id="l25.27" class="difflineplus">+          data[0]), data[1]);</span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+      });</span>
<a href="#l25.29"></a><span id="l25.29" class="difflineplus">+    });</span>
<a href="#l25.30"></a><span id="l25.30" class="difflineplus">+  });</span>
<a href="#l25.31"></a><span id="l25.31" class="difflineplus">+}</span>
<a href="#l25.32"></a><span id="l25.32" class="difflineplus">+</span>
<a href="#l25.33"></a><span id="l25.33" class="difflineplus">+function makeCT(media, sub, params) {</span>
<a href="#l25.34"></a><span id="l25.34" class="difflineplus">+  var object = new Map();</span>
<a href="#l25.35"></a><span id="l25.35" class="difflineplus">+  object.mediatype = media;</span>
<a href="#l25.36"></a><span id="l25.36" class="difflineplus">+  object.subtype = sub;</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineplus">+  object.type = media + &quot;/&quot; + sub;</span>
<a href="#l25.38"></a><span id="l25.38" class="difflineplus">+  for (let k in params)</span>
<a href="#l25.39"></a><span id="l25.39" class="difflineplus">+    object.set(k, params[k]);</span>
<a href="#l25.40"></a><span id="l25.40" class="difflineplus">+  return object;</span>
<a href="#l25.41"></a><span id="l25.41" class="difflineplus">+}</span>
<a href="#l25.42"></a><span id="l25.42" class="difflineplus">+suite('Custom decoder support', function () {</span>
<a href="#l25.43"></a><span id="l25.43" class="difflineplus">+  function customDecoder(values) {</span>
<a href="#l25.44"></a><span id="l25.44" class="difflineplus">+    let value = values.join('');</span>
<a href="#l25.45"></a><span id="l25.45" class="difflineplus">+    return atob(value);</span>
<a href="#l25.46"></a><span id="l25.46" class="difflineplus">+  }</span>
<a href="#l25.47"></a><span id="l25.47" class="difflineplus">+  function customEncoder(value) {</span>
<a href="#l25.48"></a><span id="l25.48" class="difflineplus">+    this.addText(btoa(value), true);</span>
<a href="#l25.49"></a><span id="l25.49" class="difflineplus">+  }</span>
<a href="#l25.50"></a><span id="l25.50" class="difflineplus">+  test('addStructuredEncoder', function () {</span>
<a href="#l25.51"></a><span id="l25.51" class="difflineplus">+    assert.equal('X-Base64: String\r\n',</span>
<a href="#l25.52"></a><span id="l25.52" class="difflineplus">+      jsmime.headeremitter.emitStructuredHeader('X-Base64', 'String', {}));</span>
<a href="#l25.53"></a><span id="l25.53" class="difflineplus">+    jsmime.headeremitter.addStructuredEncoder('X-Base64', customEncoder);</span>
<a href="#l25.54"></a><span id="l25.54" class="difflineplus">+    assert.equal('X-Base64: U3RyaW5n\r\n',</span>
<a href="#l25.55"></a><span id="l25.55" class="difflineplus">+      jsmime.headeremitter.emitStructuredHeader('X-Base64', 'String', {}));</span>
<a href="#l25.56"></a><span id="l25.56" class="difflineplus">+    assert.equal('X-Base64: U3RyaW5n\r\n',</span>
<a href="#l25.57"></a><span id="l25.57" class="difflineplus">+      jsmime.headeremitter.emitStructuredHeader('x-bASe64', 'String', {}));</span>
<a href="#l25.58"></a><span id="l25.58" class="difflineplus">+  });</span>
<a href="#l25.59"></a><span id="l25.59" class="difflineplus">+  test('addStructuredDecoder', function () {</span>
<a href="#l25.60"></a><span id="l25.60" class="difflineplus">+    assert.throws(function () {</span>
<a href="#l25.61"></a><span id="l25.61" class="difflineplus">+      jsmime.headerparser.parseStructuredHeader('X-Base64', 'U3RyaW5n');</span>
<a href="#l25.62"></a><span id="l25.62" class="difflineplus">+    });</span>
<a href="#l25.63"></a><span id="l25.63" class="difflineplus">+    jsmime.headerparser.addStructuredDecoder('X-Base64', customDecoder);</span>
<a href="#l25.64"></a><span id="l25.64" class="difflineplus">+    assert.equal('String',</span>
<a href="#l25.65"></a><span id="l25.65" class="difflineplus">+      jsmime.headerparser.parseStructuredHeader('X-Base64', 'U3RyaW5n'));</span>
<a href="#l25.66"></a><span id="l25.66" class="difflineplus">+    assert.throws(function () {</span>
<a href="#l25.67"></a><span id="l25.67" class="difflineplus">+      jsmime.headerparser.addStructuredDecoder('To', customDecoder);</span>
<a href="#l25.68"></a><span id="l25.68" class="difflineplus">+    });</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineplus">+  });</span>
<a href="#l25.70"></a><span id="l25.70" class="difflineplus">+});</span>
<a href="#l25.71"></a><span id="l25.71" class="difflineplus">+</span>
<a href="#l25.72"></a><span id="l25.72" class="difflineplus">+});</span>
<a href="#l25.73"></a><span id="l25.73" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1">new file mode 100644</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineminus">--- /dev/null</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/test_header.js</span>
<a href="#l26.4"></a><span id="l26.4" class="difflineat">@@ -0,0 +1,515 @@</span>
<a href="#l26.5"></a><span id="l26.5" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l26.6"></a><span id="l26.6" class="difflineplus">+define(function(require) {</span>
<a href="#l26.7"></a><span id="l26.7" class="difflineplus">+</span>
<a href="#l26.8"></a><span id="l26.8" class="difflineplus">+var headerparser = require('jsmime').headerparser;</span>
<a href="#l26.9"></a><span id="l26.9" class="difflineplus">+var assert = require('assert');</span>
<a href="#l26.10"></a><span id="l26.10" class="difflineplus">+</span>
<a href="#l26.11"></a><span id="l26.11" class="difflineplus">+function arrayTest(data, fn) {</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineplus">+  fn.toString = function () {</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+    let text = Function.prototype.toString.call(this);</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineplus">+    text = text.replace(/data\[([0-9]*)\]/g, function (m, p) {</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineplus">+      return JSON.stringify(data[p]);</span>
<a href="#l26.16"></a><span id="l26.16" class="difflineplus">+    });</span>
<a href="#l26.17"></a><span id="l26.17" class="difflineplus">+    return text;</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineplus">+  };</span>
<a href="#l26.19"></a><span id="l26.19" class="difflineplus">+  return test(data[0], fn);</span>
<a href="#l26.20"></a><span id="l26.20" class="difflineplus">+}</span>
<a href="#l26.21"></a><span id="l26.21" class="difflineplus">+suite('headerparser', function () {</span>
<a href="#l26.22"></a><span id="l26.22" class="difflineplus">+  suite('parseParameterHeader', function () {</span>
<a href="#l26.23"></a><span id="l26.23" class="difflineplus">+    let header_tests = [</span>
<a href="#l26.24"></a><span id="l26.24" class="difflineplus">+      ['multipart/related', [&quot;multipart/related&quot;, {}]],</span>
<a href="#l26.25"></a><span id="l26.25" class="difflineplus">+      [&quot;a ; b=v&quot;, [&quot;a&quot;, {&quot;b&quot;: &quot;v&quot;}]],</span>
<a href="#l26.26"></a><span id="l26.26" class="difflineplus">+      [&quot;a ; b='v'&quot;, [&quot;a&quot;, {&quot;b&quot;: &quot;'v'&quot;}]],</span>
<a href="#l26.27"></a><span id="l26.27" class="difflineplus">+      ['a; b = &quot;v&quot;', [&quot;a&quot;, {&quot;b&quot;: &quot;v&quot;}]],</span>
<a href="#l26.28"></a><span id="l26.28" class="difflineplus">+      [&quot;a;b=1;b=2&quot;, [&quot;a&quot;, {&quot;b&quot;: &quot;1&quot;}]],</span>
<a href="#l26.29"></a><span id="l26.29" class="difflineplus">+      [&quot;a;b=2;b=1&quot;, [&quot;a&quot;, {&quot;b&quot;: &quot;2&quot;}]],</span>
<a href="#l26.30"></a><span id="l26.30" class="difflineplus">+      ['a;b=&quot;a;b&quot;', [&quot;a&quot;, {&quot;b&quot;: &quot;a;b&quot;}]],</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineplus">+      ['a;b=&quot;\\\\&quot;', [&quot;a&quot;, {&quot;b&quot;: &quot;\\&quot;}]],</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineplus">+      ['a;b=&quot;a\\b\\c&quot;', [&quot;a&quot;, {&quot;b&quot;: &quot;abc&quot;}]],</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineplus">+      ['a;b=1;c=2', [&quot;a&quot;, {&quot;b&quot;: &quot;1&quot;, &quot;c&quot;: &quot;2&quot;}]],</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineplus">+      ['a;b=&quot;a\\', [&quot;a&quot;, {&quot;b&quot;: &quot;a&quot;}]],</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineplus">+      ['a;b', [&quot;a&quot;, {}]],</span>
<a href="#l26.36"></a><span id="l26.36" class="difflineplus">+      ['a;b=&quot;;&quot;;c=d', [&quot;a&quot;, {&quot;b&quot;: ';', 'c': &quot;d&quot;}]],</span>
<a href="#l26.37"></a><span id="l26.37" class="difflineplus">+    ];</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l26.39"></a><span id="l26.39" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l26.40"></a><span id="l26.40" class="difflineplus">+        let testMap = new Map();</span>
<a href="#l26.41"></a><span id="l26.41" class="difflineplus">+        for (let key in data[1][1])</span>
<a href="#l26.42"></a><span id="l26.42" class="difflineplus">+          testMap.set(key, data[1][1][key]);</span>
<a href="#l26.43"></a><span id="l26.43" class="difflineplus">+        testMap.preSemi = data[1][0];</span>
<a href="#l26.44"></a><span id="l26.44" class="difflineplus">+        assert.deepEqual(headerparser.parseParameterHeader(data[0], false, false),</span>
<a href="#l26.45"></a><span id="l26.45" class="difflineplus">+          testMap);</span>
<a href="#l26.46"></a><span id="l26.46" class="difflineplus">+      });</span>
<a href="#l26.47"></a><span id="l26.47" class="difflineplus">+    });</span>
<a href="#l26.48"></a><span id="l26.48" class="difflineplus">+  });</span>
<a href="#l26.49"></a><span id="l26.49" class="difflineplus">+  suite('parseParameterHeader (2231/2047 support)', function () {</span>
<a href="#l26.50"></a><span id="l26.50" class="difflineplus">+    let header_tests = [</span>
<a href="#l26.51"></a><span id="l26.51" class="difflineplus">+      // Copied from test_MIME_params.js and adapted</span>
<a href="#l26.52"></a><span id="l26.52" class="difflineplus">+      [&quot;attachment;&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.53"></a><span id="l26.53" class="difflineplus">+      [&quot;attachment; filename=basic&quot;, [&quot;attachment&quot;, {filename: &quot;basic&quot;}]],</span>
<a href="#l26.54"></a><span id="l26.54" class="difflineplus">+      [&quot;attachment; filename=\&quot;\\\&quot;\&quot;&quot;, [&quot;attachment&quot;, {filename: '&quot;'}]],</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineplus">+      [&quot;attachment; filename=\&quot;\\x\&quot;&quot;, [&quot;attachment&quot;, {filename: &quot;x&quot;}]],</span>
<a href="#l26.56"></a><span id="l26.56" class="difflineplus">+      [&quot;attachment; filename=\&quot;\&quot;&quot;, [&quot;attachment&quot;, {filename: &quot;&quot;}]],</span>
<a href="#l26.57"></a><span id="l26.57" class="difflineplus">+      [&quot;attachment; filename=&quot;, [&quot;attachment&quot;, {filename: &quot;&quot;}]],</span>
<a href="#l26.58"></a><span id="l26.58" class="difflineplus">+      [&quot;attachment; filename X&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.59"></a><span id="l26.59" class="difflineplus">+      [&quot;attachment; filename = foo-A.html&quot;,</span>
<a href="#l26.60"></a><span id="l26.60" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo-A.html&quot;}]],</span>
<a href="#l26.61"></a><span id="l26.61" class="difflineplus">+      [&quot;attachment; filename=\&quot;&quot;, [&quot;attachment&quot;, {filename: &quot;&quot;}]],</span>
<a href="#l26.62"></a><span id="l26.62" class="difflineplus">+      [&quot;attachment; filename=foo; trouble&quot;, [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.63"></a><span id="l26.63" class="difflineplus">+      [&quot;attachment; filename=foo; trouble &quot;, [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.64"></a><span id="l26.64" class="difflineplus">+      [&quot;attachment&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.65"></a><span id="l26.65" class="difflineplus">+      [&quot;attachment; filename=foo&quot;, [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.66"></a><span id="l26.66" class="difflineplus">+      [&quot;attachment; filename=\&quot;foo\&quot;&quot;, [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.67"></a><span id="l26.67" class="difflineplus">+      [&quot;attachment; filename='foo'&quot;, [&quot;attachment&quot;, {filename: &quot;'foo'&quot;}]],</span>
<a href="#l26.68"></a><span id="l26.68" class="difflineplus">+      [&quot;attachment; filename=\&quot;=?UTF-8?Q?foo?=\&quot;&quot;,</span>
<a href="#l26.69"></a><span id="l26.69" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.70"></a><span id="l26.70" class="difflineplus">+      [&quot;attachment; filename==?UTF-8?Q?foo?=&quot;,</span>
<a href="#l26.71"></a><span id="l26.71" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.72"></a><span id="l26.72" class="difflineplus">+      // 2231/5987 tests from test_MIME_params.js</span>
<a href="#l26.73"></a><span id="l26.73" class="difflineplus">+      [&quot;attachment; filename*=UTF-8''extended&quot;,</span>
<a href="#l26.74"></a><span id="l26.74" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;extended&quot;}]],</span>
<a href="#l26.75"></a><span id="l26.75" class="difflineplus">+      [&quot;attachment; filename=basic; filename*=UTF-8''extended&quot;,</span>
<a href="#l26.76"></a><span id="l26.76" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;extended&quot;}]],</span>
<a href="#l26.77"></a><span id="l26.77" class="difflineplus">+      [&quot;attachment; filename*=UTF-8''extended; filename=basic&quot;,</span>
<a href="#l26.78"></a><span id="l26.78" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;extended&quot;}]],</span>
<a href="#l26.79"></a><span id="l26.79" class="difflineplus">+      [&quot;attachment; filename*0=foo; filename*1=bar&quot;,</span>
<a href="#l26.80"></a><span id="l26.80" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foobar&quot;}]],</span>
<a href="#l26.81"></a><span id="l26.81" class="difflineplus">+      [&quot;attachment; filename*0=first; filename*0=wrong; filename=basic&quot;,</span>
<a href="#l26.82"></a><span id="l26.82" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;first&quot;}]], // or basic?</span>
<a href="#l26.83"></a><span id="l26.83" class="difflineplus">+      [&quot;attachment; filename*0=first; filename*1=second; filename*0=wrong&quot;,</span>
<a href="#l26.84"></a><span id="l26.84" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;firstsecond&quot;}]], // or nothing?</span>
<a href="#l26.85"></a><span id="l26.85" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0=foo; filename*1=bar&quot;,</span>
<a href="#l26.86"></a><span id="l26.86" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foobar&quot;}]],</span>
<a href="#l26.87"></a><span id="l26.87" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0=first; filename*0=wrong; &quot; +</span>
<a href="#l26.88"></a><span id="l26.88" class="difflineplus">+        &quot;filename*=UTF-8''extended&quot;, [&quot;attachment&quot;, {filename: &quot;extended&quot;}]],</span>
<a href="#l26.89"></a><span id="l26.89" class="difflineplus">+      [&quot;attachment; filename=basic; filename*=UTF-8''extended; filename*0=foo&quot; +</span>
<a href="#l26.90"></a><span id="l26.90" class="difflineplus">+        &quot;; filename*1=bar&quot;, [&quot;attachment&quot;, {filename: &quot;extended&quot;}]],</span>
<a href="#l26.91"></a><span id="l26.91" class="difflineplus">+      [&quot;attachment; filename*0=foo; filename*2=bar&quot;,</span>
<a href="#l26.92"></a><span id="l26.92" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.93"></a><span id="l26.93" class="difflineplus">+      [&quot;attachment; filename*0=foo; filename*01=bar&quot;,</span>
<a href="#l26.94"></a><span id="l26.94" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l26.95"></a><span id="l26.95" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''multi; filename*1=line&quot; +</span>
<a href="#l26.96"></a><span id="l26.96" class="difflineplus">+        &quot;; filename*2*=%20extended&quot;,</span>
<a href="#l26.97"></a><span id="l26.97" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;multiline extended&quot;}]],</span>
<a href="#l26.98"></a><span id="l26.98" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''multi; filename*1=line&quot; +</span>
<a href="#l26.99"></a><span id="l26.99" class="difflineplus">+        &quot;; filename*3*=%20extended&quot;, [&quot;attachment&quot;, {filename: &quot;multiline&quot;}]],</span>
<a href="#l26.100"></a><span id="l26.100" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''multi; filename*1=line&quot; +</span>
<a href="#l26.101"></a><span id="l26.101" class="difflineplus">+        &quot;; filename*0*=UTF-8''wrong; filename*1=bad; filename*2=evil&quot;,</span>
<a href="#l26.102"></a><span id="l26.102" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;multiline&quot;}]],</span>
<a href="#l26.103"></a><span id="l26.103" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0=UTF-8''multi; filename*=UTF-8'&quot; +</span>
<a href="#l26.104"></a><span id="l26.104" class="difflineplus">+        &quot;'extended; filename*1=line; filename*2*=%20extended&quot;,</span>
<a href="#l26.105"></a><span id="l26.105" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;extended&quot;}]],</span>
<a href="#l26.106"></a><span id="l26.106" class="difflineplus">+      [&quot;attachment; filename*0=UTF-8''unescaped; filename*1*=%20so%20includes&quot; +</span>
<a href="#l26.107"></a><span id="l26.107" class="difflineplus">+        &quot;%20UTF-8''%20in%20value&quot;,</span>
<a href="#l26.108"></a><span id="l26.108" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;UTF-8''unescaped so includes UTF-8'' in value&quot;}]],</span>
<a href="#l26.109"></a><span id="l26.109" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''multi; filename*1=line&quot; +</span>
<a href="#l26.110"></a><span id="l26.110" class="difflineplus">+        &quot;; filename*0*=UTF-8''wrong; filename*1=bad; filename*2=evil&quot;,</span>
<a href="#l26.111"></a><span id="l26.111" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;multiline&quot;}]],</span>
<a href="#l26.112"></a><span id="l26.112" class="difflineplus">+      [&quot;attachment; filename=basic; filename*1=foo; filename*2=bar&quot;,</span>
<a href="#l26.113"></a><span id="l26.113" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;basic&quot;}]],</span>
<a href="#l26.114"></a><span id="l26.114" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''0; filename*1=1; filen&quot; +</span>
<a href="#l26.115"></a><span id="l26.115" class="difflineplus">+        &quot;ame*2=2;filename*3=3;filename*4=4;filename*5=5;filename*6=6;filename&quot; +</span>
<a href="#l26.116"></a><span id="l26.116" class="difflineplus">+        &quot;*7=7;filename*8=8;filename*9=9;filename*10=a;filename*11=b;filename*&quot; +</span>
<a href="#l26.117"></a><span id="l26.117" class="difflineplus">+        &quot;12=c;filename*13=d;filename*14=e;filename*15=f&quot;,</span>
<a href="#l26.118"></a><span id="l26.118" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;0123456789abcdef&quot;}]],</span>
<a href="#l26.119"></a><span id="l26.119" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''0; filename*1=1; filen&quot; +</span>
<a href="#l26.120"></a><span id="l26.120" class="difflineplus">+        &quot;ame*2=2;filename*3=3;filename*4=4;filename*5=5;filename*6=6;filename&quot; +</span>
<a href="#l26.121"></a><span id="l26.121" class="difflineplus">+        &quot;*7=7;filename*8=8;filename*9=9;filename*10=a;filename*11=b;filename*&quot; +</span>
<a href="#l26.122"></a><span id="l26.122" class="difflineplus">+        &quot;12=c;filename*14=e&quot;, [&quot;attachment&quot;, {filename: &quot;0123456789abc&quot;}]],</span>
<a href="#l26.123"></a><span id="l26.123" class="difflineplus">+      [&quot;attachment; filename*1=multi; filename*2=line; filename*3*=%20extended&quot;,</span>
<a href="#l26.124"></a><span id="l26.124" class="difflineplus">+        [&quot;attachment&quot;, {}]],</span>
<a href="#l26.125"></a><span id="l26.125" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''0; filename*1=1; filen&quot; +</span>
<a href="#l26.126"></a><span id="l26.126" class="difflineplus">+        &quot;ame*2=2;filename*3=3;filename*4=4;filename*5=5;filename*6=6;filename&quot; +</span>
<a href="#l26.127"></a><span id="l26.127" class="difflineplus">+        &quot;*7=7;filename*8=8;filename*9=9;filename*10=a;filename*11=b;filename*&quot; +</span>
<a href="#l26.128"></a><span id="l26.128" class="difflineplus">+        &quot;12=c;filename*13=d;filename*15=f;filename*14=e&quot;,</span>
<a href="#l26.129"></a><span id="l26.129" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;0123456789abcdef&quot;}]],</span>
<a href="#l26.130"></a><span id="l26.130" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''0; filename*1a=1&quot;,</span>
<a href="#l26.131"></a><span id="l26.131" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;0&quot;}]],</span>
<a href="#l26.132"></a><span id="l26.132" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''0; filename*1111111111&quot; +</span>
<a href="#l26.133"></a><span id="l26.133" class="difflineplus">+        &quot;1111111111111111111111111=1&quot;, [&quot;attachment&quot;, {filename: &quot;0&quot;}]],</span>
<a href="#l26.134"></a><span id="l26.134" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0*=UTF-8''0; filename*-1=1&quot;,</span>
<a href="#l26.135"></a><span id="l26.135" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;0&quot;}]],</span>
<a href="#l26.136"></a><span id="l26.136" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0=\&quot;0\&quot;; filename*1=1; filename*&quot; +</span>
<a href="#l26.137"></a><span id="l26.137" class="difflineplus">+        &quot;2*=%32&quot;, [&quot;attachment&quot;, {filename: &quot;012&quot;}]],</span>
<a href="#l26.138"></a><span id="l26.138" class="difflineplus">+      [&quot;attachment; filename=basic; filename**=UTF-8''0;&quot;,</span>
<a href="#l26.139"></a><span id="l26.139" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;basic&quot;}]],</span>
<a href="#l26.140"></a><span id="l26.140" class="difflineplus">+      [&quot;attachment; filename=IT839\x04\xB5(m8)2.pdf;&quot;,</span>
<a href="#l26.141"></a><span id="l26.141" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;IT839\u0004\u00b5(m8)2.pdf&quot;}]],</span>
<a href="#l26.142"></a><span id="l26.142" class="difflineplus">+      [&quot;attachment; filename*=utf-8''%41&quot;, [&quot;attachment&quot;, {filename: &quot;A&quot;}]],</span>
<a href="#l26.143"></a><span id="l26.143" class="difflineplus">+      // See bug 651185 and bug 703015</span>
<a href="#l26.144"></a><span id="l26.144" class="difflineplus">+      [&quot;attachment; filename*=\&quot;utf-8''%41\&quot;&quot;, [&quot;attachment&quot;, {filename: &quot;A&quot;}]],</span>
<a href="#l26.145"></a><span id="l26.145" class="difflineplus">+      [&quot;attachment; filename *=utf-8''foo-%41&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.146"></a><span id="l26.146" class="difflineplus">+      [&quot;attachment; filename*=''foo&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.147"></a><span id="l26.147" class="difflineplus">+      [&quot;attachment; filename*=a''foo&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.148"></a><span id="l26.148" class="difflineplus">+      // Bug 692574: we should ignore this one...</span>
<a href="#l26.149"></a><span id="l26.149" class="difflineplus">+      [&quot;attachment; filename*=UTF-8'foo-%41&quot;,</span>
<a href="#l26.150"></a><span id="l26.150" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo-A&quot;}]],</span>
<a href="#l26.151"></a><span id="l26.151" class="difflineplus">+      [&quot;attachment; filename*=foo-%41&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.152"></a><span id="l26.152" class="difflineplus">+      [&quot;attachment; filename*=UTF-8'foo-%41; filename=bar&quot;,</span>
<a href="#l26.153"></a><span id="l26.153" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo-A&quot;}]],</span>
<a href="#l26.154"></a><span id="l26.154" class="difflineplus">+      [&quot;attachment; filename*=ISO-8859-1''%c3%a4&quot;,</span>
<a href="#l26.155"></a><span id="l26.155" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;\u00c3\u00a4&quot;}]],</span>
<a href="#l26.156"></a><span id="l26.156" class="difflineplus">+      [&quot;attachment; filename*=ISO-8859-1''%e2%82%ac&quot;,</span>
<a href="#l26.157"></a><span id="l26.157" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;\u00e2\u201a\u00ac&quot;}]],</span>
<a href="#l26.158"></a><span id="l26.158" class="difflineplus">+      [&quot;attachment; filename*=UTF-8''A%e4B&quot;, [&quot;attachment&quot;, {}]],</span>
<a href="#l26.159"></a><span id="l26.159" class="difflineplus">+      [&quot;attachment; filename*=UTF-8''A%e4B; filename=fallback&quot;,</span>
<a href="#l26.160"></a><span id="l26.160" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;fallback&quot;}]],</span>
<a href="#l26.161"></a><span id="l26.161" class="difflineplus">+      [&quot;attachment; filename*0*=UTF-8''A%e4B; filename=fallback&quot;,</span>
<a href="#l26.162"></a><span id="l26.162" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;fallback&quot;}]],</span>
<a href="#l26.163"></a><span id="l26.163" class="difflineplus">+      [&quot;attachment; filename*0*=ISO-8859-15''euro-sign%3d%a4; filename*=ISO-8&quot; +</span>
<a href="#l26.164"></a><span id="l26.164" class="difflineplus">+        &quot;859-1''currency-sign%3d%a4&quot;,</span>
<a href="#l26.165"></a><span id="l26.165" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;currency-sign=\u00a4&quot;}]],</span>
<a href="#l26.166"></a><span id="l26.166" class="difflineplus">+      [&quot;attachment; filename*=ISO-8859-1''currency-sign%3d%a4; filename*0*=IS&quot; +</span>
<a href="#l26.167"></a><span id="l26.167" class="difflineplus">+        &quot;O-8859-15''euro-sign%3d%a4&quot;,</span>
<a href="#l26.168"></a><span id="l26.168" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;currency-sign=\u00a4&quot;}]],</span>
<a href="#l26.169"></a><span id="l26.169" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0=\&quot;foo\&quot;; filename*1=\&quot;\\b\\a\\&quot; +</span>
<a href="#l26.170"></a><span id="l26.170" class="difflineplus">+        &quot;r\&quot;&quot;, [&quot;attachment&quot;, {filename: &quot;foobar&quot;}]],</span>
<a href="#l26.171"></a><span id="l26.171" class="difflineplus">+      [&quot;attachment; filename=basic; filename*0=\&quot;foo\&quot;; filename*1=\&quot;\\b\\a\\&quot;,</span>
<a href="#l26.172"></a><span id="l26.172" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;fooba&quot;}]],</span>
<a href="#l26.173"></a><span id="l26.173" class="difflineplus">+      [&quot;attachment; filename=\&quot;\\b\\a\\&quot;, [&quot;attachment&quot;, {filename: &quot;ba&quot;}]],</span>
<a href="#l26.174"></a><span id="l26.174" class="difflineplus">+      // According to comments and bugs, this works in necko, but it doesn't</span>
<a href="#l26.175"></a><span id="l26.175" class="difflineplus">+      // appear that it ought to. See bug 732369 for more info.</span>
<a href="#l26.176"></a><span id="l26.176" class="difflineplus">+      [&quot;attachment; extension=bla filename=foo&quot;,</span>
<a href="#l26.177"></a><span id="l26.177" class="difflineplus">+        [&quot;attachment&quot;, {extension: &quot;bla&quot;}]],</span>
<a href="#l26.178"></a><span id="l26.178" class="difflineplus">+      [&quot;attachment; filename==?ISO-8859-1?Q?foo-=E4.html?=&quot;,</span>
<a href="#l26.179"></a><span id="l26.179" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo-\u00e4.html&quot;}]],</span>
<a href="#l26.180"></a><span id="l26.180" class="difflineplus">+      [&quot;attachment; filename=\&quot;=?ISO-8859-1?Q?foo-=E4.html?=\&quot;&quot;,</span>
<a href="#l26.181"></a><span id="l26.181" class="difflineplus">+        [&quot;attachment&quot;, {filename: &quot;foo-\u00e4.html&quot;}]],</span>
<a href="#l26.182"></a><span id="l26.182" class="difflineplus">+      [&quot;attachment; filename=\&quot;=?ISO-8859-1?Q?foo-=E4.html?=\&quot;; filename*=UTF&quot; +</span>
<a href="#l26.183"></a><span id="l26.183" class="difflineplus">+        &quot;-8''5987&quot;, [&quot;attachment&quot;, {filename: &quot;5987&quot;}]],</span>
<a href="#l26.184"></a><span id="l26.184" class="difflineplus">+    ];</span>
<a href="#l26.185"></a><span id="l26.185" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l26.186"></a><span id="l26.186" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l26.187"></a><span id="l26.187" class="difflineplus">+        let testMap = new Map();</span>
<a href="#l26.188"></a><span id="l26.188" class="difflineplus">+        for (let key in data[1][1])</span>
<a href="#l26.189"></a><span id="l26.189" class="difflineplus">+          testMap.set(key, data[1][1][key]);</span>
<a href="#l26.190"></a><span id="l26.190" class="difflineplus">+        testMap.preSemi = data[1][0];</span>
<a href="#l26.191"></a><span id="l26.191" class="difflineplus">+        assert.deepEqual(headerparser.parseParameterHeader(data[0], true, true),</span>
<a href="#l26.192"></a><span id="l26.192" class="difflineplus">+          testMap);</span>
<a href="#l26.193"></a><span id="l26.193" class="difflineplus">+      });</span>
<a href="#l26.194"></a><span id="l26.194" class="difflineplus">+    });</span>
<a href="#l26.195"></a><span id="l26.195" class="difflineplus">+  });</span>
<a href="#l26.196"></a><span id="l26.196" class="difflineplus">+  suite('parseAddressingHeader', function () {</span>
<a href="#l26.197"></a><span id="l26.197" class="difflineplus">+    let header_tests = [</span>
<a href="#l26.198"></a><span id="l26.198" class="difflineplus">+      [&quot;&quot;, []],</span>
<a href="#l26.199"></a><span id="l26.199" class="difflineplus">+      [&quot;Joe Schmoe &lt;jschmoe@invalid.invalid&gt;&quot;,</span>
<a href="#l26.200"></a><span id="l26.200" class="difflineplus">+        [{name: &quot;Joe Schmoe&quot;, email: &quot;jschmoe@invalid.invalid&quot;}]],</span>
<a href="#l26.201"></a><span id="l26.201" class="difflineplus">+      [&quot;user@tinderbox.invalid&quot;,</span>
<a href="#l26.202"></a><span id="l26.202" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;user@tinderbox.invalid&quot;}]],</span>
<a href="#l26.203"></a><span id="l26.203" class="difflineplus">+      [&quot;Hello Kitty &lt;a@b.c&gt;, No Kitty &lt;b@b.c&gt;&quot;,</span>
<a href="#l26.204"></a><span id="l26.204" class="difflineplus">+        [{name: &quot;Hello Kitty&quot;, email: &quot;a@b.c&quot;},</span>
<a href="#l26.205"></a><span id="l26.205" class="difflineplus">+         {name: &quot;No Kitty&quot;, email: &quot;b@b.c&quot;}]],</span>
<a href="#l26.206"></a><span id="l26.206" class="difflineplus">+      [&quot;undisclosed-recipients:;&quot;,</span>
<a href="#l26.207"></a><span id="l26.207" class="difflineplus">+        [{name: &quot;undisclosed-recipients&quot;, group: []}]],</span>
<a href="#l26.208"></a><span id="l26.208" class="difflineplus">+      [&quot;me@[127.0.0.1]&quot;, [{name: &quot;&quot;, email: &quot;me@[127.0.0.1]&quot;}]],</span>
<a href="#l26.209"></a><span id="l26.209" class="difflineplus">+      [&quot;\&quot;me\&quot;@a.com&quot;, [{name: &quot;&quot;, email: &quot;me@a.com&quot;}]],</span>
<a href="#l26.210"></a><span id="l26.210" class="difflineplus">+      [&quot;\&quot;!\&quot;@a.com&quot;, [{name: &quot;&quot;, email: &quot;\&quot;!\&quot;@a.com&quot;}]],</span>
<a href="#l26.211"></a><span id="l26.211" class="difflineplus">+      [&quot;\&quot;\\!\&quot;@a.com&quot;, [{name: &quot;&quot;, email: &quot;\&quot;!\&quot;@a.com&quot;}]],</span>
<a href="#l26.212"></a><span id="l26.212" class="difflineplus">+      [&quot;\&quot;\\\\!\&quot;@a.com&quot;, [{name: &quot;&quot;, email: &quot;\&quot;\\\\!\&quot;@a.com&quot;}]],</span>
<a href="#l26.213"></a><span id="l26.213" class="difflineplus">+      [&quot;Coward (not@email) &lt;real@email.com&gt;&quot;,</span>
<a href="#l26.214"></a><span id="l26.214" class="difflineplus">+        [{name: &quot;Coward (not@email)&quot;, email: &quot;real@email.com&quot;}]],</span>
<a href="#l26.215"></a><span id="l26.215" class="difflineplus">+      [&quot;Group: a@b.com, b@c.com;&quot;, [{name: &quot;Group&quot;, group:</span>
<a href="#l26.216"></a><span id="l26.216" class="difflineplus">+          [{name: &quot;&quot;, email: &quot;a@b.com&quot;}, {name: &quot;&quot;, email: &quot;b@c.com&quot;}]}]],</span>
<a href="#l26.217"></a><span id="l26.217" class="difflineplus">+      [&quot;a@invalid.invalid, Group: a@b.com;&quot;,</span>
<a href="#l26.218"></a><span id="l26.218" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;a@invalid.invalid&quot;},</span>
<a href="#l26.219"></a><span id="l26.219" class="difflineplus">+         {name: &quot;Group&quot;, group: [{name: &quot;&quot;, email: &quot;a@b.com&quot;}]}]],</span>
<a href="#l26.220"></a><span id="l26.220" class="difflineplus">+      [&quot;Group A: a@b.com;, Group B: b@b.com;&quot;,</span>
<a href="#l26.221"></a><span id="l26.221" class="difflineplus">+        [{name: &quot;Group A&quot;, group: [{name: &quot;&quot;, email: &quot;a@b.com&quot;}]},</span>
<a href="#l26.222"></a><span id="l26.222" class="difflineplus">+         {name: &quot;Group B&quot;, group: [{name: &quot;&quot;, email: &quot;b@b.com&quot;}]}]],</span>
<a href="#l26.223"></a><span id="l26.223" class="difflineplus">+      [&quot;Crazy (&lt;Stupid \&quot;name\&quot;) &lt;simple@a.email&gt;&quot;,</span>
<a href="#l26.224"></a><span id="l26.224" class="difflineplus">+        [{name: &quot;Crazy (&lt;Stupid name)&quot;, email: &quot;simple@a.email&quot;}]],</span>
<a href="#l26.225"></a><span id="l26.225" class="difflineplus">+      [&quot;Group: Real &lt;a@b.com&gt;, Fake &lt;a@b.com&gt;&quot;, [{name: &quot;Group&quot;, group:</span>
<a href="#l26.226"></a><span id="l26.226" class="difflineplus">+          [{name: &quot;Real&quot;, email: &quot;a@b.com&quot;},</span>
<a href="#l26.227"></a><span id="l26.227" class="difflineplus">+           {name: &quot;Fake&quot;, email: &quot;a@b.com&quot;}]}]],</span>
<a href="#l26.228"></a><span id="l26.228" class="difflineplus">+      [&quot;\&quot;Joe Q. Public\&quot; &lt;john.q.public@example.com&gt;,&quot; +</span>
<a href="#l26.229"></a><span id="l26.229" class="difflineplus">+       &quot;Test &lt;\&quot;abc!x.yz\&quot;@foo.invalid&gt;, Test &lt;test@[xyz!]&gt;,&quot; +</span>
<a href="#l26.230"></a><span id="l26.230" class="difflineplus">+       &quot;\&quot;Giant; \\\&quot;Big\\\&quot; Box\&quot; &lt;sysservices@example.net&gt;&quot;,</span>
<a href="#l26.231"></a><span id="l26.231" class="difflineplus">+         [{name: &quot;Joe Q. Public&quot;, email: &quot;john.q.public@example.com&quot;},</span>
<a href="#l26.232"></a><span id="l26.232" class="difflineplus">+          {name: &quot;Test&quot;, email: &quot;\&quot;abc!x.yz\&quot;@foo.invalid&quot;},</span>
<a href="#l26.233"></a><span id="l26.233" class="difflineplus">+          {name: &quot;Test&quot;, email: &quot;test@[xyz!]&quot;},</span>
<a href="#l26.234"></a><span id="l26.234" class="difflineplus">+          {name: &quot;Giant; \&quot;Big\&quot; Box&quot;, email: &quot;sysservices@example.net&quot;}]],</span>
<a href="#l26.235"></a><span id="l26.235" class="difflineplus">+      [&quot;Unfortunate breaking &lt; so . many . spaces @ here . invalid &gt;&quot;,</span>
<a href="#l26.236"></a><span id="l26.236" class="difflineplus">+        [{name: &quot;Unfortunate breaking&quot;, email: &quot;so.many.spaces@here.invalid&quot;}]],</span>
<a href="#l26.237"></a><span id="l26.237" class="difflineplus">+      [&quot;so . many . spaces @ here . invalid&quot;,</span>
<a href="#l26.238"></a><span id="l26.238" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;so.many.spaces@here.invalid&quot;}]],</span>
<a href="#l26.239"></a><span id="l26.239" class="difflineplus">+      [&quot;abc@foo.invalid&quot;, [{name:&quot;&quot;, email: &quot;abc@foo.invalid&quot;}]],</span>
<a href="#l26.240"></a><span id="l26.240" class="difflineplus">+      [&quot;foo &lt;ghj@foo.invalid&gt;&quot;, [{name: &quot;foo&quot;, email: &quot;ghj@foo.invalid&quot;}]],</span>
<a href="#l26.241"></a><span id="l26.241" class="difflineplus">+      [&quot;abc@foo.invalid, foo &lt;ghj@foo.invalid&gt;&quot;,</span>
<a href="#l26.242"></a><span id="l26.242" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;abc@foo.invalid&quot;},</span>
<a href="#l26.243"></a><span id="l26.243" class="difflineplus">+         {name: &quot;foo&quot;, email: &quot;ghj@foo.invalid&quot;}]],</span>
<a href="#l26.244"></a><span id="l26.244" class="difflineplus">+      [&quot;foo bar &lt;foo@bar.invalid&gt;&quot;,</span>
<a href="#l26.245"></a><span id="l26.245" class="difflineplus">+        [{name: &quot;foo bar&quot;, email: &quot;foo@bar.invalid&quot;}]],</span>
<a href="#l26.246"></a><span id="l26.246" class="difflineplus">+      [&quot;foo bar &lt;foo@bar.invalid&gt;, abc@foo.invalid, foo &lt;ghj@foo.invalid&gt;&quot;,</span>
<a href="#l26.247"></a><span id="l26.247" class="difflineplus">+        [{name: &quot;foo bar&quot;, email: &quot;foo@bar.invalid&quot;},</span>
<a href="#l26.248"></a><span id="l26.248" class="difflineplus">+         {name: &quot;&quot;, email: &quot;abc@foo.invalid&quot;},</span>
<a href="#l26.249"></a><span id="l26.249" class="difflineplus">+         {name: &quot;foo&quot;, email: &quot;ghj@foo.invalid&quot;}]],</span>
<a href="#l26.250"></a><span id="l26.250" class="difflineplus">+      [&quot;foo\u00D0 bar &lt;foo@bar.invalid&gt;, \u00F6foo &lt;ghj@foo.invalid&gt;&quot;,</span>
<a href="#l26.251"></a><span id="l26.251" class="difflineplus">+        [{name: &quot;foo\u00D0 bar&quot;, email: &quot;foo@bar.invalid&quot;},</span>
<a href="#l26.252"></a><span id="l26.252" class="difflineplus">+         {name: &quot;\u00F6foo&quot;, email: &quot;ghj@foo.invalid&quot;}]],</span>
<a href="#l26.253"></a><span id="l26.253" class="difflineplus">+      [&quot;Undisclosed recipients:;&quot;,</span>
<a href="#l26.254"></a><span id="l26.254" class="difflineplus">+        [{name: &quot;Undisclosed recipients&quot;, group: []}]],</span>
<a href="#l26.255"></a><span id="l26.255" class="difflineplus">+      [&quot;\&quot; \&quot;@a a;b&quot;,</span>
<a href="#l26.256"></a><span id="l26.256" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;\&quot; \&quot;@a a&quot;},</span>
<a href="#l26.257"></a><span id="l26.257" class="difflineplus">+         {name: &quot;b&quot;, email: &quot;&quot;}]],</span>
<a href="#l26.258"></a><span id="l26.258" class="difflineplus">+      [&quot;Undisclosed recipients:;\0:; foo &lt;ghj@veryveryveryverylongveryveryver&quot; +</span>
<a href="#l26.259"></a><span id="l26.259" class="difflineplus">+        &quot;yveryinvalidaddress.invalid&gt;&quot;,</span>
<a href="#l26.260"></a><span id="l26.260" class="difflineplus">+        [{name: &quot;Undisclosed recipients&quot;, group: []},</span>
<a href="#l26.261"></a><span id="l26.261" class="difflineplus">+         {name: &quot;\0&quot;, group: []},</span>
<a href="#l26.262"></a><span id="l26.262" class="difflineplus">+         {name: &quot;foo&quot;, email: &quot;ghj@veryveryveryverylongveryveryveryveryinvali&quot; +</span>
<a href="#l26.263"></a><span id="l26.263" class="difflineplus">+           &quot;daddress.invalid&quot;}]],</span>
<a href="#l26.264"></a><span id="l26.264" class="difflineplus">+      // XXX: test_nsIMsgHeaderParser2 has an empty one here...</span>
<a href="#l26.265"></a><span id="l26.265" class="difflineplus">+      [&quot;&lt;a;a@invalid&quot;,</span>
<a href="#l26.266"></a><span id="l26.266" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;a&quot;}, {name: &quot;&quot;, email: &quot;a@invalid&quot;}]],</span>
<a href="#l26.267"></a><span id="l26.267" class="difflineplus">+      [&quot;me@foo.invalid&quot;, [{name: &quot;&quot;, email: &quot;me@foo.invalid&quot;}]],</span>
<a href="#l26.268"></a><span id="l26.268" class="difflineplus">+      [&quot;me@foo.invalid, me2@foo.invalid&quot;,</span>
<a href="#l26.269"></a><span id="l26.269" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;me@foo.invalid&quot;},</span>
<a href="#l26.270"></a><span id="l26.270" class="difflineplus">+         {name: &quot;&quot;, email: &quot;me2@foo.invalid&quot;}]],</span>
<a href="#l26.271"></a><span id="l26.271" class="difflineplus">+      ['&quot;foo bar&quot; &lt;me@foo.invalid&gt;',</span>
<a href="#l26.272"></a><span id="l26.272" class="difflineplus">+        [{name: &quot;foo bar&quot;, email: &quot;me@foo.invalid&quot;}]],</span>
<a href="#l26.273"></a><span id="l26.273" class="difflineplus">+      ['&quot;foo bar&quot; &lt;me@foo.invalid&gt;, &quot;bar foo&quot; &lt;me2@foo.invalid&gt;',</span>
<a href="#l26.274"></a><span id="l26.274" class="difflineplus">+        [{name: &quot;foo bar&quot;, email: &quot;me@foo.invalid&quot;},</span>
<a href="#l26.275"></a><span id="l26.275" class="difflineplus">+         {name: &quot;bar foo&quot;, email: &quot;me2@foo.invalid&quot;}]],</span>
<a href="#l26.276"></a><span id="l26.276" class="difflineplus">+      [&quot;A Group:Ed Jones &lt;c@a.invalid&gt;,joe@where.invalid,John &lt;jdoe@one.invalid&gt;;&quot;,</span>
<a href="#l26.277"></a><span id="l26.277" class="difflineplus">+        [{name: &quot;A Group&quot;, group: [</span>
<a href="#l26.278"></a><span id="l26.278" class="difflineplus">+          {name: &quot;Ed Jones&quot;, email: &quot;c@a.invalid&quot;},</span>
<a href="#l26.279"></a><span id="l26.279" class="difflineplus">+          {name: &quot;&quot;, email: &quot;joe@where.invalid&quot;},</span>
<a href="#l26.280"></a><span id="l26.280" class="difflineplus">+          {name: &quot;John&quot;, email: &quot;jdoe@one.invalid&quot;}]}]],</span>
<a href="#l26.281"></a><span id="l26.281" class="difflineplus">+      ['mygroup:;, empty:;, foo@foo.invalid, othergroup:bar@foo.invalid, bar2' +</span>
<a href="#l26.282"></a><span id="l26.282" class="difflineplus">+        '@foo.invalid;,       y@y.invalid, empty:;',</span>
<a href="#l26.283"></a><span id="l26.283" class="difflineplus">+        [{name: &quot;mygroup&quot;, group: []},</span>
<a href="#l26.284"></a><span id="l26.284" class="difflineplus">+         {name: &quot;empty&quot;, group: []},</span>
<a href="#l26.285"></a><span id="l26.285" class="difflineplus">+         {name: &quot;&quot;, email: &quot;foo@foo.invalid&quot;},</span>
<a href="#l26.286"></a><span id="l26.286" class="difflineplus">+         {name: &quot;othergroup&quot;, group: [</span>
<a href="#l26.287"></a><span id="l26.287" class="difflineplus">+           {name: &quot;&quot;, email: &quot;bar@foo.invalid&quot;},</span>
<a href="#l26.288"></a><span id="l26.288" class="difflineplus">+           {name: &quot;&quot;, email: &quot;bar2@foo.invalid&quot;}</span>
<a href="#l26.289"></a><span id="l26.289" class="difflineplus">+         ]},</span>
<a href="#l26.290"></a><span id="l26.290" class="difflineplus">+         {name: &quot;&quot;, email: &quot;y@y.invalid&quot;},</span>
<a href="#l26.291"></a><span id="l26.291" class="difflineplus">+         {name: &quot;empty&quot;, group: []}]],</span>
<a href="#l26.292"></a><span id="l26.292" class="difflineplus">+      [&quot;Undisclosed recipients:;;;;;;;;;;;;;;;;,,,,,,,,,,,,,,,,&quot;,</span>
<a href="#l26.293"></a><span id="l26.293" class="difflineplus">+        [{name: &quot;Undisclosed recipients&quot;, group: []}]],</span>
<a href="#l26.294"></a><span id="l26.294" class="difflineplus">+      [&quot;a@xxx.invalid; b@xxx.invalid&quot;,</span>
<a href="#l26.295"></a><span id="l26.295" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;a@xxx.invalid&quot;},</span>
<a href="#l26.296"></a><span id="l26.296" class="difflineplus">+         {name: &quot;&quot;, email: &quot;b@xxx.invalid&quot;}]],</span>
<a href="#l26.297"></a><span id="l26.297" class="difflineplus">+      [&quot;a@xxx.invalid; B &lt;b@xxx.invalid&gt;&quot;,</span>
<a href="#l26.298"></a><span id="l26.298" class="difflineplus">+        [{name: &quot;&quot;, email: &quot;a@xxx.invalid&quot;},</span>
<a href="#l26.299"></a><span id="l26.299" class="difflineplus">+         {name: &quot;B&quot;, email: &quot;b@xxx.invalid&quot;}]],</span>
<a href="#l26.300"></a><span id="l26.300" class="difflineplus">+      ['&quot;A &quot; &lt;a@xxx.invalid&gt;; b@xxx.invalid',</span>
<a href="#l26.301"></a><span id="l26.301" class="difflineplus">+        [{name: &quot;A &quot;, email: &quot;a@xxx.invalid&quot;},</span>
<a href="#l26.302"></a><span id="l26.302" class="difflineplus">+         {name: &quot;&quot;, email: &quot;b@xxx.invalid&quot;}]],</span>
<a href="#l26.303"></a><span id="l26.303" class="difflineplus">+      [&quot;A &lt;a@xxx.invalid&gt;; B &lt;b@xxx.invalid&gt;&quot;,</span>
<a href="#l26.304"></a><span id="l26.304" class="difflineplus">+        [{name: &quot;A&quot;, email: &quot;a@xxx.invalid&quot;},</span>
<a href="#l26.305"></a><span id="l26.305" class="difflineplus">+         {name: &quot;B&quot;, email: &quot;b@xxx.invalid&quot;}]],</span>
<a href="#l26.306"></a><span id="l26.306" class="difflineplus">+      [&quot;A (this: is, a comment;) &lt;a.invalid&gt;; g:   (this: is, &lt;a&gt; comment;) C&quot; +</span>
<a href="#l26.307"></a><span id="l26.307" class="difflineplus">+        &quot;&lt;c.invalid&gt;, d.invalid;&quot;,</span>
<a href="#l26.308"></a><span id="l26.308" class="difflineplus">+        [{name: &quot;A (this: is, a comment;)&quot;, email: &quot;a.invalid&quot;},</span>
<a href="#l26.309"></a><span id="l26.309" class="difflineplus">+         {name: &quot;g&quot;, group: [</span>
<a href="#l26.310"></a><span id="l26.310" class="difflineplus">+           {name: &quot;(this: is, &lt;a&gt; comment;) C&quot;, email: &quot;c.invalid&quot;},</span>
<a href="#l26.311"></a><span id="l26.311" class="difflineplus">+           {name: &quot;d.invalid&quot;, email: &quot;&quot;}]}]],</span>
<a href="#l26.312"></a><span id="l26.312" class="difflineplus">+      ['Mary Smith &lt;mary@x.invalid&gt;, extra:;, group:jdoe@example.invalid; Who' +</span>
<a href="#l26.313"></a><span id="l26.313" class="difflineplus">+        '? &lt;one@y.invalid&gt;; &lt;boss@nil.invalid&gt;, &quot;Giant; \\&quot;Big\\&quot; Box&quot; &lt;sysse' +</span>
<a href="#l26.314"></a><span id="l26.314" class="difflineplus">+        'rvices@example.invalid&gt;,         ',</span>
<a href="#l26.315"></a><span id="l26.315" class="difflineplus">+        [{name: &quot;Mary Smith&quot;, email: &quot;mary@x.invalid&quot;},</span>
<a href="#l26.316"></a><span id="l26.316" class="difflineplus">+         {name: &quot;extra&quot;, group: []},</span>
<a href="#l26.317"></a><span id="l26.317" class="difflineplus">+         {name: &quot;group&quot;, group: [{name: &quot;&quot;, email: &quot;jdoe@example.invalid&quot;}]},</span>
<a href="#l26.318"></a><span id="l26.318" class="difflineplus">+         {name: &quot;Who?&quot;, email: &quot;one@y.invalid&quot;},</span>
<a href="#l26.319"></a><span id="l26.319" class="difflineplus">+         {name: &quot;&quot;, email: &quot;boss@nil.invalid&quot;},</span>
<a href="#l26.320"></a><span id="l26.320" class="difflineplus">+         {name: &quot;Giant; \&quot;Big\&quot; Box&quot;, email: &quot;sysservices@example.invalid&quot;}]],</span>
<a href="#l26.321"></a><span id="l26.321" class="difflineplus">+      [&quot;Undisclosed recipients: a@foo.invalid ;;extra:;&quot;,</span>
<a href="#l26.322"></a><span id="l26.322" class="difflineplus">+        [{name: &quot;Undisclosed recipients&quot;, group: [</span>
<a href="#l26.323"></a><span id="l26.323" class="difflineplus">+          {name: &quot;&quot;, email: &quot;a@foo.invalid&quot;}]},</span>
<a href="#l26.324"></a><span id="l26.324" class="difflineplus">+         {name: &quot;extra&quot;, group: []}]],</span>
<a href="#l26.325"></a><span id="l26.325" class="difflineplus">+      [&quot;Undisclosed recipients:;;extra:a@foo.invalid;&quot;,</span>
<a href="#l26.326"></a><span id="l26.326" class="difflineplus">+        [{name: &quot;Undisclosed recipients&quot;, group: []},</span>
<a href="#l26.327"></a><span id="l26.327" class="difflineplus">+         {name: &quot;extra&quot;, group: [{name: &quot;&quot;, email: &quot;a@foo.invalid&quot;}]}]],</span>
<a href="#l26.328"></a><span id="l26.328" class="difflineplus">+      [&quot;a &lt; &lt;a@b.c&gt;&quot;, [{name: &quot;a&quot;, email: &quot;a@b.c&quot;}]],</span>
<a href="#l26.329"></a><span id="l26.329" class="difflineplus">+      [&quot;Name &lt;incomplete@email&quot;, [{name: &quot;Name&quot;, email: &quot;incomplete@email&quot;}]],</span>
<a href="#l26.330"></a><span id="l26.330" class="difflineplus">+      [&quot;Name &lt;space here@email.invalid&gt;&quot;,</span>
<a href="#l26.331"></a><span id="l26.331" class="difflineplus">+        [{name: 'Name', email: '&quot;space here&quot;@email.invalid'}]],</span>
<a href="#l26.332"></a><span id="l26.332" class="difflineplus">+      [&quot;Name &lt;not an email&gt;&quot;, [{name: &quot;Name&quot;, email: &quot;not an email&quot;}]],</span>
<a href="#l26.333"></a><span id="l26.333" class="difflineplus">+      [&quot;=?UTF-8?Q?Simple?= &lt;a@b.c&gt;&quot;,</span>
<a href="#l26.334"></a><span id="l26.334" class="difflineplus">+        [{name: &quot;=?UTF-8?Q?Simple?=&quot;, email: &quot;a@b.c&quot;}]],</span>
<a href="#l26.335"></a><span id="l26.335" class="difflineplus">+    ];</span>
<a href="#l26.336"></a><span id="l26.336" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l26.337"></a><span id="l26.337" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l26.338"></a><span id="l26.338" class="difflineplus">+        assert.deepEqual(headerparser.parseAddressingHeader(data[0], false),</span>
<a href="#l26.339"></a><span id="l26.339" class="difflineplus">+          data[1]);</span>
<a href="#l26.340"></a><span id="l26.340" class="difflineplus">+      });</span>
<a href="#l26.341"></a><span id="l26.341" class="difflineplus">+    });</span>
<a href="#l26.342"></a><span id="l26.342" class="difflineplus">+  });</span>
<a href="#l26.343"></a><span id="l26.343" class="difflineplus">+  suite('parseAddressingHeader (RFC 2047 support)', function () {</span>
<a href="#l26.344"></a><span id="l26.344" class="difflineplus">+    let header_tests = [</span>
<a href="#l26.345"></a><span id="l26.345" class="difflineplus">+      [&quot;Simple &lt;a@b.c&gt;&quot;, [{name: &quot;Simple&quot;, email: &quot;a@b.c&quot;}]],</span>
<a href="#l26.346"></a><span id="l26.346" class="difflineplus">+      [&quot;=?UTF-8?Q?Simple?= &lt;a@b.c&gt;&quot;, [{name: &quot;Simple&quot;, email: &quot;a@b.c&quot;}]],</span>
<a href="#l26.347"></a><span id="l26.347" class="difflineplus">+      [&quot;=?UTF-8?Q?=3C@b.c?= &lt;a@b.c&gt;&quot;, [{name: &quot;&lt;@b.c&quot;, email: &quot;a@b.c&quot;}]],</span>
<a href="#l26.348"></a><span id="l26.348" class="difflineplus">+</span>
<a href="#l26.349"></a><span id="l26.349" class="difflineplus">+      // RFC 2047 token should not interfer with lexical processing</span>
<a href="#l26.350"></a><span id="l26.350" class="difflineplus">+      [&quot;=?UTF-8?Q?a@b.c,?= &lt;b@b.c&gt;&quot;, [{name: &quot;a@b.c,&quot;, email: &quot;b@b.c&quot;}]],</span>
<a href="#l26.351"></a><span id="l26.351" class="difflineplus">+      [&quot;=?UTF-8?Q?a@b.c=2C?= &lt;b@b.c&gt;&quot;, [{name: &quot;a@b.c,&quot;, email: &quot;b@b.c&quot;}]],</span>
<a href="#l26.352"></a><span id="l26.352" class="difflineplus">+      [&quot;=?UTF-8?Q?&lt;?= &lt;a@b.c&gt;&quot;, [{name: &quot;&lt;&quot;, email: &quot;a@b.c&quot;}]],</span>
<a href="#l26.353"></a><span id="l26.353" class="difflineplus">+      [&quot;Simple =?UTF-8?Q?&lt;?= a@b.c&gt;&quot;,</span>
<a href="#l26.354"></a><span id="l26.354" class="difflineplus">+        [{name: &quot;&quot;, email: '&quot;Simple &lt; a&quot;@b.c'}]],</span>
<a href="#l26.355"></a><span id="l26.355" class="difflineplus">+      [&quot;Tag &lt;=?UTF-8?Q?email?=@b.c&gt;&quot;, [{name: &quot;Tag&quot;, email: &quot;email@b.c&quot;}]],</span>
<a href="#l26.356"></a><span id="l26.356" class="difflineplus">+    ];</span>
<a href="#l26.357"></a><span id="l26.357" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l26.358"></a><span id="l26.358" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l26.359"></a><span id="l26.359" class="difflineplus">+        assert.deepEqual(headerparser.parseAddressingHeader(data[0], true),</span>
<a href="#l26.360"></a><span id="l26.360" class="difflineplus">+          data[1]);</span>
<a href="#l26.361"></a><span id="l26.361" class="difflineplus">+      });</span>
<a href="#l26.362"></a><span id="l26.362" class="difflineplus">+    });</span>
<a href="#l26.363"></a><span id="l26.363" class="difflineplus">+  });</span>
<a href="#l26.364"></a><span id="l26.364" class="difflineplus">+  suite('decodeRFC2047Words', function () {</span>
<a href="#l26.365"></a><span id="l26.365" class="difflineplus">+    let header_tests = [</span>
<a href="#l26.366"></a><span id="l26.366" class="difflineplus">+      // Some basic sanity tests for the test process</span>
<a href="#l26.367"></a><span id="l26.367" class="difflineplus">+      [&quot;Test&quot;, &quot;Test&quot;],</span>
<a href="#l26.368"></a><span id="l26.368" class="difflineplus">+      [&quot;Test 2&quot;, &quot;Test 2&quot;],</span>
<a href="#l26.369"></a><span id="l26.369" class="difflineplus">+      [&quot;Basic  words&quot;, &quot;Basic  words&quot;],</span>
<a href="#l26.370"></a><span id="l26.370" class="difflineplus">+      [&quot;Not a =? word&quot;, &quot;Not a =? word&quot;],</span>
<a href="#l26.371"></a><span id="l26.371" class="difflineplus">+</span>
<a href="#l26.372"></a><span id="l26.372" class="difflineplus">+      // Simple 2047 decodings</span>
<a href="#l26.373"></a><span id="l26.373" class="difflineplus">+      [&quot;=?UTF-8?Q?Encoded?=&quot;, &quot;Encoded&quot;],</span>
<a href="#l26.374"></a><span id="l26.374" class="difflineplus">+      [&quot;=?UTF-8?q?Encoded?=&quot;, &quot;Encoded&quot;],</span>
<a href="#l26.375"></a><span id="l26.375" class="difflineplus">+      [&quot;=?ISO-8859-1?Q?oxyg=e8ne?=&quot;, &quot;oxyg\u00e8ne&quot;],</span>
<a href="#l26.376"></a><span id="l26.376" class="difflineplus">+      [&quot;=?UTF-8?B?QmFzZTY0?=&quot;, &quot;Base64&quot;],</span>
<a href="#l26.377"></a><span id="l26.377" class="difflineplus">+      [&quot;=?UTF-8?b?QmFzZTY0?=&quot;, &quot;Base64&quot;],</span>
<a href="#l26.378"></a><span id="l26.378" class="difflineplus">+      [&quot;=?UTF-8?Q?A_space?=&quot;, &quot;A space&quot;],</span>
<a href="#l26.379"></a><span id="l26.379" class="difflineplus">+      [&quot;=?UTF-8?Q?A space?=&quot;, &quot;A space&quot;],</span>
<a href="#l26.380"></a><span id="l26.380" class="difflineplus">+      [&quot;A =?UTF-8?Q?B?= C&quot;, &quot;A B C&quot;],</span>
<a href="#l26.381"></a><span id="l26.381" class="difflineplus">+      [&quot;=?UTF-8?Q?A?= =?UTF-8?Q?B?=&quot;, &quot;AB&quot;],</span>
<a href="#l26.382"></a><span id="l26.382" class="difflineplus">+      [&quot;=?UTF-8?Q?oxyg=c3=a8ne?=&quot;, &quot;oxyg\u00e8ne&quot;],</span>
<a href="#l26.383"></a><span id="l26.383" class="difflineplus">+      [&quot;=?utf-8?Q?oxyg=C3=A8ne?=&quot;, &quot;oxyg\u00e8ne&quot;],</span>
<a href="#l26.384"></a><span id="l26.384" class="difflineplus">+      [&quot;=?UTF-8?B?b3h5Z8OobmU=?=&quot;, &quot;oxyg\u00e8ne&quot;],</span>
<a href="#l26.385"></a><span id="l26.385" class="difflineplus">+      [&quot;=?UTF-8*fr?B?b3h5Z8OobmU=?=&quot;, &quot;oxyg\u00e8ne&quot;],</span>
<a href="#l26.386"></a><span id="l26.386" class="difflineplus">+      [&quot;=?BIG5?Q?=B9=CF=AE=D1=C0]SSCI=A4=CEJCR=B8=EA=AE=C6=AEw=C1=BF=B2=DF=A1A=A8&quot; +</span>
<a href="#l26.387"></a><span id="l26.387" class="difflineplus">+       &quot;=F3=A7U=B1z=A1u=B4=A3=A4=C9=AC=E3=A8s=AF=C0=BD=E8=BBP=AE=C4=B2v=A5H=A4=CE&quot; +</span>
<a href="#l26.388"></a><span id="l26.388" class="difflineplus">+       &quot;=A7=EB=BDZ=B5=A6=B2=A4=AA=BA=B9B=A5=CE=A1v=A1A=C5w=AA=EF=B3=F8=A6W=B0=D1&quot; +</span>
<a href="#l26.389"></a><span id="l26.389" class="difflineplus">+       &quot;=A5[=A1C?=&quot;, &quot;\u5716\u66F8\u9928SSCI\u53CAJCR\u8CC7\u6599\u5EAB\u8B1B&quot; +</span>
<a href="#l26.390"></a><span id="l26.390" class="difflineplus">+       &quot;\u7FD2\uFF0C\u5354\u52A9\u60A8\u300C\u63D0\u5347\u7814\u7A76\u7D20\u8CEA&quot; +</span>
<a href="#l26.391"></a><span id="l26.391" class="difflineplus">+       &quot;\u8207\u6548\u7387\u4EE5\u53CA\u6295\u7A3F\u7B56\u7565\u7684\u904B\u7528&quot; +</span>
<a href="#l26.392"></a><span id="l26.392" class="difflineplus">+       &quot;\u300D\uFF0C\u6B61\u8FCE\u5831\u540D\u53C3\u52A0\u3002&quot;],</span>
<a href="#l26.393"></a><span id="l26.393" class="difflineplus">+</span>
<a href="#l26.394"></a><span id="l26.394" class="difflineplus">+      // Invalid decodings</span>
<a href="#l26.395"></a><span id="l26.395" class="difflineplus">+      [&quot;=?UTF-8?Q?=f0ab?=&quot;, &quot;\ufffdab&quot;],</span>
<a href="#l26.396"></a><span id="l26.396" class="difflineplus">+      [&quot;=?UTF-8?Q?=f0?= ab&quot;, &quot;\ufffd ab&quot;],</span>
<a href="#l26.397"></a><span id="l26.397" class="difflineplus">+      [&quot;=?UTF-8?Q?=ed=a0=bd=ed=b2=a9?=&quot;, &quot;\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd&quot;],</span>
<a href="#l26.398"></a><span id="l26.398" class="difflineplus">+      [&quot;=?NoSuchCharset?Q?ab?=&quot;, &quot;=?NoSuchCharset?Q?ab?=&quot;],</span>
<a href="#l26.399"></a><span id="l26.399" class="difflineplus">+      [&quot;=?UTF-8?U?Encoded?=&quot;, &quot;=?UTF-8?U?Encoded?=&quot;],</span>
<a href="#l26.400"></a><span id="l26.400" class="difflineplus">+      [&quot;=?UTF-8?Q?Almost&quot;, &quot;=?UTF-8?Q?Almost&quot;],</span>
<a href="#l26.401"></a><span id="l26.401" class="difflineplus">+</span>
<a href="#l26.402"></a><span id="l26.402" class="difflineplus">+      // Try some non-BMP characters in various charsets</span>
<a href="#l26.403"></a><span id="l26.403" class="difflineplus">+      [&quot;=?UTF-8?B?8J+SqQ==?=&quot;, &quot;\ud83d\udca9&quot;],</span>
<a href="#l26.404"></a><span id="l26.404" class="difflineplus">+      // The goal for the next one is to be a non-BMP in a non-full-Unicode</span>
<a href="#l26.405"></a><span id="l26.405" class="difflineplus">+      // charset. The only category where this exists is a small set of</span>
<a href="#l26.406"></a><span id="l26.406" class="difflineplus">+      // characters in Big5, which were previously mapped to a PUA in an older</span>
<a href="#l26.407"></a><span id="l26.407" class="difflineplus">+      // version but then reassigned to Plane 1. However, Big5 is really a set</span>
<a href="#l26.408"></a><span id="l26.408" class="difflineplus">+      // of slightly different, slightly incompatible charsets.</span>
<a href="#l26.409"></a><span id="l26.409" class="difflineplus">+      // TODO: This requires future investigation. Bug 912470 discusses the</span>
<a href="#l26.410"></a><span id="l26.410" class="difflineplus">+      // changes to Big5 proposed within Mozilla.</span>
<a href="#l26.411"></a><span id="l26.411" class="difflineplus">+      //[&quot;=?Big5?Q?=87E?=&quot;, &quot;\ud85c\ude67&quot;],</span>
<a href="#l26.412"></a><span id="l26.412" class="difflineplus">+      [&quot;=?GB18030?B?lDnaMw==?=&quot;, &quot;\ud83d\udca9&quot;],</span>
<a href="#l26.413"></a><span id="l26.413" class="difflineplus">+</span>
<a href="#l26.414"></a><span id="l26.414" class="difflineplus">+      // How to handle breaks in multi-byte encoding</span>
<a href="#l26.415"></a><span id="l26.415" class="difflineplus">+      [&quot;=?UTF-8?Q?=f0=9f?= =?UTF-8?Q?=92=a9?=&quot;, &quot;\ud83d\udca9&quot;],</span>
<a href="#l26.416"></a><span id="l26.416" class="difflineplus">+      [&quot;=?UTF-8?B?8J+S?= =?UTF-8?B?qQ==?=&quot;, &quot;\ud83d\udca9&quot;],</span>
<a href="#l26.417"></a><span id="l26.417" class="difflineplus">+      [&quot;=?UTF-8?B?8J+S?= =?UTF-8?Q?=a9?=&quot;, &quot;\ud83d\udca9&quot;],</span>
<a href="#l26.418"></a><span id="l26.418" class="difflineplus">+      [&quot;=?UTF-8?B?8J+S?= =?ISO-8859-1?B?qQ==?=&quot;, &quot;\ufffd\u00a9&quot;],</span>
<a href="#l26.419"></a><span id="l26.419" class="difflineplus">+      [&quot;=?UTF-8?Q?=f0?= =?UTF-8?Q?ab?=&quot;, &quot;\ufffdab&quot;],</span>
<a href="#l26.420"></a><span id="l26.420" class="difflineplus">+</span>
<a href="#l26.421"></a><span id="l26.421" class="difflineplus">+      // This is a split non-BMP character.</span>
<a href="#l26.422"></a><span id="l26.422" class="difflineplus">+      [&quot;=?UTF-8?B?YfCfkqnwn5Kp8J+SqfCfkqnwn5Kp8J+SqfCfkqnvv70=?= =?UTF-8?B?77+9?=&quot;,</span>
<a href="#l26.423"></a><span id="l26.423" class="difflineplus">+        &quot;a\uD83D\uDCA9\uD83D\uDCA9\uD83D\uDCA9\uD83D\uDCA9\uD83D\uDCA9\uD83D&quot; +</span>
<a href="#l26.424"></a><span id="l26.424" class="difflineplus">+        &quot;\uDCA9\uD83D\uDCA9\uFFFD\uFFFD&quot;],</span>
<a href="#l26.425"></a><span id="l26.425" class="difflineplus">+</span>
<a href="#l26.426"></a><span id="l26.426" class="difflineplus">+      // Spaces in RFC 2047 tokens</span>
<a href="#l26.427"></a><span id="l26.427" class="difflineplus">+      [&quot;=?UTF-8?Q?Invalid token?=&quot;, &quot;Invalid token&quot;],</span>
<a href="#l26.428"></a><span id="l26.428" class="difflineplus">+</span>
<a href="#l26.429"></a><span id="l26.429" class="difflineplus">+      // More tests from bug 493544</span>
<a href="#l26.430"></a><span id="l26.430" class="difflineplus">+      [&quot;AAA =?UTF-8?Q?bbb?= CCC =?UTF-8?Q?ddd?= EEE =?UTF-8?Q?fff?= GGG&quot;,</span>
<a href="#l26.431"></a><span id="l26.431" class="difflineplus">+        &quot;AAA bbb CCC ddd EEE fff GGG&quot;],</span>
<a href="#l26.432"></a><span id="l26.432" class="difflineplus">+      [&quot;=?UTF-8?B?4oiAICDiiIEgIOKIgiAg4oiDICDiiIQgIOKIhSAg4oiGICDiiIcgIOKIiC&quot; +</span>
<a href="#l26.433"></a><span id="l26.433" class="difflineplus">+        &quot;Ag?=\n =?UTF-8?B?4oiJICDiiIogIOKIiyAg4oiMICDiiI0gIOKIjiAg4oiP?=&quot;,</span>
<a href="#l26.434"></a><span id="l26.434" class="difflineplus">+        &quot;\u2200  \u2201  \u2202  \u2203  \u2204  \u2205  \u2206  \u2207  &quot; +</span>
<a href="#l26.435"></a><span id="l26.435" class="difflineplus">+        &quot;\u2208  \u2209  \u220a  \u220b  \u220c  \u220d  \u220e  \u220f&quot;],</span>
<a href="#l26.436"></a><span id="l26.436" class="difflineplus">+      [&quot;=?utf-8?Q?=E2=88=80__=E2=88=81__=E2=88=82__=E2=88=83__=E2=88=84__=E2&quot; +</span>
<a href="#l26.437"></a><span id="l26.437" class="difflineplus">+        &quot;?=\n =?utf-8?Q?=88=85__=E2=88=86__=E2=88=87__=E2=88=88__=E2=88=89__&quot; +</span>
<a href="#l26.438"></a><span id="l26.438" class="difflineplus">+        &quot;=E2=88?=\n =?utf-8?Q?=8A__=E2=88=8B__=E2=88=8C__=E2=88=8D__=E2=88=8&quot; +</span>
<a href="#l26.439"></a><span id="l26.439" class="difflineplus">+        &quot;E__=E2=88=8F?=&quot;,</span>
<a href="#l26.440"></a><span id="l26.440" class="difflineplus">+        &quot;\u2200  \u2201  \u2202  \u2203  \u2204  \u2205  \u2206  \u2207  &quot; +</span>
<a href="#l26.441"></a><span id="l26.441" class="difflineplus">+        &quot;\u2208  \u2209  \u220a  \u220b  \u220c  \u220d  \u220e  \u220f&quot;],</span>
<a href="#l26.442"></a><span id="l26.442" class="difflineplus">+      [&quot;=?UTF-8?B?4oiAICDiiIEgIOKIgiAg4oiDICDiiIQgIOKIhSAg4oiGICDiiIcgIOKIiA&quot; +</span>
<a href="#l26.443"></a><span id="l26.443" class="difflineplus">+        &quot;==?=\n =?UTF-8?B?ICDiiIkgIOKIiiAg4oiLICDiiIwgIOKIjSAg4oiOICDiiI8=?=&quot;,</span>
<a href="#l26.444"></a><span id="l26.444" class="difflineplus">+        &quot;\u2200  \u2201  \u2202  \u2203  \u2204  \u2205  \u2206  \u2207  &quot; +</span>
<a href="#l26.445"></a><span id="l26.445" class="difflineplus">+        &quot;\u2208  \u2209  \u220a  \u220b  \u220c  \u220d  \u220e  \u220f&quot;],</span>
<a href="#l26.446"></a><span id="l26.446" class="difflineplus">+      [&quot;=?UTF-8?b?4oiAICDiiIEgIOKIgiAg4oiDICDiiIQgIOKIhSAg4oiGICDiiIcgIOKIiA&quot; +</span>
<a href="#l26.447"></a><span id="l26.447" class="difflineplus">+        &quot;==?=\n =?UTF-8?b?ICDiiIkgIOKIiiAg4oiLICDiiIwgIOKIjSAg4oiOICDiiI8=?=&quot;,</span>
<a href="#l26.448"></a><span id="l26.448" class="difflineplus">+        &quot;\u2200  \u2201  \u2202  \u2203  \u2204  \u2205  \u2206  \u2207  &quot; +</span>
<a href="#l26.449"></a><span id="l26.449" class="difflineplus">+        &quot;\u2208  \u2209  \u220a  \u220b  \u220c  \u220d  \u220e  \u220f&quot;],</span>
<a href="#l26.450"></a><span id="l26.450" class="difflineplus">+      [&quot;=?utf-8?Q?=E2=88=80__=E2=88=81__=E2=88=82__=E2=88=83__=E2=88=84__?=\n&quot; +</span>
<a href="#l26.451"></a><span id="l26.451" class="difflineplus">+       &quot; =?utf-8?Q?=E2=88=85__=E2=88=86__=E2=88=87__=E2=88=88__=E2=88=89__?=\n&quot;+</span>
<a href="#l26.452"></a><span id="l26.452" class="difflineplus">+       &quot; =?utf-8?Q?=E2=88=8A__=E2=88=8B__=E2=88=8C__=E2=88=8D__=E2=88=8E__?=\n&quot;+</span>
<a href="#l26.453"></a><span id="l26.453" class="difflineplus">+       &quot; =?utf-8?Q?=E2=88=8F?=&quot;,</span>
<a href="#l26.454"></a><span id="l26.454" class="difflineplus">+        &quot;\u2200  \u2201  \u2202  \u2203  \u2204  \u2205  \u2206  \u2207  &quot; +</span>
<a href="#l26.455"></a><span id="l26.455" class="difflineplus">+        &quot;\u2208  \u2209  \u220a  \u220b  \u220c  \u220d  \u220e  \u220f&quot;],</span>
<a href="#l26.456"></a><span id="l26.456" class="difflineplus">+      [&quot;=?utf-8?q?=E2=88=80__=E2=88=81__=E2=88=82__=E2=88=83__=E2=88=84__?=\n&quot; +</span>
<a href="#l26.457"></a><span id="l26.457" class="difflineplus">+       &quot; =?utf-8?q?=E2=88=85__=E2=88=86__=E2=88=87__=E2=88=88__=E2=88=89__?=\n&quot;+</span>
<a href="#l26.458"></a><span id="l26.458" class="difflineplus">+       &quot; =?utf-8?q?=E2=88=8A__=E2=88=8B__=E2=88=8C__=E2=88=8D__=E2=88=8E__?=\n&quot;+</span>
<a href="#l26.459"></a><span id="l26.459" class="difflineplus">+       &quot; =?utf-8?q?=E2=88=8F?=&quot;,</span>
<a href="#l26.460"></a><span id="l26.460" class="difflineplus">+        &quot;\u2200  \u2201  \u2202  \u2203  \u2204  \u2205  \u2206  \u2207  &quot; +</span>
<a href="#l26.461"></a><span id="l26.461" class="difflineplus">+        &quot;\u2208  \u2209  \u220a  \u220b  \u220c  \u220d  \u220e  \u220f&quot;],</span>
<a href="#l26.462"></a><span id="l26.462" class="difflineplus">+      [&quot;=?UTF-8?B?4oiAICDiiIEgIOKIgiAg4oiDICDiiIQgIOKIhSAg4oiGICDiiIcgIOKIiA=&quot; +</span>
<a href="#l26.463"></a><span id="l26.463" class="difflineplus">+        &quot;==?=\n =?UTF-8?B?ICDiiIkgIOKIiiAg4oiLICDiiIwgIOKIjSAg4oiOICDiiI8=?=&quot;,</span>
<a href="#l26.464"></a><span id="l26.464" class="difflineplus">+        &quot;\u2200  \u2201  \u2202  \u2203  \u2204  \u2205  \u2206  \u2207  &quot; +</span>
<a href="#l26.465"></a><span id="l26.465" class="difflineplus">+        &quot;\u2208  \u2209  \u220a  \u220b  \u220c  \u220d  \u220e  \u220f&quot;],</span>
<a href="#l26.466"></a><span id="l26.466" class="difflineplus">+</span>
<a href="#l26.467"></a><span id="l26.467" class="difflineplus">+      // Some interesting headers found in the wild:</span>
<a href="#l26.468"></a><span id="l26.468" class="difflineplus">+      // Invalid base64 text. We decide not to decode this word.</span>
<a href="#l26.469"></a><span id="l26.469" class="difflineplus">+      [&quot;Re: [Kitchen Nightmares] Meow! Gordon Ramsay Is =?ISO-8859-1?B?UEgR l&quot; +</span>
<a href="#l26.470"></a><span id="l26.470" class="difflineplus">+        &quot;qZ VuIEhlYWQgVH rbGeOIFNob BJc RP2JzZXNzZW?= With My =?ISO-8859-1?B?&quot; +</span>
<a href="#l26.471"></a><span id="l26.471" class="difflineplus">+        &quot;SHVzYmFuZ JzX0JhbGxzL JfU2F5c19BbXiScw==?= Baking Company Owner&quot;,</span>
<a href="#l26.472"></a><span id="l26.472" class="difflineplus">+        &quot;Re: [Kitchen Nightmares] Meow! Gordon Ramsay Is =?ISO-8859-1?B?UEgR &quot; +</span>
<a href="#l26.473"></a><span id="l26.473" class="difflineplus">+        &quot;lqZ VuIEhlYWQgVH rbGeOIFNob BJc RP2JzZXNzZW?= With My =?ISO-8859-1?B&quot; +</span>
<a href="#l26.474"></a><span id="l26.474" class="difflineplus">+        &quot;?SHVzYmFuZ JzX0JhbGxzL JfU2F5c19BbXiScw==?= Baking Company Owner&quot;],</span>
<a href="#l26.475"></a><span id="l26.475" class="difflineplus">+      [&quot;=?us-ascii?Q?=09Edward_Rosten?=&quot;, &quot;\tEdward Rosten&quot;],</span>
<a href="#l26.476"></a><span id="l26.476" class="difflineplus">+      [&quot;=?us-ascii?Q?=3D=3FUTF-8=3FQ=3Ff=3DC3=3DBCr=3F=3D?=&quot;,</span>
<a href="#l26.477"></a><span id="l26.477" class="difflineplus">+        &quot;=?UTF-8?Q?f=C3=BCr?=&quot;],</span>
<a href="#l26.478"></a><span id="l26.478" class="difflineplus">+      // We don't decode unrecognized charsets (This one is actually UTF-8).</span>
<a href="#l26.479"></a><span id="l26.479" class="difflineplus">+      [&quot;=??B?Sy4gSC4gdm9uIFLDvGRlbg==?=&quot;, &quot;=??B?Sy4gSC4gdm9uIFLDvGRlbg==?=&quot;],</span>
<a href="#l26.480"></a><span id="l26.480" class="difflineplus">+    ];</span>
<a href="#l26.481"></a><span id="l26.481" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l26.482"></a><span id="l26.482" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l26.483"></a><span id="l26.483" class="difflineplus">+        assert.deepEqual(headerparser.decodeRFC2047Words(data[0]), data[1]);</span>
<a href="#l26.484"></a><span id="l26.484" class="difflineplus">+      });</span>
<a href="#l26.485"></a><span id="l26.485" class="difflineplus">+    });</span>
<a href="#l26.486"></a><span id="l26.486" class="difflineplus">+  });</span>
<a href="#l26.487"></a><span id="l26.487" class="difflineplus">+  suite('8-bit header processing', function () {</span>
<a href="#l26.488"></a><span id="l26.488" class="difflineplus">+    let header_tests = [</span>
<a href="#l26.489"></a><span id="l26.489" class="difflineplus">+      // Non-ASCII header values</span>
<a href="#l26.490"></a><span id="l26.490" class="difflineplus">+      [&quot;oxyg\xc3\xa8ne&quot;, &quot;oxyg\u00e8ne&quot;, &quot;UTF-8&quot;],</span>
<a href="#l26.491"></a><span id="l26.491" class="difflineplus">+      [&quot;oxyg\xc3\xa8ne&quot;, &quot;oxyg\u00e8ne&quot;, &quot;ISO-8859-1&quot;], // UTF-8 overrides</span>
<a href="#l26.492"></a><span id="l26.492" class="difflineplus">+      [&quot;oxyg\xc3\xa8ne&quot;, &quot;oxyg\u00e8ne&quot;], // default to UTF-8 if no charset</span>
<a href="#l26.493"></a><span id="l26.493" class="difflineplus">+      [&quot;oxyg\xe8ne&quot;, &quot;oxyg\ufffdne&quot;, &quot;UTF-8&quot;],</span>
<a href="#l26.494"></a><span id="l26.494" class="difflineplus">+      [&quot;oxyg\xe8ne&quot;, &quot;oxyg\u00e8ne&quot;, &quot;ISO-8859-1&quot;],</span>
<a href="#l26.495"></a><span id="l26.495" class="difflineplus">+      [&quot;\xc3\xa8\xe8&quot;, &quot;\u00e8\ufffd&quot;, &quot;UTF-8&quot;],</span>
<a href="#l26.496"></a><span id="l26.496" class="difflineplus">+      [&quot;\xc3\xa8\xe8&quot;, &quot;\u00c3\u00a8\u00e8&quot;, &quot;ISO-8859-1&quot;],</span>
<a href="#l26.497"></a><span id="l26.497" class="difflineplus">+</span>
<a href="#l26.498"></a><span id="l26.498" class="difflineplus">+      // Don't fallback to UTF-16 or UTF-32</span>
<a href="#l26.499"></a><span id="l26.499" class="difflineplus">+      [&quot;\xe8S!0&quot;, &quot;\ufffdS!0&quot;, &quot;UTF-16&quot;],</span>
<a href="#l26.500"></a><span id="l26.500" class="difflineplus">+      [&quot;\xe8S!0&quot;, &quot;\ufffdS!0&quot;, &quot;UTF-16be&quot;],</span>
<a href="#l26.501"></a><span id="l26.501" class="difflineplus">+      [&quot;\xe8S!0&quot;, &quot;\ufffdS!0&quot;, &quot;UTF-32&quot;],</span>
<a href="#l26.502"></a><span id="l26.502" class="difflineplus">+      [&quot;\xe8S!0&quot;, &quot;\ufffdS!0&quot;, &quot;utf-32&quot;],</span>
<a href="#l26.503"></a><span id="l26.503" class="difflineplus">+</span>
<a href="#l26.504"></a><span id="l26.504" class="difflineplus">+      // Don't combine encoded-word and header charset decoding</span>
<a href="#l26.505"></a><span id="l26.505" class="difflineplus">+      [&quot;=?UTF-8?Q?=c3?= \xa8&quot;, &quot;\ufffd \ufffd&quot;, &quot;UTF-8&quot;],</span>
<a href="#l26.506"></a><span id="l26.506" class="difflineplus">+      [&quot;=?UTF-8?Q?=c3?= \xa8&quot;, &quot;\ufffd \u00a8&quot;, &quot;ISO-8859-1&quot;],</span>
<a href="#l26.507"></a><span id="l26.507" class="difflineplus">+      [&quot;\xc3 =?UTF-8?Q?=a8?=&quot;, &quot;\ufffd \ufffd&quot;, &quot;UTF-8&quot;],</span>
<a href="#l26.508"></a><span id="l26.508" class="difflineplus">+      [&quot;\xc3 =?UTF-8?Q?=a8?=&quot;, &quot;\u00c3 \ufffd&quot;, &quot;ISO-8859-1&quot;],</span>
<a href="#l26.509"></a><span id="l26.509" class="difflineplus">+    ];</span>
<a href="#l26.510"></a><span id="l26.510" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l26.511"></a><span id="l26.511" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l26.512"></a><span id="l26.512" class="difflineplus">+        assert.deepEqual(headerparser.decodeRFC2047Words(</span>
<a href="#l26.513"></a><span id="l26.513" class="difflineplus">+          headerparser.convert8BitHeader(data[0], data[2])), data[1]);</span>
<a href="#l26.514"></a><span id="l26.514" class="difflineplus">+      });</span>
<a href="#l26.515"></a><span id="l26.515" class="difflineplus">+    });</span>
<a href="#l26.516"></a><span id="l26.516" class="difflineplus">+  });</span>
<a href="#l26.517"></a><span id="l26.517" class="difflineplus">+});</span>
<a href="#l26.518"></a><span id="l26.518" class="difflineplus">+</span>
<a href="#l26.519"></a><span id="l26.519" class="difflineplus">+});</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1">new file mode 100644</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineminus">--- /dev/null</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/test_header_emitter.js</span>
<a href="#l27.4"></a><span id="l27.4" class="difflineat">@@ -0,0 +1,228 @@</span>
<a href="#l27.5"></a><span id="l27.5" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l27.6"></a><span id="l27.6" class="difflineplus">+define(function(require) {</span>
<a href="#l27.7"></a><span id="l27.7" class="difflineplus">+</span>
<a href="#l27.8"></a><span id="l27.8" class="difflineplus">+var assert = require('assert');</span>
<a href="#l27.9"></a><span id="l27.9" class="difflineplus">+var headeremitter = require('jsmime').headeremitter;</span>
<a href="#l27.10"></a><span id="l27.10" class="difflineplus">+</span>
<a href="#l27.11"></a><span id="l27.11" class="difflineplus">+function arrayTest(data, fn) {</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineplus">+  fn.toString = function () {</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+    let text = Function.prototype.toString.call(this);</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+    text = text.replace(/data\[([0-9]*)\]/g, function (m, p) {</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+      return JSON.stringify(data[p]);</span>
<a href="#l27.16"></a><span id="l27.16" class="difflineplus">+    });</span>
<a href="#l27.17"></a><span id="l27.17" class="difflineplus">+    return text;</span>
<a href="#l27.18"></a><span id="l27.18" class="difflineplus">+  };</span>
<a href="#l27.19"></a><span id="l27.19" class="difflineplus">+  return test(JSON.stringify(data[0]), fn);</span>
<a href="#l27.20"></a><span id="l27.20" class="difflineplus">+}</span>
<a href="#l27.21"></a><span id="l27.21" class="difflineplus">+</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineplus">+suite('headeremitter', function () {</span>
<a href="#l27.23"></a><span id="l27.23" class="difflineplus">+  suite('addAddresses', function () {</span>
<a href="#l27.24"></a><span id="l27.24" class="difflineplus">+    let handler = {</span>
<a href="#l27.25"></a><span id="l27.25" class="difflineplus">+      reset: function (expected) {</span>
<a href="#l27.26"></a><span id="l27.26" class="difflineplus">+        this.output = '';</span>
<a href="#l27.27"></a><span id="l27.27" class="difflineplus">+        this.expected = expected;</span>
<a href="#l27.28"></a><span id="l27.28" class="difflineplus">+      },</span>
<a href="#l27.29"></a><span id="l27.29" class="difflineplus">+      deliverData: function (data) { this.output += data; },</span>
<a href="#l27.30"></a><span id="l27.30" class="difflineplus">+      deliverEOF: function () {</span>
<a href="#l27.31"></a><span id="l27.31" class="difflineplus">+        assert.equal(this.output, this.expected + '\r\n');</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineplus">+        for (let line of this.output.split('\r\n'))</span>
<a href="#l27.33"></a><span id="l27.33" class="difflineplus">+          assert.ok(line.length &lt;= 30, &quot;Line is too long&quot;);</span>
<a href="#l27.34"></a><span id="l27.34" class="difflineplus">+      }</span>
<a href="#l27.35"></a><span id="l27.35" class="difflineplus">+    };</span>
<a href="#l27.36"></a><span id="l27.36" class="difflineplus">+    let header_tests = [</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineplus">+      [[{name: &quot;&quot;, email: &quot;&quot;}], &quot;&quot;],</span>
<a href="#l27.38"></a><span id="l27.38" class="difflineplus">+      [[{name: &quot;&quot;, email: &quot;a@example.com&quot;}], &quot;a@example.com&quot;],</span>
<a href="#l27.39"></a><span id="l27.39" class="difflineplus">+      [[{name: &quot;John Doe&quot;, email: &quot;a@example.com&quot;}], &quot;John Doe &lt;a@example.com&gt;&quot;],</span>
<a href="#l27.40"></a><span id="l27.40" class="difflineplus">+      [[{name: &quot;&quot;, email: &quot;a@b.c&quot;}, {name: &quot;&quot;, email: &quot;b@b.c&quot;}], &quot;a@b.c, b@b.c&quot;],</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineplus">+      [[{name: &quot;JD&quot;, email: &quot;a@a.c&quot;}, {name: &quot;SD&quot;, email: &quot;b@b.c&quot;}],</span>
<a href="#l27.42"></a><span id="l27.42" class="difflineplus">+        &quot;JD &lt;a@a.c&gt;, SD &lt;b@b.c&gt;&quot;],</span>
<a href="#l27.43"></a><span id="l27.43" class="difflineplus">+      [[{name: &quot;John Doe&quot;, email: &quot;a@example.com&quot;},</span>
<a href="#l27.44"></a><span id="l27.44" class="difflineplus">+        {name: &quot;Sally Doe&quot;, email: &quot;b@example.com&quot;}],</span>
<a href="#l27.45"></a><span id="l27.45" class="difflineplus">+        &quot;John Doe &lt;a@example.com&gt;,\r\n Sally Doe &lt;b@example.com&gt;&quot;],</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineplus">+      [[{name: &quot;My name is really long and I split somewhere&quot;, email: &quot;a@a.c&quot;}],</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+        &quot;My name is really long and I\r\n split somewhere &lt;a@a.c&gt;&quot;],</span>
<a href="#l27.48"></a><span id="l27.48" class="difflineplus">+      // Note that the name is 29 chars here, so adding the email needs a break.</span>
<a href="#l27.49"></a><span id="l27.49" class="difflineplus">+      [[{name: &quot;My name is really really long&quot;, email: &quot;a@a.c&quot;}],</span>
<a href="#l27.50"></a><span id="l27.50" class="difflineplus">+        &quot;My name is really really long\r\n &lt;a@a.c&gt;&quot;],</span>
<a href="#l27.51"></a><span id="l27.51" class="difflineplus">+      [[{name: &quot;&quot;, email: &quot;a@a.c&quot;}, {name: &quot;This name is long&quot;, email: &quot;b@b.c&quot;}],</span>
<a href="#l27.52"></a><span id="l27.52" class="difflineplus">+        &quot;a@a.c,\r\n This name is long &lt;b@b.c&gt;&quot;],</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineplus">+      [[{name: &quot;&quot;, email: &quot;a@a.c&quot;}, {name: &quot;This name is also long&quot;, email: &quot;b@b.c&quot;}],</span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+        &quot;a@a.c,\r\n This name is also long\r\n &lt;b@b.c&gt;&quot;],</span>
<a href="#l27.55"></a><span id="l27.55" class="difflineplus">+      [[{name: &quot;&quot;, email: &quot;hi!bad@all.com&quot;}], &quot;\&quot;hi!bad\&quot;@all.com&quot;],</span>
<a href="#l27.56"></a><span id="l27.56" class="difflineplus">+      [[{name: &quot;&quot;, email: &quot;\&quot;hi!bad\&quot;@all.com&quot;}], &quot;\&quot;hi!bad\&quot;@all.com&quot;],</span>
<a href="#l27.57"></a><span id="l27.57" class="difflineplus">+      [[{name: &quot;Doe, John&quot;, email: &quot;a@a.com&quot;}], &quot;\&quot;Doe, John\&quot; &lt;a@a.com&gt;&quot;],</span>
<a href="#l27.58"></a><span id="l27.58" class="difflineplus">+      // This one violates the line length, so it underquotes instead.</span>
<a href="#l27.59"></a><span id="l27.59" class="difflineplus">+      [[{name: &quot;A really, really long name to quote&quot;, email: &quot;a@example.com&quot;}],</span>
<a href="#l27.60"></a><span id="l27.60" class="difflineplus">+        &quot;A \&quot;really,\&quot; really long name\r\n to quote &lt;a@example.com&gt;&quot;],</span>
<a href="#l27.61"></a><span id="l27.61" class="difflineplus">+      [[{name: &quot;Group&quot;, group: [{name: &quot;&quot;, email: &quot;a@a.c&quot;},</span>
<a href="#l27.62"></a><span id="l27.62" class="difflineplus">+                                {name: &quot;&quot;, email: &quot;b@b.c&quot;}]}],</span>
<a href="#l27.63"></a><span id="l27.63" class="difflineplus">+        &quot;Group: a@a.c, b@b.c;&quot;],</span>
<a href="#l27.64"></a><span id="l27.64" class="difflineplus">+    ];</span>
<a href="#l27.65"></a><span id="l27.65" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l27.66"></a><span id="l27.66" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l27.67"></a><span id="l27.67" class="difflineplus">+        let emitter = headeremitter.makeStreamingEmitter(handler, {</span>
<a href="#l27.68"></a><span id="l27.68" class="difflineplus">+          softMargin: 30,</span>
<a href="#l27.69"></a><span id="l27.69" class="difflineplus">+          useASCII: false,</span>
<a href="#l27.70"></a><span id="l27.70" class="difflineplus">+        });</span>
<a href="#l27.71"></a><span id="l27.71" class="difflineplus">+        handler.reset(data[1]);</span>
<a href="#l27.72"></a><span id="l27.72" class="difflineplus">+        emitter.addAddresses(data[0]);</span>
<a href="#l27.73"></a><span id="l27.73" class="difflineplus">+        emitter.finish(true);</span>
<a href="#l27.74"></a><span id="l27.74" class="difflineplus">+      });</span>
<a href="#l27.75"></a><span id="l27.75" class="difflineplus">+    });</span>
<a href="#l27.76"></a><span id="l27.76" class="difflineplus">+  });</span>
<a href="#l27.77"></a><span id="l27.77" class="difflineplus">+  suite('addAddresses (RFC 2047)', function () {</span>
<a href="#l27.78"></a><span id="l27.78" class="difflineplus">+    let handler = {</span>
<a href="#l27.79"></a><span id="l27.79" class="difflineplus">+      reset: function (expected) {</span>
<a href="#l27.80"></a><span id="l27.80" class="difflineplus">+        this.output = '';</span>
<a href="#l27.81"></a><span id="l27.81" class="difflineplus">+        this.expected = expected;</span>
<a href="#l27.82"></a><span id="l27.82" class="difflineplus">+      },</span>
<a href="#l27.83"></a><span id="l27.83" class="difflineplus">+      deliverData: function (data) { this.output += data; },</span>
<a href="#l27.84"></a><span id="l27.84" class="difflineplus">+      deliverEOF: function () {</span>
<a href="#l27.85"></a><span id="l27.85" class="difflineplus">+        assert.equal(this.output, this.expected + '\r\n');</span>
<a href="#l27.86"></a><span id="l27.86" class="difflineplus">+        for (let line of this.output.split('\r\n'))</span>
<a href="#l27.87"></a><span id="l27.87" class="difflineplus">+          assert.ok(line.length &lt;= 30, &quot;Line is too long&quot;);</span>
<a href="#l27.88"></a><span id="l27.88" class="difflineplus">+      }</span>
<a href="#l27.89"></a><span id="l27.89" class="difflineplus">+    }</span>
<a href="#l27.90"></a><span id="l27.90" class="difflineplus">+    let header_tests = [</span>
<a href="#l27.91"></a><span id="l27.91" class="difflineplus">+      [[{name: &quot;\u0436&quot;, email: &quot;a@a.c&quot;}], &quot;=?UTF-8?B?0LY=?= &lt;a@a.c&gt;&quot;],</span>
<a href="#l27.92"></a><span id="l27.92" class="difflineplus">+      [[{name: &quot;dioxyg\u00e8ne&quot;, email: &quot;a@a.c&quot;}],</span>
<a href="#l27.93"></a><span id="l27.93" class="difflineplus">+        &quot;=?UTF-8?Q?dioxyg=c3=a8ne?=\r\n &lt;a@a.c&gt;&quot;],</span>
<a href="#l27.94"></a><span id="l27.94" class="difflineplus">+      // Prefer QP if base64 and QP are exactly the same length</span>
<a href="#l27.95"></a><span id="l27.95" class="difflineplus">+      [[{name: &quot;oxyg\u00e8ne&quot;, email: &quot;a@a.c&quot;}],</span>
<a href="#l27.96"></a><span id="l27.96" class="difflineplus">+      // =?UTF-8?B?b3h5Z8OobmU=?=</span>
<a href="#l27.97"></a><span id="l27.97" class="difflineplus">+        &quot;=?UTF-8?Q?oxyg=c3=a8ne?=\r\n &lt;a@a.c&gt;&quot;],</span>
<a href="#l27.98"></a><span id="l27.98" class="difflineplus">+      [[{name: &quot;\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9&quot;,</span>
<a href="#l27.99"></a><span id="l27.99" class="difflineplus">+        email: &quot;a@a.c&quot;}],</span>
<a href="#l27.100"></a><span id="l27.100" class="difflineplus">+        &quot;=?UTF-8?B?8J+SqfCfkqnwn5Kp?=\r\n =?UTF-8?B?8J+SqQ==?= &lt;a@a.c&gt;&quot;],</span>
<a href="#l27.101"></a><span id="l27.101" class="difflineplus">+    ];</span>
<a href="#l27.102"></a><span id="l27.102" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l27.103"></a><span id="l27.103" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l27.104"></a><span id="l27.104" class="difflineplus">+        let emitter = headeremitter.makeStreamingEmitter(handler, {</span>
<a href="#l27.105"></a><span id="l27.105" class="difflineplus">+          softMargin: 30,</span>
<a href="#l27.106"></a><span id="l27.106" class="difflineplus">+          useASCII: true</span>
<a href="#l27.107"></a><span id="l27.107" class="difflineplus">+        });</span>
<a href="#l27.108"></a><span id="l27.108" class="difflineplus">+        handler.reset(data[1]);</span>
<a href="#l27.109"></a><span id="l27.109" class="difflineplus">+        emitter.addAddresses(data[0]);</span>
<a href="#l27.110"></a><span id="l27.110" class="difflineplus">+        emitter.finish(true);</span>
<a href="#l27.111"></a><span id="l27.111" class="difflineplus">+      });</span>
<a href="#l27.112"></a><span id="l27.112" class="difflineplus">+    });</span>
<a href="#l27.113"></a><span id="l27.113" class="difflineplus">+  });</span>
<a href="#l27.114"></a><span id="l27.114" class="difflineplus">+  suite('addUnstructured (RFC 2047)', function () {</span>
<a href="#l27.115"></a><span id="l27.115" class="difflineplus">+    let handler = {</span>
<a href="#l27.116"></a><span id="l27.116" class="difflineplus">+      reset: function (expected) {</span>
<a href="#l27.117"></a><span id="l27.117" class="difflineplus">+        this.output = '';</span>
<a href="#l27.118"></a><span id="l27.118" class="difflineplus">+        this.expected = expected;</span>
<a href="#l27.119"></a><span id="l27.119" class="difflineplus">+      },</span>
<a href="#l27.120"></a><span id="l27.120" class="difflineplus">+      deliverData: function (data) { this.output += data; },</span>
<a href="#l27.121"></a><span id="l27.121" class="difflineplus">+      deliverEOF: function () {</span>
<a href="#l27.122"></a><span id="l27.122" class="difflineplus">+        assert.equal(this.output, this.expected + '\r\n');</span>
<a href="#l27.123"></a><span id="l27.123" class="difflineplus">+        for (let line of this.output.split('\r\n'))</span>
<a href="#l27.124"></a><span id="l27.124" class="difflineplus">+          assert.ok(line.length &lt;= 30, &quot;Line is too long&quot;);</span>
<a href="#l27.125"></a><span id="l27.125" class="difflineplus">+      }</span>
<a href="#l27.126"></a><span id="l27.126" class="difflineplus">+    }</span>
<a href="#l27.127"></a><span id="l27.127" class="difflineplus">+    let header_tests = [</span>
<a href="#l27.128"></a><span id="l27.128" class="difflineplus">+      [&quot;My house   burned down!&quot;, &quot;My house burned down!&quot;],</span>
<a href="#l27.129"></a><span id="l27.129" class="difflineplus">+</span>
<a href="#l27.130"></a><span id="l27.130" class="difflineplus">+      // Which variables need to be encoded in QP encoding?</span>
<a href="#l27.131"></a><span id="l27.131" class="difflineplus">+      [&quot;! \&quot; # $ % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` { | } ~ \x7f&quot;,</span>
<a href="#l27.132"></a><span id="l27.132" class="difflineplus">+        &quot;=?UTF-8?Q?!_=22_#_$_%_&amp;_'_?=\r\n&quot; +</span>
<a href="#l27.133"></a><span id="l27.133" class="difflineplus">+        &quot; =?UTF-8?Q?=28_=29_*_+_,_-_.?=\r\n&quot; +</span>
<a href="#l27.134"></a><span id="l27.134" class="difflineplus">+        &quot; =?UTF-8?Q?_/_:_;_&lt;_=3d_&gt;_?=\r\n&quot; +</span>
<a href="#l27.135"></a><span id="l27.135" class="difflineplus">+        &quot; =?UTF-8?Q?=3f_@_[_\\_]_^_=5f?=\r\n&quot; +</span>
<a href="#l27.136"></a><span id="l27.136" class="difflineplus">+        &quot; =?UTF-8?Q?_`_{_|_}_~_=7f?=&quot;],</span>
<a href="#l27.137"></a><span id="l27.137" class="difflineplus">+      // But non-printable characters don't need it in the first place!</span>
<a href="#l27.138"></a><span id="l27.138" class="difflineplus">+      [&quot;! \&quot; # $ % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` { | } ~&quot;,</span>
<a href="#l27.139"></a><span id="l27.139" class="difflineplus">+        &quot;! \&quot; # $ % &amp; ' ( ) * + , - . /\r\n&quot; +</span>
<a href="#l27.140"></a><span id="l27.140" class="difflineplus">+        &quot; : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` { |\r\n&quot; +</span>
<a href="#l27.141"></a><span id="l27.141" class="difflineplus">+        &quot; } ~&quot;],</span>
<a href="#l27.142"></a><span id="l27.142" class="difflineplus">+</span>
<a href="#l27.143"></a><span id="l27.143" class="difflineplus">+      // Test to make sure 2047-encoding chooses the right values.</span>
<a href="#l27.144"></a><span id="l27.144" class="difflineplus">+      [&quot;\u001f&quot;, &quot;=?UTF-8?Q?=1f?=&quot;],</span>
<a href="#l27.145"></a><span id="l27.145" class="difflineplus">+      [&quot;\u001fa&quot;, &quot;=?UTF-8?Q?=1fa?=&quot;],</span>
<a href="#l27.146"></a><span id="l27.146" class="difflineplus">+      [&quot;\u001faa&quot;, &quot;=?UTF-8?B?H2Fh?=&quot;],</span>
<a href="#l27.147"></a><span id="l27.147" class="difflineplus">+      [&quot;\u001faaa&quot;, &quot;=?UTF-8?Q?=1faaa?=&quot;],</span>
<a href="#l27.148"></a><span id="l27.148" class="difflineplus">+      [&quot;\u001faaa\u001f&quot;, &quot;=?UTF-8?B?H2FhYR8=?=&quot;],</span>
<a href="#l27.149"></a><span id="l27.149" class="difflineplus">+      [&quot;\u001faaa\u001fa&quot;, &quot;=?UTF-8?B?H2FhYR9h?=&quot;],</span>
<a href="#l27.150"></a><span id="l27.150" class="difflineplus">+      [&quot;\u001faaa\u001faa&quot;, &quot;=?UTF-8?Q?=1faaa=1faa?=&quot;],</span>
<a href="#l27.151"></a><span id="l27.151" class="difflineplus">+      [&quot;\u001faaa\u001faa\u001faaaa&quot;, &quot;=?UTF-8?B?H2FhYR9hYR9hYWFh?=&quot;],</span>
<a href="#l27.152"></a><span id="l27.152" class="difflineplus">+</span>
<a href="#l27.153"></a><span id="l27.153" class="difflineplus">+      // Make sure line breaking works right at the edge cases</span>
<a href="#l27.154"></a><span id="l27.154" class="difflineplus">+      [&quot;\u001faaa\u001faaaaaaaaa&quot;, &quot;=?UTF-8?Q?=1faaa=1faaaaaaaaa?=&quot;],</span>
<a href="#l27.155"></a><span id="l27.155" class="difflineplus">+      [&quot;\u001faaa\u001faaaaaaaaaa&quot;,</span>
<a href="#l27.156"></a><span id="l27.156" class="difflineplus">+        &quot;=?UTF-8?Q?=1faaa=1faaaaaaaaa?=\r\n =?UTF-8?Q?a?=&quot;],</span>
<a href="#l27.157"></a><span id="l27.157" class="difflineplus">+</span>
<a href="#l27.158"></a><span id="l27.158" class="difflineplus">+      // Choose base64/qp independently for each word</span>
<a href="#l27.159"></a><span id="l27.159" class="difflineplus">+      [&quot;\ud83d\udca9\ud83d\udca9\ud83d\udca9a&quot;,</span>
<a href="#l27.160"></a><span id="l27.160" class="difflineplus">+        &quot;=?UTF-8?B?8J+SqfCfkqnwn5Kp?=\r\n =?UTF-8?Q?a?=&quot;],</span>
<a href="#l27.161"></a><span id="l27.161" class="difflineplus">+</span>
<a href="#l27.162"></a><span id="l27.162" class="difflineplus">+      // Don't split a surrogate character!</span>
<a href="#l27.163"></a><span id="l27.163" class="difflineplus">+      [&quot;a\ud83d\udca9\ud83d\udca9\ud83d\udca9a&quot;,</span>
<a href="#l27.164"></a><span id="l27.164" class="difflineplus">+        &quot;=?UTF-8?B?YfCfkqnwn5Kp?=\r\n =?UTF-8?B?8J+SqWE=?=&quot;],</span>
<a href="#l27.165"></a><span id="l27.165" class="difflineplus">+</span>
<a href="#l27.166"></a><span id="l27.166" class="difflineplus">+      // Spacing a UTF-8 string</span>
<a href="#l27.167"></a><span id="l27.167" class="difflineplus">+      [&quot;L'oxyg\u00e8ne est un \u00e9l\u00e9ment chimique du groupe des &quot; +</span>
<a href="#l27.168"></a><span id="l27.168" class="difflineplus">+        &quot;chalcog\u00e8nes&quot;,</span>
<a href="#l27.169"></a><span id="l27.169" class="difflineplus">+      //          1         2         3</span>
<a href="#l27.170"></a><span id="l27.170" class="difflineplus">+      // 123456789012345678901234567890</span>
<a href="#l27.171"></a><span id="l27.171" class="difflineplus">+        &quot;=?UTF-8?Q?L'oxyg=c3=a8ne_est?=\r\n&quot; +</span>
<a href="#l27.172"></a><span id="l27.172" class="difflineplus">+        &quot; =?UTF-8?B?IHVuIMOpbMOpbWVu?=\r\n&quot; +</span>
<a href="#l27.173"></a><span id="l27.173" class="difflineplus">+        &quot; =?UTF-8?Q?t_chimique_du_gro?=\r\n&quot; +</span>
<a href="#l27.174"></a><span id="l27.174" class="difflineplus">+        &quot; =?UTF-8?Q?upe_des_chalcog?=\r\n&quot; +</span>
<a href="#l27.175"></a><span id="l27.175" class="difflineplus">+        &quot; =?UTF-8?B?w6huZXM=?=&quot;],</span>
<a href="#l27.176"></a><span id="l27.176" class="difflineplus">+    ];</span>
<a href="#l27.177"></a><span id="l27.177" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l27.178"></a><span id="l27.178" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l27.179"></a><span id="l27.179" class="difflineplus">+        let emitter = headeremitter.makeStreamingEmitter(handler, {</span>
<a href="#l27.180"></a><span id="l27.180" class="difflineplus">+          softMargin: 30,</span>
<a href="#l27.181"></a><span id="l27.181" class="difflineplus">+          useASCII: true</span>
<a href="#l27.182"></a><span id="l27.182" class="difflineplus">+        });</span>
<a href="#l27.183"></a><span id="l27.183" class="difflineplus">+        handler.reset(data[1]);</span>
<a href="#l27.184"></a><span id="l27.184" class="difflineplus">+        emitter.addUnstructured(data[0]);</span>
<a href="#l27.185"></a><span id="l27.185" class="difflineplus">+        emitter.finish(true);</span>
<a href="#l27.186"></a><span id="l27.186" class="difflineplus">+      });</span>
<a href="#l27.187"></a><span id="l27.187" class="difflineplus">+    });</span>
<a href="#l27.188"></a><span id="l27.188" class="difflineplus">+  });</span>
<a href="#l27.189"></a><span id="l27.189" class="difflineplus">+</span>
<a href="#l27.190"></a><span id="l27.190" class="difflineplus">+  suite(&quot;Header lengths&quot;, function () {</span>
<a href="#l27.191"></a><span id="l27.191" class="difflineplus">+    let handler = {</span>
<a href="#l27.192"></a><span id="l27.192" class="difflineplus">+      reset: function (expected) {</span>
<a href="#l27.193"></a><span id="l27.193" class="difflineplus">+        this.output = '';</span>
<a href="#l27.194"></a><span id="l27.194" class="difflineplus">+        this.expected = expected;</span>
<a href="#l27.195"></a><span id="l27.195" class="difflineplus">+      },</span>
<a href="#l27.196"></a><span id="l27.196" class="difflineplus">+      deliverData: function (data) { this.output += data; },</span>
<a href="#l27.197"></a><span id="l27.197" class="difflineplus">+      deliverEOF: function () {</span>
<a href="#l27.198"></a><span id="l27.198" class="difflineplus">+        assert.equal(this.output, this.expected + '\r\n');</span>
<a href="#l27.199"></a><span id="l27.199" class="difflineplus">+      }</span>
<a href="#l27.200"></a><span id="l27.200" class="difflineplus">+    };</span>
<a href="#l27.201"></a><span id="l27.201" class="difflineplus">+    let header_tests = [</span>
<a href="#l27.202"></a><span id="l27.202" class="difflineplus">+      [[{name: &quot;Supercalifragilisticexpialidocious&quot;, email: &quot;a@b.c&quot;}],</span>
<a href="#l27.203"></a><span id="l27.203" class="difflineplus">+        'Supercalifragilisticexpialidocious\r\n &lt;a@b.c&gt;'],</span>
<a href="#l27.204"></a><span id="l27.204" class="difflineplus">+      [[{email: &quot;supercalifragilisticexpialidocious@&quot; +</span>
<a href="#l27.205"></a><span id="l27.205" class="difflineplus">+          &quot;the.longest.domain.name.in.the.world.invalid&quot;}],</span>
<a href="#l27.206"></a><span id="l27.206" class="difflineplus">+        'supercalifragilisticexpialidocious\r\n' +</span>
<a href="#l27.207"></a><span id="l27.207" class="difflineplus">+        ' @the.longest.domain.name.in.the.world.invalid'],</span>
<a href="#l27.208"></a><span id="l27.208" class="difflineplus">+      [[{name: &quot;Lopadotemachoselachogaleokranioleipsanodrimhypotrimmatosilphi&quot; +</span>
<a href="#l27.209"></a><span id="l27.209" class="difflineplus">+        &quot;paraomelitokatakechymenokichlepikossyphophattoperisteralektryonoptek&quot; +</span>
<a href="#l27.210"></a><span id="l27.210" class="difflineplus">+        &quot;ephalliokigklopeleiolagoiosiraiobaphetraganopterygon&quot;, email: &quot;a@b.c&quot;}],</span>
<a href="#l27.211"></a><span id="l27.211" class="difflineplus">+        new Error],</span>
<a href="#l27.212"></a><span id="l27.212" class="difflineplus">+    ];</span>
<a href="#l27.213"></a><span id="l27.213" class="difflineplus">+    header_tests.forEach(function (data) {</span>
<a href="#l27.214"></a><span id="l27.214" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l27.215"></a><span id="l27.215" class="difflineplus">+        let emitter = headeremitter.makeStreamingEmitter(handler, {</span>
<a href="#l27.216"></a><span id="l27.216" class="difflineplus">+          softMargin: 30,</span>
<a href="#l27.217"></a><span id="l27.217" class="difflineplus">+          hardMargin: 50,</span>
<a href="#l27.218"></a><span id="l27.218" class="difflineplus">+          useASCII: false,</span>
<a href="#l27.219"></a><span id="l27.219" class="difflineplus">+        });</span>
<a href="#l27.220"></a><span id="l27.220" class="difflineplus">+        handler.reset(data[1]);</span>
<a href="#l27.221"></a><span id="l27.221" class="difflineplus">+        if (data[1] instanceof Error)</span>
<a href="#l27.222"></a><span id="l27.222" class="difflineplus">+          assert.throws(function () { emitter.addAddresses(data[0]); });</span>
<a href="#l27.223"></a><span id="l27.223" class="difflineplus">+        else {</span>
<a href="#l27.224"></a><span id="l27.224" class="difflineplus">+          assert.doesNotThrow(function () { emitter.addAddresses(data[0]); });</span>
<a href="#l27.225"></a><span id="l27.225" class="difflineplus">+          emitter.finish(true);</span>
<a href="#l27.226"></a><span id="l27.226" class="difflineplus">+        }</span>
<a href="#l27.227"></a><span id="l27.227" class="difflineplus">+      });</span>
<a href="#l27.228"></a><span id="l27.228" class="difflineplus">+    });</span>
<a href="#l27.229"></a><span id="l27.229" class="difflineplus">+  });</span>
<a href="#l27.230"></a><span id="l27.230" class="difflineplus">+});</span>
<a href="#l27.231"></a><span id="l27.231" class="difflineplus">+</span>
<a href="#l27.232"></a><span id="l27.232" class="difflineplus">+});</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1">new file mode 100644</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineminus">--- /dev/null</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/test_mime_tree.js</span>
<a href="#l28.4"></a><span id="l28.4" class="difflineat">@@ -0,0 +1,610 @@</span>
<a href="#l28.5"></a><span id="l28.5" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l28.6"></a><span id="l28.6" class="difflineplus">+define(function(require) {</span>
<a href="#l28.7"></a><span id="l28.7" class="difflineplus">+</span>
<a href="#l28.8"></a><span id="l28.8" class="difflineplus">+var assert = require('assert');</span>
<a href="#l28.9"></a><span id="l28.9" class="difflineplus">+var jsmime = require('jsmime');</span>
<a href="#l28.10"></a><span id="l28.10" class="difflineplus">+var fs = require('fs');</span>
<a href="#l28.11"></a><span id="l28.11" class="difflineplus">+</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineplus">+function arrayTest(data, fn) {</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+  fn.toString = function () {</span>
<a href="#l28.14"></a><span id="l28.14" class="difflineplus">+    let text = Function.prototype.toString.call(this);</span>
<a href="#l28.15"></a><span id="l28.15" class="difflineplus">+    text = text.replace(/data\[([0-9]*)\]/g, function (m, p) {</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineplus">+      return JSON.stringify(data[p]);</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineplus">+    });</span>
<a href="#l28.18"></a><span id="l28.18" class="difflineplus">+    return text;</span>
<a href="#l28.19"></a><span id="l28.19" class="difflineplus">+  };</span>
<a href="#l28.20"></a><span id="l28.20" class="difflineplus">+  return test(data[0], fn);</span>
<a href="#l28.21"></a><span id="l28.21" class="difflineplus">+}</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineplus">+</span>
<a href="#l28.23"></a><span id="l28.23" class="difflineplus">+/// Returns and deletes object[field] if present, or undefined if not.</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineplus">+function extract_field(object, field) {</span>
<a href="#l28.25"></a><span id="l28.25" class="difflineplus">+  if (field in object) {</span>
<a href="#l28.26"></a><span id="l28.26" class="difflineplus">+    var result = object[field];</span>
<a href="#l28.27"></a><span id="l28.27" class="difflineplus">+    delete object[field];</span>
<a href="#l28.28"></a><span id="l28.28" class="difflineplus">+    return result;</span>
<a href="#l28.29"></a><span id="l28.29" class="difflineplus">+  }</span>
<a href="#l28.30"></a><span id="l28.30" class="difflineplus">+  return undefined;</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineplus">+}</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+</span>
<a href="#l28.33"></a><span id="l28.33" class="difflineplus">+/// A file cache for read_file.</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineplus">+var file_cache = {};</span>
<a href="#l28.35"></a><span id="l28.35" class="difflineplus">+</span>
<a href="#l28.36"></a><span id="l28.36" class="difflineplus">+/**</span>
<a href="#l28.37"></a><span id="l28.37" class="difflineplus">+ * Read a file into a string (all line endings become CRLF).</span>
<a href="#l28.38"></a><span id="l28.38" class="difflineplus">+ * @param file  The name of the file to read, relative to the data/ directory.</span>
<a href="#l28.39"></a><span id="l28.39" class="difflineplus">+ * @param start The first line of the file to return, defaulting to 0</span>
<a href="#l28.40"></a><span id="l28.40" class="difflineplus">+ * @param end   The last line of the file to return, defaulting to the number of</span>
<a href="#l28.41"></a><span id="l28.41" class="difflineplus">+ *              lines in the file.</span>
<a href="#l28.42"></a><span id="l28.42" class="difflineplus">+ * @return      Promise&lt;String&gt; The contents of the file as a binary string.</span>
<a href="#l28.43"></a><span id="l28.43" class="difflineplus">+ */</span>
<a href="#l28.44"></a><span id="l28.44" class="difflineplus">+function read_file(file, start, end) {</span>
<a href="#l28.45"></a><span id="l28.45" class="difflineplus">+  if (!(file in file_cache)) {</span>
<a href="#l28.46"></a><span id="l28.46" class="difflineplus">+    var realFile = new Promise(function (resolve, reject) {</span>
<a href="#l28.47"></a><span id="l28.47" class="difflineplus">+      fs.readFile(&quot;data/&quot; + file, function (err, data) {</span>
<a href="#l28.48"></a><span id="l28.48" class="difflineplus">+        if (err) reject(err);</span>
<a href="#l28.49"></a><span id="l28.49" class="difflineplus">+        else resolve(data);</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineplus">+      });</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineplus">+    });</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+    var loader = realFile.then(function (contents) {</span>
<a href="#l28.53"></a><span id="l28.53" class="difflineplus">+      var inStrForm = '';</span>
<a href="#l28.54"></a><span id="l28.54" class="difflineplus">+      while (contents.length &gt; 0) {</span>
<a href="#l28.55"></a><span id="l28.55" class="difflineplus">+        inStrForm += String.fromCharCode.apply(null,</span>
<a href="#l28.56"></a><span id="l28.56" class="difflineplus">+          contents.subarray(0, 1024));</span>
<a href="#l28.57"></a><span id="l28.57" class="difflineplus">+        contents = contents.subarray(1024);</span>
<a href="#l28.58"></a><span id="l28.58" class="difflineplus">+      }</span>
<a href="#l28.59"></a><span id="l28.59" class="difflineplus">+      return inStrForm.split(/\r\n|[\r\n]/);</span>
<a href="#l28.60"></a><span id="l28.60" class="difflineplus">+    });</span>
<a href="#l28.61"></a><span id="l28.61" class="difflineplus">+    file_cache[file] = loader;</span>
<a href="#l28.62"></a><span id="l28.62" class="difflineplus">+  }</span>
<a href="#l28.63"></a><span id="l28.63" class="difflineplus">+  return file_cache[file].then(function (contents) {</span>
<a href="#l28.64"></a><span id="l28.64" class="difflineplus">+    if (start !== undefined) {</span>
<a href="#l28.65"></a><span id="l28.65" class="difflineplus">+      contents = contents.slice(start - 1, end - 1);</span>
<a href="#l28.66"></a><span id="l28.66" class="difflineplus">+    }</span>
<a href="#l28.67"></a><span id="l28.67" class="difflineplus">+    return contents.join('\r\n');</span>
<a href="#l28.68"></a><span id="l28.68" class="difflineplus">+  });</span>
<a href="#l28.69"></a><span id="l28.69" class="difflineplus">+}</span>
<a href="#l28.70"></a><span id="l28.70" class="difflineplus">+</span>
<a href="#l28.71"></a><span id="l28.71" class="difflineplus">+/**</span>
<a href="#l28.72"></a><span id="l28.72" class="difflineplus">+ * Helper for body tests.</span>
<a href="#l28.73"></a><span id="l28.73" class="difflineplus">+ *</span>
<a href="#l28.74"></a><span id="l28.74" class="difflineplus">+ * Some extra options are listed too:</span>
<a href="#l28.75"></a><span id="l28.75" class="difflineplus">+ * _split: The contents of the file will be passed in packets split by this</span>
<a href="#l28.76"></a><span id="l28.76" class="difflineplus">+ *         regex. Be sure to include the split delimiter in a group so that they</span>
<a href="#l28.77"></a><span id="l28.77" class="difflineplus">+ *         are included in the output packets!</span>
<a href="#l28.78"></a><span id="l28.78" class="difflineplus">+ * _eol: The CRLFs in the input file will be replaced with the given line</span>
<a href="#l28.79"></a><span id="l28.79" class="difflineplus">+ *       ending instead.</span>
<a href="#l28.80"></a><span id="l28.80" class="difflineplus">+ * @param test     The name of test</span>
<a href="#l28.81"></a><span id="l28.81" class="difflineplus">+ * @param file     The name of the file to read (relative to mailnews/data)</span>
<a href="#l28.82"></a><span id="l28.82" class="difflineplus">+ * @param opts     Options for the mime parser, as well as a few extras detailed</span>
<a href="#l28.83"></a><span id="l28.83" class="difflineplus">+ *                 above.</span>
<a href="#l28.84"></a><span id="l28.84" class="difflineplus">+ * @param partspec An array of [partnum, line start, line end] detailing the</span>
<a href="#l28.85"></a><span id="l28.85" class="difflineplus">+ *                 expected parts in the body. It will be expected that the</span>
<a href="#l28.86"></a><span id="l28.86" class="difflineplus">+ *                 accumulated body part data for partnum would be the contents</span>
<a href="#l28.87"></a><span id="l28.87" class="difflineplus">+ *                 of the file from [line start, line end) [1-based lines]</span>
<a href="#l28.88"></a><span id="l28.88" class="difflineplus">+ */</span>
<a href="#l28.89"></a><span id="l28.89" class="difflineplus">+function make_body_test(test, file, opts, partspec) {</span>
<a href="#l28.90"></a><span id="l28.90" class="difflineplus">+  var results = Promise.all([</span>
<a href="#l28.91"></a><span id="l28.91" class="difflineplus">+    Promise.all([p[0], read_file(file, p[1], p[2])]) for (p of partspec)]);</span>
<a href="#l28.92"></a><span id="l28.92" class="difflineplus">+  var eol = extract_field(opts, &quot;_eol&quot;);</span>
<a href="#l28.93"></a><span id="l28.93" class="difflineplus">+  var msgtext = read_file(file).then(function(msgcontents) {</span>
<a href="#l28.94"></a><span id="l28.94" class="difflineplus">+    var packetize = extract_field(opts, &quot;_split&quot;);</span>
<a href="#l28.95"></a><span id="l28.95" class="difflineplus">+    if (packetize !== undefined)</span>
<a href="#l28.96"></a><span id="l28.96" class="difflineplus">+      msgcontents = msgcontents.split(packetize);</span>
<a href="#l28.97"></a><span id="l28.97" class="difflineplus">+    if (eol !== undefined) {</span>
<a href="#l28.98"></a><span id="l28.98" class="difflineplus">+      msgcontents = msgcontents.replace(/\r\n/g, eol);</span>
<a href="#l28.99"></a><span id="l28.99" class="difflineplus">+    }</span>
<a href="#l28.100"></a><span id="l28.100" class="difflineplus">+    return msgcontents;</span>
<a href="#l28.101"></a><span id="l28.101" class="difflineplus">+  });</span>
<a href="#l28.102"></a><span id="l28.102" class="difflineplus">+  if (eol !== undefined) {</span>
<a href="#l28.103"></a><span id="l28.103" class="difflineplus">+    results = results.then(function(results) {</span>
<a href="#l28.104"></a><span id="l28.104" class="difflineplus">+      for (var part of results) {</span>
<a href="#l28.105"></a><span id="l28.105" class="difflineplus">+        part[1] = part[1].replace(/\r\n/g, eol);</span>
<a href="#l28.106"></a><span id="l28.106" class="difflineplus">+      }</span>
<a href="#l28.107"></a><span id="l28.107" class="difflineplus">+      return results;</span>
<a href="#l28.108"></a><span id="l28.108" class="difflineplus">+    });</span>
<a href="#l28.109"></a><span id="l28.109" class="difflineplus">+  }</span>
<a href="#l28.110"></a><span id="l28.110" class="difflineplus">+  return [test, msgtext, opts, results];</span>
<a href="#l28.111"></a><span id="l28.111" class="difflineplus">+}</span>
<a href="#l28.112"></a><span id="l28.112" class="difflineplus">+</span>
<a href="#l28.113"></a><span id="l28.113" class="difflineplus">+/**</span>
<a href="#l28.114"></a><span id="l28.114" class="difflineplus">+ * Execute a single MIME tree test.</span>
<a href="#l28.115"></a><span id="l28.115" class="difflineplus">+ *</span>
<a href="#l28.116"></a><span id="l28.116" class="difflineplus">+ * @param message  Either the text of the message, an array of textual message</span>
<a href="#l28.117"></a><span id="l28.117" class="difflineplus">+ *                 part data (imagine coming on different TCP packets), or a</span>
<a href="#l28.118"></a><span id="l28.118" class="difflineplus">+ *                 promise that resolves to any of the above.</span>
<a href="#l28.119"></a><span id="l28.119" class="difflineplus">+ * @param opts     A set of options for the parser and for the test.</span>
<a href="#l28.120"></a><span id="l28.120" class="difflineplus">+ * @param results  The expected results of the call. This may either be a</span>
<a href="#l28.121"></a><span id="l28.121" class="difflineplus">+ *                 dictionary of part number -&gt; header -&gt; values (to check</span>
<a href="#l28.122"></a><span id="l28.122" class="difflineplus">+ *                 headers), or an array of [partnum, partdata] for expected</span>
<a href="#l28.123"></a><span id="l28.123" class="difflineplus">+ *                 results to deliverPartData, or a promise for the above.</span>
<a href="#l28.124"></a><span id="l28.124" class="difflineplus">+ * @return         A promise containing the results of the test.</span>
<a href="#l28.125"></a><span id="l28.125" class="difflineplus">+ */</span>
<a href="#l28.126"></a><span id="l28.126" class="difflineplus">+function testParser(message, opts, results) {</span>
<a href="#l28.127"></a><span id="l28.127" class="difflineplus">+  var uncheckedValues;</span>
<a href="#l28.128"></a><span id="l28.128" class="difflineplus">+  var checkingHeaders;</span>
<a href="#l28.129"></a><span id="l28.129" class="difflineplus">+  var calls = 0;</span>
<a href="#l28.130"></a><span id="l28.130" class="difflineplus">+  var fusingParts = extract_field(opts, &quot;_nofuseparts&quot;) === undefined;</span>
<a href="#l28.131"></a><span id="l28.131" class="difflineplus">+  var emitter = {</span>
<a href="#l28.132"></a><span id="l28.132" class="difflineplus">+    stack: [],</span>
<a href="#l28.133"></a><span id="l28.133" class="difflineplus">+    startMessage: function emitter_startMsg() {</span>
<a href="#l28.134"></a><span id="l28.134" class="difflineplus">+      assert.equal(this.stack.length, 0);</span>
<a href="#l28.135"></a><span id="l28.135" class="difflineplus">+      calls++;</span>
<a href="#l28.136"></a><span id="l28.136" class="difflineplus">+      this.partData = '';</span>
<a href="#l28.137"></a><span id="l28.137" class="difflineplus">+    },</span>
<a href="#l28.138"></a><span id="l28.138" class="difflineplus">+    endMessage: function emitter_endMsg() {</span>
<a href="#l28.139"></a><span id="l28.139" class="difflineplus">+      assert.equal(this.stack.length, 0);</span>
<a href="#l28.140"></a><span id="l28.140" class="difflineplus">+      calls++;</span>
<a href="#l28.141"></a><span id="l28.141" class="difflineplus">+    },</span>
<a href="#l28.142"></a><span id="l28.142" class="difflineplus">+    startPart: function emitter_startPart(partNum, headers) {</span>
<a href="#l28.143"></a><span id="l28.143" class="difflineplus">+      this.stack.push(partNum);</span>
<a href="#l28.144"></a><span id="l28.144" class="difflineplus">+      if (checkingHeaders) {</span>
<a href="#l28.145"></a><span id="l28.145" class="difflineplus">+        assert.ok(partNum in uncheckedValues);</span>
<a href="#l28.146"></a><span id="l28.146" class="difflineplus">+        // Headers is a map, convert it to an object.</span>
<a href="#l28.147"></a><span id="l28.147" class="difflineplus">+        var objmap = new Object();</span>
<a href="#l28.148"></a><span id="l28.148" class="difflineplus">+        for (let pair of headers)</span>
<a href="#l28.149"></a><span id="l28.149" class="difflineplus">+          objmap[pair[0]] = pair[1];</span>
<a href="#l28.150"></a><span id="l28.150" class="difflineplus">+        var expected = uncheckedValues[partNum];</span>
<a href="#l28.151"></a><span id="l28.151" class="difflineplus">+        var convresults = new Object();</span>
<a href="#l28.152"></a><span id="l28.152" class="difflineplus">+        for (let key in expected) {</span>
<a href="#l28.153"></a><span id="l28.153" class="difflineplus">+          try {</span>
<a href="#l28.154"></a><span id="l28.154" class="difflineplus">+            convresults[key] =</span>
<a href="#l28.155"></a><span id="l28.155" class="difflineplus">+              jsmime.headerparser.parseStructuredHeader(key, expected[key]);</span>
<a href="#l28.156"></a><span id="l28.156" class="difflineplus">+          } catch (e) {</span>
<a href="#l28.157"></a><span id="l28.157" class="difflineplus">+            convresults[key] = expected[key];</span>
<a href="#l28.158"></a><span id="l28.158" class="difflineplus">+          }</span>
<a href="#l28.159"></a><span id="l28.159" class="difflineplus">+        }</span>
<a href="#l28.160"></a><span id="l28.160" class="difflineplus">+        assert.deepEqual(objmap, convresults);</span>
<a href="#l28.161"></a><span id="l28.161" class="difflineplus">+        if (fusingParts)</span>
<a href="#l28.162"></a><span id="l28.162" class="difflineplus">+          assert.equal(this.partData, '');</span>
<a href="#l28.163"></a><span id="l28.163" class="difflineplus">+        delete uncheckedValues[partNum];</span>
<a href="#l28.164"></a><span id="l28.164" class="difflineplus">+      }</span>
<a href="#l28.165"></a><span id="l28.165" class="difflineplus">+    },</span>
<a href="#l28.166"></a><span id="l28.166" class="difflineplus">+    deliverPartData: function emitter_partData(partNum, data) {</span>
<a href="#l28.167"></a><span id="l28.167" class="difflineplus">+      assert.equal(this.stack[this.stack.length - 1], partNum);</span>
<a href="#l28.168"></a><span id="l28.168" class="difflineplus">+      if (!checkingHeaders) {</span>
<a href="#l28.169"></a><span id="l28.169" class="difflineplus">+        if (fusingParts)</span>
<a href="#l28.170"></a><span id="l28.170" class="difflineplus">+          this.partData += data;</span>
<a href="#l28.171"></a><span id="l28.171" class="difflineplus">+        else {</span>
<a href="#l28.172"></a><span id="l28.172" class="difflineplus">+          let check = uncheckedValues.shift();</span>
<a href="#l28.173"></a><span id="l28.173" class="difflineplus">+          assert.equal(partNum, check[0]);</span>
<a href="#l28.174"></a><span id="l28.174" class="difflineplus">+          assert.equal(data, check[1]);</span>
<a href="#l28.175"></a><span id="l28.175" class="difflineplus">+        }</span>
<a href="#l28.176"></a><span id="l28.176" class="difflineplus">+      }</span>
<a href="#l28.177"></a><span id="l28.177" class="difflineplus">+    },</span>
<a href="#l28.178"></a><span id="l28.178" class="difflineplus">+    endPart: function emitter_endPart(partNum) {</span>
<a href="#l28.179"></a><span id="l28.179" class="difflineplus">+      if (this.partData != '') {</span>
<a href="#l28.180"></a><span id="l28.180" class="difflineplus">+        let check = uncheckedValues.shift();</span>
<a href="#l28.181"></a><span id="l28.181" class="difflineplus">+        assert.equal(partNum, check[0]);</span>
<a href="#l28.182"></a><span id="l28.182" class="difflineplus">+        assert.equal(this.partData, check[1]);</span>
<a href="#l28.183"></a><span id="l28.183" class="difflineplus">+        this.partData = '';</span>
<a href="#l28.184"></a><span id="l28.184" class="difflineplus">+      }</span>
<a href="#l28.185"></a><span id="l28.185" class="difflineplus">+      assert.equal(this.stack.pop(), partNum);</span>
<a href="#l28.186"></a><span id="l28.186" class="difflineplus">+    }</span>
<a href="#l28.187"></a><span id="l28.187" class="difflineplus">+  };</span>
<a href="#l28.188"></a><span id="l28.188" class="difflineplus">+  opts.onerror = function (e) { throw e; };</span>
<a href="#l28.189"></a><span id="l28.189" class="difflineplus">+</span>
<a href="#l28.190"></a><span id="l28.190" class="difflineplus">+  return Promise.all([message, results]).then(function (vals) {</span>
<a href="#l28.191"></a><span id="l28.191" class="difflineplus">+    let [message, results] = vals;</span>
<a href="#l28.192"></a><span id="l28.192" class="difflineplus">+    // Clone the results array into uncheckedValues</span>
<a href="#l28.193"></a><span id="l28.193" class="difflineplus">+    if (Array.isArray(results)) {</span>
<a href="#l28.194"></a><span id="l28.194" class="difflineplus">+      uncheckedValues = [for (val of results) val];</span>
<a href="#l28.195"></a><span id="l28.195" class="difflineplus">+      checkingHeaders = false;</span>
<a href="#l28.196"></a><span id="l28.196" class="difflineplus">+    } else {</span>
<a href="#l28.197"></a><span id="l28.197" class="difflineplus">+      uncheckedValues = {};</span>
<a href="#l28.198"></a><span id="l28.198" class="difflineplus">+      for (let key in results) {</span>
<a href="#l28.199"></a><span id="l28.199" class="difflineplus">+        uncheckedValues[key] = results[key];</span>
<a href="#l28.200"></a><span id="l28.200" class="difflineplus">+      }</span>
<a href="#l28.201"></a><span id="l28.201" class="difflineplus">+      checkingHeaders = true;</span>
<a href="#l28.202"></a><span id="l28.202" class="difflineplus">+    }</span>
<a href="#l28.203"></a><span id="l28.203" class="difflineplus">+    if (!Array.isArray(message))</span>
<a href="#l28.204"></a><span id="l28.204" class="difflineplus">+      message = [message];</span>
<a href="#l28.205"></a><span id="l28.205" class="difflineplus">+    var parser = new jsmime.MimeParser(emitter, opts);</span>
<a href="#l28.206"></a><span id="l28.206" class="difflineplus">+    message.forEach(function (packet) {</span>
<a href="#l28.207"></a><span id="l28.207" class="difflineplus">+      parser.deliverData(packet);</span>
<a href="#l28.208"></a><span id="l28.208" class="difflineplus">+    });</span>
<a href="#l28.209"></a><span id="l28.209" class="difflineplus">+    parser.deliverEOF();</span>
<a href="#l28.210"></a><span id="l28.210" class="difflineplus">+    assert.equal(calls, 2);</span>
<a href="#l28.211"></a><span id="l28.211" class="difflineplus">+    if (!checkingHeaders)</span>
<a href="#l28.212"></a><span id="l28.212" class="difflineplus">+      assert.equal(0, uncheckedValues.length);</span>
<a href="#l28.213"></a><span id="l28.213" class="difflineplus">+    else</span>
<a href="#l28.214"></a><span id="l28.214" class="difflineplus">+      assert.deepEqual({}, uncheckedValues);</span>
<a href="#l28.215"></a><span id="l28.215" class="difflineplus">+  });</span>
<a href="#l28.216"></a><span id="l28.216" class="difflineplus">+}</span>
<a href="#l28.217"></a><span id="l28.217" class="difflineplus">+</span>
<a href="#l28.218"></a><span id="l28.218" class="difflineplus">+suite('MimeParser', function () {</span>
<a href="#l28.219"></a><span id="l28.219" class="difflineplus">+  /// This is the expected part specifier for the multipart-complex1 test file,</span>
<a href="#l28.220"></a><span id="l28.220" class="difflineplus">+  /// specified here because it is used in several cases.</span>
<a href="#l28.221"></a><span id="l28.221" class="difflineplus">+  let mpart_complex1 = [['1', 8, 10], ['2', 14, 16], ['3.1', 22, 24],</span>
<a href="#l28.222"></a><span id="l28.222" class="difflineplus">+      ['4', 29, 31], ['5', 33, 35]];</span>
<a href="#l28.223"></a><span id="l28.223" class="difflineplus">+</span>
<a href="#l28.224"></a><span id="l28.224" class="difflineplus">+  suite('Simple tests', function () {</span>
<a href="#l28.225"></a><span id="l28.225" class="difflineplus">+    let parser_tests = [</span>
<a href="#l28.226"></a><span id="l28.226" class="difflineplus">+      // The following tests are either degenerate or error cases that should</span>
<a href="#l28.227"></a><span id="l28.227" class="difflineplus">+      // work</span>
<a href="#l28.228"></a><span id="l28.228" class="difflineplus">+      [&quot;Empty string&quot;, &quot;&quot;, {}, {'': {}}],</span>
<a href="#l28.229"></a><span id="l28.229" class="difflineplus">+      [&quot;No value for header&quot;, &quot;Header&quot;, {}, {'': {&quot;Header&quot;: ['']}}],</span>
<a href="#l28.230"></a><span id="l28.230" class="difflineplus">+      [&quot;No trailing newline&quot;, &quot;To: eof@example.net&quot;, {},</span>
<a href="#l28.231"></a><span id="l28.231" class="difflineplus">+        {'': {&quot;To&quot;: [&quot;eof@example.net&quot;]}}],</span>
<a href="#l28.232"></a><span id="l28.232" class="difflineplus">+      [&quot;Header no val&quot;, &quot;To: eof@example.net\r\n&quot;, {},</span>
<a href="#l28.233"></a><span id="l28.233" class="difflineplus">+        {'': {&quot;To&quot;: [&quot;eof@example.net&quot;]}}],</span>
<a href="#l28.234"></a><span id="l28.234" class="difflineplus">+      [&quot;No body no headers&quot;, &quot;\r\n\r\n&quot;, {}, {'': {}}],</span>
<a href="#l28.235"></a><span id="l28.235" class="difflineplus">+      [&quot;Body no headers&quot;, &quot;\r\n\r\nA&quot;, {}, {'': {}}],</span>
<a href="#l28.236"></a><span id="l28.236" class="difflineplus">+      // Basic cases for headers</span>
<a href="#l28.237"></a><span id="l28.237" class="difflineplus">+      ['Multiparts get headers', read_file(&quot;multipart-complex1&quot;), {},</span>
<a href="#l28.238"></a><span id="l28.238" class="difflineplus">+        { '': {'Content-Type': ['multipart/mixed; boundary=&quot;boundary&quot;']},</span>
<a href="#l28.239"></a><span id="l28.239" class="difflineplus">+          '1': {'Content-Type': ['application/octet-stream'],</span>
<a href="#l28.240"></a><span id="l28.240" class="difflineplus">+                'Content-Transfer-Encoding': ['base64']},</span>
<a href="#l28.241"></a><span id="l28.241" class="difflineplus">+          '2': {'Content-Type': ['image/png'],</span>
<a href="#l28.242"></a><span id="l28.242" class="difflineplus">+                'Content-Transfer-Encoding': ['base64']},</span>
<a href="#l28.243"></a><span id="l28.243" class="difflineplus">+          '3': {'Content-Type': ['multipart/related; boundary=&quot;boundary2&quot;']},</span>
<a href="#l28.244"></a><span id="l28.244" class="difflineplus">+          '3.1': {'Content-Type': ['text/html']},</span>
<a href="#l28.245"></a><span id="l28.245" class="difflineplus">+          '4': {'Content-Type': ['text/plain']}, '5': {} }],</span>
<a href="#l28.246"></a><span id="l28.246" class="difflineplus">+    ];</span>
<a href="#l28.247"></a><span id="l28.247" class="difflineplus">+    parser_tests.forEach(function (data) {</span>
<a href="#l28.248"></a><span id="l28.248" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l28.249"></a><span id="l28.249" class="difflineplus">+        return testParser(data[1], data[2], data[3]);</span>
<a href="#l28.250"></a><span id="l28.250" class="difflineplus">+      });</span>
<a href="#l28.251"></a><span id="l28.251" class="difflineplus">+    });</span>
<a href="#l28.252"></a><span id="l28.252" class="difflineplus">+  });</span>
<a href="#l28.253"></a><span id="l28.253" class="difflineplus">+</span>
<a href="#l28.254"></a><span id="l28.254" class="difflineplus">+  suite('Body tests', function () {</span>
<a href="#l28.255"></a><span id="l28.255" class="difflineplus">+    let parser_tests = [</span>
<a href="#l28.256"></a><span id="l28.256" class="difflineplus">+      // Body tests from data</span>
<a href="#l28.257"></a><span id="l28.257" class="difflineplus">+      // (Note: line numbers are 1-based. Also, to capture trailing EOF, add 2</span>
<a href="#l28.258"></a><span id="l28.258" class="difflineplus">+      // to the last line number of the file).</span>
<a href="#l28.259"></a><span id="l28.259" class="difflineplus">+      make_body_test(&quot;Basic body&quot;, &quot;basic1&quot;, {}, [['', 3, 5]]),</span>
<a href="#l28.260"></a><span id="l28.260" class="difflineplus">+      make_body_test(&quot;Basic multipart&quot;, &quot;multipart1&quot;, {}, [['1', 10, 12]]),</span>
<a href="#l28.261"></a><span id="l28.261" class="difflineplus">+      make_body_test(&quot;Basic multipart&quot;, &quot;multipart2&quot;, {}, [['1', 8, 11]]),</span>
<a href="#l28.262"></a><span id="l28.262" class="difflineplus">+      make_body_test(&quot;Complex multipart&quot;, &quot;multipart-complex1&quot;, {},</span>
<a href="#l28.263"></a><span id="l28.263" class="difflineplus">+        mpart_complex1),</span>
<a href="#l28.264"></a><span id="l28.264" class="difflineplus">+      make_body_test(&quot;Truncated multipart&quot;, &quot;multipart-complex2&quot;, {},</span>
<a href="#l28.265"></a><span id="l28.265" class="difflineplus">+        [['1.1.1.1', 21, 25], ['2', 27, 57], ['3', 60, 62]]),</span>
<a href="#l28.266"></a><span id="l28.266" class="difflineplus">+      make_body_test(&quot;No LF multipart&quot;, &quot;multipartmalt-detach&quot;, {},</span>
<a href="#l28.267"></a><span id="l28.267" class="difflineplus">+        [['1', 20, 21], ['2.1', 27, 38], ['2.2', 42, 43], ['2.3', 47, 48],</span>
<a href="#l28.268"></a><span id="l28.268" class="difflineplus">+         ['3', 53, 54]]),</span>
<a href="#l28.269"></a><span id="l28.269" class="difflineplus">+      make_body_test(&quot;Raw body&quot;, &quot;multipart1&quot;, {bodyformat: &quot;raw&quot;},</span>
<a href="#l28.270"></a><span id="l28.270" class="difflineplus">+        [['', 4, 14]]),</span>
<a href="#l28.271"></a><span id="l28.271" class="difflineplus">+      [&quot;Base64 decode 1&quot;, read_file(&quot;base64-1&quot;), {bodyformat: &quot;decode&quot;},</span>
<a href="#l28.272"></a><span id="l28.272" class="difflineplus">+        [['', &quot;\r\nHello, world! (Again...)\r\n\r\nLet's see how well base64 &quot; +</span>
<a href="#l28.273"></a><span id="l28.273" class="difflineplus">+              &quot;text is handled.                            Yay, lots of space&quot; +</span>
<a href="#l28.274"></a><span id="l28.274" class="difflineplus">+              &quot;s! There's even a CRLF at the end and one at the beginning, bu&quot; +</span>
<a href="#l28.275"></a><span id="l28.275" class="difflineplus">+              &quot;t the output shouldn't have it.\r\n&quot;]]],</span>
<a href="#l28.276"></a><span id="l28.276" class="difflineplus">+      [&quot;Base64 decode 2&quot;, read_file(&quot;base64-2&quot;), {bodyformat: &quot;decode&quot;},</span>
<a href="#l28.277"></a><span id="l28.277" class="difflineplus">+        [['', &quot;&lt;html&gt;&lt;body&gt;This is base64 encoded HTML text, and the tags sho&quot; +</span>
<a href="#l28.278"></a><span id="l28.278" class="difflineplus">+              &quot;uldn't be stripped.\r\n&lt;b&gt;Bold text is bold!&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;&quot; +</span>
<a href="#l28.279"></a><span id="l28.279" class="difflineplus">+              &quot;\r\n&quot;]]],</span>
<a href="#l28.280"></a><span id="l28.280" class="difflineplus">+      [&quot;Base64 decode line issues&quot;,</span>
<a href="#l28.281"></a><span id="l28.281" class="difflineplus">+        read_file(&quot;base64-2&quot;).then(function (s) { return s.split(/(\r\n)/) }),</span>
<a href="#l28.282"></a><span id="l28.282" class="difflineplus">+        {bodyformat: &quot;decode&quot;},</span>
<a href="#l28.283"></a><span id="l28.283" class="difflineplus">+        [['', &quot;&lt;html&gt;&lt;body&gt;This is base64 encoded HTML text, and the tags sho&quot; +</span>
<a href="#l28.284"></a><span id="l28.284" class="difflineplus">+              &quot;uldn't be stripped.\r\n&lt;b&gt;Bold text is bold!&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;&quot; +</span>
<a href="#l28.285"></a><span id="l28.285" class="difflineplus">+              &quot;\r\n&quot;]]],</span>
<a href="#l28.286"></a><span id="l28.286" class="difflineplus">+      make_body_test(&quot;Base64 nodecode&quot;, &quot;base64-1&quot;, {}, [['', 4, 9]]),</span>
<a href="#l28.287"></a><span id="l28.287" class="difflineplus">+      [&quot;QP decode&quot;, read_file(&quot;bug505221&quot;),</span>
<a href="#l28.288"></a><span id="l28.288" class="difflineplus">+        {pruneat: '1', bodyformat: &quot;decode&quot;},</span>
<a href="#l28.289"></a><span id="l28.289" class="difflineplus">+        [['1', '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;' +</span>
<a href="#l28.290"></a><span id="l28.290" class="difflineplus">+               '&gt;\r\n&lt;HTML&gt;&lt;HEAD&gt;\r\n&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=' +</span>
<a href="#l28.291"></a><span id="l28.291" class="difflineplus">+               '&quot;text/html; charset=us-ascii&quot;&gt;\r\n\r\n\r\n&lt;META content=&quot;MSHT' +</span>
<a href="#l28.292"></a><span id="l28.292" class="difflineplus">+               'ML 6.00.6000.16735&quot; name=GENERATOR&gt;&lt;/HEAD&gt;\r\n&lt;BODY&gt; bbb\r\n&lt;' +</span>
<a href="#l28.293"></a><span id="l28.293" class="difflineplus">+               '/BODY&gt;&lt;/HTML&gt;']]],</span>
<a href="#l28.294"></a><span id="l28.294" class="difflineplus">+      [&quot;Nested messages&quot;, read_file(&quot;message-encoded&quot;), {bodyformat: &quot;decode&quot;},</span>
<a href="#l28.295"></a><span id="l28.295" class="difflineplus">+        [['1$', 'This is a plain-text message.'],</span>
<a href="#l28.296"></a><span id="l28.296" class="difflineplus">+         ['2$', 'I am a plain-text message.'],</span>
<a href="#l28.297"></a><span id="l28.297" class="difflineplus">+         ['3$', 'I am an encoded plain-text message.']]],</span>
<a href="#l28.298"></a><span id="l28.298" class="difflineplus">+      [&quot;Nested message headers&quot;, read_file(&quot;message-encoded&quot;), {},</span>
<a href="#l28.299"></a><span id="l28.299" class="difflineplus">+        {'': {'Content-Type': ['multipart/mixed; boundary=&quot;iamaboundary&quot;']},</span>
<a href="#l28.300"></a><span id="l28.300" class="difflineplus">+         '1': {'Content-Type': ['message/rfc822']},</span>
<a href="#l28.301"></a><span id="l28.301" class="difflineplus">+         '1$': {'Subject': ['I am a subject']},</span>
<a href="#l28.302"></a><span id="l28.302" class="difflineplus">+         '2': {'Content-Type': ['message/global'],</span>
<a href="#l28.303"></a><span id="l28.303" class="difflineplus">+               'Content-Transfer-Encoding': ['base64']},</span>
<a href="#l28.304"></a><span id="l28.304" class="difflineplus">+         '2$': {'Subject': ['\u79c1\u306f\u3001\u4ef6\u540d\u5348\u524d']},</span>
<a href="#l28.305"></a><span id="l28.305" class="difflineplus">+         '3': {'Content-Type': ['message/news'],</span>
<a href="#l28.306"></a><span id="l28.306" class="difflineplus">+               'Content-Transfer-Encoding': ['quoted-printable']},</span>
<a href="#l28.307"></a><span id="l28.307" class="difflineplus">+         '3$': {'Subject': ['\u79c1\u306f\u3001\u4ef6\u540d\u5348\u524d']}}],</span>
<a href="#l28.308"></a><span id="l28.308" class="difflineplus">+    ];</span>
<a href="#l28.309"></a><span id="l28.309" class="difflineplus">+    parser_tests.forEach(function (data) {</span>
<a href="#l28.310"></a><span id="l28.310" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l28.311"></a><span id="l28.311" class="difflineplus">+        return testParser(data[1], data[2], data[3]);</span>
<a href="#l28.312"></a><span id="l28.312" class="difflineplus">+      });</span>
<a href="#l28.313"></a><span id="l28.313" class="difflineplus">+    });</span>
<a href="#l28.314"></a><span id="l28.314" class="difflineplus">+  });</span>
<a href="#l28.315"></a><span id="l28.315" class="difflineplus">+</span>
<a href="#l28.316"></a><span id="l28.316" class="difflineplus">+  suite('Torture tests', function () {</span>
<a href="#l28.317"></a><span id="l28.317" class="difflineplus">+    // Generate a very long message for tests</span>
<a href="#l28.318"></a><span id="l28.318" class="difflineplus">+    let teststr = 'a';</span>
<a href="#l28.319"></a><span id="l28.319" class="difflineplus">+    for (let i = 0; i &lt; 16; i++)</span>
<a href="#l28.320"></a><span id="l28.320" class="difflineplus">+      teststr += teststr;</span>
<a href="#l28.321"></a><span id="l28.321" class="difflineplus">+    let parser_tests = [</span>
<a href="#l28.322"></a><span id="l28.322" class="difflineplus">+      [&quot;Base64 very long decode&quot;,</span>
<a href="#l28.323"></a><span id="l28.323" class="difflineplus">+        &quot;Content-Transfer-Encoding: base64\r\n\r\n&quot; + btoa(teststr) + &quot;\r\n&quot;,</span>
<a href="#l28.324"></a><span id="l28.324" class="difflineplus">+        {bodyformat: &quot;decode&quot;}, [['', teststr]]],</span>
<a href="#l28.325"></a><span id="l28.325" class="difflineplus">+      make_body_test(&quot;Torture regular body&quot;, &quot;mime-torture&quot;, {}, [</span>
<a href="#l28.326"></a><span id="l28.326" class="difflineplus">+        ['1', 17, 21], ['2$.1', 58, 75], ['2$.2.1', 83, 97], ['2$.3', 102, 130],</span>
<a href="#l28.327"></a><span id="l28.327" class="difflineplus">+        ['3$', 155, 7742], ['4', 7747, 8213], ['5', 8218, 8242],</span>
<a href="#l28.328"></a><span id="l28.328" class="difflineplus">+        ['6$.1.1', 8284, 8301], ['6$.1.2', 8306, 8733], ['6$.2.1', 8742, 9095],</span>
<a href="#l28.329"></a><span id="l28.329" class="difflineplus">+        ['6$.2.2', 9100, 9354], ['6$.2.3', 9357, 11794],</span>
<a href="#l28.330"></a><span id="l28.330" class="difflineplus">+        ['6$.2.4', 11797, 12155], ['6$.3', 12161, 12809],</span>
<a href="#l28.331"></a><span id="l28.331" class="difflineplus">+        ['7$.1', 12844, 12845], ['7$.2', 12852, 13286],</span>
<a href="#l28.332"></a><span id="l28.332" class="difflineplus">+        ['7$.3', 13288, 13297], ['8$.1', 13331, 13358], ['8$.2', 13364, 13734],</span>
<a href="#l28.333"></a><span id="l28.333" class="difflineplus">+        ['9$', 13757, 20179], ['10', 20184, 21200], ['11$.1', 21223, 22031],</span>
<a href="#l28.334"></a><span id="l28.334" class="difflineplus">+        ['11$.2', 22036, 22586], ['12$.1', 22607, 23469],</span>
<a href="#l28.335"></a><span id="l28.335" class="difflineplus">+        ['12$.2', 23474, 23774], ['12$.3$.1', 23787, 23795],</span>
<a href="#l28.336"></a><span id="l28.336" class="difflineplus">+        ['12$.3$.2.1', 23803, 23820], ['12$.3$.2.2', 23825, 24633],</span>
<a href="#l28.337"></a><span id="l28.337" class="difflineplus">+        ['12$.3$.3', 24640, 24836], ['12$.3$.4$', 24848, 25872]]),</span>
<a href="#l28.338"></a><span id="l28.338" class="difflineplus">+      make_body_test(&quot;Torture pruneat&quot;, &quot;mime-torture&quot;, {&quot;pruneat&quot;: '4'},</span>
<a href="#l28.339"></a><span id="l28.339" class="difflineplus">+        [['4', 7747, 8213]]),</span>
<a href="#l28.340"></a><span id="l28.340" class="difflineplus">+</span>
<a href="#l28.341"></a><span id="l28.341" class="difflineplus">+      // Test packetization problems</span>
<a href="#l28.342"></a><span id="l28.342" class="difflineplus">+      make_body_test(&quot;Large packets&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l28.343"></a><span id="l28.343" class="difflineplus">+        {&quot;_split&quot;: /(.{30})/}, mpart_complex1),</span>
<a href="#l28.344"></a><span id="l28.344" class="difflineplus">+      make_body_test(&quot;Split on newline&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l28.345"></a><span id="l28.345" class="difflineplus">+        {&quot;_split&quot;: /(\r\n)/}, mpart_complex1),</span>
<a href="#l28.346"></a><span id="l28.346" class="difflineplus">+      make_body_test(&quot;Pathological splitting&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l28.347"></a><span id="l28.347" class="difflineplus">+        {&quot;_split&quot;: ''}, mpart_complex1),</span>
<a href="#l28.348"></a><span id="l28.348" class="difflineplus">+</span>
<a href="#l28.349"></a><span id="l28.349" class="difflineplus">+      // Non-CLRF line endings?</span>
<a href="#l28.350"></a><span id="l28.350" class="difflineplus">+      make_body_test(&quot;LF-based messages&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l28.351"></a><span id="l28.351" class="difflineplus">+        {&quot;_eol&quot;: &quot;\n&quot;}, mpart_complex1),</span>
<a href="#l28.352"></a><span id="l28.352" class="difflineplus">+      make_body_test(&quot;CR-based messages&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l28.353"></a><span id="l28.353" class="difflineplus">+        {&quot;_eol&quot;: &quot;\r&quot;}, mpart_complex1),</span>
<a href="#l28.354"></a><span id="l28.354" class="difflineplus">+    ];</span>
<a href="#l28.355"></a><span id="l28.355" class="difflineplus">+    parser_tests.forEach(function (data) {</span>
<a href="#l28.356"></a><span id="l28.356" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l28.357"></a><span id="l28.357" class="difflineplus">+        return testParser(data[1], data[2], data[3]);</span>
<a href="#l28.358"></a><span id="l28.358" class="difflineplus">+      });</span>
<a href="#l28.359"></a><span id="l28.359" class="difflineplus">+    });</span>
<a href="#l28.360"></a><span id="l28.360" class="difflineplus">+  });</span>
<a href="#l28.361"></a><span id="l28.361" class="difflineplus">+</span>
<a href="#l28.362"></a><span id="l28.362" class="difflineplus">+  suite('Header tests', function () {</span>
<a href="#l28.363"></a><span id="l28.363" class="difflineplus">+    let parser_tests = [</span>
<a href="#l28.364"></a><span id="l28.364" class="difflineplus">+      // Basic cases for headers</span>
<a href="#l28.365"></a><span id="l28.365" class="difflineplus">+      ['Multiparts get headers', read_file(&quot;multipart-complex1&quot;), {},</span>
<a href="#l28.366"></a><span id="l28.366" class="difflineplus">+        { '': {'Content-Type': ['multipart/mixed; boundary=&quot;boundary&quot;']},</span>
<a href="#l28.367"></a><span id="l28.367" class="difflineplus">+          '1': {'Content-Type': ['application/octet-stream'],</span>
<a href="#l28.368"></a><span id="l28.368" class="difflineplus">+                'Content-Transfer-Encoding': ['base64']},</span>
<a href="#l28.369"></a><span id="l28.369" class="difflineplus">+          '2': {'Content-Type': ['image/png'],</span>
<a href="#l28.370"></a><span id="l28.370" class="difflineplus">+                'Content-Transfer-Encoding': ['base64']},</span>
<a href="#l28.371"></a><span id="l28.371" class="difflineplus">+          '3': {'Content-Type': ['multipart/related; boundary=&quot;boundary2&quot;']},</span>
<a href="#l28.372"></a><span id="l28.372" class="difflineplus">+          '3.1': {'Content-Type': ['text/html']},</span>
<a href="#l28.373"></a><span id="l28.373" class="difflineplus">+          '4': {'Content-Type': ['text/plain']}, '5': {} }],</span>
<a href="#l28.374"></a><span id="l28.374" class="difflineplus">+      // 'From ' is not an [iterable] header</span>
<a href="#l28.375"></a><span id="l28.375" class="difflineplus">+      ['Exclude mbox delimiter', read_file('bugmail11'), {}, {'': {</span>
<a href="#l28.376"></a><span id="l28.376" class="difflineplus">+        'X-Mozilla-Status': ['0001'], 'X-Mozilla-Status2': ['00000000'],</span>
<a href="#l28.377"></a><span id="l28.377" class="difflineplus">+        'X-Mozilla-Keys': [''],</span>
<a href="#l28.378"></a><span id="l28.378" class="difflineplus">+        'Return-Path': ['&lt;example@example.com&gt;',</span>
<a href="#l28.379"></a><span id="l28.379" class="difflineplus">+           '&lt;bugzilla-daemon@mozilla.org&gt;'],</span>
<a href="#l28.380"></a><span id="l28.380" class="difflineplus">+        'Delivered-To': ['bugmail@example.org'],</span>
<a href="#l28.381"></a><span id="l28.381" class="difflineplus">+        'Received': ['by 10.114.166.12 with SMTP id o12cs163262wae;' +</span>
<a href="#l28.382"></a><span id="l28.382" class="difflineplus">+                     '        Fri, 11 Apr 2008 07:17:31 -0700 (PDT)',</span>
<a href="#l28.383"></a><span id="l28.383" class="difflineplus">+          'by 10.115.60.1 with SMTP id n1mr214763wak.181.1207923450166;' +</span>
<a href="#l28.384"></a><span id="l28.384" class="difflineplus">+          '        Fri, 11 Apr 2008 07:17:30 -0700 (PDT)',</span>
<a href="#l28.385"></a><span id="l28.385" class="difflineplus">+          'from webapp-out.mozilla.org (webapp01.sj.mozilla.com [63.245.208.1' +</span>
<a href="#l28.386"></a><span id="l28.386" class="difflineplus">+          '46])        by mx.google.com with ESMTP id n38si6807242wag.2.2008.' +</span>
<a href="#l28.387"></a><span id="l28.387" class="difflineplus">+          '04.11.07.17.29;        Fri, 11 Apr 2008 07:17:30 -0700 (PDT)',</span>
<a href="#l28.388"></a><span id="l28.388" class="difflineplus">+          'from mrapp51.mozilla.org (mrapp51.mozilla.org [127.0.0.1])' +</span>
<a href="#l28.389"></a><span id="l28.389" class="difflineplus">+          '\tby webapp-out.mozilla.org (8.13.8/8.13.8) with ESMTP id m3BEHTGU' +</span>
<a href="#l28.390"></a><span id="l28.390" class="difflineplus">+          '030132\tfor &lt;bugmail@example.org&gt;; Fri, 11 Apr 2008 07:17:29 -0700',</span>
<a href="#l28.391"></a><span id="l28.391" class="difflineplus">+          '(from root@localhost)' +</span>
<a href="#l28.392"></a><span id="l28.392" class="difflineplus">+          '\tby mrapp51.mozilla.org (8.13.8/8.13.8/Submit) id m3BEHTk4030129;' +</span>
<a href="#l28.393"></a><span id="l28.393" class="difflineplus">+          '\tFri, 11 Apr 2008 07:17:29 -0700'],</span>
<a href="#l28.394"></a><span id="l28.394" class="difflineplus">+        'Received-Spf': ['neutral (google.com: 63.245.208.146 is neither perm' +</span>
<a href="#l28.395"></a><span id="l28.395" class="difflineplus">+          'itted nor denied by best guess record for domain of bugzilla-daemo' +</span>
<a href="#l28.396"></a><span id="l28.396" class="difflineplus">+          'n@mozilla.org) client-ip=63.245.208.146;'],</span>
<a href="#l28.397"></a><span id="l28.397" class="difflineplus">+        'Authentication-Results': ['mx.google.com; spf=neutral (google.com: 6' +</span>
<a href="#l28.398"></a><span id="l28.398" class="difflineplus">+          '3.245.208.146 is neither permitted nor denied by best guess record' +</span>
<a href="#l28.399"></a><span id="l28.399" class="difflineplus">+          ' for domain of bugzilla-daemon@mozilla.org) smtp.mail=bugzilla-dae' +</span>
<a href="#l28.400"></a><span id="l28.400" class="difflineplus">+          'mon@mozilla.org'],</span>
<a href="#l28.401"></a><span id="l28.401" class="difflineplus">+        'Date': ['Fri, 11 Apr 2008 07:17:29 -0700'],</span>
<a href="#l28.402"></a><span id="l28.402" class="difflineplus">+        'Message-Id': ['&lt;200804111417.m3BEHTk4030129@mrapp51.mozilla.org&gt;'],</span>
<a href="#l28.403"></a><span id="l28.403" class="difflineplus">+        'From': ['bugzilla-daemon@mozilla.org'], 'To': ['bugmail@example.org'],</span>
<a href="#l28.404"></a><span id="l28.404" class="difflineplus">+        'Subject': ['Bugzilla: confirm account creation'],</span>
<a href="#l28.405"></a><span id="l28.405" class="difflineplus">+        'X-Bugzilla-Type': ['admin'],</span>
<a href="#l28.406"></a><span id="l28.406" class="difflineplus">+        'Content-Type': ['text/plain; charset=&quot;UTF-8&quot;'],</span>
<a href="#l28.407"></a><span id="l28.407" class="difflineplus">+        'Mime-Version': ['1.0']}}],</span>
<a href="#l28.408"></a><span id="l28.408" class="difflineplus">+    ];</span>
<a href="#l28.409"></a><span id="l28.409" class="difflineplus">+    parser_tests.forEach(function (data) {</span>
<a href="#l28.410"></a><span id="l28.410" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l28.411"></a><span id="l28.411" class="difflineplus">+        return testParser(data[1], data[2], data[3]);</span>
<a href="#l28.412"></a><span id="l28.412" class="difflineplus">+      });</span>
<a href="#l28.413"></a><span id="l28.413" class="difflineplus">+    });</span>
<a href="#l28.414"></a><span id="l28.414" class="difflineplus">+  });</span>
<a href="#l28.415"></a><span id="l28.415" class="difflineplus">+</span>
<a href="#l28.416"></a><span id="l28.416" class="difflineplus">+  suite('Charset tests', function () {</span>
<a href="#l28.417"></a><span id="l28.417" class="difflineplus">+    function buildTree(file, options) {</span>
<a href="#l28.418"></a><span id="l28.418" class="difflineplus">+      var tree = new Map();</span>
<a href="#l28.419"></a><span id="l28.419" class="difflineplus">+      var emitter = {</span>
<a href="#l28.420"></a><span id="l28.420" class="difflineplus">+        startPart: function (part, headers) {</span>
<a href="#l28.421"></a><span id="l28.421" class="difflineplus">+          tree.set(part, {headers: headers, body: null});</span>
<a href="#l28.422"></a><span id="l28.422" class="difflineplus">+        },</span>
<a href="#l28.423"></a><span id="l28.423" class="difflineplus">+        deliverPartData: function (part, data) {</span>
<a href="#l28.424"></a><span id="l28.424" class="difflineplus">+          var obj = tree.get(part);</span>
<a href="#l28.425"></a><span id="l28.425" class="difflineplus">+          if (obj.body === null)</span>
<a href="#l28.426"></a><span id="l28.426" class="difflineplus">+            obj.body = data;</span>
<a href="#l28.427"></a><span id="l28.427" class="difflineplus">+          else if (typeof obj.body === &quot;string&quot;)</span>
<a href="#l28.428"></a><span id="l28.428" class="difflineplus">+            obj.body += data;</span>
<a href="#l28.429"></a><span id="l28.429" class="difflineplus">+          else {</span>
<a href="#l28.430"></a><span id="l28.430" class="difflineplus">+            var newData = new Uint8Array(obj.body.length + data.length);</span>
<a href="#l28.431"></a><span id="l28.431" class="difflineplus">+            newData.set(obj.body);</span>
<a href="#l28.432"></a><span id="l28.432" class="difflineplus">+            newData.subarray(obj.body.length).set(data);</span>
<a href="#l28.433"></a><span id="l28.433" class="difflineplus">+            obj.body = newData;</span>
<a href="#l28.434"></a><span id="l28.434" class="difflineplus">+          }</span>
<a href="#l28.435"></a><span id="l28.435" class="difflineplus">+        }</span>
<a href="#l28.436"></a><span id="l28.436" class="difflineplus">+      };</span>
<a href="#l28.437"></a><span id="l28.437" class="difflineplus">+      return file.then(function (data) {</span>
<a href="#l28.438"></a><span id="l28.438" class="difflineplus">+        var parser = new jsmime.MimeParser(emitter, options);</span>
<a href="#l28.439"></a><span id="l28.439" class="difflineplus">+        parser.deliverData(data);</span>
<a href="#l28.440"></a><span id="l28.440" class="difflineplus">+        parser.deliverEOF();</span>
<a href="#l28.441"></a><span id="l28.441" class="difflineplus">+        return tree;</span>
<a href="#l28.442"></a><span id="l28.442" class="difflineplus">+      });</span>
<a href="#l28.443"></a><span id="l28.443" class="difflineplus">+    }</span>
<a href="#l28.444"></a><span id="l28.444" class="difflineplus">+    test('Unicode decoding', function () {</span>
<a href="#l28.445"></a><span id="l28.445" class="difflineplus">+      return buildTree(read_file('shift-jis-image'), {</span>
<a href="#l28.446"></a><span id="l28.446" class="difflineplus">+        strformat: &quot;unicode&quot;,</span>
<a href="#l28.447"></a><span id="l28.447" class="difflineplus">+        bodyformat: &quot;decode&quot;</span>
<a href="#l28.448"></a><span id="l28.448" class="difflineplus">+      }).then(function (tree) {</span>
<a href="#l28.449"></a><span id="l28.449" class="difflineplus">+        // text/plain should be transcoded...</span>
<a href="#l28.450"></a><span id="l28.450" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Type').get('charset'),</span>
<a href="#l28.451"></a><span id="l28.451" class="difflineplus">+          'Shift-JIS');</span>
<a href="#l28.452"></a><span id="l28.452" class="difflineplus">+        assert.equal(tree.get('1').headers.charset, 'Shift-JIS');</span>
<a href="#l28.453"></a><span id="l28.453" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Description'),</span>
<a href="#l28.454"></a><span id="l28.454" class="difflineplus">+          '\u30b1\u30c4\u30a1\u30eb\u30b3\u30a2\u30c8\u30eb');</span>
<a href="#l28.455"></a><span id="l28.455" class="difflineplus">+        assert.equal(tree.get('1').body, 'Portable Network Graphics\uff08' +</span>
<a href="#l28.456"></a><span id="l28.456" class="difflineplus">+          '\u30dd\u30fc\u30bf\u30d6\u30eb\u30fb\u30cd\u30c3\u30c8\u30ef\u30fc' +</span>
<a href="#l28.457"></a><span id="l28.457" class="difflineplus">+          '\u30af\u30fb\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3001PNG' +</span>
<a href="#l28.458"></a><span id="l28.458" class="difflineplus">+          '\uff09\u306f\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u30d3\u30c3' +</span>
<a href="#l28.459"></a><span id="l28.459" class="difflineplus">+          '\u30c8\u30de\u30c3\u30d7\u753b\u50cf\u3092\u6271\u3046\u30d5\u30a1' +</span>
<a href="#l28.460"></a><span id="l28.460" class="difflineplus">+          '\u30a4\u30eb\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u3042\u308b' +</span>
<a href="#l28.461"></a><span id="l28.461" class="difflineplus">+          '\u3002\u5727\u7e2e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3068\u3057' +</span>
<a href="#l28.462"></a><span id="l28.462" class="difflineplus">+          '\u3066Deflate\u3092\u63a1\u7528\u3057\u3066\u3044\u308b\u3001' +</span>
<a href="#l28.463"></a><span id="l28.463" class="difflineplus">+          '\u5727\u7e2e\u306b\u3088\u308b\u753b\u8cea\u306e\u52a3\u5316\u306e' +</span>
<a href="#l28.464"></a><span id="l28.464" class="difflineplus">+          '\u306a\u3044\u53ef\u9006\u5727\u7e2e\u306e\u753b\u50cf\u30d5\u30a1' +</span>
<a href="#l28.465"></a><span id="l28.465" class="difflineplus">+          '\u30a4\u30eb\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u3042\u308b' +</span>
<a href="#l28.466"></a><span id="l28.466" class="difflineplus">+          '\u3002\r\n');</span>
<a href="#l28.467"></a><span id="l28.467" class="difflineplus">+        // ... but not image/png</span>
<a href="#l28.468"></a><span id="l28.468" class="difflineplus">+        assert.ok(!tree.get('2').headers.get('Content-Type').has('charset'));</span>
<a href="#l28.469"></a><span id="l28.469" class="difflineplus">+        assert.equal(tree.get('2').headers.charset, '');</span>
<a href="#l28.470"></a><span id="l28.470" class="difflineplus">+        assert.equal(tree.get('2').headers.get('Content-Description'),</span>
<a href="#l28.471"></a><span id="l28.471" class="difflineplus">+          '\ufffdP\ufffdc\ufffd@\ufffd\ufffd\ufffdR\ufffdA\ufffdg\ufffd\ufffd');</span>
<a href="#l28.472"></a><span id="l28.472" class="difflineplus">+        assert.equal(tree.get('2').headers.getRawHeader('Content-Description'),</span>
<a href="#l28.473"></a><span id="l28.473" class="difflineplus">+          '\x83\x50\x83\x63\x83\x40\x83\x8b\x83\x52\x83\x41\x83\x67\x83\x8b');</span>
<a href="#l28.474"></a><span id="l28.474" class="difflineplus">+        var imageData = 'iVBORw0KGgoAAAANSUhEUgAAAIAAAABECAIAAADGJao+AAAAwklE' +</span>
<a href="#l28.475"></a><span id="l28.475" class="difflineplus">+          'QVR4Xu3UgQbDMBRA0bc03f//b7N0VuqJEmwoc+KqNEkDh9b+2HuJu1KNO4f+AQCAAA' +</span>
<a href="#l28.476"></a><span id="l28.476" class="difflineplus">+          'AQAAACAEAAAAgAAAEAIAAABACAAAAQAAACAEAAAAgAAAEAIAAAANReamRLlPWYfNH0' +</span>
<a href="#l28.477"></a><span id="l28.477" class="difflineplus">+          'klxcPs+cP3NxWF+vi3lb7pa2R+vx6tHOtuN1O+a5lY3HzgM5ya/GM5N7ZjfPq7/5yS' +</span>
<a href="#l28.478"></a><span id="l28.478" class="difflineplus">+          '8IgAAAEAAAAgBAAAAIAAABACAAAAQAgAAAEAAAAgBAAAAIAAABACAAAIw322gDIPvt' +</span>
<a href="#l28.479"></a><span id="l28.479" class="difflineplus">+          'lmUAAAAASUVORK5CYII=';</span>
<a href="#l28.480"></a><span id="l28.480" class="difflineplus">+        imageData = atob(imageData);</span>
<a href="#l28.481"></a><span id="l28.481" class="difflineplus">+        var asArray = new Uint8Array(imageData.length);</span>
<a href="#l28.482"></a><span id="l28.482" class="difflineplus">+        for (var i = 0; i &lt; asArray.length; i++)</span>
<a href="#l28.483"></a><span id="l28.483" class="difflineplus">+          asArray[i] = imageData.charCodeAt(i);</span>
<a href="#l28.484"></a><span id="l28.484" class="difflineplus">+        assert.deepEqual(tree.get('2').body, asArray);</span>
<a href="#l28.485"></a><span id="l28.485" class="difflineplus">+</span>
<a href="#l28.486"></a><span id="l28.486" class="difflineplus">+        // Touching the header charset should change the interpretation.</span>
<a href="#l28.487"></a><span id="l28.487" class="difflineplus">+        tree.get('1').headers.charset = 'Shift-JIS';</span>
<a href="#l28.488"></a><span id="l28.488" class="difflineplus">+        assert.equal(tree.get('1').headers.charset, 'Shift-JIS');</span>
<a href="#l28.489"></a><span id="l28.489" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Description'),</span>
<a href="#l28.490"></a><span id="l28.490" class="difflineplus">+          '\u30b1\u30c4\u30a1\u30eb\u30b3\u30a2\u30c8\u30eb');</span>
<a href="#l28.491"></a><span id="l28.491" class="difflineplus">+      });</span>
<a href="#l28.492"></a><span id="l28.492" class="difflineplus">+    });</span>
<a href="#l28.493"></a><span id="l28.493" class="difflineplus">+    test('Fallback charset decoding', function () {</span>
<a href="#l28.494"></a><span id="l28.494" class="difflineplus">+      return buildTree(read_file('shift-jis-image'), {</span>
<a href="#l28.495"></a><span id="l28.495" class="difflineplus">+        strformat: &quot;unicode&quot;,</span>
<a href="#l28.496"></a><span id="l28.496" class="difflineplus">+        charset: &quot;ISO-8859-1&quot;,</span>
<a href="#l28.497"></a><span id="l28.497" class="difflineplus">+        bodyformat: &quot;decode&quot;</span>
<a href="#l28.498"></a><span id="l28.498" class="difflineplus">+      }).then(function (tree) {</span>
<a href="#l28.499"></a><span id="l28.499" class="difflineplus">+        // text/plain should be transcoded...</span>
<a href="#l28.500"></a><span id="l28.500" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Type').get('charset'),</span>
<a href="#l28.501"></a><span id="l28.501" class="difflineplus">+          'Shift-JIS');</span>
<a href="#l28.502"></a><span id="l28.502" class="difflineplus">+        assert.equal(tree.get('1').headers.charset, 'Shift-JIS');</span>
<a href="#l28.503"></a><span id="l28.503" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Description'),</span>
<a href="#l28.504"></a><span id="l28.504" class="difflineplus">+          '\u30b1\u30c4\u30a1\u30eb\u30b3\u30a2\u30c8\u30eb');</span>
<a href="#l28.505"></a><span id="l28.505" class="difflineplus">+        assert.equal(tree.get('1').body, 'Portable Network Graphics\uff08' +</span>
<a href="#l28.506"></a><span id="l28.506" class="difflineplus">+          '\u30dd\u30fc\u30bf\u30d6\u30eb\u30fb\u30cd\u30c3\u30c8\u30ef\u30fc' +</span>
<a href="#l28.507"></a><span id="l28.507" class="difflineplus">+          '\u30af\u30fb\u30b0\u30e9\u30d5\u30a3\u30c3\u30af\u30b9\u3001PNG' +</span>
<a href="#l28.508"></a><span id="l28.508" class="difflineplus">+          '\uff09\u306f\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u30d3\u30c3' +</span>
<a href="#l28.509"></a><span id="l28.509" class="difflineplus">+          '\u30c8\u30de\u30c3\u30d7\u753b\u50cf\u3092\u6271\u3046\u30d5\u30a1' +</span>
<a href="#l28.510"></a><span id="l28.510" class="difflineplus">+          '\u30a4\u30eb\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u3042\u308b' +</span>
<a href="#l28.511"></a><span id="l28.511" class="difflineplus">+          '\u3002\u5727\u7e2e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3068\u3057' +</span>
<a href="#l28.512"></a><span id="l28.512" class="difflineplus">+          '\u3066Deflate\u3092\u63a1\u7528\u3057\u3066\u3044\u308b\u3001' +</span>
<a href="#l28.513"></a><span id="l28.513" class="difflineplus">+          '\u5727\u7e2e\u306b\u3088\u308b\u753b\u8cea\u306e\u52a3\u5316\u306e' +</span>
<a href="#l28.514"></a><span id="l28.514" class="difflineplus">+          '\u306a\u3044\u53ef\u9006\u5727\u7e2e\u306e\u753b\u50cf\u30d5\u30a1' +</span>
<a href="#l28.515"></a><span id="l28.515" class="difflineplus">+          '\u30a4\u30eb\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u3042\u308b' +</span>
<a href="#l28.516"></a><span id="l28.516" class="difflineplus">+          '\u3002\r\n');</span>
<a href="#l28.517"></a><span id="l28.517" class="difflineplus">+        // ... but not image/png</span>
<a href="#l28.518"></a><span id="l28.518" class="difflineplus">+        assert.ok(!tree.get('2').headers.get('Content-Type').has('charset'));</span>
<a href="#l28.519"></a><span id="l28.519" class="difflineplus">+        assert.equal(tree.get('2').headers.charset, 'ISO-8859-1');</span>
<a href="#l28.520"></a><span id="l28.520" class="difflineplus">+        assert.equal(tree.get('2').headers.get('Content-Description'),</span>
<a href="#l28.521"></a><span id="l28.521" class="difflineplus">+          '\u0192P\u0192c\u0192@\u0192\u2039\u0192R\u0192A\u0192g\u0192\u2039');</span>
<a href="#l28.522"></a><span id="l28.522" class="difflineplus">+        assert.equal(tree.get('2').headers.getRawHeader('Content-Description'),</span>
<a href="#l28.523"></a><span id="l28.523" class="difflineplus">+          '\x83\x50\x83\x63\x83\x40\x83\x8b\x83\x52\x83\x41\x83\x67\x83\x8b');</span>
<a href="#l28.524"></a><span id="l28.524" class="difflineplus">+        var imageData = 'iVBORw0KGgoAAAANSUhEUgAAAIAAAABECAIAAADGJao+AAAAwklE' +</span>
<a href="#l28.525"></a><span id="l28.525" class="difflineplus">+          'QVR4Xu3UgQbDMBRA0bc03f//b7N0VuqJEmwoc+KqNEkDh9b+2HuJu1KNO4f+AQCAAA' +</span>
<a href="#l28.526"></a><span id="l28.526" class="difflineplus">+          'AQAAACAEAAAAgAAAEAIAAABACAAAAQAAACAEAAAAgAAAEAIAAAANReamRLlPWYfNH0' +</span>
<a href="#l28.527"></a><span id="l28.527" class="difflineplus">+          'klxcPs+cP3NxWF+vi3lb7pa2R+vx6tHOtuN1O+a5lY3HzgM5ya/GM5N7ZjfPq7/5yS' +</span>
<a href="#l28.528"></a><span id="l28.528" class="difflineplus">+          '8IgAAAEAAAAgBAAAAIAAABACAAAAQAgAAAEAAAAgBAAAAIAAABACAAAIw322gDIPvt' +</span>
<a href="#l28.529"></a><span id="l28.529" class="difflineplus">+          'lmUAAAAASUVORK5CYII=';</span>
<a href="#l28.530"></a><span id="l28.530" class="difflineplus">+        imageData = atob(imageData);</span>
<a href="#l28.531"></a><span id="l28.531" class="difflineplus">+        var asArray = new Uint8Array(imageData.length);</span>
<a href="#l28.532"></a><span id="l28.532" class="difflineplus">+        for (var i = 0; i &lt; asArray.length; i++)</span>
<a href="#l28.533"></a><span id="l28.533" class="difflineplus">+          asArray[i] = imageData.charCodeAt(i);</span>
<a href="#l28.534"></a><span id="l28.534" class="difflineplus">+        assert.deepEqual(tree.get('2').body, asArray);</span>
<a href="#l28.535"></a><span id="l28.535" class="difflineplus">+</span>
<a href="#l28.536"></a><span id="l28.536" class="difflineplus">+        // Touching the header charset should change the interpretation.</span>
<a href="#l28.537"></a><span id="l28.537" class="difflineplus">+        tree.get('1').headers.charset = 'Shift-JIS';</span>
<a href="#l28.538"></a><span id="l28.538" class="difflineplus">+        assert.equal(tree.get('1').headers.charset, 'Shift-JIS');</span>
<a href="#l28.539"></a><span id="l28.539" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Description'),</span>
<a href="#l28.540"></a><span id="l28.540" class="difflineplus">+          '\u30b1\u30c4\u30a1\u30eb\u30b3\u30a2\u30c8\u30eb');</span>
<a href="#l28.541"></a><span id="l28.541" class="difflineplus">+      });</span>
<a href="#l28.542"></a><span id="l28.542" class="difflineplus">+    });</span>
<a href="#l28.543"></a><span id="l28.543" class="difflineplus">+    test('Forced charset decoding', function () {</span>
<a href="#l28.544"></a><span id="l28.544" class="difflineplus">+      return buildTree(read_file('shift-jis-image'), {</span>
<a href="#l28.545"></a><span id="l28.545" class="difflineplus">+        strformat: &quot;unicode&quot;,</span>
<a href="#l28.546"></a><span id="l28.546" class="difflineplus">+        charset: &quot;ISO-8859-1&quot;,</span>
<a href="#l28.547"></a><span id="l28.547" class="difflineplus">+        &quot;force-charset&quot;: true,</span>
<a href="#l28.548"></a><span id="l28.548" class="difflineplus">+        bodyformat: &quot;decode&quot;</span>
<a href="#l28.549"></a><span id="l28.549" class="difflineplus">+      }).then(function (tree) {</span>
<a href="#l28.550"></a><span id="l28.550" class="difflineplus">+        // text/plain should be transcoded...</span>
<a href="#l28.551"></a><span id="l28.551" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Type').get('charset'),</span>
<a href="#l28.552"></a><span id="l28.552" class="difflineplus">+          'Shift-JIS');</span>
<a href="#l28.553"></a><span id="l28.553" class="difflineplus">+        assert.equal(tree.get('1').headers.charset, 'ISO-8859-1');</span>
<a href="#l28.554"></a><span id="l28.554" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Description'),</span>
<a href="#l28.555"></a><span id="l28.555" class="difflineplus">+          '\u0192P\u0192c\u0192@\u0192\u2039\u0192R\u0192A\u0192g\u0192\u2039');</span>
<a href="#l28.556"></a><span id="l28.556" class="difflineplus">+        assert.equal(tree.get('1').body, 'Portable Network Graphics\u0081i' +</span>
<a href="#l28.557"></a><span id="l28.557" class="difflineplus">+          '\u0192|\u0081[\u0192^\u0192u\u0192\u2039\u0081E\u0192l\u0192b' +</span>
<a href="#l28.558"></a><span id="l28.558" class="difflineplus">+          '\u0192g\u0192\u008f\u0081[\u0192N\u0081E\u0192O\u0192\u2030\u0192t' +</span>
<a href="#l28.559"></a><span id="l28.559" class="difflineplus">+          '\u0192B\u0192b\u0192N\u0192X\u0081APNG\u0081j\u201a\u00cd\u0192R' +</span>
<a href="#l28.560"></a><span id="l28.560" class="difflineplus">+          '\u0192\u201c\u0192s\u0192\u2026\u0081[\u0192^\u201a\u00c5\u0192r' +</span>
<a href="#l28.561"></a><span id="l28.561" class="difflineplus">+          '\u0192b\u0192g\u0192}\u0192b\u0192v\u2030\u00e6\u2018\u0153\u201a' +</span>
<a href="#l28.562"></a><span id="l28.562" class="difflineplus">+          '\u00f0\u02c6\u00b5\u201a\u00a4\u0192t\u0192@\u0192C\u0192\u2039' +</span>
<a href="#l28.563"></a><span id="l28.563" class="difflineplus">+          '\u0192t\u0192H\u0081[\u0192}\u0192b\u0192g\u201a\u00c5\u201a\u00a0' +</span>
<a href="#l28.564"></a><span id="l28.564" class="difflineplus">+          '\u201a\u00e9\u0081B\u02c6\u00b3\u008fk\u0192A\u0192\u2039\u0192S' +</span>
<a href="#l28.565"></a><span id="l28.565" class="difflineplus">+          '\u0192\u0160\u0192Y\u0192\u20ac\u201a\u00c6\u201a\u00b5\u201a' +</span>
<a href="#l28.566"></a><span id="l28.566" class="difflineplus">+          '\u00c4Deflate\u201a\u00f0\u008d\u00cc\u2014p\u201a\u00b5\u201a' +</span>
<a href="#l28.567"></a><span id="l28.567" class="difflineplus">+          '\u00c4\u201a\u00a2\u201a\u00e9\u0081A\u02c6\u00b3\u008fk\u201a' +</span>
<a href="#l28.568"></a><span id="l28.568" class="difflineplus">+          '\u00c9\u201a\u00e6\u201a\u00e9\u2030\u00e6\u017d\u00bf\u201a\u00cc' +</span>
<a href="#l28.569"></a><span id="l28.569" class="difflineplus">+          '\u2014\u00f2\u2030\u00bb\u201a\u00cc\u201a\u00c8\u201a\u00a2\u2030' +</span>
<a href="#l28.570"></a><span id="l28.570" class="difflineplus">+          '\u00c2\u2039t\u02c6\u00b3\u008fk\u201a\u00cc\u2030\u00e6\u2018' +</span>
<a href="#l28.571"></a><span id="l28.571" class="difflineplus">+          '\u0153\u0192t\u0192@\u0192C\u0192\u2039\u0192t\u0192H\u0081[\u0192' +</span>
<a href="#l28.572"></a><span id="l28.572" class="difflineplus">+          '}\u0192b\u0192g\u201a\u00c5\u201a\u00a0\u201a\u00e9\u0081B\r\n');</span>
<a href="#l28.573"></a><span id="l28.573" class="difflineplus">+        // ... but not image/png</span>
<a href="#l28.574"></a><span id="l28.574" class="difflineplus">+        assert.ok(!tree.get('2').headers.get('Content-Type').has('charset'));</span>
<a href="#l28.575"></a><span id="l28.575" class="difflineplus">+        assert.equal(tree.get('2').headers.charset, 'ISO-8859-1');</span>
<a href="#l28.576"></a><span id="l28.576" class="difflineplus">+        assert.equal(tree.get('2').headers.get('Content-Description'),</span>
<a href="#l28.577"></a><span id="l28.577" class="difflineplus">+          '\u0192P\u0192c\u0192@\u0192\u2039\u0192R\u0192A\u0192g\u0192\u2039');</span>
<a href="#l28.578"></a><span id="l28.578" class="difflineplus">+        assert.equal(tree.get('2').headers.getRawHeader('Content-Description'),</span>
<a href="#l28.579"></a><span id="l28.579" class="difflineplus">+          '\x83\x50\x83\x63\x83\x40\x83\x8b\x83\x52\x83\x41\x83\x67\x83\x8b');</span>
<a href="#l28.580"></a><span id="l28.580" class="difflineplus">+        var imageData = 'iVBORw0KGgoAAAANSUhEUgAAAIAAAABECAIAAADGJao+AAAAwklE' +</span>
<a href="#l28.581"></a><span id="l28.581" class="difflineplus">+          'QVR4Xu3UgQbDMBRA0bc03f//b7N0VuqJEmwoc+KqNEkDh9b+2HuJu1KNO4f+AQCAAA' +</span>
<a href="#l28.582"></a><span id="l28.582" class="difflineplus">+          'AQAAACAEAAAAgAAAEAIAAABACAAAAQAAACAEAAAAgAAAEAIAAAANReamRLlPWYfNH0' +</span>
<a href="#l28.583"></a><span id="l28.583" class="difflineplus">+          'klxcPs+cP3NxWF+vi3lb7pa2R+vx6tHOtuN1O+a5lY3HzgM5ya/GM5N7ZjfPq7/5yS' +</span>
<a href="#l28.584"></a><span id="l28.584" class="difflineplus">+          '8IgAAAEAAAAgBAAAAIAAABACAAAAQAgAAAEAAAAgBAAAAIAAABACAAAIw322gDIPvt' +</span>
<a href="#l28.585"></a><span id="l28.585" class="difflineplus">+          'lmUAAAAASUVORK5CYII=';</span>
<a href="#l28.586"></a><span id="l28.586" class="difflineplus">+        imageData = atob(imageData);</span>
<a href="#l28.587"></a><span id="l28.587" class="difflineplus">+        var asArray = new Uint8Array(imageData.length);</span>
<a href="#l28.588"></a><span id="l28.588" class="difflineplus">+        for (var i = 0; i &lt; asArray.length; i++)</span>
<a href="#l28.589"></a><span id="l28.589" class="difflineplus">+          asArray[i] = imageData.charCodeAt(i);</span>
<a href="#l28.590"></a><span id="l28.590" class="difflineplus">+        assert.deepEqual(tree.get('2').body, asArray);</span>
<a href="#l28.591"></a><span id="l28.591" class="difflineplus">+</span>
<a href="#l28.592"></a><span id="l28.592" class="difflineplus">+        // Touching the header charset should change the interpretation.</span>
<a href="#l28.593"></a><span id="l28.593" class="difflineplus">+        tree.get('1').headers.charset = 'Shift-JIS';</span>
<a href="#l28.594"></a><span id="l28.594" class="difflineplus">+        assert.equal(tree.get('1').headers.charset, 'Shift-JIS');</span>
<a href="#l28.595"></a><span id="l28.595" class="difflineplus">+        assert.equal(tree.get('1').headers.get('Content-Description'),</span>
<a href="#l28.596"></a><span id="l28.596" class="difflineplus">+          '\u30b1\u30c4\u30a1\u30eb\u30b3\u30a2\u30c8\u30eb');</span>
<a href="#l28.597"></a><span id="l28.597" class="difflineplus">+      });</span>
<a href="#l28.598"></a><span id="l28.598" class="difflineplus">+    });</span>
<a href="#l28.599"></a><span id="l28.599" class="difflineplus">+    test('Charset conversion', function () {</span>
<a href="#l28.600"></a><span id="l28.600" class="difflineplus">+      return buildTree(read_file('charsets'), {</span>
<a href="#l28.601"></a><span id="l28.601" class="difflineplus">+        strformat: &quot;unicode&quot;,</span>
<a href="#l28.602"></a><span id="l28.602" class="difflineplus">+        bodyformat: &quot;decode&quot;</span>
<a href="#l28.603"></a><span id="l28.603" class="difflineplus">+      }).then(function (tree) {</span>
<a href="#l28.604"></a><span id="l28.604" class="difflineplus">+        var numParts = 12;</span>
<a href="#l28.605"></a><span id="l28.605" class="difflineplus">+        for (var i = 1; i &lt; numParts; i+= 2) {</span>
<a href="#l28.606"></a><span id="l28.606" class="difflineplus">+          assert.equal(tree.get(&quot;&quot; + i).body, tree.get(&quot;&quot; + (i + 1)).body);</span>
<a href="#l28.607"></a><span id="l28.607" class="difflineplus">+        }</span>
<a href="#l28.608"></a><span id="l28.608" class="difflineplus">+        assert.ok(!tree.has(&quot;&quot; + (numParts + 1)));</span>
<a href="#l28.609"></a><span id="l28.609" class="difflineplus">+      });</span>
<a href="#l28.610"></a><span id="l28.610" class="difflineplus">+    });</span>
<a href="#l28.611"></a><span id="l28.611" class="difflineplus">+  });</span>
<a href="#l28.612"></a><span id="l28.612" class="difflineplus">+});</span>
<a href="#l28.613"></a><span id="l28.613" class="difflineplus">+</span>
<a href="#l28.614"></a><span id="l28.614" class="difflineplus">+});</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1">new file mode 100644</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineminus">--- /dev/null</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/test_structured_header_emitters.js</span>
<a href="#l29.4"></a><span id="l29.4" class="difflineat">@@ -0,0 +1,81 @@</span>
<a href="#l29.5"></a><span id="l29.5" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l29.6"></a><span id="l29.6" class="difflineplus">+define(function (require) {</span>
<a href="#l29.7"></a><span id="l29.7" class="difflineplus">+</span>
<a href="#l29.8"></a><span id="l29.8" class="difflineplus">+var assert = require('assert');</span>
<a href="#l29.9"></a><span id="l29.9" class="difflineplus">+var headeremitter = require('jsmime').headeremitter;</span>
<a href="#l29.10"></a><span id="l29.10" class="difflineplus">+</span>
<a href="#l29.11"></a><span id="l29.11" class="difflineplus">+function arrayTest(data, fn) {</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineplus">+  fn.toString = function () {</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+    let text = Function.prototype.toString.call(this);</span>
<a href="#l29.14"></a><span id="l29.14" class="difflineplus">+    text = text.replace(/data\[([0-9]*)\]/g, function (m, p) {</span>
<a href="#l29.15"></a><span id="l29.15" class="difflineplus">+      return JSON.stringify(data[p]);</span>
<a href="#l29.16"></a><span id="l29.16" class="difflineplus">+    });</span>
<a href="#l29.17"></a><span id="l29.17" class="difflineplus">+    return text;</span>
<a href="#l29.18"></a><span id="l29.18" class="difflineplus">+  };</span>
<a href="#l29.19"></a><span id="l29.19" class="difflineplus">+  return test(JSON.stringify(data[0]), fn);</span>
<a href="#l29.20"></a><span id="l29.20" class="difflineplus">+}</span>
<a href="#l29.21"></a><span id="l29.21" class="difflineplus">+</span>
<a href="#l29.22"></a><span id="l29.22" class="difflineplus">+function testHeader(header, tests) {</span>
<a href="#l29.23"></a><span id="l29.23" class="difflineplus">+  suite(header, function () {</span>
<a href="#l29.24"></a><span id="l29.24" class="difflineplus">+    tests.forEach(function (data) {</span>
<a href="#l29.25"></a><span id="l29.25" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l29.26"></a><span id="l29.26" class="difflineplus">+        assert.deepEqual(headeremitter.emitStructuredHeader(header,</span>
<a href="#l29.27"></a><span id="l29.27" class="difflineplus">+          data[0], {softMargin: 100, useASCII: true}),</span>
<a href="#l29.28"></a><span id="l29.28" class="difflineplus">+          (header + &quot;: &quot; + data[1]).trim() + '\r\n');</span>
<a href="#l29.29"></a><span id="l29.29" class="difflineplus">+      });</span>
<a href="#l29.30"></a><span id="l29.30" class="difflineplus">+    });</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineplus">+  });</span>
<a href="#l29.32"></a><span id="l29.32" class="difflineplus">+}</span>
<a href="#l29.33"></a><span id="l29.33" class="difflineplus">+</span>
<a href="#l29.34"></a><span id="l29.34" class="difflineplus">+suite('Structured header emitters', function () {</span>
<a href="#l29.35"></a><span id="l29.35" class="difflineplus">+  // Ad-hoc header tests</span>
<a href="#l29.36"></a><span id="l29.36" class="difflineplus">+  // TODO: add structured encoder tests for Content-Type when it is added.</span>
<a href="#l29.37"></a><span id="l29.37" class="difflineplus">+</span>
<a href="#l29.38"></a><span id="l29.38" class="difflineplus">+  testHeader(&quot;Content-Transfer-Encoding&quot;, [</span>
<a href="#l29.39"></a><span id="l29.39" class="difflineplus">+    [&quot;&quot;, &quot;&quot;],</span>
<a href="#l29.40"></a><span id="l29.40" class="difflineplus">+    [&quot;8bit&quot;, &quot;8bit&quot;],</span>
<a href="#l29.41"></a><span id="l29.41" class="difflineplus">+    [&quot;invalid&quot;, &quot;invalid&quot;]</span>
<a href="#l29.42"></a><span id="l29.42" class="difflineplus">+  ]);</span>
<a href="#l29.43"></a><span id="l29.43" class="difflineplus">+</span>
<a href="#l29.44"></a><span id="l29.44" class="difflineplus">+  // Non-ad-hoc header tests</span>
<a href="#l29.45"></a><span id="l29.45" class="difflineplus">+  let addressing_headers = ['From', 'To', 'Cc', 'Bcc', 'Sender', 'Reply-To',</span>
<a href="#l29.46"></a><span id="l29.46" class="difflineplus">+    'Resent-Bcc', 'Resent-To', 'Resent-From', 'Resent-Cc', 'Resent-Sender',</span>
<a href="#l29.47"></a><span id="l29.47" class="difflineplus">+    'Approved', 'Disposition-Notification-To', 'Delivered-To',</span>
<a href="#l29.48"></a><span id="l29.48" class="difflineplus">+    'Return-Receipt-To'];</span>
<a href="#l29.49"></a><span id="l29.49" class="difflineplus">+  let address_tests = [</span>
<a href="#l29.50"></a><span id="l29.50" class="difflineplus">+    [{name: &quot;&quot;, email: &quot;&quot;}, &quot;&quot;],</span>
<a href="#l29.51"></a><span id="l29.51" class="difflineplus">+    [{name: &quot;John Doe&quot;, email: &quot;john.doe@test.invalid&quot;},</span>
<a href="#l29.52"></a><span id="l29.52" class="difflineplus">+      &quot;John Doe &lt;john.doe@test.invalid&gt;&quot;],</span>
<a href="#l29.53"></a><span id="l29.53" class="difflineplus">+    [[{name: &quot;John Doe&quot;, email: &quot;john.doe@test.invalid&quot;}],</span>
<a href="#l29.54"></a><span id="l29.54" class="difflineplus">+      &quot;John Doe &lt;john.doe@test.invalid&gt;&quot;],</span>
<a href="#l29.55"></a><span id="l29.55" class="difflineplus">+    [{name: &quot;undisclosed-recipients&quot;, group: []},</span>
<a href="#l29.56"></a><span id="l29.56" class="difflineplus">+      &quot;undisclosed-recipients: ;&quot;],</span>
<a href="#l29.57"></a><span id="l29.57" class="difflineplus">+  ];</span>
<a href="#l29.58"></a><span id="l29.58" class="difflineplus">+  addressing_headers.forEach(function (header) {</span>
<a href="#l29.59"></a><span id="l29.59" class="difflineplus">+    testHeader(header, address_tests);</span>
<a href="#l29.60"></a><span id="l29.60" class="difflineplus">+  });</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineplus">+</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineplus">+  let unstructured_headers = ['Comments', 'Content-Description', 'Keywords',</span>
<a href="#l29.63"></a><span id="l29.63" class="difflineplus">+    'Subject'];</span>
<a href="#l29.64"></a><span id="l29.64" class="difflineplus">+  let unstructured_tests = [</span>
<a href="#l29.65"></a><span id="l29.65" class="difflineplus">+    [&quot;&quot;, &quot;&quot;],</span>
<a href="#l29.66"></a><span id="l29.66" class="difflineplus">+    [&quot;This is a subject&quot;, &quot;This is a subject&quot;],</span>
<a href="#l29.67"></a><span id="l29.67" class="difflineplus">+    [&quot;\u79c1\u306f\u4ef6\u540d\u5348\u524d&quot;,</span>
<a href="#l29.68"></a><span id="l29.68" class="difflineplus">+      &quot;=?UTF-8?B?56eB44Gv5Lu25ZCN5Y2I5YmN?=&quot;],</span>
<a href="#l29.69"></a><span id="l29.69" class="difflineplus">+  ];</span>
<a href="#l29.70"></a><span id="l29.70" class="difflineplus">+  unstructured_headers.forEach(function (header) {</span>
<a href="#l29.71"></a><span id="l29.71" class="difflineplus">+    testHeader(header, unstructured_tests);</span>
<a href="#l29.72"></a><span id="l29.72" class="difflineplus">+  });</span>
<a href="#l29.73"></a><span id="l29.73" class="difflineplus">+</span>
<a href="#l29.74"></a><span id="l29.74" class="difflineplus">+  test('emitStructuredHeaders', function () {</span>
<a href="#l29.75"></a><span id="l29.75" class="difflineplus">+    let headers = new Map();</span>
<a href="#l29.76"></a><span id="l29.76" class="difflineplus">+    headers.set('From', [{name:'', email: 'bugzilla-daemon@mozilla.org'}]);</span>
<a href="#l29.77"></a><span id="l29.77" class="difflineplus">+    headers.set('subject', ['[Bug 939557] browsercomps.dll failed to build']);</span>
<a href="#l29.78"></a><span id="l29.78" class="difflineplus">+    let str = headeremitter.emitStructuredHeaders(headers, {});</span>
<a href="#l29.79"></a><span id="l29.79" class="difflineplus">+    assert.equal(str,</span>
<a href="#l29.80"></a><span id="l29.80" class="difflineplus">+      'From: bugzilla-daemon@mozilla.org\r\n' +</span>
<a href="#l29.81"></a><span id="l29.81" class="difflineplus">+      'Subject: [Bug 939557] browsercomps.dll failed to build\r\n');</span>
<a href="#l29.82"></a><span id="l29.82" class="difflineplus">+  });</span>
<a href="#l29.83"></a><span id="l29.83" class="difflineplus">+});</span>
<a href="#l29.84"></a><span id="l29.84" class="difflineplus">+</span>
<a href="#l29.85"></a><span id="l29.85" class="difflineplus">+});</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1">new file mode 100644</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineminus">--- /dev/null</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/test_structured_headers.js</span>
<a href="#l30.4"></a><span id="l30.4" class="difflineat">@@ -0,0 +1,144 @@</span>
<a href="#l30.5"></a><span id="l30.5" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l30.6"></a><span id="l30.6" class="difflineplus">+define(function (require) {</span>
<a href="#l30.7"></a><span id="l30.7" class="difflineplus">+</span>
<a href="#l30.8"></a><span id="l30.8" class="difflineplus">+var assert = require('assert');</span>
<a href="#l30.9"></a><span id="l30.9" class="difflineplus">+var headerparser = require('jsmime').headerparser;</span>
<a href="#l30.10"></a><span id="l30.10" class="difflineplus">+</span>
<a href="#l30.11"></a><span id="l30.11" class="difflineplus">+function smartDeepEqual(actual, expected) {</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineplus">+  assert.deepEqual(actual, expected);</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+  if (actual instanceof Map &amp;&amp; expected instanceof Map) {</span>
<a href="#l30.14"></a><span id="l30.14" class="difflineplus">+    assert.deepEqual([x for (x of actual.entries())],</span>
<a href="#l30.15"></a><span id="l30.15" class="difflineplus">+      [y for (y of expected.entries())]);</span>
<a href="#l30.16"></a><span id="l30.16" class="difflineplus">+  }</span>
<a href="#l30.17"></a><span id="l30.17" class="difflineplus">+}</span>
<a href="#l30.18"></a><span id="l30.18" class="difflineplus">+</span>
<a href="#l30.19"></a><span id="l30.19" class="difflineplus">+function arrayTest(data, fn) {</span>
<a href="#l30.20"></a><span id="l30.20" class="difflineplus">+  fn.toString = function () {</span>
<a href="#l30.21"></a><span id="l30.21" class="difflineplus">+    let text = Function.prototype.toString.call(this);</span>
<a href="#l30.22"></a><span id="l30.22" class="difflineplus">+    text = text.replace(/data\[([0-9]*)\]/g, function (m, p) {</span>
<a href="#l30.23"></a><span id="l30.23" class="difflineplus">+      return JSON.stringify(data[p]);</span>
<a href="#l30.24"></a><span id="l30.24" class="difflineplus">+    });</span>
<a href="#l30.25"></a><span id="l30.25" class="difflineplus">+    return text;</span>
<a href="#l30.26"></a><span id="l30.26" class="difflineplus">+  };</span>
<a href="#l30.27"></a><span id="l30.27" class="difflineplus">+  return test(data[0], fn);</span>
<a href="#l30.28"></a><span id="l30.28" class="difflineplus">+}</span>
<a href="#l30.29"></a><span id="l30.29" class="difflineplus">+</span>
<a href="#l30.30"></a><span id="l30.30" class="difflineplus">+function testHeader(header, tests) {</span>
<a href="#l30.31"></a><span id="l30.31" class="difflineplus">+  suite(header, function () {</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineplus">+    tests.forEach(function (data) {</span>
<a href="#l30.33"></a><span id="l30.33" class="difflineplus">+      arrayTest(data, function () {</span>
<a href="#l30.34"></a><span id="l30.34" class="difflineplus">+        smartDeepEqual(headerparser.parseStructuredHeader(header,</span>
<a href="#l30.35"></a><span id="l30.35" class="difflineplus">+          data[0]), data[1]);</span>
<a href="#l30.36"></a><span id="l30.36" class="difflineplus">+      });</span>
<a href="#l30.37"></a><span id="l30.37" class="difflineplus">+    });</span>
<a href="#l30.38"></a><span id="l30.38" class="difflineplus">+  });</span>
<a href="#l30.39"></a><span id="l30.39" class="difflineplus">+}</span>
<a href="#l30.40"></a><span id="l30.40" class="difflineplus">+</span>
<a href="#l30.41"></a><span id="l30.41" class="difflineplus">+function makeCT(media, sub, params) {</span>
<a href="#l30.42"></a><span id="l30.42" class="difflineplus">+  var object = new Map();</span>
<a href="#l30.43"></a><span id="l30.43" class="difflineplus">+  object.mediatype = media;</span>
<a href="#l30.44"></a><span id="l30.44" class="difflineplus">+  object.subtype = sub;</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineplus">+  object.type = media + &quot;/&quot; + sub;</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineplus">+  for (let k in params)</span>
<a href="#l30.47"></a><span id="l30.47" class="difflineplus">+    object.set(k, params[k]);</span>
<a href="#l30.48"></a><span id="l30.48" class="difflineplus">+  return object;</span>
<a href="#l30.49"></a><span id="l30.49" class="difflineplus">+}</span>
<a href="#l30.50"></a><span id="l30.50" class="difflineplus">+suite('Structured headers', function () {</span>
<a href="#l30.51"></a><span id="l30.51" class="difflineplus">+  // Ad-hoc header tests</span>
<a href="#l30.52"></a><span id="l30.52" class="difflineplus">+  testHeader('Content-Type', [</span>
<a href="#l30.53"></a><span id="l30.53" class="difflineplus">+    ['text/plain', makeCT(&quot;text&quot;, &quot;plain&quot;, {})],</span>
<a href="#l30.54"></a><span id="l30.54" class="difflineplus">+    ['text/html', makeCT(&quot;text&quot;, &quot;html&quot;, {})],</span>
<a href="#l30.55"></a><span id="l30.55" class="difflineplus">+    ['text/plain; charset=&quot;UTF-8&quot;',</span>
<a href="#l30.56"></a><span id="l30.56" class="difflineplus">+      makeCT(&quot;text&quot;, &quot;plain&quot;, {charset: &quot;UTF-8&quot;})],</span>
<a href="#l30.57"></a><span id="l30.57" class="difflineplus">+    ['text/', makeCT(&quot;text&quot;, &quot;&quot;, {})],</span>
<a href="#l30.58"></a><span id="l30.58" class="difflineplus">+    ['text', makeCT(&quot;text&quot;, &quot;plain&quot;, {})],</span>
<a href="#l30.59"></a><span id="l30.59" class="difflineplus">+    ['image/', makeCT(&quot;image&quot;, &quot;&quot;, {})],</span>
<a href="#l30.60"></a><span id="l30.60" class="difflineplus">+    ['image', makeCT(&quot;text&quot;, &quot;plain&quot;, {})],</span>
<a href="#l30.61"></a><span id="l30.61" class="difflineplus">+    ['hacker/x-mailnews', makeCT(&quot;hacker&quot;, &quot;x-mailnews&quot;, {})],</span>
<a href="#l30.62"></a><span id="l30.62" class="difflineplus">+    ['hacker/x-mailnews;', makeCT(&quot;hacker&quot;, &quot;x-mailnews&quot;, {})],</span>
<a href="#l30.63"></a><span id="l30.63" class="difflineplus">+    ['HACKER/X-MAILNEWS', makeCT(&quot;hacker&quot;, &quot;x-mailnews&quot;, {})],</span>
<a href="#l30.64"></a><span id="l30.64" class="difflineplus">+    ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',</span>
<a href="#l30.65"></a><span id="l30.65" class="difflineplus">+      makeCT(&quot;application&quot;,</span>
<a href="#l30.66"></a><span id="l30.66" class="difflineplus">+      &quot;vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;, {})],</span>
<a href="#l30.67"></a><span id="l30.67" class="difflineplus">+    ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;\r' +</span>
<a href="#l30.68"></a><span id="l30.68" class="difflineplus">+      '\n name=&quot;Presentation.pptx&quot;',</span>
<a href="#l30.69"></a><span id="l30.69" class="difflineplus">+      makeCT(&quot;application&quot;,</span>
<a href="#l30.70"></a><span id="l30.70" class="difflineplus">+      &quot;vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;,</span>
<a href="#l30.71"></a><span id="l30.71" class="difflineplus">+      {name: &quot;Presentation.pptx&quot;})],</span>
<a href="#l30.72"></a><span id="l30.72" class="difflineplus">+    ['', makeCT(&quot;text&quot;, &quot;plain&quot;, {})],</span>
<a href="#l30.73"></a><span id="l30.73" class="difflineplus">+    ['                                        ', makeCT(&quot;text&quot;, &quot;plain&quot;, {})],</span>
<a href="#l30.74"></a><span id="l30.74" class="difflineplus">+    ['text/plain; c', makeCT(&quot;text&quot;, &quot;plain&quot;, {})],</span>
<a href="#l30.75"></a><span id="l30.75" class="difflineplus">+    ['text/plain; charset=', makeCT(&quot;text&quot;, &quot;plain&quot;, {charset: &quot;&quot;})],</span>
<a href="#l30.76"></a><span id="l30.76" class="difflineplus">+    ['text/plain; charset=&quot;', makeCT(&quot;text&quot;, &quot;plain&quot;, {charset: &quot;&quot;})],</span>
<a href="#l30.77"></a><span id="l30.77" class="difflineplus">+    ['text\\/enriched', makeCT(&quot;text\\&quot;, &quot;enriched&quot;, {})],</span>
<a href="#l30.78"></a><span id="l30.78" class="difflineplus">+    ['multipart/mixed &quot;;&quot; wtf=stupid', makeCT(&quot;multipart&quot;, &quot;mixed&quot;, {})],</span>
<a href="#l30.79"></a><span id="l30.79" class="difflineplus">+    ['multipart/mixed; wtf=stupid',</span>
<a href="#l30.80"></a><span id="l30.80" class="difflineplus">+      makeCT(&quot;multipart&quot;, &quot;mixed&quot;, {wtf: &quot;stupid&quot;})],</span>
<a href="#l30.81"></a><span id="l30.81" class="difflineplus">+    ['text/plain; CHARSET=Big5', makeCT(&quot;text&quot;, &quot;plain&quot;, {charset: &quot;Big5&quot;})],</span>
<a href="#l30.82"></a><span id="l30.82" class="difflineplus">+    ['text/html; CHARSET=&quot;Big5&quot;', makeCT(&quot;text&quot;, &quot;html&quot;, {charset: &quot;Big5&quot;})],</span>
<a href="#l30.83"></a><span id="l30.83" class="difflineplus">+    ['text/html; CHARSET=&quot;Big5', makeCT(&quot;text&quot;, &quot;html&quot;, {charset: &quot;Big5&quot;})],</span>
<a href="#l30.84"></a><span id="l30.84" class="difflineplus">+    [['text/html', 'multipart/mixed'], makeCT(&quot;text&quot;, &quot;html&quot;, {})],</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineplus">+  ]);</span>
<a href="#l30.86"></a><span id="l30.86" class="difflineplus">+  testHeader('Content-Transfer-Encoding', [</span>
<a href="#l30.87"></a><span id="l30.87" class="difflineplus">+    ['', ''],</span>
<a href="#l30.88"></a><span id="l30.88" class="difflineplus">+    ['8bit', '8bit'],</span>
<a href="#l30.89"></a><span id="l30.89" class="difflineplus">+    ['8BIT', '8bit'],</span>
<a href="#l30.90"></a><span id="l30.90" class="difflineplus">+    ['QuOtEd-PrInTaBlE', 'quoted-printable'],</span>
<a href="#l30.91"></a><span id="l30.91" class="difflineplus">+    ['Base64', 'base64'],</span>
<a href="#l30.92"></a><span id="l30.92" class="difflineplus">+    ['7bit', '7bit'],</span>
<a href="#l30.93"></a><span id="l30.93" class="difflineplus">+    [['7bit', '8bit'], '7bit'],</span>
<a href="#l30.94"></a><span id="l30.94" class="difflineplus">+    ['x-uuencode', 'x-uuencode']</span>
<a href="#l30.95"></a><span id="l30.95" class="difflineplus">+  ]);</span>
<a href="#l30.96"></a><span id="l30.96" class="difflineplus">+</span>
<a href="#l30.97"></a><span id="l30.97" class="difflineplus">+  // Non-ad-hoc header tests</span>
<a href="#l30.98"></a><span id="l30.98" class="difflineplus">+  let addressing_headers = ['From', 'To', 'Cc', 'Bcc', 'Sender', 'Reply-To',</span>
<a href="#l30.99"></a><span id="l30.99" class="difflineplus">+    'Resent-Bcc', 'Resent-To', 'Resent-From', 'Resent-Cc', 'Resent-Sender',</span>
<a href="#l30.100"></a><span id="l30.100" class="difflineplus">+    'Approved', 'Disposition-Notification-To', 'Delivered-To',</span>
<a href="#l30.101"></a><span id="l30.101" class="difflineplus">+    'Return-Receipt-To'];</span>
<a href="#l30.102"></a><span id="l30.102" class="difflineplus">+  let address_tests = [</span>
<a href="#l30.103"></a><span id="l30.103" class="difflineplus">+    [&quot;&quot;, []],</span>
<a href="#l30.104"></a><span id="l30.104" class="difflineplus">+    [&quot;a@example.invalid&quot;, [{name: &quot;&quot;, email: &quot;a@example.invalid&quot;}]],</span>
<a href="#l30.105"></a><span id="l30.105" class="difflineplus">+    [&quot;John Doe &lt;a@example.invalid&gt;&quot;,</span>
<a href="#l30.106"></a><span id="l30.106" class="difflineplus">+      [{name: &quot;John Doe&quot;, email: &quot;a@example.invalid&quot;}]],</span>
<a href="#l30.107"></a><span id="l30.107" class="difflineplus">+    [&quot;John Doe &lt;A@EXAMPLE.INVALID&gt;&quot;,</span>
<a href="#l30.108"></a><span id="l30.108" class="difflineplus">+      [{name: &quot;John Doe&quot;, email: &quot;A@EXAMPLE.INVALID&quot;}]],</span>
<a href="#l30.109"></a><span id="l30.109" class="difflineplus">+    [&quot;=?UTF-8?B?5bGx55Sw5aSq6YOO?= &lt;a@example.invalid&gt;&quot;,</span>
<a href="#l30.110"></a><span id="l30.110" class="difflineplus">+      [{name: &quot;\u5c71\u7530\u592a\u90ce&quot;, email: &quot;a@example.invalid&quot;}]],</span>
<a href="#l30.111"></a><span id="l30.111" class="difflineplus">+    [&quot;undisclosed-recipients:;&quot;, [{name: &quot;undisclosed-recipients&quot;, group: []}]],</span>
<a href="#l30.112"></a><span id="l30.112" class="difflineplus">+    [&quot;world: a@example.invalid, b@example.invalid;&quot;,</span>
<a href="#l30.113"></a><span id="l30.113" class="difflineplus">+      [{name: &quot;world&quot;, group: [</span>
<a href="#l30.114"></a><span id="l30.114" class="difflineplus">+        {name: &quot;&quot;, email: &quot;a@example.invalid&quot;},</span>
<a href="#l30.115"></a><span id="l30.115" class="difflineplus">+        {name: &quot;&quot;, email: &quot;b@example.invalid&quot;}</span>
<a href="#l30.116"></a><span id="l30.116" class="difflineplus">+      ]}]],</span>
<a href="#l30.117"></a><span id="l30.117" class="difflineplus">+    // TODO when we support IDN:</span>
<a href="#l30.118"></a><span id="l30.118" class="difflineplus">+    // This should be \u4f8b.invalid instead (Japanese kanji for &quot;example&quot;)</span>
<a href="#l30.119"></a><span id="l30.119" class="difflineplus">+    [&quot;\u5c71\u7530\u592a\u90ce &lt;a@xn--fsq.invalid&gt;&quot;,</span>
<a href="#l30.120"></a><span id="l30.120" class="difflineplus">+      [{name: &quot;\u5c71\u7530\u592a\u90ce&quot;, email: &quot;a@xn--fsq.invalid&quot;}]],</span>
<a href="#l30.121"></a><span id="l30.121" class="difflineplus">+    [&quot;\u5c71\u7530\u592a\u90ce &lt;a@\u4f8b.invalid&gt;&quot;,</span>
<a href="#l30.122"></a><span id="l30.122" class="difflineplus">+      [{name: &quot;\u5c71\u7530\u592a\u90ce&quot;, email: &quot;a@\u4f8b.invalid&quot;}]],</span>
<a href="#l30.123"></a><span id="l30.123" class="difflineplus">+    [&quot;\u30b1\u30c4\u30a1\u30eb\u30b3\u30a2\u30c8\u30eb@\u4f8b.invalid&quot;,</span>
<a href="#l30.124"></a><span id="l30.124" class="difflineplus">+      [{name: &quot;&quot;, email:</span>
<a href="#l30.125"></a><span id="l30.125" class="difflineplus">+         &quot;\u30b1\u30c4\u30a1\u30eb\u30b3\u30a2\u30c8\u30eb@\u4f8b.invalid&quot;}]],</span>
<a href="#l30.126"></a><span id="l30.126" class="difflineplus">+    [[&quot;a@example.invalid&quot;, &quot;b@example.invalid&quot;],</span>
<a href="#l30.127"></a><span id="l30.127" class="difflineplus">+      [{name: &quot;&quot;, email: &quot;a@example.invalid&quot;},</span>
<a href="#l30.128"></a><span id="l30.128" class="difflineplus">+       {name: &quot;&quot;, email: &quot;b@example.invalid&quot;}]],</span>
<a href="#l30.129"></a><span id="l30.129" class="difflineplus">+  ];</span>
<a href="#l30.130"></a><span id="l30.130" class="difflineplus">+  addressing_headers.forEach(function (header) {</span>
<a href="#l30.131"></a><span id="l30.131" class="difflineplus">+    testHeader(header, address_tests);</span>
<a href="#l30.132"></a><span id="l30.132" class="difflineplus">+  });</span>
<a href="#l30.133"></a><span id="l30.133" class="difflineplus">+</span>
<a href="#l30.134"></a><span id="l30.134" class="difflineplus">+  let unstructured_headers = ['Comments', 'Content-Description', 'Keywords',</span>
<a href="#l30.135"></a><span id="l30.135" class="difflineplus">+    'Subject'];</span>
<a href="#l30.136"></a><span id="l30.136" class="difflineplus">+  let unstructured_tests = [</span>
<a href="#l30.137"></a><span id="l30.137" class="difflineplus">+    [&quot;&quot;, &quot;&quot;],</span>
<a href="#l30.138"></a><span id="l30.138" class="difflineplus">+    [&quot;This is a subject&quot;, &quot;This is a subject&quot;],</span>
<a href="#l30.139"></a><span id="l30.139" class="difflineplus">+    [[&quot;Subject 1&quot;, &quot;Subject 2&quot;], &quot;Subject 1&quot;],</span>
<a href="#l30.140"></a><span id="l30.140" class="difflineplus">+    [&quot;=?UTF-8?B?56eB44Gv5Lu25ZCN5Y2I5YmN?=&quot;,</span>
<a href="#l30.141"></a><span id="l30.141" class="difflineplus">+      &quot;\u79c1\u306f\u4ef6\u540d\u5348\u524d&quot;],</span>
<a href="#l30.142"></a><span id="l30.142" class="difflineplus">+  ];</span>
<a href="#l30.143"></a><span id="l30.143" class="difflineplus">+  unstructured_headers.forEach(function (header) {</span>
<a href="#l30.144"></a><span id="l30.144" class="difflineplus">+    testHeader(header, unstructured_tests);</span>
<a href="#l30.145"></a><span id="l30.145" class="difflineplus">+  });</span>
<a href="#l30.146"></a><span id="l30.146" class="difflineplus">+});</span>
<a href="#l30.147"></a><span id="l30.147" class="difflineplus">+</span>
<a href="#l30.148"></a><span id="l30.148" class="difflineplus">+});</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1">new file mode 100644</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineminus">--- /dev/null</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineplus">+++ b/mailnews/mime/jsmime/test/xpcshell.ini</span>
<a href="#l31.4"></a><span id="l31.4" class="difflineat">@@ -0,0 +1,11 @@</span>
<a href="#l31.5"></a><span id="l31.5" class="difflineplus">+[DEFAULT]</span>
<a href="#l31.6"></a><span id="l31.6" class="difflineplus">+head=head_xpcshell_glue.js</span>
<a href="#l31.7"></a><span id="l31.7" class="difflineplus">+tail=</span>
<a href="#l31.8"></a><span id="l31.8" class="difflineplus">+support-files=data/**</span>
<a href="#l31.9"></a><span id="l31.9" class="difflineplus">+</span>
<a href="#l31.10"></a><span id="l31.10" class="difflineplus">+[test_custom_headers.js]</span>
<a href="#l31.11"></a><span id="l31.11" class="difflineplus">+[test_header_emitter.js]</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineplus">+[test_header.js]</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+[test_mime_tree.js]</span>
<a href="#l31.14"></a><span id="l31.14" class="difflineplus">+[test_structured_header_emitters.js]</span>
<a href="#l31.15"></a><span id="l31.15" class="difflineplus">+[test_structured_headers.js]</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/mailnews/mime/moz.build</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/mailnews/mime/moz.build</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -8,13 +8,14 @@ PARALLEL_DIRS += [</span>
<a href="#l32.4"></a><span id="l32.4">     'src',</span>
<a href="#l32.5"></a><span id="l32.5">     'emitters',</span>
<a href="#l32.6"></a><span id="l32.6">     'cthandlers',</span>
<a href="#l32.7"></a><span id="l32.7"> ]</span>
<a href="#l32.8"></a><span id="l32.8"> </span>
<a href="#l32.9"></a><span id="l32.9"> TEST_DIRS += ['test']</span>
<a href="#l32.10"></a><span id="l32.10"> </span>
<a href="#l32.11"></a><span id="l32.11"> EXTRA_JS_MODULES += [</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-    'jsmime/mimeParserCore.js',</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+    'jsmime/jsmime.js',</span>
<a href="#l32.14"></a><span id="l32.14"> ]</span>
<a href="#l32.15"></a><span id="l32.15"> </span>
<a href="#l32.16"></a><span id="l32.16" class="difflineminus">-JS_MODULES_PATH = 'modules/mime'</span>
<a href="#l32.17"></a><span id="l32.17" class="difflineplus">+JS_MODULES_PATH = 'modules/jsmime'</span>
<a href="#l32.18"></a><span id="l32.18"> </span>
<a href="#l32.19"></a><span id="l32.19" class="difflineplus">+XPCSHELL_TESTS_MANIFESTS += ['jsmime/test/xpcshell.ini']</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1">new file mode 100644</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineminus">--- /dev/null</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineplus">+++ b/mailnews/mime/src/jsmime.jsm</span>
<a href="#l33.4"></a><span id="l33.4" class="difflineat">@@ -0,0 +1,24 @@</span>
<a href="#l33.5"></a><span id="l33.5" class="difflineplus">+/* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l33.6"></a><span id="l33.6" class="difflineplus">+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,</span>
<a href="#l33.7"></a><span id="l33.7" class="difflineplus">+ * You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l33.8"></a><span id="l33.8" class="difflineplus">+// vim:set ts=2 sw=2 sts=2 et ft=javascript:</span>
<a href="#l33.9"></a><span id="l33.9" class="difflineplus">+</span>
<a href="#l33.10"></a><span id="l33.10" class="difflineplus">+Components.utils.import(&quot;resource:///modules/Services.jsm&quot;);</span>
<a href="#l33.11"></a><span id="l33.11" class="difflineplus">+</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineplus">+/**</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+ * This file exports the JSMime code, polyfilling code as appropriate for use in</span>
<a href="#l33.14"></a><span id="l33.14" class="difflineplus">+ * Gecko.</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineplus">+ */</span>
<a href="#l33.16"></a><span id="l33.16" class="difflineplus">+</span>
<a href="#l33.17"></a><span id="l33.17" class="difflineplus">+// Load the core MIME parser. Since it doesn't define EXPORTED_SYMBOLS, we must</span>
<a href="#l33.18"></a><span id="l33.18" class="difflineplus">+// use the subscript loader instead.</span>
<a href="#l33.19"></a><span id="l33.19" class="difflineplus">+Services.scriptloader.loadSubScript(&quot;resource:///modules/jsmime/jsmime.js&quot;);</span>
<a href="#l33.20"></a><span id="l33.20" class="difflineplus">+</span>
<a href="#l33.21"></a><span id="l33.21" class="difflineplus">+var EXPORTED_SYMBOLS = [&quot;jsmime&quot;];</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineplus">+</span>
<a href="#l33.23"></a><span id="l33.23" class="difflineplus">+// Note: JSMime 0.2 doesn't require any polyfilling for the moment, which means</span>
<a href="#l33.24"></a><span id="l33.24" class="difflineplus">+// this code looks empty. However, it is anticipated that future code will need</span>
<a href="#l33.25"></a><span id="l33.25" class="difflineplus">+// some amount of polyfilling (supporting non-UTF-8 encodings in TextEncoder for</span>
<a href="#l33.26"></a><span id="l33.26" class="difflineplus">+// composition code is the most prominent example). Since I want people to start</span>
<a href="#l33.27"></a><span id="l33.27" class="difflineplus">+// out doing the right thing, I'm defining jsmime.jsm before there's a real need</span>
<a href="#l33.28"></a><span id="l33.28" class="difflineplus">+// for it.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/mailnews/mime/src/mimeJSComponents.js</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/mailnews/mime/src/mimeJSComponents.js</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -19,17 +19,17 @@ MimeHeaders.prototype = {</span>
<a href="#l34.4"></a><span id="l34.4"> </span>
<a href="#l34.5"></a><span id="l34.5">   extractHeader: function MimeHeaders_extractHeader(header, getAll) {</span>
<a href="#l34.6"></a><span id="l34.6">     if (!this._headers)</span>
<a href="#l34.7"></a><span id="l34.7">       throw Components.results.NS_ERROR_NOT_INITIALIZED;</span>
<a href="#l34.8"></a><span id="l34.8">     // Canonicalized to lower-case form</span>
<a href="#l34.9"></a><span id="l34.9">     header = header.toLowerCase();</span>
<a href="#l34.10"></a><span id="l34.10">     if (!this._headers.has(header))</span>
<a href="#l34.11"></a><span id="l34.11">       return null;</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-    var values = this._headers.get(header);</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+    var values = this._headers.getRawHeader(header);</span>
<a href="#l34.14"></a><span id="l34.14">     if (getAll)</span>
<a href="#l34.15"></a><span id="l34.15">       return values.join(&quot;,\r\n\t&quot;);</span>
<a href="#l34.16"></a><span id="l34.16">     else</span>
<a href="#l34.17"></a><span id="l34.17">       return values[0];</span>
<a href="#l34.18"></a><span id="l34.18">   },</span>
<a href="#l34.19"></a><span id="l34.19"> </span>
<a href="#l34.20"></a><span id="l34.20">   get allHeaders() {</span>
<a href="#l34.21"></a><span id="l34.21">     return this._headers.rawHeaderText;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1">rename from mailnews/mime/jsmime/mimeParser.jsm</span>
<a href="#l35.2"></a><span id="l35.2">rename to mailnews/mime/src/mimeParser.jsm</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineminus">--- a/mailnews/mime/jsmime/mimeParser.jsm</span>
<a href="#l35.4"></a><span id="l35.4" class="difflineplus">+++ b/mailnews/mime/src/mimeParser.jsm</span>
<a href="#l35.5"></a><span id="l35.5" class="difflineat">@@ -1,19 +1,16 @@</span>
<a href="#l35.6"></a><span id="l35.6"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l35.7"></a><span id="l35.7">  * License, v. 2.0. If a copy of the MPL was not distributed with this file,</span>
<a href="#l35.8"></a><span id="l35.8">  * You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l35.9"></a><span id="l35.9"> // vim:set ts=2 sw=2 sts=2 et ft=javascript:</span>
<a href="#l35.10"></a><span id="l35.10"> </span>
<a href="#l35.11"></a><span id="l35.11"> Components.utils.import(&quot;resource:///modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l35.12"></a><span id="l35.12"> Components.utils.import(&quot;resource:///modules/Services.jsm&quot;);</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineminus">-</span>
<a href="#l35.14"></a><span id="l35.14" class="difflineminus">-// Load the core MIME parser. Since it doesn't define EXPORTED_SYMBOLS, we must</span>
<a href="#l35.15"></a><span id="l35.15" class="difflineminus">-// use the subscript loader instead.</span>
<a href="#l35.16"></a><span id="l35.16" class="difflineminus">-Services.scriptloader.loadSubScript(&quot;resource:///modules/mime/mimeParserCore.js&quot;);</span>
<a href="#l35.17"></a><span id="l35.17" class="difflineplus">+Components.utils.import(&quot;resource:///modules/jsmime.jsm&quot;);</span>
<a href="#l35.18"></a><span id="l35.18"> </span>
<a href="#l35.19"></a><span id="l35.19"> var EXPORTED_SYMBOLS = [&quot;MimeParser&quot;];</span>
<a href="#l35.20"></a><span id="l35.20"> </span>
<a href="#l35.21"></a><span id="l35.21"> // Emitter helpers, for internal functions later on.</span>
<a href="#l35.22"></a><span id="l35.22"> var ExtractHeadersEmitter = {</span>
<a href="#l35.23"></a><span id="l35.23">   startPart: function (partNum, headers) {</span>
<a href="#l35.24"></a><span id="l35.24">     if (partNum == '') {</span>
<a href="#l35.25"></a><span id="l35.25">       this.headers = headers;</span>
<a href="#l35.26"></a><span id="l35.26" class="difflineat">@@ -82,17 +79,17 @@ var MimeParser = {</span>
<a href="#l35.27"></a><span id="l35.27">    */</span>
<a href="#l35.28"></a><span id="l35.28">   parseSync: function MimeParser_parseSync(input, emitter, opts) {</span>
<a href="#l35.29"></a><span id="l35.29">     // We only support string parsing if we are trying to do this parse</span>
<a href="#l35.30"></a><span id="l35.30">     // synchronously.</span>
<a href="#l35.31"></a><span id="l35.31">     if (typeof input != &quot;string&quot;) {</span>
<a href="#l35.32"></a><span id="l35.32">       throw new Error(&quot;input is not a recognizable type!&quot;);</span>
<a href="#l35.33"></a><span id="l35.33">     }</span>
<a href="#l35.34"></a><span id="l35.34">     setDefaultParserOptions(opts);</span>
<a href="#l35.35"></a><span id="l35.35" class="difflineminus">-    var parser = new Parser(emitter, opts);</span>
<a href="#l35.36"></a><span id="l35.36" class="difflineplus">+    var parser = new jsmime.MimeParser(emitter, opts);</span>
<a href="#l35.37"></a><span id="l35.37">     parser.deliverData(input);</span>
<a href="#l35.38"></a><span id="l35.38">     parser.deliverEOF();</span>
<a href="#l35.39"></a><span id="l35.39">     return;</span>
<a href="#l35.40"></a><span id="l35.40">   },</span>
<a href="#l35.41"></a><span id="l35.41"> </span>
<a href="#l35.42"></a><span id="l35.42">   /**</span>
<a href="#l35.43"></a><span id="l35.43">    * Returns a stream listener that feeds data into a parser.</span>
<a href="#l35.44"></a><span id="l35.44">    *</span>
<a href="#l35.45"></a><span id="l35.45" class="difflineat">@@ -125,32 +122,32 @@ var MimeParser = {</span>
<a href="#l35.46"></a><span id="l35.46">         scriptIn.init(aStream);</span>
<a href="#l35.47"></a><span id="l35.47">         // Use readBytes instead of read to handle embedded NULs properly.</span>
<a href="#l35.48"></a><span id="l35.48">         this._parser.deliverData(scriptIn.readBytes(aCount));</span>
<a href="#l35.49"></a><span id="l35.49">       },</span>
<a href="#l35.50"></a><span id="l35.50">       QueryInterface: XPCOMUtils.generateQI([Ci.nsIStreamListener,</span>
<a href="#l35.51"></a><span id="l35.51">         Ci.nsIRequestObserver])</span>
<a href="#l35.52"></a><span id="l35.52">     };</span>
<a href="#l35.53"></a><span id="l35.53">     setDefaultParserOptions(opts);</span>
<a href="#l35.54"></a><span id="l35.54" class="difflineminus">-    StreamListener._parser = new Parser(emitter, opts);</span>
<a href="#l35.55"></a><span id="l35.55" class="difflineplus">+    StreamListener._parser = new jsmime.MimeParser(emitter, opts);</span>
<a href="#l35.56"></a><span id="l35.56">     return StreamListener;</span>
<a href="#l35.57"></a><span id="l35.57">   },</span>
<a href="#l35.58"></a><span id="l35.58"> </span>
<a href="#l35.59"></a><span id="l35.59">   /**</span>
<a href="#l35.60"></a><span id="l35.60">    * Returns a new raw MIME parser.</span>
<a href="#l35.61"></a><span id="l35.61">    *</span>
<a href="#l35.62"></a><span id="l35.62">    * Prefer one of the other methods where possible, since the input here must</span>
<a href="#l35.63"></a><span id="l35.63">    * be driven manually.</span>
<a href="#l35.64"></a><span id="l35.64">    *</span>
<a href="#l35.65"></a><span id="l35.65">    * @param emitter The emitter to receive callbacks on.</span>
<a href="#l35.66"></a><span id="l35.66">    * @param opts    A set of options for the parser.</span>
<a href="#l35.67"></a><span id="l35.67">    */</span>
<a href="#l35.68"></a><span id="l35.68">   makeParser: function MimeParser_makeParser(emitter, opts) {</span>
<a href="#l35.69"></a><span id="l35.69">     setDefaultParserOptions(opts);</span>
<a href="#l35.70"></a><span id="l35.70" class="difflineminus">-    return new Parser(emitter, opts);</span>
<a href="#l35.71"></a><span id="l35.71" class="difflineplus">+    return new jsmime.MimeParser(emitter, opts);</span>
<a href="#l35.72"></a><span id="l35.72">   },</span>
<a href="#l35.73"></a><span id="l35.73"> </span>
<a href="#l35.74"></a><span id="l35.74">   /**</span>
<a href="#l35.75"></a><span id="l35.75">    * Returns a dictionary of headers for the given input.</span>
<a href="#l35.76"></a><span id="l35.76">    *</span>
<a href="#l35.77"></a><span id="l35.77">    * The input is any type of input that would be accepted by parseSync. What</span>
<a href="#l35.78"></a><span id="l35.78">    * is returned is a JS object that represents the headers of the entire</span>
<a href="#l35.79"></a><span id="l35.79">    * envelope as would be received by startPart when partNum is the empty</span>
<a href="#l35.80"></a><span id="l35.80" class="difflineat">@@ -206,14 +203,14 @@ var MimeParser = {</span>
<a href="#l35.81"></a><span id="l35.81">    * @param flags   A set of flags that controls interpretation of the header.</span>
<a href="#l35.82"></a><span id="l35.82">    * @param charset A default charset to assume if no information may be found.</span>
<a href="#l35.83"></a><span id="l35.83">    */</span>
<a href="#l35.84"></a><span id="l35.84">   parseHeaderField: function MimeParser_parseHeaderField(text, flags, charset) {</span>
<a href="#l35.85"></a><span id="l35.85">     // The low 4 bits indicate the type of the header we are parsing. All of the</span>
<a href="#l35.86"></a><span id="l35.86">     // higher-order bits are flags.</span>
<a href="#l35.87"></a><span id="l35.87">     switch (flags &amp; 0x0f) {</span>
<a href="#l35.88"></a><span id="l35.88">     case MimeParser.HEADER_PARAMETER:</span>
<a href="#l35.89"></a><span id="l35.89" class="difflineminus">-      return HeaderParser.extractParameters(text);</span>
<a href="#l35.90"></a><span id="l35.90" class="difflineplus">+      return jsmime.headerparser.parseParameterHeader(text, false, false);</span>
<a href="#l35.91"></a><span id="l35.91">     default:</span>
<a href="#l35.92"></a><span id="l35.92">       throw &quot;Illegal type of header field&quot;;</span>
<a href="#l35.93"></a><span id="l35.93">     }</span>
<a href="#l35.94"></a><span id="l35.94">   },</span>
<a href="#l35.95"></a><span id="l35.95"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/mailnews/mime/src/moz.build</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/mailnews/mime/src/moz.build</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -70,11 +70,16 @@ SOURCES += [</span>
<a href="#l36.4"></a><span id="l36.4">     'nsStreamConverter.cpp',</span>
<a href="#l36.5"></a><span id="l36.5"> ]</span>
<a href="#l36.6"></a><span id="l36.6"> </span>
<a href="#l36.7"></a><span id="l36.7"> EXTRA_COMPONENTS += [</span>
<a href="#l36.8"></a><span id="l36.8">     'mimeJSComponents.js',</span>
<a href="#l36.9"></a><span id="l36.9">     'msgMime.manifest',</span>
<a href="#l36.10"></a><span id="l36.10"> ]</span>
<a href="#l36.11"></a><span id="l36.11"> </span>
<a href="#l36.12"></a><span id="l36.12" class="difflineplus">+EXTRA_JS_MODULES += [</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+    'jsmime.jsm',</span>
<a href="#l36.14"></a><span id="l36.14" class="difflineplus">+    'mimeParser.jsm'</span>
<a href="#l36.15"></a><span id="l36.15" class="difflineplus">+]</span>
<a href="#l36.16"></a><span id="l36.16" class="difflineplus">+</span>
<a href="#l36.17"></a><span id="l36.17"> FINAL_LIBRARY = 'mail'</span>
<a href="#l36.18"></a><span id="l36.18"> </span>
<a href="#l36.19"></a><span id="l36.19"> DEFINES['ENABLE_SMIME'] = True</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/mailnews/mime/test/unit/test_parser.js</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/mailnews/mime/test/unit/test_parser.js</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -70,28 +70,18 @@ function read_file(file, start, end) {</span>
<a href="#l37.4"></a><span id="l37.4">  * @param opts     Options for the mime parser, as well as a few extras detailed</span>
<a href="#l37.5"></a><span id="l37.5">  *                 above.</span>
<a href="#l37.6"></a><span id="l37.6">  * @param partspec An array of [partnum, line start, line end] detailing the</span>
<a href="#l37.7"></a><span id="l37.7">  *                 expected parts in the body. It will be expected that the</span>
<a href="#l37.8"></a><span id="l37.8">  *                 accumulated body part data for partnum would be the contents</span>
<a href="#l37.9"></a><span id="l37.9">  *                 of the file from [line start, line end) [1-based lines]</span>
<a href="#l37.10"></a><span id="l37.10">  */</span>
<a href="#l37.11"></a><span id="l37.11"> function make_body_test(test, file, opts, partspec) {</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-  var results = [[p[0], read_file(file, p[1], p[2])] for each (p in partspec)];</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+  var results = [[p[0], read_file(file, p[1], p[2])] for (p of partspec)];</span>
<a href="#l37.14"></a><span id="l37.14">   var msgcontents = read_file(file);</span>
<a href="#l37.15"></a><span id="l37.15" class="difflineminus">-  var packetize = extract_field(opts, &quot;_split&quot;);</span>
<a href="#l37.16"></a><span id="l37.16" class="difflineminus">-  if (packetize !== undefined)</span>
<a href="#l37.17"></a><span id="l37.17" class="difflineminus">-    msgcontents = msgcontents.split(packetize);</span>
<a href="#l37.18"></a><span id="l37.18" class="difflineminus">-  var eol = extract_field(opts, &quot;_eol&quot;);</span>
<a href="#l37.19"></a><span id="l37.19" class="difflineminus">-  if (eol !== undefined) {</span>
<a href="#l37.20"></a><span id="l37.20" class="difflineminus">-    msgcontents = msgcontents.replace(/\r\n/g, eol);</span>
<a href="#l37.21"></a><span id="l37.21" class="difflineminus">-    for (var part of results) {</span>
<a href="#l37.22"></a><span id="l37.22" class="difflineminus">-      part[1] = part[1].replace(/\r\n/g, eol);</span>
<a href="#l37.23"></a><span id="l37.23" class="difflineminus">-    }</span>
<a href="#l37.24"></a><span id="l37.24" class="difflineminus">-  }</span>
<a href="#l37.25"></a><span id="l37.25">   return [test, msgcontents, opts, results];</span>
<a href="#l37.26"></a><span id="l37.26"> }</span>
<a href="#l37.27"></a><span id="l37.27"> </span>
<a href="#l37.28"></a><span id="l37.28"> /// This is the expected part specifier for the multipart-complex1 test file,</span>
<a href="#l37.29"></a><span id="l37.29"> /// specified here because it is used in several cases.</span>
<a href="#l37.30"></a><span id="l37.30"> let mpart_complex1 = [['1', 8, 10], ['2', 14, 16], ['3.1', 22, 24],</span>
<a href="#l37.31"></a><span id="l37.31">     ['4', 29, 31], ['5', 33, 35]];</span>
<a href="#l37.32"></a><span id="l37.32"> </span>
<a href="#l37.33"></a><span id="l37.33" class="difflineat">@@ -101,34 +91,16 @@ let mpart_complex1 = [['1', 8, 10], ['2'</span>
<a href="#l37.34"></a><span id="l37.34"> // entry[2] = options for the MIME parser</span>
<a href="#l37.35"></a><span id="l37.35"> // entry[3] = A checker result:</span>
<a href="#l37.36"></a><span id="l37.36"> //            either a {partnum: header object} (to check headers)</span>
<a href="#l37.37"></a><span id="l37.37"> //            or a [[partnum body], [partnum body], ...] (to check bodies)</span>
<a href="#l37.38"></a><span id="l37.38"> //            (the partnums refer to the expected part numbers of the MIME test)</span>
<a href="#l37.39"></a><span id="l37.39"> // Note that for body tests, unless you're testing decoding, it is preferable to</span>
<a href="#l37.40"></a><span id="l37.40"> // use make_body_test instead of writing the array yourself.</span>
<a href="#l37.41"></a><span id="l37.41"> let parser_tests = [</span>
<a href="#l37.42"></a><span id="l37.42" class="difflineminus">-  // The following tests are either degenerate or error cases that should work</span>
<a href="#l37.43"></a><span id="l37.43" class="difflineminus">-  [&quot;Empty string&quot;, &quot;&quot;, {}, {'': {}}],</span>
<a href="#l37.44"></a><span id="l37.44" class="difflineminus">-  [&quot;No value for header&quot;, &quot;Header&quot;, {}, {'': {&quot;header&quot;: [null]}}],</span>
<a href="#l37.45"></a><span id="l37.45" class="difflineminus">-  [&quot;Header no val&quot;, &quot;A: EOF&quot;, {}, {'': {&quot;a&quot;: [&quot;EOF&quot;]}}],</span>
<a href="#l37.46"></a><span id="l37.46" class="difflineminus">-  [&quot;Header no val&quot;, &quot;A: EOF\r\n&quot;, {}, {'': {&quot;a&quot;: [&quot;EOF&quot;]}}],</span>
<a href="#l37.47"></a><span id="l37.47" class="difflineminus">-  [&quot;No body no headers&quot;, &quot;\r\n\r\n&quot;, {}, {'': {}}],</span>
<a href="#l37.48"></a><span id="l37.48" class="difflineminus">-  [&quot;Body no headers&quot;, &quot;\r\n\r\nA&quot;, {}, {'': {}}],</span>
<a href="#l37.49"></a><span id="l37.49" class="difflineminus">-</span>
<a href="#l37.50"></a><span id="l37.50" class="difflineminus">-  // Basic cases for headers</span>
<a href="#l37.51"></a><span id="l37.51" class="difflineminus">-  ['Multiparts get headers', read_file(&quot;multipart-complex1&quot;), {},</span>
<a href="#l37.52"></a><span id="l37.52" class="difflineminus">-    { '': {'content-type': ['multipart/mixed; boundary=&quot;boundary&quot;']},</span>
<a href="#l37.53"></a><span id="l37.53" class="difflineminus">-      '1': {'content-type': ['application/octet-stream'],</span>
<a href="#l37.54"></a><span id="l37.54" class="difflineminus">-            'content-transfer-encoding': ['base64']},</span>
<a href="#l37.55"></a><span id="l37.55" class="difflineminus">-      '2': {'content-type': ['image/png'],</span>
<a href="#l37.56"></a><span id="l37.56" class="difflineminus">-            'content-transfer-encoding': ['base64']},</span>
<a href="#l37.57"></a><span id="l37.57" class="difflineminus">-      '3': {'content-type': ['multipart/related; boundary=&quot;boundary2&quot;']},</span>
<a href="#l37.58"></a><span id="l37.58" class="difflineminus">-      '3.1': {'content-type': ['text/html']},</span>
<a href="#l37.59"></a><span id="l37.59" class="difflineminus">-      '4': {'content-type': ['text/plain']}, '5': {} }],</span>
<a href="#l37.60"></a><span id="l37.60">   // Body tests from data</span>
<a href="#l37.61"></a><span id="l37.61">   // (Note: line numbers are 1-based. Also, to capture trailing EOF, add 2 to</span>
<a href="#l37.62"></a><span id="l37.62">   // the last line number of the file).</span>
<a href="#l37.63"></a><span id="l37.63">   make_body_test(&quot;Basic body&quot;, &quot;basic1&quot;, {}, [['', 3, 5]]),</span>
<a href="#l37.64"></a><span id="l37.64">   make_body_test(&quot;Basic multipart&quot;, &quot;multipart1&quot;, {}, [['1', 10, 12]]),</span>
<a href="#l37.65"></a><span id="l37.65">   make_body_test(&quot;Basic multipart&quot;, &quot;multipart2&quot;, {}, [['1', 8, 11]]),</span>
<a href="#l37.66"></a><span id="l37.66">   make_body_test(&quot;Complex multipart&quot;, &quot;multipart-complex1&quot;, {}, mpart_complex1),</span>
<a href="#l37.67"></a><span id="l37.67">   make_body_test(&quot;Truncated multipart&quot;, &quot;multipart-complex2&quot;, {},</span>
<a href="#l37.68"></a><span id="l37.68" class="difflineat">@@ -140,20 +112,16 @@ let parser_tests = [</span>
<a href="#l37.69"></a><span id="l37.69">   [&quot;Base64 decode 1&quot;, read_file(&quot;base64-1&quot;), {bodyformat: &quot;decode&quot;},</span>
<a href="#l37.70"></a><span id="l37.70">     [['', &quot;\r\nHello, world! (Again...)\r\n\r\nLet's see how well base64 text&quot; +</span>
<a href="#l37.71"></a><span id="l37.71">           &quot; is handled.                            Yay, lots of spaces! There&quot; +</span>
<a href="#l37.72"></a><span id="l37.72">           &quot;'s even a CRLF at the end and one at the beginning, but the output&quot; +</span>
<a href="#l37.73"></a><span id="l37.73">           &quot; shouldn't have it.\r\n&quot;]]],</span>
<a href="#l37.74"></a><span id="l37.74">   [&quot;Base64 decode 2&quot;, read_file(&quot;base64-2&quot;), {bodyformat: &quot;decode&quot;},</span>
<a href="#l37.75"></a><span id="l37.75">     [['', &quot;&lt;html&gt;&lt;body&gt;This is base64 encoded HTML text, and the tags shouldn&quot; +</span>
<a href="#l37.76"></a><span id="l37.76">           &quot;'t be stripped.\r\n&lt;b&gt;Bold text is bold!&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;]]],</span>
<a href="#l37.77"></a><span id="l37.77" class="difflineminus">-  [&quot;Base64 decode line issues&quot;, read_file(&quot;base64-2&quot;).split(/(\r\n)/),</span>
<a href="#l37.78"></a><span id="l37.78" class="difflineminus">-    {bodyformat: &quot;decode&quot;},</span>
<a href="#l37.79"></a><span id="l37.79" class="difflineminus">-    [['', &quot;&lt;html&gt;&lt;body&gt;This is base64 encoded HTML text, and the tags shouldn&quot; +</span>
<a href="#l37.80"></a><span id="l37.80" class="difflineminus">-          &quot;'t be stripped.\r\n&lt;b&gt;Bold text is bold!&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;]]],</span>
<a href="#l37.81"></a><span id="l37.81">   make_body_test(&quot;Base64 nodecode&quot;, &quot;base64-1&quot;, {}, [['', 4, 9]]),</span>
<a href="#l37.82"></a><span id="l37.82">   [&quot;QP decode&quot;, read_file(&quot;bug505221&quot;), {pruneat: '1', bodyformat: &quot;decode&quot;},</span>
<a href="#l37.83"></a><span id="l37.83">     [['1', '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;\r'  +</span>
<a href="#l37.84"></a><span id="l37.84">            '\n&lt;HTML&gt;&lt;HEAD&gt;\r\n&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/h' +</span>
<a href="#l37.85"></a><span id="l37.85">            'tml; charset=us-ascii&quot;&gt;\r\n\r\n\r\n&lt;META content=&quot;MSHTML 6.00.600' +</span>
<a href="#l37.86"></a><span id="l37.86">            '0.16735&quot; name=GENERATOR&gt;&lt;/HEAD&gt;\r\n&lt;BODY&gt; bbb\r\n&lt;/BODY&gt;&lt;/HTML&gt;']]],</span>
<a href="#l37.87"></a><span id="l37.87"> </span>
<a href="#l37.88"></a><span id="l37.88">   // Comprehensive tests from the torture test</span>
<a href="#l37.89"></a><span id="l37.89" class="difflineat">@@ -166,68 +134,19 @@ let parser_tests = [</span>
<a href="#l37.90"></a><span id="l37.90">     ['7$.3', 13288, 13297], ['8$.1', 13331, 13358], ['8$.2', 13364, 13734],</span>
<a href="#l37.91"></a><span id="l37.91">     ['9$', 13757, 20179], ['10', 20184, 21200], ['11$.1', 21223, 22031],</span>
<a href="#l37.92"></a><span id="l37.92">     ['11$.2', 22036, 22586], ['12$.1', 22607, 23469], ['12$.2', 23474, 23774],</span>
<a href="#l37.93"></a><span id="l37.93">     ['12$.3$.1', 23787, 23795], ['12$.3$.2.1', 23803, 23820],</span>
<a href="#l37.94"></a><span id="l37.94">     ['12$.3$.2.2', 23825, 24633], ['12$.3$.3', 24640, 24836],</span>
<a href="#l37.95"></a><span id="l37.95">     ['12$.3$.4$', 24848, 25872]]),</span>
<a href="#l37.96"></a><span id="l37.96">   make_body_test(&quot;Torture pruneat&quot;, &quot;mime-torture&quot;, {&quot;pruneat&quot;: '4'},</span>
<a href="#l37.97"></a><span id="l37.97">     [['4', 7747, 8213]]),</span>
<a href="#l37.98"></a><span id="l37.98" class="difflineminus">-</span>
<a href="#l37.99"></a><span id="l37.99" class="difflineminus">-  // Test packetization problems</span>
<a href="#l37.100"></a><span id="l37.100" class="difflineminus">-  make_body_test(&quot;Large packets&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l37.101"></a><span id="l37.101" class="difflineminus">-    {&quot;_split&quot;: /(.{30})/}, mpart_complex1),</span>
<a href="#l37.102"></a><span id="l37.102" class="difflineminus">-  make_body_test(&quot;Split on newline&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l37.103"></a><span id="l37.103" class="difflineminus">-    {&quot;_split&quot;: /(\r\n)/}, mpart_complex1),</span>
<a href="#l37.104"></a><span id="l37.104" class="difflineminus">-  make_body_test(&quot;Pathological splitting&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l37.105"></a><span id="l37.105" class="difflineminus">-    {&quot;_split&quot;: ''}, mpart_complex1),</span>
<a href="#l37.106"></a><span id="l37.106" class="difflineminus">-</span>
<a href="#l37.107"></a><span id="l37.107" class="difflineminus">-  // Non-CLRF line endings?</span>
<a href="#l37.108"></a><span id="l37.108" class="difflineminus">-  make_body_test(&quot;LF-based messages&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l37.109"></a><span id="l37.109" class="difflineminus">-    {&quot;_eol&quot;: &quot;\n&quot;}, mpart_complex1),</span>
<a href="#l37.110"></a><span id="l37.110" class="difflineminus">-  make_body_test(&quot;CR-based messages&quot;, &quot;multipart-complex1&quot;,</span>
<a href="#l37.111"></a><span id="l37.111" class="difflineminus">-    {&quot;_eol&quot;: &quot;\r&quot;}, mpart_complex1),</span>
<a href="#l37.112"></a><span id="l37.112" class="difflineminus">-</span>
<a href="#l37.113"></a><span id="l37.113" class="difflineminus">-  // 'From ' is not an [iterable] header</span>
<a href="#l37.114"></a><span id="l37.114" class="difflineminus">-  ['Exclude mbox delimiter', read_file('bugmail11'), {}, {'': {</span>
<a href="#l37.115"></a><span id="l37.115" class="difflineminus">-    'x-mozilla-status': ['0001'], 'x-mozilla-status2': ['00000000'],</span>
<a href="#l37.116"></a><span id="l37.116" class="difflineminus">-    'x-mozilla-keys': [''],</span>
<a href="#l37.117"></a><span id="l37.117" class="difflineminus">-    'return-path': ['&lt;example@example.com&gt;', '&lt;bugzilla-daemon@mozilla.org&gt;'],</span>
<a href="#l37.118"></a><span id="l37.118" class="difflineminus">-    'delivered-to': ['bugmail@example.org'],</span>
<a href="#l37.119"></a><span id="l37.119" class="difflineminus">-    'received': ['by 10.114.166.12 with SMTP id o12cs163262wae;' +</span>
<a href="#l37.120"></a><span id="l37.120" class="difflineminus">-                 '        Fri, 11 Apr 2008 07:17:31 -0700 (PDT)',</span>
<a href="#l37.121"></a><span id="l37.121" class="difflineminus">-      'by 10.115.60.1 with SMTP id n1mr214763wak.181.1207923450166;' +</span>
<a href="#l37.122"></a><span id="l37.122" class="difflineminus">-      '        Fri, 11 Apr 2008 07:17:30 -0700 (PDT)',</span>
<a href="#l37.123"></a><span id="l37.123" class="difflineminus">-      'from webapp-out.mozilla.org (webapp01.sj.mozilla.com [63.245.208.146])' +</span>
<a href="#l37.124"></a><span id="l37.124" class="difflineminus">-      '        by mx.google.com with ESMTP id n38si6807242wag.2.2008.04.11.07' +</span>
<a href="#l37.125"></a><span id="l37.125" class="difflineminus">-      '.17.29;        Fri, 11 Apr 2008 07:17:30 -0700 (PDT)',</span>
<a href="#l37.126"></a><span id="l37.126" class="difflineminus">-      'from mrapp51.mozilla.org (mrapp51.mozilla.org [127.0.0.1])' +</span>
<a href="#l37.127"></a><span id="l37.127" class="difflineminus">-      '\tby webapp-out.mozilla.org (8.13.8/8.13.8) with ESMTP id m3BEHTGU0301' +</span>
<a href="#l37.128"></a><span id="l37.128" class="difflineminus">-      '32\tfor &lt;bugmail@example.org&gt;; Fri, 11 Apr 2008 07:17:29 -0700',</span>
<a href="#l37.129"></a><span id="l37.129" class="difflineminus">-      '(from root@localhost)' +</span>
<a href="#l37.130"></a><span id="l37.130" class="difflineminus">-      '\tby mrapp51.mozilla.org (8.13.8/8.13.8/Submit) id m3BEHTk4030129;' +</span>
<a href="#l37.131"></a><span id="l37.131" class="difflineminus">-      '\tFri, 11 Apr 2008 07:17:29 -0700'],</span>
<a href="#l37.132"></a><span id="l37.132" class="difflineminus">-    'received-spf': ['neutral (google.com: 63.245.208.146 is neither permitte' +</span>
<a href="#l37.133"></a><span id="l37.133" class="difflineminus">-      'd nor denied by best guess record for domain of bugzilla-daemon@mozill' +</span>
<a href="#l37.134"></a><span id="l37.134" class="difflineminus">-      'a.org) client-ip=63.245.208.146;'],</span>
<a href="#l37.135"></a><span id="l37.135" class="difflineminus">-    'authentication-results': ['mx.google.com; spf=neutral (google.com: 63.24' +</span>
<a href="#l37.136"></a><span id="l37.136" class="difflineminus">-      '5.208.146 is neither permitted nor denied by best guess record for dom' +</span>
<a href="#l37.137"></a><span id="l37.137" class="difflineminus">-      'ain of bugzilla-daemon@mozilla.org) smtp.mail=bugzilla-daemon@mozilla.' +</span>
<a href="#l37.138"></a><span id="l37.138" class="difflineminus">-      'org'],</span>
<a href="#l37.139"></a><span id="l37.139" class="difflineminus">-    'date': ['Fri, 11 Apr 2008 07:17:29 -0700'],</span>
<a href="#l37.140"></a><span id="l37.140" class="difflineminus">-    'message-id': ['&lt;200804111417.m3BEHTk4030129@mrapp51.mozilla.org&gt;'],</span>
<a href="#l37.141"></a><span id="l37.141" class="difflineminus">-    'from': ['bugzilla-daemon@mozilla.org'],'to': ['bugmail@example.org'],</span>
<a href="#l37.142"></a><span id="l37.142" class="difflineminus">-    'subject': ['Bugzilla: confirm account creation'],</span>
<a href="#l37.143"></a><span id="l37.143" class="difflineminus">-    'x-bugzilla-type': ['admin'],</span>
<a href="#l37.144"></a><span id="l37.144" class="difflineminus">-    'content-type': ['text/plain; charset=&quot;UTF-8&quot;'], 'mime-version': ['1.0']}}],</span>
<a href="#l37.145"></a><span id="l37.145"> ];</span>
<a href="#l37.146"></a><span id="l37.146"> </span>
<a href="#l37.147"></a><span id="l37.147"> function test_parser(message, opts, results) {</span>
<a href="#l37.148"></a><span id="l37.148" class="difflineminus">-  if (!(message instanceof Array))</span>
<a href="#l37.149"></a><span id="l37.149" class="difflineminus">-    message = [message];</span>
<a href="#l37.150"></a><span id="l37.150">   var checkingHeaders = !(results instanceof Array);</span>
<a href="#l37.151"></a><span id="l37.151">   var calls = 0, dataCalls = 0;</span>
<a href="#l37.152"></a><span id="l37.152">   var fusingParts = extract_field(opts, &quot;_nofuseparts&quot;) === undefined;</span>
<a href="#l37.153"></a><span id="l37.153">   var emitter = {</span>
<a href="#l37.154"></a><span id="l37.154">     stack: [],</span>
<a href="#l37.155"></a><span id="l37.155">     startMessage: function emitter_startMsg() {</span>
<a href="#l37.156"></a><span id="l37.156">       do_check_eq(this.stack.length, 0);</span>
<a href="#l37.157"></a><span id="l37.157">       calls++;</span>
<a href="#l37.158"></a><span id="l37.158" class="difflineat">@@ -268,20 +187,17 @@ function test_parser(message, opts, resu</span>
<a href="#l37.159"></a><span id="l37.159">         compare_objects(this.partData, results[dataCalls][1]);</span>
<a href="#l37.160"></a><span id="l37.160">         dataCalls++;</span>
<a href="#l37.161"></a><span id="l37.161">         this.partData = '';</span>
<a href="#l37.162"></a><span id="l37.162">       }</span>
<a href="#l37.163"></a><span id="l37.163">       do_check_eq(this.stack.pop(), partNum);</span>
<a href="#l37.164"></a><span id="l37.164">     }</span>
<a href="#l37.165"></a><span id="l37.165">   };</span>
<a href="#l37.166"></a><span id="l37.166">   opts.onerror = function (e) { throw e; };</span>
<a href="#l37.167"></a><span id="l37.167" class="difflineminus">-  var parser = MimeParser.makeParser(emitter, opts);</span>
<a href="#l37.168"></a><span id="l37.168" class="difflineminus">-  for each (var packet in message)</span>
<a href="#l37.169"></a><span id="l37.169" class="difflineminus">-    parser.deliverData(packet);</span>
<a href="#l37.170"></a><span id="l37.170" class="difflineminus">-  parser.deliverEOF();</span>
<a href="#l37.171"></a><span id="l37.171" class="difflineplus">+  MimeParser.parseSync(message, emitter, opts);</span>
<a href="#l37.172"></a><span id="l37.172">   do_check_eq(calls, 2);</span>
<a href="#l37.173"></a><span id="l37.173">   if (!checkingHeaders)</span>
<a href="#l37.174"></a><span id="l37.174">     do_check_eq(dataCalls, results.length);</span>
<a href="#l37.175"></a><span id="l37.175"> }</span>
<a href="#l37.176"></a><span id="l37.176"> </span>
<a href="#l37.177"></a><span id="l37.177"> const ATTACH = MimeParser.HEADER_PARAMETER;</span>
<a href="#l37.178"></a><span id="l37.178"> // Format of tests:</span>
<a href="#l37.179"></a><span id="l37.179"> // entry[0] = header</span>
<a href="#l37.180"></a><span id="l37.180" class="difflineat">@@ -296,50 +212,30 @@ let header_tests = [</span>
<a href="#l37.181"></a><span id="l37.181">   [&quot;a;b=1;b=2&quot;, MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: &quot;1&quot;}]],</span>
<a href="#l37.182"></a><span id="l37.182">   [&quot;a;b=2;b=1&quot;, MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: &quot;2&quot;}]],</span>
<a href="#l37.183"></a><span id="l37.183">   ['a;b=&quot;a;b&quot;', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: &quot;a;b&quot;}]],</span>
<a href="#l37.184"></a><span id="l37.184">   ['a;b=&quot;\\\\&quot;', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: &quot;\\&quot;}]],</span>
<a href="#l37.185"></a><span id="l37.185">   ['a;b=&quot;a\\b\\c&quot;', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: &quot;abc&quot;}]],</span>
<a href="#l37.186"></a><span id="l37.186">   ['a;b=1;c=2', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: &quot;1&quot;, &quot;c&quot;: &quot;2&quot;}]],</span>
<a href="#l37.187"></a><span id="l37.187">   ['a;b=&quot;a\\', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: &quot;a&quot;}]],</span>
<a href="#l37.188"></a><span id="l37.188">   ['a;b', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {}]],</span>
<a href="#l37.189"></a><span id="l37.189" class="difflineminus">-  ['a;b=1&quot;2;c=d', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: '1&quot;2', 'c': &quot;d&quot;}]],</span>
<a href="#l37.190"></a><span id="l37.190" class="difflineminus">-</span>
<a href="#l37.191"></a><span id="l37.191" class="difflineminus">-  // Copied from test_MIME_params.js and adapted</span>
<a href="#l37.192"></a><span id="l37.192" class="difflineminus">-  [&quot;attachment;&quot;, ATTACH, [&quot;attachment&quot;, {}]],</span>
<a href="#l37.193"></a><span id="l37.193" class="difflineminus">-  [&quot;attachment; filename=basic&quot;, ATTACH, [&quot;attachment&quot;, {filename: &quot;basic&quot;}]],</span>
<a href="#l37.194"></a><span id="l37.194" class="difflineminus">-  [&quot;attachment; filename=\&quot;\\\&quot;\&quot;&quot;, ATTACH, [&quot;attachment&quot;, {filename: '&quot;'}]],</span>
<a href="#l37.195"></a><span id="l37.195" class="difflineminus">-  [&quot;attachment; filename=\&quot;\\x\&quot;&quot;, ATTACH, [&quot;attachment&quot;, {filename: &quot;x&quot;}]],</span>
<a href="#l37.196"></a><span id="l37.196" class="difflineminus">-  [&quot;attachment; filename=\&quot;\&quot;&quot;, ATTACH, [&quot;attachment&quot;, {filename: &quot;&quot;}]],</span>
<a href="#l37.197"></a><span id="l37.197" class="difflineminus">-  [&quot;attachment; filename=&quot;, ATTACH, [&quot;attachment&quot;, {filename: &quot;&quot;}]],</span>
<a href="#l37.198"></a><span id="l37.198" class="difflineminus">-  [&quot;attachment; filename X&quot;, ATTACH, [&quot;attachment&quot;, {}]],</span>
<a href="#l37.199"></a><span id="l37.199" class="difflineminus">-  [&quot;attachment; filename = foo-A.html&quot;, ATTACH,</span>
<a href="#l37.200"></a><span id="l37.200" class="difflineminus">-    [&quot;attachment&quot;, {filename: &quot;foo-A.html&quot;}]],</span>
<a href="#l37.201"></a><span id="l37.201" class="difflineminus">-  [&quot;attachment; filename=\&quot;&quot;, ATTACH, [&quot;attachment&quot;, {filename: &quot;&quot;}]],</span>
<a href="#l37.202"></a><span id="l37.202" class="difflineminus">-  [&quot;attachment; filename=foo; trouble&quot;, ATTACH,</span>
<a href="#l37.203"></a><span id="l37.203" class="difflineminus">-    [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l37.204"></a><span id="l37.204" class="difflineminus">-  [&quot;attachment; filename=foo; trouble &quot;, ATTACH,</span>
<a href="#l37.205"></a><span id="l37.205" class="difflineminus">-    [&quot;attachment&quot;, {filename: &quot;foo&quot;}]],</span>
<a href="#l37.206"></a><span id="l37.206" class="difflineminus">-  [&quot;attachment&quot;, ATTACH, [&quot;attachment&quot;, {}]],</span>
<a href="#l37.207"></a><span id="l37.207" class="difflineminus">-  // According to comments and bugs, this works in necko, but it doesn't appear</span>
<a href="#l37.208"></a><span id="l37.208" class="difflineminus">-  // that it ought to. See bug 732369 for more info.</span>
<a href="#l37.209"></a><span id="l37.209" class="difflineminus">-  [&quot;attachment; extension=bla filename=foo&quot;, ATTACH,</span>
<a href="#l37.210"></a><span id="l37.210" class="difflineminus">-    [&quot;attachment&quot;, {extension: &quot;bla&quot;}]],</span>
<a href="#l37.211"></a><span id="l37.211" class="difflineplus">+  ['a;b=&quot;;&quot;;c=d', MimeParser.HEADER_PARAMETER, [&quot;a&quot;, {&quot;b&quot;: ';', 'c': &quot;d&quot;}]],</span>
<a href="#l37.212"></a><span id="l37.212"> ];</span>
<a href="#l37.213"></a><span id="l37.213"> </span>
<a href="#l37.214"></a><span id="l37.214"> function test_header(headerValue, flags, expected) {</span>
<a href="#l37.215"></a><span id="l37.215">   let result = MimeParser.parseHeaderField(headerValue, flags);</span>
<a href="#l37.216"></a><span id="l37.216" class="difflineminus">-  do_check_eq(uneval(result), uneval(expected));</span>
<a href="#l37.217"></a><span id="l37.217" class="difflineplus">+  do_check_eq(result.preSemi, expected[0]);</span>
<a href="#l37.218"></a><span id="l37.218" class="difflineplus">+  compare_objects(result, expected[1]);</span>
<a href="#l37.219"></a><span id="l37.219"> }</span>
<a href="#l37.220"></a><span id="l37.220"> </span>
<a href="#l37.221"></a><span id="l37.221"> function run_test() {</span>
<a href="#l37.222"></a><span id="l37.222" class="difflineminus">-  for each (let test in parser_tests) {</span>
<a href="#l37.223"></a><span id="l37.223" class="difflineplus">+  for (let test of parser_tests) {</span>
<a href="#l37.224"></a><span id="l37.224">     dump(&quot;Testing message &quot; + test[0]);</span>
<a href="#l37.225"></a><span id="l37.225">     if (test[1] instanceof Array)</span>
<a href="#l37.226"></a><span id="l37.226">       dump(&quot; using &quot; + test[1].length + &quot; packets&quot;);</span>
<a href="#l37.227"></a><span id="l37.227">     dump('\n');</span>
<a href="#l37.228"></a><span id="l37.228">     test_parser(test[1], test[2], test[3]);</span>
<a href="#l37.229"></a><span id="l37.229">   }</span>
<a href="#l37.230"></a><span id="l37.230" class="difflineminus">-  for each (let test in header_tests) {</span>
<a href="#l37.231"></a><span id="l37.231" class="difflineplus">+  for (let test of header_tests) {</span>
<a href="#l37.232"></a><span id="l37.232">     dump(&quot;Testing value -&gt;&quot; + test[0] + &quot;&lt;- with flags &quot; + test[1] + &quot;\n&quot;);</span>
<a href="#l37.233"></a><span id="l37.233">     test_header(test[0], test[1], test[2]);</span>
<a href="#l37.234"></a><span id="l37.234">   }</span>
<a href="#l37.235"></a><span id="l37.235"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/mailnews/test/fakeserver/imapd.js</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/mailnews/test/fakeserver/imapd.js</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -1534,27 +1534,27 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l38.4"></a><span id="l38.4">       break;</span>
<a href="#l38.5"></a><span id="l38.5">     case &quot;HEADER.FIELDS&quot;:</span>
<a href="#l38.6"></a><span id="l38.6">       var joinList = [];</span>
<a href="#l38.7"></a><span id="l38.7">       var headers = message.getPartHeaders(partNum);</span>
<a href="#l38.8"></a><span id="l38.8">       for (let header of queryArgs) {</span>
<a href="#l38.9"></a><span id="l38.9">         header = header.toLowerCase();</span>
<a href="#l38.10"></a><span id="l38.10">         if (headers.has(header))</span>
<a href="#l38.11"></a><span id="l38.11">           joinList.push([header + &quot;: &quot; + value</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-                         for (value of headers.get(header))].join('\r\n'));</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineplus">+                         for (value of headers.getRawHeader(header))].join('\r\n'));</span>
<a href="#l38.14"></a><span id="l38.14">       }</span>
<a href="#l38.15"></a><span id="l38.15">       data += joinList.join('\r\n') + &quot;\r\n&quot;;</span>
<a href="#l38.16"></a><span id="l38.16">       break;</span>
<a href="#l38.17"></a><span id="l38.17">     case &quot;HEADER.FIELDS.NOT&quot;:</span>
<a href="#l38.18"></a><span id="l38.18">       var joinList = [];</span>
<a href="#l38.19"></a><span id="l38.19">       var headers = message.getPartHeaders(partNum);</span>
<a href="#l38.20"></a><span id="l38.20">       for (let header of headers) {</span>
<a href="#l38.21"></a><span id="l38.21">         if (!(header in queryArgs))</span>
<a href="#l38.22"></a><span id="l38.22">           joinList.push([header + &quot;: &quot; + value</span>
<a href="#l38.23"></a><span id="l38.23" class="difflineminus">-                         for (value of headers.get(header))].join('\r\n'));</span>
<a href="#l38.24"></a><span id="l38.24" class="difflineplus">+                         for (value of headers.getRawHeader(header))].join('\r\n'));</span>
<a href="#l38.25"></a><span id="l38.25">       }</span>
<a href="#l38.26"></a><span id="l38.26">       data += joinList.join('\r\n') + &quot;\r\n&quot;;</span>
<a href="#l38.27"></a><span id="l38.27">       break;</span>
<a href="#l38.28"></a><span id="l38.28">     default:</span>
<a href="#l38.29"></a><span id="l38.29">       data += message.getPartBody(partNum);</span>
<a href="#l38.30"></a><span id="l38.30">     }</span>
<a href="#l38.31"></a><span id="l38.31"> </span>
<a href="#l38.32"></a><span id="l38.32">     this.sendingLiteral = true;</span>
<a href="#l38.33"></a><span id="l38.33" class="difflineat">@@ -2149,62 +2149,57 @@ function bodystructure(msg, extension) {</span>
<a href="#l38.34"></a><span id="l38.34"> </span>
<a href="#l38.35"></a><span id="l38.35">   // Use the mime parser emitter to generate body structure data. Most of the</span>
<a href="#l38.36"></a><span id="l38.36">   // string will be built as we exit a part. Currently not working:</span>
<a href="#l38.37"></a><span id="l38.37">   // 1. Some of the fields return NIL instead of trying to calculate them.</span>
<a href="#l38.38"></a><span id="l38.38">   // 2. MESSAGE is missing the ENVELOPE and the lines at the end.</span>
<a href="#l38.39"></a><span id="l38.39">   var bodystruct = '';</span>
<a href="#l38.40"></a><span id="l38.40">   function paramToString(params) {</span>
<a href="#l38.41"></a><span id="l38.41">     let paramList = [];</span>
<a href="#l38.42"></a><span id="l38.42" class="difflineminus">-    for (var param in params)</span>
<a href="#l38.43"></a><span id="l38.43" class="difflineminus">-      paramList.push('&quot;' + param.toUpperCase() + '&quot; &quot;' + params[param] + '&quot;');</span>
<a href="#l38.44"></a><span id="l38.44" class="difflineplus">+    for (let [param, value] of params)</span>
<a href="#l38.45"></a><span id="l38.45" class="difflineplus">+      paramList.push('&quot;' + param.toUpperCase() + '&quot; &quot;' + value + '&quot;');</span>
<a href="#l38.46"></a><span id="l38.46">     return paramList.length == 0 ? 'NIL' : '(' + paramList.join(' ') + ')';</span>
<a href="#l38.47"></a><span id="l38.47">   }</span>
<a href="#l38.48"></a><span id="l38.48">   var headerStack = [];</span>
<a href="#l38.49"></a><span id="l38.49">   var BodyStructureEmitter = {</span>
<a href="#l38.50"></a><span id="l38.50">     startPart: function bodystructure_startPart(partNum, headers) {</span>
<a href="#l38.51"></a><span id="l38.51">       bodystruct += '(';</span>
<a href="#l38.52"></a><span id="l38.52">       headerStack.push(headers);</span>
<a href="#l38.53"></a><span id="l38.53">       this.numLines = 0;</span>
<a href="#l38.54"></a><span id="l38.54">       this.length = 0;</span>
<a href="#l38.55"></a><span id="l38.55">     },</span>
<a href="#l38.56"></a><span id="l38.56">     deliverPartData: function bodystructure_deliverPartData(partNum, data) {</span>
<a href="#l38.57"></a><span id="l38.57">       this.length += data.length;</span>
<a href="#l38.58"></a><span id="l38.58" class="difflineminus">-      this.numLines += [x for each (x in data) if (x == '\n')].length;</span>
<a href="#l38.59"></a><span id="l38.59" class="difflineplus">+      this.numLines += [x for (x of data) if (x == '\n')].length;</span>
<a href="#l38.60"></a><span id="l38.60">     },</span>
<a href="#l38.61"></a><span id="l38.61">     endPart: function bodystructure_endPart(partNum) {</span>
<a href="#l38.62"></a><span id="l38.62">       // Grab the headers from before</span>
<a href="#l38.63"></a><span id="l38.63">       let headers = headerStack.pop();</span>
<a href="#l38.64"></a><span id="l38.64" class="difflineminus">-      let contentType = headers.has('content-type') ?</span>
<a href="#l38.65"></a><span id="l38.65" class="difflineminus">-        headers.get('content-type')[0] : 'text/plain';</span>
<a href="#l38.66"></a><span id="l38.66" class="difflineminus">-      let [type, params] = MimeParser.parseHeaderField(contentType,</span>
<a href="#l38.67"></a><span id="l38.67" class="difflineminus">-        MimeParser.HEADER_PARAMETER);</span>
<a href="#l38.68"></a><span id="l38.68" class="difflineminus">-      // Use uppercase canonicalization for now</span>
<a href="#l38.69"></a><span id="l38.69" class="difflineminus">-      type = type.toUpperCase();</span>
<a href="#l38.70"></a><span id="l38.70" class="difflineminus">-      let [media, sub] = type.split('/', 2);</span>
<a href="#l38.71"></a><span id="l38.71" class="difflineminus">-      if (media == &quot;MULTIPART&quot;) {</span>
<a href="#l38.72"></a><span id="l38.72" class="difflineminus">-        bodystruct += ' &quot;' + sub + '&quot;';</span>
<a href="#l38.73"></a><span id="l38.73" class="difflineplus">+      let contentType = headers.contentType;</span>
<a href="#l38.74"></a><span id="l38.74" class="difflineplus">+      if (contentType.mediatype == &quot;multipart&quot;) {</span>
<a href="#l38.75"></a><span id="l38.75" class="difflineplus">+        bodystruct += ' &quot;' + contentType.subtype.toUpperCase() + '&quot;';</span>
<a href="#l38.76"></a><span id="l38.76">         if (extension) {</span>
<a href="#l38.77"></a><span id="l38.77" class="difflineminus">-          bodystruct += ' ' + paramToString(params);</span>
<a href="#l38.78"></a><span id="l38.78" class="difflineplus">+          bodystruct += ' ' + paramToString(contentType);</span>
<a href="#l38.79"></a><span id="l38.79">           // XXX: implement the rest</span>
<a href="#l38.80"></a><span id="l38.80">           bodystruct += ' NIL NIL NIL';</span>
<a href="#l38.81"></a><span id="l38.81">         }</span>
<a href="#l38.82"></a><span id="l38.82">       } else {</span>
<a href="#l38.83"></a><span id="l38.83" class="difflineminus">-        bodystruct += '&quot;' + media + '&quot; &quot;' + sub + '&quot;';</span>
<a href="#l38.84"></a><span id="l38.84" class="difflineminus">-        bodystruct += ' ' + paramToString(params);</span>
<a href="#l38.85"></a><span id="l38.85" class="difflineplus">+        bodystruct += '&quot;' + contentType.mediatype.toUpperCase() + '&quot; &quot;' +</span>
<a href="#l38.86"></a><span id="l38.86" class="difflineplus">+          contentType.subtype.toUpperCase() + '&quot;';</span>
<a href="#l38.87"></a><span id="l38.87" class="difflineplus">+        bodystruct += ' ' + paramToString(contentType);</span>
<a href="#l38.88"></a><span id="l38.88"> </span>
<a href="#l38.89"></a><span id="l38.89">         // XXX: Content ID, Content description</span>
<a href="#l38.90"></a><span id="l38.90">         bodystruct += ' NIL NIL';</span>
<a href="#l38.91"></a><span id="l38.91"> </span>
<a href="#l38.92"></a><span id="l38.92">         let cte = headers.has('content-transfer-encoding') ?</span>
<a href="#l38.93"></a><span id="l38.93" class="difflineminus">-          headers.get('content-transfer-encoding')[0].toUpperCase() : '7BIT';</span>
<a href="#l38.94"></a><span id="l38.94" class="difflineplus">+          headers.get('content-transfer-encoding') : '7BIT';</span>
<a href="#l38.95"></a><span id="l38.95">         bodystruct += ' &quot;' + cte + '&quot;';</span>
<a href="#l38.96"></a><span id="l38.96"> </span>
<a href="#l38.97"></a><span id="l38.97">         bodystruct += ' ' + this.length;</span>
<a href="#l38.98"></a><span id="l38.98" class="difflineminus">-        if (media == &quot;TEXT&quot;)</span>
<a href="#l38.99"></a><span id="l38.99" class="difflineplus">+        if (contentType.mediatype == &quot;text&quot;)</span>
<a href="#l38.100"></a><span id="l38.100">           bodystruct += ' ' + this.numLines;</span>
<a href="#l38.101"></a><span id="l38.101"> </span>
<a href="#l38.102"></a><span id="l38.102">         // XXX: I don't want to implement these yet</span>
<a href="#l38.103"></a><span id="l38.103">         if (extension)</span>
<a href="#l38.104"></a><span id="l38.104">           bodystruct += ' NIL NIL NIL NIL';</span>
<a href="#l38.105"></a><span id="l38.105">       }</span>
<a href="#l38.106"></a><span id="l38.106">       bodystruct += ')';</span>
<a href="#l38.107"></a><span id="l38.107">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/mailnews/test/fakeserver/nntpd.js</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/mailnews/test/fakeserver/nntpd.js</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -77,17 +77,17 @@ nntpDaemon.prototype = {</span>
<a href="#l39.4"></a><span id="l39.4"> function newsArticle(text) {</span>
<a href="#l39.5"></a><span id="l39.5">   this.headers = {};</span>
<a href="#l39.6"></a><span id="l39.6">   this.body = &quot;&quot;;</span>
<a href="#l39.7"></a><span id="l39.7">   this.messageID = &quot;&quot;;</span>
<a href="#l39.8"></a><span id="l39.8">   this.fullText = text;</span>
<a href="#l39.9"></a><span id="l39.9"> </span>
<a href="#l39.10"></a><span id="l39.10">   var headerMap;</span>
<a href="#l39.11"></a><span id="l39.11">   [headerMap, this.body] = MimeParser.extractHeadersAndBody(text);</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">-  for (var [header, values] of headerMap) {</span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+  for (var [header, values] of headerMap._rawHeaders) {</span>
<a href="#l39.14"></a><span id="l39.14">     var value = values[0];</span>
<a href="#l39.15"></a><span id="l39.15">     this.headers[header] = value;</span>
<a href="#l39.16"></a><span id="l39.16">     if (header == &quot;message-id&quot;) {</span>
<a href="#l39.17"></a><span id="l39.17">       var start = value.indexOf('&lt;');</span>
<a href="#l39.18"></a><span id="l39.18">       var end = value.indexOf('&gt;', start);</span>
<a href="#l39.19"></a><span id="l39.19">       this.messageID = value.substring(start, end+1);</span>
<a href="#l39.20"></a><span id="l39.20">     } else if (header == &quot;newsgroups&quot;) {</span>
<a href="#l39.21"></a><span id="l39.21">       this.groups = value.split(/[ \t]*,[ \t]*/);</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

