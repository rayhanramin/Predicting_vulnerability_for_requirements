<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 4331:413b2018349cd0f90b7217b5c5a6b73ab97ee66b</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 413b2018349cd0f90b7217b5c5a6b73ab97ee66b" />
<meta property="og:url" content="/comm-central/rev/413b2018349cd0f90b7217b5c5a6b73ab97ee66b" />
<meta property="og:description" content="Gloda correctness fix.  Nominally tracked by Bug 465618 - gloda deleted message processing logic is not purging messages. r+sr=bienvenu, a=blocking-thunderbird3." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 413b2018349cd0f90b7217b5c5a6b73ab97ee66b 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/413b2018349cd0f90b7217b5c5a6b73ab97ee66b">shortlog</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/413b2018349cd0f90b7217b5c5a6b73ab97ee66b">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b">files</a> |
changeset |
<a href="/comm-central/raw-rev/413b2018349cd0f90b7217b5c5a6b73ab97ee66b">raw</a>  | <a href="/comm-central/archive/413b2018349cd0f90b7217b5c5a6b73ab97ee66b.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
Gloda correctness fix.  Nominally tracked by <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465618">Bug 465618</a> - gloda deleted message processing logic is not purging messages. r+sr=bienvenu, a=blocking-thunderbird3.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 06 Nov 2009 15:48:36 -0800</td></tr>

<tr>
 <td>changeset 4331</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/413b2018349cd0f90b7217b5c5a6b73ab97ee66b">413b2018349cd0f90b7217b5c5a6b73ab97ee66b</a></td>
</tr>



<tr>
<td>parent 4330</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/c82b70d027a857e533b97ac732ce697236087251">c82b70d027a857e533b97ac732ce697236087251</a>
</td>
</tr>

<tr>
<td>child 4332</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/5bc61d53d1ab0fda2f163741ca442c4c5e08023f">5bc61d53d1ab0fda2f163741ca442c4c5e08023f</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=413b2018349cd0f90b7217b5c5a6b73ab97ee66b">3384</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Fri, 06 Nov 2009 23:49:15 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@413b2018349c [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b&newProject=comm-central&newRevision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b&newProject=comm-central&newRevision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b&newProject=comm-central&newRevision=413b2018349cd0f90b7217b5c5a6b73ab97ee66b&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28blocking-thunderbird3%29&revcount=50">blocking-thunderbird3</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465618">465618</a></td></tr>




</table></div>

<div class="page_body description">Gloda correctness fix.  Nominally tracked by <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465618">Bug 465618</a> - gloda deleted message processing logic is not purging messages. r+sr=bienvenu, a=blocking-thunderbird3.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/resources/viewWrapperTestUtils.js">mail/base/test/unit/resources/viewWrapperTestUtils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/resources/viewWrapperTestUtils.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/resources/viewWrapperTestUtils.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/resources/viewWrapperTestUtils.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/resources/viewWrapperTestUtils.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/resources/viewWrapperTestUtils.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_logic.js">mail/base/test/unit/test_viewWrapper_logic.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_logic.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_logic.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_logic.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_logic.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_logic.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_realFolder.js">mail/base/test/unit/test_viewWrapper_realFolder.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_realFolder.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_realFolder.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_realFolder.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_realFolder.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_realFolder.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_virtualFolder.js">mail/base/test/unit/test_viewWrapper_virtualFolder.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_virtualFolder.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_virtualFolder.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_virtualFolder.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_virtualFolder.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/base/test/unit/test_viewWrapper_virtualFolder.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/activity/modules/glodaIndexer.js">mail/components/activity/modules/glodaIndexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/activity/modules/glodaIndexer.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/activity/modules/glodaIndexer.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/activity/modules/glodaIndexer.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/activity/modules/glodaIndexer.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/activity/modules/glodaIndexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/search/content/searchCommon.js">mail/components/search/content/searchCommon.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/search/content/searchCommon.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/search/content/searchCommon.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/search/content/searchCommon.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/search/content/searchCommon.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/components/search/content/searchCommon.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/folder-display/test-columns.js">mail/test/mozmill/folder-display/test-columns.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/folder-display/test-columns.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/folder-display/test-columns.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/folder-display/test-columns.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/folder-display/test-columns.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/folder-display/test-columns.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">mail/test/mozmill/shared-modules/test-folder-display-helpers.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderListener.idl">mailnews/base/public/nsIMsgFolderListener.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderListener.idl">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderListener.idl">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderListener.idl">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderListener.idl">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderListener.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderNotificationService.idl">mailnews/base/public/nsIMsgFolderNotificationService.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderNotificationService.idl">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderNotificationService.idl">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderNotificationService.idl">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderNotificationService.idl">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/public/nsIMsgFolderNotificationService.idl">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/search/src/nsMsgSearchTerm.cpp">mailnews/base/search/src/nsMsgSearchTerm.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/search/src/nsMsgSearchTerm.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/search/src/nsMsgSearchTerm.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/search/src/nsMsgSearchTerm.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/search/src/nsMsgSearchTerm.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/search/src/nsMsgSearchTerm.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgDBView.cpp">mailnews/base/src/nsMsgDBView.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgDBView.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgDBView.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgDBView.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgDBView.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgDBView.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderCompactor.cpp">mailnews/base/src/nsMsgFolderCompactor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderCompactor.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderCompactor.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderCompactor.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderCompactor.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderCompactor.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderNotificationService.cpp">mailnews/base/src/nsMsgFolderNotificationService.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderNotificationService.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderNotificationService.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderNotificationService.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderNotificationService.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/src/nsMsgFolderNotificationService.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListener.js">mailnews/base/test/unit/test_nsIMsgFolderListener.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListener.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListener.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListener.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListener.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListener.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js">mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsMsgDBView.js">mailnews/base/test/unit/test_nsMsgDBView.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsMsgDBView.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsMsgDBView.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsMsgDBView.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsMsgDBView.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/test/unit/test_nsMsgDBView.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.cpp">mailnews/base/util/nsMsgDBFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.h">mailnews/base/util/nsMsgDBFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.h">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.h">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.h">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.h">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/base/util/nsMsgDBFolder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/compose/test/unit/test_sendMessageLater2.js">mailnews/compose/test/unit/test_sendMessageLater2.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/compose/test/unit/test_sendMessageLater2.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/compose/test/unit/test_sendMessageLater2.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/compose/test/unit/test_sendMessageLater2.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/compose/test/unit/test_sendMessageLater2.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/compose/test/unit/test_sendMessageLater2.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/collection.js">mailnews/db/gloda/modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/collection.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/collection.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/everybody.js">mailnews/db/gloda/modules/everybody.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/everybody.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/everybody.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/everybody.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/everybody.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/everybody.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/explattr.js">mailnews/db/gloda/modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/fundattr.js">mailnews/db/gloda/modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/gloda.js">mailnews/db/gloda/modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_ab.js">mailnews/db/gloda/modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_ab.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_msg.js">mailnews/db/gloda/modules/index_msg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_msg.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_msg.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_msg.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_msg.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/index_msg.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/indexer.js">mailnews/db/gloda/modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/log4moz.js">mailnews/db/gloda/modules/log4moz.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/log4moz.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/log4moz.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/log4moz.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/log4moz.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/log4moz.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/noun_tag.js">mailnews/db/gloda/modules/noun_tag.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/noun_tag.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/noun_tag.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/noun_tag.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/noun_tag.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/noun_tag.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/public.js">mailnews/db/gloda/modules/public.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/public.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/public.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/public.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/public.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/public.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/query.js">mailnews/db/gloda/modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/query.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/query.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/query.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/query.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/query.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/utils.js">mailnews/db/gloda/modules/utils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/utils.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/utils.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/utils.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/utils.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/modules/utils.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_gloda_content.js">mailnews/db/gloda/test/unit/base_gloda_content.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_gloda_content.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_gloda_content.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_gloda_content.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_gloda_content.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_gloda_content.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_junk.js">mailnews/db/gloda/test/unit/base_index_junk.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_junk.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_junk.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_junk.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_junk.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_junk.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_messages.js">mailnews/db/gloda/test/unit/base_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_messages.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_messages.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_query_messages.js">mailnews/db/gloda/test/unit/base_query_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_query_messages.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_query_messages.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_query_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_query_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/base_query_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/genericIndexer.js">mailnews/db/gloda/test/unit/resources/genericIndexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/genericIndexer.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/genericIndexer.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/genericIndexer.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/genericIndexer.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/genericIndexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/mockIndexer.js">mailnews/db/gloda/test/unit/resources/mockIndexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/mockIndexer.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/mockIndexer.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/mockIndexer.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/mockIndexer.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/resources/mockIndexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content.js">mailnews/db/gloda/test/unit/test_gloda_content.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js">mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_local.js">mailnews/db/gloda/test/unit/test_gloda_content_local.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_local.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_local.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_local.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_local.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_gloda_content_local.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_adaptive.js">mailnews/db/gloda/test/unit/test_index_adaptive.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_adaptive.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_adaptive.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_adaptive.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_addressbook.js">mailnews/db/gloda/test/unit/test_index_addressbook.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_addressbook.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_addressbook.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_addressbook.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_addressbook.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_addressbook.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_bad_messages.js">mailnews/db/gloda/test/unit/test_index_bad_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_bad_messages.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_bad_messages.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_bad_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_bad_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_bad_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_compaction.js">mailnews/db/gloda/test/unit/test_index_compaction.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_compaction.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_compaction.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_compaction.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_compaction.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_compaction.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js">mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_online.js">mailnews/db/gloda/test/unit/test_index_junk_imap_online.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_online.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_online.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_online.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_online.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_imap_online.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_local.js">mailnews/db/gloda/test/unit/test_index_junk_local.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_local.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_local.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_local.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_local.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_junk_local.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages.js">mailnews/db/gloda/test/unit/test_index_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js">mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online.js">mailnews/db/gloda/test/unit/test_index_messages_imap_online.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js">mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_local.js">mailnews/db/gloda/test/unit/test_index_messages_local.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_local.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_local.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_local.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_local.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_messages_local.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">mailnews/db/gloda/test/unit/test_index_sweep_folder.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_intl.js">mailnews/db/gloda/test/unit/test_intl.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_intl.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_intl.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_intl.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_intl.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_intl.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_mime_emitter.js">mailnews/db/gloda/test/unit/test_mime_emitter.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_mime_emitter.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_mime_emitter.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_mime_emitter.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_mime_emitter.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_mime_emitter.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_noun_mimetype.js">mailnews/db/gloda/test/unit/test_noun_mimetype.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_noun_mimetype.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_noun_mimetype.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_noun_mimetype.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_noun_mimetype.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_noun_mimetype.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_core.js">mailnews/db/gloda/test/unit/test_query_core.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_core.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_core.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_core.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_core.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_core.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages.js">mailnews/db/gloda/test/unit/test_query_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js">mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online.js">mailnews/db/gloda/test/unit/test_query_messages_imap_online.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js">mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_local.js">mailnews/db/gloda/test/unit/test_query_messages_local.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_local.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_local.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_local.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_local.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_messages_local.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_search_messages.js">mailnews/db/gloda/test/unit/test_search_messages.js</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_search_messages.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_search_messages.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/db/gloda/test/unit/test_search_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/head_server.js">mailnews/imap/test/unit/head_server.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/head_server.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/head_server.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/head_server.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/head_server.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/head_server.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_autosync_date_constraints.js">mailnews/imap/test/unit/test_autosync_date_constraints.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_autosync_date_constraints.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_autosync_date_constraints.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_autosync_date_constraints.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_autosync_date_constraints.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_autosync_date_constraints.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_imapPasswordFailure.js">mailnews/imap/test/unit/test_imapPasswordFailure.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_imapPasswordFailure.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_imapPasswordFailure.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_imapPasswordFailure.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_imapPasswordFailure.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_imapPasswordFailure.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.cpp">mailnews/local/src/nsLocalMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.h">mailnews/local/src/nsLocalMailFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.h">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.h">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.h">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.h">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsLocalMailFolder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsRssIncomingServer.cpp">mailnews/local/src/nsRssIncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsRssIncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsRssIncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsRssIncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsRssIncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/local/src/nsRssIncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/fakeserver/maild.js">mailnews/test/fakeserver/maild.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/fakeserver/maild.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/fakeserver/maild.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/fakeserver/maild.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/fakeserver/maild.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/fakeserver/maild.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/asyncTestUtils.js">mailnews/test/resources/asyncTestUtils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/asyncTestUtils.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/asyncTestUtils.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/asyncTestUtils.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/asyncTestUtils.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/asyncTestUtils.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/logHelper.js">mailnews/test/resources/logHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/logHelper.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/logHelper.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/logHelper.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/logHelper.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/logHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/mailTestUtils.js">mailnews/test/resources/mailTestUtils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/mailTestUtils.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/mailTestUtils.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/mailTestUtils.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/mailTestUtils.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/mailTestUtils.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageGenerator.js">mailnews/test/resources/messageGenerator.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageGenerator.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageGenerator.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageGenerator.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageGenerator.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageGenerator.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageInjection.js">mailnews/test/resources/messageInjection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageInjection.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageInjection.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageInjection.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageInjection.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageInjection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageModifier.js">mailnews/test/resources/messageModifier.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageModifier.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageModifier.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageModifier.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageModifier.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/messageModifier.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/msgFolderListenerSetup.js">mailnews/test/resources/msgFolderListenerSetup.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/msgFolderListenerSetup.js">file</a> |
<a href="/comm-central/annotate/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/msgFolderListenerSetup.js">annotate</a> |
<a href="/comm-central/diff/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/msgFolderListenerSetup.js">diff</a> |
<a href="/comm-central/comparison/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/msgFolderListenerSetup.js">comparison</a> |
<a href="/comm-central/log/413b2018349cd0f90b7217b5c5a6b73ab97ee66b/mailnews/test/resources/msgFolderListenerSetup.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mail/base/test/unit/resources/viewWrapperTestUtils.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mail/base/test/unit/resources/viewWrapperTestUtils.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -35,27 +35,27 @@</span>
<a href="#l1.4"></a><span id="l1.4">  *</span>
<a href="#l1.5"></a><span id="l1.5">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7"> Components.utils.import(&quot;resource://app/modules/dbViewWrapper.js&quot;);</span>
<a href="#l1.8"></a><span id="l1.8"> Components.utils.import(&quot;resource://app/modules/mailViewManager.js&quot;);</span>
<a href="#l1.9"></a><span id="l1.9"> Components.utils.import(&quot;resource://app/modules/quickSearchManager.js&quot;);</span>
<a href="#l1.10"></a><span id="l1.10"> Components.utils.import(&quot;resource://app/modules/virtualFolderWrapper.js&quot;);</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-var gMessageGenerator, gMessageScenarioFactory;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-</span>
<a href="#l1.14"></a><span id="l1.14"> /**</span>
<a href="#l1.15"></a><span id="l1.15">  * Do initialization for xpcshell-tests; not used by</span>
<a href="#l1.16"></a><span id="l1.16">  *  test-folder-display-helpers.js, our friendly mozmill test helper.</span>
<a href="#l1.17"></a><span id="l1.17">  */</span>
<a href="#l1.18"></a><span id="l1.18"> function initViewWrapperTestUtils() {</span>
<a href="#l1.19"></a><span id="l1.19">   gMessageGenerator = new MessageGenerator();</span>
<a href="#l1.20"></a><span id="l1.20">   gMessageScenarioFactory = new MessageScenarioFactory(gMessageGenerator);</span>
<a href="#l1.21"></a><span id="l1.21"> </span>
<a href="#l1.22"></a><span id="l1.22">   async_test_runner_register_helper(VWTU_testHelper);</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+  register_message_injection_listener(VWTU_testHelper);</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l1.25"></a><span id="l1.25"> }</span>
<a href="#l1.26"></a><span id="l1.26"> </span>
<a href="#l1.27"></a><span id="l1.27"> // something less sucky than do_check_true</span>
<a href="#l1.28"></a><span id="l1.28"> function assert_true(aBeTrue, aWhy, aDumpView) {</span>
<a href="#l1.29"></a><span id="l1.29">   if (!aBeTrue) {</span>
<a href="#l1.30"></a><span id="l1.30">     if (aDumpView)</span>
<a href="#l1.31"></a><span id="l1.31">       dump_view_state(VWTU_testHelper.active_view_wrappers[0]);</span>
<a href="#l1.32"></a><span id="l1.32">     do_throw(aWhy);</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineat">@@ -142,16 +142,20 @@ function punt() {</span>
<a href="#l1.34"></a><span id="l1.34">  *  a test completes, but also so we can provide useful information about the</span>
<a href="#l1.35"></a><span id="l1.35">  *  state of things if a test times out.</span>
<a href="#l1.36"></a><span id="l1.36">  */</span>
<a href="#l1.37"></a><span id="l1.37"> var VWTU_testHelper = {</span>
<a href="#l1.38"></a><span id="l1.38">   active_view_wrappers: [],</span>
<a href="#l1.39"></a><span id="l1.39">   active_real_folders: [],</span>
<a href="#l1.40"></a><span id="l1.40">   active_virtual_folders: [],</span>
<a href="#l1.41"></a><span id="l1.41"> </span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+  onVirtualFolderCreated: function(aVirtualFolder) {</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+    this.active_virtual_folders.push(aVirtualFolder);</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  },</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+</span>
<a href="#l1.46"></a><span id="l1.46">   postTest: function () {</span>
<a href="#l1.47"></a><span id="l1.47">     // close all the views we opened</span>
<a href="#l1.48"></a><span id="l1.48">     this.active_view_wrappers.forEach(function (wrapper) {</span>
<a href="#l1.49"></a><span id="l1.49">       wrapper.close();</span>
<a href="#l1.50"></a><span id="l1.50">     });</span>
<a href="#l1.51"></a><span id="l1.51">     // verify that the notification helper has no outstanding listeners.</span>
<a href="#l1.52"></a><span id="l1.52">     if (IDBViewWrapperListener.prototype._FNH.haveListeners()) {</span>
<a href="#l1.53"></a><span id="l1.53">       let msg = &quot;FolderNotificationHelper has listeners, but should not.&quot;;</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineat">@@ -243,29 +247,16 @@ function async_view_refresh(aViewWrapper</span>
<a href="#l1.55"></a><span id="l1.55">  *  manually, then poke at the view, then call us to end the view update.</span>
<a href="#l1.56"></a><span id="l1.56">  */</span>
<a href="#l1.57"></a><span id="l1.57"> function async_view_end_update(aViewWrapper) {</span>
<a href="#l1.58"></a><span id="l1.58">   aViewWrapper.listener.pendingLoad = true;</span>
<a href="#l1.59"></a><span id="l1.59">   aViewWrapper.endViewUpdate();</span>
<a href="#l1.60"></a><span id="l1.60">   return false;</span>
<a href="#l1.61"></a><span id="l1.61"> }</span>
<a href="#l1.62"></a><span id="l1.62"> </span>
<a href="#l1.63"></a><span id="l1.63" class="difflineminus">-var gNextUniqueFolderId = 0;</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineminus">-/**</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineminus">- * Create and return an empty local folder.  If you want to delete this folder</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineminus">- *  you must call delete_folder to kill it!</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineminus">- */</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineminus">-function make_empty_folder() {</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineminus">-  let name = &quot;gabba&quot; + gNextUniqueFolderId++;</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineminus">-  let testFolder = gLocalIncomingServer.rootMsgFolder.addSubfolder(name);</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineminus">-  // track it for cleanup or error reporting (if the test hangs)</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineminus">-  VWTU_testHelper.active_real_folders.push(testFolder);</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineminus">-  return testFolder;</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineminus">-}</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineminus">-</span>
<a href="#l1.76"></a><span id="l1.76"> /**</span>
<a href="#l1.77"></a><span id="l1.77">  * The deletion is asynchronous from a view perspective because the view ends</span>
<a href="#l1.78"></a><span id="l1.78">  *  up re-creating itself which triggers a new search.  This function is</span>
<a href="#l1.79"></a><span id="l1.79">  *  nominally asynchronous because we refresh XFVF views when one of their</span>
<a href="#l1.80"></a><span id="l1.80">  *  folders gets deleted.  In that case, you must pass the view wrapper you</span>
<a href="#l1.81"></a><span id="l1.81">  *  expect to be affected so we can do our async thing.</span>
<a href="#l1.82"></a><span id="l1.82">  * If, however, you are deleting the last folder that belongs to a view, you</span>
<a href="#l1.83"></a><span id="l1.83">  *  should not pass a view wrapper, because you should expect the view wrapper</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineat">@@ -300,69 +291,16 @@ function async_delete_folder(aFolder, aV</span>
<a href="#l1.85"></a><span id="l1.85">   // ...so now the stupid folder is in the stupid trash</span>
<a href="#l1.86"></a><span id="l1.86">   // let's empty the trash, then, shall we?</span>
<a href="#l1.87"></a><span id="l1.87">   // (for local folders it doesn't matter who we call this on.)</span>
<a href="#l1.88"></a><span id="l1.88">   aFolder.emptyTrash(null, null);</span>
<a href="#l1.89"></a><span id="l1.89">   return false;</span>
<a href="#l1.90"></a><span id="l1.90"> }</span>
<a href="#l1.91"></a><span id="l1.91"> var delete_folder = async_delete_folder;</span>
<a href="#l1.92"></a><span id="l1.92"> </span>
<a href="#l1.93"></a><span id="l1.93" class="difflineminus">-SEARCH_TERM_MAP_HELPER = {</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineminus">-  subject: Components.interfaces.nsMsgSearchAttrib.Subject,</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineminus">-  body: Components.interfaces.nsMsgSearchAttrib.Body,</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineminus">-  from: Components.interfaces.nsMsgSearchAttrib.Sender,</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineminus">-  to: Components.interfaces.nsMsgSearchAttrib.To,</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineminus">-  cc: Components.interfaces.nsMsgSearchAttrib.CC,</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineminus">-  recipient: Components.interfaces.nsMsgSearchAttrib.ToOrCC,</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineminus">-  involves: Components.interfaces.nsMsgSearchAttrib.AllAddresses,</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineminus">-  age: Components.interfaces.nsMsgSearchAttrib.AgeInDays,</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineminus">-  tags: Components.interfaces.nsMsgSearchAttrib.Keywords,</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineminus">-};</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineminus">-/**</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineminus">- * Create and return a virtual folder.</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineminus">- *</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineminus">- * @param aFolders The real folders this virtual folder should draw from.</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineminus">- * @param aSearchDef The search definition to use to build the list of search</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineminus">- *     terms that populate this virtual folder.  Keys should be stuff from</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineminus">- *     SEARCH_TERM_MAP_HELPER and values should be strings to search for within</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineminus">- *     those attribute things.</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineminus">- * @param aBooleanAnd Should the search terms be and-ed together.</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineminus">- * @param [aName] Name to use.</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineminus">- */</span>
<a href="#l1.115"></a><span id="l1.115" class="difflineminus">-function make_virtual_folder(aFolders, aSearchDef, aBooleanAnd, aName) {</span>
<a href="#l1.116"></a><span id="l1.116" class="difflineminus">-  let name = aName ? aName : &quot;virt&quot; + gNextUniqueFolderId++;</span>
<a href="#l1.117"></a><span id="l1.117" class="difflineminus">-</span>
<a href="#l1.118"></a><span id="l1.118" class="difflineminus">-  let terms = [];</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineminus">-  let termCreator = Components.classes[&quot;@mozilla.org/messenger/searchSession;1&quot;]</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineminus">-                              .createInstance(Ci.nsIMsgSearchSession);</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineminus">-  for each (let [key, val] in Iterator(aSearchDef)) {</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineminus">-    let term = termCreator.createTerm();</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineminus">-    let value = term.value;</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-    value.str = val;</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineminus">-    term.value = value;</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineminus">-    term.attrib = SEARCH_TERM_MAP_HELPER[key];</span>
<a href="#l1.127"></a><span id="l1.127" class="difflineminus">-    term.op = Components.interfaces.nsMsgSearchOp.Contains;</span>
<a href="#l1.128"></a><span id="l1.128" class="difflineminus">-    term.booleanAnd = Boolean(aBooleanAnd);</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineminus">-    terms.push(term);</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineminus">-  }</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineminus">-  // create an ALL case if we didn't add any terms</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineminus">-  if (terms.length == 0) {</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineminus">-    let term = termCreator.createTerm();</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineminus">-    term.matchAll = true;</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineminus">-    terms.push(term);</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineminus">-  }</span>
<a href="#l1.137"></a><span id="l1.137" class="difflineminus">-</span>
<a href="#l1.138"></a><span id="l1.138" class="difflineminus">-  let wrapped = VirtualFolderHelper.createNewVirtualFolder(</span>
<a href="#l1.139"></a><span id="l1.139" class="difflineminus">-    name, gLocalIncomingServer.rootMsgFolder, aFolders, terms,</span>
<a href="#l1.140"></a><span id="l1.140" class="difflineminus">-    /* online */ false);</span>
<a href="#l1.141"></a><span id="l1.141" class="difflineminus">-  // track it for cleanup or error reporting (if the test hangs)</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineminus">-  VWTU_testHelper.active_virtual_folders.push(wrapped.virtualFolder);</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineminus">-  return wrapped.virtualFolder;</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineminus">-}</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineminus">-</span>
<a href="#l1.146"></a><span id="l1.146"> /**</span>
<a href="#l1.147"></a><span id="l1.147">  * For assistance in debugging, dump information about a message header.</span>
<a href="#l1.148"></a><span id="l1.148">  */</span>
<a href="#l1.149"></a><span id="l1.149"> function dump_message_header(aMsgHdr) {</span>
<a href="#l1.150"></a><span id="l1.150">   dump(&quot;  Subject: &quot; + aMsgHdr.mime2DecodedSubject + &quot;\n&quot;);</span>
<a href="#l1.151"></a><span id="l1.151">   dump(&quot;  Date: &quot; + new Date(aMsgHdr.date / 1000) + &quot;\n&quot;);</span>
<a href="#l1.152"></a><span id="l1.152">   dump(&quot;  Author: &quot; + aMsgHdr.mime2DecodedAuthor + &quot;\n&quot;);</span>
<a href="#l1.153"></a><span id="l1.153">   dump(&quot;  Recipients: &quot; + aMsgHdr.mime2DecodedRecipients + &quot;\n&quot;);</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineat">@@ -573,184 +511,35 @@ function verify_view_row_at_index_is_dum</span>
<a href="#l1.155"></a><span id="l1.155">     let flags = aViewWrapper.dbView.getFlagsAt(viewIndex);</span>
<a href="#l1.156"></a><span id="l1.156">     if (!(flags &amp; MSG_VIEW_FLAG_DUMMY)) {</span>
<a href="#l1.157"></a><span id="l1.157">       dump_view_state(aViewWrapper);</span>
<a href="#l1.158"></a><span id="l1.158">       do_throw(&quot;Expected a dummy header at view index &quot; + viewIndex);</span>
<a href="#l1.159"></a><span id="l1.159">     }</span>
<a href="#l1.160"></a><span id="l1.160">   }</span>
<a href="#l1.161"></a><span id="l1.161"> }</span>
<a href="#l1.162"></a><span id="l1.162"> </span>
<a href="#l1.163"></a><span id="l1.163" class="difflineminus">-</span>
<a href="#l1.164"></a><span id="l1.164"> /**</span>
<a href="#l1.165"></a><span id="l1.165">  * Expand all nodes in the view wrapper.  This is a debug helper function</span>
<a href="#l1.166"></a><span id="l1.166">  *  because there's no good reason to have it be on the view wrapper at this</span>
<a href="#l1.167"></a><span id="l1.167">  *  time.  You must call async_view_refresh or async_view_end_update (if you are</span>
<a href="#l1.168"></a><span id="l1.168">  *  within a view update batch) after calling this!</span>
<a href="#l1.169"></a><span id="l1.169">  */</span>
<a href="#l1.170"></a><span id="l1.170"> function view_expand_all(aViewWrapper) {</span>
<a href="#l1.171"></a><span id="l1.171">   // we can't use the command because it has assertions about having a tree.</span>
<a href="#l1.172"></a><span id="l1.172">   aViewWrapper._viewFlags |= Ci.nsMsgViewFlagsType.kExpandAll;</span>
<a href="#l1.173"></a><span id="l1.173"> }</span>
<a href="#l1.174"></a><span id="l1.174"> </span>
<a href="#l1.175"></a><span id="l1.175"> /**</span>
<a href="#l1.176"></a><span id="l1.176" class="difflineminus">- * Create a new local folder, populating it with messages according to the set</span>
<a href="#l1.177"></a><span id="l1.177" class="difflineminus">- *  definition provided.</span>
<a href="#l1.178"></a><span id="l1.178" class="difflineminus">- *</span>
<a href="#l1.179"></a><span id="l1.179" class="difflineminus">- * @param aSynSetDefs A synthetic set definition, as appropriate to pass to</span>
<a href="#l1.180"></a><span id="l1.180" class="difflineminus">- *     make_new_sets_in_folder.</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineminus">- * @return A list whose first element is the nsIMsgLocalMailFolder created and</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineminus">- *     whose subsequent items are the SyntheticMessageSets used to populate the</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineminus">- *     folder (as returned by make_new_sets_in_folder).</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineminus">- */</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineminus">-function make_folder_with_sets(aSynSetDefs) {</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineminus">-  let msgFolder = make_empty_folder();</span>
<a href="#l1.187"></a><span id="l1.187" class="difflineminus">-  let results = make_new_sets_in_folder(msgFolder, aSynSetDefs);</span>
<a href="#l1.188"></a><span id="l1.188" class="difflineminus">-  results.unshift(msgFolder);</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineminus">-  return results;</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineminus">-}</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineminus">-</span>
<a href="#l1.192"></a><span id="l1.192" class="difflineminus">-/**</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineminus">- * Create multiple new local folders, populating them with messages according to</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineminus">- *  the set definitions provided.  Differs from make_folder_with_sets by taking</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineminus">- *  the number of folders to create and return the list of created folders as</span>
<a href="#l1.196"></a><span id="l1.196" class="difflineminus">- *  the first element in the returned list.  This method is simple enough that</span>
<a href="#l1.197"></a><span id="l1.197" class="difflineminus">- *  the limited code duplication is deemed acceptable in support of readability.</span>
<a href="#l1.198"></a><span id="l1.198" class="difflineminus">- *</span>
<a href="#l1.199"></a><span id="l1.199" class="difflineminus">- * @param aSynSetDefs A synthetic set definition, as appropriate to pass to</span>
<a href="#l1.200"></a><span id="l1.200" class="difflineminus">- *     make_new_sets_in_folder.</span>
<a href="#l1.201"></a><span id="l1.201" class="difflineminus">- * @return A list whose first element is the nsIMsgLocalMailFolder created and</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineminus">- *     whose subsequent items are the SyntheticMessageSets used to populate the</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineminus">- *     folder (as returned by make_new_sets_in_folder).</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineminus">- */</span>
<a href="#l1.205"></a><span id="l1.205" class="difflineminus">-function make_folders_with_sets(aFolderCount, aSynSetDefs) {</span>
<a href="#l1.206"></a><span id="l1.206" class="difflineminus">-  let msgFolders = [];</span>
<a href="#l1.207"></a><span id="l1.207" class="difflineminus">-  for (let i = 0; i &lt; aFolderCount; i++)</span>
<a href="#l1.208"></a><span id="l1.208" class="difflineminus">-    msgFolders.push(make_empty_folder());</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineminus">-  let results = make_new_sets_in_folders(msgFolders, aSynSetDefs);</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineminus">-  results.unshift(msgFolders);</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineminus">-  return results;</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineminus">-}</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineminus">-</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineminus">-/**</span>
<a href="#l1.215"></a><span id="l1.215" class="difflineminus">- * Given one or more existing local folder, create new message sets and add them</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineminus">- *  to the folders using</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineminus">- *</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineminus">- * @param aMsgFolders A single nsIMsgLocalMailFolder or a list of them.  The</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineminus">- *     synthetic messages will be added to the folder(s).</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineminus">- * @param aSynSetDefs Either an integer describing the number of sets of</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineminus">- *     messages to create (using default parameters), or a list of set</span>
<a href="#l1.222"></a><span id="l1.222" class="difflineminus">- *     definition objects as defined by MessageGenerator.makeMessages.</span>
<a href="#l1.223"></a><span id="l1.223" class="difflineminus">- * @return A list of SyntheticMessageSet objects, each corresponding to the</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineminus">- *     entry in aSynSetDefs (or implied if an integer was passed).</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineminus">- */</span>
<a href="#l1.226"></a><span id="l1.226" class="difflineminus">-function make_new_sets_in_folders(aMsgFolders, aSynSetDefs) {</span>
<a href="#l1.227"></a><span id="l1.227" class="difflineminus">-  // is it just a count of the number of plain vanilla sets to create?</span>
<a href="#l1.228"></a><span id="l1.228" class="difflineminus">-  if (typeof(aSynSetDefs) == &quot;number&quot;) {</span>
<a href="#l1.229"></a><span id="l1.229" class="difflineminus">-    let setCount = aSynSetDefs;</span>
<a href="#l1.230"></a><span id="l1.230" class="difflineminus">-    aSynSetDefs = [];</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineminus">-    for (let iSet = 0; iSet &lt; setCount; iSet++)</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineminus">-      aSynSetDefs.push({});</span>
<a href="#l1.233"></a><span id="l1.233" class="difflineminus">-  }</span>
<a href="#l1.234"></a><span id="l1.234" class="difflineminus">-  // now it must be a list of set descriptors</span>
<a href="#l1.235"></a><span id="l1.235" class="difflineminus">-</span>
<a href="#l1.236"></a><span id="l1.236" class="difflineminus">-  // - create the synthetic message sets</span>
<a href="#l1.237"></a><span id="l1.237" class="difflineminus">-  let messageSets = [];</span>
<a href="#l1.238"></a><span id="l1.238" class="difflineminus">-  for each (let [, synSetDef] in Iterator(aSynSetDefs)) {</span>
<a href="#l1.239"></a><span id="l1.239" class="difflineminus">-    let messages = gMessageGenerator.makeMessages(synSetDef);</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineminus">-    messageSets.push(new SyntheticMessageSet(messages));</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineminus">-  }</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineminus">-</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineminus">-  // - add the messages to the folders (interleaving them)</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineminus">-  add_sets_to_folders(aMsgFolders, messageSets);</span>
<a href="#l1.245"></a><span id="l1.245" class="difflineminus">-</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineminus">-  return messageSets;</span>
<a href="#l1.247"></a><span id="l1.247" class="difflineminus">-}</span>
<a href="#l1.248"></a><span id="l1.248" class="difflineminus">-/** singular folder alias for single-folder users' readability */</span>
<a href="#l1.249"></a><span id="l1.249" class="difflineminus">-let make_new_sets_in_folder = make_new_sets_in_folders;</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineminus">-</span>
<a href="#l1.251"></a><span id="l1.251" class="difflineminus">-/**</span>
<a href="#l1.252"></a><span id="l1.252" class="difflineminus">- * An iterator that generates an infinite sequence of its argument.  So</span>
<a href="#l1.253"></a><span id="l1.253" class="difflineminus">- *  _looperator(1, 2, 3) will generate the iteration stream: [1, 2, 3, 1, 2, 3,</span>
<a href="#l1.254"></a><span id="l1.254" class="difflineminus">- *  1, 2, 3, ...].  For use by add_sets_across_folders.</span>
<a href="#l1.255"></a><span id="l1.255" class="difflineminus">- */</span>
<a href="#l1.256"></a><span id="l1.256" class="difflineminus">-function _looperator(aList) {</span>
<a href="#l1.257"></a><span id="l1.257" class="difflineminus">-  if (aList.length == 0)</span>
<a href="#l1.258"></a><span id="l1.258" class="difflineminus">-    throw Exception(&quot;aList must have at least one item!&quot;);</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineminus">-</span>
<a href="#l1.260"></a><span id="l1.260" class="difflineminus">-  let i = 0, length = aList.length;</span>
<a href="#l1.261"></a><span id="l1.261" class="difflineminus">-  while (true) {</span>
<a href="#l1.262"></a><span id="l1.262" class="difflineminus">-    yield aList[i];</span>
<a href="#l1.263"></a><span id="l1.263" class="difflineminus">-    i = (i + 1) % length;</span>
<a href="#l1.264"></a><span id="l1.264" class="difflineminus">-  }</span>
<a href="#l1.265"></a><span id="l1.265" class="difflineminus">-}</span>
<a href="#l1.266"></a><span id="l1.266" class="difflineminus">-</span>
<a href="#l1.267"></a><span id="l1.267" class="difflineminus">-/**</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineminus">- * Spreads the messages in aMessageSets across the folders in aMsgFolders.  Each</span>
<a href="#l1.269"></a><span id="l1.269" class="difflineminus">- *  message set is spread in a round-robin fashion across all folders.  At the</span>
<a href="#l1.270"></a><span id="l1.270" class="difflineminus">- *  same time, each message-sets insertion is interleaved with the other message</span>
<a href="#l1.271"></a><span id="l1.271" class="difflineminus">- *  sets.  This distributes message across multiple folders for useful</span>
<a href="#l1.272"></a><span id="l1.272" class="difflineminus">- *  cross-folder threading testing (via the round robin) while also hopefully</span>
<a href="#l1.273"></a><span id="l1.273" class="difflineminus">- *  avoiding making things pathologically easy for the code under test (by way</span>
<a href="#l1.274"></a><span id="l1.274" class="difflineminus">- *  of the interleaving.)</span>
<a href="#l1.275"></a><span id="l1.275" class="difflineminus">- *</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineminus">- * For example, given the following 2 input message sets:</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineminus">- *  message set 'lower': [a b c d e f]</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineminus">- *  message set 'upper': [A B C D E F G H]</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineminus">- *</span>
<a href="#l1.280"></a><span id="l1.280" class="difflineminus">- * across 2 folders:</span>
<a href="#l1.281"></a><span id="l1.281" class="difflineminus">- *  folder 1: [a A c C e E G]</span>
<a href="#l1.282"></a><span id="l1.282" class="difflineminus">- *  folder 2: [b B d D f F H</span>
<a href="#l1.283"></a><span id="l1.283" class="difflineminus">- * across 3 folders:</span>
<a href="#l1.284"></a><span id="l1.284" class="difflineminus">- *  folder 1: [a A d D G]</span>
<a href="#l1.285"></a><span id="l1.285" class="difflineminus">- *  folder 2: [b B e E H]</span>
<a href="#l1.286"></a><span id="l1.286" class="difflineminus">- *  folder 3: [c C f F]</span>
<a href="#l1.287"></a><span id="l1.287" class="difflineminus">- *</span>
<a href="#l1.288"></a><span id="l1.288" class="difflineminus">- * @param aMsgFolders An nsIMsgLocalMailFolder to add the message sets to or a</span>
<a href="#l1.289"></a><span id="l1.289" class="difflineminus">- *     list of them.</span>
<a href="#l1.290"></a><span id="l1.290" class="difflineminus">- * @param aMessageSets A list of SyntheticMessageSets.</span>
<a href="#l1.291"></a><span id="l1.291" class="difflineminus">- */</span>
<a href="#l1.292"></a><span id="l1.292" class="difflineminus">-function add_sets_to_folders(aMsgFolders, aMessageSets) {</span>
<a href="#l1.293"></a><span id="l1.293" class="difflineminus">-  if (!('length' in aMsgFolders))</span>
<a href="#l1.294"></a><span id="l1.294" class="difflineminus">-    aMsgFolders = [aMsgFolders];</span>
<a href="#l1.295"></a><span id="l1.295" class="difflineminus">-</span>
<a href="#l1.296"></a><span id="l1.296" class="difflineminus">-  for each (let [, folder] in Iterator(aMsgFolders)) {</span>
<a href="#l1.297"></a><span id="l1.297" class="difflineminus">-    if (!(folder instanceof Components.interfaces.nsIMsgLocalMailFolder))</span>
<a href="#l1.298"></a><span id="l1.298" class="difflineminus">-      throw Exception(&quot;All folders in aMsgFolders must be local folders!&quot;);</span>
<a href="#l1.299"></a><span id="l1.299" class="difflineminus">-  }</span>
<a href="#l1.300"></a><span id="l1.300" class="difflineminus">-</span>
<a href="#l1.301"></a><span id="l1.301" class="difflineminus">-  let iterFolders = _looperator(aMsgFolders);</span>
<a href="#l1.302"></a><span id="l1.302" class="difflineminus">-</span>
<a href="#l1.303"></a><span id="l1.303" class="difflineminus">-  let iPerSet = 0, folder = iterFolders.next();</span>
<a href="#l1.304"></a><span id="l1.304" class="difflineminus">-  // loop, incrementing our subscript until all message sets are out of messages</span>
<a href="#l1.305"></a><span id="l1.305" class="difflineminus">-  let didSomething;</span>
<a href="#l1.306"></a><span id="l1.306" class="difflineminus">-  do {</span>
<a href="#l1.307"></a><span id="l1.307" class="difflineminus">-    didSomething = false;</span>
<a href="#l1.308"></a><span id="l1.308" class="difflineminus">-    // for each message set, if it is not out of messages, add the message</span>
<a href="#l1.309"></a><span id="l1.309" class="difflineminus">-    for each (let [, messageSet] in Iterator(aMessageSets)) {</span>
<a href="#l1.310"></a><span id="l1.310" class="difflineminus">-      if (iPerSet &lt; messageSet.synMessages.length) {</span>
<a href="#l1.311"></a><span id="l1.311" class="difflineminus">-        messageSet.addMessageToFolderByIndex(folder, iPerSet);</span>
<a href="#l1.312"></a><span id="l1.312" class="difflineminus">-        folder.hasNewMessages = true;</span>
<a href="#l1.313"></a><span id="l1.313" class="difflineminus">-        didSomething = true;</span>
<a href="#l1.314"></a><span id="l1.314" class="difflineminus">-      }</span>
<a href="#l1.315"></a><span id="l1.315" class="difflineminus">-    }</span>
<a href="#l1.316"></a><span id="l1.316" class="difflineminus">-    iPerSet++;</span>
<a href="#l1.317"></a><span id="l1.317" class="difflineminus">-    folder = iterFolders.next();</span>
<a href="#l1.318"></a><span id="l1.318" class="difflineminus">-  } while (didSomething);</span>
<a href="#l1.319"></a><span id="l1.319" class="difflineminus">-}</span>
<a href="#l1.320"></a><span id="l1.320" class="difflineminus">-/** singular function name for understandability of single-folder users */</span>
<a href="#l1.321"></a><span id="l1.321" class="difflineminus">-let add_sets_to_folder = add_sets_to_folders;</span>
<a href="#l1.322"></a><span id="l1.322" class="difflineminus">-</span>
<a href="#l1.323"></a><span id="l1.323" class="difflineminus">-/**</span>
<a href="#l1.324"></a><span id="l1.324">  * Create a name and address pair where the provided word is part of the name.</span>
<a href="#l1.325"></a><span id="l1.325">  */</span>
<a href="#l1.326"></a><span id="l1.326"> function make_person_with_word_in_name(aWord) {</span>
<a href="#l1.327"></a><span id="l1.327">   let dude = gMessageGenerator.makeNameAndAddress();</span>
<a href="#l1.328"></a><span id="l1.328">   return [aWord, dude[1]];</span>
<a href="#l1.329"></a><span id="l1.329"> }</span>
<a href="#l1.330"></a><span id="l1.330"> </span>
<a href="#l1.331"></a><span id="l1.331"> /**</span>
<a href="#l1.332"></a><span id="l1.332">  * Create a name and address pair where the provided word is part of the mail</span>
<a href="#l1.333"></a><span id="l1.333">  *  address.</span>
<a href="#l1.334"></a><span id="l1.334">  */</span>
<a href="#l1.335"></a><span id="l1.335"> function make_person_with_word_in_address(aWord) {</span>
<a href="#l1.336"></a><span id="l1.336">   let dude = gMessageGenerator.makeNameAndAddress();</span>
<a href="#l1.337"></a><span id="l1.337">   return [dude[0], aWord + &quot;@madeup.nul&quot;];</span>
<a href="#l1.338"></a><span id="l1.338" class="difflineminus">-}</span>
<a href="#l1.339"></a><span id="l1.339">\ No newline at end of file</span>
<a href="#l1.340"></a><span id="l1.340" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mail/base/test/unit/test_viewWrapper_logic.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mail/base/test/unit/test_viewWrapper_logic.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -1,11 +1,14 @@</span>
<a href="#l2.4"></a><span id="l2.4" class="difflineplus">+load(&quot;../../mailnews/resources/logHelper.js&quot;);</span>
<a href="#l2.5"></a><span id="l2.5" class="difflineplus">+load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l2.6"></a><span id="l2.6" class="difflineplus">+</span>
<a href="#l2.7"></a><span id="l2.7"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l2.8"></a><span id="l2.8"> load(&quot;../../mailnews/resources/messageModifier.js&quot;);</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineminus">-load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l2.10"></a><span id="l2.10" class="difflineplus">+load(&quot;../../mailnews/resources/messageInjection.js&quot;);</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12"> load(&quot;resources/viewWrapperTestUtils.js&quot;);</span>
<a href="#l2.13"></a><span id="l2.13"> initViewWrapperTestUtils();</span>
<a href="#l2.14"></a><span id="l2.14"> </span>
<a href="#l2.15"></a><span id="l2.15"> /**</span>
<a href="#l2.16"></a><span id="l2.16">  * Verify that flipping between threading and grouped by sort settings properly</span>
<a href="#l2.17"></a><span id="l2.17">  *  clears the other flag.  (Because they're mutually exclusive, you see.)</span>
<a href="#l2.18"></a><span id="l2.18">  */</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineat">@@ -251,11 +254,10 @@ var tests = [</span>
<a href="#l2.20"></a><span id="l2.20">   test_sort_primary,</span>
<a href="#l2.21"></a><span id="l2.21">   test_sort_secondary_explicit,</span>
<a href="#l2.22"></a><span id="l2.22">   test_sort_secondary_implicit,</span>
<a href="#l2.23"></a><span id="l2.23">   test_mailviews_persistence,</span>
<a href="#l2.24"></a><span id="l2.24">   test_view_update_depth_logic,</span>
<a href="#l2.25"></a><span id="l2.25"> ];</span>
<a href="#l2.26"></a><span id="l2.26"> </span>
<a href="#l2.27"></a><span id="l2.27"> function run_test() {</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineminus">-  loadLocalMailAccount();</span>
<a href="#l2.29"></a><span id="l2.29">   async_run_tests(tests);</span>
<a href="#l2.30"></a><span id="l2.30"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mail/base/test/unit/test_viewWrapper_realFolder.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mail/base/test/unit/test_viewWrapper_realFolder.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -1,17 +1,20 @@</span>
<a href="#l3.4"></a><span id="l3.4"> /**</span>
<a href="#l3.5"></a><span id="l3.5">  * Test DBViewWrapper against a single local folder.  Try and test all the</span>
<a href="#l3.6"></a><span id="l3.6">  *  features we can without having a fake newsgroup.  (Some features are</span>
<a href="#l3.7"></a><span id="l3.7">  *  newsgroup specific.)</span>
<a href="#l3.8"></a><span id="l3.8">  */</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+load(&quot;../../mailnews/resources/logHelper.js&quot;);</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+</span>
<a href="#l3.13"></a><span id="l3.13"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l3.14"></a><span id="l3.14"> load(&quot;../../mailnews/resources/messageModifier.js&quot;);</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">-load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+load(&quot;../../mailnews/resources/messageInjection.js&quot;);</span>
<a href="#l3.17"></a><span id="l3.17"> </span>
<a href="#l3.18"></a><span id="l3.18"> load(&quot;resources/viewWrapperTestUtils.js&quot;);</span>
<a href="#l3.19"></a><span id="l3.19"> initViewWrapperTestUtils();</span>
<a href="#l3.20"></a><span id="l3.20"> </span>
<a href="#l3.21"></a><span id="l3.21"> /* ===== Real Folder, no features ===== */</span>
<a href="#l3.22"></a><span id="l3.22"> </span>
<a href="#l3.23"></a><span id="l3.23"> /**</span>
<a href="#l3.24"></a><span id="l3.24">  * Open a pre-populated real folder, make sure all the messages show up.</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineat">@@ -39,21 +42,21 @@ function test_real_folder_update() {</span>
<a href="#l3.26"></a><span id="l3.26">   let [setOne] = make_new_sets_in_folder(msgFolder, 1);</span>
<a href="#l3.27"></a><span id="l3.27">   verify_messages_in_view(setOne, viewWrapper);</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29">   // add more messages! (some -&gt; more)</span>
<a href="#l3.30"></a><span id="l3.30">   let [setTwo] = make_new_sets_in_folder(msgFolder, 1);</span>
<a href="#l3.31"></a><span id="l3.31">   verify_messages_in_view([setOne, setTwo], viewWrapper);</span>
<a href="#l3.32"></a><span id="l3.32"> </span>
<a href="#l3.33"></a><span id="l3.33">   // remove the first set of messages (more -&gt; some)</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">-  yield async_delete_messages(setOne);</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+  yield async_trash_messages(setOne);</span>
<a href="#l3.36"></a><span id="l3.36">   verify_messages_in_view(setTwo, viewWrapper);</span>
<a href="#l3.37"></a><span id="l3.37"> </span>
<a href="#l3.38"></a><span id="l3.38">   // remove the second set of messages (some -&gt; none)</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineminus">-  yield async_delete_messages(setTwo);</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+  yield async_trash_messages(setTwo);</span>
<a href="#l3.41"></a><span id="l3.41">   verify_empty_view(viewWrapper);</span>
<a href="#l3.42"></a><span id="l3.42"> </span>
<a href="#l3.43"></a><span id="l3.43"> }</span>
<a href="#l3.44"></a><span id="l3.44"> </span>
<a href="#l3.45"></a><span id="l3.45"> /**</span>
<a href="#l3.46"></a><span id="l3.46">  * Open a real folder, verify, open another folder, verify.  We are testing</span>
<a href="#l3.47"></a><span id="l3.47">  *  ability to change folders without exploding.</span>
<a href="#l3.48"></a><span id="l3.48">  */</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineat">@@ -756,11 +759,10 @@ var tests = [</span>
<a href="#l3.50"></a><span id="l3.50">   // - special views</span>
<a href="#l3.51"></a><span id="l3.51">   test_real_folder_special_views_threads_with_unread,</span>
<a href="#l3.52"></a><span id="l3.52">   test_real_folder_special_views_persist,</span>
<a href="#l3.53"></a><span id="l3.53">   // (we cannot test the watched threads with unread case in local folders)</span>
<a href="#l3.54"></a><span id="l3.54">   test_real_folder_mark_read_on_exit,</span>
<a href="#l3.55"></a><span id="l3.55"> ];</span>
<a href="#l3.56"></a><span id="l3.56"> </span>
<a href="#l3.57"></a><span id="l3.57"> function run_test() {</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineminus">-  loadLocalMailAccount();</span>
<a href="#l3.59"></a><span id="l3.59">   async_run_tests(tests);</span>
<a href="#l3.60"></a><span id="l3.60"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mail/base/test/unit/test_viewWrapper_virtualFolder.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mail/base/test/unit/test_viewWrapper_virtualFolder.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -6,19 +6,22 @@</span>
<a href="#l4.4"></a><span id="l4.4">  *   view's problem!  (We test it in the real folder to make sure we are telling</span>
<a href="#l4.5"></a><span id="l4.5">  *   it to do things correctly.)</span>
<a href="#l4.6"></a><span id="l4.6">  * - view flags.  Again, it's a db view issue once we're sure we set the bits.</span>
<a href="#l4.7"></a><span id="l4.7">  * - special view with threads.  same deal.</span>
<a href="#l4.8"></a><span id="l4.8">  *</span>
<a href="#l4.9"></a><span id="l4.9">  * We could test all these things, but my patch is way behind schedule...</span>
<a href="#l4.10"></a><span id="l4.10">  */</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+load(&quot;../../mailnews/resources/logHelper.js&quot;);</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+</span>
<a href="#l4.15"></a><span id="l4.15"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l4.16"></a><span id="l4.16"> load(&quot;../../mailnews/resources/messageModifier.js&quot;);</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">-load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+load(&quot;../../mailnews/resources/messageInjection.js&quot;);</span>
<a href="#l4.19"></a><span id="l4.19"> </span>
<a href="#l4.20"></a><span id="l4.20"> load(&quot;resources/viewWrapperTestUtils.js&quot;);</span>
<a href="#l4.21"></a><span id="l4.21"> initViewWrapperTestUtils();</span>
<a href="#l4.22"></a><span id="l4.22"> </span>
<a href="#l4.23"></a><span id="l4.23"> /**</span>
<a href="#l4.24"></a><span id="l4.24">  * Make sure we open a virtual folder backed by a single underlying folder</span>
<a href="#l4.25"></a><span id="l4.25">  *  correctly; no constraints.</span>
<a href="#l4.26"></a><span id="l4.26">  */</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineat">@@ -456,11 +459,10 @@ var tests = [</span>
<a href="#l4.28"></a><span id="l4.28">   // -- quick search (parameterized for single and multi folder cases)</span>
<a href="#l4.29"></a><span id="l4.29">   parameterizeTest(test_virtual_folder_param_quick_search_simple, [1, 4]),</span>
<a href="#l4.30"></a><span id="l4.30">   parameterizeTest(test_virtual_folder_param_quick_search_complex, [1, 4]),</span>
<a href="#l4.31"></a><span id="l4.31">   // -- mail view with quick search</span>
<a href="#l4.32"></a><span id="l4.32">   parameterizeTest(test_virtual_folder_param_mail_view_and_quick_search,[1, 4]),</span>
<a href="#l4.33"></a><span id="l4.33"> ];</span>
<a href="#l4.34"></a><span id="l4.34"> </span>
<a href="#l4.35"></a><span id="l4.35"> function run_test() {</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineminus">-  loadLocalMailAccount();</span>
<a href="#l4.37"></a><span id="l4.37">   async_run_tests(tests);</span>
<a href="#l4.38"></a><span id="l4.38"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mail/components/activity/modules/glodaIndexer.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mail/components/activity/modules/glodaIndexer.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -54,17 +54,19 @@ const nsActWarning = Components.Construc</span>
<a href="#l5.4"></a><span id="l5.4">                                             &quot;nsIActivityWarning&quot;, &quot;init&quot;);</span>
<a href="#l5.5"></a><span id="l5.5"> </span>
<a href="#l5.6"></a><span id="l5.6"> Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l5.7"></a><span id="l5.7"> Cu.import(&quot;resource://gre/modules/PluralForm.jsm&quot;);</span>
<a href="#l5.8"></a><span id="l5.8"> Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l5.9"></a><span id="l5.9"> Cu.import(&quot;resource://app/modules/gloda/gloda.js&quot;);</span>
<a href="#l5.10"></a><span id="l5.10"> Cu.import(&quot;resource://app/modules/gloda/indexer.js&quot;);</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-// This module links the gloda indexer and the activity manager.</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+/**</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+ * Gloda message indexer feedback.</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+ */</span>
<a href="#l5.16"></a><span id="l5.16"> let glodaIndexerActivity =</span>
<a href="#l5.17"></a><span id="l5.17"> {</span>
<a href="#l5.18"></a><span id="l5.18">   get log() {</span>
<a href="#l5.19"></a><span id="l5.19">     delete this.log;</span>
<a href="#l5.20"></a><span id="l5.20">     return this.log = Log4Moz.getConfiguredLogger(&quot;glodaIndexerActivity&quot;);</span>
<a href="#l5.21"></a><span id="l5.21">   },</span>
<a href="#l5.22"></a><span id="l5.22"> </span>
<a href="#l5.23"></a><span id="l5.23">   get activityMgr() {</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineat">@@ -75,32 +77,31 @@ let glodaIndexerActivity =</span>
<a href="#l5.25"></a><span id="l5.25"> </span>
<a href="#l5.26"></a><span id="l5.26">   get bundle() {</span>
<a href="#l5.27"></a><span id="l5.27">     delete this.bundle;</span>
<a href="#l5.28"></a><span id="l5.28">     let bundleSvc = Cc[&quot;@mozilla.org/intl/stringbundle;1&quot;]</span>
<a href="#l5.29"></a><span id="l5.29">                       .getService(Ci.nsIStringBundleService);</span>
<a href="#l5.30"></a><span id="l5.30">     return this.bundle = bundleSvc</span>
<a href="#l5.31"></a><span id="l5.31">       .createBundle(&quot;chrome://messenger/locale/activity.properties&quot;);</span>
<a href="#l5.32"></a><span id="l5.32">   },</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-  </span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+</span>
<a href="#l5.35"></a><span id="l5.35">   getString: function(stringName) {</span>
<a href="#l5.36"></a><span id="l5.36">     try {</span>
<a href="#l5.37"></a><span id="l5.37">       return this.bundle.GetStringFromName(stringName);</span>
<a href="#l5.38"></a><span id="l5.38">     } catch (e) {</span>
<a href="#l5.39"></a><span id="l5.39">       this.log.error(&quot;error trying to get a string called: &quot; + stringName);</span>
<a href="#l5.40"></a><span id="l5.40">       throw(e);</span>
<a href="#l5.41"></a><span id="l5.41">     }</span>
<a href="#l5.42"></a><span id="l5.42">   },</span>
<a href="#l5.43"></a><span id="l5.43"> </span>
<a href="#l5.44"></a><span id="l5.44">   init: function() {</span>
<a href="#l5.45"></a><span id="l5.45">     // Register a listener with the Gloda indexer that receives notifications</span>
<a href="#l5.46"></a><span id="l5.46">     // about Gloda indexing status.  We wrap the listener in this function so we</span>
<a href="#l5.47"></a><span id="l5.47">     // can set |this| to the GlodaIndexerActivity object inside the listener.</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineminus">-    function listenerWrapper(aStatus, aFolder, aJobNumber, aTotalJobNum,</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineminus">-                             aItemNumber, aTotalItemNum)</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+    function listenerWrapper()</span>
<a href="#l5.51"></a><span id="l5.51">     {</span>
<a href="#l5.52"></a><span id="l5.52">       glodaIndexerActivity.listener.apply(glodaIndexerActivity, arguments);</span>
<a href="#l5.53"></a><span id="l5.53">     };</span>
<a href="#l5.54"></a><span id="l5.54">     GlodaIndexer.addListener(listenerWrapper);</span>
<a href="#l5.55"></a><span id="l5.55">   },</span>
<a href="#l5.56"></a><span id="l5.56"> </span>
<a href="#l5.57"></a><span id="l5.57">   /**</span>
<a href="#l5.58"></a><span id="l5.58">    * Information about the current job.  An object with these properties:</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineat">@@ -113,21 +114,21 @@ let glodaIndexerActivity =</span>
<a href="#l5.60"></a><span id="l5.60">    *                the activity process corresponding to the current job</span>
<a href="#l5.61"></a><span id="l5.61">    *   startTime    {Date}</span>
<a href="#l5.62"></a><span id="l5.62">    *                the time at which we were first notified about the job</span>
<a href="#l5.63"></a><span id="l5.63">    *   totalItemNum {Number}</span>
<a href="#l5.64"></a><span id="l5.64">    *                the total number of messages being indexed in the job</span>
<a href="#l5.65"></a><span id="l5.65">    */</span>
<a href="#l5.66"></a><span id="l5.66">   currentJob: null,</span>
<a href="#l5.67"></a><span id="l5.67"> </span>
<a href="#l5.68"></a><span id="l5.68" class="difflineminus">-  listener: function(aStatus, aFolder, aJobNumber, aTotalJobNum, aItemNumber,</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+  listener: function(aStatus, aFolder, aJobNumber, aItemNumber,</span>
<a href="#l5.70"></a><span id="l5.70">                      aTotalItemNum)</span>
<a href="#l5.71"></a><span id="l5.71">   {</span>
<a href="#l5.72"></a><span id="l5.72">     this.log.debug(&quot;Gloda Indexer Folder/Status: &quot; + aFolder + &quot;/&quot; + aStatus);</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineminus">-    this.log.debug(&quot;Gloda Indexer Job: &quot; + aJobNumber + &quot;/&quot; + aTotalJobNum);</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+    this.log.debug(&quot;Gloda Indexer Job: &quot; + aJobNumber);</span>
<a href="#l5.75"></a><span id="l5.75">     this.log.debug(&quot;Gloda Indexer Item: &quot; + aItemNumber + &quot;/&quot; + aTotalItemNum);</span>
<a href="#l5.76"></a><span id="l5.76"> </span>
<a href="#l5.77"></a><span id="l5.77">     if (aStatus == Gloda.kIndexerIdle)</span>
<a href="#l5.78"></a><span id="l5.78">     {</span>
<a href="#l5.79"></a><span id="l5.79">       if (this.currentJob)</span>
<a href="#l5.80"></a><span id="l5.80">         this.onJobCompleted();</span>
<a href="#l5.81"></a><span id="l5.81">     }</span>
<a href="#l5.82"></a><span id="l5.82">     else</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineat">@@ -224,37 +225,37 @@ let glodaIndexerActivity =</span>
<a href="#l5.84"></a><span id="l5.84">     if (this.currentJob.folder &amp;&amp; totalItemNum &gt; 0) {</span>
<a href="#l5.85"></a><span id="l5.85">       // Note: we must replace the folder name placeholder last; otherwise,</span>
<a href="#l5.86"></a><span id="l5.86">       // if the name happens to contain another one of the placeholders, we'll</span>
<a href="#l5.87"></a><span id="l5.87">       // hork the name when replacing it.</span>
<a href="#l5.88"></a><span id="l5.88">       let displayText = PluralForm.get(totalItemNum,</span>
<a href="#l5.89"></a><span id="l5.89">                                        this.getString(&quot;indexedFolder&quot;))</span>
<a href="#l5.90"></a><span id="l5.90">                           .replace(&quot;#1&quot;, totalItemNum)</span>
<a href="#l5.91"></a><span id="l5.91">                           .replace(&quot;#2&quot;, this.currentJob.folder);</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineminus">-  </span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+</span>
<a href="#l5.94"></a><span id="l5.94">       let endTime = new Date();</span>
<a href="#l5.95"></a><span id="l5.95">       let secondsElapsed = parseInt((endTime - this.currentJob.startTime)/1000);</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineminus">-  </span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+</span>
<a href="#l5.98"></a><span id="l5.98">       let statusText = PluralForm.get(secondsElapsed,</span>
<a href="#l5.99"></a><span id="l5.99">                                       this.getString(&quot;indexedFolderStatus&quot;))</span>
<a href="#l5.100"></a><span id="l5.100">                          .replace(&quot;#1&quot;, secondsElapsed);</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineminus">-  </span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+</span>
<a href="#l5.103"></a><span id="l5.103">       let event = new nsActEvent(displayText,</span>
<a href="#l5.104"></a><span id="l5.104">                                  Gloda,</span>
<a href="#l5.105"></a><span id="l5.105">                                  statusText,</span>
<a href="#l5.106"></a><span id="l5.106">                                  this.currentJob.startTime,</span>
<a href="#l5.107"></a><span id="l5.107">                                  endTime);</span>
<a href="#l5.108"></a><span id="l5.108">       event.contextType = this.currentJob.contextType;</span>
<a href="#l5.109"></a><span id="l5.109">       event.contextObj = this.currentJob.contextObj;</span>
<a href="#l5.110"></a><span id="l5.110">       event.iconClass   = &quot;indexMail&quot;;</span>
<a href="#l5.111"></a><span id="l5.111"> </span>
<a href="#l5.112"></a><span id="l5.112">       // Transfer subjects.</span>
<a href="#l5.113"></a><span id="l5.113">       let subjects = this.currentJob.process.getSubjects({});</span>
<a href="#l5.114"></a><span id="l5.114">       for each (let [, subject] in Iterator(subjects))</span>
<a href="#l5.115"></a><span id="l5.115">         event.addSubject(subject);</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineminus">-  </span>
<a href="#l5.117"></a><span id="l5.117" class="difflineplus">+</span>
<a href="#l5.118"></a><span id="l5.118">       this.activityMgr.addActivity(event);</span>
<a href="#l5.119"></a><span id="l5.119">     }</span>
<a href="#l5.120"></a><span id="l5.120"> </span>
<a href="#l5.121"></a><span id="l5.121">     this.currentJob = null;</span>
<a href="#l5.122"></a><span id="l5.122">   }</span>
<a href="#l5.123"></a><span id="l5.123"> </span>
<a href="#l5.124"></a><span id="l5.124"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mail/components/search/content/searchCommon.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mail/components/search/content/searchCommon.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -233,33 +233,43 @@ let SearchSupport =</span>
<a href="#l6.4"></a><span id="l6.4">         .getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l6.5"></a><span id="l6.5"> </span>
<a href="#l6.6"></a><span id="l6.6">     this._removeObservers();</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8">     if (aEnable)</span>
<a href="#l6.9"></a><span id="l6.9">     {</span>
<a href="#l6.10"></a><span id="l6.10">       // This stuff we always need to do</span>
<a href="#l6.11"></a><span id="l6.11">       notificationService.addListener(this._msgFolderListener,</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-                                      notificationService.all &amp;</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-                                      ~notificationService.folderAdded);</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+        notificationService.msgAdded |</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+        notificationService.msgsDeleted |</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+        notificationService.msgsMoveCopyCompleted |</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+        // this code pre-dates msgsClassified</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+        // folderAdded intentionally omitted</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+        notificationService.folderDeleted |</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+        notificationService.folderMoveCopyCompleted |</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+        notificationService.folderRenamed);</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+        // itemEvent intentionally omitted</span>
<a href="#l6.23"></a><span id="l6.23">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;]</span>
<a href="#l6.24"></a><span id="l6.24">                               .getService(Ci.nsIObserverService);</span>
<a href="#l6.25"></a><span id="l6.25">       observerService.addObserver(this, &quot;MsgMsgDisplayed&quot;, false);</span>
<a href="#l6.26"></a><span id="l6.26">       let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;]</span>
<a href="#l6.27"></a><span id="l6.27">                           .getService(Ci.nsIIdleService);</span>
<a href="#l6.28"></a><span id="l6.28">       idleService.addIdleObserver(this, this._idleThresholdSecs);</span>
<a href="#l6.29"></a><span id="l6.29">     }</span>
<a href="#l6.30"></a><span id="l6.30">     else</span>
<a href="#l6.31"></a><span id="l6.31">       // We want to observe moves, deletes and renames in case we're disabled</span>
<a href="#l6.32"></a><span id="l6.32">       // If we don't, we'll have no idea the support files exist later</span>
<a href="#l6.33"></a><span id="l6.33">       notificationService.addListener(this._msgFolderListener,</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineminus">-                                      notificationService.msgsMoveCopyCompleted |</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineminus">-                                      notificationService.msgsDeleted |</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineminus">-                                      (notificationService.allFolderNotifications &amp;</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineminus">-                                       ~notificationService.folderAdded));</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+        notificationService.msgsMoveCopyCompleted |</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+        notificationService.msgsDeleted |</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+        // folderAdded intentionally omitted</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+        notificationService.folderDeleted |</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+        notificationService.folderMoveCopyCompleted |</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+        notificationService.folderRenamed);</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+</span>
<a href="#l6.45"></a><span id="l6.45">     this._enabled = aEnable;</span>
<a href="#l6.46"></a><span id="l6.46">   },</span>
<a href="#l6.47"></a><span id="l6.47">   get enabled()</span>
<a href="#l6.48"></a><span id="l6.48">   {</span>
<a href="#l6.49"></a><span id="l6.49">     return this._enabled;</span>
<a href="#l6.50"></a><span id="l6.50">   },</span>
<a href="#l6.51"></a><span id="l6.51"> </span>
<a href="#l6.52"></a><span id="l6.52">   /**</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mail/test/mozmill/folder-display/test-columns.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mail/test/mozmill/folder-display/test-columns.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -129,18 +129,18 @@ var INBOX_DEFAULTS = [</span>
<a href="#l7.4"></a><span id="l7.4">   &quot;junkStatusCol&quot;,</span>
<a href="#l7.5"></a><span id="l7.5">   &quot;dateCol&quot;</span>
<a href="#l7.6"></a><span id="l7.6"> ];</span>
<a href="#l7.7"></a><span id="l7.7"> </span>
<a href="#l7.8"></a><span id="l7.8"> /**</span>
<a href="#l7.9"></a><span id="l7.9">  * Make sure we set the proper defaults for an Inbox.</span>
<a href="#l7.10"></a><span id="l7.10">  */</span>
<a href="#l7.11"></a><span id="l7.11"> function test_column_defaults_inbox() {</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-  // just use the inbox</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">-  folderInbox = gLocalInboxFolder;</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+  // just use the inbox; comes from test-folder-display-helpers</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+  folderInbox = inboxFolder;</span>
<a href="#l7.16"></a><span id="l7.16">   enter_folder(folderInbox);</span>
<a href="#l7.17"></a><span id="l7.17">   assert_visible_columns(INBOX_DEFAULTS);</span>
<a href="#l7.18"></a><span id="l7.18"> }</span>
<a href="#l7.19"></a><span id="l7.19"> </span>
<a href="#l7.20"></a><span id="l7.20"> var SENT_DEFAULTS = [</span>
<a href="#l7.21"></a><span id="l7.21">   &quot;threadCol&quot;,</span>
<a href="#l7.22"></a><span id="l7.22">   &quot;flaggedCol&quot;,</span>
<a href="#l7.23"></a><span id="l7.23">   &quot;attachmentCol&quot;,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mail/test/mozmill/shared-modules/test-folder-display-helpers.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mail/test/mozmill/shared-modules/test-folder-display-helpers.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -58,32 +58,37 @@ const RELATIVE_ROOT = '../shared-modules</span>
<a href="#l8.4"></a><span id="l8.4"> // we need window-helpers for augment_controller</span>
<a href="#l8.5"></a><span id="l8.5"> const MODULES_REQUIRES = ['window-helpers'];</span>
<a href="#l8.6"></a><span id="l8.6"> </span>
<a href="#l8.7"></a><span id="l8.7"> const nsMsgViewIndex_None = 0xffffffff;</span>
<a href="#l8.8"></a><span id="l8.8"> Cu.import('resource://app/modules/MailUtils.js');</span>
<a href="#l8.9"></a><span id="l8.9"> Cu.import('resource://app/modules/MailConsts.js');</span>
<a href="#l8.10"></a><span id="l8.10"> Cu.import('resource://app/modules/mailViewManager.js');</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+/**</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+ * List of keys not to export via installInto; values do not matter, we just</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+ *  use true.</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+ */</span>
<a href="#l8.16"></a><span id="l8.16"> const DO_NOT_EXPORT = {</span>
<a href="#l8.17"></a><span id="l8.17">   // magic globals</span>
<a href="#l8.18"></a><span id="l8.18">   MODULE_NAME: true, DO_NOT_EXPORT: true,</span>
<a href="#l8.19"></a><span id="l8.19">   // imported modules</span>
<a href="#l8.20"></a><span id="l8.20">   elib: true, mozmill: true, controller: true, frame: true, os: true,</span>
<a href="#l8.21"></a><span id="l8.21">   // convenience constants</span>
<a href="#l8.22"></a><span id="l8.22">   Ci: true, Cc: true, Cu: true, Cr: true,</span>
<a href="#l8.23"></a><span id="l8.23">   // useful constants (we do export MailViewConstants)</span>
<a href="#l8.24"></a><span id="l8.24">   nsMsgViewIndex_None: true, MailConsts: true,</span>
<a href="#l8.25"></a><span id="l8.25">   // utility functions</span>
<a href="#l8.26"></a><span id="l8.26">   MailUtils: true, MailViewManager: true,</span>
<a href="#l8.27"></a><span id="l8.27">   // internal setup functions</span>
<a href="#l8.28"></a><span id="l8.28">   setupModule: true, setupAccountStuff: true,</span>
<a href="#l8.29"></a><span id="l8.29">   // internal setup flags</span>
<a href="#l8.30"></a><span id="l8.30">   initialized: false,</span>
<a href="#l8.31"></a><span id="l8.31">   // other libraries we use</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+  testHelperModule: true,</span>
<a href="#l8.33"></a><span id="l8.33">   windowHelper: true</span>
<a href="#l8.34"></a><span id="l8.34"> };</span>
<a href="#l8.35"></a><span id="l8.35"> </span>
<a href="#l8.36"></a><span id="l8.36"> const EXPORT_VIA_GETTER_SETTER = {</span>
<a href="#l8.37"></a><span id="l8.37">   // These should be getters and setters instead of direct property accesses so</span>
<a href="#l8.38"></a><span id="l8.38">   // that setting them reflects across scopes.</span>
<a href="#l8.39"></a><span id="l8.39">   mainController: true, mc: true,</span>
<a href="#l8.40"></a><span id="l8.40"> };</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineat">@@ -93,74 +98,84 @@ var Application = Cc[&quot;@mozilla.org/steel</span>
<a href="#l8.42"></a><span id="l8.42"> </span>
<a href="#l8.43"></a><span id="l8.43"> var mainController = null;</span>
<a href="#l8.44"></a><span id="l8.44"> /** convenience shorthand for the mainController. */</span>
<a href="#l8.45"></a><span id="l8.45"> var mc;</span>
<a href="#l8.46"></a><span id="l8.46"> /** the index of the current 'other' tab */</span>
<a href="#l8.47"></a><span id="l8.47"> var otherTab;</span>
<a href="#l8.48"></a><span id="l8.48"> </span>
<a href="#l8.49"></a><span id="l8.49"> // These are pseudo-modules setup by setupModule:</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineminus">-var messageGenerator;</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineminus">-var messageModifier;</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineminus">-var viewWrapperTestUtils;</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineplus">+var testHelperModule;</span>
<a href="#l8.54"></a><span id="l8.54"> // (end pseudo-modules)</span>
<a href="#l8.55"></a><span id="l8.55"> </span>
<a href="#l8.56"></a><span id="l8.56"> var msgGen;</span>
<a href="#l8.57"></a><span id="l8.57"> </span>
<a href="#l8.58"></a><span id="l8.58" class="difflineminus">-var gLocalIncomingServer = null;</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineminus">-var gLocalInboxFolder = null;</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineplus">+var inboxFolder = null;</span>
<a href="#l8.61"></a><span id="l8.61"> </span>
<a href="#l8.62"></a><span id="l8.62" class="difflineminus">-var rootFolder = null;</span>
<a href="#l8.63"></a><span id="l8.63" class="difflineplus">+// logHelper exports</span>
<a href="#l8.64"></a><span id="l8.64" class="difflineplus">+var mark_action;</span>
<a href="#l8.65"></a><span id="l8.65" class="difflineplus">+var mark_failure;</span>
<a href="#l8.66"></a><span id="l8.66"> </span>
<a href="#l8.67"></a><span id="l8.67"> // the windowHelper module</span>
<a href="#l8.68"></a><span id="l8.68"> var windowHelper;</span>
<a href="#l8.69"></a><span id="l8.69"> </span>
<a href="#l8.70"></a><span id="l8.70"> var initialized = false;</span>
<a href="#l8.71"></a><span id="l8.71"> function setupModule() {</span>
<a href="#l8.72"></a><span id="l8.72">   if (initialized)</span>
<a href="#l8.73"></a><span id="l8.73">     return;</span>
<a href="#l8.74"></a><span id="l8.74">   initialized = true;</span>
<a href="#l8.75"></a><span id="l8.75"> </span>
<a href="#l8.76"></a><span id="l8.76" class="difflineplus">+  testHelperModule = {</span>
<a href="#l8.77"></a><span id="l8.77" class="difflineplus">+    Cc: Cc,</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineplus">+    Ci: Ci,</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineplus">+    Cu: Cu,</span>
<a href="#l8.80"></a><span id="l8.80" class="difflineplus">+    // fake some xpcshell stuff</span>
<a href="#l8.81"></a><span id="l8.81" class="difflineplus">+    _TEST_FILE: [&quot;mozmill&quot;],</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineplus">+    do_throw: function(aMsg) {</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineplus">+      throw new Error(aMsg);</span>
<a href="#l8.84"></a><span id="l8.84" class="difflineplus">+    },</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineplus">+    do_check_eq: function() {},</span>
<a href="#l8.86"></a><span id="l8.86" class="difflineplus">+    do_check_neq: function() {},</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineplus">+  };</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+</span>
<a href="#l8.89"></a><span id="l8.89">   // The xpcshell test resources assume they are loaded into a single global</span>
<a href="#l8.90"></a><span id="l8.90">   //  namespace, so we need to help them out to maintain their delusion.</span>
<a href="#l8.91"></a><span id="l8.91" class="difflineminus">-  messageGenerator = load_via_src_path(</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineminus">-    'mailnews/test/resources/messageGenerator.js');</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineminus">-  messageModifier = load_via_src_path(</span>
<a href="#l8.94"></a><span id="l8.94" class="difflineminus">-    'mailnews/test/resources/messageModifier.js');</span>
<a href="#l8.95"></a><span id="l8.95" class="difflineminus">-  viewWrapperTestUtils = load_via_src_path(</span>
<a href="#l8.96"></a><span id="l8.96" class="difflineminus">-    'mail/base/test/unit/resources/viewWrapperTestUtils.js');</span>
<a href="#l8.97"></a><span id="l8.97" class="difflineminus">-  // desired global types...</span>
<a href="#l8.98"></a><span id="l8.98" class="difflineminus">-  viewWrapperTestUtils.SyntheticMessageSet =</span>
<a href="#l8.99"></a><span id="l8.99" class="difflineminus">-    messageModifier.SyntheticMessageSet;</span>
<a href="#l8.100"></a><span id="l8.100" class="difflineminus">-  viewWrapperTestUtils.do_throw = function(aMsg) {</span>
<a href="#l8.101"></a><span id="l8.101" class="difflineminus">-    throw new Error(aMsg);</span>
<a href="#l8.102"></a><span id="l8.102" class="difflineminus">-  };</span>
<a href="#l8.103"></a><span id="l8.103" class="difflineminus">-  // viewWrapperTestUtils wants a gMessageGenerator (and so do we)</span>
<a href="#l8.104"></a><span id="l8.104" class="difflineminus">-  msgGen = new messageGenerator.MessageGenerator();</span>
<a href="#l8.105"></a><span id="l8.105" class="difflineminus">-  viewWrapperTestUtils.gMessageGenerator = msgGen;</span>
<a href="#l8.106"></a><span id="l8.106" class="difflineminus">-  viewWrapperTestUtils.gMessageScenarioFactory =</span>
<a href="#l8.107"></a><span id="l8.107" class="difflineminus">-    new messageGenerator.MessageScenarioFactory(msgGen);</span>
<a href="#l8.108"></a><span id="l8.108" class="difflineplus">+  load_via_src_path('mailnews/test/resources/logHelper.js',</span>
<a href="#l8.109"></a><span id="l8.109" class="difflineplus">+                    testHelperModule);</span>
<a href="#l8.110"></a><span id="l8.110" class="difflineplus">+  mark_action = testHelperModule.mark_action;</span>
<a href="#l8.111"></a><span id="l8.111" class="difflineplus">+  mark_failure = testHelperModule.mark_failure;</span>
<a href="#l8.112"></a><span id="l8.112" class="difflineplus">+</span>
<a href="#l8.113"></a><span id="l8.113" class="difflineplus">+  load_via_src_path('mailnews/test/resources/asyncTestUtils.js',</span>
<a href="#l8.114"></a><span id="l8.114" class="difflineplus">+                    testHelperModule);</span>
<a href="#l8.115"></a><span id="l8.115" class="difflineplus">+  load_via_src_path('mailnews/test/resources/messageGenerator.js',</span>
<a href="#l8.116"></a><span id="l8.116" class="difflineplus">+                    testHelperModule);</span>
<a href="#l8.117"></a><span id="l8.117" class="difflineplus">+  load_via_src_path('mailnews/test/resources/messageModifier.js',</span>
<a href="#l8.118"></a><span id="l8.118" class="difflineplus">+                    testHelperModule);</span>
<a href="#l8.119"></a><span id="l8.119" class="difflineplus">+  load_via_src_path('mailnews/test/resources/messageInjection.js',</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineplus">+                    testHelperModule);</span>
<a href="#l8.121"></a><span id="l8.121" class="difflineplus">+  load_via_src_path('mail/base/test/unit/resources/viewWrapperTestUtils.js',</span>
<a href="#l8.122"></a><span id="l8.122" class="difflineplus">+                    testHelperModule);</span>
<a href="#l8.123"></a><span id="l8.123" class="difflineplus">+</span>
<a href="#l8.124"></a><span id="l8.124" class="difflineplus">+  // messageInjection wants a gMessageGenerator (and so do we)</span>
<a href="#l8.125"></a><span id="l8.125" class="difflineplus">+  msgGen = new testHelperModule.MessageGenerator();</span>
<a href="#l8.126"></a><span id="l8.126" class="difflineplus">+  testHelperModule.gMessageGenerator = msgGen;</span>
<a href="#l8.127"></a><span id="l8.127" class="difflineplus">+  testHelperModule.gMessageScenarioFactory =</span>
<a href="#l8.128"></a><span id="l8.128" class="difflineplus">+    new testHelperModule.MessageScenarioFactory(msgGen);</span>
<a href="#l8.129"></a><span id="l8.129"> </span>
<a href="#l8.130"></a><span id="l8.130">   make_new_sets_in_folders = make_new_sets_in_folder =</span>
<a href="#l8.131"></a><span id="l8.131" class="difflineminus">-    viewWrapperTestUtils.make_new_sets_in_folders;</span>
<a href="#l8.132"></a><span id="l8.132" class="difflineminus">-  add_sets_to_folders = viewWrapperTestUtils.add_sets_to_folders;</span>
<a href="#l8.133"></a><span id="l8.133" class="difflineminus">-  create_virtual_folder = viewWrapperTestUtils.make_virtual_folder;</span>
<a href="#l8.134"></a><span id="l8.134" class="difflineminus">-</span>
<a href="#l8.135"></a><span id="l8.135" class="difflineminus">-  viewWrapperTestUtils.Ci = Ci;</span>
<a href="#l8.136"></a><span id="l8.136" class="difflineminus">-  viewWrapperTestUtils.Cu = Cu;</span>
<a href="#l8.137"></a><span id="l8.137" class="difflineminus">-  viewWrapperTestUtils.Cc = Cc;</span>
<a href="#l8.138"></a><span id="l8.138" class="difflineplus">+    testHelperModule.make_new_sets_in_folders;</span>
<a href="#l8.139"></a><span id="l8.139" class="difflineplus">+  add_sets_to_folders = testHelperModule.add_sets_to_folders;</span>
<a href="#l8.140"></a><span id="l8.140"> </span>
<a href="#l8.141"></a><span id="l8.141">   // use window-helper's augment_controller method to get our extra good stuff</span>
<a href="#l8.142"></a><span id="l8.142">   //  we need.</span>
<a href="#l8.143"></a><span id="l8.143">   windowHelper = collector.getModule('window-helpers');</span>
<a href="#l8.144"></a><span id="l8.144">   mc = mainController = windowHelper.wait_for_existing_window(&quot;mail:3pane&quot;);</span>
<a href="#l8.145"></a><span id="l8.145">   windowHelper.augment_controller(mc);</span>
<a href="#l8.146"></a><span id="l8.146"> </span>
<a href="#l8.147"></a><span id="l8.147">   setupAccountStuff();</span>
<a href="#l8.148"></a><span id="l8.148" class="difflineminus">-  viewWrapperTestUtils.gLocalIncomingServer = gLocalIncomingServer;</span>
<a href="#l8.149"></a><span id="l8.149"> }</span>
<a href="#l8.150"></a><span id="l8.150"> </span>
<a href="#l8.151"></a><span id="l8.151"> /**</span>
<a href="#l8.152"></a><span id="l8.152">  * Install this module into the provided module.</span>
<a href="#l8.153"></a><span id="l8.153">  */</span>
<a href="#l8.154"></a><span id="l8.154"> function installInto(module) {</span>
<a href="#l8.155"></a><span id="l8.155">   setupModule();</span>
<a href="#l8.156"></a><span id="l8.156"> </span>
<a href="#l8.157"></a><span id="l8.157" class="difflineat">@@ -180,36 +195,17 @@ function installInto(module) {</span>
<a href="#l8.158"></a><span id="l8.158">     else if (!(key in DO_NOT_EXPORT) &amp;&amp;</span>
<a href="#l8.159"></a><span id="l8.159">              key[0] != &quot;_&quot;) {</span>
<a href="#l8.160"></a><span id="l8.160">       module[key] = value;</span>
<a href="#l8.161"></a><span id="l8.161">     }</span>
<a href="#l8.162"></a><span id="l8.162">   }</span>
<a href="#l8.163"></a><span id="l8.163"> }</span>
<a href="#l8.164"></a><span id="l8.164"> </span>
<a href="#l8.165"></a><span id="l8.165"> function setupAccountStuff() {</span>
<a href="#l8.166"></a><span id="l8.166" class="difflineminus">-  // Create a local account to work with folders.</span>
<a href="#l8.167"></a><span id="l8.167" class="difflineminus">-  // (Note this gives you an Outbox and Trash folder by default).</span>
<a href="#l8.168"></a><span id="l8.168" class="difflineminus">-  let acctMgr = Components.classes[&quot;@mozilla.org/messenger/account-manager;1&quot;]</span>
<a href="#l8.169"></a><span id="l8.169" class="difflineminus">-                          .getService(Components.interfaces.nsIMsgAccountManager);</span>
<a href="#l8.170"></a><span id="l8.170" class="difflineminus">-  //acctMgr.createLocalMailAccount();</span>
<a href="#l8.171"></a><span id="l8.171" class="difflineminus">-</span>
<a href="#l8.172"></a><span id="l8.172" class="difflineminus">-  gLocalIncomingServer = acctMgr.localFoldersServer;</span>
<a href="#l8.173"></a><span id="l8.173" class="difflineminus">-</span>
<a href="#l8.174"></a><span id="l8.174" class="difflineminus">-  rootFolder = gLocalIncomingServer.rootMsgFolder;</span>
<a href="#l8.175"></a><span id="l8.175" class="difflineminus">-  // Note: Inbox is not created automatically when there is no deferred server,</span>
<a href="#l8.176"></a><span id="l8.176" class="difflineminus">-  // so we need to create it.</span>
<a href="#l8.177"></a><span id="l8.177" class="difflineminus">-  gLocalInboxFolder = rootFolder.addSubfolder(&quot;Inbox&quot;);</span>
<a href="#l8.178"></a><span id="l8.178" class="difflineminus">-  // a local inbox should have a Mail flag!</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineminus">-  gLocalInboxFolder.setFlag(Ci.nsMsgFolderFlags.Mail);</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineminus">-  gLocalInboxFolder.setFlag(Ci.nsMsgFolderFlags.Inbox);</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineminus">-</span>
<a href="#l8.182"></a><span id="l8.182" class="difflineminus">-  // Force an initialization of the Inbox folder database.</span>
<a href="#l8.183"></a><span id="l8.183" class="difflineminus">-  var folderName = gLocalInboxFolder.prettiestName;</span>
<a href="#l8.184"></a><span id="l8.184" class="difflineminus">-</span>
<a href="#l8.185"></a><span id="l8.185" class="difflineminus">-  gLocalInboxFolder = rootFolder.getChildNamed(&quot;Inbox&quot;);</span>
<a href="#l8.186"></a><span id="l8.186" class="difflineplus">+  inboxFolder = testHelperModule.configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l8.187"></a><span id="l8.187"> }</span>
<a href="#l8.188"></a><span id="l8.188"> </span>
<a href="#l8.189"></a><span id="l8.189"> /*</span>
<a href="#l8.190"></a><span id="l8.190">  * Although we all agree that the use of generators when dealing with async</span>
<a href="#l8.191"></a><span id="l8.191">  *  operations is awesome, the mozmill idiom is for calls to be synchronous and</span>
<a href="#l8.192"></a><span id="l8.192">  *  just spin event loops when they need to wait for things to happen.  This</span>
<a href="#l8.193"></a><span id="l8.193">  *  does make the test code significantly less confusing, so we do it too.</span>
<a href="#l8.194"></a><span id="l8.194">  * All of our operations are synchronous and just spin until they are happy.</span>
<a href="#l8.195"></a><span id="l8.195" class="difflineat">@@ -217,37 +213,38 @@ function setupAccountStuff() {</span>
<a href="#l8.196"></a><span id="l8.196"> </span>
<a href="#l8.197"></a><span id="l8.197"> const NORMAL_TIMEOUT = 6000;</span>
<a href="#l8.198"></a><span id="l8.198"> const FAST_INTERVAL = 100;</span>
<a href="#l8.199"></a><span id="l8.199"> </span>
<a href="#l8.200"></a><span id="l8.200"> /**</span>
<a href="#l8.201"></a><span id="l8.201">  * Create a folder and rebuild the folder tree view.</span>
<a href="#l8.202"></a><span id="l8.202">  */</span>
<a href="#l8.203"></a><span id="l8.203"> function create_folder(aFolderName) {</span>
<a href="#l8.204"></a><span id="l8.204" class="difflineminus">-  let folder = rootFolder.addSubfolder(aFolderName);</span>
<a href="#l8.205"></a><span id="l8.205" class="difflineplus">+  let folder = testHelperModule.make_empty_folder(aFolderName);</span>
<a href="#l8.206"></a><span id="l8.206">   mc.folderTreeView.mode = &quot;all&quot;;</span>
<a href="#l8.207"></a><span id="l8.207">   return folder;</span>
<a href="#l8.208"></a><span id="l8.208"> }</span>
<a href="#l8.209"></a><span id="l8.209"> </span>
<a href="#l8.210"></a><span id="l8.210"> /**</span>
<a href="#l8.211"></a><span id="l8.211">  * Create a virtual folder by deferring to |make_virtual_folder| and making</span>
<a href="#l8.212"></a><span id="l8.212">  *  sure to rebuild the folder tree afterwards.</span>
<a href="#l8.213"></a><span id="l8.213">  */</span>
<a href="#l8.214"></a><span id="l8.214"> function create_virtual_folder() {</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineminus">-  let folder = viewWrapperTestUtils.make_virtual_folder.apply(null, arguments);</span>
<a href="#l8.216"></a><span id="l8.216" class="difflineplus">+  let folder = testHelperModule.make_virtual_folder.apply(null, arguments);</span>
<a href="#l8.217"></a><span id="l8.217">   mc.folderTreeView.mode = &quot;all&quot;;</span>
<a href="#l8.218"></a><span id="l8.218">   return folder;</span>
<a href="#l8.219"></a><span id="l8.219"> }</span>
<a href="#l8.220"></a><span id="l8.220"> </span>
<a href="#l8.221"></a><span id="l8.221"> </span>
<a href="#l8.222"></a><span id="l8.222"> /**</span>
<a href="#l8.223"></a><span id="l8.223">  * Create a thread with the specified number of messages in it.</span>
<a href="#l8.224"></a><span id="l8.224">  */</span>
<a href="#l8.225"></a><span id="l8.225"> function create_thread(aCount) {</span>
<a href="#l8.226"></a><span id="l8.226" class="difflineminus">-  return new viewWrapperTestUtils.SyntheticMessageSet(viewWrapperTestUtils.gMessageScenarioFactory.directReply(aCount));</span>
<a href="#l8.227"></a><span id="l8.227" class="difflineplus">+  return new testHelperModule.SyntheticMessageSet(</span>
<a href="#l8.228"></a><span id="l8.228" class="difflineplus">+    testHelperModule.gMessageScenarioFactory.directReply(aCount));</span>
<a href="#l8.229"></a><span id="l8.229"> }</span>
<a href="#l8.230"></a><span id="l8.230"> </span>
<a href="#l8.231"></a><span id="l8.231"> /**</span>
<a href="#l8.232"></a><span id="l8.232">  * Make sure we are entering the folder from not having been in the folder.  We</span>
<a href="#l8.233"></a><span id="l8.233">  *  will leave the folder and come back if we have to.</span>
<a href="#l8.234"></a><span id="l8.234">  */</span>
<a href="#l8.235"></a><span id="l8.235"> function enter_folder(aFolder) {</span>
<a href="#l8.236"></a><span id="l8.236">   // Drain the event queue prior to doing any work.  It's possible that there's</span>
<a href="#l8.237"></a><span id="l8.237" class="difflineat">@@ -1054,18 +1051,18 @@ function wait_for_folder_events() {</span>
<a href="#l8.238"></a><span id="l8.238">  *</span>
<a href="#l8.239"></a><span id="l8.239">  * @param aSynSets Either a single SyntheticMessageSet or a list of them.</span>
<a href="#l8.240"></a><span id="l8.240">  * @param aController Optional controller, which we get the folderDisplay</span>
<a href="#l8.241"></a><span id="l8.241">  *     property from.  If omitted, we use the mc (mainController).</span>
<a href="#l8.242"></a><span id="l8.242">  */</span>
<a href="#l8.243"></a><span id="l8.243"> function assert_messages_in_view(aSynSets, aController) {</span>
<a href="#l8.244"></a><span id="l8.244">   if (aController === undefined)</span>
<a href="#l8.245"></a><span id="l8.245">     aController = mc;</span>
<a href="#l8.246"></a><span id="l8.246" class="difflineminus">-  viewWrapperTestUtils.verify_messages_in_view(aSynSets,</span>
<a href="#l8.247"></a><span id="l8.247" class="difflineminus">-                                               aController.folderDisplay.view);</span>
<a href="#l8.248"></a><span id="l8.248" class="difflineplus">+  testHelperModule.verify_messages_in_view(aSynSets,</span>
<a href="#l8.249"></a><span id="l8.249" class="difflineplus">+                                           aController.folderDisplay.view);</span>
<a href="#l8.250"></a><span id="l8.250"> }</span>
<a href="#l8.251"></a><span id="l8.251"> </span>
<a href="#l8.252"></a><span id="l8.252"> /**</span>
<a href="#l8.253"></a><span id="l8.253">  * Assert the the given message/messages are not present in the view.</span>
<a href="#l8.254"></a><span id="l8.254">  * @param aMessages Either a single nsIMsgDBHdr or a list of them.</span>
<a href="#l8.255"></a><span id="l8.255">  */</span>
<a href="#l8.256"></a><span id="l8.256"> function assert_messages_not_in_view(aMessages, aController) {</span>
<a href="#l8.257"></a><span id="l8.257">   if (aController === undefined)</span>
<a href="#l8.258"></a><span id="l8.258" class="difflineat">@@ -1933,29 +1930,39 @@ function assert_summary_contains_N_divs(</span>
<a href="#l8.259"></a><span id="l8.259"> }</span>
<a href="#l8.260"></a><span id="l8.260"> </span>
<a href="#l8.261"></a><span id="l8.261"> </span>
<a href="#l8.262"></a><span id="l8.262"> function throw_and_dump_view_state(aMessage, aController) {</span>
<a href="#l8.263"></a><span id="l8.263">   if (aController == null)</span>
<a href="#l8.264"></a><span id="l8.264">     aController = mc;</span>
<a href="#l8.265"></a><span id="l8.265"> </span>
<a href="#l8.266"></a><span id="l8.266">   dump(&quot;******** &quot; + aMessage + &quot;\n&quot;);</span>
<a href="#l8.267"></a><span id="l8.267" class="difflineminus">-  viewWrapperTestUtils.dump_view_state(aController.folderDisplay.view);</span>
<a href="#l8.268"></a><span id="l8.268" class="difflineplus">+  testHelperModule.dump_view_state(aController.folderDisplay.view);</span>
<a href="#l8.269"></a><span id="l8.269">   throw new Error(aMessage);</span>
<a href="#l8.270"></a><span id="l8.270"> }</span>
<a href="#l8.271"></a><span id="l8.271"> </span>
<a href="#l8.272"></a><span id="l8.272" class="difflineminus">-/** exported from viewWrapperTestUtils */</span>
<a href="#l8.273"></a><span id="l8.273" class="difflineplus">+/** exported from messageInjection */</span>
<a href="#l8.274"></a><span id="l8.274"> var make_new_sets_in_folders;</span>
<a href="#l8.275"></a><span id="l8.275"> var make_new_sets_in_folder;</span>
<a href="#l8.276"></a><span id="l8.276"> var add_sets_to_folders;</span>
<a href="#l8.277"></a><span id="l8.277"> </span>
<a href="#l8.278"></a><span id="l8.278"> /**</span>
<a href="#l8.279"></a><span id="l8.279">  * Load a file in its own 'module'.</span>
<a href="#l8.280"></a><span id="l8.280">  *</span>
<a href="#l8.281"></a><span id="l8.281">  * @param aPath A path relative to the comm-central source path.</span>
<a href="#l8.282"></a><span id="l8.282">  *</span>
<a href="#l8.283"></a><span id="l8.283">  * @return An object that serves as the global scope for the loaded file.</span>
<a href="#l8.284"></a><span id="l8.284">  */</span>
<a href="#l8.285"></a><span id="l8.285" class="difflineminus">-function load_via_src_path(aPath) {</span>
<a href="#l8.286"></a><span id="l8.286" class="difflineplus">+function load_via_src_path(aPath, aModule) {</span>
<a href="#l8.287"></a><span id="l8.287" class="difflineplus">+  let loader = Cc[&quot;@mozilla.org/moz/jssubscript-loader;1&quot;]</span>
<a href="#l8.288"></a><span id="l8.288" class="difflineplus">+                 .getService(Ci.mozIJSSubScriptLoader);</span>
<a href="#l8.289"></a><span id="l8.289" class="difflineplus">+  let ioService = Cc[&quot;@mozilla.org/network/io-service;1&quot;]</span>
<a href="#l8.290"></a><span id="l8.290" class="difflineplus">+                    .getService(Ci.nsIIOService);</span>
<a href="#l8.291"></a><span id="l8.291" class="difflineplus">+</span>
<a href="#l8.292"></a><span id="l8.292">   let srcPath = os.abspath(&quot;../../../..&quot;,os.getFileForPath( __file__));</span>
<a href="#l8.293"></a><span id="l8.293">   let fullPath = os.abspath(aPath, os.getFileForPath(srcPath));</span>
<a href="#l8.294"></a><span id="l8.294" class="difflineminus">-  return frame.loadFile(fullPath, undefined);</span>
<a href="#l8.295"></a><span id="l8.295" class="difflineplus">+</span>
<a href="#l8.296"></a><span id="l8.296" class="difflineplus">+  let file = Cc[&quot;@mozilla.org/file/local;1&quot;]</span>
<a href="#l8.297"></a><span id="l8.297" class="difflineplus">+               .createInstance(Ci.nsILocalFile);</span>
<a href="#l8.298"></a><span id="l8.298" class="difflineplus">+  file.initWithPath(fullPath);</span>
<a href="#l8.299"></a><span id="l8.299" class="difflineplus">+  let uri = ioService.newFileURI(file).spec;</span>
<a href="#l8.300"></a><span id="l8.300" class="difflineplus">+  loader.loadSubScript(uri, aModule);</span>
<a href="#l8.301"></a><span id="l8.301"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/base/public/nsIMsgFolderListener.idl</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/base/public/nsIMsgFolderListener.idl</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -47,27 +47,64 @@ interface nsIArray;</span>
<a href="#l9.4"></a><span id="l9.4">  * especially w.r.t. moving messages and folders.  Some listeners want to know</span>
<a href="#l9.5"></a><span id="l9.5">  * about moves, instead of getting an itemAdded and itemRemoved notification.</span>
<a href="#l9.6"></a><span id="l9.6">  * Folder listeners also only tend to get called if a view is open on the folder,</span>
<a href="#l9.7"></a><span id="l9.7">  * which is not always the case. I don't want to change nsIFolderListener at this</span>
<a href="#l9.8"></a><span id="l9.8">  * point since there are lots of extensions that rely on it. Eventually,</span>
<a href="#l9.9"></a><span id="l9.9">  * these two interfaces should be combined somehow.</span>
<a href="#l9.10"></a><span id="l9.10">  */</span>
<a href="#l9.11"></a><span id="l9.11"> </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-[scriptable, uuid(eebbedae-ce43-4151-9798-3f1c6e5a5af0)]</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+[scriptable, uuid(63533aa2-9e03-424c-b308-a3ee5ad47bc5)]</span>
<a href="#l9.14"></a><span id="l9.14"> interface nsIMsgFolderListener : nsISupports {</span>
<a href="#l9.15"></a><span id="l9.15">   /**</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineminus">-   * Notified immediately after a message is added to a folder. This could be a new incoming</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineminus">-   * message to a local folder, or a new message in an IMAP folder when it is opened.</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+   * Notified immediately after a message is added to a folder. This could be a</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+   * new incoming message to a local folder, or a new message in an IMAP folder</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+   * when it is opened.</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+   *</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+   * You may want to consider using the msgsClassified notification instead of</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+   * this notification if any of the following are true:</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+   *</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+   * - You only want to be notified about messages after junk classification</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineplus">+   *   has occurred (if it is going to occur for a message).  This also goes for</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineplus">+   *   trait classification which is a generic use of the bayesian engine at</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+   *   the heart of the spam logic.</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineplus">+   *</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineplus">+   * - You only want to be notified about messages after all filters have been</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineplus">+   *   run.  Although some filters may be run before the msgAdded notification</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+   *   is generated, filters dependent on junk/trait classification wait until</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineplus">+   *   classification completes.</span>
<a href="#l9.34"></a><span id="l9.34">    *</span>
<a href="#l9.35"></a><span id="l9.35">    * @param aMsg The message header that was just added</span>
<a href="#l9.36"></a><span id="l9.36">    */</span>
<a href="#l9.37"></a><span id="l9.37">   void msgAdded(in nsIMsgDBHdr aMsg);</span>
<a href="#l9.38"></a><span id="l9.38"> </span>
<a href="#l9.39"></a><span id="l9.39">   /**</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+   * Notification that (new to the client) messages have been through junk and</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+   * trait classification.  This event will occur for all messages at some point</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+   * after their existence is revealed by msgAdded.</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+   *</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+   * Because junk classification does not run if no messages have ever been</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineplus">+   * marked as junk by the user, it is possible to receive this message without</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+   * any classification having actually been performed.  We still generate the</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+   * notification in this case so that code is reliably notified about the</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineplus">+   * existence of the new message headers.</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineplus">+   *</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+   * IMPORTANT! You may receive a notification for a message more than once</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+   * because of deficiencies in our treatment of new messages.</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineplus">+   *</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineplus">+   * @param aMsgs The message headers that have been classified or were</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+   *     intentionally not classified.</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineplus">+   * @param aJunkProcessed Were the messages processed for junk classification?</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineplus">+   * @param aTraitProcessed Were the messages processed for trait</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+   *     classification?</span>
<a href="#l9.58"></a><span id="l9.58" class="difflineplus">+   */</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineplus">+  void msgsClassified(in nsIArray aMsgs, in boolean aJunkProcessed,</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineplus">+                      in boolean aTraitProcessed);</span>
<a href="#l9.61"></a><span id="l9.61" class="difflineplus">+</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineplus">+  /**</span>
<a href="#l9.63"></a><span id="l9.63">    * Notified after a command to delete a group of messages has been given, but before the</span>
<a href="#l9.64"></a><span id="l9.64">    * messages have actually been deleted.</span>
<a href="#l9.65"></a><span id="l9.65">    *</span>
<a href="#l9.66"></a><span id="l9.66">    * @param aMsgs An array of the message headers about to be deleted</span>
<a href="#l9.67"></a><span id="l9.67">    *</span>
<a href="#l9.68"></a><span id="l9.68">    * @note</span>
<a href="#l9.69"></a><span id="l9.69">    * This notification will not take place if the messages are being deleted from the folder</span>
<a href="#l9.70"></a><span id="l9.70">    * as the result of a move to another folder. Instead, the msgsMoveCopyCompleted() notification</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineat">@@ -79,31 +116,35 @@ interface nsIMsgFolderListener : nsISupp</span>
<a href="#l9.72"></a><span id="l9.72">    * @note</span>
<a href="#l9.73"></a><span id="l9.73">    * If the user has selected the IMAP delete model (marking messages as deleted, then purging them</span>
<a href="#l9.74"></a><span id="l9.74">    * later) for an IMAP account, this notification will not take place on the delete. This will only</span>
<a href="#l9.75"></a><span id="l9.75">    * take place on the purge.</span>
<a href="#l9.76"></a><span id="l9.76">    */</span>
<a href="#l9.77"></a><span id="l9.77">   void msgsDeleted(in nsIArray aMsgs);</span>
<a href="#l9.78"></a><span id="l9.78"> </span>
<a href="#l9.79"></a><span id="l9.79">   /**</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineminus">-   * Notified after a command to move or copy a group of messages completes. In case of a move,</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineminus">-   * this is before the messages have been deleted from the source folder.</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineplus">+   * Notified after a command to move or copy a group of messages completes. In</span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+   * case of a move, this is before the messages have been deleted from the</span>
<a href="#l9.84"></a><span id="l9.84" class="difflineplus">+   * source folder.</span>
<a href="#l9.85"></a><span id="l9.85">    *</span>
<a href="#l9.86"></a><span id="l9.86">    * @param aMove true if a move, false if a copy</span>
<a href="#l9.87"></a><span id="l9.87">    * @param aSrcMsgs An array of the message headers in the source folder</span>
<a href="#l9.88"></a><span id="l9.88" class="difflineminus">-   * @param aDestFolder The folder these messages were moved to</span>
<a href="#l9.89"></a><span id="l9.89" class="difflineplus">+   * @param aDestFolder The folder these messages were moved to.</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineplus">+   * @param aDestMsgs Present only for local folder moves, it provides the list</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+   *     of target message headers.</span>
<a href="#l9.92"></a><span id="l9.92">    *</span>
<a href="#l9.93"></a><span id="l9.93">    * @note</span>
<a href="#l9.94"></a><span id="l9.94" class="difflineminus">-   * If messages are moved from a server which uses the IMAP delete model, you'll get aMove =</span>
<a href="#l9.95"></a><span id="l9.95" class="difflineminus">-   * false. That's because the messages are not deleted from the source database, but instead</span>
<a href="#l9.96"></a><span id="l9.96" class="difflineminus">-   * simply marked deleted.</span>
<a href="#l9.97"></a><span id="l9.97" class="difflineplus">+   * If messages are moved from a server which uses the IMAP delete model,</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineplus">+   * you'll get aMove = false. That's because the messages are not deleted from</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineplus">+   * the source database, but instead simply marked deleted.</span>
<a href="#l9.100"></a><span id="l9.100">    */</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineminus">-  void msgsMoveCopyCompleted(in boolean aMove, </span>
<a href="#l9.102"></a><span id="l9.102" class="difflineminus">-                             in nsIArray aSrcMsgs, </span>
<a href="#l9.103"></a><span id="l9.103" class="difflineminus">-                             in nsIMsgFolder aDestFolder);</span>
<a href="#l9.104"></a><span id="l9.104" class="difflineplus">+  void msgsMoveCopyCompleted(in boolean aMove,</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineplus">+                             in nsIArray aSrcMsgs,</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineplus">+                             in nsIMsgFolder aDestFolder,</span>
<a href="#l9.107"></a><span id="l9.107" class="difflineplus">+                             in nsIArray aDestMsgs);</span>
<a href="#l9.108"></a><span id="l9.108"> </span>
<a href="#l9.109"></a><span id="l9.109">   /**</span>
<a href="#l9.110"></a><span id="l9.110">    * Notified after a folder has been added.</span>
<a href="#l9.111"></a><span id="l9.111">    *</span>
<a href="#l9.112"></a><span id="l9.112">    * @param aFolder The folder that has just been added</span>
<a href="#l9.113"></a><span id="l9.113">    */</span>
<a href="#l9.114"></a><span id="l9.114">   void folderAdded(in nsIMsgFolder aFolder);</span>
<a href="#l9.115"></a><span id="l9.115"> </span>
<a href="#l9.116"></a><span id="l9.116" class="difflineat">@@ -133,17 +174,41 @@ interface nsIMsgFolderListener : nsISupp</span>
<a href="#l9.117"></a><span id="l9.117">    * Notified after a folder is renamed.</span>
<a href="#l9.118"></a><span id="l9.118">    *</span>
<a href="#l9.119"></a><span id="l9.119">    * @param aOrigFolder The folder with the old name</span>
<a href="#l9.120"></a><span id="l9.120">    * @param aNewFolder The folder with the new name</span>
<a href="#l9.121"></a><span id="l9.121">    */</span>
<a href="#l9.122"></a><span id="l9.122">   void folderRenamed(in nsIMsgFolder aOrigFolder, in nsIMsgFolder aNewFolder);</span>
<a href="#l9.123"></a><span id="l9.123">   </span>
<a href="#l9.124"></a><span id="l9.124">   /**</span>
<a href="#l9.125"></a><span id="l9.125" class="difflineminus">-   * Notified when a particular event takes place for an item. Currently this is</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineminus">-   * unused.</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineplus">+   * Notified when a particular event takes place for an item.</span>
<a href="#l9.128"></a><span id="l9.128" class="difflineplus">+   *</span>
<a href="#l9.129"></a><span id="l9.129" class="difflineplus">+   * Current uses by event string:</span>
<a href="#l9.130"></a><span id="l9.130" class="difflineplus">+   *</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineplus">+   * - FolderCompactStart: nsIMsgFolderCompactor is beginning compaction of the</span>
<a href="#l9.132"></a><span id="l9.132" class="difflineplus">+   *    folder.  If the summary file was missing or out-of-date and a parse</span>
<a href="#l9.133"></a><span id="l9.133" class="difflineplus">+   *    is required, this notification will come after the completion of the</span>
<a href="#l9.134"></a><span id="l9.134" class="difflineplus">+   *    parse.  The compactor will be holding the folder's semaphore when</span>
<a href="#l9.135"></a><span id="l9.135" class="difflineplus">+   *    this notification is generated.  This only happens for local folders</span>
<a href="#l9.136"></a><span id="l9.136" class="difflineplus">+   *    currently.  aItem is the folder.</span>
<a href="#l9.137"></a><span id="l9.137" class="difflineplus">+   * - FolderCompactFinish: nsIMsgFolderCompactor has completed compaction of</span>
<a href="#l9.138"></a><span id="l9.138" class="difflineplus">+   *    the folder.  This notification will be generated immediately prior to</span>
<a href="#l9.139"></a><span id="l9.139" class="difflineplus">+   *    the nsIFolderListener::itemEvent() notification with a</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineplus">+   *    &quot;CompactCompleted&quot; atom.  At this point, the folder semaphore has been</span>
<a href="#l9.141"></a><span id="l9.141" class="difflineplus">+   *    released and the database has been committed.  aItem is the folder.</span>
<a href="#l9.142"></a><span id="l9.142" class="difflineplus">+   *</span>
<a href="#l9.143"></a><span id="l9.143" class="difflineplus">+   * - JunkStatusChanged: Indicates that some messages that had already been</span>
<a href="#l9.144"></a><span id="l9.144" class="difflineplus">+   *    reported by msgsClassified have had their junk status changed.  This</span>
<a href="#l9.145"></a><span id="l9.145" class="difflineplus">+   *    event will not fire for the initial automatic classification of</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineplus">+   *    messages; msgsClassified will tell you about those messages.  This</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineplus">+   *    notification may be promoted to an explicit callback function at some</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineplus">+   *    point.  This is not guaranteed to be a comprehensive source of junk</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+   *    notification events; right now any time an nsMsgDBView marks things as</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineplus">+   *    junk/non-junk a notification is produced.  aItem is an nsIArray of</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineplus">+   *    messages, aData is either a &quot;junk&quot; or &quot;notjunk&quot; atom if all of the</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineplus">+   *    messages have the same state.</span>
<a href="#l9.153"></a><span id="l9.153">    *</span>
<a href="#l9.154"></a><span id="l9.154">    * @param aItem The item the event takes place on</span>
<a href="#l9.155"></a><span id="l9.155">    * @param aEvent String describing the event</span>
<a href="#l9.156"></a><span id="l9.156">    * @param aData Data relevant to the event</span>
<a href="#l9.157"></a><span id="l9.157">    */</span>
<a href="#l9.158"></a><span id="l9.158">   void itemEvent(in nsISupports aItem, in ACString aEvent, in nsISupports aData);</span>
<a href="#l9.159"></a><span id="l9.159"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/base/public/nsIMsgFolderNotificationService.idl</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/base/public/nsIMsgFolderNotificationService.idl</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -40,73 +40,75 @@</span>
<a href="#l10.4"></a><span id="l10.4"> </span>
<a href="#l10.5"></a><span id="l10.5"> interface nsIMsgDBHdr;</span>
<a href="#l10.6"></a><span id="l10.6"> interface nsIMsgFolder;</span>
<a href="#l10.7"></a><span id="l10.7"> interface nsIMsgFolderListener;</span>
<a href="#l10.8"></a><span id="l10.8"> interface nsIArray;</span>
<a href="#l10.9"></a><span id="l10.9"> </span>
<a href="#l10.10"></a><span id="l10.10"> typedef unsigned long msgFolderListenerFlag;</span>
<a href="#l10.11"></a><span id="l10.11"> </span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-[scriptable, uuid(e5d75176-a3d7-4f80-a1fe-b915a679ca53)]</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+[scriptable, uuid(45420c55-b460-4a61-bd67-7f763a69a46e)]</span>
<a href="#l10.14"></a><span id="l10.14"> interface nsIMsgFolderNotificationService : nsISupports {</span>
<a href="#l10.15"></a><span id="l10.15">   /**</span>
<a href="#l10.16"></a><span id="l10.16">    * @name Notification flags</span>
<a href="#l10.17"></a><span id="l10.17">    * These flags determine which notifications will be sent.</span>
<a href="#l10.18"></a><span id="l10.18">    * @{</span>
<a href="#l10.19"></a><span id="l10.19">    */</span>
<a href="#l10.20"></a><span id="l10.20">   /// nsIMsgFolderListener::msgAdded notification</span>
<a href="#l10.21"></a><span id="l10.21">   const msgFolderListenerFlag msgAdded = 0x1;</span>
<a href="#l10.22"></a><span id="l10.22"> </span>
<a href="#l10.23"></a><span id="l10.23">   /// nsIMsgFolderListener::msgsDeleted notification</span>
<a href="#l10.24"></a><span id="l10.24">   const msgFolderListenerFlag msgsDeleted = 0x2;</span>
<a href="#l10.25"></a><span id="l10.25"> </span>
<a href="#l10.26"></a><span id="l10.26">   /// nsIMsgFolderListener::msgsMoveCopyCompleted notification</span>
<a href="#l10.27"></a><span id="l10.27">   const msgFolderListenerFlag msgsMoveCopyCompleted = 0x4;</span>
<a href="#l10.28"></a><span id="l10.28"> </span>
<a href="#l10.29"></a><span id="l10.29" class="difflineminus">-  /// All message notifications</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineminus">-  const msgFolderListenerFlag allMsgNotifications = 0x7;</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+  /// nsIMsgFolderListener::msgsClassified notification</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+  const msgFolderListenerFlag msgsClassified = 0x8;</span>
<a href="#l10.33"></a><span id="l10.33"> </span>
<a href="#l10.34"></a><span id="l10.34">   /// nsIMsgFolderListener::folderAdded notification</span>
<a href="#l10.35"></a><span id="l10.35">   const msgFolderListenerFlag folderAdded = 0x8000;</span>
<a href="#l10.36"></a><span id="l10.36"> </span>
<a href="#l10.37"></a><span id="l10.37">   /// nsIMsgFolderListener::folderDeleted notification</span>
<a href="#l10.38"></a><span id="l10.38">   const msgFolderListenerFlag folderDeleted = 0x1000;</span>
<a href="#l10.39"></a><span id="l10.39"> </span>
<a href="#l10.40"></a><span id="l10.40">   /// nsIMsgFolderListener::folderMoveCopyCompleted notification</span>
<a href="#l10.41"></a><span id="l10.41">   const msgFolderListenerFlag folderMoveCopyCompleted = 0x2000;</span>
<a href="#l10.42"></a><span id="l10.42"> </span>
<a href="#l10.43"></a><span id="l10.43">   /// nsIMsgFolderListener::folderRenamed notification</span>
<a href="#l10.44"></a><span id="l10.44">   const msgFolderListenerFlag folderRenamed = 0x4000;</span>
<a href="#l10.45"></a><span id="l10.45"> </span>
<a href="#l10.46"></a><span id="l10.46" class="difflineminus">-  /// All folder notifications</span>
<a href="#l10.47"></a><span id="l10.47" class="difflineminus">-  const msgFolderListenerFlag allFolderNotifications = 0xF000;</span>
<a href="#l10.48"></a><span id="l10.48" class="difflineminus">-</span>
<a href="#l10.49"></a><span id="l10.49">   /// nsIMsgFolderListener::itemEvent notification</span>
<a href="#l10.50"></a><span id="l10.50">   const msgFolderListenerFlag itemEvent = 0x1000000;</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineminus">-</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineminus">-  /// All notifications</span>
<a href="#l10.53"></a><span id="l10.53" class="difflineminus">-  const msgFolderListenerFlag all = 0xFFFFFFFF;</span>
<a href="#l10.54"></a><span id="l10.54">   /** @} */</span>
<a href="#l10.55"></a><span id="l10.55"> </span>
<a href="#l10.56"></a><span id="l10.56">   readonly attribute boolean hasListeners;</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineminus">-  void addListener(in nsIMsgFolderListener aListener, in msgFolderListenerFlag flags);</span>
<a href="#l10.58"></a><span id="l10.58" class="difflineplus">+  void addListener(in nsIMsgFolderListener aListener,</span>
<a href="#l10.59"></a><span id="l10.59" class="difflineplus">+                   in msgFolderListenerFlag flags);</span>
<a href="#l10.60"></a><span id="l10.60">   void removeListener(in nsIMsgFolderListener aListener);</span>
<a href="#l10.61"></a><span id="l10.61"> </span>
<a href="#l10.62"></a><span id="l10.62">   // message-specific functions</span>
<a href="#l10.63"></a><span id="l10.63">   // single message for added, array for delete/move/copy</span>
<a href="#l10.64"></a><span id="l10.64">   void notifyMsgAdded(in nsIMsgDBHdr aMsg);</span>
<a href="#l10.65"></a><span id="l10.65" class="difflineplus">+  void notifyMsgsClassified(in nsIArray aMsgs,</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineplus">+                            in boolean aJunkProcessed,</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineplus">+                            in boolean aTraitProcessed);</span>
<a href="#l10.68"></a><span id="l10.68">   void notifyMsgsDeleted(in nsIArray aMsgs);</span>
<a href="#l10.69"></a><span id="l10.69">   void notifyMsgsMoveCopyCompleted(in boolean aMove, </span>
<a href="#l10.70"></a><span id="l10.70">                                    in nsIArray aSrcMsgs, </span>
<a href="#l10.71"></a><span id="l10.71" class="difflineminus">-                                   in nsIMsgFolder aDestFolder);</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+                                   in nsIMsgFolder aDestFolder,</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+                                   in nsIArray aDestMsgs);</span>
<a href="#l10.74"></a><span id="l10.74"> </span>
<a href="#l10.75"></a><span id="l10.75">   // folder specific functions</span>
<a href="#l10.76"></a><span id="l10.76">   // single folders, all the time</span>
<a href="#l10.77"></a><span id="l10.77">   void notifyFolderAdded(in nsIMsgFolder aFolder);</span>
<a href="#l10.78"></a><span id="l10.78">   void notifyFolderDeleted(in nsIMsgFolder aFolder);</span>
<a href="#l10.79"></a><span id="l10.79">   void notifyFolderMoveCopyCompleted(in boolean aMove,</span>
<a href="#l10.80"></a><span id="l10.80">                                      in nsIMsgFolder aSrcFolder,</span>
<a href="#l10.81"></a><span id="l10.81">                                      in nsIMsgFolder aDestFolder);</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineminus">-  void notifyFolderRenamed(in nsIMsgFolder aOrigFolder, in nsIMsgFolder aNewFolder);</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineplus">+  void notifyFolderRenamed(in nsIMsgFolder aOrigFolder,</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineplus">+                           in nsIMsgFolder aNewFolder);</span>
<a href="#l10.85"></a><span id="l10.85"> </span>
<a href="#l10.86"></a><span id="l10.86">   // extensibility hook</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineminus">-  void notifyItemEvent(in nsISupports aItem, in ACString aEvent, in nsISupports aData);</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineplus">+  void notifyItemEvent(in nsISupports aItem,</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineplus">+                       in ACString aEvent,</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+                       in nsISupports aData);</span>
<a href="#l10.91"></a><span id="l10.91"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/base/search/src/nsMsgSearchTerm.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/base/search/src/nsMsgSearchTerm.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -531,16 +531,21 @@ nsresult nsMsgSearchTerm::OutputValue(ns</span>
<a href="#l11.4"></a><span id="l11.4">         outputStr.Append(&quot;true&quot;);  // don't need anything here, really</span>
<a href="#l11.5"></a><span id="l11.5">         break;</span>
<a href="#l11.6"></a><span id="l11.6">       }</span>
<a href="#l11.7"></a><span id="l11.7">     case nsMsgSearchAttrib::Size:</span>
<a href="#l11.8"></a><span id="l11.8">       {</span>
<a href="#l11.9"></a><span id="l11.9">         outputStr.AppendInt(m_value.u.size);</span>
<a href="#l11.10"></a><span id="l11.10">         break;</span>
<a href="#l11.11"></a><span id="l11.11">       }</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+    case nsMsgSearchAttrib::Uint32HdrProperty:</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+      {</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+        outputStr.AppendInt(m_value.u.msgStatus);</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+        break;</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+      }</span>
<a href="#l11.17"></a><span id="l11.17">     default:</span>
<a href="#l11.18"></a><span id="l11.18">       NS_ASSERTION(PR_FALSE, &quot;trying to output invalid attribute&quot;);</span>
<a href="#l11.19"></a><span id="l11.19">       break;</span>
<a href="#l11.20"></a><span id="l11.20">     }</span>
<a href="#l11.21"></a><span id="l11.21">   }</span>
<a href="#l11.22"></a><span id="l11.22">   return NS_OK;</span>
<a href="#l11.23"></a><span id="l11.23"> }</span>
<a href="#l11.24"></a><span id="l11.24"> </span>
<a href="#l11.25"></a><span id="l11.25" class="difflineat">@@ -564,16 +569,21 @@ NS_IMETHODIMP nsMsgSearchTerm::GetTermAs</span>
<a href="#l11.26"></a><span id="l11.26">   }</span>
<a href="#l11.27"></a><span id="l11.27"> </span>
<a href="#l11.28"></a><span id="l11.28">   else if (m_attribute == nsMsgSearchAttrib::Custom)</span>
<a href="#l11.29"></a><span id="l11.29">   {</span>
<a href="#l11.30"></a><span id="l11.30">     // use the custom id as the string</span>
<a href="#l11.31"></a><span id="l11.31">     outputStr = m_customId;</span>
<a href="#l11.32"></a><span id="l11.32">   }</span>
<a href="#l11.33"></a><span id="l11.33"> </span>
<a href="#l11.34"></a><span id="l11.34" class="difflineplus">+  else if (m_attribute == nsMsgSearchAttrib::Uint32HdrProperty)</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+  {</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+    outputStr = m_hdrProperty;</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+  }</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+</span>
<a href="#l11.39"></a><span id="l11.39">   else {</span>
<a href="#l11.40"></a><span id="l11.40">     const char *attrib;</span>
<a href="#l11.41"></a><span id="l11.41">     ret = NS_MsgGetStringForAttribute(m_attribute, &amp;attrib);</span>
<a href="#l11.42"></a><span id="l11.42">     if (ret != NS_OK)</span>
<a href="#l11.43"></a><span id="l11.43">       return ret;</span>
<a href="#l11.44"></a><span id="l11.44">     outputStr = attrib;</span>
<a href="#l11.45"></a><span id="l11.45">   }</span>
<a href="#l11.46"></a><span id="l11.46"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgDBView.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -71,16 +71,17 @@</span>
<a href="#l12.4"></a><span id="l12.4"> #include &quot;nsITreeColumns.h&quot;</span>
<a href="#l12.5"></a><span id="l12.5"> #include &quot;nsTextFormatter.h&quot;</span>
<a href="#l12.6"></a><span id="l12.6"> #include &quot;nsIMutableArray.h&quot;</span>
<a href="#l12.7"></a><span id="l12.7"> #include &quot;nsIMimeConverter.h&quot;</span>
<a href="#l12.8"></a><span id="l12.8"> #include &quot;nsMsgMessageFlags.h&quot;</span>
<a href="#l12.9"></a><span id="l12.9"> #include &quot;nsIPrompt.h&quot;</span>
<a href="#l12.10"></a><span id="l12.10"> #include &quot;nsIWindowWatcher.h&quot;</span>
<a href="#l12.11"></a><span id="l12.11"> #include &quot;nsMsgDBCID.h&quot;</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+#include &quot;nsIMsgFolderNotificationService.h&quot;</span>
<a href="#l12.13"></a><span id="l12.13"> </span>
<a href="#l12.14"></a><span id="l12.14"> nsrefcnt nsMsgDBView::gInstanceCount  = 0;</span>
<a href="#l12.15"></a><span id="l12.15"> </span>
<a href="#l12.16"></a><span id="l12.16"> #ifdef SUPPORT_PRIORITY_COLORS</span>
<a href="#l12.17"></a><span id="l12.17"> nsIAtom * nsMsgDBView::kHighestPriorityAtom = nsnull;</span>
<a href="#l12.18"></a><span id="l12.18"> nsIAtom * nsMsgDBView::kHighPriorityAtom = nsnull;</span>
<a href="#l12.19"></a><span id="l12.19"> nsIAtom * nsMsgDBView::kLowestPriorityAtom = nsnull;</span>
<a href="#l12.20"></a><span id="l12.20"> nsIAtom * nsMsgDBView::kLowPriorityAtom = nsnull;</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineat">@@ -2805,16 +2806,28 @@ nsMsgDBView::ApplyCommandToIndices(nsMsg</span>
<a href="#l12.22"></a><span id="l12.22">         break;</span>
<a href="#l12.23"></a><span id="l12.23">       case nsMsgViewCommandType::undeleteMsg:</span>
<a href="#l12.24"></a><span id="l12.24">         break; // this is completely handled in the imap code below.</span>
<a href="#l12.25"></a><span id="l12.25">       default:</span>
<a href="#l12.26"></a><span id="l12.26">         NS_ASSERTION(PR_FALSE, &quot;unhandled command&quot;);</span>
<a href="#l12.27"></a><span id="l12.27">         break;</span>
<a href="#l12.28"></a><span id="l12.28">       }</span>
<a href="#l12.29"></a><span id="l12.29">     }</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+    // Provide junk-related batch notifications</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+    if ((command == nsMsgViewCommandType::junk) &amp;&amp;</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+        (command == nsMsgViewCommandType::unjunk)) {</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+        notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+      if (notifier)</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+        notifier-&gt;NotifyItemEvent(messages,</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+                                  NS_LITERAL_CSTRING(&quot;JunkStatusChanged&quot;),</span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+                                  (command == nsMsgViewCommandType::junk) ?</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineplus">+                                    kJunkMsgAtom : kNotJunkMsgAtom);</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineplus">+    }</span>
<a href="#l12.42"></a><span id="l12.42">   }</span>
<a href="#l12.43"></a><span id="l12.43"> </span>
<a href="#l12.44"></a><span id="l12.44">   folder-&gt;EnableNotifications(nsIMsgFolder::allMessageCountNotifications, PR_TRUE, PR_TRUE /*dbBatching*/);</span>
<a href="#l12.45"></a><span id="l12.45"> </span>
<a href="#l12.46"></a><span id="l12.46">   if (thisIsImapFolder)</span>
<a href="#l12.47"></a><span id="l12.47">   {</span>
<a href="#l12.48"></a><span id="l12.48">     imapMessageFlagsType flags = kNoImapMsgFlag;</span>
<a href="#l12.49"></a><span id="l12.49">     PRBool addFlags = PR_FALSE;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/base/src/nsMsgFolderCompactor.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgFolderCompactor.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -56,16 +56,18 @@</span>
<a href="#l13.4"></a><span id="l13.4"> #include &quot;nsMailHeaders.h&quot;</span>
<a href="#l13.5"></a><span id="l13.5"> #include &quot;nsMsgI18N.h&quot;</span>
<a href="#l13.6"></a><span id="l13.6"> #include &quot;prprf.h&quot;</span>
<a href="#l13.7"></a><span id="l13.7"> #include &quot;nsMsgLocalFolderHdrs.h&quot;</span>
<a href="#l13.8"></a><span id="l13.8"> #include &quot;nsIMsgDatabase.h&quot;</span>
<a href="#l13.9"></a><span id="l13.9"> #include &quot;nsArrayUtils.h&quot;</span>
<a href="#l13.10"></a><span id="l13.10"> #include &quot;nsMsgMessageFlags.h&quot;</span>
<a href="#l13.11"></a><span id="l13.11"> #include &quot;nsIMsgStatusFeedback.h&quot;</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+#include &quot;nsMsgBaseCID.h&quot;</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+#include &quot;nsIMsgFolderNotificationService.h&quot;</span>
<a href="#l13.14"></a><span id="l13.14"> </span>
<a href="#l13.15"></a><span id="l13.15"> //////////////////////////////////////////////////////////////////////////////</span>
<a href="#l13.16"></a><span id="l13.16"> // nsFolderCompactState</span>
<a href="#l13.17"></a><span id="l13.17"> //////////////////////////////////////////////////////////////////////////////</span>
<a href="#l13.18"></a><span id="l13.18"> </span>
<a href="#l13.19"></a><span id="l13.19"> NS_IMPL_ISUPPORTS5(nsFolderCompactState, nsIMsgFolderCompactor, nsIRequestObserver, nsIStreamListener, nsICopyMessageStreamListener, nsIUrlListener)</span>
<a href="#l13.20"></a><span id="l13.20"> </span>
<a href="#l13.21"></a><span id="l13.21"> nsFolderCompactState::nsFolderCompactState()</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineat">@@ -361,18 +363,28 @@ NS_IMETHODIMP nsFolderCompactState::OnSt</span>
<a href="#l13.23"></a><span id="l13.23">     CompactCompleted(status);</span>
<a href="#l13.24"></a><span id="l13.24">   }</span>
<a href="#l13.25"></a><span id="l13.25">   return NS_OK;</span>
<a href="#l13.26"></a><span id="l13.26"> }</span>
<a href="#l13.27"></a><span id="l13.27"> </span>
<a href="#l13.28"></a><span id="l13.28"> nsresult nsFolderCompactState::StartCompacting()</span>
<a href="#l13.29"></a><span id="l13.29"> {</span>
<a href="#l13.30"></a><span id="l13.30">   nsresult rv = NS_OK;</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineplus">+  // Notify that compaction is beginning.  We do this even if there are no</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+  // messages to be copied because the summary database still gets blown away</span>
<a href="#l13.33"></a><span id="l13.33" class="difflineplus">+  // which is still pretty interesting.  (And we like consistency.)</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineplus">+    notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineplus">+  if (notifier)</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineplus">+    notifier-&gt;NotifyItemEvent(m_folder,</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineplus">+                              NS_LITERAL_CSTRING(&quot;FolderCompactStart&quot;),</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineplus">+                              nsnull);</span>
<a href="#l13.40"></a><span id="l13.40">   if (m_size &gt; 0)</span>
<a href="#l13.41"></a><span id="l13.41">   {</span>
<a href="#l13.42"></a><span id="l13.42" class="difflineplus">+</span>
<a href="#l13.43"></a><span id="l13.43">     ShowCompactingStatusMsg();</span>
<a href="#l13.44"></a><span id="l13.44">     AddRef();</span>
<a href="#l13.45"></a><span id="l13.45">     rv = m_messageService-&gt;CopyMessages(m_keyArray, m_folder, this, PR_FALSE, nsnull, m_window, nsnull);</span>
<a href="#l13.46"></a><span id="l13.46">     // m_curIndex = m_size;  // advance m_curIndex to the end - we're done</span>
<a href="#l13.47"></a><span id="l13.47"> </span>
<a href="#l13.48"></a><span id="l13.48">   }</span>
<a href="#l13.49"></a><span id="l13.49">   else</span>
<a href="#l13.50"></a><span id="l13.50">   { // no messages to copy with</span>
<a href="#l13.51"></a><span id="l13.51" class="difflineat">@@ -486,16 +498,23 @@ nsFolderCompactState::FinishCompact()</span>
<a href="#l13.52"></a><span id="l13.52">     // and set the summary valid again.</span>
<a href="#l13.53"></a><span id="l13.53">     if(dbFolderInfo)</span>
<a href="#l13.54"></a><span id="l13.54">       dbFolderInfo-&gt;SetExpungedBytes(0);</span>
<a href="#l13.55"></a><span id="l13.55">   }</span>
<a href="#l13.56"></a><span id="l13.56">   if (m_db)</span>
<a href="#l13.57"></a><span id="l13.57">     m_db-&gt;Close(PR_TRUE);</span>
<a href="#l13.58"></a><span id="l13.58">   m_db = nsnull;</span>
<a href="#l13.59"></a><span id="l13.59"> </span>
<a href="#l13.60"></a><span id="l13.60" class="difflineplus">+  // Notify that compaction of the folder is completed.</span>
<a href="#l13.61"></a><span id="l13.61" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l13.62"></a><span id="l13.62" class="difflineplus">+    notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l13.63"></a><span id="l13.63" class="difflineplus">+  if (notifier)</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineplus">+    notifier-&gt;NotifyItemEvent(m_folder,</span>
<a href="#l13.65"></a><span id="l13.65" class="difflineplus">+                              NS_LITERAL_CSTRING(&quot;FolderCompactFinish&quot;),</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineplus">+                              nsnull);</span>
<a href="#l13.67"></a><span id="l13.67">   m_folder-&gt;NotifyCompactCompleted();</span>
<a href="#l13.68"></a><span id="l13.68"> </span>
<a href="#l13.69"></a><span id="l13.69">   if (m_compactAll)</span>
<a href="#l13.70"></a><span id="l13.70">     rv = CompactNextFolder();</span>
<a href="#l13.71"></a><span id="l13.71">   else</span>
<a href="#l13.72"></a><span id="l13.72">     CompactCompleted(NS_OK);</span>
<a href="#l13.73"></a><span id="l13.73">       </span>
<a href="#l13.74"></a><span id="l13.74">   return rv;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/base/src/nsMsgFolderNotificationService.cpp</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/base/src/nsMsgFolderNotificationService.cpp</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -102,25 +102,37 @@ NS_IMETHODIMP nsMsgFolderNotificationSer</span>
<a href="#l14.4"></a><span id="l14.4"> </span>
<a href="#l14.5"></a><span id="l14.5"> /* void notifyMsgAdded (in nsIMsgDBHdr aMsg); */</span>
<a href="#l14.6"></a><span id="l14.6"> NS_IMETHODIMP nsMsgFolderNotificationService::NotifyMsgAdded(nsIMsgDBHdr *aMsg)</span>
<a href="#l14.7"></a><span id="l14.7"> {</span>
<a href="#l14.8"></a><span id="l14.8">   NOTIFY_MSGFOLDER_LISTENERS(msgAdded, MsgAdded, (aMsg));</span>
<a href="#l14.9"></a><span id="l14.9">   return NS_OK;</span>
<a href="#l14.10"></a><span id="l14.10"> }</span>
<a href="#l14.11"></a><span id="l14.11"> </span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+/* void notifyMsgsClassified (in  */</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+NS_IMETHODIMP nsMsgFolderNotificationService::NotifyMsgsClassified(</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+  nsIArray *aMsgs, PRBool aJunkProcessed, PRBool aTraitProcessed)</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+{</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+  NOTIFY_MSGFOLDER_LISTENERS(msgsClassified, MsgsClassified,</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+                             (aMsgs, aJunkProcessed, aTraitProcessed));</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+  return NS_OK;</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+}</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+</span>
<a href="#l14.21"></a><span id="l14.21"> /* void notifyMsgsDeleted (in nsIArray aMsgs); */</span>
<a href="#l14.22"></a><span id="l14.22"> NS_IMETHODIMP nsMsgFolderNotificationService::NotifyMsgsDeleted(nsIArray *aMsgs)</span>
<a href="#l14.23"></a><span id="l14.23"> {</span>
<a href="#l14.24"></a><span id="l14.24">   NOTIFY_MSGFOLDER_LISTENERS(msgsDeleted, MsgsDeleted, (aMsgs));</span>
<a href="#l14.25"></a><span id="l14.25">   return NS_OK;</span>
<a href="#l14.26"></a><span id="l14.26"> }</span>
<a href="#l14.27"></a><span id="l14.27"> </span>
<a href="#l14.28"></a><span id="l14.28" class="difflineminus">-/* void notifyMsgsMoveCopyCompleted (in boolean aMove, in nsIArray aSrcMsgs, in nsIMsgFolder aDestFolder); */</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineminus">-NS_IMETHODIMP nsMsgFolderNotificationService::NotifyMsgsMoveCopyCompleted(PRBool aMove, nsIArray *aSrcMsgs, nsIMsgFolder *aDestFolder)</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+/* void notifyMsgsMoveCopyCompleted (in boolean aMove, in nsIArray aSrcMsgs,</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+                                     in nsIMsgFolder aDestFolder); */</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+NS_IMETHODIMP nsMsgFolderNotificationService::NotifyMsgsMoveCopyCompleted(</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+  PRBool aMove, nsIArray *aSrcMsgs, nsIMsgFolder *aDestFolder,</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+  nsIArray *aDestMsgs)</span>
<a href="#l14.35"></a><span id="l14.35"> {</span>
<a href="#l14.36"></a><span id="l14.36">   PRUint32 count = mListeners.Length();</span>
<a href="#l14.37"></a><span id="l14.37">   </span>
<a href="#l14.38"></a><span id="l14.38">   // IMAP delete model means that a &quot;move&quot; isn't really a move, it is a copy,</span>
<a href="#l14.39"></a><span id="l14.39">   // followed by storing the IMAP deleted flag on the message.</span>
<a href="#l14.40"></a><span id="l14.40">   PRBool isReallyMove = aMove;</span>
<a href="#l14.41"></a><span id="l14.41">   if (count &gt; 0 &amp;&amp; aMove)</span>
<a href="#l14.42"></a><span id="l14.42">   {</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineat">@@ -144,17 +156,17 @@ NS_IMETHODIMP nsMsgFolderNotificationSer</span>
<a href="#l14.44"></a><span id="l14.44">         imapServer-&gt;GetDeleteModel(&amp;deleteModel);</span>
<a href="#l14.45"></a><span id="l14.45">         if (deleteModel == nsMsgImapDeleteModels::IMAPDelete)</span>
<a href="#l14.46"></a><span id="l14.46">           isReallyMove = PR_FALSE;</span>
<a href="#l14.47"></a><span id="l14.47">       }</span>
<a href="#l14.48"></a><span id="l14.48">     }</span>
<a href="#l14.49"></a><span id="l14.49">   }</span>
<a href="#l14.50"></a><span id="l14.50"> </span>
<a href="#l14.51"></a><span id="l14.51">   NOTIFY_MSGFOLDER_LISTENERS(msgsMoveCopyCompleted, MsgsMoveCopyCompleted,</span>
<a href="#l14.52"></a><span id="l14.52" class="difflineminus">-                             (isReallyMove, aSrcMsgs, aDestFolder));</span>
<a href="#l14.53"></a><span id="l14.53" class="difflineplus">+                             (isReallyMove, aSrcMsgs, aDestFolder, aDestMsgs));</span>
<a href="#l14.54"></a><span id="l14.54">   return NS_OK;</span>
<a href="#l14.55"></a><span id="l14.55"> }</span>
<a href="#l14.56"></a><span id="l14.56"> </span>
<a href="#l14.57"></a><span id="l14.57"> /* void notifyFolderAdded(in nsIMsgFolder aFolder); */</span>
<a href="#l14.58"></a><span id="l14.58"> NS_IMETHODIMP nsMsgFolderNotificationService::NotifyFolderAdded(nsIMsgFolder *aFolder)</span>
<a href="#l14.59"></a><span id="l14.59"> {</span>
<a href="#l14.60"></a><span id="l14.60">   NOTIFY_MSGFOLDER_LISTENERS(folderAdded, FolderAdded, (aFolder));</span>
<a href="#l14.61"></a><span id="l14.61">   return NS_OK;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/mailnews/base/test/unit/test_nsIMsgFolderListener.js</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/mailnews/base/test/unit/test_nsIMsgFolderListener.js</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -13,159 +13,156 @@</span>
<a href="#l15.4"></a><span id="l15.4"> const mFNSContractID = &quot;@mozilla.org/messenger/msgnotificationservice;1&quot;;</span>
<a href="#l15.5"></a><span id="l15.5"> const nsIMFNService = Ci.nsIMsgFolderNotificationService;</span>
<a href="#l15.6"></a><span id="l15.6"> const nsIMFListener = Ci.nsIMsgFolderListener;</span>
<a href="#l15.7"></a><span id="l15.7"> </span>
<a href="#l15.8"></a><span id="l15.8"> </span>
<a href="#l15.9"></a><span id="l15.9"> const gIndividualFlags =</span>
<a href="#l15.10"></a><span id="l15.10"> [</span>
<a href="#l15.11"></a><span id="l15.11">   nsIMFNService.msgAdded,</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+  nsIMFNService.msgsClassified,</span>
<a href="#l15.13"></a><span id="l15.13">   nsIMFNService.msgsDeleted,</span>
<a href="#l15.14"></a><span id="l15.14">   nsIMFNService.msgsMoveCopyCompleted,</span>
<a href="#l15.15"></a><span id="l15.15">   nsIMFNService.folderAdded,</span>
<a href="#l15.16"></a><span id="l15.16">   nsIMFNService.folderDeleted,</span>
<a href="#l15.17"></a><span id="l15.17">   nsIMFNService.folderMoveCopyCompleted,</span>
<a href="#l15.18"></a><span id="l15.18">   nsIMFNService.folderRenamed,</span>
<a href="#l15.19"></a><span id="l15.19">   nsIMFNService.itemEvent,</span>
<a href="#l15.20"></a><span id="l15.20"> ];</span>
<a href="#l15.21"></a><span id="l15.21"> </span>
<a href="#l15.22"></a><span id="l15.22" class="difflineminus">-const gCollectiveFlags =</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineminus">-[</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineminus">-  nsIMFNService.allMsgNotifications,</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineminus">-  nsIMFNService.allFolderNotifications,</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineminus">-];</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineminus">-</span>
<a href="#l15.28"></a><span id="l15.28"> var gMFNService = Cc[mFNSContractID].getService(nsIMFNService);</span>
<a href="#l15.29"></a><span id="l15.29"> </span>
<a href="#l15.30"></a><span id="l15.30"> // Our listener, which captures events.</span>
<a href="#l15.31"></a><span id="l15.31"> function gMFListener() {}</span>
<a href="#l15.32"></a><span id="l15.32"> gMFListener.prototype =</span>
<a href="#l15.33"></a><span id="l15.33"> {</span>
<a href="#l15.34"></a><span id="l15.34">   mReceived: 0,</span>
<a href="#l15.35"></a><span id="l15.35">   mRemoveSelf: false,</span>
<a href="#l15.36"></a><span id="l15.36"> </span>
<a href="#l15.37"></a><span id="l15.37">   msgAdded: function (aMsg)</span>
<a href="#l15.38"></a><span id="l15.38">   {</span>
<a href="#l15.39"></a><span id="l15.39">     do_check_eq(this.mReceived &amp; nsIMFNService.msgAdded, 0);</span>
<a href="#l15.40"></a><span id="l15.40">     this.mReceived |= nsIMFNService.msgAdded;</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+  },</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineplus">+</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+  msgsClassified: function (aMsgs, aJunkProcessed, aTraitProcessed)</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+  {</span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+    do_check_eq(this.mReceived &amp; nsIMFNService.msgsClassified, 0);</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineplus">+    this.mReceived |= nsIMFNService.msgsClassified;</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.52"></a><span id="l15.52">   },</span>
<a href="#l15.53"></a><span id="l15.53"> </span>
<a href="#l15.54"></a><span id="l15.54">   msgsDeleted: function (aMsgs)</span>
<a href="#l15.55"></a><span id="l15.55">   {</span>
<a href="#l15.56"></a><span id="l15.56">     do_check_eq(this.mReceived &amp; nsIMFNService.msgsDeleted, 0);</span>
<a href="#l15.57"></a><span id="l15.57">     this.mReceived |= nsIMFNService.msgsDeleted;</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.60"></a><span id="l15.60" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.61"></a><span id="l15.61">   },</span>
<a href="#l15.62"></a><span id="l15.62"> </span>
<a href="#l15.63"></a><span id="l15.63" class="difflineminus">-  msgsMoveCopyCompleted: function (aMove, aSrcMsgs, aDestFolder)</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+  msgsMoveCopyCompleted: function (aMove, aSrcMsgs, aDestFolder, aDestMsgs)</span>
<a href="#l15.65"></a><span id="l15.65">   {</span>
<a href="#l15.66"></a><span id="l15.66">     do_check_eq(this.mReceived &amp; nsIMFNService.msgsMoveCopyCompleted, 0);</span>
<a href="#l15.67"></a><span id="l15.67">     this.mReceived |= nsIMFNService.msgsMoveCopyCompleted;</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.71"></a><span id="l15.71">   },</span>
<a href="#l15.72"></a><span id="l15.72">   </span>
<a href="#l15.73"></a><span id="l15.73">   folderAdded: function (aFolder)</span>
<a href="#l15.74"></a><span id="l15.74">   {</span>
<a href="#l15.75"></a><span id="l15.75">     do_check_eq(this.mReceived &amp; nsIMFNService.folderAdded, 0);</span>
<a href="#l15.76"></a><span id="l15.76">     this.mReceived |= nsIMFNService.folderAdded;</span>
<a href="#l15.77"></a><span id="l15.77" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.78"></a><span id="l15.78" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.79"></a><span id="l15.79" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.80"></a><span id="l15.80">   },</span>
<a href="#l15.81"></a><span id="l15.81"> </span>
<a href="#l15.82"></a><span id="l15.82">   folderDeleted: function (aFolder)</span>
<a href="#l15.83"></a><span id="l15.83">   {</span>
<a href="#l15.84"></a><span id="l15.84">     do_check_eq(this.mReceived &amp; nsIMFNService.folderDeleted, 0);</span>
<a href="#l15.85"></a><span id="l15.85">     this.mReceived |= nsIMFNService.folderDeleted;</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.87"></a><span id="l15.87" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.88"></a><span id="l15.88" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.89"></a><span id="l15.89">   },</span>
<a href="#l15.90"></a><span id="l15.90"> </span>
<a href="#l15.91"></a><span id="l15.91">   folderMoveCopyCompleted: function (aMove, aSrcFolder, aDestFolder)</span>
<a href="#l15.92"></a><span id="l15.92">   {</span>
<a href="#l15.93"></a><span id="l15.93">     do_check_eq(this.mReceived &amp; nsIMFNService.folderMoveCopyCompleted, 0);</span>
<a href="#l15.94"></a><span id="l15.94">     this.mReceived |= nsIMFNService.folderMoveCopyCompleted;</span>
<a href="#l15.95"></a><span id="l15.95" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.98"></a><span id="l15.98">   },</span>
<a href="#l15.99"></a><span id="l15.99"> </span>
<a href="#l15.100"></a><span id="l15.100">   folderRenamed: function (aOrigFolder, aNewFolder)</span>
<a href="#l15.101"></a><span id="l15.101">   {</span>
<a href="#l15.102"></a><span id="l15.102">     do_check_eq(this.mReceived &amp; nsIMFNService.folderRenamed, 0);</span>
<a href="#l15.103"></a><span id="l15.103">     this.mReceived |= nsIMFNService.folderRenamed;</span>
<a href="#l15.104"></a><span id="l15.104" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.105"></a><span id="l15.105" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.106"></a><span id="l15.106" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.107"></a><span id="l15.107">   },</span>
<a href="#l15.108"></a><span id="l15.108"> </span>
<a href="#l15.109"></a><span id="l15.109">   itemEvent: function (aItem, aEvent, aData)</span>
<a href="#l15.110"></a><span id="l15.110">   {</span>
<a href="#l15.111"></a><span id="l15.111">     do_check_eq(this.mReceived &amp; nsIMFNService.itemEvent, 0);</span>
<a href="#l15.112"></a><span id="l15.112">     this.mReceived |= nsIMFNService.itemEvent;</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineminus">-    if (this.mRemoveSelf) gMFNService.removeListener(this);</span>
<a href="#l15.114"></a><span id="l15.114" class="difflineplus">+    if (this.mRemoveSelf)</span>
<a href="#l15.115"></a><span id="l15.115" class="difflineplus">+      gMFNService.removeListener(this);</span>
<a href="#l15.116"></a><span id="l15.116">   }</span>
<a href="#l15.117"></a><span id="l15.117"> };</span>
<a href="#l15.118"></a><span id="l15.118"> </span>
<a href="#l15.119"></a><span id="l15.119"> function NotifyMsgFolderListeners()</span>
<a href="#l15.120"></a><span id="l15.120"> {</span>
<a href="#l15.121"></a><span id="l15.121">   gMFNService.notifyMsgAdded(null);</span>
<a href="#l15.122"></a><span id="l15.122" class="difflineplus">+  gMFNService.notifyMsgsClassified(null, null, null);</span>
<a href="#l15.123"></a><span id="l15.123">   gMFNService.notifyMsgsDeleted(null);</span>
<a href="#l15.124"></a><span id="l15.124" class="difflineminus">-  gMFNService.notifyMsgsMoveCopyCompleted(null, null, null);</span>
<a href="#l15.125"></a><span id="l15.125" class="difflineplus">+  gMFNService.notifyMsgsMoveCopyCompleted(null, null, null, null);</span>
<a href="#l15.126"></a><span id="l15.126">   gMFNService.notifyFolderAdded(null);</span>
<a href="#l15.127"></a><span id="l15.127">   gMFNService.notifyFolderDeleted(null);</span>
<a href="#l15.128"></a><span id="l15.128">   gMFNService.notifyFolderMoveCopyCompleted(null, null, null);</span>
<a href="#l15.129"></a><span id="l15.129">   gMFNService.notifyFolderRenamed(null, null);</span>
<a href="#l15.130"></a><span id="l15.130">   gMFNService.notifyItemEvent(null, null, null);</span>
<a href="#l15.131"></a><span id="l15.131"> }</span>
<a href="#l15.132"></a><span id="l15.132"> </span>
<a href="#l15.133"></a><span id="l15.133"> function run_test()</span>
<a href="#l15.134"></a><span id="l15.134"> {</span>
<a href="#l15.135"></a><span id="l15.135" class="difflineminus">-  // Test: Add listeners (all and single).</span>
<a href="#l15.136"></a><span id="l15.136" class="difflineminus">-  var allListener = new gMFListener();</span>
<a href="#l15.137"></a><span id="l15.137" class="difflineminus">-  gMFNService.addListener(allListener, nsIMFNService.all);</span>
<a href="#l15.138"></a><span id="l15.138" class="difflineminus">-</span>
<a href="#l15.139"></a><span id="l15.139" class="difflineminus">-  var allReceived = 0;</span>
<a href="#l15.140"></a><span id="l15.140" class="difflineminus">-</span>
<a href="#l15.141"></a><span id="l15.141" class="difflineminus">-  gIndividualFlags.forEach(function (flag) { allReceived |= flag; });</span>
<a href="#l15.142"></a><span id="l15.142" class="difflineminus">-</span>
<a href="#l15.143"></a><span id="l15.143" class="difflineplus">+  // Test: Add listeners</span>
<a href="#l15.144"></a><span id="l15.144">   var singleListeners = [];</span>
<a href="#l15.145"></a><span id="l15.145"> </span>
<a href="#l15.146"></a><span id="l15.146">   var addAListener = function (flag) {</span>
<a href="#l15.147"></a><span id="l15.147">     var listener = new gMFListener();</span>
<a href="#l15.148"></a><span id="l15.148">     gMFNService.addListener(listener, flag);</span>
<a href="#l15.149"></a><span id="l15.149">     singleListeners.push(listener);</span>
<a href="#l15.150"></a><span id="l15.150">   };</span>
<a href="#l15.151"></a><span id="l15.151"> </span>
<a href="#l15.152"></a><span id="l15.152">   gIndividualFlags.forEach(addAListener);</span>
<a href="#l15.153"></a><span id="l15.153" class="difflineminus">-  gCollectiveFlags.forEach(addAListener);</span>
<a href="#l15.154"></a><span id="l15.154"> </span>
<a href="#l15.155"></a><span id="l15.155">   // Test: Notify the listeners of all events.</span>
<a href="#l15.156"></a><span id="l15.156">   NotifyMsgFolderListeners();</span>
<a href="#l15.157"></a><span id="l15.157"> </span>
<a href="#l15.158"></a><span id="l15.158">   // Test: check whether the correct number of notifications have been received.</span>
<a href="#l15.159"></a><span id="l15.159">   // Then remove the listeners</span>
<a href="#l15.160"></a><span id="l15.160" class="difflineminus">-  do_check_eq(allListener.mReceived, allReceived);</span>
<a href="#l15.161"></a><span id="l15.161" class="difflineminus">-  gMFNService.removeListener(allListener);</span>
<a href="#l15.162"></a><span id="l15.162" class="difflineminus">-</span>
<a href="#l15.163"></a><span id="l15.163">   var checkFlag = function (flag) {</span>
<a href="#l15.164"></a><span id="l15.164">     var listener = singleListeners.shift();</span>
<a href="#l15.165"></a><span id="l15.165">     do_check_eq(listener.mReceived, flag);</span>
<a href="#l15.166"></a><span id="l15.166">     listener.mRemoveSelf = true;</span>
<a href="#l15.167"></a><span id="l15.167">     listener.mReceived = 0;</span>
<a href="#l15.168"></a><span id="l15.168">     singleListeners.push(listener);</span>
<a href="#l15.169"></a><span id="l15.169">   };</span>
<a href="#l15.170"></a><span id="l15.170">   gIndividualFlags.forEach(checkFlag);</span>
<a href="#l15.171"></a><span id="l15.171" class="difflineminus">-  gCollectiveFlags.forEach(checkFlag);</span>
<a href="#l15.172"></a><span id="l15.172"> </span>
<a href="#l15.173"></a><span id="l15.173">   // We'll do one more set of notifications, and remove ourselves in the middle of them</span>
<a href="#l15.174"></a><span id="l15.174">   NotifyMsgFolderListeners();</span>
<a href="#l15.175"></a><span id="l15.175"> </span>
<a href="#l15.176"></a><span id="l15.176">   // Test: all listeners should be removed at this point</span>
<a href="#l15.177"></a><span id="l15.177">   do_check_false(gMFNService.hasListeners);</span>
<a href="#l15.178"></a><span id="l15.178"> </span>
<a href="#l15.179"></a><span id="l15.179">   // Test: Send notifications again. Check that we don't receive any notifications.</span>
<a href="#l15.180"></a><span id="l15.180" class="difflineminus">-  allListener.mReceived = 0;</span>
<a href="#l15.181"></a><span id="l15.181">   singleListeners.forEach(function (listener) { listener.mReceived = 0; });</span>
<a href="#l15.182"></a><span id="l15.182"> </span>
<a href="#l15.183"></a><span id="l15.183">   NotifyMsgFolderListeners();</span>
<a href="#l15.184"></a><span id="l15.184" class="difflineminus">-  do_check_eq(allListener.mReceived, 0);</span>
<a href="#l15.185"></a><span id="l15.185"> </span>
<a href="#l15.186"></a><span id="l15.186">   var checkNotReceived = function() {</span>
<a href="#l15.187"></a><span id="l15.187">     do_check_eq(singleListeners.shift().mReceived, 0);</span>
<a href="#l15.188"></a><span id="l15.188">   }</span>
<a href="#l15.189"></a><span id="l15.189">   gIndividualFlags.forEach(checkNotReceived);</span>
<a href="#l15.190"></a><span id="l15.190" class="difflineminus">-  gCollectiveFlags.forEach(checkNotReceived);</span>
<a href="#l15.191"></a><span id="l15.191"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/mailnews/base/test/unit/test_nsIMsgFolderListenerLocal.js</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -35,34 +35,44 @@ function addFolder(parent, folderName, s</span>
<a href="#l16.4"></a><span id="l16.4">   // We won't receive a copy listener notification for this</span>
<a href="#l16.5"></a><span id="l16.5">   gCurrStatus |= kStatus.onStopCopyDone;</span>
<a href="#l16.6"></a><span id="l16.6">   parent.createSubfolder(folderName, null);</span>
<a href="#l16.7"></a><span id="l16.7">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l16.8"></a><span id="l16.8">   if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l16.9"></a><span id="l16.9">     resetStatusAndProceed();</span>
<a href="#l16.10"></a><span id="l16.10"> }</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+/**</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+ * This will introduce a new message to the system which will generate an added</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+ * notification and subsequently a classification notification.  For the</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+ * classification because no messages have yet been marked as junk and there</span>
<a href="#l16.16"></a><span id="l16.16" class="difflineplus">+ * are no traits configured, aJunkProcessed and aTraitProcessed will be false.</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineplus">+ */</span>
<a href="#l16.18"></a><span id="l16.18"> function copyFileMessage(file, destFolder, isDraftOrTemplate)</span>
<a href="#l16.19"></a><span id="l16.19"> {</span>
<a href="#l16.20"></a><span id="l16.20">   copyListener.mFolderStoredIn = destFolder;</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineminus">-  gExpectedEvents = [[gMFNService.msgAdded, gHdrsReceived]];</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineminus">-  gCopyService.CopyFileMessage(file, destFolder, null, isDraftOrTemplate, 0, &quot;&quot;, copyListener, null);</span>
<a href="#l16.23"></a><span id="l16.23" class="difflineplus">+  gExpectedEvents = [[gMFNService.msgAdded, gHdrsReceived],</span>
<a href="#l16.24"></a><span id="l16.24" class="difflineplus">+                     [gMFNService.msgsClassified, gHdrsReceived, false, false]];</span>
<a href="#l16.25"></a><span id="l16.25" class="difflineplus">+  gCopyService.CopyFileMessage(file, destFolder, null, isDraftOrTemplate, 0, &quot;&quot;,</span>
<a href="#l16.26"></a><span id="l16.26" class="difflineplus">+                               copyListener, null);</span>
<a href="#l16.27"></a><span id="l16.27">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l16.28"></a><span id="l16.28">   if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l16.29"></a><span id="l16.29">     resetStatusAndProceed();</span>
<a href="#l16.30"></a><span id="l16.30"> }</span>
<a href="#l16.31"></a><span id="l16.31"> </span>
<a href="#l16.32"></a><span id="l16.32"> function copyMessages(items, isMove, srcFolder, destFolder)</span>
<a href="#l16.33"></a><span id="l16.33"> {</span>
<a href="#l16.34"></a><span id="l16.34">   var array = Cc[&quot;@mozilla.org/array;1&quot;].createInstance(Ci.nsIMutableArray);</span>
<a href="#l16.35"></a><span id="l16.35">   items.forEach(function (item) {</span>
<a href="#l16.36"></a><span id="l16.36">     array.appendElement(item, false);</span>
<a href="#l16.37"></a><span id="l16.37">   });</span>
<a href="#l16.38"></a><span id="l16.38" class="difflineminus">-  gExpectedEvents = [[gMFNService.msgsMoveCopyCompleted, isMove, items, destFolder]];</span>
<a href="#l16.39"></a><span id="l16.39" class="difflineminus">-  gCopyService.CopyMessages(srcFolder, array, destFolder, isMove, copyListener, null, true);</span>
<a href="#l16.40"></a><span id="l16.40" class="difflineplus">+  gExpectedEvents = [</span>
<a href="#l16.41"></a><span id="l16.41" class="difflineplus">+    [gMFNService.msgsMoveCopyCompleted, isMove, items, destFolder, true]];</span>
<a href="#l16.42"></a><span id="l16.42" class="difflineplus">+  gCopyService.CopyMessages(srcFolder, array, destFolder, isMove, copyListener,</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineplus">+                            null, true);</span>
<a href="#l16.44"></a><span id="l16.44">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l16.45"></a><span id="l16.45">   if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l16.46"></a><span id="l16.46">     resetStatusAndProceed();</span>
<a href="#l16.47"></a><span id="l16.47"> }</span>
<a href="#l16.48"></a><span id="l16.48"> </span>
<a href="#l16.49"></a><span id="l16.49"> function copyFolders(items, isMove, destFolder)</span>
<a href="#l16.50"></a><span id="l16.50"> {</span>
<a href="#l16.51"></a><span id="l16.51">   var array = Cc[&quot;@mozilla.org/array;1&quot;].createInstance(Ci.nsIMutableArray);</span>
<a href="#l16.52"></a><span id="l16.52" class="difflineat">@@ -88,17 +98,18 @@ function deleteMessages(srcFolder, items</span>
<a href="#l16.53"></a><span id="l16.53">   if (!isMove &amp;&amp; (deleteStorage || isTrashFolder))</span>
<a href="#l16.54"></a><span id="l16.54">   {</span>
<a href="#l16.55"></a><span id="l16.55">     // We won't be getting any OnStopCopy notification in this case</span>
<a href="#l16.56"></a><span id="l16.56">     gCurrStatus = kStatus.onStopCopyDone;</span>
<a href="#l16.57"></a><span id="l16.57">     gExpectedEvents = [[gMFNService.msgsDeleted, items]];</span>
<a href="#l16.58"></a><span id="l16.58">   }</span>
<a href="#l16.59"></a><span id="l16.59">   else</span>
<a href="#l16.60"></a><span id="l16.60">     // We have to be getting a move notification, even if isMove is false</span>
<a href="#l16.61"></a><span id="l16.61" class="difflineminus">-    gExpectedEvents = [[gMFNService.msgsMoveCopyCompleted, true, items, gLocalTrashFolder]];</span>
<a href="#l16.62"></a><span id="l16.62" class="difflineplus">+    gExpectedEvents = [[gMFNService.msgsMoveCopyCompleted, true, items,</span>
<a href="#l16.63"></a><span id="l16.63" class="difflineplus">+                        gLocalTrashFolder, true]];</span>
<a href="#l16.64"></a><span id="l16.64"> </span>
<a href="#l16.65"></a><span id="l16.65">   srcFolder.deleteMessages(array, null, deleteStorage, isMove, copyListener, true);</span>
<a href="#l16.66"></a><span id="l16.66">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l16.67"></a><span id="l16.67">   if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l16.68"></a><span id="l16.68">     resetStatusAndProceed();</span>
<a href="#l16.69"></a><span id="l16.69"> }</span>
<a href="#l16.70"></a><span id="l16.70"> </span>
<a href="#l16.71"></a><span id="l16.71"> function renameFolder(folder, newName)</span>
<a href="#l16.72"></a><span id="l16.72" class="difflineat">@@ -131,16 +142,28 @@ function deleteFolder(folder, child)</span>
<a href="#l16.73"></a><span id="l16.73">     gExpectedEvents = [[gMFNService.folderMoveCopyCompleted, true, [folder], gLocalTrashFolder]];</span>
<a href="#l16.74"></a><span id="l16.74"> </span>
<a href="#l16.75"></a><span id="l16.75">   folder.parent.deleteSubFolders(array, null);</span>
<a href="#l16.76"></a><span id="l16.76">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l16.77"></a><span id="l16.77">   if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l16.78"></a><span id="l16.78">     resetStatusAndProceed();</span>
<a href="#l16.79"></a><span id="l16.79"> }</span>
<a href="#l16.80"></a><span id="l16.80"> </span>
<a href="#l16.81"></a><span id="l16.81" class="difflineplus">+function compactFolder(folder)</span>
<a href="#l16.82"></a><span id="l16.82" class="difflineplus">+{</span>
<a href="#l16.83"></a><span id="l16.83" class="difflineplus">+  gExpectedEvents = [[gMFNService.itemEvent, folder, &quot;FolderCompactStart&quot;],</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineplus">+                     [gMFNService.itemEvent, folder, &quot;FolderCompactFinish&quot;]];</span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+  // We won't receive a copy listener notification for this</span>
<a href="#l16.86"></a><span id="l16.86" class="difflineplus">+  gCurrStatus |= kStatus.onStopCopyDone;</span>
<a href="#l16.87"></a><span id="l16.87" class="difflineplus">+  folder.compact(null, null);</span>
<a href="#l16.88"></a><span id="l16.88" class="difflineplus">+  gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l16.89"></a><span id="l16.89" class="difflineplus">+  if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l16.90"></a><span id="l16.90" class="difflineplus">+    resetStatusAndProceed();</span>
<a href="#l16.91"></a><span id="l16.91" class="difflineplus">+}</span>
<a href="#l16.92"></a><span id="l16.92" class="difflineplus">+</span>
<a href="#l16.93"></a><span id="l16.93"> /*</span>
<a href="#l16.94"></a><span id="l16.94">  * TESTS</span>
<a href="#l16.95"></a><span id="l16.95">  */</span>
<a href="#l16.96"></a><span id="l16.96"> </span>
<a href="#l16.97"></a><span id="l16.97"> // Beware before commenting out a test -- later tests might just depend on earlier ones</span>
<a href="#l16.98"></a><span id="l16.98"> const gTestArray =</span>
<a href="#l16.99"></a><span id="l16.99"> [</span>
<a href="#l16.100"></a><span id="l16.100">   // Adding folders</span>
<a href="#l16.101"></a><span id="l16.101" class="difflineat">@@ -237,26 +260,29 @@ const gTestArray =</span>
<a href="#l16.102"></a><span id="l16.102">   // Inbox</span>
<a href="#l16.103"></a><span id="l16.103">   // Trash</span>
<a href="#l16.104"></a><span id="l16.104">   // -folder2</span>
<a href="#l16.105"></a><span id="l16.105">   // --folder3</span>
<a href="#l16.106"></a><span id="l16.106">   function deleteFolder4() {</span>
<a href="#l16.107"></a><span id="l16.107">     // Let's take a moment to re-initialize stuff that got moved</span>
<a href="#l16.108"></a><span id="l16.108">     gLocalFolder2 = gLocalTrashFolder.getChildNamed(&quot;folder2&quot;);</span>
<a href="#l16.109"></a><span id="l16.109">     gLocalFolder3 = gLocalFolder2.getChildNamed(&quot;folder3&quot;);</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineminus">-    deleteFolder(gLocalFolder2, gLocalFolder3); }</span>
<a href="#l16.111"></a><span id="l16.111" class="difflineplus">+    deleteFolder(gLocalFolder2, gLocalFolder3); },</span>
<a href="#l16.112"></a><span id="l16.112" class="difflineplus">+  function compactInbox() {</span>
<a href="#l16.113"></a><span id="l16.113" class="difflineplus">+    compactFolder(gLocalInboxFolder);</span>
<a href="#l16.114"></a><span id="l16.114" class="difflineplus">+  }</span>
<a href="#l16.115"></a><span id="l16.115"> ];</span>
<a href="#l16.116"></a><span id="l16.116">   // Folder structure should just be</span>
<a href="#l16.117"></a><span id="l16.117">   // Inbox</span>
<a href="#l16.118"></a><span id="l16.118">   // Trash</span>
<a href="#l16.119"></a><span id="l16.119"> </span>
<a href="#l16.120"></a><span id="l16.120"> function run_test()</span>
<a href="#l16.121"></a><span id="l16.121"> {</span>
<a href="#l16.122"></a><span id="l16.122">   // Add a listener.</span>
<a href="#l16.123"></a><span id="l16.123" class="difflineminus">-  gMFNService.addListener(gMFListener, gMFNService.all);</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineplus">+  gMFNService.addListener(gMFListener, allTestedEvents);</span>
<a href="#l16.125"></a><span id="l16.125"> </span>
<a href="#l16.126"></a><span id="l16.126">   loadLocalMailAccount();</span>
<a href="#l16.127"></a><span id="l16.127"> </span>
<a href="#l16.128"></a><span id="l16.128">   // Load up some messages so that we can copy them in later.</span>
<a href="#l16.129"></a><span id="l16.129">   gMsgFile1 = do_get_file(&quot;../../mailnews/data/bugmail10&quot;);</span>
<a href="#l16.130"></a><span id="l16.130">   gMsgFile2 = do_get_file(&quot;../../mailnews/data/bugmail11&quot;);</span>
<a href="#l16.131"></a><span id="l16.131">   gMsgFile3 = do_get_file(&quot;../../mailnews/data/draft1&quot;);</span>
<a href="#l16.132"></a><span id="l16.132"> </span>
<a href="#l16.133"></a><span id="l16.133" class="difflineat">@@ -274,16 +300,17 @@ function run_test()</span>
<a href="#l16.134"></a><span id="l16.134"> function doTest(test)</span>
<a href="#l16.135"></a><span id="l16.135"> {</span>
<a href="#l16.136"></a><span id="l16.136">   if (test &lt;= gTestArray.length)</span>
<a href="#l16.137"></a><span id="l16.137">   {</span>
<a href="#l16.138"></a><span id="l16.138">     var testFn = gTestArray[test-1];</span>
<a href="#l16.139"></a><span id="l16.139">     // Set a limit of three seconds; if the notifications haven't arrived by then there's a problem.</span>
<a href="#l16.140"></a><span id="l16.140">     do_timeout(10000, &quot;if (gTest == &quot;+test+&quot;) \</span>
<a href="#l16.141"></a><span id="l16.141">       do_throw('Notifications not received in 10000 ms for operation &quot;+testFn.name+&quot;, current status is '+gCurrStatus);&quot;);</span>
<a href="#l16.142"></a><span id="l16.142" class="difflineplus">+    dump(&quot;=== Test: &quot; + testFn.name + &quot;\n&quot;);</span>
<a href="#l16.143"></a><span id="l16.143">     testFn();</span>
<a href="#l16.144"></a><span id="l16.144">   }</span>
<a href="#l16.145"></a><span id="l16.145">   else</span>
<a href="#l16.146"></a><span id="l16.146">   {</span>
<a href="#l16.147"></a><span id="l16.147">     gHdrsReceived = null;</span>
<a href="#l16.148"></a><span id="l16.148">     gMsgHdrs = null;</span>
<a href="#l16.149"></a><span id="l16.149">     gMFNService.removeListener(gMFListener);</span>
<a href="#l16.150"></a><span id="l16.150">     do_test_finished(); // for the one in run_test()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/mailnews/base/test/unit/test_nsMsgDBView.js</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/mailnews/base/test/unit/test_nsMsgDBView.js</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -1,32 +1,33 @@</span>
<a href="#l17.4"></a><span id="l17.4"> /*</span>
<a href="#l17.5"></a><span id="l17.5">  * Attempt to test nsMsgDBView and descendents.  Right now this means we:</span>
<a href="#l17.6"></a><span id="l17.6">  * - Ensure sorting and grouping sorta works, including using custom columns.</span>
<a href="#l17.7"></a><span id="l17.7">  *</span>
<a href="#l17.8"></a><span id="l17.8">  * Things we really should do:</span>
<a href="#l17.9"></a><span id="l17.9">  * - Test that secondary sorting works, especially when the primary column is</span>
<a href="#l17.10"></a><span id="l17.10">  *   a custom column.</span>
<a href="#l17.11"></a><span id="l17.11" class="difflineplus">+ *</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineplus">+ * You may also want to look into the test_viewWrapper_*.js tests as well.</span>
<a href="#l17.13"></a><span id="l17.13">  */</span>
<a href="#l17.14"></a><span id="l17.14"> </span>
<a href="#l17.15"></a><span id="l17.15" class="difflineminus">-// this will be migrated out of gloda soon...</span>
<a href="#l17.16"></a><span id="l17.16" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l17.17"></a><span id="l17.17" class="difflineplus">+load(&quot;../../mailnews/resources/logHelper.js&quot;);</span>
<a href="#l17.18"></a><span id="l17.18"> load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l17.19"></a><span id="l17.19"> </span>
<a href="#l17.20"></a><span id="l17.20" class="difflineminus">-var gMessageGenerator;</span>
<a href="#l17.21"></a><span id="l17.21" class="difflineminus">-var gScenarioFactory;</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineplus">+load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l17.23"></a><span id="l17.23" class="difflineplus">+load(&quot;../../mailnews/resources/messageModifier.js&quot;);</span>
<a href="#l17.24"></a><span id="l17.24" class="difflineplus">+load(&quot;../../mailnews/resources/messageInjection.js&quot;);</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineplus">+</span>
<a href="#l17.26"></a><span id="l17.26" class="difflineplus">+var gMessageGenerator = new MessageGenerator();</span>
<a href="#l17.27"></a><span id="l17.27" class="difflineplus">+var gScenarioFactory = new MessageScenarioFactory(gMessageGenerator);</span>
<a href="#l17.28"></a><span id="l17.28"> </span>
<a href="#l17.29"></a><span id="l17.29"> var gTestFolder;</span>
<a href="#l17.30"></a><span id="l17.30"> var gSiblingsMissingParentsSubject;</span>
<a href="#l17.31"></a><span id="l17.31"> </span>
<a href="#l17.32"></a><span id="l17.32"> function setup_globals(aNextFunc) {</span>
<a href="#l17.33"></a><span id="l17.33" class="difflineminus">-  loadLocalMailAccount();</span>
<a href="#l17.34"></a><span id="l17.34" class="difflineminus">-  gMessageGenerator = new MessageGenerator();</span>
<a href="#l17.35"></a><span id="l17.35" class="difflineminus">-  gScenarioFactory = new MessageScenarioFactory(gMessageGenerator);</span>
<a href="#l17.36"></a><span id="l17.36" class="difflineminus">-</span>
<a href="#l17.37"></a><span id="l17.37">   // build up a diverse list of messages</span>
<a href="#l17.38"></a><span id="l17.38">   let messages = [];</span>
<a href="#l17.39"></a><span id="l17.39">   messages = messages.concat(gScenarioFactory.directReply(10));</span>
<a href="#l17.40"></a><span id="l17.40">   // the message generator uses a constanty incrementing counter, so we need to</span>
<a href="#l17.41"></a><span id="l17.41">   //  mix up the order of messages ourselves to ensure that the timestamp</span>
<a href="#l17.42"></a><span id="l17.42">   //  ordering is not already in order.  (a poor test of sorting otherwise.)</span>
<a href="#l17.43"></a><span id="l17.43">   messages = gScenarioFactory.directReply(6).concat(messages);</span>
<a href="#l17.44"></a><span id="l17.44"> </span>
<a href="#l17.45"></a><span id="l17.45" class="difflineat">@@ -44,23 +45,20 @@ function setup_globals(aNextFunc) {</span>
<a href="#l17.46"></a><span id="l17.46">   //    2</span>
<a href="#l17.47"></a><span id="l17.47">   //     4</span>
<a href="#l17.48"></a><span id="l17.48">   //    3</span>
<a href="#l17.49"></a><span id="l17.49">   let msg1 = gMessageGenerator.makeMessage();</span>
<a href="#l17.50"></a><span id="l17.50">   let msg2 = gMessageGenerator.makeMessage({inReplyTo: msg1});</span>
<a href="#l17.51"></a><span id="l17.51">   let msg3 = gMessageGenerator.makeMessage({inReplyTo: msg1});</span>
<a href="#l17.52"></a><span id="l17.52">   let msg4 = gMessageGenerator.makeMessage({inReplyTo: msg2});</span>
<a href="#l17.53"></a><span id="l17.53">   messages = messages.concat([msg1, msg2, msg3, msg4]);</span>
<a href="#l17.54"></a><span id="l17.54" class="difflineplus">+  let msgSet = new SyntheticMessageSet(messages);</span>
<a href="#l17.55"></a><span id="l17.55"> </span>
<a href="#l17.56"></a><span id="l17.56" class="difflineminus">-  let mboxName = &quot;dbviewy&quot;;</span>
<a href="#l17.57"></a><span id="l17.57" class="difflineminus">-  writeMessagesToMbox(messages, gProfileDir,</span>
<a href="#l17.58"></a><span id="l17.58" class="difflineminus">-                      &quot;Mail&quot;, &quot;Local Folders&quot;, mboxName);</span>
<a href="#l17.59"></a><span id="l17.59" class="difflineminus">-  gTestFolder = gLocalIncomingServer.rootMsgFolder.addSubfolder(mboxName);</span>
<a href="#l17.60"></a><span id="l17.60" class="difflineminus">-  updateFolderAndNotify(gTestFolder, async_driver);</span>
<a href="#l17.61"></a><span id="l17.61" class="difflineminus">-  return false;</span>
<a href="#l17.62"></a><span id="l17.62" class="difflineplus">+  gTestFolder = make_empty_folder();</span>
<a href="#l17.63"></a><span id="l17.63" class="difflineplus">+  return add_sets_to_folders(gTestFolder, [msgSet]);</span>
<a href="#l17.64"></a><span id="l17.64"> }</span>
<a href="#l17.65"></a><span id="l17.65"> </span>
<a href="#l17.66"></a><span id="l17.66"> var gCommandUpdater = {</span>
<a href="#l17.67"></a><span id="l17.67">   updateCommandStatus : function()</span>
<a href="#l17.68"></a><span id="l17.68">   {</span>
<a href="#l17.69"></a><span id="l17.69">     // the back end is smart and is only telling us to update command status</span>
<a href="#l17.70"></a><span id="l17.70">     // when the # of items in the selection has actually changed.</span>
<a href="#l17.71"></a><span id="l17.71">   },</span>
<a href="#l17.72"></a><span id="l17.72" class="difflineat">@@ -70,39 +68,31 @@ var gCommandUpdater = {</span>
<a href="#l17.73"></a><span id="l17.73">   },</span>
<a href="#l17.74"></a><span id="l17.74"> </span>
<a href="#l17.75"></a><span id="l17.75">   updateNextMessageAfterDelete : function()</span>
<a href="#l17.76"></a><span id="l17.76">   {</span>
<a href="#l17.77"></a><span id="l17.77">   },</span>
<a href="#l17.78"></a><span id="l17.78">   summarizeSelection : function() {return false;}</span>
<a href="#l17.79"></a><span id="l17.79"> };</span>
<a href="#l17.80"></a><span id="l17.80"> </span>
<a href="#l17.81"></a><span id="l17.81" class="difflineminus">-var gNextUniqueFolderId = 0;</span>
<a href="#l17.82"></a><span id="l17.82" class="difflineminus">-function make_empty_folder() {</span>
<a href="#l17.83"></a><span id="l17.83" class="difflineminus">-  let name = &quot;gabba&quot; + gNextUniqueFolderId++;</span>
<a href="#l17.84"></a><span id="l17.84" class="difflineminus">-  let testFolder = gLocalIncomingServer.rootMsgFolder.addSubfolder(name);</span>
<a href="#l17.85"></a><span id="l17.85" class="difflineminus">-  return testFolder;</span>
<a href="#l17.86"></a><span id="l17.86" class="difflineminus">-}</span>
<a href="#l17.87"></a><span id="l17.87" class="difflineminus">-</span>
<a href="#l17.88"></a><span id="l17.88"> /**</span>
<a href="#l17.89"></a><span id="l17.89">  * Create a synthetic message by passing the provided aMessageArgs to</span>
<a href="#l17.90"></a><span id="l17.90">  *  the message generator, then add the resulting message to the given</span>
<a href="#l17.91"></a><span id="l17.91">  *  folder (or gTestFolder if no folder is provided).</span>
<a href="#l17.92"></a><span id="l17.92" class="difflineplus">+ *</span>
<a href="#l17.93"></a><span id="l17.93" class="difflineplus">+ * @TODO change callers to use more generic messageInjection mechanisms.</span>
<a href="#l17.94"></a><span id="l17.94">  */</span>
<a href="#l17.95"></a><span id="l17.95" class="difflineminus">-function make_and_add_message(aMessageArgs, aFolder) {</span>
<a href="#l17.96"></a><span id="l17.96" class="difflineplus">+function make_and_add_message(aMessageArgs) {</span>
<a href="#l17.97"></a><span id="l17.97">   // create the message</span>
<a href="#l17.98"></a><span id="l17.98">   let synMsg = gMessageGenerator.makeMessage(aMessageArgs);</span>
<a href="#l17.99"></a><span id="l17.99" class="difflineplus">+  let msgSet = new SyntheticMessageSet([synMsg]);</span>
<a href="#l17.100"></a><span id="l17.100" class="difflineplus">+  // this is synchronous for local stuff.</span>
<a href="#l17.101"></a><span id="l17.101" class="difflineplus">+  add_sets_to_folder(gTestFolder, [msgSet]);</span>
<a href="#l17.102"></a><span id="l17.102"> </span>
<a href="#l17.103"></a><span id="l17.103" class="difflineminus">-  // do it for the side-effect</span>
<a href="#l17.104"></a><span id="l17.104" class="difflineminus">-  if (aFolder == null)</span>
<a href="#l17.105"></a><span id="l17.105" class="difflineminus">-    aFolder = gTestFolder;</span>
<a href="#l17.106"></a><span id="l17.106" class="difflineminus">-  aFolder.QueryInterface(Ci.nsIMsgLocalMailFolder);</span>
<a href="#l17.107"></a><span id="l17.107" class="difflineminus">-  aFolder.addMessage(synMsg.toMboxString());</span>
<a href="#l17.108"></a><span id="l17.108" class="difflineminus">-</span>
<a href="#l17.109"></a><span id="l17.109" class="difflineminus">-  return synMsg;</span>
<a href="#l17.110"></a><span id="l17.110" class="difflineplus">+  return [synMsg, msgSet];</span>
<a href="#l17.111"></a><span id="l17.111"> }</span>
<a href="#l17.112"></a><span id="l17.112"> </span>
<a href="#l17.113"></a><span id="l17.113"> var WHITESPACE = &quot;                                              &quot;;</span>
<a href="#l17.114"></a><span id="l17.114"> /**</span>
<a href="#l17.115"></a><span id="l17.115">  * Print out the current db view as best we can.</span>
<a href="#l17.116"></a><span id="l17.116">  *</span>
<a href="#l17.117"></a><span id="l17.117">  * Because nsITreeColumns are hard (impossible?) to create in an xpcshell test</span>
<a href="#l17.118"></a><span id="l17.118">  *  and GetCellText requires a real one (because it uses GetIdConst which is not</span>
<a href="#l17.119"></a><span id="l17.119" class="difflineat">@@ -468,17 +458,17 @@ function test_sort_columns() {</span>
<a href="#l17.120"></a><span id="l17.120">   // Received</span>
<a href="#l17.121"></a><span id="l17.121"> }</span>
<a href="#l17.122"></a><span id="l17.122"> </span>
<a href="#l17.123"></a><span id="l17.123"> function test_msg_added_to_search_view() {</span>
<a href="#l17.124"></a><span id="l17.124">   // if the view is a non-grouped search view, test adding a header to</span>
<a href="#l17.125"></a><span id="l17.125">   // the search results, and verify it gets put at top.</span>
<a href="#l17.126"></a><span id="l17.126">   if (! (gDBView.viewFlags &amp; ViewFlags.kGroupBySort)) {</span>
<a href="#l17.127"></a><span id="l17.127">     gDBView.sort(SortType.byDate, SortOrder.descending);</span>
<a href="#l17.128"></a><span id="l17.128" class="difflineminus">-    let synMsg = make_and_add_message();</span>
<a href="#l17.129"></a><span id="l17.129" class="difflineplus">+    let [synMsg, synSet] = make_and_add_message();</span>
<a href="#l17.130"></a><span id="l17.130">     let msgHdr = gTestFolder.msgDatabase.getMsgHdrForMessageID(synMsg.messageId);</span>
<a href="#l17.131"></a><span id="l17.131">     gDBView.QueryInterface(Components.interfaces.nsIMsgSearchNotify)</span>
<a href="#l17.132"></a><span id="l17.132">             .onSearchHit(msgHdr, msgHdr.folder);</span>
<a href="#l17.133"></a><span id="l17.133">     assert_view_message_at_indices(synMsg, 0);</span>
<a href="#l17.134"></a><span id="l17.134">   }</span>
<a href="#l17.135"></a><span id="l17.135"> }</span>
<a href="#l17.136"></a><span id="l17.136"> </span>
<a href="#l17.137"></a><span id="l17.137"> function IsHdrChildOf(possibleParent, possibleChild) {</span>
<a href="#l17.138"></a><span id="l17.138" class="difflineat">@@ -493,17 +483,17 @@ function IsHdrChildOf(possibleParent, po</span>
<a href="#l17.139"></a><span id="l17.139"> </span>
<a href="#l17.140"></a><span id="l17.140"> // This could be part of ensure_view_ordering() but I don't want to make that</span>
<a href="#l17.141"></a><span id="l17.141"> // function any harder to read.</span>
<a href="#l17.142"></a><span id="l17.142"> function test_threading_levels() {</span>
<a href="#l17.143"></a><span id="l17.143"> </span>
<a href="#l17.144"></a><span id="l17.144">   if (!gTreeView.rowCount)</span>
<a href="#l17.145"></a><span id="l17.145">     do_throw(&quot;There are no rows in my folder! I can't test anything!&quot;);</span>
<a href="#l17.146"></a><span id="l17.146">   // only look at threaded, non-grouped views.</span>
<a href="#l17.147"></a><span id="l17.147" class="difflineminus">-  if ((gDBView.viewFlags &amp; ViewFlags.kGroupBySort) || </span>
<a href="#l17.148"></a><span id="l17.148" class="difflineplus">+  if ((gDBView.viewFlags &amp; ViewFlags.kGroupBySort) ||</span>
<a href="#l17.149"></a><span id="l17.149">       ! (gDBView.viewFlags &amp; ViewFlags.kThreadedDisplay))</span>
<a href="#l17.150"></a><span id="l17.150">     return;</span>
<a href="#l17.151"></a><span id="l17.151"> </span>
<a href="#l17.152"></a><span id="l17.152">   let prevLevel = 1;</span>
<a href="#l17.153"></a><span id="l17.153">   let prevMsgHdr;</span>
<a href="#l17.154"></a><span id="l17.154">   for (let iViewIndex = 0; iViewIndex &lt; gTreeView.rowCount; iViewIndex++) {</span>
<a href="#l17.155"></a><span id="l17.155">     let msgHdr = gDBView.getMsgHdrAt(iViewIndex);</span>
<a href="#l17.156"></a><span id="l17.156">     let level = gTreeView.getLevel(iViewIndex);</span>
<a href="#l17.157"></a><span id="l17.157" class="difflineat">@@ -540,45 +530,45 @@ function test_group_dummies_under_mutati</span>
<a href="#l17.158"></a><span id="l17.158">   assert_view_empty();</span>
<a href="#l17.159"></a><span id="l17.159"> </span>
<a href="#l17.160"></a><span id="l17.160">   // - add a message from this week</span>
<a href="#l17.161"></a><span id="l17.161">   // (we want to make sure all the messages end up in the same bucket and that</span>
<a href="#l17.162"></a><span id="l17.162">   //  the current day changing as we run the test does not change buckets</span>
<a href="#l17.163"></a><span id="l17.163">   //  either. bucket 1 is same day, bucket 2 is yesterday, bucket 3 is last</span>
<a href="#l17.164"></a><span id="l17.164">   //  week, so 2 days ago or older is always last week, even if we roll over</span>
<a href="#l17.165"></a><span id="l17.165">   //  and it becomes 3 days ago.)</span>
<a href="#l17.166"></a><span id="l17.166" class="difflineminus">-  let smsg = make_and_add_message({age: {days: 2, hours: 1}});</span>
<a href="#l17.167"></a><span id="l17.167" class="difflineplus">+  let [smsg, synSet] = make_and_add_message({age: {days: 2, hours: 1}});</span>
<a href="#l17.168"></a><span id="l17.168"> </span>
<a href="#l17.169"></a><span id="l17.169">   // - make sure the message and a dummy appear</span>
<a href="#l17.170"></a><span id="l17.170">   assert_view_row_count(2);</span>
<a href="#l17.171"></a><span id="l17.171">   assert_view_index_is_dummy(0);</span>
<a href="#l17.172"></a><span id="l17.172">   assert_view_index_is_not_dummy(1);</span>
<a href="#l17.173"></a><span id="l17.173">   assert_view_message_at_indices(smsg, 0, 1);</span>
<a href="#l17.174"></a><span id="l17.174"> </span>
<a href="#l17.175"></a><span id="l17.175" class="difflineminus">-  // - delete the message</span>
<a href="#l17.176"></a><span id="l17.176" class="difflineminus">-  yield async_delete_messages(smsg);</span>
<a href="#l17.177"></a><span id="l17.177" class="difflineplus">+  // - move the messages to the trash</span>
<a href="#l17.178"></a><span id="l17.178" class="difflineplus">+  yield async_trash_messages(synSet);</span>
<a href="#l17.179"></a><span id="l17.179"> </span>
<a href="#l17.180"></a><span id="l17.180">   // - make sure the message and dummy disappear</span>
<a href="#l17.181"></a><span id="l17.181">   assert_view_empty();</span>
<a href="#l17.182"></a><span id="l17.182"> </span>
<a href="#l17.183"></a><span id="l17.183">   // - add two messages from this week (same date bucket concerns)</span>
<a href="#l17.184"></a><span id="l17.184" class="difflineminus">-  let newer = make_and_add_message({age: {days: 2, hours: 1}});</span>
<a href="#l17.185"></a><span id="l17.185" class="difflineminus">-  let older = make_and_add_message({age: {days: 2, hours: 2}});</span>
<a href="#l17.186"></a><span id="l17.186" class="difflineplus">+  let [newer, newerSet] = make_and_add_message({age: {days: 2, hours: 1}});</span>
<a href="#l17.187"></a><span id="l17.187" class="difflineplus">+  let [older, olderSet] = make_and_add_message({age: {days: 2, hours: 2}});</span>
<a href="#l17.188"></a><span id="l17.188"> </span>
<a href="#l17.189"></a><span id="l17.189">   // - sanity check addition</span>
<a href="#l17.190"></a><span id="l17.190">   assert_view_row_count(3); // 2 messages + 1 dummy</span>
<a href="#l17.191"></a><span id="l17.191">   assert_view_index_is_dummy(0);</span>
<a href="#l17.192"></a><span id="l17.192">   assert_view_index_is_not_dummy(1, 2);</span>
<a href="#l17.193"></a><span id="l17.193">   // the dummy should be based off the older guy</span>
<a href="#l17.194"></a><span id="l17.194">   assert_view_message_at_indices(older, 0, 1);</span>
<a href="#l17.195"></a><span id="l17.195">   assert_view_message_at_indices(newer, 2);</span>
<a href="#l17.196"></a><span id="l17.196"> </span>
<a href="#l17.197"></a><span id="l17.197">   // - delete the message right under the dummy</span>
<a href="#l17.198"></a><span id="l17.198">   // (this will be the newer one)</span>
<a href="#l17.199"></a><span id="l17.199" class="difflineminus">-  yield async_delete_messages(newer);</span>
<a href="#l17.200"></a><span id="l17.200" class="difflineplus">+  yield async_trash_messages(newerSet);</span>
<a href="#l17.201"></a><span id="l17.201"> </span>
<a href="#l17.202"></a><span id="l17.202">   // - ensure we still have the dummy and the right child node</span>
<a href="#l17.203"></a><span id="l17.203">   assert_view_row_count(2);</span>
<a href="#l17.204"></a><span id="l17.204">   assert_view_index_is_dummy(0);</span>
<a href="#l17.205"></a><span id="l17.205">   assert_view_index_is_not_dummy(1);</span>
<a href="#l17.206"></a><span id="l17.206">   // now the dummy should be based off the remaining older one</span>
<a href="#l17.207"></a><span id="l17.207">   assert_view_message_at_indices(older, 0, 1);</span>
<a href="#l17.208"></a><span id="l17.208"> }</span>
<a href="#l17.209"></a><span id="l17.209" class="difflineat">@@ -606,16 +596,17 @@ var tests_for_specific_views = {</span>
<a href="#l17.210"></a><span id="l17.210">     test_msg_added_to_search_view</span>
<a href="#l17.211"></a><span id="l17.211">   ],</span>
<a href="#l17.212"></a><span id="l17.212">   quicksearch: [</span>
<a href="#l17.213"></a><span id="l17.213">     test_qs_results</span>
<a href="#l17.214"></a><span id="l17.214">   ]</span>
<a href="#l17.215"></a><span id="l17.215"> };</span>
<a href="#l17.216"></a><span id="l17.216"> </span>
<a href="#l17.217"></a><span id="l17.217"> function run_test() {</span>
<a href="#l17.218"></a><span id="l17.218" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l17.219"></a><span id="l17.219">   do_test_pending();</span>
<a href="#l17.220"></a><span id="l17.220">   async_run({func: actually_run_test});</span>
<a href="#l17.221"></a><span id="l17.221"> }</span>
<a href="#l17.222"></a><span id="l17.222"> </span>
<a href="#l17.223"></a><span id="l17.223"> function actually_run_test() {</span>
<a href="#l17.224"></a><span id="l17.224">   dump(&quot;in actually_run_test\n&quot;);</span>
<a href="#l17.225"></a><span id="l17.225">   yield async_run({func: setup_globals});</span>
<a href="#l17.226"></a><span id="l17.226">   dump(&quot;Num Messages: &quot; + gTestFolder.msgDatabase.dBFolderInfo.numMessages + &quot;\n&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -2161,34 +2161,71 @@ nsMsgDBFolder::SpamFilterClassifyMessage</span>
<a href="#l18.4"></a><span id="l18.4"> </span>
<a href="#l18.5"></a><span id="l18.5"> NS_IMETHODIMP</span>
<a href="#l18.6"></a><span id="l18.6"> nsMsgDBFolder::OnMessageClassified(const char *aMsgURI,</span>
<a href="#l18.7"></a><span id="l18.7">                                    nsMsgJunkStatus aClassification,</span>
<a href="#l18.8"></a><span id="l18.8">                                    PRUint32 aJunkPercent)</span>
<a href="#l18.9"></a><span id="l18.9"> {</span>
<a href="#l18.10"></a><span id="l18.10">   if (!aMsgURI) // This signifies end of batch.</span>
<a href="#l18.11"></a><span id="l18.11">   {</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineplus">+    nsresult rv = NS_OK;</span>
<a href="#l18.13"></a><span id="l18.13">     // Apply filters if needed.</span>
<a href="#l18.14"></a><span id="l18.14">     PRUint32 length;</span>
<a href="#l18.15"></a><span id="l18.15" class="difflineminus">-    if ((!mPostBayesMessagesToFilter ||</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineminus">-         NS_FAILED(mPostBayesMessagesToFilter-&gt;GetLength(&amp;length)) ||</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineminus">-         !length))</span>
<a href="#l18.18"></a><span id="l18.18" class="difflineminus">-      return NS_OK; // No filtering needed or possible.</span>
<a href="#l18.19"></a><span id="l18.19" class="difflineminus">-</span>
<a href="#l18.20"></a><span id="l18.20" class="difflineminus">-    // Apply post-bayes filtering.</span>
<a href="#l18.21"></a><span id="l18.21" class="difflineminus">-    nsresult rv;</span>
<a href="#l18.22"></a><span id="l18.22" class="difflineminus">-    nsCOMPtr&lt;nsIMsgFilterService&gt; filterService(do_GetService(NS_MSGFILTERSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l18.23"></a><span id="l18.23" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l18.24"></a><span id="l18.24" class="difflineminus">-      // We use a null nsIMsgWindow because we don't want some sort of ui</span>
<a href="#l18.25"></a><span id="l18.25" class="difflineminus">-      // appearing in the middle of automatic filtering (plus I really don't</span>
<a href="#l18.26"></a><span id="l18.26" class="difflineminus">-      // want to propagate that value.)</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineminus">-      rv = filterService-&gt;ApplyFilters(nsMsgFilterType::PostPlugin,</span>
<a href="#l18.28"></a><span id="l18.28" class="difflineminus">-                                       mPostBayesMessagesToFilter,</span>
<a href="#l18.29"></a><span id="l18.29" class="difflineminus">-                                       this, nsnull /* nsIMsgWindow */);</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineminus">-    mPostBayesMessagesToFilter-&gt;Clear();</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+    if (mPostBayesMessagesToFilter &amp;&amp;</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+         NS_SUCCEEDED(mPostBayesMessagesToFilter-&gt;GetLength(&amp;length)) &amp;&amp;</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineplus">+         length)</span>
<a href="#l18.34"></a><span id="l18.34" class="difflineplus">+    {</span>
<a href="#l18.35"></a><span id="l18.35" class="difflineplus">+      // Apply post-bayes filtering.</span>
<a href="#l18.36"></a><span id="l18.36" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFilterService&gt;</span>
<a href="#l18.37"></a><span id="l18.37" class="difflineplus">+        filterService(do_GetService(NS_MSGFILTERSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l18.38"></a><span id="l18.38" class="difflineplus">+      if (NS_SUCCEEDED(rv))</span>
<a href="#l18.39"></a><span id="l18.39" class="difflineplus">+        // We use a null nsIMsgWindow because we don't want some sort of ui</span>
<a href="#l18.40"></a><span id="l18.40" class="difflineplus">+        // appearing in the middle of automatic filtering (plus I really don't</span>
<a href="#l18.41"></a><span id="l18.41" class="difflineplus">+        // want to propagate that value.)</span>
<a href="#l18.42"></a><span id="l18.42" class="difflineplus">+        rv = filterService-&gt;ApplyFilters(nsMsgFilterType::PostPlugin,</span>
<a href="#l18.43"></a><span id="l18.43" class="difflineplus">+                                         mPostBayesMessagesToFilter,</span>
<a href="#l18.44"></a><span id="l18.44" class="difflineplus">+                                         this, nsnull /* nsIMsgWindow */);</span>
<a href="#l18.45"></a><span id="l18.45" class="difflineplus">+      mPostBayesMessagesToFilter-&gt;Clear();</span>
<a href="#l18.46"></a><span id="l18.46" class="difflineplus">+    }</span>
<a href="#l18.47"></a><span id="l18.47" class="difflineplus">+</span>
<a href="#l18.48"></a><span id="l18.48" class="difflineplus">+    // Bail if we didn't actually classify any messages.</span>
<a href="#l18.49"></a><span id="l18.49" class="difflineplus">+    if (mBayesMsgKeys.IsEmpty())</span>
<a href="#l18.50"></a><span id="l18.50" class="difflineplus">+      return rv;</span>
<a href="#l18.51"></a><span id="l18.51" class="difflineplus">+</span>
<a href="#l18.52"></a><span id="l18.52" class="difflineplus">+    // Notify that we classified some messages.</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l18.54"></a><span id="l18.54" class="difflineplus">+      notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineplus">+</span>
<a href="#l18.57"></a><span id="l18.57" class="difflineplus">+    nsCOMPtr &lt;nsIMutableArray&gt; classifiedMsgHdrs =</span>
<a href="#l18.58"></a><span id="l18.58" class="difflineplus">+      do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l18.59"></a><span id="l18.59" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineplus">+</span>
<a href="#l18.61"></a><span id="l18.61" class="difflineplus">+    PRUint32 numKeys = mBayesMsgKeys.Length();</span>
<a href="#l18.62"></a><span id="l18.62" class="difflineplus">+    for (PRUint32 i = 0 ; i &lt; numKeys ; ++i)</span>
<a href="#l18.63"></a><span id="l18.63" class="difflineplus">+    {</span>
<a href="#l18.64"></a><span id="l18.64" class="difflineplus">+      nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l18.65"></a><span id="l18.65" class="difflineplus">+      PRBool hasKey;</span>
<a href="#l18.66"></a><span id="l18.66" class="difflineplus">+      // It is very possible for a message header to no longer be around because</span>
<a href="#l18.67"></a><span id="l18.67" class="difflineplus">+      // a filter moved it.</span>
<a href="#l18.68"></a><span id="l18.68" class="difflineplus">+      rv = mDatabase-&gt;ContainsKey(mBayesMsgKeys[i], &amp;hasKey);</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineplus">+      if (!NS_SUCCEEDED(rv) || !hasKey)</span>
<a href="#l18.70"></a><span id="l18.70" class="difflineplus">+        continue;</span>
<a href="#l18.71"></a><span id="l18.71" class="difflineplus">+      rv = mDatabase-&gt;GetMsgHdrForKey(mBayesMsgKeys[i],</span>
<a href="#l18.72"></a><span id="l18.72" class="difflineplus">+                                      getter_AddRefs(msgHdr));</span>
<a href="#l18.73"></a><span id="l18.73" class="difflineplus">+      if (!NS_SUCCEEDED(rv))</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineplus">+        continue;</span>
<a href="#l18.75"></a><span id="l18.75" class="difflineplus">+      classifiedMsgHdrs-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l18.76"></a><span id="l18.76" class="difflineplus">+    }</span>
<a href="#l18.77"></a><span id="l18.77" class="difflineplus">+</span>
<a href="#l18.78"></a><span id="l18.78" class="difflineplus">+    notifier-&gt;NotifyMsgsClassified(classifiedMsgHdrs,</span>
<a href="#l18.79"></a><span id="l18.79" class="difflineplus">+                                   mBayesJunkClassifying,</span>
<a href="#l18.80"></a><span id="l18.80" class="difflineplus">+                                   mBayesTraitClassifying);</span>
<a href="#l18.81"></a><span id="l18.81" class="difflineplus">+    mBayesMsgKeys.Clear();</span>
<a href="#l18.82"></a><span id="l18.82" class="difflineplus">+</span>
<a href="#l18.83"></a><span id="l18.83">     return rv;</span>
<a href="#l18.84"></a><span id="l18.84">   }</span>
<a href="#l18.85"></a><span id="l18.85"> </span>
<a href="#l18.86"></a><span id="l18.86">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l18.87"></a><span id="l18.87">   nsresult rv = GetServer(getter_AddRefs(server));</span>
<a href="#l18.88"></a><span id="l18.88">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.89"></a><span id="l18.89"> </span>
<a href="#l18.90"></a><span id="l18.90">   nsCOMPtr&lt;nsISpamSettings&gt; spamSettings;</span>
<a href="#l18.91"></a><span id="l18.91" class="difflineat">@@ -2441,42 +2478,75 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l18.92"></a><span id="l18.92">       PRBool enabled = PR_FALSE;</span>
<a href="#l18.93"></a><span id="l18.93">       filter-&gt;GetEnabled(&amp;enabled);</span>
<a href="#l18.94"></a><span id="l18.94">       if (!enabled)</span>
<a href="#l18.95"></a><span id="l18.95">         continue;</span>
<a href="#l18.96"></a><span id="l18.96">       filterPostPlugin = PR_TRUE;</span>
<a href="#l18.97"></a><span id="l18.97">     }</span>
<a href="#l18.98"></a><span id="l18.98">   }</span>
<a href="#l18.99"></a><span id="l18.99"> </span>
<a href="#l18.100"></a><span id="l18.100" class="difflineminus">-  if (!filterForOther &amp;&amp; !filterForJunk &amp;&amp; !filterPostPlugin)</span>
<a href="#l18.101"></a><span id="l18.101" class="difflineminus">-    return NS_OK;</span>
<a href="#l18.102"></a><span id="l18.102" class="difflineminus">-  </span>
<a href="#l18.103"></a><span id="l18.103">   // get the list of new messages</span>
<a href="#l18.104"></a><span id="l18.104">   //</span>
<a href="#l18.105"></a><span id="l18.105">   PRUint32 numNewKeys;</span>
<a href="#l18.106"></a><span id="l18.106">   PRUint32 *newKeys;</span>
<a href="#l18.107"></a><span id="l18.107">   rv = mDatabase-&gt;GetNewList(&amp;numNewKeys, &amp;newKeys);</span>
<a href="#l18.108"></a><span id="l18.108">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.109"></a><span id="l18.109"> </span>
<a href="#l18.110"></a><span id="l18.110">   nsTArray&lt;nsMsgKey&gt; newMessageKeys;</span>
<a href="#l18.111"></a><span id="l18.111" class="difflineplus">+  // Start from m_saveNewMsgs (and clear its current state).  m_saveNewMsgs is</span>
<a href="#l18.112"></a><span id="l18.112" class="difflineplus">+  // where we stash the list of new messages when we are told to clear the list</span>
<a href="#l18.113"></a><span id="l18.113" class="difflineplus">+  // of new messages by the UI (which purges the list from the nsMsgDatabase).</span>
<a href="#l18.114"></a><span id="l18.114">   newMessageKeys.SwapElements(m_saveNewMsgs);</span>
<a href="#l18.115"></a><span id="l18.115">   if (numNewKeys)</span>
<a href="#l18.116"></a><span id="l18.116">     newMessageKeys.AppendElements(newKeys, numNewKeys);</span>
<a href="#l18.117"></a><span id="l18.117"> </span>
<a href="#l18.118"></a><span id="l18.118">   NS_Free(newKeys);</span>
<a href="#l18.119"></a><span id="l18.119"> </span>
<a href="#l18.120"></a><span id="l18.120">   // if there weren't any, just return</span>
<a href="#l18.121"></a><span id="l18.121">   if (newMessageKeys.IsEmpty())</span>
<a href="#l18.122"></a><span id="l18.122">     return NS_OK;</span>
<a href="#l18.123"></a><span id="l18.123"> </span>
<a href="#l18.124"></a><span id="l18.124" class="difflineplus">+  // If we do not need to do any work, leave.</span>
<a href="#l18.125"></a><span id="l18.125" class="difflineplus">+  // (We needed to get the list of new messages so we could get their headers so</span>
<a href="#l18.126"></a><span id="l18.126" class="difflineplus">+  // we can send notifications about them here.)</span>
<a href="#l18.127"></a><span id="l18.127" class="difflineplus">+  if (!filterForOther &amp;&amp; !filterForJunk &amp;&amp; !filterPostPlugin)</span>
<a href="#l18.128"></a><span id="l18.128" class="difflineplus">+  {</span>
<a href="#l18.129"></a><span id="l18.129" class="difflineplus">+    // notify that these messages are not being classified</span>
<a href="#l18.130"></a><span id="l18.130" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l18.131"></a><span id="l18.131" class="difflineplus">+      notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l18.132"></a><span id="l18.132" class="difflineplus">+    if (notifier)</span>
<a href="#l18.133"></a><span id="l18.133" class="difflineplus">+    {</span>
<a href="#l18.134"></a><span id="l18.134" class="difflineplus">+      nsCOMPtr &lt;nsIMutableArray&gt; newMsgHdrs =</span>
<a href="#l18.135"></a><span id="l18.135" class="difflineplus">+        do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv);</span>
<a href="#l18.136"></a><span id="l18.136" class="difflineplus">+      NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l18.137"></a><span id="l18.137" class="difflineplus">+</span>
<a href="#l18.138"></a><span id="l18.138" class="difflineplus">+      PRUint32 numNewMessages = newMessageKeys.Length();</span>
<a href="#l18.139"></a><span id="l18.139" class="difflineplus">+      for (PRUint32 i = 0 ; i &lt; numNewMessages ; ++i)</span>
<a href="#l18.140"></a><span id="l18.140" class="difflineplus">+      {</span>
<a href="#l18.141"></a><span id="l18.141" class="difflineplus">+        nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l18.142"></a><span id="l18.142" class="difflineplus">+        // We do not need to do a ContainsKey check here; nothing could have</span>
<a href="#l18.143"></a><span id="l18.143" class="difflineplus">+        // changed yet.</span>
<a href="#l18.144"></a><span id="l18.144" class="difflineplus">+        rv = mDatabase-&gt;GetMsgHdrForKey(newMessageKeys[i],</span>
<a href="#l18.145"></a><span id="l18.145" class="difflineplus">+                                        getter_AddRefs(msgHdr));</span>
<a href="#l18.146"></a><span id="l18.146" class="difflineplus">+        if (!NS_SUCCEEDED(rv))</span>
<a href="#l18.147"></a><span id="l18.147" class="difflineplus">+          continue;</span>
<a href="#l18.148"></a><span id="l18.148" class="difflineplus">+        newMsgHdrs-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l18.149"></a><span id="l18.149" class="difflineplus">+      }</span>
<a href="#l18.150"></a><span id="l18.150" class="difflineplus">+      // we need to build up a list of message headers for this notification</span>
<a href="#l18.151"></a><span id="l18.151" class="difflineplus">+      notifier-&gt;NotifyMsgsClassified(newMsgHdrs, filterForJunk, filterForOther);</span>
<a href="#l18.152"></a><span id="l18.152" class="difflineplus">+    }</span>
<a href="#l18.153"></a><span id="l18.153" class="difflineplus">+    return NS_OK;</span>
<a href="#l18.154"></a><span id="l18.154" class="difflineplus">+  }</span>
<a href="#l18.155"></a><span id="l18.155" class="difflineplus">+</span>
<a href="#l18.156"></a><span id="l18.156">   // build up list of keys to classify</span>
<a href="#l18.157"></a><span id="l18.157">   nsCString uri;</span>
<a href="#l18.158"></a><span id="l18.158" class="difflineminus">-  nsTArray&lt;nsMsgKey&gt; keysToClassify;</span>
<a href="#l18.159"></a><span id="l18.159" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; msgHdrsNotBeingClassified; // create on demand</span>
<a href="#l18.160"></a><span id="l18.160" class="difflineplus">+</span>
<a href="#l18.161"></a><span id="l18.161">   PRUint32 numNewMessages = newMessageKeys.Length();</span>
<a href="#l18.162"></a><span id="l18.162" class="difflineminus">-  for ( PRUint32 i=0 ; i &lt; numNewMessages ; ++i )</span>
<a href="#l18.163"></a><span id="l18.163" class="difflineplus">+  for (PRUint32 i = 0 ; i &lt; numNewMessages ; ++i)</span>
<a href="#l18.164"></a><span id="l18.164">   {</span>
<a href="#l18.165"></a><span id="l18.165">     nsCOMPtr &lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l18.166"></a><span id="l18.166">     nsMsgKey msgKey = newMessageKeys[i];</span>
<a href="#l18.167"></a><span id="l18.167">     rv = mDatabase-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(msgHdr));</span>
<a href="#l18.168"></a><span id="l18.168">     if (!NS_SUCCEEDED(rv))</span>
<a href="#l18.169"></a><span id="l18.169">       continue;</span>
<a href="#l18.170"></a><span id="l18.170">     // per-message junk tests.</span>
<a href="#l18.171"></a><span id="l18.171">     PRBool filterMessageForJunk = PR_FALSE;</span>
<a href="#l18.172"></a><span id="l18.172" class="difflineat">@@ -2513,22 +2583,32 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l18.173"></a><span id="l18.173">       // don't do trait processing on this message again</span>
<a href="#l18.174"></a><span id="l18.174">       OrProcessingFlags(msgKey, nsMsgProcessingFlags::TraitsDone);</span>
<a href="#l18.175"></a><span id="l18.175">       if (filterForOther)</span>
<a href="#l18.176"></a><span id="l18.176">         filterMessageForOther = PR_TRUE;</span>
<a href="#l18.177"></a><span id="l18.177">     }</span>
<a href="#l18.178"></a><span id="l18.178"> </span>
<a href="#l18.179"></a><span id="l18.179">     if (filterMessageForJunk || filterMessageForOther)</span>
<a href="#l18.180"></a><span id="l18.180">     {</span>
<a href="#l18.181"></a><span id="l18.181" class="difflineminus">-      keysToClassify.AppendElement(newMessageKeys[i]);</span>
<a href="#l18.182"></a><span id="l18.182" class="difflineplus">+      mBayesMsgKeys.AppendElement(newMessageKeys[i]);</span>
<a href="#l18.183"></a><span id="l18.183">       if (filterMessageForJunk)</span>
<a href="#l18.184"></a><span id="l18.184">         OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyJunk);</span>
<a href="#l18.185"></a><span id="l18.185">       if (filterMessageForOther)</span>
<a href="#l18.186"></a><span id="l18.186">         OrProcessingFlags(msgKey, nsMsgProcessingFlags::ClassifyTraits);</span>
<a href="#l18.187"></a><span id="l18.187">     }</span>
<a href="#l18.188"></a><span id="l18.188" class="difflineplus">+    else</span>
<a href="#l18.189"></a><span id="l18.189" class="difflineplus">+    {</span>
<a href="#l18.190"></a><span id="l18.190" class="difflineplus">+      if (!msgHdrsNotBeingClassified)</span>
<a href="#l18.191"></a><span id="l18.191" class="difflineplus">+        msgHdrsNotBeingClassified = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l18.192"></a><span id="l18.192" class="difflineplus">+      if (!msgHdrsNotBeingClassified)</span>
<a href="#l18.193"></a><span id="l18.193" class="difflineplus">+        return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.194"></a><span id="l18.194" class="difflineplus">+      // Accumulate the message header for immediate classified notification</span>
<a href="#l18.195"></a><span id="l18.195" class="difflineplus">+      // that we are not classifying it.</span>
<a href="#l18.196"></a><span id="l18.196" class="difflineplus">+      msgHdrsNotBeingClassified-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l18.197"></a><span id="l18.197" class="difflineplus">+    }</span>
<a href="#l18.198"></a><span id="l18.198"> </span>
<a href="#l18.199"></a><span id="l18.199">     // Set messages to filter post-bayes.</span>
<a href="#l18.200"></a><span id="l18.200">     // Have we already filtered this message?</span>
<a href="#l18.201"></a><span id="l18.201">     if (!(processingFlags &amp; nsMsgProcessingFlags::FiltersDone))</span>
<a href="#l18.202"></a><span id="l18.202">     {</span>
<a href="#l18.203"></a><span id="l18.203">       // Don't do filters on this message again.</span>
<a href="#l18.204"></a><span id="l18.204">       OrProcessingFlags(msgKey, nsMsgProcessingFlags::FiltersDone);</span>
<a href="#l18.205"></a><span id="l18.205">       if (filterPostPlugin)</span>
<a href="#l18.206"></a><span id="l18.206" class="difflineat">@@ -2536,27 +2616,44 @@ nsMsgDBFolder::CallFilterPlugins(nsIMsgW</span>
<a href="#l18.207"></a><span id="l18.207">         // Lazily create the array.</span>
<a href="#l18.208"></a><span id="l18.208">         if (!mPostBayesMessagesToFilter)</span>
<a href="#l18.209"></a><span id="l18.209">           mPostBayesMessagesToFilter = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l18.210"></a><span id="l18.210">         mPostBayesMessagesToFilter-&gt;AppendElement(msgHdr, PR_FALSE);</span>
<a href="#l18.211"></a><span id="l18.211">       }</span>
<a href="#l18.212"></a><span id="l18.212">     }</span>
<a href="#l18.213"></a><span id="l18.213">   }</span>
<a href="#l18.214"></a><span id="l18.214"> </span>
<a href="#l18.215"></a><span id="l18.215" class="difflineminus">-  if (!keysToClassify.IsEmpty())</span>
<a href="#l18.216"></a><span id="l18.216" class="difflineplus">+  // If we have any headers not being classified, notify about them.</span>
<a href="#l18.217"></a><span id="l18.217" class="difflineplus">+  if (msgHdrsNotBeingClassified)</span>
<a href="#l18.218"></a><span id="l18.218">   {</span>
<a href="#l18.219"></a><span id="l18.219" class="difflineminus">-    PRUint32 numMessagesToClassify = keysToClassify.Length();</span>
<a href="#l18.220"></a><span id="l18.220" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolderNotificationService&gt;</span>
<a href="#l18.221"></a><span id="l18.221" class="difflineplus">+      notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l18.222"></a><span id="l18.222" class="difflineplus">+    if (notifier)</span>
<a href="#l18.223"></a><span id="l18.223" class="difflineplus">+      notifier-&gt;NotifyMsgsClassified(msgHdrsNotBeingClassified,</span>
<a href="#l18.224"></a><span id="l18.224" class="difflineplus">+                                     // no classification is being performed</span>
<a href="#l18.225"></a><span id="l18.225" class="difflineplus">+                                     PR_FALSE, PR_FALSE);</span>
<a href="#l18.226"></a><span id="l18.226" class="difflineplus">+  }</span>
<a href="#l18.227"></a><span id="l18.227" class="difflineplus">+</span>
<a href="#l18.228"></a><span id="l18.228" class="difflineplus">+  if (!mBayesMsgKeys.IsEmpty())</span>
<a href="#l18.229"></a><span id="l18.229" class="difflineplus">+  {</span>
<a href="#l18.230"></a><span id="l18.230" class="difflineplus">+    // Remember what classifications are the source of this decision for when</span>
<a href="#l18.231"></a><span id="l18.231" class="difflineplus">+    // we perform the notification in OnMessageClassified at the conclusion of</span>
<a href="#l18.232"></a><span id="l18.232" class="difflineplus">+    // classification.</span>
<a href="#l18.233"></a><span id="l18.233" class="difflineplus">+    mBayesJunkClassifying = filterForJunk;</span>
<a href="#l18.234"></a><span id="l18.234" class="difflineplus">+    mBayesTraitClassifying = filterForOther;</span>
<a href="#l18.235"></a><span id="l18.235" class="difflineplus">+</span>
<a href="#l18.236"></a><span id="l18.236" class="difflineplus">+    PRUint32 numMessagesToClassify = mBayesMsgKeys.Length();</span>
<a href="#l18.237"></a><span id="l18.237">     char ** messageURIs = (char **) PR_MALLOC(sizeof(const char *) * numMessagesToClassify);</span>
<a href="#l18.238"></a><span id="l18.238">     if (!messageURIs)</span>
<a href="#l18.239"></a><span id="l18.239">       return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l18.240"></a><span id="l18.240"> </span>
<a href="#l18.241"></a><span id="l18.241">     for (PRUint32 msgIndex = 0; msgIndex &lt; numMessagesToClassify ; ++msgIndex )</span>
<a href="#l18.242"></a><span id="l18.242">     {</span>
<a href="#l18.243"></a><span id="l18.243">       nsCString tmpStr;</span>
<a href="#l18.244"></a><span id="l18.244" class="difflineminus">-      rv = GenerateMessageURI(keysToClassify[msgIndex], tmpStr);</span>
<a href="#l18.245"></a><span id="l18.245" class="difflineplus">+      rv = GenerateMessageURI(mBayesMsgKeys[msgIndex], tmpStr);</span>
<a href="#l18.246"></a><span id="l18.246">       messageURIs[msgIndex] = ToNewCString(tmpStr);</span>
<a href="#l18.247"></a><span id="l18.247">       if (NS_FAILED(rv))</span>
<a href="#l18.248"></a><span id="l18.248">           NS_WARNING(&quot;nsMsgDBFolder::CallFilterPlugins(): could not&quot;</span>
<a href="#l18.249"></a><span id="l18.249">                      &quot; generate URI for message&quot;);</span>
<a href="#l18.250"></a><span id="l18.250">     }</span>
<a href="#l18.251"></a><span id="l18.251">     // filterMsgs</span>
<a href="#l18.252"></a><span id="l18.252">     *aFiltersRun = PR_TRUE;</span>
<a href="#l18.253"></a><span id="l18.253">     rv = SpamFilterClassifyMessages((const char **) messageURIs, numMessagesToClassify, aMsgWindow, junkMailPlugin);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/mailnews/base/util/nsMsgDBFolder.h</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -297,16 +297,29 @@ protected:</span>
<a href="#l19.4"></a><span id="l19.4">   struct</span>
<a href="#l19.5"></a><span id="l19.5">   {</span>
<a href="#l19.6"></a><span id="l19.6">     PRUint32 bit;</span>
<a href="#l19.7"></a><span id="l19.7">     nsMsgKeySetU* keys;</span>
<a href="#l19.8"></a><span id="l19.8">   } mProcessingFlag[nsMsgProcessingFlags::NumberOfFlags];</span>
<a href="#l19.9"></a><span id="l19.9"> </span>
<a href="#l19.10"></a><span id="l19.10">   // list of nsIMsgDBHdrs for messages to process post-bayes</span>
<a href="#l19.11"></a><span id="l19.11">   nsCOMPtr&lt;nsIMutableArray&gt; mPostBayesMessagesToFilter;</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineplus">+</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+  /**</span>
<a href="#l19.14"></a><span id="l19.14" class="difflineplus">+   * The list of message keys of messages being processed by Bayesian</span>
<a href="#l19.15"></a><span id="l19.15" class="difflineplus">+   * classification.  We save the keys instead of the headers because it is</span>
<a href="#l19.16"></a><span id="l19.16" class="difflineplus">+   * possible that post-classification filters may end up moving the messages</span>
<a href="#l19.17"></a><span id="l19.17" class="difflineplus">+   * out of the folder (at which point the header becomes invalid).  (It also</span>
<a href="#l19.18"></a><span id="l19.18" class="difflineplus">+   * helps keep memory usage down when there are lots of messages.)</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineplus">+   */</span>
<a href="#l19.20"></a><span id="l19.20" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; mBayesMsgKeys;</span>
<a href="#l19.21"></a><span id="l19.21" class="difflineplus">+  // Is the current bayes filtering doing junk classification?</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineplus">+  PRBool mBayesJunkClassifying;</span>
<a href="#l19.23"></a><span id="l19.23" class="difflineplus">+  // Is the current bayes filtering doing trait classification?</span>
<a href="#l19.24"></a><span id="l19.24" class="difflineplus">+  PRBool mBayesTraitClassifying;</span>
<a href="#l19.25"></a><span id="l19.25"> };</span>
<a href="#l19.26"></a><span id="l19.26"> </span>
<a href="#l19.27"></a><span id="l19.27"> // This class is a kludge to allow nsMsgKeySet to be used with PRUint32 keys</span>
<a href="#l19.28"></a><span id="l19.28"> class nsMsgKeySetU</span>
<a href="#l19.29"></a><span id="l19.29"> {</span>
<a href="#l19.30"></a><span id="l19.30"> public:</span>
<a href="#l19.31"></a><span id="l19.31">     // Creates an empty set.</span>
<a href="#l19.32"></a><span id="l19.32">   static nsMsgKeySetU* Create();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/mailnews/compose/test/unit/test_sendMessageLater2.js</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/mailnews/compose/test/unit/test_sendMessageLater2.js</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -7,16 +7,17 @@</span>
<a href="#l20.4"></a><span id="l20.4">  * from one send later instance, however due to the fact we use one connection</span>
<a href="#l20.5"></a><span id="l20.5">  * per message sent, it is very difficult to consistently get the fake server</span>
<a href="#l20.6"></a><span id="l20.6">  * reconected in time for the next connection. Thus, sending of multiple</span>
<a href="#l20.7"></a><span id="l20.7">  * messages is currently disabled (but commented out for local testing if</span>
<a href="#l20.8"></a><span id="l20.8">  * required), when we fix bug 136871 we should be able to enable the multiple</span>
<a href="#l20.9"></a><span id="l20.9">  * messages option. </span>
<a href="#l20.10"></a><span id="l20.10">  */</span>
<a href="#l20.11"></a><span id="l20.11"> </span>
<a href="#l20.12"></a><span id="l20.12" class="difflineplus">+load(&quot;../../mailnews/resources/logHelper.js&quot;);</span>
<a href="#l20.13"></a><span id="l20.13"> load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l20.14"></a><span id="l20.14"> </span>
<a href="#l20.15"></a><span id="l20.15"> var test = &quot;sendMessageLater&quot;;</span>
<a href="#l20.16"></a><span id="l20.16"> var server = null;</span>
<a href="#l20.17"></a><span id="l20.17"> var gSentFolder;</span>
<a href="#l20.18"></a><span id="l20.18"> var originalData;</span>
<a href="#l20.19"></a><span id="l20.19"> var identity = null;</span>
<a href="#l20.20"></a><span id="l20.20"> var gMsgFile =</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/mailnews/db/gloda/modules/collection.js</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/collection.js</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -177,16 +177,33 @@ var GlodaCollectionManager = {</span>
<a href="#l21.4"></a><span id="l21.4">         }</span>
<a href="#l21.5"></a><span id="l21.5">       }</span>
<a href="#l21.6"></a><span id="l21.6">     }</span>
<a href="#l21.7"></a><span id="l21.7"> </span>
<a href="#l21.8"></a><span id="l21.8">     return [foundCount, notFoundCount, notFound];</span>
<a href="#l21.9"></a><span id="l21.9">   },</span>
<a href="#l21.10"></a><span id="l21.10"> </span>
<a href="#l21.11"></a><span id="l21.11">   /**</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineplus">+   * Friendlier version of |cacheLookupMany|; takes a list of ids and returns</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+   *  an object whose keys and values are the gloda id's and instances of the</span>
<a href="#l21.14"></a><span id="l21.14" class="difflineplus">+   *  instances that were found.  We don't tell you who we didn't find.  The</span>
<a href="#l21.15"></a><span id="l21.15" class="difflineplus">+   *  assumption is this is being used for in-memory updates where we only need</span>
<a href="#l21.16"></a><span id="l21.16" class="difflineplus">+   *  to tweak what is in memory.</span>
<a href="#l21.17"></a><span id="l21.17" class="difflineplus">+   */</span>
<a href="#l21.18"></a><span id="l21.18" class="difflineplus">+  cacheLookupManyList: function gloda_colm_cacheLookupManyList(aNounID, aIds) {</span>
<a href="#l21.19"></a><span id="l21.19" class="difflineplus">+    let checkMap = {}, targetMap = {};</span>
<a href="#l21.20"></a><span id="l21.20" class="difflineplus">+    for each (let [, id] in Iterator(aIds)) {</span>
<a href="#l21.21"></a><span id="l21.21" class="difflineplus">+      checkMap[id] = null;</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineplus">+    }</span>
<a href="#l21.23"></a><span id="l21.23" class="difflineplus">+    // do not promote found items into the cache</span>
<a href="#l21.24"></a><span id="l21.24" class="difflineplus">+    this.cacheLookupMany(aNounID, checkMap, targetMap, false);</span>
<a href="#l21.25"></a><span id="l21.25" class="difflineplus">+    return targetMap;</span>
<a href="#l21.26"></a><span id="l21.26" class="difflineplus">+  },</span>
<a href="#l21.27"></a><span id="l21.27" class="difflineplus">+</span>
<a href="#l21.28"></a><span id="l21.28" class="difflineplus">+  /**</span>
<a href="#l21.29"></a><span id="l21.29">    * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l21.30"></a><span id="l21.30">    *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l21.31"></a><span id="l21.31">    *  but rather a collection, it is added to the cache.)</span>
<a href="#l21.32"></a><span id="l21.32">    */</span>
<a href="#l21.33"></a><span id="l21.33">   cacheLookupOneByUniqueValue:</span>
<a href="#l21.34"></a><span id="l21.34">       function gloda_colm_cacheLookupOneByUniqueValue(aNounID, aUniqueValue,</span>
<a href="#l21.35"></a><span id="l21.35">                                                       aDoCache) {</span>
<a href="#l21.36"></a><span id="l21.36">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l21.37"></a><span id="l21.37" class="difflineat">@@ -388,39 +405,80 @@ var GlodaCollectionManager = {</span>
<a href="#l21.38"></a><span id="l21.38">         collection._onItemsAdded(added);</span>
<a href="#l21.39"></a><span id="l21.39">       if (modified.length)</span>
<a href="#l21.40"></a><span id="l21.40">         collection._onItemsModified(modified);</span>
<a href="#l21.41"></a><span id="l21.41">       if (removed.length)</span>
<a href="#l21.42"></a><span id="l21.42">         collection._onItemsRemoved(removed);</span>
<a href="#l21.43"></a><span id="l21.43">     }</span>
<a href="#l21.44"></a><span id="l21.44">   },</span>
<a href="#l21.45"></a><span id="l21.45">   /**</span>
<a href="#l21.46"></a><span id="l21.46" class="difflineminus">-   * This should be called when items in the global database are permanently</span>
<a href="#l21.47"></a><span id="l21.47" class="difflineplus">+   * This should be called when items in the global database are permanently-ish</span>
<a href="#l21.48"></a><span id="l21.48">    *  deleted.  (This is distinct from concepts like message deletion which may</span>
<a href="#l21.49"></a><span id="l21.49">    *  involved trash folders or other modified forms of existence.  Deleted</span>
<a href="#l21.50"></a><span id="l21.50">    *  means the data is gone and if it were to come back, it would come back</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineminus">-   *  with a brand new unique id and we would get an itemsAdded event.)</span>
<a href="#l21.52"></a><span id="l21.52" class="difflineplus">+   *  via an itemsAdded event.)</span>
<a href="#l21.53"></a><span id="l21.53">    * We walk all existing collections for the given noun type.  For items</span>
<a href="#l21.54"></a><span id="l21.54">    *  currently in the collection, we generate onItemsRemoved events.</span>
<a href="#l21.55"></a><span id="l21.55" class="difflineplus">+   * </span>
<a href="#l21.56"></a><span id="l21.56" class="difflineplus">+   * @param aItemIds A list of item ids that are being deleted.</span>
<a href="#l21.57"></a><span id="l21.57">    */</span>
<a href="#l21.58"></a><span id="l21.58" class="difflineminus">-  itemsDeleted: function gloda_colm_itemsDeleted(aNounID, aItems) {</span>
<a href="#l21.59"></a><span id="l21.59" class="difflineplus">+  itemsDeleted: function gloda_colm_itemsDeleted(aNounID, aItemIds) {</span>
<a href="#l21.60"></a><span id="l21.60">     // cache</span>
<a href="#l21.61"></a><span id="l21.61">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l21.62"></a><span id="l21.62">     if (cache) {</span>
<a href="#l21.63"></a><span id="l21.63" class="difflineminus">-      for each (let [iItem, item] in Iterator(aItem)) {</span>
<a href="#l21.64"></a><span id="l21.64" class="difflineminus">-        if (item.id in cache._idMap)</span>
<a href="#l21.65"></a><span id="l21.65" class="difflineminus">-          cache.delete(item);</span>
<a href="#l21.66"></a><span id="l21.66" class="difflineplus">+      for each (let [, itemId] in Iterator(aItemIds)) {</span>
<a href="#l21.67"></a><span id="l21.67" class="difflineplus">+        if (itemId in cache._idMap)</span>
<a href="#l21.68"></a><span id="l21.68" class="difflineplus">+          cache.deleted(cache._idMap[itemId]);</span>
<a href="#l21.69"></a><span id="l21.69">       }</span>
<a href="#l21.70"></a><span id="l21.70">     }</span>
<a href="#l21.71"></a><span id="l21.71"> </span>
<a href="#l21.72"></a><span id="l21.72">     // collections</span>
<a href="#l21.73"></a><span id="l21.73">     for each (let [iCollection, collection] in</span>
<a href="#l21.74"></a><span id="l21.74">               Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l21.75"></a><span id="l21.75" class="difflineminus">-      let removeItems = [item for each ([i, item] in Iterator(aItems))</span>
<a href="#l21.76"></a><span id="l21.76" class="difflineminus">-                         if (item.id in collection._idMap)];</span>
<a href="#l21.77"></a><span id="l21.77" class="difflineplus">+      let removeItems = [collection._idMap[itemId]</span>
<a href="#l21.78"></a><span id="l21.78" class="difflineplus">+                         for each ([, itemId] in Iterator(aItemIds))</span>
<a href="#l21.79"></a><span id="l21.79" class="difflineplus">+                         if (itemId in collection._idMap)];</span>
<a href="#l21.80"></a><span id="l21.80" class="difflineplus">+      if (removeItems.length)</span>
<a href="#l21.81"></a><span id="l21.81" class="difflineplus">+        collection._onItemsRemoved(removeItems);</span>
<a href="#l21.82"></a><span id="l21.82" class="difflineplus">+    }</span>
<a href="#l21.83"></a><span id="l21.83" class="difflineplus">+  },</span>
<a href="#l21.84"></a><span id="l21.84" class="difflineplus">+  /**</span>
<a href="#l21.85"></a><span id="l21.85" class="difflineplus">+   * Like |itemsDeleted| but for the case where the deletion is based on an</span>
<a href="#l21.86"></a><span id="l21.86" class="difflineplus">+   *  attribute that SQLite can more efficiently check than we can and where the</span>
<a href="#l21.87"></a><span id="l21.87" class="difflineplus">+   *  cost of scanning the in-memory items is presumably much cheaper than</span>
<a href="#l21.88"></a><span id="l21.88" class="difflineplus">+   *  trying to figure out what actually got deleted.</span>
<a href="#l21.89"></a><span id="l21.89" class="difflineplus">+   * </span>
<a href="#l21.90"></a><span id="l21.90" class="difflineplus">+   * Since we are doing an in-memory walk, this is obviously O(n) where n is the</span>
<a href="#l21.91"></a><span id="l21.91" class="difflineplus">+   *  number of noun instances of a given type in-memory.  We are assuming this</span>
<a href="#l21.92"></a><span id="l21.92" class="difflineplus">+   *  is a reasonable number of things and that this type of deletion call is</span>
<a href="#l21.93"></a><span id="l21.93" class="difflineplus">+   *  not going to happen all that frequently.  If these assumptions are wrong,</span>
<a href="#l21.94"></a><span id="l21.94" class="difflineplus">+   *  callers are advised to re-think the whole situation.</span>
<a href="#l21.95"></a><span id="l21.95" class="difflineplus">+   * </span>
<a href="#l21.96"></a><span id="l21.96" class="difflineplus">+   * @param aNounID Type of noun we are talking about here.</span>
<a href="#l21.97"></a><span id="l21.97" class="difflineplus">+   * @param aFilter A filter function that returns true when the item should be</span>
<a href="#l21.98"></a><span id="l21.98" class="difflineplus">+   *     thought of as deleted, or false if the item is still good.  Screw this</span>
<a href="#l21.99"></a><span id="l21.99" class="difflineplus">+   *     up and you will get some seriously wacky bugs, yo.</span>
<a href="#l21.100"></a><span id="l21.100" class="difflineplus">+   */</span>
<a href="#l21.101"></a><span id="l21.101" class="difflineplus">+  itemsDeletedByAttribute: function gloda_colm_itemsDeletedByAttribute(</span>
<a href="#l21.102"></a><span id="l21.102" class="difflineplus">+      aNounID, aFilter) {</span>
<a href="#l21.103"></a><span id="l21.103" class="difflineplus">+    // cache</span>
<a href="#l21.104"></a><span id="l21.104" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l21.105"></a><span id="l21.105" class="difflineplus">+    if (cache) {</span>
<a href="#l21.106"></a><span id="l21.106" class="difflineplus">+      for each (let [, item] in Iterator(cache._idMap)) {</span>
<a href="#l21.107"></a><span id="l21.107" class="difflineplus">+        if (aFilter(item))</span>
<a href="#l21.108"></a><span id="l21.108" class="difflineplus">+          cache.deleted(item);</span>
<a href="#l21.109"></a><span id="l21.109" class="difflineplus">+      }</span>
<a href="#l21.110"></a><span id="l21.110" class="difflineplus">+    }</span>
<a href="#l21.111"></a><span id="l21.111" class="difflineplus">+</span>
<a href="#l21.112"></a><span id="l21.112" class="difflineplus">+    // collections</span>
<a href="#l21.113"></a><span id="l21.113" class="difflineplus">+    for each (let [, collection] in</span>
<a href="#l21.114"></a><span id="l21.114" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l21.115"></a><span id="l21.115" class="difflineplus">+      let removeItems = [item</span>
<a href="#l21.116"></a><span id="l21.116" class="difflineplus">+                         for each ([, item] in Iterator(collection.items))</span>
<a href="#l21.117"></a><span id="l21.117" class="difflineplus">+                         if (aFilter(item))];</span>
<a href="#l21.118"></a><span id="l21.118">       if (removeItems.length)</span>
<a href="#l21.119"></a><span id="l21.119">         collection._onItemsRemoved(removeItems);</span>
<a href="#l21.120"></a><span id="l21.120">     }</span>
<a href="#l21.121"></a><span id="l21.121">   },</span>
<a href="#l21.122"></a><span id="l21.122"> };</span>
<a href="#l21.123"></a><span id="l21.123"> </span>
<a href="#l21.124"></a><span id="l21.124"> /**</span>
<a href="#l21.125"></a><span id="l21.125">  * @class A current view of the set of first-class nouns meeting a given query.</span>
<a href="#l21.126"></a><span id="l21.126" class="difflineat">@@ -578,17 +636,17 @@ GlodaCollection.prototype = {</span>
<a href="#l21.127"></a><span id="l21.127">     let items = this.items;</span>
<a href="#l21.128"></a><span id="l21.128">     // in-place filter.  probably needless optimization.</span>
<a href="#l21.129"></a><span id="l21.129">     let iWrite=0;</span>
<a href="#l21.130"></a><span id="l21.130">     for (let iRead = 0; iRead &lt; items.length; iRead++) {</span>
<a href="#l21.131"></a><span id="l21.131">       let item = items[iRead];</span>
<a href="#l21.132"></a><span id="l21.132">       if (!(item.id in deleteMap))</span>
<a href="#l21.133"></a><span id="l21.133">         items[iWrite++] = item;</span>
<a href="#l21.134"></a><span id="l21.134">     }</span>
<a href="#l21.135"></a><span id="l21.135" class="difflineminus">-    items.slice(iWrite);</span>
<a href="#l21.136"></a><span id="l21.136" class="difflineplus">+    items.splice(iWrite);</span>
<a href="#l21.137"></a><span id="l21.137"> </span>
<a href="#l21.138"></a><span id="l21.138">     if (this._listener) {</span>
<a href="#l21.139"></a><span id="l21.139">       try {</span>
<a href="#l21.140"></a><span id="l21.140">         this._listener.onItemsRemoved(aItems, this);</span>
<a href="#l21.141"></a><span id="l21.141">       }</span>
<a href="#l21.142"></a><span id="l21.142">       catch (ex) {</span>
<a href="#l21.143"></a><span id="l21.143">         LOG.error(&quot;caught exception from listener in onItemsRemoved: &quot; +</span>
<a href="#l21.144"></a><span id="l21.144">             ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l21.145"></a><span id="l21.145" class="difflineat">@@ -716,17 +774,17 @@ GlodaLRUCacheCollection.prototype.delete</span>
<a href="#l21.146"></a><span id="l21.146">   delete aItem._lruPrev;</span>
<a href="#l21.147"></a><span id="l21.147"> </span>
<a href="#l21.148"></a><span id="l21.148">   // nuke from our id map</span>
<a href="#l21.149"></a><span id="l21.149">   delete this._idMap[aItem.id];</span>
<a href="#l21.150"></a><span id="l21.150">   if (this._uniqueValueMap)</span>
<a href="#l21.151"></a><span id="l21.151">     delete this._uniqueValueMap[aItem.uniqueValue];</span>
<a href="#l21.152"></a><span id="l21.152"> </span>
<a href="#l21.153"></a><span id="l21.153">   this._size--;</span>
<a href="#l21.154"></a><span id="l21.154" class="difflineminus">-}</span>
<a href="#l21.155"></a><span id="l21.155" class="difflineplus">+};</span>
<a href="#l21.156"></a><span id="l21.156"> </span>
<a href="#l21.157"></a><span id="l21.157"> /**</span>
<a href="#l21.158"></a><span id="l21.158">  * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l21.159"></a><span id="l21.159">  *  dirty.</span>
<a href="#l21.160"></a><span id="l21.160">  */</span>
<a href="#l21.161"></a><span id="l21.161"> GlodaLRUCacheCollection.prototype.commitDirty = function cache_commitDirty() {</span>
<a href="#l21.162"></a><span id="l21.162">   // we can only do this if there is an update method available...</span>
<a href="#l21.163"></a><span id="l21.163">   if (!this._nounDef.objUpdate)</span>
<a href="#l21.164"></a><span id="l21.164" class="difflineat">@@ -734,9 +792,9 @@ GlodaLRUCacheCollection.prototype.commit</span>
<a href="#l21.165"></a><span id="l21.165"> </span>
<a href="#l21.166"></a><span id="l21.166">   for each (let [iItem, item] in Iterator(this._idMap)) {</span>
<a href="#l21.167"></a><span id="l21.167">     if (item.dirty) {</span>
<a href="#l21.168"></a><span id="l21.168">       LOG.debug(&quot;flushing dirty: &quot; + item);</span>
<a href="#l21.169"></a><span id="l21.169">       this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l21.170"></a><span id="l21.170">       delete item.dirty;</span>
<a href="#l21.171"></a><span id="l21.171">     }</span>
<a href="#l21.172"></a><span id="l21.172">   }</span>
<a href="#l21.173"></a><span id="l21.173" class="difflineminus">-}</span>
<a href="#l21.174"></a><span id="l21.174" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -54,30 +54,32 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l22.4"></a><span id="l22.4">  *  stores the information in the database relating to this attribute</span>
<a href="#l22.5"></a><span id="l22.5">  *  definition.  Access its attrDef attribute to get at the realy juicy data.</span>
<a href="#l22.6"></a><span id="l22.6">  *  This main interesting thing this class does is serve as the keeper of the</span>
<a href="#l22.7"></a><span id="l22.7">  *  mapping from parameters to attribute ids in the database if this is a</span>
<a href="#l22.8"></a><span id="l22.8">  *  parameterized attribute.</span>
<a href="#l22.9"></a><span id="l22.9">  */</span>
<a href="#l22.10"></a><span id="l22.10"> function GlodaAttributeDBDef(aDatastore, aID, aCompoundName, aAttrType,</span>
<a href="#l22.11"></a><span id="l22.11">                            aPluginName, aAttrName) {</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-  this._datastore = aDatastore;</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+  // _datastore is now set on the prototype by GlodaDatastore</span>
<a href="#l22.14"></a><span id="l22.14">   this._id = aID;</span>
<a href="#l22.15"></a><span id="l22.15">   this._compoundName = aCompoundName;</span>
<a href="#l22.16"></a><span id="l22.16">   this._attrType = aAttrType;</span>
<a href="#l22.17"></a><span id="l22.17">   this._pluginName = aPluginName;</span>
<a href="#l22.18"></a><span id="l22.18">   this._attrName = aAttrName;</span>
<a href="#l22.19"></a><span id="l22.19"> </span>
<a href="#l22.20"></a><span id="l22.20">   this.attrDef = null;</span>
<a href="#l22.21"></a><span id="l22.21"> </span>
<a href="#l22.22"></a><span id="l22.22">   /** Map parameter values to the underlying database id. */</span>
<a href="#l22.23"></a><span id="l22.23">   this._parameterBindings = {};</span>
<a href="#l22.24"></a><span id="l22.24"> }</span>
<a href="#l22.25"></a><span id="l22.25"> </span>
<a href="#l22.26"></a><span id="l22.26"> GlodaAttributeDBDef.prototype = {</span>
<a href="#l22.27"></a><span id="l22.27" class="difflineplus">+  // set by GlodaDatastore</span>
<a href="#l22.28"></a><span id="l22.28" class="difflineplus">+  _datastore: null,</span>
<a href="#l22.29"></a><span id="l22.29">   get id() { return this._id; },</span>
<a href="#l22.30"></a><span id="l22.30">   get attributeName() { return this._attrName; },</span>
<a href="#l22.31"></a><span id="l22.31"> </span>
<a href="#l22.32"></a><span id="l22.32">   get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l22.33"></a><span id="l22.33"> </span>
<a href="#l22.34"></a><span id="l22.34">   /**</span>
<a href="#l22.35"></a><span id="l22.35">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l22.36"></a><span id="l22.36">    *  attribute-parameter as an attribute.</span>
<a href="#l22.37"></a><span id="l22.37" class="difflineat">@@ -177,25 +179,27 @@ function MixIn(aConstructor, aMixIn) {</span>
<a href="#l22.38"></a><span id="l22.38">   }</span>
<a href="#l22.39"></a><span id="l22.39"> }</span>
<a href="#l22.40"></a><span id="l22.40"> </span>
<a href="#l22.41"></a><span id="l22.41"> /**</span>
<a href="#l22.42"></a><span id="l22.42">  * @class A gloda conversation (thread) exists so that messages can belong.</span>
<a href="#l22.43"></a><span id="l22.43">  */</span>
<a href="#l22.44"></a><span id="l22.44"> function GlodaConversation(aDatastore, aID, aSubject, aOldestMessageDate,</span>
<a href="#l22.45"></a><span id="l22.45">                            aNewestMessageDate) {</span>
<a href="#l22.46"></a><span id="l22.46" class="difflineminus">-  this._datastore = aDatastore;</span>
<a href="#l22.47"></a><span id="l22.47" class="difflineplus">+  // _datastore is now set on the prototype by GlodaDatastore</span>
<a href="#l22.48"></a><span id="l22.48">   this._id = aID;</span>
<a href="#l22.49"></a><span id="l22.49">   this._subject = aSubject;</span>
<a href="#l22.50"></a><span id="l22.50">   this._oldestMessageDate = aOldestMessageDate;</span>
<a href="#l22.51"></a><span id="l22.51">   this._newestMessageDate = aNewestMessageDate;</span>
<a href="#l22.52"></a><span id="l22.52"> }</span>
<a href="#l22.53"></a><span id="l22.53"> </span>
<a href="#l22.54"></a><span id="l22.54"> GlodaConversation.prototype = {</span>
<a href="#l22.55"></a><span id="l22.55">   NOUN_ID: 101,</span>
<a href="#l22.56"></a><span id="l22.56" class="difflineplus">+  // set by GlodaDatastore</span>
<a href="#l22.57"></a><span id="l22.57" class="difflineplus">+  _datastore: null,</span>
<a href="#l22.58"></a><span id="l22.58">   get id() { return this._id; },</span>
<a href="#l22.59"></a><span id="l22.59">   get subject() { return this._subject; },</span>
<a href="#l22.60"></a><span id="l22.60">   get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l22.61"></a><span id="l22.61">   get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l22.62"></a><span id="l22.62"> </span>
<a href="#l22.63"></a><span id="l22.63">   getMessagesCollection: function gloda_conversation_getMessagesCollection(</span>
<a href="#l22.64"></a><span id="l22.64">     aListener, aData) {</span>
<a href="#l22.65"></a><span id="l22.65">     let query = new GlodaMessage.prototype.NOUN_DEF.queryClass();</span>
<a href="#l22.66"></a><span id="l22.66" class="difflineat">@@ -209,30 +213,33 @@ GlodaConversation.prototype = {</span>
<a href="#l22.67"></a><span id="l22.67"> </span>
<a href="#l22.68"></a><span id="l22.68">   toLocaleString: function gloda_conversation_toLocaleString() {</span>
<a href="#l22.69"></a><span id="l22.69">     return this._subject;</span>
<a href="#l22.70"></a><span id="l22.70">   }</span>
<a href="#l22.71"></a><span id="l22.71"> };</span>
<a href="#l22.72"></a><span id="l22.72"> </span>
<a href="#l22.73"></a><span id="l22.73"> function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName,</span>
<a href="#l22.74"></a><span id="l22.74">                      aIndexingPriority) {</span>
<a href="#l22.75"></a><span id="l22.75" class="difflineminus">-  this._datastore = aDatastore;</span>
<a href="#l22.76"></a><span id="l22.76" class="difflineplus">+  // _datastore is now set by GlodaDatastore</span>
<a href="#l22.77"></a><span id="l22.77">   this._id = aID;</span>
<a href="#l22.78"></a><span id="l22.78">   this._uri = aURI;</span>
<a href="#l22.79"></a><span id="l22.79">   this._dirtyStatus = aDirtyStatus;</span>
<a href="#l22.80"></a><span id="l22.80">   this._prettyName = aPrettyName;</span>
<a href="#l22.81"></a><span id="l22.81">   this._xpcomFolder = null;</span>
<a href="#l22.82"></a><span id="l22.82">   this._activeIndexing = false;</span>
<a href="#l22.83"></a><span id="l22.83">   this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l22.84"></a><span id="l22.84">   this._indexingPriority = aIndexingPriority;</span>
<a href="#l22.85"></a><span id="l22.85">   this._deleted = false;</span>
<a href="#l22.86"></a><span id="l22.86" class="difflineplus">+  this._compacting = false;</span>
<a href="#l22.87"></a><span id="l22.87"> }</span>
<a href="#l22.88"></a><span id="l22.88"> </span>
<a href="#l22.89"></a><span id="l22.89"> GlodaFolder.prototype = {</span>
<a href="#l22.90"></a><span id="l22.90">   NOUN_ID: 100,</span>
<a href="#l22.91"></a><span id="l22.91" class="difflineplus">+  // set by GlodaDatastore</span>
<a href="#l22.92"></a><span id="l22.92" class="difflineplus">+  _datastore: null,</span>
<a href="#l22.93"></a><span id="l22.93"> </span>
<a href="#l22.94"></a><span id="l22.94">   /** The folder is believed to be up-to-date */</span>
<a href="#l22.95"></a><span id="l22.95">   kFolderClean: 0,</span>
<a href="#l22.96"></a><span id="l22.96">   /** The folder has some un-indexed or dirty messages */</span>
<a href="#l22.97"></a><span id="l22.97">   kFolderDirty: 1,</span>
<a href="#l22.98"></a><span id="l22.98">   /** The folder needs to be entirely re-indexed, regardless of the flags on</span>
<a href="#l22.99"></a><span id="l22.99">    * the messages in the folder. This state will be downgraded to dirty */</span>
<a href="#l22.100"></a><span id="l22.100">   kFolderFilthy: 2,</span>
<a href="#l22.101"></a><span id="l22.101" class="difflineat">@@ -392,33 +399,48 @@ GlodaFolder.prototype = {</span>
<a href="#l22.102"></a><span id="l22.102">       //  not, this needs to be reset to 0 too.</span>
<a href="#l22.103"></a><span id="l22.103">       this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l22.104"></a><span id="l22.104">     }</span>
<a href="#l22.105"></a><span id="l22.105"> </span>
<a href="#l22.106"></a><span id="l22.106">     return true;</span>
<a href="#l22.107"></a><span id="l22.107">   },</span>
<a href="#l22.108"></a><span id="l22.108"> </span>
<a href="#l22.109"></a><span id="l22.109">   /**</span>
<a href="#l22.110"></a><span id="l22.110" class="difflineplus">+   * Indicate whether this folder is currently being compacted.  The</span>
<a href="#l22.111"></a><span id="l22.111" class="difflineplus">+   *  |GlodaMsgIndexer| keeps this in-memory-only value up-to-date.</span>
<a href="#l22.112"></a><span id="l22.112" class="difflineplus">+   */</span>
<a href="#l22.113"></a><span id="l22.113" class="difflineplus">+  get compacting gloda_folder_get_compacting() {</span>
<a href="#l22.114"></a><span id="l22.114" class="difflineplus">+    return this._compacting;</span>
<a href="#l22.115"></a><span id="l22.115" class="difflineplus">+  },</span>
<a href="#l22.116"></a><span id="l22.116" class="difflineplus">+  /**</span>
<a href="#l22.117"></a><span id="l22.117" class="difflineplus">+   * Set whether this folder is currently being compacted.  This is really only</span>
<a href="#l22.118"></a><span id="l22.118" class="difflineplus">+   *  for the |GlodaMsgIndexer| to set.</span>
<a href="#l22.119"></a><span id="l22.119" class="difflineplus">+   */</span>
<a href="#l22.120"></a><span id="l22.120" class="difflineplus">+  set compacting gloda_folder_set_compacting(aCompacting) {</span>
<a href="#l22.121"></a><span id="l22.121" class="difflineplus">+    this._compacting = aCompacting;</span>
<a href="#l22.122"></a><span id="l22.122" class="difflineplus">+  },</span>
<a href="#l22.123"></a><span id="l22.123" class="difflineplus">+</span>
<a href="#l22.124"></a><span id="l22.124" class="difflineplus">+  /**</span>
<a href="#l22.125"></a><span id="l22.125">    * Return the string associated with this account.</span>
<a href="#l22.126"></a><span id="l22.126">    */</span>
<a href="#l22.127"></a><span id="l22.127">   get accountLabel() {</span>
<a href="#l22.128"></a><span id="l22.128">     let msgFolder = this.getXPCOMFolder(this.kActivityFolderOnlyNoData);</span>
<a href="#l22.129"></a><span id="l22.129">     return msgFolder.server.prettyName;</span>
<a href="#l22.130"></a><span id="l22.130">   }</span>
<a href="#l22.131"></a><span id="l22.131"> };</span>
<a href="#l22.132"></a><span id="l22.132"> </span>
<a href="#l22.133"></a><span id="l22.133"> /**</span>
<a href="#l22.134"></a><span id="l22.134">  * @class A message representation.</span>
<a href="#l22.135"></a><span id="l22.135">  */</span>
<a href="#l22.136"></a><span id="l22.136"> function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l22.137"></a><span id="l22.137">                       aConversationID, aConversation, aDate,</span>
<a href="#l22.138"></a><span id="l22.138">                       aHeaderMessageID, aDeleted, aJsonText,</span>
<a href="#l22.139"></a><span id="l22.139">                       aNotability,</span>
<a href="#l22.140"></a><span id="l22.140">                       aSubject, aIndexedBodyText, aAttachmentNames) {</span>
<a href="#l22.141"></a><span id="l22.141" class="difflineminus">-  this._datastore = aDatastore;</span>
<a href="#l22.142"></a><span id="l22.142" class="difflineplus">+  // _datastore is now set on the prototype by GlodaDatastore</span>
<a href="#l22.143"></a><span id="l22.143">   this._id = aID;</span>
<a href="#l22.144"></a><span id="l22.144">   this._folderID = aFolderID;</span>
<a href="#l22.145"></a><span id="l22.145">   this._messageKey = aMessageKey;</span>
<a href="#l22.146"></a><span id="l22.146">   this._conversationID = aConversationID;</span>
<a href="#l22.147"></a><span id="l22.147">   this._conversation = aConversation;</span>
<a href="#l22.148"></a><span id="l22.148">   this._date = aDate;</span>
<a href="#l22.149"></a><span id="l22.149">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l22.150"></a><span id="l22.150">   this._jsonText = aJsonText;</span>
<a href="#l22.151"></a><span id="l22.151" class="difflineat">@@ -430,16 +452,18 @@ function GlodaMessage(aDatastore, aID, a</span>
<a href="#l22.152"></a><span id="l22.152">   // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l22.153"></a><span id="l22.153">   //  speaking for us.</span>
<a href="#l22.154"></a><span id="l22.154">   if (aDeleted)</span>
<a href="#l22.155"></a><span id="l22.155">     this._deleted = aDeleted;</span>
<a href="#l22.156"></a><span id="l22.156"> }</span>
<a href="#l22.157"></a><span id="l22.157"> </span>
<a href="#l22.158"></a><span id="l22.158"> GlodaMessage.prototype = {</span>
<a href="#l22.159"></a><span id="l22.159">   NOUN_ID: 102,</span>
<a href="#l22.160"></a><span id="l22.160" class="difflineplus">+  // set by GlodaDatastore</span>
<a href="#l22.161"></a><span id="l22.161" class="difflineplus">+  _datastore: null,</span>
<a href="#l22.162"></a><span id="l22.162">   get id() { return this._id; },</span>
<a href="#l22.163"></a><span id="l22.163">   get folderID() { return this._folderID; },</span>
<a href="#l22.164"></a><span id="l22.164">   get messageKey() { return this._messageKey; },</span>
<a href="#l22.165"></a><span id="l22.165">   get conversationID() { return this._conversationID; },</span>
<a href="#l22.166"></a><span id="l22.166">   // conversation is special</span>
<a href="#l22.167"></a><span id="l22.167">   get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l22.168"></a><span id="l22.168">   get notability() { return this._notability; },</span>
<a href="#l22.169"></a><span id="l22.169">   set notability(aNotability) { this._notability = aNotability; },</span>
<a href="#l22.170"></a><span id="l22.170" class="difflineat">@@ -478,37 +502,37 @@ GlodaMessage.prototype = {</span>
<a href="#l22.171"></a><span id="l22.171">   },</span>
<a href="#l22.172"></a><span id="l22.172"> </span>
<a href="#l22.173"></a><span id="l22.173">   toString: function gloda_message_toString() {</span>
<a href="#l22.174"></a><span id="l22.174">     // uh, this is a tough one...</span>
<a href="#l22.175"></a><span id="l22.175">     return &quot;Message:&quot; + this._id;</span>
<a href="#l22.176"></a><span id="l22.176">   },</span>
<a href="#l22.177"></a><span id="l22.177"> </span>
<a href="#l22.178"></a><span id="l22.178">   _clone: function gloda_message_clone() {</span>
<a href="#l22.179"></a><span id="l22.179" class="difflineminus">-    return new GlodaMessage(this._datastore, this._id, this._folderID,</span>
<a href="#l22.180"></a><span id="l22.180" class="difflineplus">+    return new GlodaMessage(/* datastore */ null, this._id, this._folderID,</span>
<a href="#l22.181"></a><span id="l22.181">       this._messageKey, this._conversationID, this._conversation, this._date,</span>
<a href="#l22.182"></a><span id="l22.182">       this._headerMessageID, this._deleted, this._jsonText, this._notability,</span>
<a href="#l22.183"></a><span id="l22.183">       this._subject, this._indexedBodyText, this._attachmentNames);</span>
<a href="#l22.184"></a><span id="l22.184">   },</span>
<a href="#l22.185"></a><span id="l22.185"> </span>
<a href="#l22.186"></a><span id="l22.186">   _ghost: function gloda_message_ghost() {</span>
<a href="#l22.187"></a><span id="l22.187">     this._folderID = null;</span>
<a href="#l22.188"></a><span id="l22.188">     this._messageKey = null;</span>
<a href="#l22.189"></a><span id="l22.189" class="difflineplus">+    // a ghost is not deleted</span>
<a href="#l22.190"></a><span id="l22.190" class="difflineplus">+    this._deleted = false;</span>
<a href="#l22.191"></a><span id="l22.191">   },</span>
<a href="#l22.192"></a><span id="l22.192"> </span>
<a href="#l22.193"></a><span id="l22.193">   _nuke: function gloda_message_nuke() {</span>
<a href="#l22.194"></a><span id="l22.194">     this._id = null;</span>
<a href="#l22.195"></a><span id="l22.195">     this._folderID = null;</span>
<a href="#l22.196"></a><span id="l22.196">     this._messageKey = null;</span>
<a href="#l22.197"></a><span id="l22.197">     this._conversationID = null;</span>
<a href="#l22.198"></a><span id="l22.198">     this._conversation = null;</span>
<a href="#l22.199"></a><span id="l22.199">     this.date = null;</span>
<a href="#l22.200"></a><span id="l22.200">     this._headerMessageID = null;</span>
<a href="#l22.201"></a><span id="l22.201" class="difflineminus">-</span>
<a href="#l22.202"></a><span id="l22.202" class="difflineminus">-    this._datastore = null;</span>
<a href="#l22.203"></a><span id="l22.203">   },</span>
<a href="#l22.204"></a><span id="l22.204"> </span>
<a href="#l22.205"></a><span id="l22.205">   /**</span>
<a href="#l22.206"></a><span id="l22.206">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l22.207"></a><span id="l22.207">    *  null if the message does not exist for one reason or another.  We may log</span>
<a href="#l22.208"></a><span id="l22.208">    *  to our logger in the failure cases.</span>
<a href="#l22.209"></a><span id="l22.209">    *</span>
<a href="#l22.210"></a><span id="l22.210">    * This method no longer caches the result, so if you need to hold onto it,</span>
<a href="#l22.211"></a><span id="l22.211" class="difflineat">@@ -576,31 +600,33 @@ GlodaMessage.prototype = {</span>
<a href="#l22.212"></a><span id="l22.212"> MixIn(GlodaMessage, GlodaHasAttributesMixIn);</span>
<a href="#l22.213"></a><span id="l22.213"> </span>
<a href="#l22.214"></a><span id="l22.214"> /**</span>
<a href="#l22.215"></a><span id="l22.215">  * @class Contacts correspond to people (one per person), and may own multiple</span>
<a href="#l22.216"></a><span id="l22.216">  *  identities (e-mail address, IM account, etc.)</span>
<a href="#l22.217"></a><span id="l22.217">  */</span>
<a href="#l22.218"></a><span id="l22.218"> function GlodaContact(aDatastore, aID, aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l22.219"></a><span id="l22.219">                       aPopularity, aFrecency, aJsonText) {</span>
<a href="#l22.220"></a><span id="l22.220" class="difflineminus">-  this._datastore = aDatastore;</span>
<a href="#l22.221"></a><span id="l22.221" class="difflineplus">+  // _datastore set on the prototype by GlodaDatastore</span>
<a href="#l22.222"></a><span id="l22.222">   this._id = aID;</span>
<a href="#l22.223"></a><span id="l22.223">   this._directoryUUID = aDirectoryUUID;</span>
<a href="#l22.224"></a><span id="l22.224">   this._contactUUID = aContactUUID;</span>
<a href="#l22.225"></a><span id="l22.225">   this._name = aName;</span>
<a href="#l22.226"></a><span id="l22.226">   this._popularity = aPopularity;</span>
<a href="#l22.227"></a><span id="l22.227">   this._frecency = aFrecency;</span>
<a href="#l22.228"></a><span id="l22.228">   if (aJsonText)</span>
<a href="#l22.229"></a><span id="l22.229">     this._jsonText = aJsonText;</span>
<a href="#l22.230"></a><span id="l22.230"> </span>
<a href="#l22.231"></a><span id="l22.231">   this._identities = null;</span>
<a href="#l22.232"></a><span id="l22.232"> }</span>
<a href="#l22.233"></a><span id="l22.233"> </span>
<a href="#l22.234"></a><span id="l22.234"> GlodaContact.prototype = {</span>
<a href="#l22.235"></a><span id="l22.235">   NOUN_ID: 103,</span>
<a href="#l22.236"></a><span id="l22.236" class="difflineplus">+  // set by GlodaDatastore</span>
<a href="#l22.237"></a><span id="l22.237" class="difflineplus">+  _datastore: null,</span>
<a href="#l22.238"></a><span id="l22.238"> </span>
<a href="#l22.239"></a><span id="l22.239">   get id() { return this._id; },</span>
<a href="#l22.240"></a><span id="l22.240">   get directoryUUID() { return this._directoryUUID; },</span>
<a href="#l22.241"></a><span id="l22.241">   get contactUUID() { return this._contactUUID; },</span>
<a href="#l22.242"></a><span id="l22.242">   get name() { return this._name; },</span>
<a href="#l22.243"></a><span id="l22.243">   set name(aName) { this._name = aName; },</span>
<a href="#l22.244"></a><span id="l22.244"> </span>
<a href="#l22.245"></a><span id="l22.245">   get popularity() { return this._popularity; },</span>
<a href="#l22.246"></a><span id="l22.246" class="difflineat">@@ -623,44 +649,46 @@ GlodaContact.prototype = {</span>
<a href="#l22.247"></a><span id="l22.247">     return &quot;Contact:&quot; + this._id;</span>
<a href="#l22.248"></a><span id="l22.248">   },</span>
<a href="#l22.249"></a><span id="l22.249"> </span>
<a href="#l22.250"></a><span id="l22.250">   get accessibleLabel() {</span>
<a href="#l22.251"></a><span id="l22.251">     return &quot;Contact: &quot; + this._name;</span>
<a href="#l22.252"></a><span id="l22.252">   },</span>
<a href="#l22.253"></a><span id="l22.253"> </span>
<a href="#l22.254"></a><span id="l22.254">   _clone: function gloda_contact_clone() {</span>
<a href="#l22.255"></a><span id="l22.255" class="difflineminus">-    return new GlodaContact(this._datastore, this._id, this._directoryUUID,</span>
<a href="#l22.256"></a><span id="l22.256" class="difflineplus">+    return new GlodaContact(/* datastore */ null, this._id, this._directoryUUID,</span>
<a href="#l22.257"></a><span id="l22.257">       this._contactUUID, this._name, this._popularity, this._frecency);</span>
<a href="#l22.258"></a><span id="l22.258">   },</span>
<a href="#l22.259"></a><span id="l22.259"> };</span>
<a href="#l22.260"></a><span id="l22.260"> MixIn(GlodaContact, GlodaHasAttributesMixIn);</span>
<a href="#l22.261"></a><span id="l22.261"> </span>
<a href="#l22.262"></a><span id="l22.262"> </span>
<a href="#l22.263"></a><span id="l22.263"> /**</span>
<a href="#l22.264"></a><span id="l22.264">  * @class A specific means of communication for a contact.</span>
<a href="#l22.265"></a><span id="l22.265">  */</span>
<a href="#l22.266"></a><span id="l22.266"> function GlodaIdentity(aDatastore, aID, aContactID, aContact, aKind, aValue,</span>
<a href="#l22.267"></a><span id="l22.267">                        aDescription, aIsRelay) {</span>
<a href="#l22.268"></a><span id="l22.268" class="difflineminus">-  this._datastore = aDatastore;</span>
<a href="#l22.269"></a><span id="l22.269" class="difflineplus">+  // _datastore set on the prototype by GlodaDatastore</span>
<a href="#l22.270"></a><span id="l22.270">   this._id = aID;</span>
<a href="#l22.271"></a><span id="l22.271">   this._contactID = aContactID;</span>
<a href="#l22.272"></a><span id="l22.272">   this._contact = aContact;</span>
<a href="#l22.273"></a><span id="l22.273">   this._kind = aKind;</span>
<a href="#l22.274"></a><span id="l22.274">   this._value = aValue;</span>
<a href="#l22.275"></a><span id="l22.275">   this._description = aDescription;</span>
<a href="#l22.276"></a><span id="l22.276">   this._isRelay = aIsRelay;</span>
<a href="#l22.277"></a><span id="l22.277">   /// Cached indication of whether there is an address book card for this</span>
<a href="#l22.278"></a><span id="l22.278">   ///  identity.  We keep this up-to-date via address book listener</span>
<a href="#l22.279"></a><span id="l22.279">   ///  notifications in |GlodaABIndexer|.</span>
<a href="#l22.280"></a><span id="l22.280">   this._hasAddressBookCard = undefined;</span>
<a href="#l22.281"></a><span id="l22.281"> }</span>
<a href="#l22.282"></a><span id="l22.282"> </span>
<a href="#l22.283"></a><span id="l22.283"> GlodaIdentity.prototype = {</span>
<a href="#l22.284"></a><span id="l22.284">   NOUN_ID: 104,</span>
<a href="#l22.285"></a><span id="l22.285" class="difflineplus">+  // set by GlodaDatastore</span>
<a href="#l22.286"></a><span id="l22.286" class="difflineplus">+  _datastore: null,</span>
<a href="#l22.287"></a><span id="l22.287">   get id() { return this._id; },</span>
<a href="#l22.288"></a><span id="l22.288">   get contactID() { return this._contactID; },</span>
<a href="#l22.289"></a><span id="l22.289">   get contact() { return this._contact; },</span>
<a href="#l22.290"></a><span id="l22.290">   get kind() { return this._kind; },</span>
<a href="#l22.291"></a><span id="l22.291">   get value() { return this._value; },</span>
<a href="#l22.292"></a><span id="l22.292">   get description() { return this._description; },</span>
<a href="#l22.293"></a><span id="l22.293">   get isRelay() { return this._isRelay; },</span>
<a href="#l22.294"></a><span id="l22.294"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -51,27 +51,31 @@ const Cu = Components.utils;</span>
<a href="#l23.4"></a><span id="l23.4"> Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l23.5"></a><span id="l23.5"> </span>
<a href="#l23.6"></a><span id="l23.6"> Cu.import(&quot;resource://app/modules/gloda/datamodel.js&quot;);</span>
<a href="#l23.7"></a><span id="l23.7"> Cu.import(&quot;resource://app/modules/gloda/databind.js&quot;);</span>
<a href="#l23.8"></a><span id="l23.8"> Cu.import(&quot;resource://app/modules/gloda/collection.js&quot;);</span>
<a href="#l23.9"></a><span id="l23.9"> </span>
<a href="#l23.10"></a><span id="l23.10"> let PCH_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.pch&quot;);</span>
<a href="#l23.11"></a><span id="l23.11"> </span>
<a href="#l23.12"></a><span id="l23.12" class="difflineplus">+/**</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+ * Commit async handler; hands off the notification to</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+ *  |GlodaDatastore._asyncCompleted|.</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+ */</span>
<a href="#l23.16"></a><span id="l23.16"> function PostCommitHandler(aCallbacks) {</span>
<a href="#l23.17"></a><span id="l23.17">   this.callbacks = aCallbacks;</span>
<a href="#l23.18"></a><span id="l23.18">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l23.19"></a><span id="l23.19"> }</span>
<a href="#l23.20"></a><span id="l23.20"> </span>
<a href="#l23.21"></a><span id="l23.21"> PostCommitHandler.prototype = {</span>
<a href="#l23.22"></a><span id="l23.22">   handleResult: function gloda_ds_pch_handleResult(aResultSet) {</span>
<a href="#l23.23"></a><span id="l23.23">   },</span>
<a href="#l23.24"></a><span id="l23.24"> </span>
<a href="#l23.25"></a><span id="l23.25">   handleError: function gloda_ds_pch_handleError(aError) {</span>
<a href="#l23.26"></a><span id="l23.26" class="difflineminus">-    PCH_LOG.error(&quot;database error:&quot; + aError)</span>
<a href="#l23.27"></a><span id="l23.27" class="difflineplus">+    PCH_LOG.error(&quot;database error:&quot; + aError);</span>
<a href="#l23.28"></a><span id="l23.28">   },</span>
<a href="#l23.29"></a><span id="l23.29"> </span>
<a href="#l23.30"></a><span id="l23.30">   handleCompletion: function gloda_ds_pch_handleCompletion(aReason) {</span>
<a href="#l23.31"></a><span id="l23.31">     // just outright bail if we are shutdown</span>
<a href="#l23.32"></a><span id="l23.32">     if (GlodaDatastore.datastoreIsShutdown)</span>
<a href="#l23.33"></a><span id="l23.33">       return;</span>
<a href="#l23.34"></a><span id="l23.34"> </span>
<a href="#l23.35"></a><span id="l23.35">     if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {</span>
<a href="#l23.36"></a><span id="l23.36" class="difflineat">@@ -92,16 +96,28 @@ PostCommitHandler.prototype = {</span>
<a href="#l23.37"></a><span id="l23.37">       PCH_LOG.error(&quot;Exception in handleCompletion: &quot; + e);</span>
<a href="#l23.38"></a><span id="l23.38">     }</span>
<a href="#l23.39"></a><span id="l23.39"> </span>
<a href="#l23.40"></a><span id="l23.40">   }</span>
<a href="#l23.41"></a><span id="l23.41"> };</span>
<a href="#l23.42"></a><span id="l23.42"> </span>
<a href="#l23.43"></a><span id="l23.43"> let QFQ_LOG = Log4Moz.repository.getLogger(&quot;gloda.ds.qfq&quot;);</span>
<a href="#l23.44"></a><span id="l23.44"> </span>
<a href="#l23.45"></a><span id="l23.45" class="difflineplus">+/**</span>
<a href="#l23.46"></a><span id="l23.46" class="difflineplus">+ * Singleton collection listener used by |QueryFromQueryCallback| to assist in</span>
<a href="#l23.47"></a><span id="l23.47" class="difflineplus">+ *  the loading of referenced noun instances.  Which is to say, messages have</span>
<a href="#l23.48"></a><span id="l23.48" class="difflineplus">+ *  identities (specific e-mail addresses) associated with them via attributes.</span>
<a href="#l23.49"></a><span id="l23.49" class="difflineplus">+ *  And these identities in turn reference / are referenced by contacts (the</span>
<a href="#l23.50"></a><span id="l23.50" class="difflineplus">+ *  notion of a person).</span>
<a href="#l23.51"></a><span id="l23.51" class="difflineplus">+ *</span>
<a href="#l23.52"></a><span id="l23.52" class="difflineplus">+ * This listener is primarily concerned with fixing up the references in each</span>
<a href="#l23.53"></a><span id="l23.53" class="difflineplus">+ *  noun instance to its referenced instances once they have been loaded.  It</span>
<a href="#l23.54"></a><span id="l23.54" class="difflineplus">+ *  also deals with caching so that our identity invariant is maintained: user</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineplus">+ *  code should only ever see one distinct instance of a thing at a time.</span>
<a href="#l23.56"></a><span id="l23.56" class="difflineplus">+ */</span>
<a href="#l23.57"></a><span id="l23.57"> let QueryFromQueryResolver = {</span>
<a href="#l23.58"></a><span id="l23.58">   onItemsAdded: function(aIgnoredItems, aCollection, aFake) {</span>
<a href="#l23.59"></a><span id="l23.59">     let originColl = aCollection.dataStack ? aCollection.dataStack.pop()</span>
<a href="#l23.60"></a><span id="l23.60">                                            : aCollection.data;</span>
<a href="#l23.61"></a><span id="l23.61">     //QFQ_LOG.debug(&quot;QFQR: originColl: &quot; + originColl);</span>
<a href="#l23.62"></a><span id="l23.62">     if (aCollection.completionShifter)</span>
<a href="#l23.63"></a><span id="l23.63">       aCollection.completionShifter.push(originColl);</span>
<a href="#l23.64"></a><span id="l23.64">     else</span>
<a href="#l23.65"></a><span id="l23.65" class="difflineat">@@ -156,18 +172,27 @@ let QueryFromQueryResolver = {</span>
<a href="#l23.66"></a><span id="l23.66">     //  originColl._nounDef.name);</span>
<a href="#l23.67"></a><span id="l23.67">     if (originColl.deferredCount &lt;= 0) {</span>
<a href="#l23.68"></a><span id="l23.68">       originColl._onQueryCompleted();</span>
<a href="#l23.69"></a><span id="l23.69">     }</span>
<a href="#l23.70"></a><span id="l23.70">   },</span>
<a href="#l23.71"></a><span id="l23.71"> };</span>
<a href="#l23.72"></a><span id="l23.72"> </span>
<a href="#l23.73"></a><span id="l23.73"> /**</span>
<a href="#l23.74"></a><span id="l23.74" class="difflineminus">- * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l23.75"></a><span id="l23.75" class="difflineminus">- * @constructor</span>
<a href="#l23.76"></a><span id="l23.76" class="difflineplus">+ * Handles the results from a GlodaDatastore.queryFromQuery call in cooperation</span>
<a href="#l23.77"></a><span id="l23.77" class="difflineplus">+ *  with the |QueryFromQueryResolver| collection listener.  We do a lot of</span>
<a href="#l23.78"></a><span id="l23.78" class="difflineplus">+ *  legwork related to satisfying references to other noun instances on the</span>
<a href="#l23.79"></a><span id="l23.79" class="difflineplus">+ *  noun instances the user directy queried.  Messages reference identities</span>
<a href="#l23.80"></a><span id="l23.80" class="difflineplus">+ *  reference contacts which in turn (implicitly) reference identities again.</span>
<a href="#l23.81"></a><span id="l23.81" class="difflineplus">+ *  We have to spin up those other queries and stitch things together.</span>
<a href="#l23.82"></a><span id="l23.82" class="difflineplus">+ *</span>
<a href="#l23.83"></a><span id="l23.83" class="difflineplus">+ * While the code is generally up to the existing set of tasks it is called to</span>
<a href="#l23.84"></a><span id="l23.84" class="difflineplus">+ *  handle, I would not be surprised for it to fall down if things get more</span>
<a href="#l23.85"></a><span id="l23.85" class="difflineplus">+ *  complex.  Some of the logic here 'evolved' a bit and could benefit from</span>
<a href="#l23.86"></a><span id="l23.86" class="difflineplus">+ *  additional documentation and a fresh go-through.</span>
<a href="#l23.87"></a><span id="l23.87">  */</span>
<a href="#l23.88"></a><span id="l23.88"> function QueryFromQueryCallback(aStatement, aNounDef, aCollection) {</span>
<a href="#l23.89"></a><span id="l23.89">   this.statement = aStatement;</span>
<a href="#l23.90"></a><span id="l23.90">   this.nounDef = aNounDef;</span>
<a href="#l23.91"></a><span id="l23.91">   this.collection = aCollection;</span>
<a href="#l23.92"></a><span id="l23.92"> </span>
<a href="#l23.93"></a><span id="l23.93">   //QFQ_LOG.debug(&quot;Creating QFQCallback for noun: &quot; + aNounDef.name);</span>
<a href="#l23.94"></a><span id="l23.94"> </span>
<a href="#l23.95"></a><span id="l23.95" class="difflineat">@@ -339,17 +364,17 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l23.96"></a><span id="l23.96">               query.id.apply(query, [id for (id in notFound)]);</span>
<a href="#l23.97"></a><span id="l23.97"> </span>
<a href="#l23.98"></a><span id="l23.98">               this.collection.masterCollection.subCollections[nounDef.id] =</span>
<a href="#l23.99"></a><span id="l23.99">                 GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver,</span>
<a href="#l23.100"></a><span id="l23.100">                   this.collection,</span>
<a href="#l23.101"></a><span id="l23.101">                   // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l23.102"></a><span id="l23.102">                   this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l23.103"></a><span id="l23.103">                   this.collection.masterCollection,</span>
<a href="#l23.104"></a><span id="l23.104" class="difflineminus">-                  /* become explicit */ true);</span>
<a href="#l23.105"></a><span id="l23.105" class="difflineplus">+                  {becomeExplicit: true});</span>
<a href="#l23.106"></a><span id="l23.106">             }</span>
<a href="#l23.107"></a><span id="l23.107">           }</span>
<a href="#l23.108"></a><span id="l23.108"> </span>
<a href="#l23.109"></a><span id="l23.109">           for each (let [nounID, inverseReferences] in</span>
<a href="#l23.110"></a><span id="l23.110">               Iterator(this.inverseReferencesByNounID)) {</span>
<a href="#l23.111"></a><span id="l23.111">             this.collection.deferredCount++;</span>
<a href="#l23.112"></a><span id="l23.112">             let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l23.113"></a><span id="l23.113"> </span>
<a href="#l23.114"></a><span id="l23.114" class="difflineat">@@ -360,17 +385,17 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l23.115"></a><span id="l23.115">             let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l23.116"></a><span id="l23.116">             queryConstrainer.apply(query, [pid for (pid in inverseReferences)]);</span>
<a href="#l23.117"></a><span id="l23.117">             this.collection.masterCollection.subCollections[nounDef.id] =</span>
<a href="#l23.118"></a><span id="l23.118">               GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver,</span>
<a href="#l23.119"></a><span id="l23.119">                 this.collection,</span>
<a href="#l23.120"></a><span id="l23.120">                 // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l23.121"></a><span id="l23.121">                 this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l23.122"></a><span id="l23.122">                 this.collection.masterCollection,</span>
<a href="#l23.123"></a><span id="l23.123" class="difflineminus">-                /* become explicit */ true);</span>
<a href="#l23.124"></a><span id="l23.124" class="difflineplus">+                {becomeExplicit: true});</span>
<a href="#l23.125"></a><span id="l23.125">           }</span>
<a href="#l23.126"></a><span id="l23.126">         }</span>
<a href="#l23.127"></a><span id="l23.127">         else {</span>
<a href="#l23.128"></a><span id="l23.128">           this.collection.deferredCount--;</span>
<a href="#l23.129"></a><span id="l23.129">           this.collection.resolvedCount++;</span>
<a href="#l23.130"></a><span id="l23.130">         }</span>
<a href="#l23.131"></a><span id="l23.131"> </span>
<a href="#l23.132"></a><span id="l23.132">         //QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l23.133"></a><span id="l23.133" class="difflineat">@@ -382,25 +407,55 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l23.134"></a><span id="l23.134">           //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l23.135"></a><span id="l23.135">           //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l23.136"></a><span id="l23.136">           //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l23.137"></a><span id="l23.137">           QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l23.138"></a><span id="l23.138">           QueryFromQueryResolver.onQueryCompleted({data: this.collection});</span>
<a href="#l23.139"></a><span id="l23.139">         }</span>
<a href="#l23.140"></a><span id="l23.140">       }</span>
<a href="#l23.141"></a><span id="l23.141">       catch (e) {</span>
<a href="#l23.142"></a><span id="l23.142" class="difflineplus">+        Components.utils.reportError(e);</span>
<a href="#l23.143"></a><span id="l23.143">         QFQ_LOG.error(&quot;Exception: &quot; + e);</span>
<a href="#l23.144"></a><span id="l23.144">       }</span>
<a href="#l23.145"></a><span id="l23.145">     }</span>
<a href="#l23.146"></a><span id="l23.146">     finally {</span>
<a href="#l23.147"></a><span id="l23.147">       GlodaDatastore._asyncCompleted();</span>
<a href="#l23.148"></a><span id="l23.148">     }</span>
<a href="#l23.149"></a><span id="l23.149">   }</span>
<a href="#l23.150"></a><span id="l23.150"> };</span>
<a href="#l23.151"></a><span id="l23.151"> </span>
<a href="#l23.152"></a><span id="l23.152" class="difflineplus">+/**</span>
<a href="#l23.153"></a><span id="l23.153" class="difflineplus">+ * Used by |GlodaDatastore.folderCompactionPassBlockFetch| to accumulate the</span>
<a href="#l23.154"></a><span id="l23.154" class="difflineplus">+ *  results and pass them back in to the compaction process in</span>
<a href="#l23.155"></a><span id="l23.155" class="difflineplus">+ *  |GlodaMsgIndexer._worker_folderCompactionPass|.</span>
<a href="#l23.156"></a><span id="l23.156" class="difflineplus">+ */</span>
<a href="#l23.157"></a><span id="l23.157" class="difflineplus">+function CompactionBlockFetcherHandler(aCallback) {</span>
<a href="#l23.158"></a><span id="l23.158" class="difflineplus">+  this.callback = aCallback;</span>
<a href="#l23.159"></a><span id="l23.159" class="difflineplus">+  this.idsAndMessageKeys = [];</span>
<a href="#l23.160"></a><span id="l23.160" class="difflineplus">+  GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l23.161"></a><span id="l23.161" class="difflineplus">+}</span>
<a href="#l23.162"></a><span id="l23.162" class="difflineplus">+CompactionBlockFetcherHandler.prototype = {</span>
<a href="#l23.163"></a><span id="l23.163" class="difflineplus">+  handleResult: function gloda_ds_cbfh_handleResult(aResultSet) {</span>
<a href="#l23.164"></a><span id="l23.164" class="difflineplus">+    let row;</span>
<a href="#l23.165"></a><span id="l23.165" class="difflineplus">+    while ((row = aResultSet.getNextRow())) {</span>
<a href="#l23.166"></a><span id="l23.166" class="difflineplus">+      this.idsAndMessageKeys.push([</span>
<a href="#l23.167"></a><span id="l23.167" class="difflineplus">+        row.getInt64(0), // id</span>
<a href="#l23.168"></a><span id="l23.168" class="difflineplus">+        row.getInt64(1), // messageKey</span>
<a href="#l23.169"></a><span id="l23.169" class="difflineplus">+        row.getString(2), // headerMessageID</span>
<a href="#l23.170"></a><span id="l23.170" class="difflineplus">+        ]);</span>
<a href="#l23.171"></a><span id="l23.171" class="difflineplus">+    }</span>
<a href="#l23.172"></a><span id="l23.172" class="difflineplus">+  },</span>
<a href="#l23.173"></a><span id="l23.173" class="difflineplus">+  handleError: function gloda_ds_cbfh_handleError(aError) {</span>
<a href="#l23.174"></a><span id="l23.174" class="difflineplus">+</span>
<a href="#l23.175"></a><span id="l23.175" class="difflineplus">+  },</span>
<a href="#l23.176"></a><span id="l23.176" class="difflineplus">+  handleCompletion: function gloda_ds_cbfh_handleCompletion(aReason) {</span>
<a href="#l23.177"></a><span id="l23.177" class="difflineplus">+    GlodaDatastore._asyncCompleted();</span>
<a href="#l23.178"></a><span id="l23.178" class="difflineplus">+    this.callback(this.idsAndMessageKeys);</span>
<a href="#l23.179"></a><span id="l23.179" class="difflineplus">+  }</span>
<a href="#l23.180"></a><span id="l23.180" class="difflineplus">+};</span>
<a href="#l23.181"></a><span id="l23.181"> </span>
<a href="#l23.182"></a><span id="l23.182"> /**</span>
<a href="#l23.183"></a><span id="l23.183">  * Database abstraction layer.  Contains explicit SQL schemas for our</span>
<a href="#l23.184"></a><span id="l23.184">  *  fundamental representations (core 'nouns', if you will) as well as</span>
<a href="#l23.185"></a><span id="l23.185">  *  specialized functions for then dealing with each type of object.  At the</span>
<a href="#l23.186"></a><span id="l23.186">  *  same time, we are beginning to support extension-provided tables, which</span>
<a href="#l23.187"></a><span id="l23.187">  *  call into question whether we really need our hand-rolled code, or could</span>
<a href="#l23.188"></a><span id="l23.188">  *  simply improve the extension-provided table case to work for most of our</span>
<a href="#l23.189"></a><span id="l23.189" class="difflineat">@@ -503,17 +558,17 @@ var GlodaDatastore = {</span>
<a href="#l23.190"></a><span id="l23.190">   kConstraintIn: 1,</span>
<a href="#l23.191"></a><span id="l23.191">   kConstraintRanges: 2,</span>
<a href="#l23.192"></a><span id="l23.192">   kConstraintEquals: 3,</span>
<a href="#l23.193"></a><span id="l23.193">   kConstraintStringLike: 4,</span>
<a href="#l23.194"></a><span id="l23.194">   kConstraintFulltext: 5,</span>
<a href="#l23.195"></a><span id="l23.195"> </span>
<a href="#l23.196"></a><span id="l23.196">   /* ******************* SCHEMA ******************* */</span>
<a href="#l23.197"></a><span id="l23.197"> </span>
<a href="#l23.198"></a><span id="l23.198" class="difflineminus">-  _schemaVersion: 13,</span>
<a href="#l23.199"></a><span id="l23.199" class="difflineplus">+  _schemaVersion: 14,</span>
<a href="#l23.200"></a><span id="l23.200">   _schema: {</span>
<a href="#l23.201"></a><span id="l23.201">     tables: {</span>
<a href="#l23.202"></a><span id="l23.202"> </span>
<a href="#l23.203"></a><span id="l23.203">       // ----- Messages</span>
<a href="#l23.204"></a><span id="l23.204">       folderLocations: {</span>
<a href="#l23.205"></a><span id="l23.205">         columns: [</span>
<a href="#l23.206"></a><span id="l23.206">           [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;],</span>
<a href="#l23.207"></a><span id="l23.207">           [&quot;folderURI&quot;, &quot;TEXT NOT NULL&quot;],</span>
<a href="#l23.208"></a><span id="l23.208" class="difflineat">@@ -689,24 +744,24 @@ var GlodaDatastore = {</span>
<a href="#l23.209"></a><span id="l23.209">         }</span>
<a href="#l23.210"></a><span id="l23.210">       },</span>
<a href="#l23.211"></a><span id="l23.211">     },</span>
<a href="#l23.212"></a><span id="l23.212">   },</span>
<a href="#l23.213"></a><span id="l23.213"> </span>
<a href="#l23.214"></a><span id="l23.214"> </span>
<a href="#l23.215"></a><span id="l23.215">   /* ******************* LOGIC ******************* */</span>
<a href="#l23.216"></a><span id="l23.216">   /**</span>
<a href="#l23.217"></a><span id="l23.217" class="difflineminus">-   * Our synchronous connection, primarily intended for read-only use, so as to</span>
<a href="#l23.218"></a><span id="l23.218" class="difflineminus">-   *  avoid stepping on the toes of our asynchronous connection that will do</span>
<a href="#l23.219"></a><span id="l23.219" class="difflineminus">-   *  most/all of our updating.</span>
<a href="#l23.220"></a><span id="l23.220" class="difflineplus">+   * We only have one connection; this name exists for legacy reasons but helps</span>
<a href="#l23.221"></a><span id="l23.221" class="difflineplus">+   *  track when we are intentionally doing synchronous things during startup.</span>
<a href="#l23.222"></a><span id="l23.222" class="difflineplus">+   *  We do nothing synchronous once our setup has completed.</span>
<a href="#l23.223"></a><span id="l23.223">    */</span>
<a href="#l23.224"></a><span id="l23.224">   syncConnection: null,</span>
<a href="#l23.225"></a><span id="l23.225">   /**</span>
<a href="#l23.226"></a><span id="l23.226" class="difflineminus">-   * Our connection reused for asynchronous usage, intended for database write</span>
<a href="#l23.227"></a><span id="l23.227" class="difflineminus">-   *  purposes.</span>
<a href="#l23.228"></a><span id="l23.228" class="difflineplus">+   * We only have one connection and we only do asynchronous things after setup;</span>
<a href="#l23.229"></a><span id="l23.229" class="difflineplus">+   *  this name still exists mainly for legacy reasons.</span>
<a href="#l23.230"></a><span id="l23.230">    */</span>
<a href="#l23.231"></a><span id="l23.231">   asyncConnection: null,</span>
<a href="#l23.232"></a><span id="l23.232"> </span>
<a href="#l23.233"></a><span id="l23.233">   /**</span>
<a href="#l23.234"></a><span id="l23.234">    * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l23.235"></a><span id="l23.235">    *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l23.236"></a><span id="l23.236">    *  mapping.</span>
<a href="#l23.237"></a><span id="l23.237">    */</span>
<a href="#l23.238"></a><span id="l23.238" class="difflineat">@@ -786,23 +841,27 @@ var GlodaDatastore = {</span>
<a href="#l23.239"></a><span id="l23.239">   },</span>
<a href="#l23.240"></a><span id="l23.240"> </span>
<a href="#l23.241"></a><span id="l23.241">   datastoreIsShutdown: false,</span>
<a href="#l23.242"></a><span id="l23.242"> </span>
<a href="#l23.243"></a><span id="l23.243">   /**</span>
<a href="#l23.244"></a><span id="l23.244">    * Perform datastore shutdown.</span>
<a href="#l23.245"></a><span id="l23.245">    */</span>
<a href="#l23.246"></a><span id="l23.246">   shutdown: function gloda_ds_shutdown() {</span>
<a href="#l23.247"></a><span id="l23.247" class="difflineminus">-    // clear out any pending transaction by committing it.</span>
<a href="#l23.248"></a><span id="l23.248" class="difflineminus">-    // Although you might worry that this is potentially an arbitrary and</span>
<a href="#l23.249"></a><span id="l23.249" class="difflineminus">-    //  inconsistent point to issue a commit, it is not.  Because we are going</span>
<a href="#l23.250"></a><span id="l23.250" class="difflineminus">-    //  to be called from the main/UI thread, that means the indexer cannot be</span>
<a href="#l23.251"></a><span id="l23.251" class="difflineminus">-    //  active on the thread at the time.  The indexer only yields at times</span>
<a href="#l23.252"></a><span id="l23.252" class="difflineminus">-    //  when the database state AS ISSUED is coherent.  As noted below, the</span>
<a href="#l23.253"></a><span id="l23.253" class="difflineminus">-    //  async execution queue will actually be drained to completion.</span>
<a href="#l23.254"></a><span id="l23.254" class="difflineplus">+    // Clear out any pending transaction by committing it.</span>
<a href="#l23.255"></a><span id="l23.255" class="difflineplus">+    // The indexer has been shutdown by this point; it no longer has any active</span>
<a href="#l23.256"></a><span id="l23.256" class="difflineplus">+    //  indexing logic and it no longer has active event listeners capable of</span>
<a href="#l23.257"></a><span id="l23.257" class="difflineplus">+    //  generating new activity.</span>
<a href="#l23.258"></a><span id="l23.258" class="difflineplus">+    // Semantic consistency of the database is guaranteed by the indexer's</span>
<a href="#l23.259"></a><span id="l23.259" class="difflineplus">+    //  strategy of only yielding control at coherent times.  Although it takes</span>
<a href="#l23.260"></a><span id="l23.260" class="difflineplus">+    //  multiple calls and multiple SQL operations to update the state of our</span>
<a href="#l23.261"></a><span id="l23.261" class="difflineplus">+    //  database representations, the generator does not yield until it has</span>
<a href="#l23.262"></a><span id="l23.262" class="difflineplus">+    //  issued all the database statements required for said update.  As such,</span>
<a href="#l23.263"></a><span id="l23.263" class="difflineplus">+    //  this commit will leave us in a good way (and the commit will happen</span>
<a href="#l23.264"></a><span id="l23.264" class="difflineplus">+    //  because closing the connection will drain the async execution queue.)</span>
<a href="#l23.265"></a><span id="l23.265">     while (this._transactionDepth) {</span>
<a href="#l23.266"></a><span id="l23.266">       this._log.info(&quot;Closing pending transaction out for shutdown.&quot;);</span>
<a href="#l23.267"></a><span id="l23.267">       // just schedule this function to be run again once the transaction has</span>
<a href="#l23.268"></a><span id="l23.268">       //  been closed out.</span>
<a href="#l23.269"></a><span id="l23.269">       this._commitTransaction();</span>
<a href="#l23.270"></a><span id="l23.270">     }</span>
<a href="#l23.271"></a><span id="l23.271"> </span>
<a href="#l23.272"></a><span id="l23.272">     this.datastoreIsShutdown = true;</span>
<a href="#l23.273"></a><span id="l23.273" class="difflineat">@@ -1003,16 +1062,19 @@ var GlodaDatastore = {</span>
<a href="#l23.274"></a><span id="l23.274">     // - altered toMe and ccMe to just be toMe</span>
<a href="#l23.275"></a><span id="l23.275">     // - exposes bcc to cc-related attributes</span>
<a href="#l23.276"></a><span id="l23.276">     // - MIME type DB schema overhaul</span>
<a href="#l23.277"></a><span id="l23.277">     // version 15ish, still labeled 13:</span>
<a href="#l23.278"></a><span id="l23.278">     // - change tokenizer to mozporter to support CJK</span>
<a href="#l23.279"></a><span id="l23.279">     // (We are slip-streaming this so that only people who want to test CJK</span>
<a href="#l23.280"></a><span id="l23.280">     //  have to test it.  We will properly bump the schema revision when the</span>
<a href="#l23.281"></a><span id="l23.281">     //  gloda correctness patch lands.)</span>
<a href="#l23.282"></a><span id="l23.282" class="difflineplus">+    // version 16ish, labeled 14</span>
<a href="#l23.283"></a><span id="l23.283" class="difflineplus">+    // - gloda message id's start from 32 now</span>
<a href="#l23.284"></a><span id="l23.284" class="difflineplus">+    // - all kinds of correctness changes</span>
<a href="#l23.285"></a><span id="l23.285">     if (aCurVersion &lt; 15) {</span>
<a href="#l23.286"></a><span id="l23.286">       aDBConnection.close();</span>
<a href="#l23.287"></a><span id="l23.287">       aDBFile.remove(false);</span>
<a href="#l23.288"></a><span id="l23.288">       this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l23.289"></a><span id="l23.289">       return this._createDB(aDBService, aDBFile);</span>
<a href="#l23.290"></a><span id="l23.290">     }</span>
<a href="#l23.291"></a><span id="l23.291"> </span>
<a href="#l23.292"></a><span id="l23.292">     aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l23.293"></a><span id="l23.293" class="difflineat">@@ -1119,16 +1181,20 @@ var GlodaDatastore = {</span>
<a href="#l23.294"></a><span id="l23.294">       else</span>
<a href="#l23.295"></a><span id="l23.295">         aStatement.bindDoubleParameter(aIndex, aVariant);</span>
<a href="#l23.296"></a><span id="l23.296">     }</span>
<a href="#l23.297"></a><span id="l23.297">     else</span>
<a href="#l23.298"></a><span id="l23.298">       throw(&quot;Attempt to bind variant with unsupported type: &quot; +</span>
<a href="#l23.299"></a><span id="l23.299">             (typeof aVariant));</span>
<a href="#l23.300"></a><span id="l23.300">   },</span>
<a href="#l23.301"></a><span id="l23.301"> </span>
<a href="#l23.302"></a><span id="l23.302" class="difflineplus">+  /**</span>
<a href="#l23.303"></a><span id="l23.303" class="difflineplus">+   * Helper that uses the appropriate getter given the data type; should be</span>
<a href="#l23.304"></a><span id="l23.304" class="difflineplus">+   *  mooted once we move to 1.9.2 and can use built-in variant support.</span>
<a href="#l23.305"></a><span id="l23.305" class="difflineplus">+   */</span>
<a href="#l23.306"></a><span id="l23.306">   _getVariant: function gloda_ds_getBlob(aRow, aIndex) {</span>
<a href="#l23.307"></a><span id="l23.307">     let typeOfIndex = aRow.getTypeOfIndex(aIndex);</span>
<a href="#l23.308"></a><span id="l23.308">     if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l23.309"></a><span id="l23.309">       return null;</span>
<a href="#l23.310"></a><span id="l23.310">     // XPConnect would just end up going through an intermediary double stage</span>
<a href="#l23.311"></a><span id="l23.311">     //  for the int64 case anyways...</span>
<a href="#l23.312"></a><span id="l23.312">     else if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_INTEGER ||</span>
<a href="#l23.313"></a><span id="l23.313">              typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_DOUBLE)</span>
<a href="#l23.314"></a><span id="l23.314" class="difflineat">@@ -1136,28 +1202,37 @@ var GlodaDatastore = {</span>
<a href="#l23.315"></a><span id="l23.315">     else // typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_TEXT</span>
<a href="#l23.316"></a><span id="l23.316">       return aRow.getString(aIndex);</span>
<a href="#l23.317"></a><span id="l23.317">   },</span>
<a href="#l23.318"></a><span id="l23.318"> </span>
<a href="#l23.319"></a><span id="l23.319">   /** Simple nested transaction support as a performance optimization. */</span>
<a href="#l23.320"></a><span id="l23.320">   _transactionDepth: 0,</span>
<a href="#l23.321"></a><span id="l23.321">   _transactionGood: false,</span>
<a href="#l23.322"></a><span id="l23.322"> </span>
<a href="#l23.323"></a><span id="l23.323" class="difflineplus">+  /**</span>
<a href="#l23.324"></a><span id="l23.324" class="difflineplus">+   * Self-memoizing BEGIN TRANSACTION statement.</span>
<a href="#l23.325"></a><span id="l23.325" class="difflineplus">+   */</span>
<a href="#l23.326"></a><span id="l23.326">   get _beginTransactionStatement() {</span>
<a href="#l23.327"></a><span id="l23.327">     let statement = this._createAsyncStatement(&quot;BEGIN TRANSACTION&quot;);</span>
<a href="#l23.328"></a><span id="l23.328">     this.__defineGetter__(&quot;_beginTransactionStatement&quot;, function() statement);</span>
<a href="#l23.329"></a><span id="l23.329">     return this._beginTransactionStatement;</span>
<a href="#l23.330"></a><span id="l23.330">   },</span>
<a href="#l23.331"></a><span id="l23.331"> </span>
<a href="#l23.332"></a><span id="l23.332" class="difflineplus">+  /**</span>
<a href="#l23.333"></a><span id="l23.333" class="difflineplus">+   * Self-memoizing COMMIT statement.</span>
<a href="#l23.334"></a><span id="l23.334" class="difflineplus">+   */</span>
<a href="#l23.335"></a><span id="l23.335">   get _commitTransactionStatement() {</span>
<a href="#l23.336"></a><span id="l23.336">     let statement = this._createAsyncStatement(&quot;COMMIT&quot;);</span>
<a href="#l23.337"></a><span id="l23.337">     this.__defineGetter__(&quot;_commitTransactionStatement&quot;, function() statement);</span>
<a href="#l23.338"></a><span id="l23.338">     return this._commitTransactionStatement;</span>
<a href="#l23.339"></a><span id="l23.339">   },</span>
<a href="#l23.340"></a><span id="l23.340"> </span>
<a href="#l23.341"></a><span id="l23.341" class="difflineplus">+  /**</span>
<a href="#l23.342"></a><span id="l23.342" class="difflineplus">+   * Self-memoizing ROLLBACK statement.</span>
<a href="#l23.343"></a><span id="l23.343" class="difflineplus">+   */</span>
<a href="#l23.344"></a><span id="l23.344">   get _rollbackTransactionStatement() {</span>
<a href="#l23.345"></a><span id="l23.345">     let statement = this._createAsyncStatement(&quot;ROLLBACK&quot;);</span>
<a href="#l23.346"></a><span id="l23.346">     this.__defineGetter__(&quot;_rollbackTransactionStatement&quot;, function() statement);</span>
<a href="#l23.347"></a><span id="l23.347">     return this._rollbackTransactionStatement;</span>
<a href="#l23.348"></a><span id="l23.348">   },</span>
<a href="#l23.349"></a><span id="l23.349"> </span>
<a href="#l23.350"></a><span id="l23.350">   _pendingPostCommitCallbacks: null,</span>
<a href="#l23.351"></a><span id="l23.351">   /**</span>
<a href="#l23.352"></a><span id="l23.352" class="difflineat">@@ -1324,17 +1399,17 @@ var GlodaDatastore = {</span>
<a href="#l23.353"></a><span id="l23.353">     let stmt = this._createSyncStatement(</span>
<a href="#l23.354"></a><span id="l23.354">       &quot;SELECT id, attributeType, extensionName, name, parameter \</span>
<a href="#l23.355"></a><span id="l23.355">          FROM attributeDefinitions&quot;, true);</span>
<a href="#l23.356"></a><span id="l23.356"> </span>
<a href="#l23.357"></a><span id="l23.357">     // map compound name to the attribute</span>
<a href="#l23.358"></a><span id="l23.358">     let attribs = {};</span>
<a href="#l23.359"></a><span id="l23.359">     // map the attribute id to [attribute, parameter] where parameter is null</span>
<a href="#l23.360"></a><span id="l23.360">     //  in cases where parameter is unused.</span>
<a href="#l23.361"></a><span id="l23.361" class="difflineminus">-    let idToAttribAndParam = {}</span>
<a href="#l23.362"></a><span id="l23.362" class="difflineplus">+    let idToAttribAndParam = {};</span>
<a href="#l23.363"></a><span id="l23.363"> </span>
<a href="#l23.364"></a><span id="l23.364">     this._log.info(&quot;loading all attribute defs&quot;);</span>
<a href="#l23.365"></a><span id="l23.365"> </span>
<a href="#l23.366"></a><span id="l23.366">     while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l23.367"></a><span id="l23.367">       let rowId = stmt.getInt64(0);</span>
<a href="#l23.368"></a><span id="l23.368">       let rowAttributeType = stmt.getInt64(1);</span>
<a href="#l23.369"></a><span id="l23.369">       let rowExtensionName = stmt.getString(2);</span>
<a href="#l23.370"></a><span id="l23.370">       let rowName = stmt.getString(3);</span>
<a href="#l23.371"></a><span id="l23.371" class="difflineat">@@ -1429,16 +1504,20 @@ var GlodaDatastore = {</span>
<a href="#l23.372"></a><span id="l23.372">     stmt.finalize();</span>
<a href="#l23.373"></a><span id="l23.373">   },</span>
<a href="#l23.374"></a><span id="l23.374"> </span>
<a href="#l23.375"></a><span id="l23.375">   _folderKnown: function gloda_ds_folderKnown(aFolder) {</span>
<a href="#l23.376"></a><span id="l23.376">     let folderURI = aFolder.URI;</span>
<a href="#l23.377"></a><span id="l23.377">     return folderURI in this._folderByURI;</span>
<a href="#l23.378"></a><span id="l23.378">   },</span>
<a href="#l23.379"></a><span id="l23.379"> </span>
<a href="#l23.380"></a><span id="l23.380" class="difflineplus">+  _folderIdKnown: function gloda_ds_folderIdKnown(aFolderID) {</span>
<a href="#l23.381"></a><span id="l23.381" class="difflineplus">+    return (aFolderID in this._folderByID);</span>
<a href="#l23.382"></a><span id="l23.382" class="difflineplus">+  },</span>
<a href="#l23.383"></a><span id="l23.383" class="difflineplus">+</span>
<a href="#l23.384"></a><span id="l23.384">   /**</span>
<a href="#l23.385"></a><span id="l23.385">    * Map a folder URI to a GlodaFolder instance, creating the mapping if it does</span>
<a href="#l23.386"></a><span id="l23.386">    *  not yet exist.</span>
<a href="#l23.387"></a><span id="l23.387">    *</span>
<a href="#l23.388"></a><span id="l23.388">    * @param aFolder The nsIMsgFolder instance you would like the GlodaFolder</span>
<a href="#l23.389"></a><span id="l23.389">    *     instance for.</span>
<a href="#l23.390"></a><span id="l23.390">    * @returns The existing or newly created GlodaFolder instance.</span>
<a href="#l23.391"></a><span id="l23.391">    */</span>
<a href="#l23.392"></a><span id="l23.392" class="difflineat">@@ -1446,19 +1525,33 @@ var GlodaDatastore = {</span>
<a href="#l23.393"></a><span id="l23.393">     let folderURI = aFolder.URI;</span>
<a href="#l23.394"></a><span id="l23.394">     if (folderURI in this._folderByURI) {</span>
<a href="#l23.395"></a><span id="l23.395">       return this._folderByURI[folderURI];</span>
<a href="#l23.396"></a><span id="l23.396">     }</span>
<a href="#l23.397"></a><span id="l23.397"> </span>
<a href="#l23.398"></a><span id="l23.398">     let folderID = this._nextFolderId++;</span>
<a href="#l23.399"></a><span id="l23.399"> </span>
<a href="#l23.400"></a><span id="l23.400">     let indexingPriority = GlodaFolder.prototype.kIndexingDefaultPriority;</span>
<a href="#l23.401"></a><span id="l23.401" class="difflineminus">-    // do not walk into trash/junk folders.</span>
<a href="#l23.402"></a><span id="l23.402" class="difflineminus">-    if (aFolder.flags &amp; (Ci.nsMsgFolderFlags.Trash |</span>
<a href="#l23.403"></a><span id="l23.403" class="difflineminus">-                         Ci.nsMsgFolderFlags.Junk))</span>
<a href="#l23.404"></a><span id="l23.404" class="difflineplus">+    // Do not walk into trash/junk folders.</span>
<a href="#l23.405"></a><span id="l23.405" class="difflineplus">+    // Queue folders should also be ignored just because messages should not</span>
<a href="#l23.406"></a><span id="l23.406" class="difflineplus">+    //  spend much time in there.</span>
<a href="#l23.407"></a><span id="l23.407" class="difflineplus">+    // We hate newsgroups, and public IMAP folders are similar.</span>
<a href="#l23.408"></a><span id="l23.408" class="difflineplus">+    // Other user IMAP folders should be ignored because it's not this user's</span>
<a href="#l23.409"></a><span id="l23.409" class="difflineplus">+    //  mail.</span>
<a href="#l23.410"></a><span id="l23.410" class="difflineplus">+    if (aFolder.flags &amp; (Ci.nsMsgFolderFlags.Trash</span>
<a href="#l23.411"></a><span id="l23.411" class="difflineplus">+                         | Ci.nsMsgFolderFlags.Junk</span>
<a href="#l23.412"></a><span id="l23.412" class="difflineplus">+                         | Ci.nsMsgFolderFlags.Queue</span>
<a href="#l23.413"></a><span id="l23.413" class="difflineplus">+                         | Ci.nsMsgFolderFlags.Newsgroup</span>
<a href="#l23.414"></a><span id="l23.414" class="difflineplus">+                         // In unit testing at least folders can be confusingly</span>
<a href="#l23.415"></a><span id="l23.415" class="difflineplus">+                         //  labeled ImapPublic when they should not be.  Or</span>
<a href="#l23.416"></a><span id="l23.416" class="difflineplus">+                         //  at least I don't think they should be.  So they're</span>
<a href="#l23.417"></a><span id="l23.417" class="difflineplus">+                         //  legit for now.</span>
<a href="#l23.418"></a><span id="l23.418" class="difflineplus">+                         //| Ci.nsMsgFolderFlags.ImapPublic</span>
<a href="#l23.419"></a><span id="l23.419" class="difflineplus">+                         //| Ci.nsMsgFolderFlags.ImapOtherUser</span>
<a href="#l23.420"></a><span id="l23.420" class="difflineplus">+                        ))</span>
<a href="#l23.421"></a><span id="l23.421">       indexingPriority = GlodaFolder.prototype.kIndexingNeverPriority;</span>
<a href="#l23.422"></a><span id="l23.422">     else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.Inbox)</span>
<a href="#l23.423"></a><span id="l23.423">       indexingPriority = GlodaFolder.prototype.kIndexingInboxPriority;</span>
<a href="#l23.424"></a><span id="l23.424">     else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.SentMail)</span>
<a href="#l23.425"></a><span id="l23.425">       indexingPriority = GlodaFolder.prototype.kIndexingSentMailPriority;</span>
<a href="#l23.426"></a><span id="l23.426">     else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.Favorite)</span>
<a href="#l23.427"></a><span id="l23.427">       indexingPriority = GlodaFolder.prototype.kIndexingFavoritePriority;</span>
<a href="#l23.428"></a><span id="l23.428">     else if (aFolder.flags &amp; Ci.nsMsgFolderFlags.CheckNew)</span>
<a href="#l23.429"></a><span id="l23.429" class="difflineat">@@ -1707,76 +1800,52 @@ var GlodaDatastore = {</span>
<a href="#l23.430"></a><span id="l23.430">    * Asynchronously delete a conversation given its ID.</span>
<a href="#l23.431"></a><span id="l23.431">    */</span>
<a href="#l23.432"></a><span id="l23.432">   deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l23.433"></a><span id="l23.433">                                       aConversationID) {</span>
<a href="#l23.434"></a><span id="l23.434">     let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l23.435"></a><span id="l23.435">     dcbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l23.436"></a><span id="l23.436">     dcbids.executeAsync(this.trackAsync());</span>
<a href="#l23.437"></a><span id="l23.437"> </span>
<a href="#l23.438"></a><span id="l23.438" class="difflineminus">-    // TODO: collection manager implications</span>
<a href="#l23.439"></a><span id="l23.439" class="difflineminus">-    //GlodaCollectionManager.removeByID()</span>
<a href="#l23.440"></a><span id="l23.440" class="difflineminus">-  },</span>
<a href="#l23.441"></a><span id="l23.441" class="difflineminus">-</span>
<a href="#l23.442"></a><span id="l23.442" class="difflineminus">-  get _selectConversationByIDStatement() {</span>
<a href="#l23.443"></a><span id="l23.443" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.444"></a><span id="l23.444" class="difflineminus">-      &quot;SELECT id, subject, oldestMessageDate, newestMessageDate \</span>
<a href="#l23.445"></a><span id="l23.445" class="difflineminus">-         FROM conversations WHERE id = ?1&quot;);</span>
<a href="#l23.446"></a><span id="l23.446" class="difflineminus">-    this.__defineGetter__(&quot;_selectConversationByIDStatement&quot;,</span>
<a href="#l23.447"></a><span id="l23.447" class="difflineminus">-      function() statement);</span>
<a href="#l23.448"></a><span id="l23.448" class="difflineminus">-    return this._selectConversationByIDStatement;</span>
<a href="#l23.449"></a><span id="l23.449" class="difflineplus">+    GlodaCollectionManager.itemsDeleted(GlodaConversation.prototype.NOUN_ID,</span>
<a href="#l23.450"></a><span id="l23.450" class="difflineplus">+                                        [aConversationID]);</span>
<a href="#l23.451"></a><span id="l23.451">   },</span>
<a href="#l23.452"></a><span id="l23.452"> </span>
<a href="#l23.453"></a><span id="l23.453">   _conversationFromRow: function gloda_ds_conversationFromRow(aStmt) {</span>
<a href="#l23.454"></a><span id="l23.454">       let oldestMessageDate, newestMessageDate;</span>
<a href="#l23.455"></a><span id="l23.455">       if (aStmt.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l23.456"></a><span id="l23.456">         oldestMessageDate = null;</span>
<a href="#l23.457"></a><span id="l23.457">       else</span>
<a href="#l23.458"></a><span id="l23.458">         oldestMessageDate = aStmt.getInt64(2);</span>
<a href="#l23.459"></a><span id="l23.459">       if (aStmt.getTypeOfIndex(3) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l23.460"></a><span id="l23.460">         newestMessageDate = null;</span>
<a href="#l23.461"></a><span id="l23.461">       else</span>
<a href="#l23.462"></a><span id="l23.462">         newestMessageDate = aStmt.getInt64(3);</span>
<a href="#l23.463"></a><span id="l23.463">       return new GlodaConversation(this, aStmt.getInt64(0),</span>
<a href="#l23.464"></a><span id="l23.464">         aStmt.getString(1), oldestMessageDate, newestMessageDate);</span>
<a href="#l23.465"></a><span id="l23.465">   },</span>
<a href="#l23.466"></a><span id="l23.466"> </span>
<a href="#l23.467"></a><span id="l23.467" class="difflineminus">-  /**</span>
<a href="#l23.468"></a><span id="l23.468" class="difflineminus">-   * Synchronously look up a conversation given its ID.</span>
<a href="#l23.469"></a><span id="l23.469" class="difflineminus">-   */</span>
<a href="#l23.470"></a><span id="l23.470" class="difflineminus">-  getConversationByID: function gloda_ds_getConversationByID(aConversationID) {</span>
<a href="#l23.471"></a><span id="l23.471" class="difflineminus">-    let conversation = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l23.472"></a><span id="l23.472" class="difflineminus">-      GlodaConversation.prototype.NOUN_ID, aConversationID);</span>
<a href="#l23.473"></a><span id="l23.473" class="difflineminus">-</span>
<a href="#l23.474"></a><span id="l23.474" class="difflineminus">-    if (conversation === null) {</span>
<a href="#l23.475"></a><span id="l23.475" class="difflineminus">-      let scbids = this._selectConversationByIDStatement;</span>
<a href="#l23.476"></a><span id="l23.476" class="difflineminus">-</span>
<a href="#l23.477"></a><span id="l23.477" class="difflineminus">-      scbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l23.478"></a><span id="l23.478" class="difflineminus">-      if (this._syncStep(scbids)) {</span>
<a href="#l23.479"></a><span id="l23.479" class="difflineminus">-        conversation = this._conversationFromRow(scbids);</span>
<a href="#l23.480"></a><span id="l23.480" class="difflineminus">-        GlodaCollectionManager.itemLoaded(conversation);</span>
<a href="#l23.481"></a><span id="l23.481" class="difflineminus">-      }</span>
<a href="#l23.482"></a><span id="l23.482" class="difflineminus">-      scbids.reset();</span>
<a href="#l23.483"></a><span id="l23.483" class="difflineminus">-    }</span>
<a href="#l23.484"></a><span id="l23.484" class="difflineminus">-</span>
<a href="#l23.485"></a><span id="l23.485" class="difflineminus">-    return conversation;</span>
<a href="#l23.486"></a><span id="l23.486" class="difflineminus">-  },</span>
<a href="#l23.487"></a><span id="l23.487" class="difflineminus">-</span>
<a href="#l23.488"></a><span id="l23.488">   /* ********** Message ********** */</span>
<a href="#l23.489"></a><span id="l23.489">   /**</span>
<a href="#l23.490"></a><span id="l23.490">    * Next message id, managed because of our use of asynchronous inserts.</span>
<a href="#l23.491"></a><span id="l23.491">    * Initialized by _populateMessageManagedId called by _init.</span>
<a href="#l23.492"></a><span id="l23.492" class="difflineplus">+   *</span>
<a href="#l23.493"></a><span id="l23.493" class="difflineplus">+   * Start from 32 to leave us all kinds of magical sentinel values at the</span>
<a href="#l23.494"></a><span id="l23.494" class="difflineplus">+   *  bottom.</span>
<a href="#l23.495"></a><span id="l23.495">    */</span>
<a href="#l23.496"></a><span id="l23.496" class="difflineminus">-  _nextMessageId: 1,</span>
<a href="#l23.497"></a><span id="l23.497" class="difflineplus">+  _nextMessageId: 32,</span>
<a href="#l23.498"></a><span id="l23.498"> </span>
<a href="#l23.499"></a><span id="l23.499">   _populateMessageManagedId: function () {</span>
<a href="#l23.500"></a><span id="l23.500">     let stmt = this._createSyncStatement(</span>
<a href="#l23.501"></a><span id="l23.501">       &quot;SELECT MAX(id) FROM messages&quot;, true);</span>
<a href="#l23.502"></a><span id="l23.502">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l23.503"></a><span id="l23.503" class="difflineminus">-      this._nextMessageId = stmt.getInt64(0) + 1;</span>
<a href="#l23.504"></a><span id="l23.504" class="difflineplus">+      // 0 gets returned even if there are no messages...</span>
<a href="#l23.505"></a><span id="l23.505" class="difflineplus">+      let highestSeen = stmt.getInt64(0);</span>
<a href="#l23.506"></a><span id="l23.506" class="difflineplus">+      if (highestSeen != 0)</span>
<a href="#l23.507"></a><span id="l23.507" class="difflineplus">+        this._nextMessageId = highestSeen + 1;</span>
<a href="#l23.508"></a><span id="l23.508">     }</span>
<a href="#l23.509"></a><span id="l23.509">     stmt.finalize();</span>
<a href="#l23.510"></a><span id="l23.510">   },</span>
<a href="#l23.511"></a><span id="l23.511"> </span>
<a href="#l23.512"></a><span id="l23.512">   get _insertMessageStatement() {</span>
<a href="#l23.513"></a><span id="l23.513">     let statement = this._createAsyncStatement(</span>
<a href="#l23.514"></a><span id="l23.514">       &quot;INSERT INTO messages (id, folderID, messageKey, conversationID, date, \</span>
<a href="#l23.515"></a><span id="l23.515">                              headerMessageID, jsonAttributes, notability) \</span>
<a href="#l23.516"></a><span id="l23.516" class="difflineat">@@ -1819,20 +1888,16 @@ var GlodaDatastore = {</span>
<a href="#l23.517"></a><span id="l23.517">     let message = new GlodaMessage(</span>
<a href="#l23.518"></a><span id="l23.518">       this, messageID, folderID,</span>
<a href="#l23.519"></a><span id="l23.519">       aMessageKey,</span>
<a href="#l23.520"></a><span id="l23.520">       aConversationID, /* conversation */ null,</span>
<a href="#l23.521"></a><span id="l23.521">       aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l23.522"></a><span id="l23.522">       aHeaderMessageID,</span>
<a href="#l23.523"></a><span id="l23.523">       /* deleted */ false, /* jsonText */ undefined, /* notability*/ 0);</span>
<a href="#l23.524"></a><span id="l23.524"> </span>
<a href="#l23.525"></a><span id="l23.525" class="difflineminus">-    this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l23.526"></a><span id="l23.526" class="difflineminus">-                    aConversationID + &quot;, &quot; + aDatePRTime + &quot;, &quot; +</span>
<a href="#l23.527"></a><span id="l23.527" class="difflineminus">-                    aHeaderMessageID);</span>
<a href="#l23.528"></a><span id="l23.528" class="difflineminus">-</span>
<a href="#l23.529"></a><span id="l23.529">     // We would love to notify the collection manager about the message at this</span>
<a href="#l23.530"></a><span id="l23.530">     //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l23.531"></a><span id="l23.531">     //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l23.532"></a><span id="l23.532">     //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l23.533"></a><span id="l23.533"> </span>
<a href="#l23.534"></a><span id="l23.534">     return message;</span>
<a href="#l23.535"></a><span id="l23.535">   },</span>
<a href="#l23.536"></a><span id="l23.536"> </span>
<a href="#l23.537"></a><span id="l23.537" class="difflineat">@@ -1914,18 +1979,19 @@ var GlodaDatastore = {</span>
<a href="#l23.538"></a><span id="l23.538">   get _updateMessageStatement() {</span>
<a href="#l23.539"></a><span id="l23.539">     let statement = this._createAsyncStatement(</span>
<a href="#l23.540"></a><span id="l23.540">       &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l23.541"></a><span id="l23.541">                            messageKey = ?2, \</span>
<a href="#l23.542"></a><span id="l23.542">                            conversationID = ?3, \</span>
<a href="#l23.543"></a><span id="l23.543">                            date = ?4, \</span>
<a href="#l23.544"></a><span id="l23.544">                            headerMessageID = ?5, \</span>
<a href="#l23.545"></a><span id="l23.545">                            jsonAttributes = ?6, \</span>
<a href="#l23.546"></a><span id="l23.546" class="difflineminus">-                           notability = ?7 \</span>
<a href="#l23.547"></a><span id="l23.547" class="difflineminus">-              WHERE id = ?8&quot;);</span>
<a href="#l23.548"></a><span id="l23.548" class="difflineplus">+                           notability = ?7, \</span>
<a href="#l23.549"></a><span id="l23.549" class="difflineplus">+                           deleted = ?8 \</span>
<a href="#l23.550"></a><span id="l23.550" class="difflineplus">+              WHERE id = ?9&quot;);</span>
<a href="#l23.551"></a><span id="l23.551">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l23.552"></a><span id="l23.552">     return this._updateMessageStatement;</span>
<a href="#l23.553"></a><span id="l23.553">   },</span>
<a href="#l23.554"></a><span id="l23.554"> </span>
<a href="#l23.555"></a><span id="l23.555">   get _updateMessageTextStatement() {</span>
<a href="#l23.556"></a><span id="l23.556">     let statement = this._createAsyncStatement(</span>
<a href="#l23.557"></a><span id="l23.557">       &quot;UPDATE messagesText SET body = ?1, \</span>
<a href="#l23.558"></a><span id="l23.558">                                attachmentNames = ?2 \</span>
<a href="#l23.559"></a><span id="l23.559" class="difflineat">@@ -1941,17 +2007,17 @@ var GlodaDatastore = {</span>
<a href="#l23.560"></a><span id="l23.560">    *</span>
<a href="#l23.561"></a><span id="l23.561">    * aMessage._isNew is currently equivalent to the fact that there is no</span>
<a href="#l23.562"></a><span id="l23.562">    * full-text row associated with this message, and we work with this</span>
<a href="#l23.563"></a><span id="l23.563">    * assumption here. Note that if aMessage._isNew is not defined, then</span>
<a href="#l23.564"></a><span id="l23.564">    * we don't do anything.</span>
<a href="#l23.565"></a><span id="l23.565">    */</span>
<a href="#l23.566"></a><span id="l23.566">   updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l23.567"></a><span id="l23.567">     let ums = this._updateMessageStatement;</span>
<a href="#l23.568"></a><span id="l23.568" class="difflineminus">-    ums.bindInt64Parameter(7, aMessage.id);</span>
<a href="#l23.569"></a><span id="l23.569" class="difflineplus">+    ums.bindInt64Parameter(8, aMessage.id);</span>
<a href="#l23.570"></a><span id="l23.570">     if (aMessage.folderID === null)</span>
<a href="#l23.571"></a><span id="l23.571">       ums.bindNullParameter(0);</span>
<a href="#l23.572"></a><span id="l23.572">     else</span>
<a href="#l23.573"></a><span id="l23.573">       ums.bindInt64Parameter(0, aMessage.folderID);</span>
<a href="#l23.574"></a><span id="l23.574">     if (aMessage.messageKey === null)</span>
<a href="#l23.575"></a><span id="l23.575">       ums.bindNullParameter(1);</span>
<a href="#l23.576"></a><span id="l23.576">     else</span>
<a href="#l23.577"></a><span id="l23.577">       ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l23.578"></a><span id="l23.578" class="difflineat">@@ -1961,16 +2027,17 @@ var GlodaDatastore = {</span>
<a href="#l23.579"></a><span id="l23.579">     else</span>
<a href="#l23.580"></a><span id="l23.580">       ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l23.581"></a><span id="l23.581">     ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l23.582"></a><span id="l23.582">     if (aMessage._jsonText)</span>
<a href="#l23.583"></a><span id="l23.583">       ums.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l23.584"></a><span id="l23.584">     else</span>
<a href="#l23.585"></a><span id="l23.585">       ums.bindNullParameter(5);</span>
<a href="#l23.586"></a><span id="l23.586">     ums.bindInt64Parameter(6, aMessage.notability);</span>
<a href="#l23.587"></a><span id="l23.587" class="difflineplus">+    ums.bindInt64Parameter(7, (&quot;_deleted&quot; in aMessage) &amp;&amp; aMessage.deleted);</span>
<a href="#l23.588"></a><span id="l23.588"> </span>
<a href="#l23.589"></a><span id="l23.589">     ums.executeAsync(this.trackAsync());</span>
<a href="#l23.590"></a><span id="l23.590"> </span>
<a href="#l23.591"></a><span id="l23.591">     if (aMessage.folderID !== null) {</span>
<a href="#l23.592"></a><span id="l23.592">       if (aMessage._isNew === true)</span>
<a href="#l23.593"></a><span id="l23.593">         this._insertMessageText(aMessage);</span>
<a href="#l23.594"></a><span id="l23.594">       else</span>
<a href="#l23.595"></a><span id="l23.595">         this._updateMessageText(aMessage);</span>
<a href="#l23.596"></a><span id="l23.596" class="difflineat">@@ -1998,17 +2065,16 @@ var GlodaDatastore = {</span>
<a href="#l23.597"></a><span id="l23.597"> </span>
<a href="#l23.598"></a><span id="l23.598">     // If the body text matches, don't perform an update</span>
<a href="#l23.599"></a><span id="l23.599">     if (newIndexedBodyText == aMessage._indexedBodyText) {</span>
<a href="#l23.600"></a><span id="l23.600">       this._log.debug(&quot;in _updateMessageText, skipping update because body matches&quot;);</span>
<a href="#l23.601"></a><span id="l23.601">       return;</span>
<a href="#l23.602"></a><span id="l23.602">     }</span>
<a href="#l23.603"></a><span id="l23.603"> </span>
<a href="#l23.604"></a><span id="l23.604">     aMessage._indexedBodyText = newIndexedBodyText;</span>
<a href="#l23.605"></a><span id="l23.605" class="difflineminus">-</span>
<a href="#l23.606"></a><span id="l23.606">     let umts = this._updateMessageTextStatement;</span>
<a href="#l23.607"></a><span id="l23.607">     umts.bindInt64Parameter(2, aMessage.id);</span>
<a href="#l23.608"></a><span id="l23.608"> </span>
<a href="#l23.609"></a><span id="l23.609">     if (aMessage._indexedBodyText == null)</span>
<a href="#l23.610"></a><span id="l23.610">       umts.bindNullParameter(0);</span>
<a href="#l23.611"></a><span id="l23.611">     else</span>
<a href="#l23.612"></a><span id="l23.612">       umts.bindStringParameter(0, aMessage._indexedBodyText);</span>
<a href="#l23.613"></a><span id="l23.613"> </span>
<a href="#l23.614"></a><span id="l23.614" class="difflineat">@@ -2036,82 +2102,76 @@ var GlodaDatastore = {</span>
<a href="#l23.615"></a><span id="l23.615">   },</span>
<a href="#l23.616"></a><span id="l23.616"> </span>
<a href="#l23.617"></a><span id="l23.617">   /**</span>
<a href="#l23.618"></a><span id="l23.618">    * Given a list of gloda message ids, and a list of their new message keys in</span>
<a href="#l23.619"></a><span id="l23.619">    *  the given new folder location, asynchronously update the message's</span>
<a href="#l23.620"></a><span id="l23.620">    *  database locations.  Also, update the in-memory representations.</span>
<a href="#l23.621"></a><span id="l23.621">    */</span>
<a href="#l23.622"></a><span id="l23.622">   updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l23.623"></a><span id="l23.623" class="difflineminus">-      aNewMessageKeys, aDestFolder) {</span>
<a href="#l23.624"></a><span id="l23.624" class="difflineplus">+      aNewMessageKeys, aDestFolder, aDoNotNotify) {</span>
<a href="#l23.625"></a><span id="l23.625">     let statement = this._updateMessageLocationStatement;</span>
<a href="#l23.626"></a><span id="l23.626" class="difflineminus">-    let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l23.627"></a><span id="l23.627" class="difflineplus">+    let destFolderID = (typeof(aDestFolder) == &quot;number&quot;) ? aDestFolder :</span>
<a href="#l23.628"></a><span id="l23.628" class="difflineplus">+                         this._mapFolder(aDestFolder).id;</span>
<a href="#l23.629"></a><span id="l23.629"> </span>
<a href="#l23.630"></a><span id="l23.630">     let modifiedItems = [];</span>
<a href="#l23.631"></a><span id="l23.631"> </span>
<a href="#l23.632"></a><span id="l23.632">     for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l23.633"></a><span id="l23.633">       let id = aMessageIds[iMsg];</span>
<a href="#l23.634"></a><span id="l23.634">       statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l23.635"></a><span id="l23.635">       statement.bindInt64Parameter(1, aNewMessageKeys[iMsg]);</span>
<a href="#l23.636"></a><span id="l23.636">       statement.bindInt64Parameter(2, id);</span>
<a href="#l23.637"></a><span id="l23.637">       statement.executeAsync(this.trackAsync());</span>
<a href="#l23.638"></a><span id="l23.638"> </span>
<a href="#l23.639"></a><span id="l23.639">       // so, if the message is currently loaded, we also need to change it up...</span>
<a href="#l23.640"></a><span id="l23.640" class="difflineplus">+      // XXX we should be using cacheLookupMany.</span>
<a href="#l23.641"></a><span id="l23.641">       let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l23.642"></a><span id="l23.642">         GlodaMessage.prototype.NOUN_ID, id);</span>
<a href="#l23.643"></a><span id="l23.643">       if (message) {</span>
<a href="#l23.644"></a><span id="l23.644">         message._folderID = destFolderID;</span>
<a href="#l23.645"></a><span id="l23.645" class="difflineplus">+        message._messageKey = aNewMessageKeys[iMsg];</span>
<a href="#l23.646"></a><span id="l23.646">         modifiedItems.push(message);</span>
<a href="#l23.647"></a><span id="l23.647">       }</span>
<a href="#l23.648"></a><span id="l23.648">     }</span>
<a href="#l23.649"></a><span id="l23.649"> </span>
<a href="#l23.650"></a><span id="l23.650" class="difflineminus">-    // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l23.651"></a><span id="l23.651" class="difflineminus">-    //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l23.652"></a><span id="l23.652" class="difflineminus">-    //  synchronous reads off (this) the main thread.</span>
<a href="#l23.653"></a><span id="l23.653" class="difflineminus">-    if ((aMessageIds.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l23.654"></a><span id="l23.654" class="difflineminus">-      this._commitTransaction();</span>
<a href="#l23.655"></a><span id="l23.655" class="difflineminus">-      this._beginTransaction();</span>
<a href="#l23.656"></a><span id="l23.656" class="difflineminus">-    }</span>
<a href="#l23.657"></a><span id="l23.657" class="difflineminus">-</span>
<a href="#l23.658"></a><span id="l23.658">     // tell the collection manager about the modified messages so it can update</span>
<a href="#l23.659"></a><span id="l23.659">     //  any existing views...</span>
<a href="#l23.660"></a><span id="l23.660" class="difflineminus">-    if (modifiedItems.length) {</span>
<a href="#l23.661"></a><span id="l23.661" class="difflineminus">-      GlodaCollectionManager.itemsModified(GlodaMessage.prototype.NOUN,</span>
<a href="#l23.662"></a><span id="l23.662" class="difflineplus">+    if (!aDoNotNotify &amp;&amp; modifiedItems.length) {</span>
<a href="#l23.663"></a><span id="l23.663" class="difflineplus">+      GlodaCollectionManager.itemsModified(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l23.664"></a><span id="l23.664">                                            modifiedItems);</span>
<a href="#l23.665"></a><span id="l23.665">     }</span>
<a href="#l23.666"></a><span id="l23.666">   },</span>
<a href="#l23.667"></a><span id="l23.667"> </span>
<a href="#l23.668"></a><span id="l23.668">   /**</span>
<a href="#l23.669"></a><span id="l23.669">    * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l23.670"></a><span id="l23.670">    *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l23.671"></a><span id="l23.671">    *  don't yet know their target message keys.</span>
<a href="#l23.672"></a><span id="l23.672" class="difflineplus">+   *</span>
<a href="#l23.673"></a><span id="l23.673" class="difflineplus">+   * Updates in-memory representations too.</span>
<a href="#l23.674"></a><span id="l23.674">    */</span>
<a href="#l23.675"></a><span id="l23.675">   updateMessageFoldersByKeyPurging:</span>
<a href="#l23.676"></a><span id="l23.676" class="difflineminus">-      function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolder,</span>
<a href="#l23.677"></a><span id="l23.677" class="difflineminus">-        aMessageKeys, aDestFolder) {</span>
<a href="#l23.678"></a><span id="l23.678" class="difflineminus">-    let srcFolderID = this._mapFolder(aSrcFolder).id;</span>
<a href="#l23.679"></a><span id="l23.679" class="difflineplus">+      function gloda_ds_updateMessageFoldersByKeyPurging(aGlodaIds,</span>
<a href="#l23.680"></a><span id="l23.680" class="difflineplus">+                                                         aDestFolder) {</span>
<a href="#l23.681"></a><span id="l23.681">     let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l23.682"></a><span id="l23.682"> </span>
<a href="#l23.683"></a><span id="l23.683">     let sqlStr = &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l23.684"></a><span id="l23.684">                                       messageKey = ?2 \</span>
<a href="#l23.685"></a><span id="l23.685" class="difflineminus">-                   WHERE folderID = ?3 \</span>
<a href="#l23.686"></a><span id="l23.686" class="difflineminus">-                     AND messageKey IN (&quot; + aMessageKeys.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l23.687"></a><span id="l23.687" class="difflineplus">+                   WHERE id IN (&quot; + aGlodaIds.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l23.688"></a><span id="l23.688">     let statement = this._createAsyncStatement(sqlStr, true);</span>
<a href="#l23.689"></a><span id="l23.689" class="difflineminus">-    statement.bindInt64Parameter(2, srcFolderID);</span>
<a href="#l23.690"></a><span id="l23.690">     statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l23.691"></a><span id="l23.691">     statement.bindNullParameter(1);</span>
<a href="#l23.692"></a><span id="l23.692">     statement.executeAsync(this.trackAsync());</span>
<a href="#l23.693"></a><span id="l23.693">     statement.finalize();</span>
<a href="#l23.694"></a><span id="l23.694"> </span>
<a href="#l23.695"></a><span id="l23.695" class="difflineminus">-    // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l23.696"></a><span id="l23.696" class="difflineminus">-    //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l23.697"></a><span id="l23.697" class="difflineminus">-    //  synchronous reads off (this) the main thread.</span>
<a href="#l23.698"></a><span id="l23.698" class="difflineminus">-    if ((aMessageKeys.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l23.699"></a><span id="l23.699" class="difflineminus">-      this._commitTransaction();</span>
<a href="#l23.700"></a><span id="l23.700" class="difflineminus">-      this._beginTransaction();</span>
<a href="#l23.701"></a><span id="l23.701" class="difflineplus">+    let cached =</span>
<a href="#l23.702"></a><span id="l23.702" class="difflineplus">+      GlodaCollectionManager.cacheLookupManyList(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l23.703"></a><span id="l23.703" class="difflineplus">+                                                 aGlodaIds);</span>
<a href="#l23.704"></a><span id="l23.704" class="difflineplus">+    for each (let [, glodaMsg] in Iterator(cached)) {</span>
<a href="#l23.705"></a><span id="l23.705" class="difflineplus">+      glodaMsg._folderID = destFolderID;</span>
<a href="#l23.706"></a><span id="l23.706" class="difflineplus">+      glodaMsg._messageKey = null;</span>
<a href="#l23.707"></a><span id="l23.707">     }</span>
<a href="#l23.708"></a><span id="l23.708">   },</span>
<a href="#l23.709"></a><span id="l23.709"> </span>
<a href="#l23.710"></a><span id="l23.710">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l23.711"></a><span id="l23.711">     let folderId, messageKey, date, jsonText, subject, indexedBodyText,</span>
<a href="#l23.712"></a><span id="l23.712">         attachmentNames;</span>
<a href="#l23.713"></a><span id="l23.713">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l23.714"></a><span id="l23.714">       folderId = null;</span>
<a href="#l23.715"></a><span id="l23.715" class="difflineat">@@ -2152,228 +2212,115 @@ var GlodaDatastore = {</span>
<a href="#l23.716"></a><span id="l23.716">       // we ignore 13, recipients</span>
<a href="#l23.717"></a><span id="l23.717">     }</span>
<a href="#l23.718"></a><span id="l23.718">     return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l23.719"></a><span id="l23.719">                             aRow.getInt64(3), null, date, aRow.getString(5),</span>
<a href="#l23.720"></a><span id="l23.720">                             aRow.getInt64(6), jsonText, aRow.getInt64(8),</span>
<a href="#l23.721"></a><span id="l23.721">                             subject, indexedBodyText, attachmentNames);</span>
<a href="#l23.722"></a><span id="l23.722">   },</span>
<a href="#l23.723"></a><span id="l23.723"> </span>
<a href="#l23.724"></a><span id="l23.724" class="difflineminus">-  get _selectMessageByIDStatement() {</span>
<a href="#l23.725"></a><span id="l23.725" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.726"></a><span id="l23.726" class="difflineminus">-      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID, \</span>
<a href="#l23.727"></a><span id="l23.727" class="difflineminus">-           deleted FROM messages WHERE id = ?1&quot;);</span>
<a href="#l23.728"></a><span id="l23.728" class="difflineminus">-    this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l23.729"></a><span id="l23.729" class="difflineminus">-      function() statement);</span>
<a href="#l23.730"></a><span id="l23.730" class="difflineminus">-    return this._selectMessageByIDStatement;</span>
<a href="#l23.731"></a><span id="l23.731" class="difflineminus">-  },</span>
<a href="#l23.732"></a><span id="l23.732" class="difflineminus">-</span>
<a href="#l23.733"></a><span id="l23.733" class="difflineminus">-  /**</span>
<a href="#l23.734"></a><span id="l23.734" class="difflineminus">-   * Synchronously retrieve the given message given its gloda message id.</span>
<a href="#l23.735"></a><span id="l23.735" class="difflineminus">-   */</span>
<a href="#l23.736"></a><span id="l23.736" class="difflineminus">-  getMessageByID: function gloda_ds_getMessageByID(aID) {</span>
<a href="#l23.737"></a><span id="l23.737" class="difflineminus">-    let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l23.738"></a><span id="l23.738" class="difflineminus">-      GlodaMessage.prototype.NOUN_ID, aID);</span>
<a href="#l23.739"></a><span id="l23.739" class="difflineminus">-</span>
<a href="#l23.740"></a><span id="l23.740" class="difflineminus">-    if (message === null) {</span>
<a href="#l23.741"></a><span id="l23.741" class="difflineminus">-      let smbis = this._selectMessageByIDStatement;</span>
<a href="#l23.742"></a><span id="l23.742" class="difflineminus">-</span>
<a href="#l23.743"></a><span id="l23.743" class="difflineminus">-      smbis.bindInt64Parameter(0, aID);</span>
<a href="#l23.744"></a><span id="l23.744" class="difflineminus">-      if (this._syncStep(smbis)) {</span>
<a href="#l23.745"></a><span id="l23.745" class="difflineminus">-        message = this._messageFromRow(smbis);</span>
<a href="#l23.746"></a><span id="l23.746" class="difflineminus">-        GlodaCollectionManager.itemLoaded(message);</span>
<a href="#l23.747"></a><span id="l23.747" class="difflineminus">-      }</span>
<a href="#l23.748"></a><span id="l23.748" class="difflineminus">-      smbis.reset();</span>
<a href="#l23.749"></a><span id="l23.749" class="difflineminus">-    }</span>
<a href="#l23.750"></a><span id="l23.750" class="difflineminus">-</span>
<a href="#l23.751"></a><span id="l23.751" class="difflineminus">-    return message;</span>
<a href="#l23.752"></a><span id="l23.752" class="difflineminus">-  },</span>
<a href="#l23.753"></a><span id="l23.753" class="difflineminus">-</span>
<a href="#l23.754"></a><span id="l23.754" class="difflineminus">-  get _selectMessageByLocationStatement() {</span>
<a href="#l23.755"></a><span id="l23.755" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.756"></a><span id="l23.756" class="difflineminus">-      &quot;SELECT * FROM messages WHERE folderID = ?1 AND messageKey = ?2&quot;);</span>
<a href="#l23.757"></a><span id="l23.757" class="difflineminus">-    this.__defineGetter__(&quot;_selectMessageByLocationStatement&quot;,</span>
<a href="#l23.758"></a><span id="l23.758" class="difflineminus">-      function() statement);</span>
<a href="#l23.759"></a><span id="l23.759" class="difflineminus">-    return this._selectMessageByLocationStatement;</span>
<a href="#l23.760"></a><span id="l23.760" class="difflineminus">-  },</span>
<a href="#l23.761"></a><span id="l23.761" class="difflineminus">-</span>
<a href="#l23.762"></a><span id="l23.762" class="difflineminus">-  /**</span>
<a href="#l23.763"></a><span id="l23.763" class="difflineminus">-   * Synchronously retrieve the message that we believe to correspond to the</span>
<a href="#l23.764"></a><span id="l23.764" class="difflineminus">-   *  given message key in the given folder.</span>
<a href="#l23.765"></a><span id="l23.765" class="difflineminus">-   * @return null on failure to locate the message, the message on success.</span>
<a href="#l23.766"></a><span id="l23.766" class="difflineminus">-   *</span>
<a href="#l23.767"></a><span id="l23.767" class="difflineminus">-   * @XXX on failure, attempt to resolve the problem through re-indexing, etc.</span>
<a href="#l23.768"></a><span id="l23.768" class="difflineminus">-   */</span>
<a href="#l23.769"></a><span id="l23.769" class="difflineminus">-  getMessageFromLocation: function gloda_ds_getMessageFromLocation(aFolder,</span>
<a href="#l23.770"></a><span id="l23.770" class="difflineminus">-                                                                 aMessageKey) {</span>
<a href="#l23.771"></a><span id="l23.771" class="difflineminus">-    this._selectMessageByLocationStatement.bindInt64Parameter(0,</span>
<a href="#l23.772"></a><span id="l23.772" class="difflineminus">-      this._mapFolder(aFolder).id);</span>
<a href="#l23.773"></a><span id="l23.773" class="difflineminus">-    this._selectMessageByLocationStatement.bindInt64Parameter(1, aMessageKey);</span>
<a href="#l23.774"></a><span id="l23.774" class="difflineminus">-</span>
<a href="#l23.775"></a><span id="l23.775" class="difflineminus">-    let message = null;</span>
<a href="#l23.776"></a><span id="l23.776" class="difflineminus">-    if (this._syncStep(this._selectMessageByLocationStatement))</span>
<a href="#l23.777"></a><span id="l23.777" class="difflineminus">-      message = this._messageFromRow(this._selectMessageByLocationStatement);</span>
<a href="#l23.778"></a><span id="l23.778" class="difflineminus">-    this._selectMessageByLocationStatement.reset();</span>
<a href="#l23.779"></a><span id="l23.779" class="difflineminus">-</span>
<a href="#l23.780"></a><span id="l23.780" class="difflineminus">-    if (message === null)</span>
<a href="#l23.781"></a><span id="l23.781" class="difflineminus">-      this._log.info(&quot;Error locating message with key=&quot; + aMessageKey +</span>
<a href="#l23.782"></a><span id="l23.782" class="difflineminus">-                     &quot; and URI &quot; + aFolder.URI);</span>
<a href="#l23.783"></a><span id="l23.783" class="difflineminus">-</span>
<a href="#l23.784"></a><span id="l23.784" class="difflineminus">-    return message &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(message);</span>
<a href="#l23.785"></a><span id="l23.785" class="difflineminus">-  },</span>
<a href="#l23.786"></a><span id="l23.786" class="difflineminus">-</span>
<a href="#l23.787"></a><span id="l23.787" class="difflineminus">-  get _selectMessageIDsByFolderStatement() {</span>
<a href="#l23.788"></a><span id="l23.788" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.789"></a><span id="l23.789" class="difflineminus">-      &quot;SELECT id FROM messages WHERE folderID = ?1&quot;);</span>
<a href="#l23.790"></a><span id="l23.790" class="difflineminus">-    this.__defineGetter__(&quot;_selectMessageIDsByFolderStatement&quot;,</span>
<a href="#l23.791"></a><span id="l23.791" class="difflineminus">-      function() statement);</span>
<a href="#l23.792"></a><span id="l23.792" class="difflineminus">-    return this._selectMessageIDsByFolderStatement;</span>
<a href="#l23.793"></a><span id="l23.793" class="difflineminus">-  },</span>
<a href="#l23.794"></a><span id="l23.794" class="difflineminus">-</span>
<a href="#l23.795"></a><span id="l23.795" class="difflineminus">-  getMessageIDsByFolderID:</span>
<a href="#l23.796"></a><span id="l23.796" class="difflineminus">-      function gloda_ds_getMessageIDsFromFolderID(aFolderID) {</span>
<a href="#l23.797"></a><span id="l23.797" class="difflineminus">-    let messageIDs = [];</span>
<a href="#l23.798"></a><span id="l23.798" class="difflineminus">-</span>
<a href="#l23.799"></a><span id="l23.799" class="difflineminus">-    let smidbfs = this._selectMessageIDsByFolderStatement;</span>
<a href="#l23.800"></a><span id="l23.800" class="difflineminus">-    smidbfs.bindInt64Parameter(0, aFolderID);</span>
<a href="#l23.801"></a><span id="l23.801" class="difflineminus">-</span>
<a href="#l23.802"></a><span id="l23.802" class="difflineminus">-    while (this._syncStep(smidbfs)) {</span>
<a href="#l23.803"></a><span id="l23.803" class="difflineminus">-      messageIDs.push(smidbfs.getInt64(0));</span>
<a href="#l23.804"></a><span id="l23.804" class="difflineminus">-    }</span>
<a href="#l23.805"></a><span id="l23.805" class="difflineminus">-    smidbfs.reset();</span>
<a href="#l23.806"></a><span id="l23.806" class="difflineminus">-</span>
<a href="#l23.807"></a><span id="l23.807" class="difflineminus">-    return messageIDs;</span>
<a href="#l23.808"></a><span id="l23.808" class="difflineminus">-  },</span>
<a href="#l23.809"></a><span id="l23.809" class="difflineminus">-</span>
<a href="#l23.810"></a><span id="l23.810">   get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l23.811"></a><span id="l23.811">     let statement = this._createAsyncStatement(</span>
<a href="#l23.812"></a><span id="l23.812">       &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l23.813"></a><span id="l23.813">               deleted = 1 WHERE folderID = ?1&quot;);</span>
<a href="#l23.814"></a><span id="l23.814">     this.__defineGetter__(&quot;_updateMessagesMarkDeletedByFolderID&quot;,</span>
<a href="#l23.815"></a><span id="l23.815">       function() statement);</span>
<a href="#l23.816"></a><span id="l23.816">     return this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l23.817"></a><span id="l23.817">   },</span>
<a href="#l23.818"></a><span id="l23.818"> </span>
<a href="#l23.819"></a><span id="l23.819" class="difflineplus">+  /**</span>
<a href="#l23.820"></a><span id="l23.820" class="difflineplus">+   * Efficiently mark all the messages in a folder as deleted.  Unfortunately,</span>
<a href="#l23.821"></a><span id="l23.821" class="difflineplus">+   *  we obviously do not know the id's of the messages affected by this which</span>
<a href="#l23.822"></a><span id="l23.822" class="difflineplus">+   *  complicates in-memory updates.  The options are sending out to the SQL</span>
<a href="#l23.823"></a><span id="l23.823" class="difflineplus">+   *  database for a list of the message id's or some form of in-memory</span>
<a href="#l23.824"></a><span id="l23.824" class="difflineplus">+   *  traversal.  I/O costs being what they are, users having a propensity to</span>
<a href="#l23.825"></a><span id="l23.825" class="difflineplus">+   *  have folders with tens of thousands of messages, and the unlikeliness</span>
<a href="#l23.826"></a><span id="l23.826" class="difflineplus">+   *  of all of those messages being gloda-memory-resident, we go with the</span>
<a href="#l23.827"></a><span id="l23.827" class="difflineplus">+   *  in-memory traversal.</span>
<a href="#l23.828"></a><span id="l23.828" class="difflineplus">+   */</span>
<a href="#l23.829"></a><span id="l23.829">   markMessagesDeletedByFolderID:</span>
<a href="#l23.830"></a><span id="l23.830">       function gloda_ds_markMessagesDeletedByFolderID(aFolderID) {</span>
<a href="#l23.831"></a><span id="l23.831">     let statement = this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l23.832"></a><span id="l23.832">     statement.bindInt64Parameter(0, aFolderID);</span>
<a href="#l23.833"></a><span id="l23.833">     statement.executeAsync(this.trackAsync());</span>
<a href="#l23.834"></a><span id="l23.834" class="difflineplus">+</span>
<a href="#l23.835"></a><span id="l23.835" class="difflineplus">+    // Have the collection manager generate itemsRemoved events for any</span>
<a href="#l23.836"></a><span id="l23.836" class="difflineplus">+    //  in-memory messages in that folder.</span>
<a href="#l23.837"></a><span id="l23.837" class="difflineplus">+    GlodaCollectionManager.itemsDeletedByAttribute(</span>
<a href="#l23.838"></a><span id="l23.838" class="difflineplus">+      GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l23.839"></a><span id="l23.839" class="difflineplus">+      function(aMsg) aMsg._folderID == aFolderID);</span>
<a href="#l23.840"></a><span id="l23.840">   },</span>
<a href="#l23.841"></a><span id="l23.841"> </span>
<a href="#l23.842"></a><span id="l23.842" class="difflineplus">+  /**</span>
<a href="#l23.843"></a><span id="l23.843" class="difflineplus">+   * Mark all the gloda messages as deleted blind-fire.  Check if any of the</span>
<a href="#l23.844"></a><span id="l23.844" class="difflineplus">+   *  messages are known to the collection manager and update them to be deleted</span>
<a href="#l23.845"></a><span id="l23.845" class="difflineplus">+   *  along with the requisite collection notifications.</span>
<a href="#l23.846"></a><span id="l23.846" class="difflineplus">+   */</span>
<a href="#l23.847"></a><span id="l23.847">   markMessagesDeletedByIDs: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l23.848"></a><span id="l23.848">       aMessageIDs) {</span>
<a href="#l23.849"></a><span id="l23.849">     let sqlString = &quot;UPDATE messages SET deleted = 1 WHERE id IN (&quot; +</span>
<a href="#l23.850"></a><span id="l23.850">       aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l23.851"></a><span id="l23.851"> </span>
<a href="#l23.852"></a><span id="l23.852">     let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l23.853"></a><span id="l23.853">     statement.executeAsync(this.trackAsync());</span>
<a href="#l23.854"></a><span id="l23.854">     statement.finalize();</span>
<a href="#l23.855"></a><span id="l23.855"> </span>
<a href="#l23.856"></a><span id="l23.856" class="difflineminus">-    // some people are inclined to deleting ridiculous numbers of messages at</span>
<a href="#l23.857"></a><span id="l23.857" class="difflineminus">-    //  a time.  if we are in a transaction, this has the potential to cause us</span>
<a href="#l23.858"></a><span id="l23.858" class="difflineminus">-    //  to spill the transaction to disk prior to disk, resulting in a lock</span>
<a href="#l23.859"></a><span id="l23.859" class="difflineminus">-    //  escalation and making any synchronous reads from the main thread need</span>
<a href="#l23.860"></a><span id="l23.860" class="difflineminus">-    //  to become blocking.  We don't want that, so:</span>
<a href="#l23.861"></a><span id="l23.861" class="difflineminus">-    // If we are in a transaction and there are a &quot;lot&quot; of messages being</span>
<a href="#l23.862"></a><span id="l23.862" class="difflineminus">-    //  marked as deleted, issue a commit and then re-open the transaction.</span>
<a href="#l23.863"></a><span id="l23.863" class="difflineminus">-    if ((aMessageIDs.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l23.864"></a><span id="l23.864" class="difflineminus">-      this._commitTransaction();</span>
<a href="#l23.865"></a><span id="l23.865" class="difflineminus">-      this._beginTransaction();</span>
<a href="#l23.866"></a><span id="l23.866" class="difflineminus">-    }</span>
<a href="#l23.867"></a><span id="l23.867" class="difflineplus">+    GlodaCollectionManager.itemsDeleted(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l23.868"></a><span id="l23.868" class="difflineplus">+                                        aMessageIDs);</span>
<a href="#l23.869"></a><span id="l23.869">   },</span>
<a href="#l23.870"></a><span id="l23.870"> </span>
<a href="#l23.871"></a><span id="l23.871">   get _deleteMessageByIDStatement() {</span>
<a href="#l23.872"></a><span id="l23.872">     let statement = this._createAsyncStatement(</span>
<a href="#l23.873"></a><span id="l23.873">       &quot;DELETE FROM messages WHERE id = ?1&quot;);</span>
<a href="#l23.874"></a><span id="l23.874">     this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l23.875"></a><span id="l23.875">                           function() statement);</span>
<a href="#l23.876"></a><span id="l23.876">     return this._deleteMessageByIDStatement;</span>
<a href="#l23.877"></a><span id="l23.877">   },</span>
<a href="#l23.878"></a><span id="l23.878"> </span>
<a href="#l23.879"></a><span id="l23.879" class="difflineminus">-  deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l23.880"></a><span id="l23.880" class="difflineminus">-    // TODO: collection manager implications</span>
<a href="#l23.881"></a><span id="l23.881" class="difflineminus">-    let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l23.882"></a><span id="l23.882" class="difflineminus">-    dmbids.bindInt64Parameter(0, aMessageID);</span>
<a href="#l23.883"></a><span id="l23.883" class="difflineminus">-    dmbids.executeAsync(this.trackAsync());</span>
<a href="#l23.884"></a><span id="l23.884" class="difflineminus">-  },</span>
<a href="#l23.885"></a><span id="l23.885" class="difflineminus">-</span>
<a href="#l23.886"></a><span id="l23.886" class="difflineminus">-  get _deleteMessagesByConversationIDStatement() {</span>
<a href="#l23.887"></a><span id="l23.887" class="difflineplus">+  get _deleteMessageTextByIDStatement() {</span>
<a href="#l23.888"></a><span id="l23.888">     let statement = this._createAsyncStatement(</span>
<a href="#l23.889"></a><span id="l23.889" class="difflineminus">-      &quot;DELETE FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l23.890"></a><span id="l23.890" class="difflineminus">-    this.__defineGetter__(&quot;_deleteMessagesByConversationIDStatement&quot;,</span>
<a href="#l23.891"></a><span id="l23.891" class="difflineplus">+      &quot;DELETE FROM messagesText WHERE docid = ?1&quot;);</span>
<a href="#l23.892"></a><span id="l23.892" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessageTextByIDStatement&quot;,</span>
<a href="#l23.893"></a><span id="l23.893">                           function() statement);</span>
<a href="#l23.894"></a><span id="l23.894" class="difflineminus">-    return this._deleteMessagesByConversationIDStatement;</span>
<a href="#l23.895"></a><span id="l23.895" class="difflineplus">+    return this._deleteMessageTextByIDStatement;</span>
<a href="#l23.896"></a><span id="l23.896">   },</span>
<a href="#l23.897"></a><span id="l23.897"> </span>
<a href="#l23.898"></a><span id="l23.898">   /**</span>
<a href="#l23.899"></a><span id="l23.899" class="difflineminus">-   * Delete messages by conversation ID.  For use by the indexer's deletion</span>
<a href="#l23.900"></a><span id="l23.900" class="difflineminus">-   *  logic, NOT you.</span>
<a href="#l23.901"></a><span id="l23.901" class="difflineplus">+   * Delete a message and its fulltext from the database.  It is assumed that</span>
<a href="#l23.902"></a><span id="l23.902" class="difflineplus">+   *  the message was already marked as deleted and so is not visible to the</span>
<a href="#l23.903"></a><span id="l23.903" class="difflineplus">+   *  collection manager and so nothing needs to be done about that.</span>
<a href="#l23.904"></a><span id="l23.904">    */</span>
<a href="#l23.905"></a><span id="l23.905" class="difflineminus">-  deleteMessagesByConversationID:</span>
<a href="#l23.906"></a><span id="l23.906" class="difflineminus">-    // TODO: collection manager implications</span>
<a href="#l23.907"></a><span id="l23.907" class="difflineminus">-      function gloda_ds_deleteMessagesByConversationID(aConversationID) {</span>
<a href="#l23.908"></a><span id="l23.908" class="difflineminus">-    let dmbcids = this._deleteMessagesByConversationIDStatement;</span>
<a href="#l23.909"></a><span id="l23.909" class="difflineminus">-    dmbcids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l23.910"></a><span id="l23.910" class="difflineminus">-    dmbcids.executeAsync(this.trackAsync());</span>
<a href="#l23.911"></a><span id="l23.911" class="difflineminus">-  },</span>
<a href="#l23.912"></a><span id="l23.912" class="difflineminus">-</span>
<a href="#l23.913"></a><span id="l23.913" class="difflineminus">-  get _selectMessagesByConversationIDStatement() {</span>
<a href="#l23.914"></a><span id="l23.914" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.915"></a><span id="l23.915" class="difflineminus">-      &quot;SELECT * FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l23.916"></a><span id="l23.916" class="difflineminus">-    this.__defineGetter__(&quot;_selectMessagesByConversationIDStatement&quot;,</span>
<a href="#l23.917"></a><span id="l23.917" class="difflineminus">-      function() statement);</span>
<a href="#l23.918"></a><span id="l23.918" class="difflineminus">-    return this._selectMessagesByConversationIDStatement;</span>
<a href="#l23.919"></a><span id="l23.919" class="difflineminus">-  },</span>
<a href="#l23.920"></a><span id="l23.920" class="difflineminus">-</span>
<a href="#l23.921"></a><span id="l23.921" class="difflineminus">-  get _selectMessagesByConversationIDNoGhostsStatement() {</span>
<a href="#l23.922"></a><span id="l23.922" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.923"></a><span id="l23.923" class="difflineminus">-      &quot;SELECT * FROM messages WHERE conversationID = ?1 AND \</span>
<a href="#l23.924"></a><span id="l23.924" class="difflineminus">-                                    folderID IS NOT NULL&quot;);</span>
<a href="#l23.925"></a><span id="l23.925" class="difflineminus">-    this.__defineGetter__(&quot;_selectMessagesByConversationIDNoGhostsStatement&quot;,</span>
<a href="#l23.926"></a><span id="l23.926" class="difflineminus">-      function() statement);</span>
<a href="#l23.927"></a><span id="l23.927" class="difflineminus">-    return this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l23.928"></a><span id="l23.928" class="difflineplus">+  deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l23.929"></a><span id="l23.929" class="difflineplus">+    let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l23.930"></a><span id="l23.930" class="difflineplus">+    dmbids.bindInt64Parameter(0, aMessageID);</span>
<a href="#l23.931"></a><span id="l23.931" class="difflineplus">+    dmbids.executeAsync(this.trackAsync());</span>
<a href="#l23.932"></a><span id="l23.932" class="difflineplus">+</span>
<a href="#l23.933"></a><span id="l23.933" class="difflineplus">+    let dmt = this._deleteMessageTextByIDStatement;</span>
<a href="#l23.934"></a><span id="l23.934" class="difflineplus">+    dmt.bindInt64Parameter(0, aMessageID);</span>
<a href="#l23.935"></a><span id="l23.935" class="difflineplus">+    dmt.executeAsync(this.trackAsync());</span>
<a href="#l23.936"></a><span id="l23.936">   },</span>
<a href="#l23.937"></a><span id="l23.937"> </span>
<a href="#l23.938"></a><span id="l23.938" class="difflineminus">-  /**</span>
<a href="#l23.939"></a><span id="l23.939" class="difflineminus">-   * Retrieve all the messages belonging to the given conversation.  This</span>
<a href="#l23.940"></a><span id="l23.940" class="difflineminus">-   *  method is used by the indexer and the GlodaConversation class and is not</span>
<a href="#l23.941"></a><span id="l23.941" class="difflineminus">-   *  intended to be used by any other code.  (Most other code should probably</span>
<a href="#l23.942"></a><span id="l23.942" class="difflineminus">-   *  use the GlodaConversation.messages attribute or the general purpose query</span>
<a href="#l23.943"></a><span id="l23.943" class="difflineminus">-   *  mechanism.)</span>
<a href="#l23.944"></a><span id="l23.944" class="difflineminus">-   *</span>
<a href="#l23.945"></a><span id="l23.945" class="difflineminus">-   * @param aConversationID The ID of the conversation for which you want all</span>
<a href="#l23.946"></a><span id="l23.946" class="difflineminus">-   *     the messages.</span>
<a href="#l23.947"></a><span id="l23.947" class="difflineminus">-   * @param aIncludeGhosts Boolean indicating whether you want 'ghost' messages</span>
<a href="#l23.948"></a><span id="l23.948" class="difflineminus">-   *     (true) or not (false).  'Ghost' messages are messages that exist in the</span>
<a href="#l23.949"></a><span id="l23.949" class="difflineminus">-   *     database purely for conversation tracking/threading purposes.  They</span>
<a href="#l23.950"></a><span id="l23.950" class="difflineminus">-   *     are markers for messages we have not yet seen yet assume must exist</span>
<a href="#l23.951"></a><span id="l23.951" class="difflineminus">-   *     based on references/in-reply-to headers from non-ghost messages in our</span>
<a href="#l23.952"></a><span id="l23.952" class="difflineminus">-   *     database.</span>
<a href="#l23.953"></a><span id="l23.953" class="difflineminus">-   */</span>
<a href="#l23.954"></a><span id="l23.954" class="difflineminus">-  getMessagesByConversationID: function gloda_ds_getMessagesByConversationID(</span>
<a href="#l23.955"></a><span id="l23.955" class="difflineminus">-        aConversationID, aIncludeGhosts) {</span>
<a href="#l23.956"></a><span id="l23.956" class="difflineminus">-    let statement;</span>
<a href="#l23.957"></a><span id="l23.957" class="difflineminus">-    if (aIncludeGhosts)</span>
<a href="#l23.958"></a><span id="l23.958" class="difflineminus">-      statement = this._selectMessagesByConversationIDStatement;</span>
<a href="#l23.959"></a><span id="l23.959" class="difflineminus">-    else</span>
<a href="#l23.960"></a><span id="l23.960" class="difflineminus">-      statement = this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l23.961"></a><span id="l23.961" class="difflineminus">-    statement.bindInt64Parameter(0, aConversationID);</span>
<a href="#l23.962"></a><span id="l23.962" class="difflineminus">-</span>
<a href="#l23.963"></a><span id="l23.963" class="difflineminus">-    let messages = [];</span>
<a href="#l23.964"></a><span id="l23.964" class="difflineminus">-    while (this._syncStep(statement)) {</span>
<a href="#l23.965"></a><span id="l23.965" class="difflineminus">-      messages.push(this._messageFromRow(statement));</span>
<a href="#l23.966"></a><span id="l23.966" class="difflineminus">-    }</span>
<a href="#l23.967"></a><span id="l23.967" class="difflineminus">-    statement.reset();</span>
<a href="#l23.968"></a><span id="l23.968" class="difflineminus">-</span>
<a href="#l23.969"></a><span id="l23.969" class="difflineminus">-    if (messages.length)</span>
<a href="#l23.970"></a><span id="l23.970" class="difflineminus">-      GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l23.971"></a><span id="l23.971" class="difflineminus">-                                            messages);</span>
<a href="#l23.972"></a><span id="l23.972" class="difflineminus">-</span>
<a href="#l23.973"></a><span id="l23.973" class="difflineminus">-    return messages;</span>
<a href="#l23.974"></a><span id="l23.974" class="difflineplus">+  get _folderCompactionStatement() {</span>
<a href="#l23.975"></a><span id="l23.975" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l23.976"></a><span id="l23.976" class="difflineplus">+      &quot;SELECT id, messageKey, headerMessageID FROM messages \</span>
<a href="#l23.977"></a><span id="l23.977" class="difflineplus">+        WHERE folderID = ?1 AND \</span>
<a href="#l23.978"></a><span id="l23.978" class="difflineplus">+          messageKey &gt;= ?2 AND +deleted = 0 ORDER BY messageKey LIMIT ?3&quot;);</span>
<a href="#l23.979"></a><span id="l23.979" class="difflineplus">+    this.__defineGetter__(&quot;_folderCompactionStatement&quot;,</span>
<a href="#l23.980"></a><span id="l23.980" class="difflineplus">+                          function() statement);</span>
<a href="#l23.981"></a><span id="l23.981" class="difflineplus">+    return this._folderCompactionStatement;</span>
<a href="#l23.982"></a><span id="l23.982" class="difflineplus">+  },</span>
<a href="#l23.983"></a><span id="l23.983" class="difflineplus">+</span>
<a href="#l23.984"></a><span id="l23.984" class="difflineplus">+  folderCompactionPassBlockFetch:</span>
<a href="#l23.985"></a><span id="l23.985" class="difflineplus">+      function gloda_ds_folderCompactionPassBlockFetch(</span>
<a href="#l23.986"></a><span id="l23.986" class="difflineplus">+        aFolderID, aStartingMessageKey, aLimit, aCallback) {</span>
<a href="#l23.987"></a><span id="l23.987" class="difflineplus">+    let fcs = this._folderCompactionStatement;</span>
<a href="#l23.988"></a><span id="l23.988" class="difflineplus">+    fcs.bindInt64Parameter(0, aFolderID);</span>
<a href="#l23.989"></a><span id="l23.989" class="difflineplus">+    fcs.bindInt64Parameter(1, aStartingMessageKey);</span>
<a href="#l23.990"></a><span id="l23.990" class="difflineplus">+    fcs.bindInt64Parameter(2, aLimit);</span>
<a href="#l23.991"></a><span id="l23.991" class="difflineplus">+    fcs.executeAsync(new CompactionBlockFetcherHandler(aCallback));</span>
<a href="#l23.992"></a><span id="l23.992">   },</span>
<a href="#l23.993"></a><span id="l23.993"> </span>
<a href="#l23.994"></a><span id="l23.994">   /* ********** Message Attributes ********** */</span>
<a href="#l23.995"></a><span id="l23.995">   get _insertMessageAttributeStatement() {</span>
<a href="#l23.996"></a><span id="l23.996">     let statement = this._createAsyncStatement(</span>
<a href="#l23.997"></a><span id="l23.997">       &quot;INSERT INTO messageAttributes (conversationID, messageID, attributeID, \</span>
<a href="#l23.998"></a><span id="l23.998">                              value) \</span>
<a href="#l23.999"></a><span id="l23.999">               VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l23.1000"></a><span id="l23.1000" class="difflineat">@@ -2480,54 +2427,16 @@ var GlodaDatastore = {</span>
<a href="#l23.1001"></a><span id="l23.1001">     if (aMessage.id != null) {</span>
<a href="#l23.1002"></a><span id="l23.1002">       this._deleteMessageAttributesByMessageIDStatement.bindInt64Parameter(0,</span>
<a href="#l23.1003"></a><span id="l23.1003">         aMessage.id);</span>
<a href="#l23.1004"></a><span id="l23.1004">       this._deleteMessageAttributesByMessageIDStatement.executeAsync(</span>
<a href="#l23.1005"></a><span id="l23.1005">         this.trackAsync());</span>
<a href="#l23.1006"></a><span id="l23.1006">     }</span>
<a href="#l23.1007"></a><span id="l23.1007">   },</span>
<a href="#l23.1008"></a><span id="l23.1008"> </span>
<a href="#l23.1009"></a><span id="l23.1009" class="difflineminus">-  get _selectMessageAttributesByMessageIDStatement() {</span>
<a href="#l23.1010"></a><span id="l23.1010" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.1011"></a><span id="l23.1011" class="difflineminus">-      &quot;SELECT attributeID, value FROM messageAttributes \</span>
<a href="#l23.1012"></a><span id="l23.1012" class="difflineminus">-         WHERE messageID = ?1&quot;);</span>
<a href="#l23.1013"></a><span id="l23.1013" class="difflineminus">-    this.__defineGetter__(&quot;_selectMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l23.1014"></a><span id="l23.1014" class="difflineminus">-      function() statement);</span>
<a href="#l23.1015"></a><span id="l23.1015" class="difflineminus">-    return this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l23.1016"></a><span id="l23.1016" class="difflineminus">-  },</span>
<a href="#l23.1017"></a><span id="l23.1017" class="difflineminus">-</span>
<a href="#l23.1018"></a><span id="l23.1018" class="difflineminus">-  /**</span>
<a href="#l23.1019"></a><span id="l23.1019" class="difflineminus">-   * Look-up the attributes associated with the given GlodaMessage instance,</span>
<a href="#l23.1020"></a><span id="l23.1020" class="difflineminus">-   *  returning them in APV form (a tuple of Attribute definition object,</span>
<a href="#l23.1021"></a><span id="l23.1021" class="difflineminus">-   *  attribute Parameter, and attribute Value).</span>
<a href="#l23.1022"></a><span id="l23.1022" class="difflineminus">-   *</span>
<a href="#l23.1023"></a><span id="l23.1023" class="difflineminus">-   * @param aMessage The GlodaMessage whose attributes you want retrieved.</span>
<a href="#l23.1024"></a><span id="l23.1024" class="difflineminus">-   * @return An APV list of the attributes.</span>
<a href="#l23.1025"></a><span id="l23.1025" class="difflineminus">-   */</span>
<a href="#l23.1026"></a><span id="l23.1026" class="difflineminus">-  getMessageAttributes: function gloda_ds_getMessageAttributes(aMessage) {</span>
<a href="#l23.1027"></a><span id="l23.1027" class="difflineminus">-    // A list of [attribute def object, (attr) parameter value, attribute value]</span>
<a href="#l23.1028"></a><span id="l23.1028" class="difflineminus">-    let attribParamVals = []</span>
<a href="#l23.1029"></a><span id="l23.1029" class="difflineminus">-</span>
<a href="#l23.1030"></a><span id="l23.1030" class="difflineminus">-    let smas = this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l23.1031"></a><span id="l23.1031" class="difflineminus">-</span>
<a href="#l23.1032"></a><span id="l23.1032" class="difflineminus">-    smas.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l23.1033"></a><span id="l23.1033" class="difflineminus">-    while (this._syncStep(smas)) {</span>
<a href="#l23.1034"></a><span id="l23.1034" class="difflineminus">-      let attributeID = smas.getInt64(0);</span>
<a href="#l23.1035"></a><span id="l23.1035" class="difflineminus">-      if (!(attributeID in this._attributeIDToDBDefAndParam)) {</span>
<a href="#l23.1036"></a><span id="l23.1036" class="difflineminus">-        this._log.error(&quot;Attribute ID &quot; + attributeID + &quot; not in our map!&quot;);</span>
<a href="#l23.1037"></a><span id="l23.1037" class="difflineminus">-      }</span>
<a href="#l23.1038"></a><span id="l23.1038" class="difflineminus">-      let attribAndParam = this._attributeIDToDBDefAndParam[attributeID];</span>
<a href="#l23.1039"></a><span id="l23.1039" class="difflineminus">-      let val = smas.getDouble(1);</span>
<a href="#l23.1040"></a><span id="l23.1040" class="difflineminus">-      attribParamVals.push([attribAndParam[0], attribAndParam[1], val]);</span>
<a href="#l23.1041"></a><span id="l23.1041" class="difflineminus">-    }</span>
<a href="#l23.1042"></a><span id="l23.1042" class="difflineminus">-    smas.reset();</span>
<a href="#l23.1043"></a><span id="l23.1043" class="difflineminus">-</span>
<a href="#l23.1044"></a><span id="l23.1044" class="difflineminus">-    return attribParamVals;</span>
<a href="#l23.1045"></a><span id="l23.1045" class="difflineminus">-  },</span>
<a href="#l23.1046"></a><span id="l23.1046" class="difflineminus">-</span>
<a href="#l23.1047"></a><span id="l23.1047">   _stringSQLQuoter: function(aString) {</span>
<a href="#l23.1048"></a><span id="l23.1048">     return &quot;'&quot; + aString.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot;;</span>
<a href="#l23.1049"></a><span id="l23.1049">   },</span>
<a href="#l23.1050"></a><span id="l23.1050">   _numberQuoter: function(aNum) {</span>
<a href="#l23.1051"></a><span id="l23.1051">     return aNum;</span>
<a href="#l23.1052"></a><span id="l23.1052">   },</span>
<a href="#l23.1053"></a><span id="l23.1053"> </span>
<a href="#l23.1054"></a><span id="l23.1054">   /* ===== Generic Attribute Support ===== */</span>
<a href="#l23.1055"></a><span id="l23.1055" class="difflineat">@@ -2730,19 +2639,21 @@ var GlodaDatastore = {</span>
<a href="#l23.1056"></a><span id="l23.1056">   /**</span>
<a href="#l23.1057"></a><span id="l23.1057">    * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l23.1058"></a><span id="l23.1058">    *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l23.1059"></a><span id="l23.1059">    *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l23.1060"></a><span id="l23.1060">    *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l23.1061"></a><span id="l23.1061">    *  its listener) as the state of the database changes.</span>
<a href="#l23.1062"></a><span id="l23.1062">    * This functionality is made user/extension visible by the Query's</span>
<a href="#l23.1063"></a><span id="l23.1063">    *  getCollection (asynchronous).</span>
<a href="#l23.1064"></a><span id="l23.1064" class="difflineplus">+   *</span>
<a href="#l23.1065"></a><span id="l23.1065" class="difflineplus">+   * @param [aArgs] See |GlodaQuery.getCollection| for info.</span>
<a href="#l23.1066"></a><span id="l23.1066">    */</span>
<a href="#l23.1067"></a><span id="l23.1067">   queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener,</span>
<a href="#l23.1068"></a><span id="l23.1068" class="difflineminus">-      aListenerData, aExistingCollection, aMasterCollection, aBecomeExplicit) {</span>
<a href="#l23.1069"></a><span id="l23.1069" class="difflineplus">+      aListenerData, aExistingCollection, aMasterCollection, aArgs) {</span>
<a href="#l23.1070"></a><span id="l23.1070">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l23.1071"></a><span id="l23.1071">     //  likewise has its changes made.</span>
<a href="#l23.1072"></a><span id="l23.1072">     let nounDef = aQuery._nounDef;</span>
<a href="#l23.1073"></a><span id="l23.1073"> </span>
<a href="#l23.1074"></a><span id="l23.1074">     let whereClauses = [];</span>
<a href="#l23.1075"></a><span id="l23.1075">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l23.1076"></a><span id="l23.1076">     let boundArgs = [];</span>
<a href="#l23.1077"></a><span id="l23.1077"> </span>
<a href="#l23.1078"></a><span id="l23.1078" class="difflineat">@@ -2943,18 +2854,20 @@ var GlodaDatastore = {</span>
<a href="#l23.1079"></a><span id="l23.1079">     // if we want to become explicit, replace the query (which has already</span>
<a href="#l23.1080"></a><span id="l23.1080">     //  provided our actual SQL query) with an explicit query.  This will be</span>
<a href="#l23.1081"></a><span id="l23.1081">     //  what gets attached to the collection in the event we create a new</span>
<a href="#l23.1082"></a><span id="l23.1082">     //  collection.  If we are reusing one, we assume that the explicitness,</span>
<a href="#l23.1083"></a><span id="l23.1083">     //  if desired, already happened.</span>
<a href="#l23.1084"></a><span id="l23.1084">     // (we do not need to pass an argument to the explicitQueryClass constructor</span>
<a href="#l23.1085"></a><span id="l23.1085">     //  because it will be passed in to the collection's constructor, which will</span>
<a href="#l23.1086"></a><span id="l23.1086">     //  ensure that the collection attribute gets set.)</span>
<a href="#l23.1087"></a><span id="l23.1087" class="difflineminus">-    if (aBecomeExplicit)</span>
<a href="#l23.1088"></a><span id="l23.1088" class="difflineplus">+    if (aArgs &amp;&amp; (&quot;becomeExplicit&quot; in aArgs) &amp;&amp; aArgs.becomeExplicit)</span>
<a href="#l23.1089"></a><span id="l23.1089">       aQuery = new nounDef.explicitQueryClass();</span>
<a href="#l23.1090"></a><span id="l23.1090" class="difflineplus">+    else if (aArgs &amp;&amp; (&quot;becomeNull&quot; in aArgs) &amp;&amp; aArgs.becomeNull)</span>
<a href="#l23.1091"></a><span id="l23.1091" class="difflineplus">+      aQuery = new nounDef.nullQueryClass();</span>
<a href="#l23.1092"></a><span id="l23.1092"> </span>
<a href="#l23.1093"></a><span id="l23.1093">     return this._queryFromSQLString(sqlString, boundArgs, nounDef, aQuery,</span>
<a href="#l23.1094"></a><span id="l23.1094">         aListener, aListenerData, aExistingCollection, aMasterCollection);</span>
<a href="#l23.1095"></a><span id="l23.1095">   },</span>
<a href="#l23.1096"></a><span id="l23.1096"> </span>
<a href="#l23.1097"></a><span id="l23.1097">   _queryFromSQLString: function gloda_ds__queryFromSQLString(aSqlString,</span>
<a href="#l23.1098"></a><span id="l23.1098">       aBoundArgs, aNounDef, aQuery, aListener, aListenerData,</span>
<a href="#l23.1099"></a><span id="l23.1099">       aExistingCollection, aMasterCollection) {</span>
<a href="#l23.1100"></a><span id="l23.1100" class="difflineat">@@ -3198,17 +3111,16 @@ var GlodaDatastore = {</span>
<a href="#l23.1101"></a><span id="l23.1101">               VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)&quot;);</span>
<a href="#l23.1102"></a><span id="l23.1102">     this.__defineGetter__(&quot;_insertContactStatement&quot;, function() statement);</span>
<a href="#l23.1103"></a><span id="l23.1103">     return this._insertContactStatement;</span>
<a href="#l23.1104"></a><span id="l23.1104">   },</span>
<a href="#l23.1105"></a><span id="l23.1105"> </span>
<a href="#l23.1106"></a><span id="l23.1106">   createContact: function gloda_ds_createContact(aDirectoryUUID, aContactUUID,</span>
<a href="#l23.1107"></a><span id="l23.1107">       aName, aPopularity, aFrecency) {</span>
<a href="#l23.1108"></a><span id="l23.1108">     let contactID = this._nextContactId++;</span>
<a href="#l23.1109"></a><span id="l23.1109" class="difflineminus">-    this._log.debug(&quot;createContact: &quot; + contactID + &quot;: &quot; + aName);</span>
<a href="#l23.1110"></a><span id="l23.1110">     let contact = new GlodaContact(this, contactID,</span>
<a href="#l23.1111"></a><span id="l23.1111">                                    aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l23.1112"></a><span id="l23.1112">                                    aPopularity, aFrecency);</span>
<a href="#l23.1113"></a><span id="l23.1113">     return contact;</span>
<a href="#l23.1114"></a><span id="l23.1114">   },</span>
<a href="#l23.1115"></a><span id="l23.1115"> </span>
<a href="#l23.1116"></a><span id="l23.1116">   insertContact: function gloda_ds_insertContact(aContact) {</span>
<a href="#l23.1117"></a><span id="l23.1117">     let ics = this._insertContactStatement;</span>
<a href="#l23.1118"></a><span id="l23.1118" class="difflineat">@@ -3225,17 +3137,16 @@ var GlodaDatastore = {</span>
<a href="#l23.1119"></a><span id="l23.1119">     ics.bindInt64Parameter(4, aContact.popularity);</span>
<a href="#l23.1120"></a><span id="l23.1120">     ics.bindInt64Parameter(5, aContact.frecency);</span>
<a href="#l23.1121"></a><span id="l23.1121">     if (aContact._jsonText)</span>
<a href="#l23.1122"></a><span id="l23.1122">       ics.bindStringParameter(6, aContact._jsonText);</span>
<a href="#l23.1123"></a><span id="l23.1123">     else</span>
<a href="#l23.1124"></a><span id="l23.1124">       ics.bindNullParameter(6);</span>
<a href="#l23.1125"></a><span id="l23.1125"> </span>
<a href="#l23.1126"></a><span id="l23.1126">     ics.executeAsync(this.trackAsync());</span>
<a href="#l23.1127"></a><span id="l23.1127" class="difflineminus">-    this._log.debug(&quot;insertContact: &quot; + aContact.id + &quot;:&quot; + aContact.name);</span>
<a href="#l23.1128"></a><span id="l23.1128"> </span>
<a href="#l23.1129"></a><span id="l23.1129">     return aContact;</span>
<a href="#l23.1130"></a><span id="l23.1130">   },</span>
<a href="#l23.1131"></a><span id="l23.1131"> </span>
<a href="#l23.1132"></a><span id="l23.1132">   get _updateContactStatement() {</span>
<a href="#l23.1133"></a><span id="l23.1133">     let statement = this._createAsyncStatement(</span>
<a href="#l23.1134"></a><span id="l23.1134">       &quot;UPDATE contacts SET directoryUUID = ?1, \</span>
<a href="#l23.1135"></a><span id="l23.1135">                            contactUUID = ?2, \</span>
<a href="#l23.1136"></a><span id="l23.1136" class="difflineat">@@ -3287,16 +3198,22 @@ var GlodaDatastore = {</span>
<a href="#l23.1137"></a><span id="l23.1137">   get _selectContactByIDStatement() {</span>
<a href="#l23.1138"></a><span id="l23.1138">     let statement = this._createSyncStatement(</span>
<a href="#l23.1139"></a><span id="l23.1139">       &quot;SELECT * FROM contacts WHERE id = ?1&quot;);</span>
<a href="#l23.1140"></a><span id="l23.1140">     this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l23.1141"></a><span id="l23.1141">       function() statement);</span>
<a href="#l23.1142"></a><span id="l23.1142">     return this._selectContactByIDStatement;</span>
<a href="#l23.1143"></a><span id="l23.1143">   },</span>
<a href="#l23.1144"></a><span id="l23.1144"> </span>
<a href="#l23.1145"></a><span id="l23.1145" class="difflineplus">+  /**</span>
<a href="#l23.1146"></a><span id="l23.1146" class="difflineplus">+   * Synchronous contact lookup currently only for use by gloda's creation</span>
<a href="#l23.1147"></a><span id="l23.1147" class="difflineplus">+   *  of the concept of &quot;me&quot;.  It is okay for it to be doing synchronous work</span>
<a href="#l23.1148"></a><span id="l23.1148" class="difflineplus">+   *  because it is part of the startup process before any user code could</span>
<a href="#l23.1149"></a><span id="l23.1149" class="difflineplus">+   *  have gotten a reference to Gloda, but no one else should do this.</span>
<a href="#l23.1150"></a><span id="l23.1150" class="difflineplus">+   */</span>
<a href="#l23.1151"></a><span id="l23.1151">   getContactByID: function gloda_ds_getContactByID(aContactID) {</span>
<a href="#l23.1152"></a><span id="l23.1152">     let contact = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l23.1153"></a><span id="l23.1153">       GlodaContact.prototype.NOUN_ID, aContactID);</span>
<a href="#l23.1154"></a><span id="l23.1154"> </span>
<a href="#l23.1155"></a><span id="l23.1155">     if (contact === null) {</span>
<a href="#l23.1156"></a><span id="l23.1156">       let scbi = this._selectContactByIDStatement;</span>
<a href="#l23.1157"></a><span id="l23.1157">       scbi.bindInt64Parameter(0, aContactID);</span>
<a href="#l23.1158"></a><span id="l23.1158">       if (this._syncStep(scbi)) {</span>
<a href="#l23.1159"></a><span id="l23.1159" class="difflineat">@@ -3359,76 +3276,35 @@ var GlodaDatastore = {</span>
<a href="#l23.1160"></a><span id="l23.1160">   get _selectIdentityByKindValueStatement() {</span>
<a href="#l23.1161"></a><span id="l23.1161">     let statement = this._createSyncStatement(</span>
<a href="#l23.1162"></a><span id="l23.1162">       &quot;SELECT * FROM identities WHERE kind = ?1 AND value = ?2&quot;);</span>
<a href="#l23.1163"></a><span id="l23.1163">     this.__defineGetter__(&quot;_selectIdentityByKindValueStatement&quot;,</span>
<a href="#l23.1164"></a><span id="l23.1164">       function() statement);</span>
<a href="#l23.1165"></a><span id="l23.1165">     return this._selectIdentityByKindValueStatement;</span>
<a href="#l23.1166"></a><span id="l23.1166">   },</span>
<a href="#l23.1167"></a><span id="l23.1167"> </span>
<a href="#l23.1168"></a><span id="l23.1168" class="difflineminus">-  /** Lookup an identity by kind and value.  Ex: (email, foo@bar.com) */</span>
<a href="#l23.1169"></a><span id="l23.1169" class="difflineplus">+  /**</span>
<a href="#l23.1170"></a><span id="l23.1170" class="difflineplus">+   * Synchronous lookup of an identity by kind and value, only for use by</span>
<a href="#l23.1171"></a><span id="l23.1171" class="difflineplus">+   *  the legacy gloda core code that creates a concept of &quot;me&quot;.</span>
<a href="#l23.1172"></a><span id="l23.1172" class="difflineplus">+   *  Ex: (email, foo@bar.com)</span>
<a href="#l23.1173"></a><span id="l23.1173" class="difflineplus">+   */</span>
<a href="#l23.1174"></a><span id="l23.1174">   getIdentity: function gloda_ds_getIdentity(aKind, aValue) {</span>
<a href="#l23.1175"></a><span id="l23.1175">     let identity = GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l23.1176"></a><span id="l23.1176">       GlodaIdentity.prototype.NOUN_ID, aKind + &quot;@&quot; + aValue);</span>
<a href="#l23.1177"></a><span id="l23.1177"> </span>
<a href="#l23.1178"></a><span id="l23.1178">     let ibkv = this._selectIdentityByKindValueStatement;</span>
<a href="#l23.1179"></a><span id="l23.1179">     ibkv.bindStringParameter(0, aKind);</span>
<a href="#l23.1180"></a><span id="l23.1180">     ibkv.bindStringParameter(1, aValue);</span>
<a href="#l23.1181"></a><span id="l23.1181">     if (this._syncStep(ibkv)) {</span>
<a href="#l23.1182"></a><span id="l23.1182">       identity = this._identityFromRow(ibkv);</span>
<a href="#l23.1183"></a><span id="l23.1183">       GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l23.1184"></a><span id="l23.1184">     }</span>
<a href="#l23.1185"></a><span id="l23.1185">     ibkv.reset();</span>
<a href="#l23.1186"></a><span id="l23.1186"> </span>
<a href="#l23.1187"></a><span id="l23.1187">     return identity;</span>
<a href="#l23.1188"></a><span id="l23.1188">   },</span>
<a href="#l23.1189"></a><span id="l23.1189" class="difflineminus">-</span>
<a href="#l23.1190"></a><span id="l23.1190" class="difflineminus">-  get _selectIdentityByIDStatement() {</span>
<a href="#l23.1191"></a><span id="l23.1191" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.1192"></a><span id="l23.1192" class="difflineminus">-      &quot;SELECT * FROM identities WHERE id = ?1&quot;);</span>
<a href="#l23.1193"></a><span id="l23.1193" class="difflineminus">-    this.__defineGetter__(&quot;_selectIdentityByIDStatement&quot;,</span>
<a href="#l23.1194"></a><span id="l23.1194" class="difflineminus">-      function() statement);</span>
<a href="#l23.1195"></a><span id="l23.1195" class="difflineminus">-    return this._selectIdentityByIDStatement;</span>
<a href="#l23.1196"></a><span id="l23.1196" class="difflineminus">-  },</span>
<a href="#l23.1197"></a><span id="l23.1197" class="difflineminus">-</span>
<a href="#l23.1198"></a><span id="l23.1198" class="difflineminus">-  getIdentityByID: function gloda_ds_getIdentityByID(aID) {</span>
<a href="#l23.1199"></a><span id="l23.1199" class="difflineminus">-    let identity = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l23.1200"></a><span id="l23.1200" class="difflineminus">-      GlodaIdentity.prototype.NOUN_ID, aID);</span>
<a href="#l23.1201"></a><span id="l23.1201" class="difflineminus">-</span>
<a href="#l23.1202"></a><span id="l23.1202" class="difflineminus">-    if (identity === null) {</span>
<a href="#l23.1203"></a><span id="l23.1203" class="difflineminus">-      let sibis = this._selectIdentityByIDStatement;</span>
<a href="#l23.1204"></a><span id="l23.1204" class="difflineminus">-      sibis.bindInt64Parameter(0, aID);</span>
<a href="#l23.1205"></a><span id="l23.1205" class="difflineminus">-      if (this._syncStep(sibis)) {</span>
<a href="#l23.1206"></a><span id="l23.1206" class="difflineminus">-        identity = this._identityFromRow(sibis);</span>
<a href="#l23.1207"></a><span id="l23.1207" class="difflineminus">-        GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l23.1208"></a><span id="l23.1208" class="difflineminus">-      }</span>
<a href="#l23.1209"></a><span id="l23.1209" class="difflineminus">-      sibis.reset();</span>
<a href="#l23.1210"></a><span id="l23.1210" class="difflineminus">-    }</span>
<a href="#l23.1211"></a><span id="l23.1211" class="difflineminus">-</span>
<a href="#l23.1212"></a><span id="l23.1212" class="difflineminus">-    return identity;</span>
<a href="#l23.1213"></a><span id="l23.1213" class="difflineminus">-  },</span>
<a href="#l23.1214"></a><span id="l23.1214" class="difflineminus">-</span>
<a href="#l23.1215"></a><span id="l23.1215" class="difflineminus">-  get _selectIdentityByContactIDStatement() {</span>
<a href="#l23.1216"></a><span id="l23.1216" class="difflineminus">-    let statement = this._createSyncStatement(</span>
<a href="#l23.1217"></a><span id="l23.1217" class="difflineminus">-      &quot;SELECT * FROM identities WHERE contactID = ?1&quot;);</span>
<a href="#l23.1218"></a><span id="l23.1218" class="difflineminus">-    this.__defineGetter__(&quot;_selectIdentityByContactIDStatement&quot;,</span>
<a href="#l23.1219"></a><span id="l23.1219" class="difflineminus">-      function() statement);</span>
<a href="#l23.1220"></a><span id="l23.1220" class="difflineminus">-    return this._selectIdentityByContactIDStatement;</span>
<a href="#l23.1221"></a><span id="l23.1221" class="difflineminus">-  },</span>
<a href="#l23.1222"></a><span id="l23.1222" class="difflineminus">-</span>
<a href="#l23.1223"></a><span id="l23.1223" class="difflineminus">-  getIdentitiesByContactID: function gloda_ds_getIdentitiesByContactID(</span>
<a href="#l23.1224"></a><span id="l23.1224" class="difflineminus">-      aContactID) {</span>
<a href="#l23.1225"></a><span id="l23.1225" class="difflineminus">-    let sibcs = this._selectIdentityByContactIDStatement;</span>
<a href="#l23.1226"></a><span id="l23.1226" class="difflineminus">-</span>
<a href="#l23.1227"></a><span id="l23.1227" class="difflineminus">-    sibcs.bindInt64Parameter(0, aContactID);</span>
<a href="#l23.1228"></a><span id="l23.1228" class="difflineminus">-</span>
<a href="#l23.1229"></a><span id="l23.1229" class="difflineminus">-    let identities = [];</span>
<a href="#l23.1230"></a><span id="l23.1230" class="difflineminus">-    while (this._syncStep(sibcs)) {</span>
<a href="#l23.1231"></a><span id="l23.1231" class="difflineminus">-      identities.push(this._identityFromRow(sibcs));</span>
<a href="#l23.1232"></a><span id="l23.1232" class="difflineminus">-    }</span>
<a href="#l23.1233"></a><span id="l23.1233" class="difflineminus">-    sibcs.reset();</span>
<a href="#l23.1234"></a><span id="l23.1234" class="difflineminus">-</span>
<a href="#l23.1235"></a><span id="l23.1235" class="difflineminus">-    if (identities.length)</span>
<a href="#l23.1236"></a><span id="l23.1236" class="difflineminus">-      GlodaCollectionManager.cacheLoadUnify(GlodaIdentity.prototype.NOUN_ID,</span>
<a href="#l23.1237"></a><span id="l23.1237" class="difflineminus">-                                            identities);</span>
<a href="#l23.1238"></a><span id="l23.1238" class="difflineminus">-    return identities;</span>
<a href="#l23.1239"></a><span id="l23.1239" class="difflineminus">-  },</span>
<a href="#l23.1240"></a><span id="l23.1240"> };</span>
<a href="#l23.1241"></a><span id="l23.1241" class="difflineplus">+GlodaAttributeDBDef.prototype._datastore = GlodaDatastore;</span>
<a href="#l23.1242"></a><span id="l23.1242" class="difflineplus">+GlodaConversation.prototype._datastore = GlodaDatastore;</span>
<a href="#l23.1243"></a><span id="l23.1243" class="difflineplus">+GlodaFolder.prototype._datastore = GlodaDatastore;</span>
<a href="#l23.1244"></a><span id="l23.1244" class="difflineplus">+GlodaMessage.prototype._datastore = GlodaDatastore;</span>
<a href="#l23.1245"></a><span id="l23.1245" class="difflineplus">+GlodaContact.prototype._datastore = GlodaDatastore;</span>
<a href="#l23.1246"></a><span id="l23.1246" class="difflineplus">+GlodaIdentity.prototype._datastore = GlodaDatastore;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/mailnews/db/gloda/modules/everybody.js</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/everybody.js</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l24.4"></a><span id="l24.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l24.5"></a><span id="l24.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l24.6"></a><span id="l24.6">  *</span>
<a href="#l24.7"></a><span id="l24.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l24.8"></a><span id="l24.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l24.9"></a><span id="l24.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l24.10"></a><span id="l24.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l24.11"></a><span id="l24.11" class="difflineminus">- * </span>
<a href="#l24.12"></a><span id="l24.12" class="difflineplus">+ *</span>
<a href="#l24.13"></a><span id="l24.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l24.14"></a><span id="l24.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l24.15"></a><span id="l24.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l24.16"></a><span id="l24.16">  * License.</span>
<a href="#l24.17"></a><span id="l24.17">  *</span>
<a href="#l24.18"></a><span id="l24.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l24.19"></a><span id="l24.19">  *</span>
<a href="#l24.20"></a><span id="l24.20">  * The Initial Developer of the Original Code is</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineat">@@ -27,17 +27,17 @@</span>
<a href="#l24.22"></a><span id="l24.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l24.23"></a><span id="l24.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l24.24"></a><span id="l24.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l24.25"></a><span id="l24.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l24.26"></a><span id="l24.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l24.27"></a><span id="l24.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l24.28"></a><span id="l24.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l24.29"></a><span id="l24.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l24.30"></a><span id="l24.30" class="difflineminus">- * </span>
<a href="#l24.31"></a><span id="l24.31" class="difflineplus">+ *</span>
<a href="#l24.32"></a><span id="l24.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l24.33"></a><span id="l24.33"> </span>
<a href="#l24.34"></a><span id="l24.34"> const EXPORTED_SYMBOLS = [];</span>
<a href="#l24.35"></a><span id="l24.35"> </span>
<a href="#l24.36"></a><span id="l24.36"> const Cc = Components.classes;</span>
<a href="#l24.37"></a><span id="l24.37"> const Ci = Components.interfaces;</span>
<a href="#l24.38"></a><span id="l24.38"> const Cr = Components.results;</span>
<a href="#l24.39"></a><span id="l24.39"> const Cu = Components.utils;</span>
<a href="#l24.40"></a><span id="l24.40" class="difflineat">@@ -55,17 +55,17 @@ function loadModule(aModuleURI, aNSContr</span>
<a href="#l24.41"></a><span id="l24.41">   catch (ex) {</span>
<a href="#l24.42"></a><span id="l24.42">     LOG.error(&quot;!!! error loading &quot; + aModuleURI);</span>
<a href="#l24.43"></a><span id="l24.43">     LOG.error(&quot;(&quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;) &quot; + ex);</span>
<a href="#l24.44"></a><span id="l24.44">     return false;</span>
<a href="#l24.45"></a><span id="l24.45">   }</span>
<a href="#l24.46"></a><span id="l24.46">   LOG.info(&quot;+++ loaded &quot; + aModuleURI);</span>
<a href="#l24.47"></a><span id="l24.47"> </span>
<a href="#l24.48"></a><span id="l24.48">   if (aNSContrib) {</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineminus">-    try {  </span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+    try {</span>
<a href="#l24.51"></a><span id="l24.51">       importNS[aNSContrib].init();</span>
<a href="#l24.52"></a><span id="l24.52">     }</span>
<a href="#l24.53"></a><span id="l24.53">     catch (ex) {</span>
<a href="#l24.54"></a><span id="l24.54">       LOG.error(&quot;!!! error initializing &quot; + aModuleURI);</span>
<a href="#l24.55"></a><span id="l24.55">       LOG.error(&quot;(&quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;) &quot; + ex);</span>
<a href="#l24.56"></a><span id="l24.56">       return false;</span>
<a href="#l24.57"></a><span id="l24.57">     }</span>
<a href="#l24.58"></a><span id="l24.58">     LOG.info(&quot;+++ inited &quot; + aModuleURI);</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineat">@@ -74,9 +74,10 @@ function loadModule(aModuleURI, aNSContr</span>
<a href="#l24.60"></a><span id="l24.60"> }</span>
<a href="#l24.61"></a><span id="l24.61"> </span>
<a href="#l24.62"></a><span id="l24.62"> loadModule(&quot;resource://app/modules/gloda/fundattr.js&quot;, &quot;GlodaFundAttr&quot;);</span>
<a href="#l24.63"></a><span id="l24.63"> loadModule(&quot;resource://app/modules/gloda/explattr.js&quot;, &quot;GlodaExplicitAttr&quot;);</span>
<a href="#l24.64"></a><span id="l24.64"> </span>
<a href="#l24.65"></a><span id="l24.65"> loadModule(&quot;resource://app/modules/gloda/noun_tag.js&quot;);</span>
<a href="#l24.66"></a><span id="l24.66"> loadModule(&quot;resource://app/modules/gloda/noun_freetag.js&quot;);</span>
<a href="#l24.67"></a><span id="l24.67"> loadModule(&quot;resource://app/modules/gloda/noun_mimetype.js&quot;);</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+loadModule(&quot;resource://app/modules/gloda/index_msg.js&quot;);</span>
<a href="#l24.69"></a><span id="l24.69"> loadModule(&quot;resource://app/modules/gloda/index_ab.js&quot;, &quot;GlodaABAttrs&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/mailnews/db/gloda/modules/explattr.js</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/explattr.js</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -187,17 +187,17 @@ var GlodaExplicitAttr = {</span>
<a href="#l25.4"></a><span id="l25.4">     let keywords = aMsgHdr.getStringProperty(&quot;keywords&quot;);</span>
<a href="#l25.5"></a><span id="l25.5">     let keywordList = keywords.split(' ');</span>
<a href="#l25.6"></a><span id="l25.6">     let keywordMap = {};</span>
<a href="#l25.7"></a><span id="l25.7">     for (let iKeyword = 0; iKeyword &lt; keywordList.length; iKeyword++) {</span>
<a href="#l25.8"></a><span id="l25.8">       let keyword = keywordList[iKeyword];</span>
<a href="#l25.9"></a><span id="l25.9">       keywordMap[keyword] = true;</span>
<a href="#l25.10"></a><span id="l25.10">     }</span>
<a href="#l25.11"></a><span id="l25.11"> </span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-    let tagArray = this._msgTagService.getAllTags({});</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+    let tagArray = TagNoun.getAllTags();</span>
<a href="#l25.14"></a><span id="l25.14">     for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l25.15"></a><span id="l25.15">       let tag = tagArray[iTag];</span>
<a href="#l25.16"></a><span id="l25.16">       if (tag.key in keywordMap)</span>
<a href="#l25.17"></a><span id="l25.17">         tags.push(tag);</span>
<a href="#l25.18"></a><span id="l25.18">     }</span>
<a href="#l25.19"></a><span id="l25.19"> </span>
<a href="#l25.20"></a><span id="l25.20">     if (tags.length)</span>
<a href="#l25.21"></a><span id="l25.21">       aGlodaMessage.notability += this.NOTABILITY_TAGGED_FIRST +</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -147,16 +147,34 @@ var GlodaFundAttr = {</span>
<a href="#l26.4"></a><span id="l26.4">       attributeName: &quot;messageKey&quot;,</span>
<a href="#l26.5"></a><span id="l26.5">       singular: true,</span>
<a href="#l26.6"></a><span id="l26.6">       special: Gloda.kSpecialColumn,</span>
<a href="#l26.7"></a><span id="l26.7">       specialColumnName: &quot;messageKey&quot;,</span>
<a href="#l26.8"></a><span id="l26.8">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l26.9"></a><span id="l26.9">       objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l26.10"></a><span id="l26.10">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l26.11"></a><span id="l26.11"> </span>
<a href="#l26.12"></a><span id="l26.12" class="difflineplus">+    // We need to surface the deleted attribute for querying, but there is no</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+    //  reason for user code, so let's call it &quot;_deleted&quot; rather than deleted.</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineplus">+    // (In fact, our validity constraints require a special query formulation</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineplus">+    //  that user code should have no clue exists.  That's right user code,</span>
<a href="#l26.16"></a><span id="l26.16" class="difflineplus">+    //  that's a dare.)</span>
<a href="#l26.17"></a><span id="l26.17" class="difflineplus">+    Gloda.defineAttribute({</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineplus">+      provider: this,</span>
<a href="#l26.19"></a><span id="l26.19" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l26.20"></a><span id="l26.20" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l26.21"></a><span id="l26.21" class="difflineplus">+      attributeName: &quot;_deleted&quot;,</span>
<a href="#l26.22"></a><span id="l26.22" class="difflineplus">+      singular: true,</span>
<a href="#l26.23"></a><span id="l26.23" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l26.24"></a><span id="l26.24" class="difflineplus">+      specialColumnName: &quot;deleted&quot;,</span>
<a href="#l26.25"></a><span id="l26.25" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l26.26"></a><span id="l26.26" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l26.27"></a><span id="l26.27" class="difflineplus">+      });</span>
<a href="#l26.28"></a><span id="l26.28" class="difflineplus">+</span>
<a href="#l26.29"></a><span id="l26.29" class="difflineplus">+</span>
<a href="#l26.30"></a><span id="l26.30">     // -- fulltext search helpers</span>
<a href="#l26.31"></a><span id="l26.31">     // fulltextMatches.  Match over message subject, body, and attachments</span>
<a href="#l26.32"></a><span id="l26.32">     // @testpoint gloda.noun.message.attr.fulltextMatches</span>
<a href="#l26.33"></a><span id="l26.33">     this._attrFulltext = Gloda.defineAttribute({</span>
<a href="#l26.34"></a><span id="l26.34">       provider: this,</span>
<a href="#l26.35"></a><span id="l26.35">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l26.36"></a><span id="l26.36">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l26.37"></a><span id="l26.37">       attributeName: &quot;fulltextMatches&quot;,</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineat">@@ -314,17 +332,17 @@ var GlodaFundAttr = {</span>
<a href="#l26.39"></a><span id="l26.39"> </span>
<a href="#l26.40"></a><span id="l26.40">     // Header message ID.</span>
<a href="#l26.41"></a><span id="l26.41">     this._attrHeaderMessageID = Gloda.defineAttribute({</span>
<a href="#l26.42"></a><span id="l26.42">                         provider: this,</span>
<a href="#l26.43"></a><span id="l26.43">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l26.44"></a><span id="l26.44">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l26.45"></a><span id="l26.45">                         attributeName: &quot;headerMessageID&quot;,</span>
<a href="#l26.46"></a><span id="l26.46">                         singular: true,</span>
<a href="#l26.47"></a><span id="l26.47" class="difflineminus">-                        special: Gloda.kSpecialColumn,</span>
<a href="#l26.48"></a><span id="l26.48" class="difflineplus">+                        special: Gloda.kSpecialString,</span>
<a href="#l26.49"></a><span id="l26.49">                         specialColumnName: &quot;headerMessageID&quot;,</span>
<a href="#l26.50"></a><span id="l26.50">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l26.51"></a><span id="l26.51">                         objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l26.52"></a><span id="l26.52">                         }); // tested-by: test_attributes_fundamental</span>
<a href="#l26.53"></a><span id="l26.53"> </span>
<a href="#l26.54"></a><span id="l26.54">     // Attachment MIME Types</span>
<a href="#l26.55"></a><span id="l26.55">     this._attrAttachmentTypes = Gloda.defineAttribute({</span>
<a href="#l26.56"></a><span id="l26.56">       provider: this,</span>
<a href="#l26.57"></a><span id="l26.57" class="difflineat">@@ -487,20 +505,20 @@ var GlodaFundAttr = {</span>
<a href="#l26.58"></a><span id="l26.58">     let [authorIdentities, toIdentities, ccIdentities, bccIdentities,</span>
<a href="#l26.59"></a><span id="l26.59">          listIdentities] =</span>
<a href="#l26.60"></a><span id="l26.60">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l26.61"></a><span id="l26.61">         Gloda.getOrCreateMailIdentities(aCallbackHandle,</span>
<a href="#l26.62"></a><span id="l26.62">                                         author, aMsgHdr.mime2DecodedRecipients,</span>
<a href="#l26.63"></a><span id="l26.63">                                         aMsgHdr.ccList, aMsgHdr.bccList,</span>
<a href="#l26.64"></a><span id="l26.64">                                         normalizedListPost));</span>
<a href="#l26.65"></a><span id="l26.65"> </span>
<a href="#l26.66"></a><span id="l26.66" class="difflineminus">-    if (authorIdentities.length == 0) {</span>
<a href="#l26.67"></a><span id="l26.67" class="difflineminus">-      this._log.error(&quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l26.68"></a><span id="l26.68" class="difflineminus">-                      &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l26.69"></a><span id="l26.69" class="difflineminus">-      return; // being a generator, this generates an exception; we like.</span>
<a href="#l26.70"></a><span id="l26.70" class="difflineplus">+    if (authorIdentities.length != 1) {</span>
<a href="#l26.71"></a><span id="l26.71" class="difflineplus">+      throw new Gloda.BadItemContentsError(</span>
<a href="#l26.72"></a><span id="l26.72" class="difflineplus">+        &quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l26.73"></a><span id="l26.73" class="difflineplus">+          &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l26.74"></a><span id="l26.74">     }</span>
<a href="#l26.75"></a><span id="l26.75">     let authorIdentity = authorIdentities[0];</span>
<a href="#l26.76"></a><span id="l26.76">     aGlodaMessage.from = authorIdentity;</span>
<a href="#l26.77"></a><span id="l26.77"> </span>
<a href="#l26.78"></a><span id="l26.78">     // -- To, Cc, Bcc</span>
<a href="#l26.79"></a><span id="l26.79">     aGlodaMessage.to = toIdentities;</span>
<a href="#l26.80"></a><span id="l26.80">     aGlodaMessage.cc = ccIdentities;</span>
<a href="#l26.81"></a><span id="l26.81">     aGlodaMessage.bcc = bccIdentities;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -52,22 +52,18 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l27.4"></a><span id="l27.4"> Cu.import(&quot;resource://app/modules/gloda/query.js&quot;);</span>
<a href="#l27.5"></a><span id="l27.5"> Cu.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l27.6"></a><span id="l27.6"> </span>
<a href="#l27.7"></a><span id="l27.7"> Cu.import(&quot;resource://app/modules/iteratorUtils.jsm&quot;);</span>
<a href="#l27.8"></a><span id="l27.8"> </span>
<a href="#l27.9"></a><span id="l27.9"> let MBM_LOG = Log4Moz.repository.getLogger(&quot;gloda.NS.mbm&quot;);</span>
<a href="#l27.10"></a><span id="l27.10"> </span>
<a href="#l27.11"></a><span id="l27.11"> /**</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">- * @class This callback handles processing the asynchronous query results of</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+ * This callback handles processing the asynchronous query results of</span>
<a href="#l27.14"></a><span id="l27.14">  *  Gloda.getMessagesByMessageID.</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineminus">- *</span>
<a href="#l27.16"></a><span id="l27.16" class="difflineminus">- * @param aMsgIDToIndex Map from message-id to the desired</span>
<a href="#l27.17"></a><span id="l27.17" class="difflineminus">- *</span>
<a href="#l27.18"></a><span id="l27.18" class="difflineminus">- * @constructor</span>
<a href="#l27.19"></a><span id="l27.19">  */</span>
<a href="#l27.20"></a><span id="l27.20"> function MessagesByMessageIdCallback(aMsgIDToIndex, aResults,</span>
<a href="#l27.21"></a><span id="l27.21">                                      aCallback, aCallbackThis) {</span>
<a href="#l27.22"></a><span id="l27.22">   this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l27.23"></a><span id="l27.23">   this.results = aResults;</span>
<a href="#l27.24"></a><span id="l27.24">   this.callback = aCallback;</span>
<a href="#l27.25"></a><span id="l27.25">   this.callbackThis = aCallbackThis;</span>
<a href="#l27.26"></a><span id="l27.26"> }</span>
<a href="#l27.27"></a><span id="l27.27" class="difflineat">@@ -93,16 +89,29 @@ MessagesByMessageIdCallback.prototype = </span>
<a href="#l27.28"></a><span id="l27.28">     if (MBM_LOG.level &lt;= Log4Moz.Level.Debug)</span>
<a href="#l27.29"></a><span id="l27.29">       MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l27.30"></a><span id="l27.30"> </span>
<a href="#l27.31"></a><span id="l27.31">     this.callback.call(this.callbackThis, this.results);</span>
<a href="#l27.32"></a><span id="l27.32">   }</span>
<a href="#l27.33"></a><span id="l27.33"> };</span>
<a href="#l27.34"></a><span id="l27.34"> </span>
<a href="#l27.35"></a><span id="l27.35"> /**</span>
<a href="#l27.36"></a><span id="l27.36" class="difflineplus">+ * @see |Gloda.BadItemContentsError|</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineplus">+ */</span>
<a href="#l27.38"></a><span id="l27.38" class="difflineplus">+function BadItemContentsError(aMessage) {</span>
<a href="#l27.39"></a><span id="l27.39" class="difflineplus">+  this.message = aMessage;</span>
<a href="#l27.40"></a><span id="l27.40" class="difflineplus">+}</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineplus">+BadItemContentsError.prototype = {</span>
<a href="#l27.42"></a><span id="l27.42" class="difflineplus">+  toString: function BadItemContentsError_toString() {</span>
<a href="#l27.43"></a><span id="l27.43" class="difflineplus">+    return this.message;</span>
<a href="#l27.44"></a><span id="l27.44" class="difflineplus">+  }</span>
<a href="#l27.45"></a><span id="l27.45" class="difflineplus">+};</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineplus">+</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+</span>
<a href="#l27.48"></a><span id="l27.48" class="difflineplus">+/**</span>
<a href="#l27.49"></a><span id="l27.49">  * Provides the user-visible (and extension visible) global database</span>
<a href="#l27.50"></a><span id="l27.50">  *  functionality.  There is currently a dependency/ordering</span>
<a href="#l27.51"></a><span id="l27.51">  *  problem in that the concept of 'gloda' also includes some logic that is</span>
<a href="#l27.52"></a><span id="l27.52">  *  contributed by built-in extensions, if you will.  Those built-in extensions</span>
<a href="#l27.53"></a><span id="l27.53">  *  (fundattr.js, explattr.js) also import this file.  To avoid a circular</span>
<a href="#l27.54"></a><span id="l27.54">  *  dependency, those built-in extensions are loaded by everybody.js.  The</span>
<a href="#l27.55"></a><span id="l27.55">  *  simplest/best solution is probably to move everybody.js to be gloda.js and</span>
<a href="#l27.56"></a><span id="l27.56">  *  have it re-export only 'Gloda'.  gloda.js (this file) can then move to be</span>
<a href="#l27.57"></a><span id="l27.57" class="difflineat">@@ -222,17 +231,17 @@ var Gloda = {</span>
<a href="#l27.58"></a><span id="l27.58"> </span>
<a href="#l27.59"></a><span id="l27.59">     try {</span>
<a href="#l27.60"></a><span id="l27.60">       // figure out if event-driven indexing should be enabled...</span>
<a href="#l27.61"></a><span id="l27.61">       let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l27.62"></a><span id="l27.62">                           getService(Ci.nsIPrefService);</span>
<a href="#l27.63"></a><span id="l27.63">       let branch = prefService.getBranch(&quot;mailnews.database.global.logging.&quot;);</span>
<a href="#l27.64"></a><span id="l27.64">       enableConsoleLogging = branch.getBoolPref(&quot;console&quot;);</span>
<a href="#l27.65"></a><span id="l27.65">       enableDumpLogging = branch.getBoolPref(&quot;dump&quot;);</span>
<a href="#l27.66"></a><span id="l27.66" class="difflineminus">-      enableNetLogging = branch.getBoolPref(&quot;net&quot;);</span>
<a href="#l27.67"></a><span id="l27.67" class="difflineplus">+      considerNetLogging = branch.getBoolPref(&quot;net&quot;);</span>
<a href="#l27.68"></a><span id="l27.68">     } catch (ex) {}</span>
<a href="#l27.69"></a><span id="l27.69"> </span>
<a href="#l27.70"></a><span id="l27.70">     if (enableConsoleLogging) {</span>
<a href="#l27.71"></a><span id="l27.71">       let capp = new Log4Moz.ConsoleAppender(formatter);</span>
<a href="#l27.72"></a><span id="l27.72">       capp.level = Log4Moz.Level.Warn;</span>
<a href="#l27.73"></a><span id="l27.73">       glodaLog.addAppender(capp);</span>
<a href="#l27.74"></a><span id="l27.74">     }</span>
<a href="#l27.75"></a><span id="l27.75"> </span>
<a href="#l27.76"></a><span id="l27.76" class="difflineat">@@ -259,20 +268,25 @@ var Gloda = {</span>
<a href="#l27.77"></a><span id="l27.77">         glodaLog.addAppender(sapp);</span>
<a href="#l27.78"></a><span id="l27.78">       }</span>
<a href="#l27.79"></a><span id="l27.79">     }</span>
<a href="#l27.80"></a><span id="l27.80"> </span>
<a href="#l27.81"></a><span id="l27.81">     this._log = Log4Moz.repository.getLogger(&quot;gloda.NS&quot;);</span>
<a href="#l27.82"></a><span id="l27.82">     this._log.info(&quot;Logging Initialized&quot;);</span>
<a href="#l27.83"></a><span id="l27.83">   },</span>
<a href="#l27.84"></a><span id="l27.84"> </span>
<a href="#l27.85"></a><span id="l27.85" class="difflineplus">+  /**</span>
<a href="#l27.86"></a><span id="l27.86" class="difflineplus">+   * The indexer is idle.</span>
<a href="#l27.87"></a><span id="l27.87" class="difflineplus">+   */</span>
<a href="#l27.88"></a><span id="l27.88">   kIndexerIdle: 0,</span>
<a href="#l27.89"></a><span id="l27.89" class="difflineplus">+  /**</span>
<a href="#l27.90"></a><span id="l27.90" class="difflineplus">+   * The indexer is doing something.  We used to have other specific states, but</span>
<a href="#l27.91"></a><span id="l27.91" class="difflineplus">+   *  they have been rendered irrelevant and wiped from existence.</span>
<a href="#l27.92"></a><span id="l27.92" class="difflineplus">+   */</span>
<a href="#l27.93"></a><span id="l27.93">   kIndexerIndexing: 1,</span>
<a href="#l27.94"></a><span id="l27.94" class="difflineminus">-  kIndexerMoving: 2,</span>
<a href="#l27.95"></a><span id="l27.95" class="difflineminus">-  kIndexerRemoving: 3,</span>
<a href="#l27.96"></a><span id="l27.96"> </span>
<a href="#l27.97"></a><span id="l27.97">   /** Synchronous activities performed, you can drive us more. */</span>
<a href="#l27.98"></a><span id="l27.98">   kWorkSync: 0,</span>
<a href="#l27.99"></a><span id="l27.99">   /**</span>
<a href="#l27.100"></a><span id="l27.100">    * Asynchronous activity performed, you need to relinquish flow control and</span>
<a href="#l27.101"></a><span id="l27.101">    *  trust us to call callbackDriver later.</span>
<a href="#l27.102"></a><span id="l27.102">    */</span>
<a href="#l27.103"></a><span id="l27.103">   kWorkAsync: 1,</span>
<a href="#l27.104"></a><span id="l27.104" class="difflineat">@@ -389,28 +403,25 @@ var Gloda = {</span>
<a href="#l27.105"></a><span id="l27.105">     let msgIDToIndex = {};</span>
<a href="#l27.106"></a><span id="l27.106">     let results = [];</span>
<a href="#l27.107"></a><span id="l27.107">     for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l27.108"></a><span id="l27.108">       let msgID = aMessageIDs[iID];</span>
<a href="#l27.109"></a><span id="l27.109">       results.push([]);</span>
<a href="#l27.110"></a><span id="l27.110">       msgIDToIndex[msgID] = iID;</span>
<a href="#l27.111"></a><span id="l27.111">     }</span>
<a href="#l27.112"></a><span id="l27.112"> </span>
<a href="#l27.113"></a><span id="l27.113" class="difflineminus">-    let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l27.114"></a><span id="l27.114" class="difflineminus">-                      ([i, msgID] in Iterator(aMessageIDs))];</span>
<a href="#l27.115"></a><span id="l27.115" class="difflineminus">-</span>
<a href="#l27.116"></a><span id="l27.116">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l27.117"></a><span id="l27.117">       noDbQueryValidityConstraints: true,</span>
<a href="#l27.118"></a><span id="l27.118">     });</span>
<a href="#l27.119"></a><span id="l27.119" class="difflineminus">-    query.headerMessageID.apply(query, quotedIDs);</span>
<a href="#l27.120"></a><span id="l27.120" class="difflineplus">+    query.headerMessageID.apply(query, aMessageIDs);</span>
<a href="#l27.121"></a><span id="l27.121">     query.frozen = true;</span>
<a href="#l27.122"></a><span id="l27.122"> </span>
<a href="#l27.123"></a><span id="l27.123">     let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l27.124"></a><span id="l27.124">                                                    aCallback, aCallbackThis);</span>
<a href="#l27.125"></a><span id="l27.125" class="difflineminus">-    return query.getCollection(listener);</span>
<a href="#l27.126"></a><span id="l27.126" class="difflineplus">+    return query.getCollection(listener, null, {becomeNull: true});</span>
<a href="#l27.127"></a><span id="l27.127">   },</span>
<a href="#l27.128"></a><span id="l27.128"> </span>
<a href="#l27.129"></a><span id="l27.129">   /**</span>
<a href="#l27.130"></a><span id="l27.130">    * @testpoint gloda.ns.getMessageContent</span>
<a href="#l27.131"></a><span id="l27.131">    */</span>
<a href="#l27.132"></a><span id="l27.132">   getMessageContent: function gloda_ns_getMessageContent(aGlodaMessage, aMimeMsg) {</span>
<a href="#l27.133"></a><span id="l27.133">     return mimeMsgToContentAndMeta(aMimeMsg, aGlodaMessage.folderMessage.folder)[0];</span>
<a href="#l27.134"></a><span id="l27.134">   },</span>
<a href="#l27.135"></a><span id="l27.135" class="difflineat">@@ -1918,16 +1929,25 @@ var Gloda = {</span>
<a href="#l27.136"></a><span id="l27.136">     let collection = new GlodaCollection(nounDef, aItems, null, null);</span>
<a href="#l27.137"></a><span id="l27.137">     let query = new nounDef.wildcardQueryClass(collection);</span>
<a href="#l27.138"></a><span id="l27.138">     collection.query = query;</span>
<a href="#l27.139"></a><span id="l27.139">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l27.140"></a><span id="l27.140">     return collection;</span>
<a href="#l27.141"></a><span id="l27.141">   },</span>
<a href="#l27.142"></a><span id="l27.142"> </span>
<a href="#l27.143"></a><span id="l27.143">   /**</span>
<a href="#l27.144"></a><span id="l27.144" class="difflineplus">+   * Attribute providers attempting to index something that experience a fatal</span>
<a href="#l27.145"></a><span id="l27.145" class="difflineplus">+   *  problem should throw one of these.  For example:</span>
<a href="#l27.146"></a><span id="l27.146" class="difflineplus">+   *  &quot;throw new Gloda.BadItemContentsError('Message lacks an author.');&quot;.</span>
<a href="#l27.147"></a><span id="l27.147" class="difflineplus">+   *</span>
<a href="#l27.148"></a><span id="l27.148" class="difflineplus">+   * We're not really taking advantage of this yet, but it's a good idea.</span>
<a href="#l27.149"></a><span id="l27.149" class="difflineplus">+   */</span>
<a href="#l27.150"></a><span id="l27.150" class="difflineplus">+  BadItemContentsError: BadItemContentsError,</span>
<a href="#l27.151"></a><span id="l27.151" class="difflineplus">+</span>
<a href="#l27.152"></a><span id="l27.152" class="difflineplus">+  /**</span>
<a href="#l27.153"></a><span id="l27.153">    * Populate a gloda representation of an item given the thus-far built</span>
<a href="#l27.154"></a><span id="l27.154">    *  representation, the previous representation, and one or more raw</span>
<a href="#l27.155"></a><span id="l27.155">    *  representations.  The attribute providers/optimizers for the given noun</span>
<a href="#l27.156"></a><span id="l27.156">    *  type are invoked, allowing them to contribute/alter things.  Following</span>
<a href="#l27.157"></a><span id="l27.157">    *  that, we build and persist our attribute representations.</span>
<a href="#l27.158"></a><span id="l27.158">    *</span>
<a href="#l27.159"></a><span id="l27.159">    * The result of the processing ends up with attributes in 3 different forms:</span>
<a href="#l27.160"></a><span id="l27.160">    * - Database attribute rows (to be added and removed).</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_ab.js</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_ab.js</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -52,33 +52,34 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l28.4"></a><span id="l28.4"> Cu.import(&quot;resource://app/modules/gloda/indexer.js&quot;);</span>
<a href="#l28.5"></a><span id="l28.5"> </span>
<a href="#l28.6"></a><span id="l28.6"> Cu.import(&quot;resource://app/modules/gloda/noun_freetag.js&quot;);</span>
<a href="#l28.7"></a><span id="l28.7"> </span>
<a href="#l28.8"></a><span id="l28.8"> </span>
<a href="#l28.9"></a><span id="l28.9"> var GlodaABIndexer = {</span>
<a href="#l28.10"></a><span id="l28.10">   _log: null,</span>
<a href="#l28.11"></a><span id="l28.11"> </span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-  name: &quot;ab_indexer&quot;,</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+  name: &quot;index_ab&quot;,</span>
<a href="#l28.14"></a><span id="l28.14">   enable: function() {</span>
<a href="#l28.15"></a><span id="l28.15">     if (this._log == null)</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineminus">-      this._log =  Log4Moz.repository.getLogger(&quot;gloda.ab_indexer&quot;);</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineplus">+      this._log =  Log4Moz.repository.getLogger(&quot;gloda.index_ab&quot;);</span>
<a href="#l28.18"></a><span id="l28.18"> </span>
<a href="#l28.19"></a><span id="l28.19">     let abManager = Cc[&quot;@mozilla.org/abmanager;1&quot;].getService(Ci.nsIAbManager);</span>
<a href="#l28.20"></a><span id="l28.20">     abManager.addAddressBookListener(this,</span>
<a href="#l28.21"></a><span id="l28.21">                                      Ci.nsIAbListener.itemAdded |</span>
<a href="#l28.22"></a><span id="l28.22">                                        Ci.nsIAbListener.itemChanged |</span>
<a href="#l28.23"></a><span id="l28.23">                                        Ci.nsIAbListener.directoryItemRemoved);</span>
<a href="#l28.24"></a><span id="l28.24">   },</span>
<a href="#l28.25"></a><span id="l28.25"> </span>
<a href="#l28.26"></a><span id="l28.26">   disable: function() {</span>
<a href="#l28.27"></a><span id="l28.27">     let abManager = Cc[&quot;@mozilla.org/abmanager;1&quot;].getService(Ci.nsIAbManager);</span>
<a href="#l28.28"></a><span id="l28.28">     abManager.removeAddressBookListener(this);</span>
<a href="#l28.29"></a><span id="l28.29">   },</span>
<a href="#l28.30"></a><span id="l28.30"> </span>
<a href="#l28.31"></a><span id="l28.31" class="difflineplus">+  // it's a getter so we can reference 'this'</span>
<a href="#l28.32"></a><span id="l28.32">   get workers() {</span>
<a href="#l28.33"></a><span id="l28.33">     return [[&quot;ab-card&quot;, this._worker_index_card]];</span>
<a href="#l28.34"></a><span id="l28.34">   },</span>
<a href="#l28.35"></a><span id="l28.35"> </span>
<a href="#l28.36"></a><span id="l28.36">   _worker_index_card: function(aJob, aCallbackHandle) {</span>
<a href="#l28.37"></a><span id="l28.37">     let card = aJob.id;</span>
<a href="#l28.38"></a><span id="l28.38"> </span>
<a href="#l28.39"></a><span id="l28.39">     if (card.primaryEmail) {</span>
<a href="#l28.40"></a><span id="l28.40" class="difflineat">@@ -140,18 +141,18 @@ var GlodaABIndexer = {</span>
<a href="#l28.41"></a><span id="l28.41"> </span>
<a href="#l28.42"></a><span id="l28.42">   },</span>
<a href="#l28.43"></a><span id="l28.43">   onItemPropertyChanged: function ab_indexer_onItemPropertyChanged(aItem,</span>
<a href="#l28.44"></a><span id="l28.44">       aProperty, aOldValue, aNewValue) {</span>
<a href="#l28.45"></a><span id="l28.45">     if (aProperty == null &amp;&amp; aItem instanceof Ci.nsIAbCard) {</span>
<a href="#l28.46"></a><span id="l28.46">       this._log.debug(&quot;Received Card Change Notification&quot;);</span>
<a href="#l28.47"></a><span id="l28.47"> </span>
<a href="#l28.48"></a><span id="l28.48">       let card = aItem; // instanceof already QueryInterface'd for us.</span>
<a href="#l28.49"></a><span id="l28.49" class="difflineminus">-      let job = new IndexingJob(&quot;ab-card&quot;, 1, card);</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineminus">-      GlodaIndexer.indexJob(job);</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineplus">+      let job = new IndexingJob(&quot;ab-card&quot;, card);</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+      GlodaIndexer.indexJob(this, job, false);</span>
<a href="#l28.53"></a><span id="l28.53">     }</span>
<a href="#l28.54"></a><span id="l28.54">   }</span>
<a href="#l28.55"></a><span id="l28.55"> };</span>
<a href="#l28.56"></a><span id="l28.56"> GlodaIndexer.registerIndexer(GlodaABIndexer);</span>
<a href="#l28.57"></a><span id="l28.57"> </span>
<a href="#l28.58"></a><span id="l28.58"> var GlodaABAttrs = {</span>
<a href="#l28.59"></a><span id="l28.59">   providerName: &quot;gloda.ab_attr&quot;,</span>
<a href="#l28.60"></a><span id="l28.60">   _log: null,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1">copy from mailnews/db/gloda/modules/indexer.js</span>
<a href="#l29.2"></a><span id="l29.2">copy to mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l29.4"></a><span id="l29.4" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l29.5"></a><span id="l29.5" class="difflineat">@@ -32,736 +32,380 @@</span>
<a href="#l29.6"></a><span id="l29.6">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l29.7"></a><span id="l29.7">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l29.8"></a><span id="l29.8">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l29.9"></a><span id="l29.9">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l29.10"></a><span id="l29.10">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l29.11"></a><span id="l29.11">  *</span>
<a href="#l29.12"></a><span id="l29.12">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l29.13"></a><span id="l29.13"> </span>
<a href="#l29.14"></a><span id="l29.14" class="difflineplus">+&quot;use strict&quot;;</span>
<a href="#l29.15"></a><span id="l29.15" class="difflineplus">+</span>
<a href="#l29.16"></a><span id="l29.16"> /*</span>
<a href="#l29.17"></a><span id="l29.17">  * This file currently contains a fairly general implementation of asynchronous</span>
<a href="#l29.18"></a><span id="l29.18">  *  indexing with a very explicit message indexing implementation.  As gloda</span>
<a href="#l29.19"></a><span id="l29.19">  *  will eventually want to index more than just messages, the message-specific</span>
<a href="#l29.20"></a><span id="l29.20">  *  things should ideally lose their special hold on this file.  This will</span>
<a href="#l29.21"></a><span id="l29.21">  *  benefit readability/size as well.</span>
<a href="#l29.22"></a><span id="l29.22">  */</span>
<a href="#l29.23"></a><span id="l29.23"> </span>
<a href="#l29.24"></a><span id="l29.24" class="difflineminus">-const EXPORTED_SYMBOLS = ['GlodaIndexer', 'IndexingJob'];</span>
<a href="#l29.25"></a><span id="l29.25" class="difflineplus">+const EXPORTED_SYMBOLS = ['GlodaMsgIndexer'];</span>
<a href="#l29.26"></a><span id="l29.26"> </span>
<a href="#l29.27"></a><span id="l29.27"> const Cc = Components.classes;</span>
<a href="#l29.28"></a><span id="l29.28"> const Ci = Components.interfaces;</span>
<a href="#l29.29"></a><span id="l29.29"> const Cr = Components.results;</span>
<a href="#l29.30"></a><span id="l29.30"> const Cu = Components.utils;</span>
<a href="#l29.31"></a><span id="l29.31"> </span>
<a href="#l29.32"></a><span id="l29.32"> Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l29.33"></a><span id="l29.33" class="difflineplus">+Cu.import(&quot;resource://app/modules/iteratorUtils.jsm&quot;);</span>
<a href="#l29.34"></a><span id="l29.34"> </span>
<a href="#l29.35"></a><span id="l29.35"> Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l29.36"></a><span id="l29.36"> </span>
<a href="#l29.37"></a><span id="l29.37"> Cu.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l29.38"></a><span id="l29.38"> Cu.import(&quot;resource://app/modules/gloda/datastore.js&quot;);</span>
<a href="#l29.39"></a><span id="l29.39" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/datamodel.js&quot;);</span>
<a href="#l29.40"></a><span id="l29.40"> Cu.import(&quot;resource://app/modules/gloda/gloda.js&quot;);</span>
<a href="#l29.41"></a><span id="l29.41"> Cu.import(&quot;resource://app/modules/gloda/collection.js&quot;);</span>
<a href="#l29.42"></a><span id="l29.42"> Cu.import(&quot;resource://app/modules/gloda/connotent.js&quot;);</span>
<a href="#l29.43"></a><span id="l29.43"> </span>
<a href="#l29.44"></a><span id="l29.44" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/indexer.js&quot;);</span>
<a href="#l29.45"></a><span id="l29.45" class="difflineplus">+</span>
<a href="#l29.46"></a><span id="l29.46"> Cu.import(&quot;resource://app/modules/gloda/mimemsg.js&quot;);</span>
<a href="#l29.47"></a><span id="l29.47"> </span>
<a href="#l29.48"></a><span id="l29.48"> // Components.results does not have mailnews error codes!</span>
<a href="#l29.49"></a><span id="l29.49"> const NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE = 0x80550005;</span>
<a href="#l29.50"></a><span id="l29.50"> </span>
<a href="#l29.51"></a><span id="l29.51"> const GLODA_MESSAGE_ID_PROPERTY = &quot;gloda-id&quot;;</span>
<a href="#l29.52"></a><span id="l29.52" class="difflineplus">+/**</span>
<a href="#l29.53"></a><span id="l29.53" class="difflineplus">+ * Message header property to track dirty status; one of</span>
<a href="#l29.54"></a><span id="l29.54" class="difflineplus">+ *  |GlodaIndexer.kMessageClean|, |GlodaIndexer.kMessageDirty|,</span>
<a href="#l29.55"></a><span id="l29.55" class="difflineplus">+ *  |GlodaIndexer.kMessageFilthy|.</span>
<a href="#l29.56"></a><span id="l29.56" class="difflineplus">+ */</span>
<a href="#l29.57"></a><span id="l29.57"> const GLODA_DIRTY_PROPERTY = &quot;gloda-dirty&quot;;</span>
<a href="#l29.58"></a><span id="l29.58"> </span>
<a href="#l29.59"></a><span id="l29.59" class="difflineplus">+/**</span>
<a href="#l29.60"></a><span id="l29.60" class="difflineplus">+ * The sentinel GLODA_MESSAGE_ID_PROPERTY value indicating that a message fails</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineplus">+ *  to index and we should not bother trying again, at least not until a new</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineplus">+ *  release is made.</span>
<a href="#l29.63"></a><span id="l29.63" class="difflineplus">+ */</span>
<a href="#l29.64"></a><span id="l29.64" class="difflineplus">+const GLODA_BAD_MESSAGE_ID = 1;</span>
<a href="#l29.65"></a><span id="l29.65" class="difflineplus">+const GLODA_FIRST_VALID_MESSAGE_ID = 32;</span>
<a href="#l29.66"></a><span id="l29.66" class="difflineplus">+</span>
<a href="#l29.67"></a><span id="l29.67" class="difflineplus">+const JUNK_SCORE_PROPERTY = &quot;junkscore&quot;;</span>
<a href="#l29.68"></a><span id="l29.68" class="difflineplus">+const JUNK_SPAM_SCORE_STR = Ci.nsIJunkMailPlugin.IS_SPAM_SCORE.toString();</span>
<a href="#l29.69"></a><span id="l29.69" class="difflineplus">+const JUNK_HAM_SCORE_STR = Ci.nsIJunkMailPlugin.IS_HAM_SCORE.toString();</span>
<a href="#l29.70"></a><span id="l29.70" class="difflineplus">+</span>
<a href="#l29.71"></a><span id="l29.71" class="difflineplus">+const nsIArray = Ci.nsIArray;</span>
<a href="#l29.72"></a><span id="l29.72" class="difflineplus">+const nsIMsgFolder = Ci.nsIMsgFolder;</span>
<a href="#l29.73"></a><span id="l29.73" class="difflineplus">+const nsIMsgLocalMailFolder = Ci.nsIMsgLocalMailFolder;</span>
<a href="#l29.74"></a><span id="l29.74" class="difflineplus">+const nsIMsgImapMailFolder = Ci.nsIMsgImapMailFolder;</span>
<a href="#l29.75"></a><span id="l29.75" class="difflineplus">+const nsIMsgDBHdr = Ci.nsIMsgDBHdr;</span>
<a href="#l29.76"></a><span id="l29.76" class="difflineplus">+const nsMsgFolderFlags = Ci.nsMsgFolderFlags;</span>
<a href="#l29.77"></a><span id="l29.77" class="difflineplus">+const nsMsgMessageFlags = Ci.nsMsgMessageFlags;</span>
<a href="#l29.78"></a><span id="l29.78" class="difflineplus">+const nsMsgProcessingFlags = Ci.nsMsgProcessingFlags;</span>
<a href="#l29.79"></a><span id="l29.79" class="difflineplus">+</span>
<a href="#l29.80"></a><span id="l29.80"> // for list comprehension fun</span>
<a href="#l29.81"></a><span id="l29.81"> function range(begin, end) {</span>
<a href="#l29.82"></a><span id="l29.82">   for (let i = begin; i &lt; end; ++i) {</span>
<a href="#l29.83"></a><span id="l29.83">     yield i;</span>
<a href="#l29.84"></a><span id="l29.84">   }</span>
<a href="#l29.85"></a><span id="l29.85"> }</span>
<a href="#l29.86"></a><span id="l29.86"> </span>
<a href="#l29.87"></a><span id="l29.87" class="difflineminus">-const GFI = Log4Moz.repository.getLogger(&quot;gloda.fixiterator&quot;);</span>
<a href="#l29.88"></a><span id="l29.88" class="difflineminus">-</span>
<a href="#l29.89"></a><span id="l29.89" class="difflineminus">-</span>
<a href="#l29.90"></a><span id="l29.90" class="difflineminus">-// FROM STEEL (a la Joey Minta/jminta)</span>
<a href="#l29.91"></a><span id="l29.91" class="difflineminus">-// (and to go away when STEEL is checked in, although we may also want to</span>
<a href="#l29.92"></a><span id="l29.92" class="difflineminus">-//  consider just specializing the code in the few places this method is used.)</span>
<a href="#l29.93"></a><span id="l29.93"> /**</span>
<a href="#l29.94"></a><span id="l29.94" class="difflineminus">- * This function will take a variety of xpcom iterators designed for c++ and turn</span>
<a href="#l29.95"></a><span id="l29.95" class="difflineminus">- * them into a nice JavaScript style object that can be iterated using for...in</span>
<a href="#l29.96"></a><span id="l29.96" class="difflineminus">- *</span>
<a href="#l29.97"></a><span id="l29.97" class="difflineminus">- * Currently, we support the following types of xpcom iterators:</span>
<a href="#l29.98"></a><span id="l29.98" class="difflineminus">- *   nsISupportsArray</span>
<a href="#l29.99"></a><span id="l29.99" class="difflineminus">- *   nsIEnumerator</span>
<a href="#l29.100"></a><span id="l29.100" class="difflineminus">- *   nsISimpleEnumerator</span>
<a href="#l29.101"></a><span id="l29.101" class="difflineminus">- *</span>
<a href="#l29.102"></a><span id="l29.102" class="difflineminus">- *   @param aEnum  the enumerator to convert</span>
<a href="#l29.103"></a><span id="l29.103" class="difflineminus">- *   @param aIface (optional) an interface to QI each object to prior to returning</span>
<a href="#l29.104"></a><span id="l29.104" class="difflineminus">- *</span>
<a href="#l29.105"></a><span id="l29.105" class="difflineminus">- *   @note This does *not* return an Array object.  It returns an object that can</span>
<a href="#l29.106"></a><span id="l29.106" class="difflineminus">- *         be use in for...in contexts only.  To create such an array, use</span>
<a href="#l29.107"></a><span id="l29.107" class="difflineminus">- *         var array = [a for (a in fixIterator(xpcomEnumerator))];</span>
<a href="#l29.108"></a><span id="l29.108" class="difflineplus">+ * We do not set properties on the messages until we perform a DB commit; this</span>
<a href="#l29.109"></a><span id="l29.109" class="difflineplus">+ *  helper class tracks messages that we have indexed but are not yet marked</span>
<a href="#l29.110"></a><span id="l29.110" class="difflineplus">+ *  as such on their header.</span>
<a href="#l29.111"></a><span id="l29.111">  */</span>
<a href="#l29.112"></a><span id="l29.112" class="difflineminus">-function fixIterator(aEnum, aIface) {</span>
<a href="#l29.113"></a><span id="l29.113" class="difflineminus">-  let face = aIface || Ci.nsISupports;</span>
<a href="#l29.114"></a><span id="l29.114" class="difflineminus">-  // Try to QI our object to each of the known iterator types.  If the QI does</span>
<a href="#l29.115"></a><span id="l29.115" class="difflineminus">-  // not throw, assign our iteration function</span>
<a href="#l29.116"></a><span id="l29.116" class="difflineminus">-  try {</span>
<a href="#l29.117"></a><span id="l29.117" class="difflineminus">-    aEnum.QueryInterface(Ci.nsISupportsArray);</span>
<a href="#l29.118"></a><span id="l29.118" class="difflineminus">-    let iter = function() {</span>
<a href="#l29.119"></a><span id="l29.119" class="difflineminus">-      let count = aEnum.Count();</span>
<a href="#l29.120"></a><span id="l29.120" class="difflineminus">-      for (let i = 0; i &lt; count; i++)</span>
<a href="#l29.121"></a><span id="l29.121" class="difflineminus">-        yield aEnum.GetElementAt(i).QueryInterface(face);</span>
<a href="#l29.122"></a><span id="l29.122" class="difflineplus">+var PendingCommitTracker = {</span>
<a href="#l29.123"></a><span id="l29.123" class="difflineplus">+  /**</span>
<a href="#l29.124"></a><span id="l29.124" class="difflineplus">+   * Maps message URIs to their gloda ids.</span>
<a href="#l29.125"></a><span id="l29.125" class="difflineplus">+   */</span>
<a href="#l29.126"></a><span id="l29.126" class="difflineplus">+  _indexedMessagesPendingCommitByKey: {},</span>
<a href="#l29.127"></a><span id="l29.127" class="difflineplus">+  /**</span>
<a href="#l29.128"></a><span id="l29.128" class="difflineplus">+   * Map from the pending commit gloda id to a tuple of [the corresponding</span>
<a href="#l29.129"></a><span id="l29.129" class="difflineplus">+   *  message header, dirtyState].</span>
<a href="#l29.130"></a><span id="l29.130" class="difflineplus">+   */</span>
<a href="#l29.131"></a><span id="l29.131" class="difflineplus">+  _indexedMessagesPendingCommitByGlodaId: {},</span>
<a href="#l29.132"></a><span id="l29.132" class="difflineplus">+  /**</span>
<a href="#l29.133"></a><span id="l29.133" class="difflineplus">+   * Do we have a post-commit handler registered with this transaction yet?</span>
<a href="#l29.134"></a><span id="l29.134" class="difflineplus">+   */</span>
<a href="#l29.135"></a><span id="l29.135" class="difflineplus">+  _pendingCommit: false,</span>
<a href="#l29.136"></a><span id="l29.136" class="difflineplus">+</span>
<a href="#l29.137"></a><span id="l29.137" class="difflineplus">+  /**</span>
<a href="#l29.138"></a><span id="l29.138" class="difflineplus">+   * The function gets called when the commit actually happens to flush our</span>
<a href="#l29.139"></a><span id="l29.139" class="difflineplus">+   *  message id's.</span>
<a href="#l29.140"></a><span id="l29.140" class="difflineplus">+   */</span>
<a href="#l29.141"></a><span id="l29.141" class="difflineplus">+  _commitCallback: function PendingCommitTracker_commitCallback() {</span>
<a href="#l29.142"></a><span id="l29.142" class="difflineplus">+    for each (let [glodaId, [msgHdr, dirtyState]] in</span>
<a href="#l29.143"></a><span id="l29.143" class="difflineplus">+              Iterator(</span>
<a href="#l29.144"></a><span id="l29.144" class="difflineplus">+                PendingCommitTracker._indexedMessagesPendingCommitByGlodaId)) {</span>
<a href="#l29.145"></a><span id="l29.145" class="difflineplus">+      // Mark this message as indexed</span>
<a href="#l29.146"></a><span id="l29.146" class="difflineplus">+      let curGlodaId = msgHdr.getUint32Property(GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.147"></a><span id="l29.147" class="difflineplus">+      if (curGlodaId != glodaId)</span>
<a href="#l29.148"></a><span id="l29.148" class="difflineplus">+        msgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY, glodaId);</span>
<a href="#l29.149"></a><span id="l29.149" class="difflineplus">+      let headerDirty = msgHdr.getUint32Property(GLODA_DIRTY_PROPERTY);</span>
<a href="#l29.150"></a><span id="l29.150" class="difflineplus">+      if (headerDirty != dirtyState)</span>
<a href="#l29.151"></a><span id="l29.151" class="difflineplus">+        msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, dirtyState);</span>
<a href="#l29.152"></a><span id="l29.152">     }</span>
<a href="#l29.153"></a><span id="l29.153" class="difflineminus">-    return { __iterator__: iter };</span>
<a href="#l29.154"></a><span id="l29.154" class="difflineminus">-  } catch(ex) {}</span>
<a href="#l29.155"></a><span id="l29.155" class="difflineplus">+</span>
<a href="#l29.156"></a><span id="l29.156" class="difflineplus">+    PendingCommitTracker._indexedMessagesPendingCommitByGlodaId = {};</span>
<a href="#l29.157"></a><span id="l29.157" class="difflineplus">+    PendingCommitTracker._indexedMessagesPendingCommitByKey = {};</span>
<a href="#l29.158"></a><span id="l29.158"> </span>
<a href="#l29.159"></a><span id="l29.159" class="difflineminus">-  // Now try nsIEnumerator</span>
<a href="#l29.160"></a><span id="l29.160" class="difflineminus">-  try {</span>
<a href="#l29.161"></a><span id="l29.161" class="difflineminus">-    aEnum.QueryInterface(Ci.nsIEnumerator);</span>
<a href="#l29.162"></a><span id="l29.162" class="difflineminus">-    let done = false;</span>
<a href="#l29.163"></a><span id="l29.163" class="difflineminus">-    let iter = function() {</span>
<a href="#l29.164"></a><span id="l29.164" class="difflineminus">-      while (!done) {</span>
<a href="#l29.165"></a><span id="l29.165" class="difflineminus">-        try {</span>
<a href="#l29.166"></a><span id="l29.166" class="difflineminus">-          //rets.push(aEnum.currentItem().QueryInterface(face));</span>
<a href="#l29.167"></a><span id="l29.167" class="difflineminus">-          yield aEnum.currentItem().QueryInterface(face);</span>
<a href="#l29.168"></a><span id="l29.168" class="difflineminus">-          aEnum.next();</span>
<a href="#l29.169"></a><span id="l29.169" class="difflineminus">-        } catch(ex) {</span>
<a href="#l29.170"></a><span id="l29.170" class="difflineminus">-          done = true;</span>
<a href="#l29.171"></a><span id="l29.171" class="difflineminus">-          GFI.error(face + &quot; =&gt; &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex)</span>
<a href="#l29.172"></a><span id="l29.172" class="difflineminus">-        }</span>
<a href="#l29.173"></a><span id="l29.173" class="difflineminus">-      }</span>
<a href="#l29.174"></a><span id="l29.174" class="difflineminus">-    };</span>
<a href="#l29.175"></a><span id="l29.175" class="difflineplus">+    PendingCommitTracker._pendingCommit = false;</span>
<a href="#l29.176"></a><span id="l29.176" class="difflineplus">+  },</span>
<a href="#l29.177"></a><span id="l29.177" class="difflineplus">+</span>
<a href="#l29.178"></a><span id="l29.178" class="difflineplus">+  /**</span>
<a href="#l29.179"></a><span id="l29.179" class="difflineplus">+   * Track a message header that should be marked with the given gloda id when</span>
<a href="#l29.180"></a><span id="l29.180" class="difflineplus">+   *  the database commits.</span>
<a href="#l29.181"></a><span id="l29.181" class="difflineplus">+   */</span>
<a href="#l29.182"></a><span id="l29.182" class="difflineplus">+  track: function PendingCommitTracker_track(aMsgHdr, aGlodaId) {</span>
<a href="#l29.183"></a><span id="l29.183" class="difflineplus">+    let pendingKey = aMsgHdr.folder.URI + &quot;#&quot; + aMsgHdr.messageKey;</span>
<a href="#l29.184"></a><span id="l29.184" class="difflineplus">+    this._indexedMessagesPendingCommitByKey[pendingKey] = aGlodaId;</span>
<a href="#l29.185"></a><span id="l29.185" class="difflineplus">+    this._indexedMessagesPendingCommitByGlodaId[aGlodaId] =</span>
<a href="#l29.186"></a><span id="l29.186" class="difflineplus">+      [aMsgHdr, GlodaMsgIndexer.kMessageClean];</span>
<a href="#l29.187"></a><span id="l29.187"> </span>
<a href="#l29.188"></a><span id="l29.188" class="difflineminus">-    return { __iterator__: iter };</span>
<a href="#l29.189"></a><span id="l29.189" class="difflineminus">-  } catch(ex) {}</span>
<a href="#l29.190"></a><span id="l29.190" class="difflineplus">+    if (!this._pendingCommit) {</span>
<a href="#l29.191"></a><span id="l29.191" class="difflineplus">+      GlodaDatastore.runPostCommit(this._commitCallback);</span>
<a href="#l29.192"></a><span id="l29.192" class="difflineplus">+      this._pendingCommit = true;</span>
<a href="#l29.193"></a><span id="l29.193" class="difflineplus">+    }</span>
<a href="#l29.194"></a><span id="l29.194" class="difflineplus">+  },</span>
<a href="#l29.195"></a><span id="l29.195"> </span>
<a href="#l29.196"></a><span id="l29.196" class="difflineminus">-  // how about nsISimpleEnumerator? this one is nice and simple</span>
<a href="#l29.197"></a><span id="l29.197" class="difflineminus">-  try {</span>
<a href="#l29.198"></a><span id="l29.198" class="difflineminus">-    aEnum.QueryInterface(Ci.nsISimpleEnumerator);</span>
<a href="#l29.199"></a><span id="l29.199" class="difflineminus">-    let iter = function () {</span>
<a href="#l29.200"></a><span id="l29.200" class="difflineminus">-      while (aEnum.hasMoreElements())</span>
<a href="#l29.201"></a><span id="l29.201" class="difflineminus">-        yield aEnum.getNext().QueryInterface(face);</span>
<a href="#l29.202"></a><span id="l29.202" class="difflineplus">+  /**</span>
<a href="#l29.203"></a><span id="l29.203" class="difflineplus">+   * Get the current state of a message header given that we cannot rely on just</span>
<a href="#l29.204"></a><span id="l29.204" class="difflineplus">+   *  looking at the header's properties because we defer setting those</span>
<a href="#l29.205"></a><span id="l29.205" class="difflineplus">+   *  until the SQLite commit happens.</span>
<a href="#l29.206"></a><span id="l29.206" class="difflineplus">+   *</span>
<a href="#l29.207"></a><span id="l29.207" class="difflineplus">+   * @return Tuple of [gloda id, dirty status].</span>
<a href="#l29.208"></a><span id="l29.208" class="difflineplus">+   */</span>
<a href="#l29.209"></a><span id="l29.209" class="difflineplus">+  getGlodaState:</span>
<a href="#l29.210"></a><span id="l29.210" class="difflineplus">+      function PendingCommitTracker_getGlodaState(aMsgHdr) {</span>
<a href="#l29.211"></a><span id="l29.211" class="difflineplus">+    // If it's in the pending commit table, then the message is basically</span>
<a href="#l29.212"></a><span id="l29.212" class="difflineplus">+    //  clean.  Return that info.</span>
<a href="#l29.213"></a><span id="l29.213" class="difflineplus">+    let pendingKey = aMsgHdr.folder.URI + &quot;#&quot; + aMsgHdr.messageKey;</span>
<a href="#l29.214"></a><span id="l29.214" class="difflineplus">+    if (pendingKey in this._indexedMessagesPendingCommitByKey) {</span>
<a href="#l29.215"></a><span id="l29.215" class="difflineplus">+      let glodaId =</span>
<a href="#l29.216"></a><span id="l29.216" class="difflineplus">+        PendingCommitTracker._indexedMessagesPendingCommitByKey[pendingKey];</span>
<a href="#l29.217"></a><span id="l29.217" class="difflineplus">+      return [glodaId, this._indexedMessagesPendingCommitByGlodaId[glodaId][1]];</span>
<a href="#l29.218"></a><span id="l29.218">     }</span>
<a href="#l29.219"></a><span id="l29.219" class="difflineminus">-    return { __iterator__: iter };</span>
<a href="#l29.220"></a><span id="l29.220" class="difflineminus">-  } catch(ex) {}</span>
<a href="#l29.221"></a><span id="l29.221" class="difflineminus">-}</span>
<a href="#l29.222"></a><span id="l29.222" class="difflineplus">+    else {</span>
<a href="#l29.223"></a><span id="l29.223" class="difflineplus">+      // Otherwise the header's concept of state is correct.</span>
<a href="#l29.224"></a><span id="l29.224" class="difflineplus">+      let glodaId = aMsgHdr.getUint32Property(GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.225"></a><span id="l29.225" class="difflineplus">+      let glodaDirty = aMsgHdr.getUint32Property(GLODA_DIRTY_PROPERTY);</span>
<a href="#l29.226"></a><span id="l29.226" class="difflineplus">+      return [glodaId, glodaDirty];</span>
<a href="#l29.227"></a><span id="l29.227" class="difflineplus">+    }</span>
<a href="#l29.228"></a><span id="l29.228" class="difflineplus">+  },</span>
<a href="#l29.229"></a><span id="l29.229"> </span>
<a href="#l29.230"></a><span id="l29.230" class="difflineminus">-function MakeCleanMsgHdrCallback(aMsgHdr, aGlodaMessageID) {</span>
<a href="#l29.231"></a><span id="l29.231" class="difflineminus">-  return function() {</span>
<a href="#l29.232"></a><span id="l29.232" class="difflineminus">-    // Mark this message as indexed</span>
<a href="#l29.233"></a><span id="l29.233" class="difflineminus">-    aMsgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY, aGlodaMessageID);</span>
<a href="#l29.234"></a><span id="l29.234" class="difflineminus">-    // If there is a gloda-dirty flag on there, clear it by writing a 0.  (But</span>
<a href="#l29.235"></a><span id="l29.235" class="difflineminus">-    //  don't do this if we didn't have a dirty flag on there in the first</span>
<a href="#l29.236"></a><span id="l29.236" class="difflineminus">-    //  case.)  It sounds like we would actually prefer to &quot;cut&quot; the &quot;cell&quot;,</span>
<a href="#l29.237"></a><span id="l29.237" class="difflineminus">-    //  but I don't see any in-domain means of doing that.</span>
<a href="#l29.238"></a><span id="l29.238" class="difflineminus">-    try {</span>
<a href="#l29.239"></a><span id="l29.239" class="difflineminus">-      let isDirty = aMsgHdr.getUint32Property(GLODA_DIRTY_PROPERTY);</span>
<a href="#l29.240"></a><span id="l29.240" class="difflineminus">-      if (isDirty)</span>
<a href="#l29.241"></a><span id="l29.241" class="difflineminus">-        aMsgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l29.242"></a><span id="l29.242" class="difflineminus">-    }</span>
<a href="#l29.243"></a><span id="l29.243" class="difflineminus">-    catch (ex) {}</span>
<a href="#l29.244"></a><span id="l29.244" class="difflineminus">-  };</span>
<a href="#l29.245"></a><span id="l29.245" class="difflineminus">-}</span>
<a href="#l29.246"></a><span id="l29.246" class="difflineplus">+  /**</span>
<a href="#l29.247"></a><span id="l29.247" class="difflineplus">+   * Update our structure to reflect moved headers.  Moves are currently</span>
<a href="#l29.248"></a><span id="l29.248" class="difflineplus">+   *  treated as weakly interesting and do not require a reindexing</span>
<a href="#l29.249"></a><span id="l29.249" class="difflineplus">+   *  although collections will get notified.  So our job is to to fix-up</span>
<a href="#l29.250"></a><span id="l29.250" class="difflineplus">+   *  the pending commit information if the message has a pending commit.</span>
<a href="#l29.251"></a><span id="l29.251" class="difflineplus">+   */</span>
<a href="#l29.252"></a><span id="l29.252" class="difflineplus">+  noteMove: function PendingCommitTracker_noteMove(aOldHdr, aNewHdr) {</span>
<a href="#l29.253"></a><span id="l29.253" class="difflineplus">+    let oldKey = aOldHdr.folder.URI + &quot;#&quot; + aOldHdr.messageKey;</span>
<a href="#l29.254"></a><span id="l29.254" class="difflineplus">+    if (!(oldKey in this._indexedMessagesPendingCommitByKey))</span>
<a href="#l29.255"></a><span id="l29.255" class="difflineplus">+      return;</span>
<a href="#l29.256"></a><span id="l29.256" class="difflineplus">+</span>
<a href="#l29.257"></a><span id="l29.257" class="difflineplus">+    let glodaId = this._indexedMessagesPendingCommitByKey[oldKey];</span>
<a href="#l29.258"></a><span id="l29.258" class="difflineplus">+    delete this._indexedMessagesPendingCommitByKey[oldKey];</span>
<a href="#l29.259"></a><span id="l29.259" class="difflineplus">+</span>
<a href="#l29.260"></a><span id="l29.260" class="difflineplus">+    let newKey = aNewHdr.folder.URI + &quot;#&quot; + aNewHdr.messageKey;</span>
<a href="#l29.261"></a><span id="l29.261" class="difflineplus">+    this._indexedMessagesPendingCommitByKey[newKey] = glodaId;</span>
<a href="#l29.262"></a><span id="l29.262" class="difflineplus">+</span>
<a href="#l29.263"></a><span id="l29.263" class="difflineplus">+    // only clobber the header, not the dirty state</span>
<a href="#l29.264"></a><span id="l29.264" class="difflineplus">+    this._indexedMessagesPendingCommitByGlodaId[glodaId][0] = aNewHdr;</span>
<a href="#l29.265"></a><span id="l29.265" class="difflineplus">+  },</span>
<a href="#l29.266"></a><span id="l29.266"> </span>
<a href="#l29.267"></a><span id="l29.267" class="difflineminus">-/**</span>
<a href="#l29.268"></a><span id="l29.268" class="difflineminus">- * @class Capture the indexing batch concept explicitly.</span>
<a href="#l29.269"></a><span id="l29.269" class="difflineminus">- *</span>
<a href="#l29.270"></a><span id="l29.270" class="difflineminus">- * @param aJobType The type of thing we are indexing.  Current choices are:</span>
<a href="#l29.271"></a><span id="l29.271" class="difflineminus">- *   &quot;folder&quot; and &quot;message&quot;.  Previous choices included &quot;account&quot;.  The indexer</span>
<a href="#l29.272"></a><span id="l29.272" class="difflineminus">- *   currently knows too much about these; they should be de-coupled.</span>
<a href="#l29.273"></a><span id="l29.273" class="difflineminus">- * @param aDeltaType -1 for deletion, 0 for move, 1 for addition/new.</span>
<a href="#l29.274"></a><span id="l29.274" class="difflineminus">- * @param aID Specific to the job type, but for now only used to hold folder</span>
<a href="#l29.275"></a><span id="l29.275" class="difflineminus">- *     IDs.</span>
<a href="#l29.276"></a><span id="l29.276" class="difflineminus">- *</span>
<a href="#l29.277"></a><span id="l29.277" class="difflineminus">- * @ivar items The list of items to process during this job/batch.  (For</span>
<a href="#l29.278"></a><span id="l29.278" class="difflineminus">- *     example, if this is a &quot;messages&quot; job, this would be the list of messages</span>
<a href="#l29.279"></a><span id="l29.279" class="difflineminus">- *     to process, although the specific representation is determined by the</span>
<a href="#l29.280"></a><span id="l29.280" class="difflineminus">- *     job.)  The list will only be mutated through the addition of extra items.</span>
<a href="#l29.281"></a><span id="l29.281" class="difflineminus">- * @ivar offset The current offset into the 'items' list (if used), updated as</span>
<a href="#l29.282"></a><span id="l29.282" class="difflineminus">- *     processing occurs.  If 'items' is not used, the processing code can also</span>
<a href="#l29.283"></a><span id="l29.283" class="difflineminus">- *     update this in a similar fashion.  This is used by the status</span>
<a href="#l29.284"></a><span id="l29.284" class="difflineminus">- *     notification code in conjunction with goal.</span>
<a href="#l29.285"></a><span id="l29.285" class="difflineminus">- * @ivar goal The total number of items to index/actions to perform in this job.</span>
<a href="#l29.286"></a><span id="l29.286" class="difflineminus">- *     This number may increase during the life of the job, but should not</span>
<a href="#l29.287"></a><span id="l29.287" class="difflineminus">- *     decrease.  This is used by the status notification code in conjunction</span>
<a href="#l29.288"></a><span id="l29.288" class="difflineminus">- *     with the goal.</span>
<a href="#l29.289"></a><span id="l29.289" class="difflineminus">- * @ivar recoverable Integer indicating if this job is recoverable, and how</span>
<a href="#l29.290"></a><span id="l29.290" class="difflineminus">- *     many failures we should allow for before we give up.  By default, this is</span>
<a href="#l29.291"></a><span id="l29.291" class="difflineminus">- *     set to 10, but your job should choose a more appopriate number itself.</span>
<a href="#l29.292"></a><span id="l29.292" class="difflineminus">- *</span>
<a href="#l29.293"></a><span id="l29.293" class="difflineminus">- * @constructor</span>
<a href="#l29.294"></a><span id="l29.294" class="difflineminus">- */</span>
<a href="#l29.295"></a><span id="l29.295" class="difflineminus">-function IndexingJob(aJobType, aDeltaType, aID, aItems) {</span>
<a href="#l29.296"></a><span id="l29.296" class="difflineminus">-  this.jobType = aJobType;</span>
<a href="#l29.297"></a><span id="l29.297" class="difflineminus">-  this.deltaType = aDeltaType;</span>
<a href="#l29.298"></a><span id="l29.298" class="difflineminus">-  this.id = aID;</span>
<a href="#l29.299"></a><span id="l29.299" class="difflineminus">-  this.items = (aItems != null) ? aItems : [];</span>
<a href="#l29.300"></a><span id="l29.300" class="difflineminus">-  this.offset = 0;</span>
<a href="#l29.301"></a><span id="l29.301" class="difflineminus">-  this.goal = null;</span>
<a href="#l29.302"></a><span id="l29.302" class="difflineminus">-  this.recoverable = 10;</span>
<a href="#l29.303"></a><span id="l29.303" class="difflineminus">-}</span>
<a href="#l29.304"></a><span id="l29.304" class="difflineminus">-IndexingJob.prototype = {</span>
<a href="#l29.305"></a><span id="l29.305" class="difflineminus">-  toString: function IndexingJob_toString() {</span>
<a href="#l29.306"></a><span id="l29.306" class="difflineminus">-    return &quot;[job:&quot; + this.jobType + &quot; delta:&quot; + this.deltaType +</span>
<a href="#l29.307"></a><span id="l29.307" class="difflineminus">-      &quot; id:&quot; + this.id + &quot; items:&quot; + (this.items ? this.items.length : &quot;no&quot;) +</span>
<a href="#l29.308"></a><span id="l29.308" class="difflineminus">-      &quot; offset:&quot; + this.offset + &quot; goal:&quot; + this.goal + &quot;]&quot;;</span>
<a href="#l29.309"></a><span id="l29.309" class="difflineminus">-  }</span>
<a href="#l29.310"></a><span id="l29.310" class="difflineplus">+  /**</span>
<a href="#l29.311"></a><span id="l29.311" class="difflineplus">+   * A blind move is one where we have the source header but not the destination</span>
<a href="#l29.312"></a><span id="l29.312" class="difflineplus">+   *  header.  This happens for IMAP messages.</span>
<a href="#l29.313"></a><span id="l29.313" class="difflineplus">+   * XXX Since IMAP moves will propagate the gloda-id/gloda-dirty bits for us,</span>
<a href="#l29.314"></a><span id="l29.314" class="difflineplus">+   *  we could detect the other side of the move when it shows up as a</span>
<a href="#l29.315"></a><span id="l29.315" class="difflineplus">+   *  msgsClassified event and restore the mapping information.</span>
<a href="#l29.316"></a><span id="l29.316" class="difflineplus">+   *</span>
<a href="#l29.317"></a><span id="l29.317" class="difflineplus">+   * We just re-dispatch to noteDirtyHeader because we can't do anything more</span>
<a href="#l29.318"></a><span id="l29.318" class="difflineplus">+   *  clever.</span>
<a href="#l29.319"></a><span id="l29.319" class="difflineplus">+   */</span>
<a href="#l29.320"></a><span id="l29.320" class="difflineplus">+  noteBlindMove: function PendingCommitTracker_noteBlindMove(aOldHdr) {</span>
<a href="#l29.321"></a><span id="l29.321" class="difflineplus">+    this.noteDirtyHeader(aOldHdr);</span>
<a href="#l29.322"></a><span id="l29.322" class="difflineplus">+  },</span>
<a href="#l29.323"></a><span id="l29.323" class="difflineplus">+</span>
<a href="#l29.324"></a><span id="l29.324" class="difflineplus">+  /**</span>
<a href="#l29.325"></a><span id="l29.325" class="difflineplus">+   * If a message is dirty we should stop tracking it for post-commit</span>
<a href="#l29.326"></a><span id="l29.326" class="difflineplus">+   *  purposes.  This is not because we don't want to write to its header</span>
<a href="#l29.327"></a><span id="l29.327" class="difflineplus">+   *  when we commit as much as that we want to avoid |getHeaderGlodaState|</span>
<a href="#l29.328"></a><span id="l29.328" class="difflineplus">+   *  reporting that the message is clean.  We could complicate our state</span>
<a href="#l29.329"></a><span id="l29.329" class="difflineplus">+   *  by storing that information, but this is easier and ends up the same</span>
<a href="#l29.330"></a><span id="l29.330" class="difflineplus">+   *  in the end.</span>
<a href="#l29.331"></a><span id="l29.331" class="difflineplus">+   */</span>
<a href="#l29.332"></a><span id="l29.332" class="difflineplus">+  noteDirtyHeader: function PendingCommitTracker_noteDirtyHeader(aMsgHdr) {</span>
<a href="#l29.333"></a><span id="l29.333" class="difflineplus">+    let pendingKey = aMsgHdr.folder.URI + &quot;#&quot; + aMsgHdr.messageKey;</span>
<a href="#l29.334"></a><span id="l29.334" class="difflineplus">+    if (!(pendingKey in this._indexedMessagesPendingCommitByKey))</span>
<a href="#l29.335"></a><span id="l29.335" class="difflineplus">+      return;</span>
<a href="#l29.336"></a><span id="l29.336" class="difflineplus">+</span>
<a href="#l29.337"></a><span id="l29.337" class="difflineplus">+    // (It is important that we get the gloda id from our own structure!)</span>
<a href="#l29.338"></a><span id="l29.338" class="difflineplus">+    let glodaId = this._indexedMessagesPendingCommitByKey[pendingKey];</span>
<a href="#l29.339"></a><span id="l29.339" class="difflineplus">+    this._indexedMessagesPendingCommitByGlodaId[glodaId][1] =</span>
<a href="#l29.340"></a><span id="l29.340" class="difflineplus">+      GlodaMsgIndexer.kMessageDirty;</span>
<a href="#l29.341"></a><span id="l29.341" class="difflineplus">+  },</span>
<a href="#l29.342"></a><span id="l29.342" class="difflineplus">+</span>
<a href="#l29.343"></a><span id="l29.343" class="difflineplus">+  /**</span>
<a href="#l29.344"></a><span id="l29.344" class="difflineplus">+   * When a folder compaction happens, we are basically out of luck and need</span>
<a href="#l29.345"></a><span id="l29.345" class="difflineplus">+   *  to discard everything about the folder.  The good news is that the</span>
<a href="#l29.346"></a><span id="l29.346" class="difflineplus">+   *  folder compaction pass is clever enough to put two and two together.</span>
<a href="#l29.347"></a><span id="l29.347" class="difflineplus">+   */</span>
<a href="#l29.348"></a><span id="l29.348" class="difflineplus">+  noteFolderCompaction:</span>
<a href="#l29.349"></a><span id="l29.349" class="difflineplus">+      function PendingCommitTracker_noteFolderCompaction(aMsgFolder) {</span>
<a href="#l29.350"></a><span id="l29.350" class="difflineplus">+    let uri = aMsgFolder.URI + &quot;#&quot;;</span>
<a href="#l29.351"></a><span id="l29.351" class="difflineplus">+    for (let key in Iterator(this._indexedMessagesPendingCommitByKey, true)) {</span>
<a href="#l29.352"></a><span id="l29.352" class="difflineplus">+      // this is not as efficient as it could be, but compaction is relatively</span>
<a href="#l29.353"></a><span id="l29.353" class="difflineplus">+      //  rare and the number of pending headers is generally going to be</span>
<a href="#l29.354"></a><span id="l29.354" class="difflineplus">+      //  small.</span>
<a href="#l29.355"></a><span id="l29.355" class="difflineplus">+      if (key.indexOf(uri) == 0) {</span>
<a href="#l29.356"></a><span id="l29.356" class="difflineplus">+        delete this._indexedMessagesPendingCommitByKey[key];</span>
<a href="#l29.357"></a><span id="l29.357" class="difflineplus">+      }</span>
<a href="#l29.358"></a><span id="l29.358" class="difflineplus">+    }</span>
<a href="#l29.359"></a><span id="l29.359" class="difflineplus">+  },</span>
<a href="#l29.360"></a><span id="l29.360"> };</span>
<a href="#l29.361"></a><span id="l29.361"> </span>
<a href="#l29.362"></a><span id="l29.362"> /**</span>
<a href="#l29.363"></a><span id="l29.363" class="difflineminus">- * @namespace Core indexing logic, plus message-specific indexing logic.</span>
<a href="#l29.364"></a><span id="l29.364" class="difflineminus">- *</span>
<a href="#l29.365"></a><span id="l29.365" class="difflineminus">- * === Indexing Goals</span>
<a href="#l29.366"></a><span id="l29.366" class="difflineminus">- * We have the following goals:</span>
<a href="#l29.367"></a><span id="l29.367" class="difflineminus">- *</span>
<a href="#l29.368"></a><span id="l29.368" class="difflineminus">- * Responsiveness</span>
<a href="#l29.369"></a><span id="l29.369" class="difflineminus">- * - When the user wants to quit, we should be able to stop and quit in a timely</span>
<a href="#l29.370"></a><span id="l29.370" class="difflineminus">- *   fasion.</span>
<a href="#l29.371"></a><span id="l29.371" class="difflineminus">- * - We should not interfere with the user's thunderbird usage.</span>
<a href="#l29.372"></a><span id="l29.372" class="difflineplus">+ * The message indexer!</span>
<a href="#l29.373"></a><span id="l29.373">  *</span>
<a href="#l29.374"></a><span id="l29.374" class="difflineminus">- * Correctness</span>
<a href="#l29.375"></a><span id="l29.375" class="difflineminus">- * - Quitting should not result in any information loss; we should (eventually)</span>
<a href="#l29.376"></a><span id="l29.376" class="difflineminus">- *   end up at the same indexed state regardless of whether a user lets</span>
<a href="#l29.377"></a><span id="l29.377" class="difflineminus">- *   indexing run to completion or restarts thunderbird in the middle of the</span>
<a href="#l29.378"></a><span id="l29.378" class="difflineminus">- *   process.  (It is okay to take slightly longer in the latter case.)</span>
<a href="#l29.379"></a><span id="l29.379" class="difflineminus">- *</span>
<a href="#l29.380"></a><span id="l29.380" class="difflineminus">- * Worst Case Scenario Avoidance</span>
<a href="#l29.381"></a><span id="l29.381" class="difflineminus">- * - We should try to be O(1) memory-wise regardless of what notifications</span>
<a href="#l29.382"></a><span id="l29.382" class="difflineminus">- *   are thrown at us.</span>
<a href="#l29.383"></a><span id="l29.383" class="difflineminus">- *</span>
<a href="#l29.384"></a><span id="l29.384" class="difflineminus">- * === Indexing Strategy</span>
<a href="#l29.385"></a><span id="l29.385" class="difflineplus">+ * === Message Indexing Strategy</span>
<a href="#l29.386"></a><span id="l29.386">  * To these ends, we implement things like so:</span>
<a href="#l29.387"></a><span id="l29.387">  *</span>
<a href="#l29.388"></a><span id="l29.388">  * Mesage State Tracking</span>
<a href="#l29.389"></a><span id="l29.389">  * - We store a property on all indexed headers indicating their gloda message</span>
<a href="#l29.390"></a><span id="l29.390">  *   id.  This allows us to tell whether a message is indexed from the header,</span>
<a href="#l29.391"></a><span id="l29.391">  *   without having to consult the SQL database.</span>
<a href="#l29.392"></a><span id="l29.392">  * - When we receive an event that indicates that a message's meta-data has</span>
<a href="#l29.393"></a><span id="l29.393">  *   changed and gloda needs to re-index the message, we set a property on the</span>
<a href="#l29.394"></a><span id="l29.394" class="difflineminus">- *   header that indicates the message is dirty.</span>
<a href="#l29.395"></a><span id="l29.395" class="difflineminus">- * - We store a property on folders that indicate that the folder's index is</span>
<a href="#l29.396"></a><span id="l29.396" class="difflineminus">- *   up-to-date.  Absence of this property is akin to a 0=folder not up to date.</span>
<a href="#l29.397"></a><span id="l29.397" class="difflineminus">- *   There is no particular reason for the choice of using the folder's</span>
<a href="#l29.398"></a><span id="l29.398" class="difflineminus">- *   properties (via the folder cache implementation) over gloda's own folder</span>
<a href="#l29.399"></a><span id="l29.399" class="difflineminus">- *   meta-data.</span>
<a href="#l29.400"></a><span id="l29.400" class="difflineplus">+ *   header that indicates the message is dirty.  This property can indicate</span>
<a href="#l29.401"></a><span id="l29.401" class="difflineplus">+ *   that the message needs to be re-indexed but the gloda-id is valid (dirty)</span>
<a href="#l29.402"></a><span id="l29.402" class="difflineplus">+ *   or that the message's gloda-id is invalid (filthy) because the gloda</span>
<a href="#l29.403"></a><span id="l29.403" class="difflineplus">+ *   database has been blown away.</span>
<a href="#l29.404"></a><span id="l29.404" class="difflineplus">+ * - We track whether a folder is up-to-date on our GlodaFolder representation</span>
<a href="#l29.405"></a><span id="l29.405" class="difflineplus">+ *   using a concept of dirtiness, just like messages.  Like messages, a folder</span>
<a href="#l29.406"></a><span id="l29.406" class="difflineplus">+ *   can be dirty or filthy.  A dirty folder has at least one dirty message in</span>
<a href="#l29.407"></a><span id="l29.407" class="difflineplus">+ *   it which means we should scan the folder.  A filthy folder means that</span>
<a href="#l29.408"></a><span id="l29.408" class="difflineplus">+ *   every message in the folder should be considered filthy.  Folders start</span>
<a href="#l29.409"></a><span id="l29.409" class="difflineplus">+ *   out filthy when Gloda is first told about them indicating we cannot</span>
<a href="#l29.410"></a><span id="l29.410" class="difflineplus">+ *   trust any of the gloda-id's in the folders.  Filthy folders are downgraded</span>
<a href="#l29.411"></a><span id="l29.411" class="difflineplus">+ *   to dirty folders after we mark all of the headers with gloda-id's filthy.</span>
<a href="#l29.412"></a><span id="l29.412">  *</span>
<a href="#l29.413"></a><span id="l29.413">  * Indexing Message Control</span>
<a href="#l29.414"></a><span id="l29.414">  * - We index the headers of all IMAP messages. We index the bodies of all IMAP</span>
<a href="#l29.415"></a><span id="l29.415" class="difflineminus">- *   messages that are offline.  We index all local messages.</span>
<a href="#l29.416"></a><span id="l29.416" class="difflineminus">- *   We plan to avoid indexing news messages.</span>
<a href="#l29.417"></a><span id="l29.417" class="difflineplus">+ *   messages that are offline.  We index all local messages.  We plan to avoid</span>
<a href="#l29.418"></a><span id="l29.418" class="difflineplus">+ *   indexing news messages.</span>
<a href="#l29.419"></a><span id="l29.419">  * - We would like a way to express desires about indexing that either don't</span>
<a href="#l29.420"></a><span id="l29.420">  *   confound offline storage with indexing, or actually allow some choice.</span>
<a href="#l29.421"></a><span id="l29.421">  *</span>
<a href="#l29.422"></a><span id="l29.422" class="difflineminus">- * Indexing</span>
<a href="#l29.423"></a><span id="l29.423" class="difflineminus">- * - We process one folder at a time, walking the headers in the folder,</span>
<a href="#l29.424"></a><span id="l29.424" class="difflineminus">- *   indexing those which should be indexed, but which have never been indexed</span>
<a href="#l29.425"></a><span id="l29.425" class="difflineminus">- *   or are dirty.</span>
<a href="#l29.426"></a><span id="l29.426" class="difflineplus">+ * Indexing Messages</span>
<a href="#l29.427"></a><span id="l29.427" class="difflineplus">+ * - We have two major modes of indexing: sweep and event-driven.  When we</span>
<a href="#l29.428"></a><span id="l29.428" class="difflineplus">+ *   start up we kick off an indexing sweep.  We use event-driven indexing</span>
<a href="#l29.429"></a><span id="l29.429" class="difflineplus">+ *   as we receive events for eligible messages, but if we get too many</span>
<a href="#l29.430"></a><span id="l29.430" class="difflineplus">+ *   events we start dropping them on the floor and just flag that an indexing</span>
<a href="#l29.431"></a><span id="l29.431" class="difflineplus">+ *   sweep is required.</span>
<a href="#l29.432"></a><span id="l29.432" class="difflineplus">+ * - The sweep initiates folder indexing jobs based on the priorities assigned</span>
<a href="#l29.433"></a><span id="l29.433" class="difflineplus">+ *   to folders.  Folder indexing uses a filtered message enumerator to find</span>
<a href="#l29.434"></a><span id="l29.434" class="difflineplus">+ *   messages that need to be indexed, minimizing wasteful exposure of message</span>
<a href="#l29.435"></a><span id="l29.435" class="difflineplus">+ *   headers to XPConnect that we would not end up indexing.</span>
<a href="#l29.436"></a><span id="l29.436">  * - For local folders, we use GetDatabaseWithReparse to ensure that the .msf</span>
<a href="#l29.437"></a><span id="l29.437">  *   file exists.  For IMAP folders, we simply use GetDatabase because we know</span>
<a href="#l29.438"></a><span id="l29.438">  *   the auto-sync logic will make sure that the folder is up-to-date and we</span>
<a href="#l29.439"></a><span id="l29.439">  *   want to avoid creating problems through use of updateFolder.</span>
<a href="#l29.440"></a><span id="l29.440">  *</span>
<a href="#l29.441"></a><span id="l29.441" class="difflineminus">- * Indexing Throttling</span>
<a href="#l29.442"></a><span id="l29.442" class="difflineminus">- * - Unless we believe everything is up-to-date, then we are always indexing.</span>
<a href="#l29.443"></a><span id="l29.443" class="difflineminus">- *   We must be able to process messages</span>
<a href="#l29.444"></a><span id="l29.444" class="difflineminus">- *</span>
<a href="#l29.445"></a><span id="l29.445" class="difflineminus">- *</span>
<a href="#l29.446"></a><span id="l29.446" class="difflineminus">- * === Message Indexing</span>
<a href="#l29.447"></a><span id="l29.447" class="difflineminus">- *</span>
<a href="#l29.448"></a><span id="l29.448" class="difflineminus">- * We are good at listening to nsIMsgFolderListener events.  Unfortunately,</span>
<a href="#l29.449"></a><span id="l29.449" class="difflineminus">- *  MailNews isn't pervasively thorough at generating these yet (newsgroups</span>
<a href="#l29.450"></a><span id="l29.450" class="difflineminus">- *  don't produce them, probably not RSS either.)  This provides us with</span>
<a href="#l29.451"></a><span id="l29.451" class="difflineminus">- *  message addition, moves/copies, and deletion.</span>
<a href="#l29.452"></a><span id="l29.452" class="difflineminus">- * We are not good at listening to nsIFolderListener events.  This means we fail</span>
<a href="#l29.453"></a><span id="l29.453" class="difflineminus">- *  to update ourselves when a message is changed because of a change in tags,</span>
<a href="#l29.454"></a><span id="l29.454" class="difflineminus">- *  read status/starred status/etc.  (Well, in fairness, events aren't actually</span>
<a href="#l29.455"></a><span id="l29.455" class="difflineminus">- *  generated in all of those cases either, yet, but we should try.)  We need</span>
<a href="#l29.456"></a><span id="l29.456" class="difflineminus">- *  to handle this.</span>
<a href="#l29.457"></a><span id="l29.457" class="difflineminus">- *</span>
<a href="#l29.458"></a><span id="l29.458" class="difflineminus">- * Currently, when we index a message, when it comes to attributes, we ignore</span>
<a href="#l29.459"></a><span id="l29.459" class="difflineminus">- *  all that has come before us and simply blow away the attributes and apply</span>
<a href="#l29.460"></a><span id="l29.460" class="difflineminus">- *  those provided by the attribute providers anew.  This is not particularly</span>
<a href="#l29.461"></a><span id="l29.461" class="difflineminus">- *  efficient for anyone.  Also, I think we probably screw this up now that we</span>
<a href="#l29.462"></a><span id="l29.462" class="difflineminus">- *  have object identity support.  Uh, so, this should be improved, but</span>
<a href="#l29.463"></a><span id="l29.463" class="difflineminus">- *  certainly works.</span>
<a href="#l29.464"></a><span id="l29.464" class="difflineplus">+ * Junk Mail</span>
<a href="#l29.465"></a><span id="l29.465" class="difflineplus">+ * - We do not index junk.  We do not index messages until the junk/non-junk</span>
<a href="#l29.466"></a><span id="l29.466" class="difflineplus">+ *   determination has been made.  If a message gets marked as junk, we act like</span>
<a href="#l29.467"></a><span id="l29.467" class="difflineplus">+ *   it was deleted.</span>
<a href="#l29.468"></a><span id="l29.468" class="difflineplus">+ * - We know when a message is actively queued for junk processing thanks to</span>
<a href="#l29.469"></a><span id="l29.469" class="difflineplus">+ *   folder processing flags.  nsMsgDBFolder::CallFilterPlugins does this</span>
<a href="#l29.470"></a><span id="l29.470" class="difflineplus">+ *   prior to initiating spam processing.  Unfortunately, this method does not</span>
<a href="#l29.471"></a><span id="l29.471" class="difflineplus">+ *   get called until after we receive the notification about the existence of</span>
<a href="#l29.472"></a><span id="l29.472" class="difflineplus">+ *   the header.  How long after can vary on different factors.  The longest</span>
<a href="#l29.473"></a><span id="l29.473" class="difflineplus">+ *   delay is in the IMAP case where there is a filter that requires the</span>
<a href="#l29.474"></a><span id="l29.474" class="difflineplus">+ *   message body to be present; the method does not get called until all the</span>
<a href="#l29.475"></a><span id="l29.475" class="difflineplus">+ *   bodies are downloaded.</span>
<a href="#l29.476"></a><span id="l29.476">  *</span>
<a href="#l29.477"></a><span id="l29.477">  */</span>
<a href="#l29.478"></a><span id="l29.478" class="difflineminus">-var GlodaIndexer = {</span>
<a href="#l29.479"></a><span id="l29.479" class="difflineplus">+var GlodaMsgIndexer = {</span>
<a href="#l29.480"></a><span id="l29.480">   /**</span>
<a href="#l29.481"></a><span id="l29.481">    * A partial attempt to generalize to support multiple databases.  Each</span>
<a href="#l29.482"></a><span id="l29.482">    *  database would have its own datastore would have its own indexer.  But</span>
<a href="#l29.483"></a><span id="l29.483">    *  we rather inter-mingle our use of this field with the singleton global</span>
<a href="#l29.484"></a><span id="l29.484">    *  GlodaDatastore.</span>
<a href="#l29.485"></a><span id="l29.485">    */</span>
<a href="#l29.486"></a><span id="l29.486">   _datastore: GlodaDatastore,</span>
<a href="#l29.487"></a><span id="l29.487" class="difflineminus">-  _log: Log4Moz.repository.getLogger(&quot;gloda.indexer&quot;),</span>
<a href="#l29.488"></a><span id="l29.488" class="difflineminus">-  /**</span>
<a href="#l29.489"></a><span id="l29.489" class="difflineminus">-   * Our nsITimer that we use to schedule ourselves on the main thread</span>
<a href="#l29.490"></a><span id="l29.490" class="difflineminus">-   *  intermittently.  The timer always exists but may not always be active.</span>
<a href="#l29.491"></a><span id="l29.491" class="difflineminus">-   */</span>
<a href="#l29.492"></a><span id="l29.492" class="difflineminus">-  _timer: null,</span>
<a href="#l29.493"></a><span id="l29.493" class="difflineminus">-  /**</span>
<a href="#l29.494"></a><span id="l29.494" class="difflineminus">-   * Our nsITimer that we use to schedule events in the &quot;far&quot; future.  For now,</span>
<a href="#l29.495"></a><span id="l29.495" class="difflineminus">-   *  this means not compelling an initial indexing sweep until some number of</span>
<a href="#l29.496"></a><span id="l29.496" class="difflineminus">-   *  seconds after startup.</span>
<a href="#l29.497"></a><span id="l29.497" class="difflineminus">-   */</span>
<a href="#l29.498"></a><span id="l29.498" class="difflineminus">-  _longTimer: null,</span>
<a href="#l29.499"></a><span id="l29.499" class="difflineminus">-</span>
<a href="#l29.500"></a><span id="l29.500" class="difflineminus">-  /**</span>
<a href="#l29.501"></a><span id="l29.501" class="difflineminus">-   * Periodic performance adjustment parameters:  The overall goal is to adjust</span>
<a href="#l29.502"></a><span id="l29.502" class="difflineminus">-   *  our rate of work so that we don't interfere with the user's activities</span>
<a href="#l29.503"></a><span id="l29.503" class="difflineminus">-   *  when they are around (non-idle), and the system in general (when idle).</span>
<a href="#l29.504"></a><span id="l29.504" class="difflineminus">-   *  Being nice when idle isn't quite as important, but is a good idea so that</span>
<a href="#l29.505"></a><span id="l29.505" class="difflineminus">-   *  when the user un-idles we are able to back off nicely.  Also, we give</span>
<a href="#l29.506"></a><span id="l29.506" class="difflineminus">-   *  other processes on the system a chance to do something.</span>
<a href="#l29.507"></a><span id="l29.507" class="difflineminus">-   *</span>
<a href="#l29.508"></a><span id="l29.508" class="difflineminus">-   * We do this by organizing our work into discrete &quot;tokens&quot; of activity,</span>
<a href="#l29.509"></a><span id="l29.509" class="difflineminus">-   *  then processing the number of tokens that we have determined will</span>
<a href="#l29.510"></a><span id="l29.510" class="difflineminus">-   *  not impact the UI. Then we pause to give other activities a chance to get</span>
<a href="#l29.511"></a><span id="l29.511" class="difflineminus">-   *  some work done, and we measure whether anything happened during our pause.</span>
<a href="#l29.512"></a><span id="l29.512" class="difflineminus">-   *  If something else is going on in our application during that pause, we</span>
<a href="#l29.513"></a><span id="l29.513" class="difflineminus">-   *  give it priority (up to a point) by delaying further indexing.</span>
<a href="#l29.514"></a><span id="l29.514" class="difflineminus">-   *</span>
<a href="#l29.515"></a><span id="l29.515" class="difflineminus">-   * Keep in mind that many of our operations are actually asynchronous, so we</span>
<a href="#l29.516"></a><span id="l29.516" class="difflineminus">-   *  aren't entirely starving the event queue.  However, a lot of the async</span>
<a href="#l29.517"></a><span id="l29.517" class="difflineminus">-   *  stuff can end up not having any actual delay between events. For</span>
<a href="#l29.518"></a><span id="l29.518" class="difflineminus">-   *  example, we only index offline message bodies, so there's no network</span>
<a href="#l29.519"></a><span id="l29.519" class="difflineminus">-   *  latency involved, just disk IO; the only meaningful latency will be the</span>
<a href="#l29.520"></a><span id="l29.520" class="difflineminus">-   *  initial disk seek (if there is one... pre-fetching may seriously be our</span>
<a href="#l29.521"></a><span id="l29.521" class="difflineminus">-   *  friend).</span>
<a href="#l29.522"></a><span id="l29.522" class="difflineminus">-   *</span>
<a href="#l29.523"></a><span id="l29.523" class="difflineminus">-   * In order to maintain responsiveness, I assert that we want to minimize the</span>
<a href="#l29.524"></a><span id="l29.524" class="difflineminus">-   *  length of the time we are dominating the event queue.  This suggests</span>
<a href="#l29.525"></a><span id="l29.525" class="difflineminus">-   *  that we want break up our blocks of work frequently.  But not so</span>
<a href="#l29.526"></a><span id="l29.526" class="difflineminus">-   *  frequently that there is a lot of waste.  Accordingly our algorithm is</span>
<a href="#l29.527"></a><span id="l29.527" class="difflineminus">-   *  basically:</span>
<a href="#l29.528"></a><span id="l29.528" class="difflineminus">-   *</span>
<a href="#l29.529"></a><span id="l29.529" class="difflineminus">-   * - Estimate the time that it takes to process a token, and schedule the</span>
<a href="#l29.530"></a><span id="l29.530" class="difflineminus">-   *   number of tokens that should fit into that time.</span>
<a href="#l29.531"></a><span id="l29.531" class="difflineminus">-   * - Detect user activity, and back off immediately if found.</span>
<a href="#l29.532"></a><span id="l29.532" class="difflineminus">-   * - Try to delay commits and garbage collection until the user is inactive,</span>
<a href="#l29.533"></a><span id="l29.533" class="difflineminus">-   *   as these tend to cause a brief pause in the UI.</span>
<a href="#l29.534"></a><span id="l29.534" class="difflineminus">-   */</span>
<a href="#l29.535"></a><span id="l29.535" class="difflineminus">-</span>
<a href="#l29.536"></a><span id="l29.536" class="difflineminus">-  /**</span>
<a href="#l29.537"></a><span id="l29.537" class="difflineminus">-   * The number of milliseconds before we declare the user idle and step up our</span>
<a href="#l29.538"></a><span id="l29.538" class="difflineminus">-   *  indexing.</span>
<a href="#l29.539"></a><span id="l29.539" class="difflineminus">-   */</span>
<a href="#l29.540"></a><span id="l29.540" class="difflineminus">-  _INDEX_IDLE_ADJUSTMENT_TIME: 5000,</span>
<a href="#l29.541"></a><span id="l29.541" class="difflineminus">-</span>
<a href="#l29.542"></a><span id="l29.542" class="difflineminus">-  /**</span>
<a href="#l29.543"></a><span id="l29.543" class="difflineminus">-   * The time delay in milliseconds before we should schedule our initial sweep.</span>
<a href="#l29.544"></a><span id="l29.544" class="difflineminus">-   */</span>
<a href="#l29.545"></a><span id="l29.545" class="difflineminus">-  _INITIAL_SWEEP_DELAY: 10000,</span>
<a href="#l29.546"></a><span id="l29.546" class="difflineminus">-</span>
<a href="#l29.547"></a><span id="l29.547" class="difflineminus">-  /**</span>
<a href="#l29.548"></a><span id="l29.548" class="difflineminus">-   * How many milliseconds in the future should we schedule indexing to start</span>
<a href="#l29.549"></a><span id="l29.549" class="difflineminus">-   *  when turning on indexing (and it was not previously active).</span>
<a href="#l29.550"></a><span id="l29.550" class="difflineminus">-   */</span>
<a href="#l29.551"></a><span id="l29.551" class="difflineminus">-  _INDEX_KICKOFF_DELAY: 200,</span>
<a href="#l29.552"></a><span id="l29.552" class="difflineminus">-</span>
<a href="#l29.553"></a><span id="l29.553" class="difflineminus">-  /**</span>
<a href="#l29.554"></a><span id="l29.554" class="difflineminus">-   * The time interval, in milliseconds, of pause between indexing batches.  The</span>
<a href="#l29.555"></a><span id="l29.555" class="difflineminus">-   *  maximum processor consumption is determined by this constant and the</span>
<a href="#l29.556"></a><span id="l29.556" class="difflineminus">-   *  active |_cpuTargetIndexTime|.</span>
<a href="#l29.557"></a><span id="l29.557" class="difflineminus">-   *</span>
<a href="#l29.558"></a><span id="l29.558" class="difflineminus">-   * For current constants, that puts us at 50% while the user is active and 83%</span>
<a href="#l29.559"></a><span id="l29.559" class="difflineminus">-   *  when idle.</span>
<a href="#l29.560"></a><span id="l29.560" class="difflineminus">-   */</span>
<a href="#l29.561"></a><span id="l29.561" class="difflineminus">-  _INDEX_INTERVAL: 32,</span>
<a href="#l29.562"></a><span id="l29.562" class="difflineminus">-</span>
<a href="#l29.563"></a><span id="l29.563" class="difflineminus">-  /**</span>
<a href="#l29.564"></a><span id="l29.564" class="difflineminus">-   * Number of indexing 'tokens' we are allowed to consume before yielding for</span>
<a href="#l29.565"></a><span id="l29.565" class="difflineminus">-   *  each incremental pass.  Consider a single token equal to indexing a single</span>
<a href="#l29.566"></a><span id="l29.566" class="difflineminus">-   *  medium-sized message.  This may be altered by user session (in)activity.</span>
<a href="#l29.567"></a><span id="l29.567" class="difflineminus">-   * Because we fetch message bodies, which is potentially asynchronous, this</span>
<a href="#l29.568"></a><span id="l29.568" class="difflineminus">-   *  is not a precise knob to twiddle.</span>
<a href="#l29.569"></a><span id="l29.569" class="difflineminus">-   */</span>
<a href="#l29.570"></a><span id="l29.570" class="difflineminus">-  _indexTokens: 2,</span>
<a href="#l29.571"></a><span id="l29.571" class="difflineplus">+  _log: Log4Moz.repository.getLogger(&quot;gloda.index_msg&quot;),</span>
<a href="#l29.572"></a><span id="l29.572"> </span>
<a href="#l29.573"></a><span id="l29.573" class="difflineminus">-  /**</span>
<a href="#l29.574"></a><span id="l29.574" class="difflineminus">-   * Stopwatches used to measure performance during indexing, and during</span>
<a href="#l29.575"></a><span id="l29.575" class="difflineminus">-   * pauses between indexing. These help us adapt our indexing constants so</span>
<a href="#l29.576"></a><span id="l29.576" class="difflineminus">-   *  as to not explode your computer.  Kind of us, no?</span>
<a href="#l29.577"></a><span id="l29.577" class="difflineminus">-   */</span>
<a href="#l29.578"></a><span id="l29.578" class="difflineminus">-  _perfIndexStopwatch: null,</span>
<a href="#l29.579"></a><span id="l29.579" class="difflineminus">-  _perfPauseStopwatch: null,</span>
<a href="#l29.580"></a><span id="l29.580" class="difflineminus">-  /**</span>
<a href="#l29.581"></a><span id="l29.581" class="difflineminus">-   * Do we have an uncommitted indexer transaction that idle callback should commit?</span>
<a href="#l29.582"></a><span id="l29.582" class="difflineminus">-   */</span>
<a href="#l29.583"></a><span id="l29.583" class="difflineminus">-  _idleToCommit: false,</span>
<a href="#l29.584"></a><span id="l29.584" class="difflineminus">-  /**</span>
<a href="#l29.585"></a><span id="l29.585" class="difflineminus">-   * Target CPU time per batch of tokens, current value (milliseconds).</span>
<a href="#l29.586"></a><span id="l29.586" class="difflineminus">-   */</span>
<a href="#l29.587"></a><span id="l29.587" class="difflineminus">-  _cpuTargetIndexTime: 32,</span>
<a href="#l29.588"></a><span id="l29.588" class="difflineminus">-  /**</span>
<a href="#l29.589"></a><span id="l29.589" class="difflineminus">-   * Target CPU time per batch of tokens, during non-idle (milliseconds).</span>
<a href="#l29.590"></a><span id="l29.590" class="difflineminus">-   */</span>
<a href="#l29.591"></a><span id="l29.591" class="difflineminus">-  _CPU_TARGET_INDEX_TIME_ACTIVE: 32,</span>
<a href="#l29.592"></a><span id="l29.592" class="difflineminus">-  /**</span>
<a href="#l29.593"></a><span id="l29.593" class="difflineminus">-   * Target CPU time per batch of tokens, during idle (milliseconds).</span>
<a href="#l29.594"></a><span id="l29.594" class="difflineminus">-   */</span>
<a href="#l29.595"></a><span id="l29.595" class="difflineminus">-  _CPU_TARGET_INDEX_TIME_IDLE: 160,</span>
<a href="#l29.596"></a><span id="l29.596" class="difflineminus">-  /**</span>
<a href="#l29.597"></a><span id="l29.597" class="difflineminus">-   * Average CPU time per processed token (milliseconds).</span>
<a href="#l29.598"></a><span id="l29.598" class="difflineminus">-   */</span>
<a href="#l29.599"></a><span id="l29.599" class="difflineminus">-  _cpuAverageTimePerToken: 16,</span>
<a href="#l29.600"></a><span id="l29.600" class="difflineminus">-  /**</span>
<a href="#l29.601"></a><span id="l29.601" class="difflineminus">-   * Damping factor for _cpuAverageTimePerToken, as an approximate</span>
<a href="#l29.602"></a><span id="l29.602" class="difflineminus">-   * number of tokens to include in the average time.</span>
<a href="#l29.603"></a><span id="l29.603" class="difflineminus">-   */</span>
<a href="#l29.604"></a><span id="l29.604" class="difflineminus">-  _CPU_AVERAGE_TIME_DAMPING: 200,</span>
<a href="#l29.605"></a><span id="l29.605" class="difflineminus">-  /**</span>
<a href="#l29.606"></a><span id="l29.606" class="difflineminus">-   * Maximum tokens per batch. This is normally just a sanity check.</span>
<a href="#l29.607"></a><span id="l29.607" class="difflineminus">-   */</span>
<a href="#l29.608"></a><span id="l29.608" class="difflineminus">-  _CPU_MAX_TOKENS_PER_BATCH: 100,</span>
<a href="#l29.609"></a><span id="l29.609" class="difflineminus">-  /**</span>
<a href="#l29.610"></a><span id="l29.610" class="difflineminus">-   * CPU usage during a pause to declare that system was busy (milliseconds).</span>
<a href="#l29.611"></a><span id="l29.611" class="difflineminus">-   * This is typically set as 1.5 times the minimum resolution of the cpu</span>
<a href="#l29.612"></a><span id="l29.612" class="difflineminus">-   * usage clock, which is 16 milliseconds on Windows systems, and (I think)</span>
<a href="#l29.613"></a><span id="l29.613" class="difflineminus">-   * smaller on other systems, so we take the worst case.</span>
<a href="#l29.614"></a><span id="l29.614" class="difflineminus">-   */</span>
<a href="#l29.615"></a><span id="l29.615" class="difflineminus">-  _CPU_IS_BUSY_TIME: 24,</span>
<a href="#l29.616"></a><span id="l29.616" class="difflineminus">-  /**</span>
<a href="#l29.617"></a><span id="l29.617" class="difflineminus">-   * Time that return from pause may be late before the system is declared</span>
<a href="#l29.618"></a><span id="l29.618" class="difflineminus">-   * busy, in milliseconds. (Same issues as _CPU_IS_BUSY_TIME).</span>
<a href="#l29.619"></a><span id="l29.619" class="difflineminus">-   */</span>
<a href="#l29.620"></a><span id="l29.620" class="difflineminus">-  _PAUSE_LATE_IS_BUSY_TIME: 24,</span>
<a href="#l29.621"></a><span id="l29.621" class="difflineminus">-  /**</span>
<a href="#l29.622"></a><span id="l29.622" class="difflineminus">-   * Number of times that we will repeat a pause while waiting for a</span>
<a href="#l29.623"></a><span id="l29.623" class="difflineminus">-   * free CPU.</span>
<a href="#l29.624"></a><span id="l29.624" class="difflineminus">-   */</span>
<a href="#l29.625"></a><span id="l29.625" class="difflineminus">-  _PAUSE_REPEAT_LIMIT: 10,</span>
<a href="#l29.626"></a><span id="l29.626" class="difflineminus">-  /**</span>
<a href="#l29.627"></a><span id="l29.627" class="difflineminus">-   * Minimum time delay between commits, in milliseconds.</span>
<a href="#l29.628"></a><span id="l29.628" class="difflineminus">-   */</span>
<a href="#l29.629"></a><span id="l29.629" class="difflineminus">-  _MINIMUM_COMMIT_TIME: 5000,</span>
<a href="#l29.630"></a><span id="l29.630" class="difflineminus">-  /**</span>
<a href="#l29.631"></a><span id="l29.631" class="difflineminus">-   * Maximum time delay between commits, in milliseconds.</span>
<a href="#l29.632"></a><span id="l29.632" class="difflineminus">-   */</span>
<a href="#l29.633"></a><span id="l29.633" class="difflineminus">-  _MAXIMUM_COMMIT_TIME: 20000,</span>
<a href="#l29.634"></a><span id="l29.634" class="difflineminus">-  /**</span>
<a href="#l29.635"></a><span id="l29.635" class="difflineminus">-   * Last commit time.</span>
<a href="#l29.636"></a><span id="l29.636" class="difflineminus">-   */</span>
<a href="#l29.637"></a><span id="l29.637" class="difflineminus">-  _lastCommitTime: Date.now(),</span>
<a href="#l29.638"></a><span id="l29.638" class="difflineminus">-</span>
<a href="#l29.639"></a><span id="l29.639" class="difflineminus">-  _inited: false,</span>
<a href="#l29.640"></a><span id="l29.640" class="difflineminus">-  /**</span>
<a href="#l29.641"></a><span id="l29.641" class="difflineminus">-   * Initialize the indexer.</span>
<a href="#l29.642"></a><span id="l29.642" class="difflineminus">-   */</span>
<a href="#l29.643"></a><span id="l29.643" class="difflineminus">-  _init: function gloda_index_init() {</span>
<a href="#l29.644"></a><span id="l29.644" class="difflineminus">-    if (this._inited)</span>
<a href="#l29.645"></a><span id="l29.645" class="difflineminus">-      return;</span>
<a href="#l29.646"></a><span id="l29.646" class="difflineminus">-</span>
<a href="#l29.647"></a><span id="l29.647" class="difflineminus">-    this._inited = true;</span>
<a href="#l29.648"></a><span id="l29.648" class="difflineminus">-</span>
<a href="#l29.649"></a><span id="l29.649" class="difflineminus">-    // initialize our listeners' this pointers</span>
<a href="#l29.650"></a><span id="l29.650" class="difflineminus">-    this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l29.651"></a><span id="l29.651" class="difflineminus">-    this._msgFolderListener.indexer = this;</span>
<a href="#l29.652"></a><span id="l29.652" class="difflineminus">-</span>
<a href="#l29.653"></a><span id="l29.653" class="difflineminus">-    this._callbackHandle.init();</span>
<a href="#l29.654"></a><span id="l29.654" class="difflineminus">-</span>
<a href="#l29.655"></a><span id="l29.655" class="difflineminus">-    // create the timer that drives our intermittent indexing</span>
<a href="#l29.656"></a><span id="l29.656" class="difflineminus">-    this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l29.657"></a><span id="l29.657" class="difflineminus">-    // create the timer for larger offsets independent of indexing</span>
<a href="#l29.658"></a><span id="l29.658" class="difflineminus">-    this._longTimer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l29.659"></a><span id="l29.659" class="difflineminus">-</span>
<a href="#l29.660"></a><span id="l29.660" class="difflineminus">-    this._idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;]</span>
<a href="#l29.661"></a><span id="l29.661" class="difflineminus">-                          .getService(Ci.nsIIdleService);</span>
<a href="#l29.662"></a><span id="l29.662" class="difflineminus">-</span>
<a href="#l29.663"></a><span id="l29.663" class="difflineminus">-    // create our performance stopwatches</span>
<a href="#l29.664"></a><span id="l29.664" class="difflineminus">-    try {</span>
<a href="#l29.665"></a><span id="l29.665" class="difflineminus">-      this._perfIndexStopwatch = Cc[&quot;@mozilla.org/stopwatch;1&quot;]</span>
<a href="#l29.666"></a><span id="l29.666" class="difflineminus">-                                   .createInstance(Ci.nsIStopwatch);</span>
<a href="#l29.667"></a><span id="l29.667" class="difflineminus">-      this._perfPauseStopwatch = Cc[&quot;@mozilla.org/stopwatch;1&quot;]</span>
<a href="#l29.668"></a><span id="l29.668" class="difflineminus">-                                   .createInstance(Ci.nsIStopwatch);</span>
<a href="#l29.669"></a><span id="l29.669" class="difflineplus">+  _junkService:</span>
<a href="#l29.670"></a><span id="l29.670" class="difflineplus">+    Cc[&quot;@mozilla.org/messenger/filter-plugin;1?name=bayesianfilter&quot;]</span>
<a href="#l29.671"></a><span id="l29.671" class="difflineplus">+      .getService(Ci.nsIJunkMailPlugin),</span>
<a href="#l29.672"></a><span id="l29.672"> </span>
<a href="#l29.673"></a><span id="l29.673" class="difflineminus">-    } catch (ex) {</span>
<a href="#l29.674"></a><span id="l29.674" class="difflineminus">-      this._log.error(&quot;problem creating stopwatch!: &quot; + ex);</span>
<a href="#l29.675"></a><span id="l29.675" class="difflineminus">-    }</span>
<a href="#l29.676"></a><span id="l29.676" class="difflineminus">-    // figure out if event-driven indexing should be enabled...</span>
<a href="#l29.677"></a><span id="l29.677" class="difflineminus">-    let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l29.678"></a><span id="l29.678" class="difflineminus">-                        getService(Ci.nsIPrefService);</span>
<a href="#l29.679"></a><span id="l29.679" class="difflineminus">-    let branch = prefService.getBranch(&quot;mailnews.database.global.indexer.&quot;);</span>
<a href="#l29.680"></a><span id="l29.680" class="difflineminus">-    let eventDrivenEnabled = false; // default</span>
<a href="#l29.681"></a><span id="l29.681" class="difflineminus">-    let performInitialSweep = true; // default</span>
<a href="#l29.682"></a><span id="l29.682" class="difflineminus">-    try {</span>
<a href="#l29.683"></a><span id="l29.683" class="difflineminus">-      eventDrivenEnabled = branch.getBoolPref(&quot;enabled&quot;);</span>
<a href="#l29.684"></a><span id="l29.684" class="difflineminus">-    } catch (ex) {</span>
<a href="#l29.685"></a><span id="l29.685" class="difflineminus">-      dump(&quot;%%% annoying exception on pref access: &quot; + ex);</span>
<a href="#l29.686"></a><span id="l29.686" class="difflineminus">-    }</span>
<a href="#l29.687"></a><span id="l29.687" class="difflineminus">-    // this is a secret preference mainly intended for testing purposes.</span>
<a href="#l29.688"></a><span id="l29.688" class="difflineminus">-    try {</span>
<a href="#l29.689"></a><span id="l29.689" class="difflineminus">-      performInitialSweep = branch.getBoolPref(&quot;perform_initial_sweep&quot;);</span>
<a href="#l29.690"></a><span id="l29.690" class="difflineminus">-    } catch (ex) {}</span>
<a href="#l29.691"></a><span id="l29.691" class="difflineminus">-    // pretend we have already performed an initial sweep...</span>
<a href="#l29.692"></a><span id="l29.692" class="difflineminus">-    if (!performInitialSweep)</span>
<a href="#l29.693"></a><span id="l29.693" class="difflineminus">-      this._initialSweepPerformed = true;</span>
<a href="#l29.694"></a><span id="l29.694" class="difflineminus">-</span>
<a href="#l29.695"></a><span id="l29.695" class="difflineminus">-    this.enabled = eventDrivenEnabled;</span>
<a href="#l29.696"></a><span id="l29.696" class="difflineminus">-  },</span>
<a href="#l29.697"></a><span id="l29.697" class="difflineminus">-</span>
<a href="#l29.698"></a><span id="l29.698" class="difflineminus">-  /**</span>
<a href="#l29.699"></a><span id="l29.699" class="difflineminus">-   * When shutdown, indexing immediately ceases and no further progress should</span>
<a href="#l29.700"></a><span id="l29.700" class="difflineminus">-   *  be made.  This flag goes true once, and never returns to false.  Being</span>
<a href="#l29.701"></a><span id="l29.701" class="difflineminus">-   *  in this state is a destructive thing from whence we cannot recover.</span>
<a href="#l29.702"></a><span id="l29.702" class="difflineminus">-   */</span>
<a href="#l29.703"></a><span id="l29.703" class="difflineminus">-  _indexerIsShutdown: false,</span>
<a href="#l29.704"></a><span id="l29.704" class="difflineminus">-</span>
<a href="#l29.705"></a><span id="l29.705" class="difflineminus">-  /**</span>
<a href="#l29.706"></a><span id="l29.706" class="difflineminus">-   * Shutdown the indexing process and datastore as quickly as possible in</span>
<a href="#l29.707"></a><span id="l29.707" class="difflineminus">-   *  a synchronous fashion.</span>
<a href="#l29.708"></a><span id="l29.708" class="difflineminus">-   *</span>
<a href="#l29.709"></a><span id="l29.709" class="difflineminus">-   * @returns true on full and immediate shutdown, false if we need to pend on</span>
<a href="#l29.710"></a><span id="l29.710" class="difflineminus">-   *     something asynchronous.</span>
<a href="#l29.711"></a><span id="l29.711" class="difflineminus">-   */</span>
<a href="#l29.712"></a><span id="l29.712" class="difflineminus">-  _shutdown: function gloda_index_shutdown() {</span>
<a href="#l29.713"></a><span id="l29.713" class="difflineminus">-    // no more timer events, please</span>
<a href="#l29.714"></a><span id="l29.714" class="difflineminus">-    try {</span>
<a href="#l29.715"></a><span id="l29.715" class="difflineminus">-      this._timer.cancel();</span>
<a href="#l29.716"></a><span id="l29.716" class="difflineminus">-    } catch (ex) {}</span>
<a href="#l29.717"></a><span id="l29.717" class="difflineminus">-    this._timer = null;</span>
<a href="#l29.718"></a><span id="l29.718" class="difflineminus">-    try {</span>
<a href="#l29.719"></a><span id="l29.719" class="difflineminus">-      this._longTimer.cancel();</span>
<a href="#l29.720"></a><span id="l29.720" class="difflineminus">-    } catch (ex) {}</span>
<a href="#l29.721"></a><span id="l29.721" class="difflineminus">-    this._longTimer = null;</span>
<a href="#l29.722"></a><span id="l29.722" class="difflineminus">-</span>
<a href="#l29.723"></a><span id="l29.723" class="difflineminus">-    this._perfIndexStopwatch = null;</span>
<a href="#l29.724"></a><span id="l29.724" class="difflineminus">-    this._perfPauseStopwatch = null;</span>
<a href="#l29.725"></a><span id="l29.725" class="difflineminus">-</span>
<a href="#l29.726"></a><span id="l29.726" class="difflineminus">-    // Remove listeners to avoid reference cycles on the off chance one of them</span>
<a href="#l29.727"></a><span id="l29.727" class="difflineminus">-    // holds a reference to the indexer object.</span>
<a href="#l29.728"></a><span id="l29.728" class="difflineminus">-    this._indexListeners = [];</span>
<a href="#l29.729"></a><span id="l29.729" class="difflineminus">-</span>
<a href="#l29.730"></a><span id="l29.730" class="difflineminus">-    this._indexerIsShutdown = true;</span>
<a href="#l29.731"></a><span id="l29.731" class="difflineminus">-</span>
<a href="#l29.732"></a><span id="l29.732" class="difflineminus">-    if (!this.enabled)</span>
<a href="#l29.733"></a><span id="l29.733" class="difflineminus">-      return true;</span>
<a href="#l29.734"></a><span id="l29.734" class="difflineminus">-</span>
<a href="#l29.735"></a><span id="l29.735" class="difflineminus">-    this._log.info(&quot;Shutting Down&quot;);</span>
<a href="#l29.736"></a><span id="l29.736" class="difflineminus">-</span>
<a href="#l29.737"></a><span id="l29.737" class="difflineminus">-    this.suppressIndexing = true;</span>
<a href="#l29.738"></a><span id="l29.738" class="difflineminus">-    this._indexerLeaveFolder(); // nop if we aren't &quot;in&quot; a folder</span>
<a href="#l29.739"></a><span id="l29.739" class="difflineminus">-    this._callbackHandle.cleanup();</span>
<a href="#l29.740"></a><span id="l29.740" class="difflineminus">-    this._workBatchData = undefined;</span>
<a href="#l29.741"></a><span id="l29.741" class="difflineminus">-    this.enabled = false;</span>
<a href="#l29.742"></a><span id="l29.742" class="difflineminus">-</span>
<a href="#l29.743"></a><span id="l29.743" class="difflineminus">-    GlodaDatastore.shutdown();</span>
<a href="#l29.744"></a><span id="l29.744" class="difflineminus">-  },</span>
<a href="#l29.745"></a><span id="l29.745" class="difflineminus">-</span>
<a href="#l29.746"></a><span id="l29.746" class="difflineminus">-  _otherIndexers: [],</span>
<a href="#l29.747"></a><span id="l29.747" class="difflineminus">-  registerIndexer: function gloda_index_registerIndexer(aIndexer) {</span>
<a href="#l29.748"></a><span id="l29.748" class="difflineminus">-    this._log.info(&quot;Registering indexer: &quot; + aIndexer.name);</span>
<a href="#l29.749"></a><span id="l29.749" class="difflineminus">-    this._otherIndexers.push(aIndexer);</span>
<a href="#l29.750"></a><span id="l29.750" class="difflineminus">-</span>
<a href="#l29.751"></a><span id="l29.751" class="difflineminus">-    try {</span>
<a href="#l29.752"></a><span id="l29.752" class="difflineminus">-      for each (let [iWorker, workerInfo] in Iterator(aIndexer.workers)) {</span>
<a href="#l29.753"></a><span id="l29.753" class="difflineminus">-        let [workerCode, workerFunc] = workerInfo;</span>
<a href="#l29.754"></a><span id="l29.754" class="difflineminus">-        this._otherIndexerWorkers[workerCode] = [aIndexer, workerFunc];</span>
<a href="#l29.755"></a><span id="l29.755" class="difflineminus">-      }</span>
<a href="#l29.756"></a><span id="l29.756" class="difflineminus">-    }</span>
<a href="#l29.757"></a><span id="l29.757" class="difflineminus">-    catch (ex) {</span>
<a href="#l29.758"></a><span id="l29.758" class="difflineminus">-      this._log.warn(&quot;Helper indexer threw exception on worker enum.&quot;);</span>
<a href="#l29.759"></a><span id="l29.759" class="difflineminus">-    }</span>
<a href="#l29.760"></a><span id="l29.760" class="difflineminus">-</span>
<a href="#l29.761"></a><span id="l29.761" class="difflineminus">-    if (this._enabled) {</span>
<a href="#l29.762"></a><span id="l29.762" class="difflineminus">-      try {</span>
<a href="#l29.763"></a><span id="l29.763" class="difflineminus">-        aIndexer.enable();</span>
<a href="#l29.764"></a><span id="l29.764" class="difflineminus">-      } catch (ex) {</span>
<a href="#l29.765"></a><span id="l29.765" class="difflineminus">-        this._log.warn(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l29.766"></a><span id="l29.766" class="difflineminus">-      }</span>
<a href="#l29.767"></a><span id="l29.767" class="difflineminus">-    }</span>
<a href="#l29.768"></a><span id="l29.768" class="difflineminus">-  },</span>
<a href="#l29.769"></a><span id="l29.769" class="difflineminus">-</span>
<a href="#l29.770"></a><span id="l29.770" class="difflineplus">+  name: &quot;index_msg&quot;,</span>
<a href="#l29.771"></a><span id="l29.771">   /**</span>
<a href="#l29.772"></a><span id="l29.772">    * Are we enabled, read: are we processing change events?</span>
<a href="#l29.773"></a><span id="l29.773">    */</span>
<a href="#l29.774"></a><span id="l29.774">   _enabled: false,</span>
<a href="#l29.775"></a><span id="l29.775">   get enabled() { return this._enabled; },</span>
<a href="#l29.776"></a><span id="l29.776" class="difflineminus">-  set enabled(aEnable) {</span>
<a href="#l29.777"></a><span id="l29.777" class="difflineminus">-    if (!this._enabled &amp;&amp; aEnable) {</span>
<a href="#l29.778"></a><span id="l29.778" class="difflineminus">-      // register for:</span>
<a href="#l29.779"></a><span id="l29.779" class="difflineminus">-      // - folder loaded events, so we know when getDatabaseWithReparse has finished</span>
<a href="#l29.780"></a><span id="l29.780" class="difflineminus">-      //   updating the index/what not (if it was't immediately available)</span>
<a href="#l29.781"></a><span id="l29.781" class="difflineminus">-      // - property changes (so we know when a message's read/starred state have</span>
<a href="#l29.782"></a><span id="l29.782" class="difflineminus">-      //   changed.)</span>
<a href="#l29.783"></a><span id="l29.783" class="difflineminus">-      let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l29.784"></a><span id="l29.784" class="difflineminus">-                          getService(Ci.nsIMsgMailSession);</span>
<a href="#l29.785"></a><span id="l29.785" class="difflineminus">-      this._folderListener._init(this);</span>
<a href="#l29.786"></a><span id="l29.786" class="difflineminus">-      mailSession.AddFolderListener(this._folderListener,</span>
<a href="#l29.787"></a><span id="l29.787" class="difflineminus">-                                    Ci.nsIFolderListener.propertyFlagChanged |</span>
<a href="#l29.788"></a><span id="l29.788" class="difflineminus">-                                    Ci.nsIFolderListener.event);</span>
<a href="#l29.789"></a><span id="l29.789"> </span>
<a href="#l29.790"></a><span id="l29.790" class="difflineminus">-      // register for shutdown, offline notifications</span>
<a href="#l29.791"></a><span id="l29.791" class="difflineminus">-      let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l29.792"></a><span id="l29.792" class="difflineminus">-                              getService(Ci.nsIObserverService);</span>
<a href="#l29.793"></a><span id="l29.793" class="difflineminus">-      observerService.addObserver(this, &quot;network:offline-status-changed&quot;, false);</span>
<a href="#l29.794"></a><span id="l29.794" class="difflineminus">-      observerService.addObserver(this, &quot;quit-application&quot;, false);</span>
<a href="#l29.795"></a><span id="l29.795" class="difflineminus">-</span>
<a href="#l29.796"></a><span id="l29.796" class="difflineminus">-      // register for idle notification</span>
<a href="#l29.797"></a><span id="l29.797" class="difflineminus">-      this._idleService.addIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l29.798"></a><span id="l29.798" class="difflineminus">-</span>
<a href="#l29.799"></a><span id="l29.799" class="difflineminus">-      let notificationService =</span>
<a href="#l29.800"></a><span id="l29.800" class="difflineminus">-        Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l29.801"></a><span id="l29.801" class="difflineminus">-        getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l29.802"></a><span id="l29.802" class="difflineminus">-      notificationService.addListener(this._msgFolderListener,</span>
<a href="#l29.803"></a><span id="l29.803" class="difflineminus">-                                      Ci.nsIMsgFolderNotificationService.all &amp;</span>
<a href="#l29.804"></a><span id="l29.804" class="difflineminus">-                                      ~Ci.nsIMsgFolderNotificationService.folderAdded);</span>
<a href="#l29.805"></a><span id="l29.805" class="difflineminus">-</span>
<a href="#l29.806"></a><span id="l29.806" class="difflineminus">-      this._enabled = true;</span>
<a href="#l29.807"></a><span id="l29.807" class="difflineminus">-</span>
<a href="#l29.808"></a><span id="l29.808" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l29.809"></a><span id="l29.809" class="difflineminus">-        try {</span>
<a href="#l29.810"></a><span id="l29.810" class="difflineminus">-          indexer.enable();</span>
<a href="#l29.811"></a><span id="l29.811" class="difflineminus">-        } catch (ex) {</span>
<a href="#l29.812"></a><span id="l29.812" class="difflineminus">-          this._log.warn(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l29.813"></a><span id="l29.813" class="difflineminus">-        }</span>
<a href="#l29.814"></a><span id="l29.814" class="difflineminus">-      }</span>
<a href="#l29.815"></a><span id="l29.815" class="difflineplus">+  enable: function msg_indexer_enable() {</span>
<a href="#l29.816"></a><span id="l29.816" class="difflineplus">+    // initialize our listeners' this pointers</span>
<a href="#l29.817"></a><span id="l29.817" class="difflineplus">+    this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l29.818"></a><span id="l29.818" class="difflineplus">+    this._msgFolderListener.indexer = this;</span>
<a href="#l29.819"></a><span id="l29.819"> </span>
<a href="#l29.820"></a><span id="l29.820" class="difflineminus">-      // if we have an accumulated desire to index things, kick it off again.</span>
<a href="#l29.821"></a><span id="l29.821" class="difflineminus">-      if (this._indexingDesired) {</span>
<a href="#l29.822"></a><span id="l29.822" class="difflineminus">-        this._indexingDesired = false; // it's edge-triggered for now</span>
<a href="#l29.823"></a><span id="l29.823" class="difflineminus">-        this.indexing = true;</span>
<a href="#l29.824"></a><span id="l29.824" class="difflineminus">-      }</span>
<a href="#l29.825"></a><span id="l29.825" class="difflineminus">-</span>
<a href="#l29.826"></a><span id="l29.826" class="difflineminus">-      // if we have not done an initial sweep, schedule scheduling one.</span>
<a href="#l29.827"></a><span id="l29.827" class="difflineminus">-      if (!this._initialSweepPerformed)</span>
<a href="#l29.828"></a><span id="l29.828" class="difflineminus">-        this._longTimer.initWithCallback(this._scheduleInitialSweep,</span>
<a href="#l29.829"></a><span id="l29.829" class="difflineminus">-          this._INITIAL_SWEEP_DELAY, Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l29.830"></a><span id="l29.830" class="difflineminus">-    }</span>
<a href="#l29.831"></a><span id="l29.831" class="difflineminus">-    else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l29.832"></a><span id="l29.832" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l29.833"></a><span id="l29.833" class="difflineminus">-        try {</span>
<a href="#l29.834"></a><span id="l29.834" class="difflineminus">-          indexer.disable();</span>
<a href="#l29.835"></a><span id="l29.835" class="difflineminus">-        } catch (ex) {</span>
<a href="#l29.836"></a><span id="l29.836" class="difflineminus">-          this._log.warn(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l29.837"></a><span id="l29.837" class="difflineminus">-        }</span>
<a href="#l29.838"></a><span id="l29.838" class="difflineminus">-      }</span>
<a href="#l29.839"></a><span id="l29.839" class="difflineplus">+    // register for:</span>
<a href="#l29.840"></a><span id="l29.840" class="difflineplus">+    // - folder loaded events, so we know when getDatabaseWithReparse has</span>
<a href="#l29.841"></a><span id="l29.841" class="difflineplus">+    //   finished updating the index/what not (if it was't immediately</span>
<a href="#l29.842"></a><span id="l29.842" class="difflineplus">+    //   available)</span>
<a href="#l29.843"></a><span id="l29.843" class="difflineplus">+    // - property changes (so we know when a message's read/starred state have</span>
<a href="#l29.844"></a><span id="l29.844" class="difflineplus">+    //   changed.)</span>
<a href="#l29.845"></a><span id="l29.845" class="difflineplus">+    let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l29.846"></a><span id="l29.846" class="difflineplus">+      getService(Ci.nsIMsgMailSession);</span>
<a href="#l29.847"></a><span id="l29.847" class="difflineplus">+    this._folderListener._init(this);</span>
<a href="#l29.848"></a><span id="l29.848" class="difflineplus">+    mailSession.AddFolderListener(this._folderListener,</span>
<a href="#l29.849"></a><span id="l29.849" class="difflineplus">+                                  Ci.nsIFolderListener.propertyFlagChanged |</span>
<a href="#l29.850"></a><span id="l29.850" class="difflineplus">+                                  Ci.nsIFolderListener.event);</span>
<a href="#l29.851"></a><span id="l29.851"> </span>
<a href="#l29.852"></a><span id="l29.852" class="difflineminus">-      // remove observer; no more events to observe!</span>
<a href="#l29.853"></a><span id="l29.853" class="difflineminus">-      let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l29.854"></a><span id="l29.854" class="difflineminus">-                              getService(Ci.nsIObserverService);</span>
<a href="#l29.855"></a><span id="l29.855" class="difflineminus">-      observerService.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l29.856"></a><span id="l29.856" class="difflineminus">-      observerService.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l29.857"></a><span id="l29.857" class="difflineminus">-</span>
<a href="#l29.858"></a><span id="l29.858" class="difflineminus">-      // remove idle</span>
<a href="#l29.859"></a><span id="l29.859" class="difflineminus">-      this._idleService.removeIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l29.860"></a><span id="l29.860" class="difflineplus">+    let notificationService =</span>
<a href="#l29.861"></a><span id="l29.861" class="difflineplus">+      Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l29.862"></a><span id="l29.862" class="difflineplus">+      getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l29.863"></a><span id="l29.863" class="difflineplus">+    notificationService.addListener(this._msgFolderListener,</span>
<a href="#l29.864"></a><span id="l29.864" class="difflineplus">+      // note: intentionally no msgAdded notification is requested.</span>
<a href="#l29.865"></a><span id="l29.865" class="difflineplus">+      Ci.nsIMsgFolderNotificationService.msgsClassified |</span>
<a href="#l29.866"></a><span id="l29.866" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.msgsDeleted |</span>
<a href="#l29.867"></a><span id="l29.867" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.msgsMoveCopyCompleted |</span>
<a href="#l29.868"></a><span id="l29.868" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.folderDeleted |</span>
<a href="#l29.869"></a><span id="l29.869" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.folderMoveCopyCompleted |</span>
<a href="#l29.870"></a><span id="l29.870" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.folderRenamed |</span>
<a href="#l29.871"></a><span id="l29.871" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.itemEvent);</span>
<a href="#l29.872"></a><span id="l29.872"> </span>
<a href="#l29.873"></a><span id="l29.873" class="difflineminus">-      // remove FolderLoaded notification listener</span>
<a href="#l29.874"></a><span id="l29.874" class="difflineminus">-      let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l29.875"></a><span id="l29.875" class="difflineminus">-                          getService(Ci.nsIMsgMailSession);</span>
<a href="#l29.876"></a><span id="l29.876" class="difflineminus">-      mailSession.RemoveFolderListener(this._folderListener);</span>
<a href="#l29.877"></a><span id="l29.877" class="difflineminus">-</span>
<a href="#l29.878"></a><span id="l29.878" class="difflineminus">-      let notificationService =</span>
<a href="#l29.879"></a><span id="l29.879" class="difflineminus">-        Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l29.880"></a><span id="l29.880" class="difflineminus">-        getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l29.881"></a><span id="l29.881" class="difflineminus">-      notificationService.removeListener(this._msgFolderListener);</span>
<a href="#l29.882"></a><span id="l29.882" class="difflineminus">-</span>
<a href="#l29.883"></a><span id="l29.883" class="difflineminus">-      this._enabled = false;</span>
<a href="#l29.884"></a><span id="l29.884" class="difflineminus">-    }</span>
<a href="#l29.885"></a><span id="l29.885" class="difflineplus">+    this._enabled = true;</span>
<a href="#l29.886"></a><span id="l29.886"> </span>
<a href="#l29.887"></a><span id="l29.887">     this._log.info(&quot;Event-Driven Indexing is now &quot; + this._enabled);</span>
<a href="#l29.888"></a><span id="l29.888">   },</span>
<a href="#l29.889"></a><span id="l29.889" class="difflineminus">-</span>
<a href="#l29.890"></a><span id="l29.890" class="difflineminus">-  /** Track whether indexing is desired (we have jobs to prosecute). */</span>
<a href="#l29.891"></a><span id="l29.891" class="difflineminus">-  _indexingDesired: false,</span>
<a href="#l29.892"></a><span id="l29.892" class="difflineminus">-  /**</span>
<a href="#l29.893"></a><span id="l29.893" class="difflineminus">-   * Track whether we have an actively pending callback or timer event.  We do</span>
<a href="#l29.894"></a><span id="l29.894" class="difflineminus">-   *  this so we don't experience a transient suppression and accidentally</span>
<a href="#l29.895"></a><span id="l29.895" class="difflineminus">-   *  get multiple event-chains driving indexing at the same time (which the</span>
<a href="#l29.896"></a><span id="l29.896" class="difflineminus">-   *  code will not handle correctly).</span>
<a href="#l29.897"></a><span id="l29.897" class="difflineminus">-   */</span>
<a href="#l29.898"></a><span id="l29.898" class="difflineminus">-  _indexingActive: false,</span>
<a href="#l29.899"></a><span id="l29.899" class="difflineminus">-  /**</span>
<a href="#l29.900"></a><span id="l29.900" class="difflineminus">-   * Indicates whether indexing is currently ongoing.  This may return false</span>
<a href="#l29.901"></a><span id="l29.901" class="difflineminus">-   *  while indexing activities are still active, but they will quiesce shortly.</span>
<a href="#l29.902"></a><span id="l29.902" class="difflineminus">-   */</span>
<a href="#l29.903"></a><span id="l29.903" class="difflineminus">-  get indexing() {</span>
<a href="#l29.904"></a><span id="l29.904" class="difflineminus">-    return this._indexingDesired &amp;&amp; !this._suppressIndexing;</span>
<a href="#l29.905"></a><span id="l29.905" class="difflineminus">-  },</span>
<a href="#l29.906"></a><span id="l29.906" class="difflineminus">-  /** Indicates whether indexing is desired. */</span>
<a href="#l29.907"></a><span id="l29.907" class="difflineminus">-  get indexingDesired() {</span>
<a href="#l29.908"></a><span id="l29.908" class="difflineminus">-    return this._indexingDesired;</span>
<a href="#l29.909"></a><span id="l29.909" class="difflineminus">-  },</span>
<a href="#l29.910"></a><span id="l29.910" class="difflineminus">-  /**</span>
<a href="#l29.911"></a><span id="l29.911" class="difflineminus">-   * Set this to true to indicate there is indexing work to perform.  This does</span>
<a href="#l29.912"></a><span id="l29.912" class="difflineminus">-   *  not mean indexing will begin immediately (if it wasn't active), however.</span>
<a href="#l29.913"></a><span id="l29.913" class="difflineminus">-   *  If suppressIndexing has been set, we won't do anything until indexing is</span>
<a href="#l29.914"></a><span id="l29.914" class="difflineminus">-   *  no longer suppressed.</span>
<a href="#l29.915"></a><span id="l29.915" class="difflineminus">-   */</span>
<a href="#l29.916"></a><span id="l29.916" class="difflineminus">-  set indexing(aShouldIndex) {</span>
<a href="#l29.917"></a><span id="l29.917" class="difflineminus">-    if (!this._indexingDesired &amp;&amp; aShouldIndex) {</span>
<a href="#l29.918"></a><span id="l29.918" class="difflineminus">-      this._indexingDesired = true;</span>
<a href="#l29.919"></a><span id="l29.919" class="difflineminus">-      if (this.enabled &amp;&amp; !this._indexingActive &amp;&amp; !this._suppressIndexing) {</span>
<a href="#l29.920"></a><span id="l29.920" class="difflineminus">-        this._log.info(&quot;+++ Indexing Queue Processing Commencing&quot;);</span>
<a href="#l29.921"></a><span id="l29.921" class="difflineminus">-        this._indexingActive = true;</span>
<a href="#l29.922"></a><span id="l29.922" class="difflineminus">-        this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l29.923"></a><span id="l29.923" class="difflineminus">-                                     this._INDEX_KICKOFF_DELAY,</span>
<a href="#l29.924"></a><span id="l29.924" class="difflineminus">-                                     Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l29.925"></a><span id="l29.925" class="difflineminus">-      }</span>
<a href="#l29.926"></a><span id="l29.926" class="difflineminus">-    }</span>
<a href="#l29.927"></a><span id="l29.927" class="difflineminus">-  },</span>
<a href="#l29.928"></a><span id="l29.928" class="difflineplus">+  disable: function msg_indexer_disable() {</span>
<a href="#l29.929"></a><span id="l29.929" class="difflineplus">+    // remove FolderLoaded notification listener</span>
<a href="#l29.930"></a><span id="l29.930" class="difflineplus">+    let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l29.931"></a><span id="l29.931" class="difflineplus">+      getService(Ci.nsIMsgMailSession);</span>
<a href="#l29.932"></a><span id="l29.932" class="difflineplus">+    mailSession.RemoveFolderListener(this._folderListener);</span>
<a href="#l29.933"></a><span id="l29.933"> </span>
<a href="#l29.934"></a><span id="l29.934" class="difflineminus">-  _suppressIndexing: false,</span>
<a href="#l29.935"></a><span id="l29.935" class="difflineminus">-  /**</span>
<a href="#l29.936"></a><span id="l29.936" class="difflineminus">-   * Set whether or not indexing should be suppressed.  This is to allow us to</span>
<a href="#l29.937"></a><span id="l29.937" class="difflineminus">-   *  avoid running down a laptop's battery when it is not on AC.  Only code</span>
<a href="#l29.938"></a><span id="l29.938" class="difflineminus">-   *  in charge of regulating that tracking should be setting this variable; if</span>
<a href="#l29.939"></a><span id="l29.939" class="difflineminus">-   *  other factors want to contribute to such a decision, this logic needs to</span>
<a href="#l29.940"></a><span id="l29.940" class="difflineminus">-   *  be changed to track that, since last-write currently wins.</span>
<a href="#l29.941"></a><span id="l29.941" class="difflineminus">-   */</span>
<a href="#l29.942"></a><span id="l29.942" class="difflineminus">-  set suppressIndexing(aShouldSuppress) {</span>
<a href="#l29.943"></a><span id="l29.943" class="difflineminus">-    this._suppressIndexing = aShouldSuppress;</span>
<a href="#l29.944"></a><span id="l29.944" class="difflineminus">-</span>
<a href="#l29.945"></a><span id="l29.945" class="difflineminus">-    // re-start processing if we are no longer suppressing, there is work yet</span>
<a href="#l29.946"></a><span id="l29.946" class="difflineminus">-    //  to do, and the indexing process had actually stopped.</span>
<a href="#l29.947"></a><span id="l29.947" class="difflineminus">-    if (!this._suppressIndexing &amp;&amp; this._indexingDesired &amp;&amp;</span>
<a href="#l29.948"></a><span id="l29.948" class="difflineminus">-        !this._indexingActive) {</span>
<a href="#l29.949"></a><span id="l29.949" class="difflineminus">-        this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l29.950"></a><span id="l29.950" class="difflineminus">-        this._indexingActive = true;</span>
<a href="#l29.951"></a><span id="l29.951" class="difflineminus">-        this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l29.952"></a><span id="l29.952" class="difflineminus">-                                     this._INDEX_KICKOFF_DELAY,</span>
<a href="#l29.953"></a><span id="l29.953" class="difflineminus">-                                     Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l29.954"></a><span id="l29.954" class="difflineminus">-    }</span>
<a href="#l29.955"></a><span id="l29.955" class="difflineminus">-  },</span>
<a href="#l29.956"></a><span id="l29.956" class="difflineplus">+    let notificationService =</span>
<a href="#l29.957"></a><span id="l29.957" class="difflineplus">+      Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l29.958"></a><span id="l29.958" class="difflineplus">+      getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l29.959"></a><span id="l29.959" class="difflineplus">+    notificationService.removeListener(this._msgFolderListener);</span>
<a href="#l29.960"></a><span id="l29.960"> </span>
<a href="#l29.961"></a><span id="l29.961" class="difflineminus">-  /**</span>
<a href="#l29.962"></a><span id="l29.962" class="difflineminus">-   * Our timer-driven callback to schedule our first initial indexing sweep.</span>
<a href="#l29.963"></a><span id="l29.963" class="difflineminus">-   *  Because it is invoked by an nsITimer it operates without the benefit of</span>
<a href="#l29.964"></a><span id="l29.964" class="difflineminus">-   *  a 'this' context and must use GlodaIndexer instead of this.</span>
<a href="#l29.965"></a><span id="l29.965" class="difflineminus">-   * Since an initial sweep could have been performed before we get invoked,</span>
<a href="#l29.966"></a><span id="l29.966" class="difflineminus">-   *  we need to check whether an initial sweep is still desired before trying</span>
<a href="#l29.967"></a><span id="l29.967" class="difflineminus">-   *  to schedule one.  We don't need to worry about whether one is active</span>
<a href="#l29.968"></a><span id="l29.968" class="difflineminus">-   *  because the indexingSweepNeeded takes care of that.</span>
<a href="#l29.969"></a><span id="l29.969" class="difflineminus">-   */</span>
<a href="#l29.970"></a><span id="l29.970" class="difflineminus">-  _scheduleInitialSweep: function gloda_index_scheduleInitialSweep() {</span>
<a href="#l29.971"></a><span id="l29.971" class="difflineminus">-    if (!GlodaIndexer._initialSweepPerformed)</span>
<a href="#l29.972"></a><span id="l29.972" class="difflineminus">-      GlodaIndexer.indexingSweepNeeded = true;</span>
<a href="#l29.973"></a><span id="l29.973" class="difflineminus">-  },</span>
<a href="#l29.974"></a><span id="l29.974" class="difflineplus">+    this._indexerLeaveFolder(); // nop if we aren't &quot;in&quot; a folder</span>
<a href="#l29.975"></a><span id="l29.975"> </span>
<a href="#l29.976"></a><span id="l29.976" class="difflineminus">-  _initialSweepPerformed: false,</span>
<a href="#l29.977"></a><span id="l29.977" class="difflineminus">-  _indexingSweepActive: false,</span>
<a href="#l29.978"></a><span id="l29.978" class="difflineminus">-  /**</span>
<a href="#l29.979"></a><span id="l29.979" class="difflineminus">-   * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l29.980"></a><span id="l29.980" class="difflineminus">-   *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l29.981"></a><span id="l29.981" class="difflineminus">-   *  that we either can't process as an event or that we normally handle</span>
<a href="#l29.982"></a><span id="l29.982" class="difflineminus">-   *  during the sweep pass anyways.</span>
<a href="#l29.983"></a><span id="l29.983" class="difflineminus">-   */</span>
<a href="#l29.984"></a><span id="l29.984" class="difflineminus">-  set indexingSweepNeeded(aNeeded) {</span>
<a href="#l29.985"></a><span id="l29.985" class="difflineminus">-    if (!this._indexingSweepActive &amp;&amp; aNeeded) {</span>
<a href="#l29.986"></a><span id="l29.986" class="difflineminus">-      let job = new IndexingJob(&quot;sweep&quot;, 0, null);</span>
<a href="#l29.987"></a><span id="l29.987" class="difflineminus">-      job.mappedFolders = false;</span>
<a href="#l29.988"></a><span id="l29.988" class="difflineminus">-      this._indexQueue.push(job);</span>
<a href="#l29.989"></a><span id="l29.989" class="difflineminus">-      this._indexingJobGoal++;</span>
<a href="#l29.990"></a><span id="l29.990" class="difflineminus">-      this._indexingSweepActive = true;</span>
<a href="#l29.991"></a><span id="l29.991" class="difflineminus">-      this.indexing = true;</span>
<a href="#l29.992"></a><span id="l29.992" class="difflineminus">-    }</span>
<a href="#l29.993"></a><span id="l29.993" class="difflineplus">+    this._enabled = false;</span>
<a href="#l29.994"></a><span id="l29.994" class="difflineplus">+</span>
<a href="#l29.995"></a><span id="l29.995" class="difflineplus">+    this._log.info(&quot;Event-Driven Indexing is now &quot; + this._enabled);</span>
<a href="#l29.996"></a><span id="l29.996">   },</span>
<a href="#l29.997"></a><span id="l29.997"> </span>
<a href="#l29.998"></a><span id="l29.998" class="difflineminus">-</span>
<a href="#l29.999"></a><span id="l29.999">   /**</span>
<a href="#l29.1000"></a><span id="l29.1000">    * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l29.1001"></a><span id="l29.1001">    *  are gloda message rows flagged for deletion.  If this value is a boolean,</span>
<a href="#l29.1002"></a><span id="l29.1002">    *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l29.1003"></a><span id="l29.1003">    *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l29.1004"></a><span id="l29.1004">    *  the database.</span>
<a href="#l29.1005"></a><span id="l29.1005">    */</span>
<a href="#l29.1006"></a><span id="l29.1006">   pendingDeletions: null,</span>
<a href="#l29.1007"></a><span id="l29.1007" class="difflineat">@@ -778,188 +422,92 @@ var GlodaIndexer = {</span>
<a href="#l29.1008"></a><span id="l29.1008">    *  messages in an event-driven fashion for a finite number of messages, but</span>
<a href="#l29.1009"></a><span id="l29.1009">    *  because we can quit without completing processing of the queue, we need to</span>
<a href="#l29.1010"></a><span id="l29.1010">    *  mark the folder dirty, just-in-case.)  (We could do some extra leg-work</span>
<a href="#l29.1011"></a><span id="l29.1011">    *  and do a better job of marking the folder clean again.)</span>
<a href="#l29.1012"></a><span id="l29.1012">    */</span>
<a href="#l29.1013"></a><span id="l29.1013">   kMessageDirty: 1,</span>
<a href="#l29.1014"></a><span id="l29.1014">   /**</span>
<a href="#l29.1015"></a><span id="l29.1015">    * We have not indexed the folder at all, but messages in the folder think</span>
<a href="#l29.1016"></a><span id="l29.1016" class="difflineminus">-   *  they are indexed.  Once we mark all the messages in the folder as being</span>
<a href="#l29.1017"></a><span id="l29.1017" class="difflineminus">-   *  dirty so that they don't confuse us, we downgrade the folder's dirty</span>
<a href="#l29.1018"></a><span id="l29.1018" class="difflineminus">-   *  status to just kMessageDirty.</span>
<a href="#l29.1019"></a><span id="l29.1019" class="difflineplus">+   *  they are indexed.  We downgrade the folder to just kMessageDirty after</span>
<a href="#l29.1020"></a><span id="l29.1020" class="difflineplus">+   *  marking all the messages in the folder as dirty.  We do this so that if we</span>
<a href="#l29.1021"></a><span id="l29.1021" class="difflineplus">+   *  have to stop indexing the folder we can still build on our progress next</span>
<a href="#l29.1022"></a><span id="l29.1022" class="difflineplus">+   *  time we enter the folder.</span>
<a href="#l29.1023"></a><span id="l29.1023" class="difflineplus">+   * We mark all folders filthy when (re-)creating the database because there</span>
<a href="#l29.1024"></a><span id="l29.1024" class="difflineplus">+   *  may be previous state left over from an earlier database.</span>
<a href="#l29.1025"></a><span id="l29.1025">    */</span>
<a href="#l29.1026"></a><span id="l29.1026">   kMessageFilthy: 2,</span>
<a href="#l29.1027"></a><span id="l29.1027" class="difflineminus">-</span>
<a href="#l29.1028"></a><span id="l29.1028" class="difflineminus">-  kWorkSync: Gloda.kWorkSync,</span>
<a href="#l29.1029"></a><span id="l29.1029" class="difflineminus">-  kWorkAsync: Gloda.kWorkAsync,</span>
<a href="#l29.1030"></a><span id="l29.1030" class="difflineminus">-  kWorkDone: Gloda.kWorkDone,</span>
<a href="#l29.1031"></a><span id="l29.1031" class="difflineminus">-  kWorkPause: Gloda.kWorkPause,</span>
<a href="#l29.1032"></a><span id="l29.1032" class="difflineminus">-  kWorkDoneWithResult: Gloda.kWorkDoneWithResult,</span>
<a href="#l29.1033"></a><span id="l29.1033" class="difflineminus">-</span>
<a href="#l29.1034"></a><span id="l29.1034">   /**</span>
<a href="#l29.1035"></a><span id="l29.1035" class="difflineminus">-   * Our current job number, out of _indexingJobGoal.  Although our jobs comes</span>
<a href="#l29.1036"></a><span id="l29.1036" class="difflineminus">-   *  from _indexQueue, this is not an offset into that list because we forget</span>
<a href="#l29.1037"></a><span id="l29.1037" class="difflineminus">-   *  jobs once we complete them.  As such, this value is strictly for progress</span>
<a href="#l29.1038"></a><span id="l29.1038" class="difflineminus">-   *  tracking.</span>
<a href="#l29.1039"></a><span id="l29.1039" class="difflineplus">+   * The (local) folder has been compacted and all of its message keys are</span>
<a href="#l29.1040"></a><span id="l29.1040" class="difflineplus">+   *  potentially incorrect.  This is not a possible state for IMAP folders</span>
<a href="#l29.1041"></a><span id="l29.1041" class="difflineplus">+   *  because their message keys are based on UIDs rather than offsets into</span>
<a href="#l29.1042"></a><span id="l29.1042" class="difflineplus">+   *  the mbox file.</span>
<a href="#l29.1043"></a><span id="l29.1043" class="difflineplus">+   * This is dealt with via a specialized/optimized processing pass and does not</span>
<a href="#l29.1044"></a><span id="l29.1044" class="difflineplus">+   *  attempt to touch every message and mark its dirty state.  This is because</span>
<a href="#l29.1045"></a><span id="l29.1045" class="difflineplus">+   *  we are able to (comparatively) efficiently process the folder, so it is</span>
<a href="#l29.1046"></a><span id="l29.1046" class="difflineplus">+   *  sufficiently likely we will run to completion.  Additionally, immediately</span>
<a href="#l29.1047"></a><span id="l29.1047" class="difflineplus">+   *  touching a property on every message in a folder and then touching them</span>
<a href="#l29.1048"></a><span id="l29.1048" class="difflineplus">+   *  again once processed in some ways defeats the benefits of compaction.</span>
<a href="#l29.1049"></a><span id="l29.1049">    */</span>
<a href="#l29.1050"></a><span id="l29.1050" class="difflineminus">-  _indexingJobCount: 0,</span>
<a href="#l29.1051"></a><span id="l29.1051" class="difflineminus">-  /**</span>
<a href="#l29.1052"></a><span id="l29.1052" class="difflineminus">-   * Total number of jobs to process in this current indexing session; may</span>
<a href="#l29.1053"></a><span id="l29.1053" class="difflineminus">-   *  increase as new jobs are added to the _indexQueue.  This value won't</span>
<a href="#l29.1054"></a><span id="l29.1054" class="difflineminus">-   *  decrease until the indexing session is completed (and we become idle),</span>
<a href="#l29.1055"></a><span id="l29.1055" class="difflineminus">-   *  and then it will go to zero.</span>
<a href="#l29.1056"></a><span id="l29.1056" class="difflineminus">-   */</span>
<a href="#l29.1057"></a><span id="l29.1057" class="difflineminus">-  _indexingJobGoal: 0,</span>
<a href="#l29.1058"></a><span id="l29.1058" class="difflineminus">-</span>
<a href="#l29.1059"></a><span id="l29.1059" class="difflineminus">-  /**</span>
<a href="#l29.1060"></a><span id="l29.1060" class="difflineminus">-   * A list of IndexingJob instances to process.</span>
<a href="#l29.1061"></a><span id="l29.1061" class="difflineminus">-   * - ['account', account object]</span>
<a href="#l29.1062"></a><span id="l29.1062" class="difflineminus">-   * - ['folder', folder URI]</span>
<a href="#l29.1063"></a><span id="l29.1063" class="difflineminus">-   * - ['message', delta type, message header, folder ID, message key,</span>
<a href="#l29.1064"></a><span id="l29.1064" class="difflineminus">-   *      message ID]</span>
<a href="#l29.1065"></a><span id="l29.1065" class="difflineminus">-   *   (we use folder ID instead of URI so that renames can't trick us)</span>
<a href="#l29.1066"></a><span id="l29.1066" class="difflineminus">-   */</span>
<a href="#l29.1067"></a><span id="l29.1067" class="difflineminus">-  _indexQueue: [],</span>
<a href="#l29.1068"></a><span id="l29.1068" class="difflineminus">-</span>
<a href="#l29.1069"></a><span id="l29.1069" class="difflineminus">-  /**</span>
<a href="#l29.1070"></a><span id="l29.1070" class="difflineminus">-   * The current indexing job.</span>
<a href="#l29.1071"></a><span id="l29.1071" class="difflineminus">-   */</span>
<a href="#l29.1072"></a><span id="l29.1072" class="difflineminus">-  _curIndexingJob: null,</span>
<a href="#l29.1073"></a><span id="l29.1073" class="difflineplus">+  kMessageCompactedDirtyBit: 4,</span>
<a href="#l29.1074"></a><span id="l29.1074"> </span>
<a href="#l29.1075"></a><span id="l29.1075">   /**</span>
<a href="#l29.1076"></a><span id="l29.1076">    * A message addition job yet to be (completely) processed.  Since message</span>
<a href="#l29.1077"></a><span id="l29.1077">    *  addition events come to us one-by-one, in order to aggregate them into a</span>
<a href="#l29.1078"></a><span id="l29.1078">    *  job, we need something like this.  It's up to the indexing loop to</span>
<a href="#l29.1079"></a><span id="l29.1079">    *  decide when to null this out; it can either do it when it first starts</span>
<a href="#l29.1080"></a><span id="l29.1080">    *  processing it, or when it has processed the last thing.  It's really a</span>
<a href="#l29.1081"></a><span id="l29.1081">    *  question of whether we want retrograde motion in the folder progress bar</span>
<a href="#l29.1082"></a><span id="l29.1082">    *  or the message progress bar.</span>
<a href="#l29.1083"></a><span id="l29.1083">    */</span>
<a href="#l29.1084"></a><span id="l29.1084">   _pendingAddJob: null,</span>
<a href="#l29.1085"></a><span id="l29.1085"> </span>
<a href="#l29.1086"></a><span id="l29.1086">   /**</span>
<a href="#l29.1087"></a><span id="l29.1087" class="difflineminus">-   * The number of seconds before we declare the user idle and commit if</span>
<a href="#l29.1088"></a><span id="l29.1088" class="difflineminus">-   *  needed.</span>
<a href="#l29.1089"></a><span id="l29.1089" class="difflineminus">-   */</span>
<a href="#l29.1090"></a><span id="l29.1090" class="difflineminus">-  _indexIdleThresholdSecs: 3,</span>
<a href="#l29.1091"></a><span id="l29.1091" class="difflineminus">-</span>
<a href="#l29.1092"></a><span id="l29.1092" class="difflineminus">-  /**</span>
<a href="#l29.1093"></a><span id="l29.1093">    * The number of messages that we should queue for processing before letting</span>
<a href="#l29.1094"></a><span id="l29.1094">    *  them fall on the floor and relying on our folder-walking logic to ensure</span>
<a href="#l29.1095"></a><span id="l29.1095">    *  that the messages are indexed.</span>
<a href="#l29.1096"></a><span id="l29.1096">    * The reason we allow for queueing messages in an event-driven fashion is</span>
<a href="#l29.1097"></a><span id="l29.1097">    *  that once we have reached a steady-state, it is preferable to be able to</span>
<a href="#l29.1098"></a><span id="l29.1098">    *  deal with new messages and modified meta-data in a prompt fasion rather</span>
<a href="#l29.1099"></a><span id="l29.1099">    *  than having to (potentially) walk every folder in the system just to find</span>
<a href="#l29.1100"></a><span id="l29.1100">    *  the message that the user changed the tag on.</span>
<a href="#l29.1101"></a><span id="l29.1101">    */</span>
<a href="#l29.1102"></a><span id="l29.1102">   _indexMaxEventQueueMessages: 20,</span>
<a href="#l29.1103"></a><span id="l29.1103"> </span>
<a href="#l29.1104"></a><span id="l29.1104" class="difflineminus">-  _indexListeners: [],</span>
<a href="#l29.1105"></a><span id="l29.1105">   /**</span>
<a href="#l29.1106"></a><span id="l29.1106" class="difflineminus">-   * Add an indexing progress listener.  The listener will be notified of at</span>
<a href="#l29.1107"></a><span id="l29.1107" class="difflineminus">-   *  least all major status changes (idle -&gt; indexing, indexing -&gt; idle), plus</span>
<a href="#l29.1108"></a><span id="l29.1108" class="difflineminus">-   *  arbitrary progress updates during the indexing process.</span>
<a href="#l29.1109"></a><span id="l29.1109" class="difflineminus">-   * If indexing is not active when the listener is added, a synthetic idle</span>
<a href="#l29.1110"></a><span id="l29.1110" class="difflineminus">-   *  notification will be generated.</span>
<a href="#l29.1111"></a><span id="l29.1111" class="difflineminus">-   *</span>
<a href="#l29.1112"></a><span id="l29.1112" class="difflineminus">-   * @param aListener A listener function, taking arguments: status (Gloda.</span>
<a href="#l29.1113"></a><span id="l29.1113" class="difflineminus">-   *     kIndexer*), the folder name if a folder is involved (string or null),</span>
<a href="#l29.1114"></a><span id="l29.1114" class="difflineminus">-   *     current zero-based job number (int), total number of jobs (int),</span>
<a href="#l29.1115"></a><span id="l29.1115" class="difflineminus">-   *     current item number being indexed in this job (int), total number</span>
<a href="#l29.1116"></a><span id="l29.1116" class="difflineminus">-   *     of items in this job to be indexed (int).</span>
<a href="#l29.1117"></a><span id="l29.1117" class="difflineminus">-   *</span>
<a href="#l29.1118"></a><span id="l29.1118" class="difflineminus">-   * @TODO should probably allow for a 'this' value to be provided</span>
<a href="#l29.1119"></a><span id="l29.1119" class="difflineminus">-   * @TODO generalize to not be folder/message specific.  use nouns!</span>
<a href="#l29.1120"></a><span id="l29.1120" class="difflineminus">-   */</span>
<a href="#l29.1121"></a><span id="l29.1121" class="difflineminus">-  addListener: function gloda_index_addListener(aListener) {</span>
<a href="#l29.1122"></a><span id="l29.1122" class="difflineminus">-    // should we weakify?</span>
<a href="#l29.1123"></a><span id="l29.1123" class="difflineminus">-    if (this._indexListeners.indexOf(aListener) == -1)</span>
<a href="#l29.1124"></a><span id="l29.1124" class="difflineminus">-      this._indexListeners.push(aListener);</span>
<a href="#l29.1125"></a><span id="l29.1125" class="difflineminus">-    // if we aren't indexing, give them an idle indicator, otherwise they can</span>
<a href="#l29.1126"></a><span id="l29.1126" class="difflineminus">-    //  just be happy when we hit the next actual status point.</span>
<a href="#l29.1127"></a><span id="l29.1127" class="difflineminus">-    if (!this.indexing)</span>
<a href="#l29.1128"></a><span id="l29.1128" class="difflineminus">-      aListener(Gloda.kIndexerIdle, null, 0, 1, 0, 1);</span>
<a href="#l29.1129"></a><span id="l29.1129" class="difflineminus">-    return aListener;</span>
<a href="#l29.1130"></a><span id="l29.1130" class="difflineminus">-  },</span>
<a href="#l29.1131"></a><span id="l29.1131" class="difflineminus">-  /**</span>
<a href="#l29.1132"></a><span id="l29.1132" class="difflineminus">-   * Remove the given listener so that it no longer receives indexing progress</span>
<a href="#l29.1133"></a><span id="l29.1133" class="difflineminus">-   *  updates.</span>
<a href="#l29.1134"></a><span id="l29.1134" class="difflineminus">-   */</span>
<a href="#l29.1135"></a><span id="l29.1135" class="difflineminus">-  removeListener: function gloda_index_removeListener(aListener) {</span>
<a href="#l29.1136"></a><span id="l29.1136" class="difflineminus">-    let index = this._indexListeners.indexOf(aListener);</span>
<a href="#l29.1137"></a><span id="l29.1137" class="difflineminus">-    if (index != -1)</span>
<a href="#l29.1138"></a><span id="l29.1138" class="difflineminus">-      this._indexListeners.splice(index, 1);</span>
<a href="#l29.1139"></a><span id="l29.1139" class="difflineminus">-  },</span>
<a href="#l29.1140"></a><span id="l29.1140" class="difflineminus">-  /**</span>
<a href="#l29.1141"></a><span id="l29.1141" class="difflineminus">-   * Helper method to tell listeners what we're up to.  For code simplicity,</span>
<a href="#l29.1142"></a><span id="l29.1142" class="difflineminus">-   *  the caller is just deciding when to send this update (preferably at</span>
<a href="#l29.1143"></a><span id="l29.1143" class="difflineminus">-   *  reasonable intervals), and doesn't need to provide any indication of</span>
<a href="#l29.1144"></a><span id="l29.1144" class="difflineminus">-   *  state... we figure that out ourselves.</span>
<a href="#l29.1145"></a><span id="l29.1145" class="difflineplus">+   * Unit testing hook to get us to emit additional logging that verges on</span>
<a href="#l29.1146"></a><span id="l29.1146" class="difflineplus">+   *  inane for general usage but is helpful in unit test output to get a lay</span>
<a href="#l29.1147"></a><span id="l29.1147" class="difflineplus">+   *  of the land and for paranoia reasons.</span>
<a href="#l29.1148"></a><span id="l29.1148">    */</span>
<a href="#l29.1149"></a><span id="l29.1149" class="difflineminus">-  _notifyListeners: function gloda_index_notifyListeners() {</span>
<a href="#l29.1150"></a><span id="l29.1150" class="difflineminus">-    let status, prettyName, jobIndex, jobTotal, jobItemIndex, jobItemGoal;</span>
<a href="#l29.1151"></a><span id="l29.1151" class="difflineminus">-</span>
<a href="#l29.1152"></a><span id="l29.1152" class="difflineminus">-    if (this.indexing &amp;&amp; this._curIndexingJob) {</span>
<a href="#l29.1153"></a><span id="l29.1153" class="difflineminus">-      let job = this._curIndexingJob;</span>
<a href="#l29.1154"></a><span id="l29.1154" class="difflineminus">-      if (job.deltaType &gt; 0)</span>
<a href="#l29.1155"></a><span id="l29.1155" class="difflineminus">-        status = Gloda.kIndexerIndexing;</span>
<a href="#l29.1156"></a><span id="l29.1156" class="difflineminus">-      else if (job.deltaType == 0)</span>
<a href="#l29.1157"></a><span id="l29.1157" class="difflineminus">-        status = Gloda.kIndexerMoving;</span>
<a href="#l29.1158"></a><span id="l29.1158" class="difflineminus">-      else</span>
<a href="#l29.1159"></a><span id="l29.1159" class="difflineminus">-        status = Gloda.kIndexerRemoving;</span>
<a href="#l29.1160"></a><span id="l29.1160" class="difflineminus">-</span>
<a href="#l29.1161"></a><span id="l29.1161" class="difflineminus">-      prettyName = (this._indexingFolder !== null) ?</span>
<a href="#l29.1162"></a><span id="l29.1162" class="difflineminus">-                   this._indexingFolder.prettiestName : null;</span>
<a href="#l29.1163"></a><span id="l29.1163" class="difflineminus">-</span>
<a href="#l29.1164"></a><span id="l29.1164" class="difflineminus">-      jobIndex = this._indexingJobCount-1;</span>
<a href="#l29.1165"></a><span id="l29.1165" class="difflineminus">-      jobTotal = this._indexingJobGoal;</span>
<a href="#l29.1166"></a><span id="l29.1166" class="difflineminus">-      jobItemIndex = job.offset;</span>
<a href="#l29.1167"></a><span id="l29.1167" class="difflineminus">-      jobItemGoal  = job.goal;</span>
<a href="#l29.1168"></a><span id="l29.1168" class="difflineminus">-    }</span>
<a href="#l29.1169"></a><span id="l29.1169" class="difflineminus">-    else {</span>
<a href="#l29.1170"></a><span id="l29.1170" class="difflineminus">-      status = Gloda.kIndexerIdle;</span>
<a href="#l29.1171"></a><span id="l29.1171" class="difflineminus">-      prettyName = null;</span>
<a href="#l29.1172"></a><span id="l29.1172" class="difflineminus">-      jobIndex = 0;</span>
<a href="#l29.1173"></a><span id="l29.1173" class="difflineminus">-      jobTotal = 1;</span>
<a href="#l29.1174"></a><span id="l29.1174" class="difflineminus">-      jobItemIndex = 0;</span>
<a href="#l29.1175"></a><span id="l29.1175" class="difflineminus">-      jobItemGoal = 1;</span>
<a href="#l29.1176"></a><span id="l29.1176" class="difflineminus">-    }</span>
<a href="#l29.1177"></a><span id="l29.1177" class="difflineminus">-</span>
<a href="#l29.1178"></a><span id="l29.1178" class="difflineminus">-    for (let iListener = this._indexListeners.length-1; iListener &gt;= 0;</span>
<a href="#l29.1179"></a><span id="l29.1179" class="difflineminus">-         iListener--) {</span>
<a href="#l29.1180"></a><span id="l29.1180" class="difflineminus">-      let listener = this._indexListeners[iListener];</span>
<a href="#l29.1181"></a><span id="l29.1181" class="difflineminus">-      try {</span>
<a href="#l29.1182"></a><span id="l29.1182" class="difflineminus">-        listener(status, prettyName, jobIndex, jobTotal, jobItemIndex,</span>
<a href="#l29.1183"></a><span id="l29.1183" class="difflineminus">-                 jobItemGoal);</span>
<a href="#l29.1184"></a><span id="l29.1184" class="difflineminus">-      }</span>
<a href="#l29.1185"></a><span id="l29.1185" class="difflineminus">-      catch(ex) {</span>
<a href="#l29.1186"></a><span id="l29.1186" class="difflineminus">-        this._log.error(ex);</span>
<a href="#l29.1187"></a><span id="l29.1187" class="difflineminus">-      }</span>
<a href="#l29.1188"></a><span id="l29.1188" class="difflineminus">-    }</span>
<a href="#l29.1189"></a><span id="l29.1189" class="difflineminus">-  },</span>
<a href="#l29.1190"></a><span id="l29.1190" class="difflineplus">+  _unitTestSuperVerbose: false,</span>
<a href="#l29.1191"></a><span id="l29.1191"> </span>
<a href="#l29.1192"></a><span id="l29.1192">   /** The GlodaFolder corresponding to the folder we are indexing. */</span>
<a href="#l29.1193"></a><span id="l29.1193">   _indexingGlodaFolder: null,</span>
<a href="#l29.1194"></a><span id="l29.1194">   /** The nsIMsgFolder we are currently indexing. */</span>
<a href="#l29.1195"></a><span id="l29.1195">   _indexingFolder: null,</span>
<a href="#l29.1196"></a><span id="l29.1196">   /** The nsIMsgDatabase we are currently indexing. */</span>
<a href="#l29.1197"></a><span id="l29.1197">   _indexingDatabase: null,</span>
<a href="#l29.1198"></a><span id="l29.1198">   /**</span>
<a href="#l29.1199"></a><span id="l29.1199">    * The iterator we are using to iterate over the headers in</span>
<a href="#l29.1200"></a><span id="l29.1200">    *  this._indexingDatabase.</span>
<a href="#l29.1201"></a><span id="l29.1201">    */</span>
<a href="#l29.1202"></a><span id="l29.1202">   _indexingIterator: null,</span>
<a href="#l29.1203"></a><span id="l29.1203"> </span>
<a href="#l29.1204"></a><span id="l29.1204">   /** folder whose entry we are pending on */</span>
<a href="#l29.1205"></a><span id="l29.1205">   _pendingFolderEntry: null,</span>
<a href="#l29.1206"></a><span id="l29.1206"> </span>
<a href="#l29.1207"></a><span id="l29.1207" class="difflineplus">+  // copy-down the work constants from Gloda</span>
<a href="#l29.1208"></a><span id="l29.1208" class="difflineplus">+  kWorkSync: Gloda.kWorkSync,</span>
<a href="#l29.1209"></a><span id="l29.1209" class="difflineplus">+  kWorkAsync: Gloda.kWorkAsync,</span>
<a href="#l29.1210"></a><span id="l29.1210" class="difflineplus">+  kWorkDone: Gloda.kWorkDone,</span>
<a href="#l29.1211"></a><span id="l29.1211" class="difflineplus">+  kWorkPause: Gloda.kWorkPause,</span>
<a href="#l29.1212"></a><span id="l29.1212" class="difflineplus">+  kWorkDoneWithResult: Gloda.kWorkDoneWithResult,</span>
<a href="#l29.1213"></a><span id="l29.1213" class="difflineplus">+</span>
<a href="#l29.1214"></a><span id="l29.1214">   /**</span>
<a href="#l29.1215"></a><span id="l29.1215" class="difflineminus">-   * Common logic that we want to deal with the given folder ID.  Besides</span>
<a href="#l29.1216"></a><span id="l29.1216" class="difflineplus">+   * Async common logic that we want to deal with the given folder ID.  Besides</span>
<a href="#l29.1217"></a><span id="l29.1217">    *  cutting down on duplicate code, this ensures that we are listening on</span>
<a href="#l29.1218"></a><span id="l29.1218">    *  the folder in case it tries to go away when we are using it.</span>
<a href="#l29.1219"></a><span id="l29.1219">    *</span>
<a href="#l29.1220"></a><span id="l29.1220">    * @return true when the folder was successfully entered, false when we need</span>
<a href="#l29.1221"></a><span id="l29.1221">    *     to pend on notification of updating of the folder (due to re-parsing</span>
<a href="#l29.1222"></a><span id="l29.1222">    *     or what have you).  In the event of an actual problem, an exception</span>
<a href="#l29.1223"></a><span id="l29.1223">    *     will escape.</span>
<a href="#l29.1224"></a><span id="l29.1224">    */</span>
<a href="#l29.1225"></a><span id="l29.1225" class="difflineat">@@ -975,17 +523,17 @@ var GlodaIndexer = {</span>
<a href="#l29.1226"></a><span id="l29.1226"> </span>
<a href="#l29.1227"></a><span id="l29.1227">     if (this._indexingFolder)</span>
<a href="#l29.1228"></a><span id="l29.1228">       this._log.debug(&quot;Entering folder: &quot; + this._indexingFolder.URI);</span>
<a href="#l29.1229"></a><span id="l29.1229"> </span>
<a href="#l29.1230"></a><span id="l29.1230">     try {</span>
<a href="#l29.1231"></a><span id="l29.1231">       // The msf may need to be created or otherwise updated for local folders.</span>
<a href="#l29.1232"></a><span id="l29.1232">       // This may require yielding until such time as the msf has been created.</span>
<a href="#l29.1233"></a><span id="l29.1233">       try {</span>
<a href="#l29.1234"></a><span id="l29.1234" class="difflineminus">-        if (this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l29.1235"></a><span id="l29.1235" class="difflineplus">+        if (this._indexingFolder instanceof nsIMsgLocalMailFolder) {</span>
<a href="#l29.1236"></a><span id="l29.1236">           this._indexingDatabase =</span>
<a href="#l29.1237"></a><span id="l29.1237">             this._indexingFolder.getDatabaseWithReparse(null,</span>
<a href="#l29.1238"></a><span id="l29.1238">                                                         null);</span>
<a href="#l29.1239"></a><span id="l29.1239">         }</span>
<a href="#l29.1240"></a><span id="l29.1240">         // we need do nothing special for IMAP, news, or other</span>
<a href="#l29.1241"></a><span id="l29.1241">       }</span>
<a href="#l29.1242"></a><span id="l29.1242">       // getDatabaseWithReparse can return either NS_ERROR_NOT_INITIALIZED or</span>
<a href="#l29.1243"></a><span id="l29.1243">       //  NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE if the net result is that it</span>
<a href="#l29.1244"></a><span id="l29.1244" class="difflineat">@@ -1043,39 +591,53 @@ var GlodaIndexer = {</span>
<a href="#l29.1245"></a><span id="l29.1245">     // the load is no longer pending; we certainly don't want more notifications</span>
<a href="#l29.1246"></a><span id="l29.1246">     this._pendingFolderEntry = null;</span>
<a href="#l29.1247"></a><span id="l29.1247">     // indexerEnterFolder returned kWorkAsync, which means we need to notify</span>
<a href="#l29.1248"></a><span id="l29.1248">     //  the callback driver to get things going again.</span>
<a href="#l29.1249"></a><span id="l29.1249">     this.callbackDriver();</span>
<a href="#l29.1250"></a><span id="l29.1250">   },</span>
<a href="#l29.1251"></a><span id="l29.1251"> </span>
<a href="#l29.1252"></a><span id="l29.1252">   /**</span>
<a href="#l29.1253"></a><span id="l29.1253" class="difflineminus">-   *  @param  aGetAll  should we get all messages</span>
<a href="#l29.1254"></a><span id="l29.1254" class="difflineminus">-   *                    (or only those we need to index)?</span>
<a href="#l29.1255"></a><span id="l29.1255" class="difflineplus">+   * Enumerate all messages in the folder.</span>
<a href="#l29.1256"></a><span id="l29.1256" class="difflineplus">+   */</span>
<a href="#l29.1257"></a><span id="l29.1257" class="difflineplus">+  kEnumAllMsgs: 0,</span>
<a href="#l29.1258"></a><span id="l29.1258" class="difflineplus">+  /**</span>
<a href="#l29.1259"></a><span id="l29.1259" class="difflineplus">+   * Enumerate messages that look like they need to be indexed.</span>
<a href="#l29.1260"></a><span id="l29.1260" class="difflineplus">+   */</span>
<a href="#l29.1261"></a><span id="l29.1261" class="difflineplus">+  kEnumMsgsToIndex: 1,</span>
<a href="#l29.1262"></a><span id="l29.1262" class="difflineplus">+  /**</span>
<a href="#l29.1263"></a><span id="l29.1263" class="difflineplus">+   * Enumerate messages that are already indexed.</span>
<a href="#l29.1264"></a><span id="l29.1264">    */</span>
<a href="#l29.1265"></a><span id="l29.1265" class="difflineminus">-  _indexerGetEnumerator: function gloda_indexer_indexerGetEnumerator(aGetAll) {</span>
<a href="#l29.1266"></a><span id="l29.1266" class="difflineminus">-    if (aGetAll) {</span>
<a href="#l29.1267"></a><span id="l29.1267" class="difflineminus">-      this._indexingEnumerator = this._indexingDatabase.EnumerateMessages();</span>
<a href="#l29.1268"></a><span id="l29.1268" class="difflineminus">-    }</span>
<a href="#l29.1269"></a><span id="l29.1269" class="difflineplus">+  kEnumIndexedMsgs: 2,</span>
<a href="#l29.1270"></a><span id="l29.1270"> </span>
<a href="#l29.1271"></a><span id="l29.1271" class="difflineminus">-    else {</span>
<a href="#l29.1272"></a><span id="l29.1272" class="difflineplus">+  /**</span>
<a href="#l29.1273"></a><span id="l29.1273" class="difflineplus">+   * Synchronous helper to get an enumerator for the current folder (as found</span>
<a href="#l29.1274"></a><span id="l29.1274" class="difflineplus">+   *  in |_indexingFolder|.</span>
<a href="#l29.1275"></a><span id="l29.1275" class="difflineplus">+   *</span>
<a href="#l29.1276"></a><span id="l29.1276" class="difflineplus">+   * @param aEnumKind One of |kEnumAllMsgs|, |kEnumMsgsToIndex|, or</span>
<a href="#l29.1277"></a><span id="l29.1277" class="difflineplus">+   *     |kEnumIndexedMsgs|.</span>
<a href="#l29.1278"></a><span id="l29.1278" class="difflineplus">+   */</span>
<a href="#l29.1279"></a><span id="l29.1279" class="difflineplus">+  _indexerGetEnumerator: function gloda_indexer_indexerGetEnumerator(</span>
<a href="#l29.1280"></a><span id="l29.1280" class="difflineplus">+      aEnumKind) {</span>
<a href="#l29.1281"></a><span id="l29.1281" class="difflineplus">+    if (aEnumKind == this.kEnumMsgsToIndex) {</span>
<a href="#l29.1282"></a><span id="l29.1282">       // We need to create search terms for messages to index. Messages should</span>
<a href="#l29.1283"></a><span id="l29.1283">       //  be indexed if they're indexable (local or offline and not expunged)</span>
<a href="#l29.1284"></a><span id="l29.1284">       //  and either haven't been indexed or are dirty.</span>
<a href="#l29.1285"></a><span id="l29.1285">       // The basic search expression is:</span>
<a href="#l29.1286"></a><span id="l29.1286" class="difflineminus">-      //  ((GLODA_MESSAGE_ID_PROPERTY Is 0) || (GLODA_DIRTY_PROPERTY Isnt 0))</span>
<a href="#l29.1287"></a><span id="l29.1287" class="difflineplus">+      //  ((GLODA_MESSAGE_ID_PROPERTY Is 0) || (GLODA_DIRTY_PROPERTY Isnt 0)) &amp;&amp;</span>
<a href="#l29.1288"></a><span id="l29.1288" class="difflineplus">+      //  (JUNK_SCORE_PROPERTY Isnt 100)</span>
<a href="#l29.1289"></a><span id="l29.1289">       // If the folder !isLocal we add the terms:</span>
<a href="#l29.1290"></a><span id="l29.1290">       //  - if the folder is offline -- &amp;&amp; (Status Is nsMsgMessageFlags.Offline)</span>
<a href="#l29.1291"></a><span id="l29.1291">       //  - &amp;&amp; (Status Isnt nsMsgMessageFlags.Expunged)</span>
<a href="#l29.1292"></a><span id="l29.1292"> </span>
<a href="#l29.1293"></a><span id="l29.1293">       let searchSession = Cc[&quot;@mozilla.org/messenger/searchSession;1&quot;]</span>
<a href="#l29.1294"></a><span id="l29.1294">                             .createInstance(Ci.nsIMsgSearchSession);</span>
<a href="#l29.1295"></a><span id="l29.1295">       let searchTerms = Cc[&quot;@mozilla.org/array;1&quot;]</span>
<a href="#l29.1296"></a><span id="l29.1296">                          .createInstance(Ci.nsIMutableArray);</span>
<a href="#l29.1297"></a><span id="l29.1297" class="difflineminus">-      let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l29.1298"></a><span id="l29.1298" class="difflineplus">+      let isLocal = this._indexingFolder instanceof nsIMsgLocalMailFolder;</span>
<a href="#l29.1299"></a><span id="l29.1299"> </span>
<a href="#l29.1300"></a><span id="l29.1300">       searchSession.addScopeTerm(Ci.nsMsgSearchScope.offlineMail,</span>
<a href="#l29.1301"></a><span id="l29.1301">                                  this._indexingFolder);</span>
<a href="#l29.1302"></a><span id="l29.1302">       let nsMsgSearchAttrib = Ci.nsMsgSearchAttrib;</span>
<a href="#l29.1303"></a><span id="l29.1303">       let nsMsgSearchOp = Ci.nsMsgSearchOp;</span>
<a href="#l29.1304"></a><span id="l29.1304"> </span>
<a href="#l29.1305"></a><span id="l29.1305">       // first term: (GLODA_MESSAGE_ID_PROPERTY Is 0</span>
<a href="#l29.1306"></a><span id="l29.1306">       let searchTerm = searchSession.createTerm();</span>
<a href="#l29.1307"></a><span id="l29.1307" class="difflineat">@@ -1098,49 +660,122 @@ var GlodaIndexer = {</span>
<a href="#l29.1308"></a><span id="l29.1308">       searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l29.1309"></a><span id="l29.1309">       value = searchTerm.value;</span>
<a href="#l29.1310"></a><span id="l29.1310">       value.attrib = searchTerm.attrib;</span>
<a href="#l29.1311"></a><span id="l29.1311">       value.status = 0;</span>
<a href="#l29.1312"></a><span id="l29.1312">       searchTerm.value = value;</span>
<a href="#l29.1313"></a><span id="l29.1313">       searchTerm.hdrProperty = GLODA_DIRTY_PROPERTY;</span>
<a href="#l29.1314"></a><span id="l29.1314">       searchTerms.appendElement(searchTerm, false);</span>
<a href="#l29.1315"></a><span id="l29.1315"> </span>
<a href="#l29.1316"></a><span id="l29.1316" class="difflineplus">+      // JUNK_SCORE_PROPERTY Isnt 100</span>
<a href="#l29.1317"></a><span id="l29.1317" class="difflineplus">+      // For symmetry with our event-driven stuff, we just directly deal with</span>
<a href="#l29.1318"></a><span id="l29.1318" class="difflineplus">+      //  the header property.</span>
<a href="#l29.1319"></a><span id="l29.1319" class="difflineplus">+      searchTerm = searchSession.createTerm();</span>
<a href="#l29.1320"></a><span id="l29.1320" class="difflineplus">+      searchTerm.booleanAnd = true;</span>
<a href="#l29.1321"></a><span id="l29.1321" class="difflineplus">+      searchTerm.attrib = nsMsgSearchAttrib.HdrProperty;</span>
<a href="#l29.1322"></a><span id="l29.1322" class="difflineplus">+      searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l29.1323"></a><span id="l29.1323" class="difflineplus">+      value = searchTerm.value;</span>
<a href="#l29.1324"></a><span id="l29.1324" class="difflineplus">+      value.attrib = searchTerm.attrib;</span>
<a href="#l29.1325"></a><span id="l29.1325" class="difflineplus">+      value.str = JUNK_SPAM_SCORE_STR;</span>
<a href="#l29.1326"></a><span id="l29.1326" class="difflineplus">+      searchTerm.value = value;</span>
<a href="#l29.1327"></a><span id="l29.1327" class="difflineplus">+      searchTerm.hdrProperty = JUNK_SCORE_PROPERTY;</span>
<a href="#l29.1328"></a><span id="l29.1328" class="difflineplus">+      searchTerms.appendElement(searchTerm, false);</span>
<a href="#l29.1329"></a><span id="l29.1329" class="difflineplus">+</span>
<a href="#l29.1330"></a><span id="l29.1330">       if (!isLocal)</span>
<a href="#l29.1331"></a><span id="l29.1331">       {</span>
<a href="#l29.1332"></a><span id="l29.1332">         // If the folder is offline, then the message should be too</span>
<a href="#l29.1333"></a><span id="l29.1333">         if (this._indexingFolder.flags &amp; Ci.nsMsgFolderFlags.Offline) {</span>
<a href="#l29.1334"></a><span id="l29.1334">           // third term: &amp;&amp; Status Is nsMsgMessageFlags.Offline</span>
<a href="#l29.1335"></a><span id="l29.1335">           searchTerm = searchSession.createTerm();</span>
<a href="#l29.1336"></a><span id="l29.1336">           searchTerm.booleanAnd = true;</span>
<a href="#l29.1337"></a><span id="l29.1337">           searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l29.1338"></a><span id="l29.1338">           searchTerm.op = nsMsgSearchOp.Is;</span>
<a href="#l29.1339"></a><span id="l29.1339">           value = searchTerm.value;</span>
<a href="#l29.1340"></a><span id="l29.1340">           value.attrib = searchTerm.attrib;</span>
<a href="#l29.1341"></a><span id="l29.1341" class="difflineminus">-          value.status = Ci.nsMsgMessageFlags.Offline;</span>
<a href="#l29.1342"></a><span id="l29.1342" class="difflineplus">+          value.status = nsMsgMessageFlags.Offline;</span>
<a href="#l29.1343"></a><span id="l29.1343">           searchTerm.value = value;</span>
<a href="#l29.1344"></a><span id="l29.1344">           searchTerms.appendElement(searchTerm, false);</span>
<a href="#l29.1345"></a><span id="l29.1345">         }</span>
<a href="#l29.1346"></a><span id="l29.1346"> </span>
<a href="#l29.1347"></a><span id="l29.1347">         // fourth term: &amp;&amp; Status Isnt nsMsgMessageFlags.Expunged</span>
<a href="#l29.1348"></a><span id="l29.1348">         searchTerm = searchSession.createTerm();</span>
<a href="#l29.1349"></a><span id="l29.1349">         searchTerm.booleanAnd = true;</span>
<a href="#l29.1350"></a><span id="l29.1350">         searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l29.1351"></a><span id="l29.1351">         searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l29.1352"></a><span id="l29.1352">         value = searchTerm.value;</span>
<a href="#l29.1353"></a><span id="l29.1353">         value.attrib = searchTerm.attrib;</span>
<a href="#l29.1354"></a><span id="l29.1354" class="difflineminus">-        value.status = Ci.nsMsgMessageFlags.Expunged;</span>
<a href="#l29.1355"></a><span id="l29.1355" class="difflineplus">+        value.status = nsMsgMessageFlags.Expunged;</span>
<a href="#l29.1356"></a><span id="l29.1356">         searchTerm.value = value;</span>
<a href="#l29.1357"></a><span id="l29.1357">         searchTerms.appendElement(searchTerm, false);</span>
<a href="#l29.1358"></a><span id="l29.1358">       }</span>
<a href="#l29.1359"></a><span id="l29.1359"> </span>
<a href="#l29.1360"></a><span id="l29.1360" class="difflineminus">-      this._indexingEnumerator = this._indexingDatabase.getFilterEnumerator(searchTerms);</span>
<a href="#l29.1361"></a><span id="l29.1361" class="difflineplus">+      this._indexingEnumerator =</span>
<a href="#l29.1362"></a><span id="l29.1362" class="difflineplus">+        this._indexingDatabase.getFilterEnumerator(searchTerms, true);</span>
<a href="#l29.1363"></a><span id="l29.1363" class="difflineplus">+    }</span>
<a href="#l29.1364"></a><span id="l29.1364" class="difflineplus">+    else if (aEnumKind == this.kEnumIndexedMsgs) {</span>
<a href="#l29.1365"></a><span id="l29.1365" class="difflineplus">+      // Enumerate only messages that are already indexed.  This comes out to:</span>
<a href="#l29.1366"></a><span id="l29.1366" class="difflineplus">+      //  ((GLODA_MESSAGE_ID_PROPERTY &gt; GLODA_FIRST_VALID_MESSAGE_ID-1) &amp;&amp;</span>
<a href="#l29.1367"></a><span id="l29.1367" class="difflineplus">+      //   (GLODA_DIRTY_PROPERTY Isnt kMessageFilthy))</span>
<a href="#l29.1368"></a><span id="l29.1368" class="difflineplus">+      // In English, a message is indexed if (by clause):</span>
<a href="#l29.1369"></a><span id="l29.1369" class="difflineplus">+      // 1) The message has a gloda-id and that gloda-id is in the valid range</span>
<a href="#l29.1370"></a><span id="l29.1370" class="difflineplus">+      //    (and not in the bad message marker range).</span>
<a href="#l29.1371"></a><span id="l29.1371" class="difflineplus">+      // 2) The message has not been marked filthy (which invalidates the</span>
<a href="#l29.1372"></a><span id="l29.1372" class="difflineplus">+      //    gloda-id.)  We also assume that the folder would not have been</span>
<a href="#l29.1373"></a><span id="l29.1373" class="difflineplus">+      //    entered at all if it was marked filthy.</span>
<a href="#l29.1374"></a><span id="l29.1374" class="difflineplus">+      let searchSession = Cc[&quot;@mozilla.org/messenger/searchSession;1&quot;]</span>
<a href="#l29.1375"></a><span id="l29.1375" class="difflineplus">+                            .createInstance(Ci.nsIMsgSearchSession);</span>
<a href="#l29.1376"></a><span id="l29.1376" class="difflineplus">+      let searchTerms = Cc[&quot;@mozilla.org/array;1&quot;]</span>
<a href="#l29.1377"></a><span id="l29.1377" class="difflineplus">+                         .createInstance(Ci.nsIMutableArray);</span>
<a href="#l29.1378"></a><span id="l29.1378" class="difflineplus">+</span>
<a href="#l29.1379"></a><span id="l29.1379" class="difflineplus">+      searchSession.addScopeTerm(Ci.nsMsgSearchScope.offlineMail,</span>
<a href="#l29.1380"></a><span id="l29.1380" class="difflineplus">+                                 this._indexingFolder);</span>
<a href="#l29.1381"></a><span id="l29.1381" class="difflineplus">+      let nsMsgSearchAttrib = Ci.nsMsgSearchAttrib;</span>
<a href="#l29.1382"></a><span id="l29.1382" class="difflineplus">+      let nsMsgSearchOp = Ci.nsMsgSearchOp;</span>
<a href="#l29.1383"></a><span id="l29.1383" class="difflineplus">+</span>
<a href="#l29.1384"></a><span id="l29.1384" class="difflineplus">+      // first term: (GLODA_MESSAGE_ID_PROPERTY &gt; GLODA_FIRST_VALID_MESSAGE_ID-1</span>
<a href="#l29.1385"></a><span id="l29.1385" class="difflineplus">+      let searchTerm = searchSession.createTerm();</span>
<a href="#l29.1386"></a><span id="l29.1386" class="difflineplus">+      searchTerm.booleanAnd = false; // actually don't care here</span>
<a href="#l29.1387"></a><span id="l29.1387" class="difflineplus">+      searchTerm.beginsGrouping = true;</span>
<a href="#l29.1388"></a><span id="l29.1388" class="difflineplus">+      searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;</span>
<a href="#l29.1389"></a><span id="l29.1389" class="difflineplus">+      searchTerm.op = nsMsgSearchOp.IsGreaterThan;</span>
<a href="#l29.1390"></a><span id="l29.1390" class="difflineplus">+      let value = searchTerm.value;</span>
<a href="#l29.1391"></a><span id="l29.1391" class="difflineplus">+      value.attrib = searchTerm.attrib;</span>
<a href="#l29.1392"></a><span id="l29.1392" class="difflineplus">+      value.status = GLODA_FIRST_VALID_MESSAGE_ID - 1;</span>
<a href="#l29.1393"></a><span id="l29.1393" class="difflineplus">+      searchTerm.value = value;</span>
<a href="#l29.1394"></a><span id="l29.1394" class="difflineplus">+      searchTerm.hdrProperty = GLODA_MESSAGE_ID_PROPERTY;</span>
<a href="#l29.1395"></a><span id="l29.1395" class="difflineplus">+      searchTerms.appendElement(searchTerm, false);</span>
<a href="#l29.1396"></a><span id="l29.1396" class="difflineplus">+</span>
<a href="#l29.1397"></a><span id="l29.1397" class="difflineplus">+      //  second term: &amp;&amp; GLODA_DIRTY_PROPERTY Isnt kMessageFilthy)</span>
<a href="#l29.1398"></a><span id="l29.1398" class="difflineplus">+      searchTerm = searchSession.createTerm();</span>
<a href="#l29.1399"></a><span id="l29.1399" class="difflineplus">+      searchTerm.booleanAnd = true;</span>
<a href="#l29.1400"></a><span id="l29.1400" class="difflineplus">+      searchTerm.endsGrouping = true;</span>
<a href="#l29.1401"></a><span id="l29.1401" class="difflineplus">+      searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;</span>
<a href="#l29.1402"></a><span id="l29.1402" class="difflineplus">+      searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l29.1403"></a><span id="l29.1403" class="difflineplus">+      value = searchTerm.value;</span>
<a href="#l29.1404"></a><span id="l29.1404" class="difflineplus">+      value.attrib = searchTerm.attrib;</span>
<a href="#l29.1405"></a><span id="l29.1405" class="difflineplus">+      value.status = this.kMessageFilthy;</span>
<a href="#l29.1406"></a><span id="l29.1406" class="difflineplus">+      searchTerm.value = value;</span>
<a href="#l29.1407"></a><span id="l29.1407" class="difflineplus">+      searchTerm.hdrProperty = GLODA_DIRTY_PROPERTY;</span>
<a href="#l29.1408"></a><span id="l29.1408" class="difflineplus">+      searchTerms.appendElement(searchTerm, false);</span>
<a href="#l29.1409"></a><span id="l29.1409" class="difflineplus">+</span>
<a href="#l29.1410"></a><span id="l29.1410" class="difflineplus">+      // The use-case of already indexed messages does not want them reversed;</span>
<a href="#l29.1411"></a><span id="l29.1411" class="difflineplus">+      //  we care about seeing the message keys in order.</span>
<a href="#l29.1412"></a><span id="l29.1412" class="difflineplus">+      this._indexingEnumerator =</span>
<a href="#l29.1413"></a><span id="l29.1413" class="difflineplus">+        this._indexingDatabase.getFilterEnumerator(searchTerms, false);</span>
<a href="#l29.1414"></a><span id="l29.1414" class="difflineplus">+    }</span>
<a href="#l29.1415"></a><span id="l29.1415" class="difflineplus">+    else if (aEnumKind == this.kEnumAllMsgs) {</span>
<a href="#l29.1416"></a><span id="l29.1416" class="difflineplus">+      this._indexingEnumerator =</span>
<a href="#l29.1417"></a><span id="l29.1417" class="difflineplus">+        this._indexingDatabase.ReverseEnumerateMessages();</span>
<a href="#l29.1418"></a><span id="l29.1418" class="difflineplus">+    }</span>
<a href="#l29.1419"></a><span id="l29.1419" class="difflineplus">+    else {</span>
<a href="#l29.1420"></a><span id="l29.1420" class="difflineplus">+      throw new Error(&quot;Unknown enumerator type requested:&quot; + aEnumKind);</span>
<a href="#l29.1421"></a><span id="l29.1421">     }</span>
<a href="#l29.1422"></a><span id="l29.1422">   },</span>
<a href="#l29.1423"></a><span id="l29.1423"> </span>
<a href="#l29.1424"></a><span id="l29.1424" class="difflineminus">-  _indexerLeaveFolder: function gloda_index_indexerLeaveFolder(aExpected) {</span>
<a href="#l29.1425"></a><span id="l29.1425" class="difflineplus">+  _indexerLeaveFolder: function gloda_index_indexerLeaveFolder() {</span>
<a href="#l29.1426"></a><span id="l29.1426">     if (this._indexingFolder !== null) {</span>
<a href="#l29.1427"></a><span id="l29.1427">       if (this._indexingDatabase) {</span>
<a href="#l29.1428"></a><span id="l29.1428">         this._indexingDatabase.Commit(Ci.nsMsgDBCommitType.kLargeCommit);</span>
<a href="#l29.1429"></a><span id="l29.1429">         // remove our listener!</span>
<a href="#l29.1430"></a><span id="l29.1430">         this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l29.1431"></a><span id="l29.1431">       }</span>
<a href="#l29.1432"></a><span id="l29.1432">       // let the gloda folder know we are done indexing</span>
<a href="#l29.1433"></a><span id="l29.1433">       this._indexingGlodaFolder.indexing = false;</span>
<a href="#l29.1434"></a><span id="l29.1434" class="difflineat">@@ -1149,478 +784,75 @@ var GlodaIndexer = {</span>
<a href="#l29.1435"></a><span id="l29.1435">       this._indexingGlodaFolder = null;</span>
<a href="#l29.1436"></a><span id="l29.1436">       this._indexingDatabase = null;</span>
<a href="#l29.1437"></a><span id="l29.1437">       this._indexingEnumerator = null;</span>
<a href="#l29.1438"></a><span id="l29.1438">     }</span>
<a href="#l29.1439"></a><span id="l29.1439">   },</span>
<a href="#l29.1440"></a><span id="l29.1440"> </span>
<a href="#l29.1441"></a><span id="l29.1441">   /**</span>
<a href="#l29.1442"></a><span id="l29.1442">    * Event fed to us by our nsIFolderListener when a folder is loaded.  We use</span>
<a href="#l29.1443"></a><span id="l29.1443" class="difflineminus">-   *  this event to two ends:</span>
<a href="#l29.1444"></a><span id="l29.1444" class="difflineminus">-   *</span>
<a href="#l29.1445"></a><span id="l29.1445" class="difflineminus">-   * - Know when a folder we were trying to open to index is actually ready to</span>
<a href="#l29.1446"></a><span id="l29.1446" class="difflineminus">-   *   be indexed.  (The summary may have not existed, may have been out of</span>
<a href="#l29.1447"></a><span id="l29.1447" class="difflineminus">-   *   date, or otherwise.)</span>
<a href="#l29.1448"></a><span id="l29.1448" class="difflineminus">-   * - Know when</span>
<a href="#l29.1449"></a><span id="l29.1449" class="difflineplus">+   *  this event to know when a folder we were trying to open to index is</span>
<a href="#l29.1450"></a><span id="l29.1450" class="difflineplus">+   *  actually ready to be indexed.  (The summary may have not existed, may have</span>
<a href="#l29.1451"></a><span id="l29.1451" class="difflineplus">+   *  been out of date, or otherwise.)</span>
<a href="#l29.1452"></a><span id="l29.1452">    *</span>
<a href="#l29.1453"></a><span id="l29.1453">    * @param aFolder An nsIMsgFolder, already QI'd.</span>
<a href="#l29.1454"></a><span id="l29.1454">    */</span>
<a href="#l29.1455"></a><span id="l29.1455">   _onFolderLoaded: function gloda_index_onFolderLoaded(aFolder) {</span>
<a href="#l29.1456"></a><span id="l29.1456">     if ((this._pendingFolderEntry !== null) &amp;&amp;</span>
<a href="#l29.1457"></a><span id="l29.1457">         (aFolder.URI == this._pendingFolderEntry.URI))</span>
<a href="#l29.1458"></a><span id="l29.1458">       this._indexerCompletePendingFolderEntry();</span>
<a href="#l29.1459"></a><span id="l29.1459">   },</span>
<a href="#l29.1460"></a><span id="l29.1460"> </span>
<a href="#l29.1461"></a><span id="l29.1461" class="difflineminus">-  /**</span>
<a href="#l29.1462"></a><span id="l29.1462" class="difflineminus">-   * A simple wrapper to make 'this' be right for incrementalIndex.</span>
<a href="#l29.1463"></a><span id="l29.1463" class="difflineminus">-   */</span>
<a href="#l29.1464"></a><span id="l29.1464" class="difflineminus">-  _wrapCallbackDriver: function gloda_index_wrapCallbackDriver() {</span>
<a href="#l29.1465"></a><span id="l29.1465" class="difflineminus">-    GlodaIndexer.callbackDriver();</span>
<a href="#l29.1466"></a><span id="l29.1466" class="difflineminus">-  },</span>
<a href="#l29.1467"></a><span id="l29.1467" class="difflineminus">-</span>
<a href="#l29.1468"></a><span id="l29.1468" class="difflineminus">-  /**</span>
<a href="#l29.1469"></a><span id="l29.1469" class="difflineminus">-   * The current processing 'batch' generator, produced by a call to workBatch()</span>
<a href="#l29.1470"></a><span id="l29.1470" class="difflineminus">-   *  and used by callbackDriver to drive execution.</span>
<a href="#l29.1471"></a><span id="l29.1471" class="difflineminus">-   */</span>
<a href="#l29.1472"></a><span id="l29.1472" class="difflineminus">-  _batch: null,</span>
<a href="#l29.1473"></a><span id="l29.1473" class="difflineminus">-  _inCallback: false,</span>
<a href="#l29.1474"></a><span id="l29.1474" class="difflineminus">-  _savedCallbackArgs: null,</span>
<a href="#l29.1475"></a><span id="l29.1475" class="difflineminus">-  /**</span>
<a href="#l29.1476"></a><span id="l29.1476" class="difflineminus">-   * The root work-driver.  callbackDriver creates workBatch generator instances</span>
<a href="#l29.1477"></a><span id="l29.1477" class="difflineminus">-   *  (stored in _batch) which run until they are done (kWorkDone) or they</span>
<a href="#l29.1478"></a><span id="l29.1478" class="difflineminus">-   *  (really the embedded _actualWorker) encounter something asynchronous.</span>
<a href="#l29.1479"></a><span id="l29.1479" class="difflineminus">-   *  The convention is that all the callback handlers end up calling us,</span>
<a href="#l29.1480"></a><span id="l29.1480" class="difflineminus">-   *  ensuring that control-flow properly resumes.  If the batch completes,</span>
<a href="#l29.1481"></a><span id="l29.1481" class="difflineminus">-   *  we re-schedule ourselves after a time delay (controlled by _INDEX_INTERVAL)</span>
<a href="#l29.1482"></a><span id="l29.1482" class="difflineminus">-   *  and return.  (We use one-shot timers because repeating-slack does not</span>
<a href="#l29.1483"></a><span id="l29.1483" class="difflineminus">-   *  know enough to deal with our (current) asynchronous nature.)</span>
<a href="#l29.1484"></a><span id="l29.1484" class="difflineminus">-   */</span>
<a href="#l29.1485"></a><span id="l29.1485" class="difflineminus">-  callbackDriver: function gloda_index_callbackDriver() {</span>
<a href="#l29.1486"></a><span id="l29.1486" class="difflineminus">-    // just bail if we are shutdown</span>
<a href="#l29.1487"></a><span id="l29.1487" class="difflineminus">-    if (this._indexerIsShutdown)</span>
<a href="#l29.1488"></a><span id="l29.1488" class="difflineminus">-      return;</span>
<a href="#l29.1489"></a><span id="l29.1489" class="difflineminus">-</span>
<a href="#l29.1490"></a><span id="l29.1490" class="difflineminus">-    // it is conceivable that someone we call will call something that in some</span>
<a href="#l29.1491"></a><span id="l29.1491" class="difflineminus">-    //  cases might be asynchronous, and in other cases immediately generate</span>
<a href="#l29.1492"></a><span id="l29.1492" class="difflineminus">-    //  events without returning.  In the interest of (stack-depth) sanity,</span>
<a href="#l29.1493"></a><span id="l29.1493" class="difflineminus">-    //  let's handle this by performing a minimal time-delay callback.</span>
<a href="#l29.1494"></a><span id="l29.1494" class="difflineminus">-    // this is also now a good thing sequencing-wise.  if we get our callback</span>
<a href="#l29.1495"></a><span id="l29.1495" class="difflineminus">-    //  with data before the underlying function has yielded, we obviously can't</span>
<a href="#l29.1496"></a><span id="l29.1496" class="difflineminus">-    //  cram the data in yet.  Our options in this case are to either mark the</span>
<a href="#l29.1497"></a><span id="l29.1497" class="difflineminus">-    //  fact that the callback has already happened and immediately return to</span>
<a href="#l29.1498"></a><span id="l29.1498" class="difflineminus">-    //  the iterator when it does bubble up the kWorkAsync, or we can do as we</span>
<a href="#l29.1499"></a><span id="l29.1499" class="difflineminus">-    //  have been doing, but save the</span>
<a href="#l29.1500"></a><span id="l29.1500" class="difflineminus">-    if (this._inCallback) {</span>
<a href="#l29.1501"></a><span id="l29.1501" class="difflineminus">-      this._savedCallbackArgs = arguments;</span>
<a href="#l29.1502"></a><span id="l29.1502" class="difflineminus">-      this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l29.1503"></a><span id="l29.1503" class="difflineminus">-                                   0,</span>
<a href="#l29.1504"></a><span id="l29.1504" class="difflineminus">-                                   Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l29.1505"></a><span id="l29.1505" class="difflineminus">-      return;</span>
<a href="#l29.1506"></a><span id="l29.1506" class="difflineminus">-    }</span>
<a href="#l29.1507"></a><span id="l29.1507" class="difflineminus">-    this._inCallback = true;</span>
<a href="#l29.1508"></a><span id="l29.1508" class="difflineminus">-</span>
<a href="#l29.1509"></a><span id="l29.1509" class="difflineminus">-    try {</span>
<a href="#l29.1510"></a><span id="l29.1510" class="difflineminus">-      if (this._batch === null)</span>
<a href="#l29.1511"></a><span id="l29.1511" class="difflineminus">-        this._batch = this.workBatch();</span>
<a href="#l29.1512"></a><span id="l29.1512" class="difflineminus">-</span>
<a href="#l29.1513"></a><span id="l29.1513" class="difflineminus">-      // kWorkAsync, kWorkDone, kWorkPause are allowed out; kWorkSync is not</span>
<a href="#l29.1514"></a><span id="l29.1514" class="difflineminus">-      // On kWorkDone, we want to schedule another timer to fire on us if we are</span>
<a href="#l29.1515"></a><span id="l29.1515" class="difflineminus">-      //  not done indexing.  (On kWorkAsync, we don't care what happens, because</span>
<a href="#l29.1516"></a><span id="l29.1516" class="difflineminus">-      //  someone else will be receiving the callback, and they will call us when</span>
<a href="#l29.1517"></a><span id="l29.1517" class="difflineminus">-      //  they are done doing their thing.</span>
<a href="#l29.1518"></a><span id="l29.1518" class="difflineminus">-      let args;</span>
<a href="#l29.1519"></a><span id="l29.1519" class="difflineminus">-      if (this._savedCallbackArgs != null) {</span>
<a href="#l29.1520"></a><span id="l29.1520" class="difflineminus">-        args = this._savedCallbackArgs;</span>
<a href="#l29.1521"></a><span id="l29.1521" class="difflineminus">-        this._savedCallbackArgs = null;</span>
<a href="#l29.1522"></a><span id="l29.1522" class="difflineminus">-      }</span>
<a href="#l29.1523"></a><span id="l29.1523" class="difflineminus">-      else</span>
<a href="#l29.1524"></a><span id="l29.1524" class="difflineminus">-        args = arguments; //Array.slice.call(arguments);</span>
<a href="#l29.1525"></a><span id="l29.1525" class="difflineminus">-</span>
<a href="#l29.1526"></a><span id="l29.1526" class="difflineminus">-      let result;</span>
<a href="#l29.1527"></a><span id="l29.1527" class="difflineminus">-      if (args.length == 0)</span>
<a href="#l29.1528"></a><span id="l29.1528" class="difflineminus">-        result = this._batch.next();</span>
<a href="#l29.1529"></a><span id="l29.1529" class="difflineminus">-      else if (args.length == 1)</span>
<a href="#l29.1530"></a><span id="l29.1530" class="difflineminus">-        result = this._batch.send(args[0]);</span>
<a href="#l29.1531"></a><span id="l29.1531" class="difflineminus">-      else // arguments works with destructuring assignment</span>
<a href="#l29.1532"></a><span id="l29.1532" class="difflineminus">-        result = this._batch.send(args);</span>
<a href="#l29.1533"></a><span id="l29.1533" class="difflineminus">-      switch (result) {</span>
<a href="#l29.1534"></a><span id="l29.1534" class="difflineminus">-        // job's done, close the batch and re-schedule ourselves if there's more</span>
<a href="#l29.1535"></a><span id="l29.1535" class="difflineminus">-        //  to do.</span>
<a href="#l29.1536"></a><span id="l29.1536" class="difflineminus">-        case this.kWorkDone:</span>
<a href="#l29.1537"></a><span id="l29.1537" class="difflineminus">-          this._batch.close();</span>
<a href="#l29.1538"></a><span id="l29.1538" class="difflineminus">-          this._batch = null;</span>
<a href="#l29.1539"></a><span id="l29.1539" class="difflineminus">-          // (intentional fall-through to re-scheduling logic)</span>
<a href="#l29.1540"></a><span id="l29.1540" class="difflineminus">-        // the batch wants to get re-scheduled, do so.</span>
<a href="#l29.1541"></a><span id="l29.1541" class="difflineminus">-        case this.kWorkPause:</span>
<a href="#l29.1542"></a><span id="l29.1542" class="difflineminus">-          if (this.indexing)</span>
<a href="#l29.1543"></a><span id="l29.1543" class="difflineminus">-            this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l29.1544"></a><span id="l29.1544" class="difflineminus">-                                         this._INDEX_INTERVAL,</span>
<a href="#l29.1545"></a><span id="l29.1545" class="difflineminus">-                                         Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l29.1546"></a><span id="l29.1546" class="difflineminus">-          else { // it's important to indicate no more callbacks are in flight</span>
<a href="#l29.1547"></a><span id="l29.1547" class="difflineminus">-            this._indexingActive = false;</span>
<a href="#l29.1548"></a><span id="l29.1548" class="difflineminus">-          }</span>
<a href="#l29.1549"></a><span id="l29.1549" class="difflineminus">-          break;</span>
<a href="#l29.1550"></a><span id="l29.1550" class="difflineminus">-        case this.kWorkAsync:</span>
<a href="#l29.1551"></a><span id="l29.1551" class="difflineminus">-          // there is nothing to do.  some other code is now responsible for</span>
<a href="#l29.1552"></a><span id="l29.1552" class="difflineminus">-          //  calling us.</span>
<a href="#l29.1553"></a><span id="l29.1553" class="difflineminus">-          break;</span>
<a href="#l29.1554"></a><span id="l29.1554" class="difflineminus">-      }</span>
<a href="#l29.1555"></a><span id="l29.1555" class="difflineminus">-    }</span>
<a href="#l29.1556"></a><span id="l29.1556" class="difflineminus">-    finally {</span>
<a href="#l29.1557"></a><span id="l29.1557" class="difflineminus">-      this._inCallback = false;</span>
<a href="#l29.1558"></a><span id="l29.1558" class="difflineminus">-    }</span>
<a href="#l29.1559"></a><span id="l29.1559" class="difflineplus">+  // it's a getter so we can reference 'this'.  we could memoize.</span>
<a href="#l29.1560"></a><span id="l29.1560" class="difflineplus">+  get workers() {</span>
<a href="#l29.1561"></a><span id="l29.1561" class="difflineplus">+    return [</span>
<a href="#l29.1562"></a><span id="l29.1562" class="difflineplus">+      [&quot;folderSweep&quot;, {</span>
<a href="#l29.1563"></a><span id="l29.1563" class="difflineplus">+         worker: this._worker_indexingSweep,</span>
<a href="#l29.1564"></a><span id="l29.1564" class="difflineplus">+       }],</span>
<a href="#l29.1565"></a><span id="l29.1565" class="difflineplus">+      [&quot;folder&quot;, {</span>
<a href="#l29.1566"></a><span id="l29.1566" class="difflineplus">+         worker: this._worker_folderIndex,</span>
<a href="#l29.1567"></a><span id="l29.1567" class="difflineplus">+         recover: this._recover_indexMessage,</span>
<a href="#l29.1568"></a><span id="l29.1568" class="difflineplus">+         cleanup: this._cleanup_indexing,</span>
<a href="#l29.1569"></a><span id="l29.1569" class="difflineplus">+       }],</span>
<a href="#l29.1570"></a><span id="l29.1570" class="difflineplus">+      [&quot;folderCompact&quot;, {</span>
<a href="#l29.1571"></a><span id="l29.1571" class="difflineplus">+         worker: this._worker_folderCompactionPass,</span>
<a href="#l29.1572"></a><span id="l29.1572" class="difflineplus">+         // compaction enters the folder so needs to know how to leave</span>
<a href="#l29.1573"></a><span id="l29.1573" class="difflineplus">+         cleanup: this._cleanup_indexing,</span>
<a href="#l29.1574"></a><span id="l29.1574" class="difflineplus">+       }],</span>
<a href="#l29.1575"></a><span id="l29.1575" class="difflineplus">+      [&quot;message&quot;, {</span>
<a href="#l29.1576"></a><span id="l29.1576" class="difflineplus">+         worker: this._worker_messageIndex,</span>
<a href="#l29.1577"></a><span id="l29.1577" class="difflineplus">+         onSchedule: this._schedule_messageIndex,</span>
<a href="#l29.1578"></a><span id="l29.1578" class="difflineplus">+         jobCanceled: this._canceled_messageIndex,</span>
<a href="#l29.1579"></a><span id="l29.1579" class="difflineplus">+         recover: this._recover_indexMessage,</span>
<a href="#l29.1580"></a><span id="l29.1580" class="difflineplus">+         cleanup: this._cleanup_indexing,</span>
<a href="#l29.1581"></a><span id="l29.1581" class="difflineplus">+       }],</span>
<a href="#l29.1582"></a><span id="l29.1582" class="difflineplus">+      [&quot;delete&quot;, {</span>
<a href="#l29.1583"></a><span id="l29.1583" class="difflineplus">+         worker: this._worker_processDeletes,</span>
<a href="#l29.1584"></a><span id="l29.1584" class="difflineplus">+       }],</span>
<a href="#l29.1585"></a><span id="l29.1585" class="difflineplus">+    ];</span>
<a href="#l29.1586"></a><span id="l29.1586">   },</span>
<a href="#l29.1587"></a><span id="l29.1587"> </span>
<a href="#l29.1588"></a><span id="l29.1588" class="difflineminus">-  _callbackHandle: {</span>
<a href="#l29.1589"></a><span id="l29.1589" class="difflineminus">-    init: function gloda_index_callbackhandle_init() {</span>
<a href="#l29.1590"></a><span id="l29.1590" class="difflineminus">-      this.wrappedCallback = GlodaIndexer._wrapCallbackDriver;</span>
<a href="#l29.1591"></a><span id="l29.1591" class="difflineminus">-      this.callbackThis = GlodaIndexer;</span>
<a href="#l29.1592"></a><span id="l29.1592" class="difflineminus">-      this.callback = GlodaIndexer.callbackDriver;</span>
<a href="#l29.1593"></a><span id="l29.1593" class="difflineminus">-    },</span>
<a href="#l29.1594"></a><span id="l29.1594" class="difflineminus">-    activeStack: [],</span>
<a href="#l29.1595"></a><span id="l29.1595" class="difflineminus">-    activeIterator: null,</span>
<a href="#l29.1596"></a><span id="l29.1596" class="difflineminus">-    push: function gloda_index_callbackhandle_push(aIterator) {</span>
<a href="#l29.1597"></a><span id="l29.1597" class="difflineminus">-      this.activeStack.push(aIterator);</span>
<a href="#l29.1598"></a><span id="l29.1598" class="difflineminus">-      this.activeIterator = aIterator;</span>
<a href="#l29.1599"></a><span id="l29.1599" class="difflineminus">-    },</span>
<a href="#l29.1600"></a><span id="l29.1600" class="difflineminus">-    pushAndGo: function gloda_index_callbackhandle_pushAndGo(aIterator) {</span>
<a href="#l29.1601"></a><span id="l29.1601" class="difflineminus">-      this.push(aIterator);</span>
<a href="#l29.1602"></a><span id="l29.1602" class="difflineminus">-      return this.activeIterator.next();</span>
<a href="#l29.1603"></a><span id="l29.1603" class="difflineminus">-    },</span>
<a href="#l29.1604"></a><span id="l29.1604" class="difflineminus">-    pop: function gloda_index_callbackhandle_pop() {</span>
<a href="#l29.1605"></a><span id="l29.1605" class="difflineminus">-      this.activeIterator.close();</span>
<a href="#l29.1606"></a><span id="l29.1606" class="difflineminus">-      this.activeStack.pop();</span>
<a href="#l29.1607"></a><span id="l29.1607" class="difflineminus">-      if (this.activeStack.length)</span>
<a href="#l29.1608"></a><span id="l29.1608" class="difflineminus">-        this.activeIterator = this.activeStack[this.activeStack.length - 1];</span>
<a href="#l29.1609"></a><span id="l29.1609" class="difflineminus">-      else</span>
<a href="#l29.1610"></a><span id="l29.1610" class="difflineminus">-        this.activeIterator = null;</span>
<a href="#l29.1611"></a><span id="l29.1611" class="difflineminus">-    },</span>
<a href="#l29.1612"></a><span id="l29.1612" class="difflineminus">-    /**</span>
<a href="#l29.1613"></a><span id="l29.1613" class="difflineminus">-     * Someone propagated an exception and we need to clean-up all the active</span>
<a href="#l29.1614"></a><span id="l29.1614" class="difflineminus">-     *  logic as best we can.  Which is not really all that well.</span>
<a href="#l29.1615"></a><span id="l29.1615" class="difflineminus">-     */</span>
<a href="#l29.1616"></a><span id="l29.1616" class="difflineminus">-    cleanup: function gloda_index_callbackhandle_cleanup(aOptionalStopAtDepth) {</span>
<a href="#l29.1617"></a><span id="l29.1617" class="difflineminus">-      if (aOptionalStopAtDepth === undefined)</span>
<a href="#l29.1618"></a><span id="l29.1618" class="difflineminus">-        aOptionalStopAtDepth = 0;</span>
<a href="#l29.1619"></a><span id="l29.1619" class="difflineminus">-      while (this.activeStack.length &gt; aOptionalStopAtDepth) {</span>
<a href="#l29.1620"></a><span id="l29.1620" class="difflineminus">-        this.pop();</span>
<a href="#l29.1621"></a><span id="l29.1621" class="difflineminus">-      }</span>
<a href="#l29.1622"></a><span id="l29.1622" class="difflineminus">-    },</span>
<a href="#l29.1623"></a><span id="l29.1623" class="difflineminus">-    popWithResult: function gloda_index_callbackhandle_popWithResult() {</span>
<a href="#l29.1624"></a><span id="l29.1624" class="difflineminus">-      this.pop();</span>
<a href="#l29.1625"></a><span id="l29.1625" class="difflineminus">-      let result = this._result;</span>
<a href="#l29.1626"></a><span id="l29.1626" class="difflineminus">-      this._result = null;</span>
<a href="#l29.1627"></a><span id="l29.1627" class="difflineminus">-      return result;</span>
<a href="#l29.1628"></a><span id="l29.1628" class="difflineminus">-    },</span>
<a href="#l29.1629"></a><span id="l29.1629" class="difflineminus">-    _result: null,</span>
<a href="#l29.1630"></a><span id="l29.1630" class="difflineminus">-    doneWithResult: function gloda_index_callbackhandle_doneWithResult(aResult){</span>
<a href="#l29.1631"></a><span id="l29.1631" class="difflineminus">-      this._result = aResult;</span>
<a href="#l29.1632"></a><span id="l29.1632" class="difflineminus">-      return Gloda.kWorkDoneWithResult;</span>
<a href="#l29.1633"></a><span id="l29.1633" class="difflineminus">-    },</span>
<a href="#l29.1634"></a><span id="l29.1634" class="difflineminus">-</span>
<a href="#l29.1635"></a><span id="l29.1635" class="difflineminus">-    /* be able to serve as a collection listener, resuming the active iterator's</span>
<a href="#l29.1636"></a><span id="l29.1636" class="difflineminus">-       last yield kWorkAsync */</span>
<a href="#l29.1637"></a><span id="l29.1637" class="difflineminus">-    onItemsAdded: function() {},</span>
<a href="#l29.1638"></a><span id="l29.1638" class="difflineminus">-    onItemsModified: function() {},</span>
<a href="#l29.1639"></a><span id="l29.1639" class="difflineminus">-    onItemsRemoved: function() {},</span>
<a href="#l29.1640"></a><span id="l29.1640" class="difflineminus">-    onQueryCompleted: function(aCollection) {</span>
<a href="#l29.1641"></a><span id="l29.1641" class="difflineminus">-      GlodaIndexer.callbackDriver();</span>
<a href="#l29.1642"></a><span id="l29.1642" class="difflineminus">-    }</span>
<a href="#l29.1643"></a><span id="l29.1643" class="difflineminus">-  },</span>
<a href="#l29.1644"></a><span id="l29.1644" class="difflineminus">-  _workBatchData: undefined,</span>
<a href="#l29.1645"></a><span id="l29.1645" class="difflineminus">-  /**</span>
<a href="#l29.1646"></a><span id="l29.1646" class="difflineminus">-   * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l29.1647"></a><span id="l29.1647" class="difflineminus">-   *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l29.1648"></a><span id="l29.1648" class="difflineminus">-   *  _actualWorker generator which is doing the work.</span>
<a href="#l29.1649"></a><span id="l29.1649" class="difflineminus">-   * workBatch will only produce kWorkAsync, kWorkPause, and kWorkDone</span>
<a href="#l29.1650"></a><span id="l29.1650" class="difflineminus">-   *  notifications.  If _actualWorker returns kWorkSync and there are still</span>
<a href="#l29.1651"></a><span id="l29.1651" class="difflineminus">-   *  tokens available, workBatch will keep driving _actualWorker until it</span>
<a href="#l29.1652"></a><span id="l29.1652" class="difflineminus">-   *  encounters a kWorkAsync (which workBatch will yield to callbackDriver), or</span>
<a href="#l29.1653"></a><span id="l29.1653" class="difflineminus">-   *  it runs out of tokens and yields a kWorkPause or kWorkDone.</span>
<a href="#l29.1654"></a><span id="l29.1654" class="difflineminus">-   */</span>
<a href="#l29.1655"></a><span id="l29.1655" class="difflineminus">-  workBatch: function gloda_index_workBatch() {</span>
<a href="#l29.1656"></a><span id="l29.1656" class="difflineminus">-</span>
<a href="#l29.1657"></a><span id="l29.1657" class="difflineminus">-    // Do we still have an open transaction? If not, start a new one.</span>
<a href="#l29.1658"></a><span id="l29.1658" class="difflineminus">-    if (!this._idleToCommit)</span>
<a href="#l29.1659"></a><span id="l29.1659" class="difflineminus">-      GlodaDatastore._beginTransaction();</span>
<a href="#l29.1660"></a><span id="l29.1660" class="difflineminus">-    else</span>
<a href="#l29.1661"></a><span id="l29.1661" class="difflineminus">-      // We'll manage commit ourself while this routine is active.</span>
<a href="#l29.1662"></a><span id="l29.1662" class="difflineminus">-      this._idleToCommit = false;</span>
<a href="#l29.1663"></a><span id="l29.1663" class="difflineminus">-</span>
<a href="#l29.1664"></a><span id="l29.1664" class="difflineminus">-    this._perfIndexStopwatch.start();</span>
<a href="#l29.1665"></a><span id="l29.1665" class="difflineminus">-    let batchCount;</span>
<a href="#l29.1666"></a><span id="l29.1666" class="difflineminus">-    let haveMoreWork = true;</span>
<a href="#l29.1667"></a><span id="l29.1667" class="difflineminus">-    let transactionToCommit = true;</span>
<a href="#l29.1668"></a><span id="l29.1668" class="difflineminus">-    let inIdle;</span>
<a href="#l29.1669"></a><span id="l29.1669" class="difflineminus">-</span>
<a href="#l29.1670"></a><span id="l29.1670" class="difflineminus">-    let notifyDecimator = 0;</span>
<a href="#l29.1671"></a><span id="l29.1671" class="difflineminus">-</span>
<a href="#l29.1672"></a><span id="l29.1672" class="difflineminus">-    while (haveMoreWork) {</span>
<a href="#l29.1673"></a><span id="l29.1673" class="difflineminus">-      // Both explicit work activity points (sync + async) and transfer of</span>
<a href="#l29.1674"></a><span id="l29.1674" class="difflineminus">-      //  control return (via kWorkDone*) results in a token being eaten.  The</span>
<a href="#l29.1675"></a><span id="l29.1675" class="difflineminus">-      //  idea now is to make tokens less precious so that the adaptive logic</span>
<a href="#l29.1676"></a><span id="l29.1676" class="difflineminus">-      //  can adjust them with less impact.  (Before this change, doing 1</span>
<a href="#l29.1677"></a><span id="l29.1677" class="difflineminus">-      //  token's work per cycle ended up being an entire non-idle time-slice's</span>
<a href="#l29.1678"></a><span id="l29.1678" class="difflineminus">-      //  work.)</span>
<a href="#l29.1679"></a><span id="l29.1679" class="difflineminus">-      // During this loop we track the clock real-time used even though we</span>
<a href="#l29.1680"></a><span id="l29.1680" class="difflineminus">-      //  frequently yield to asynchronous operations.  These asynchronous</span>
<a href="#l29.1681"></a><span id="l29.1681" class="difflineminus">-      //  operations are either database queries or message streaming requests.</span>
<a href="#l29.1682"></a><span id="l29.1682" class="difflineminus">-      //  Both may involve disk I/O but no network I/O (since we only stream</span>
<a href="#l29.1683"></a><span id="l29.1683" class="difflineminus">-      //  messages that are already available offline), but in an ideal</span>
<a href="#l29.1684"></a><span id="l29.1684" class="difflineminus">-      //  situation will come from cache and so the work this function kicks off</span>
<a href="#l29.1685"></a><span id="l29.1685" class="difflineminus">-      //  will dominate.</span>
<a href="#l29.1686"></a><span id="l29.1686" class="difflineminus">-      // We do not use the CPU time to this end because...</span>
<a href="#l29.1687"></a><span id="l29.1687" class="difflineminus">-      //  1) Our timer granularity on linux is worse for CPU than for wall time.</span>
<a href="#l29.1688"></a><span id="l29.1688" class="difflineminus">-      //  2) That can fail to account for our I/O cost.</span>
<a href="#l29.1689"></a><span id="l29.1689" class="difflineminus">-      //  3) If something with a high priority / low latency need (like playing</span>
<a href="#l29.1690"></a><span id="l29.1690" class="difflineminus">-      //     a video) is fighting us, although using CPU time will accurately</span>
<a href="#l29.1691"></a><span id="l29.1691" class="difflineminus">-      //     express how much time we are actually spending to index, our goal</span>
<a href="#l29.1692"></a><span id="l29.1692" class="difflineminus">-      //     is to control the duration of our time slices, not be &quot;right&quot; about</span>
<a href="#l29.1693"></a><span id="l29.1693" class="difflineminus">-      //     the actual CPU cost.  In that case, if we attempted to take on more</span>
<a href="#l29.1694"></a><span id="l29.1694" class="difflineminus">-      //     work, we would likely interfere with the higher priority process or</span>
<a href="#l29.1695"></a><span id="l29.1695" class="difflineminus">-      //     make ourselves less responsive by drawing out the period of time we</span>
<a href="#l29.1696"></a><span id="l29.1696" class="difflineminus">-      //     are dominating the main thread.</span>
<a href="#l29.1697"></a><span id="l29.1697" class="difflineminus">-      this._perfIndexStopwatch.start();</span>
<a href="#l29.1698"></a><span id="l29.1698" class="difflineminus">-      batchCount = 0;</span>
<a href="#l29.1699"></a><span id="l29.1699" class="difflineminus">-      while (batchCount &lt; this._indexTokens) {</span>
<a href="#l29.1700"></a><span id="l29.1700" class="difflineminus">-</span>
<a href="#l29.1701"></a><span id="l29.1701" class="difflineminus">-        if ((this._callbackHandle.activeIterator === null) &amp;&amp;</span>
<a href="#l29.1702"></a><span id="l29.1702" class="difflineminus">-            !this._hireJobWorker()) {</span>
<a href="#l29.1703"></a><span id="l29.1703" class="difflineminus">-          haveMoreWork = false;</span>
<a href="#l29.1704"></a><span id="l29.1704" class="difflineminus">-          break;</span>
<a href="#l29.1705"></a><span id="l29.1705" class="difflineminus">-        }</span>
<a href="#l29.1706"></a><span id="l29.1706" class="difflineminus">-        batchCount++;</span>
<a href="#l29.1707"></a><span id="l29.1707" class="difflineminus">-</span>
<a href="#l29.1708"></a><span id="l29.1708" class="difflineminus">-        // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l29.1709"></a><span id="l29.1709" class="difflineminus">-        //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l29.1710"></a><span id="l29.1710" class="difflineminus">-        //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l29.1711"></a><span id="l29.1711" class="difflineminus">-        //  tokens.)</span>
<a href="#l29.1712"></a><span id="l29.1712" class="difflineminus">-        try {</span>
<a href="#l29.1713"></a><span id="l29.1713" class="difflineminus">-          switch (this._callbackHandle.activeIterator.send(this._workBatchData)) {</span>
<a href="#l29.1714"></a><span id="l29.1714" class="difflineminus">-            case this.kWorkSync:</span>
<a href="#l29.1715"></a><span id="l29.1715" class="difflineminus">-              this._workBatchData = undefined;</span>
<a href="#l29.1716"></a><span id="l29.1716" class="difflineminus">-              break;</span>
<a href="#l29.1717"></a><span id="l29.1717" class="difflineminus">-            case this.kWorkAsync:</span>
<a href="#l29.1718"></a><span id="l29.1718" class="difflineminus">-              this._workBatchData = yield this.kWorkAsync;</span>
<a href="#l29.1719"></a><span id="l29.1719" class="difflineminus">-              break;</span>
<a href="#l29.1720"></a><span id="l29.1720" class="difflineminus">-            case this.kWorkDone:</span>
<a href="#l29.1721"></a><span id="l29.1721" class="difflineminus">-              this._callbackHandle.pop();</span>
<a href="#l29.1722"></a><span id="l29.1722" class="difflineminus">-              this._workBatchData = undefined;</span>
<a href="#l29.1723"></a><span id="l29.1723" class="difflineminus">-              break;</span>
<a href="#l29.1724"></a><span id="l29.1724" class="difflineminus">-            case this.kWorkDoneWithResult:</span>
<a href="#l29.1725"></a><span id="l29.1725" class="difflineminus">-              this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l29.1726"></a><span id="l29.1726" class="difflineminus">-              break;</span>
<a href="#l29.1727"></a><span id="l29.1727" class="difflineminus">-            default:</span>
<a href="#l29.1728"></a><span id="l29.1728" class="difflineminus">-              break;</span>
<a href="#l29.1729"></a><span id="l29.1729" class="difflineminus">-          }</span>
<a href="#l29.1730"></a><span id="l29.1730" class="difflineminus">-        }</span>
<a href="#l29.1731"></a><span id="l29.1731" class="difflineminus">-        catch (ex) {</span>
<a href="#l29.1732"></a><span id="l29.1732" class="difflineminus">-          // Try and recover if the job is recoverable and the iterator that</span>
<a href="#l29.1733"></a><span id="l29.1733" class="difflineminus">-          //  experienced the problem wasn't the job worker.  (If it was the</span>
<a href="#l29.1734"></a><span id="l29.1734" class="difflineminus">-          //  job worker, we can't rely on its state to be intact.)</span>
<a href="#l29.1735"></a><span id="l29.1735" class="difflineminus">-          if (this._curIndexingJob.recoverable &gt; 0 &amp;&amp;</span>
<a href="#l29.1736"></a><span id="l29.1736" class="difflineminus">-              this._callbackHandle.activeStack.length &gt; 1) {</span>
<a href="#l29.1737"></a><span id="l29.1737" class="difflineminus">-            this._curIndexingJob.recoverable--;</span>
<a href="#l29.1738"></a><span id="l29.1738" class="difflineminus">-            this._log.warn(&quot;Problem during &quot; + this._curIndexingJob +</span>
<a href="#l29.1739"></a><span id="l29.1739" class="difflineminus">-              &quot;, trying to recover.  Problem was at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l29.1740"></a><span id="l29.1740" class="difflineminus">-              ex.lineNumber + &quot;: &quot; + ex +</span>
<a href="#l29.1741"></a><span id="l29.1741" class="difflineminus">-              (ex.stack ? (&quot;. Stack:\n  &quot; + ex.stack.replace(&quot;\n&quot;, &quot;\n  &quot;, &quot;g&quot;))</span>
<a href="#l29.1742"></a><span id="l29.1742" class="difflineminus">-                        : &quot;&quot;));</span>
<a href="#l29.1743"></a><span id="l29.1743" class="difflineminus">-            // cleanup but leave the job's iterator intact.</span>
<a href="#l29.1744"></a><span id="l29.1744" class="difflineminus">-            this._callbackHandle.cleanup(1);</span>
<a href="#l29.1745"></a><span id="l29.1745" class="difflineminus">-            // the data must now be invalid</span>
<a href="#l29.1746"></a><span id="l29.1746" class="difflineminus">-            this._workBatchData = undefined;</span>
<a href="#l29.1747"></a><span id="l29.1747" class="difflineminus">-          }</span>
<a href="#l29.1748"></a><span id="l29.1748" class="difflineminus">-          else {</span>
<a href="#l29.1749"></a><span id="l29.1749" class="difflineminus">-            this._log.warn(&quot;Problem during &quot; + this._curIndexingJob +</span>
<a href="#l29.1750"></a><span id="l29.1750" class="difflineminus">-              &quot;, bailing.  Problem was at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l29.1751"></a><span id="l29.1751" class="difflineminus">-              ex.lineNumber + &quot;: &quot; + ex +</span>
<a href="#l29.1752"></a><span id="l29.1752" class="difflineminus">-              (ex.stack ? (&quot;. Stack:\n  &quot; + ex.stack.replace(&quot;\n&quot;, &quot;\n  &quot;, &quot;g&quot;))</span>
<a href="#l29.1753"></a><span id="l29.1753" class="difflineminus">-                        : &quot;&quot;));</span>
<a href="#l29.1754"></a><span id="l29.1754" class="difflineminus">-            // make sure we no longer have a current folder</span>
<a href="#l29.1755"></a><span id="l29.1755" class="difflineminus">-            this._indexerLeaveFolder(true);</span>
<a href="#l29.1756"></a><span id="l29.1756" class="difflineminus">-            this._curIndexingJob = null;</span>
<a href="#l29.1757"></a><span id="l29.1757" class="difflineminus">-            // clear out our current generators and our related data</span>
<a href="#l29.1758"></a><span id="l29.1758" class="difflineminus">-            this._callbackHandle.cleanup();</span>
<a href="#l29.1759"></a><span id="l29.1759" class="difflineminus">-            this._workBatchData = undefined;</span>
<a href="#l29.1760"></a><span id="l29.1760" class="difflineminus">-          }</span>
<a href="#l29.1761"></a><span id="l29.1761" class="difflineminus">-        }</span>
<a href="#l29.1762"></a><span id="l29.1762" class="difflineminus">-      }</span>
<a href="#l29.1763"></a><span id="l29.1763" class="difflineminus">-      this._perfIndexStopwatch.stop();</span>
<a href="#l29.1764"></a><span id="l29.1764" class="difflineminus">-</span>
<a href="#l29.1765"></a><span id="l29.1765" class="difflineminus">-      // We want to stop ASAP when leaving idle, so we can't rely on the</span>
<a href="#l29.1766"></a><span id="l29.1766" class="difflineminus">-      // standard polled callback. We do the polling ourselves.</span>
<a href="#l29.1767"></a><span id="l29.1767" class="difflineminus">-      if (this._idleService.idleTime &lt; this._INDEX_IDLE_ADJUSTMENT_TIME) {</span>
<a href="#l29.1768"></a><span id="l29.1768" class="difflineminus">-        inIdle = false;</span>
<a href="#l29.1769"></a><span id="l29.1769" class="difflineminus">-        this._cpuTargetIndexTime = this._CPU_TARGET_INDEX_TIME_ACTIVE;</span>
<a href="#l29.1770"></a><span id="l29.1770" class="difflineminus">-      }</span>
<a href="#l29.1771"></a><span id="l29.1771" class="difflineminus">-      else {</span>
<a href="#l29.1772"></a><span id="l29.1772" class="difflineminus">-        inIdle = true;</span>
<a href="#l29.1773"></a><span id="l29.1773" class="difflineminus">-        this._cpuTargetIndexTime = this._CPU_TARGET_INDEX_TIME_IDLE;</span>
<a href="#l29.1774"></a><span id="l29.1774" class="difflineminus">-      }</span>
<a href="#l29.1775"></a><span id="l29.1775" class="difflineminus">-</span>
<a href="#l29.1776"></a><span id="l29.1776" class="difflineminus">-      // take a breather by having the caller re-schedule us sometime in the</span>
<a href="#l29.1777"></a><span id="l29.1777" class="difflineminus">-      //  future, but only if we're going to perform another loop iteration.</span>
<a href="#l29.1778"></a><span id="l29.1778" class="difflineminus">-      if (haveMoreWork) {</span>
<a href="#l29.1779"></a><span id="l29.1779" class="difflineminus">-        notifyDecimator = (notifyDecimator + 1) % 32;</span>
<a href="#l29.1780"></a><span id="l29.1780" class="difflineminus">-        if (!notifyDecimator)</span>
<a href="#l29.1781"></a><span id="l29.1781" class="difflineminus">-          this._notifyListeners();</span>
<a href="#l29.1782"></a><span id="l29.1782" class="difflineminus">-</span>
<a href="#l29.1783"></a><span id="l29.1783" class="difflineminus">-        for (let pauseCount = 0;</span>
<a href="#l29.1784"></a><span id="l29.1784" class="difflineminus">-             pauseCount &lt; this._PAUSE_REPEAT_LIMIT;</span>
<a href="#l29.1785"></a><span id="l29.1785" class="difflineminus">-             pauseCount++) {</span>
<a href="#l29.1786"></a><span id="l29.1786" class="difflineminus">-          this._perfPauseStopwatch.start();</span>
<a href="#l29.1787"></a><span id="l29.1787" class="difflineminus">-</span>
<a href="#l29.1788"></a><span id="l29.1788" class="difflineminus">-          yield this.kWorkPause;</span>
<a href="#l29.1789"></a><span id="l29.1789" class="difflineminus">-</span>
<a href="#l29.1790"></a><span id="l29.1790" class="difflineminus">-          this._perfPauseStopwatch.stop();</span>
<a href="#l29.1791"></a><span id="l29.1791" class="difflineminus">-          // We repeat the pause if the pause was longer than</span>
<a href="#l29.1792"></a><span id="l29.1792" class="difflineminus">-          //  we expected, or if it used a significant amount</span>
<a href="#l29.1793"></a><span id="l29.1793" class="difflineminus">-          //  of cpu, either of which indicate significant other</span>
<a href="#l29.1794"></a><span id="l29.1794" class="difflineminus">-          //  activity.</span>
<a href="#l29.1795"></a><span id="l29.1795" class="difflineminus">-          if ((this._perfPauseStopwatch.cpuTimeSeconds * 1000 &lt;</span>
<a href="#l29.1796"></a><span id="l29.1796" class="difflineminus">-               this._CPU_IS_BUSY_TIME) &amp;&amp;</span>
<a href="#l29.1797"></a><span id="l29.1797" class="difflineminus">-              (this._perfPauseStopwatch.realTimeSeconds * 1000 -</span>
<a href="#l29.1798"></a><span id="l29.1798" class="difflineminus">-               this._INDEX_INTERVAL &lt; this._PAUSE_LATE_IS_BUSY_TIME))</span>
<a href="#l29.1799"></a><span id="l29.1799" class="difflineminus">-            break;</span>
<a href="#l29.1800"></a><span id="l29.1800" class="difflineminus">-        }</span>
<a href="#l29.1801"></a><span id="l29.1801" class="difflineminus">-      }</span>
<a href="#l29.1802"></a><span id="l29.1802" class="difflineminus">-      if (batchCount &gt; 0) {</span>
<a href="#l29.1803"></a><span id="l29.1803" class="difflineminus">-        let totalTime = this._perfIndexStopwatch.realTimeSeconds * 1000;</span>
<a href="#l29.1804"></a><span id="l29.1804" class="difflineminus">-        let timePerToken = totalTime / batchCount;</span>
<a href="#l29.1805"></a><span id="l29.1805" class="difflineminus">-        // Damp the average time since it is a rough estimate only.</span>
<a href="#l29.1806"></a><span id="l29.1806" class="difflineminus">-        this._cpuAverageTimePerToken =</span>
<a href="#l29.1807"></a><span id="l29.1807" class="difflineminus">-          (totalTime +</span>
<a href="#l29.1808"></a><span id="l29.1808" class="difflineminus">-           this._CPU_AVERAGE_TIME_DAMPING * this._cpuAverageTimePerToken) /</span>
<a href="#l29.1809"></a><span id="l29.1809" class="difflineminus">-          (batchCount + this._CPU_AVERAGE_TIME_DAMPING);</span>
<a href="#l29.1810"></a><span id="l29.1810" class="difflineminus">-        // We use the larger of the recent or the average time per token, so</span>
<a href="#l29.1811"></a><span id="l29.1811" class="difflineminus">-        //  that we can respond quickly to slow down indexing if there</span>
<a href="#l29.1812"></a><span id="l29.1812" class="difflineminus">-        //  is a sudden increase in time per token.</span>
<a href="#l29.1813"></a><span id="l29.1813" class="difflineminus">-        let bestTimePerToken =</span>
<a href="#l29.1814"></a><span id="l29.1814" class="difflineminus">-            Math.max(timePerToken, this._cpuAverageTimePerToken);</span>
<a href="#l29.1815"></a><span id="l29.1815" class="difflineminus">-        // Always index at least one token!</span>
<a href="#l29.1816"></a><span id="l29.1816" class="difflineminus">-        this._indexTokens =</span>
<a href="#l29.1817"></a><span id="l29.1817" class="difflineminus">-            Math.max(1, this._cpuTargetIndexTime / bestTimePerToken);</span>
<a href="#l29.1818"></a><span id="l29.1818" class="difflineminus">-        // But no more than the a maximum limit, just for sanity's sake.</span>
<a href="#l29.1819"></a><span id="l29.1819" class="difflineminus">-        this._indexTokens = Math.min(this._CPU_MAX_TOKENS_PER_BATCH,</span>
<a href="#l29.1820"></a><span id="l29.1820" class="difflineminus">-                                     this._indexTokens);</span>
<a href="#l29.1821"></a><span id="l29.1821" class="difflineminus">-        this._indexTokens = Math.ceil(this._indexTokens);</span>
<a href="#l29.1822"></a><span id="l29.1822" class="difflineminus">-      }</span>
<a href="#l29.1823"></a><span id="l29.1823" class="difflineminus">-</span>
<a href="#l29.1824"></a><span id="l29.1824" class="difflineminus">-      // Should we try to commit now?</span>
<a href="#l29.1825"></a><span id="l29.1825" class="difflineminus">-      let elapsed = Date.now() - this._lastCommitTime;</span>
<a href="#l29.1826"></a><span id="l29.1826" class="difflineminus">-      // Commit tends to cause a brief UI pause, so we try to delay it (but not</span>
<a href="#l29.1827"></a><span id="l29.1827" class="difflineminus">-      //  forever) if the user is active. If we're done and idling, we'll also</span>
<a href="#l29.1828"></a><span id="l29.1828" class="difflineminus">-      //  commit, otherwise we'll let the idle callback do it.</span>
<a href="#l29.1829"></a><span id="l29.1829" class="difflineminus">-      let doCommit = transactionToCommit &amp;&amp;</span>
<a href="#l29.1830"></a><span id="l29.1830" class="difflineminus">-                      (elapsed &gt; this._MAXIMUM_COMMIT_TIME) ||</span>
<a href="#l29.1831"></a><span id="l29.1831" class="difflineminus">-                      (inIdle &amp;&amp; (elapsed &gt; this._MINIMUM_COMMIT_TIME ||</span>
<a href="#l29.1832"></a><span id="l29.1832" class="difflineminus">-                                  !haveMoreWork));</span>
<a href="#l29.1833"></a><span id="l29.1833" class="difflineminus">-      if (doCommit) {</span>
<a href="#l29.1834"></a><span id="l29.1834" class="difflineminus">-        // XXX doing the dirty commit/check every time could be pretty expensive...</span>
<a href="#l29.1835"></a><span id="l29.1835" class="difflineminus">-        GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l29.1836"></a><span id="l29.1836" class="difflineminus">-        // Set up an async notification to happen after the commit completes so that</span>
<a href="#l29.1837"></a><span id="l29.1837" class="difflineminus">-        //  we can avoid the indexer doing something with the database that causes the</span>
<a href="#l29.1838"></a><span id="l29.1838" class="difflineminus">-        //  main thread to block against the completion of the commit (which can be</span>
<a href="#l29.1839"></a><span id="l29.1839" class="difflineminus">-        //  a while) on 1.9.1.</span>
<a href="#l29.1840"></a><span id="l29.1840" class="difflineminus">-        GlodaDatastore.runPostCommit(this._callbackHandle.wrappedCallback);</span>
<a href="#l29.1841"></a><span id="l29.1841" class="difflineminus">-        // kick off the commit</span>
<a href="#l29.1842"></a><span id="l29.1842" class="difflineminus">-        GlodaDatastore._commitTransaction();</span>
<a href="#l29.1843"></a><span id="l29.1843" class="difflineminus">-        yield this.kWorkAsync;</span>
<a href="#l29.1844"></a><span id="l29.1844" class="difflineminus">-        // Let's do the GC after the commit completes just so we can avoid having any</span>
<a href="#l29.1845"></a><span id="l29.1845" class="difflineminus">-        //  ugly interactions.</span>
<a href="#l29.1846"></a><span id="l29.1846" class="difflineminus">-        GlodaUtils.forceGarbageCollection(false);</span>
<a href="#l29.1847"></a><span id="l29.1847" class="difflineminus">-        this._lastCommitTime = Date.now();</span>
<a href="#l29.1848"></a><span id="l29.1848" class="difflineminus">-        // Restart the transaction if we still have work.</span>
<a href="#l29.1849"></a><span id="l29.1849" class="difflineminus">-        if (haveMoreWork)</span>
<a href="#l29.1850"></a><span id="l29.1850" class="difflineminus">-          GlodaDatastore._beginTransaction();</span>
<a href="#l29.1851"></a><span id="l29.1851" class="difflineminus">-        else</span>
<a href="#l29.1852"></a><span id="l29.1852" class="difflineminus">-          transactionToCommit = false;</span>
<a href="#l29.1853"></a><span id="l29.1853" class="difflineminus">-      }</span>
<a href="#l29.1854"></a><span id="l29.1854" class="difflineminus">-    }</span>
<a href="#l29.1855"></a><span id="l29.1855" class="difflineminus">-</span>
<a href="#l29.1856"></a><span id="l29.1856" class="difflineminus">-    // try and get a job if we don't have one for the sake of the notification</span>
<a href="#l29.1857"></a><span id="l29.1857" class="difflineminus">-    if (this.indexing &amp;&amp; (this._actualWorker === null))</span>
<a href="#l29.1858"></a><span id="l29.1858" class="difflineminus">-      this._hireJobWorker();</span>
<a href="#l29.1859"></a><span id="l29.1859" class="difflineminus">-    else</span>
<a href="#l29.1860"></a><span id="l29.1860" class="difflineminus">-      this._notifyListeners();</span>
<a href="#l29.1861"></a><span id="l29.1861" class="difflineminus">-</span>
<a href="#l29.1862"></a><span id="l29.1862" class="difflineminus">-    // If we still have a transaction to commit, tell idle to do the commit</span>
<a href="#l29.1863"></a><span id="l29.1863" class="difflineminus">-    //  when it gets around to it.</span>
<a href="#l29.1864"></a><span id="l29.1864" class="difflineminus">-    if (transactionToCommit)</span>
<a href="#l29.1865"></a><span id="l29.1865" class="difflineminus">-      this._idleToCommit = true;</span>
<a href="#l29.1866"></a><span id="l29.1866" class="difflineminus">-</span>
<a href="#l29.1867"></a><span id="l29.1867" class="difflineminus">-    yield this.kWorkDone;</span>
<a href="#l29.1868"></a><span id="l29.1868" class="difflineplus">+  initialSweep: function() {</span>
<a href="#l29.1869"></a><span id="l29.1869" class="difflineplus">+    this.indexingSweepNeeded = true;</span>
<a href="#l29.1870"></a><span id="l29.1870">   },</span>
<a href="#l29.1871"></a><span id="l29.1871"> </span>
<a href="#l29.1872"></a><span id="l29.1872" class="difflineminus">-  _otherIndexerWorkers: {},</span>
<a href="#l29.1873"></a><span id="l29.1873" class="difflineplus">+  _indexingSweepActive: false,</span>
<a href="#l29.1874"></a><span id="l29.1874">   /**</span>
<a href="#l29.1875"></a><span id="l29.1875" class="difflineminus">-   * Perform the initialization step and return a generator if there is any</span>
<a href="#l29.1876"></a><span id="l29.1876" class="difflineminus">-   *  steady-state processing to be had.</span>
<a href="#l29.1877"></a><span id="l29.1877" class="difflineplus">+   * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l29.1878"></a><span id="l29.1878" class="difflineplus">+   *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l29.1879"></a><span id="l29.1879" class="difflineplus">+   *  that we either can't process as an event or that we normally handle</span>
<a href="#l29.1880"></a><span id="l29.1880" class="difflineplus">+   *  during the sweep pass anyways.</span>
<a href="#l29.1881"></a><span id="l29.1881">    */</span>
<a href="#l29.1882"></a><span id="l29.1882" class="difflineminus">-  _hireJobWorker: function gloda_index_hireJobWorker() {</span>
<a href="#l29.1883"></a><span id="l29.1883" class="difflineminus">-    if (this._indexQueue.length == 0) {</span>
<a href="#l29.1884"></a><span id="l29.1884" class="difflineminus">-      this._log.info(&quot;--- Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l29.1885"></a><span id="l29.1885" class="difflineminus">-</span>
<a href="#l29.1886"></a><span id="l29.1886" class="difflineminus">-      if (this._indexingFolder !== null) {</span>
<a href="#l29.1887"></a><span id="l29.1887" class="difflineminus">-        this._indexerLeaveFolder(true);</span>
<a href="#l29.1888"></a><span id="l29.1888" class="difflineminus">-      }</span>
<a href="#l29.1889"></a><span id="l29.1889" class="difflineminus">-</span>
<a href="#l29.1890"></a><span id="l29.1890" class="difflineminus">-      this._curIndexingJob = null;</span>
<a href="#l29.1891"></a><span id="l29.1891" class="difflineminus">-      this._indexingDesired = false;</span>
<a href="#l29.1892"></a><span id="l29.1892" class="difflineminus">-      this._indexingJobCount = 0;</span>
<a href="#l29.1893"></a><span id="l29.1893" class="difflineminus">-      this._indexingJobGoal = 0;</span>
<a href="#l29.1894"></a><span id="l29.1894" class="difflineminus">-      return false;</span>
<a href="#l29.1895"></a><span id="l29.1895" class="difflineminus">-    }</span>
<a href="#l29.1896"></a><span id="l29.1896" class="difflineminus">-</span>
<a href="#l29.1897"></a><span id="l29.1897" class="difflineminus">-    //this._log.debug(&quot;++ Pulling job from queue of size &quot; +</span>
<a href="#l29.1898"></a><span id="l29.1898" class="difflineminus">-    //                this._indexQueue.length);</span>
<a href="#l29.1899"></a><span id="l29.1899" class="difflineminus">-    let job = this._curIndexingJob = this._indexQueue.shift();</span>
<a href="#l29.1900"></a><span id="l29.1900" class="difflineminus">-    this._indexingJobCount++;</span>
<a href="#l29.1901"></a><span id="l29.1901" class="difflineminus">-    //this._log.debug(&quot;++ Pulled job: &quot; + job.jobType + &quot;, &quot; +</span>
<a href="#l29.1902"></a><span id="l29.1902" class="difflineminus">-    //                job.deltaType + &quot;, &quot; + job.id);</span>
<a href="#l29.1903"></a><span id="l29.1903" class="difflineminus">-    let generator = null;</span>
<a href="#l29.1904"></a><span id="l29.1904" class="difflineminus">-</span>
<a href="#l29.1905"></a><span id="l29.1905" class="difflineminus">-    if (job.jobType == &quot;sweep&quot;) {</span>
<a href="#l29.1906"></a><span id="l29.1906" class="difflineminus">-      generator = this._worker_indexingSweep(job);</span>
<a href="#l29.1907"></a><span id="l29.1907" class="difflineplus">+  set indexingSweepNeeded(aNeeded) {</span>
<a href="#l29.1908"></a><span id="l29.1908" class="difflineplus">+    if (!this._indexingSweepActive &amp;&amp; aNeeded) {</span>
<a href="#l29.1909"></a><span id="l29.1909" class="difflineplus">+      let job = new IndexingJob(&quot;folderSweep&quot;, null);</span>
<a href="#l29.1910"></a><span id="l29.1910" class="difflineplus">+      job.mappedFolders = false;</span>
<a href="#l29.1911"></a><span id="l29.1911" class="difflineplus">+      GlodaIndexer.indexJob(job);</span>
<a href="#l29.1912"></a><span id="l29.1912" class="difflineplus">+      this._indexingSweepActive = true;</span>
<a href="#l29.1913"></a><span id="l29.1913">     }</span>
<a href="#l29.1914"></a><span id="l29.1914" class="difflineminus">-    else if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l29.1915"></a><span id="l29.1915" class="difflineminus">-      generator = this._worker_folderIndex(job);</span>
<a href="#l29.1916"></a><span id="l29.1916" class="difflineminus">-    }</span>
<a href="#l29.1917"></a><span id="l29.1917" class="difflineminus">-    else if(job.jobType == &quot;message&quot;) {</span>
<a href="#l29.1918"></a><span id="l29.1918" class="difflineminus">-      // we do not want new work items to be added as we are processing, so</span>
<a href="#l29.1919"></a><span id="l29.1919" class="difflineminus">-      //  clear _pendingAddJob.  A new job will be created as needed.</span>
<a href="#l29.1920"></a><span id="l29.1920" class="difflineminus">-      if (job === this._pendingAddJob)</span>
<a href="#l29.1921"></a><span id="l29.1921" class="difflineminus">-        this._pendingAddJob = null;</span>
<a href="#l29.1922"></a><span id="l29.1922" class="difflineminus">-      // update our goal from the items length</span>
<a href="#l29.1923"></a><span id="l29.1923" class="difflineminus">-      job.goal = job.items.length;</span>
<a href="#l29.1924"></a><span id="l29.1924" class="difflineminus">-</span>
<a href="#l29.1925"></a><span id="l29.1925" class="difflineminus">-      generator = this._worker_messageIndex(job);</span>
<a href="#l29.1926"></a><span id="l29.1926" class="difflineminus">-    }</span>
<a href="#l29.1927"></a><span id="l29.1927" class="difflineminus">-    else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l29.1928"></a><span id="l29.1928" class="difflineminus">-      // we'll count the block processing as a cost of 1...</span>
<a href="#l29.1929"></a><span id="l29.1929" class="difflineminus">-      job.goal = 1;</span>
<a href="#l29.1930"></a><span id="l29.1930" class="difflineminus">-      generator = this._worker_processDeletes(job);</span>
<a href="#l29.1931"></a><span id="l29.1931" class="difflineminus">-    }</span>
<a href="#l29.1932"></a><span id="l29.1932" class="difflineminus">-    else if (job.jobType in this._otherIndexerWorkers) {</span>
<a href="#l29.1933"></a><span id="l29.1933" class="difflineminus">-      let [indexer, workerFunc] = this._otherIndexerWorkers[job.jobType];</span>
<a href="#l29.1934"></a><span id="l29.1934" class="difflineminus">-      generator = workerFunc.call(indexer, job, this._callbackHandle);</span>
<a href="#l29.1935"></a><span id="l29.1935" class="difflineminus">-    }</span>
<a href="#l29.1936"></a><span id="l29.1936" class="difflineminus">-    else {</span>
<a href="#l29.1937"></a><span id="l29.1937" class="difflineminus">-      this._log.warn(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l29.1938"></a><span id="l29.1938" class="difflineminus">-    }</span>
<a href="#l29.1939"></a><span id="l29.1939" class="difflineminus">-</span>
<a href="#l29.1940"></a><span id="l29.1940" class="difflineminus">-    this._notifyListeners();</span>
<a href="#l29.1941"></a><span id="l29.1941" class="difflineminus">-</span>
<a href="#l29.1942"></a><span id="l29.1942" class="difflineminus">-    if (generator) {</span>
<a href="#l29.1943"></a><span id="l29.1943" class="difflineminus">-      this._callbackHandle.push(generator);</span>
<a href="#l29.1944"></a><span id="l29.1944" class="difflineminus">-      return true;</span>
<a href="#l29.1945"></a><span id="l29.1945" class="difflineminus">-    }</span>
<a href="#l29.1946"></a><span id="l29.1946" class="difflineminus">-    else</span>
<a href="#l29.1947"></a><span id="l29.1947" class="difflineminus">-      return false;</span>
<a href="#l29.1948"></a><span id="l29.1948">   },</span>
<a href="#l29.1949"></a><span id="l29.1949"> </span>
<a href="#l29.1950"></a><span id="l29.1950">   /**</span>
<a href="#l29.1951"></a><span id="l29.1951">    * Performs the folder sweep, locating folders that should be indexed, and</span>
<a href="#l29.1952"></a><span id="l29.1952">    *  creating a folder indexing job for them, and rescheduling itself for</span>
<a href="#l29.1953"></a><span id="l29.1953">    *  execution after that job is completed.  Once it indexes all the folders,</span>
<a href="#l29.1954"></a><span id="l29.1954">    *  if we believe we have deletions to process (or just don't know), it kicks</span>
<a href="#l29.1955"></a><span id="l29.1955">    *  off a deletion processing job.</span>
<a href="#l29.1956"></a><span id="l29.1956" class="difflineat">@@ -1653,274 +885,643 @@ var GlodaIndexer = {</span>
<a href="#l29.1957"></a><span id="l29.1957">         rootFolder.ListDescendents(allFolders);</span>
<a href="#l29.1958"></a><span id="l29.1958">         let numFolders = allFolders.Count();</span>
<a href="#l29.1959"></a><span id="l29.1959">         for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++) {</span>
<a href="#l29.1960"></a><span id="l29.1960">           let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l29.1961"></a><span id="l29.1961">             Ci.nsIMsgFolder);</span>
<a href="#l29.1962"></a><span id="l29.1962">           if (!this.shouldIndexFolder(folder))</span>
<a href="#l29.1963"></a><span id="l29.1963">             continue;</span>
<a href="#l29.1964"></a><span id="l29.1964"> </span>
<a href="#l29.1965"></a><span id="l29.1965" class="difflineminus">-          // we only index local or IMAP folders</span>
<a href="#l29.1966"></a><span id="l29.1966" class="difflineminus">-          if (!(folder instanceof Ci.nsIMsgLocalMailFolder) &amp;&amp;</span>
<a href="#l29.1967"></a><span id="l29.1967" class="difflineminus">-              !(folder instanceof Ci.nsIMsgImapMailFolder))</span>
<a href="#l29.1968"></a><span id="l29.1968" class="difflineminus">-            continue;</span>
<a href="#l29.1969"></a><span id="l29.1969" class="difflineminus">-</span>
<a href="#l29.1970"></a><span id="l29.1970" class="difflineminus">-          let glodaFolder = Gloda.getFolderForFolder(folder);</span>
<a href="#l29.1971"></a><span id="l29.1971" class="difflineminus">-          if (glodaFolder.indexingPriority !=</span>
<a href="#l29.1972"></a><span id="l29.1972" class="difflineminus">-              glodaFolder.kIndexingNeverPriority)</span>
<a href="#l29.1973"></a><span id="l29.1973" class="difflineminus">-            foldersToProcess.push(glodaFolder);</span>
<a href="#l29.1974"></a><span id="l29.1974" class="difflineplus">+          foldersToProcess.push(Gloda.getFolderForFolder(folder));</span>
<a href="#l29.1975"></a><span id="l29.1975">         }</span>
<a href="#l29.1976"></a><span id="l29.1976">       }</span>
<a href="#l29.1977"></a><span id="l29.1977"> </span>
<a href="#l29.1978"></a><span id="l29.1978">       // sort the folders by priority (descending)</span>
<a href="#l29.1979"></a><span id="l29.1979">       foldersToProcess.sort(function (a, b) {</span>
<a href="#l29.1980"></a><span id="l29.1980">         return b.indexingPriority - a.indexingPriority;</span>
<a href="#l29.1981"></a><span id="l29.1981">       });</span>
<a href="#l29.1982"></a><span id="l29.1982"> </span>
<a href="#l29.1983"></a><span id="l29.1983">       aJob.mappedFolders = true;</span>
<a href="#l29.1984"></a><span id="l29.1984">     }</span>
<a href="#l29.1985"></a><span id="l29.1985"> </span>
<a href="#l29.1986"></a><span id="l29.1986">     // - process the folders (in sorted order)</span>
<a href="#l29.1987"></a><span id="l29.1987">     while (aJob.foldersToProcess.length) {</span>
<a href="#l29.1988"></a><span id="l29.1988">       let glodaFolder = aJob.foldersToProcess.shift();</span>
<a href="#l29.1989"></a><span id="l29.1989" class="difflineminus">-      if (glodaFolder._deleted || !glodaFolder.dirtyStatus)</span>
<a href="#l29.1990"></a><span id="l29.1990" class="difflineplus">+      // ignore folders that:</span>
<a href="#l29.1991"></a><span id="l29.1991" class="difflineplus">+      // - have been deleted out of existence!</span>
<a href="#l29.1992"></a><span id="l29.1992" class="difflineplus">+      // - are not dirty</span>
<a href="#l29.1993"></a><span id="l29.1993" class="difflineplus">+      // - are actively being compacted</span>
<a href="#l29.1994"></a><span id="l29.1994" class="difflineplus">+      if (glodaFolder._deleted || !glodaFolder.dirtyStatus ||</span>
<a href="#l29.1995"></a><span id="l29.1995" class="difflineplus">+          glodaFolder.compacting)</span>
<a href="#l29.1996"></a><span id="l29.1996">         continue;</span>
<a href="#l29.1997"></a><span id="l29.1997"> </span>
<a href="#l29.1998"></a><span id="l29.1998" class="difflineminus">-      this._indexingJobGoal += 2;</span>
<a href="#l29.1999"></a><span id="l29.1999">       // add a job for the folder indexing</span>
<a href="#l29.2000"></a><span id="l29.2000" class="difflineminus">-      this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 0, glodaFolder.id));</span>
<a href="#l29.2001"></a><span id="l29.2001" class="difflineplus">+      GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l29.2002"></a><span id="l29.2002">       // re-schedule this job (although this worker will die)</span>
<a href="#l29.2003"></a><span id="l29.2003" class="difflineminus">-      this._indexQueue.push(aJob);</span>
<a href="#l29.2004"></a><span id="l29.2004" class="difflineplus">+      GlodaIndexer.indexJob(aJob);</span>
<a href="#l29.2005"></a><span id="l29.2005">       yield this.kWorkDone;</span>
<a href="#l29.2006"></a><span id="l29.2006">     }</span>
<a href="#l29.2007"></a><span id="l29.2007"> </span>
<a href="#l29.2008"></a><span id="l29.2008">     // consider deletion</span>
<a href="#l29.2009"></a><span id="l29.2009" class="difflineminus">-    if (this.pendingDeletion || this.pendingDeletion === null) {</span>
<a href="#l29.2010"></a><span id="l29.2010" class="difflineminus">-      this._indexingJobGoal++;</span>
<a href="#l29.2011"></a><span id="l29.2011" class="difflineminus">-      this._indexQueue.push(new IndexingJob(&quot;delete&quot;, 0, null));</span>
<a href="#l29.2012"></a><span id="l29.2012" class="difflineminus">-      // no need to set this.indexing to true, it must be true if we are here.</span>
<a href="#l29.2013"></a><span id="l29.2013" class="difflineminus">-    }</span>
<a href="#l29.2014"></a><span id="l29.2014" class="difflineminus">-</span>
<a href="#l29.2015"></a><span id="l29.2015" class="difflineminus">-    // if this is our first sweep, give the other indexers a chance to do their</span>
<a href="#l29.2016"></a><span id="l29.2016" class="difflineminus">-    //  own initial sweep.  it's on them to schedule their own job if they have</span>
<a href="#l29.2017"></a><span id="l29.2017" class="difflineminus">-    //  a lot to do, but if they only have a little to do, they can get away</span>
<a href="#l29.2018"></a><span id="l29.2018" class="difflineminus">-    //  with it, as we yield a sync after each one.</span>
<a href="#l29.2019"></a><span id="l29.2019" class="difflineminus">-    if (!this._initialSweepPerformed) {</span>
<a href="#l29.2020"></a><span id="l29.2020" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l29.2021"></a><span id="l29.2021" class="difflineminus">-        try {</span>
<a href="#l29.2022"></a><span id="l29.2022" class="difflineminus">-          indexer.initialSweep();</span>
<a href="#l29.2023"></a><span id="l29.2023" class="difflineminus">-        }</span>
<a href="#l29.2024"></a><span id="l29.2024" class="difflineminus">-        catch (ex) {</span>
<a href="#l29.2025"></a><span id="l29.2025" class="difflineminus">-          this._log.warn(&quot;Helper indexer threw exception on initial sweep:&quot; +</span>
<a href="#l29.2026"></a><span id="l29.2026" class="difflineminus">-                         ex);</span>
<a href="#l29.2027"></a><span id="l29.2027" class="difflineminus">-        }</span>
<a href="#l29.2028"></a><span id="l29.2028" class="difflineminus">-        yield this.kWorkSync;</span>
<a href="#l29.2029"></a><span id="l29.2029" class="difflineminus">-      }</span>
<a href="#l29.2030"></a><span id="l29.2030" class="difflineminus">-      this._initialSweepPerformed = true;</span>
<a href="#l29.2031"></a><span id="l29.2031" class="difflineminus">-    }</span>
<a href="#l29.2032"></a><span id="l29.2032" class="difflineplus">+    if (this.pendingDeletions || this.pendingDeletions === null)</span>
<a href="#l29.2033"></a><span id="l29.2033" class="difflineplus">+      GlodaIndexer.indexJob(new IndexingJob(&quot;delete&quot;, null));</span>
<a href="#l29.2034"></a><span id="l29.2034"> </span>
<a href="#l29.2035"></a><span id="l29.2035">     // we don't have any more work to do...</span>
<a href="#l29.2036"></a><span id="l29.2036">     this._indexingSweepActive = false;</span>
<a href="#l29.2037"></a><span id="l29.2037">     yield this.kWorkDone;</span>
<a href="#l29.2038"></a><span id="l29.2038">   },</span>
<a href="#l29.2039"></a><span id="l29.2039"> </span>
<a href="#l29.2040"></a><span id="l29.2040">   /**</span>
<a href="#l29.2041"></a><span id="l29.2041" class="difflineplus">+   * The number of headers to look at before yielding with kWorkSync.  This</span>
<a href="#l29.2042"></a><span id="l29.2042" class="difflineplus">+   *  is for time-slicing purposes so we still yield to the UI periodically.</span>
<a href="#l29.2043"></a><span id="l29.2043" class="difflineplus">+   */</span>
<a href="#l29.2044"></a><span id="l29.2044" class="difflineplus">+  HEADER_CHECK_SYNC_BLOCK_SIZE: 25,</span>
<a href="#l29.2045"></a><span id="l29.2045" class="difflineplus">+</span>
<a href="#l29.2046"></a><span id="l29.2046" class="difflineplus">+  /**</span>
<a href="#l29.2047"></a><span id="l29.2047" class="difflineplus">+   * The number of headers to look at before calling</span>
<a href="#l29.2048"></a><span id="l29.2048" class="difflineplus">+   */</span>
<a href="#l29.2049"></a><span id="l29.2049" class="difflineplus">+  HEADER_CHECK_GC_BLOCK_SIZE: 256,</span>
<a href="#l29.2050"></a><span id="l29.2050" class="difflineplus">+</span>
<a href="#l29.2051"></a><span id="l29.2051" class="difflineplus">+  FOLDER_COMPACTION_PASS_BATCH_SIZE: 512,</span>
<a href="#l29.2052"></a><span id="l29.2052" class="difflineplus">+  /**</span>
<a href="#l29.2053"></a><span id="l29.2053" class="difflineplus">+   * Special indexing pass for (local) folders than have been compacted.  The</span>
<a href="#l29.2054"></a><span id="l29.2054" class="difflineplus">+   *  compaction can cause message keys to change because message keys in local</span>
<a href="#l29.2055"></a><span id="l29.2055" class="difflineplus">+   *  folders are simply offsets into the mbox file.  Accordingly, we need to</span>
<a href="#l29.2056"></a><span id="l29.2056" class="difflineplus">+   *  update the gloda records/objects to point them at the new message key.</span>
<a href="#l29.2057"></a><span id="l29.2057" class="difflineplus">+   *</span>
<a href="#l29.2058"></a><span id="l29.2058" class="difflineplus">+   * Our general algorithm is to perform two traversals in parallel.  The first</span>
<a href="#l29.2059"></a><span id="l29.2059" class="difflineplus">+   *  is a straightforward enumeration of the message headers in the folder that</span>
<a href="#l29.2060"></a><span id="l29.2060" class="difflineplus">+   *  apparently have been already indexed.  These provide us with the message</span>
<a href="#l29.2061"></a><span id="l29.2061" class="difflineplus">+   *  key and the &quot;gloda-id&quot; property.</span>
<a href="#l29.2062"></a><span id="l29.2062" class="difflineplus">+   * The second is a list of tuples containing a gloda message id, its current</span>
<a href="#l29.2063"></a><span id="l29.2063" class="difflineplus">+   *  message key per the gloda database, and the message-id header.  We re-fill</span>
<a href="#l29.2064"></a><span id="l29.2064" class="difflineplus">+   *  the list with batches on-demand.  This allows us to both avoid dispatching</span>
<a href="#l29.2065"></a><span id="l29.2065" class="difflineplus">+   *  needless UPDATEs as well as deal with messages that were tracked by the</span>
<a href="#l29.2066"></a><span id="l29.2066" class="difflineplus">+   *  PendingCommitTracker but were discarded by the compaction notification.</span>
<a href="#l29.2067"></a><span id="l29.2067" class="difflineplus">+   *</span>
<a href="#l29.2068"></a><span id="l29.2068" class="difflineplus">+   * We end up processing two streams of gloda-id's and some extra info.  In</span>
<a href="#l29.2069"></a><span id="l29.2069" class="difflineplus">+   *  the normal case we expect these two streams to line up exactly and all</span>
<a href="#l29.2070"></a><span id="l29.2070" class="difflineplus">+   *  we need to do is update the message key if it has changed.</span>
<a href="#l29.2071"></a><span id="l29.2071" class="difflineplus">+   * The expected exceptional case is that we will sometimes see a gloda-id from</span>
<a href="#l29.2072"></a><span id="l29.2072" class="difflineplus">+   *  the gloda database that does not have a corresponding header from the</span>
<a href="#l29.2073"></a><span id="l29.2073" class="difflineplus">+   *  nsIMsgDBHdr-producing enumerator.  In this case we assume the message was</span>
<a href="#l29.2074"></a><span id="l29.2074" class="difflineplus">+   *  indexed and tracked by the PendingCommitTracker but got purged by the</span>
<a href="#l29.2075"></a><span id="l29.2075" class="difflineplus">+   *  compaction.  Since we have the message-id header for the gloda message</span>
<a href="#l29.2076"></a><span id="l29.2076" class="difflineplus">+   *  we are able to ask the nsIMsgDatabase for the matching message and mark</span>
<a href="#l29.2077"></a><span id="l29.2077" class="difflineplus">+   *  the header with the gloda-id using the PendingCommitTracker.  (We are</span>
<a href="#l29.2078"></a><span id="l29.2078" class="difflineplus">+   *  unable to verify that the information has been committed so we need to</span>
<a href="#l29.2079"></a><span id="l29.2079" class="difflineplus">+   *  wait on the commit again to mark it.)  Although the lookup is O(n)</span>
<a href="#l29.2080"></a><span id="l29.2080" class="difflineplus">+   *  it is native on the in-memory mork database and is far more preferable</span>
<a href="#l29.2081"></a><span id="l29.2081" class="difflineplus">+   *  than using an unfiltered iterator in the normal case as well.</span>
<a href="#l29.2082"></a><span id="l29.2082" class="difflineplus">+   * The unexpected exceptional case is that we will see a gloda-id from the</span>
<a href="#l29.2083"></a><span id="l29.2083" class="difflineplus">+   *  enumerator that has no corresponding entry in the actual database.</span>
<a href="#l29.2084"></a><span id="l29.2084" class="difflineplus">+   *  This should not happen.  We are able to differentiate this case from the</span>
<a href="#l29.2085"></a><span id="l29.2085" class="difflineplus">+   *  previous case by always checking for a message given its message-id</span>
<a href="#l29.2086"></a><span id="l29.2086" class="difflineplus">+   *  header value when we experience a gloda-id mis-match.  In all cases we</span>
<a href="#l29.2087"></a><span id="l29.2087" class="difflineplus">+   *  should be able to locate a message header with the message-id.  If</span>
<a href="#l29.2088"></a><span id="l29.2088" class="difflineplus">+   *  the message header's messageKey is greater than that of the enumerator's</span>
<a href="#l29.2089"></a><span id="l29.2089" class="difflineplus">+   *  header then we know we are in the unexpected case.  (It implies an</span>
<a href="#l29.2090"></a><span id="l29.2090" class="difflineplus">+   *  insertion in the enumerator stream which is how we define the unexpected</span>
<a href="#l29.2091"></a><span id="l29.2091" class="difflineplus">+   *  case.)  If the opposite is true, then that implies the enumerator skipped</span>
<a href="#l29.2092"></a><span id="l29.2092" class="difflineplus">+   *  over the message header because it never got marked by the</span>
<a href="#l29.2093"></a><span id="l29.2093" class="difflineplus">+   *  PendingCommitTracker which is the expected case.</span>
<a href="#l29.2094"></a><span id="l29.2094" class="difflineplus">+   *</span>
<a href="#l29.2095"></a><span id="l29.2095" class="difflineplus">+   * Besides updating the database rows, we also need to make sure that</span>
<a href="#l29.2096"></a><span id="l29.2096" class="difflineplus">+   *  in-memory representations are updated.  Immediately after dispatching</span>
<a href="#l29.2097"></a><span id="l29.2097" class="difflineplus">+   *  UPDATE changes to the database we use the same set of data to walk the</span>
<a href="#l29.2098"></a><span id="l29.2098" class="difflineplus">+   *  live collections and update any affected messages.  We are then able to</span>
<a href="#l29.2099"></a><span id="l29.2099" class="difflineplus">+   *  discard the information.  Although this means that we will have to</span>
<a href="#l29.2100"></a><span id="l29.2100" class="difflineplus">+   *  potentially walk the live collections multiple times, unless something</span>
<a href="#l29.2101"></a><span id="l29.2101" class="difflineplus">+   *  has gone horribly wrong, the number of collections should be reasonable</span>
<a href="#l29.2102"></a><span id="l29.2102" class="difflineplus">+   *  and the lookups are cheap.  We bias batch sizes accordingly.</span>
<a href="#l29.2103"></a><span id="l29.2103" class="difflineplus">+   *</span>
<a href="#l29.2104"></a><span id="l29.2104" class="difflineplus">+   * Because we operate based on chunks we need to make sure that when we</span>
<a href="#l29.2105"></a><span id="l29.2105" class="difflineplus">+   *  actually deal with multiple chunks that we don't step on our own feet with</span>
<a href="#l29.2106"></a><span id="l29.2106" class="difflineplus">+   *  our database updates.  Since compaction of message key K results in a new</span>
<a href="#l29.2107"></a><span id="l29.2107" class="difflineplus">+   *  message key K' such that K' &lt;= K, we can reliably issue database</span>
<a href="#l29.2108"></a><span id="l29.2108" class="difflineplus">+   *  updates for all values &lt;= K.  Which means our feet are safe no matter</span>
<a href="#l29.2109"></a><span id="l29.2109" class="difflineplus">+   *  when we issue the update command.  For maximum cache benefit, we issue</span>
<a href="#l29.2110"></a><span id="l29.2110" class="difflineplus">+   *  our updates prior to our new query since they should still be maximally</span>
<a href="#l29.2111"></a><span id="l29.2111" class="difflineplus">+   *  hot at that point.</span>
<a href="#l29.2112"></a><span id="l29.2112" class="difflineplus">+   */</span>
<a href="#l29.2113"></a><span id="l29.2113" class="difflineplus">+  _worker_folderCompactionPass:</span>
<a href="#l29.2114"></a><span id="l29.2114" class="difflineplus">+      function gloda_worker_folderCompactionPass(aJob, aCallbackHandle) {</span>
<a href="#l29.2115"></a><span id="l29.2115" class="difflineplus">+    yield this._indexerEnterFolder(aJob.id);</span>
<a href="#l29.2116"></a><span id="l29.2116" class="difflineplus">+    this._indexerGetEnumerator(this.kEnumIndexedMsgs);</span>
<a href="#l29.2117"></a><span id="l29.2117" class="difflineplus">+</span>
<a href="#l29.2118"></a><span id="l29.2118" class="difflineplus">+    const HEADER_CHECK_SYNC_BLOCK_SIZE = this.HEADER_CHECK_SYNC_BLOCK_SIZE;</span>
<a href="#l29.2119"></a><span id="l29.2119" class="difflineplus">+    const HEADER_CHECK_GC_BLOCK_SIZE = this.HEADER_CHECK_GC_BLOCK_SIZE;</span>
<a href="#l29.2120"></a><span id="l29.2120" class="difflineplus">+    const FOLDER_COMPACTION_PASS_BATCH_SIZE =</span>
<a href="#l29.2121"></a><span id="l29.2121" class="difflineplus">+      this.FOLDER_COMPACTION_PASS_BATCH_SIZE;</span>
<a href="#l29.2122"></a><span id="l29.2122" class="difflineplus">+</span>
<a href="#l29.2123"></a><span id="l29.2123" class="difflineplus">+    // Tuples of [gloda id, message key, message-id header] from</span>
<a href="#l29.2124"></a><span id="l29.2124" class="difflineplus">+    //  folderCompactionPassBlockFetch</span>
<a href="#l29.2125"></a><span id="l29.2125" class="difflineplus">+    let glodaIdsMsgKeysHeaderIds = [];</span>
<a href="#l29.2126"></a><span id="l29.2126" class="difflineplus">+    // Unpack each tuple from glodaIdsMsgKeysHeaderIds into these guys.</span>
<a href="#l29.2127"></a><span id="l29.2127" class="difflineplus">+    // (Initialize oldMessageKey because we use it to kickstart our query.)</span>
<a href="#l29.2128"></a><span id="l29.2128" class="difflineplus">+    let oldGlodaId, oldMessageKey = -1, oldHeaderMessageId;</span>
<a href="#l29.2129"></a><span id="l29.2129" class="difflineplus">+    // parallel lists of gloda ids and message keys to pass to</span>
<a href="#l29.2130"></a><span id="l29.2130" class="difflineplus">+    //  GlodaDatastore.updateMessageLocations</span>
<a href="#l29.2131"></a><span id="l29.2131" class="difflineplus">+    let updateGlodaIds = [];</span>
<a href="#l29.2132"></a><span id="l29.2132" class="difflineplus">+    let updateMessageKeys = [];</span>
<a href="#l29.2133"></a><span id="l29.2133" class="difflineplus">+    let exceptionalMessages = {};</span>
<a href="#l29.2134"></a><span id="l29.2134" class="difflineplus">+</span>
<a href="#l29.2135"></a><span id="l29.2135" class="difflineplus">+    // for GC reasons we need to track the number of headers seen</span>
<a href="#l29.2136"></a><span id="l29.2136" class="difflineplus">+    let numHeadersSeen = 0;</span>
<a href="#l29.2137"></a><span id="l29.2137" class="difflineplus">+</span>
<a href="#l29.2138"></a><span id="l29.2138" class="difflineplus">+    // We are consuming two lists; our loop structure has to reflect that.</span>
<a href="#l29.2139"></a><span id="l29.2139" class="difflineplus">+    let headerIter = Iterator(fixIterator(this._indexingEnumerator,</span>
<a href="#l29.2140"></a><span id="l29.2140" class="difflineplus">+                                          nsIMsgDBHdr));</span>
<a href="#l29.2141"></a><span id="l29.2141" class="difflineplus">+    let mayHaveMoreGlodaMessages = true;</span>
<a href="#l29.2142"></a><span id="l29.2142" class="difflineplus">+    let keepIterHeader = false;</span>
<a href="#l29.2143"></a><span id="l29.2143" class="difflineplus">+    let keepGlodaTuple = false;</span>
<a href="#l29.2144"></a><span id="l29.2144" class="difflineplus">+    let msgHdr = null;</span>
<a href="#l29.2145"></a><span id="l29.2145" class="difflineplus">+    while (headerIter || mayHaveMoreGlodaMessages) {</span>
<a href="#l29.2146"></a><span id="l29.2146" class="difflineplus">+      let glodaId;</span>
<a href="#l29.2147"></a><span id="l29.2147" class="difflineplus">+      if (headerIter) {</span>
<a href="#l29.2148"></a><span id="l29.2148" class="difflineplus">+        try {</span>
<a href="#l29.2149"></a><span id="l29.2149" class="difflineplus">+          if (!keepIterHeader)</span>
<a href="#l29.2150"></a><span id="l29.2150" class="difflineplus">+            msgHdr = headerIter.next();</span>
<a href="#l29.2151"></a><span id="l29.2151" class="difflineplus">+          else</span>
<a href="#l29.2152"></a><span id="l29.2152" class="difflineplus">+            keepIterHeader = false;</span>
<a href="#l29.2153"></a><span id="l29.2153" class="difflineplus">+        }</span>
<a href="#l29.2154"></a><span id="l29.2154" class="difflineplus">+        catch (ex if ex instanceof StopIteration) {</span>
<a href="#l29.2155"></a><span id="l29.2155" class="difflineplus">+          headerIter = null;</span>
<a href="#l29.2156"></a><span id="l29.2156" class="difflineplus">+          msgHdr = null;</span>
<a href="#l29.2157"></a><span id="l29.2157" class="difflineplus">+          // do the loop check again</span>
<a href="#l29.2158"></a><span id="l29.2158" class="difflineplus">+          continue;</span>
<a href="#l29.2159"></a><span id="l29.2159" class="difflineplus">+        }</span>
<a href="#l29.2160"></a><span id="l29.2160" class="difflineplus">+      }</span>
<a href="#l29.2161"></a><span id="l29.2161" class="difflineplus">+</span>
<a href="#l29.2162"></a><span id="l29.2162" class="difflineplus">+      if (msgHdr) {</span>
<a href="#l29.2163"></a><span id="l29.2163" class="difflineplus">+        numHeadersSeen++;</span>
<a href="#l29.2164"></a><span id="l29.2164" class="difflineplus">+        if (numHeadersSeen % HEADER_CHECK_SYNC_BLOCK_SIZE == 0)</span>
<a href="#l29.2165"></a><span id="l29.2165" class="difflineplus">+          yield this.kWorkSync;</span>
<a href="#l29.2166"></a><span id="l29.2166" class="difflineplus">+</span>
<a href="#l29.2167"></a><span id="l29.2167" class="difflineplus">+        if (numHeadersSeen % HEADER_CHECK_GC_BLOCK_SIZE == 0)</span>
<a href="#l29.2168"></a><span id="l29.2168" class="difflineplus">+          GlodaUtils.considerHeaderBasedGC(HEADER_CHECK_GC_BLOCK_SIZE);</span>
<a href="#l29.2169"></a><span id="l29.2169" class="difflineplus">+</span>
<a href="#l29.2170"></a><span id="l29.2170" class="difflineplus">+        // There is no need to check with PendingCommitTracker.  If a message</span>
<a href="#l29.2171"></a><span id="l29.2171" class="difflineplus">+        //  somehow got indexed between the time the compaction killed</span>
<a href="#l29.2172"></a><span id="l29.2172" class="difflineplus">+        //  everything and the time we run, that is a bug.</span>
<a href="#l29.2173"></a><span id="l29.2173" class="difflineplus">+        glodaId = msgHdr.getUint32Property(GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.2174"></a><span id="l29.2174" class="difflineplus">+        // (there is also no need to check for gloda dirty since the enumerator</span>
<a href="#l29.2175"></a><span id="l29.2175" class="difflineplus">+        //  filtered that for us.)</span>
<a href="#l29.2176"></a><span id="l29.2176" class="difflineplus">+      }</span>
<a href="#l29.2177"></a><span id="l29.2177" class="difflineplus">+</span>
<a href="#l29.2178"></a><span id="l29.2178" class="difflineplus">+      // get more [gloda id, message key, message-id header] tuples if out</span>
<a href="#l29.2179"></a><span id="l29.2179" class="difflineplus">+      if (!glodaIdsMsgKeysHeaderIds.length &amp;&amp; mayHaveMoreGlodaMessages) {</span>
<a href="#l29.2180"></a><span id="l29.2180" class="difflineplus">+        // Since we operate on blocks, getting a new block implies we should</span>
<a href="#l29.2181"></a><span id="l29.2181" class="difflineplus">+        //  flush the last block if applicable.</span>
<a href="#l29.2182"></a><span id="l29.2182" class="difflineplus">+        if (updateGlodaIds.length) {</span>
<a href="#l29.2183"></a><span id="l29.2183" class="difflineplus">+          GlodaDatastore.updateMessageLocations(updateGlodaIds,</span>
<a href="#l29.2184"></a><span id="l29.2184" class="difflineplus">+                                                updateMessageKeys,</span>
<a href="#l29.2185"></a><span id="l29.2185" class="difflineplus">+                                                aJob.id, true);</span>
<a href="#l29.2186"></a><span id="l29.2186" class="difflineplus">+          updateGlodaIds = [];</span>
<a href="#l29.2187"></a><span id="l29.2187" class="difflineplus">+          updateMessageKeys = [];</span>
<a href="#l29.2188"></a><span id="l29.2188" class="difflineplus">+        }</span>
<a href="#l29.2189"></a><span id="l29.2189" class="difflineplus">+</span>
<a href="#l29.2190"></a><span id="l29.2190" class="difflineplus">+        GlodaDatastore.folderCompactionPassBlockFetch(</span>
<a href="#l29.2191"></a><span id="l29.2191" class="difflineplus">+          aJob.id, oldMessageKey + 1, FOLDER_COMPACTION_PASS_BATCH_SIZE,</span>
<a href="#l29.2192"></a><span id="l29.2192" class="difflineplus">+          aCallbackHandle.wrappedCallback);</span>
<a href="#l29.2193"></a><span id="l29.2193" class="difflineplus">+        glodaIdsMsgKeysHeaderIds = yield this.kWorkAsync;</span>
<a href="#l29.2194"></a><span id="l29.2194" class="difflineplus">+        // Reverse so we can use pop instead of shift and I don't need to be</span>
<a href="#l29.2195"></a><span id="l29.2195" class="difflineplus">+        //  paranoid about performance.</span>
<a href="#l29.2196"></a><span id="l29.2196" class="difflineplus">+        glodaIdsMsgKeysHeaderIds.reverse();</span>
<a href="#l29.2197"></a><span id="l29.2197" class="difflineplus">+</span>
<a href="#l29.2198"></a><span id="l29.2198" class="difflineplus">+        if (!glodaIdsMsgKeysHeaderIds.length) {</span>
<a href="#l29.2199"></a><span id="l29.2199" class="difflineplus">+          mayHaveMoreGlodaMessages = false;</span>
<a href="#l29.2200"></a><span id="l29.2200" class="difflineplus">+</span>
<a href="#l29.2201"></a><span id="l29.2201" class="difflineplus">+          // We shouldn't be in the loop anymore if headerIter is dead now.</span>
<a href="#l29.2202"></a><span id="l29.2202" class="difflineplus">+          if (!headerIter)</span>
<a href="#l29.2203"></a><span id="l29.2203" class="difflineplus">+            break;</span>
<a href="#l29.2204"></a><span id="l29.2204" class="difflineplus">+        }</span>
<a href="#l29.2205"></a><span id="l29.2205" class="difflineplus">+      }</span>
<a href="#l29.2206"></a><span id="l29.2206" class="difflineplus">+</span>
<a href="#l29.2207"></a><span id="l29.2207" class="difflineplus">+      if (!keepGlodaTuple) {</span>
<a href="#l29.2208"></a><span id="l29.2208" class="difflineplus">+        if (mayHaveMoreGlodaMessages)</span>
<a href="#l29.2209"></a><span id="l29.2209" class="difflineplus">+          [oldGlodaId, oldMessageKey, oldHeaderMessageId] =</span>
<a href="#l29.2210"></a><span id="l29.2210" class="difflineplus">+            glodaIdsMsgKeysHeaderIds.pop();</span>
<a href="#l29.2211"></a><span id="l29.2211" class="difflineplus">+        else</span>
<a href="#l29.2212"></a><span id="l29.2212" class="difflineplus">+          oldGlodaId = oldMessageKey = oldHeaderMessageId = null;</span>
<a href="#l29.2213"></a><span id="l29.2213" class="difflineplus">+      }</span>
<a href="#l29.2214"></a><span id="l29.2214" class="difflineplus">+      else {</span>
<a href="#l29.2215"></a><span id="l29.2215" class="difflineplus">+        keepGlodaTuple = false;</span>
<a href="#l29.2216"></a><span id="l29.2216" class="difflineplus">+      }</span>
<a href="#l29.2217"></a><span id="l29.2217" class="difflineplus">+</span>
<a href="#l29.2218"></a><span id="l29.2218" class="difflineplus">+      // normal expected case</span>
<a href="#l29.2219"></a><span id="l29.2219" class="difflineplus">+      if (glodaId == oldGlodaId) {</span>
<a href="#l29.2220"></a><span id="l29.2220" class="difflineplus">+        // only need to do something if the key is not right</span>
<a href="#l29.2221"></a><span id="l29.2221" class="difflineplus">+        if (msgHdr.messageKey != oldMessageKey) {</span>
<a href="#l29.2222"></a><span id="l29.2222" class="difflineplus">+          updateGlodaIds.push(glodaId);</span>
<a href="#l29.2223"></a><span id="l29.2223" class="difflineplus">+          updateMessageKeys.push(msgHdr.messageKey);</span>
<a href="#l29.2224"></a><span id="l29.2224" class="difflineplus">+        }</span>
<a href="#l29.2225"></a><span id="l29.2225" class="difflineplus">+      }</span>
<a href="#l29.2226"></a><span id="l29.2226" class="difflineplus">+      // exceptional case;</span>
<a href="#l29.2227"></a><span id="l29.2227" class="difflineplus">+      else {</span>
<a href="#l29.2228"></a><span id="l29.2228" class="difflineplus">+        // This should always return a value unless something is very wrong.</span>
<a href="#l29.2229"></a><span id="l29.2229" class="difflineplus">+        //  We do not want to catch the exception if one happens.</span>
<a href="#l29.2230"></a><span id="l29.2230" class="difflineplus">+        let idBasedHeader = oldHeaderMessageId ?</span>
<a href="#l29.2231"></a><span id="l29.2231" class="difflineplus">+          this._indexingDatabase.getMsgHdrForMessageID(oldHeaderMessageId) :</span>
<a href="#l29.2232"></a><span id="l29.2232" class="difflineplus">+          false;</span>
<a href="#l29.2233"></a><span id="l29.2233" class="difflineplus">+        if (idBasedHeader == null)</span>
<a href="#l29.2234"></a><span id="l29.2234" class="difflineplus">+          throw new Error(&quot;Compaction pass failure; unable to locate header &quot; +</span>
<a href="#l29.2235"></a><span id="l29.2235" class="difflineplus">+                          &quot;with message-id &quot; + oldHeaderMessageId);</span>
<a href="#l29.2236"></a><span id="l29.2236" class="difflineplus">+        // The expected case is that the message referenced by the gloda</span>
<a href="#l29.2237"></a><span id="l29.2237" class="difflineplus">+        //  database precedes the header the enumerator told us about.  This</span>
<a href="#l29.2238"></a><span id="l29.2238" class="difflineplus">+        //  is expected because if PendingCommitTracker did not mark the</span>
<a href="#l29.2239"></a><span id="l29.2239" class="difflineplus">+        //  message as indexed/clean then the enumerator would not tell us</span>
<a href="#l29.2240"></a><span id="l29.2240" class="difflineplus">+        //  about it.</span>
<a href="#l29.2241"></a><span id="l29.2241" class="difflineplus">+        // Also, if we ran out of headers from the enumerator, this is a dead</span>
<a href="#l29.2242"></a><span id="l29.2242" class="difflineplus">+        //  giveaway that this is the expected case.</span>
<a href="#l29.2243"></a><span id="l29.2243" class="difflineplus">+        if (idBasedHeader &amp;&amp;</span>
<a href="#l29.2244"></a><span id="l29.2244" class="difflineplus">+             ((msgHdr &amp;&amp;</span>
<a href="#l29.2245"></a><span id="l29.2245" class="difflineplus">+               idBasedHeader.messageKey &lt; msgHdr.messageKey) ||</span>
<a href="#l29.2246"></a><span id="l29.2246" class="difflineplus">+              !msgHdr)) {</span>
<a href="#l29.2247"></a><span id="l29.2247" class="difflineplus">+          // tell the pending commit tracker about the gloda database one</span>
<a href="#l29.2248"></a><span id="l29.2248" class="difflineplus">+          PendingCommitTracker.track(idBasedHeader, oldGlodaId);</span>
<a href="#l29.2249"></a><span id="l29.2249" class="difflineplus">+          // and we might need to update the message key too</span>
<a href="#l29.2250"></a><span id="l29.2250" class="difflineplus">+          if (idBasedHeader.messageKey != oldMessageKey) {</span>
<a href="#l29.2251"></a><span id="l29.2251" class="difflineplus">+            updateGlodaIds.push(oldGlodaId);</span>
<a href="#l29.2252"></a><span id="l29.2252" class="difflineplus">+            updateMessageKeys.push(idBasedHeader.messageKey);</span>
<a href="#l29.2253"></a><span id="l29.2253" class="difflineplus">+          }</span>
<a href="#l29.2254"></a><span id="l29.2254" class="difflineplus">+          // Take another pass through the loop so that we check the</span>
<a href="#l29.2255"></a><span id="l29.2255" class="difflineplus">+          //  enumerator header against the next message in the gloda</span>
<a href="#l29.2256"></a><span id="l29.2256" class="difflineplus">+          //  database.</span>
<a href="#l29.2257"></a><span id="l29.2257" class="difflineplus">+          keepIterHeader = true;</span>
<a href="#l29.2258"></a><span id="l29.2258" class="difflineplus">+        }</span>
<a href="#l29.2259"></a><span id="l29.2259" class="difflineplus">+        // Whereas if the message referenced by gloda has a message key</span>
<a href="#l29.2260"></a><span id="l29.2260" class="difflineplus">+        //  greater than the one returned by the enumerator, then we have a</span>
<a href="#l29.2261"></a><span id="l29.2261" class="difflineplus">+        //  header claiming to be indexed by gloda that gloda does not</span>
<a href="#l29.2262"></a><span id="l29.2262" class="difflineplus">+        //  actually know about.  This is exceptional and gets a warning.</span>
<a href="#l29.2263"></a><span id="l29.2263" class="difflineplus">+        else if (msgHdr) {</span>
<a href="#l29.2264"></a><span id="l29.2264" class="difflineplus">+          this._log.warn(&quot;Observed header that claims to be gloda indexed &quot; +</span>
<a href="#l29.2265"></a><span id="l29.2265" class="difflineplus">+                         &quot;but that gloda has never heard of during &quot; +</span>
<a href="#l29.2266"></a><span id="l29.2266" class="difflineplus">+                         &quot;compaction.&quot; +</span>
<a href="#l29.2267"></a><span id="l29.2267" class="difflineplus">+                         &quot; In folder: &quot; + msgHdr.folder.URI +</span>
<a href="#l29.2268"></a><span id="l29.2268" class="difflineplus">+                         &quot; sketchy key: &quot; + msgHdr.messageKey +</span>
<a href="#l29.2269"></a><span id="l29.2269" class="difflineplus">+                         &quot; subject: &quot; + msgHdr.mime2DecodedSubject);</span>
<a href="#l29.2270"></a><span id="l29.2270" class="difflineplus">+          // Keep this tuple around for the next enumerator provided header</span>
<a href="#l29.2271"></a><span id="l29.2271" class="difflineplus">+          keepGlodaTuple = true;</span>
<a href="#l29.2272"></a><span id="l29.2272" class="difflineplus">+        }</span>
<a href="#l29.2273"></a><span id="l29.2273" class="difflineplus">+      }</span>
<a href="#l29.2274"></a><span id="l29.2274" class="difflineplus">+    }</span>
<a href="#l29.2275"></a><span id="l29.2275" class="difflineplus">+    // If we don't flush the update, no one will!</span>
<a href="#l29.2276"></a><span id="l29.2276" class="difflineplus">+    if (updateGlodaIds.length)</span>
<a href="#l29.2277"></a><span id="l29.2277" class="difflineplus">+      GlodaDatastore.updateMessageLocations(updateGlodaIds,</span>
<a href="#l29.2278"></a><span id="l29.2278" class="difflineplus">+                                            updateMessageKeys,</span>
<a href="#l29.2279"></a><span id="l29.2279" class="difflineplus">+                                            aJob.id, true);</span>
<a href="#l29.2280"></a><span id="l29.2280" class="difflineplus">+</span>
<a href="#l29.2281"></a><span id="l29.2281" class="difflineplus">+    this._indexerLeaveFolder();</span>
<a href="#l29.2282"></a><span id="l29.2282" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l29.2283"></a><span id="l29.2283" class="difflineplus">+  },</span>
<a href="#l29.2284"></a><span id="l29.2284" class="difflineplus">+</span>
<a href="#l29.2285"></a><span id="l29.2285" class="difflineplus">+  /**</span>
<a href="#l29.2286"></a><span id="l29.2286">    * Index the contents of a folder.</span>
<a href="#l29.2287"></a><span id="l29.2287">    */</span>
<a href="#l29.2288"></a><span id="l29.2288" class="difflineminus">-  _worker_folderIndex: function gloda_worker_folderIndex(aJob) {</span>
<a href="#l29.2289"></a><span id="l29.2289" class="difflineplus">+  _worker_folderIndex:</span>
<a href="#l29.2290"></a><span id="l29.2290" class="difflineplus">+      function gloda_worker_folderIndex(aJob, aCallbackHandle) {</span>
<a href="#l29.2291"></a><span id="l29.2291">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l29.2292"></a><span id="l29.2292">     yield this._indexerEnterFolder(aJob.id);</span>
<a href="#l29.2293"></a><span id="l29.2293"> </span>
<a href="#l29.2294"></a><span id="l29.2294">     if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l29.2295"></a><span id="l29.2295">       yield this.kWorkDone;</span>
<a href="#l29.2296"></a><span id="l29.2296"> </span>
<a href="#l29.2297"></a><span id="l29.2297">     // Make sure listeners get notified about this job.</span>
<a href="#l29.2298"></a><span id="l29.2298" class="difflineminus">-    this._notifyListeners();</span>
<a href="#l29.2299"></a><span id="l29.2299" class="difflineplus">+    GlodaIndexer._notifyListeners();</span>
<a href="#l29.2300"></a><span id="l29.2300"> </span>
<a href="#l29.2301"></a><span id="l29.2301">     // there is of course a cost to all this header investigation even if we</span>
<a href="#l29.2302"></a><span id="l29.2302">     //  don't do something.  so we will yield with kWorkSync for every block.</span>
<a href="#l29.2303"></a><span id="l29.2303" class="difflineminus">-    const HEADER_CHECK_BLOCK_SIZE = 25;</span>
<a href="#l29.2304"></a><span id="l29.2304" class="difflineplus">+    const HEADER_CHECK_SYNC_BLOCK_SIZE = this.HEADER_CHECK_SYNC_BLOCK_SIZE;</span>
<a href="#l29.2305"></a><span id="l29.2305" class="difflineplus">+    const HEADER_CHECK_GC_BLOCK_SIZE = this.HEADER_CHECK_GC_BLOCK_SIZE;</span>
<a href="#l29.2306"></a><span id="l29.2306"> </span>
<a href="#l29.2307"></a><span id="l29.2307">     // we can safely presume if we are here that this folder has been selected</span>
<a href="#l29.2308"></a><span id="l29.2308">     //  for offline processing...</span>
<a href="#l29.2309"></a><span id="l29.2309"> </span>
<a href="#l29.2310"></a><span id="l29.2310" class="difflineminus">-    // Handle the filthy case.  A filthy folder may have misleading properties</span>
<a href="#l29.2311"></a><span id="l29.2311" class="difflineminus">-    //  on the message that claim the message is indexed.  They are misleading</span>
<a href="#l29.2312"></a><span id="l29.2312" class="difflineminus">-    //  because the database, for whatever reason, does not have the messages</span>
<a href="#l29.2313"></a><span id="l29.2313" class="difflineminus">-    //  (accurately) indexed.</span>
<a href="#l29.2314"></a><span id="l29.2314" class="difflineplus">+    // -- Filthy Folder</span>
<a href="#l29.2315"></a><span id="l29.2315" class="difflineplus">+    // A filthy folder may have misleading properties on the message that claim</span>
<a href="#l29.2316"></a><span id="l29.2316" class="difflineplus">+    //  the message is indexed.  They are misleading because the database, for</span>
<a href="#l29.2317"></a><span id="l29.2317" class="difflineplus">+    //  whatever reason, does not have the messages (accurately) indexed.</span>
<a href="#l29.2318"></a><span id="l29.2318">     // We need to walk all the messages and mark them filthy if they have a</span>
<a href="#l29.2319"></a><span id="l29.2319">     //  dirty property.  Once we have done this, we can downgrade the folder's</span>
<a href="#l29.2320"></a><span id="l29.2320">     //  dirty status to plain dirty.  We do this rather than trying to process</span>
<a href="#l29.2321"></a><span id="l29.2321">     //  everyone in one go in a filthy context because if we have to terminate</span>
<a href="#l29.2322"></a><span id="l29.2322">     //  indexing before we quit, we don't want to have to re-index messages next</span>
<a href="#l29.2323"></a><span id="l29.2323">     //  time.  (This could even lead to never completing indexing in a</span>
<a href="#l29.2324"></a><span id="l29.2324">     //  pathological situation.)</span>
<a href="#l29.2325"></a><span id="l29.2325">     let glodaFolder = GlodaDatastore._mapFolder(this._indexingFolder);</span>
<a href="#l29.2326"></a><span id="l29.2326">     if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy) {</span>
<a href="#l29.2327"></a><span id="l29.2327" class="difflineminus">-      this._indexerGetEnumerator(true);</span>
<a href="#l29.2328"></a><span id="l29.2328" class="difflineplus">+      this._indexerGetEnumerator(this.kEnumIndexedMsgs);</span>
<a href="#l29.2329"></a><span id="l29.2329">       let count = 0;</span>
<a href="#l29.2330"></a><span id="l29.2330" class="difflineminus">-      for (let msgHdr in fixIterator(this._indexingEnumerator,</span>
<a href="#l29.2331"></a><span id="l29.2331" class="difflineminus">-                                     Ci.nsIMsgDBHdr)) {</span>
<a href="#l29.2332"></a><span id="l29.2332" class="difflineplus">+      for (let msgHdr in fixIterator(this._indexingEnumerator, nsIMsgDBHdr)) {</span>
<a href="#l29.2333"></a><span id="l29.2333">         // we still need to avoid locking up the UI, pause periodically...</span>
<a href="#l29.2334"></a><span id="l29.2334" class="difflineminus">-        if (++count % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l29.2335"></a><span id="l29.2335" class="difflineplus">+        if (++count % HEADER_CHECK_SYNC_BLOCK_SIZE == 0)</span>
<a href="#l29.2336"></a><span id="l29.2336">           yield this.kWorkSync;</span>
<a href="#l29.2337"></a><span id="l29.2337"> </span>
<a href="#l29.2338"></a><span id="l29.2338" class="difflineplus">+        if (count % HEADER_CHECK_GC_BLOCK_SIZE == 0)</span>
<a href="#l29.2339"></a><span id="l29.2339" class="difflineplus">+          GlodaUtils.considerHeaderBasedGC(HEADER_CHECK_GC_BLOCK_SIZE);</span>
<a href="#l29.2340"></a><span id="l29.2340" class="difflineplus">+</span>
<a href="#l29.2341"></a><span id="l29.2341">         let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l29.2342"></a><span id="l29.2342">           GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.2343"></a><span id="l29.2343">         // if it has a gloda message id, we need to mark it filthy</span>
<a href="#l29.2344"></a><span id="l29.2344">         if (glodaMessageId != 0)</span>
<a href="#l29.2345"></a><span id="l29.2345">           msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, this.kMessageFilthy);</span>
<a href="#l29.2346"></a><span id="l29.2346">         // if it doesn't have a gloda message id, we will definitely index it,</span>
<a href="#l29.2347"></a><span id="l29.2347">         //  so no action is required.</span>
<a href="#l29.2348"></a><span id="l29.2348">       }</span>
<a href="#l29.2349"></a><span id="l29.2349" class="difflineplus">+      // Commit the filthy status changes to the message database.</span>
<a href="#l29.2350"></a><span id="l29.2350" class="difflineplus">+      this._indexingDatabase.Commit(Ci.nsMsgDBCommitType.kLargeCommit);</span>
<a href="#l29.2351"></a><span id="l29.2351" class="difflineplus">+</span>
<a href="#l29.2352"></a><span id="l29.2352">       // this will automatically persist to the database</span>
<a href="#l29.2353"></a><span id="l29.2353">       glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l29.2354"></a><span id="l29.2354">     }</span>
<a href="#l29.2355"></a><span id="l29.2355"> </span>
<a href="#l29.2356"></a><span id="l29.2356">     // Pass 1: count the number of messages to index.</span>
<a href="#l29.2357"></a><span id="l29.2357">     //  We do this in order to be able to report to the user what we're doing.</span>
<a href="#l29.2358"></a><span id="l29.2358">     // TODO: give up after reaching a certain number of messages in folders</span>
<a href="#l29.2359"></a><span id="l29.2359">     //  with ridiculous numbers of messages and make the interface just say</span>
<a href="#l29.2360"></a><span id="l29.2360">     //  something like &quot;over N messages to go.&quot;</span>
<a href="#l29.2361"></a><span id="l29.2361"> </span>
<a href="#l29.2362"></a><span id="l29.2362" class="difflineminus">-    this._indexerGetEnumerator(false);</span>
<a href="#l29.2363"></a><span id="l29.2363" class="difflineplus">+    this._indexerGetEnumerator(this.kEnumMsgsToIndex);</span>
<a href="#l29.2364"></a><span id="l29.2364">     let numMessagesToIndex = 0;</span>
<a href="#l29.2365"></a><span id="l29.2365">     let numMessagesOut = {};</span>
<a href="#l29.2366"></a><span id="l29.2366">     // Keep going until we run out of headers.</span>
<a href="#l29.2367"></a><span id="l29.2367">     while (this._indexingFolder.msgDatabase.nextMatchingHdrs(</span>
<a href="#l29.2368"></a><span id="l29.2368">              this._indexingEnumerator,</span>
<a href="#l29.2369"></a><span id="l29.2369" class="difflineminus">-             HEADER_CHECK_BLOCK_SIZE * 8, // this way is much faster, do more</span>
<a href="#l29.2370"></a><span id="l29.2370" class="difflineplus">+             HEADER_CHECK_SYNC_BLOCK_SIZE * 8, // this way is faster, do more</span>
<a href="#l29.2371"></a><span id="l29.2371">              0, // moot, we don't return headers</span>
<a href="#l29.2372"></a><span id="l29.2372">              null, // don't return headers, we just want the count</span>
<a href="#l29.2373"></a><span id="l29.2373">              numMessagesOut)) {</span>
<a href="#l29.2374"></a><span id="l29.2374">       numMessagesToIndex += numMessagesOut.value;</span>
<a href="#l29.2375"></a><span id="l29.2375">       yield this.kWorkSync;</span>
<a href="#l29.2376"></a><span id="l29.2376">     }</span>
<a href="#l29.2377"></a><span id="l29.2377">     numMessagesToIndex += numMessagesOut.value;</span>
<a href="#l29.2378"></a><span id="l29.2378"> </span>
<a href="#l29.2379"></a><span id="l29.2379">     aJob.goal = numMessagesToIndex;</span>
<a href="#l29.2380"></a><span id="l29.2380"> </span>
<a href="#l29.2381"></a><span id="l29.2381">     if (numMessagesToIndex &gt; 0) {</span>
<a href="#l29.2382"></a><span id="l29.2382">       // We used up the iterator, get a new one.</span>
<a href="#l29.2383"></a><span id="l29.2383" class="difflineminus">-      this._indexerGetEnumerator(false);</span>
<a href="#l29.2384"></a><span id="l29.2384" class="difflineplus">+      this._indexerGetEnumerator(this.kEnumMsgsToIndex);</span>
<a href="#l29.2385"></a><span id="l29.2385"> </span>
<a href="#l29.2386"></a><span id="l29.2386">       // Pass 2: index the messages.</span>
<a href="#l29.2387"></a><span id="l29.2387">       let count = 0;</span>
<a href="#l29.2388"></a><span id="l29.2388" class="difflineminus">-      for (let msgHdr in fixIterator(this._indexingEnumerator,</span>
<a href="#l29.2389"></a><span id="l29.2389" class="difflineminus">-                                     Ci.nsIMsgDBHdr)) {</span>
<a href="#l29.2390"></a><span id="l29.2390" class="difflineplus">+      for (let msgHdr in fixIterator(this._indexingEnumerator, nsIMsgDBHdr)) {</span>
<a href="#l29.2391"></a><span id="l29.2391">         // per above, we want to periodically release control while doing all</span>
<a href="#l29.2392"></a><span id="l29.2392">         // this header traversal/investigation.</span>
<a href="#l29.2393"></a><span id="l29.2393" class="difflineminus">-        // XXX not clear that this is really needed, since search has its own</span>
<a href="#l29.2394"></a><span id="l29.2394" class="difflineminus">-        // method to yield to UI periodically.</span>
<a href="#l29.2395"></a><span id="l29.2395" class="difflineminus">-        if (++count % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l29.2396"></a><span id="l29.2396" class="difflineplus">+        if (++count % HEADER_CHECK_SYNC_BLOCK_SIZE == 0)</span>
<a href="#l29.2397"></a><span id="l29.2397">           yield this.kWorkSync;</span>
<a href="#l29.2398"></a><span id="l29.2398"> </span>
<a href="#l29.2399"></a><span id="l29.2399" class="difflineplus">+        if (count % HEADER_CHECK_GC_BLOCK_SIZE == 0)</span>
<a href="#l29.2400"></a><span id="l29.2400" class="difflineplus">+          GlodaUtils.considerHeaderBasedGC(HEADER_CHECK_GC_BLOCK_SIZE);</span>
<a href="#l29.2401"></a><span id="l29.2401" class="difflineplus">+</span>
<a href="#l29.2402"></a><span id="l29.2402" class="difflineplus">+        // To keep our counts more accurate, increment the offset before</span>
<a href="#l29.2403"></a><span id="l29.2403" class="difflineplus">+        //  potentially skipping any messages.</span>
<a href="#l29.2404"></a><span id="l29.2404">         ++aJob.offset;</span>
<a href="#l29.2405"></a><span id="l29.2405" class="difflineplus">+</span>
<a href="#l29.2406"></a><span id="l29.2406" class="difflineplus">+        // skip messages that are currently being processed for junk</span>
<a href="#l29.2407"></a><span id="l29.2407" class="difflineplus">+        if (this._indexingFolder.getProcessingFlags(msgHdr.messageKey) &amp;</span>
<a href="#l29.2408"></a><span id="l29.2408" class="difflineplus">+            nsMsgProcessingFlags.ClassifyJunk)</span>
<a href="#l29.2409"></a><span id="l29.2409" class="difflineplus">+          continue;</span>
<a href="#l29.2410"></a><span id="l29.2410" class="difflineplus">+</span>
<a href="#l29.2411"></a><span id="l29.2411" class="difflineplus">+        // Because the gloda id could be in-flight, we need to double-check the</span>
<a href="#l29.2412"></a><span id="l29.2412" class="difflineplus">+        //  enumerator here since it can't know about our in-memory stuff.</span>
<a href="#l29.2413"></a><span id="l29.2413" class="difflineplus">+        let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(msgHdr);</span>
<a href="#l29.2414"></a><span id="l29.2414" class="difflineplus">+        // if the message seems valid, skip it.  (that means good gloda id</span>
<a href="#l29.2415"></a><span id="l29.2415" class="difflineplus">+        //  and not dirty)</span>
<a href="#l29.2416"></a><span id="l29.2416" class="difflineplus">+        if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l29.2417"></a><span id="l29.2417" class="difflineplus">+            glodaDirty == this.kMessageClean)</span>
<a href="#l29.2418"></a><span id="l29.2418" class="difflineplus">+          continue;</span>
<a href="#l29.2419"></a><span id="l29.2419" class="difflineplus">+</span>
<a href="#l29.2420"></a><span id="l29.2420">         if (logDebug)</span>
<a href="#l29.2421"></a><span id="l29.2421">           this._log.debug(&quot;&gt;&gt;&gt;  _indexMessage&quot;);</span>
<a href="#l29.2422"></a><span id="l29.2422" class="difflineminus">-        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l29.2423"></a><span id="l29.2423" class="difflineminus">-            this._callbackHandle));</span>
<a href="#l29.2424"></a><span id="l29.2424" class="difflineplus">+        yield aCallbackHandle.pushAndGo(</span>
<a href="#l29.2425"></a><span id="l29.2425" class="difflineplus">+          this._indexMessage(msgHdr, aCallbackHandle),</span>
<a href="#l29.2426"></a><span id="l29.2426" class="difflineplus">+          {what: &quot;indexMessage&quot;, msgHdr: msgHdr});</span>
<a href="#l29.2427"></a><span id="l29.2427">         if (logDebug)</span>
<a href="#l29.2428"></a><span id="l29.2428">           this._log.debug(&quot;&lt;&lt;&lt;  _indexMessage&quot;);</span>
<a href="#l29.2429"></a><span id="l29.2429">       }</span>
<a href="#l29.2430"></a><span id="l29.2430">     }</span>
<a href="#l29.2431"></a><span id="l29.2431"> </span>
<a href="#l29.2432"></a><span id="l29.2432">     glodaFolder.dirtyStatus = glodaFolder.kFolderClean;</span>
<a href="#l29.2433"></a><span id="l29.2433"> </span>
<a href="#l29.2434"></a><span id="l29.2434">     // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l29.2435"></a><span id="l29.2435">     this._indexerLeaveFolder();</span>
<a href="#l29.2436"></a><span id="l29.2436"> </span>
<a href="#l29.2437"></a><span id="l29.2437">     yield this.kWorkDone;</span>
<a href="#l29.2438"></a><span id="l29.2438">   },</span>
<a href="#l29.2439"></a><span id="l29.2439"> </span>
<a href="#l29.2440"></a><span id="l29.2440">   /**</span>
<a href="#l29.2441"></a><span id="l29.2441" class="difflineplus">+   * Invoked when a &quot;message&quot; job is scheduled so that we can clear</span>
<a href="#l29.2442"></a><span id="l29.2442" class="difflineplus">+   *  _pendingAddJob if that is the job.  We do this so that work items are not</span>
<a href="#l29.2443"></a><span id="l29.2443" class="difflineplus">+   *  added to _pendingAddJob while it is being processed.</span>
<a href="#l29.2444"></a><span id="l29.2444" class="difflineplus">+   */</span>
<a href="#l29.2445"></a><span id="l29.2445" class="difflineplus">+  _schedule_messageIndex: function(aJob, aCallbackHandle) {</span>
<a href="#l29.2446"></a><span id="l29.2446" class="difflineplus">+    // we do not want new work items to be added as we are processing, so</span>
<a href="#l29.2447"></a><span id="l29.2447" class="difflineplus">+    //  clear _pendingAddJob.  A new job will be created as needed.</span>
<a href="#l29.2448"></a><span id="l29.2448" class="difflineplus">+    if (aJob === this._pendingAddJob)</span>
<a href="#l29.2449"></a><span id="l29.2449" class="difflineplus">+      this._pendingAddJob = null;</span>
<a href="#l29.2450"></a><span id="l29.2450" class="difflineplus">+    // update our goal from the items length</span>
<a href="#l29.2451"></a><span id="l29.2451" class="difflineplus">+    aJob.goal = aJob.items.length;</span>
<a href="#l29.2452"></a><span id="l29.2452" class="difflineplus">+  },</span>
<a href="#l29.2453"></a><span id="l29.2453" class="difflineplus">+  /**</span>
<a href="#l29.2454"></a><span id="l29.2454" class="difflineplus">+   * If the job gets canceled, we need to make sure that we clear out pending</span>
<a href="#l29.2455"></a><span id="l29.2455" class="difflineplus">+   *  add job or our state will get wonky.</span>
<a href="#l29.2456"></a><span id="l29.2456" class="difflineplus">+   */</span>
<a href="#l29.2457"></a><span id="l29.2457" class="difflineplus">+  _canceled_messageIndex: function gloda_index_msg_canceled_messageIndex(aJob) {</span>
<a href="#l29.2458"></a><span id="l29.2458" class="difflineplus">+    if (aJob === this._pendingAddJob)</span>
<a href="#l29.2459"></a><span id="l29.2459" class="difflineplus">+      this._pendingAddJob = null;</span>
<a href="#l29.2460"></a><span id="l29.2460" class="difflineplus">+  },</span>
<a href="#l29.2461"></a><span id="l29.2461" class="difflineplus">+</span>
<a href="#l29.2462"></a><span id="l29.2462" class="difflineplus">+</span>
<a href="#l29.2463"></a><span id="l29.2463" class="difflineplus">+  /**</span>
<a href="#l29.2464"></a><span id="l29.2464">    * Index a specific list of messages that we know to index from</span>
<a href="#l29.2465"></a><span id="l29.2465">    *  event-notification hints.</span>
<a href="#l29.2466"></a><span id="l29.2466">    */</span>
<a href="#l29.2467"></a><span id="l29.2467" class="difflineminus">-  _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l29.2468"></a><span id="l29.2468" class="difflineplus">+  _worker_messageIndex:</span>
<a href="#l29.2469"></a><span id="l29.2469" class="difflineplus">+      function gloda_worker_messageIndex(aJob, aCallbackHandle) {</span>
<a href="#l29.2470"></a><span id="l29.2470">     // if we are already in the correct folder, our &quot;get in the folder&quot; clause</span>
<a href="#l29.2471"></a><span id="l29.2471">     //  will not execute, so we need to make sure this value is accurate in</span>
<a href="#l29.2472"></a><span id="l29.2472">     //  that case.  (and we want to avoid multiple checks...)</span>
<a href="#l29.2473"></a><span id="l29.2473">     for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l29.2474"></a><span id="l29.2474">       let item = aJob.items[aJob.offset];</span>
<a href="#l29.2475"></a><span id="l29.2475">       // item is either [folder ID, message key] or</span>
<a href="#l29.2476"></a><span id="l29.2476">       //                [folder ID, message ID]</span>
<a href="#l29.2477"></a><span id="l29.2477"> </span>
<a href="#l29.2478"></a><span id="l29.2478" class="difflineplus">+      let glodaFolderId = item[0];</span>
<a href="#l29.2479"></a><span id="l29.2479" class="difflineplus">+      // If the folder has been deleted since we queued, skip this message</span>
<a href="#l29.2480"></a><span id="l29.2480" class="difflineplus">+      if (!GlodaDatastore._folderIdKnown(glodaFolderId))</span>
<a href="#l29.2481"></a><span id="l29.2481" class="difflineplus">+        continue;</span>
<a href="#l29.2482"></a><span id="l29.2482" class="difflineplus">+      let glodaFolder = GlodaDatastore._mapFolderID(glodaFolderId);</span>
<a href="#l29.2483"></a><span id="l29.2483" class="difflineplus">+</span>
<a href="#l29.2484"></a><span id="l29.2484" class="difflineplus">+      // Stay out of folders that:</span>
<a href="#l29.2485"></a><span id="l29.2485" class="difflineplus">+      // - are compacting</span>
<a href="#l29.2486"></a><span id="l29.2486" class="difflineplus">+      // - got deleted (this would be redundant if we had a stance on id nukage)</span>
<a href="#l29.2487"></a><span id="l29.2487" class="difflineplus">+      // (these things could have changed since we queued the event)</span>
<a href="#l29.2488"></a><span id="l29.2488" class="difflineplus">+      if (glodaFolder.compacting || glodaFolder._deleted)</span>
<a href="#l29.2489"></a><span id="l29.2489" class="difflineplus">+        continue;</span>
<a href="#l29.2490"></a><span id="l29.2490" class="difflineplus">+</span>
<a href="#l29.2491"></a><span id="l29.2491">       // get in the folder</span>
<a href="#l29.2492"></a><span id="l29.2492" class="difflineminus">-      if (!this._indexingGlodaFolder ||</span>
<a href="#l29.2493"></a><span id="l29.2493" class="difflineminus">-          this._indexingGlodaFolder.id != item[0]) {</span>
<a href="#l29.2494"></a><span id="l29.2494" class="difflineminus">-        yield this._indexerEnterFolder(item[0]);</span>
<a href="#l29.2495"></a><span id="l29.2495" class="difflineplus">+      if (this._indexingGlodaFolder != glodaFolder) {</span>
<a href="#l29.2496"></a><span id="l29.2496" class="difflineplus">+        yield this._indexerEnterFolder(glodaFolderId);</span>
<a href="#l29.2497"></a><span id="l29.2497"> </span>
<a href="#l29.2498"></a><span id="l29.2498" class="difflineminus">-        // stay out of folders we should not be in!</span>
<a href="#l29.2499"></a><span id="l29.2499" class="difflineplus">+        // Now that we have the real nsIMsgFolder, sanity-check that we should</span>
<a href="#l29.2500"></a><span id="l29.2500" class="difflineplus">+        //  be indexing it.  (There are some checks that require the</span>
<a href="#l29.2501"></a><span id="l29.2501" class="difflineplus">+        //  nsIMsgFolder.)</span>
<a href="#l29.2502"></a><span id="l29.2502">         if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l29.2503"></a><span id="l29.2503">           continue;</span>
<a href="#l29.2504"></a><span id="l29.2504">       }</span>
<a href="#l29.2505"></a><span id="l29.2505"> </span>
<a href="#l29.2506"></a><span id="l29.2506">       let msgHdr;</span>
<a href="#l29.2507"></a><span id="l29.2507" class="difflineplus">+      // GetMessageHeader can be affected by the use cache, so we need to check</span>
<a href="#l29.2508"></a><span id="l29.2508" class="difflineplus">+      //  ContainsKey first to see if the header is really actually there.</span>
<a href="#l29.2509"></a><span id="l29.2509">       if (typeof item[1] == &quot;number&quot;)</span>
<a href="#l29.2510"></a><span id="l29.2510" class="difflineminus">-        msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l29.2511"></a><span id="l29.2511" class="difflineplus">+        msgHdr = this._indexingDatabase.ContainsKey(item[1]) &amp;&amp;</span>
<a href="#l29.2512"></a><span id="l29.2512" class="difflineplus">+                 this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l29.2513"></a><span id="l29.2513">       else</span>
<a href="#l29.2514"></a><span id="l29.2514">         // same deal as in move processing.</span>
<a href="#l29.2515"></a><span id="l29.2515">         // TODO fixme to not assume singular message-id's.</span>
<a href="#l29.2516"></a><span id="l29.2516">         msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l29.2517"></a><span id="l29.2517"> </span>
<a href="#l29.2518"></a><span id="l29.2518" class="difflineminus">-      // it needs a header, and the header needs to not be expunged.</span>
<a href="#l29.2519"></a><span id="l29.2519" class="difflineminus">-      if (msgHdr &amp;&amp;</span>
<a href="#l29.2520"></a><span id="l29.2520" class="difflineminus">-          !(msgHdr.flags &amp; Components.interfaces.nsMsgMessageFlags.Expunged))</span>
<a href="#l29.2521"></a><span id="l29.2521" class="difflineminus">-        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l29.2522"></a><span id="l29.2522" class="difflineminus">-            this._callbackHandle));</span>
<a href="#l29.2523"></a><span id="l29.2523" class="difflineplus">+      if (msgHdr)</span>
<a href="#l29.2524"></a><span id="l29.2524" class="difflineplus">+        yield aCallbackHandle.pushAndGo(</span>
<a href="#l29.2525"></a><span id="l29.2525" class="difflineplus">+          this._indexMessage(msgHdr, aCallbackHandle),</span>
<a href="#l29.2526"></a><span id="l29.2526" class="difflineplus">+          {what: &quot;indexMessage&quot;, msgHdr: msgHdr});</span>
<a href="#l29.2527"></a><span id="l29.2527">       else</span>
<a href="#l29.2528"></a><span id="l29.2528">         yield this.kWorkSync;</span>
<a href="#l29.2529"></a><span id="l29.2529">     }</span>
<a href="#l29.2530"></a><span id="l29.2530" class="difflineplus">+</span>
<a href="#l29.2531"></a><span id="l29.2531" class="difflineplus">+    // There is no real reason to stay 'in' the folder.  If we are going to get</span>
<a href="#l29.2532"></a><span id="l29.2532" class="difflineplus">+    //  more events from the folder, its database would have to be open for us</span>
<a href="#l29.2533"></a><span id="l29.2533" class="difflineplus">+    //  to get the events, so it's not like we're creating an efficiency</span>
<a href="#l29.2534"></a><span id="l29.2534" class="difflineplus">+    //  problem where we unload a folder just to load it again in 2 seconds.</span>
<a href="#l29.2535"></a><span id="l29.2535" class="difflineplus">+    // (Well, at least assuming the views are good about holding onto the</span>
<a href="#l29.2536"></a><span id="l29.2536" class="difflineplus">+    //  database references even though they go out of their way to avoid</span>
<a href="#l29.2537"></a><span id="l29.2537" class="difflineplus">+    //  holding onto message header references.)</span>
<a href="#l29.2538"></a><span id="l29.2538" class="difflineplus">+    this._indexerLeaveFolder();</span>
<a href="#l29.2539"></a><span id="l29.2539" class="difflineplus">+</span>
<a href="#l29.2540"></a><span id="l29.2540">     yield this.kWorkDone;</span>
<a href="#l29.2541"></a><span id="l29.2541">   },</span>
<a href="#l29.2542"></a><span id="l29.2542"> </span>
<a href="#l29.2543"></a><span id="l29.2543">   /**</span>
<a href="#l29.2544"></a><span id="l29.2544" class="difflineplus">+   * Recover from a &quot;folder&quot; or &quot;message&quot; job failing inside a call to</span>
<a href="#l29.2545"></a><span id="l29.2545" class="difflineplus">+   *  |_indexMessage|, marking the message bad.  If we were not in an</span>
<a href="#l29.2546"></a><span id="l29.2546" class="difflineplus">+   *  |_indexMessage| call, then fail to recover.</span>
<a href="#l29.2547"></a><span id="l29.2547" class="difflineplus">+   *</span>
<a href="#l29.2548"></a><span id="l29.2548" class="difflineplus">+   * @param aJob The job that was being worked.  We ignore this for now.</span>
<a href="#l29.2549"></a><span id="l29.2549" class="difflineplus">+   * @param aContextStack The callbackHandle mechanism's context stack.  When we</span>
<a href="#l29.2550"></a><span id="l29.2550" class="difflineplus">+   *     invoke pushAndGo for _indexMessage we put something in so we can</span>
<a href="#l29.2551"></a><span id="l29.2551" class="difflineplus">+   *     detect when it is on the async stack.</span>
<a href="#l29.2552"></a><span id="l29.2552" class="difflineplus">+   *</span>
<a href="#l29.2553"></a><span id="l29.2553" class="difflineplus">+   * @return 1 if we were able to recover (because we want the call stack</span>
<a href="#l29.2554"></a><span id="l29.2554" class="difflineplus">+   *     popped down to our worker), false if we can't.</span>
<a href="#l29.2555"></a><span id="l29.2555" class="difflineplus">+   */</span>
<a href="#l29.2556"></a><span id="l29.2556" class="difflineplus">+  _recover_indexMessage:</span>
<a href="#l29.2557"></a><span id="l29.2557" class="difflineplus">+      function gloda_index_recover_indexMessage(aJob, aContextStack) {</span>
<a href="#l29.2558"></a><span id="l29.2558" class="difflineplus">+    // See if indexMessage is on the stack...</span>
<a href="#l29.2559"></a><span id="l29.2559" class="difflineplus">+    if (aContextStack.length &gt;= 2 &amp;&amp;</span>
<a href="#l29.2560"></a><span id="l29.2560" class="difflineplus">+        aContextStack[1] &amp;&amp;</span>
<a href="#l29.2561"></a><span id="l29.2561" class="difflineplus">+        (&quot;what&quot; in aContextStack[1]) &amp;&amp;</span>
<a href="#l29.2562"></a><span id="l29.2562" class="difflineplus">+        aContextStack[1].what == &quot;indexMessage&quot;) {</span>
<a href="#l29.2563"></a><span id="l29.2563" class="difflineplus">+      // it is, so this is probably recoverable.</span>
<a href="#l29.2564"></a><span id="l29.2564" class="difflineplus">+</span>
<a href="#l29.2565"></a><span id="l29.2565" class="difflineplus">+      // -- Mark the message as bad</span>
<a href="#l29.2566"></a><span id="l29.2566" class="difflineplus">+      let msgHdr = aContextStack[1].msgHdr;</span>
<a href="#l29.2567"></a><span id="l29.2567" class="difflineplus">+      // (In the worst case, the header is no longer valid, which will result in</span>
<a href="#l29.2568"></a><span id="l29.2568" class="difflineplus">+      //  exceptions.  We need to be prepared for that.)</span>
<a href="#l29.2569"></a><span id="l29.2569" class="difflineplus">+      try {</span>
<a href="#l29.2570"></a><span id="l29.2570" class="difflineplus">+        msgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY,</span>
<a href="#l29.2571"></a><span id="l29.2571" class="difflineplus">+                                 GLODA_BAD_MESSAGE_ID);</span>
<a href="#l29.2572"></a><span id="l29.2572" class="difflineplus">+        // clear the dirty bit if it has one</span>
<a href="#l29.2573"></a><span id="l29.2573" class="difflineplus">+        if (msgHdr.getUint32Property(GLODA_DIRTY_PROPERTY))</span>
<a href="#l29.2574"></a><span id="l29.2574" class="difflineplus">+          msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l29.2575"></a><span id="l29.2575" class="difflineplus">+      }</span>
<a href="#l29.2576"></a><span id="l29.2576" class="difflineplus">+      catch (ex) {</span>
<a href="#l29.2577"></a><span id="l29.2577" class="difflineplus">+        // If we are indexing a folder and the message header is no longer</span>
<a href="#l29.2578"></a><span id="l29.2578" class="difflineplus">+        //  valid, then it's quite likely the whole folder is no longer valid.</span>
<a href="#l29.2579"></a><span id="l29.2579" class="difflineplus">+        //  But since in the event-driven message indexing case we could have</span>
<a href="#l29.2580"></a><span id="l29.2580" class="difflineplus">+        //  other valid things to look at, let's try and recover.  The folder</span>
<a href="#l29.2581"></a><span id="l29.2581" class="difflineplus">+        //  indexing case will come back to us shortly and we will indicate</span>
<a href="#l29.2582"></a><span id="l29.2582" class="difflineplus">+        //  recovery is not possible at that point.</span>
<a href="#l29.2583"></a><span id="l29.2583" class="difflineplus">+        // So do nothing here since by popping the indexing of the specific</span>
<a href="#l29.2584"></a><span id="l29.2584" class="difflineplus">+        //  message out of existence we are recovering.</span>
<a href="#l29.2585"></a><span id="l29.2585" class="difflineplus">+      }</span>
<a href="#l29.2586"></a><span id="l29.2586" class="difflineplus">+      return 1;</span>
<a href="#l29.2587"></a><span id="l29.2587" class="difflineplus">+    }</span>
<a href="#l29.2588"></a><span id="l29.2588" class="difflineplus">+    return false;</span>
<a href="#l29.2589"></a><span id="l29.2589" class="difflineplus">+  },</span>
<a href="#l29.2590"></a><span id="l29.2590" class="difflineplus">+</span>
<a href="#l29.2591"></a><span id="l29.2591" class="difflineplus">+  /**</span>
<a href="#l29.2592"></a><span id="l29.2592" class="difflineplus">+   * Cleanup after an aborted &quot;folder&quot; or &quot;message&quot; job.</span>
<a href="#l29.2593"></a><span id="l29.2593" class="difflineplus">+   */</span>
<a href="#l29.2594"></a><span id="l29.2594" class="difflineplus">+  _cleanup_indexing: function gloda_index_cleanup_indexing(aJob) {</span>
<a href="#l29.2595"></a><span id="l29.2595" class="difflineplus">+    this._indexerLeaveFolder();</span>
<a href="#l29.2596"></a><span id="l29.2596" class="difflineplus">+  },</span>
<a href="#l29.2597"></a><span id="l29.2597" class="difflineplus">+</span>
<a href="#l29.2598"></a><span id="l29.2598" class="difflineplus">+  /**</span>
<a href="#l29.2599"></a><span id="l29.2599" class="difflineplus">+   * Maximum number of deleted messages to process at a time.  Arbitrary; there</span>
<a href="#l29.2600"></a><span id="l29.2600" class="difflineplus">+   *  are no real known performance constraints at this point.</span>
<a href="#l29.2601"></a><span id="l29.2601" class="difflineplus">+   */</span>
<a href="#l29.2602"></a><span id="l29.2602" class="difflineplus">+  DELETED_MESSAGE_BLOCK_SIZE: 32,</span>
<a href="#l29.2603"></a><span id="l29.2603" class="difflineplus">+</span>
<a href="#l29.2604"></a><span id="l29.2604" class="difflineplus">+  /**</span>
<a href="#l29.2605"></a><span id="l29.2605">    * Process pending deletes...</span>
<a href="#l29.2606"></a><span id="l29.2606">    */</span>
<a href="#l29.2607"></a><span id="l29.2607">   _worker_processDeletes: function gloda_worker_processDeletes(aJob,</span>
<a href="#l29.2608"></a><span id="l29.2608">       aCallbackHandle) {</span>
<a href="#l29.2609"></a><span id="l29.2609" class="difflineminus">-    // get a block of messages to delete.  for now, let's just do this</span>
<a href="#l29.2610"></a><span id="l29.2610" class="difflineminus">-    //  synchronously.  we don't care if there are un-landed delete changes</span>
<a href="#l29.2611"></a><span id="l29.2611" class="difflineminus">-    //  on the asynchronous thread.  (well, there is a potential race that</span>
<a href="#l29.2612"></a><span id="l29.2612" class="difflineminus">-    //  would result in us clearing pendingDeletions erroneously, but the</span>
<a href="#l29.2613"></a><span id="l29.2613" class="difflineminus">-    //  processedAny flag and our use of a while loop here make this</span>
<a href="#l29.2614"></a><span id="l29.2614" class="difflineminus">-    //  sufficiently close to zero until we move to being async.)</span>
<a href="#l29.2615"></a><span id="l29.2615" class="difflineminus">-    let messagesToDelete = this._datastore.getDeletedMessageBlock();</span>
<a href="#l29.2616"></a><span id="l29.2616" class="difflineminus">-    let processedAny = false;</span>
<a href="#l29.2617"></a><span id="l29.2617" class="difflineminus">-    while (messagesToDelete.length) {</span>
<a href="#l29.2618"></a><span id="l29.2618" class="difflineminus">-      aJob.goal += messagesToDelete.length;</span>
<a href="#l29.2619"></a><span id="l29.2619" class="difflineminus">-      for each (let [iMessage, message] in Iterator(messagesToDelete)) {</span>
<a href="#l29.2620"></a><span id="l29.2620" class="difflineminus">-        yield aCallbackHandle.pushAndGo(this._deleteMessage(message));</span>
<a href="#l29.2621"></a><span id="l29.2621" class="difflineplus">+</span>
<a href="#l29.2622"></a><span id="l29.2622" class="difflineplus">+    // get a block of messages to delete.</span>
<a href="#l29.2623"></a><span id="l29.2623" class="difflineplus">+    let query = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l29.2624"></a><span id="l29.2624" class="difflineplus">+                                 noDbQueryValidityConstraints: true,</span>
<a href="#l29.2625"></a><span id="l29.2625" class="difflineplus">+                               });</span>
<a href="#l29.2626"></a><span id="l29.2626" class="difflineplus">+    query._deleted(1);</span>
<a href="#l29.2627"></a><span id="l29.2627" class="difflineplus">+    query.limit(this.DELETED_MESSAGE_BLOCK_SIZE);</span>
<a href="#l29.2628"></a><span id="l29.2628" class="difflineplus">+    let deletedCollection = query.getCollection(aCallbackHandle);</span>
<a href="#l29.2629"></a><span id="l29.2629" class="difflineplus">+    yield this.kWorkAsync;</span>
<a href="#l29.2630"></a><span id="l29.2630" class="difflineplus">+</span>
<a href="#l29.2631"></a><span id="l29.2631" class="difflineplus">+    while (deletedCollection.items.length) {</span>
<a href="#l29.2632"></a><span id="l29.2632" class="difflineplus">+      aJob.goal += deletedCollection.items.length;</span>
<a href="#l29.2633"></a><span id="l29.2633" class="difflineplus">+      for each (let [, message] in Iterator(deletedCollection.items)) {</span>
<a href="#l29.2634"></a><span id="l29.2634" class="difflineplus">+        yield aCallbackHandle.pushAndGo(this._deleteMessage(message,</span>
<a href="#l29.2635"></a><span id="l29.2635" class="difflineplus">+                                                            aCallbackHandle));</span>
<a href="#l29.2636"></a><span id="l29.2636">         aJob.offset++;</span>
<a href="#l29.2637"></a><span id="l29.2637">         yield this.kWorkSync;</span>
<a href="#l29.2638"></a><span id="l29.2638">       }</span>
<a href="#l29.2639"></a><span id="l29.2639"> </span>
<a href="#l29.2640"></a><span id="l29.2640" class="difflineminus">-      processedAny = true;</span>
<a href="#l29.2641"></a><span id="l29.2641" class="difflineminus">-      messagesToDelete = this._datastore.getDeletedMessageBlock();</span>
<a href="#l29.2642"></a><span id="l29.2642" class="difflineplus">+      deletedCollection = query.getCollection(aCallbackHandle);</span>
<a href="#l29.2643"></a><span id="l29.2643" class="difflineplus">+      yield this.kWorkAsync;</span>
<a href="#l29.2644"></a><span id="l29.2644">     }</span>
<a href="#l29.2645"></a><span id="l29.2645" class="difflineminus">-    if (processedAny)</span>
<a href="#l29.2646"></a><span id="l29.2646" class="difflineminus">-      this.pendingDeletions = false;</span>
<a href="#l29.2647"></a><span id="l29.2647" class="difflineplus">+    this.pendingDeletions = false;</span>
<a href="#l29.2648"></a><span id="l29.2648"> </span>
<a href="#l29.2649"></a><span id="l29.2649">     yield this.kWorkDone;</span>
<a href="#l29.2650"></a><span id="l29.2650">   },</span>
<a href="#l29.2651"></a><span id="l29.2651"> </span>
<a href="#l29.2652"></a><span id="l29.2652">   /**</span>
<a href="#l29.2653"></a><span id="l29.2653">    * Determine whether a folder is suitable for indexing.</span>
<a href="#l29.2654"></a><span id="l29.2654">    *</span>
<a href="#l29.2655"></a><span id="l29.2655">    * @param aMsgFolder An nsIMsgFolder you want to see if we should index.</span>
<a href="#l29.2656"></a><span id="l29.2656">    *</span>
<a href="#l29.2657"></a><span id="l29.2657">    * @returns true if we want to index messages in this type of folder, false if</span>
<a href="#l29.2658"></a><span id="l29.2658">    *     we do not.</span>
<a href="#l29.2659"></a><span id="l29.2659">    */</span>
<a href="#l29.2660"></a><span id="l29.2660">   shouldIndexFolder: function(aMsgFolder) {</span>
<a href="#l29.2661"></a><span id="l29.2661">     let folderFlags = aMsgFolder.flags;</span>
<a href="#l29.2662"></a><span id="l29.2662" class="difflineminus">-    // only index mail folders but stay out of virtual folders</span>
<a href="#l29.2663"></a><span id="l29.2663" class="difflineminus">-    return ((folderFlags &amp; Ci.nsMsgFolderFlags.Mail) &amp;&amp;</span>
<a href="#l29.2664"></a><span id="l29.2664" class="difflineminus">-            !(folderFlags &amp; Ci.nsMsgFolderFlags.Virtual));</span>
<a href="#l29.2665"></a><span id="l29.2665" class="difflineplus">+    // Completely ignore non-mail and virtual folders.  They should never even</span>
<a href="#l29.2666"></a><span id="l29.2666" class="difflineplus">+    //  get to be GlodaFolder instances.</span>
<a href="#l29.2667"></a><span id="l29.2667" class="difflineplus">+    if (!(folderFlags &amp; Ci.nsMsgFolderFlags.Mail) ||</span>
<a href="#l29.2668"></a><span id="l29.2668" class="difflineplus">+        (folderFlags &amp; Ci.nsMsgFolderFlags.Virtual))</span>
<a href="#l29.2669"></a><span id="l29.2669" class="difflineplus">+      return false;</span>
<a href="#l29.2670"></a><span id="l29.2670" class="difflineplus">+</span>
<a href="#l29.2671"></a><span id="l29.2671" class="difflineplus">+    // we only index local or IMAP folders</span>
<a href="#l29.2672"></a><span id="l29.2672" class="difflineplus">+    if (!(aMsgFolder instanceof nsIMsgLocalMailFolder) &amp;&amp;</span>
<a href="#l29.2673"></a><span id="l29.2673" class="difflineplus">+        !(aMsgFolder instanceof nsIMsgImapMailFolder))</span>
<a href="#l29.2674"></a><span id="l29.2674" class="difflineplus">+      return false;</span>
<a href="#l29.2675"></a><span id="l29.2675" class="difflineplus">+</span>
<a href="#l29.2676"></a><span id="l29.2676" class="difflineplus">+    // Now see what our gloda folder information has to say about the folder.</span>
<a href="#l29.2677"></a><span id="l29.2677" class="difflineplus">+    let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l29.2678"></a><span id="l29.2678" class="difflineplus">+    return glodaFolder.indexingPriority != glodaFolder.kIndexingNeverPriority;</span>
<a href="#l29.2679"></a><span id="l29.2679">   },</span>
<a href="#l29.2680"></a><span id="l29.2680"> </span>
<a href="#l29.2681"></a><span id="l29.2681">   /**</span>
<a href="#l29.2682"></a><span id="l29.2682">    * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l29.2683"></a><span id="l29.2683">    *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l29.2684"></a><span id="l29.2684">    *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l29.2685"></a><span id="l29.2685">    *  indexed.  (We previously queued accounts rather than immediately</span>
<a href="#l29.2686"></a><span id="l29.2686">    *  walking their list of folders.)</span>
<a href="#l29.2687"></a><span id="l29.2687" class="difflineat">@@ -1949,348 +1550,479 @@ var GlodaIndexer = {</span>
<a href="#l29.2688"></a><span id="l29.2688">                          .createInstance(Ci.nsISupportsArray);</span>
<a href="#l29.2689"></a><span id="l29.2689">       rootFolder.ListDescendents(allFolders);</span>
<a href="#l29.2690"></a><span id="l29.2690">       let numFolders = allFolders.Count();</span>
<a href="#l29.2691"></a><span id="l29.2691">       let folderJobs = [];</span>
<a href="#l29.2692"></a><span id="l29.2692">       for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++) {</span>
<a href="#l29.2693"></a><span id="l29.2693">         let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l29.2694"></a><span id="l29.2694">                                                             Ci.nsIMsgFolder);</span>
<a href="#l29.2695"></a><span id="l29.2695">         if (this.shouldIndexFolder(folder))</span>
<a href="#l29.2696"></a><span id="l29.2696" class="difflineminus">-          folderJobs.push(</span>
<a href="#l29.2697"></a><span id="l29.2697" class="difflineminus">-            new IndexingJob(&quot;folder&quot;, 1, GlodaDatastore._mapFolder(folder).id));</span>
<a href="#l29.2698"></a><span id="l29.2698" class="difflineplus">+          GlodaIndexer.indexJob(</span>
<a href="#l29.2699"></a><span id="l29.2699" class="difflineplus">+            new IndexingJob(&quot;folder&quot;, GlodaDatastore._mapFolder(folder).id));</span>
<a href="#l29.2700"></a><span id="l29.2700">       }</span>
<a href="#l29.2701"></a><span id="l29.2701" class="difflineminus">-</span>
<a href="#l29.2702"></a><span id="l29.2702" class="difflineminus">-      this._indexingJobGoal += folderJobs.length;</span>
<a href="#l29.2703"></a><span id="l29.2703" class="difflineminus">-      this._indexQueue = this._indexQueue.concat(folderJobs);</span>
<a href="#l29.2704"></a><span id="l29.2704" class="difflineminus">-      this.indexing = true;</span>
<a href="#l29.2705"></a><span id="l29.2705">     }</span>
<a href="#l29.2706"></a><span id="l29.2706">     else {</span>
<a href="#l29.2707"></a><span id="l29.2707">       this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l29.2708"></a><span id="l29.2708">     }</span>
<a href="#l29.2709"></a><span id="l29.2709">   },</span>
<a href="#l29.2710"></a><span id="l29.2710"> </span>
<a href="#l29.2711"></a><span id="l29.2711" class="difflineminus">-  indexJob: function glodaIndexJob(aJob) {</span>
<a href="#l29.2712"></a><span id="l29.2712" class="difflineminus">-    this._log.info(&quot;Queue-ing job for indexing: &quot; + aJob.jobType);</span>
<a href="#l29.2713"></a><span id="l29.2713" class="difflineminus">-</span>
<a href="#l29.2714"></a><span id="l29.2714" class="difflineminus">-    this._indexQueue.push(aJob);</span>
<a href="#l29.2715"></a><span id="l29.2715" class="difflineminus">-    this._indexingJobGoal++;</span>
<a href="#l29.2716"></a><span id="l29.2716" class="difflineminus">-    this.indexing = true;</span>
<a href="#l29.2717"></a><span id="l29.2717" class="difflineminus">-  },</span>
<a href="#l29.2718"></a><span id="l29.2718" class="difflineminus">-</span>
<a href="#l29.2719"></a><span id="l29.2719">   /**</span>
<a href="#l29.2720"></a><span id="l29.2720">    * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l29.2721"></a><span id="l29.2721">    */</span>
<a href="#l29.2722"></a><span id="l29.2722" class="difflineminus">-  indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l29.2723"></a><span id="l29.2723" class="difflineminus">-    this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l29.2724"></a><span id="l29.2724" class="difflineplus">+  indexFolder: function glodaIndexFolder(aMsgFolder) {</span>
<a href="#l29.2725"></a><span id="l29.2725" class="difflineplus">+    let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l29.2726"></a><span id="l29.2726" class="difflineplus">+    // stay out of compacting folders</span>
<a href="#l29.2727"></a><span id="l29.2727" class="difflineplus">+    if (glodaFolder.compacting)</span>
<a href="#l29.2728"></a><span id="l29.2728" class="difflineplus">+      return;</span>
<a href="#l29.2729"></a><span id="l29.2729"> </span>
<a href="#l29.2730"></a><span id="l29.2730" class="difflineminus">-    this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l29.2731"></a><span id="l29.2731" class="difflineminus">-                          GlodaDatastore._mapFolder(aFolder).id));</span>
<a href="#l29.2732"></a><span id="l29.2732" class="difflineminus">-    this._indexingJobGoal++;</span>
<a href="#l29.2733"></a><span id="l29.2733" class="difflineminus">-    this.indexing = true;</span>
<a href="#l29.2734"></a><span id="l29.2734" class="difflineplus">+    this._log.info(&quot;Queue-ing folder for indexing: &quot; +</span>
<a href="#l29.2735"></a><span id="l29.2735" class="difflineplus">+                   aMsgFolder.prettiestName);</span>
<a href="#l29.2736"></a><span id="l29.2736" class="difflineplus">+    GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l29.2737"></a><span id="l29.2737">   },</span>
<a href="#l29.2738"></a><span id="l29.2738"> </span>
<a href="#l29.2739"></a><span id="l29.2739">   /**</span>
<a href="#l29.2740"></a><span id="l29.2740">    * Queue a list of messages for indexing.</span>
<a href="#l29.2741"></a><span id="l29.2741">    *</span>
<a href="#l29.2742"></a><span id="l29.2742">    * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l29.2743"></a><span id="l29.2743">    */</span>
<a href="#l29.2744"></a><span id="l29.2744">   indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l29.2745"></a><span id="l29.2745" class="difflineminus">-    let job = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l29.2746"></a><span id="l29.2746" class="difflineplus">+    let job = new IndexingJob(&quot;message&quot;, null);</span>
<a href="#l29.2747"></a><span id="l29.2747">     job.items = [[GlodaDatastore._mapFolder(fm[0]).id, fm[1]] for each</span>
<a href="#l29.2748"></a><span id="l29.2748">                  ([i, fm] in Iterator(aFoldersAndMessages))];</span>
<a href="#l29.2749"></a><span id="l29.2749" class="difflineminus">-    this._indexQueue.push(job);</span>
<a href="#l29.2750"></a><span id="l29.2750" class="difflineminus">-    this._indexingJobGoal++;</span>
<a href="#l29.2751"></a><span id="l29.2751" class="difflineminus">-    this.indexing = true;</span>
<a href="#l29.2752"></a><span id="l29.2752" class="difflineplus">+    GlodaIndexer.indexJob(job);</span>
<a href="#l29.2753"></a><span id="l29.2753">   },</span>
<a href="#l29.2754"></a><span id="l29.2754"> </span>
<a href="#l29.2755"></a><span id="l29.2755">   /**</span>
<a href="#l29.2756"></a><span id="l29.2756">    * Given a message header, return whether this message is likely to have</span>
<a href="#l29.2757"></a><span id="l29.2757">    * been indexed or not.</span>
<a href="#l29.2758"></a><span id="l29.2758">    *</span>
<a href="#l29.2759"></a><span id="l29.2759" class="difflineplus">+   * This means the message must:</span>
<a href="#l29.2760"></a><span id="l29.2760" class="difflineplus">+   * - Be in a folder eligible for gloda indexing. (Not News, etc.)</span>
<a href="#l29.2761"></a><span id="l29.2761" class="difflineplus">+   * - Be in a non-filthy folder.</span>
<a href="#l29.2762"></a><span id="l29.2762" class="difflineplus">+   * - Be gloda-indexed and non-filthy.</span>
<a href="#l29.2763"></a><span id="l29.2763" class="difflineplus">+   *</span>
<a href="#l29.2764"></a><span id="l29.2764">    * @param aMsgHdr A message header.</span>
<a href="#l29.2765"></a><span id="l29.2765">    * @returns true if the message is likely to have been indexed.</span>
<a href="#l29.2766"></a><span id="l29.2766">    */</span>
<a href="#l29.2767"></a><span id="l29.2767">   isMessageIndexed: function gloda_index_isMessageIndexed(aMsgHdr) {</span>
<a href="#l29.2768"></a><span id="l29.2768" class="difflineplus">+    // If it's in a folder that we flat out do not index, say no.</span>
<a href="#l29.2769"></a><span id="l29.2769" class="difflineplus">+    if (!this.shouldIndexFolder(aMsgHdr.folder))</span>
<a href="#l29.2770"></a><span id="l29.2770" class="difflineplus">+      return false;</span>
<a href="#l29.2771"></a><span id="l29.2771">     let glodaFolder = GlodaDatastore._mapFolder(aMsgHdr.folder);</span>
<a href="#l29.2772"></a><span id="l29.2772" class="difflineminus">-    return aMsgHdr.getUint32Property(GLODA_MESSAGE_ID_PROPERTY) != 0 &amp;&amp;</span>
<a href="#l29.2773"></a><span id="l29.2773" class="difflineminus">-           aMsgHdr.getStringProperty(GLODA_DIRTY_PROPERTY) == 0 &amp;&amp;</span>
<a href="#l29.2774"></a><span id="l29.2774" class="difflineminus">-           glodaFolder &amp;&amp; glodaFolder.dirtyStatus != glodaFolder.kFolderFilthy;</span>
<a href="#l29.2775"></a><span id="l29.2775" class="difflineplus">+    let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(aMsgHdr);</span>
<a href="#l29.2776"></a><span id="l29.2776" class="difflineplus">+    return glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l29.2777"></a><span id="l29.2777" class="difflineplus">+           glodaDirty != GlodaMsgIndexer.kMessageFilthy &amp;&amp;</span>
<a href="#l29.2778"></a><span id="l29.2778" class="difflineplus">+           glodaFolder &amp;&amp;</span>
<a href="#l29.2779"></a><span id="l29.2779" class="difflineplus">+           glodaFolder.dirtyStatus != glodaFolder.kFolderFilthy;</span>
<a href="#l29.2780"></a><span id="l29.2780">   },</span>
<a href="#l29.2781"></a><span id="l29.2781"> </span>
<a href="#l29.2782"></a><span id="l29.2782">   /* *********** Event Processing *********** */</span>
<a href="#l29.2783"></a><span id="l29.2783" class="difflineminus">-  observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l29.2784"></a><span id="l29.2784" class="difflineminus">-    // idle</span>
<a href="#l29.2785"></a><span id="l29.2785" class="difflineminus">-    if (aTopic == &quot;idle&quot;) {</span>
<a href="#l29.2786"></a><span id="l29.2786" class="difflineminus">-      // Do we need to commit an indexer transaction?</span>
<a href="#l29.2787"></a><span id="l29.2787" class="difflineminus">-      if (this._idleToCommit) {</span>
<a href="#l29.2788"></a><span id="l29.2788" class="difflineminus">-        this._idleToCommit = false;</span>
<a href="#l29.2789"></a><span id="l29.2789" class="difflineminus">-        GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l29.2790"></a><span id="l29.2790" class="difflineminus">-        GlodaDatastore._commitTransaction();</span>
<a href="#l29.2791"></a><span id="l29.2791" class="difflineminus">-        this._lastCommitTime = Date.now();</span>
<a href="#l29.2792"></a><span id="l29.2792" class="difflineminus">-        this._notifyListeners();</span>
<a href="#l29.2793"></a><span id="l29.2793" class="difflineplus">+  /**</span>
<a href="#l29.2794"></a><span id="l29.2794" class="difflineplus">+   * Common logic for things that want to feed event-driven indexing.  This gets</span>
<a href="#l29.2795"></a><span id="l29.2795" class="difflineplus">+   *  called by both |_msgFolderListener.msgsClassified| when we are first</span>
<a href="#l29.2796"></a><span id="l29.2796" class="difflineplus">+   *  seeing a message as well as by |_folderListener| when things happen to</span>
<a href="#l29.2797"></a><span id="l29.2797" class="difflineplus">+   *  existing messages.  Although we could slightly specialize for the</span>
<a href="#l29.2798"></a><span id="l29.2798" class="difflineplus">+   *  new-to-us case, it works out to be cleaner to just treat them the same</span>
<a href="#l29.2799"></a><span id="l29.2799" class="difflineplus">+   *  and take a very small performance hit.</span>
<a href="#l29.2800"></a><span id="l29.2800" class="difflineplus">+   */</span>
<a href="#l29.2801"></a><span id="l29.2801" class="difflineplus">+  _reindexChangedMessages: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l29.2802"></a><span id="l29.2802" class="difflineplus">+    aMsgHdrs) {</span>
<a href="#l29.2803"></a><span id="l29.2803" class="difflineplus">+    let glodaIdsNeedingDeletion = null;</span>
<a href="#l29.2804"></a><span id="l29.2804" class="difflineplus">+    for each (let msgHdr in fixIterator(aMsgHdrs, nsIMsgDBHdr)) {</span>
<a href="#l29.2805"></a><span id="l29.2805" class="difflineplus">+      // -- Index this folder?</span>
<a href="#l29.2806"></a><span id="l29.2806" class="difflineplus">+      let msgFolder = msgHdr.folder;</span>
<a href="#l29.2807"></a><span id="l29.2807" class="difflineplus">+      if (!this.shouldIndexFolder(msgFolder)) {</span>
<a href="#l29.2808"></a><span id="l29.2808" class="difflineplus">+        continue;</span>
<a href="#l29.2809"></a><span id="l29.2809" class="difflineplus">+      }</span>
<a href="#l29.2810"></a><span id="l29.2810" class="difflineplus">+</span>
<a href="#l29.2811"></a><span id="l29.2811" class="difflineplus">+      // -- Index this message?</span>
<a href="#l29.2812"></a><span id="l29.2812" class="difflineplus">+      // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l29.2813"></a><span id="l29.2813" class="difflineplus">+      // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l29.2814"></a><span id="l29.2814" class="difflineplus">+      let isFolderLocal = msgFolder instanceof nsIMsgLocalMailFolder;</span>
<a href="#l29.2815"></a><span id="l29.2815" class="difflineplus">+      if (!isFolderLocal) {</span>
<a href="#l29.2816"></a><span id="l29.2816" class="difflineplus">+        if (!(msgHdr.flags &amp; nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l29.2817"></a><span id="l29.2817" class="difflineplus">+            (msgFolder.flags &amp; nsMsgFolderFlags.Offline)) {</span>
<a href="#l29.2818"></a><span id="l29.2818" class="difflineplus">+          continue;</span>
<a href="#l29.2819"></a><span id="l29.2819" class="difflineplus">+        }</span>
<a href="#l29.2820"></a><span id="l29.2820" class="difflineplus">+      }</span>
<a href="#l29.2821"></a><span id="l29.2821" class="difflineplus">+</span>
<a href="#l29.2822"></a><span id="l29.2822" class="difflineplus">+      let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(msgHdr);</span>
<a href="#l29.2823"></a><span id="l29.2823" class="difflineplus">+</span>
<a href="#l29.2824"></a><span id="l29.2824" class="difflineplus">+      let isSpam = msgHdr.getStringProperty(JUNK_SCORE_PROPERTY) ==</span>
<a href="#l29.2825"></a><span id="l29.2825" class="difflineplus">+                     JUNK_SPAM_SCORE_STR;</span>
<a href="#l29.2826"></a><span id="l29.2826" class="difflineplus">+</span>
<a href="#l29.2827"></a><span id="l29.2827" class="difflineplus">+      // -- Is the message currently gloda indexed?</span>
<a href="#l29.2828"></a><span id="l29.2828" class="difflineplus">+      if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l29.2829"></a><span id="l29.2829" class="difflineplus">+          glodaDirty != this.kMessageFilthy) {</span>
<a href="#l29.2830"></a><span id="l29.2830" class="difflineplus">+        // - Is the message spam?</span>
<a href="#l29.2831"></a><span id="l29.2831" class="difflineplus">+        if (isSpam) {</span>
<a href="#l29.2832"></a><span id="l29.2832" class="difflineplus">+          // Treat this as a deletion...</span>
<a href="#l29.2833"></a><span id="l29.2833" class="difflineplus">+          if (!glodaIdsNeedingDeletion)</span>
<a href="#l29.2834"></a><span id="l29.2834" class="difflineplus">+            glodaIdsNeedingDeletion = [];</span>
<a href="#l29.2835"></a><span id="l29.2835" class="difflineplus">+          glodaIdsNeedingDeletion.push(glodaId);</span>
<a href="#l29.2836"></a><span id="l29.2836" class="difflineplus">+          // and skip to the next message</span>
<a href="#l29.2837"></a><span id="l29.2837" class="difflineplus">+          continue;</span>
<a href="#l29.2838"></a><span id="l29.2838" class="difflineplus">+        }</span>
<a href="#l29.2839"></a><span id="l29.2839" class="difflineplus">+</span>
<a href="#l29.2840"></a><span id="l29.2840" class="difflineplus">+        // - Mark the message dirty if it is clean.</span>
<a href="#l29.2841"></a><span id="l29.2841" class="difflineplus">+        // (This is the only case in which we need to mark dirty so that the</span>
<a href="#l29.2842"></a><span id="l29.2842" class="difflineplus">+        //  indexing sweep takes care of things if we don't process this in</span>
<a href="#l29.2843"></a><span id="l29.2843" class="difflineplus">+        //  an event-driven fashion.  If the message has no gloda-id or does</span>
<a href="#l29.2844"></a><span id="l29.2844" class="difflineplus">+        //  and it's already dirty or filthy, it is already marked for</span>
<a href="#l29.2845"></a><span id="l29.2845" class="difflineplus">+        //  indexing.)</span>
<a href="#l29.2846"></a><span id="l29.2846" class="difflineplus">+        if (glodaDirty == this.kMessageClean)</span>
<a href="#l29.2847"></a><span id="l29.2847" class="difflineplus">+          msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, this.kMessageDirty);</span>
<a href="#l29.2848"></a><span id="l29.2848" class="difflineplus">+        // if the message is pending clean, this change invalidates that.</span>
<a href="#l29.2849"></a><span id="l29.2849" class="difflineplus">+        PendingCommitTracker.noteDirtyHeader(msgHdr);</span>
<a href="#l29.2850"></a><span id="l29.2850" class="difflineplus">+      }</span>
<a href="#l29.2851"></a><span id="l29.2851" class="difflineplus">+      // If it's not indexed but is spam, ignore it.</span>
<a href="#l29.2852"></a><span id="l29.2852" class="difflineplus">+      else if (isSpam) {</span>
<a href="#l29.2853"></a><span id="l29.2853" class="difflineplus">+        continue;</span>
<a href="#l29.2854"></a><span id="l29.2854" class="difflineplus">+      }</span>
<a href="#l29.2855"></a><span id="l29.2855" class="difflineplus">+      // (we want to index the message if we are here)</span>
<a href="#l29.2856"></a><span id="l29.2856" class="difflineplus">+</span>
<a href="#l29.2857"></a><span id="l29.2857" class="difflineplus">+      // mark the folder dirty too, so we know to look inside</span>
<a href="#l29.2858"></a><span id="l29.2858" class="difflineplus">+      let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l29.2859"></a><span id="l29.2859" class="difflineplus">+      glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l29.2860"></a><span id="l29.2860" class="difflineplus">+</span>
<a href="#l29.2861"></a><span id="l29.2861" class="difflineplus">+      if (this._pendingAddJob == null) {</span>
<a href="#l29.2862"></a><span id="l29.2862" class="difflineplus">+        this._pendingAddJob = new IndexingJob(&quot;message&quot;, null);</span>
<a href="#l29.2863"></a><span id="l29.2863" class="difflineplus">+        GlodaIndexer.indexJob(this._pendingAddJob);</span>
<a href="#l29.2864"></a><span id="l29.2864" class="difflineplus">+      }</span>
<a href="#l29.2865"></a><span id="l29.2865" class="difflineplus">+      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l29.2866"></a><span id="l29.2866" class="difflineplus">+      if (this._pendingAddJob.items.length &lt;</span>
<a href="#l29.2867"></a><span id="l29.2867" class="difflineplus">+          this._indexMaxEventQueueMessages) {</span>
<a href="#l29.2868"></a><span id="l29.2868" class="difflineplus">+        this._pendingAddJob.items.push(</span>
<a href="#l29.2869"></a><span id="l29.2869" class="difflineplus">+          [GlodaDatastore._mapFolder(msgFolder).id, msgHdr.messageKey]);</span>
<a href="#l29.2870"></a><span id="l29.2870" class="difflineplus">+      }</span>
<a href="#l29.2871"></a><span id="l29.2871" class="difflineplus">+      else {</span>
<a href="#l29.2872"></a><span id="l29.2872" class="difflineplus">+        this.indexingSweepNeeded = true;</span>
<a href="#l29.2873"></a><span id="l29.2873">       }</span>
<a href="#l29.2874"></a><span id="l29.2874">     }</span>
<a href="#l29.2875"></a><span id="l29.2875" class="difflineminus">-    // offline status</span>
<a href="#l29.2876"></a><span id="l29.2876" class="difflineminus">-    else if (aTopic == &quot;network:offline-status-changed&quot;) {</span>
<a href="#l29.2877"></a><span id="l29.2877" class="difflineminus">-      if (aData == &quot;offline&quot;) {</span>
<a href="#l29.2878"></a><span id="l29.2878" class="difflineminus">-        this.suppressIndexing = true;</span>
<a href="#l29.2879"></a><span id="l29.2879" class="difflineminus">-      }</span>
<a href="#l29.2880"></a><span id="l29.2880" class="difflineminus">-      else { // online</span>
<a href="#l29.2881"></a><span id="l29.2881" class="difflineminus">-        this.suppressIndexing = false;</span>
<a href="#l29.2882"></a><span id="l29.2882" class="difflineminus">-      }</span>
<a href="#l29.2883"></a><span id="l29.2883" class="difflineminus">-    }</span>
<a href="#l29.2884"></a><span id="l29.2884" class="difflineminus">-    // shutdown fallback</span>
<a href="#l29.2885"></a><span id="l29.2885" class="difflineminus">-    else if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l29.2886"></a><span id="l29.2886" class="difflineminus">-      this._shutdown();</span>
<a href="#l29.2887"></a><span id="l29.2887" class="difflineplus">+</span>
<a href="#l29.2888"></a><span id="l29.2888" class="difflineplus">+    // If we accumulated any deletions in there, batch them off now.</span>
<a href="#l29.2889"></a><span id="l29.2889" class="difflineplus">+    if (glodaIdsNeedingDeletion) {</span>
<a href="#l29.2890"></a><span id="l29.2890" class="difflineplus">+      GlodaDatastore.markMessagesDeletedByIDs(glodaIdsNeedingDeletion);</span>
<a href="#l29.2891"></a><span id="l29.2891" class="difflineplus">+      this.pendingDeletions = true;</span>
<a href="#l29.2892"></a><span id="l29.2892">     }</span>
<a href="#l29.2893"></a><span id="l29.2893">   },</span>
<a href="#l29.2894"></a><span id="l29.2894"> </span>
<a href="#l29.2895"></a><span id="l29.2895" class="difflineplus">+</span>
<a href="#l29.2896"></a><span id="l29.2896">   /* ***** Folder Changes ***** */</span>
<a href="#l29.2897"></a><span id="l29.2897">   /**</span>
<a href="#l29.2898"></a><span id="l29.2898">    * All additions and removals are queued for processing.  Indexing messages</span>
<a href="#l29.2899"></a><span id="l29.2899">    *  is potentially phenomenally expensive, and deletion can still be</span>
<a href="#l29.2900"></a><span id="l29.2900">    *  relatively expensive due to our need to delete the message, its</span>
<a href="#l29.2901"></a><span id="l29.2901">    *  attributes, and all attributes that reference it.  Additionally,</span>
<a href="#l29.2902"></a><span id="l29.2902">    *  attribute deletion costs are higher than attribute look-up because</span>
<a href="#l29.2903"></a><span id="l29.2903">    *  there is the actual row plus its 3 indices, and our covering indices are</span>
<a href="#l29.2904"></a><span id="l29.2904">    *  no help there.</span>
<a href="#l29.2905"></a><span id="l29.2905">    *</span>
<a href="#l29.2906"></a><span id="l29.2906">    */</span>
<a href="#l29.2907"></a><span id="l29.2907">   _msgFolderListener: {</span>
<a href="#l29.2908"></a><span id="l29.2908">     indexer: null,</span>
<a href="#l29.2909"></a><span id="l29.2909"> </span>
<a href="#l29.2910"></a><span id="l29.2910">     /**</span>
<a href="#l29.2911"></a><span id="l29.2911" class="difflineminus">-     * Handle a new-to-thunderbird message, meaning a newly fetched message</span>
<a href="#l29.2912"></a><span id="l29.2912" class="difflineminus">-     *  (local folder) one revealed by synching with the server (IMAP).  Because</span>
<a href="#l29.2913"></a><span id="l29.2913" class="difflineminus">-     *  the new-to-IMAP case requires Thunderbird to have opened the folder,</span>
<a href="#l29.2914"></a><span id="l29.2914" class="difflineminus">-     *  we either need to depend on MailNews to be aggressive about looking</span>
<a href="#l29.2915"></a><span id="l29.2915" class="difflineminus">-     *  for new messages in folders or try and do it ourselves.  For now, we</span>
<a href="#l29.2916"></a><span id="l29.2916" class="difflineminus">-     *  leave it up to MailNews proper.</span>
<a href="#l29.2917"></a><span id="l29.2917" class="difflineminus">-     *</span>
<a href="#l29.2918"></a><span id="l29.2918" class="difflineminus">-     * For the time being, we post the message header as received to our</span>
<a href="#l29.2919"></a><span id="l29.2919" class="difflineminus">-     *  indexing queue.  Depending on experience, it may be more suitable to</span>
<a href="#l29.2920"></a><span id="l29.2920" class="difflineminus">-     *  try and index the message immediately, or hold onto a less specific</span>
<a href="#l29.2921"></a><span id="l29.2921" class="difflineminus">-     *  form of message information than the nsIMsgDBHdr.  (If we were to</span>
<a href="#l29.2922"></a><span id="l29.2922" class="difflineminus">-     *  process immediately, it might appropriate to consider having a</span>
<a href="#l29.2923"></a><span id="l29.2923" class="difflineminus">-     *  transaction open that is commited by timer/sufficient activity, since it</span>
<a href="#l29.2924"></a><span id="l29.2924" class="difflineminus">-     *  is conceivable we will see a number of these events in fairly rapid</span>
<a href="#l29.2925"></a><span id="l29.2925" class="difflineminus">-     *  succession.)</span>
<a href="#l29.2926"></a><span id="l29.2926" class="difflineplus">+     * We no longer use the msgAdded notification, instead opting to wait until</span>
<a href="#l29.2927"></a><span id="l29.2927" class="difflineplus">+     *  junk/trait classification has run (or decided not to run) and all</span>
<a href="#l29.2928"></a><span id="l29.2928" class="difflineplus">+     *  filters have run.  The msgsClassified notification provides that for us.</span>
<a href="#l29.2929"></a><span id="l29.2929">      */</span>
<a href="#l29.2930"></a><span id="l29.2930">     msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l29.2931"></a><span id="l29.2931" class="difflineminus">-      // make sure the message is eligible for indexing...</span>
<a href="#l29.2932"></a><span id="l29.2932" class="difflineminus">-      let msgFolder = aMsgHdr.folder;</span>
<a href="#l29.2933"></a><span id="l29.2933" class="difflineminus">-      if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l29.2934"></a><span id="l29.2934" class="difflineminus">-        return;</span>
<a href="#l29.2935"></a><span id="l29.2935" class="difflineminus">-</span>
<a href="#l29.2936"></a><span id="l29.2936" class="difflineminus">-      // Make sure the message is eligible for indexing.</span>
<a href="#l29.2937"></a><span id="l29.2937" class="difflineminus">-      // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l29.2938"></a><span id="l29.2938" class="difflineminus">-      // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l29.2939"></a><span id="l29.2939" class="difflineminus">-      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l29.2940"></a><span id="l29.2940" class="difflineminus">-      if (!isFolderLocal) {</span>
<a href="#l29.2941"></a><span id="l29.2941" class="difflineminus">-        if (!(aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l29.2942"></a><span id="l29.2942" class="difflineminus">-            (msgFolder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l29.2943"></a><span id="l29.2943" class="difflineminus">-          return;</span>
<a href="#l29.2944"></a><span id="l29.2944" class="difflineminus">-      }</span>
<a href="#l29.2945"></a><span id="l29.2945" class="difflineplus">+      // we are never called! we do not enable this bit!</span>
<a href="#l29.2946"></a><span id="l29.2946" class="difflineplus">+    },</span>
<a href="#l29.2947"></a><span id="l29.2947"> </span>
<a href="#l29.2948"></a><span id="l29.2948" class="difflineminus">-      // mark the folder dirty so we know to look in it, but there is no need</span>
<a href="#l29.2949"></a><span id="l29.2949" class="difflineminus">-      //  to mark the message because it will lack a gloda-id anyways.</span>
<a href="#l29.2950"></a><span id="l29.2950" class="difflineminus">-      let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l29.2951"></a><span id="l29.2951" class="difflineminus">-      glodaFolder.dirtyStatus = true;</span>
<a href="#l29.2952"></a><span id="l29.2952" class="difflineminus">-</span>
<a href="#l29.2953"></a><span id="l29.2953" class="difflineminus">-      if (this.indexer._pendingAddJob === null) {</span>
<a href="#l29.2954"></a><span id="l29.2954" class="difflineminus">-        this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l29.2955"></a><span id="l29.2955" class="difflineminus">-        this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l29.2956"></a><span id="l29.2956" class="difflineminus">-        this.indexer._indexingJobGoal++;</span>
<a href="#l29.2957"></a><span id="l29.2957" class="difflineplus">+    /**</span>
<a href="#l29.2958"></a><span id="l29.2958" class="difflineplus">+     * XXX We treat all messages we see as if they have undergone a dirtying</span>
<a href="#l29.2959"></a><span id="l29.2959" class="difflineplus">+     *  event.  However, we should really be leveraging the hard work of the</span>
<a href="#l29.2960"></a><span id="l29.2960" class="difflineplus">+     *  mailnews IMAP subsystem to fast-path the IMAP move case and just</span>
<a href="#l29.2961"></a><span id="l29.2961" class="difflineplus">+     *  update the location information.</span>
<a href="#l29.2962"></a><span id="l29.2962" class="difflineplus">+     */</span>
<a href="#l29.2963"></a><span id="l29.2963" class="difflineplus">+    msgsClassified: function gloda_indexer_msgsClassified(</span>
<a href="#l29.2964"></a><span id="l29.2964" class="difflineplus">+                      aMsgHdrs, aJunkClassified, aTraitClassified) {</span>
<a href="#l29.2965"></a><span id="l29.2965" class="difflineplus">+      this.indexer._log.debug(&quot;msgsClassified notification&quot;);</span>
<a href="#l29.2966"></a><span id="l29.2966" class="difflineplus">+      try {</span>
<a href="#l29.2967"></a><span id="l29.2967" class="difflineplus">+        GlodaMsgIndexer._reindexChangedMessages(aMsgHdrs.enumerate());</span>
<a href="#l29.2968"></a><span id="l29.2968">       }</span>
<a href="#l29.2969"></a><span id="l29.2969" class="difflineminus">-      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l29.2970"></a><span id="l29.2970" class="difflineminus">-      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l29.2971"></a><span id="l29.2971" class="difflineminus">-          this.indexer._indexMaxEventQueueMessages) {</span>
<a href="#l29.2972"></a><span id="l29.2972" class="difflineminus">-        this.indexer._pendingAddJob.items.push(</span>
<a href="#l29.2973"></a><span id="l29.2973" class="difflineminus">-          [glodaFolder.id, aMsgHdr.messageKey]);</span>
<a href="#l29.2974"></a><span id="l29.2974" class="difflineminus">-        this.indexer.indexing = true;</span>
<a href="#l29.2975"></a><span id="l29.2975" class="difflineminus">-        this.indexer._log.debug(&quot;msgAdded notification, event indexing&quot;);</span>
<a href="#l29.2976"></a><span id="l29.2976" class="difflineminus">-      }</span>
<a href="#l29.2977"></a><span id="l29.2977" class="difflineminus">-      else {</span>
<a href="#l29.2978"></a><span id="l29.2978" class="difflineminus">-        this.indexer.indexingSweepNeeded = true;</span>
<a href="#l29.2979"></a><span id="l29.2979" class="difflineminus">-        this.indexer._log.debug(&quot;msgAdded notification, sweep indexing&quot;);</span>
<a href="#l29.2980"></a><span id="l29.2980" class="difflineplus">+      catch (ex) {</span>
<a href="#l29.2981"></a><span id="l29.2981" class="difflineplus">+        this.indexer._log.error(&quot;Explosion in msgsClassified handling: &quot; +</span>
<a href="#l29.2982"></a><span id="l29.2982" class="difflineplus">+                                ex.stack);</span>
<a href="#l29.2983"></a><span id="l29.2983">       }</span>
<a href="#l29.2984"></a><span id="l29.2984">     },</span>
<a href="#l29.2985"></a><span id="l29.2985"> </span>
<a href="#l29.2986"></a><span id="l29.2986">     /**</span>
<a href="#l29.2987"></a><span id="l29.2987">      * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l29.2988"></a><span id="l29.2988" class="difflineminus">-     *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l29.2989"></a><span id="l29.2989" class="difflineplus">+     *  don't count); we only see the deletion here when it becomes forever,</span>
<a href="#l29.2990"></a><span id="l29.2990">      *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l29.2991"></a><span id="l29.2991">      *  going away, we need to either process things immediately or extract the</span>
<a href="#l29.2992"></a><span id="l29.2992">      *  information required to purge it later without the header.</span>
<a href="#l29.2993"></a><span id="l29.2993">      * To this end, we mark all messages that were indexed in the gloda message</span>
<a href="#l29.2994"></a><span id="l29.2994">      *  database as deleted.  We set our pending deletions flag to let our</span>
<a href="#l29.2995"></a><span id="l29.2995">      *  indexing logic know that after its next wave of folder traversal, it</span>
<a href="#l29.2996"></a><span id="l29.2996">      *  should perform a deletion pass.  If it turns out the messages are coming</span>
<a href="#l29.2997"></a><span id="l29.2997">      *  back, the fact that deletion is thus deferred can be handy, as we can</span>
<a href="#l29.2998"></a><span id="l29.2998">      *  reuse the existing gloda message.</span>
<a href="#l29.2999"></a><span id="l29.2999">      */</span>
<a href="#l29.3000"></a><span id="l29.3000">     msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l29.3001"></a><span id="l29.3001">       this.indexer._log.debug(&quot;msgsDeleted notification&quot;);</span>
<a href="#l29.3002"></a><span id="l29.3002" class="difflineminus">-</span>
<a href="#l29.3003"></a><span id="l29.3003">       let glodaMessageIds = [];</span>
<a href="#l29.3004"></a><span id="l29.3004"> </span>
<a href="#l29.3005"></a><span id="l29.3005" class="difflineminus">-      let deleteJob = new IndexingJob(&quot;message&quot;, -1, null);</span>
<a href="#l29.3006"></a><span id="l29.3006">       for (let iMsgHdr = 0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l29.3007"></a><span id="l29.3007" class="difflineminus">-        let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l29.3008"></a><span id="l29.3008" class="difflineminus">-        try {</span>
<a href="#l29.3009"></a><span id="l29.3009" class="difflineminus">-          glodaMessageIds.push(msgHdr.getUint32Property(</span>
<a href="#l29.3010"></a><span id="l29.3010" class="difflineminus">-            GLODA_MESSAGE_ID_PROPERTY));</span>
<a href="#l29.3011"></a><span id="l29.3011" class="difflineminus">-        }</span>
<a href="#l29.3012"></a><span id="l29.3012" class="difflineminus">-        catch (ex) {}</span>
<a href="#l29.3013"></a><span id="l29.3013" class="difflineplus">+        let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, nsIMsgDBHdr);</span>
<a href="#l29.3014"></a><span id="l29.3014" class="difflineplus">+        let [glodaId, glodaDirty] = PendingCommitTracker.getGlodaState(msgHdr);</span>
<a href="#l29.3015"></a><span id="l29.3015" class="difflineplus">+        if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l29.3016"></a><span id="l29.3016" class="difflineplus">+            glodaDirty != GlodaMsgIndexer.kMessageFilthy)</span>
<a href="#l29.3017"></a><span id="l29.3017" class="difflineplus">+          glodaMessageIds.push(glodaId);</span>
<a href="#l29.3018"></a><span id="l29.3018">       }</span>
<a href="#l29.3019"></a><span id="l29.3019"> </span>
<a href="#l29.3020"></a><span id="l29.3020">       if (glodaMessageIds.length) {</span>
<a href="#l29.3021"></a><span id="l29.3021" class="difflineminus">-        this.indexer._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l29.3022"></a><span id="l29.3022" class="difflineminus">-        this.indexer.pendingDeletions = true;</span>
<a href="#l29.3023"></a><span id="l29.3023" class="difflineplus">+        GlodaMsgIndexer._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l29.3024"></a><span id="l29.3024" class="difflineplus">+        GlodaMsgIndexer.pendingDeletions = true;</span>
<a href="#l29.3025"></a><span id="l29.3025">       }</span>
<a href="#l29.3026"></a><span id="l29.3026">     },</span>
<a href="#l29.3027"></a><span id="l29.3027"> </span>
<a href="#l29.3028"></a><span id="l29.3028">     /**</span>
<a href="#l29.3029"></a><span id="l29.3029">      * Process a move or copy.</span>
<a href="#l29.3030"></a><span id="l29.3030" class="difflineminus">-     * Moves to a local folder can be dealt with (relatively) efficiently; the</span>
<a href="#l29.3031"></a><span id="l29.3031" class="difflineminus">-     *  target message headers exist at the time of the notification.  The trick</span>
<a href="#l29.3032"></a><span id="l29.3032" class="difflineminus">-     *  is that we aren't provided with them.</span>
<a href="#l29.3033"></a><span id="l29.3033" class="difflineminus">-     * Moves to an IMAP folder are troublesome because mailnews may not actually</span>
<a href="#l29.3034"></a><span id="l29.3034" class="difflineminus">-     *  know anything about the messages in their new location.  If there isn't</span>
<a href="#l29.3035"></a><span id="l29.3035" class="difflineminus">-     *  a currently open connection to the destination folder, we will only hear</span>
<a href="#l29.3036"></a><span id="l29.3036" class="difflineminus">-     *  about the headers when the user browses there or IMAP auto-sync gets to</span>
<a href="#l29.3037"></a><span id="l29.3037" class="difflineminus">-     *  the folder.  Either way, we will actually receive a msgAdded event for</span>
<a href="#l29.3038"></a><span id="l29.3038" class="difflineminus">-     *  each message, so the main thing we need to do is provide a hint to the</span>
<a href="#l29.3039"></a><span id="l29.3039" class="difflineminus">-     *  indexing logic that the gloda message in question should be reused and</span>
<a href="#l29.3040"></a><span id="l29.3040" class="difflineminus">-     *  is not a duplicate.</span>
<a href="#l29.3041"></a><span id="l29.3041" class="difflineplus">+     *</span>
<a href="#l29.3042"></a><span id="l29.3042" class="difflineplus">+     * Moves to a local folder are dealt with efficiently because we get both</span>
<a href="#l29.3043"></a><span id="l29.3043" class="difflineplus">+     *  the source and destination headers.  The only non-obvious thing is that</span>
<a href="#l29.3044"></a><span id="l29.3044" class="difflineplus">+     *  we need to make sure that we deal with the impact of filthy folders and</span>
<a href="#l29.3045"></a><span id="l29.3045" class="difflineplus">+     *  messages on gloda-id's (they invalidate the gloda-id).</span>
<a href="#l29.3046"></a><span id="l29.3046" class="difflineplus">+     *</span>
<a href="#l29.3047"></a><span id="l29.3047" class="difflineplus">+     * Moves to an IMAP folder do not provide us with the target header, but the</span>
<a href="#l29.3048"></a><span id="l29.3048" class="difflineplus">+     *  IMAP code does have support for propagating properties on the message</span>
<a href="#l29.3049"></a><span id="l29.3049" class="difflineplus">+     *  header so when we see it in the msgsClassified (or msgAdded if we used</span>
<a href="#l29.3050"></a><span id="l29.3050" class="difflineplus">+     *  that anymore), it should have the properties of the source message</span>
<a href="#l29.3051"></a><span id="l29.3051" class="difflineplus">+     *  copied over.</span>
<a href="#l29.3052"></a><span id="l29.3052" class="difflineplus">+     * We make sure that gloda-id's do not get propagated when messages are</span>
<a href="#l29.3053"></a><span id="l29.3053" class="difflineplus">+     *  moved from IMAP folders that are marked filthy or are marked as not</span>
<a href="#l29.3054"></a><span id="l29.3054" class="difflineplus">+     *  supposed to be indexed by clearing the pending attributes for the header</span>
<a href="#l29.3055"></a><span id="l29.3055" class="difflineplus">+     *  being tracked by the destination IMAP folder.</span>
<a href="#l29.3056"></a><span id="l29.3056" class="difflineplus">+     * XXX We will receive a msgsClassified event for each message, so the</span>
<a href="#l29.3057"></a><span id="l29.3057" class="difflineplus">+     *  main thing we need to do is provide a hint to the indexing logic that</span>
<a href="#l29.3058"></a><span id="l29.3058" class="difflineplus">+     *  the gloda message in question should be reused and is not a duplicate.</span>
<a href="#l29.3059"></a><span id="l29.3059" class="difflineplus">+     * We could fast-path the IMAP move case in msgsClassified by noticing that</span>
<a href="#l29.3060"></a><span id="l29.3060" class="difflineplus">+     *  a message is showing up with a gloda-id header already and just</span>
<a href="#l29.3061"></a><span id="l29.3061" class="difflineplus">+     *  performing an async location update.</span>
<a href="#l29.3062"></a><span id="l29.3062" class="difflineplus">+</span>
<a href="#l29.3063"></a><span id="l29.3063" class="difflineplus">+     *</span>
<a href="#l29.3064"></a><span id="l29.3064">      * Because copied messages are, by their nature, duplicate messages, we</span>
<a href="#l29.3065"></a><span id="l29.3065">      *  do not particularly care about them.  As such, we defer their processing</span>
<a href="#l29.3066"></a><span id="l29.3066">      *  to the automatic sync logic that will happen much later on.  This is</span>
<a href="#l29.3067"></a><span id="l29.3067">      *  potentially desirable in case the user deletes some of the original</span>
<a href="#l29.3068"></a><span id="l29.3068">      *  messages, allowing us to reuse the gloda message representations when</span>
<a href="#l29.3069"></a><span id="l29.3069">      *  we finally get around to indexing the messages.  We do need to mark the</span>
<a href="#l29.3070"></a><span id="l29.3070">      *  folder as dirty, though, to clue in the sync logic.</span>
<a href="#l29.3071"></a><span id="l29.3071">      */</span>
<a href="#l29.3072"></a><span id="l29.3072">     msgsMoveCopyCompleted: function gloda_indexer_msgsMoveCopyCompleted(aMove,</span>
<a href="#l29.3073"></a><span id="l29.3073" class="difflineminus">-                             aSrcMsgHdrs, aDestFolder) {</span>
<a href="#l29.3074"></a><span id="l29.3074" class="difflineplus">+                             aSrcMsgHdrs, aDestFolder, aDestMsgHdrs) {</span>
<a href="#l29.3075"></a><span id="l29.3075">       this.indexer._log.debug(&quot;MoveCopy notification.  Move: &quot; + aMove);</span>
<a href="#l29.3076"></a><span id="l29.3076">       try {</span>
<a href="#l29.3077"></a><span id="l29.3077" class="difflineplus">+        // ---- Move</span>
<a href="#l29.3078"></a><span id="l29.3078">         if (aMove) {</span>
<a href="#l29.3079"></a><span id="l29.3079" class="difflineminus">-          // target is a local folder, we can find the destination messages</span>
<a href="#l29.3080"></a><span id="l29.3080" class="difflineminus">-          if (aDestFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l29.3081"></a><span id="l29.3081" class="difflineminus">-            // ...of course, finding the destination messages is not going to</span>
<a href="#l29.3082"></a><span id="l29.3082" class="difflineminus">-            //  be cheap.  we're O(n) for the messages in the target folder</span>
<a href="#l29.3083"></a><span id="l29.3083" class="difflineminus">-            //  (which is &gt;= the number of moved messages).</span>
<a href="#l29.3084"></a><span id="l29.3084" class="difflineminus">-            // XXX for now, we assume the gloda-id is not propagated at the</span>
<a href="#l29.3085"></a><span id="l29.3085" class="difflineminus">-            //  cost of getting confused if multiple messages have the same</span>
<a href="#l29.3086"></a><span id="l29.3086" class="difflineminus">-            //  message-id header; we would do better to get the gloda-id</span>
<a href="#l29.3087"></a><span id="l29.3087" class="difflineminus">-            //  propagated and use that.  (needs C++ code changes.)</span>
<a href="#l29.3088"></a><span id="l29.3088" class="difflineminus">-            // (we would still need to do the traversal because we still need</span>
<a href="#l29.3089"></a><span id="l29.3089" class="difflineminus">-            //  to know the messageKey in the target folder...)</span>
<a href="#l29.3090"></a><span id="l29.3090" class="difflineminus">-            let srcMsgIdToHdr = {};</span>
<a href="#l29.3091"></a><span id="l29.3091" class="difflineplus">+          // -- Effectively a deletion?</span>
<a href="#l29.3092"></a><span id="l29.3092" class="difflineplus">+          // If the destination folder is not indexed, it's like these messages</span>
<a href="#l29.3093"></a><span id="l29.3093" class="difflineplus">+          //  are being deleted.</span>
<a href="#l29.3094"></a><span id="l29.3094" class="difflineplus">+          if (!GlodaMsgIndexer.shouldIndexFolder(aDestFolder)) {</span>
<a href="#l29.3095"></a><span id="l29.3095" class="difflineplus">+            this.msgsDeleted(aSrcMsgHdrs);</span>
<a href="#l29.3096"></a><span id="l29.3096" class="difflineplus">+            return;</span>
<a href="#l29.3097"></a><span id="l29.3097" class="difflineplus">+          }</span>
<a href="#l29.3098"></a><span id="l29.3098" class="difflineplus">+</span>
<a href="#l29.3099"></a><span id="l29.3099" class="difflineplus">+          // -- Avoid propagation of filthy gloda-id's.</span>
<a href="#l29.3100"></a><span id="l29.3100" class="difflineplus">+          // If the source folder is filthy or should not be indexed (and so</span>
<a href="#l29.3101"></a><span id="l29.3101" class="difflineplus">+          //  any gloda-id's found in there are gibberish), our only job is to</span>
<a href="#l29.3102"></a><span id="l29.3102" class="difflineplus">+          //  strip the gloda-id's off of all the destination headers because</span>
<a href="#l29.3103"></a><span id="l29.3103" class="difflineplus">+          //  none of the gloda-id's are valid (and so we certainly don't want</span>
<a href="#l29.3104"></a><span id="l29.3104" class="difflineplus">+          //  to try and use them as a basis for updating message keys.)</span>
<a href="#l29.3105"></a><span id="l29.3105" class="difflineplus">+          let srcMsgFolder = aSrcMsgHdrs.queryElementAt(0, nsIMsgDBHdr).folder;</span>
<a href="#l29.3106"></a><span id="l29.3106" class="difflineplus">+          if (!this.indexer.shouldIndexFolder(srcMsgFolder) ||</span>
<a href="#l29.3107"></a><span id="l29.3107" class="difflineplus">+              (GlodaDatastore._mapFolder(srcMsgFolder).dirtyStatus ==</span>
<a href="#l29.3108"></a><span id="l29.3108" class="difflineplus">+                 GlodaFolder.prototype.kFolderFilthy)) {</span>
<a href="#l29.3109"></a><span id="l29.3109" class="difflineplus">+            // Local case, just modify the destination headers directly.</span>
<a href="#l29.3110"></a><span id="l29.3110" class="difflineplus">+            if (aDestMsgHdrs) {</span>
<a href="#l29.3111"></a><span id="l29.3111" class="difflineplus">+              for each (let destMsgHdr in fixIterator(aDestMsgHdrs.enumerate(),</span>
<a href="#l29.3112"></a><span id="l29.3112" class="difflineplus">+                                                      nsIMsgDBHdr)) {</span>
<a href="#l29.3113"></a><span id="l29.3113" class="difflineplus">+                // zero it out if it exists</span>
<a href="#l29.3114"></a><span id="l29.3114" class="difflineplus">+                // (no need to deal with pending commit issues here; a filthy</span>
<a href="#l29.3115"></a><span id="l29.3115" class="difflineplus">+                //  folder by definition has nothing indexed in it.)</span>
<a href="#l29.3116"></a><span id="l29.3116" class="difflineplus">+                let glodaId = destMsgHdr.getUint32Property(</span>
<a href="#l29.3117"></a><span id="l29.3117" class="difflineplus">+                                GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.3118"></a><span id="l29.3118" class="difflineplus">+                if (glodaId)</span>
<a href="#l29.3119"></a><span id="l29.3119" class="difflineplus">+                  destMsgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY,</span>
<a href="#l29.3120"></a><span id="l29.3120" class="difflineplus">+                                               0);</span>
<a href="#l29.3121"></a><span id="l29.3121" class="difflineplus">+              }</span>
<a href="#l29.3122"></a><span id="l29.3122"> </span>
<a href="#l29.3123"></a><span id="l29.3123" class="difflineminus">-            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l29.3124"></a><span id="l29.3124" class="difflineminus">-              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l29.3125"></a><span id="l29.3125" class="difflineminus">-              // (note: collissions on message-id headers are possible and sad)</span>
<a href="#l29.3126"></a><span id="l29.3126" class="difflineminus">-              srcMsgIdToHdr[msgHdr.messageId] = msgHdr;</span>
<a href="#l29.3127"></a><span id="l29.3127" class="difflineplus">+              // Since we are moving messages from a folder where they were</span>
<a href="#l29.3128"></a><span id="l29.3128" class="difflineplus">+              //  effectively not indexed, it is up to us to make sure the</span>
<a href="#l29.3129"></a><span id="l29.3129" class="difflineplus">+              //  messages now get indexed.</span>
<a href="#l29.3130"></a><span id="l29.3130" class="difflineplus">+              this.indexer._reindexChangedMessages(aDestMsgHdrs.enumerate());</span>
<a href="#l29.3131"></a><span id="l29.3131" class="difflineplus">+              return;</span>
<a href="#l29.3132"></a><span id="l29.3132">             }</span>
<a href="#l29.3133"></a><span id="l29.3133" class="difflineplus">+            // IMAP move case, we need to operate on the pending headers using</span>
<a href="#l29.3134"></a><span id="l29.3134" class="difflineplus">+            //  the source header to get the pending header and as the</span>
<a href="#l29.3135"></a><span id="l29.3135" class="difflineplus">+            //  indication of what has been already set on the pending header.</span>
<a href="#l29.3136"></a><span id="l29.3136" class="difflineplus">+            else {</span>
<a href="#l29.3137"></a><span id="l29.3137" class="difflineplus">+              let destDb;</span>
<a href="#l29.3138"></a><span id="l29.3138" class="difflineplus">+              // so, this can fail, and there's not much we can do about it.</span>
<a href="#l29.3139"></a><span id="l29.3139" class="difflineplus">+              try {</span>
<a href="#l29.3140"></a><span id="l29.3140" class="difflineplus">+                destDb = aDestFolder.msgDatabase;</span>
<a href="#l29.3141"></a><span id="l29.3141" class="difflineplus">+              } catch (ex) {</span>
<a href="#l29.3142"></a><span id="l29.3142" class="difflineplus">+                this.indexer._log.warn(&quot;Destination database for &quot; +</span>
<a href="#l29.3143"></a><span id="l29.3143" class="difflineplus">+                                       aDestFolder.prettiestName +</span>
<a href="#l29.3144"></a><span id="l29.3144" class="difflineplus">+                                       &quot; not ready on IMAP move.&quot; +</span>
<a href="#l29.3145"></a><span id="l29.3145" class="difflineplus">+                                       &quot; Gloda corruption possible.&quot;);</span>
<a href="#l29.3146"></a><span id="l29.3146" class="difflineplus">+                return;</span>
<a href="#l29.3147"></a><span id="l29.3147" class="difflineplus">+              }</span>
<a href="#l29.3148"></a><span id="l29.3148" class="difflineplus">+              for each (let srcMsgHdr in fixIterator(aSrcMsgHdrs.enumerate(),</span>
<a href="#l29.3149"></a><span id="l29.3149" class="difflineplus">+                                                     nsIMsgDBHdr)) {</span>
<a href="#l29.3150"></a><span id="l29.3150" class="difflineplus">+                // zero it out if it exists</span>
<a href="#l29.3151"></a><span id="l29.3151" class="difflineplus">+                // (no need to deal with pending commit issues here; a filthy</span>
<a href="#l29.3152"></a><span id="l29.3152" class="difflineplus">+                //  folder by definition has nothing indexed in it.)</span>
<a href="#l29.3153"></a><span id="l29.3153" class="difflineplus">+                let glodaId = srcMsgHdr.getUint32Property(</span>
<a href="#l29.3154"></a><span id="l29.3154" class="difflineplus">+                                GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.3155"></a><span id="l29.3155" class="difflineplus">+                if (glodaId)</span>
<a href="#l29.3156"></a><span id="l29.3156" class="difflineplus">+                  destDb.setUint32AttributeOnPendingHdr(</span>
<a href="#l29.3157"></a><span id="l29.3157" class="difflineplus">+                    srcMsgHdr, GLODA_MESSAGE_ID_PROPERTY, 0);</span>
<a href="#l29.3158"></a><span id="l29.3158" class="difflineplus">+              }</span>
<a href="#l29.3159"></a><span id="l29.3159" class="difflineplus">+</span>
<a href="#l29.3160"></a><span id="l29.3160" class="difflineplus">+              // Nothing remains to be done.  The msgClassified event will take</span>
<a href="#l29.3161"></a><span id="l29.3161" class="difflineplus">+              //  care of making sure the message gets indexed.</span>
<a href="#l29.3162"></a><span id="l29.3162" class="difflineplus">+              return;</span>
<a href="#l29.3163"></a><span id="l29.3163" class="difflineplus">+            }</span>
<a href="#l29.3164"></a><span id="l29.3164" class="difflineplus">+          }</span>
<a href="#l29.3165"></a><span id="l29.3165" class="difflineplus">+</span>
<a href="#l29.3166"></a><span id="l29.3166" class="difflineplus">+</span>
<a href="#l29.3167"></a><span id="l29.3167" class="difflineplus">+          // --- Have destination headers (local case):</span>
<a href="#l29.3168"></a><span id="l29.3168" class="difflineplus">+          if (aDestMsgHdrs) {</span>
<a href="#l29.3169"></a><span id="l29.3169" class="difflineplus">+            // -- Update message keys for valid gloda-id's.</span>
<a href="#l29.3170"></a><span id="l29.3170" class="difflineplus">+            // (Which means ignore filthy gloda-id's.)</span>
<a href="#l29.3171"></a><span id="l29.3171">             let glodaIds = [];</span>
<a href="#l29.3172"></a><span id="l29.3172">             let newMessageKeys = [];</span>
<a href="#l29.3173"></a><span id="l29.3173" class="difflineminus">-            for each (let destMsgHdr in fixIterator(aDestFolder.messages,</span>
<a href="#l29.3174"></a><span id="l29.3174" class="difflineminus">-                                                    Ci.nsIMsgDBHdr)) {</span>
<a href="#l29.3175"></a><span id="l29.3175" class="difflineminus">-              let destMsgId = destMsgHdr.messageId;</span>
<a href="#l29.3176"></a><span id="l29.3176" class="difflineminus">-              let matchingSrcHdr = srcMsgIdToHdr[destMsgId];</span>
<a href="#l29.3177"></a><span id="l29.3177" class="difflineminus">-              if (matchingSrcHdr) {</span>
<a href="#l29.3178"></a><span id="l29.3178" class="difflineminus">-                try {</span>
<a href="#l29.3179"></a><span id="l29.3179" class="difflineminus">-                  let glodaId = matchingSrcHdr.getUint32Property(</span>
<a href="#l29.3180"></a><span id="l29.3180" class="difflineminus">-                    GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.3181"></a><span id="l29.3181" class="difflineminus">-                  glodaIds.push(glodaId);</span>
<a href="#l29.3182"></a><span id="l29.3182" class="difflineminus">-                  newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l29.3183"></a><span id="l29.3183" class="difflineminus">-                }</span>
<a href="#l29.3184"></a><span id="l29.3184" class="difflineminus">-                // no gloda id means it hasn't been indexed, so the move isn't</span>
<a href="#l29.3185"></a><span id="l29.3185" class="difflineminus">-                //  required.</span>
<a href="#l29.3186"></a><span id="l29.3186" class="difflineminus">-                catch (ex) {}</span>
<a href="#l29.3187"></a><span id="l29.3187" class="difflineplus">+            aSrcMsgHdrs.QueryInterface(nsIArray);</span>
<a href="#l29.3188"></a><span id="l29.3188" class="difflineplus">+            aDestMsgHdrs.QueryInterface(nsIArray);</span>
<a href="#l29.3189"></a><span id="l29.3189" class="difflineplus">+            for (let iMsg = 0; iMsg &lt; aSrcMsgHdrs.length; iMsg++) {</span>
<a href="#l29.3190"></a><span id="l29.3190" class="difflineplus">+              let srcMsgHdr = aSrcMsgHdrs.queryElementAt(iMsg, nsIMsgDBHdr);</span>
<a href="#l29.3191"></a><span id="l29.3191" class="difflineplus">+              let destMsgHdr = aDestMsgHdrs.queryElementAt(iMsg, nsIMsgDBHdr);</span>
<a href="#l29.3192"></a><span id="l29.3192" class="difflineplus">+</span>
<a href="#l29.3193"></a><span id="l29.3193" class="difflineplus">+              let [glodaId, dirtyStatus] =</span>
<a href="#l29.3194"></a><span id="l29.3194" class="difflineplus">+                PendingCommitTracker.getGlodaState(srcMsgHdr);</span>
<a href="#l29.3195"></a><span id="l29.3195" class="difflineplus">+              if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l29.3196"></a><span id="l29.3196" class="difflineplus">+                  dirtyStatus != GlodaMsgIndexer.kMessageFilthy) {</span>
<a href="#l29.3197"></a><span id="l29.3197" class="difflineplus">+                // we may need to update the pending commit map (it checks)</span>
<a href="#l29.3198"></a><span id="l29.3198" class="difflineplus">+                PendingCommitTracker.noteMove(srcMsgHdr, destMsgHdr);</span>
<a href="#l29.3199"></a><span id="l29.3199" class="difflineplus">+                // but we always need to update our database</span>
<a href="#l29.3200"></a><span id="l29.3200" class="difflineplus">+                glodaIds.push(glodaId);</span>
<a href="#l29.3201"></a><span id="l29.3201" class="difflineplus">+                newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l29.3202"></a><span id="l29.3202">               }</span>
<a href="#l29.3203"></a><span id="l29.3203">             }</span>
<a href="#l29.3204"></a><span id="l29.3204"> </span>
<a href="#l29.3205"></a><span id="l29.3205">             // this method takes care to update the in-memory representations</span>
<a href="#l29.3206"></a><span id="l29.3206">             //  too; we don't need to do anything</span>
<a href="#l29.3207"></a><span id="l29.3207" class="difflineminus">-            this.indexer._datastore.updateMessageLocations(glodaIds,</span>
<a href="#l29.3208"></a><span id="l29.3208" class="difflineminus">-              newMessageKeys, aDestFolder);</span>
<a href="#l29.3209"></a><span id="l29.3209" class="difflineplus">+            if (glodaIds.length)</span>
<a href="#l29.3210"></a><span id="l29.3210" class="difflineplus">+              GlodaDatastore.updateMessageLocations(glodaIds, newMessageKeys,</span>
<a href="#l29.3211"></a><span id="l29.3211" class="difflineplus">+                                                    aDestFolder);</span>
<a href="#l29.3212"></a><span id="l29.3212">           }</span>
<a href="#l29.3213"></a><span id="l29.3213" class="difflineminus">-          // target is IMAP or something we equally don't understand</span>
<a href="#l29.3214"></a><span id="l29.3214" class="difflineplus">+          // --- No dest headers (IMAP case):</span>
<a href="#l29.3215"></a><span id="l29.3215" class="difflineplus">+          // Update any valid gloda indexed messages into their new folder to</span>
<a href="#l29.3216"></a><span id="l29.3216" class="difflineplus">+          //  make the indexer's life easier when it sees the messages in their</span>
<a href="#l29.3217"></a><span id="l29.3217" class="difflineplus">+          //  new folder.</span>
<a href="#l29.3218"></a><span id="l29.3218">           else {</span>
<a href="#l29.3219"></a><span id="l29.3219" class="difflineminus">-            // XXX the srcFolder will always be the same for now, but we</span>
<a href="#l29.3220"></a><span id="l29.3220" class="difflineminus">-            //  probably don't want to depend on it, or at least want a unit</span>
<a href="#l29.3221"></a><span id="l29.3221" class="difflineminus">-            //  test that will break if it changes...</span>
<a href="#l29.3222"></a><span id="l29.3222" class="difflineminus">-            let srcFolder = aSrcMsgHdrs.queryElementAt(0,Ci.nsIMsgDBHdr).folder;</span>
<a href="#l29.3223"></a><span id="l29.3223" class="difflineplus">+            let glodaIds = [];</span>
<a href="#l29.3224"></a><span id="l29.3224" class="difflineplus">+</span>
<a href="#l29.3225"></a><span id="l29.3225" class="difflineplus">+            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l29.3226"></a><span id="l29.3226" class="difflineplus">+              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, nsIMsgDBHdr);</span>
<a href="#l29.3227"></a><span id="l29.3227"> </span>
<a href="#l29.3228"></a><span id="l29.3228" class="difflineminus">-            // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l29.3229"></a><span id="l29.3229" class="difflineminus">-            //  job list too.</span>
<a href="#l29.3230"></a><span id="l29.3230" class="difflineminus">-            let messageKeys = [];</span>
<a href="#l29.3231"></a><span id="l29.3231" class="difflineminus">-            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l29.3232"></a><span id="l29.3232" class="difflineminus">-              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l29.3233"></a><span id="l29.3233" class="difflineminus">-              messageKeys.push(msgHdr.messageKey);</span>
<a href="#l29.3234"></a><span id="l29.3234" class="difflineplus">+              let [glodaId, dirtyStatus] =</span>
<a href="#l29.3235"></a><span id="l29.3235" class="difflineplus">+                PendingCommitTracker.getGlodaState(msgHdr);</span>
<a href="#l29.3236"></a><span id="l29.3236" class="difflineplus">+              if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l29.3237"></a><span id="l29.3237" class="difflineplus">+                  dirtyStatus != GlodaMsgIndexer.kMessageFilthy) {</span>
<a href="#l29.3238"></a><span id="l29.3238" class="difflineplus">+                // we may need to update the pending commit map (it checks)</span>
<a href="#l29.3239"></a><span id="l29.3239" class="difflineplus">+                PendingCommitTracker.noteBlindMove(msgHdr);</span>
<a href="#l29.3240"></a><span id="l29.3240" class="difflineplus">+                // but we always need to update our database</span>
<a href="#l29.3241"></a><span id="l29.3241" class="difflineplus">+                glodaIds.push(glodaId);</span>
<a href="#l29.3242"></a><span id="l29.3242" class="difflineplus">+              }</span>
<a href="#l29.3243"></a><span id="l29.3243">             }</span>
<a href="#l29.3244"></a><span id="l29.3244" class="difflineminus">-            // XXX we could extract the gloda message id's instead.</span>
<a href="#l29.3245"></a><span id="l29.3245" class="difflineplus">+</span>
<a href="#l29.3246"></a><span id="l29.3246">             // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l29.3247"></a><span id="l29.3247" class="difflineminus">-            this.indexer._datastore.updateMessageFoldersByKeyPurging(</span>
<a href="#l29.3248"></a><span id="l29.3248" class="difflineminus">-              srcFolder, messageKeys, aDestFolder);</span>
<a href="#l29.3249"></a><span id="l29.3249" class="difflineplus">+            GlodaDatastore.updateMessageFoldersByKeyPurging(glodaIds,</span>
<a href="#l29.3250"></a><span id="l29.3250" class="difflineplus">+                                                            aDestFolder);</span>
<a href="#l29.3251"></a><span id="l29.3251">             // we _do not_ need to mark the folder as dirty, because the</span>
<a href="#l29.3252"></a><span id="l29.3252">             //  message added events will cause that to happen.</span>
<a href="#l29.3253"></a><span id="l29.3253">           }</span>
<a href="#l29.3254"></a><span id="l29.3254">         }</span>
<a href="#l29.3255"></a><span id="l29.3255" class="difflineminus">-       // copy case</span>
<a href="#l29.3256"></a><span id="l29.3256" class="difflineplus">+        // ---- Copy case</span>
<a href="#l29.3257"></a><span id="l29.3257">         else {</span>
<a href="#l29.3258"></a><span id="l29.3258" class="difflineplus">+          // -- Do not propagate gloda-id's for copies</span>
<a href="#l29.3259"></a><span id="l29.3259" class="difflineplus">+          // (Only applies if we have the destination header, which means local)</span>
<a href="#l29.3260"></a><span id="l29.3260" class="difflineplus">+          if (aDestMsgHdrs) {</span>
<a href="#l29.3261"></a><span id="l29.3261" class="difflineplus">+            for each (let destMsgHdr in fixIterator(aDestMsgHdrs.enumerate(),</span>
<a href="#l29.3262"></a><span id="l29.3262" class="difflineplus">+                                                    nsIMsgDBHdr)) {</span>
<a href="#l29.3263"></a><span id="l29.3263" class="difflineplus">+              let glodaId = destMsgHdr.getUint32Property(</span>
<a href="#l29.3264"></a><span id="l29.3264" class="difflineplus">+                GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l29.3265"></a><span id="l29.3265" class="difflineplus">+              if (glodaId)</span>
<a href="#l29.3266"></a><span id="l29.3266" class="difflineplus">+                destMsgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY, 0);</span>
<a href="#l29.3267"></a><span id="l29.3267" class="difflineplus">+            }</span>
<a href="#l29.3268"></a><span id="l29.3268" class="difflineplus">+          }</span>
<a href="#l29.3269"></a><span id="l29.3269" class="difflineplus">+</span>
<a href="#l29.3270"></a><span id="l29.3270">           // mark the folder as dirty; we'll get to it later.</span>
<a href="#l29.3271"></a><span id="l29.3271">           let destGlodaFolder = GlodaDatastore._mapFolder(aDestFolder);</span>
<a href="#l29.3272"></a><span id="l29.3272" class="difflineminus">-          destGlodaFolder.dirtyStatus = true;</span>
<a href="#l29.3273"></a><span id="l29.3273" class="difflineplus">+          destGlodaFolder.dirtyStatus = destGlodaFolder.kFolderDirty;</span>
<a href="#l29.3274"></a><span id="l29.3274">           this.indexer.indexingSweepNeeded = true;</span>
<a href="#l29.3275"></a><span id="l29.3275">         }</span>
<a href="#l29.3276"></a><span id="l29.3276">       } catch (ex) {</span>
<a href="#l29.3277"></a><span id="l29.3277">         this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l29.3278"></a><span id="l29.3278" class="difflineminus">-          &quot;: &quot; + ex);</span>
<a href="#l29.3279"></a><span id="l29.3279" class="difflineplus">+          &quot;: &quot; + ex + &quot;\n\n&quot; + ex.stack + &quot;\n\n&quot;);</span>
<a href="#l29.3280"></a><span id="l29.3280">       }</span>
<a href="#l29.3281"></a><span id="l29.3281">     },</span>
<a href="#l29.3282"></a><span id="l29.3282"> </span>
<a href="#l29.3283"></a><span id="l29.3283">     /**</span>
<a href="#l29.3284"></a><span id="l29.3284">      * Handles folder no-longer-exists-ence.  We mark all messages as deleted</span>
<a href="#l29.3285"></a><span id="l29.3285">      *  and remove the folder from our URI table.  Currently, if a folder that</span>
<a href="#l29.3286"></a><span id="l29.3286">      *  contains other folders is deleted, we may either receive one</span>
<a href="#l29.3287"></a><span id="l29.3287">      *  notification for the folder that is deleted, or a notification for the</span>
<a href="#l29.3288"></a><span id="l29.3288">      *  folder and one for each of its descendents.  This depends upon the</span>
<a href="#l29.3289"></a><span id="l29.3289">      *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l29.3290"></a><span id="l29.3290">      *  Namely, we treat it as if we're only planning on getting one, but we</span>
<a href="#l29.3291"></a><span id="l29.3291">      *  handle if the children are already gone for some reason.</span>
<a href="#l29.3292"></a><span id="l29.3292">      */</span>
<a href="#l29.3293"></a><span id="l29.3293">     folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l29.3294"></a><span id="l29.3294">       this.indexer._log.debug(&quot;folderDeleted notification&quot;);</span>
<a href="#l29.3295"></a><span id="l29.3295" class="difflineminus">-</span>
<a href="#l29.3296"></a><span id="l29.3296" class="difflineminus">-      let delFunc = function(aFolder, indexer) {</span>
<a href="#l29.3297"></a><span id="l29.3297" class="difflineminus">-        if (indexer._datastore._folderKnown(aFolder)) {</span>
<a href="#l29.3298"></a><span id="l29.3298" class="difflineminus">-          let folder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l29.3299"></a><span id="l29.3299" class="difflineminus">-          folder._deleted = true;</span>
<a href="#l29.3300"></a><span id="l29.3300" class="difflineminus">-          indexer._datastore.markMessagesDeletedByFolderID(folder.id);</span>
<a href="#l29.3301"></a><span id="l29.3301" class="difflineminus">-          indexer._datastore.deleteFolderByID(folder.id);</span>
<a href="#l29.3302"></a><span id="l29.3302" class="difflineminus">-        }</span>
<a href="#l29.3303"></a><span id="l29.3303" class="difflineminus">-      };</span>
<a href="#l29.3304"></a><span id="l29.3304" class="difflineplus">+      try {</span>
<a href="#l29.3305"></a><span id="l29.3305" class="difflineplus">+        let delFunc = function(aFolder, indexer) {</span>
<a href="#l29.3306"></a><span id="l29.3306" class="difflineplus">+          if (indexer._datastore._folderKnown(aFolder)) {</span>
<a href="#l29.3307"></a><span id="l29.3307" class="difflineplus">+            indexer._log.info(&quot;Processing deletion of folder &quot; +</span>
<a href="#l29.3308"></a><span id="l29.3308" class="difflineplus">+                              aFolder.prettiestName + &quot;.&quot;);</span>
<a href="#l29.3309"></a><span id="l29.3309" class="difflineplus">+            let folder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l29.3310"></a><span id="l29.3310" class="difflineplus">+            folder._deleted = true;</span>
<a href="#l29.3311"></a><span id="l29.3311" class="difflineplus">+            indexer._datastore.markMessagesDeletedByFolderID(folder.id);</span>
<a href="#l29.3312"></a><span id="l29.3312" class="difflineplus">+            indexer._datastore.deleteFolderByID(folder.id);</span>
<a href="#l29.3313"></a><span id="l29.3313" class="difflineplus">+          }</span>
<a href="#l29.3314"></a><span id="l29.3314" class="difflineplus">+          else {</span>
<a href="#l29.3315"></a><span id="l29.3315" class="difflineplus">+            indexer._log.info(&quot;Ignoring deletion of folder &quot; +</span>
<a href="#l29.3316"></a><span id="l29.3316" class="difflineplus">+                              aFolder.prettiestName +</span>
<a href="#l29.3317"></a><span id="l29.3317" class="difflineplus">+                              &quot; because it is unknown to gloda.&quot;);</span>
<a href="#l29.3318"></a><span id="l29.3318" class="difflineplus">+          }</span>
<a href="#l29.3319"></a><span id="l29.3319" class="difflineplus">+        };</span>
<a href="#l29.3320"></a><span id="l29.3320"> </span>
<a href="#l29.3321"></a><span id="l29.3321" class="difflineminus">-      let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l29.3322"></a><span id="l29.3322" class="difflineminus">-                                createInstance(Ci.nsISupportsArray);</span>
<a href="#l29.3323"></a><span id="l29.3323" class="difflineminus">-      aFolder.ListDescendents(descendentFolders);</span>
<a href="#l29.3324"></a><span id="l29.3324" class="difflineplus">+        let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l29.3325"></a><span id="l29.3325" class="difflineplus">+        createInstance(Ci.nsISupportsArray);</span>
<a href="#l29.3326"></a><span id="l29.3326" class="difflineplus">+        aFolder.ListDescendents(descendentFolders);</span>
<a href="#l29.3327"></a><span id="l29.3327"> </span>
<a href="#l29.3328"></a><span id="l29.3328" class="difflineminus">-      // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l29.3329"></a><span id="l29.3329" class="difflineminus">-      // delete the parent</span>
<a href="#l29.3330"></a><span id="l29.3330" class="difflineminus">-      delFunc(aFolder, this.indexer);</span>
<a href="#l29.3331"></a><span id="l29.3331" class="difflineminus">-      // delete all its descendents</span>
<a href="#l29.3332"></a><span id="l29.3332" class="difflineminus">-      for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l29.3333"></a><span id="l29.3333" class="difflineminus">-        delFunc(folder, this.indexer);</span>
<a href="#l29.3334"></a><span id="l29.3334" class="difflineplus">+        // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l29.3335"></a><span id="l29.3335" class="difflineplus">+        // delete the parent</span>
<a href="#l29.3336"></a><span id="l29.3336" class="difflineplus">+        delFunc(aFolder, this.indexer);</span>
<a href="#l29.3337"></a><span id="l29.3337" class="difflineplus">+        // delete all its descendents</span>
<a href="#l29.3338"></a><span id="l29.3338" class="difflineplus">+        for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l29.3339"></a><span id="l29.3339" class="difflineplus">+          delFunc(folder, this.indexer);</span>
<a href="#l29.3340"></a><span id="l29.3340" class="difflineplus">+        }</span>
<a href="#l29.3341"></a><span id="l29.3341" class="difflineplus">+</span>
<a href="#l29.3342"></a><span id="l29.3342" class="difflineplus">+        this.indexer.pendingDeletions = true;</span>
<a href="#l29.3343"></a><span id="l29.3343" class="difflineplus">+      } catch (ex) {</span>
<a href="#l29.3344"></a><span id="l29.3344" class="difflineplus">+        this.indexer._log.error(&quot;Problem encountered during folder deletion&quot; +</span>
<a href="#l29.3345"></a><span id="l29.3345" class="difflineplus">+          &quot;: &quot; + ex + &quot;\n\n&quot; + ex.stack + &quot;\n\n&quot;);</span>
<a href="#l29.3346"></a><span id="l29.3346">       }</span>
<a href="#l29.3347"></a><span id="l29.3347" class="difflineminus">-</span>
<a href="#l29.3348"></a><span id="l29.3348" class="difflineminus">-      this.indexer.pendingDeletions = true;</span>
<a href="#l29.3349"></a><span id="l29.3349">     },</span>
<a href="#l29.3350"></a><span id="l29.3350"> </span>
<a href="#l29.3351"></a><span id="l29.3351">     /**</span>
<a href="#l29.3352"></a><span id="l29.3352">      * Handle a folder being copied or moved.</span>
<a href="#l29.3353"></a><span id="l29.3353">      * Moves are handled by a helper function shared with _folderRenameHelper</span>
<a href="#l29.3354"></a><span id="l29.3354">      *  (which takes care of any nesting involved).</span>
<a href="#l29.3355"></a><span id="l29.3355">      * Copies are actually ignored, because our periodic indexing traversal</span>
<a href="#l29.3356"></a><span id="l29.3356">      *  should discover these automatically.  We could hint ourselves into</span>
<a href="#l29.3357"></a><span id="l29.3357" class="difflineat">@@ -2300,19 +2032,21 @@ var GlodaIndexer = {</span>
<a href="#l29.3358"></a><span id="l29.3358">     folderMoveCopyCompleted: function gloda_indexer_folderMoveCopyCompleted(</span>
<a href="#l29.3359"></a><span id="l29.3359">                                aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l29.3360"></a><span id="l29.3360">       this.indexer._log.debug(&quot;folderMoveCopy notification (Move: &quot; + aMove</span>
<a href="#l29.3361"></a><span id="l29.3361">                               + &quot;)&quot;);</span>
<a href="#l29.3362"></a><span id="l29.3362">       if (aMove) {</span>
<a href="#l29.3363"></a><span id="l29.3363">         let srcURI = aSrcFolder.URI;</span>
<a href="#l29.3364"></a><span id="l29.3364">         let targetURI = aDestFolder.URI +</span>
<a href="#l29.3365"></a><span id="l29.3365">                         srcURI.substring(srcURI.lastIndexOf(&quot;/&quot;));</span>
<a href="#l29.3366"></a><span id="l29.3366" class="difflineminus">-        return this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l29.3367"></a><span id="l29.3367" class="difflineplus">+        this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l29.3368"></a><span id="l29.3368">       }</span>
<a href="#l29.3369"></a><span id="l29.3369" class="difflineminus">-      this.indexer.indexingSweepNeeded = true;</span>
<a href="#l29.3370"></a><span id="l29.3370" class="difflineplus">+      else {</span>
<a href="#l29.3371"></a><span id="l29.3371" class="difflineplus">+        this.indexer.indexingSweepNeeded = true;</span>
<a href="#l29.3372"></a><span id="l29.3372" class="difflineplus">+      }</span>
<a href="#l29.3373"></a><span id="l29.3373">     },</span>
<a href="#l29.3374"></a><span id="l29.3374"> </span>
<a href="#l29.3375"></a><span id="l29.3375">     /**</span>
<a href="#l29.3376"></a><span id="l29.3376">      * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l29.3377"></a><span id="l29.3377">      *  all of which is actually done by the datastore for us.</span>
<a href="#l29.3378"></a><span id="l29.3378">      * This method needs to deal with the complexity where local folders will</span>
<a href="#l29.3379"></a><span id="l29.3379">      *  generate a rename notification for each sub-folder, but IMAP folders</span>
<a href="#l29.3380"></a><span id="l29.3380">      *  will generate only a single notification.  Our logic primarily handles</span>
<a href="#l29.3381"></a><span id="l29.3381" class="difflineat">@@ -2328,115 +2062,125 @@ var GlodaIndexer = {</span>
<a href="#l29.3382"></a><span id="l29.3382">       // this rename is straightforward.</span>
<a href="#l29.3383"></a><span id="l29.3383">       GlodaDatastore.renameFolder(aOrigFolder, aNewURI);</span>
<a href="#l29.3384"></a><span id="l29.3384"> </span>
<a href="#l29.3385"></a><span id="l29.3385">       for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l29.3386"></a><span id="l29.3386">         let oldSubURI = folder.URI;</span>
<a href="#l29.3387"></a><span id="l29.3387">         // mangle a new URI from the old URI.  we could also try and do a</span>
<a href="#l29.3388"></a><span id="l29.3388">         //  parallel traversal of the new folder hierarchy, but that seems like</span>
<a href="#l29.3389"></a><span id="l29.3389">         //  more work.</span>
<a href="#l29.3390"></a><span id="l29.3390" class="difflineminus">-        let newSubURI = aNewURI + oldSubURI.substring(origURI.length)</span>
<a href="#l29.3391"></a><span id="l29.3391" class="difflineplus">+        let newSubURI = aNewURI + oldSubURI.substring(origURI.length);</span>
<a href="#l29.3392"></a><span id="l29.3392">         this.indexer._datastore.renameFolder(oldSubURI, newSubURI);</span>
<a href="#l29.3393"></a><span id="l29.3393">       }</span>
<a href="#l29.3394"></a><span id="l29.3394"> </span>
<a href="#l29.3395"></a><span id="l29.3395">       this.indexer._log.debug(&quot;folder renamed: &quot; + origURI + &quot; to &quot; + aNewURI);</span>
<a href="#l29.3396"></a><span id="l29.3396">     },</span>
<a href="#l29.3397"></a><span id="l29.3397"> </span>
<a href="#l29.3398"></a><span id="l29.3398">     /**</span>
<a href="#l29.3399"></a><span id="l29.3399">      * Handle folder renames, dispatching to our rename helper (which also</span>
<a href="#l29.3400"></a><span id="l29.3400">      *  takes care of any nested folder issues.)</span>
<a href="#l29.3401"></a><span id="l29.3401">      */</span>
<a href="#l29.3402"></a><span id="l29.3402">     folderRenamed: function gloda_indexer_folderRenamed(aOrigFolder,</span>
<a href="#l29.3403"></a><span id="l29.3403">                                                         aNewFolder) {</span>
<a href="#l29.3404"></a><span id="l29.3404">       this._folderRenameHelper(aOrigFolder, aNewFolder.URI);</span>
<a href="#l29.3405"></a><span id="l29.3405">     },</span>
<a href="#l29.3406"></a><span id="l29.3406"> </span>
<a href="#l29.3407"></a><span id="l29.3407" class="difflineplus">+    /**</span>
<a href="#l29.3408"></a><span id="l29.3408" class="difflineplus">+     * This tells us about compaction start and end events.  What we do:</span>
<a href="#l29.3409"></a><span id="l29.3409" class="difflineplus">+     *</span>
<a href="#l29.3410"></a><span id="l29.3410" class="difflineplus">+     * - FolderCompactStart: Mark the folder as compacting in our in-memory</span>
<a href="#l29.3411"></a><span id="l29.3411" class="difflineplus">+     *    representation.  This should keep any new indexing out of the folder</span>
<a href="#l29.3412"></a><span id="l29.3412" class="difflineplus">+     *    until it is done compacting.  Also, kill any active or existing jobs</span>
<a href="#l29.3413"></a><span id="l29.3413" class="difflineplus">+     *    to index the folder.</span>
<a href="#l29.3414"></a><span id="l29.3414" class="difflineplus">+     * - FolderCompactFinish: Mark the folder as done compacting in our</span>
<a href="#l29.3415"></a><span id="l29.3415" class="difflineplus">+     *    in-memory representation.  Assuming the folder was known to us and</span>
<a href="#l29.3416"></a><span id="l29.3416" class="difflineplus">+     *    not marked filthy, queue a compaction job.</span>
<a href="#l29.3417"></a><span id="l29.3417" class="difflineplus">+     */</span>
<a href="#l29.3418"></a><span id="l29.3418">     itemEvent: function gloda_indexer_itemEvent(aItem, aEvent, aData) {</span>
<a href="#l29.3419"></a><span id="l29.3419" class="difflineminus">-      // nop.  this is an expansion method on the part of the interface and has</span>
<a href="#l29.3420"></a><span id="l29.3420" class="difflineminus">-      //  no known events that we need to handle.</span>
<a href="#l29.3421"></a><span id="l29.3421" class="difflineplus">+      if (aEvent == &quot;FolderCompactStart&quot;) {</span>
<a href="#l29.3422"></a><span id="l29.3422" class="difflineplus">+        let aMsgFolder = aItem.QueryInterface(nsIMsgFolder);</span>
<a href="#l29.3423"></a><span id="l29.3423" class="difflineplus">+        // ignore folders we ignore...</span>
<a href="#l29.3424"></a><span id="l29.3424" class="difflineplus">+        if (!GlodaMsgIndexer.shouldIndexFolder(aMsgFolder))</span>
<a href="#l29.3425"></a><span id="l29.3425" class="difflineplus">+          return;</span>
<a href="#l29.3426"></a><span id="l29.3426" class="difflineplus">+</span>
<a href="#l29.3427"></a><span id="l29.3427" class="difflineplus">+        let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l29.3428"></a><span id="l29.3428" class="difflineplus">+        glodaFolder.compacting = true;</span>
<a href="#l29.3429"></a><span id="l29.3429" class="difflineplus">+</span>
<a href="#l29.3430"></a><span id="l29.3430" class="difflineplus">+        // Purge any explicit indexing of said folder.</span>
<a href="#l29.3431"></a><span id="l29.3431" class="difflineplus">+        GlodaIndexer.purgeJobsUsingFilter(function (aJob) {</span>
<a href="#l29.3432"></a><span id="l29.3432" class="difflineplus">+          return (aJob.jobType == &quot;folder&quot; &amp;&amp;</span>
<a href="#l29.3433"></a><span id="l29.3433" class="difflineplus">+                  aJob.id == aMsgFolder.id);</span>
<a href="#l29.3434"></a><span id="l29.3434" class="difflineplus">+        });</span>
<a href="#l29.3435"></a><span id="l29.3435" class="difflineplus">+</span>
<a href="#l29.3436"></a><span id="l29.3436" class="difflineplus">+        // Abort the active job if it's in the folder (this covers both</span>
<a href="#l29.3437"></a><span id="l29.3437" class="difflineplus">+        //  event-driven indexing that happens to be in the folder as well</span>
<a href="#l29.3438"></a><span id="l29.3438" class="difflineplus">+        //  explicit folder indexing of the folder).</span>
<a href="#l29.3439"></a><span id="l29.3439" class="difflineplus">+        if (GlodaMsgIndexer._indexingFolder == aMsgFolder)</span>
<a href="#l29.3440"></a><span id="l29.3440" class="difflineplus">+          GlodaIndexer.killActiveJob();</span>
<a href="#l29.3441"></a><span id="l29.3441" class="difflineplus">+</span>
<a href="#l29.3442"></a><span id="l29.3442" class="difflineplus">+        // Tell the PendingCommitTracker to throw away anything it is tracking</span>
<a href="#l29.3443"></a><span id="l29.3443" class="difflineplus">+        //  about the folder.  We will pick up the pieces in the compaction</span>
<a href="#l29.3444"></a><span id="l29.3444" class="difflineplus">+        //  pass.</span>
<a href="#l29.3445"></a><span id="l29.3445" class="difflineplus">+        PendingCommitTracker.noteFolderCompaction(aMsgFolder);</span>
<a href="#l29.3446"></a><span id="l29.3446" class="difflineplus">+</span>
<a href="#l29.3447"></a><span id="l29.3447" class="difflineplus">+        // (We do not need to mark the folder dirty because if we were indexing</span>
<a href="#l29.3448"></a><span id="l29.3448" class="difflineplus">+        //  it, it already must have been marked dirty.)</span>
<a href="#l29.3449"></a><span id="l29.3449" class="difflineplus">+      }</span>
<a href="#l29.3450"></a><span id="l29.3450" class="difflineplus">+      else if (aEvent == &quot;FolderCompactFinish&quot;) {</span>
<a href="#l29.3451"></a><span id="l29.3451" class="difflineplus">+        let aMsgFolder = aItem.QueryInterface(nsIMsgFolder);</span>
<a href="#l29.3452"></a><span id="l29.3452" class="difflineplus">+        // ignore folders we ignore...</span>
<a href="#l29.3453"></a><span id="l29.3453" class="difflineplus">+        if (!GlodaMsgIndexer.shouldIndexFolder(aMsgFolder))</span>
<a href="#l29.3454"></a><span id="l29.3454" class="difflineplus">+          return;</span>
<a href="#l29.3455"></a><span id="l29.3455" class="difflineplus">+</span>
<a href="#l29.3456"></a><span id="l29.3456" class="difflineplus">+        let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l29.3457"></a><span id="l29.3457" class="difflineplus">+        glodaFolder.compacting = false;</span>
<a href="#l29.3458"></a><span id="l29.3458" class="difflineplus">+</span>
<a href="#l29.3459"></a><span id="l29.3459" class="difflineplus">+        // Queue compaction unless the folder was filthy (in which case there</span>
<a href="#l29.3460"></a><span id="l29.3460" class="difflineplus">+        //  are no valid gloda-id's to update.)</span>
<a href="#l29.3461"></a><span id="l29.3461" class="difflineplus">+        if (glodaFolder.dirtyStatus != glodaFolder.kFolderFilthy)</span>
<a href="#l29.3462"></a><span id="l29.3462" class="difflineplus">+          GlodaIndexer.indexJob(</span>
<a href="#l29.3463"></a><span id="l29.3463" class="difflineplus">+            new IndexingJob(&quot;folderCompact&quot;, glodaFolder.id));</span>
<a href="#l29.3464"></a><span id="l29.3464" class="difflineplus">+</span>
<a href="#l29.3465"></a><span id="l29.3465" class="difflineplus">+        // Queue indexing of the folder if it is dirty.  We are doing this</span>
<a href="#l29.3466"></a><span id="l29.3466" class="difflineplus">+        //  mainly in case we were indexing it before the compaction started.</span>
<a href="#l29.3467"></a><span id="l29.3467" class="difflineplus">+        //  It should be reasonably harmless if we weren't.</span>
<a href="#l29.3468"></a><span id="l29.3468" class="difflineplus">+        // (It would probably be better to just make sure that there is an</span>
<a href="#l29.3469"></a><span id="l29.3469" class="difflineplus">+        //  indexing sweep queued or active, and if it's already active that</span>
<a href="#l29.3470"></a><span id="l29.3470" class="difflineplus">+        //  this folder is in the queue to be processed.)</span>
<a href="#l29.3471"></a><span id="l29.3471" class="difflineplus">+        if (glodaFolder.dirtyStatus == glodaFolder.kFolderDirty)</span>
<a href="#l29.3472"></a><span id="l29.3472" class="difflineplus">+          GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l29.3473"></a><span id="l29.3473" class="difflineplus">+      }</span>
<a href="#l29.3474"></a><span id="l29.3474" class="difflineplus">+      else if (aEvent == &quot;JunkStatusChanged&quot;) {</span>
<a href="#l29.3475"></a><span id="l29.3475" class="difflineplus">+        this.indexer._log.debug(&quot;JunkStatusChanged notification&quot;);</span>
<a href="#l29.3476"></a><span id="l29.3476" class="difflineplus">+        aItem.QueryInterface(Ci.nsIArray);</span>
<a href="#l29.3477"></a><span id="l29.3477" class="difflineplus">+        GlodaMsgIndexer._reindexChangedMessages(aItem.enumerate());</span>
<a href="#l29.3478"></a><span id="l29.3478" class="difflineplus">+      }</span>
<a href="#l29.3479"></a><span id="l29.3479">     },</span>
<a href="#l29.3480"></a><span id="l29.3480">   },</span>
<a href="#l29.3481"></a><span id="l29.3481"> </span>
<a href="#l29.3482"></a><span id="l29.3482">   /**</span>
<a href="#l29.3483"></a><span id="l29.3483">    * A nsIFolderListener (listening on nsIMsgMailSession so we get all of</span>
<a href="#l29.3484"></a><span id="l29.3484">    *  these events) PRIMARILY to get folder loaded notifications.  Because of</span>
<a href="#l29.3485"></a><span id="l29.3485">    *  deficiencies in the nsIMsgFolderListener's events at this time, we also</span>
<a href="#l29.3486"></a><span id="l29.3486">    *  get our folder-added and newsgroup notifications from here for now.  (This</span>
<a href="#l29.3487"></a><span id="l29.3487">    *  will be rectified.)</span>
<a href="#l29.3488"></a><span id="l29.3488">    */</span>
<a href="#l29.3489"></a><span id="l29.3489">   _folderListener: {</span>
<a href="#l29.3490"></a><span id="l29.3490">     indexer: null,</span>
<a href="#l29.3491"></a><span id="l29.3491" class="difflineminus">-    _kFolderLoadedAtom: null,</span>
<a href="#l29.3492"></a><span id="l29.3492" class="difflineminus">-    _kKeywordsAtom: null,</span>
<a href="#l29.3493"></a><span id="l29.3493" class="difflineminus">-    _kStatusAtom: null,</span>
<a href="#l29.3494"></a><span id="l29.3494" class="difflineminus">-    _kFlaggedAtom: null,</span>
<a href="#l29.3495"></a><span id="l29.3495" class="difflineminus">-    _kJunkStatusChangedAtom: null,</span>
<a href="#l29.3496"></a><span id="l29.3496"> </span>
<a href="#l29.3497"></a><span id="l29.3497">     _init: function gloda_indexer_fl_init(aIndexer) {</span>
<a href="#l29.3498"></a><span id="l29.3498">       this.indexer = aIndexer;</span>
<a href="#l29.3499"></a><span id="l29.3499">       let atomService = Cc[&quot;@mozilla.org/atom-service;1&quot;].</span>
<a href="#l29.3500"></a><span id="l29.3500">                         getService(Ci.nsIAtomService);</span>
<a href="#l29.3501"></a><span id="l29.3501">       this._kFolderLoadedAtom = atomService.getAtom(&quot;FolderLoaded&quot;);</span>
<a href="#l29.3502"></a><span id="l29.3502">       // we explicitly know about these things rather than bothering with some</span>
<a href="#l29.3503"></a><span id="l29.3503">       //  form of registration scheme because these aren't going to change much.</span>
<a href="#l29.3504"></a><span id="l29.3504">       this._kKeywordsAtom = atomService.getAtom(&quot;Keywords&quot;);</span>
<a href="#l29.3505"></a><span id="l29.3505">       this._kStatusAtom = atomService.getAtom(&quot;Status&quot;);</span>
<a href="#l29.3506"></a><span id="l29.3506">       this._kFlaggedAtom = atomService.getAtom(&quot;Flagged&quot;);</span>
<a href="#l29.3507"></a><span id="l29.3507" class="difflineminus">-      this._kJunkStatusChangedAtom = atomService.getAtom(&quot;JunkStatusChanged&quot;);</span>
<a href="#l29.3508"></a><span id="l29.3508" class="difflineminus">-    },</span>
<a href="#l29.3509"></a><span id="l29.3509" class="difflineminus">-</span>
<a href="#l29.3510"></a><span id="l29.3510" class="difflineminus">-    /**</span>
<a href="#l29.3511"></a><span id="l29.3511" class="difflineminus">-     * Helper method to do the leg-work associated with flagging a message</span>
<a href="#l29.3512"></a><span id="l29.3512" class="difflineminus">-     *  for re-indexing because of some change in meta-state that happened to</span>
<a href="#l29.3513"></a><span id="l29.3513" class="difflineminus">-     *  it.  Job-wise, we treat this as a message addition; we are uniquely</span>
<a href="#l29.3514"></a><span id="l29.3514" class="difflineminus">-     *  identifying the message by providing its folder ID and message key, and</span>
<a href="#l29.3515"></a><span id="l29.3515" class="difflineminus">-     *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l29.3516"></a><span id="l29.3516" class="difflineminus">-     */</span>
<a href="#l29.3517"></a><span id="l29.3517" class="difflineminus">-    _reindexChangedMessage: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l29.3518"></a><span id="l29.3518" class="difflineminus">-        aMsgHdr) {</span>
<a href="#l29.3519"></a><span id="l29.3519" class="difflineminus">-      // make sure the message is eligible for indexing...</span>
<a href="#l29.3520"></a><span id="l29.3520" class="difflineminus">-      let msgFolder = aMsgHdr.folder;</span>
<a href="#l29.3521"></a><span id="l29.3521" class="difflineminus">-      if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l29.3522"></a><span id="l29.3522" class="difflineminus">-        return;</span>
<a href="#l29.3523"></a><span id="l29.3523" class="difflineminus">-</span>
<a href="#l29.3524"></a><span id="l29.3524" class="difflineminus">-      // Make sure the message is eligible for indexing.</span>
<a href="#l29.3525"></a><span id="l29.3525" class="difflineminus">-      // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l29.3526"></a><span id="l29.3526" class="difflineminus">-      // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l29.3527"></a><span id="l29.3527" class="difflineminus">-      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l29.3528"></a><span id="l29.3528" class="difflineminus">-      if (!isFolderLocal) {</span>
<a href="#l29.3529"></a><span id="l29.3529" class="difflineminus">-        if (!(aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l29.3530"></a><span id="l29.3530" class="difflineminus">-            (msgFolder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l29.3531"></a><span id="l29.3531" class="difflineminus">-          return;</span>
<a href="#l29.3532"></a><span id="l29.3532" class="difflineminus">-      }</span>
<a href="#l29.3533"></a><span id="l29.3533" class="difflineminus">-</span>
<a href="#l29.3534"></a><span id="l29.3534" class="difflineminus">-      // mark the message as dirty</span>
<a href="#l29.3535"></a><span id="l29.3535" class="difflineminus">-      // (We could check for the presence of the gloda message id property</span>
<a href="#l29.3536"></a><span id="l29.3536" class="difflineminus">-      //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l29.3537"></a><span id="l29.3537" class="difflineminus">-      //  not sure whether it is worth the high-probability exception cost.)</span>
<a href="#l29.3538"></a><span id="l29.3538" class="difflineminus">-      aMsgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l29.3539"></a><span id="l29.3539" class="difflineminus">-      // mark the folder dirty too, so we know to look inside</span>
<a href="#l29.3540"></a><span id="l29.3540" class="difflineminus">-      let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l29.3541"></a><span id="l29.3541" class="difflineminus">-      glodaFolder.dirtyStatus = true;</span>
<a href="#l29.3542"></a><span id="l29.3542" class="difflineminus">-</span>
<a href="#l29.3543"></a><span id="l29.3543" class="difflineminus">-      if (this.indexer._pendingAddJob === null) {</span>
<a href="#l29.3544"></a><span id="l29.3544" class="difflineminus">-        this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l29.3545"></a><span id="l29.3545" class="difflineminus">-        this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l29.3546"></a><span id="l29.3546" class="difflineminus">-        this.indexer._indexingJobGoal++;</span>
<a href="#l29.3547"></a><span id="l29.3547" class="difflineminus">-      }</span>
<a href="#l29.3548"></a><span id="l29.3548" class="difflineminus">-      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l29.3549"></a><span id="l29.3549" class="difflineminus">-      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l29.3550"></a><span id="l29.3550" class="difflineminus">-          this.indexer._indexMaxEventQueueMessages) {</span>
<a href="#l29.3551"></a><span id="l29.3551" class="difflineminus">-        this.indexer._pendingAddJob.items.push(</span>
<a href="#l29.3552"></a><span id="l29.3552" class="difflineminus">-          [GlodaDatastore._mapFolder(msgFolder).id,</span>
<a href="#l29.3553"></a><span id="l29.3553" class="difflineminus">-           aMsgHdr.messageKey]);</span>
<a href="#l29.3554"></a><span id="l29.3554" class="difflineminus">-        this.indexer.indexing = true;</span>
<a href="#l29.3555"></a><span id="l29.3555" class="difflineminus">-      }</span>
<a href="#l29.3556"></a><span id="l29.3556" class="difflineminus">-      else {</span>
<a href="#l29.3557"></a><span id="l29.3557" class="difflineminus">-        this.indexer.indexingSweepNeeded = true;</span>
<a href="#l29.3558"></a><span id="l29.3558" class="difflineminus">-      }</span>
<a href="#l29.3559"></a><span id="l29.3559">     },</span>
<a href="#l29.3560"></a><span id="l29.3560"> </span>
<a href="#l29.3561"></a><span id="l29.3561">     OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l29.3562"></a><span id="l29.3562">     },</span>
<a href="#l29.3563"></a><span id="l29.3563">     OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l29.3564"></a><span id="l29.3564">     },</span>
<a href="#l29.3565"></a><span id="l29.3565">     OnItemPropertyChanged: function gloda_indexer_OnItemPropertyChanged(</span>
<a href="#l29.3566"></a><span id="l29.3566">                              aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l29.3567"></a><span id="l29.3567" class="difflineat">@@ -2448,85 +2192,125 @@ var GlodaIndexer = {</span>
<a href="#l29.3568"></a><span id="l29.3568">                                 aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l29.3569"></a><span id="l29.3569">     },</span>
<a href="#l29.3570"></a><span id="l29.3570">     OnItemUnicharPropertyChanged:</span>
<a href="#l29.3571"></a><span id="l29.3571">         function gloda_indexer_OnItemUnicharPropertyChanged(</span>
<a href="#l29.3572"></a><span id="l29.3572">           aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l29.3573"></a><span id="l29.3573"> </span>
<a href="#l29.3574"></a><span id="l29.3574">     },</span>
<a href="#l29.3575"></a><span id="l29.3575">     /**</span>
<a href="#l29.3576"></a><span id="l29.3576" class="difflineminus">-     * Notice when user activity changes a message's status, or automated</span>
<a href="#l29.3577"></a><span id="l29.3577" class="difflineminus">-     *  junk processing flags a message as junk.</span>
<a href="#l29.3578"></a><span id="l29.3578" class="difflineplus">+     * Notice when user activity adds/removes tags or changes a message's</span>
<a href="#l29.3579"></a><span id="l29.3579" class="difflineplus">+     *  status.</span>
<a href="#l29.3580"></a><span id="l29.3580">      */</span>
<a href="#l29.3581"></a><span id="l29.3581">     OnItemPropertyFlagChanged: function gloda_indexer_OnItemPropertyFlagChanged(</span>
<a href="#l29.3582"></a><span id="l29.3582">                                 aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l29.3583"></a><span id="l29.3583">       if (aProperty == this._kKeywordsAtom ||</span>
<a href="#l29.3584"></a><span id="l29.3584" class="difflineminus">-          aProperty == this._kStatusAtom ||</span>
<a href="#l29.3585"></a><span id="l29.3585" class="difflineminus">-          aProperty == this._kFlaggedAtom ||</span>
<a href="#l29.3586"></a><span id="l29.3586" class="difflineminus">-          aProperty == this._kJunkStatusChangedAtom) {</span>
<a href="#l29.3587"></a><span id="l29.3587" class="difflineminus">-        if (this.indexer.enabled) {</span>
<a href="#l29.3588"></a><span id="l29.3588" class="difflineminus">-          this.indexer._log.debug(&quot;ItemPropertyFlagChanged notification&quot;);</span>
<a href="#l29.3589"></a><span id="l29.3589" class="difflineminus">-          this._reindexChangedMessage(aMsgHdr);</span>
<a href="#l29.3590"></a><span id="l29.3590" class="difflineminus">-        }</span>
<a href="#l29.3591"></a><span id="l29.3591" class="difflineplus">+          // We could care less about the new flag changing.</span>
<a href="#l29.3592"></a><span id="l29.3592" class="difflineplus">+          (aProperty == this._kStatusAtom &amp;&amp;</span>
<a href="#l29.3593"></a><span id="l29.3593" class="difflineplus">+           (aOldValue ^ aNewValue) != nsMsgMessageFlags.New &amp;&amp;</span>
<a href="#l29.3594"></a><span id="l29.3594" class="difflineplus">+           // We do care about IMAP deletion, but msgsDeleted tells us that, so</span>
<a href="#l29.3595"></a><span id="l29.3595" class="difflineplus">+           //  ignore IMAPDeleted too...</span>
<a href="#l29.3596"></a><span id="l29.3596" class="difflineplus">+           (aOldValue ^ aNewValue) != nsMsgMessageFlags.IMAPDeleted) ||</span>
<a href="#l29.3597"></a><span id="l29.3597" class="difflineplus">+          aProperty == this._kFlaggedAtom) {</span>
<a href="#l29.3598"></a><span id="l29.3598" class="difflineplus">+        GlodaMsgIndexer._reindexChangedMessages([aMsgHdr]);</span>
<a href="#l29.3599"></a><span id="l29.3599">       }</span>
<a href="#l29.3600"></a><span id="l29.3600">     },</span>
<a href="#l29.3601"></a><span id="l29.3601"> </span>
<a href="#l29.3602"></a><span id="l29.3602">     /**</span>
<a href="#l29.3603"></a><span id="l29.3603">      * Get folder loaded notifications for folders that had to do some</span>
<a href="#l29.3604"></a><span id="l29.3604">      *  (asynchronous) processing before they could be opened.</span>
<a href="#l29.3605"></a><span id="l29.3605">      */</span>
<a href="#l29.3606"></a><span id="l29.3606">     OnItemEvent: function gloda_indexer_OnItemEvent(aFolder, aEvent) {</span>
<a href="#l29.3607"></a><span id="l29.3607">       if (aEvent == this._kFolderLoadedAtom)</span>
<a href="#l29.3608"></a><span id="l29.3608">         this.indexer._onFolderLoaded(aFolder);</span>
<a href="#l29.3609"></a><span id="l29.3609">     },</span>
<a href="#l29.3610"></a><span id="l29.3610">   },</span>
<a href="#l29.3611"></a><span id="l29.3611"> </span>
<a href="#l29.3612"></a><span id="l29.3612">   /* ***** Rebuilding / Reindexing ***** */</span>
<a href="#l29.3613"></a><span id="l29.3613" class="difflineminus">-  // TODO: implement a folder observer doodad to handle rebuilding / reindexing</span>
<a href="#l29.3614"></a><span id="l29.3614">   /**</span>
<a href="#l29.3615"></a><span id="l29.3615">    * Allow us to invalidate an outstanding folder traversal because the</span>
<a href="#l29.3616"></a><span id="l29.3616">    *  underlying database is going away.  We use other means for detecting</span>
<a href="#l29.3617"></a><span id="l29.3617">    *  modifications of the message (labeling, marked (un)read, starred, etc.)</span>
<a href="#l29.3618"></a><span id="l29.3618">    *</span>
<a href="#l29.3619"></a><span id="l29.3619">    * This is an nsIDBChangeListener listening to an nsIDBChangeAnnouncer.  To</span>
<a href="#l29.3620"></a><span id="l29.3620">    *  add ourselves, we get us a nice nsMsgDatabase, query it to the announcer,</span>
<a href="#l29.3621"></a><span id="l29.3621">    *  then call AddListener.</span>
<a href="#l29.3622"></a><span id="l29.3622">    */</span>
<a href="#l29.3623"></a><span id="l29.3623">   _databaseAnnouncerListener: {</span>
<a href="#l29.3624"></a><span id="l29.3624">     indexer: null,</span>
<a href="#l29.3625"></a><span id="l29.3625" class="difflineplus">+    /**</span>
<a href="#l29.3626"></a><span id="l29.3626" class="difflineplus">+     * XXX We really should define the operations under which we expect this to</span>
<a href="#l29.3627"></a><span id="l29.3627" class="difflineplus">+     *  occur.  While we know this must be happening as the result of a</span>
<a href="#l29.3628"></a><span id="l29.3628" class="difflineplus">+     *  ForceClosed call, we don't have a comprehensive list of when this is</span>
<a href="#l29.3629"></a><span id="l29.3629" class="difflineplus">+     *  expected to occur.  Some reasons:</span>
<a href="#l29.3630"></a><span id="l29.3630" class="difflineplus">+     * - Compaction (although we should already have killed the job thanks to</span>
<a href="#l29.3631"></a><span id="l29.3631" class="difflineplus">+     *    our compaction notification)</span>
<a href="#l29.3632"></a><span id="l29.3632" class="difflineplus">+     * - UID validity rolls.</span>
<a href="#l29.3633"></a><span id="l29.3633" class="difflineplus">+     * - Folder Rename</span>
<a href="#l29.3634"></a><span id="l29.3634" class="difflineplus">+     * - Folder Delete</span>
<a href="#l29.3635"></a><span id="l29.3635" class="difflineplus">+     * The fact that we already have the database open when getting this means</span>
<a href="#l29.3636"></a><span id="l29.3636" class="difflineplus">+     *  that it had to be valid before we opened it, which hopefully rules out</span>
<a href="#l29.3637"></a><span id="l29.3637" class="difflineplus">+     *  modification of the mbox file by an external process (since that is</span>
<a href="#l29.3638"></a><span id="l29.3638" class="difflineplus">+     *  forbidden when we are running) and many other exotic things.</span>
<a href="#l29.3639"></a><span id="l29.3639" class="difflineplus">+     *</span>
<a href="#l29.3640"></a><span id="l29.3640" class="difflineplus">+     * So this really ends up just being a correctness / safety protection</span>
<a href="#l29.3641"></a><span id="l29.3641" class="difflineplus">+     *  mechanism.  At least now that we have better compaction support.</span>
<a href="#l29.3642"></a><span id="l29.3642" class="difflineplus">+     */</span>
<a href="#l29.3643"></a><span id="l29.3643">     onAnnouncerGoingAway: function gloda_indexer_dbGoingAway(</span>
<a href="#l29.3644"></a><span id="l29.3644">                                          aDBChangeAnnouncer) {</span>
<a href="#l29.3645"></a><span id="l29.3645" class="difflineminus">-      this.indexer._indexerLeaveFolder(false);</span>
<a href="#l29.3646"></a><span id="l29.3646" class="difflineplus">+      // The fact that we are getting called means we have an active folder and</span>
<a href="#l29.3647"></a><span id="l29.3647" class="difflineplus">+      //  that we therefore are the active job.  As such, we must kill the</span>
<a href="#l29.3648"></a><span id="l29.3648" class="difflineplus">+      //  active job.</span>
<a href="#l29.3649"></a><span id="l29.3649" class="difflineplus">+      // XXX In the future, when we support interleaved event-driven indexing</span>
<a href="#l29.3650"></a><span id="l29.3650" class="difflineplus">+      //  that bumps long-running indexing tasks, the semantics of this will</span>
<a href="#l29.3651"></a><span id="l29.3651" class="difflineplus">+      //  have to change a bit since we will want to maintain being active in a</span>
<a href="#l29.3652"></a><span id="l29.3652" class="difflineplus">+      //  folder even when bumped.  However, we will probably have a more</span>
<a href="#l29.3653"></a><span id="l29.3653" class="difflineplus">+      //  complex notion of indexing contexts on a per-job basis.</span>
<a href="#l29.3654"></a><span id="l29.3654" class="difflineplus">+      GlodaIndexer.killActiveJob();</span>
<a href="#l29.3655"></a><span id="l29.3655">     },</span>
<a href="#l29.3656"></a><span id="l29.3656"> </span>
<a href="#l29.3657"></a><span id="l29.3657">     onHdrFlagsChanged: function(aHdrChanged, aOldFlags, aNewFlags, aInstigator) {},</span>
<a href="#l29.3658"></a><span id="l29.3658">     onHdrDeleted: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l29.3659"></a><span id="l29.3659">     onHdrAdded: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l29.3660"></a><span id="l29.3660">     onParentChanged: function(aKeyChanged, aOldParent, aNewParent,</span>
<a href="#l29.3661"></a><span id="l29.3661">                               aInstigator) {},</span>
<a href="#l29.3662"></a><span id="l29.3662">     onReadChanged: function(aInstigator) {},</span>
<a href="#l29.3663"></a><span id="l29.3663">     onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l29.3664"></a><span id="l29.3664">     onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l29.3665"></a><span id="l29.3665">                                     aInstigator) {},</span>
<a href="#l29.3666"></a><span id="l29.3666">     onEvent: function (aDB, aEvent) {},</span>
<a href="#l29.3667"></a><span id="l29.3667">   },</span>
<a href="#l29.3668"></a><span id="l29.3668"> </span>
<a href="#l29.3669"></a><span id="l29.3669" class="difflineplus">+  /**</span>
<a href="#l29.3670"></a><span id="l29.3670" class="difflineplus">+   * A reference to MsgHdrToMimeMessage that unit testing can clobber when it</span>
<a href="#l29.3671"></a><span id="l29.3671" class="difflineplus">+   *  wants to cause us to hang or inject a fault.  If you are not</span>
<a href="#l29.3672"></a><span id="l29.3672" class="difflineplus">+   *  glodaTestHelper.js then _do not touch this_.</span>
<a href="#l29.3673"></a><span id="l29.3673" class="difflineplus">+   */</span>
<a href="#l29.3674"></a><span id="l29.3674" class="difflineplus">+  _MsgHdrToMimeMessageFunc: MsgHdrToMimeMessage,</span>
<a href="#l29.3675"></a><span id="l29.3675" class="difflineplus">+  /**</span>
<a href="#l29.3676"></a><span id="l29.3676" class="difflineplus">+   * Primary message indexing logic.  This method is mainly concerned with</span>
<a href="#l29.3677"></a><span id="l29.3677" class="difflineplus">+   *  getting all the information about the message required for threading /</span>
<a href="#l29.3678"></a><span id="l29.3678" class="difflineplus">+   *  conversation building and subsequent processing.  It is responsible for</span>
<a href="#l29.3679"></a><span id="l29.3679" class="difflineplus">+   *  determining whether to reuse existing gloda messages or whether a new one</span>
<a href="#l29.3680"></a><span id="l29.3680" class="difflineplus">+   *  should be created.  Most attribute stuff happens in fund_attr.js or</span>
<a href="#l29.3681"></a><span id="l29.3681" class="difflineplus">+   *  expl_attr.js.</span>
<a href="#l29.3682"></a><span id="l29.3682" class="difflineplus">+   */</span>
<a href="#l29.3683"></a><span id="l29.3683">   _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l29.3684"></a><span id="l29.3684">     let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l29.3685"></a><span id="l29.3685">     if (logDebug)</span>
<a href="#l29.3686"></a><span id="l29.3686">       this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l29.3687"></a><span id="l29.3687">                       aMsgHdr.subject);</span>
<a href="#l29.3688"></a><span id="l29.3688"> </span>
<a href="#l29.3689"></a><span id="l29.3689">     // If the message is offline, then get the message body as well</span>
<a href="#l29.3690"></a><span id="l29.3690">     let isMsgOffline = false;</span>
<a href="#l29.3691"></a><span id="l29.3691">     let aMimeMsg;</span>
<a href="#l29.3692"></a><span id="l29.3692" class="difflineminus">-    if ((aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) ||</span>
<a href="#l29.3693"></a><span id="l29.3693" class="difflineminus">-        (aMsgHdr.folder instanceof Ci.nsIMsgLocalMailFolder)) {</span>
<a href="#l29.3694"></a><span id="l29.3694" class="difflineplus">+    if ((aMsgHdr.flags &amp; nsMsgMessageFlags.Offline) ||</span>
<a href="#l29.3695"></a><span id="l29.3695" class="difflineplus">+        (aMsgHdr.folder instanceof nsIMsgLocalMailFolder)) {</span>
<a href="#l29.3696"></a><span id="l29.3696">       isMsgOffline = true;</span>
<a href="#l29.3697"></a><span id="l29.3697" class="difflineminus">-      MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l29.3698"></a><span id="l29.3698" class="difflineplus">+      this._MsgHdrToMimeMessageFunc(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l29.3699"></a><span id="l29.3699">           aCallbackHandle.callback);</span>
<a href="#l29.3700"></a><span id="l29.3700">       [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l29.3701"></a><span id="l29.3701">     }</span>
<a href="#l29.3702"></a><span id="l29.3702">     else {</span>
<a href="#l29.3703"></a><span id="l29.3703">       if (logDebug)</span>
<a href="#l29.3704"></a><span id="l29.3704">         this._log.debug(&quot;  * Message is not offline -- only headers indexed&quot;);</span>
<a href="#l29.3705"></a><span id="l29.3705">     }</span>
<a href="#l29.3706"></a><span id="l29.3706"> </span>
<a href="#l29.3707"></a><span id="l29.3707" class="difflineat">@@ -2553,19 +2337,22 @@ var GlodaIndexer = {</span>
<a href="#l29.3708"></a><span id="l29.3708"> </span>
<a href="#l29.3709"></a><span id="l29.3709">     Gloda.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l29.3710"></a><span id="l29.3710">                                  aCallbackHandle.callbackThis);</span>
<a href="#l29.3711"></a><span id="l29.3711">     // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l29.3712"></a><span id="l29.3712">     let ancestorLists = yield this.kWorkAsync;</span>
<a href="#l29.3713"></a><span id="l29.3713"> </span>
<a href="#l29.3714"></a><span id="l29.3714">     if (logDebug) {</span>
<a href="#l29.3715"></a><span id="l29.3715">       this._log.debug(&quot;ancestors raw: &quot; + ancestorLists);</span>
<a href="#l29.3716"></a><span id="l29.3716" class="difflineminus">-      this._log.debug(&quot;ref len: &quot; + references.length + &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l29.3717"></a><span id="l29.3717" class="difflineminus">-      this._log.debug(&quot;references: &quot; + Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l29.3718"></a><span id="l29.3718" class="difflineminus">-      this._log.debug(&quot;ancestors: &quot; + Log4Moz.enumerateProperties(ancestorLists).join(&quot;,&quot;));</span>
<a href="#l29.3719"></a><span id="l29.3719" class="difflineplus">+      this._log.debug(&quot;ref len: &quot; + references.length +</span>
<a href="#l29.3720"></a><span id="l29.3720" class="difflineplus">+                      &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l29.3721"></a><span id="l29.3721" class="difflineplus">+      this._log.debug(&quot;references: &quot; +</span>
<a href="#l29.3722"></a><span id="l29.3722" class="difflineplus">+                      Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l29.3723"></a><span id="l29.3723" class="difflineplus">+      this._log.debug(&quot;ancestors: &quot; +</span>
<a href="#l29.3724"></a><span id="l29.3724" class="difflineplus">+                      Log4Moz.enumerateProperties(ancestorLists).join(&quot;,&quot;));</span>
<a href="#l29.3725"></a><span id="l29.3725">     }</span>
<a href="#l29.3726"></a><span id="l29.3726"> </span>
<a href="#l29.3727"></a><span id="l29.3727">     // pull our current message lookup results off</span>
<a href="#l29.3728"></a><span id="l29.3728">     references.pop();</span>
<a href="#l29.3729"></a><span id="l29.3729">     let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l29.3730"></a><span id="l29.3730"> </span>
<a href="#l29.3731"></a><span id="l29.3731">     let conversationID = null;</span>
<a href="#l29.3732"></a><span id="l29.3732">     let conversation = null;</span>
<a href="#l29.3733"></a><span id="l29.3733" class="difflineat">@@ -2586,21 +2373,24 @@ var GlodaIndexer = {</span>
<a href="#l29.3734"></a><span id="l29.3734">           // we only care about the first instance of the message because we are</span>
<a href="#l29.3735"></a><span id="l29.3735">           //  able to guarantee the invariant that all messages with the same</span>
<a href="#l29.3736"></a><span id="l29.3736">           //  message id belong to the same conversation.</span>
<a href="#l29.3737"></a><span id="l29.3737">           let ancestor = ancestorList[0];</span>
<a href="#l29.3738"></a><span id="l29.3738">           if (conversationID === null) {</span>
<a href="#l29.3739"></a><span id="l29.3739">             conversationID = ancestor.conversationID;</span>
<a href="#l29.3740"></a><span id="l29.3740">             conversation = ancestor.conversation;</span>
<a href="#l29.3741"></a><span id="l29.3741">           }</span>
<a href="#l29.3742"></a><span id="l29.3742" class="difflineminus">-          else if (conversationID != ancestor.conversationID)</span>
<a href="#l29.3743"></a><span id="l29.3743" class="difflineminus">-            this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l29.3744"></a><span id="l29.3744" class="difflineminus">-                            ancestor.headerMessageID + &quot;.  It has conv id &quot; +</span>
<a href="#l29.3745"></a><span id="l29.3745" class="difflineminus">-                            ancestor.conversationID + &quot; but expected &quot; +</span>
<a href="#l29.3746"></a><span id="l29.3746" class="difflineminus">-                            conversationID + &quot;. ID: &quot; + ancestor.id);</span>
<a href="#l29.3747"></a><span id="l29.3747" class="difflineplus">+          else if (conversationID != ancestor.conversationID) {</span>
<a href="#l29.3748"></a><span id="l29.3748" class="difflineplus">+            // XXX this inconsistency is known and understood and tracked by</span>
<a href="#l29.3749"></a><span id="l29.3749" class="difflineplus">+            //  bug 478162 https://bugzilla.mozilla.org/show_bug.cgi?id=478162</span>
<a href="#l29.3750"></a><span id="l29.3750" class="difflineplus">+            //this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l29.3751"></a><span id="l29.3751" class="difflineplus">+            //                ancestor.headerMessageID + &quot;.  It has conv id &quot; +</span>
<a href="#l29.3752"></a><span id="l29.3752" class="difflineplus">+            //                ancestor.conversationID + &quot; but expected &quot; +</span>
<a href="#l29.3753"></a><span id="l29.3753" class="difflineplus">+            //                conversationID + &quot;. ID: &quot; + ancestor.id);</span>
<a href="#l29.3754"></a><span id="l29.3754" class="difflineplus">+          }</span>
<a href="#l29.3755"></a><span id="l29.3755">         }</span>
<a href="#l29.3756"></a><span id="l29.3756">       }</span>
<a href="#l29.3757"></a><span id="l29.3757">     }</span>
<a href="#l29.3758"></a><span id="l29.3758"> </span>
<a href="#l29.3759"></a><span id="l29.3759">     // nobody had one?  create a new conversation</span>
<a href="#l29.3760"></a><span id="l29.3760">     if (conversationID === null) {</span>
<a href="#l29.3761"></a><span id="l29.3761">       // (the create method could issue the id, making the call return</span>
<a href="#l29.3762"></a><span id="l29.3762">       //  without waiting for the database...)</span>
<a href="#l29.3763"></a><span id="l29.3763" class="difflineat">@@ -2737,17 +2527,17 @@ var GlodaIndexer = {</span>
<a href="#l29.3764"></a><span id="l29.3764">     delete curMsg._content;</span>
<a href="#l29.3765"></a><span id="l29.3765">     delete curMsg._isNew;</span>
<a href="#l29.3766"></a><span id="l29.3766">     delete curMsg._indexAuthor;</span>
<a href="#l29.3767"></a><span id="l29.3767">     delete curMsg._indexRecipients;</span>
<a href="#l29.3768"></a><span id="l29.3768"> </span>
<a href="#l29.3769"></a><span id="l29.3769">     // we want to update the header for messages only after the transaction</span>
<a href="#l29.3770"></a><span id="l29.3770">     //  irrevocably hits the disk.  otherwise we could get confused if the</span>
<a href="#l29.3771"></a><span id="l29.3771">     //  transaction rolls back or what not.</span>
<a href="#l29.3772"></a><span id="l29.3772" class="difflineminus">-    GlodaDatastore.runPostCommit(MakeCleanMsgHdrCallback(aMsgHdr, curMsg.id));</span>
<a href="#l29.3773"></a><span id="l29.3773" class="difflineplus">+    PendingCommitTracker.track(aMsgHdr, curMsg.id);</span>
<a href="#l29.3774"></a><span id="l29.3774"> </span>
<a href="#l29.3775"></a><span id="l29.3775">     yield this.kWorkDone;</span>
<a href="#l29.3776"></a><span id="l29.3776">   },</span>
<a href="#l29.3777"></a><span id="l29.3777"> </span>
<a href="#l29.3778"></a><span id="l29.3778">   /**</span>
<a href="#l29.3779"></a><span id="l29.3779">    * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l29.3780"></a><span id="l29.3780">    *  tricky than one would first expect because there are potentially</span>
<a href="#l29.3781"></a><span id="l29.3781">    *  attributes not immediately associated with this message that reference</span>
<a href="#l29.3782"></a><span id="l29.3782" class="difflineat">@@ -2763,81 +2553,80 @@ var GlodaIndexer = {</span>
<a href="#l29.3783"></a><span id="l29.3783">    *  don't redundantly store attributes, we can deal with the problem by</span>
<a href="#l29.3784"></a><span id="l29.3784">    *  collecting up all the attributes that accept a message as their object</span>
<a href="#l29.3785"></a><span id="l29.3785">    *  type and issuing a delete against that.  For example, delete (*, [1,2,3],</span>
<a href="#l29.3786"></a><span id="l29.3786">    *  message id).</span>
<a href="#l29.3787"></a><span id="l29.3787">    * (We are punting because we haven't implemented support for generating</span>
<a href="#l29.3788"></a><span id="l29.3788">    *  attributes like that yet.)</span>
<a href="#l29.3789"></a><span id="l29.3789">    *</span>
<a href="#l29.3790"></a><span id="l29.3790">    * @TODO: implement deletion of attributes that reference (deleted) messages</span>
<a href="#l29.3791"></a><span id="l29.3791" class="difflineplus">+   *</span>
<a href="#l29.3792"></a><span id="l29.3792" class="difflineplus">+   * @param</span>
<a href="#l29.3793"></a><span id="l29.3793">    */</span>
<a href="#l29.3794"></a><span id="l29.3794" class="difflineminus">-  _deleteMessage: function gloda_index_deleteMessage(aMessage) {</span>
<a href="#l29.3795"></a><span id="l29.3795" class="difflineplus">+  _deleteMessage: function gloda_index_deleteMessage(aMessage,</span>
<a href="#l29.3796"></a><span id="l29.3796" class="difflineplus">+                                                     aCallbackHandle) {</span>
<a href="#l29.3797"></a><span id="l29.3797" class="difflineplus">+    let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l29.3798"></a><span id="l29.3798" class="difflineplus">+    if (logDebug)</span>
<a href="#l29.3799"></a><span id="l29.3799" class="difflineplus">+      this._log.debug(&quot;*** Deleting message: &quot; + aMessage);</span>
<a href="#l29.3800"></a><span id="l29.3800" class="difflineplus">+</span>
<a href="#l29.3801"></a><span id="l29.3801">     // -- delete our attributes</span>
<a href="#l29.3802"></a><span id="l29.3802">     // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l29.3803"></a><span id="l29.3803">     //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l29.3804"></a><span id="l29.3804">     //  schema but the back-end ignores it)</span>
<a href="#l29.3805"></a><span id="l29.3805" class="difflineminus">-    aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l29.3806"></a><span id="l29.3806" class="difflineplus">+    GlodaDatastore.clearMessageAttributes(aMessage);</span>
<a href="#l29.3807"></a><span id="l29.3807"> </span>
<a href="#l29.3808"></a><span id="l29.3808">     // -- delete our message or ghost us, and maybe nuke the whole conversation</span>
<a href="#l29.3809"></a><span id="l29.3809">     // look at the other messages in the conversation.</span>
<a href="#l29.3810"></a><span id="l29.3810" class="difflineminus">-    let conversationCollection = aMessage.conversation.getMessagesCollection(</span>
<a href="#l29.3811"></a><span id="l29.3811" class="difflineminus">-        aCallbackHandle);</span>
<a href="#l29.3812"></a><span id="l29.3812" class="difflineplus">+    let convPrivQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l29.3813"></a><span id="l29.3813" class="difflineplus">+                                         noDbQueryValidityConstraints: true,</span>
<a href="#l29.3814"></a><span id="l29.3814" class="difflineplus">+                                       });</span>
<a href="#l29.3815"></a><span id="l29.3815" class="difflineplus">+    convPrivQuery.conversation(aMessage.conversation);</span>
<a href="#l29.3816"></a><span id="l29.3816" class="difflineplus">+    let conversationCollection = convPrivQuery.getCollection(aCallbackHandle);</span>
<a href="#l29.3817"></a><span id="l29.3817">     yield this.kWorkAsync;</span>
<a href="#l29.3818"></a><span id="l29.3818" class="difflineplus">+</span>
<a href="#l29.3819"></a><span id="l29.3819">     let conversationMsgs = conversationCollection.items;</span>
<a href="#l29.3820"></a><span id="l29.3820"> </span>
<a href="#l29.3821"></a><span id="l29.3821">     let ghosts = [];</span>
<a href="#l29.3822"></a><span id="l29.3822">     let twinMessage = null;</span>
<a href="#l29.3823"></a><span id="l29.3823" class="difflineminus">-    for (let iMsg = 0; iMsg &lt; conversationMsgs.length; iMsg++) {</span>
<a href="#l29.3824"></a><span id="l29.3824" class="difflineminus">-      let convMsg = conversationMsgs[iMsg];</span>
<a href="#l29.3825"></a><span id="l29.3825" class="difflineminus">-</span>
<a href="#l29.3826"></a><span id="l29.3826" class="difflineminus">-      // ignore our message</span>
<a href="#l29.3827"></a><span id="l29.3827" class="difflineplus">+    for each (let [, convMsg] in Iterator(conversationMsgs)) {</span>
<a href="#l29.3828"></a><span id="l29.3828" class="difflineplus">+      // ignore our own message</span>
<a href="#l29.3829"></a><span id="l29.3829">       if (convMsg.id == aMessage.id)</span>
<a href="#l29.3830"></a><span id="l29.3830">         continue;</span>
<a href="#l29.3831"></a><span id="l29.3831"> </span>
<a href="#l29.3832"></a><span id="l29.3832">       if (convMsg.folderID !== null) {</span>
<a href="#l29.3833"></a><span id="l29.3833">         if (convMsg.headerMessageID == aMessage.headerMessageID) {</span>
<a href="#l29.3834"></a><span id="l29.3834">           twinMessage = convMsg;</span>
<a href="#l29.3835"></a><span id="l29.3835">         }</span>
<a href="#l29.3836"></a><span id="l29.3836">       }</span>
<a href="#l29.3837"></a><span id="l29.3837">       else {</span>
<a href="#l29.3838"></a><span id="l29.3838">         ghosts.push(convMsg);</span>
<a href="#l29.3839"></a><span id="l29.3839">       }</span>
<a href="#l29.3840"></a><span id="l29.3840">     }</span>
<a href="#l29.3841"></a><span id="l29.3841"> </span>
<a href="#l29.3842"></a><span id="l29.3842" class="difflineminus">-    // is everyone else a ghost? (note that conversationMsgs includes us, but</span>
<a href="#l29.3843"></a><span id="l29.3843" class="difflineplus">+    // is everyone else a ghost? (note that conversation includes us, but</span>
<a href="#l29.3844"></a><span id="l29.3844">     //  ghosts cannot)</span>
<a href="#l29.3845"></a><span id="l29.3845">     if ((conversationMsgs.length - 1) == ghosts.length) {</span>
<a href="#l29.3846"></a><span id="l29.3846">       // obliterate the conversation including aMessage.</span>
<a href="#l29.3847"></a><span id="l29.3847">       // since everyone else is a ghost they have no attributes.  however, the</span>
<a href="#l29.3848"></a><span id="l29.3848">       //  conversation may some day have attributes targeted against it, so it</span>
<a href="#l29.3849"></a><span id="l29.3849">       //  gets a helper.</span>
<a href="#l29.3850"></a><span id="l29.3850" class="difflineminus">-      this._deleteConversationOfMessage(aMessage);</span>
<a href="#l29.3851"></a><span id="l29.3851" class="difflineplus">+      for each (let [, msg] in Iterator(conversationMsgs)) {</span>
<a href="#l29.3852"></a><span id="l29.3852" class="difflineplus">+        GlodaDatastore.deleteMessageByID(msg.id);</span>
<a href="#l29.3853"></a><span id="l29.3853" class="difflineplus">+      }</span>
<a href="#l29.3854"></a><span id="l29.3854" class="difflineplus">+      GlodaDatastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l29.3855"></a><span id="l29.3855">       aMessage._nuke();</span>
<a href="#l29.3856"></a><span id="l29.3856">     }</span>
<a href="#l29.3857"></a><span id="l29.3857">     else { // there is at least one real message out there, so the only q is...</span>
<a href="#l29.3858"></a><span id="l29.3858">       // do we have a twin (so it's okay to delete us) or do we become a ghost?</span>
<a href="#l29.3859"></a><span id="l29.3859">       if (twinMessage !== null) { // just delete us</span>
<a href="#l29.3860"></a><span id="l29.3860" class="difflineminus">-        aMessage._datastore.deleteMessageByID(aMessage.id);</span>
<a href="#l29.3861"></a><span id="l29.3861" class="difflineplus">+        GlodaDatastore.deleteMessageByID(aMessage.id);</span>
<a href="#l29.3862"></a><span id="l29.3862">         aMessage._nuke();</span>
<a href="#l29.3863"></a><span id="l29.3863">       }</span>
<a href="#l29.3864"></a><span id="l29.3864">       else { // ghost us</span>
<a href="#l29.3865"></a><span id="l29.3865">         aMessage._ghost();</span>
<a href="#l29.3866"></a><span id="l29.3866" class="difflineminus">-        aMessage._datastore.updateMessage(aMessage);</span>
<a href="#l29.3867"></a><span id="l29.3867" class="difflineplus">+        GlodaDatastore.updateMessage(aMessage);</span>
<a href="#l29.3868"></a><span id="l29.3868">       }</span>
<a href="#l29.3869"></a><span id="l29.3869">     }</span>
<a href="#l29.3870"></a><span id="l29.3870"> </span>
<a href="#l29.3871"></a><span id="l29.3871">     yield this.kWorkDone;</span>
<a href="#l29.3872"></a><span id="l29.3872">   },</span>
<a href="#l29.3873"></a><span id="l29.3873" class="difflineminus">-</span>
<a href="#l29.3874"></a><span id="l29.3874" class="difflineminus">-  /**</span>
<a href="#l29.3875"></a><span id="l29.3875" class="difflineminus">-   * Delete an entire conversation, using the passed-in message which must be</span>
<a href="#l29.3876"></a><span id="l29.3876" class="difflineminus">-   *  the last non-ghost in the conversation and have its attributes all</span>
<a href="#l29.3877"></a><span id="l29.3877" class="difflineminus">-   *  deleted.  This function issues the batch delete of all the ghosts (and the</span>
<a href="#l29.3878"></a><span id="l29.3878" class="difflineminus">-   *  message), and in the future will take care to nuke any attributes</span>
<a href="#l29.3879"></a><span id="l29.3879" class="difflineminus">-   *  referencing the conversation.</span>
<a href="#l29.3880"></a><span id="l29.3880" class="difflineminus">-   */</span>
<a href="#l29.3881"></a><span id="l29.3881" class="difflineminus">-  _deleteConversationOfMessage:</span>
<a href="#l29.3882"></a><span id="l29.3882" class="difflineminus">-      function gloda_index_deleteConversationOfMessage(aMessage) {</span>
<a href="#l29.3883"></a><span id="l29.3883" class="difflineminus">-    aMessage._datastore.deleteMessagesByConversationID(aMessage.conversationID);</span>
<a href="#l29.3884"></a><span id="l29.3884" class="difflineminus">-    aMessage._datastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l29.3885"></a><span id="l29.3885" class="difflineminus">-  },</span>
<a href="#l29.3886"></a><span id="l29.3886"> };</span>
<a href="#l29.3887"></a><span id="l29.3887" class="difflineminus">-GlodaIndexer._init();</span>
<a href="#l29.3888"></a><span id="l29.3888" class="difflineplus">+GlodaIndexer.registerIndexer(GlodaMsgIndexer);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -48,164 +48,58 @@</span>
<a href="#l30.4"></a><span id="l30.4"> const EXPORTED_SYMBOLS = ['GlodaIndexer', 'IndexingJob'];</span>
<a href="#l30.5"></a><span id="l30.5"> </span>
<a href="#l30.6"></a><span id="l30.6"> const Cc = Components.classes;</span>
<a href="#l30.7"></a><span id="l30.7"> const Ci = Components.interfaces;</span>
<a href="#l30.8"></a><span id="l30.8"> const Cr = Components.results;</span>
<a href="#l30.9"></a><span id="l30.9"> const Cu = Components.utils;</span>
<a href="#l30.10"></a><span id="l30.10"> </span>
<a href="#l30.11"></a><span id="l30.11"> Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineplus">+Cu.import(&quot;resource://app/modules/iteratorUtils.jsm&quot;);</span>
<a href="#l30.13"></a><span id="l30.13"> </span>
<a href="#l30.14"></a><span id="l30.14"> Cu.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l30.15"></a><span id="l30.15"> </span>
<a href="#l30.16"></a><span id="l30.16"> Cu.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l30.17"></a><span id="l30.17"> Cu.import(&quot;resource://app/modules/gloda/datastore.js&quot;);</span>
<a href="#l30.18"></a><span id="l30.18"> Cu.import(&quot;resource://app/modules/gloda/gloda.js&quot;);</span>
<a href="#l30.19"></a><span id="l30.19"> Cu.import(&quot;resource://app/modules/gloda/collection.js&quot;);</span>
<a href="#l30.20"></a><span id="l30.20"> Cu.import(&quot;resource://app/modules/gloda/connotent.js&quot;);</span>
<a href="#l30.21"></a><span id="l30.21"> </span>
<a href="#l30.22"></a><span id="l30.22" class="difflineminus">-Cu.import(&quot;resource://app/modules/gloda/mimemsg.js&quot;);</span>
<a href="#l30.23"></a><span id="l30.23" class="difflineminus">-</span>
<a href="#l30.24"></a><span id="l30.24" class="difflineminus">-// Components.results does not have mailnews error codes!</span>
<a href="#l30.25"></a><span id="l30.25" class="difflineminus">-const NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE = 0x80550005;</span>
<a href="#l30.26"></a><span id="l30.26" class="difflineminus">-</span>
<a href="#l30.27"></a><span id="l30.27" class="difflineminus">-const GLODA_MESSAGE_ID_PROPERTY = &quot;gloda-id&quot;;</span>
<a href="#l30.28"></a><span id="l30.28" class="difflineminus">-const GLODA_DIRTY_PROPERTY = &quot;gloda-dirty&quot;;</span>
<a href="#l30.29"></a><span id="l30.29" class="difflineminus">-</span>
<a href="#l30.30"></a><span id="l30.30" class="difflineminus">-// for list comprehension fun</span>
<a href="#l30.31"></a><span id="l30.31" class="difflineminus">-function range(begin, end) {</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineminus">-  for (let i = begin; i &lt; end; ++i) {</span>
<a href="#l30.33"></a><span id="l30.33" class="difflineminus">-    yield i;</span>
<a href="#l30.34"></a><span id="l30.34" class="difflineminus">-  }</span>
<a href="#l30.35"></a><span id="l30.35" class="difflineminus">-}</span>
<a href="#l30.36"></a><span id="l30.36" class="difflineminus">-</span>
<a href="#l30.37"></a><span id="l30.37" class="difflineminus">-const GFI = Log4Moz.repository.getLogger(&quot;gloda.fixiterator&quot;);</span>
<a href="#l30.38"></a><span id="l30.38" class="difflineminus">-</span>
<a href="#l30.39"></a><span id="l30.39" class="difflineminus">-</span>
<a href="#l30.40"></a><span id="l30.40" class="difflineminus">-// FROM STEEL (a la Joey Minta/jminta)</span>
<a href="#l30.41"></a><span id="l30.41" class="difflineminus">-// (and to go away when STEEL is checked in, although we may also want to</span>
<a href="#l30.42"></a><span id="l30.42" class="difflineminus">-//  consider just specializing the code in the few places this method is used.)</span>
<a href="#l30.43"></a><span id="l30.43" class="difflineminus">-/**</span>
<a href="#l30.44"></a><span id="l30.44" class="difflineminus">- * This function will take a variety of xpcom iterators designed for c++ and turn</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineminus">- * them into a nice JavaScript style object that can be iterated using for...in</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineminus">- *</span>
<a href="#l30.47"></a><span id="l30.47" class="difflineminus">- * Currently, we support the following types of xpcom iterators:</span>
<a href="#l30.48"></a><span id="l30.48" class="difflineminus">- *   nsISupportsArray</span>
<a href="#l30.49"></a><span id="l30.49" class="difflineminus">- *   nsIEnumerator</span>
<a href="#l30.50"></a><span id="l30.50" class="difflineminus">- *   nsISimpleEnumerator</span>
<a href="#l30.51"></a><span id="l30.51" class="difflineminus">- *</span>
<a href="#l30.52"></a><span id="l30.52" class="difflineminus">- *   @param aEnum  the enumerator to convert</span>
<a href="#l30.53"></a><span id="l30.53" class="difflineminus">- *   @param aIface (optional) an interface to QI each object to prior to returning</span>
<a href="#l30.54"></a><span id="l30.54" class="difflineminus">- *</span>
<a href="#l30.55"></a><span id="l30.55" class="difflineminus">- *   @note This does *not* return an Array object.  It returns an object that can</span>
<a href="#l30.56"></a><span id="l30.56" class="difflineminus">- *         be use in for...in contexts only.  To create such an array, use</span>
<a href="#l30.57"></a><span id="l30.57" class="difflineminus">- *         var array = [a for (a in fixIterator(xpcomEnumerator))];</span>
<a href="#l30.58"></a><span id="l30.58" class="difflineminus">- */</span>
<a href="#l30.59"></a><span id="l30.59" class="difflineminus">-function fixIterator(aEnum, aIface) {</span>
<a href="#l30.60"></a><span id="l30.60" class="difflineminus">-  let face = aIface || Ci.nsISupports;</span>
<a href="#l30.61"></a><span id="l30.61" class="difflineminus">-  // Try to QI our object to each of the known iterator types.  If the QI does</span>
<a href="#l30.62"></a><span id="l30.62" class="difflineminus">-  // not throw, assign our iteration function</span>
<a href="#l30.63"></a><span id="l30.63" class="difflineminus">-  try {</span>
<a href="#l30.64"></a><span id="l30.64" class="difflineminus">-    aEnum.QueryInterface(Ci.nsISupportsArray);</span>
<a href="#l30.65"></a><span id="l30.65" class="difflineminus">-    let iter = function() {</span>
<a href="#l30.66"></a><span id="l30.66" class="difflineminus">-      let count = aEnum.Count();</span>
<a href="#l30.67"></a><span id="l30.67" class="difflineminus">-      for (let i = 0; i &lt; count; i++)</span>
<a href="#l30.68"></a><span id="l30.68" class="difflineminus">-        yield aEnum.GetElementAt(i).QueryInterface(face);</span>
<a href="#l30.69"></a><span id="l30.69" class="difflineminus">-    }</span>
<a href="#l30.70"></a><span id="l30.70" class="difflineminus">-    return { __iterator__: iter };</span>
<a href="#l30.71"></a><span id="l30.71" class="difflineminus">-  } catch(ex) {}</span>
<a href="#l30.72"></a><span id="l30.72" class="difflineminus">-</span>
<a href="#l30.73"></a><span id="l30.73" class="difflineminus">-  // Now try nsIEnumerator</span>
<a href="#l30.74"></a><span id="l30.74" class="difflineminus">-  try {</span>
<a href="#l30.75"></a><span id="l30.75" class="difflineminus">-    aEnum.QueryInterface(Ci.nsIEnumerator);</span>
<a href="#l30.76"></a><span id="l30.76" class="difflineminus">-    let done = false;</span>
<a href="#l30.77"></a><span id="l30.77" class="difflineminus">-    let iter = function() {</span>
<a href="#l30.78"></a><span id="l30.78" class="difflineminus">-      while (!done) {</span>
<a href="#l30.79"></a><span id="l30.79" class="difflineminus">-        try {</span>
<a href="#l30.80"></a><span id="l30.80" class="difflineminus">-          //rets.push(aEnum.currentItem().QueryInterface(face));</span>
<a href="#l30.81"></a><span id="l30.81" class="difflineminus">-          yield aEnum.currentItem().QueryInterface(face);</span>
<a href="#l30.82"></a><span id="l30.82" class="difflineminus">-          aEnum.next();</span>
<a href="#l30.83"></a><span id="l30.83" class="difflineminus">-        } catch(ex) {</span>
<a href="#l30.84"></a><span id="l30.84" class="difflineminus">-          done = true;</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineminus">-          GFI.error(face + &quot; =&gt; &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex)</span>
<a href="#l30.86"></a><span id="l30.86" class="difflineminus">-        }</span>
<a href="#l30.87"></a><span id="l30.87" class="difflineminus">-      }</span>
<a href="#l30.88"></a><span id="l30.88" class="difflineminus">-    };</span>
<a href="#l30.89"></a><span id="l30.89" class="difflineminus">-</span>
<a href="#l30.90"></a><span id="l30.90" class="difflineminus">-    return { __iterator__: iter };</span>
<a href="#l30.91"></a><span id="l30.91" class="difflineminus">-  } catch(ex) {}</span>
<a href="#l30.92"></a><span id="l30.92" class="difflineminus">-</span>
<a href="#l30.93"></a><span id="l30.93" class="difflineminus">-  // how about nsISimpleEnumerator? this one is nice and simple</span>
<a href="#l30.94"></a><span id="l30.94" class="difflineminus">-  try {</span>
<a href="#l30.95"></a><span id="l30.95" class="difflineminus">-    aEnum.QueryInterface(Ci.nsISimpleEnumerator);</span>
<a href="#l30.96"></a><span id="l30.96" class="difflineminus">-    let iter = function () {</span>
<a href="#l30.97"></a><span id="l30.97" class="difflineminus">-      while (aEnum.hasMoreElements())</span>
<a href="#l30.98"></a><span id="l30.98" class="difflineminus">-        yield aEnum.getNext().QueryInterface(face);</span>
<a href="#l30.99"></a><span id="l30.99" class="difflineminus">-    }</span>
<a href="#l30.100"></a><span id="l30.100" class="difflineminus">-    return { __iterator__: iter };</span>
<a href="#l30.101"></a><span id="l30.101" class="difflineminus">-  } catch(ex) {}</span>
<a href="#l30.102"></a><span id="l30.102" class="difflineminus">-}</span>
<a href="#l30.103"></a><span id="l30.103" class="difflineminus">-</span>
<a href="#l30.104"></a><span id="l30.104" class="difflineminus">-function MakeCleanMsgHdrCallback(aMsgHdr, aGlodaMessageID) {</span>
<a href="#l30.105"></a><span id="l30.105" class="difflineminus">-  return function() {</span>
<a href="#l30.106"></a><span id="l30.106" class="difflineminus">-    // Mark this message as indexed</span>
<a href="#l30.107"></a><span id="l30.107" class="difflineminus">-    aMsgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY, aGlodaMessageID);</span>
<a href="#l30.108"></a><span id="l30.108" class="difflineminus">-    // If there is a gloda-dirty flag on there, clear it by writing a 0.  (But</span>
<a href="#l30.109"></a><span id="l30.109" class="difflineminus">-    //  don't do this if we didn't have a dirty flag on there in the first</span>
<a href="#l30.110"></a><span id="l30.110" class="difflineminus">-    //  case.)  It sounds like we would actually prefer to &quot;cut&quot; the &quot;cell&quot;,</span>
<a href="#l30.111"></a><span id="l30.111" class="difflineminus">-    //  but I don't see any in-domain means of doing that.</span>
<a href="#l30.112"></a><span id="l30.112" class="difflineminus">-    try {</span>
<a href="#l30.113"></a><span id="l30.113" class="difflineminus">-      let isDirty = aMsgHdr.getUint32Property(GLODA_DIRTY_PROPERTY);</span>
<a href="#l30.114"></a><span id="l30.114" class="difflineminus">-      if (isDirty)</span>
<a href="#l30.115"></a><span id="l30.115" class="difflineminus">-        aMsgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l30.116"></a><span id="l30.116" class="difflineminus">-    }</span>
<a href="#l30.117"></a><span id="l30.117" class="difflineminus">-    catch (ex) {}</span>
<a href="#l30.118"></a><span id="l30.118" class="difflineminus">-  };</span>
<a href="#l30.119"></a><span id="l30.119" class="difflineminus">-}</span>
<a href="#l30.120"></a><span id="l30.120" class="difflineminus">-</span>
<a href="#l30.121"></a><span id="l30.121"> /**</span>
<a href="#l30.122"></a><span id="l30.122">  * @class Capture the indexing batch concept explicitly.</span>
<a href="#l30.123"></a><span id="l30.123">  *</span>
<a href="#l30.124"></a><span id="l30.124">  * @param aJobType The type of thing we are indexing.  Current choices are:</span>
<a href="#l30.125"></a><span id="l30.125">  *   &quot;folder&quot; and &quot;message&quot;.  Previous choices included &quot;account&quot;.  The indexer</span>
<a href="#l30.126"></a><span id="l30.126">  *   currently knows too much about these; they should be de-coupled.</span>
<a href="#l30.127"></a><span id="l30.127" class="difflineminus">- * @param aDeltaType -1 for deletion, 0 for move, 1 for addition/new.</span>
<a href="#l30.128"></a><span id="l30.128">  * @param aID Specific to the job type, but for now only used to hold folder</span>
<a href="#l30.129"></a><span id="l30.129">  *     IDs.</span>
<a href="#l30.130"></a><span id="l30.130">  *</span>
<a href="#l30.131"></a><span id="l30.131">  * @ivar items The list of items to process during this job/batch.  (For</span>
<a href="#l30.132"></a><span id="l30.132">  *     example, if this is a &quot;messages&quot; job, this would be the list of messages</span>
<a href="#l30.133"></a><span id="l30.133">  *     to process, although the specific representation is determined by the</span>
<a href="#l30.134"></a><span id="l30.134">  *     job.)  The list will only be mutated through the addition of extra items.</span>
<a href="#l30.135"></a><span id="l30.135">  * @ivar offset The current offset into the 'items' list (if used), updated as</span>
<a href="#l30.136"></a><span id="l30.136">  *     processing occurs.  If 'items' is not used, the processing code can also</span>
<a href="#l30.137"></a><span id="l30.137">  *     update this in a similar fashion.  This is used by the status</span>
<a href="#l30.138"></a><span id="l30.138">  *     notification code in conjunction with goal.</span>
<a href="#l30.139"></a><span id="l30.139">  * @ivar goal The total number of items to index/actions to perform in this job.</span>
<a href="#l30.140"></a><span id="l30.140">  *     This number may increase during the life of the job, but should not</span>
<a href="#l30.141"></a><span id="l30.141">  *     decrease.  This is used by the status notification code in conjunction</span>
<a href="#l30.142"></a><span id="l30.142">  *     with the goal.</span>
<a href="#l30.143"></a><span id="l30.143" class="difflineminus">- * @ivar recoverable Integer indicating if this job is recoverable, and how</span>
<a href="#l30.144"></a><span id="l30.144" class="difflineminus">- *     many failures we should allow for before we give up.  By default, this is</span>
<a href="#l30.145"></a><span id="l30.145" class="difflineminus">- *     set to 10, but your job should choose a more appopriate number itself.</span>
<a href="#l30.146"></a><span id="l30.146" class="difflineminus">- *</span>
<a href="#l30.147"></a><span id="l30.147" class="difflineminus">- * @constructor</span>
<a href="#l30.148"></a><span id="l30.148">  */</span>
<a href="#l30.149"></a><span id="l30.149" class="difflineminus">-function IndexingJob(aJobType, aDeltaType, aID, aItems) {</span>
<a href="#l30.150"></a><span id="l30.150" class="difflineplus">+function IndexingJob(aJobType, aID, aItems) {</span>
<a href="#l30.151"></a><span id="l30.151">   this.jobType = aJobType;</span>
<a href="#l30.152"></a><span id="l30.152" class="difflineminus">-  this.deltaType = aDeltaType;</span>
<a href="#l30.153"></a><span id="l30.153">   this.id = aID;</span>
<a href="#l30.154"></a><span id="l30.154">   this.items = (aItems != null) ? aItems : [];</span>
<a href="#l30.155"></a><span id="l30.155">   this.offset = 0;</span>
<a href="#l30.156"></a><span id="l30.156">   this.goal = null;</span>
<a href="#l30.157"></a><span id="l30.157" class="difflineminus">-  this.recoverable = 10;</span>
<a href="#l30.158"></a><span id="l30.158"> }</span>
<a href="#l30.159"></a><span id="l30.159"> IndexingJob.prototype = {</span>
<a href="#l30.160"></a><span id="l30.160">   toString: function IndexingJob_toString() {</span>
<a href="#l30.161"></a><span id="l30.161" class="difflineminus">-    return &quot;[job:&quot; + this.jobType + &quot; delta:&quot; + this.deltaType +</span>
<a href="#l30.162"></a><span id="l30.162" class="difflineplus">+    return &quot;[job:&quot; + this.jobType +</span>
<a href="#l30.163"></a><span id="l30.163">       &quot; id:&quot; + this.id + &quot; items:&quot; + (this.items ? this.items.length : &quot;no&quot;) +</span>
<a href="#l30.164"></a><span id="l30.164">       &quot; offset:&quot; + this.offset + &quot; goal:&quot; + this.goal + &quot;]&quot;;</span>
<a href="#l30.165"></a><span id="l30.165">   }</span>
<a href="#l30.166"></a><span id="l30.166"> };</span>
<a href="#l30.167"></a><span id="l30.167"> </span>
<a href="#l30.168"></a><span id="l30.168"> /**</span>
<a href="#l30.169"></a><span id="l30.169">  * @namespace Core indexing logic, plus message-specific indexing logic.</span>
<a href="#l30.170"></a><span id="l30.170">  *</span>
<a href="#l30.171"></a><span id="l30.171" class="difflineat">@@ -222,71 +116,28 @@ IndexingJob.prototype = {</span>
<a href="#l30.172"></a><span id="l30.172">  *   end up at the same indexed state regardless of whether a user lets</span>
<a href="#l30.173"></a><span id="l30.173">  *   indexing run to completion or restarts thunderbird in the middle of the</span>
<a href="#l30.174"></a><span id="l30.174">  *   process.  (It is okay to take slightly longer in the latter case.)</span>
<a href="#l30.175"></a><span id="l30.175">  *</span>
<a href="#l30.176"></a><span id="l30.176">  * Worst Case Scenario Avoidance</span>
<a href="#l30.177"></a><span id="l30.177">  * - We should try to be O(1) memory-wise regardless of what notifications</span>
<a href="#l30.178"></a><span id="l30.178">  *   are thrown at us.</span>
<a href="#l30.179"></a><span id="l30.179">  *</span>
<a href="#l30.180"></a><span id="l30.180" class="difflineminus">- * === Indexing Strategy</span>
<a href="#l30.181"></a><span id="l30.181" class="difflineminus">- * To these ends, we implement things like so:</span>
<a href="#l30.182"></a><span id="l30.182" class="difflineminus">- *</span>
<a href="#l30.183"></a><span id="l30.183" class="difflineminus">- * Mesage State Tracking</span>
<a href="#l30.184"></a><span id="l30.184" class="difflineminus">- * - We store a property on all indexed headers indicating their gloda message</span>
<a href="#l30.185"></a><span id="l30.185" class="difflineminus">- *   id.  This allows us to tell whether a message is indexed from the header,</span>
<a href="#l30.186"></a><span id="l30.186" class="difflineminus">- *   without having to consult the SQL database.</span>
<a href="#l30.187"></a><span id="l30.187" class="difflineminus">- * - When we receive an event that indicates that a message's meta-data has</span>
<a href="#l30.188"></a><span id="l30.188" class="difflineminus">- *   changed and gloda needs to re-index the message, we set a property on the</span>
<a href="#l30.189"></a><span id="l30.189" class="difflineminus">- *   header that indicates the message is dirty.</span>
<a href="#l30.190"></a><span id="l30.190" class="difflineminus">- * - We store a property on folders that indicate that the folder's index is</span>
<a href="#l30.191"></a><span id="l30.191" class="difflineminus">- *   up-to-date.  Absence of this property is akin to a 0=folder not up to date.</span>
<a href="#l30.192"></a><span id="l30.192" class="difflineminus">- *   There is no particular reason for the choice of using the folder's</span>
<a href="#l30.193"></a><span id="l30.193" class="difflineminus">- *   properties (via the folder cache implementation) over gloda's own folder</span>
<a href="#l30.194"></a><span id="l30.194" class="difflineminus">- *   meta-data.</span>
<a href="#l30.195"></a><span id="l30.195" class="difflineminus">- *</span>
<a href="#l30.196"></a><span id="l30.196" class="difflineminus">- * Indexing Message Control</span>
<a href="#l30.197"></a><span id="l30.197" class="difflineminus">- * - We index the headers of all IMAP messages. We index the bodies of all IMAP</span>
<a href="#l30.198"></a><span id="l30.198" class="difflineminus">- *   messages that are offline.  We index all local messages.</span>
<a href="#l30.199"></a><span id="l30.199" class="difflineminus">- *   We plan to avoid indexing news messages.</span>
<a href="#l30.200"></a><span id="l30.200" class="difflineminus">- * - We would like a way to express desires about indexing that either don't</span>
<a href="#l30.201"></a><span id="l30.201" class="difflineminus">- *   confound offline storage with indexing, or actually allow some choice.</span>
<a href="#l30.202"></a><span id="l30.202" class="difflineplus">+ * ===  Indexing Throttling</span>
<a href="#l30.203"></a><span id="l30.203">  *</span>
<a href="#l30.204"></a><span id="l30.204" class="difflineminus">- * Indexing</span>
<a href="#l30.205"></a><span id="l30.205" class="difflineminus">- * - We process one folder at a time, walking the headers in the folder,</span>
<a href="#l30.206"></a><span id="l30.206" class="difflineminus">- *   indexing those which should be indexed, but which have never been indexed</span>
<a href="#l30.207"></a><span id="l30.207" class="difflineminus">- *   or are dirty.</span>
<a href="#l30.208"></a><span id="l30.208" class="difflineminus">- * - For local folders, we use GetDatabaseWithReparse to ensure that the .msf</span>
<a href="#l30.209"></a><span id="l30.209" class="difflineminus">- *   file exists.  For IMAP folders, we simply use GetDatabase because we know</span>
<a href="#l30.210"></a><span id="l30.210" class="difflineminus">- *   the auto-sync logic will make sure that the folder is up-to-date and we</span>
<a href="#l30.211"></a><span id="l30.211" class="difflineminus">- *   want to avoid creating problems through use of updateFolder.</span>
<a href="#l30.212"></a><span id="l30.212" class="difflineminus">- *</span>
<a href="#l30.213"></a><span id="l30.213" class="difflineminus">- * Indexing Throttling</span>
<a href="#l30.214"></a><span id="l30.214" class="difflineminus">- * - Unless we believe everything is up-to-date, then we are always indexing.</span>
<a href="#l30.215"></a><span id="l30.215" class="difflineminus">- *   We must be able to process messages</span>
<a href="#l30.216"></a><span id="l30.216" class="difflineminus">- *</span>
<a href="#l30.217"></a><span id="l30.217" class="difflineminus">- *</span>
<a href="#l30.218"></a><span id="l30.218" class="difflineminus">- * === Message Indexing</span>
<a href="#l30.219"></a><span id="l30.219" class="difflineminus">- *</span>
<a href="#l30.220"></a><span id="l30.220" class="difflineminus">- * We are good at listening to nsIMsgFolderListener events.  Unfortunately,</span>
<a href="#l30.221"></a><span id="l30.221" class="difflineminus">- *  MailNews isn't pervasively thorough at generating these yet (newsgroups</span>
<a href="#l30.222"></a><span id="l30.222" class="difflineminus">- *  don't produce them, probably not RSS either.)  This provides us with</span>
<a href="#l30.223"></a><span id="l30.223" class="difflineminus">- *  message addition, moves/copies, and deletion.</span>
<a href="#l30.224"></a><span id="l30.224" class="difflineminus">- * We are not good at listening to nsIFolderListener events.  This means we fail</span>
<a href="#l30.225"></a><span id="l30.225" class="difflineminus">- *  to update ourselves when a message is changed because of a change in tags,</span>
<a href="#l30.226"></a><span id="l30.226" class="difflineminus">- *  read status/starred status/etc.  (Well, in fairness, events aren't actually</span>
<a href="#l30.227"></a><span id="l30.227" class="difflineminus">- *  generated in all of those cases either, yet, but we should try.)  We need</span>
<a href="#l30.228"></a><span id="l30.228" class="difflineminus">- *  to handle this.</span>
<a href="#l30.229"></a><span id="l30.229" class="difflineminus">- *</span>
<a href="#l30.230"></a><span id="l30.230" class="difflineminus">- * Currently, when we index a message, when it comes to attributes, we ignore</span>
<a href="#l30.231"></a><span id="l30.231" class="difflineminus">- *  all that has come before us and simply blow away the attributes and apply</span>
<a href="#l30.232"></a><span id="l30.232" class="difflineminus">- *  those provided by the attribute providers anew.  This is not particularly</span>
<a href="#l30.233"></a><span id="l30.233" class="difflineminus">- *  efficient for anyone.  Also, I think we probably screw this up now that we</span>
<a href="#l30.234"></a><span id="l30.234" class="difflineminus">- *  have object identity support.  Uh, so, this should be improved, but</span>
<a href="#l30.235"></a><span id="l30.235" class="difflineminus">- *  certainly works.</span>
<a href="#l30.236"></a><span id="l30.236" class="difflineplus">+ * Adaptive Indexing</span>
<a href="#l30.237"></a><span id="l30.237" class="difflineplus">+ * - The indexer tries to stay out of the way of other running code in</span>
<a href="#l30.238"></a><span id="l30.238" class="difflineplus">+ *   Thunderbird (autosync) and other code on the system.  We try and target</span>
<a href="#l30.239"></a><span id="l30.239" class="difflineplus">+ *   some number of milliseconds of activity between intentional inactive</span>
<a href="#l30.240"></a><span id="l30.240" class="difflineplus">+ *   periods.  The number of milliseconds of activity varies based on whether we</span>
<a href="#l30.241"></a><span id="l30.241" class="difflineplus">+ *   believe the user to be actively using the computer or idle.  We use our</span>
<a href="#l30.242"></a><span id="l30.242" class="difflineplus">+ *   inactive periods as a way to measure system load; if we receive our</span>
<a href="#l30.243"></a><span id="l30.243" class="difflineplus">+ *   notification promptly at the end of our inactive period, we believe the</span>
<a href="#l30.244"></a><span id="l30.244" class="difflineplus">+ *   system is not heavily loaded.  If we do not get notified promptly, we</span>
<a href="#l30.245"></a><span id="l30.245" class="difflineplus">+ *   assume there is other stuff going on and back off.</span>
<a href="#l30.246"></a><span id="l30.246">  *</span>
<a href="#l30.247"></a><span id="l30.247">  */</span>
<a href="#l30.248"></a><span id="l30.248"> var GlodaIndexer = {</span>
<a href="#l30.249"></a><span id="l30.249">   /**</span>
<a href="#l30.250"></a><span id="l30.250">    * A partial attempt to generalize to support multiple databases.  Each</span>
<a href="#l30.251"></a><span id="l30.251">    *  database would have its own datastore would have its own indexer.  But</span>
<a href="#l30.252"></a><span id="l30.252">    *  we rather inter-mingle our use of this field with the singleton global</span>
<a href="#l30.253"></a><span id="l30.253">    *  GlodaDatastore.</span>
<a href="#l30.254"></a><span id="l30.254" class="difflineat">@@ -433,35 +284,52 @@ var GlodaIndexer = {</span>
<a href="#l30.255"></a><span id="l30.255">   /**</span>
<a href="#l30.256"></a><span id="l30.256">    * Minimum time delay between commits, in milliseconds.</span>
<a href="#l30.257"></a><span id="l30.257">    */</span>
<a href="#l30.258"></a><span id="l30.258">   _MINIMUM_COMMIT_TIME: 5000,</span>
<a href="#l30.259"></a><span id="l30.259">   /**</span>
<a href="#l30.260"></a><span id="l30.260">    * Maximum time delay between commits, in milliseconds.</span>
<a href="#l30.261"></a><span id="l30.261">    */</span>
<a href="#l30.262"></a><span id="l30.262">   _MAXIMUM_COMMIT_TIME: 20000,</span>
<a href="#l30.263"></a><span id="l30.263" class="difflineplus">+</span>
<a href="#l30.264"></a><span id="l30.264">   /**</span>
<a href="#l30.265"></a><span id="l30.265" class="difflineminus">-   * Last commit time.</span>
<a href="#l30.266"></a><span id="l30.266" class="difflineplus">+   * Unit testing hook to get us to emit additional logging that verges on</span>
<a href="#l30.267"></a><span id="l30.267" class="difflineplus">+   *  inane for general usage but is helpful in unit test output to get a lay</span>
<a href="#l30.268"></a><span id="l30.268" class="difflineplus">+   *  of the land and for paranoia reasons.</span>
<a href="#l30.269"></a><span id="l30.269" class="difflineplus">+   */</span>
<a href="#l30.270"></a><span id="l30.270" class="difflineplus">+  _unitTestSuperVerbose: false,</span>
<a href="#l30.271"></a><span id="l30.271" class="difflineplus">+  /**</span>
<a href="#l30.272"></a><span id="l30.272" class="difflineplus">+   * Unit test vector to get notified when a worker has a problem and it has</span>
<a href="#l30.273"></a><span id="l30.273" class="difflineplus">+   *  a recover helper associated.  This gets called with an argument</span>
<a href="#l30.274"></a><span id="l30.274" class="difflineplus">+   *  indicating whether the recovery helper indicates recovery was possible.</span>
<a href="#l30.275"></a><span id="l30.275" class="difflineplus">+   */</span>
<a href="#l30.276"></a><span id="l30.276" class="difflineplus">+  _unitTestHookRecover: null,</span>
<a href="#l30.277"></a><span id="l30.277" class="difflineplus">+  /**</span>
<a href="#l30.278"></a><span id="l30.278" class="difflineplus">+   * Unit test vector to get notified when a worker runs into an exceptional</span>
<a href="#l30.279"></a><span id="l30.279" class="difflineplus">+   *  situation (an exception propagates or gets explicitly killed) and needs</span>
<a href="#l30.280"></a><span id="l30.280" class="difflineplus">+   *  to be cleaned up.  This gets called with an argument indicating if there</span>
<a href="#l30.281"></a><span id="l30.281" class="difflineplus">+   *  was a helper that was used or if we just did the default cleanup thing.</span>
<a href="#l30.282"></a><span id="l30.282" class="difflineplus">+   */</span>
<a href="#l30.283"></a><span id="l30.283" class="difflineplus">+  _unitTestHookCleanup: null,</span>
<a href="#l30.284"></a><span id="l30.284" class="difflineplus">+</span>
<a href="#l30.285"></a><span id="l30.285" class="difflineplus">+  /**</span>
<a href="#l30.286"></a><span id="l30.286" class="difflineplus">+   * Last commit time.  Tracked to try and only commit at reasonable intervals.</span>
<a href="#l30.287"></a><span id="l30.287">    */</span>
<a href="#l30.288"></a><span id="l30.288">   _lastCommitTime: Date.now(),</span>
<a href="#l30.289"></a><span id="l30.289"> </span>
<a href="#l30.290"></a><span id="l30.290">   _inited: false,</span>
<a href="#l30.291"></a><span id="l30.291">   /**</span>
<a href="#l30.292"></a><span id="l30.292">    * Initialize the indexer.</span>
<a href="#l30.293"></a><span id="l30.293">    */</span>
<a href="#l30.294"></a><span id="l30.294">   _init: function gloda_index_init() {</span>
<a href="#l30.295"></a><span id="l30.295">     if (this._inited)</span>
<a href="#l30.296"></a><span id="l30.296">       return;</span>
<a href="#l30.297"></a><span id="l30.297"> </span>
<a href="#l30.298"></a><span id="l30.298">     this._inited = true;</span>
<a href="#l30.299"></a><span id="l30.299"> </span>
<a href="#l30.300"></a><span id="l30.300" class="difflineminus">-    // initialize our listeners' this pointers</span>
<a href="#l30.301"></a><span id="l30.301" class="difflineminus">-    this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l30.302"></a><span id="l30.302" class="difflineminus">-    this._msgFolderListener.indexer = this;</span>
<a href="#l30.303"></a><span id="l30.303" class="difflineminus">-</span>
<a href="#l30.304"></a><span id="l30.304">     this._callbackHandle.init();</span>
<a href="#l30.305"></a><span id="l30.305"> </span>
<a href="#l30.306"></a><span id="l30.306">     // create the timer that drives our intermittent indexing</span>
<a href="#l30.307"></a><span id="l30.307">     this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l30.308"></a><span id="l30.308">     // create the timer for larger offsets independent of indexing</span>
<a href="#l30.309"></a><span id="l30.309">     this._longTimer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l30.310"></a><span id="l30.310"> </span>
<a href="#l30.311"></a><span id="l30.311">     this._idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;]</span>
<a href="#l30.312"></a><span id="l30.312" class="difflineat">@@ -504,19 +372,16 @@ var GlodaIndexer = {</span>
<a href="#l30.313"></a><span id="l30.313">    *  be made.  This flag goes true once, and never returns to false.  Being</span>
<a href="#l30.314"></a><span id="l30.314">    *  in this state is a destructive thing from whence we cannot recover.</span>
<a href="#l30.315"></a><span id="l30.315">    */</span>
<a href="#l30.316"></a><span id="l30.316">   _indexerIsShutdown: false,</span>
<a href="#l30.317"></a><span id="l30.317"> </span>
<a href="#l30.318"></a><span id="l30.318">   /**</span>
<a href="#l30.319"></a><span id="l30.319">    * Shutdown the indexing process and datastore as quickly as possible in</span>
<a href="#l30.320"></a><span id="l30.320">    *  a synchronous fashion.</span>
<a href="#l30.321"></a><span id="l30.321" class="difflineminus">-   *</span>
<a href="#l30.322"></a><span id="l30.322" class="difflineminus">-   * @returns true on full and immediate shutdown, false if we need to pend on</span>
<a href="#l30.323"></a><span id="l30.323" class="difflineminus">-   *     something asynchronous.</span>
<a href="#l30.324"></a><span id="l30.324">    */</span>
<a href="#l30.325"></a><span id="l30.325">   _shutdown: function gloda_index_shutdown() {</span>
<a href="#l30.326"></a><span id="l30.326">     // no more timer events, please</span>
<a href="#l30.327"></a><span id="l30.327">     try {</span>
<a href="#l30.328"></a><span id="l30.328">       this._timer.cancel();</span>
<a href="#l30.329"></a><span id="l30.329">     } catch (ex) {}</span>
<a href="#l30.330"></a><span id="l30.330">     this._timer = null;</span>
<a href="#l30.331"></a><span id="l30.331">     try {</span>
<a href="#l30.332"></a><span id="l30.332" class="difflineat">@@ -529,38 +394,91 @@ var GlodaIndexer = {</span>
<a href="#l30.333"></a><span id="l30.333"> </span>
<a href="#l30.334"></a><span id="l30.334">     // Remove listeners to avoid reference cycles on the off chance one of them</span>
<a href="#l30.335"></a><span id="l30.335">     // holds a reference to the indexer object.</span>
<a href="#l30.336"></a><span id="l30.336">     this._indexListeners = [];</span>
<a href="#l30.337"></a><span id="l30.337"> </span>
<a href="#l30.338"></a><span id="l30.338">     this._indexerIsShutdown = true;</span>
<a href="#l30.339"></a><span id="l30.339"> </span>
<a href="#l30.340"></a><span id="l30.340">     if (!this.enabled)</span>
<a href="#l30.341"></a><span id="l30.341" class="difflineminus">-      return true;</span>
<a href="#l30.342"></a><span id="l30.342" class="difflineplus">+      return;</span>
<a href="#l30.343"></a><span id="l30.343"> </span>
<a href="#l30.344"></a><span id="l30.344">     this._log.info(&quot;Shutting Down&quot;);</span>
<a href="#l30.345"></a><span id="l30.345"> </span>
<a href="#l30.346"></a><span id="l30.346" class="difflineplus">+    // don't let anything try and convince us to start indexing again</span>
<a href="#l30.347"></a><span id="l30.347">     this.suppressIndexing = true;</span>
<a href="#l30.348"></a><span id="l30.348" class="difflineminus">-    this._indexerLeaveFolder(); // nop if we aren't &quot;in&quot; a folder</span>
<a href="#l30.349"></a><span id="l30.349" class="difflineplus">+</span>
<a href="#l30.350"></a><span id="l30.350" class="difflineplus">+    // If there is an active job and it has a cleanup handler, run it.</span>
<a href="#l30.351"></a><span id="l30.351" class="difflineplus">+    if (this._curIndexingJob) {</span>
<a href="#l30.352"></a><span id="l30.352" class="difflineplus">+      let workerDef = this._curIndexingJob._workerDef;</span>
<a href="#l30.353"></a><span id="l30.353" class="difflineplus">+      if (workerDef.cleanup)</span>
<a href="#l30.354"></a><span id="l30.354" class="difflineplus">+        workerDef.cleanup.call(workerDef.indexer, this._curIndexingJob);</span>
<a href="#l30.355"></a><span id="l30.355" class="difflineplus">+    }</span>
<a href="#l30.356"></a><span id="l30.356" class="difflineplus">+    // Definitely clean out the async call stack and any associated data</span>
<a href="#l30.357"></a><span id="l30.357">     this._callbackHandle.cleanup();</span>
<a href="#l30.358"></a><span id="l30.358">     this._workBatchData = undefined;</span>
<a href="#l30.359"></a><span id="l30.359" class="difflineplus">+</span>
<a href="#l30.360"></a><span id="l30.360" class="difflineplus">+    // disable ourselves and all of the specific indexers</span>
<a href="#l30.361"></a><span id="l30.361">     this.enabled = false;</span>
<a href="#l30.362"></a><span id="l30.362"> </span>
<a href="#l30.363"></a><span id="l30.363">     GlodaDatastore.shutdown();</span>
<a href="#l30.364"></a><span id="l30.364">   },</span>
<a href="#l30.365"></a><span id="l30.365"> </span>
<a href="#l30.366"></a><span id="l30.366" class="difflineminus">-  _otherIndexers: [],</span>
<a href="#l30.367"></a><span id="l30.367" class="difflineplus">+  /**</span>
<a href="#l30.368"></a><span id="l30.368" class="difflineplus">+   * The list of indexers registered with us.  If you are a core gloda indexer</span>
<a href="#l30.369"></a><span id="l30.369" class="difflineplus">+   *  (you ship with gloda), then you can import this file directly and should</span>
<a href="#l30.370"></a><span id="l30.370" class="difflineplus">+   *  make sure your indexer is imported in 'everybody.js' in the right order.</span>
<a href="#l30.371"></a><span id="l30.371" class="difflineplus">+   *  If you are not core gloda, then you should import 'public.js' and only</span>
<a href="#l30.372"></a><span id="l30.372" class="difflineplus">+   *  then should you import 'indexer.js' to get at GlodaIndexer.</span>
<a href="#l30.373"></a><span id="l30.373" class="difflineplus">+   */</span>
<a href="#l30.374"></a><span id="l30.374" class="difflineplus">+  _indexers: [],</span>
<a href="#l30.375"></a><span id="l30.375" class="difflineplus">+  /**</span>
<a href="#l30.376"></a><span id="l30.376" class="difflineplus">+   * Register an indexer with the Gloda indexing mechanism.</span>
<a href="#l30.377"></a><span id="l30.377" class="difflineplus">+   *</span>
<a href="#l30.378"></a><span id="l30.378" class="difflineplus">+   * @param aIndexer.name The name of your indexer.</span>
<a href="#l30.379"></a><span id="l30.379" class="difflineplus">+   * @param aIndexer.enable Your enable function.  This will be called during</span>
<a href="#l30.380"></a><span id="l30.380" class="difflineplus">+   *     the call to registerIndexer if Gloda indexing is already enabled.  If</span>
<a href="#l30.381"></a><span id="l30.381" class="difflineplus">+   *     indexing is not yet enabled, you will be called</span>
<a href="#l30.382"></a><span id="l30.382" class="difflineplus">+   * @param aIndexer.disable Your disable function.  This will be called when</span>
<a href="#l30.383"></a><span id="l30.383" class="difflineplus">+   *     indexing is disabled or we are shutting down.  This will only be called</span>
<a href="#l30.384"></a><span id="l30.384" class="difflineplus">+   *     if enable has already been called.</span>
<a href="#l30.385"></a><span id="l30.385" class="difflineplus">+   * @param aIndexer.workers A list of tuples of the form [worker type code,</span>
<a href="#l30.386"></a><span id="l30.386" class="difflineplus">+   *     worker generator function, optional scheduling trigger function].  The</span>
<a href="#l30.387"></a><span id="l30.387" class="difflineplus">+   *     type code is the string used to uniquely identify the job type.  If you</span>
<a href="#l30.388"></a><span id="l30.388" class="difflineplus">+   *     are not core gloda, your job type must start with your extension's name</span>
<a href="#l30.389"></a><span id="l30.389" class="difflineplus">+   *     and a colon; you can collow that with anything you want.  The worker</span>
<a href="#l30.390"></a><span id="l30.390" class="difflineplus">+   *     generator is not easily explained in here.  The trigger function is</span>
<a href="#l30.391"></a><span id="l30.391" class="difflineplus">+   *     invoked immediately prior to calling the generator to create it.  The</span>
<a href="#l30.392"></a><span id="l30.392" class="difflineplus">+   *     trigger function takes the job as an argument and should perform any</span>
<a href="#l30.393"></a><span id="l30.393" class="difflineplus">+   *     finalization required on the job.  Most workers should not need to use</span>
<a href="#l30.394"></a><span id="l30.394" class="difflineplus">+   *     the trigger function.</span>
<a href="#l30.395"></a><span id="l30.395" class="difflineplus">+   * @param aIndexer.initialSweep We call this to tell each indexer when it is</span>
<a href="#l30.396"></a><span id="l30.396" class="difflineplus">+   *     its turn to run its indexing sweep.  The idea of the indexing sweep is</span>
<a href="#l30.397"></a><span id="l30.397" class="difflineplus">+   *     that this is when you traverse things eligible for indexing to make</span>
<a href="#l30.398"></a><span id="l30.398" class="difflineplus">+   *     sure they are indexed.  Right now we just call everyone at the same</span>
<a href="#l30.399"></a><span id="l30.399" class="difflineplus">+   *     time and hope that their jobs don't fight too much.</span>
<a href="#l30.400"></a><span id="l30.400" class="difflineplus">+   */</span>
<a href="#l30.401"></a><span id="l30.401">   registerIndexer: function gloda_index_registerIndexer(aIndexer) {</span>
<a href="#l30.402"></a><span id="l30.402">     this._log.info(&quot;Registering indexer: &quot; + aIndexer.name);</span>
<a href="#l30.403"></a><span id="l30.403" class="difflineminus">-    this._otherIndexers.push(aIndexer);</span>
<a href="#l30.404"></a><span id="l30.404" class="difflineplus">+    this._indexers.push(aIndexer);</span>
<a href="#l30.405"></a><span id="l30.405"> </span>
<a href="#l30.406"></a><span id="l30.406">     try {</span>
<a href="#l30.407"></a><span id="l30.407">       for each (let [iWorker, workerInfo] in Iterator(aIndexer.workers)) {</span>
<a href="#l30.408"></a><span id="l30.408" class="difflineminus">-        let [workerCode, workerFunc] = workerInfo;</span>
<a href="#l30.409"></a><span id="l30.409" class="difflineminus">-        this._otherIndexerWorkers[workerCode] = [aIndexer, workerFunc];</span>
<a href="#l30.410"></a><span id="l30.410" class="difflineplus">+        let workerCode = workerInfo[0];</span>
<a href="#l30.411"></a><span id="l30.411" class="difflineplus">+        let workerDef = workerInfo[1];</span>
<a href="#l30.412"></a><span id="l30.412" class="difflineplus">+        workerDef.indexer = aIndexer;</span>
<a href="#l30.413"></a><span id="l30.413" class="difflineplus">+        this._indexerWorkerDefs[workerCode] = workerDef;</span>
<a href="#l30.414"></a><span id="l30.414" class="difflineplus">+        if (!(&quot;recover&quot; in workerDef))</span>
<a href="#l30.415"></a><span id="l30.415" class="difflineplus">+          workerDef.recover = null;</span>
<a href="#l30.416"></a><span id="l30.416" class="difflineplus">+        if (!(&quot;cleanup&quot; in workerDef))</span>
<a href="#l30.417"></a><span id="l30.417" class="difflineplus">+          workerDef.cleanup = null;</span>
<a href="#l30.418"></a><span id="l30.418" class="difflineplus">+        if (!(&quot;onSchedule&quot; in workerDef))</span>
<a href="#l30.419"></a><span id="l30.419" class="difflineplus">+          workerDef.onSchedule = null;</span>
<a href="#l30.420"></a><span id="l30.420" class="difflineplus">+        if (!(&quot;jobCanceled&quot; in workerDef))</span>
<a href="#l30.421"></a><span id="l30.421" class="difflineplus">+          workerDef.jobCanceled = null;</span>
<a href="#l30.422"></a><span id="l30.422">       }</span>
<a href="#l30.423"></a><span id="l30.423">     }</span>
<a href="#l30.424"></a><span id="l30.424">     catch (ex) {</span>
<a href="#l30.425"></a><span id="l30.425">       this._log.warn(&quot;Helper indexer threw exception on worker enum.&quot;);</span>
<a href="#l30.426"></a><span id="l30.426">     }</span>
<a href="#l30.427"></a><span id="l30.427"> </span>
<a href="#l30.428"></a><span id="l30.428">     if (this._enabled) {</span>
<a href="#l30.429"></a><span id="l30.429">       try {</span>
<a href="#l30.430"></a><span id="l30.430" class="difflineat">@@ -573,47 +491,28 @@ var GlodaIndexer = {</span>
<a href="#l30.431"></a><span id="l30.431"> </span>
<a href="#l30.432"></a><span id="l30.432">   /**</span>
<a href="#l30.433"></a><span id="l30.433">    * Are we enabled, read: are we processing change events?</span>
<a href="#l30.434"></a><span id="l30.434">    */</span>
<a href="#l30.435"></a><span id="l30.435">   _enabled: false,</span>
<a href="#l30.436"></a><span id="l30.436">   get enabled() { return this._enabled; },</span>
<a href="#l30.437"></a><span id="l30.437">   set enabled(aEnable) {</span>
<a href="#l30.438"></a><span id="l30.438">     if (!this._enabled &amp;&amp; aEnable) {</span>
<a href="#l30.439"></a><span id="l30.439" class="difflineminus">-      // register for:</span>
<a href="#l30.440"></a><span id="l30.440" class="difflineminus">-      // - folder loaded events, so we know when getDatabaseWithReparse has finished</span>
<a href="#l30.441"></a><span id="l30.441" class="difflineminus">-      //   updating the index/what not (if it was't immediately available)</span>
<a href="#l30.442"></a><span id="l30.442" class="difflineminus">-      // - property changes (so we know when a message's read/starred state have</span>
<a href="#l30.443"></a><span id="l30.443" class="difflineminus">-      //   changed.)</span>
<a href="#l30.444"></a><span id="l30.444" class="difflineminus">-      let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l30.445"></a><span id="l30.445" class="difflineminus">-                          getService(Ci.nsIMsgMailSession);</span>
<a href="#l30.446"></a><span id="l30.446" class="difflineminus">-      this._folderListener._init(this);</span>
<a href="#l30.447"></a><span id="l30.447" class="difflineminus">-      mailSession.AddFolderListener(this._folderListener,</span>
<a href="#l30.448"></a><span id="l30.448" class="difflineminus">-                                    Ci.nsIFolderListener.propertyFlagChanged |</span>
<a href="#l30.449"></a><span id="l30.449" class="difflineminus">-                                    Ci.nsIFolderListener.event);</span>
<a href="#l30.450"></a><span id="l30.450" class="difflineminus">-</span>
<a href="#l30.451"></a><span id="l30.451">       // register for shutdown, offline notifications</span>
<a href="#l30.452"></a><span id="l30.452">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l30.453"></a><span id="l30.453">                               getService(Ci.nsIObserverService);</span>
<a href="#l30.454"></a><span id="l30.454">       observerService.addObserver(this, &quot;network:offline-status-changed&quot;, false);</span>
<a href="#l30.455"></a><span id="l30.455">       observerService.addObserver(this, &quot;quit-application&quot;, false);</span>
<a href="#l30.456"></a><span id="l30.456"> </span>
<a href="#l30.457"></a><span id="l30.457">       // register for idle notification</span>
<a href="#l30.458"></a><span id="l30.458">       this._idleService.addIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l30.459"></a><span id="l30.459"> </span>
<a href="#l30.460"></a><span id="l30.460" class="difflineminus">-      let notificationService =</span>
<a href="#l30.461"></a><span id="l30.461" class="difflineminus">-        Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l30.462"></a><span id="l30.462" class="difflineminus">-        getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l30.463"></a><span id="l30.463" class="difflineminus">-      notificationService.addListener(this._msgFolderListener,</span>
<a href="#l30.464"></a><span id="l30.464" class="difflineminus">-                                      Ci.nsIMsgFolderNotificationService.all &amp;</span>
<a href="#l30.465"></a><span id="l30.465" class="difflineminus">-                                      ~Ci.nsIMsgFolderNotificationService.folderAdded);</span>
<a href="#l30.466"></a><span id="l30.466" class="difflineminus">-</span>
<a href="#l30.467"></a><span id="l30.467">       this._enabled = true;</span>
<a href="#l30.468"></a><span id="l30.468"> </span>
<a href="#l30.469"></a><span id="l30.469" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l30.470"></a><span id="l30.470" class="difflineplus">+      for each (let [iIndexer, indexer] in Iterator(this._indexers)) {</span>
<a href="#l30.471"></a><span id="l30.471">         try {</span>
<a href="#l30.472"></a><span id="l30.472">           indexer.enable();</span>
<a href="#l30.473"></a><span id="l30.473">         } catch (ex) {</span>
<a href="#l30.474"></a><span id="l30.474">           this._log.warn(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l30.475"></a><span id="l30.475">         }</span>
<a href="#l30.476"></a><span id="l30.476">       }</span>
<a href="#l30.477"></a><span id="l30.477"> </span>
<a href="#l30.478"></a><span id="l30.478">       // if we have an accumulated desire to index things, kick it off again.</span>
<a href="#l30.479"></a><span id="l30.479" class="difflineat">@@ -623,47 +522,36 @@ var GlodaIndexer = {</span>
<a href="#l30.480"></a><span id="l30.480">       }</span>
<a href="#l30.481"></a><span id="l30.481"> </span>
<a href="#l30.482"></a><span id="l30.482">       // if we have not done an initial sweep, schedule scheduling one.</span>
<a href="#l30.483"></a><span id="l30.483">       if (!this._initialSweepPerformed)</span>
<a href="#l30.484"></a><span id="l30.484">         this._longTimer.initWithCallback(this._scheduleInitialSweep,</span>
<a href="#l30.485"></a><span id="l30.485">           this._INITIAL_SWEEP_DELAY, Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l30.486"></a><span id="l30.486">     }</span>
<a href="#l30.487"></a><span id="l30.487">     else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l30.488"></a><span id="l30.488" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l30.489"></a><span id="l30.489" class="difflineplus">+      for each (let [iIndexer, indexer] in Iterator(this._indexers)) {</span>
<a href="#l30.490"></a><span id="l30.490">         try {</span>
<a href="#l30.491"></a><span id="l30.491">           indexer.disable();</span>
<a href="#l30.492"></a><span id="l30.492">         } catch (ex) {</span>
<a href="#l30.493"></a><span id="l30.493">           this._log.warn(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l30.494"></a><span id="l30.494">         }</span>
<a href="#l30.495"></a><span id="l30.495">       }</span>
<a href="#l30.496"></a><span id="l30.496"> </span>
<a href="#l30.497"></a><span id="l30.497">       // remove observer; no more events to observe!</span>
<a href="#l30.498"></a><span id="l30.498">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l30.499"></a><span id="l30.499">                               getService(Ci.nsIObserverService);</span>
<a href="#l30.500"></a><span id="l30.500">       observerService.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l30.501"></a><span id="l30.501">       observerService.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l30.502"></a><span id="l30.502"> </span>
<a href="#l30.503"></a><span id="l30.503">       // remove idle</span>
<a href="#l30.504"></a><span id="l30.504">       this._idleService.removeIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l30.505"></a><span id="l30.505"> </span>
<a href="#l30.506"></a><span id="l30.506" class="difflineminus">-      // remove FolderLoaded notification listener</span>
<a href="#l30.507"></a><span id="l30.507" class="difflineminus">-      let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l30.508"></a><span id="l30.508" class="difflineminus">-                          getService(Ci.nsIMsgMailSession);</span>
<a href="#l30.509"></a><span id="l30.509" class="difflineminus">-      mailSession.RemoveFolderListener(this._folderListener);</span>
<a href="#l30.510"></a><span id="l30.510" class="difflineminus">-</span>
<a href="#l30.511"></a><span id="l30.511" class="difflineminus">-      let notificationService =</span>
<a href="#l30.512"></a><span id="l30.512" class="difflineminus">-        Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l30.513"></a><span id="l30.513" class="difflineminus">-        getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l30.514"></a><span id="l30.514" class="difflineminus">-      notificationService.removeListener(this._msgFolderListener);</span>
<a href="#l30.515"></a><span id="l30.515" class="difflineminus">-</span>
<a href="#l30.516"></a><span id="l30.516">       this._enabled = false;</span>
<a href="#l30.517"></a><span id="l30.517">     }</span>
<a href="#l30.518"></a><span id="l30.518"> </span>
<a href="#l30.519"></a><span id="l30.519" class="difflineminus">-    this._log.info(&quot;Event-Driven Indexing is now &quot; + this._enabled);</span>
<a href="#l30.520"></a><span id="l30.520">   },</span>
<a href="#l30.521"></a><span id="l30.521"> </span>
<a href="#l30.522"></a><span id="l30.522">   /** Track whether indexing is desired (we have jobs to prosecute). */</span>
<a href="#l30.523"></a><span id="l30.523">   _indexingDesired: false,</span>
<a href="#l30.524"></a><span id="l30.524">   /**</span>
<a href="#l30.525"></a><span id="l30.525">    * Track whether we have an actively pending callback or timer event.  We do</span>
<a href="#l30.526"></a><span id="l30.526">    *  this so we don't experience a transient suppression and accidentally</span>
<a href="#l30.527"></a><span id="l30.527">    *  get multiple event-chains driving indexing at the same time (which the</span>
<a href="#l30.528"></a><span id="l30.528" class="difflineat">@@ -688,17 +576,17 @@ var GlodaIndexer = {</span>
<a href="#l30.529"></a><span id="l30.529">    *  no longer suppressed.</span>
<a href="#l30.530"></a><span id="l30.530">    */</span>
<a href="#l30.531"></a><span id="l30.531">   set indexing(aShouldIndex) {</span>
<a href="#l30.532"></a><span id="l30.532">     if (!this._indexingDesired &amp;&amp; aShouldIndex) {</span>
<a href="#l30.533"></a><span id="l30.533">       this._indexingDesired = true;</span>
<a href="#l30.534"></a><span id="l30.534">       if (this.enabled &amp;&amp; !this._indexingActive &amp;&amp; !this._suppressIndexing) {</span>
<a href="#l30.535"></a><span id="l30.535">         this._log.info(&quot;+++ Indexing Queue Processing Commencing&quot;);</span>
<a href="#l30.536"></a><span id="l30.536">         this._indexingActive = true;</span>
<a href="#l30.537"></a><span id="l30.537" class="difflineminus">-        this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l30.538"></a><span id="l30.538" class="difflineplus">+        this._timer.initWithCallback(this._timerCallbackDriver,</span>
<a href="#l30.539"></a><span id="l30.539">                                      this._INDEX_KICKOFF_DELAY,</span>
<a href="#l30.540"></a><span id="l30.540">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l30.541"></a><span id="l30.541">       }</span>
<a href="#l30.542"></a><span id="l30.542">     }</span>
<a href="#l30.543"></a><span id="l30.543">   },</span>
<a href="#l30.544"></a><span id="l30.544"> </span>
<a href="#l30.545"></a><span id="l30.545">   _suppressIndexing: false,</span>
<a href="#l30.546"></a><span id="l30.546">   /**</span>
<a href="#l30.547"></a><span id="l30.547" class="difflineat">@@ -712,473 +600,177 @@ var GlodaIndexer = {</span>
<a href="#l30.548"></a><span id="l30.548">     this._suppressIndexing = aShouldSuppress;</span>
<a href="#l30.549"></a><span id="l30.549"> </span>
<a href="#l30.550"></a><span id="l30.550">     // re-start processing if we are no longer suppressing, there is work yet</span>
<a href="#l30.551"></a><span id="l30.551">     //  to do, and the indexing process had actually stopped.</span>
<a href="#l30.552"></a><span id="l30.552">     if (!this._suppressIndexing &amp;&amp; this._indexingDesired &amp;&amp;</span>
<a href="#l30.553"></a><span id="l30.553">         !this._indexingActive) {</span>
<a href="#l30.554"></a><span id="l30.554">         this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l30.555"></a><span id="l30.555">         this._indexingActive = true;</span>
<a href="#l30.556"></a><span id="l30.556" class="difflineminus">-        this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l30.557"></a><span id="l30.557" class="difflineplus">+        this._timer.initWithCallback(this._timerCallbackDriver,</span>
<a href="#l30.558"></a><span id="l30.558">                                      this._INDEX_KICKOFF_DELAY,</span>
<a href="#l30.559"></a><span id="l30.559">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l30.560"></a><span id="l30.560">     }</span>
<a href="#l30.561"></a><span id="l30.561">   },</span>
<a href="#l30.562"></a><span id="l30.562"> </span>
<a href="#l30.563"></a><span id="l30.563">   /**</span>
<a href="#l30.564"></a><span id="l30.564" class="difflineplus">+   * Track whether an initial sweep has been performed.  This mainly exists so</span>
<a href="#l30.565"></a><span id="l30.565" class="difflineplus">+   *  that unit testing can stop us from performing an initial sweep.</span>
<a href="#l30.566"></a><span id="l30.566" class="difflineplus">+   */</span>
<a href="#l30.567"></a><span id="l30.567" class="difflineplus">+  _initialSweepPerformed: false,</span>
<a href="#l30.568"></a><span id="l30.568" class="difflineplus">+  /**</span>
<a href="#l30.569"></a><span id="l30.569">    * Our timer-driven callback to schedule our first initial indexing sweep.</span>
<a href="#l30.570"></a><span id="l30.570">    *  Because it is invoked by an nsITimer it operates without the benefit of</span>
<a href="#l30.571"></a><span id="l30.571">    *  a 'this' context and must use GlodaIndexer instead of this.</span>
<a href="#l30.572"></a><span id="l30.572">    * Since an initial sweep could have been performed before we get invoked,</span>
<a href="#l30.573"></a><span id="l30.573">    *  we need to check whether an initial sweep is still desired before trying</span>
<a href="#l30.574"></a><span id="l30.574">    *  to schedule one.  We don't need to worry about whether one is active</span>
<a href="#l30.575"></a><span id="l30.575">    *  because the indexingSweepNeeded takes care of that.</span>
<a href="#l30.576"></a><span id="l30.576">    */</span>
<a href="#l30.577"></a><span id="l30.577">   _scheduleInitialSweep: function gloda_index_scheduleInitialSweep() {</span>
<a href="#l30.578"></a><span id="l30.578" class="difflineminus">-    if (!GlodaIndexer._initialSweepPerformed)</span>
<a href="#l30.579"></a><span id="l30.579" class="difflineminus">-      GlodaIndexer.indexingSweepNeeded = true;</span>
<a href="#l30.580"></a><span id="l30.580" class="difflineminus">-  },</span>
<a href="#l30.581"></a><span id="l30.581" class="difflineminus">-</span>
<a href="#l30.582"></a><span id="l30.582" class="difflineminus">-  _initialSweepPerformed: false,</span>
<a href="#l30.583"></a><span id="l30.583" class="difflineminus">-  _indexingSweepActive: false,</span>
<a href="#l30.584"></a><span id="l30.584" class="difflineminus">-  /**</span>
<a href="#l30.585"></a><span id="l30.585" class="difflineminus">-   * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l30.586"></a><span id="l30.586" class="difflineminus">-   *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l30.587"></a><span id="l30.587" class="difflineminus">-   *  that we either can't process as an event or that we normally handle</span>
<a href="#l30.588"></a><span id="l30.588" class="difflineminus">-   *  during the sweep pass anyways.</span>
<a href="#l30.589"></a><span id="l30.589" class="difflineminus">-   */</span>
<a href="#l30.590"></a><span id="l30.590" class="difflineminus">-  set indexingSweepNeeded(aNeeded) {</span>
<a href="#l30.591"></a><span id="l30.591" class="difflineminus">-    if (!this._indexingSweepActive &amp;&amp; aNeeded) {</span>
<a href="#l30.592"></a><span id="l30.592" class="difflineminus">-      let job = new IndexingJob(&quot;sweep&quot;, 0, null);</span>
<a href="#l30.593"></a><span id="l30.593" class="difflineminus">-      job.mappedFolders = false;</span>
<a href="#l30.594"></a><span id="l30.594" class="difflineminus">-      this._indexQueue.push(job);</span>
<a href="#l30.595"></a><span id="l30.595" class="difflineminus">-      this._indexingJobGoal++;</span>
<a href="#l30.596"></a><span id="l30.596" class="difflineminus">-      this._indexingSweepActive = true;</span>
<a href="#l30.597"></a><span id="l30.597" class="difflineminus">-      this.indexing = true;</span>
<a href="#l30.598"></a><span id="l30.598" class="difflineplus">+    if (GlodaIndexer._initialSweepPerformed)</span>
<a href="#l30.599"></a><span id="l30.599" class="difflineplus">+      return;</span>
<a href="#l30.600"></a><span id="l30.600" class="difflineplus">+    GlodaIndexer._initialSweepPerformed = true;</span>
<a href="#l30.601"></a><span id="l30.601" class="difflineplus">+    for each (let [, indexer] in Iterator(GlodaIndexer._indexers)) {</span>
<a href="#l30.602"></a><span id="l30.602" class="difflineplus">+      indexer.initialSweep();</span>
<a href="#l30.603"></a><span id="l30.603">     }</span>
<a href="#l30.604"></a><span id="l30.604">   },</span>
<a href="#l30.605"></a><span id="l30.605"> </span>
<a href="#l30.606"></a><span id="l30.606" class="difflineminus">-</span>
<a href="#l30.607"></a><span id="l30.607" class="difflineminus">-  /**</span>
<a href="#l30.608"></a><span id="l30.608" class="difflineminus">-   * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l30.609"></a><span id="l30.609" class="difflineminus">-   *  are gloda message rows flagged for deletion.  If this value is a boolean,</span>
<a href="#l30.610"></a><span id="l30.610" class="difflineminus">-   *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l30.611"></a><span id="l30.611" class="difflineminus">-   *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l30.612"></a><span id="l30.612" class="difflineminus">-   *  the database.</span>
<a href="#l30.613"></a><span id="l30.613" class="difflineminus">-   */</span>
<a href="#l30.614"></a><span id="l30.614" class="difflineminus">-  pendingDeletions: null,</span>
<a href="#l30.615"></a><span id="l30.615" class="difflineminus">-</span>
<a href="#l30.616"></a><span id="l30.616" class="difflineminus">-  /**</span>
<a href="#l30.617"></a><span id="l30.617" class="difflineminus">-   * The message (or folder state) is believed up-to-date.</span>
<a href="#l30.618"></a><span id="l30.618" class="difflineminus">-   */</span>
<a href="#l30.619"></a><span id="l30.619" class="difflineminus">-  kMessageClean: 0,</span>
<a href="#l30.620"></a><span id="l30.620" class="difflineminus">-  /**</span>
<a href="#l30.621"></a><span id="l30.621" class="difflineminus">-   * The message (or folder) is known to not be up-to-date. In the case of</span>
<a href="#l30.622"></a><span id="l30.622" class="difflineminus">-   *  folders, this means that some of the messages in the folder may be dirty.</span>
<a href="#l30.623"></a><span id="l30.623" class="difflineminus">-   *  However, because of the way our indexing works, it is possible there may</span>
<a href="#l30.624"></a><span id="l30.624" class="difflineminus">-   *  actually be no dirty messages in a folder.  (We attempt to process</span>
<a href="#l30.625"></a><span id="l30.625" class="difflineminus">-   *  messages in an event-driven fashion for a finite number of messages, but</span>
<a href="#l30.626"></a><span id="l30.626" class="difflineminus">-   *  because we can quit without completing processing of the queue, we need to</span>
<a href="#l30.627"></a><span id="l30.627" class="difflineminus">-   *  mark the folder dirty, just-in-case.)  (We could do some extra leg-work</span>
<a href="#l30.628"></a><span id="l30.628" class="difflineminus">-   *  and do a better job of marking the folder clean again.)</span>
<a href="#l30.629"></a><span id="l30.629" class="difflineminus">-   */</span>
<a href="#l30.630"></a><span id="l30.630" class="difflineminus">-  kMessageDirty: 1,</span>
<a href="#l30.631"></a><span id="l30.631" class="difflineminus">-  /**</span>
<a href="#l30.632"></a><span id="l30.632" class="difflineminus">-   * We have not indexed the folder at all, but messages in the folder think</span>
<a href="#l30.633"></a><span id="l30.633" class="difflineminus">-   *  they are indexed.  Once we mark all the messages in the folder as being</span>
<a href="#l30.634"></a><span id="l30.634" class="difflineminus">-   *  dirty so that they don't confuse us, we downgrade the folder's dirty</span>
<a href="#l30.635"></a><span id="l30.635" class="difflineminus">-   *  status to just kMessageDirty.</span>
<a href="#l30.636"></a><span id="l30.636" class="difflineminus">-   */</span>
<a href="#l30.637"></a><span id="l30.637" class="difflineminus">-  kMessageFilthy: 2,</span>
<a href="#l30.638"></a><span id="l30.638" class="difflineminus">-</span>
<a href="#l30.639"></a><span id="l30.639">   kWorkSync: Gloda.kWorkSync,</span>
<a href="#l30.640"></a><span id="l30.640">   kWorkAsync: Gloda.kWorkAsync,</span>
<a href="#l30.641"></a><span id="l30.641">   kWorkDone: Gloda.kWorkDone,</span>
<a href="#l30.642"></a><span id="l30.642">   kWorkPause: Gloda.kWorkPause,</span>
<a href="#l30.643"></a><span id="l30.643">   kWorkDoneWithResult: Gloda.kWorkDoneWithResult,</span>
<a href="#l30.644"></a><span id="l30.644"> </span>
<a href="#l30.645"></a><span id="l30.645">   /**</span>
<a href="#l30.646"></a><span id="l30.646" class="difflineminus">-   * Our current job number, out of _indexingJobGoal.  Although our jobs comes</span>
<a href="#l30.647"></a><span id="l30.647" class="difflineminus">-   *  from _indexQueue, this is not an offset into that list because we forget</span>
<a href="#l30.648"></a><span id="l30.648" class="difflineminus">-   *  jobs once we complete them.  As such, this value is strictly for progress</span>
<a href="#l30.649"></a><span id="l30.649" class="difflineminus">-   *  tracking.</span>
<a href="#l30.650"></a><span id="l30.650" class="difflineplus">+   * Our current job number.  Meaningless value that increments with every job</span>
<a href="#l30.651"></a><span id="l30.651" class="difflineplus">+   *  we process that resets to 0 when we run out of jobs.  Currently used by</span>
<a href="#l30.652"></a><span id="l30.652" class="difflineplus">+   *  the activity manager's gloda listener to tell when we have changed jobs.</span>
<a href="#l30.653"></a><span id="l30.653" class="difflineplus">+   * We really need a better listener mechanism.</span>
<a href="#l30.654"></a><span id="l30.654">    */</span>
<a href="#l30.655"></a><span id="l30.655">   _indexingJobCount: 0,</span>
<a href="#l30.656"></a><span id="l30.656" class="difflineminus">-  /**</span>
<a href="#l30.657"></a><span id="l30.657" class="difflineminus">-   * Total number of jobs to process in this current indexing session; may</span>
<a href="#l30.658"></a><span id="l30.658" class="difflineminus">-   *  increase as new jobs are added to the _indexQueue.  This value won't</span>
<a href="#l30.659"></a><span id="l30.659" class="difflineminus">-   *  decrease until the indexing session is completed (and we become idle),</span>
<a href="#l30.660"></a><span id="l30.660" class="difflineminus">-   *  and then it will go to zero.</span>
<a href="#l30.661"></a><span id="l30.661" class="difflineminus">-   */</span>
<a href="#l30.662"></a><span id="l30.662" class="difflineminus">-  _indexingJobGoal: 0,</span>
<a href="#l30.663"></a><span id="l30.663"> </span>
<a href="#l30.664"></a><span id="l30.664">   /**</span>
<a href="#l30.665"></a><span id="l30.665">    * A list of IndexingJob instances to process.</span>
<a href="#l30.666"></a><span id="l30.666" class="difflineminus">-   * - ['account', account object]</span>
<a href="#l30.667"></a><span id="l30.667" class="difflineminus">-   * - ['folder', folder URI]</span>
<a href="#l30.668"></a><span id="l30.668" class="difflineminus">-   * - ['message', delta type, message header, folder ID, message key,</span>
<a href="#l30.669"></a><span id="l30.669" class="difflineminus">-   *      message ID]</span>
<a href="#l30.670"></a><span id="l30.670" class="difflineminus">-   *   (we use folder ID instead of URI so that renames can't trick us)</span>
<a href="#l30.671"></a><span id="l30.671">    */</span>
<a href="#l30.672"></a><span id="l30.672">   _indexQueue: [],</span>
<a href="#l30.673"></a><span id="l30.673"> </span>
<a href="#l30.674"></a><span id="l30.674">   /**</span>
<a href="#l30.675"></a><span id="l30.675">    * The current indexing job.</span>
<a href="#l30.676"></a><span id="l30.676">    */</span>
<a href="#l30.677"></a><span id="l30.677">   _curIndexingJob: null,</span>
<a href="#l30.678"></a><span id="l30.678"> </span>
<a href="#l30.679"></a><span id="l30.679">   /**</span>
<a href="#l30.680"></a><span id="l30.680" class="difflineminus">-   * A message addition job yet to be (completely) processed.  Since message</span>
<a href="#l30.681"></a><span id="l30.681" class="difflineminus">-   *  addition events come to us one-by-one, in order to aggregate them into a</span>
<a href="#l30.682"></a><span id="l30.682" class="difflineminus">-   *  job, we need something like this.  It's up to the indexing loop to</span>
<a href="#l30.683"></a><span id="l30.683" class="difflineminus">-   *  decide when to null this out; it can either do it when it first starts</span>
<a href="#l30.684"></a><span id="l30.684" class="difflineminus">-   *  processing it, or when it has processed the last thing.  It's really a</span>
<a href="#l30.685"></a><span id="l30.685" class="difflineminus">-   *  question of whether we want retrograde motion in the folder progress bar</span>
<a href="#l30.686"></a><span id="l30.686" class="difflineminus">-   *  or the message progress bar.</span>
<a href="#l30.687"></a><span id="l30.687" class="difflineminus">-   */</span>
<a href="#l30.688"></a><span id="l30.688" class="difflineminus">-  _pendingAddJob: null,</span>
<a href="#l30.689"></a><span id="l30.689" class="difflineminus">-</span>
<a href="#l30.690"></a><span id="l30.690" class="difflineminus">-  /**</span>
<a href="#l30.691"></a><span id="l30.691">    * The number of seconds before we declare the user idle and commit if</span>
<a href="#l30.692"></a><span id="l30.692">    *  needed.</span>
<a href="#l30.693"></a><span id="l30.693">    */</span>
<a href="#l30.694"></a><span id="l30.694">   _indexIdleThresholdSecs: 3,</span>
<a href="#l30.695"></a><span id="l30.695"> </span>
<a href="#l30.696"></a><span id="l30.696" class="difflineminus">-  /**</span>
<a href="#l30.697"></a><span id="l30.697" class="difflineminus">-   * The number of messages that we should queue for processing before letting</span>
<a href="#l30.698"></a><span id="l30.698" class="difflineminus">-   *  them fall on the floor and relying on our folder-walking logic to ensure</span>
<a href="#l30.699"></a><span id="l30.699" class="difflineminus">-   *  that the messages are indexed.</span>
<a href="#l30.700"></a><span id="l30.700" class="difflineminus">-   * The reason we allow for queueing messages in an event-driven fashion is</span>
<a href="#l30.701"></a><span id="l30.701" class="difflineminus">-   *  that once we have reached a steady-state, it is preferable to be able to</span>
<a href="#l30.702"></a><span id="l30.702" class="difflineminus">-   *  deal with new messages and modified meta-data in a prompt fasion rather</span>
<a href="#l30.703"></a><span id="l30.703" class="difflineminus">-   *  than having to (potentially) walk every folder in the system just to find</span>
<a href="#l30.704"></a><span id="l30.704" class="difflineminus">-   *  the message that the user changed the tag on.</span>
<a href="#l30.705"></a><span id="l30.705" class="difflineminus">-   */</span>
<a href="#l30.706"></a><span id="l30.706" class="difflineminus">-  _indexMaxEventQueueMessages: 20,</span>
<a href="#l30.707"></a><span id="l30.707" class="difflineminus">-</span>
<a href="#l30.708"></a><span id="l30.708">   _indexListeners: [],</span>
<a href="#l30.709"></a><span id="l30.709">   /**</span>
<a href="#l30.710"></a><span id="l30.710">    * Add an indexing progress listener.  The listener will be notified of at</span>
<a href="#l30.711"></a><span id="l30.711">    *  least all major status changes (idle -&gt; indexing, indexing -&gt; idle), plus</span>
<a href="#l30.712"></a><span id="l30.712">    *  arbitrary progress updates during the indexing process.</span>
<a href="#l30.713"></a><span id="l30.713">    * If indexing is not active when the listener is added, a synthetic idle</span>
<a href="#l30.714"></a><span id="l30.714">    *  notification will be generated.</span>
<a href="#l30.715"></a><span id="l30.715">    *</span>
<a href="#l30.716"></a><span id="l30.716">    * @param aListener A listener function, taking arguments: status (Gloda.</span>
<a href="#l30.717"></a><span id="l30.717">    *     kIndexer*), the folder name if a folder is involved (string or null),</span>
<a href="#l30.718"></a><span id="l30.718" class="difflineminus">-   *     current zero-based job number (int), total number of jobs (int),</span>
<a href="#l30.719"></a><span id="l30.719" class="difflineplus">+   *     current zero-based job number (int),</span>
<a href="#l30.720"></a><span id="l30.720">    *     current item number being indexed in this job (int), total number</span>
<a href="#l30.721"></a><span id="l30.721">    *     of items in this job to be indexed (int).</span>
<a href="#l30.722"></a><span id="l30.722">    *</span>
<a href="#l30.723"></a><span id="l30.723">    * @TODO should probably allow for a 'this' value to be provided</span>
<a href="#l30.724"></a><span id="l30.724">    * @TODO generalize to not be folder/message specific.  use nouns!</span>
<a href="#l30.725"></a><span id="l30.725">    */</span>
<a href="#l30.726"></a><span id="l30.726">   addListener: function gloda_index_addListener(aListener) {</span>
<a href="#l30.727"></a><span id="l30.727">     // should we weakify?</span>
<a href="#l30.728"></a><span id="l30.728">     if (this._indexListeners.indexOf(aListener) == -1)</span>
<a href="#l30.729"></a><span id="l30.729">       this._indexListeners.push(aListener);</span>
<a href="#l30.730"></a><span id="l30.730">     // if we aren't indexing, give them an idle indicator, otherwise they can</span>
<a href="#l30.731"></a><span id="l30.731">     //  just be happy when we hit the next actual status point.</span>
<a href="#l30.732"></a><span id="l30.732">     if (!this.indexing)</span>
<a href="#l30.733"></a><span id="l30.733" class="difflineminus">-      aListener(Gloda.kIndexerIdle, null, 0, 1, 0, 1);</span>
<a href="#l30.734"></a><span id="l30.734" class="difflineplus">+      aListener(Gloda.kIndexerIdle, null, 0, 0, 1);</span>
<a href="#l30.735"></a><span id="l30.735">     return aListener;</span>
<a href="#l30.736"></a><span id="l30.736">   },</span>
<a href="#l30.737"></a><span id="l30.737">   /**</span>
<a href="#l30.738"></a><span id="l30.738">    * Remove the given listener so that it no longer receives indexing progress</span>
<a href="#l30.739"></a><span id="l30.739">    *  updates.</span>
<a href="#l30.740"></a><span id="l30.740">    */</span>
<a href="#l30.741"></a><span id="l30.741">   removeListener: function gloda_index_removeListener(aListener) {</span>
<a href="#l30.742"></a><span id="l30.742">     let index = this._indexListeners.indexOf(aListener);</span>
<a href="#l30.743"></a><span id="l30.743">     if (index != -1)</span>
<a href="#l30.744"></a><span id="l30.744">       this._indexListeners.splice(index, 1);</span>
<a href="#l30.745"></a><span id="l30.745">   },</span>
<a href="#l30.746"></a><span id="l30.746">   /**</span>
<a href="#l30.747"></a><span id="l30.747">    * Helper method to tell listeners what we're up to.  For code simplicity,</span>
<a href="#l30.748"></a><span id="l30.748">    *  the caller is just deciding when to send this update (preferably at</span>
<a href="#l30.749"></a><span id="l30.749">    *  reasonable intervals), and doesn't need to provide any indication of</span>
<a href="#l30.750"></a><span id="l30.750">    *  state... we figure that out ourselves.</span>
<a href="#l30.751"></a><span id="l30.751" class="difflineplus">+   *</span>
<a href="#l30.752"></a><span id="l30.752" class="difflineplus">+   * This was not pretty but got ugly once we moved the message indexing out</span>
<a href="#l30.753"></a><span id="l30.753" class="difflineplus">+   *  to its own indexer.  Some generalization is required but will likely</span>
<a href="#l30.754"></a><span id="l30.754" class="difflineplus">+   *  require string hooks.</span>
<a href="#l30.755"></a><span id="l30.755">    */</span>
<a href="#l30.756"></a><span id="l30.756">   _notifyListeners: function gloda_index_notifyListeners() {</span>
<a href="#l30.757"></a><span id="l30.757" class="difflineminus">-    let status, prettyName, jobIndex, jobTotal, jobItemIndex, jobItemGoal;</span>
<a href="#l30.758"></a><span id="l30.758" class="difflineplus">+    let status, prettyName, jobIndex, jobItemIndex, jobItemGoal;</span>
<a href="#l30.759"></a><span id="l30.759"> </span>
<a href="#l30.760"></a><span id="l30.760">     if (this.indexing &amp;&amp; this._curIndexingJob) {</span>
<a href="#l30.761"></a><span id="l30.761">       let job = this._curIndexingJob;</span>
<a href="#l30.762"></a><span id="l30.762" class="difflineminus">-      if (job.deltaType &gt; 0)</span>
<a href="#l30.763"></a><span id="l30.763" class="difflineminus">-        status = Gloda.kIndexerIndexing;</span>
<a href="#l30.764"></a><span id="l30.764" class="difflineminus">-      else if (job.deltaType == 0)</span>
<a href="#l30.765"></a><span id="l30.765" class="difflineminus">-        status = Gloda.kIndexerMoving;</span>
<a href="#l30.766"></a><span id="l30.766" class="difflineplus">+      status = Gloda.kIndexerIndexing;</span>
<a href="#l30.767"></a><span id="l30.767" class="difflineplus">+</span>
<a href="#l30.768"></a><span id="l30.768" class="difflineplus">+      let indexer = this._indexerWorkerDefs[job.jobType].indexer;</span>
<a href="#l30.769"></a><span id="l30.769" class="difflineplus">+      if (&quot;_indexingFolder&quot; in indexer)</span>
<a href="#l30.770"></a><span id="l30.770" class="difflineplus">+        prettyName = (indexer._indexingFolder != null) ?</span>
<a href="#l30.771"></a><span id="l30.771" class="difflineplus">+                     indexer._indexingFolder.prettiestName : null;</span>
<a href="#l30.772"></a><span id="l30.772">       else</span>
<a href="#l30.773"></a><span id="l30.773" class="difflineminus">-        status = Gloda.kIndexerRemoving;</span>
<a href="#l30.774"></a><span id="l30.774" class="difflineminus">-</span>
<a href="#l30.775"></a><span id="l30.775" class="difflineminus">-      prettyName = (this._indexingFolder !== null) ?</span>
<a href="#l30.776"></a><span id="l30.776" class="difflineminus">-                   this._indexingFolder.prettiestName : null;</span>
<a href="#l30.777"></a><span id="l30.777" class="difflineplus">+        prettyName = null;</span>
<a href="#l30.778"></a><span id="l30.778"> </span>
<a href="#l30.779"></a><span id="l30.779">       jobIndex = this._indexingJobCount-1;</span>
<a href="#l30.780"></a><span id="l30.780" class="difflineminus">-      jobTotal = this._indexingJobGoal;</span>
<a href="#l30.781"></a><span id="l30.781">       jobItemIndex = job.offset;</span>
<a href="#l30.782"></a><span id="l30.782">       jobItemGoal  = job.goal;</span>
<a href="#l30.783"></a><span id="l30.783">     }</span>
<a href="#l30.784"></a><span id="l30.784">     else {</span>
<a href="#l30.785"></a><span id="l30.785">       status = Gloda.kIndexerIdle;</span>
<a href="#l30.786"></a><span id="l30.786">       prettyName = null;</span>
<a href="#l30.787"></a><span id="l30.787">       jobIndex = 0;</span>
<a href="#l30.788"></a><span id="l30.788" class="difflineminus">-      jobTotal = 1;</span>
<a href="#l30.789"></a><span id="l30.789">       jobItemIndex = 0;</span>
<a href="#l30.790"></a><span id="l30.790">       jobItemGoal = 1;</span>
<a href="#l30.791"></a><span id="l30.791">     }</span>
<a href="#l30.792"></a><span id="l30.792"> </span>
<a href="#l30.793"></a><span id="l30.793" class="difflineplus">+    // Some people ascribe to the belief that the most you can give is 100%.</span>
<a href="#l30.794"></a><span id="l30.794" class="difflineplus">+    // We know better, but let's humor them.</span>
<a href="#l30.795"></a><span id="l30.795" class="difflineplus">+    if (jobItemIndex &gt; jobItemGoal)</span>
<a href="#l30.796"></a><span id="l30.796" class="difflineplus">+      jobItemGoal = jobItemIndex;</span>
<a href="#l30.797"></a><span id="l30.797" class="difflineplus">+</span>
<a href="#l30.798"></a><span id="l30.798">     for (let iListener = this._indexListeners.length-1; iListener &gt;= 0;</span>
<a href="#l30.799"></a><span id="l30.799">          iListener--) {</span>
<a href="#l30.800"></a><span id="l30.800">       let listener = this._indexListeners[iListener];</span>
<a href="#l30.801"></a><span id="l30.801">       try {</span>
<a href="#l30.802"></a><span id="l30.802" class="difflineminus">-        listener(status, prettyName, jobIndex, jobTotal, jobItemIndex,</span>
<a href="#l30.803"></a><span id="l30.803" class="difflineminus">-                 jobItemGoal);</span>
<a href="#l30.804"></a><span id="l30.804" class="difflineplus">+        listener(status, prettyName, jobIndex, jobItemIndex, jobItemGoal);</span>
<a href="#l30.805"></a><span id="l30.805">       }</span>
<a href="#l30.806"></a><span id="l30.806">       catch(ex) {</span>
<a href="#l30.807"></a><span id="l30.807">         this._log.error(ex);</span>
<a href="#l30.808"></a><span id="l30.808">       }</span>
<a href="#l30.809"></a><span id="l30.809">     }</span>
<a href="#l30.810"></a><span id="l30.810">   },</span>
<a href="#l30.811"></a><span id="l30.811"> </span>
<a href="#l30.812"></a><span id="l30.812" class="difflineminus">-  /** The GlodaFolder corresponding to the folder we are indexing. */</span>
<a href="#l30.813"></a><span id="l30.813" class="difflineminus">-  _indexingGlodaFolder: null,</span>
<a href="#l30.814"></a><span id="l30.814" class="difflineminus">-  /** The nsIMsgFolder we are currently indexing. */</span>
<a href="#l30.815"></a><span id="l30.815" class="difflineminus">-  _indexingFolder: null,</span>
<a href="#l30.816"></a><span id="l30.816" class="difflineminus">-  /** The nsIMsgDatabase we are currently indexing. */</span>
<a href="#l30.817"></a><span id="l30.817" class="difflineminus">-  _indexingDatabase: null,</span>
<a href="#l30.818"></a><span id="l30.818">   /**</span>
<a href="#l30.819"></a><span id="l30.819" class="difflineminus">-   * The iterator we are using to iterate over the headers in</span>
<a href="#l30.820"></a><span id="l30.820" class="difflineminus">-   *  this._indexingDatabase.</span>
<a href="#l30.821"></a><span id="l30.821" class="difflineminus">-   */</span>
<a href="#l30.822"></a><span id="l30.822" class="difflineminus">-  _indexingIterator: null,</span>
<a href="#l30.823"></a><span id="l30.823" class="difflineminus">-</span>
<a href="#l30.824"></a><span id="l30.824" class="difflineminus">-  /** folder whose entry we are pending on */</span>
<a href="#l30.825"></a><span id="l30.825" class="difflineminus">-  _pendingFolderEntry: null,</span>
<a href="#l30.826"></a><span id="l30.826" class="difflineminus">-</span>
<a href="#l30.827"></a><span id="l30.827" class="difflineminus">-  /**</span>
<a href="#l30.828"></a><span id="l30.828" class="difflineminus">-   * Common logic that we want to deal with the given folder ID.  Besides</span>
<a href="#l30.829"></a><span id="l30.829" class="difflineminus">-   *  cutting down on duplicate code, this ensures that we are listening on</span>
<a href="#l30.830"></a><span id="l30.830" class="difflineminus">-   *  the folder in case it tries to go away when we are using it.</span>
<a href="#l30.831"></a><span id="l30.831" class="difflineminus">-   *</span>
<a href="#l30.832"></a><span id="l30.832" class="difflineminus">-   * @return true when the folder was successfully entered, false when we need</span>
<a href="#l30.833"></a><span id="l30.833" class="difflineminus">-   *     to pend on notification of updating of the folder (due to re-parsing</span>
<a href="#l30.834"></a><span id="l30.834" class="difflineminus">-   *     or what have you).  In the event of an actual problem, an exception</span>
<a href="#l30.835"></a><span id="l30.835" class="difflineminus">-   *     will escape.</span>
<a href="#l30.836"></a><span id="l30.836" class="difflineplus">+   * A wrapped callback driver intended to be used by timers that provide</span>
<a href="#l30.837"></a><span id="l30.837" class="difflineplus">+   *  arguments we really do not care about.</span>
<a href="#l30.838"></a><span id="l30.838">    */</span>
<a href="#l30.839"></a><span id="l30.839" class="difflineminus">-  _indexerEnterFolder: function gloda_index_indexerEnterFolder(aFolderID) {</span>
<a href="#l30.840"></a><span id="l30.840" class="difflineminus">-    // leave the folder if we haven't explicitly left it.</span>
<a href="#l30.841"></a><span id="l30.841" class="difflineminus">-    if (this._indexingFolder !== null) {</span>
<a href="#l30.842"></a><span id="l30.842" class="difflineminus">-      this._indexerLeaveFolder();</span>
<a href="#l30.843"></a><span id="l30.843" class="difflineminus">-    }</span>
<a href="#l30.844"></a><span id="l30.844" class="difflineminus">-</span>
<a href="#l30.845"></a><span id="l30.845" class="difflineminus">-    this._indexingGlodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l30.846"></a><span id="l30.846" class="difflineminus">-    this._indexingFolder = this._indexingGlodaFolder.getXPCOMFolder(</span>
<a href="#l30.847"></a><span id="l30.847" class="difflineminus">-                             this._indexingGlodaFolder.kActivityIndexing);</span>
<a href="#l30.848"></a><span id="l30.848" class="difflineminus">-</span>
<a href="#l30.849"></a><span id="l30.849" class="difflineminus">-    if (this._indexingFolder)</span>
<a href="#l30.850"></a><span id="l30.850" class="difflineminus">-      this._log.debug(&quot;Entering folder: &quot; + this._indexingFolder.URI);</span>
<a href="#l30.851"></a><span id="l30.851" class="difflineminus">-</span>
<a href="#l30.852"></a><span id="l30.852" class="difflineminus">-    try {</span>
<a href="#l30.853"></a><span id="l30.853" class="difflineminus">-      // The msf may need to be created or otherwise updated for local folders.</span>
<a href="#l30.854"></a><span id="l30.854" class="difflineminus">-      // This may require yielding until such time as the msf has been created.</span>
<a href="#l30.855"></a><span id="l30.855" class="difflineminus">-      try {</span>
<a href="#l30.856"></a><span id="l30.856" class="difflineminus">-        if (this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l30.857"></a><span id="l30.857" class="difflineminus">-          this._indexingDatabase =</span>
<a href="#l30.858"></a><span id="l30.858" class="difflineminus">-            this._indexingFolder.getDatabaseWithReparse(null,</span>
<a href="#l30.859"></a><span id="l30.859" class="difflineminus">-                                                        null);</span>
<a href="#l30.860"></a><span id="l30.860" class="difflineminus">-        }</span>
<a href="#l30.861"></a><span id="l30.861" class="difflineminus">-        // we need do nothing special for IMAP, news, or other</span>
<a href="#l30.862"></a><span id="l30.862" class="difflineminus">-      }</span>
<a href="#l30.863"></a><span id="l30.863" class="difflineminus">-      // getDatabaseWithReparse can return either NS_ERROR_NOT_INITIALIZED or</span>
<a href="#l30.864"></a><span id="l30.864" class="difflineminus">-      //  NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE if the net result is that it</span>
<a href="#l30.865"></a><span id="l30.865" class="difflineminus">-      //  is going to send us a notification when the reparse has completed.</span>
<a href="#l30.866"></a><span id="l30.866" class="difflineminus">-      // (note that although internally NS_MSG_ERROR_FOLDER_SUMMARY_MISSING</span>
<a href="#l30.867"></a><span id="l30.867" class="difflineminus">-      //  might get flung around, it won't make it out to us, and will instead</span>
<a href="#l30.868"></a><span id="l30.868" class="difflineminus">-      //  be permuted into an NS_ERROR_NOT_INITIALIZED.)</span>
<a href="#l30.869"></a><span id="l30.869" class="difflineminus">-      catch (e if ((e.result == Cr.NS_ERROR_NOT_INITIALIZED) ||</span>
<a href="#l30.870"></a><span id="l30.870" class="difflineminus">-                   (e.result == NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE))) {</span>
<a href="#l30.871"></a><span id="l30.871" class="difflineminus">-        // this means that we need to pend on the update; the listener for</span>
<a href="#l30.872"></a><span id="l30.872" class="difflineminus">-        //  FolderLoaded events will call _indexerCompletePendingFolderEntry.</span>
<a href="#l30.873"></a><span id="l30.873" class="difflineminus">-        this._log.debug(&quot;Pending on folder load...&quot;);</span>
<a href="#l30.874"></a><span id="l30.874" class="difflineminus">-        this._pendingFolderEntry = this._indexingFolder;</span>
<a href="#l30.875"></a><span id="l30.875" class="difflineminus">-        return this.kWorkAsync;</span>
<a href="#l30.876"></a><span id="l30.876" class="difflineminus">-      }</span>
<a href="#l30.877"></a><span id="l30.877" class="difflineminus">-      // we get an nsIMsgDatabase out of this (unsurprisingly) which</span>
<a href="#l30.878"></a><span id="l30.878" class="difflineminus">-      //  explicitly inherits from nsIDBChangeAnnouncer, which has the</span>
<a href="#l30.879"></a><span id="l30.879" class="difflineminus">-      //  AddListener call we want.</span>
<a href="#l30.880"></a><span id="l30.880" class="difflineminus">-      if (this._indexingDatabase == null)</span>
<a href="#l30.881"></a><span id="l30.881" class="difflineminus">-        this._indexingDatabase = this._indexingFolder.msgDatabase;</span>
<a href="#l30.882"></a><span id="l30.882" class="difflineminus">-      this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l30.883"></a><span id="l30.883" class="difflineminus">-    }</span>
<a href="#l30.884"></a><span id="l30.884" class="difflineminus">-    catch (ex) {</span>
<a href="#l30.885"></a><span id="l30.885" class="difflineminus">-      this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l30.886"></a><span id="l30.886" class="difflineminus">-                      (this._indexingFolder ?</span>
<a href="#l30.887"></a><span id="l30.887" class="difflineminus">-                         this._indexingFolder.prettiestName : &quot;unknown&quot;) +</span>
<a href="#l30.888"></a><span id="l30.888" class="difflineminus">-                      &quot;, skipping. Error was: &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l30.889"></a><span id="l30.889" class="difflineminus">-                      ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l30.890"></a><span id="l30.890" class="difflineminus">-      this._indexingGlodaFolder.indexing = false;</span>
<a href="#l30.891"></a><span id="l30.891" class="difflineminus">-      this._indexingFolder = null;</span>
<a href="#l30.892"></a><span id="l30.892" class="difflineminus">-      this._indexingGlodaFolder = null;</span>
<a href="#l30.893"></a><span id="l30.893" class="difflineminus">-      this._indexingDatabase = null;</span>
<a href="#l30.894"></a><span id="l30.894" class="difflineminus">-      this._indexingEnumerator = null;</span>
<a href="#l30.895"></a><span id="l30.895" class="difflineminus">-</span>
<a href="#l30.896"></a><span id="l30.896" class="difflineminus">-      // re-throw, we just wanted to make sure this junk is cleaned up and</span>
<a href="#l30.897"></a><span id="l30.897" class="difflineminus">-      //  get localized error logging...</span>
<a href="#l30.898"></a><span id="l30.898" class="difflineminus">-      throw ex;</span>
<a href="#l30.899"></a><span id="l30.899" class="difflineminus">-    }</span>
<a href="#l30.900"></a><span id="l30.900" class="difflineminus">-</span>
<a href="#l30.901"></a><span id="l30.901" class="difflineminus">-    return this.kWorkSync;</span>
<a href="#l30.902"></a><span id="l30.902" class="difflineminus">-  },</span>
<a href="#l30.903"></a><span id="l30.903" class="difflineminus">-</span>
<a href="#l30.904"></a><span id="l30.904" class="difflineminus">-  /**</span>
<a href="#l30.905"></a><span id="l30.905" class="difflineminus">-   * If the folder was still parsing/updating when we tried to enter, then this</span>
<a href="#l30.906"></a><span id="l30.906" class="difflineminus">-   *  handler will get called by the listener who got the FolderLoaded message.</span>
<a href="#l30.907"></a><span id="l30.907" class="difflineminus">-   * All we need to do is get the database reference, register a listener on</span>
<a href="#l30.908"></a><span id="l30.908" class="difflineminus">-   *  the db, and retrieve an iterator if desired.</span>
<a href="#l30.909"></a><span id="l30.909" class="difflineminus">-   */</span>
<a href="#l30.910"></a><span id="l30.910" class="difflineminus">-  _indexerCompletePendingFolderEntry:</span>
<a href="#l30.911"></a><span id="l30.911" class="difflineminus">-      function gloda_indexer_indexerCompletePendingFolderEntry() {</span>
<a href="#l30.912"></a><span id="l30.912" class="difflineminus">-    this._indexingDatabase = this._indexingFolder.msgDatabase;</span>
<a href="#l30.913"></a><span id="l30.913" class="difflineminus">-    this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l30.914"></a><span id="l30.914" class="difflineminus">-    this._log.debug(&quot;...Folder Loaded!&quot;);</span>
<a href="#l30.915"></a><span id="l30.915" class="difflineminus">-</span>
<a href="#l30.916"></a><span id="l30.916" class="difflineminus">-    // the load is no longer pending; we certainly don't want more notifications</span>
<a href="#l30.917"></a><span id="l30.917" class="difflineminus">-    this._pendingFolderEntry = null;</span>
<a href="#l30.918"></a><span id="l30.918" class="difflineminus">-    // indexerEnterFolder returned kWorkAsync, which means we need to notify</span>
<a href="#l30.919"></a><span id="l30.919" class="difflineminus">-    //  the callback driver to get things going again.</span>
<a href="#l30.920"></a><span id="l30.920" class="difflineminus">-    this.callbackDriver();</span>
<a href="#l30.921"></a><span id="l30.921" class="difflineplus">+  _timerCallbackDriver: function gloda_index_timerCallbackDriver() {</span>
<a href="#l30.922"></a><span id="l30.922" class="difflineplus">+    GlodaIndexer.callbackDriver();</span>
<a href="#l30.923"></a><span id="l30.923">   },</span>
<a href="#l30.924"></a><span id="l30.924"> </span>
<a href="#l30.925"></a><span id="l30.925">   /**</span>
<a href="#l30.926"></a><span id="l30.926" class="difflineminus">-   *  @param  aGetAll  should we get all messages</span>
<a href="#l30.927"></a><span id="l30.927" class="difflineminus">-   *                    (or only those we need to index)?</span>
<a href="#l30.928"></a><span id="l30.928" class="difflineminus">-   */</span>
<a href="#l30.929"></a><span id="l30.929" class="difflineminus">-  _indexerGetEnumerator: function gloda_indexer_indexerGetEnumerator(aGetAll) {</span>
<a href="#l30.930"></a><span id="l30.930" class="difflineminus">-    if (aGetAll) {</span>
<a href="#l30.931"></a><span id="l30.931" class="difflineminus">-      this._indexingEnumerator = this._indexingDatabase.EnumerateMessages();</span>
<a href="#l30.932"></a><span id="l30.932" class="difflineminus">-    }</span>
<a href="#l30.933"></a><span id="l30.933" class="difflineminus">-</span>
<a href="#l30.934"></a><span id="l30.934" class="difflineminus">-    else {</span>
<a href="#l30.935"></a><span id="l30.935" class="difflineminus">-      // We need to create search terms for messages to index. Messages should</span>
<a href="#l30.936"></a><span id="l30.936" class="difflineminus">-      //  be indexed if they're indexable (local or offline and not expunged)</span>
<a href="#l30.937"></a><span id="l30.937" class="difflineminus">-      //  and either haven't been indexed or are dirty.</span>
<a href="#l30.938"></a><span id="l30.938" class="difflineminus">-      // The basic search expression is:</span>
<a href="#l30.939"></a><span id="l30.939" class="difflineminus">-      //  ((GLODA_MESSAGE_ID_PROPERTY Is 0) || (GLODA_DIRTY_PROPERTY Isnt 0))</span>
<a href="#l30.940"></a><span id="l30.940" class="difflineminus">-      // If the folder !isLocal we add the terms:</span>
<a href="#l30.941"></a><span id="l30.941" class="difflineminus">-      //  - if the folder is offline -- &amp;&amp; (Status Is nsMsgMessageFlags.Offline)</span>
<a href="#l30.942"></a><span id="l30.942" class="difflineminus">-      //  - &amp;&amp; (Status Isnt nsMsgMessageFlags.Expunged)</span>
<a href="#l30.943"></a><span id="l30.943" class="difflineminus">-</span>
<a href="#l30.944"></a><span id="l30.944" class="difflineminus">-      let searchSession = Cc[&quot;@mozilla.org/messenger/searchSession;1&quot;]</span>
<a href="#l30.945"></a><span id="l30.945" class="difflineminus">-                            .createInstance(Ci.nsIMsgSearchSession);</span>
<a href="#l30.946"></a><span id="l30.946" class="difflineminus">-      let searchTerms = Cc[&quot;@mozilla.org/array;1&quot;]</span>
<a href="#l30.947"></a><span id="l30.947" class="difflineminus">-                         .createInstance(Ci.nsIMutableArray);</span>
<a href="#l30.948"></a><span id="l30.948" class="difflineminus">-      let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l30.949"></a><span id="l30.949" class="difflineminus">-</span>
<a href="#l30.950"></a><span id="l30.950" class="difflineminus">-      searchSession.addScopeTerm(Ci.nsMsgSearchScope.offlineMail,</span>
<a href="#l30.951"></a><span id="l30.951" class="difflineminus">-                                 this._indexingFolder);</span>
<a href="#l30.952"></a><span id="l30.952" class="difflineminus">-      let nsMsgSearchAttrib = Ci.nsMsgSearchAttrib;</span>
<a href="#l30.953"></a><span id="l30.953" class="difflineminus">-      let nsMsgSearchOp = Ci.nsMsgSearchOp;</span>
<a href="#l30.954"></a><span id="l30.954" class="difflineminus">-</span>
<a href="#l30.955"></a><span id="l30.955" class="difflineminus">-      // first term: (GLODA_MESSAGE_ID_PROPERTY Is 0</span>
<a href="#l30.956"></a><span id="l30.956" class="difflineminus">-      let searchTerm = searchSession.createTerm();</span>
<a href="#l30.957"></a><span id="l30.957" class="difflineminus">-      searchTerm.booleanAnd = false; // actually don't care here</span>
<a href="#l30.958"></a><span id="l30.958" class="difflineminus">-      searchTerm.beginsGrouping = true;</span>
<a href="#l30.959"></a><span id="l30.959" class="difflineminus">-      searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;</span>
<a href="#l30.960"></a><span id="l30.960" class="difflineminus">-      searchTerm.op = nsMsgSearchOp.Is;</span>
<a href="#l30.961"></a><span id="l30.961" class="difflineminus">-      let value = searchTerm.value;</span>
<a href="#l30.962"></a><span id="l30.962" class="difflineminus">-      value.attrib = searchTerm.attrib;</span>
<a href="#l30.963"></a><span id="l30.963" class="difflineminus">-      value.status = 0;</span>
<a href="#l30.964"></a><span id="l30.964" class="difflineminus">-      searchTerm.value = value;</span>
<a href="#l30.965"></a><span id="l30.965" class="difflineminus">-      searchTerm.hdrProperty = GLODA_MESSAGE_ID_PROPERTY;</span>
<a href="#l30.966"></a><span id="l30.966" class="difflineminus">-      searchTerms.appendElement(searchTerm, false);</span>
<a href="#l30.967"></a><span id="l30.967" class="difflineminus">-</span>
<a href="#l30.968"></a><span id="l30.968" class="difflineminus">-      //  second term: || GLODA_DIRTY_PROPERTY Isnt 0 )</span>
<a href="#l30.969"></a><span id="l30.969" class="difflineminus">-      searchTerm = searchSession.createTerm();</span>
<a href="#l30.970"></a><span id="l30.970" class="difflineminus">-      searchTerm.booleanAnd = false;</span>
<a href="#l30.971"></a><span id="l30.971" class="difflineminus">-      searchTerm.endsGrouping = true;</span>
<a href="#l30.972"></a><span id="l30.972" class="difflineminus">-      searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;</span>
<a href="#l30.973"></a><span id="l30.973" class="difflineminus">-      searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l30.974"></a><span id="l30.974" class="difflineminus">-      value = searchTerm.value;</span>
<a href="#l30.975"></a><span id="l30.975" class="difflineminus">-      value.attrib = searchTerm.attrib;</span>
<a href="#l30.976"></a><span id="l30.976" class="difflineminus">-      value.status = 0;</span>
<a href="#l30.977"></a><span id="l30.977" class="difflineminus">-      searchTerm.value = value;</span>
<a href="#l30.978"></a><span id="l30.978" class="difflineminus">-      searchTerm.hdrProperty = GLODA_DIRTY_PROPERTY;</span>
<a href="#l30.979"></a><span id="l30.979" class="difflineminus">-      searchTerms.appendElement(searchTerm, false);</span>
<a href="#l30.980"></a><span id="l30.980" class="difflineminus">-</span>
<a href="#l30.981"></a><span id="l30.981" class="difflineminus">-      if (!isLocal)</span>
<a href="#l30.982"></a><span id="l30.982" class="difflineminus">-      {</span>
<a href="#l30.983"></a><span id="l30.983" class="difflineminus">-        // If the folder is offline, then the message should be too</span>
<a href="#l30.984"></a><span id="l30.984" class="difflineminus">-        if (this._indexingFolder.flags &amp; Ci.nsMsgFolderFlags.Offline) {</span>
<a href="#l30.985"></a><span id="l30.985" class="difflineminus">-          // third term: &amp;&amp; Status Is nsMsgMessageFlags.Offline</span>
<a href="#l30.986"></a><span id="l30.986" class="difflineminus">-          searchTerm = searchSession.createTerm();</span>
<a href="#l30.987"></a><span id="l30.987" class="difflineminus">-          searchTerm.booleanAnd = true;</span>
<a href="#l30.988"></a><span id="l30.988" class="difflineminus">-          searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l30.989"></a><span id="l30.989" class="difflineminus">-          searchTerm.op = nsMsgSearchOp.Is;</span>
<a href="#l30.990"></a><span id="l30.990" class="difflineminus">-          value = searchTerm.value;</span>
<a href="#l30.991"></a><span id="l30.991" class="difflineminus">-          value.attrib = searchTerm.attrib;</span>
<a href="#l30.992"></a><span id="l30.992" class="difflineminus">-          value.status = Ci.nsMsgMessageFlags.Offline;</span>
<a href="#l30.993"></a><span id="l30.993" class="difflineminus">-          searchTerm.value = value;</span>
<a href="#l30.994"></a><span id="l30.994" class="difflineminus">-          searchTerms.appendElement(searchTerm, false);</span>
<a href="#l30.995"></a><span id="l30.995" class="difflineminus">-        }</span>
<a href="#l30.996"></a><span id="l30.996" class="difflineminus">-</span>
<a href="#l30.997"></a><span id="l30.997" class="difflineminus">-        // fourth term: &amp;&amp; Status Isnt nsMsgMessageFlags.Expunged</span>
<a href="#l30.998"></a><span id="l30.998" class="difflineminus">-        searchTerm = searchSession.createTerm();</span>
<a href="#l30.999"></a><span id="l30.999" class="difflineminus">-        searchTerm.booleanAnd = true;</span>
<a href="#l30.1000"></a><span id="l30.1000" class="difflineminus">-        searchTerm.attrib = nsMsgSearchAttrib.MsgStatus;</span>
<a href="#l30.1001"></a><span id="l30.1001" class="difflineminus">-        searchTerm.op = nsMsgSearchOp.Isnt;</span>
<a href="#l30.1002"></a><span id="l30.1002" class="difflineminus">-        value = searchTerm.value;</span>
<a href="#l30.1003"></a><span id="l30.1003" class="difflineminus">-        value.attrib = searchTerm.attrib;</span>
<a href="#l30.1004"></a><span id="l30.1004" class="difflineminus">-        value.status = Ci.nsMsgMessageFlags.Expunged;</span>
<a href="#l30.1005"></a><span id="l30.1005" class="difflineminus">-        searchTerm.value = value;</span>
<a href="#l30.1006"></a><span id="l30.1006" class="difflineminus">-        searchTerms.appendElement(searchTerm, false);</span>
<a href="#l30.1007"></a><span id="l30.1007" class="difflineminus">-      }</span>
<a href="#l30.1008"></a><span id="l30.1008" class="difflineminus">-</span>
<a href="#l30.1009"></a><span id="l30.1009" class="difflineminus">-      this._indexingEnumerator = this._indexingDatabase.getFilterEnumerator(searchTerms);</span>
<a href="#l30.1010"></a><span id="l30.1010" class="difflineminus">-    }</span>
<a href="#l30.1011"></a><span id="l30.1011" class="difflineminus">-  },</span>
<a href="#l30.1012"></a><span id="l30.1012" class="difflineminus">-</span>
<a href="#l30.1013"></a><span id="l30.1013" class="difflineminus">-  _indexerLeaveFolder: function gloda_index_indexerLeaveFolder(aExpected) {</span>
<a href="#l30.1014"></a><span id="l30.1014" class="difflineminus">-    if (this._indexingFolder !== null) {</span>
<a href="#l30.1015"></a><span id="l30.1015" class="difflineminus">-      if (this._indexingDatabase) {</span>
<a href="#l30.1016"></a><span id="l30.1016" class="difflineminus">-        this._indexingDatabase.Commit(Ci.nsMsgDBCommitType.kLargeCommit);</span>
<a href="#l30.1017"></a><span id="l30.1017" class="difflineminus">-        // remove our listener!</span>
<a href="#l30.1018"></a><span id="l30.1018" class="difflineminus">-        this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l30.1019"></a><span id="l30.1019" class="difflineminus">-      }</span>
<a href="#l30.1020"></a><span id="l30.1020" class="difflineminus">-      // let the gloda folder know we are done indexing</span>
<a href="#l30.1021"></a><span id="l30.1021" class="difflineminus">-      this._indexingGlodaFolder.indexing = false;</span>
<a href="#l30.1022"></a><span id="l30.1022" class="difflineminus">-      // null everyone out</span>
<a href="#l30.1023"></a><span id="l30.1023" class="difflineminus">-      this._indexingFolder = null;</span>
<a href="#l30.1024"></a><span id="l30.1024" class="difflineminus">-      this._indexingGlodaFolder = null;</span>
<a href="#l30.1025"></a><span id="l30.1025" class="difflineminus">-      this._indexingDatabase = null;</span>
<a href="#l30.1026"></a><span id="l30.1026" class="difflineminus">-      this._indexingEnumerator = null;</span>
<a href="#l30.1027"></a><span id="l30.1027" class="difflineminus">-    }</span>
<a href="#l30.1028"></a><span id="l30.1028" class="difflineminus">-  },</span>
<a href="#l30.1029"></a><span id="l30.1029" class="difflineminus">-</span>
<a href="#l30.1030"></a><span id="l30.1030" class="difflineminus">-  /**</span>
<a href="#l30.1031"></a><span id="l30.1031" class="difflineminus">-   * Event fed to us by our nsIFolderListener when a folder is loaded.  We use</span>
<a href="#l30.1032"></a><span id="l30.1032" class="difflineminus">-   *  this event to two ends:</span>
<a href="#l30.1033"></a><span id="l30.1033" class="difflineminus">-   *</span>
<a href="#l30.1034"></a><span id="l30.1034" class="difflineminus">-   * - Know when a folder we were trying to open to index is actually ready to</span>
<a href="#l30.1035"></a><span id="l30.1035" class="difflineminus">-   *   be indexed.  (The summary may have not existed, may have been out of</span>
<a href="#l30.1036"></a><span id="l30.1036" class="difflineminus">-   *   date, or otherwise.)</span>
<a href="#l30.1037"></a><span id="l30.1037" class="difflineminus">-   * - Know when</span>
<a href="#l30.1038"></a><span id="l30.1038" class="difflineminus">-   *</span>
<a href="#l30.1039"></a><span id="l30.1039" class="difflineminus">-   * @param aFolder An nsIMsgFolder, already QI'd.</span>
<a href="#l30.1040"></a><span id="l30.1040" class="difflineminus">-   */</span>
<a href="#l30.1041"></a><span id="l30.1041" class="difflineminus">-  _onFolderLoaded: function gloda_index_onFolderLoaded(aFolder) {</span>
<a href="#l30.1042"></a><span id="l30.1042" class="difflineminus">-    if ((this._pendingFolderEntry !== null) &amp;&amp;</span>
<a href="#l30.1043"></a><span id="l30.1043" class="difflineminus">-        (aFolder.URI == this._pendingFolderEntry.URI))</span>
<a href="#l30.1044"></a><span id="l30.1044" class="difflineminus">-      this._indexerCompletePendingFolderEntry();</span>
<a href="#l30.1045"></a><span id="l30.1045" class="difflineminus">-  },</span>
<a href="#l30.1046"></a><span id="l30.1046" class="difflineminus">-</span>
<a href="#l30.1047"></a><span id="l30.1047" class="difflineminus">-  /**</span>
<a href="#l30.1048"></a><span id="l30.1048" class="difflineminus">-   * A simple wrapper to make 'this' be right for incrementalIndex.</span>
<a href="#l30.1049"></a><span id="l30.1049" class="difflineplus">+   * A simple callback driver wrapper to provide 'this'.</span>
<a href="#l30.1050"></a><span id="l30.1050">    */</span>
<a href="#l30.1051"></a><span id="l30.1051">   _wrapCallbackDriver: function gloda_index_wrapCallbackDriver() {</span>
<a href="#l30.1052"></a><span id="l30.1052" class="difflineminus">-    GlodaIndexer.callbackDriver();</span>
<a href="#l30.1053"></a><span id="l30.1053" class="difflineplus">+    GlodaIndexer.callbackDriver.apply(GlodaIndexer, arguments);</span>
<a href="#l30.1054"></a><span id="l30.1054">   },</span>
<a href="#l30.1055"></a><span id="l30.1055"> </span>
<a href="#l30.1056"></a><span id="l30.1056">   /**</span>
<a href="#l30.1057"></a><span id="l30.1057">    * The current processing 'batch' generator, produced by a call to workBatch()</span>
<a href="#l30.1058"></a><span id="l30.1058">    *  and used by callbackDriver to drive execution.</span>
<a href="#l30.1059"></a><span id="l30.1059">    */</span>
<a href="#l30.1060"></a><span id="l30.1060">   _batch: null,</span>
<a href="#l30.1061"></a><span id="l30.1061">   _inCallback: false,</span>
<a href="#l30.1062"></a><span id="l30.1062" class="difflineat">@@ -1205,17 +797,17 @@ var GlodaIndexer = {</span>
<a href="#l30.1063"></a><span id="l30.1063">     // this is also now a good thing sequencing-wise.  if we get our callback</span>
<a href="#l30.1064"></a><span id="l30.1064">     //  with data before the underlying function has yielded, we obviously can't</span>
<a href="#l30.1065"></a><span id="l30.1065">     //  cram the data in yet.  Our options in this case are to either mark the</span>
<a href="#l30.1066"></a><span id="l30.1066">     //  fact that the callback has already happened and immediately return to</span>
<a href="#l30.1067"></a><span id="l30.1067">     //  the iterator when it does bubble up the kWorkAsync, or we can do as we</span>
<a href="#l30.1068"></a><span id="l30.1068">     //  have been doing, but save the</span>
<a href="#l30.1069"></a><span id="l30.1069">     if (this._inCallback) {</span>
<a href="#l30.1070"></a><span id="l30.1070">       this._savedCallbackArgs = arguments;</span>
<a href="#l30.1071"></a><span id="l30.1071" class="difflineminus">-      this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l30.1072"></a><span id="l30.1072" class="difflineplus">+      this._timer.initWithCallback(this._timerCallbackDriver,</span>
<a href="#l30.1073"></a><span id="l30.1073">                                    0,</span>
<a href="#l30.1074"></a><span id="l30.1074">                                    Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l30.1075"></a><span id="l30.1075">       return;</span>
<a href="#l30.1076"></a><span id="l30.1076">     }</span>
<a href="#l30.1077"></a><span id="l30.1077">     this._inCallback = true;</span>
<a href="#l30.1078"></a><span id="l30.1078"> </span>
<a href="#l30.1079"></a><span id="l30.1079">     try {</span>
<a href="#l30.1080"></a><span id="l30.1080">       if (this._batch === null)</span>
<a href="#l30.1081"></a><span id="l30.1081" class="difflineat">@@ -1246,17 +838,17 @@ var GlodaIndexer = {</span>
<a href="#l30.1082"></a><span id="l30.1082">         //  to do.</span>
<a href="#l30.1083"></a><span id="l30.1083">         case this.kWorkDone:</span>
<a href="#l30.1084"></a><span id="l30.1084">           this._batch.close();</span>
<a href="#l30.1085"></a><span id="l30.1085">           this._batch = null;</span>
<a href="#l30.1086"></a><span id="l30.1086">           // (intentional fall-through to re-scheduling logic)</span>
<a href="#l30.1087"></a><span id="l30.1087">         // the batch wants to get re-scheduled, do so.</span>
<a href="#l30.1088"></a><span id="l30.1088">         case this.kWorkPause:</span>
<a href="#l30.1089"></a><span id="l30.1089">           if (this.indexing)</span>
<a href="#l30.1090"></a><span id="l30.1090" class="difflineminus">-            this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l30.1091"></a><span id="l30.1091" class="difflineplus">+            this._timer.initWithCallback(this._timerCallbackDriver,</span>
<a href="#l30.1092"></a><span id="l30.1092">                                          this._INDEX_INTERVAL,</span>
<a href="#l30.1093"></a><span id="l30.1093">                                          Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l30.1094"></a><span id="l30.1094">           else { // it's important to indicate no more callbacks are in flight</span>
<a href="#l30.1095"></a><span id="l30.1095">             this._indexingActive = false;</span>
<a href="#l30.1096"></a><span id="l30.1096">           }</span>
<a href="#l30.1097"></a><span id="l30.1097">           break;</span>
<a href="#l30.1098"></a><span id="l30.1098">         case this.kWorkAsync:</span>
<a href="#l30.1099"></a><span id="l30.1099">           // there is nothing to do.  some other code is now responsible for</span>
<a href="#l30.1100"></a><span id="l30.1100" class="difflineat">@@ -1270,52 +862,98 @@ var GlodaIndexer = {</span>
<a href="#l30.1101"></a><span id="l30.1101">   },</span>
<a href="#l30.1102"></a><span id="l30.1102"> </span>
<a href="#l30.1103"></a><span id="l30.1103">   _callbackHandle: {</span>
<a href="#l30.1104"></a><span id="l30.1104">     init: function gloda_index_callbackhandle_init() {</span>
<a href="#l30.1105"></a><span id="l30.1105">       this.wrappedCallback = GlodaIndexer._wrapCallbackDriver;</span>
<a href="#l30.1106"></a><span id="l30.1106">       this.callbackThis = GlodaIndexer;</span>
<a href="#l30.1107"></a><span id="l30.1107">       this.callback = GlodaIndexer.callbackDriver;</span>
<a href="#l30.1108"></a><span id="l30.1108">     },</span>
<a href="#l30.1109"></a><span id="l30.1109" class="difflineplus">+    /**</span>
<a href="#l30.1110"></a><span id="l30.1110" class="difflineplus">+     * The stack of generators we are processing.  The (numerically) last one is</span>
<a href="#l30.1111"></a><span id="l30.1111" class="difflineplus">+     *  also the |activeIterator|.</span>
<a href="#l30.1112"></a><span id="l30.1112" class="difflineplus">+     */</span>
<a href="#l30.1113"></a><span id="l30.1113">     activeStack: [],</span>
<a href="#l30.1114"></a><span id="l30.1114" class="difflineplus">+    /**</span>
<a href="#l30.1115"></a><span id="l30.1115" class="difflineplus">+     * The generator at the top of the |activeStack| and that we will call next</span>
<a href="#l30.1116"></a><span id="l30.1116" class="difflineplus">+     *  or send on next if nothing changes.</span>
<a href="#l30.1117"></a><span id="l30.1117" class="difflineplus">+     */</span>
<a href="#l30.1118"></a><span id="l30.1118">     activeIterator: null,</span>
<a href="#l30.1119"></a><span id="l30.1119" class="difflineminus">-    push: function gloda_index_callbackhandle_push(aIterator) {</span>
<a href="#l30.1120"></a><span id="l30.1120" class="difflineplus">+    /**</span>
<a href="#l30.1121"></a><span id="l30.1121" class="difflineplus">+     * Meta-information about the generators at each level of the stack.</span>
<a href="#l30.1122"></a><span id="l30.1122" class="difflineplus">+     */</span>
<a href="#l30.1123"></a><span id="l30.1123" class="difflineplus">+    contextStack: [],</span>
<a href="#l30.1124"></a><span id="l30.1124" class="difflineplus">+    /**</span>
<a href="#l30.1125"></a><span id="l30.1125" class="difflineplus">+     * Push a new generator onto the stack.  It becomes the active generator.</span>
<a href="#l30.1126"></a><span id="l30.1126" class="difflineplus">+     */</span>
<a href="#l30.1127"></a><span id="l30.1127" class="difflineplus">+    push: function gloda_index_callbackhandle_push(aIterator, aContext) {</span>
<a href="#l30.1128"></a><span id="l30.1128">       this.activeStack.push(aIterator);</span>
<a href="#l30.1129"></a><span id="l30.1129" class="difflineplus">+      this.contextStack.push(aContext);</span>
<a href="#l30.1130"></a><span id="l30.1130">       this.activeIterator = aIterator;</span>
<a href="#l30.1131"></a><span id="l30.1131">     },</span>
<a href="#l30.1132"></a><span id="l30.1132" class="difflineminus">-    pushAndGo: function gloda_index_callbackhandle_pushAndGo(aIterator) {</span>
<a href="#l30.1133"></a><span id="l30.1133" class="difflineminus">-      this.push(aIterator);</span>
<a href="#l30.1134"></a><span id="l30.1134" class="difflineminus">-      return this.activeIterator.next();</span>
<a href="#l30.1135"></a><span id="l30.1135" class="difflineplus">+    /**</span>
<a href="#l30.1136"></a><span id="l30.1136" class="difflineplus">+     * For use by generators that want to call another asynchronous process</span>
<a href="#l30.1137"></a><span id="l30.1137" class="difflineplus">+     *  implemented as a generator.  They should do</span>
<a href="#l30.1138"></a><span id="l30.1138" class="difflineplus">+     *  &quot;yield aCallbackHandle.pushAndGo(someGenerator(arg1, arg2));&quot;.</span>
<a href="#l30.1139"></a><span id="l30.1139" class="difflineplus">+     *</span>
<a href="#l30.1140"></a><span id="l30.1140" class="difflineplus">+     * @public</span>
<a href="#l30.1141"></a><span id="l30.1141" class="difflineplus">+     */</span>
<a href="#l30.1142"></a><span id="l30.1142" class="difflineplus">+    pushAndGo: function gloda_index_callbackhandle_pushAndGo(aIterator,</span>
<a href="#l30.1143"></a><span id="l30.1143" class="difflineplus">+                                                             aContext) {</span>
<a href="#l30.1144"></a><span id="l30.1144" class="difflineplus">+      this.push(aIterator, aContext);</span>
<a href="#l30.1145"></a><span id="l30.1145" class="difflineplus">+      return GlodaIndexer.kWorkSync;</span>
<a href="#l30.1146"></a><span id="l30.1146">     },</span>
<a href="#l30.1147"></a><span id="l30.1147" class="difflineplus">+    /**</span>
<a href="#l30.1148"></a><span id="l30.1148" class="difflineplus">+     * Pop the active generator off the stack and close it.</span>
<a href="#l30.1149"></a><span id="l30.1149" class="difflineplus">+     */</span>
<a href="#l30.1150"></a><span id="l30.1150">     pop: function gloda_index_callbackhandle_pop() {</span>
<a href="#l30.1151"></a><span id="l30.1151">       this.activeIterator.close();</span>
<a href="#l30.1152"></a><span id="l30.1152">       this.activeStack.pop();</span>
<a href="#l30.1153"></a><span id="l30.1153" class="difflineplus">+      this.contextStack.pop();</span>
<a href="#l30.1154"></a><span id="l30.1154">       if (this.activeStack.length)</span>
<a href="#l30.1155"></a><span id="l30.1155">         this.activeIterator = this.activeStack[this.activeStack.length - 1];</span>
<a href="#l30.1156"></a><span id="l30.1156">       else</span>
<a href="#l30.1157"></a><span id="l30.1157">         this.activeIterator = null;</span>
<a href="#l30.1158"></a><span id="l30.1158">     },</span>
<a href="#l30.1159"></a><span id="l30.1159">     /**</span>
<a href="#l30.1160"></a><span id="l30.1160">      * Someone propagated an exception and we need to clean-up all the active</span>
<a href="#l30.1161"></a><span id="l30.1161">      *  logic as best we can.  Which is not really all that well.</span>
<a href="#l30.1162"></a><span id="l30.1162" class="difflineplus">+     *</span>
<a href="#l30.1163"></a><span id="l30.1163" class="difflineplus">+     * @param [aOptionalStopAtDepth=0] The length the stack should be when this</span>
<a href="#l30.1164"></a><span id="l30.1164" class="difflineplus">+     *     method completes.  Pass 0 or omit for us to clear everything out.</span>
<a href="#l30.1165"></a><span id="l30.1165" class="difflineplus">+     *     Pass 1 to leave just the top-level generator intact.</span>
<a href="#l30.1166"></a><span id="l30.1166">      */</span>
<a href="#l30.1167"></a><span id="l30.1167">     cleanup: function gloda_index_callbackhandle_cleanup(aOptionalStopAtDepth) {</span>
<a href="#l30.1168"></a><span id="l30.1168">       if (aOptionalStopAtDepth === undefined)</span>
<a href="#l30.1169"></a><span id="l30.1169">         aOptionalStopAtDepth = 0;</span>
<a href="#l30.1170"></a><span id="l30.1170">       while (this.activeStack.length &gt; aOptionalStopAtDepth) {</span>
<a href="#l30.1171"></a><span id="l30.1171">         this.pop();</span>
<a href="#l30.1172"></a><span id="l30.1172">       }</span>
<a href="#l30.1173"></a><span id="l30.1173">     },</span>
<a href="#l30.1174"></a><span id="l30.1174" class="difflineplus">+    /**</span>
<a href="#l30.1175"></a><span id="l30.1175" class="difflineplus">+     * For use when a generator finishes up by calling |doneWithResult| on us;</span>
<a href="#l30.1176"></a><span id="l30.1176" class="difflineplus">+     *  the async driver calls this to pop that generator off the stack</span>
<a href="#l30.1177"></a><span id="l30.1177" class="difflineplus">+     *  and get the result it passed in to its call to |doneWithResult|.</span>
<a href="#l30.1178"></a><span id="l30.1178" class="difflineplus">+     *</span>
<a href="#l30.1179"></a><span id="l30.1179" class="difflineplus">+     * @protected</span>
<a href="#l30.1180"></a><span id="l30.1180" class="difflineplus">+     */</span>
<a href="#l30.1181"></a><span id="l30.1181">     popWithResult: function gloda_index_callbackhandle_popWithResult() {</span>
<a href="#l30.1182"></a><span id="l30.1182">       this.pop();</span>
<a href="#l30.1183"></a><span id="l30.1183">       let result = this._result;</span>
<a href="#l30.1184"></a><span id="l30.1184">       this._result = null;</span>
<a href="#l30.1185"></a><span id="l30.1185">       return result;</span>
<a href="#l30.1186"></a><span id="l30.1186">     },</span>
<a href="#l30.1187"></a><span id="l30.1187">     _result: null,</span>
<a href="#l30.1188"></a><span id="l30.1188" class="difflineplus">+    /**</span>
<a href="#l30.1189"></a><span id="l30.1189" class="difflineplus">+     * For use by generators that want to return a result to the calling</span>
<a href="#l30.1190"></a><span id="l30.1190" class="difflineplus">+     *  asynchronous generator.  Specifically, they should do</span>
<a href="#l30.1191"></a><span id="l30.1191" class="difflineplus">+     *  &quot;yield aCallbackHandle.doneWithResult(RESULT);&quot;.</span>
<a href="#l30.1192"></a><span id="l30.1192" class="difflineplus">+     *</span>
<a href="#l30.1193"></a><span id="l30.1193" class="difflineplus">+     * @public</span>
<a href="#l30.1194"></a><span id="l30.1194" class="difflineplus">+     */</span>
<a href="#l30.1195"></a><span id="l30.1195">     doneWithResult: function gloda_index_callbackhandle_doneWithResult(aResult){</span>
<a href="#l30.1196"></a><span id="l30.1196">       this._result = aResult;</span>
<a href="#l30.1197"></a><span id="l30.1197">       return Gloda.kWorkDoneWithResult;</span>
<a href="#l30.1198"></a><span id="l30.1198">     },</span>
<a href="#l30.1199"></a><span id="l30.1199"> </span>
<a href="#l30.1200"></a><span id="l30.1200">     /* be able to serve as a collection listener, resuming the active iterator's</span>
<a href="#l30.1201"></a><span id="l30.1201">        last yield kWorkAsync */</span>
<a href="#l30.1202"></a><span id="l30.1202">     onItemsAdded: function() {},</span>
<a href="#l30.1203"></a><span id="l30.1203" class="difflineat">@@ -1389,17 +1027,18 @@ var GlodaIndexer = {</span>
<a href="#l30.1204"></a><span id="l30.1204">         }</span>
<a href="#l30.1205"></a><span id="l30.1205">         batchCount++;</span>
<a href="#l30.1206"></a><span id="l30.1206"> </span>
<a href="#l30.1207"></a><span id="l30.1207">         // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l30.1208"></a><span id="l30.1208">         //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l30.1209"></a><span id="l30.1209">         //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l30.1210"></a><span id="l30.1210">         //  tokens.)</span>
<a href="#l30.1211"></a><span id="l30.1211">         try {</span>
<a href="#l30.1212"></a><span id="l30.1212" class="difflineminus">-          switch (this._callbackHandle.activeIterator.send(this._workBatchData)) {</span>
<a href="#l30.1213"></a><span id="l30.1213" class="difflineplus">+          switch (this._callbackHandle.activeIterator.send(</span>
<a href="#l30.1214"></a><span id="l30.1214" class="difflineplus">+                    this._workBatchData)) {</span>
<a href="#l30.1215"></a><span id="l30.1215">             case this.kWorkSync:</span>
<a href="#l30.1216"></a><span id="l30.1216">               this._workBatchData = undefined;</span>
<a href="#l30.1217"></a><span id="l30.1217">               break;</span>
<a href="#l30.1218"></a><span id="l30.1218">             case this.kWorkAsync:</span>
<a href="#l30.1219"></a><span id="l30.1219">               this._workBatchData = yield this.kWorkAsync;</span>
<a href="#l30.1220"></a><span id="l30.1220">               break;</span>
<a href="#l30.1221"></a><span id="l30.1221">             case this.kWorkDone:</span>
<a href="#l30.1222"></a><span id="l30.1222">               this._callbackHandle.pop();</span>
<a href="#l30.1223"></a><span id="l30.1223" class="difflineat">@@ -1408,45 +1047,60 @@ var GlodaIndexer = {</span>
<a href="#l30.1224"></a><span id="l30.1224">             case this.kWorkDoneWithResult:</span>
<a href="#l30.1225"></a><span id="l30.1225">               this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l30.1226"></a><span id="l30.1226">               break;</span>
<a href="#l30.1227"></a><span id="l30.1227">             default:</span>
<a href="#l30.1228"></a><span id="l30.1228">               break;</span>
<a href="#l30.1229"></a><span id="l30.1229">           }</span>
<a href="#l30.1230"></a><span id="l30.1230">         }</span>
<a href="#l30.1231"></a><span id="l30.1231">         catch (ex) {</span>
<a href="#l30.1232"></a><span id="l30.1232" class="difflineminus">-          // Try and recover if the job is recoverable and the iterator that</span>
<a href="#l30.1233"></a><span id="l30.1233" class="difflineminus">-          //  experienced the problem wasn't the job worker.  (If it was the</span>
<a href="#l30.1234"></a><span id="l30.1234" class="difflineminus">-          //  job worker, we can't rely on its state to be intact.)</span>
<a href="#l30.1235"></a><span id="l30.1235" class="difflineminus">-          if (this._curIndexingJob.recoverable &gt; 0 &amp;&amp;</span>
<a href="#l30.1236"></a><span id="l30.1236" class="difflineminus">-              this._callbackHandle.activeStack.length &gt; 1) {</span>
<a href="#l30.1237"></a><span id="l30.1237" class="difflineminus">-            this._curIndexingJob.recoverable--;</span>
<a href="#l30.1238"></a><span id="l30.1238" class="difflineminus">-            this._log.warn(&quot;Problem during &quot; + this._curIndexingJob +</span>
<a href="#l30.1239"></a><span id="l30.1239" class="difflineminus">-              &quot;, trying to recover.  Problem was at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l30.1240"></a><span id="l30.1240" class="difflineminus">-              ex.lineNumber + &quot;: &quot; + ex +</span>
<a href="#l30.1241"></a><span id="l30.1241" class="difflineminus">-              (ex.stack ? (&quot;. Stack:\n  &quot; + ex.stack.replace(&quot;\n&quot;, &quot;\n  &quot;, &quot;g&quot;))</span>
<a href="#l30.1242"></a><span id="l30.1242" class="difflineminus">-                        : &quot;&quot;));</span>
<a href="#l30.1243"></a><span id="l30.1243" class="difflineminus">-            // cleanup but leave the job's iterator intact.</span>
<a href="#l30.1244"></a><span id="l30.1244" class="difflineminus">-            this._callbackHandle.cleanup(1);</span>
<a href="#l30.1245"></a><span id="l30.1245" class="difflineminus">-            // the data must now be invalid</span>
<a href="#l30.1246"></a><span id="l30.1246" class="difflineminus">-            this._workBatchData = undefined;</span>
<a href="#l30.1247"></a><span id="l30.1247" class="difflineplus">+          let workerDef = this._curIndexingJob._workerDef;</span>
<a href="#l30.1248"></a><span id="l30.1248" class="difflineplus">+          if (workerDef.recover) {</span>
<a href="#l30.1249"></a><span id="l30.1249" class="difflineplus">+            let recoverToDepth =</span>
<a href="#l30.1250"></a><span id="l30.1250" class="difflineplus">+              workerDef.recover.call(workerDef.indexer,</span>
<a href="#l30.1251"></a><span id="l30.1251" class="difflineplus">+                                     this._curIndexingJob,</span>
<a href="#l30.1252"></a><span id="l30.1252" class="difflineplus">+                                     this._callbackHandle.contextStack);</span>
<a href="#l30.1253"></a><span id="l30.1253" class="difflineplus">+            if (this._unitTestHookRecover)</span>
<a href="#l30.1254"></a><span id="l30.1254" class="difflineplus">+              this._unitTestHookRecover(recoverToDepth, ex,</span>
<a href="#l30.1255"></a><span id="l30.1255" class="difflineplus">+                                        this._curIndexingJob,</span>
<a href="#l30.1256"></a><span id="l30.1256" class="difflineplus">+                                        this._callbackHandle);</span>
<a href="#l30.1257"></a><span id="l30.1257" class="difflineplus">+</span>
<a href="#l30.1258"></a><span id="l30.1258" class="difflineplus">+            if (recoverToDepth) {</span>
<a href="#l30.1259"></a><span id="l30.1259" class="difflineplus">+              this._callbackHandle.cleanup(recoverToDepth);</span>
<a href="#l30.1260"></a><span id="l30.1260" class="difflineplus">+              continue;</span>
<a href="#l30.1261"></a><span id="l30.1261" class="difflineplus">+            }</span>
<a href="#l30.1262"></a><span id="l30.1262" class="difflineplus">+          }</span>
<a href="#l30.1263"></a><span id="l30.1263" class="difflineplus">+          // (we either did not have a recover handler or it couldn't recover)</span>
<a href="#l30.1264"></a><span id="l30.1264" class="difflineplus">+          // call the cleanup helper if there is one</span>
<a href="#l30.1265"></a><span id="l30.1265" class="difflineplus">+          if (workerDef.cleanup) {</span>
<a href="#l30.1266"></a><span id="l30.1266" class="difflineplus">+            workerDef.cleanup.call(workerDef.indexer, this._curIndexingJob);</span>
<a href="#l30.1267"></a><span id="l30.1267" class="difflineplus">+            if (this._unitTestHookCleanup)</span>
<a href="#l30.1268"></a><span id="l30.1268" class="difflineplus">+              this._unitTestHookCleanup(true, ex, this._curIndexingJob,</span>
<a href="#l30.1269"></a><span id="l30.1269" class="difflineplus">+                                        this._callbackHandle);</span>
<a href="#l30.1270"></a><span id="l30.1270">           }</span>
<a href="#l30.1271"></a><span id="l30.1271">           else {</span>
<a href="#l30.1272"></a><span id="l30.1272" class="difflineminus">-            this._log.warn(&quot;Problem during &quot; + this._curIndexingJob +</span>
<a href="#l30.1273"></a><span id="l30.1273" class="difflineminus">-              &quot;, bailing.  Problem was at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l30.1274"></a><span id="l30.1274" class="difflineminus">-              ex.lineNumber + &quot;: &quot; + ex +</span>
<a href="#l30.1275"></a><span id="l30.1275" class="difflineminus">-              (ex.stack ? (&quot;. Stack:\n  &quot; + ex.stack.replace(&quot;\n&quot;, &quot;\n  &quot;, &quot;g&quot;))</span>
<a href="#l30.1276"></a><span id="l30.1276" class="difflineminus">-                        : &quot;&quot;));</span>
<a href="#l30.1277"></a><span id="l30.1277" class="difflineminus">-            // make sure we no longer have a current folder</span>
<a href="#l30.1278"></a><span id="l30.1278" class="difflineminus">-            this._indexerLeaveFolder(true);</span>
<a href="#l30.1279"></a><span id="l30.1279" class="difflineminus">-            this._curIndexingJob = null;</span>
<a href="#l30.1280"></a><span id="l30.1280" class="difflineminus">-            // clear out our current generators and our related data</span>
<a href="#l30.1281"></a><span id="l30.1281" class="difflineminus">-            this._callbackHandle.cleanup();</span>
<a href="#l30.1282"></a><span id="l30.1282" class="difflineminus">-            this._workBatchData = undefined;</span>
<a href="#l30.1283"></a><span id="l30.1283" class="difflineplus">+            if (this._unitTestHookCleanup)</span>
<a href="#l30.1284"></a><span id="l30.1284" class="difflineplus">+              this._unitTestHookCleanup(false, ex, this._curIndexingJob,</span>
<a href="#l30.1285"></a><span id="l30.1285" class="difflineplus">+                                        this._callbackHandle);</span>
<a href="#l30.1286"></a><span id="l30.1286">           }</span>
<a href="#l30.1287"></a><span id="l30.1287" class="difflineplus">+</span>
<a href="#l30.1288"></a><span id="l30.1288" class="difflineplus">+          // Clean out everything on the async stack, warn about the job, kill.</span>
<a href="#l30.1289"></a><span id="l30.1289" class="difflineplus">+          // We do not log this warning lightly; it will break unit tests and</span>
<a href="#l30.1290"></a><span id="l30.1290" class="difflineplus">+          //  be visible to users.  Anything expected should likely have a</span>
<a href="#l30.1291"></a><span id="l30.1291" class="difflineplus">+          //  recovery function or the cleanup logic should be extended to</span>
<a href="#l30.1292"></a><span id="l30.1292" class="difflineplus">+          //  indicate that the failure is acceptable.</span>
<a href="#l30.1293"></a><span id="l30.1293" class="difflineplus">+          this._callbackHandle.cleanup();</span>
<a href="#l30.1294"></a><span id="l30.1294" class="difflineplus">+          this._log.warn(&quot;Problem during &quot; + this._curIndexingJob +</span>
<a href="#l30.1295"></a><span id="l30.1295" class="difflineplus">+            &quot;, bailing.  Problem was at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l30.1296"></a><span id="l30.1296" class="difflineplus">+            ex.lineNumber + &quot;: &quot; + ex +</span>
<a href="#l30.1297"></a><span id="l30.1297" class="difflineplus">+            (ex.stack ? (&quot;. Stack:\n  &quot; + ex.stack.replace(&quot;\n&quot;, &quot;\n  &quot;, &quot;g&quot;))</span>
<a href="#l30.1298"></a><span id="l30.1298" class="difflineplus">+                      : &quot;&quot;));</span>
<a href="#l30.1299"></a><span id="l30.1299" class="difflineplus">+          this._curIndexingJob = null;</span>
<a href="#l30.1300"></a><span id="l30.1300" class="difflineplus">+          // the data must now be invalid</span>
<a href="#l30.1301"></a><span id="l30.1301" class="difflineplus">+          this._workBatchData = undefined;</span>
<a href="#l30.1302"></a><span id="l30.1302">         }</span>
<a href="#l30.1303"></a><span id="l30.1303">       }</span>
<a href="#l30.1304"></a><span id="l30.1304">       this._perfIndexStopwatch.stop();</span>
<a href="#l30.1305"></a><span id="l30.1305"> </span>
<a href="#l30.1306"></a><span id="l30.1306">       // We want to stop ASAP when leaving idle, so we can't rely on the</span>
<a href="#l30.1307"></a><span id="l30.1307">       // standard polled callback. We do the polling ourselves.</span>
<a href="#l30.1308"></a><span id="l30.1308">       if (this._idleService.idleTime &lt; this._INDEX_IDLE_ADJUSTMENT_TIME) {</span>
<a href="#l30.1309"></a><span id="l30.1309">         inIdle = false;</span>
<a href="#l30.1310"></a><span id="l30.1310" class="difflineat">@@ -1510,28 +1164,27 @@ var GlodaIndexer = {</span>
<a href="#l30.1311"></a><span id="l30.1311">       // Commit tends to cause a brief UI pause, so we try to delay it (but not</span>
<a href="#l30.1312"></a><span id="l30.1312">       //  forever) if the user is active. If we're done and idling, we'll also</span>
<a href="#l30.1313"></a><span id="l30.1313">       //  commit, otherwise we'll let the idle callback do it.</span>
<a href="#l30.1314"></a><span id="l30.1314">       let doCommit = transactionToCommit &amp;&amp;</span>
<a href="#l30.1315"></a><span id="l30.1315">                       (elapsed &gt; this._MAXIMUM_COMMIT_TIME) ||</span>
<a href="#l30.1316"></a><span id="l30.1316">                       (inIdle &amp;&amp; (elapsed &gt; this._MINIMUM_COMMIT_TIME ||</span>
<a href="#l30.1317"></a><span id="l30.1317">                                   !haveMoreWork));</span>
<a href="#l30.1318"></a><span id="l30.1318">       if (doCommit) {</span>
<a href="#l30.1319"></a><span id="l30.1319" class="difflineminus">-        // XXX doing the dirty commit/check every time could be pretty expensive...</span>
<a href="#l30.1320"></a><span id="l30.1320">         GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l30.1321"></a><span id="l30.1321" class="difflineminus">-        // Set up an async notification to happen after the commit completes so that</span>
<a href="#l30.1322"></a><span id="l30.1322" class="difflineminus">-        //  we can avoid the indexer doing something with the database that causes the</span>
<a href="#l30.1323"></a><span id="l30.1323" class="difflineminus">-        //  main thread to block against the completion of the commit (which can be</span>
<a href="#l30.1324"></a><span id="l30.1324" class="difflineminus">-        //  a while) on 1.9.1.</span>
<a href="#l30.1325"></a><span id="l30.1325" class="difflineplus">+        // Set up an async notification to happen after the commit completes so</span>
<a href="#l30.1326"></a><span id="l30.1326" class="difflineplus">+        //  that we can avoid the indexer doing something with the database that</span>
<a href="#l30.1327"></a><span id="l30.1327" class="difflineplus">+        //  causes the main thread to block against the completion of the commit</span>
<a href="#l30.1328"></a><span id="l30.1328" class="difflineplus">+        //  (which can be a while) on 1.9.1.</span>
<a href="#l30.1329"></a><span id="l30.1329">         GlodaDatastore.runPostCommit(this._callbackHandle.wrappedCallback);</span>
<a href="#l30.1330"></a><span id="l30.1330">         // kick off the commit</span>
<a href="#l30.1331"></a><span id="l30.1331">         GlodaDatastore._commitTransaction();</span>
<a href="#l30.1332"></a><span id="l30.1332">         yield this.kWorkAsync;</span>
<a href="#l30.1333"></a><span id="l30.1333" class="difflineminus">-        // Let's do the GC after the commit completes just so we can avoid having any</span>
<a href="#l30.1334"></a><span id="l30.1334" class="difflineminus">-        //  ugly interactions.</span>
<a href="#l30.1335"></a><span id="l30.1335" class="difflineplus">+        // Let's do the GC after the commit completes just so we can avoid</span>
<a href="#l30.1336"></a><span id="l30.1336" class="difflineplus">+        //  having any ugly interactions.</span>
<a href="#l30.1337"></a><span id="l30.1337">         GlodaUtils.forceGarbageCollection(false);</span>
<a href="#l30.1338"></a><span id="l30.1338">         this._lastCommitTime = Date.now();</span>
<a href="#l30.1339"></a><span id="l30.1339">         // Restart the transaction if we still have work.</span>
<a href="#l30.1340"></a><span id="l30.1340">         if (haveMoreWork)</span>
<a href="#l30.1341"></a><span id="l30.1341">           GlodaDatastore._beginTransaction();</span>
<a href="#l30.1342"></a><span id="l30.1342">         else</span>
<a href="#l30.1343"></a><span id="l30.1343">           transactionToCommit = false;</span>
<a href="#l30.1344"></a><span id="l30.1344">       }</span>
<a href="#l30.1345"></a><span id="l30.1345" class="difflineat">@@ -1546,478 +1199,156 @@ var GlodaIndexer = {</span>
<a href="#l30.1346"></a><span id="l30.1346">     // If we still have a transaction to commit, tell idle to do the commit</span>
<a href="#l30.1347"></a><span id="l30.1347">     //  when it gets around to it.</span>
<a href="#l30.1348"></a><span id="l30.1348">     if (transactionToCommit)</span>
<a href="#l30.1349"></a><span id="l30.1349">       this._idleToCommit = true;</span>
<a href="#l30.1350"></a><span id="l30.1350"> </span>
<a href="#l30.1351"></a><span id="l30.1351">     yield this.kWorkDone;</span>
<a href="#l30.1352"></a><span id="l30.1352">   },</span>
<a href="#l30.1353"></a><span id="l30.1353"> </span>
<a href="#l30.1354"></a><span id="l30.1354" class="difflineminus">-  _otherIndexerWorkers: {},</span>
<a href="#l30.1355"></a><span id="l30.1355" class="difflineplus">+  /**</span>
<a href="#l30.1356"></a><span id="l30.1356" class="difflineplus">+   * Maps indexing job type names to a worker definition.</span>
<a href="#l30.1357"></a><span id="l30.1357" class="difflineplus">+   * The worker definition is an object with the following attributes where</span>
<a href="#l30.1358"></a><span id="l30.1358" class="difflineplus">+   *  only worker is required:</span>
<a href="#l30.1359"></a><span id="l30.1359" class="difflineplus">+   * - worker:</span>
<a href="#l30.1360"></a><span id="l30.1360" class="difflineplus">+   * - onSchedule: A function to be invoked when the worker is scheduled.  The</span>
<a href="#l30.1361"></a><span id="l30.1361" class="difflineplus">+   *    job is passed as an argument.</span>
<a href="#l30.1362"></a><span id="l30.1362" class="difflineplus">+   * - recover:</span>
<a href="#l30.1363"></a><span id="l30.1363" class="difflineplus">+   * - cleanup:</span>
<a href="#l30.1364"></a><span id="l30.1364" class="difflineplus">+   */</span>
<a href="#l30.1365"></a><span id="l30.1365" class="difflineplus">+  _indexerWorkerDefs: {},</span>
<a href="#l30.1366"></a><span id="l30.1366">   /**</span>
<a href="#l30.1367"></a><span id="l30.1367">    * Perform the initialization step and return a generator if there is any</span>
<a href="#l30.1368"></a><span id="l30.1368">    *  steady-state processing to be had.</span>
<a href="#l30.1369"></a><span id="l30.1369">    */</span>
<a href="#l30.1370"></a><span id="l30.1370">   _hireJobWorker: function gloda_index_hireJobWorker() {</span>
<a href="#l30.1371"></a><span id="l30.1371" class="difflineplus">+    // In no circumstances should there be data bouncing around from previous</span>
<a href="#l30.1372"></a><span id="l30.1372" class="difflineplus">+    //  calls if we are here.  |killActiveJob| depends on this.</span>
<a href="#l30.1373"></a><span id="l30.1373" class="difflineplus">+    this._workBatchData = undefined;</span>
<a href="#l30.1374"></a><span id="l30.1374" class="difflineplus">+</span>
<a href="#l30.1375"></a><span id="l30.1375">     if (this._indexQueue.length == 0) {</span>
<a href="#l30.1376"></a><span id="l30.1376">       this._log.info(&quot;--- Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l30.1377"></a><span id="l30.1377"> </span>
<a href="#l30.1378"></a><span id="l30.1378" class="difflineminus">-      if (this._indexingFolder !== null) {</span>
<a href="#l30.1379"></a><span id="l30.1379" class="difflineminus">-        this._indexerLeaveFolder(true);</span>
<a href="#l30.1380"></a><span id="l30.1380" class="difflineminus">-      }</span>
<a href="#l30.1381"></a><span id="l30.1381" class="difflineminus">-</span>
<a href="#l30.1382"></a><span id="l30.1382">       this._curIndexingJob = null;</span>
<a href="#l30.1383"></a><span id="l30.1383">       this._indexingDesired = false;</span>
<a href="#l30.1384"></a><span id="l30.1384">       this._indexingJobCount = 0;</span>
<a href="#l30.1385"></a><span id="l30.1385" class="difflineminus">-      this._indexingJobGoal = 0;</span>
<a href="#l30.1386"></a><span id="l30.1386">       return false;</span>
<a href="#l30.1387"></a><span id="l30.1387">     }</span>
<a href="#l30.1388"></a><span id="l30.1388"> </span>
<a href="#l30.1389"></a><span id="l30.1389" class="difflineminus">-    //this._log.debug(&quot;++ Pulling job from queue of size &quot; +</span>
<a href="#l30.1390"></a><span id="l30.1390" class="difflineminus">-    //                this._indexQueue.length);</span>
<a href="#l30.1391"></a><span id="l30.1391">     let job = this._curIndexingJob = this._indexQueue.shift();</span>
<a href="#l30.1392"></a><span id="l30.1392">     this._indexingJobCount++;</span>
<a href="#l30.1393"></a><span id="l30.1393" class="difflineminus">-    //this._log.debug(&quot;++ Pulled job: &quot; + job.jobType + &quot;, &quot; +</span>
<a href="#l30.1394"></a><span id="l30.1394" class="difflineminus">-    //                job.deltaType + &quot;, &quot; + job.id);</span>
<a href="#l30.1395"></a><span id="l30.1395" class="difflineplus">+</span>
<a href="#l30.1396"></a><span id="l30.1396">     let generator = null;</span>
<a href="#l30.1397"></a><span id="l30.1397"> </span>
<a href="#l30.1398"></a><span id="l30.1398" class="difflineminus">-    if (job.jobType == &quot;sweep&quot;) {</span>
<a href="#l30.1399"></a><span id="l30.1399" class="difflineminus">-      generator = this._worker_indexingSweep(job);</span>
<a href="#l30.1400"></a><span id="l30.1400" class="difflineminus">-    }</span>
<a href="#l30.1401"></a><span id="l30.1401" class="difflineminus">-    else if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l30.1402"></a><span id="l30.1402" class="difflineminus">-      generator = this._worker_folderIndex(job);</span>
<a href="#l30.1403"></a><span id="l30.1403" class="difflineminus">-    }</span>
<a href="#l30.1404"></a><span id="l30.1404" class="difflineminus">-    else if(job.jobType == &quot;message&quot;) {</span>
<a href="#l30.1405"></a><span id="l30.1405" class="difflineminus">-      // we do not want new work items to be added as we are processing, so</span>
<a href="#l30.1406"></a><span id="l30.1406" class="difflineminus">-      //  clear _pendingAddJob.  A new job will be created as needed.</span>
<a href="#l30.1407"></a><span id="l30.1407" class="difflineminus">-      if (job === this._pendingAddJob)</span>
<a href="#l30.1408"></a><span id="l30.1408" class="difflineminus">-        this._pendingAddJob = null;</span>
<a href="#l30.1409"></a><span id="l30.1409" class="difflineminus">-      // update our goal from the items length</span>
<a href="#l30.1410"></a><span id="l30.1410" class="difflineminus">-      job.goal = job.items.length;</span>
<a href="#l30.1411"></a><span id="l30.1411" class="difflineplus">+    if (job.jobType in this._indexerWorkerDefs) {</span>
<a href="#l30.1412"></a><span id="l30.1412" class="difflineplus">+      let workerDef = this._indexerWorkerDefs[job.jobType];</span>
<a href="#l30.1413"></a><span id="l30.1413" class="difflineplus">+      job._workerDef = workerDef;</span>
<a href="#l30.1414"></a><span id="l30.1414"> </span>
<a href="#l30.1415"></a><span id="l30.1415" class="difflineminus">-      generator = this._worker_messageIndex(job);</span>
<a href="#l30.1416"></a><span id="l30.1416" class="difflineminus">-    }</span>
<a href="#l30.1417"></a><span id="l30.1417" class="difflineminus">-    else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l30.1418"></a><span id="l30.1418" class="difflineminus">-      // we'll count the block processing as a cost of 1...</span>
<a href="#l30.1419"></a><span id="l30.1419" class="difflineminus">-      job.goal = 1;</span>
<a href="#l30.1420"></a><span id="l30.1420" class="difflineminus">-      generator = this._worker_processDeletes(job);</span>
<a href="#l30.1421"></a><span id="l30.1421" class="difflineminus">-    }</span>
<a href="#l30.1422"></a><span id="l30.1422" class="difflineminus">-    else if (job.jobType in this._otherIndexerWorkers) {</span>
<a href="#l30.1423"></a><span id="l30.1423" class="difflineminus">-      let [indexer, workerFunc] = this._otherIndexerWorkers[job.jobType];</span>
<a href="#l30.1424"></a><span id="l30.1424" class="difflineminus">-      generator = workerFunc.call(indexer, job, this._callbackHandle);</span>
<a href="#l30.1425"></a><span id="l30.1425" class="difflineplus">+      // Prior to creating the worker, call the scheduling trigger function</span>
<a href="#l30.1426"></a><span id="l30.1426" class="difflineplus">+      //  if there is one.  This is so that jobs can be finalized.  The</span>
<a href="#l30.1427"></a><span id="l30.1427" class="difflineplus">+      //  initial use case is event-driven message indexing that accumulates</span>
<a href="#l30.1428"></a><span id="l30.1428" class="difflineplus">+      //  a list of messages to index but wants it locked down once we start</span>
<a href="#l30.1429"></a><span id="l30.1429" class="difflineplus">+      //  processing the list.</span>
<a href="#l30.1430"></a><span id="l30.1430" class="difflineplus">+      if (workerDef.onSchedule)</span>
<a href="#l30.1431"></a><span id="l30.1431" class="difflineplus">+        workerDef.onSchedule.call(workerDef.indexer, job);</span>
<a href="#l30.1432"></a><span id="l30.1432" class="difflineplus">+</span>
<a href="#l30.1433"></a><span id="l30.1433" class="difflineplus">+      generator = workerDef.worker.call(workerDef.indexer, job,</span>
<a href="#l30.1434"></a><span id="l30.1434" class="difflineplus">+                                        this._callbackHandle);</span>
<a href="#l30.1435"></a><span id="l30.1435">     }</span>
<a href="#l30.1436"></a><span id="l30.1436">     else {</span>
<a href="#l30.1437"></a><span id="l30.1437" class="difflineminus">-      this._log.warn(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l30.1438"></a><span id="l30.1438" class="difflineplus">+      // Nothing we can do about this.  Be loud about it and try to schedule</span>
<a href="#l30.1439"></a><span id="l30.1439" class="difflineplus">+      //  something else.</span>
<a href="#l30.1440"></a><span id="l30.1440" class="difflineplus">+      this._log.error(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l30.1441"></a><span id="l30.1441" class="difflineplus">+      return this._hireJobWorker();</span>
<a href="#l30.1442"></a><span id="l30.1442">     }</span>
<a href="#l30.1443"></a><span id="l30.1443"> </span>
<a href="#l30.1444"></a><span id="l30.1444" class="difflineplus">+    if (this._unitTestSuperVerbose)</span>
<a href="#l30.1445"></a><span id="l30.1445" class="difflineplus">+      this._log.debug(&quot;Hired job of type: &quot; + job.jobType);</span>
<a href="#l30.1446"></a><span id="l30.1446" class="difflineplus">+</span>
<a href="#l30.1447"></a><span id="l30.1447">     this._notifyListeners();</span>
<a href="#l30.1448"></a><span id="l30.1448"> </span>
<a href="#l30.1449"></a><span id="l30.1449">     if (generator) {</span>
<a href="#l30.1450"></a><span id="l30.1450">       this._callbackHandle.push(generator);</span>
<a href="#l30.1451"></a><span id="l30.1451">       return true;</span>
<a href="#l30.1452"></a><span id="l30.1452">     }</span>
<a href="#l30.1453"></a><span id="l30.1453">     else</span>
<a href="#l30.1454"></a><span id="l30.1454">       return false;</span>
<a href="#l30.1455"></a><span id="l30.1455">   },</span>
<a href="#l30.1456"></a><span id="l30.1456"> </span>
<a href="#l30.1457"></a><span id="l30.1457">   /**</span>
<a href="#l30.1458"></a><span id="l30.1458" class="difflineminus">-   * Performs the folder sweep, locating folders that should be indexed, and</span>
<a href="#l30.1459"></a><span id="l30.1459" class="difflineminus">-   *  creating a folder indexing job for them, and rescheduling itself for</span>
<a href="#l30.1460"></a><span id="l30.1460" class="difflineminus">-   *  execution after that job is completed.  Once it indexes all the folders,</span>
<a href="#l30.1461"></a><span id="l30.1461" class="difflineminus">-   *  if we believe we have deletions to process (or just don't know), it kicks</span>
<a href="#l30.1462"></a><span id="l30.1462" class="difflineminus">-   *  off a deletion processing job.</span>
<a href="#l30.1463"></a><span id="l30.1463" class="difflineminus">-   *</span>
<a href="#l30.1464"></a><span id="l30.1464" class="difflineminus">-   * Folder traversal logic is based off the spotlight/vista indexer code; we</span>
<a href="#l30.1465"></a><span id="l30.1465" class="difflineminus">-   *  retrieve the list of servers and folders each time want to find a new</span>
<a href="#l30.1466"></a><span id="l30.1466" class="difflineminus">-   *  folder to index.  This avoids needing to maintain a perfect model of the</span>
<a href="#l30.1467"></a><span id="l30.1467" class="difflineminus">-   *  folder hierarchy at all times.  (We may eventually want to do that, but</span>
<a href="#l30.1468"></a><span id="l30.1468" class="difflineminus">-   *  this is sufficient and safe for now.)  Although our use of dirty flags on</span>
<a href="#l30.1469"></a><span id="l30.1469" class="difflineminus">-   *  the folders allows us to avoid tracking the 'last folder' we processed,</span>
<a href="#l30.1470"></a><span id="l30.1470" class="difflineminus">-   *  we do so to avoid getting 'trapped' in a folder with a high rate of</span>
<a href="#l30.1471"></a><span id="l30.1471" class="difflineminus">-   *  changes.</span>
<a href="#l30.1472"></a><span id="l30.1472" class="difflineminus">-   */</span>
<a href="#l30.1473"></a><span id="l30.1473" class="difflineminus">-  _worker_indexingSweep: function gloda_worker_indexingSweep(aJob) {</span>
<a href="#l30.1474"></a><span id="l30.1474" class="difflineminus">-    if (!aJob.mappedFolders) {</span>
<a href="#l30.1475"></a><span id="l30.1475" class="difflineminus">-      // Walk the folders and make sure all the folders we would want to index</span>
<a href="#l30.1476"></a><span id="l30.1476" class="difflineminus">-      //  are mapped.  Build up a list of GlodaFolders as we go, so that we can</span>
<a href="#l30.1477"></a><span id="l30.1477" class="difflineminus">-      //  sort them by their indexing priority.</span>
<a href="#l30.1478"></a><span id="l30.1478" class="difflineminus">-      let foldersToProcess = aJob.foldersToProcess = [];</span>
<a href="#l30.1479"></a><span id="l30.1479" class="difflineminus">-</span>
<a href="#l30.1480"></a><span id="l30.1480" class="difflineminus">-      let accountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l30.1481"></a><span id="l30.1481" class="difflineminus">-                           getService(Ci.nsIMsgAccountManager);</span>
<a href="#l30.1482"></a><span id="l30.1482" class="difflineminus">-      let servers = accountManager.allServers;</span>
<a href="#l30.1483"></a><span id="l30.1483" class="difflineminus">-      for (let i = 0; i &lt; servers.Count(); i++) {</span>
<a href="#l30.1484"></a><span id="l30.1484" class="difflineminus">-        let server = servers.QueryElementAt(i, Ci.nsIMsgIncomingServer);</span>
<a href="#l30.1485"></a><span id="l30.1485" class="difflineminus">-        let rootFolder = server.rootFolder;</span>
<a href="#l30.1486"></a><span id="l30.1486" class="difflineminus">-</span>
<a href="#l30.1487"></a><span id="l30.1487" class="difflineminus">-        let allFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l30.1488"></a><span id="l30.1488" class="difflineminus">-          createInstance(Ci.nsISupportsArray);</span>
<a href="#l30.1489"></a><span id="l30.1489" class="difflineminus">-        rootFolder.ListDescendents(allFolders);</span>
<a href="#l30.1490"></a><span id="l30.1490" class="difflineminus">-        let numFolders = allFolders.Count();</span>
<a href="#l30.1491"></a><span id="l30.1491" class="difflineminus">-        for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++) {</span>
<a href="#l30.1492"></a><span id="l30.1492" class="difflineminus">-          let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l30.1493"></a><span id="l30.1493" class="difflineminus">-            Ci.nsIMsgFolder);</span>
<a href="#l30.1494"></a><span id="l30.1494" class="difflineminus">-          if (!this.shouldIndexFolder(folder))</span>
<a href="#l30.1495"></a><span id="l30.1495" class="difflineminus">-            continue;</span>
<a href="#l30.1496"></a><span id="l30.1496" class="difflineminus">-</span>
<a href="#l30.1497"></a><span id="l30.1497" class="difflineminus">-          // we only index local or IMAP folders</span>
<a href="#l30.1498"></a><span id="l30.1498" class="difflineminus">-          if (!(folder instanceof Ci.nsIMsgLocalMailFolder) &amp;&amp;</span>
<a href="#l30.1499"></a><span id="l30.1499" class="difflineminus">-              !(folder instanceof Ci.nsIMsgImapMailFolder))</span>
<a href="#l30.1500"></a><span id="l30.1500" class="difflineminus">-            continue;</span>
<a href="#l30.1501"></a><span id="l30.1501" class="difflineminus">-</span>
<a href="#l30.1502"></a><span id="l30.1502" class="difflineminus">-          let glodaFolder = Gloda.getFolderForFolder(folder);</span>
<a href="#l30.1503"></a><span id="l30.1503" class="difflineminus">-          if (glodaFolder.indexingPriority !=</span>
<a href="#l30.1504"></a><span id="l30.1504" class="difflineminus">-              glodaFolder.kIndexingNeverPriority)</span>
<a href="#l30.1505"></a><span id="l30.1505" class="difflineminus">-            foldersToProcess.push(glodaFolder);</span>
<a href="#l30.1506"></a><span id="l30.1506" class="difflineminus">-        }</span>
<a href="#l30.1507"></a><span id="l30.1507" class="difflineminus">-      }</span>
<a href="#l30.1508"></a><span id="l30.1508" class="difflineminus">-</span>
<a href="#l30.1509"></a><span id="l30.1509" class="difflineminus">-      // sort the folders by priority (descending)</span>
<a href="#l30.1510"></a><span id="l30.1510" class="difflineminus">-      foldersToProcess.sort(function (a, b) {</span>
<a href="#l30.1511"></a><span id="l30.1511" class="difflineminus">-        return b.indexingPriority - a.indexingPriority;</span>
<a href="#l30.1512"></a><span id="l30.1512" class="difflineminus">-      });</span>
<a href="#l30.1513"></a><span id="l30.1513" class="difflineminus">-</span>
<a href="#l30.1514"></a><span id="l30.1514" class="difflineminus">-      aJob.mappedFolders = true;</span>
<a href="#l30.1515"></a><span id="l30.1515" class="difflineminus">-    }</span>
<a href="#l30.1516"></a><span id="l30.1516" class="difflineminus">-</span>
<a href="#l30.1517"></a><span id="l30.1517" class="difflineminus">-    // - process the folders (in sorted order)</span>
<a href="#l30.1518"></a><span id="l30.1518" class="difflineminus">-    while (aJob.foldersToProcess.length) {</span>
<a href="#l30.1519"></a><span id="l30.1519" class="difflineminus">-      let glodaFolder = aJob.foldersToProcess.shift();</span>
<a href="#l30.1520"></a><span id="l30.1520" class="difflineminus">-      if (glodaFolder._deleted || !glodaFolder.dirtyStatus)</span>
<a href="#l30.1521"></a><span id="l30.1521" class="difflineminus">-        continue;</span>
<a href="#l30.1522"></a><span id="l30.1522" class="difflineminus">-</span>
<a href="#l30.1523"></a><span id="l30.1523" class="difflineminus">-      this._indexingJobGoal += 2;</span>
<a href="#l30.1524"></a><span id="l30.1524" class="difflineminus">-      // add a job for the folder indexing</span>
<a href="#l30.1525"></a><span id="l30.1525" class="difflineminus">-      this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 0, glodaFolder.id));</span>
<a href="#l30.1526"></a><span id="l30.1526" class="difflineminus">-      // re-schedule this job (although this worker will die)</span>
<a href="#l30.1527"></a><span id="l30.1527" class="difflineminus">-      this._indexQueue.push(aJob);</span>
<a href="#l30.1528"></a><span id="l30.1528" class="difflineminus">-      yield this.kWorkDone;</span>
<a href="#l30.1529"></a><span id="l30.1529" class="difflineminus">-    }</span>
<a href="#l30.1530"></a><span id="l30.1530" class="difflineminus">-</span>
<a href="#l30.1531"></a><span id="l30.1531" class="difflineminus">-    // consider deletion</span>
<a href="#l30.1532"></a><span id="l30.1532" class="difflineminus">-    if (this.pendingDeletion || this.pendingDeletion === null) {</span>
<a href="#l30.1533"></a><span id="l30.1533" class="difflineminus">-      this._indexingJobGoal++;</span>
<a href="#l30.1534"></a><span id="l30.1534" class="difflineminus">-      this._indexQueue.push(new IndexingJob(&quot;delete&quot;, 0, null));</span>
<a href="#l30.1535"></a><span id="l30.1535" class="difflineminus">-      // no need to set this.indexing to true, it must be true if we are here.</span>
<a href="#l30.1536"></a><span id="l30.1536" class="difflineminus">-    }</span>
<a href="#l30.1537"></a><span id="l30.1537" class="difflineminus">-</span>
<a href="#l30.1538"></a><span id="l30.1538" class="difflineminus">-    // if this is our first sweep, give the other indexers a chance to do their</span>
<a href="#l30.1539"></a><span id="l30.1539" class="difflineminus">-    //  own initial sweep.  it's on them to schedule their own job if they have</span>
<a href="#l30.1540"></a><span id="l30.1540" class="difflineminus">-    //  a lot to do, but if they only have a little to do, they can get away</span>
<a href="#l30.1541"></a><span id="l30.1541" class="difflineminus">-    //  with it, as we yield a sync after each one.</span>
<a href="#l30.1542"></a><span id="l30.1542" class="difflineminus">-    if (!this._initialSweepPerformed) {</span>
<a href="#l30.1543"></a><span id="l30.1543" class="difflineminus">-      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l30.1544"></a><span id="l30.1544" class="difflineminus">-        try {</span>
<a href="#l30.1545"></a><span id="l30.1545" class="difflineminus">-          indexer.initialSweep();</span>
<a href="#l30.1546"></a><span id="l30.1546" class="difflineminus">-        }</span>
<a href="#l30.1547"></a><span id="l30.1547" class="difflineminus">-        catch (ex) {</span>
<a href="#l30.1548"></a><span id="l30.1548" class="difflineminus">-          this._log.warn(&quot;Helper indexer threw exception on initial sweep:&quot; +</span>
<a href="#l30.1549"></a><span id="l30.1549" class="difflineminus">-                         ex);</span>
<a href="#l30.1550"></a><span id="l30.1550" class="difflineminus">-        }</span>
<a href="#l30.1551"></a><span id="l30.1551" class="difflineminus">-        yield this.kWorkSync;</span>
<a href="#l30.1552"></a><span id="l30.1552" class="difflineminus">-      }</span>
<a href="#l30.1553"></a><span id="l30.1553" class="difflineminus">-      this._initialSweepPerformed = true;</span>
<a href="#l30.1554"></a><span id="l30.1554" class="difflineminus">-    }</span>
<a href="#l30.1555"></a><span id="l30.1555" class="difflineminus">-</span>
<a href="#l30.1556"></a><span id="l30.1556" class="difflineminus">-    // we don't have any more work to do...</span>
<a href="#l30.1557"></a><span id="l30.1557" class="difflineminus">-    this._indexingSweepActive = false;</span>
<a href="#l30.1558"></a><span id="l30.1558" class="difflineminus">-    yield this.kWorkDone;</span>
<a href="#l30.1559"></a><span id="l30.1559" class="difflineminus">-  },</span>
<a href="#l30.1560"></a><span id="l30.1560" class="difflineminus">-</span>
<a href="#l30.1561"></a><span id="l30.1561" class="difflineminus">-  /**</span>
<a href="#l30.1562"></a><span id="l30.1562" class="difflineminus">-   * Index the contents of a folder.</span>
<a href="#l30.1563"></a><span id="l30.1563" class="difflineplus">+   * Schedule a job for indexing.</span>
<a href="#l30.1564"></a><span id="l30.1564">    */</span>
<a href="#l30.1565"></a><span id="l30.1565" class="difflineminus">-  _worker_folderIndex: function gloda_worker_folderIndex(aJob) {</span>
<a href="#l30.1566"></a><span id="l30.1566" class="difflineminus">-    let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l30.1567"></a><span id="l30.1567" class="difflineminus">-    yield this._indexerEnterFolder(aJob.id);</span>
<a href="#l30.1568"></a><span id="l30.1568" class="difflineminus">-</span>
<a href="#l30.1569"></a><span id="l30.1569" class="difflineminus">-    if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l30.1570"></a><span id="l30.1570" class="difflineminus">-      yield this.kWorkDone;</span>
<a href="#l30.1571"></a><span id="l30.1571" class="difflineminus">-</span>
<a href="#l30.1572"></a><span id="l30.1572" class="difflineminus">-    // Make sure listeners get notified about this job.</span>
<a href="#l30.1573"></a><span id="l30.1573" class="difflineminus">-    this._notifyListeners();</span>
<a href="#l30.1574"></a><span id="l30.1574" class="difflineminus">-</span>
<a href="#l30.1575"></a><span id="l30.1575" class="difflineminus">-    // there is of course a cost to all this header investigation even if we</span>
<a href="#l30.1576"></a><span id="l30.1576" class="difflineminus">-    //  don't do something.  so we will yield with kWorkSync for every block.</span>
<a href="#l30.1577"></a><span id="l30.1577" class="difflineminus">-    const HEADER_CHECK_BLOCK_SIZE = 25;</span>
<a href="#l30.1578"></a><span id="l30.1578" class="difflineminus">-</span>
<a href="#l30.1579"></a><span id="l30.1579" class="difflineminus">-    // we can safely presume if we are here that this folder has been selected</span>
<a href="#l30.1580"></a><span id="l30.1580" class="difflineminus">-    //  for offline processing...</span>
<a href="#l30.1581"></a><span id="l30.1581" class="difflineminus">-</span>
<a href="#l30.1582"></a><span id="l30.1582" class="difflineminus">-    // Handle the filthy case.  A filthy folder may have misleading properties</span>
<a href="#l30.1583"></a><span id="l30.1583" class="difflineminus">-    //  on the message that claim the message is indexed.  They are misleading</span>
<a href="#l30.1584"></a><span id="l30.1584" class="difflineminus">-    //  because the database, for whatever reason, does not have the messages</span>
<a href="#l30.1585"></a><span id="l30.1585" class="difflineminus">-    //  (accurately) indexed.</span>
<a href="#l30.1586"></a><span id="l30.1586" class="difflineminus">-    // We need to walk all the messages and mark them filthy if they have a</span>
<a href="#l30.1587"></a><span id="l30.1587" class="difflineminus">-    //  dirty property.  Once we have done this, we can downgrade the folder's</span>
<a href="#l30.1588"></a><span id="l30.1588" class="difflineminus">-    //  dirty status to plain dirty.  We do this rather than trying to process</span>
<a href="#l30.1589"></a><span id="l30.1589" class="difflineminus">-    //  everyone in one go in a filthy context because if we have to terminate</span>
<a href="#l30.1590"></a><span id="l30.1590" class="difflineminus">-    //  indexing before we quit, we don't want to have to re-index messages next</span>
<a href="#l30.1591"></a><span id="l30.1591" class="difflineminus">-    //  time.  (This could even lead to never completing indexing in a</span>
<a href="#l30.1592"></a><span id="l30.1592" class="difflineminus">-    //  pathological situation.)</span>
<a href="#l30.1593"></a><span id="l30.1593" class="difflineminus">-    let glodaFolder = GlodaDatastore._mapFolder(this._indexingFolder);</span>
<a href="#l30.1594"></a><span id="l30.1594" class="difflineminus">-    if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy) {</span>
<a href="#l30.1595"></a><span id="l30.1595" class="difflineminus">-      this._indexerGetEnumerator(true);</span>
<a href="#l30.1596"></a><span id="l30.1596" class="difflineminus">-      let count = 0;</span>
<a href="#l30.1597"></a><span id="l30.1597" class="difflineminus">-      for (let msgHdr in fixIterator(this._indexingEnumerator,</span>
<a href="#l30.1598"></a><span id="l30.1598" class="difflineminus">-                                     Ci.nsIMsgDBHdr)) {</span>
<a href="#l30.1599"></a><span id="l30.1599" class="difflineminus">-        // we still need to avoid locking up the UI, pause periodically...</span>
<a href="#l30.1600"></a><span id="l30.1600" class="difflineminus">-        if (++count % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l30.1601"></a><span id="l30.1601" class="difflineminus">-          yield this.kWorkSync;</span>
<a href="#l30.1602"></a><span id="l30.1602" class="difflineminus">-</span>
<a href="#l30.1603"></a><span id="l30.1603" class="difflineminus">-        let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l30.1604"></a><span id="l30.1604" class="difflineminus">-          GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l30.1605"></a><span id="l30.1605" class="difflineminus">-        // if it has a gloda message id, we need to mark it filthy</span>
<a href="#l30.1606"></a><span id="l30.1606" class="difflineminus">-        if (glodaMessageId != 0)</span>
<a href="#l30.1607"></a><span id="l30.1607" class="difflineminus">-          msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, this.kMessageFilthy);</span>
<a href="#l30.1608"></a><span id="l30.1608" class="difflineminus">-        // if it doesn't have a gloda message id, we will definitely index it,</span>
<a href="#l30.1609"></a><span id="l30.1609" class="difflineminus">-        //  so no action is required.</span>
<a href="#l30.1610"></a><span id="l30.1610" class="difflineminus">-      }</span>
<a href="#l30.1611"></a><span id="l30.1611" class="difflineminus">-      // this will automatically persist to the database</span>
<a href="#l30.1612"></a><span id="l30.1612" class="difflineminus">-      glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l30.1613"></a><span id="l30.1613" class="difflineminus">-    }</span>
<a href="#l30.1614"></a><span id="l30.1614" class="difflineminus">-</span>
<a href="#l30.1615"></a><span id="l30.1615" class="difflineminus">-    // Pass 1: count the number of messages to index.</span>
<a href="#l30.1616"></a><span id="l30.1616" class="difflineminus">-    //  We do this in order to be able to report to the user what we're doing.</span>
<a href="#l30.1617"></a><span id="l30.1617" class="difflineminus">-    // TODO: give up after reaching a certain number of messages in folders</span>
<a href="#l30.1618"></a><span id="l30.1618" class="difflineminus">-    //  with ridiculous numbers of messages and make the interface just say</span>
<a href="#l30.1619"></a><span id="l30.1619" class="difflineminus">-    //  something like &quot;over N messages to go.&quot;</span>
<a href="#l30.1620"></a><span id="l30.1620" class="difflineminus">-</span>
<a href="#l30.1621"></a><span id="l30.1621" class="difflineminus">-    this._indexerGetEnumerator(false);</span>
<a href="#l30.1622"></a><span id="l30.1622" class="difflineminus">-    let numMessagesToIndex = 0;</span>
<a href="#l30.1623"></a><span id="l30.1623" class="difflineminus">-    let numMessagesOut = {};</span>
<a href="#l30.1624"></a><span id="l30.1624" class="difflineminus">-    // Keep going until we run out of headers.</span>
<a href="#l30.1625"></a><span id="l30.1625" class="difflineminus">-    while (this._indexingFolder.msgDatabase.nextMatchingHdrs(</span>
<a href="#l30.1626"></a><span id="l30.1626" class="difflineminus">-             this._indexingEnumerator,</span>
<a href="#l30.1627"></a><span id="l30.1627" class="difflineminus">-             HEADER_CHECK_BLOCK_SIZE * 8, // this way is much faster, do more</span>
<a href="#l30.1628"></a><span id="l30.1628" class="difflineminus">-             0, // moot, we don't return headers</span>
<a href="#l30.1629"></a><span id="l30.1629" class="difflineminus">-             null, // don't return headers, we just want the count</span>
<a href="#l30.1630"></a><span id="l30.1630" class="difflineminus">-             numMessagesOut)) {</span>
<a href="#l30.1631"></a><span id="l30.1631" class="difflineminus">-      numMessagesToIndex += numMessagesOut.value;</span>
<a href="#l30.1632"></a><span id="l30.1632" class="difflineminus">-      yield this.kWorkSync;</span>
<a href="#l30.1633"></a><span id="l30.1633" class="difflineminus">-    }</span>
<a href="#l30.1634"></a><span id="l30.1634" class="difflineminus">-    numMessagesToIndex += numMessagesOut.value;</span>
<a href="#l30.1635"></a><span id="l30.1635" class="difflineminus">-</span>
<a href="#l30.1636"></a><span id="l30.1636" class="difflineminus">-    aJob.goal = numMessagesToIndex;</span>
<a href="#l30.1637"></a><span id="l30.1637" class="difflineminus">-</span>
<a href="#l30.1638"></a><span id="l30.1638" class="difflineminus">-    if (numMessagesToIndex &gt; 0) {</span>
<a href="#l30.1639"></a><span id="l30.1639" class="difflineminus">-      // We used up the iterator, get a new one.</span>
<a href="#l30.1640"></a><span id="l30.1640" class="difflineminus">-      this._indexerGetEnumerator(false);</span>
<a href="#l30.1641"></a><span id="l30.1641" class="difflineminus">-</span>
<a href="#l30.1642"></a><span id="l30.1642" class="difflineminus">-      // Pass 2: index the messages.</span>
<a href="#l30.1643"></a><span id="l30.1643" class="difflineminus">-      let count = 0;</span>
<a href="#l30.1644"></a><span id="l30.1644" class="difflineminus">-      for (let msgHdr in fixIterator(this._indexingEnumerator,</span>
<a href="#l30.1645"></a><span id="l30.1645" class="difflineminus">-                                     Ci.nsIMsgDBHdr)) {</span>
<a href="#l30.1646"></a><span id="l30.1646" class="difflineminus">-        // per above, we want to periodically release control while doing all</span>
<a href="#l30.1647"></a><span id="l30.1647" class="difflineminus">-        // this header traversal/investigation.</span>
<a href="#l30.1648"></a><span id="l30.1648" class="difflineminus">-        // XXX not clear that this is really needed, since search has its own</span>
<a href="#l30.1649"></a><span id="l30.1649" class="difflineminus">-        // method to yield to UI periodically.</span>
<a href="#l30.1650"></a><span id="l30.1650" class="difflineminus">-        if (++count % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l30.1651"></a><span id="l30.1651" class="difflineminus">-          yield this.kWorkSync;</span>
<a href="#l30.1652"></a><span id="l30.1652" class="difflineminus">-</span>
<a href="#l30.1653"></a><span id="l30.1653" class="difflineminus">-        ++aJob.offset;</span>
<a href="#l30.1654"></a><span id="l30.1654" class="difflineminus">-        if (logDebug)</span>
<a href="#l30.1655"></a><span id="l30.1655" class="difflineminus">-          this._log.debug(&quot;&gt;&gt;&gt;  _indexMessage&quot;);</span>
<a href="#l30.1656"></a><span id="l30.1656" class="difflineminus">-        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l30.1657"></a><span id="l30.1657" class="difflineminus">-            this._callbackHandle));</span>
<a href="#l30.1658"></a><span id="l30.1658" class="difflineminus">-        if (logDebug)</span>
<a href="#l30.1659"></a><span id="l30.1659" class="difflineminus">-          this._log.debug(&quot;&lt;&lt;&lt;  _indexMessage&quot;);</span>
<a href="#l30.1660"></a><span id="l30.1660" class="difflineminus">-      }</span>
<a href="#l30.1661"></a><span id="l30.1661" class="difflineminus">-    }</span>
<a href="#l30.1662"></a><span id="l30.1662" class="difflineminus">-</span>
<a href="#l30.1663"></a><span id="l30.1663" class="difflineminus">-    glodaFolder.dirtyStatus = glodaFolder.kFolderClean;</span>
<a href="#l30.1664"></a><span id="l30.1664" class="difflineminus">-</span>
<a href="#l30.1665"></a><span id="l30.1665" class="difflineminus">-    // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l30.1666"></a><span id="l30.1666" class="difflineminus">-    this._indexerLeaveFolder();</span>
<a href="#l30.1667"></a><span id="l30.1667" class="difflineminus">-</span>
<a href="#l30.1668"></a><span id="l30.1668" class="difflineminus">-    yield this.kWorkDone;</span>
<a href="#l30.1669"></a><span id="l30.1669" class="difflineminus">-  },</span>
<a href="#l30.1670"></a><span id="l30.1670" class="difflineminus">-</span>
<a href="#l30.1671"></a><span id="l30.1671" class="difflineminus">-  /**</span>
<a href="#l30.1672"></a><span id="l30.1672" class="difflineminus">-   * Index a specific list of messages that we know to index from</span>
<a href="#l30.1673"></a><span id="l30.1673" class="difflineminus">-   *  event-notification hints.</span>
<a href="#l30.1674"></a><span id="l30.1674" class="difflineminus">-   */</span>
<a href="#l30.1675"></a><span id="l30.1675" class="difflineminus">-  _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l30.1676"></a><span id="l30.1676" class="difflineminus">-    // if we are already in the correct folder, our &quot;get in the folder&quot; clause</span>
<a href="#l30.1677"></a><span id="l30.1677" class="difflineminus">-    //  will not execute, so we need to make sure this value is accurate in</span>
<a href="#l30.1678"></a><span id="l30.1678" class="difflineminus">-    //  that case.  (and we want to avoid multiple checks...)</span>
<a href="#l30.1679"></a><span id="l30.1679" class="difflineminus">-    for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l30.1680"></a><span id="l30.1680" class="difflineminus">-      let item = aJob.items[aJob.offset];</span>
<a href="#l30.1681"></a><span id="l30.1681" class="difflineminus">-      // item is either [folder ID, message key] or</span>
<a href="#l30.1682"></a><span id="l30.1682" class="difflineminus">-      //                [folder ID, message ID]</span>
<a href="#l30.1683"></a><span id="l30.1683" class="difflineminus">-</span>
<a href="#l30.1684"></a><span id="l30.1684" class="difflineminus">-      // get in the folder</span>
<a href="#l30.1685"></a><span id="l30.1685" class="difflineminus">-      if (!this._indexingGlodaFolder ||</span>
<a href="#l30.1686"></a><span id="l30.1686" class="difflineminus">-          this._indexingGlodaFolder.id != item[0]) {</span>
<a href="#l30.1687"></a><span id="l30.1687" class="difflineminus">-        yield this._indexerEnterFolder(item[0]);</span>
<a href="#l30.1688"></a><span id="l30.1688" class="difflineminus">-</span>
<a href="#l30.1689"></a><span id="l30.1689" class="difflineminus">-        // stay out of folders we should not be in!</span>
<a href="#l30.1690"></a><span id="l30.1690" class="difflineminus">-        if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l30.1691"></a><span id="l30.1691" class="difflineminus">-          continue;</span>
<a href="#l30.1692"></a><span id="l30.1692" class="difflineminus">-      }</span>
<a href="#l30.1693"></a><span id="l30.1693" class="difflineminus">-</span>
<a href="#l30.1694"></a><span id="l30.1694" class="difflineminus">-      let msgHdr;</span>
<a href="#l30.1695"></a><span id="l30.1695" class="difflineminus">-      if (typeof item[1] == &quot;number&quot;)</span>
<a href="#l30.1696"></a><span id="l30.1696" class="difflineminus">-        msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l30.1697"></a><span id="l30.1697" class="difflineminus">-      else</span>
<a href="#l30.1698"></a><span id="l30.1698" class="difflineminus">-        // same deal as in move processing.</span>
<a href="#l30.1699"></a><span id="l30.1699" class="difflineminus">-        // TODO fixme to not assume singular message-id's.</span>
<a href="#l30.1700"></a><span id="l30.1700" class="difflineminus">-        msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l30.1701"></a><span id="l30.1701" class="difflineminus">-</span>
<a href="#l30.1702"></a><span id="l30.1702" class="difflineminus">-      // it needs a header, and the header needs to not be expunged.</span>
<a href="#l30.1703"></a><span id="l30.1703" class="difflineminus">-      if (msgHdr &amp;&amp;</span>
<a href="#l30.1704"></a><span id="l30.1704" class="difflineminus">-          !(msgHdr.flags &amp; Components.interfaces.nsMsgMessageFlags.Expunged))</span>
<a href="#l30.1705"></a><span id="l30.1705" class="difflineminus">-        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l30.1706"></a><span id="l30.1706" class="difflineminus">-            this._callbackHandle));</span>
<a href="#l30.1707"></a><span id="l30.1707" class="difflineminus">-      else</span>
<a href="#l30.1708"></a><span id="l30.1708" class="difflineminus">-        yield this.kWorkSync;</span>
<a href="#l30.1709"></a><span id="l30.1709" class="difflineminus">-    }</span>
<a href="#l30.1710"></a><span id="l30.1710" class="difflineminus">-    yield this.kWorkDone;</span>
<a href="#l30.1711"></a><span id="l30.1711" class="difflineminus">-  },</span>
<a href="#l30.1712"></a><span id="l30.1712" class="difflineminus">-</span>
<a href="#l30.1713"></a><span id="l30.1713" class="difflineminus">-  /**</span>
<a href="#l30.1714"></a><span id="l30.1714" class="difflineminus">-   * Process pending deletes...</span>
<a href="#l30.1715"></a><span id="l30.1715" class="difflineminus">-   */</span>
<a href="#l30.1716"></a><span id="l30.1716" class="difflineminus">-  _worker_processDeletes: function gloda_worker_processDeletes(aJob,</span>
<a href="#l30.1717"></a><span id="l30.1717" class="difflineminus">-      aCallbackHandle) {</span>
<a href="#l30.1718"></a><span id="l30.1718" class="difflineminus">-    // get a block of messages to delete.  for now, let's just do this</span>
<a href="#l30.1719"></a><span id="l30.1719" class="difflineminus">-    //  synchronously.  we don't care if there are un-landed delete changes</span>
<a href="#l30.1720"></a><span id="l30.1720" class="difflineminus">-    //  on the asynchronous thread.  (well, there is a potential race that</span>
<a href="#l30.1721"></a><span id="l30.1721" class="difflineminus">-    //  would result in us clearing pendingDeletions erroneously, but the</span>
<a href="#l30.1722"></a><span id="l30.1722" class="difflineminus">-    //  processedAny flag and our use of a while loop here make this</span>
<a href="#l30.1723"></a><span id="l30.1723" class="difflineminus">-    //  sufficiently close to zero until we move to being async.)</span>
<a href="#l30.1724"></a><span id="l30.1724" class="difflineminus">-    let messagesToDelete = this._datastore.getDeletedMessageBlock();</span>
<a href="#l30.1725"></a><span id="l30.1725" class="difflineminus">-    let processedAny = false;</span>
<a href="#l30.1726"></a><span id="l30.1726" class="difflineminus">-    while (messagesToDelete.length) {</span>
<a href="#l30.1727"></a><span id="l30.1727" class="difflineminus">-      aJob.goal += messagesToDelete.length;</span>
<a href="#l30.1728"></a><span id="l30.1728" class="difflineminus">-      for each (let [iMessage, message] in Iterator(messagesToDelete)) {</span>
<a href="#l30.1729"></a><span id="l30.1729" class="difflineminus">-        yield aCallbackHandle.pushAndGo(this._deleteMessage(message));</span>
<a href="#l30.1730"></a><span id="l30.1730" class="difflineminus">-        aJob.offset++;</span>
<a href="#l30.1731"></a><span id="l30.1731" class="difflineminus">-        yield this.kWorkSync;</span>
<a href="#l30.1732"></a><span id="l30.1732" class="difflineminus">-      }</span>
<a href="#l30.1733"></a><span id="l30.1733" class="difflineminus">-</span>
<a href="#l30.1734"></a><span id="l30.1734" class="difflineminus">-      processedAny = true;</span>
<a href="#l30.1735"></a><span id="l30.1735" class="difflineminus">-      messagesToDelete = this._datastore.getDeletedMessageBlock();</span>
<a href="#l30.1736"></a><span id="l30.1736" class="difflineminus">-    }</span>
<a href="#l30.1737"></a><span id="l30.1737" class="difflineminus">-    if (processedAny)</span>
<a href="#l30.1738"></a><span id="l30.1738" class="difflineminus">-      this.pendingDeletions = false;</span>
<a href="#l30.1739"></a><span id="l30.1739" class="difflineminus">-</span>
<a href="#l30.1740"></a><span id="l30.1740" class="difflineminus">-    yield this.kWorkDone;</span>
<a href="#l30.1741"></a><span id="l30.1741" class="difflineminus">-  },</span>
<a href="#l30.1742"></a><span id="l30.1742" class="difflineminus">-</span>
<a href="#l30.1743"></a><span id="l30.1743" class="difflineminus">-  /**</span>
<a href="#l30.1744"></a><span id="l30.1744" class="difflineminus">-   * Determine whether a folder is suitable for indexing.</span>
<a href="#l30.1745"></a><span id="l30.1745" class="difflineminus">-   *</span>
<a href="#l30.1746"></a><span id="l30.1746" class="difflineminus">-   * @param aMsgFolder An nsIMsgFolder you want to see if we should index.</span>
<a href="#l30.1747"></a><span id="l30.1747" class="difflineminus">-   *</span>
<a href="#l30.1748"></a><span id="l30.1748" class="difflineminus">-   * @returns true if we want to index messages in this type of folder, false if</span>
<a href="#l30.1749"></a><span id="l30.1749" class="difflineminus">-   *     we do not.</span>
<a href="#l30.1750"></a><span id="l30.1750" class="difflineminus">-   */</span>
<a href="#l30.1751"></a><span id="l30.1751" class="difflineminus">-  shouldIndexFolder: function(aMsgFolder) {</span>
<a href="#l30.1752"></a><span id="l30.1752" class="difflineminus">-    let folderFlags = aMsgFolder.flags;</span>
<a href="#l30.1753"></a><span id="l30.1753" class="difflineminus">-    // only index mail folders but stay out of virtual folders</span>
<a href="#l30.1754"></a><span id="l30.1754" class="difflineminus">-    return ((folderFlags &amp; Ci.nsMsgFolderFlags.Mail) &amp;&amp;</span>
<a href="#l30.1755"></a><span id="l30.1755" class="difflineminus">-            !(folderFlags &amp; Ci.nsMsgFolderFlags.Virtual));</span>
<a href="#l30.1756"></a><span id="l30.1756" class="difflineminus">-  },</span>
<a href="#l30.1757"></a><span id="l30.1757" class="difflineminus">-</span>
<a href="#l30.1758"></a><span id="l30.1758" class="difflineminus">-  /**</span>
<a href="#l30.1759"></a><span id="l30.1759" class="difflineminus">-   * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l30.1760"></a><span id="l30.1760" class="difflineminus">-   *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l30.1761"></a><span id="l30.1761" class="difflineminus">-   *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l30.1762"></a><span id="l30.1762" class="difflineminus">-   *  indexed.  (We previously queued accounts rather than immediately</span>
<a href="#l30.1763"></a><span id="l30.1763" class="difflineminus">-   *  walking their list of folders.)</span>
<a href="#l30.1764"></a><span id="l30.1764" class="difflineminus">-   */</span>
<a href="#l30.1765"></a><span id="l30.1765" class="difflineminus">-  indexEverything: function glodaIndexEverything() {</span>
<a href="#l30.1766"></a><span id="l30.1766" class="difflineminus">-    this._log.info(&quot;Queueing all accounts for indexing.&quot;);</span>
<a href="#l30.1767"></a><span id="l30.1767" class="difflineminus">-    let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l30.1768"></a><span id="l30.1768" class="difflineminus">-                            getService(Ci.nsIMsgAccountManager);</span>
<a href="#l30.1769"></a><span id="l30.1769" class="difflineminus">-</span>
<a href="#l30.1770"></a><span id="l30.1770" class="difflineminus">-    GlodaDatastore._beginTransaction();</span>
<a href="#l30.1771"></a><span id="l30.1771" class="difflineminus">-    let sideEffects = [this.indexAccount(account) for each</span>
<a href="#l30.1772"></a><span id="l30.1772" class="difflineminus">-                       (account in fixIterator(msgAccountManager.accounts,</span>
<a href="#l30.1773"></a><span id="l30.1773" class="difflineminus">-                                               Ci.nsIMsgAccount))];</span>
<a href="#l30.1774"></a><span id="l30.1774" class="difflineminus">-    GlodaDatastore._commitTransaction();</span>
<a href="#l30.1775"></a><span id="l30.1775" class="difflineminus">-  },</span>
<a href="#l30.1776"></a><span id="l30.1776" class="difflineminus">-</span>
<a href="#l30.1777"></a><span id="l30.1777" class="difflineminus">-  /**</span>
<a href="#l30.1778"></a><span id="l30.1778" class="difflineminus">-   * Queue all of the folders belonging to an account for indexing.</span>
<a href="#l30.1779"></a><span id="l30.1779" class="difflineminus">-   */</span>
<a href="#l30.1780"></a><span id="l30.1780" class="difflineminus">-  indexAccount: function glodaIndexAccount(aAccount) {</span>
<a href="#l30.1781"></a><span id="l30.1781" class="difflineminus">-    let rootFolder = aAccount.incomingServer.rootFolder;</span>
<a href="#l30.1782"></a><span id="l30.1782" class="difflineminus">-    if (rootFolder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l30.1783"></a><span id="l30.1783" class="difflineminus">-      this._log.info(&quot;Queueing account folders for indexing: &quot; + aAccount.key);</span>
<a href="#l30.1784"></a><span id="l30.1784" class="difflineminus">-</span>
<a href="#l30.1785"></a><span id="l30.1785" class="difflineminus">-      let allFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;]</span>
<a href="#l30.1786"></a><span id="l30.1786" class="difflineminus">-                         .createInstance(Ci.nsISupportsArray);</span>
<a href="#l30.1787"></a><span id="l30.1787" class="difflineminus">-      rootFolder.ListDescendents(allFolders);</span>
<a href="#l30.1788"></a><span id="l30.1788" class="difflineminus">-      let numFolders = allFolders.Count();</span>
<a href="#l30.1789"></a><span id="l30.1789" class="difflineminus">-      let folderJobs = [];</span>
<a href="#l30.1790"></a><span id="l30.1790" class="difflineminus">-      for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++) {</span>
<a href="#l30.1791"></a><span id="l30.1791" class="difflineminus">-        let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l30.1792"></a><span id="l30.1792" class="difflineminus">-                                                            Ci.nsIMsgFolder);</span>
<a href="#l30.1793"></a><span id="l30.1793" class="difflineminus">-        if (this.shouldIndexFolder(folder))</span>
<a href="#l30.1794"></a><span id="l30.1794" class="difflineminus">-          folderJobs.push(</span>
<a href="#l30.1795"></a><span id="l30.1795" class="difflineminus">-            new IndexingJob(&quot;folder&quot;, 1, GlodaDatastore._mapFolder(folder).id));</span>
<a href="#l30.1796"></a><span id="l30.1796" class="difflineminus">-      }</span>
<a href="#l30.1797"></a><span id="l30.1797" class="difflineminus">-</span>
<a href="#l30.1798"></a><span id="l30.1798" class="difflineminus">-      this._indexingJobGoal += folderJobs.length;</span>
<a href="#l30.1799"></a><span id="l30.1799" class="difflineminus">-      this._indexQueue = this._indexQueue.concat(folderJobs);</span>
<a href="#l30.1800"></a><span id="l30.1800" class="difflineminus">-      this.indexing = true;</span>
<a href="#l30.1801"></a><span id="l30.1801" class="difflineminus">-    }</span>
<a href="#l30.1802"></a><span id="l30.1802" class="difflineminus">-    else {</span>
<a href="#l30.1803"></a><span id="l30.1803" class="difflineminus">-      this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l30.1804"></a><span id="l30.1804" class="difflineminus">-    }</span>
<a href="#l30.1805"></a><span id="l30.1805" class="difflineminus">-  },</span>
<a href="#l30.1806"></a><span id="l30.1806" class="difflineminus">-</span>
<a href="#l30.1807"></a><span id="l30.1807">   indexJob: function glodaIndexJob(aJob) {</span>
<a href="#l30.1808"></a><span id="l30.1808">     this._log.info(&quot;Queue-ing job for indexing: &quot; + aJob.jobType);</span>
<a href="#l30.1809"></a><span id="l30.1809"> </span>
<a href="#l30.1810"></a><span id="l30.1810">     this._indexQueue.push(aJob);</span>
<a href="#l30.1811"></a><span id="l30.1811" class="difflineminus">-    this._indexingJobGoal++;</span>
<a href="#l30.1812"></a><span id="l30.1812" class="difflineminus">-    this.indexing = true;</span>
<a href="#l30.1813"></a><span id="l30.1813" class="difflineminus">-  },</span>
<a href="#l30.1814"></a><span id="l30.1814" class="difflineminus">-</span>
<a href="#l30.1815"></a><span id="l30.1815" class="difflineminus">-  /**</span>
<a href="#l30.1816"></a><span id="l30.1816" class="difflineminus">-   * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l30.1817"></a><span id="l30.1817" class="difflineminus">-   */</span>
<a href="#l30.1818"></a><span id="l30.1818" class="difflineminus">-  indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l30.1819"></a><span id="l30.1819" class="difflineminus">-    this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l30.1820"></a><span id="l30.1820" class="difflineminus">-</span>
<a href="#l30.1821"></a><span id="l30.1821" class="difflineminus">-    this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l30.1822"></a><span id="l30.1822" class="difflineminus">-                          GlodaDatastore._mapFolder(aFolder).id));</span>
<a href="#l30.1823"></a><span id="l30.1823" class="difflineminus">-    this._indexingJobGoal++;</span>
<a href="#l30.1824"></a><span id="l30.1824">     this.indexing = true;</span>
<a href="#l30.1825"></a><span id="l30.1825">   },</span>
<a href="#l30.1826"></a><span id="l30.1826"> </span>
<a href="#l30.1827"></a><span id="l30.1827">   /**</span>
<a href="#l30.1828"></a><span id="l30.1828" class="difflineminus">-   * Queue a list of messages for indexing.</span>
<a href="#l30.1829"></a><span id="l30.1829" class="difflineplus">+   * Kill the active job.  This means a few things:</span>
<a href="#l30.1830"></a><span id="l30.1830" class="difflineplus">+   * - Kill all the generators in the callbackHandle stack.</span>
<a href="#l30.1831"></a><span id="l30.1831" class="difflineplus">+   * - If we are currently waiting on an async return, we need to make sure it</span>
<a href="#l30.1832"></a><span id="l30.1832" class="difflineplus">+   *    does not screw us up.</span>
<a href="#l30.1833"></a><span id="l30.1833" class="difflineplus">+   * - Make sure the job's cleanup function gets called if appropriate.</span>
<a href="#l30.1834"></a><span id="l30.1834">    *</span>
<a href="#l30.1835"></a><span id="l30.1835" class="difflineminus">-   * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l30.1836"></a><span id="l30.1836" class="difflineplus">+   * The async return case is actually not too troublesome.  Since there is an</span>
<a href="#l30.1837"></a><span id="l30.1837" class="difflineplus">+   *  active indexing job and we are not (by fiat) in that call stack, we know</span>
<a href="#l30.1838"></a><span id="l30.1838" class="difflineplus">+   *  that the callback driver is guaranteed to get triggered again somehow.</span>
<a href="#l30.1839"></a><span id="l30.1839" class="difflineplus">+   *  The only issue is to make sure that _workBatchData does not end up with</span>
<a href="#l30.1840"></a><span id="l30.1840" class="difflineplus">+   *  the data.  We compel |_hireJobWorker| to erase it to this end.</span>
<a href="#l30.1841"></a><span id="l30.1841" class="difflineplus">+   *</span>
<a href="#l30.1842"></a><span id="l30.1842" class="difflineplus">+   * @note You MUST NOT call this function from inside a job or an async funtion</span>
<a href="#l30.1843"></a><span id="l30.1843" class="difflineplus">+   *    on the callbackHandle's stack of generators.  If you are in that</span>
<a href="#l30.1844"></a><span id="l30.1844" class="difflineplus">+   *    situation, you should just throw an exception.  At the very least,</span>
<a href="#l30.1845"></a><span id="l30.1845" class="difflineplus">+   *    use a timeout to trigger us.</span>
<a href="#l30.1846"></a><span id="l30.1846">    */</span>
<a href="#l30.1847"></a><span id="l30.1847" class="difflineminus">-  indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l30.1848"></a><span id="l30.1848" class="difflineminus">-    let job = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l30.1849"></a><span id="l30.1849" class="difflineminus">-    job.items = [[GlodaDatastore._mapFolder(fm[0]).id, fm[1]] for each</span>
<a href="#l30.1850"></a><span id="l30.1850" class="difflineminus">-                 ([i, fm] in Iterator(aFoldersAndMessages))];</span>
<a href="#l30.1851"></a><span id="l30.1851" class="difflineminus">-    this._indexQueue.push(job);</span>
<a href="#l30.1852"></a><span id="l30.1852" class="difflineminus">-    this._indexingJobGoal++;</span>
<a href="#l30.1853"></a><span id="l30.1853" class="difflineminus">-    this.indexing = true;</span>
<a href="#l30.1854"></a><span id="l30.1854" class="difflineplus">+  killActiveJob: function() {</span>
<a href="#l30.1855"></a><span id="l30.1855" class="difflineplus">+    // There is nothing to do if we have no job</span>
<a href="#l30.1856"></a><span id="l30.1856" class="difflineplus">+    if (!this._curIndexingJob)</span>
<a href="#l30.1857"></a><span id="l30.1857" class="difflineplus">+      return;</span>
<a href="#l30.1858"></a><span id="l30.1858" class="difflineplus">+</span>
<a href="#l30.1859"></a><span id="l30.1859" class="difflineplus">+    // -- Blow away the stack with cleanup.</span>
<a href="#l30.1860"></a><span id="l30.1860" class="difflineplus">+    let workerDef = this._curIndexingJob._workerDef;</span>
<a href="#l30.1861"></a><span id="l30.1861" class="difflineplus">+    if (this._unitTestHookCleanup)</span>
<a href="#l30.1862"></a><span id="l30.1862" class="difflineplus">+      this._unitTestHookCleanup(workerDef.cleanup ? true : false,</span>
<a href="#l30.1863"></a><span id="l30.1863" class="difflineplus">+                                &quot;no exception, this was killActiveJob&quot;,</span>
<a href="#l30.1864"></a><span id="l30.1864" class="difflineplus">+                                this._curIndexingJob,</span>
<a href="#l30.1865"></a><span id="l30.1865" class="difflineplus">+                                this._callbackHandle);</span>
<a href="#l30.1866"></a><span id="l30.1866" class="difflineplus">+    this._callbackHandle.cleanup();</span>
<a href="#l30.1867"></a><span id="l30.1867" class="difflineplus">+    if (workerDef.cleanup)</span>
<a href="#l30.1868"></a><span id="l30.1868" class="difflineplus">+      workerDef.cleanup.call(workerDef.indexer, this._curIndexingJob);</span>
<a href="#l30.1869"></a><span id="l30.1869" class="difflineplus">+</span>
<a href="#l30.1870"></a><span id="l30.1870" class="difflineplus">+    // Eliminate the job.</span>
<a href="#l30.1871"></a><span id="l30.1871" class="difflineplus">+    this._curIndexingJob = null;</span>
<a href="#l30.1872"></a><span id="l30.1872">   },</span>
<a href="#l30.1873"></a><span id="l30.1873"> </span>
<a href="#l30.1874"></a><span id="l30.1874">   /**</span>
<a href="#l30.1875"></a><span id="l30.1875" class="difflineminus">-   * Given a message header, return whether this message is likely to have</span>
<a href="#l30.1876"></a><span id="l30.1876" class="difflineminus">-   * been indexed or not.</span>
<a href="#l30.1877"></a><span id="l30.1877" class="difflineplus">+   * Purge all jobs that the filter function returns true for.  This does not</span>
<a href="#l30.1878"></a><span id="l30.1878" class="difflineplus">+   *  kill the active job, use |killActiveJob| to do that.</span>
<a href="#l30.1879"></a><span id="l30.1879">    *</span>
<a href="#l30.1880"></a><span id="l30.1880" class="difflineminus">-   * @param aMsgHdr A message header.</span>
<a href="#l30.1881"></a><span id="l30.1881" class="difflineminus">-   * @returns true if the message is likely to have been indexed.</span>
<a href="#l30.1882"></a><span id="l30.1882" class="difflineplus">+   * Make sure to call this function before killActiveJob</span>
<a href="#l30.1883"></a><span id="l30.1883" class="difflineplus">+   *</span>
<a href="#l30.1884"></a><span id="l30.1884" class="difflineplus">+   * @param aFilterElimFunc A filter function that takes an |IndexingJob| and</span>
<a href="#l30.1885"></a><span id="l30.1885" class="difflineplus">+   *     returns true if the job should be purged, false if it should not be.</span>
<a href="#l30.1886"></a><span id="l30.1886" class="difflineplus">+   *     The filter sees the jobs in the order they are scheduled.</span>
<a href="#l30.1887"></a><span id="l30.1887">    */</span>
<a href="#l30.1888"></a><span id="l30.1888" class="difflineminus">-  isMessageIndexed: function gloda_index_isMessageIndexed(aMsgHdr) {</span>
<a href="#l30.1889"></a><span id="l30.1889" class="difflineminus">-    let glodaFolder = GlodaDatastore._mapFolder(aMsgHdr.folder);</span>
<a href="#l30.1890"></a><span id="l30.1890" class="difflineminus">-    return aMsgHdr.getUint32Property(GLODA_MESSAGE_ID_PROPERTY) != 0 &amp;&amp;</span>
<a href="#l30.1891"></a><span id="l30.1891" class="difflineminus">-           aMsgHdr.getStringProperty(GLODA_DIRTY_PROPERTY) == 0 &amp;&amp;</span>
<a href="#l30.1892"></a><span id="l30.1892" class="difflineminus">-           glodaFolder &amp;&amp; glodaFolder.dirtyStatus != glodaFolder.kFolderFilthy;</span>
<a href="#l30.1893"></a><span id="l30.1893" class="difflineplus">+  purgeJobsUsingFilter: function(aFilterElimFunc) {</span>
<a href="#l30.1894"></a><span id="l30.1894" class="difflineplus">+    for (let iJob = 0; iJob &lt; this._indexQueue.length; iJob++) {</span>
<a href="#l30.1895"></a><span id="l30.1895" class="difflineplus">+      let job = this._indexQueue[iJob];</span>
<a href="#l30.1896"></a><span id="l30.1896" class="difflineplus">+</span>
<a href="#l30.1897"></a><span id="l30.1897" class="difflineplus">+      // If the filter says to, splice the job out of existence (and make sure</span>
<a href="#l30.1898"></a><span id="l30.1898" class="difflineplus">+      //  to fixup iJob to compensate.)</span>
<a href="#l30.1899"></a><span id="l30.1899" class="difflineplus">+      if (aFilterElimFunc(job)) {</span>
<a href="#l30.1900"></a><span id="l30.1900" class="difflineplus">+        this._indexQueue.splice(iJob--, 1);</span>
<a href="#l30.1901"></a><span id="l30.1901" class="difflineplus">+        let workerDef = this._indexerWorkerDefs[job.jobType];</span>
<a href="#l30.1902"></a><span id="l30.1902" class="difflineplus">+        if (workerDef.jobCanceled)</span>
<a href="#l30.1903"></a><span id="l30.1903" class="difflineplus">+          workerDef.jobCanceled.call(workerDef.indexer, job);</span>
<a href="#l30.1904"></a><span id="l30.1904" class="difflineplus">+      }</span>
<a href="#l30.1905"></a><span id="l30.1905" class="difflineplus">+    }</span>
<a href="#l30.1906"></a><span id="l30.1906">   },</span>
<a href="#l30.1907"></a><span id="l30.1907"> </span>
<a href="#l30.1908"></a><span id="l30.1908">   /* *********** Event Processing *********** */</span>
<a href="#l30.1909"></a><span id="l30.1909">   observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l30.1910"></a><span id="l30.1910">     // idle</span>
<a href="#l30.1911"></a><span id="l30.1911">     if (aTopic == &quot;idle&quot;) {</span>
<a href="#l30.1912"></a><span id="l30.1912">       // Do we need to commit an indexer transaction?</span>
<a href="#l30.1913"></a><span id="l30.1913">       if (this._idleToCommit) {</span>
<a href="#l30.1914"></a><span id="l30.1914" class="difflineat">@@ -2038,806 +1369,11 @@ var GlodaIndexer = {</span>
<a href="#l30.1915"></a><span id="l30.1915">       }</span>
<a href="#l30.1916"></a><span id="l30.1916">     }</span>
<a href="#l30.1917"></a><span id="l30.1917">     // shutdown fallback</span>
<a href="#l30.1918"></a><span id="l30.1918">     else if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l30.1919"></a><span id="l30.1919">       this._shutdown();</span>
<a href="#l30.1920"></a><span id="l30.1920">     }</span>
<a href="#l30.1921"></a><span id="l30.1921">   },</span>
<a href="#l30.1922"></a><span id="l30.1922"> </span>
<a href="#l30.1923"></a><span id="l30.1923" class="difflineminus">-  /* ***** Folder Changes ***** */</span>
<a href="#l30.1924"></a><span id="l30.1924" class="difflineminus">-  /**</span>
<a href="#l30.1925"></a><span id="l30.1925" class="difflineminus">-   * All additions and removals are queued for processing.  Indexing messages</span>
<a href="#l30.1926"></a><span id="l30.1926" class="difflineminus">-   *  is potentially phenomenally expensive, and deletion can still be</span>
<a href="#l30.1927"></a><span id="l30.1927" class="difflineminus">-   *  relatively expensive due to our need to delete the message, its</span>
<a href="#l30.1928"></a><span id="l30.1928" class="difflineminus">-   *  attributes, and all attributes that reference it.  Additionally,</span>
<a href="#l30.1929"></a><span id="l30.1929" class="difflineminus">-   *  attribute deletion costs are higher than attribute look-up because</span>
<a href="#l30.1930"></a><span id="l30.1930" class="difflineminus">-   *  there is the actual row plus its 3 indices, and our covering indices are</span>
<a href="#l30.1931"></a><span id="l30.1931" class="difflineminus">-   *  no help there.</span>
<a href="#l30.1932"></a><span id="l30.1932" class="difflineminus">-   *</span>
<a href="#l30.1933"></a><span id="l30.1933" class="difflineminus">-   */</span>
<a href="#l30.1934"></a><span id="l30.1934" class="difflineminus">-  _msgFolderListener: {</span>
<a href="#l30.1935"></a><span id="l30.1935" class="difflineminus">-    indexer: null,</span>
<a href="#l30.1936"></a><span id="l30.1936"> </span>
<a href="#l30.1937"></a><span id="l30.1937" class="difflineminus">-    /**</span>
<a href="#l30.1938"></a><span id="l30.1938" class="difflineminus">-     * Handle a new-to-thunderbird message, meaning a newly fetched message</span>
<a href="#l30.1939"></a><span id="l30.1939" class="difflineminus">-     *  (local folder) one revealed by synching with the server (IMAP).  Because</span>
<a href="#l30.1940"></a><span id="l30.1940" class="difflineminus">-     *  the new-to-IMAP case requires Thunderbird to have opened the folder,</span>
<a href="#l30.1941"></a><span id="l30.1941" class="difflineminus">-     *  we either need to depend on MailNews to be aggressive about looking</span>
<a href="#l30.1942"></a><span id="l30.1942" class="difflineminus">-     *  for new messages in folders or try and do it ourselves.  For now, we</span>
<a href="#l30.1943"></a><span id="l30.1943" class="difflineminus">-     *  leave it up to MailNews proper.</span>
<a href="#l30.1944"></a><span id="l30.1944" class="difflineminus">-     *</span>
<a href="#l30.1945"></a><span id="l30.1945" class="difflineminus">-     * For the time being, we post the message header as received to our</span>
<a href="#l30.1946"></a><span id="l30.1946" class="difflineminus">-     *  indexing queue.  Depending on experience, it may be more suitable to</span>
<a href="#l30.1947"></a><span id="l30.1947" class="difflineminus">-     *  try and index the message immediately, or hold onto a less specific</span>
<a href="#l30.1948"></a><span id="l30.1948" class="difflineminus">-     *  form of message information than the nsIMsgDBHdr.  (If we were to</span>
<a href="#l30.1949"></a><span id="l30.1949" class="difflineminus">-     *  process immediately, it might appropriate to consider having a</span>
<a href="#l30.1950"></a><span id="l30.1950" class="difflineminus">-     *  transaction open that is commited by timer/sufficient activity, since it</span>
<a href="#l30.1951"></a><span id="l30.1951" class="difflineminus">-     *  is conceivable we will see a number of these events in fairly rapid</span>
<a href="#l30.1952"></a><span id="l30.1952" class="difflineminus">-     *  succession.)</span>
<a href="#l30.1953"></a><span id="l30.1953" class="difflineminus">-     */</span>
<a href="#l30.1954"></a><span id="l30.1954" class="difflineminus">-    msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l30.1955"></a><span id="l30.1955" class="difflineminus">-      // make sure the message is eligible for indexing...</span>
<a href="#l30.1956"></a><span id="l30.1956" class="difflineminus">-      let msgFolder = aMsgHdr.folder;</span>
<a href="#l30.1957"></a><span id="l30.1957" class="difflineminus">-      if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l30.1958"></a><span id="l30.1958" class="difflineminus">-        return;</span>
<a href="#l30.1959"></a><span id="l30.1959" class="difflineminus">-</span>
<a href="#l30.1960"></a><span id="l30.1960" class="difflineminus">-      // Make sure the message is eligible for indexing.</span>
<a href="#l30.1961"></a><span id="l30.1961" class="difflineminus">-      // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l30.1962"></a><span id="l30.1962" class="difflineminus">-      // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l30.1963"></a><span id="l30.1963" class="difflineminus">-      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l30.1964"></a><span id="l30.1964" class="difflineminus">-      if (!isFolderLocal) {</span>
<a href="#l30.1965"></a><span id="l30.1965" class="difflineminus">-        if (!(aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l30.1966"></a><span id="l30.1966" class="difflineminus">-            (msgFolder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l30.1967"></a><span id="l30.1967" class="difflineminus">-          return;</span>
<a href="#l30.1968"></a><span id="l30.1968" class="difflineminus">-      }</span>
<a href="#l30.1969"></a><span id="l30.1969" class="difflineminus">-</span>
<a href="#l30.1970"></a><span id="l30.1970" class="difflineminus">-      // mark the folder dirty so we know to look in it, but there is no need</span>
<a href="#l30.1971"></a><span id="l30.1971" class="difflineminus">-      //  to mark the message because it will lack a gloda-id anyways.</span>
<a href="#l30.1972"></a><span id="l30.1972" class="difflineminus">-      let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l30.1973"></a><span id="l30.1973" class="difflineminus">-      glodaFolder.dirtyStatus = true;</span>
<a href="#l30.1974"></a><span id="l30.1974" class="difflineminus">-</span>
<a href="#l30.1975"></a><span id="l30.1975" class="difflineminus">-      if (this.indexer._pendingAddJob === null) {</span>
<a href="#l30.1976"></a><span id="l30.1976" class="difflineminus">-        this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l30.1977"></a><span id="l30.1977" class="difflineminus">-        this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l30.1978"></a><span id="l30.1978" class="difflineminus">-        this.indexer._indexingJobGoal++;</span>
<a href="#l30.1979"></a><span id="l30.1979" class="difflineminus">-      }</span>
<a href="#l30.1980"></a><span id="l30.1980" class="difflineminus">-      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l30.1981"></a><span id="l30.1981" class="difflineminus">-      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l30.1982"></a><span id="l30.1982" class="difflineminus">-          this.indexer._indexMaxEventQueueMessages) {</span>
<a href="#l30.1983"></a><span id="l30.1983" class="difflineminus">-        this.indexer._pendingAddJob.items.push(</span>
<a href="#l30.1984"></a><span id="l30.1984" class="difflineminus">-          [glodaFolder.id, aMsgHdr.messageKey]);</span>
<a href="#l30.1985"></a><span id="l30.1985" class="difflineminus">-        this.indexer.indexing = true;</span>
<a href="#l30.1986"></a><span id="l30.1986" class="difflineminus">-        this.indexer._log.debug(&quot;msgAdded notification, event indexing&quot;);</span>
<a href="#l30.1987"></a><span id="l30.1987" class="difflineminus">-      }</span>
<a href="#l30.1988"></a><span id="l30.1988" class="difflineminus">-      else {</span>
<a href="#l30.1989"></a><span id="l30.1989" class="difflineminus">-        this.indexer.indexingSweepNeeded = true;</span>
<a href="#l30.1990"></a><span id="l30.1990" class="difflineminus">-        this.indexer._log.debug(&quot;msgAdded notification, sweep indexing&quot;);</span>
<a href="#l30.1991"></a><span id="l30.1991" class="difflineminus">-      }</span>
<a href="#l30.1992"></a><span id="l30.1992" class="difflineminus">-    },</span>
<a href="#l30.1993"></a><span id="l30.1993" class="difflineminus">-</span>
<a href="#l30.1994"></a><span id="l30.1994" class="difflineminus">-    /**</span>
<a href="#l30.1995"></a><span id="l30.1995" class="difflineminus">-     * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l30.1996"></a><span id="l30.1996" class="difflineminus">-     *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l30.1997"></a><span id="l30.1997" class="difflineminus">-     *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l30.1998"></a><span id="l30.1998" class="difflineminus">-     *  going away, we need to either process things immediately or extract the</span>
<a href="#l30.1999"></a><span id="l30.1999" class="difflineminus">-     *  information required to purge it later without the header.</span>
<a href="#l30.2000"></a><span id="l30.2000" class="difflineminus">-     * To this end, we mark all messages that were indexed in the gloda message</span>
<a href="#l30.2001"></a><span id="l30.2001" class="difflineminus">-     *  database as deleted.  We set our pending deletions flag to let our</span>
<a href="#l30.2002"></a><span id="l30.2002" class="difflineminus">-     *  indexing logic know that after its next wave of folder traversal, it</span>
<a href="#l30.2003"></a><span id="l30.2003" class="difflineminus">-     *  should perform a deletion pass.  If it turns out the messages are coming</span>
<a href="#l30.2004"></a><span id="l30.2004" class="difflineminus">-     *  back, the fact that deletion is thus deferred can be handy, as we can</span>
<a href="#l30.2005"></a><span id="l30.2005" class="difflineminus">-     *  reuse the existing gloda message.</span>
<a href="#l30.2006"></a><span id="l30.2006" class="difflineminus">-     */</span>
<a href="#l30.2007"></a><span id="l30.2007" class="difflineminus">-    msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l30.2008"></a><span id="l30.2008" class="difflineminus">-      this.indexer._log.debug(&quot;msgsDeleted notification&quot;);</span>
<a href="#l30.2009"></a><span id="l30.2009" class="difflineminus">-</span>
<a href="#l30.2010"></a><span id="l30.2010" class="difflineminus">-      let glodaMessageIds = [];</span>
<a href="#l30.2011"></a><span id="l30.2011" class="difflineminus">-</span>
<a href="#l30.2012"></a><span id="l30.2012" class="difflineminus">-      let deleteJob = new IndexingJob(&quot;message&quot;, -1, null);</span>
<a href="#l30.2013"></a><span id="l30.2013" class="difflineminus">-      for (let iMsgHdr = 0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l30.2014"></a><span id="l30.2014" class="difflineminus">-        let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l30.2015"></a><span id="l30.2015" class="difflineminus">-        try {</span>
<a href="#l30.2016"></a><span id="l30.2016" class="difflineminus">-          glodaMessageIds.push(msgHdr.getUint32Property(</span>
<a href="#l30.2017"></a><span id="l30.2017" class="difflineminus">-            GLODA_MESSAGE_ID_PROPERTY));</span>
<a href="#l30.2018"></a><span id="l30.2018" class="difflineminus">-        }</span>
<a href="#l30.2019"></a><span id="l30.2019" class="difflineminus">-        catch (ex) {}</span>
<a href="#l30.2020"></a><span id="l30.2020" class="difflineminus">-      }</span>
<a href="#l30.2021"></a><span id="l30.2021" class="difflineminus">-</span>
<a href="#l30.2022"></a><span id="l30.2022" class="difflineminus">-      if (glodaMessageIds.length) {</span>
<a href="#l30.2023"></a><span id="l30.2023" class="difflineminus">-        this.indexer._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l30.2024"></a><span id="l30.2024" class="difflineminus">-        this.indexer.pendingDeletions = true;</span>
<a href="#l30.2025"></a><span id="l30.2025" class="difflineminus">-      }</span>
<a href="#l30.2026"></a><span id="l30.2026" class="difflineminus">-    },</span>
<a href="#l30.2027"></a><span id="l30.2027" class="difflineminus">-</span>
<a href="#l30.2028"></a><span id="l30.2028" class="difflineminus">-    /**</span>
<a href="#l30.2029"></a><span id="l30.2029" class="difflineminus">-     * Process a move or copy.</span>
<a href="#l30.2030"></a><span id="l30.2030" class="difflineminus">-     * Moves to a local folder can be dealt with (relatively) efficiently; the</span>
<a href="#l30.2031"></a><span id="l30.2031" class="difflineminus">-     *  target message headers exist at the time of the notification.  The trick</span>
<a href="#l30.2032"></a><span id="l30.2032" class="difflineminus">-     *  is that we aren't provided with them.</span>
<a href="#l30.2033"></a><span id="l30.2033" class="difflineminus">-     * Moves to an IMAP folder are troublesome because mailnews may not actually</span>
<a href="#l30.2034"></a><span id="l30.2034" class="difflineminus">-     *  know anything about the messages in their new location.  If there isn't</span>
<a href="#l30.2035"></a><span id="l30.2035" class="difflineminus">-     *  a currently open connection to the destination folder, we will only hear</span>
<a href="#l30.2036"></a><span id="l30.2036" class="difflineminus">-     *  about the headers when the user browses there or IMAP auto-sync gets to</span>
<a href="#l30.2037"></a><span id="l30.2037" class="difflineminus">-     *  the folder.  Either way, we will actually receive a msgAdded event for</span>
<a href="#l30.2038"></a><span id="l30.2038" class="difflineminus">-     *  each message, so the main thing we need to do is provide a hint to the</span>
<a href="#l30.2039"></a><span id="l30.2039" class="difflineminus">-     *  indexing logic that the gloda message in question should be reused and</span>
<a href="#l30.2040"></a><span id="l30.2040" class="difflineminus">-     *  is not a duplicate.</span>
<a href="#l30.2041"></a><span id="l30.2041" class="difflineminus">-     * Because copied messages are, by their nature, duplicate messages, we</span>
<a href="#l30.2042"></a><span id="l30.2042" class="difflineminus">-     *  do not particularly care about them.  As such, we defer their processing</span>
<a href="#l30.2043"></a><span id="l30.2043" class="difflineminus">-     *  to the automatic sync logic that will happen much later on.  This is</span>
<a href="#l30.2044"></a><span id="l30.2044" class="difflineminus">-     *  potentially desirable in case the user deletes some of the original</span>
<a href="#l30.2045"></a><span id="l30.2045" class="difflineminus">-     *  messages, allowing us to reuse the gloda message representations when</span>
<a href="#l30.2046"></a><span id="l30.2046" class="difflineminus">-     *  we finally get around to indexing the messages.  We do need to mark the</span>
<a href="#l30.2047"></a><span id="l30.2047" class="difflineminus">-     *  folder as dirty, though, to clue in the sync logic.</span>
<a href="#l30.2048"></a><span id="l30.2048" class="difflineminus">-     */</span>
<a href="#l30.2049"></a><span id="l30.2049" class="difflineminus">-    msgsMoveCopyCompleted: function gloda_indexer_msgsMoveCopyCompleted(aMove,</span>
<a href="#l30.2050"></a><span id="l30.2050" class="difflineminus">-                             aSrcMsgHdrs, aDestFolder) {</span>
<a href="#l30.2051"></a><span id="l30.2051" class="difflineminus">-      this.indexer._log.debug(&quot;MoveCopy notification.  Move: &quot; + aMove);</span>
<a href="#l30.2052"></a><span id="l30.2052" class="difflineminus">-      try {</span>
<a href="#l30.2053"></a><span id="l30.2053" class="difflineminus">-        if (aMove) {</span>
<a href="#l30.2054"></a><span id="l30.2054" class="difflineminus">-          // target is a local folder, we can find the destination messages</span>
<a href="#l30.2055"></a><span id="l30.2055" class="difflineminus">-          if (aDestFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l30.2056"></a><span id="l30.2056" class="difflineminus">-            // ...of course, finding the destination messages is not going to</span>
<a href="#l30.2057"></a><span id="l30.2057" class="difflineminus">-            //  be cheap.  we're O(n) for the messages in the target folder</span>
<a href="#l30.2058"></a><span id="l30.2058" class="difflineminus">-            //  (which is &gt;= the number of moved messages).</span>
<a href="#l30.2059"></a><span id="l30.2059" class="difflineminus">-            // XXX for now, we assume the gloda-id is not propagated at the</span>
<a href="#l30.2060"></a><span id="l30.2060" class="difflineminus">-            //  cost of getting confused if multiple messages have the same</span>
<a href="#l30.2061"></a><span id="l30.2061" class="difflineminus">-            //  message-id header; we would do better to get the gloda-id</span>
<a href="#l30.2062"></a><span id="l30.2062" class="difflineminus">-            //  propagated and use that.  (needs C++ code changes.)</span>
<a href="#l30.2063"></a><span id="l30.2063" class="difflineminus">-            // (we would still need to do the traversal because we still need</span>
<a href="#l30.2064"></a><span id="l30.2064" class="difflineminus">-            //  to know the messageKey in the target folder...)</span>
<a href="#l30.2065"></a><span id="l30.2065" class="difflineminus">-            let srcMsgIdToHdr = {};</span>
<a href="#l30.2066"></a><span id="l30.2066" class="difflineminus">-</span>
<a href="#l30.2067"></a><span id="l30.2067" class="difflineminus">-            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l30.2068"></a><span id="l30.2068" class="difflineminus">-              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l30.2069"></a><span id="l30.2069" class="difflineminus">-              // (note: collissions on message-id headers are possible and sad)</span>
<a href="#l30.2070"></a><span id="l30.2070" class="difflineminus">-              srcMsgIdToHdr[msgHdr.messageId] = msgHdr;</span>
<a href="#l30.2071"></a><span id="l30.2071" class="difflineminus">-            }</span>
<a href="#l30.2072"></a><span id="l30.2072" class="difflineminus">-            let glodaIds = [];</span>
<a href="#l30.2073"></a><span id="l30.2073" class="difflineminus">-            let newMessageKeys = [];</span>
<a href="#l30.2074"></a><span id="l30.2074" class="difflineminus">-            for each (let destMsgHdr in fixIterator(aDestFolder.messages,</span>
<a href="#l30.2075"></a><span id="l30.2075" class="difflineminus">-                                                    Ci.nsIMsgDBHdr)) {</span>
<a href="#l30.2076"></a><span id="l30.2076" class="difflineminus">-              let destMsgId = destMsgHdr.messageId;</span>
<a href="#l30.2077"></a><span id="l30.2077" class="difflineminus">-              let matchingSrcHdr = srcMsgIdToHdr[destMsgId];</span>
<a href="#l30.2078"></a><span id="l30.2078" class="difflineminus">-              if (matchingSrcHdr) {</span>
<a href="#l30.2079"></a><span id="l30.2079" class="difflineminus">-                try {</span>
<a href="#l30.2080"></a><span id="l30.2080" class="difflineminus">-                  let glodaId = matchingSrcHdr.getUint32Property(</span>
<a href="#l30.2081"></a><span id="l30.2081" class="difflineminus">-                    GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l30.2082"></a><span id="l30.2082" class="difflineminus">-                  glodaIds.push(glodaId);</span>
<a href="#l30.2083"></a><span id="l30.2083" class="difflineminus">-                  newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l30.2084"></a><span id="l30.2084" class="difflineminus">-                }</span>
<a href="#l30.2085"></a><span id="l30.2085" class="difflineminus">-                // no gloda id means it hasn't been indexed, so the move isn't</span>
<a href="#l30.2086"></a><span id="l30.2086" class="difflineminus">-                //  required.</span>
<a href="#l30.2087"></a><span id="l30.2087" class="difflineminus">-                catch (ex) {}</span>
<a href="#l30.2088"></a><span id="l30.2088" class="difflineminus">-              }</span>
<a href="#l30.2089"></a><span id="l30.2089" class="difflineminus">-            }</span>
<a href="#l30.2090"></a><span id="l30.2090" class="difflineminus">-</span>
<a href="#l30.2091"></a><span id="l30.2091" class="difflineminus">-            // this method takes care to update the in-memory representations</span>
<a href="#l30.2092"></a><span id="l30.2092" class="difflineminus">-            //  too; we don't need to do anything</span>
<a href="#l30.2093"></a><span id="l30.2093" class="difflineminus">-            this.indexer._datastore.updateMessageLocations(glodaIds,</span>
<a href="#l30.2094"></a><span id="l30.2094" class="difflineminus">-              newMessageKeys, aDestFolder);</span>
<a href="#l30.2095"></a><span id="l30.2095" class="difflineminus">-          }</span>
<a href="#l30.2096"></a><span id="l30.2096" class="difflineminus">-          // target is IMAP or something we equally don't understand</span>
<a href="#l30.2097"></a><span id="l30.2097" class="difflineminus">-          else {</span>
<a href="#l30.2098"></a><span id="l30.2098" class="difflineminus">-            // XXX the srcFolder will always be the same for now, but we</span>
<a href="#l30.2099"></a><span id="l30.2099" class="difflineminus">-            //  probably don't want to depend on it, or at least want a unit</span>
<a href="#l30.2100"></a><span id="l30.2100" class="difflineminus">-            //  test that will break if it changes...</span>
<a href="#l30.2101"></a><span id="l30.2101" class="difflineminus">-            let srcFolder = aSrcMsgHdrs.queryElementAt(0,Ci.nsIMsgDBHdr).folder;</span>
<a href="#l30.2102"></a><span id="l30.2102" class="difflineminus">-</span>
<a href="#l30.2103"></a><span id="l30.2103" class="difflineminus">-            // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l30.2104"></a><span id="l30.2104" class="difflineminus">-            //  job list too.</span>
<a href="#l30.2105"></a><span id="l30.2105" class="difflineminus">-            let messageKeys = [];</span>
<a href="#l30.2106"></a><span id="l30.2106" class="difflineminus">-            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l30.2107"></a><span id="l30.2107" class="difflineminus">-              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l30.2108"></a><span id="l30.2108" class="difflineminus">-              messageKeys.push(msgHdr.messageKey);</span>
<a href="#l30.2109"></a><span id="l30.2109" class="difflineminus">-            }</span>
<a href="#l30.2110"></a><span id="l30.2110" class="difflineminus">-            // XXX we could extract the gloda message id's instead.</span>
<a href="#l30.2111"></a><span id="l30.2111" class="difflineminus">-            // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l30.2112"></a><span id="l30.2112" class="difflineminus">-            this.indexer._datastore.updateMessageFoldersByKeyPurging(</span>
<a href="#l30.2113"></a><span id="l30.2113" class="difflineminus">-              srcFolder, messageKeys, aDestFolder);</span>
<a href="#l30.2114"></a><span id="l30.2114" class="difflineminus">-            // we _do not_ need to mark the folder as dirty, because the</span>
<a href="#l30.2115"></a><span id="l30.2115" class="difflineminus">-            //  message added events will cause that to happen.</span>
<a href="#l30.2116"></a><span id="l30.2116" class="difflineminus">-          }</span>
<a href="#l30.2117"></a><span id="l30.2117" class="difflineminus">-        }</span>
<a href="#l30.2118"></a><span id="l30.2118" class="difflineminus">-       // copy case</span>
<a href="#l30.2119"></a><span id="l30.2119" class="difflineminus">-        else {</span>
<a href="#l30.2120"></a><span id="l30.2120" class="difflineminus">-          // mark the folder as dirty; we'll get to it later.</span>
<a href="#l30.2121"></a><span id="l30.2121" class="difflineminus">-          let destGlodaFolder = GlodaDatastore._mapFolder(aDestFolder);</span>
<a href="#l30.2122"></a><span id="l30.2122" class="difflineminus">-          destGlodaFolder.dirtyStatus = true;</span>
<a href="#l30.2123"></a><span id="l30.2123" class="difflineminus">-          this.indexer.indexingSweepNeeded = true;</span>
<a href="#l30.2124"></a><span id="l30.2124" class="difflineminus">-        }</span>
<a href="#l30.2125"></a><span id="l30.2125" class="difflineminus">-      } catch (ex) {</span>
<a href="#l30.2126"></a><span id="l30.2126" class="difflineminus">-        this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l30.2127"></a><span id="l30.2127" class="difflineminus">-          &quot;: &quot; + ex);</span>
<a href="#l30.2128"></a><span id="l30.2128" class="difflineminus">-      }</span>
<a href="#l30.2129"></a><span id="l30.2129" class="difflineminus">-    },</span>
<a href="#l30.2130"></a><span id="l30.2130" class="difflineminus">-</span>
<a href="#l30.2131"></a><span id="l30.2131" class="difflineminus">-    /**</span>
<a href="#l30.2132"></a><span id="l30.2132" class="difflineminus">-     * Handles folder no-longer-exists-ence.  We mark all messages as deleted</span>
<a href="#l30.2133"></a><span id="l30.2133" class="difflineminus">-     *  and remove the folder from our URI table.  Currently, if a folder that</span>
<a href="#l30.2134"></a><span id="l30.2134" class="difflineminus">-     *  contains other folders is deleted, we may either receive one</span>
<a href="#l30.2135"></a><span id="l30.2135" class="difflineminus">-     *  notification for the folder that is deleted, or a notification for the</span>
<a href="#l30.2136"></a><span id="l30.2136" class="difflineminus">-     *  folder and one for each of its descendents.  This depends upon the</span>
<a href="#l30.2137"></a><span id="l30.2137" class="difflineminus">-     *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l30.2138"></a><span id="l30.2138" class="difflineminus">-     *  Namely, we treat it as if we're only planning on getting one, but we</span>
<a href="#l30.2139"></a><span id="l30.2139" class="difflineminus">-     *  handle if the children are already gone for some reason.</span>
<a href="#l30.2140"></a><span id="l30.2140" class="difflineminus">-     */</span>
<a href="#l30.2141"></a><span id="l30.2141" class="difflineminus">-    folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l30.2142"></a><span id="l30.2142" class="difflineminus">-      this.indexer._log.debug(&quot;folderDeleted notification&quot;);</span>
<a href="#l30.2143"></a><span id="l30.2143" class="difflineminus">-</span>
<a href="#l30.2144"></a><span id="l30.2144" class="difflineminus">-      let delFunc = function(aFolder, indexer) {</span>
<a href="#l30.2145"></a><span id="l30.2145" class="difflineminus">-        if (indexer._datastore._folderKnown(aFolder)) {</span>
<a href="#l30.2146"></a><span id="l30.2146" class="difflineminus">-          let folder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l30.2147"></a><span id="l30.2147" class="difflineminus">-          folder._deleted = true;</span>
<a href="#l30.2148"></a><span id="l30.2148" class="difflineminus">-          indexer._datastore.markMessagesDeletedByFolderID(folder.id);</span>
<a href="#l30.2149"></a><span id="l30.2149" class="difflineminus">-          indexer._datastore.deleteFolderByID(folder.id);</span>
<a href="#l30.2150"></a><span id="l30.2150" class="difflineminus">-        }</span>
<a href="#l30.2151"></a><span id="l30.2151" class="difflineminus">-      };</span>
<a href="#l30.2152"></a><span id="l30.2152" class="difflineminus">-</span>
<a href="#l30.2153"></a><span id="l30.2153" class="difflineminus">-      let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l30.2154"></a><span id="l30.2154" class="difflineminus">-                                createInstance(Ci.nsISupportsArray);</span>
<a href="#l30.2155"></a><span id="l30.2155" class="difflineminus">-      aFolder.ListDescendents(descendentFolders);</span>
<a href="#l30.2156"></a><span id="l30.2156" class="difflineminus">-</span>
<a href="#l30.2157"></a><span id="l30.2157" class="difflineminus">-      // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l30.2158"></a><span id="l30.2158" class="difflineminus">-      // delete the parent</span>
<a href="#l30.2159"></a><span id="l30.2159" class="difflineminus">-      delFunc(aFolder, this.indexer);</span>
<a href="#l30.2160"></a><span id="l30.2160" class="difflineminus">-      // delete all its descendents</span>
<a href="#l30.2161"></a><span id="l30.2161" class="difflineminus">-      for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l30.2162"></a><span id="l30.2162" class="difflineminus">-        delFunc(folder, this.indexer);</span>
<a href="#l30.2163"></a><span id="l30.2163" class="difflineminus">-      }</span>
<a href="#l30.2164"></a><span id="l30.2164" class="difflineminus">-</span>
<a href="#l30.2165"></a><span id="l30.2165" class="difflineminus">-      this.indexer.pendingDeletions = true;</span>
<a href="#l30.2166"></a><span id="l30.2166" class="difflineminus">-    },</span>
<a href="#l30.2167"></a><span id="l30.2167" class="difflineminus">-</span>
<a href="#l30.2168"></a><span id="l30.2168" class="difflineminus">-    /**</span>
<a href="#l30.2169"></a><span id="l30.2169" class="difflineminus">-     * Handle a folder being copied or moved.</span>
<a href="#l30.2170"></a><span id="l30.2170" class="difflineminus">-     * Moves are handled by a helper function shared with _folderRenameHelper</span>
<a href="#l30.2171"></a><span id="l30.2171" class="difflineminus">-     *  (which takes care of any nesting involved).</span>
<a href="#l30.2172"></a><span id="l30.2172" class="difflineminus">-     * Copies are actually ignored, because our periodic indexing traversal</span>
<a href="#l30.2173"></a><span id="l30.2173" class="difflineminus">-     *  should discover these automatically.  We could hint ourselves into</span>
<a href="#l30.2174"></a><span id="l30.2174" class="difflineminus">-     *  action, but arguably a set of completely duplicate messages is not</span>
<a href="#l30.2175"></a><span id="l30.2175" class="difflineminus">-     *  a high priority for indexing.</span>
<a href="#l30.2176"></a><span id="l30.2176" class="difflineminus">-     */</span>
<a href="#l30.2177"></a><span id="l30.2177" class="difflineminus">-    folderMoveCopyCompleted: function gloda_indexer_folderMoveCopyCompleted(</span>
<a href="#l30.2178"></a><span id="l30.2178" class="difflineminus">-                               aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l30.2179"></a><span id="l30.2179" class="difflineminus">-      this.indexer._log.debug(&quot;folderMoveCopy notification (Move: &quot; + aMove</span>
<a href="#l30.2180"></a><span id="l30.2180" class="difflineminus">-                              + &quot;)&quot;);</span>
<a href="#l30.2181"></a><span id="l30.2181" class="difflineminus">-      if (aMove) {</span>
<a href="#l30.2182"></a><span id="l30.2182" class="difflineminus">-        let srcURI = aSrcFolder.URI;</span>
<a href="#l30.2183"></a><span id="l30.2183" class="difflineminus">-        let targetURI = aDestFolder.URI +</span>
<a href="#l30.2184"></a><span id="l30.2184" class="difflineminus">-                        srcURI.substring(srcURI.lastIndexOf(&quot;/&quot;));</span>
<a href="#l30.2185"></a><span id="l30.2185" class="difflineminus">-        return this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l30.2186"></a><span id="l30.2186" class="difflineminus">-      }</span>
<a href="#l30.2187"></a><span id="l30.2187" class="difflineminus">-      this.indexer.indexingSweepNeeded = true;</span>
<a href="#l30.2188"></a><span id="l30.2188" class="difflineminus">-    },</span>
<a href="#l30.2189"></a><span id="l30.2189" class="difflineminus">-</span>
<a href="#l30.2190"></a><span id="l30.2190" class="difflineminus">-    /**</span>
<a href="#l30.2191"></a><span id="l30.2191" class="difflineminus">-     * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l30.2192"></a><span id="l30.2192" class="difflineminus">-     *  all of which is actually done by the datastore for us.</span>
<a href="#l30.2193"></a><span id="l30.2193" class="difflineminus">-     * This method needs to deal with the complexity where local folders will</span>
<a href="#l30.2194"></a><span id="l30.2194" class="difflineminus">-     *  generate a rename notification for each sub-folder, but IMAP folders</span>
<a href="#l30.2195"></a><span id="l30.2195" class="difflineminus">-     *  will generate only a single notification.  Our logic primarily handles</span>
<a href="#l30.2196"></a><span id="l30.2196" class="difflineminus">-     *  this by not exploding if the original folder no longer exists.</span>
<a href="#l30.2197"></a><span id="l30.2197" class="difflineminus">-     */</span>
<a href="#l30.2198"></a><span id="l30.2198" class="difflineminus">-    _folderRenameHelper: function gloda_indexer_folderRenameHelper(aOrigFolder,</span>
<a href="#l30.2199"></a><span id="l30.2199" class="difflineminus">-                                                                   aNewURI) {</span>
<a href="#l30.2200"></a><span id="l30.2200" class="difflineminus">-      let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l30.2201"></a><span id="l30.2201" class="difflineminus">-                                createInstance(Ci.nsISupportsArray);</span>
<a href="#l30.2202"></a><span id="l30.2202" class="difflineminus">-      aOrigFolder.ListDescendents(descendentFolders);</span>
<a href="#l30.2203"></a><span id="l30.2203" class="difflineminus">-</span>
<a href="#l30.2204"></a><span id="l30.2204" class="difflineminus">-      let origURI = aOrigFolder.URI;</span>
<a href="#l30.2205"></a><span id="l30.2205" class="difflineminus">-      // this rename is straightforward.</span>
<a href="#l30.2206"></a><span id="l30.2206" class="difflineminus">-      GlodaDatastore.renameFolder(aOrigFolder, aNewURI);</span>
<a href="#l30.2207"></a><span id="l30.2207" class="difflineminus">-</span>
<a href="#l30.2208"></a><span id="l30.2208" class="difflineminus">-      for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l30.2209"></a><span id="l30.2209" class="difflineminus">-        let oldSubURI = folder.URI;</span>
<a href="#l30.2210"></a><span id="l30.2210" class="difflineminus">-        // mangle a new URI from the old URI.  we could also try and do a</span>
<a href="#l30.2211"></a><span id="l30.2211" class="difflineminus">-        //  parallel traversal of the new folder hierarchy, but that seems like</span>
<a href="#l30.2212"></a><span id="l30.2212" class="difflineminus">-        //  more work.</span>
<a href="#l30.2213"></a><span id="l30.2213" class="difflineminus">-        let newSubURI = aNewURI + oldSubURI.substring(origURI.length)</span>
<a href="#l30.2214"></a><span id="l30.2214" class="difflineminus">-        this.indexer._datastore.renameFolder(oldSubURI, newSubURI);</span>
<a href="#l30.2215"></a><span id="l30.2215" class="difflineminus">-      }</span>
<a href="#l30.2216"></a><span id="l30.2216" class="difflineminus">-</span>
<a href="#l30.2217"></a><span id="l30.2217" class="difflineminus">-      this.indexer._log.debug(&quot;folder renamed: &quot; + origURI + &quot; to &quot; + aNewURI);</span>
<a href="#l30.2218"></a><span id="l30.2218" class="difflineminus">-    },</span>
<a href="#l30.2219"></a><span id="l30.2219" class="difflineminus">-</span>
<a href="#l30.2220"></a><span id="l30.2220" class="difflineminus">-    /**</span>
<a href="#l30.2221"></a><span id="l30.2221" class="difflineminus">-     * Handle folder renames, dispatching to our rename helper (which also</span>
<a href="#l30.2222"></a><span id="l30.2222" class="difflineminus">-     *  takes care of any nested folder issues.)</span>
<a href="#l30.2223"></a><span id="l30.2223" class="difflineminus">-     */</span>
<a href="#l30.2224"></a><span id="l30.2224" class="difflineminus">-    folderRenamed: function gloda_indexer_folderRenamed(aOrigFolder,</span>
<a href="#l30.2225"></a><span id="l30.2225" class="difflineminus">-                                                        aNewFolder) {</span>
<a href="#l30.2226"></a><span id="l30.2226" class="difflineminus">-      this._folderRenameHelper(aOrigFolder, aNewFolder.URI);</span>
<a href="#l30.2227"></a><span id="l30.2227" class="difflineminus">-    },</span>
<a href="#l30.2228"></a><span id="l30.2228" class="difflineminus">-</span>
<a href="#l30.2229"></a><span id="l30.2229" class="difflineminus">-    itemEvent: function gloda_indexer_itemEvent(aItem, aEvent, aData) {</span>
<a href="#l30.2230"></a><span id="l30.2230" class="difflineminus">-      // nop.  this is an expansion method on the part of the interface and has</span>
<a href="#l30.2231"></a><span id="l30.2231" class="difflineminus">-      //  no known events that we need to handle.</span>
<a href="#l30.2232"></a><span id="l30.2232" class="difflineminus">-    },</span>
<a href="#l30.2233"></a><span id="l30.2233" class="difflineminus">-  },</span>
<a href="#l30.2234"></a><span id="l30.2234" class="difflineminus">-</span>
<a href="#l30.2235"></a><span id="l30.2235" class="difflineminus">-  /**</span>
<a href="#l30.2236"></a><span id="l30.2236" class="difflineminus">-   * A nsIFolderListener (listening on nsIMsgMailSession so we get all of</span>
<a href="#l30.2237"></a><span id="l30.2237" class="difflineminus">-   *  these events) PRIMARILY to get folder loaded notifications.  Because of</span>
<a href="#l30.2238"></a><span id="l30.2238" class="difflineminus">-   *  deficiencies in the nsIMsgFolderListener's events at this time, we also</span>
<a href="#l30.2239"></a><span id="l30.2239" class="difflineminus">-   *  get our folder-added and newsgroup notifications from here for now.  (This</span>
<a href="#l30.2240"></a><span id="l30.2240" class="difflineminus">-   *  will be rectified.)</span>
<a href="#l30.2241"></a><span id="l30.2241" class="difflineminus">-   */</span>
<a href="#l30.2242"></a><span id="l30.2242" class="difflineminus">-  _folderListener: {</span>
<a href="#l30.2243"></a><span id="l30.2243" class="difflineminus">-    indexer: null,</span>
<a href="#l30.2244"></a><span id="l30.2244" class="difflineminus">-    _kFolderLoadedAtom: null,</span>
<a href="#l30.2245"></a><span id="l30.2245" class="difflineminus">-    _kKeywordsAtom: null,</span>
<a href="#l30.2246"></a><span id="l30.2246" class="difflineminus">-    _kStatusAtom: null,</span>
<a href="#l30.2247"></a><span id="l30.2247" class="difflineminus">-    _kFlaggedAtom: null,</span>
<a href="#l30.2248"></a><span id="l30.2248" class="difflineminus">-    _kJunkStatusChangedAtom: null,</span>
<a href="#l30.2249"></a><span id="l30.2249" class="difflineminus">-</span>
<a href="#l30.2250"></a><span id="l30.2250" class="difflineminus">-    _init: function gloda_indexer_fl_init(aIndexer) {</span>
<a href="#l30.2251"></a><span id="l30.2251" class="difflineminus">-      this.indexer = aIndexer;</span>
<a href="#l30.2252"></a><span id="l30.2252" class="difflineminus">-      let atomService = Cc[&quot;@mozilla.org/atom-service;1&quot;].</span>
<a href="#l30.2253"></a><span id="l30.2253" class="difflineminus">-                        getService(Ci.nsIAtomService);</span>
<a href="#l30.2254"></a><span id="l30.2254" class="difflineminus">-      this._kFolderLoadedAtom = atomService.getAtom(&quot;FolderLoaded&quot;);</span>
<a href="#l30.2255"></a><span id="l30.2255" class="difflineminus">-      // we explicitly know about these things rather than bothering with some</span>
<a href="#l30.2256"></a><span id="l30.2256" class="difflineminus">-      //  form of registration scheme because these aren't going to change much.</span>
<a href="#l30.2257"></a><span id="l30.2257" class="difflineminus">-      this._kKeywordsAtom = atomService.getAtom(&quot;Keywords&quot;);</span>
<a href="#l30.2258"></a><span id="l30.2258" class="difflineminus">-      this._kStatusAtom = atomService.getAtom(&quot;Status&quot;);</span>
<a href="#l30.2259"></a><span id="l30.2259" class="difflineminus">-      this._kFlaggedAtom = atomService.getAtom(&quot;Flagged&quot;);</span>
<a href="#l30.2260"></a><span id="l30.2260" class="difflineminus">-      this._kJunkStatusChangedAtom = atomService.getAtom(&quot;JunkStatusChanged&quot;);</span>
<a href="#l30.2261"></a><span id="l30.2261" class="difflineminus">-    },</span>
<a href="#l30.2262"></a><span id="l30.2262" class="difflineminus">-</span>
<a href="#l30.2263"></a><span id="l30.2263" class="difflineminus">-    /**</span>
<a href="#l30.2264"></a><span id="l30.2264" class="difflineminus">-     * Helper method to do the leg-work associated with flagging a message</span>
<a href="#l30.2265"></a><span id="l30.2265" class="difflineminus">-     *  for re-indexing because of some change in meta-state that happened to</span>
<a href="#l30.2266"></a><span id="l30.2266" class="difflineminus">-     *  it.  Job-wise, we treat this as a message addition; we are uniquely</span>
<a href="#l30.2267"></a><span id="l30.2267" class="difflineminus">-     *  identifying the message by providing its folder ID and message key, and</span>
<a href="#l30.2268"></a><span id="l30.2268" class="difflineminus">-     *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l30.2269"></a><span id="l30.2269" class="difflineminus">-     */</span>
<a href="#l30.2270"></a><span id="l30.2270" class="difflineminus">-    _reindexChangedMessage: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l30.2271"></a><span id="l30.2271" class="difflineminus">-        aMsgHdr) {</span>
<a href="#l30.2272"></a><span id="l30.2272" class="difflineminus">-      // make sure the message is eligible for indexing...</span>
<a href="#l30.2273"></a><span id="l30.2273" class="difflineminus">-      let msgFolder = aMsgHdr.folder;</span>
<a href="#l30.2274"></a><span id="l30.2274" class="difflineminus">-      if (!this.indexer.shouldIndexFolder(msgFolder))</span>
<a href="#l30.2275"></a><span id="l30.2275" class="difflineminus">-        return;</span>
<a href="#l30.2276"></a><span id="l30.2276" class="difflineminus">-</span>
<a href="#l30.2277"></a><span id="l30.2277" class="difflineminus">-      // Make sure the message is eligible for indexing.</span>
<a href="#l30.2278"></a><span id="l30.2278" class="difflineminus">-      // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l30.2279"></a><span id="l30.2279" class="difflineminus">-      // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l30.2280"></a><span id="l30.2280" class="difflineminus">-      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l30.2281"></a><span id="l30.2281" class="difflineminus">-      if (!isFolderLocal) {</span>
<a href="#l30.2282"></a><span id="l30.2282" class="difflineminus">-        if (!(aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l30.2283"></a><span id="l30.2283" class="difflineminus">-            (msgFolder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l30.2284"></a><span id="l30.2284" class="difflineminus">-          return;</span>
<a href="#l30.2285"></a><span id="l30.2285" class="difflineminus">-      }</span>
<a href="#l30.2286"></a><span id="l30.2286" class="difflineminus">-</span>
<a href="#l30.2287"></a><span id="l30.2287" class="difflineminus">-      // mark the message as dirty</span>
<a href="#l30.2288"></a><span id="l30.2288" class="difflineminus">-      // (We could check for the presence of the gloda message id property</span>
<a href="#l30.2289"></a><span id="l30.2289" class="difflineminus">-      //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l30.2290"></a><span id="l30.2290" class="difflineminus">-      //  not sure whether it is worth the high-probability exception cost.)</span>
<a href="#l30.2291"></a><span id="l30.2291" class="difflineminus">-      aMsgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l30.2292"></a><span id="l30.2292" class="difflineminus">-      // mark the folder dirty too, so we know to look inside</span>
<a href="#l30.2293"></a><span id="l30.2293" class="difflineminus">-      let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l30.2294"></a><span id="l30.2294" class="difflineminus">-      glodaFolder.dirtyStatus = true;</span>
<a href="#l30.2295"></a><span id="l30.2295" class="difflineminus">-</span>
<a href="#l30.2296"></a><span id="l30.2296" class="difflineminus">-      if (this.indexer._pendingAddJob === null) {</span>
<a href="#l30.2297"></a><span id="l30.2297" class="difflineminus">-        this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l30.2298"></a><span id="l30.2298" class="difflineminus">-        this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l30.2299"></a><span id="l30.2299" class="difflineminus">-        this.indexer._indexingJobGoal++;</span>
<a href="#l30.2300"></a><span id="l30.2300" class="difflineminus">-      }</span>
<a href="#l30.2301"></a><span id="l30.2301" class="difflineminus">-      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l30.2302"></a><span id="l30.2302" class="difflineminus">-      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l30.2303"></a><span id="l30.2303" class="difflineminus">-          this.indexer._indexMaxEventQueueMessages) {</span>
<a href="#l30.2304"></a><span id="l30.2304" class="difflineminus">-        this.indexer._pendingAddJob.items.push(</span>
<a href="#l30.2305"></a><span id="l30.2305" class="difflineminus">-          [GlodaDatastore._mapFolder(msgFolder).id,</span>
<a href="#l30.2306"></a><span id="l30.2306" class="difflineminus">-           aMsgHdr.messageKey]);</span>
<a href="#l30.2307"></a><span id="l30.2307" class="difflineminus">-        this.indexer.indexing = true;</span>
<a href="#l30.2308"></a><span id="l30.2308" class="difflineminus">-      }</span>
<a href="#l30.2309"></a><span id="l30.2309" class="difflineminus">-      else {</span>
<a href="#l30.2310"></a><span id="l30.2310" class="difflineminus">-        this.indexer.indexingSweepNeeded = true;</span>
<a href="#l30.2311"></a><span id="l30.2311" class="difflineminus">-      }</span>
<a href="#l30.2312"></a><span id="l30.2312" class="difflineminus">-    },</span>
<a href="#l30.2313"></a><span id="l30.2313" class="difflineminus">-</span>
<a href="#l30.2314"></a><span id="l30.2314" class="difflineminus">-    OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l30.2315"></a><span id="l30.2315" class="difflineminus">-    },</span>
<a href="#l30.2316"></a><span id="l30.2316" class="difflineminus">-    OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l30.2317"></a><span id="l30.2317" class="difflineminus">-    },</span>
<a href="#l30.2318"></a><span id="l30.2318" class="difflineminus">-    OnItemPropertyChanged: function gloda_indexer_OnItemPropertyChanged(</span>
<a href="#l30.2319"></a><span id="l30.2319" class="difflineminus">-                             aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l30.2320"></a><span id="l30.2320" class="difflineminus">-    },</span>
<a href="#l30.2321"></a><span id="l30.2321" class="difflineminus">-    OnItemIntPropertyChanged: function gloda_indexer_OnItemIntPropertyChanged(</span>
<a href="#l30.2322"></a><span id="l30.2322" class="difflineminus">-                                aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l30.2323"></a><span id="l30.2323" class="difflineminus">-    },</span>
<a href="#l30.2324"></a><span id="l30.2324" class="difflineminus">-    OnItemBoolPropertyChanged: function gloda_indexer_OnItemBoolPropertyChanged(</span>
<a href="#l30.2325"></a><span id="l30.2325" class="difflineminus">-                                aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l30.2326"></a><span id="l30.2326" class="difflineminus">-    },</span>
<a href="#l30.2327"></a><span id="l30.2327" class="difflineminus">-    OnItemUnicharPropertyChanged:</span>
<a href="#l30.2328"></a><span id="l30.2328" class="difflineminus">-        function gloda_indexer_OnItemUnicharPropertyChanged(</span>
<a href="#l30.2329"></a><span id="l30.2329" class="difflineminus">-          aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l30.2330"></a><span id="l30.2330" class="difflineminus">-</span>
<a href="#l30.2331"></a><span id="l30.2331" class="difflineminus">-    },</span>
<a href="#l30.2332"></a><span id="l30.2332" class="difflineminus">-    /**</span>
<a href="#l30.2333"></a><span id="l30.2333" class="difflineminus">-     * Notice when user activity changes a message's status, or automated</span>
<a href="#l30.2334"></a><span id="l30.2334" class="difflineminus">-     *  junk processing flags a message as junk.</span>
<a href="#l30.2335"></a><span id="l30.2335" class="difflineminus">-     */</span>
<a href="#l30.2336"></a><span id="l30.2336" class="difflineminus">-    OnItemPropertyFlagChanged: function gloda_indexer_OnItemPropertyFlagChanged(</span>
<a href="#l30.2337"></a><span id="l30.2337" class="difflineminus">-                                aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l30.2338"></a><span id="l30.2338" class="difflineminus">-      if (aProperty == this._kKeywordsAtom ||</span>
<a href="#l30.2339"></a><span id="l30.2339" class="difflineminus">-          aProperty == this._kStatusAtom ||</span>
<a href="#l30.2340"></a><span id="l30.2340" class="difflineminus">-          aProperty == this._kFlaggedAtom ||</span>
<a href="#l30.2341"></a><span id="l30.2341" class="difflineminus">-          aProperty == this._kJunkStatusChangedAtom) {</span>
<a href="#l30.2342"></a><span id="l30.2342" class="difflineminus">-        if (this.indexer.enabled) {</span>
<a href="#l30.2343"></a><span id="l30.2343" class="difflineminus">-          this.indexer._log.debug(&quot;ItemPropertyFlagChanged notification&quot;);</span>
<a href="#l30.2344"></a><span id="l30.2344" class="difflineminus">-          this._reindexChangedMessage(aMsgHdr);</span>
<a href="#l30.2345"></a><span id="l30.2345" class="difflineminus">-        }</span>
<a href="#l30.2346"></a><span id="l30.2346" class="difflineminus">-      }</span>
<a href="#l30.2347"></a><span id="l30.2347" class="difflineminus">-    },</span>
<a href="#l30.2348"></a><span id="l30.2348" class="difflineminus">-</span>
<a href="#l30.2349"></a><span id="l30.2349" class="difflineminus">-    /**</span>
<a href="#l30.2350"></a><span id="l30.2350" class="difflineminus">-     * Get folder loaded notifications for folders that had to do some</span>
<a href="#l30.2351"></a><span id="l30.2351" class="difflineminus">-     *  (asynchronous) processing before they could be opened.</span>
<a href="#l30.2352"></a><span id="l30.2352" class="difflineminus">-     */</span>
<a href="#l30.2353"></a><span id="l30.2353" class="difflineminus">-    OnItemEvent: function gloda_indexer_OnItemEvent(aFolder, aEvent) {</span>
<a href="#l30.2354"></a><span id="l30.2354" class="difflineminus">-      if (aEvent == this._kFolderLoadedAtom)</span>
<a href="#l30.2355"></a><span id="l30.2355" class="difflineminus">-        this.indexer._onFolderLoaded(aFolder);</span>
<a href="#l30.2356"></a><span id="l30.2356" class="difflineminus">-    },</span>
<a href="#l30.2357"></a><span id="l30.2357" class="difflineminus">-  },</span>
<a href="#l30.2358"></a><span id="l30.2358" class="difflineminus">-</span>
<a href="#l30.2359"></a><span id="l30.2359" class="difflineminus">-  /* ***** Rebuilding / Reindexing ***** */</span>
<a href="#l30.2360"></a><span id="l30.2360" class="difflineminus">-  // TODO: implement a folder observer doodad to handle rebuilding / reindexing</span>
<a href="#l30.2361"></a><span id="l30.2361" class="difflineminus">-  /**</span>
<a href="#l30.2362"></a><span id="l30.2362" class="difflineminus">-   * Allow us to invalidate an outstanding folder traversal because the</span>
<a href="#l30.2363"></a><span id="l30.2363" class="difflineminus">-   *  underlying database is going away.  We use other means for detecting</span>
<a href="#l30.2364"></a><span id="l30.2364" class="difflineminus">-   *  modifications of the message (labeling, marked (un)read, starred, etc.)</span>
<a href="#l30.2365"></a><span id="l30.2365" class="difflineminus">-   *</span>
<a href="#l30.2366"></a><span id="l30.2366" class="difflineminus">-   * This is an nsIDBChangeListener listening to an nsIDBChangeAnnouncer.  To</span>
<a href="#l30.2367"></a><span id="l30.2367" class="difflineminus">-   *  add ourselves, we get us a nice nsMsgDatabase, query it to the announcer,</span>
<a href="#l30.2368"></a><span id="l30.2368" class="difflineminus">-   *  then call AddListener.</span>
<a href="#l30.2369"></a><span id="l30.2369" class="difflineminus">-   */</span>
<a href="#l30.2370"></a><span id="l30.2370" class="difflineminus">-  _databaseAnnouncerListener: {</span>
<a href="#l30.2371"></a><span id="l30.2371" class="difflineminus">-    indexer: null,</span>
<a href="#l30.2372"></a><span id="l30.2372" class="difflineminus">-    onAnnouncerGoingAway: function gloda_indexer_dbGoingAway(</span>
<a href="#l30.2373"></a><span id="l30.2373" class="difflineminus">-                                         aDBChangeAnnouncer) {</span>
<a href="#l30.2374"></a><span id="l30.2374" class="difflineminus">-      this.indexer._indexerLeaveFolder(false);</span>
<a href="#l30.2375"></a><span id="l30.2375" class="difflineminus">-    },</span>
<a href="#l30.2376"></a><span id="l30.2376" class="difflineminus">-</span>
<a href="#l30.2377"></a><span id="l30.2377" class="difflineminus">-    onHdrFlagsChanged: function(aHdrChanged, aOldFlags, aNewFlags, aInstigator) {},</span>
<a href="#l30.2378"></a><span id="l30.2378" class="difflineminus">-    onHdrDeleted: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l30.2379"></a><span id="l30.2379" class="difflineminus">-    onHdrAdded: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l30.2380"></a><span id="l30.2380" class="difflineminus">-    onParentChanged: function(aKeyChanged, aOldParent, aNewParent,</span>
<a href="#l30.2381"></a><span id="l30.2381" class="difflineminus">-                              aInstigator) {},</span>
<a href="#l30.2382"></a><span id="l30.2382" class="difflineminus">-    onReadChanged: function(aInstigator) {},</span>
<a href="#l30.2383"></a><span id="l30.2383" class="difflineminus">-    onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l30.2384"></a><span id="l30.2384" class="difflineminus">-    onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l30.2385"></a><span id="l30.2385" class="difflineminus">-                                    aInstigator) {},</span>
<a href="#l30.2386"></a><span id="l30.2386" class="difflineminus">-    onEvent: function (aDB, aEvent) {},</span>
<a href="#l30.2387"></a><span id="l30.2387" class="difflineminus">-  },</span>
<a href="#l30.2388"></a><span id="l30.2388" class="difflineminus">-</span>
<a href="#l30.2389"></a><span id="l30.2389" class="difflineminus">-  _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l30.2390"></a><span id="l30.2390" class="difflineminus">-    let logDebug = this._log.level &lt;= Log4Moz.Level.Debug;</span>
<a href="#l30.2391"></a><span id="l30.2391" class="difflineminus">-    if (logDebug)</span>
<a href="#l30.2392"></a><span id="l30.2392" class="difflineminus">-      this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l30.2393"></a><span id="l30.2393" class="difflineminus">-                      aMsgHdr.subject);</span>
<a href="#l30.2394"></a><span id="l30.2394" class="difflineminus">-</span>
<a href="#l30.2395"></a><span id="l30.2395" class="difflineminus">-    // If the message is offline, then get the message body as well</span>
<a href="#l30.2396"></a><span id="l30.2396" class="difflineminus">-    let isMsgOffline = false;</span>
<a href="#l30.2397"></a><span id="l30.2397" class="difflineminus">-    let aMimeMsg;</span>
<a href="#l30.2398"></a><span id="l30.2398" class="difflineminus">-    if ((aMsgHdr.flags &amp; Ci.nsMsgMessageFlags.Offline) ||</span>
<a href="#l30.2399"></a><span id="l30.2399" class="difflineminus">-        (aMsgHdr.folder instanceof Ci.nsIMsgLocalMailFolder)) {</span>
<a href="#l30.2400"></a><span id="l30.2400" class="difflineminus">-      isMsgOffline = true;</span>
<a href="#l30.2401"></a><span id="l30.2401" class="difflineminus">-      MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l30.2402"></a><span id="l30.2402" class="difflineminus">-          aCallbackHandle.callback);</span>
<a href="#l30.2403"></a><span id="l30.2403" class="difflineminus">-      [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l30.2404"></a><span id="l30.2404" class="difflineminus">-    }</span>
<a href="#l30.2405"></a><span id="l30.2405" class="difflineminus">-    else {</span>
<a href="#l30.2406"></a><span id="l30.2406" class="difflineminus">-      if (logDebug)</span>
<a href="#l30.2407"></a><span id="l30.2407" class="difflineminus">-        this._log.debug(&quot;  * Message is not offline -- only headers indexed&quot;);</span>
<a href="#l30.2408"></a><span id="l30.2408" class="difflineminus">-    }</span>
<a href="#l30.2409"></a><span id="l30.2409" class="difflineminus">-</span>
<a href="#l30.2410"></a><span id="l30.2410" class="difflineminus">-    if (logDebug)</span>
<a href="#l30.2411"></a><span id="l30.2411" class="difflineminus">-      this._log.debug(&quot;  * Got message, subject &quot; + aMsgHdr.subject);</span>
<a href="#l30.2412"></a><span id="l30.2412" class="difflineminus">-</span>
<a href="#l30.2413"></a><span id="l30.2413" class="difflineminus">-    if (this._unitTestSuperVerbose) {</span>
<a href="#l30.2414"></a><span id="l30.2414" class="difflineminus">-      if (aMimeMsg)</span>
<a href="#l30.2415"></a><span id="l30.2415" class="difflineminus">-        this._log.debug(&quot;  * Got Mime &quot; + aMimeMsg.prettyString());</span>
<a href="#l30.2416"></a><span id="l30.2416" class="difflineminus">-      else</span>
<a href="#l30.2417"></a><span id="l30.2417" class="difflineminus">-        this._log.debug(&quot;  * NO MIME MESSAGE!!!\n&quot;);</span>
<a href="#l30.2418"></a><span id="l30.2418" class="difflineminus">-    }</span>
<a href="#l30.2419"></a><span id="l30.2419" class="difflineminus">-</span>
<a href="#l30.2420"></a><span id="l30.2420" class="difflineminus">-    // -- Find/create the conversation the message belongs to.</span>
<a href="#l30.2421"></a><span id="l30.2421" class="difflineminus">-    // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l30.2422"></a><span id="l30.2422" class="difflineminus">-    //  a conversation.</span>
<a href="#l30.2423"></a><span id="l30.2423" class="difflineminus">-</span>
<a href="#l30.2424"></a><span id="l30.2424" class="difflineminus">-    // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l30.2425"></a><span id="l30.2425" class="difflineminus">-    // (references are ordered from old [0] to new [n-1])</span>
<a href="#l30.2426"></a><span id="l30.2426" class="difflineminus">-    let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l30.2427"></a><span id="l30.2427" class="difflineminus">-                      (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l30.2428"></a><span id="l30.2428" class="difflineminus">-    // also see if we already know about the message...</span>
<a href="#l30.2429"></a><span id="l30.2429" class="difflineminus">-    references.push(aMsgHdr.messageId);</span>
<a href="#l30.2430"></a><span id="l30.2430" class="difflineminus">-</span>
<a href="#l30.2431"></a><span id="l30.2431" class="difflineminus">-    Gloda.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l30.2432"></a><span id="l30.2432" class="difflineminus">-                                 aCallbackHandle.callbackThis);</span>
<a href="#l30.2433"></a><span id="l30.2433" class="difflineminus">-    // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l30.2434"></a><span id="l30.2434" class="difflineminus">-    let ancestorLists = yield this.kWorkAsync;</span>
<a href="#l30.2435"></a><span id="l30.2435" class="difflineminus">-</span>
<a href="#l30.2436"></a><span id="l30.2436" class="difflineminus">-    if (logDebug) {</span>
<a href="#l30.2437"></a><span id="l30.2437" class="difflineminus">-      this._log.debug(&quot;ancestors raw: &quot; + ancestorLists);</span>
<a href="#l30.2438"></a><span id="l30.2438" class="difflineminus">-      this._log.debug(&quot;ref len: &quot; + references.length + &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l30.2439"></a><span id="l30.2439" class="difflineminus">-      this._log.debug(&quot;references: &quot; + Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l30.2440"></a><span id="l30.2440" class="difflineminus">-      this._log.debug(&quot;ancestors: &quot; + Log4Moz.enumerateProperties(ancestorLists).join(&quot;,&quot;));</span>
<a href="#l30.2441"></a><span id="l30.2441" class="difflineminus">-    }</span>
<a href="#l30.2442"></a><span id="l30.2442" class="difflineminus">-</span>
<a href="#l30.2443"></a><span id="l30.2443" class="difflineminus">-    // pull our current message lookup results off</span>
<a href="#l30.2444"></a><span id="l30.2444" class="difflineminus">-    references.pop();</span>
<a href="#l30.2445"></a><span id="l30.2445" class="difflineminus">-    let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l30.2446"></a><span id="l30.2446" class="difflineminus">-</span>
<a href="#l30.2447"></a><span id="l30.2447" class="difflineminus">-    let conversationID = null;</span>
<a href="#l30.2448"></a><span id="l30.2448" class="difflineminus">-    let conversation = null;</span>
<a href="#l30.2449"></a><span id="l30.2449" class="difflineminus">-    // -- figure out the conversation ID</span>
<a href="#l30.2450"></a><span id="l30.2450" class="difflineminus">-    // if we have a clone/already exist, just use his conversation ID</span>
<a href="#l30.2451"></a><span id="l30.2451" class="difflineminus">-    if (candidateCurMsgs.length &gt; 0) {</span>
<a href="#l30.2452"></a><span id="l30.2452" class="difflineminus">-      conversationID = candidateCurMsgs[0].conversationID;</span>
<a href="#l30.2453"></a><span id="l30.2453" class="difflineminus">-      conversation = candidateCurMsgs[0].conversation;</span>
<a href="#l30.2454"></a><span id="l30.2454" class="difflineminus">-    }</span>
<a href="#l30.2455"></a><span id="l30.2455" class="difflineminus">-    // otherwise check out our ancestors</span>
<a href="#l30.2456"></a><span id="l30.2456" class="difflineminus">-    else {</span>
<a href="#l30.2457"></a><span id="l30.2457" class="difflineminus">-      // (walk from closest to furthest ancestor)</span>
<a href="#l30.2458"></a><span id="l30.2458" class="difflineminus">-      for (let iAncestor = ancestorLists.length-1; iAncestor &gt;= 0;</span>
<a href="#l30.2459"></a><span id="l30.2459" class="difflineminus">-          --iAncestor) {</span>
<a href="#l30.2460"></a><span id="l30.2460" class="difflineminus">-        let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l30.2461"></a><span id="l30.2461" class="difflineminus">-</span>
<a href="#l30.2462"></a><span id="l30.2462" class="difflineminus">-        if (ancestorList.length &gt; 0) {</span>
<a href="#l30.2463"></a><span id="l30.2463" class="difflineminus">-          // we only care about the first instance of the message because we are</span>
<a href="#l30.2464"></a><span id="l30.2464" class="difflineminus">-          //  able to guarantee the invariant that all messages with the same</span>
<a href="#l30.2465"></a><span id="l30.2465" class="difflineminus">-          //  message id belong to the same conversation.</span>
<a href="#l30.2466"></a><span id="l30.2466" class="difflineminus">-          let ancestor = ancestorList[0];</span>
<a href="#l30.2467"></a><span id="l30.2467" class="difflineminus">-          if (conversationID === null) {</span>
<a href="#l30.2468"></a><span id="l30.2468" class="difflineminus">-            conversationID = ancestor.conversationID;</span>
<a href="#l30.2469"></a><span id="l30.2469" class="difflineminus">-            conversation = ancestor.conversation;</span>
<a href="#l30.2470"></a><span id="l30.2470" class="difflineminus">-          }</span>
<a href="#l30.2471"></a><span id="l30.2471" class="difflineminus">-          else if (conversationID != ancestor.conversationID)</span>
<a href="#l30.2472"></a><span id="l30.2472" class="difflineminus">-            this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l30.2473"></a><span id="l30.2473" class="difflineminus">-                            ancestor.headerMessageID + &quot;.  It has conv id &quot; +</span>
<a href="#l30.2474"></a><span id="l30.2474" class="difflineminus">-                            ancestor.conversationID + &quot; but expected &quot; +</span>
<a href="#l30.2475"></a><span id="l30.2475" class="difflineminus">-                            conversationID + &quot;. ID: &quot; + ancestor.id);</span>
<a href="#l30.2476"></a><span id="l30.2476" class="difflineminus">-        }</span>
<a href="#l30.2477"></a><span id="l30.2477" class="difflineminus">-      }</span>
<a href="#l30.2478"></a><span id="l30.2478" class="difflineminus">-    }</span>
<a href="#l30.2479"></a><span id="l30.2479" class="difflineminus">-</span>
<a href="#l30.2480"></a><span id="l30.2480" class="difflineminus">-    // nobody had one?  create a new conversation</span>
<a href="#l30.2481"></a><span id="l30.2481" class="difflineminus">-    if (conversationID === null) {</span>
<a href="#l30.2482"></a><span id="l30.2482" class="difflineminus">-      // (the create method could issue the id, making the call return</span>
<a href="#l30.2483"></a><span id="l30.2483" class="difflineminus">-      //  without waiting for the database...)</span>
<a href="#l30.2484"></a><span id="l30.2484" class="difflineminus">-      conversation = this._datastore.createConversation(</span>
<a href="#l30.2485"></a><span id="l30.2485" class="difflineminus">-          aMsgHdr.mime2DecodedSubject, null, null);</span>
<a href="#l30.2486"></a><span id="l30.2486" class="difflineminus">-      conversationID = conversation.id;</span>
<a href="#l30.2487"></a><span id="l30.2487" class="difflineminus">-    }</span>
<a href="#l30.2488"></a><span id="l30.2488" class="difflineminus">-</span>
<a href="#l30.2489"></a><span id="l30.2489" class="difflineminus">-    // Walk from furthest to closest ancestor, creating the ancestors that don't</span>
<a href="#l30.2490"></a><span id="l30.2490" class="difflineminus">-    //  exist. (This is possible if previous messages that were consumed in this</span>
<a href="#l30.2491"></a><span id="l30.2491" class="difflineminus">-    //  thread only had an in-reply-to or for some reason did not otherwise</span>
<a href="#l30.2492"></a><span id="l30.2492" class="difflineminus">-    //  provide the full references chain.)</span>
<a href="#l30.2493"></a><span id="l30.2493" class="difflineminus">-    for (let iAncestor = 0; iAncestor &lt; ancestorLists.length; ++iAncestor) {</span>
<a href="#l30.2494"></a><span id="l30.2494" class="difflineminus">-      let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l30.2495"></a><span id="l30.2495" class="difflineminus">-</span>
<a href="#l30.2496"></a><span id="l30.2496" class="difflineminus">-      if (ancestorList.length == 0) {</span>
<a href="#l30.2497"></a><span id="l30.2497" class="difflineminus">-        if (logDebug)</span>
<a href="#l30.2498"></a><span id="l30.2498" class="difflineminus">-          this._log.debug(&quot;creating message with: null, &quot; + conversationID +</span>
<a href="#l30.2499"></a><span id="l30.2499" class="difflineminus">-                          &quot;, &quot; + references[iAncestor] +</span>
<a href="#l30.2500"></a><span id="l30.2500" class="difflineminus">-                          &quot;, null.&quot;);</span>
<a href="#l30.2501"></a><span id="l30.2501" class="difflineminus">-        let ancestor = this._datastore.createMessage(null, null, // ghost</span>
<a href="#l30.2502"></a><span id="l30.2502" class="difflineminus">-                                                     conversationID, null,</span>
<a href="#l30.2503"></a><span id="l30.2503" class="difflineminus">-                                                     references[iAncestor],</span>
<a href="#l30.2504"></a><span id="l30.2504" class="difflineminus">-                                                     null, // no subject</span>
<a href="#l30.2505"></a><span id="l30.2505" class="difflineminus">-                                                     null, // no body</span>
<a href="#l30.2506"></a><span id="l30.2506" class="difflineminus">-                                                     null); // no attachments</span>
<a href="#l30.2507"></a><span id="l30.2507" class="difflineminus">-        this._datastore.insertMessage(ancestor);</span>
<a href="#l30.2508"></a><span id="l30.2508" class="difflineminus">-        ancestorLists[iAncestor].push(ancestor);</span>
<a href="#l30.2509"></a><span id="l30.2509" class="difflineminus">-      }</span>
<a href="#l30.2510"></a><span id="l30.2510" class="difflineminus">-    }</span>
<a href="#l30.2511"></a><span id="l30.2511" class="difflineminus">-    // now all our ancestors exist, though they may be ghost-like...</span>
<a href="#l30.2512"></a><span id="l30.2512" class="difflineminus">-</span>
<a href="#l30.2513"></a><span id="l30.2513" class="difflineminus">-    // find if there's a ghost version of our message or we already have indexed</span>
<a href="#l30.2514"></a><span id="l30.2514" class="difflineminus">-    //  this message.</span>
<a href="#l30.2515"></a><span id="l30.2515" class="difflineminus">-    let curMsg = null;</span>
<a href="#l30.2516"></a><span id="l30.2516" class="difflineminus">-    if (logDebug)</span>
<a href="#l30.2517"></a><span id="l30.2517" class="difflineminus">-      this._log.debug(candidateCurMsgs.length + &quot; candidate messages&quot;);</span>
<a href="#l30.2518"></a><span id="l30.2518" class="difflineminus">-    for (let iCurCand = 0; iCurCand &lt; candidateCurMsgs.length; iCurCand++) {</span>
<a href="#l30.2519"></a><span id="l30.2519" class="difflineminus">-      let candMsg = candidateCurMsgs[iCurCand];</span>
<a href="#l30.2520"></a><span id="l30.2520" class="difflineminus">-</span>
<a href="#l30.2521"></a><span id="l30.2521" class="difflineminus">-      if (logDebug)</span>
<a href="#l30.2522"></a><span id="l30.2522" class="difflineminus">-        this._log.debug(&quot;candidate folderID: &quot; + candMsg.folderID +</span>
<a href="#l30.2523"></a><span id="l30.2523" class="difflineminus">-                        &quot; messageKey: &quot; + candMsg.messageKey);</span>
<a href="#l30.2524"></a><span id="l30.2524" class="difflineminus">-</span>
<a href="#l30.2525"></a><span id="l30.2525" class="difflineminus">-      if (candMsg.folderURI == aMsgHdr.folder.URI) {</span>
<a href="#l30.2526"></a><span id="l30.2526" class="difflineminus">-        // if we are in the same folder and we have the same message key, we</span>
<a href="#l30.2527"></a><span id="l30.2527" class="difflineminus">-        //  are definitely the same, stop looking.</span>
<a href="#l30.2528"></a><span id="l30.2528" class="difflineminus">-        if (candMsg.messageKey == aMsgHdr.messageKey) {</span>
<a href="#l30.2529"></a><span id="l30.2529" class="difflineminus">-          curMsg = candMsg;</span>
<a href="#l30.2530"></a><span id="l30.2530" class="difflineminus">-          break;</span>
<a href="#l30.2531"></a><span id="l30.2531" class="difflineminus">-        }</span>
<a href="#l30.2532"></a><span id="l30.2532" class="difflineminus">-        // if (we are in the same folder and) the candidate message has a null</span>
<a href="#l30.2533"></a><span id="l30.2533" class="difflineminus">-        //  message key, we treat it as our best option unless we find an exact</span>
<a href="#l30.2534"></a><span id="l30.2534" class="difflineminus">-        //  key match. (this would happen because the 'move' notification case</span>
<a href="#l30.2535"></a><span id="l30.2535" class="difflineminus">-        //  has to deal with not knowing the target message key.  this case</span>
<a href="#l30.2536"></a><span id="l30.2536" class="difflineminus">-        //  will hopefully be somewhat improved in the future to not go through</span>
<a href="#l30.2537"></a><span id="l30.2537" class="difflineminus">-        //  this path which mandates re-indexing of the message in its entirety)</span>
<a href="#l30.2538"></a><span id="l30.2538" class="difflineminus">-        if (candMsg.messageKey === null)</span>
<a href="#l30.2539"></a><span id="l30.2539" class="difflineminus">-          curMsg = candMsg;</span>
<a href="#l30.2540"></a><span id="l30.2540" class="difflineminus">-        // if (we are in the same folder and) the candidate message's underlying</span>
<a href="#l30.2541"></a><span id="l30.2541" class="difflineminus">-        //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l30.2542"></a><span id="l30.2542" class="difflineminus">-        //  were betrayed by a re-indexing or something, but we have to make</span>
<a href="#l30.2543"></a><span id="l30.2543" class="difflineminus">-        //  sure a perfect match doesn't turn up.</span>
<a href="#l30.2544"></a><span id="l30.2544" class="difflineminus">-        else if ((curMsg === null) &amp;&amp;</span>
<a href="#l30.2545"></a><span id="l30.2545" class="difflineminus">-                 (aMsgHdr.folder.GetMessageHeader(candMsg.messageKey) === null))</span>
<a href="#l30.2546"></a><span id="l30.2546" class="difflineminus">-          curMsg = candMsg;</span>
<a href="#l30.2547"></a><span id="l30.2547" class="difflineminus">-      }</span>
<a href="#l30.2548"></a><span id="l30.2548" class="difflineminus">-      // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l30.2549"></a><span id="l30.2549" class="difflineminus">-      else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l30.2550"></a><span id="l30.2550" class="difflineminus">-        curMsg = candMsg;</span>
<a href="#l30.2551"></a><span id="l30.2551" class="difflineminus">-      }</span>
<a href="#l30.2552"></a><span id="l30.2552" class="difflineminus">-    }</span>
<a href="#l30.2553"></a><span id="l30.2553" class="difflineminus">-</span>
<a href="#l30.2554"></a><span id="l30.2554" class="difflineminus">-    let attachmentNames = null;</span>
<a href="#l30.2555"></a><span id="l30.2555" class="difflineminus">-    if (aMimeMsg) {</span>
<a href="#l30.2556"></a><span id="l30.2556" class="difflineminus">-      attachmentNames = [att.name for each</span>
<a href="#l30.2557"></a><span id="l30.2557" class="difflineminus">-                         ([i, att] in Iterator(aMimeMsg.allAttachments))</span>
<a href="#l30.2558"></a><span id="l30.2558" class="difflineminus">-                         if (att.isRealAttachment)];</span>
<a href="#l30.2559"></a><span id="l30.2559" class="difflineminus">-    }</span>
<a href="#l30.2560"></a><span id="l30.2560" class="difflineminus">-</span>
<a href="#l30.2561"></a><span id="l30.2561" class="difflineminus">-    let isConceptuallyNew, isRecordNew;</span>
<a href="#l30.2562"></a><span id="l30.2562" class="difflineminus">-    if (curMsg === null) {</span>
<a href="#l30.2563"></a><span id="l30.2563" class="difflineminus">-      curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l30.2564"></a><span id="l30.2564" class="difflineminus">-                                             aMsgHdr.messageKey,</span>
<a href="#l30.2565"></a><span id="l30.2565" class="difflineminus">-                                             conversationID,</span>
<a href="#l30.2566"></a><span id="l30.2566" class="difflineminus">-                                             aMsgHdr.date,</span>
<a href="#l30.2567"></a><span id="l30.2567" class="difflineminus">-                                             aMsgHdr.messageId);</span>
<a href="#l30.2568"></a><span id="l30.2568" class="difflineminus">-      curMsg._conversation = conversation;</span>
<a href="#l30.2569"></a><span id="l30.2569" class="difflineminus">-      isConceptuallyNew = isRecordNew = true;</span>
<a href="#l30.2570"></a><span id="l30.2570" class="difflineminus">-    }</span>
<a href="#l30.2571"></a><span id="l30.2571" class="difflineminus">-    else {</span>
<a href="#l30.2572"></a><span id="l30.2572" class="difflineminus">-      isRecordNew = false;</span>
<a href="#l30.2573"></a><span id="l30.2573" class="difflineminus">-      isConceptuallyNew = (curMsg._folderID === null); // aka was-a-ghost</span>
<a href="#l30.2574"></a><span id="l30.2574" class="difflineminus">-      // (messageKey can be null if it's not new in the move-case)</span>
<a href="#l30.2575"></a><span id="l30.2575" class="difflineminus">-      curMsg._folderID = this._datastore._mapFolder(aMsgHdr.folder).id;</span>
<a href="#l30.2576"></a><span id="l30.2576" class="difflineminus">-      curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l30.2577"></a><span id="l30.2577" class="difflineminus">-      curMsg.date = new Date(aMsgHdr.date / 1000);</span>
<a href="#l30.2578"></a><span id="l30.2578" class="difflineminus">-      // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l30.2579"></a><span id="l30.2579" class="difflineminus">-      //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l30.2580"></a><span id="l30.2580" class="difflineminus">-      //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l30.2581"></a><span id="l30.2581" class="difflineminus">-      //  that there are cases where this is not true.</span>
<a href="#l30.2582"></a><span id="l30.2582" class="difflineminus">-    }</span>
<a href="#l30.2583"></a><span id="l30.2583" class="difflineminus">-</span>
<a href="#l30.2584"></a><span id="l30.2584" class="difflineminus">-    if (aMimeMsg) {</span>
<a href="#l30.2585"></a><span id="l30.2585" class="difflineminus">-      let bodyPlain = aMimeMsg.coerceBodyToPlaintext(aMsgHdr.folder);</span>
<a href="#l30.2586"></a><span id="l30.2586" class="difflineminus">-      if (bodyPlain) {</span>
<a href="#l30.2587"></a><span id="l30.2587" class="difflineminus">-        curMsg._bodyLines = bodyPlain.split(/\r?\n/);</span>
<a href="#l30.2588"></a><span id="l30.2588" class="difflineminus">-        // curMsg._content gets set by fundattr.js</span>
<a href="#l30.2589"></a><span id="l30.2589" class="difflineminus">-      }</span>
<a href="#l30.2590"></a><span id="l30.2590" class="difflineminus">-    }</span>
<a href="#l30.2591"></a><span id="l30.2591" class="difflineminus">-</span>
<a href="#l30.2592"></a><span id="l30.2592" class="difflineminus">-    if (isConceptuallyNew) {</span>
<a href="#l30.2593"></a><span id="l30.2593" class="difflineminus">-      curMsg._isNew = true;</span>
<a href="#l30.2594"></a><span id="l30.2594" class="difflineminus">-      // curMsg._indexedBodyText is set by GlodaDatastore.insertMessage or</span>
<a href="#l30.2595"></a><span id="l30.2595" class="difflineminus">-      //  GlodaDatastore.updateMessage</span>
<a href="#l30.2596"></a><span id="l30.2596" class="difflineminus">-    }</span>
<a href="#l30.2597"></a><span id="l30.2597" class="difflineminus">-</span>
<a href="#l30.2598"></a><span id="l30.2598" class="difflineminus">-    curMsg._subject = aMsgHdr.mime2DecodedSubject;</span>
<a href="#l30.2599"></a><span id="l30.2599" class="difflineminus">-    curMsg._attachmentNames = attachmentNames;</span>
<a href="#l30.2600"></a><span id="l30.2600" class="difflineminus">-</span>
<a href="#l30.2601"></a><span id="l30.2601" class="difflineminus">-    // curMsg._indexAuthor gets set by fundattr.js</span>
<a href="#l30.2602"></a><span id="l30.2602" class="difflineminus">-    // curMsg._indexRecipients gets set by fundattr.js</span>
<a href="#l30.2603"></a><span id="l30.2603" class="difflineminus">-</span>
<a href="#l30.2604"></a><span id="l30.2604" class="difflineminus">-    // zero the notability so everything in grokNounItem can just increment</span>
<a href="#l30.2605"></a><span id="l30.2605" class="difflineminus">-    curMsg.notability = 0;</span>
<a href="#l30.2606"></a><span id="l30.2606" class="difflineminus">-</span>
<a href="#l30.2607"></a><span id="l30.2607" class="difflineminus">-    yield aCallbackHandle.pushAndGo(</span>
<a href="#l30.2608"></a><span id="l30.2608" class="difflineminus">-        Gloda.grokNounItem(curMsg,</span>
<a href="#l30.2609"></a><span id="l30.2609" class="difflineminus">-            {header: aMsgHdr, mime: aMimeMsg, bodyLines: curMsg._bodyLines},</span>
<a href="#l30.2610"></a><span id="l30.2610" class="difflineminus">-            isConceptuallyNew, isRecordNew,</span>
<a href="#l30.2611"></a><span id="l30.2611" class="difflineminus">-            aCallbackHandle));</span>
<a href="#l30.2612"></a><span id="l30.2612" class="difflineminus">-</span>
<a href="#l30.2613"></a><span id="l30.2613" class="difflineminus">-    delete curMsg._bodyLines;</span>
<a href="#l30.2614"></a><span id="l30.2614" class="difflineminus">-    delete curMsg._content;</span>
<a href="#l30.2615"></a><span id="l30.2615" class="difflineminus">-    delete curMsg._isNew;</span>
<a href="#l30.2616"></a><span id="l30.2616" class="difflineminus">-    delete curMsg._indexAuthor;</span>
<a href="#l30.2617"></a><span id="l30.2617" class="difflineminus">-    delete curMsg._indexRecipients;</span>
<a href="#l30.2618"></a><span id="l30.2618" class="difflineminus">-</span>
<a href="#l30.2619"></a><span id="l30.2619" class="difflineminus">-    // we want to update the header for messages only after the transaction</span>
<a href="#l30.2620"></a><span id="l30.2620" class="difflineminus">-    //  irrevocably hits the disk.  otherwise we could get confused if the</span>
<a href="#l30.2621"></a><span id="l30.2621" class="difflineminus">-    //  transaction rolls back or what not.</span>
<a href="#l30.2622"></a><span id="l30.2622" class="difflineminus">-    GlodaDatastore.runPostCommit(MakeCleanMsgHdrCallback(aMsgHdr, curMsg.id));</span>
<a href="#l30.2623"></a><span id="l30.2623" class="difflineminus">-</span>
<a href="#l30.2624"></a><span id="l30.2624" class="difflineminus">-    yield this.kWorkDone;</span>
<a href="#l30.2625"></a><span id="l30.2625" class="difflineminus">-  },</span>
<a href="#l30.2626"></a><span id="l30.2626" class="difflineminus">-</span>
<a href="#l30.2627"></a><span id="l30.2627" class="difflineminus">-  /**</span>
<a href="#l30.2628"></a><span id="l30.2628" class="difflineminus">-   * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l30.2629"></a><span id="l30.2629" class="difflineminus">-   *  tricky than one would first expect because there are potentially</span>
<a href="#l30.2630"></a><span id="l30.2630" class="difflineminus">-   *  attributes not immediately associated with this message that reference</span>
<a href="#l30.2631"></a><span id="l30.2631" class="difflineminus">-   *  the message.  Not only that, but deletion of messages may leave a</span>
<a href="#l30.2632"></a><span id="l30.2632" class="difflineminus">-   *  conversation posessing only ghost messages, which we don't want, so we</span>
<a href="#l30.2633"></a><span id="l30.2633" class="difflineminus">-   *  need to nuke the moot conversation and its moot ghost messages.</span>
<a href="#l30.2634"></a><span id="l30.2634" class="difflineminus">-   * For now, we are actually punting on that trickiness, and the exact</span>
<a href="#l30.2635"></a><span id="l30.2635" class="difflineminus">-   *  nuances aren't defined yet because we have not decided whether to store</span>
<a href="#l30.2636"></a><span id="l30.2636" class="difflineminus">-   *  such attributes redundantly.  For example, if we have subject-pred-object,</span>
<a href="#l30.2637"></a><span id="l30.2637" class="difflineminus">-   *  we could actually store this as attributes (subject, id, object) and</span>
<a href="#l30.2638"></a><span id="l30.2638" class="difflineminus">-   *  (object, id, subject).  In such a case, we could query on (subject, *)</span>
<a href="#l30.2639"></a><span id="l30.2639" class="difflineminus">-   *  and use the results to delete the (object, id, subject) case.  If we</span>
<a href="#l30.2640"></a><span id="l30.2640" class="difflineminus">-   *  don't redundantly store attributes, we can deal with the problem by</span>
<a href="#l30.2641"></a><span id="l30.2641" class="difflineminus">-   *  collecting up all the attributes that accept a message as their object</span>
<a href="#l30.2642"></a><span id="l30.2642" class="difflineminus">-   *  type and issuing a delete against that.  For example, delete (*, [1,2,3],</span>
<a href="#l30.2643"></a><span id="l30.2643" class="difflineminus">-   *  message id).</span>
<a href="#l30.2644"></a><span id="l30.2644" class="difflineminus">-   * (We are punting because we haven't implemented support for generating</span>
<a href="#l30.2645"></a><span id="l30.2645" class="difflineminus">-   *  attributes like that yet.)</span>
<a href="#l30.2646"></a><span id="l30.2646" class="difflineminus">-   *</span>
<a href="#l30.2647"></a><span id="l30.2647" class="difflineminus">-   * @TODO: implement deletion of attributes that reference (deleted) messages</span>
<a href="#l30.2648"></a><span id="l30.2648" class="difflineminus">-   */</span>
<a href="#l30.2649"></a><span id="l30.2649" class="difflineminus">-  _deleteMessage: function gloda_index_deleteMessage(aMessage) {</span>
<a href="#l30.2650"></a><span id="l30.2650" class="difflineminus">-    // -- delete our attributes</span>
<a href="#l30.2651"></a><span id="l30.2651" class="difflineminus">-    // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l30.2652"></a><span id="l30.2652" class="difflineminus">-    //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l30.2653"></a><span id="l30.2653" class="difflineminus">-    //  schema but the back-end ignores it)</span>
<a href="#l30.2654"></a><span id="l30.2654" class="difflineminus">-    aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l30.2655"></a><span id="l30.2655" class="difflineminus">-</span>
<a href="#l30.2656"></a><span id="l30.2656" class="difflineminus">-    // -- delete our message or ghost us, and maybe nuke the whole conversation</span>
<a href="#l30.2657"></a><span id="l30.2657" class="difflineminus">-    // look at the other messages in the conversation.</span>
<a href="#l30.2658"></a><span id="l30.2658" class="difflineminus">-    let conversationCollection = aMessage.conversation.getMessagesCollection(</span>
<a href="#l30.2659"></a><span id="l30.2659" class="difflineminus">-        aCallbackHandle);</span>
<a href="#l30.2660"></a><span id="l30.2660" class="difflineminus">-    yield this.kWorkAsync;</span>
<a href="#l30.2661"></a><span id="l30.2661" class="difflineminus">-    let conversationMsgs = conversationCollection.items;</span>
<a href="#l30.2662"></a><span id="l30.2662" class="difflineminus">-</span>
<a href="#l30.2663"></a><span id="l30.2663" class="difflineminus">-    let ghosts = [];</span>
<a href="#l30.2664"></a><span id="l30.2664" class="difflineminus">-    let twinMessage = null;</span>
<a href="#l30.2665"></a><span id="l30.2665" class="difflineminus">-    for (let iMsg = 0; iMsg &lt; conversationMsgs.length; iMsg++) {</span>
<a href="#l30.2666"></a><span id="l30.2666" class="difflineminus">-      let convMsg = conversationMsgs[iMsg];</span>
<a href="#l30.2667"></a><span id="l30.2667" class="difflineminus">-</span>
<a href="#l30.2668"></a><span id="l30.2668" class="difflineminus">-      // ignore our message</span>
<a href="#l30.2669"></a><span id="l30.2669" class="difflineminus">-      if (convMsg.id == aMessage.id)</span>
<a href="#l30.2670"></a><span id="l30.2670" class="difflineminus">-        continue;</span>
<a href="#l30.2671"></a><span id="l30.2671" class="difflineminus">-</span>
<a href="#l30.2672"></a><span id="l30.2672" class="difflineminus">-      if (convMsg.folderID !== null) {</span>
<a href="#l30.2673"></a><span id="l30.2673" class="difflineminus">-        if (convMsg.headerMessageID == aMessage.headerMessageID) {</span>
<a href="#l30.2674"></a><span id="l30.2674" class="difflineminus">-          twinMessage = convMsg;</span>
<a href="#l30.2675"></a><span id="l30.2675" class="difflineminus">-        }</span>
<a href="#l30.2676"></a><span id="l30.2676" class="difflineminus">-      }</span>
<a href="#l30.2677"></a><span id="l30.2677" class="difflineminus">-      else {</span>
<a href="#l30.2678"></a><span id="l30.2678" class="difflineminus">-        ghosts.push(convMsg);</span>
<a href="#l30.2679"></a><span id="l30.2679" class="difflineminus">-      }</span>
<a href="#l30.2680"></a><span id="l30.2680" class="difflineminus">-    }</span>
<a href="#l30.2681"></a><span id="l30.2681" class="difflineminus">-</span>
<a href="#l30.2682"></a><span id="l30.2682" class="difflineminus">-    // is everyone else a ghost? (note that conversationMsgs includes us, but</span>
<a href="#l30.2683"></a><span id="l30.2683" class="difflineminus">-    //  ghosts cannot)</span>
<a href="#l30.2684"></a><span id="l30.2684" class="difflineminus">-    if ((conversationMsgs.length - 1) == ghosts.length) {</span>
<a href="#l30.2685"></a><span id="l30.2685" class="difflineminus">-      // obliterate the conversation including aMessage.</span>
<a href="#l30.2686"></a><span id="l30.2686" class="difflineminus">-      // since everyone else is a ghost they have no attributes.  however, the</span>
<a href="#l30.2687"></a><span id="l30.2687" class="difflineminus">-      //  conversation may some day have attributes targeted against it, so it</span>
<a href="#l30.2688"></a><span id="l30.2688" class="difflineminus">-      //  gets a helper.</span>
<a href="#l30.2689"></a><span id="l30.2689" class="difflineminus">-      this._deleteConversationOfMessage(aMessage);</span>
<a href="#l30.2690"></a><span id="l30.2690" class="difflineminus">-      aMessage._nuke();</span>
<a href="#l30.2691"></a><span id="l30.2691" class="difflineminus">-    }</span>
<a href="#l30.2692"></a><span id="l30.2692" class="difflineminus">-    else { // there is at least one real message out there, so the only q is...</span>
<a href="#l30.2693"></a><span id="l30.2693" class="difflineminus">-      // do we have a twin (so it's okay to delete us) or do we become a ghost?</span>
<a href="#l30.2694"></a><span id="l30.2694" class="difflineminus">-      if (twinMessage !== null) { // just delete us</span>
<a href="#l30.2695"></a><span id="l30.2695" class="difflineminus">-        aMessage._datastore.deleteMessageByID(aMessage.id);</span>
<a href="#l30.2696"></a><span id="l30.2696" class="difflineminus">-        aMessage._nuke();</span>
<a href="#l30.2697"></a><span id="l30.2697" class="difflineminus">-      }</span>
<a href="#l30.2698"></a><span id="l30.2698" class="difflineminus">-      else { // ghost us</span>
<a href="#l30.2699"></a><span id="l30.2699" class="difflineminus">-        aMessage._ghost();</span>
<a href="#l30.2700"></a><span id="l30.2700" class="difflineminus">-        aMessage._datastore.updateMessage(aMessage);</span>
<a href="#l30.2701"></a><span id="l30.2701" class="difflineminus">-      }</span>
<a href="#l30.2702"></a><span id="l30.2702" class="difflineminus">-    }</span>
<a href="#l30.2703"></a><span id="l30.2703" class="difflineminus">-</span>
<a href="#l30.2704"></a><span id="l30.2704" class="difflineminus">-    yield this.kWorkDone;</span>
<a href="#l30.2705"></a><span id="l30.2705" class="difflineminus">-  },</span>
<a href="#l30.2706"></a><span id="l30.2706" class="difflineminus">-</span>
<a href="#l30.2707"></a><span id="l30.2707" class="difflineminus">-  /**</span>
<a href="#l30.2708"></a><span id="l30.2708" class="difflineminus">-   * Delete an entire conversation, using the passed-in message which must be</span>
<a href="#l30.2709"></a><span id="l30.2709" class="difflineminus">-   *  the last non-ghost in the conversation and have its attributes all</span>
<a href="#l30.2710"></a><span id="l30.2710" class="difflineminus">-   *  deleted.  This function issues the batch delete of all the ghosts (and the</span>
<a href="#l30.2711"></a><span id="l30.2711" class="difflineminus">-   *  message), and in the future will take care to nuke any attributes</span>
<a href="#l30.2712"></a><span id="l30.2712" class="difflineminus">-   *  referencing the conversation.</span>
<a href="#l30.2713"></a><span id="l30.2713" class="difflineminus">-   */</span>
<a href="#l30.2714"></a><span id="l30.2714" class="difflineminus">-  _deleteConversationOfMessage:</span>
<a href="#l30.2715"></a><span id="l30.2715" class="difflineminus">-      function gloda_index_deleteConversationOfMessage(aMessage) {</span>
<a href="#l30.2716"></a><span id="l30.2716" class="difflineminus">-    aMessage._datastore.deleteMessagesByConversationID(aMessage.conversationID);</span>
<a href="#l30.2717"></a><span id="l30.2717" class="difflineminus">-    aMessage._datastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l30.2718"></a><span id="l30.2718" class="difflineminus">-  },</span>
<a href="#l30.2719"></a><span id="l30.2719"> };</span>
<a href="#l30.2720"></a><span id="l30.2720"> GlodaIndexer._init();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/mailnews/db/gloda/modules/log4moz.js</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/log4moz.js</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -183,16 +183,17 @@ let Log4Moz = {</span>
<a href="#l31.4"></a><span id="l31.4"> </span>
<a href="#l31.5"></a><span id="l31.5">   get LogMessage() { return LogMessage; },</span>
<a href="#l31.6"></a><span id="l31.6">   get Logger() { return Logger; },</span>
<a href="#l31.7"></a><span id="l31.7">   get LoggerRepository() { return LoggerRepository; },</span>
<a href="#l31.8"></a><span id="l31.8"> </span>
<a href="#l31.9"></a><span id="l31.9">   get Formatter() { return Formatter; },</span>
<a href="#l31.10"></a><span id="l31.10">   get BasicFormatter() { return BasicFormatter; },</span>
<a href="#l31.11"></a><span id="l31.11">   get XMLFormatter() { return XMLFormatter; },</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineplus">+  get JSONFormatter() { return JSONFormatter; },</span>
<a href="#l31.13"></a><span id="l31.13">   get Appender() { return Appender; },</span>
<a href="#l31.14"></a><span id="l31.14">   get DumpAppender() { return DumpAppender; },</span>
<a href="#l31.15"></a><span id="l31.15">   get ConsoleAppender() { return ConsoleAppender; },</span>
<a href="#l31.16"></a><span id="l31.16">   get FileAppender() { return FileAppender; },</span>
<a href="#l31.17"></a><span id="l31.17">   get SocketAppender() { return SocketAppender; },</span>
<a href="#l31.18"></a><span id="l31.18">   get RotatingFileAppender() { return RotatingFileAppender; },</span>
<a href="#l31.19"></a><span id="l31.19">   get ThrowingAppender() { return ThrowingAppender; },</span>
<a href="#l31.20"></a><span id="l31.20"> </span>
<a href="#l31.21"></a><span id="l31.21" class="difflineat">@@ -231,39 +232,61 @@ let Log4Moz = {</span>
<a href="#l31.22"></a><span id="l31.22">         properties.push(p + &quot; = &quot; + ex);</span>
<a href="#l31.23"></a><span id="l31.23">       }</span>
<a href="#l31.24"></a><span id="l31.24">     }</span>
<a href="#l31.25"></a><span id="l31.25"> </span>
<a href="#l31.26"></a><span id="l31.26">     return properties;</span>
<a href="#l31.27"></a><span id="l31.27">   }</span>
<a href="#l31.28"></a><span id="l31.28"> };</span>
<a href="#l31.29"></a><span id="l31.29"> </span>
<a href="#l31.30"></a><span id="l31.30" class="difflineplus">+function LoggerContext() {</span>
<a href="#l31.31"></a><span id="l31.31" class="difflineplus">+  this._started = this.lastStateChange = Date.now();</span>
<a href="#l31.32"></a><span id="l31.32" class="difflineplus">+  this._state = &quot;started&quot;;</span>
<a href="#l31.33"></a><span id="l31.33" class="difflineplus">+}</span>
<a href="#l31.34"></a><span id="l31.34" class="difflineplus">+LoggerContext.prototype = {</span>
<a href="#l31.35"></a><span id="l31.35" class="difflineplus">+  _jsonMe: true,</span>
<a href="#l31.36"></a><span id="l31.36" class="difflineplus">+  _id: &quot;unknown&quot;,</span>
<a href="#l31.37"></a><span id="l31.37" class="difflineplus">+  setState: function LoggerContext_state(aState) {</span>
<a href="#l31.38"></a><span id="l31.38" class="difflineplus">+    this._state = aState;</span>
<a href="#l31.39"></a><span id="l31.39" class="difflineplus">+    this._lastStateChange = Date.now();</span>
<a href="#l31.40"></a><span id="l31.40" class="difflineplus">+    return this;</span>
<a href="#l31.41"></a><span id="l31.41" class="difflineplus">+  },</span>
<a href="#l31.42"></a><span id="l31.42" class="difflineplus">+  finish: function LoggerContext_finish() {</span>
<a href="#l31.43"></a><span id="l31.43" class="difflineplus">+    this._finished = Date.now();</span>
<a href="#l31.44"></a><span id="l31.44" class="difflineplus">+    this._state = &quot;finished&quot;;</span>
<a href="#l31.45"></a><span id="l31.45" class="difflineplus">+    return this;</span>
<a href="#l31.46"></a><span id="l31.46" class="difflineplus">+  },</span>
<a href="#l31.47"></a><span id="l31.47" class="difflineplus">+  toString: function LoggerContext_toString() {</span>
<a href="#l31.48"></a><span id="l31.48" class="difflineplus">+    return &quot;[Context: &quot; + this._id + &quot; state: &quot; + this._state + &quot;]&quot;;</span>
<a href="#l31.49"></a><span id="l31.49" class="difflineplus">+  }</span>
<a href="#l31.50"></a><span id="l31.50" class="difflineplus">+};</span>
<a href="#l31.51"></a><span id="l31.51" class="difflineplus">+</span>
<a href="#l31.52"></a><span id="l31.52"> </span>
<a href="#l31.53"></a><span id="l31.53"> /*</span>
<a href="#l31.54"></a><span id="l31.54">  * LogMessage</span>
<a href="#l31.55"></a><span id="l31.55">  * Encapsulates a single log event's data</span>
<a href="#l31.56"></a><span id="l31.56">  */</span>
<a href="#l31.57"></a><span id="l31.57" class="difflineminus">-function LogMessage(loggerName, level, message){</span>
<a href="#l31.58"></a><span id="l31.58" class="difflineplus">+function LogMessage(loggerName, level, messageObjects){</span>
<a href="#l31.59"></a><span id="l31.59">   this.loggerName = loggerName;</span>
<a href="#l31.60"></a><span id="l31.60" class="difflineminus">-  this.message = message;</span>
<a href="#l31.61"></a><span id="l31.61" class="difflineplus">+  this.messageObjects = messageObjects;</span>
<a href="#l31.62"></a><span id="l31.62">   this.level = level;</span>
<a href="#l31.63"></a><span id="l31.63">   this.time = Date.now();</span>
<a href="#l31.64"></a><span id="l31.64"> }</span>
<a href="#l31.65"></a><span id="l31.65"> LogMessage.prototype = {</span>
<a href="#l31.66"></a><span id="l31.66">   QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),</span>
<a href="#l31.67"></a><span id="l31.67"> </span>
<a href="#l31.68"></a><span id="l31.68">   get levelDesc() {</span>
<a href="#l31.69"></a><span id="l31.69">     if (this.level in Log4Moz.Level.Desc)</span>
<a href="#l31.70"></a><span id="l31.70">       return Log4Moz.Level.Desc[this.level];</span>
<a href="#l31.71"></a><span id="l31.71">     return &quot;UNKNOWN&quot;;</span>
<a href="#l31.72"></a><span id="l31.72">   },</span>
<a href="#l31.73"></a><span id="l31.73"> </span>
<a href="#l31.74"></a><span id="l31.74">   toString: function LogMsg_toString(){</span>
<a href="#l31.75"></a><span id="l31.75">     return &quot;LogMessage [&quot; + this.time + &quot; &quot; + this.level + &quot; &quot; +</span>
<a href="#l31.76"></a><span id="l31.76" class="difflineminus">-      this.message + &quot;]&quot;;</span>
<a href="#l31.77"></a><span id="l31.77" class="difflineplus">+      this.messageObjects + &quot;]&quot;;</span>
<a href="#l31.78"></a><span id="l31.78">   }</span>
<a href="#l31.79"></a><span id="l31.79"> };</span>
<a href="#l31.80"></a><span id="l31.80"> </span>
<a href="#l31.81"></a><span id="l31.81"> /*</span>
<a href="#l31.82"></a><span id="l31.82">  * Logger</span>
<a href="#l31.83"></a><span id="l31.83">  * Hierarchical version.  Logs to all appenders, assigned or inherited</span>
<a href="#l31.84"></a><span id="l31.84">  */</span>
<a href="#l31.85"></a><span id="l31.85"> </span>
<a href="#l31.86"></a><span id="l31.86" class="difflineat">@@ -310,45 +333,62 @@ Logger.prototype = {</span>
<a href="#l31.87"></a><span id="l31.87">   addAppender: function Logger_addAppender(appender) {</span>
<a href="#l31.88"></a><span id="l31.88">     for (let i = 0; i &lt; this._appenders.length; i++) {</span>
<a href="#l31.89"></a><span id="l31.89">       if (this._appenders[i] == appender)</span>
<a href="#l31.90"></a><span id="l31.90">         return;</span>
<a href="#l31.91"></a><span id="l31.91">     }</span>
<a href="#l31.92"></a><span id="l31.92">     this._appenders.push(appender);</span>
<a href="#l31.93"></a><span id="l31.93">   },</span>
<a href="#l31.94"></a><span id="l31.94"> </span>
<a href="#l31.95"></a><span id="l31.95" class="difflineplus">+  _nextContextId: 0,</span>
<a href="#l31.96"></a><span id="l31.96" class="difflineplus">+  newContext: function Logger_newContext(objWithProps) {</span>
<a href="#l31.97"></a><span id="l31.97" class="difflineplus">+    if (!(&quot;_id&quot; in objWithProps))</span>
<a href="#l31.98"></a><span id="l31.98" class="difflineplus">+      objWithProps._id = this._name + &quot;:&quot; + (++this._nextContextId);</span>
<a href="#l31.99"></a><span id="l31.99" class="difflineplus">+    objWithProps.__proto__ = LoggerContext.prototype;</span>
<a href="#l31.100"></a><span id="l31.100" class="difflineplus">+    objWithProps._isContext = true;</span>
<a href="#l31.101"></a><span id="l31.101" class="difflineplus">+    LoggerContext.call(objWithProps);</span>
<a href="#l31.102"></a><span id="l31.102" class="difflineplus">+    return objWithProps;</span>
<a href="#l31.103"></a><span id="l31.103" class="difflineplus">+  },</span>
<a href="#l31.104"></a><span id="l31.104" class="difflineplus">+</span>
<a href="#l31.105"></a><span id="l31.105">   log: function Logger_log(message) {</span>
<a href="#l31.106"></a><span id="l31.106">     if (this.level &gt; message.level)</span>
<a href="#l31.107"></a><span id="l31.107">       return;</span>
<a href="#l31.108"></a><span id="l31.108">     let appenders = this.appenders;</span>
<a href="#l31.109"></a><span id="l31.109">     for (let i = 0; i &lt; appenders.length; i++){</span>
<a href="#l31.110"></a><span id="l31.110">       appenders[i].append(message);</span>
<a href="#l31.111"></a><span id="l31.111">     }</span>
<a href="#l31.112"></a><span id="l31.112">   },</span>
<a href="#l31.113"></a><span id="l31.113"> </span>
<a href="#l31.114"></a><span id="l31.114" class="difflineminus">-  fatal: function Logger_fatal(string) {</span>
<a href="#l31.115"></a><span id="l31.115" class="difflineminus">-    this.log(new LogMessage(this._name, Log4Moz.Level.Fatal, string));</span>
<a href="#l31.116"></a><span id="l31.116" class="difflineminus">-  },</span>
<a href="#l31.117"></a><span id="l31.117" class="difflineminus">-  error: function Logger_error(string) {</span>
<a href="#l31.118"></a><span id="l31.118" class="difflineminus">-    this.log(new LogMessage(this._name, Log4Moz.Level.Error, string));</span>
<a href="#l31.119"></a><span id="l31.119" class="difflineminus">-  },</span>
<a href="#l31.120"></a><span id="l31.120" class="difflineminus">-  warn: function Logger_warn(string) {</span>
<a href="#l31.121"></a><span id="l31.121" class="difflineminus">-    this.log(new LogMessage(this._name, Log4Moz.Level.Warn, string));</span>
<a href="#l31.122"></a><span id="l31.122" class="difflineplus">+  fatal: function Logger_fatal() {</span>
<a href="#l31.123"></a><span id="l31.123" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Fatal,</span>
<a href="#l31.124"></a><span id="l31.124" class="difflineplus">+                            Array.prototype.slice.call(arguments)));</span>
<a href="#l31.125"></a><span id="l31.125">   },</span>
<a href="#l31.126"></a><span id="l31.126" class="difflineminus">-  info: function Logger_info(string) {</span>
<a href="#l31.127"></a><span id="l31.127" class="difflineminus">-    this.log(new LogMessage(this._name, Log4Moz.Level.Info, string));</span>
<a href="#l31.128"></a><span id="l31.128" class="difflineminus">-  },</span>
<a href="#l31.129"></a><span id="l31.129" class="difflineminus">-  config: function Logger_config(string) {</span>
<a href="#l31.130"></a><span id="l31.130" class="difflineminus">-    this.log(new LogMessage(this._name, Log4Moz.Level.Config, string));</span>
<a href="#l31.131"></a><span id="l31.131" class="difflineminus">-  },</span>
<a href="#l31.132"></a><span id="l31.132" class="difflineminus">-  debug: function Logger_debug(string) {</span>
<a href="#l31.133"></a><span id="l31.133" class="difflineminus">-    this.log(new LogMessage(this._name, Log4Moz.Level.Debug, string));</span>
<a href="#l31.134"></a><span id="l31.134" class="difflineminus">-  },</span>
<a href="#l31.135"></a><span id="l31.135" class="difflineminus">-  trace: function Logger_trace(string) {</span>
<a href="#l31.136"></a><span id="l31.136" class="difflineminus">-    this.log(new LogMessage(this._name, Log4Moz.Level.Trace, string));</span>
<a href="#l31.137"></a><span id="l31.137" class="difflineplus">+  error: function Logger_error() {</span>
<a href="#l31.138"></a><span id="l31.138" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Error,</span>
<a href="#l31.139"></a><span id="l31.139" class="difflineplus">+                            Array.prototype.slice.call(arguments)));</span>
<a href="#l31.140"></a><span id="l31.140" class="difflineplus">+   },</span>
<a href="#l31.141"></a><span id="l31.141" class="difflineplus">+  warn: function Logger_warn() {</span>
<a href="#l31.142"></a><span id="l31.142" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Warn,</span>
<a href="#l31.143"></a><span id="l31.143" class="difflineplus">+                            Array.prototype.slice.call(arguments)));</span>
<a href="#l31.144"></a><span id="l31.144" class="difflineplus">+   },</span>
<a href="#l31.145"></a><span id="l31.145" class="difflineplus">+  info: function Logger_info() {</span>
<a href="#l31.146"></a><span id="l31.146" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Info,</span>
<a href="#l31.147"></a><span id="l31.147" class="difflineplus">+                            Array.prototype.slice.call(arguments)));</span>
<a href="#l31.148"></a><span id="l31.148" class="difflineplus">+   },</span>
<a href="#l31.149"></a><span id="l31.149" class="difflineplus">+  config: function Logger_config() {</span>
<a href="#l31.150"></a><span id="l31.150" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Config,</span>
<a href="#l31.151"></a><span id="l31.151" class="difflineplus">+                            Array.prototype.slice.call(arguments)));</span>
<a href="#l31.152"></a><span id="l31.152" class="difflineplus">+   },</span>
<a href="#l31.153"></a><span id="l31.153" class="difflineplus">+  debug: function Logger_debug() {</span>
<a href="#l31.154"></a><span id="l31.154" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Debug,</span>
<a href="#l31.155"></a><span id="l31.155" class="difflineplus">+                            Array.prototype.slice.call(arguments)));</span>
<a href="#l31.156"></a><span id="l31.156" class="difflineplus">+   },</span>
<a href="#l31.157"></a><span id="l31.157" class="difflineplus">+  trace: function Logger_trace() {</span>
<a href="#l31.158"></a><span id="l31.158" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Trace,</span>
<a href="#l31.159"></a><span id="l31.159" class="difflineplus">+                            Array.prototype.slice.call(arguments)));</span>
<a href="#l31.160"></a><span id="l31.160">   }</span>
<a href="#l31.161"></a><span id="l31.161"> };</span>
<a href="#l31.162"></a><span id="l31.162"> </span>
<a href="#l31.163"></a><span id="l31.163"> /*</span>
<a href="#l31.164"></a><span id="l31.164">  * LoggerRepository</span>
<a href="#l31.165"></a><span id="l31.165">  * Implements a hierarchy of Loggers</span>
<a href="#l31.166"></a><span id="l31.166">  */</span>
<a href="#l31.167"></a><span id="l31.167"> </span>
<a href="#l31.168"></a><span id="l31.168" class="difflineat">@@ -441,19 +481,22 @@ BasicFormatter.prototype = {</span>
<a href="#l31.169"></a><span id="l31.169">   },</span>
<a href="#l31.170"></a><span id="l31.170"> </span>
<a href="#l31.171"></a><span id="l31.171">   set dateFormat(format) {</span>
<a href="#l31.172"></a><span id="l31.172">     this._dateFormat = format;</span>
<a href="#l31.173"></a><span id="l31.173">   },</span>
<a href="#l31.174"></a><span id="l31.174"> </span>
<a href="#l31.175"></a><span id="l31.175">   format: function BF_format(message) {</span>
<a href="#l31.176"></a><span id="l31.176">     let date = new Date(message.time);</span>
<a href="#l31.177"></a><span id="l31.177" class="difflineplus">+    let messageString = [</span>
<a href="#l31.178"></a><span id="l31.178" class="difflineplus">+      ((typeof(mo) == &quot;object&quot;) ? mo.toString() : mo) for each</span>
<a href="#l31.179"></a><span id="l31.179" class="difflineplus">+      ([,mo] in Iterator(message.messageObjects))].join(&quot; &quot;);</span>
<a href="#l31.180"></a><span id="l31.180">     return date.toLocaleFormat(this.dateFormat) + &quot;\t&quot; +</span>
<a href="#l31.181"></a><span id="l31.181">       message.loggerName + &quot;\t&quot; + message.levelDesc + &quot;\t&quot; +</span>
<a href="#l31.182"></a><span id="l31.182" class="difflineminus">-      message.message + &quot;\n&quot;;</span>
<a href="#l31.183"></a><span id="l31.183" class="difflineplus">+      messageString + &quot;\n&quot;;</span>
<a href="#l31.184"></a><span id="l31.184">   }</span>
<a href="#l31.185"></a><span id="l31.185"> };</span>
<a href="#l31.186"></a><span id="l31.186"> </span>
<a href="#l31.187"></a><span id="l31.187"> /*</span>
<a href="#l31.188"></a><span id="l31.188">  * XMLFormatter</span>
<a href="#l31.189"></a><span id="l31.189">  * Format like log4j's XMLLayout.  The intent is that you can hook this up to</span>
<a href="#l31.190"></a><span id="l31.190">  * a SocketAppender and point them at a Chainsaw GUI running with an</span>
<a href="#l31.191"></a><span id="l31.191">  * XMLSocketReceiver running.  Then your output comes out in Chainsaw.</span>
<a href="#l31.192"></a><span id="l31.192" class="difflineat">@@ -461,25 +504,60 @@ BasicFormatter.prototype = {</span>
<a href="#l31.193"></a><span id="l31.193">  * filtering and conditional coloring.)</span>
<a href="#l31.194"></a><span id="l31.194">  */</span>
<a href="#l31.195"></a><span id="l31.195"> </span>
<a href="#l31.196"></a><span id="l31.196"> function XMLFormatter() {}</span>
<a href="#l31.197"></a><span id="l31.197"> XMLFormatter.prototype = {</span>
<a href="#l31.198"></a><span id="l31.198">   __proto__: Formatter.prototype,</span>
<a href="#l31.199"></a><span id="l31.199"> </span>
<a href="#l31.200"></a><span id="l31.200">   format: function XF_format(message) {</span>
<a href="#l31.201"></a><span id="l31.201" class="difflineminus">-    let cdataEscapedMessage = message.message.replace(CDATA_END,</span>
<a href="#l31.202"></a><span id="l31.202" class="difflineminus">-                                                      CDATA_ESCAPED_END, &quot;g&quot;);</span>
<a href="#l31.203"></a><span id="l31.203" class="difflineplus">+    let cdataEscapedMessage =</span>
<a href="#l31.204"></a><span id="l31.204" class="difflineplus">+      [((typeof(mo) == &quot;object&quot;) ? mo.toString() : mo) for each</span>
<a href="#l31.205"></a><span id="l31.205" class="difflineplus">+       ([,mo] in Iterator(message.messageObjects))]</span>
<a href="#l31.206"></a><span id="l31.206" class="difflineplus">+        .join(&quot; &quot;)</span>
<a href="#l31.207"></a><span id="l31.207" class="difflineplus">+        .replace(CDATA_END, CDATA_ESCAPED_END, &quot;g&quot;);</span>
<a href="#l31.208"></a><span id="l31.208">     return &quot;&lt;log4j:event logger='&quot; + message.loggerName + &quot;' &quot; +</span>
<a href="#l31.209"></a><span id="l31.209">                         &quot;level='&quot; + message.levelDesc + &quot;' thread='unknown' &quot; +</span>
<a href="#l31.210"></a><span id="l31.210">                         &quot;timestamp='&quot; + message.time + &quot;'&gt;&quot; +</span>
<a href="#l31.211"></a><span id="l31.211">       &quot;&lt;log4j:message&gt;&lt;![CDATA[&quot; + cdataEscapedMessage + &quot;]]&gt;&lt;/log4j:message&gt;&quot; +</span>
<a href="#l31.212"></a><span id="l31.212">       &quot;&lt;/log4j:event&gt;&quot;;</span>
<a href="#l31.213"></a><span id="l31.213">   }</span>
<a href="#l31.214"></a><span id="l31.214" class="difflineplus">+};</span>
<a href="#l31.215"></a><span id="l31.215" class="difflineplus">+</span>
<a href="#l31.216"></a><span id="l31.216" class="difflineplus">+function JSONFormatter() {</span>
<a href="#l31.217"></a><span id="l31.217"> }</span>
<a href="#l31.218"></a><span id="l31.218" class="difflineplus">+JSONFormatter.prototype = {</span>
<a href="#l31.219"></a><span id="l31.219" class="difflineplus">+  __proto__: Formatter.prototype,</span>
<a href="#l31.220"></a><span id="l31.220" class="difflineplus">+</span>
<a href="#l31.221"></a><span id="l31.221" class="difflineplus">+  format: function JF_format(message) {</span>
<a href="#l31.222"></a><span id="l31.222" class="difflineplus">+    let origMessageObjects = message.messageObjects;</span>
<a href="#l31.223"></a><span id="l31.223" class="difflineplus">+    message.messageObjects = [];</span>
<a href="#l31.224"></a><span id="l31.224" class="difflineplus">+    let reProto = [];</span>
<a href="#l31.225"></a><span id="l31.225" class="difflineplus">+    for each (let [, messageObject] in Iterator(origMessageObjects)) {</span>
<a href="#l31.226"></a><span id="l31.226" class="difflineplus">+      if (messageObject)</span>
<a href="#l31.227"></a><span id="l31.227" class="difflineplus">+        if (messageObject._jsonMe) {</span>
<a href="#l31.228"></a><span id="l31.228" class="difflineplus">+          message.messageObjects.push(messageObject);</span>
<a href="#l31.229"></a><span id="l31.229" class="difflineplus">+          // temporarily strip the prototype to avoid JSONing the impl.</span>
<a href="#l31.230"></a><span id="l31.230" class="difflineplus">+          reProto.push([messageObject, messageObject.__proto__]);</span>
<a href="#l31.231"></a><span id="l31.231" class="difflineplus">+          messageObject.__proto__ = undefined;</span>
<a href="#l31.232"></a><span id="l31.232" class="difflineplus">+        }</span>
<a href="#l31.233"></a><span id="l31.233" class="difflineplus">+        else</span>
<a href="#l31.234"></a><span id="l31.234" class="difflineplus">+          message.messageObjects.push(messageObject.toString());</span>
<a href="#l31.235"></a><span id="l31.235" class="difflineplus">+      else</span>
<a href="#l31.236"></a><span id="l31.236" class="difflineplus">+        message.messageObjects.push(messageObject);</span>
<a href="#l31.237"></a><span id="l31.237" class="difflineplus">+    }</span>
<a href="#l31.238"></a><span id="l31.238" class="difflineplus">+    let encoded = JSON.stringify(message) + &quot;\r\n&quot;;</span>
<a href="#l31.239"></a><span id="l31.239" class="difflineplus">+    message.msgObjects = origMessageObjects;</span>
<a href="#l31.240"></a><span id="l31.240" class="difflineplus">+    for each (let [,objectAndProtoPair] in Iterator (reProto)) {</span>
<a href="#l31.241"></a><span id="l31.241" class="difflineplus">+      objectAndProtoPair[0].__proto__ = objectAndProtoPair[1];</span>
<a href="#l31.242"></a><span id="l31.242" class="difflineplus">+    }</span>
<a href="#l31.243"></a><span id="l31.243" class="difflineplus">+    return encoded;</span>
<a href="#l31.244"></a><span id="l31.244" class="difflineplus">+  }</span>
<a href="#l31.245"></a><span id="l31.245" class="difflineplus">+};</span>
<a href="#l31.246"></a><span id="l31.246" class="difflineplus">+</span>
<a href="#l31.247"></a><span id="l31.247"> </span>
<a href="#l31.248"></a><span id="l31.248"> /*</span>
<a href="#l31.249"></a><span id="l31.249">  * Appenders</span>
<a href="#l31.250"></a><span id="l31.250">  * These can be attached to Loggers to log to different places</span>
<a href="#l31.251"></a><span id="l31.251">  * Simply subclass and override doAppend to implement a new one</span>
<a href="#l31.252"></a><span id="l31.252">  */</span>
<a href="#l31.253"></a><span id="l31.253"> </span>
<a href="#l31.254"></a><span id="l31.254"> function Appender(formatter) {</span>
<a href="#l31.255"></a><span id="l31.255" class="difflineat">@@ -650,17 +728,17 @@ RotatingFileAppender.prototype = {</span>
<a href="#l31.256"></a><span id="l31.256">   }</span>
<a href="#l31.257"></a><span id="l31.257"> };</span>
<a href="#l31.258"></a><span id="l31.258"> </span>
<a href="#l31.259"></a><span id="l31.259"> /*</span>
<a href="#l31.260"></a><span id="l31.260">  * SocketAppender</span>
<a href="#l31.261"></a><span id="l31.261">  * Logs via TCP to a given host and port.  Attempts to automatically reconnect</span>
<a href="#l31.262"></a><span id="l31.262">  * when the connection drops or cannot be initially re-established.  Connection</span>
<a href="#l31.263"></a><span id="l31.263">  * attempts will happen at most every timeoutDelay seconds (has a sane default</span>
<a href="#l31.264"></a><span id="l31.264" class="difflineminus">- * if left blank).  Messages are dropped when there is no connection.  </span>
<a href="#l31.265"></a><span id="l31.265" class="difflineplus">+ * if left blank).  Messages are dropped when there is no connection.</span>
<a href="#l31.266"></a><span id="l31.266">  */</span>
<a href="#l31.267"></a><span id="l31.267"> </span>
<a href="#l31.268"></a><span id="l31.268"> function SocketAppender(host, port, formatter, timeoutDelay) {</span>
<a href="#l31.269"></a><span id="l31.269">   this._name = &quot;SocketAppender&quot;;</span>
<a href="#l31.270"></a><span id="l31.270">   this._host = host;</span>
<a href="#l31.271"></a><span id="l31.271">   this._port = port;</span>
<a href="#l31.272"></a><span id="l31.272">   this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l31.273"></a><span id="l31.273">   this._timeout_delay = timeoutDelay || DEFAULT_NETWORK_TIMEOUT_DELAY;</span>
<a href="#l31.274"></a><span id="l31.274" class="difflineat">@@ -678,37 +756,43 @@ SocketAppender.prototype = {</span>
<a href="#l31.275"></a><span id="l31.275">     if (!this.__nos)</span>
<a href="#l31.276"></a><span id="l31.276">       this.openStream();</span>
<a href="#l31.277"></a><span id="l31.277">     return this.__nos;</span>
<a href="#l31.278"></a><span id="l31.278">   },</span>
<a href="#l31.279"></a><span id="l31.279">   _nextCheck: 0,</span>
<a href="#l31.280"></a><span id="l31.280">   openStream: function SApp_openStream() {</span>
<a href="#l31.281"></a><span id="l31.281">     let now = Date.now();</span>
<a href="#l31.282"></a><span id="l31.282">     if (now &lt;= this._nextCheck) {</span>
<a href="#l31.283"></a><span id="l31.283" class="difflineminus">-      return null;</span>
<a href="#l31.284"></a><span id="l31.284" class="difflineplus">+      return;</span>
<a href="#l31.285"></a><span id="l31.285">     }</span>
<a href="#l31.286"></a><span id="l31.286">     this._nextCheck = now + this._timeout_delay * 1000;</span>
<a href="#l31.287"></a><span id="l31.287">     try {</span>
<a href="#l31.288"></a><span id="l31.288">       this._transport = this._socketService.createTransport(</span>
<a href="#l31.289"></a><span id="l31.289">         null, 0, // default socket type</span>
<a href="#l31.290"></a><span id="l31.290">         this._host, this._port,</span>
<a href="#l31.291"></a><span id="l31.291">         null); // no proxy</span>
<a href="#l31.292"></a><span id="l31.292">       this._transport.setTimeout(Ci.nsISocketTransport.TIMEOUT_CONNECT,</span>
<a href="#l31.293"></a><span id="l31.293">                                  this._timeout_delay);</span>
<a href="#l31.294"></a><span id="l31.294">       // do not set a timeout for TIMEOUT_READ_WRITE. The timeout is not</span>
<a href="#l31.295"></a><span id="l31.295">       //  entirely intuitive; your socket will time out if no one reads or</span>
<a href="#l31.296"></a><span id="l31.296">       //  writes to the socket within the timeout.  That, as you can imagine,</span>
<a href="#l31.297"></a><span id="l31.297">       //  is not what we want.</span>
<a href="#l31.298"></a><span id="l31.298">       this._transport.setEventSink(this, this._mainThread);</span>
<a href="#l31.299"></a><span id="l31.299" class="difflineminus">-  </span>
<a href="#l31.300"></a><span id="l31.300" class="difflineminus">-      this.__nos = this._transport.openOutputStream(</span>
<a href="#l31.301"></a><span id="l31.301" class="difflineplus">+</span>
<a href="#l31.302"></a><span id="l31.302" class="difflineplus">+      let outputStream = this._transport.openOutputStream(</span>
<a href="#l31.303"></a><span id="l31.303">         0, // neither blocking nor unbuffered operation is desired</span>
<a href="#l31.304"></a><span id="l31.304">         0, // default buffer size is fine</span>
<a href="#l31.305"></a><span id="l31.305">         0 // default buffer count is fine</span>
<a href="#l31.306"></a><span id="l31.306">         );</span>
<a href="#l31.307"></a><span id="l31.307" class="difflineplus">+</span>
<a href="#l31.308"></a><span id="l31.308" class="difflineplus">+      let uniOutputStream = Cc[&quot;@mozilla.org/intl/converter-output-stream;1&quot;]</span>
<a href="#l31.309"></a><span id="l31.309" class="difflineplus">+                              .createInstance(Ci.nsIConverterOutputStream);</span>
<a href="#l31.310"></a><span id="l31.310" class="difflineplus">+      uniOutputStream.init(outputStream, &quot;utf-8&quot;, 0, 0x0000);</span>
<a href="#l31.311"></a><span id="l31.311" class="difflineplus">+</span>
<a href="#l31.312"></a><span id="l31.312" class="difflineplus">+      this.__nos = uniOutputStream;</span>
<a href="#l31.313"></a><span id="l31.313">     } catch (ex) {</span>
<a href="#l31.314"></a><span id="l31.314">       dump(&quot;Unexpected SocketAppender connection problem: &quot; +</span>
<a href="#l31.315"></a><span id="l31.315">            ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex + &quot;\n&quot;);</span>
<a href="#l31.316"></a><span id="l31.316">     }</span>
<a href="#l31.317"></a><span id="l31.317">   },</span>
<a href="#l31.318"></a><span id="l31.318"> </span>
<a href="#l31.319"></a><span id="l31.319">   closeStream: function SApp_closeStream() {</span>
<a href="#l31.320"></a><span id="l31.320">     if (!this._transport)</span>
<a href="#l31.321"></a><span id="l31.321" class="difflineat">@@ -725,41 +809,40 @@ SocketAppender.prototype = {</span>
<a href="#l31.322"></a><span id="l31.322">   },</span>
<a href="#l31.323"></a><span id="l31.323"> </span>
<a href="#l31.324"></a><span id="l31.324">   doAppend: function SApp_doAppend(message) {</span>
<a href="#l31.325"></a><span id="l31.325">     if (message === null || message.length &lt;= 0)</span>
<a href="#l31.326"></a><span id="l31.326">       return;</span>
<a href="#l31.327"></a><span id="l31.327">     try {</span>
<a href="#l31.328"></a><span id="l31.328">       let nos = this._nos;</span>
<a href="#l31.329"></a><span id="l31.329">       if (nos)</span>
<a href="#l31.330"></a><span id="l31.330" class="difflineminus">-        nos.write(message, message.length);</span>
<a href="#l31.331"></a><span id="l31.331" class="difflineplus">+        nos.writeString(message);</span>
<a href="#l31.332"></a><span id="l31.332">     } catch(e) {</span>
<a href="#l31.333"></a><span id="l31.333">       if (this._transport &amp;&amp; !this._transport.isAlive()) {</span>
<a href="#l31.334"></a><span id="l31.334">         this.closeStream();</span>
<a href="#l31.335"></a><span id="l31.335">       }</span>
<a href="#l31.336"></a><span id="l31.336">     }</span>
<a href="#l31.337"></a><span id="l31.337">   },</span>
<a href="#l31.338"></a><span id="l31.338"> </span>
<a href="#l31.339"></a><span id="l31.339">   clear: function SApp_clear() {</span>
<a href="#l31.340"></a><span id="l31.340">     this.closeStream();</span>
<a href="#l31.341"></a><span id="l31.341" class="difflineminus">-    this._file.remove(false);</span>
<a href="#l31.342"></a><span id="l31.342">   },</span>
<a href="#l31.343"></a><span id="l31.343" class="difflineminus">-  </span>
<a href="#l31.344"></a><span id="l31.344" class="difflineplus">+</span>
<a href="#l31.345"></a><span id="l31.345">   /* nsITransportEventSink */</span>
<a href="#l31.346"></a><span id="l31.346">   onTransportStatus: function SApp_onTransportStatus(aTransport, aStatus,</span>
<a href="#l31.347"></a><span id="l31.347">       aProgress, aProgressMax) {</span>
<a href="#l31.348"></a><span id="l31.348">     if (aStatus == 0x804b0004) // STATUS_CONNECTED_TO is not a constant.</span>
<a href="#l31.349"></a><span id="l31.349">       this._connected = true;</span>
<a href="#l31.350"></a><span id="l31.350">   },</span>
<a href="#l31.351"></a><span id="l31.351"> };</span>
<a href="#l31.352"></a><span id="l31.352"> </span>
<a href="#l31.353"></a><span id="l31.353"> /**</span>
<a href="#l31.354"></a><span id="l31.354">  * Throws an exception whenever it gets a message.  Intended to be used in</span>
<a href="#l31.355"></a><span id="l31.355">  * automated testing situations where the code would normally log an error but</span>
<a href="#l31.356"></a><span id="l31.356" class="difflineminus">- * not die in a fatal manner. </span>
<a href="#l31.357"></a><span id="l31.357" class="difflineplus">+ * not die in a fatal manner.</span>
<a href="#l31.358"></a><span id="l31.358">  */</span>
<a href="#l31.359"></a><span id="l31.359"> function ThrowingAppender(thrower, formatter) {</span>
<a href="#l31.360"></a><span id="l31.360">   this._name = &quot;ThrowingAppender&quot;;</span>
<a href="#l31.361"></a><span id="l31.361">   this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l31.362"></a><span id="l31.362">   this._thrower = thrower;</span>
<a href="#l31.363"></a><span id="l31.363"> }</span>
<a href="#l31.364"></a><span id="l31.364"> ThrowingAppender.prototype = {</span>
<a href="#l31.365"></a><span id="l31.365">   __proto__: Appender.prototype,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/mailnews/db/gloda/modules/noun_tag.js</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_tag.js</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -50,30 +50,33 @@ Cu.import(&quot;resource://app/modules/gloda/</span>
<a href="#l32.4"></a><span id="l32.4"> var TagNoun = {</span>
<a href="#l32.5"></a><span id="l32.5">   name: &quot;tag&quot;,</span>
<a href="#l32.6"></a><span id="l32.6">   clazz: Ci.nsIMsgTag,</span>
<a href="#l32.7"></a><span id="l32.7">   usesParameter: true,</span>
<a href="#l32.8"></a><span id="l32.8">   allowsArbitraryAttrs: false,</span>
<a href="#l32.9"></a><span id="l32.9">   idAttr: &quot;key&quot;,</span>
<a href="#l32.10"></a><span id="l32.10">   _msgTagService: null,</span>
<a href="#l32.11"></a><span id="l32.11">   _tagMap: null,</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineplus">+  _tagList: null,</span>
<a href="#l32.13"></a><span id="l32.13"> </span>
<a href="#l32.14"></a><span id="l32.14">   _init: function () {</span>
<a href="#l32.15"></a><span id="l32.15">     this._msgTagService = Cc[&quot;@mozilla.org/messenger/tagservice;1&quot;].</span>
<a href="#l32.16"></a><span id="l32.16">                           getService(Ci.nsIMsgTagService);</span>
<a href="#l32.17"></a><span id="l32.17">     this._updateTagMap();</span>
<a href="#l32.18"></a><span id="l32.18">   },</span>
<a href="#l32.19"></a><span id="l32.19"> </span>
<a href="#l32.20"></a><span id="l32.20">   getAllTags: function gloda_noun_tag_getAllTags() {</span>
<a href="#l32.21"></a><span id="l32.21" class="difflineminus">-    return this._msgTagService.getAllTags({});</span>
<a href="#l32.22"></a><span id="l32.22" class="difflineplus">+    if (this._tagList == null)</span>
<a href="#l32.23"></a><span id="l32.23" class="difflineplus">+      this._updateTagMap();</span>
<a href="#l32.24"></a><span id="l32.24" class="difflineplus">+    return this._tagList;</span>
<a href="#l32.25"></a><span id="l32.25">   },</span>
<a href="#l32.26"></a><span id="l32.26"> </span>
<a href="#l32.27"></a><span id="l32.27">   _updateTagMap: function gloda_noun_tag_updateTagMap() {</span>
<a href="#l32.28"></a><span id="l32.28">     this._tagMap = {};</span>
<a href="#l32.29"></a><span id="l32.29" class="difflineminus">-    let tagArray = this._msgTagService.getAllTags({});</span>
<a href="#l32.30"></a><span id="l32.30" class="difflineplus">+    let tagArray = this._tagList = this._msgTagService.getAllTags({});</span>
<a href="#l32.31"></a><span id="l32.31">     for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l32.32"></a><span id="l32.32">       let tag = tagArray[iTag];</span>
<a href="#l32.33"></a><span id="l32.33">       this._tagMap[tag.key] = tag;</span>
<a href="#l32.34"></a><span id="l32.34">     }</span>
<a href="#l32.35"></a><span id="l32.35">   },</span>
<a href="#l32.36"></a><span id="l32.36"> </span>
<a href="#l32.37"></a><span id="l32.37">   comparator: function gloda_noun_tag_comparator(a, b) {</span>
<a href="#l32.38"></a><span id="l32.38">     if (a == null) {</span>
<a href="#l32.39"></a><span id="l32.39" class="difflineat">@@ -106,12 +109,18 @@ var TagNoun = {</span>
<a href="#l32.40"></a><span id="l32.40">     //  to listen to the message tag service to know when we should rebuild.</span>
<a href="#l32.41"></a><span id="l32.41">     if ((tag === undefined) &amp;&amp; this._msgTagService.isValidKey(aTagKey)) {</span>
<a href="#l32.42"></a><span id="l32.42">       this._updateTagMap();</span>
<a href="#l32.43"></a><span id="l32.43">       tag = this._tagMap[aTagKey];</span>
<a href="#l32.44"></a><span id="l32.44">     }</span>
<a href="#l32.45"></a><span id="l32.45">     // we intentionally are returning undefined if the tag doesn't exist</span>
<a href="#l32.46"></a><span id="l32.46">     return tag;</span>
<a href="#l32.47"></a><span id="l32.47">   },</span>
<a href="#l32.48"></a><span id="l32.48" class="difflineplus">+  /**</span>
<a href="#l32.49"></a><span id="l32.49" class="difflineplus">+   * Convenience helper to turn a tag key into a tag name.</span>
<a href="#l32.50"></a><span id="l32.50" class="difflineplus">+   */</span>
<a href="#l32.51"></a><span id="l32.51" class="difflineplus">+  getTag: function gloda_noun_tag_getTag(aTagKey) {</span>
<a href="#l32.52"></a><span id="l32.52" class="difflineplus">+    return this.fromJSON(aTagKey);</span>
<a href="#l32.53"></a><span id="l32.53" class="difflineplus">+  }</span>
<a href="#l32.54"></a><span id="l32.54"> };</span>
<a href="#l32.55"></a><span id="l32.55"> </span>
<a href="#l32.56"></a><span id="l32.56"> TagNoun._init();</span>
<a href="#l32.57"></a><span id="l32.57"> Gloda.defineNoun(TagNoun, Gloda.NOUN_TAG);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/mailnews/db/gloda/modules/public.js</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/public.js</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -40,21 +40,22 @@ const EXPORTED_SYMBOLS = [&quot;Gloda&quot;];</span>
<a href="#l33.4"></a><span id="l33.4"> const Cc = Components.classes;</span>
<a href="#l33.5"></a><span id="l33.5"> const Ci = Components.interfaces;</span>
<a href="#l33.6"></a><span id="l33.6"> const Cr = Components.results;</span>
<a href="#l33.7"></a><span id="l33.7"> const Cu = Components.utils;</span>
<a href="#l33.8"></a><span id="l33.8"> </span>
<a href="#l33.9"></a><span id="l33.9"> Cu.import(&quot;resource://app/modules/gloda/gloda.js&quot;);</span>
<a href="#l33.10"></a><span id="l33.10"> Cu.import(&quot;resource://app/modules/gloda/everybody.js&quot;);</span>
<a href="#l33.11"></a><span id="l33.11"> Cu.import(&quot;resource://app/modules/gloda/indexer.js&quot;);</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineplus">+Cu.import(&quot;resource://app/modules/gloda/index_msg.js&quot;);</span>
<a href="#l33.13"></a><span id="l33.13"> </span>
<a href="#l33.14"></a><span id="l33.14"> /**</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineminus">- * Expose some junk </span>
<a href="#l33.16"></a><span id="l33.16" class="difflineplus">+ * Expose some junk</span>
<a href="#l33.17"></a><span id="l33.17">  */</span>
<a href="#l33.18"></a><span id="l33.18"> function proxy(aSourceObj, aSourceAttr, aDestObj, aDestAttr) {</span>
<a href="#l33.19"></a><span id="l33.19">   aDestObj[aDestAttr] = function() {</span>
<a href="#l33.20"></a><span id="l33.20">     return aSourceObj[aSourceAttr].apply(aSourceObj, arguments);</span>
<a href="#l33.21"></a><span id="l33.21">   };</span>
<a href="#l33.22"></a><span id="l33.22"> }</span>
<a href="#l33.23"></a><span id="l33.23"> </span>
<a href="#l33.24"></a><span id="l33.24"> proxy(GlodaIndexer, &quot;addListener&quot;, Gloda, &quot;addIndexerListener&quot;);</span>
<a href="#l33.25"></a><span id="l33.25"> proxy(GlodaIndexer, &quot;removeListener&quot;, Gloda, &quot;removeIndexerListener&quot;);</span>
<a href="#l33.26"></a><span id="l33.26" class="difflineminus">-proxy(GlodaIndexer, &quot;isMessageIndexed&quot;, Gloda, &quot;isMessageIndexed&quot;);</span>
<a href="#l33.27"></a><span id="l33.27" class="difflineplus">+proxy(GlodaMsgIndexer, &quot;isMessageIndexed&quot;, Gloda, &quot;isMessageIndexed&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/mailnews/db/gloda/modules/query.js</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/query.js</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -131,20 +131,36 @@ GlodaQueryClass.prototype = {</span>
<a href="#l34.4"></a><span id="l34.4"> </span>
<a href="#l34.5"></a><span id="l34.5">   /**</span>
<a href="#l34.6"></a><span id="l34.6">    * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l34.7"></a><span id="l34.7">    *  provide a listener to receive notifications from the collection as it</span>
<a href="#l34.8"></a><span id="l34.8">    *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l34.9"></a><span id="l34.9">    *  onItemsModified, and onItemsRemoved methods, all of which take a single</span>
<a href="#l34.10"></a><span id="l34.10">    *  argument which is the list of items which have been added, modified, or</span>
<a href="#l34.11"></a><span id="l34.11">    *  removed respectively.</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineplus">+   * </span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+   * @param aListener The collection listener.</span>
<a href="#l34.14"></a><span id="l34.14" class="difflineplus">+   * @param [aData] The data attribute to set on the collection.</span>
<a href="#l34.15"></a><span id="l34.15" class="difflineplus">+   * @param [aArgs.becomeExplicit] Make the collection explicit so that the</span>
<a href="#l34.16"></a><span id="l34.16" class="difflineplus">+   *     collection will only ever contain results found from the database</span>
<a href="#l34.17"></a><span id="l34.17" class="difflineplus">+   *     query and the query will not be updated as new items are indexed that</span>
<a href="#l34.18"></a><span id="l34.18" class="difflineplus">+   *     also match the query.</span>
<a href="#l34.19"></a><span id="l34.19" class="difflineplus">+   * @param [aArgs.becomeNull] Change the collection's query to a null query so</span>
<a href="#l34.20"></a><span id="l34.20" class="difflineplus">+   *     that it will never receive any additional added/modified/removed events</span>
<a href="#l34.21"></a><span id="l34.21" class="difflineplus">+   *     apart from the underlying database query.  This is really only intended</span>
<a href="#l34.22"></a><span id="l34.22" class="difflineplus">+   *     for gloda internal use but may be acceptable for non-gloda use.  Please</span>
<a href="#l34.23"></a><span id="l34.23" class="difflineplus">+   *     ask on mozilla.dev.apps.thunderbird first to make sure there isn't a</span>
<a href="#l34.24"></a><span id="l34.24" class="difflineplus">+   *     better solution for your use-case.  (Note: removals will still happen</span>
<a href="#l34.25"></a><span id="l34.25" class="difflineplus">+   *     when things get fully deleted.)</span>
<a href="#l34.26"></a><span id="l34.26">    */</span>
<a href="#l34.27"></a><span id="l34.27" class="difflineminus">-  getCollection: function gloda_query_getCollection(aListener, aData) {</span>
<a href="#l34.28"></a><span id="l34.28" class="difflineplus">+  getCollection: function gloda_query_getCollection(aListener, aData, aArgs) {</span>
<a href="#l34.29"></a><span id="l34.29">     this.completed = false;</span>
<a href="#l34.30"></a><span id="l34.30" class="difflineminus">-    return this._nounDef.datastore.queryFromQuery(this, aListener, aData);</span>
<a href="#l34.31"></a><span id="l34.31" class="difflineplus">+    return this._nounDef.datastore.queryFromQuery(this, aListener, aData,</span>
<a href="#l34.32"></a><span id="l34.32" class="difflineplus">+             /* aExistingCollection */ null, /* aMasterCollection */ null,</span>
<a href="#l34.33"></a><span id="l34.33" class="difflineplus">+             aArgs);</span>
<a href="#l34.34"></a><span id="l34.34">   },</span>
<a href="#l34.35"></a><span id="l34.35"> </span>
<a href="#l34.36"></a><span id="l34.36">   /**</span>
<a href="#l34.37"></a><span id="l34.37">    * Test whether the given first-class noun instance satisfies this query.</span>
<a href="#l34.38"></a><span id="l34.38">    *</span>
<a href="#l34.39"></a><span id="l34.39">    * @testpoint gloda.query.test</span>
<a href="#l34.40"></a><span id="l34.40">    */</span>
<a href="#l34.41"></a><span id="l34.41">   test: function gloda_query_test(aObj) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/mailnews/db/gloda/modules/utils.js</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/utils.js</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -153,16 +153,45 @@ var GlodaUtils = {</span>
<a href="#l35.4"></a><span id="l35.4">     }</span>
<a href="#l35.5"></a><span id="l35.5"> </span>
<a href="#l35.6"></a><span id="l35.6">     sstream.close();</span>
<a href="#l35.7"></a><span id="l35.7">     fstream.close();</span>
<a href="#l35.8"></a><span id="l35.8"> </span>
<a href="#l35.9"></a><span id="l35.9">     return data;</span>
<a href="#l35.10"></a><span id="l35.10">   },</span>
<a href="#l35.11"></a><span id="l35.11"> </span>
<a href="#l35.12"></a><span id="l35.12" class="difflineplus">+</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+  _FORCE_GC_AFTER_NUM_HEADERS: 4096,</span>
<a href="#l35.14"></a><span id="l35.14" class="difflineplus">+  _headersSeen: 0,</span>
<a href="#l35.15"></a><span id="l35.15" class="difflineplus">+  /**</span>
<a href="#l35.16"></a><span id="l35.16" class="difflineplus">+   * As |forceGarbageCollection| says, once XPConnect sees a header, it likes</span>
<a href="#l35.17"></a><span id="l35.17" class="difflineplus">+   *  to hold onto that reference.  This method is used to track the number of</span>
<a href="#l35.18"></a><span id="l35.18" class="difflineplus">+   *  headers we have seen and force a GC when we have to.</span>
<a href="#l35.19"></a><span id="l35.19" class="difflineplus">+   *</span>
<a href="#l35.20"></a><span id="l35.20" class="difflineplus">+   * Ideally the indexer's idle-biased GC mechanism would take care of all the</span>
<a href="#l35.21"></a><span id="l35.21" class="difflineplus">+   *  GC; we are just a failsafe to make sure that our memory usage is bounded</span>
<a href="#l35.22"></a><span id="l35.22" class="difflineplus">+   *  based on the number of headers we have seen rather than just time.</span>
<a href="#l35.23"></a><span id="l35.23" class="difflineplus">+   *  Since holding onto headers can keep databases around too, this also</span>
<a href="#l35.24"></a><span id="l35.24" class="difflineplus">+   *  helps avoid keeping file handles open, etc.</span>
<a href="#l35.25"></a><span id="l35.25" class="difflineplus">+   *</span>
<a href="#l35.26"></a><span id="l35.26" class="difflineplus">+   * |forceGarbageCollection| will zero our tracking variable when a GC happens</span>
<a href="#l35.27"></a><span id="l35.27" class="difflineplus">+   *  so we are informed by the indexer's GC triggering.</span>
<a href="#l35.28"></a><span id="l35.28" class="difflineplus">+   *</span>
<a href="#l35.29"></a><span id="l35.29" class="difflineplus">+   * And of course, we don't want to trigger collections willy nilly because</span>
<a href="#l35.30"></a><span id="l35.30" class="difflineplus">+   *  they have a cost even if there is no garbage.</span>
<a href="#l35.31"></a><span id="l35.31" class="difflineplus">+   *</span>
<a href="#l35.32"></a><span id="l35.32" class="difflineplus">+   * @param aNumHeadersSeen The number of headers code has seen.  A granularity</span>
<a href="#l35.33"></a><span id="l35.33" class="difflineplus">+   *     of hundreds of messages should be fine.</span>
<a href="#l35.34"></a><span id="l35.34" class="difflineplus">+   */</span>
<a href="#l35.35"></a><span id="l35.35" class="difflineplus">+  considerHeaderBasedGC: function(aNumHeadersSeen) {</span>
<a href="#l35.36"></a><span id="l35.36" class="difflineplus">+    this._headersSeen += aNumHeadersSeen;</span>
<a href="#l35.37"></a><span id="l35.37" class="difflineplus">+    if (this._headersSeen &gt;= this._FORCE_GC_AFTER_NUM_HEADERS)</span>
<a href="#l35.38"></a><span id="l35.38" class="difflineplus">+      this.forceGarbageCollection();</span>
<a href="#l35.39"></a><span id="l35.39" class="difflineplus">+  },</span>
<a href="#l35.40"></a><span id="l35.40" class="difflineplus">+</span>
<a href="#l35.41"></a><span id="l35.41">   /**</span>
<a href="#l35.42"></a><span id="l35.42">    * Force a garbage-collection sweep.  Gloda has to force garbage collection</span>
<a href="#l35.43"></a><span id="l35.43">    *  periodically because XPConnect's XPCJSRuntime::DeferredRelease mechanism</span>
<a href="#l35.44"></a><span id="l35.44">    *  can end up holding onto a ridiculously high number of XPConnect objects in</span>
<a href="#l35.45"></a><span id="l35.45">    *  between normal garbage collections.  This has mainly posed a problem</span>
<a href="#l35.46"></a><span id="l35.46">    *  because nsAutolock is a jerk in DEBUG builds in 1.9.1, but in theory this</span>
<a href="#l35.47"></a><span id="l35.47">    *  also helps us even out our memory usage.</span>
<a href="#l35.48"></a><span id="l35.48">    * We also are starting to do this more to try and keep the garbage collection</span>
<a href="#l35.49"></a><span id="l35.49" class="difflineat">@@ -173,12 +202,13 @@ var GlodaUtils = {</span>
<a href="#l35.50"></a><span id="l35.50">    *  we do start involving the cycle collector, that is a non-trivial block of</span>
<a href="#l35.51"></a><span id="l35.51">    *  code to copy-and-paste all over the place (at least in a module).</span>
<a href="#l35.52"></a><span id="l35.52">    *</span>
<a href="#l35.53"></a><span id="l35.53">    * @param aCycleCollecting Do we need the cycle collector to run?  Currently</span>
<a href="#l35.54"></a><span id="l35.54">    *     unused / unimplemented, but we would use</span>
<a href="#l35.55"></a><span id="l35.55">    *     nsIDOMWindowUtils.garbageCollect() to do so.</span>
<a href="#l35.56"></a><span id="l35.56">    */</span>
<a href="#l35.57"></a><span id="l35.57">   forceGarbageCollection:</span>
<a href="#l35.58"></a><span id="l35.58" class="difflineminus">-    function gloda_utils_garbageCollection(aCycleCollecting) {</span>
<a href="#l35.59"></a><span id="l35.59" class="difflineplus">+      function gloda_utils_garbageCollection(aCycleCollecting) {</span>
<a href="#l35.60"></a><span id="l35.60">     Cu.forceGC();</span>
<a href="#l35.61"></a><span id="l35.61" class="difflineplus">+    this._headersSeen = 0;</span>
<a href="#l35.62"></a><span id="l35.62">   }</span>
<a href="#l35.63"></a><span id="l35.63"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1">rename from mailnews/db/gloda/test/unit/test_gloda_content.js</span>
<a href="#l36.2"></a><span id="l36.2">rename to mailnews/db/gloda/test/unit/base_gloda_content.js</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_gloda_content.js</span>
<a href="#l36.4"></a><span id="l36.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_gloda_content.js</span>
<a href="#l36.5"></a><span id="l36.5" class="difflineat">@@ -1,30 +1,66 @@</span>
<a href="#l36.6"></a><span id="l36.6" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l36.7"></a><span id="l36.7" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l36.8"></a><span id="l36.8" class="difflineplus">+ *</span>
<a href="#l36.9"></a><span id="l36.9" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l36.10"></a><span id="l36.10" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l36.11"></a><span id="l36.11" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+ *</span>
<a href="#l36.14"></a><span id="l36.14" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l36.15"></a><span id="l36.15" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l36.16"></a><span id="l36.16" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l36.17"></a><span id="l36.17" class="difflineplus">+ * License.</span>
<a href="#l36.18"></a><span id="l36.18" class="difflineplus">+ *</span>
<a href="#l36.19"></a><span id="l36.19" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l36.20"></a><span id="l36.20" class="difflineplus">+ *</span>
<a href="#l36.21"></a><span id="l36.21" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l36.22"></a><span id="l36.22" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l36.23"></a><span id="l36.23" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l36.24"></a><span id="l36.24" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l36.25"></a><span id="l36.25" class="difflineplus">+ *</span>
<a href="#l36.26"></a><span id="l36.26" class="difflineplus">+ * Contributor(s):</span>
<a href="#l36.27"></a><span id="l36.27" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l36.28"></a><span id="l36.28" class="difflineplus">+ *   David Ascher &lt;dascher@mozillamessaging.com&gt;</span>
<a href="#l36.29"></a><span id="l36.29" class="difflineplus">+ *</span>
<a href="#l36.30"></a><span id="l36.30" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l36.31"></a><span id="l36.31" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l36.32"></a><span id="l36.32" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l36.33"></a><span id="l36.33" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l36.34"></a><span id="l36.34" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l36.35"></a><span id="l36.35" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l36.36"></a><span id="l36.36" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l36.37"></a><span id="l36.37" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l36.38"></a><span id="l36.38" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l36.39"></a><span id="l36.39" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l36.40"></a><span id="l36.40" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l36.41"></a><span id="l36.41" class="difflineplus">+ *</span>
<a href="#l36.42"></a><span id="l36.42" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l36.43"></a><span id="l36.43" class="difflineplus">+</span>
<a href="#l36.44"></a><span id="l36.44"> /*</span>
<a href="#l36.45"></a><span id="l36.45">  * Tests the operation of the GlodaContent (in connotent.js) and its exposure</span>
<a href="#l36.46"></a><span id="l36.46">  * via Gloda.getMessageContent.  This may also be implicitly tested by indexing</span>
<a href="#l36.47"></a><span id="l36.47">  * and fulltext query tests (on messages), but the buck stops here for the</span>
<a href="#l36.48"></a><span id="l36.48">  * content stuff.</span>
<a href="#l36.49"></a><span id="l36.49">  *</span>
<a href="#l36.50"></a><span id="l36.50" class="difflineminus">- * Currently, we just test that quoting removal and that the content turns out</span>
<a href="#l36.51"></a><span id="l36.51" class="difflineminus">- * right.  We do not actually verify that the quoted blocks are correct.  (We</span>
<a href="#l36.52"></a><span id="l36.52" class="difflineminus">- * have no known consumers who care about the quoted blocks.)</span>
<a href="#l36.53"></a><span id="l36.53" class="difflineplus">+ * Currently, we just test quoting removal and that the content turns out right.</span>
<a href="#l36.54"></a><span id="l36.54" class="difflineplus">+ * We do not actually verify that the quoted blocks are correct (aka we might</span>
<a href="#l36.55"></a><span id="l36.55" class="difflineplus">+ * screw up eating the greater-than signs).  (We have no known consumers who</span>
<a href="#l36.56"></a><span id="l36.56" class="difflineplus">+ * care about the quoted blocks.)</span>
<a href="#l36.57"></a><span id="l36.57">  */</span>
<a href="#l36.58"></a><span id="l36.58"> </span>
<a href="#l36.59"></a><span id="l36.59" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l36.60"></a><span id="l36.60"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l36.61"></a><span id="l36.61"> </span>
<a href="#l36.62"></a><span id="l36.62"> Components.utils.import(&quot;resource://app/modules/gloda/mimemsg.js&quot;);</span>
<a href="#l36.63"></a><span id="l36.63"> </span>
<a href="#l36.64"></a><span id="l36.64"> // we need to be able to get at GlodaFundAttr to check the number of whittler</span>
<a href="#l36.65"></a><span id="l36.65"> //   invocations</span>
<a href="#l36.66"></a><span id="l36.66"> Components.utils.import(&quot;resource://app/modules/gloda/fundattr.js&quot;);</span>
<a href="#l36.67"></a><span id="l36.67"> </span>
<a href="#l36.68"></a><span id="l36.68" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l36.69"></a><span id="l36.69" class="difflineminus">-</span>
<a href="#l36.70"></a><span id="l36.70"> /* ===== Data ===== */</span>
<a href="#l36.71"></a><span id="l36.71"> var messageInfos = [</span>
<a href="#l36.72"></a><span id="l36.72">   {</span>
<a href="#l36.73"></a><span id="l36.73">     name: &quot;no quoting&quot;,</span>
<a href="#l36.74"></a><span id="l36.74">     bode: [[true, &quot;I like hats&quot;],</span>
<a href="#l36.75"></a><span id="l36.75">            [true, &quot;yes I do!&quot;],</span>
<a href="#l36.76"></a><span id="l36.76">            [true, &quot;I like hats!&quot;],</span>
<a href="#l36.77"></a><span id="l36.77">            [true, &quot;How bout you?&quot;]]</span>
<a href="#l36.78"></a><span id="l36.78" class="difflineat">@@ -92,36 +128,24 @@ var messageInfos = [</span>
<a href="#l36.79"></a><span id="l36.79">            [false, &quot;&gt; wrote&quot;],</span>
<a href="#l36.80"></a><span id="l36.80">            [true, &quot;cheese&quot;],</span>
<a href="#l36.81"></a><span id="l36.81">            [false, &quot;&quot;]]</span>
<a href="#l36.82"></a><span id="l36.82">   }</span>
<a href="#l36.83"></a><span id="l36.83"> ];</span>
<a href="#l36.84"></a><span id="l36.84"> </span>
<a href="#l36.85"></a><span id="l36.85"> /* ===== Tests ===== */</span>
<a href="#l36.86"></a><span id="l36.86"> </span>
<a href="#l36.87"></a><span id="l36.87" class="difflineminus">-/**</span>
<a href="#l36.88"></a><span id="l36.88" class="difflineminus">- * Hooks for pre/post setup message, used for the IMAP tests.</span>
<a href="#l36.89"></a><span id="l36.89" class="difflineminus">- */</span>
<a href="#l36.90"></a><span id="l36.90" class="difflineminus">-var pre_inject_message_hook = function default_pre_inject_message_hook() {</span>
<a href="#l36.91"></a><span id="l36.91" class="difflineminus">-  next_test();</span>
<a href="#l36.92"></a><span id="l36.92" class="difflineminus">-};</span>
<a href="#l36.93"></a><span id="l36.93" class="difflineminus">-</span>
<a href="#l36.94"></a><span id="l36.94" class="difflineminus">-var post_inject_message_hook = function default_post_inject_message_hook() {</span>
<a href="#l36.95"></a><span id="l36.95" class="difflineminus">-  next_test();</span>
<a href="#l36.96"></a><span id="l36.96" class="difflineminus">-};</span>
<a href="#l36.97"></a><span id="l36.97" class="difflineminus">-</span>
<a href="#l36.98"></a><span id="l36.98"> function setup_create_message(info) {</span>
<a href="#l36.99"></a><span id="l36.99">   info.body = {body: [tupe[1] for each</span>
<a href="#l36.100"></a><span id="l36.100">                       ([, tupe] in Iterator(info.bode))].join(&quot;\r\n&quot;)};</span>
<a href="#l36.101"></a><span id="l36.101">   info.expected = [tupe[1] for each</span>
<a href="#l36.102"></a><span id="l36.102">                    ([, tupe] in Iterator(info.bode)) if</span>
<a href="#l36.103"></a><span id="l36.103">                    (tupe[0])].join(&quot;\n&quot;);</span>
<a href="#l36.104"></a><span id="l36.104"> </span>
<a href="#l36.105"></a><span id="l36.105">   info._synMsg = msgGen.makeMessage(info);</span>
<a href="#l36.106"></a><span id="l36.106" class="difflineminus">-  next_test();</span>
<a href="#l36.107"></a><span id="l36.107"> }</span>
<a href="#l36.108"></a><span id="l36.108"> </span>
<a href="#l36.109"></a><span id="l36.109"> /**</span>
<a href="#l36.110"></a><span id="l36.110">  * To save ourselves some lookup trouble, pretend to be a verification</span>
<a href="#l36.111"></a><span id="l36.111">  *  function so we get easy access to the gloda translations of the messages so</span>
<a href="#l36.112"></a><span id="l36.112">  *  we can cram this in various places.</span>
<a href="#l36.113"></a><span id="l36.113">  */</span>
<a href="#l36.114"></a><span id="l36.114"> function glodaInfoStasher(aSynthMessage, aGlodaMessage) {</span>
<a href="#l36.115"></a><span id="l36.115" class="difflineat">@@ -131,22 +155,22 @@ function glodaInfoStasher(aSynthMessage,</span>
<a href="#l36.116"></a><span id="l36.116">       messageInfos[iMsg]._glodaMsg = aGlodaMessage;</span>
<a href="#l36.117"></a><span id="l36.117">     }</span>
<a href="#l36.118"></a><span id="l36.118">   }</span>
<a href="#l36.119"></a><span id="l36.119"> }</span>
<a href="#l36.120"></a><span id="l36.120"> </span>
<a href="#l36.121"></a><span id="l36.121"> /**</span>
<a href="#l36.122"></a><span id="l36.122">  * Actually inject all the messages we created above.</span>
<a href="#l36.123"></a><span id="l36.123">  */</span>
<a href="#l36.124"></a><span id="l36.124" class="difflineminus">-var gSynMessages;</span>
<a href="#l36.125"></a><span id="l36.125" class="difflineminus">-</span>
<a href="#l36.126"></a><span id="l36.126"> function setup_inject_messages() {</span>
<a href="#l36.127"></a><span id="l36.127" class="difflineminus">-  gSynMessages = [info._synMsg for each</span>
<a href="#l36.128"></a><span id="l36.128" class="difflineminus">-                  ([, info] in Iterator(messageInfos))];</span>
<a href="#l36.129"></a><span id="l36.129" class="difflineminus">-  indexMessages(gSynMessages, glodaInfoStasher, next_test);</span>
<a href="#l36.130"></a><span id="l36.130" class="difflineplus">+  let msgSet = new SyntheticMessageSet(</span>
<a href="#l36.131"></a><span id="l36.131" class="difflineplus">+                 [info._synMsg for each ([, info] in Iterator(messageInfos))]);</span>
<a href="#l36.132"></a><span id="l36.132" class="difflineplus">+  let folder = make_empty_folder();</span>
<a href="#l36.133"></a><span id="l36.133" class="difflineplus">+  yield add_sets_to_folders(folder, [msgSet]);</span>
<a href="#l36.134"></a><span id="l36.134" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet, {verifier: glodaInfoStasher});</span>
<a href="#l36.135"></a><span id="l36.135"> }</span>
<a href="#l36.136"></a><span id="l36.136"> </span>
<a href="#l36.137"></a><span id="l36.137"> function test_stream_message(info) {</span>
<a href="#l36.138"></a><span id="l36.138">   let msgHdr = info._glodaMsg.folderMessage;</span>
<a href="#l36.139"></a><span id="l36.139"> </span>
<a href="#l36.140"></a><span id="l36.140">   MsgHdrToMimeMessage(msgHdr, null, function(aMsgHdr, aMimeMsg) {</span>
<a href="#l36.141"></a><span id="l36.141">     verify_message_content(info, info._synMsg, info._glodaMsg, aMsgHdr,</span>
<a href="#l36.142"></a><span id="l36.142">                            aMimeMsg);</span>
<a href="#l36.143"></a><span id="l36.143" class="difflineat">@@ -166,28 +190,17 @@ function verify_message_content(aInfo, a</span>
<a href="#l36.144"></a><span id="l36.144">     do_throw(&quot;Message streaming should work; check test_mime_emitter.js first&quot;);</span>
<a href="#l36.145"></a><span id="l36.145"> </span>
<a href="#l36.146"></a><span id="l36.146">   whittleCount = 0;</span>
<a href="#l36.147"></a><span id="l36.147">   let content = Gloda.getMessageContent(aGlodaMsg, aMimeMsg);</span>
<a href="#l36.148"></a><span id="l36.148">   if (whittleCount != 1)</span>
<a href="#l36.149"></a><span id="l36.149">     do_throw(&quot;Whittle count is &quot; + whittleCount + &quot; but should be 1!&quot;);</span>
<a href="#l36.150"></a><span id="l36.150"> </span>
<a href="#l36.151"></a><span id="l36.151">   do_check_eq(content.getContentString(), aInfo.expected);</span>
<a href="#l36.152"></a><span id="l36.152" class="difflineminus">-</span>
<a href="#l36.153"></a><span id="l36.153" class="difflineminus">-  next_test();</span>
<a href="#l36.154"></a><span id="l36.154"> }</span>
<a href="#l36.155"></a><span id="l36.155"> </span>
<a href="#l36.156"></a><span id="l36.156"> /* ===== Driver ===== */</span>
<a href="#l36.157"></a><span id="l36.157"> </span>
<a href="#l36.158"></a><span id="l36.158"> var tests = [</span>
<a href="#l36.159"></a><span id="l36.159">   parameterizeTest(setup_create_message, messageInfos),</span>
<a href="#l36.160"></a><span id="l36.160" class="difflineminus">-  function pre_inject_message() { pre_inject_message_hook(); },</span>
<a href="#l36.161"></a><span id="l36.161">   setup_inject_messages,</span>
<a href="#l36.162"></a><span id="l36.162" class="difflineminus">-  function post_inject_message() { post_inject_message_hook(); },</span>
<a href="#l36.163"></a><span id="l36.163" class="difflineminus">- // disable_index_notifications,</span>
<a href="#l36.164"></a><span id="l36.164">   parameterizeTest(test_stream_message, messageInfos),</span>
<a href="#l36.165"></a><span id="l36.165"> ];</span>
<a href="#l36.166"></a><span id="l36.166" class="difflineminus">-</span>
<a href="#l36.167"></a><span id="l36.167" class="difflineminus">-function run_test() {</span>
<a href="#l36.168"></a><span id="l36.168" class="difflineminus">-  glodaHelperRunTests(tests);</span>
<a href="#l36.169"></a><span id="l36.169" class="difflineminus">-}</span>
<a href="#l36.170"></a><span id="l36.170" class="difflineminus">-</span>
<a href="#l36.171"></a><span id="l36.171" class="difflineminus">-injectMessagesUsing(INJECT_MBOX);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1">new file mode 100644</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineminus">--- /dev/null</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_index_junk.js</span>
<a href="#l37.4"></a><span id="l37.4" class="difflineat">@@ -0,0 +1,153 @@</span>
<a href="#l37.5"></a><span id="l37.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l37.6"></a><span id="l37.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l37.7"></a><span id="l37.7" class="difflineplus">+ *</span>
<a href="#l37.8"></a><span id="l37.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l37.9"></a><span id="l37.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l37.10"></a><span id="l37.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l37.11"></a><span id="l37.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineplus">+ *</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l37.14"></a><span id="l37.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l37.15"></a><span id="l37.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l37.16"></a><span id="l37.16" class="difflineplus">+ * License.</span>
<a href="#l37.17"></a><span id="l37.17" class="difflineplus">+ *</span>
<a href="#l37.18"></a><span id="l37.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l37.19"></a><span id="l37.19" class="difflineplus">+ *</span>
<a href="#l37.20"></a><span id="l37.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l37.21"></a><span id="l37.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l37.22"></a><span id="l37.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l37.23"></a><span id="l37.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l37.24"></a><span id="l37.24" class="difflineplus">+ *</span>
<a href="#l37.25"></a><span id="l37.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l37.26"></a><span id="l37.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l37.27"></a><span id="l37.27" class="difflineplus">+ *</span>
<a href="#l37.28"></a><span id="l37.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l37.29"></a><span id="l37.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l37.30"></a><span id="l37.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l37.31"></a><span id="l37.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l37.32"></a><span id="l37.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l37.33"></a><span id="l37.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l37.34"></a><span id="l37.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l37.35"></a><span id="l37.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l37.36"></a><span id="l37.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l37.37"></a><span id="l37.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l37.38"></a><span id="l37.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l37.39"></a><span id="l37.39" class="difflineplus">+ *</span>
<a href="#l37.40"></a><span id="l37.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l37.41"></a><span id="l37.41" class="difflineplus">+</span>
<a href="#l37.42"></a><span id="l37.42" class="difflineplus">+/*</span>
<a href="#l37.43"></a><span id="l37.43" class="difflineplus">+ * Test indexing in the face of junk classification and junk folders.  It is</span>
<a href="#l37.44"></a><span id="l37.44" class="difflineplus">+ *  gloda policy not to index junk mail.</span>
<a href="#l37.45"></a><span id="l37.45" class="difflineplus">+ * </span>
<a href="#l37.46"></a><span id="l37.46" class="difflineplus">+ * A similar test that moving things to the trash folder is deletion happens in</span>
<a href="#l37.47"></a><span id="l37.47" class="difflineplus">+ *  base_index_messages.js.</span>
<a href="#l37.48"></a><span id="l37.48" class="difflineplus">+ */</span>
<a href="#l37.49"></a><span id="l37.49" class="difflineplus">+</span>
<a href="#l37.50"></a><span id="l37.50" class="difflineplus">+load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l37.51"></a><span id="l37.51" class="difflineplus">+</span>
<a href="#l37.52"></a><span id="l37.52" class="difflineplus">+</span>
<a href="#l37.53"></a><span id="l37.53" class="difflineplus">+/**</span>
<a href="#l37.54"></a><span id="l37.54" class="difflineplus">+ * Because gloda defers indexing until after junk, we should never index a</span>
<a href="#l37.55"></a><span id="l37.55" class="difflineplus">+ *  message that gets marked as junk.  So if we inject a message that will</span>
<a href="#l37.56"></a><span id="l37.56" class="difflineplus">+ *  definitely be marked as junk (thanks to use of terms that guarantee it),</span>
<a href="#l37.57"></a><span id="l37.57" class="difflineplus">+ *  the indexer should never index it.</span>
<a href="#l37.58"></a><span id="l37.58" class="difflineplus">+ */</span>
<a href="#l37.59"></a><span id="l37.59" class="difflineplus">+function test_never_indexes_a_message_marked_as_junk() {</span>
<a href="#l37.60"></a><span id="l37.60" class="difflineplus">+  mark_sub_test_start(&quot;event-driven does not index junk&quot;);</span>
<a href="#l37.61"></a><span id="l37.61" class="difflineplus">+  // make a message that will be marked as junk from the get-go</span>
<a href="#l37.62"></a><span id="l37.62" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1, junk: true}]);</span>
<a href="#l37.63"></a><span id="l37.63" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l37.64"></a><span id="l37.64" class="difflineplus">+  // since the message is junk, gloda should not index it!</span>
<a href="#l37.65"></a><span id="l37.65" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l37.66"></a><span id="l37.66" class="difflineplus">+</span>
<a href="#l37.67"></a><span id="l37.67" class="difflineplus">+  mark_sub_test_start(&quot;folder sweep does not index junk&quot;);</span>
<a href="#l37.68"></a><span id="l37.68" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l37.69"></a><span id="l37.69" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l37.70"></a><span id="l37.70" class="difflineplus">+}</span>
<a href="#l37.71"></a><span id="l37.71" class="difflineplus">+</span>
<a href="#l37.72"></a><span id="l37.72" class="difflineplus">+/**</span>
<a href="#l37.73"></a><span id="l37.73" class="difflineplus">+ * Marking a message as junk is equivalent to deleting the message, un-mark it</span>
<a href="#l37.74"></a><span id="l37.74" class="difflineplus">+ *  and it should go back to being a happy message (with the same gloda-id!).</span>
<a href="#l37.75"></a><span id="l37.75" class="difflineplus">+ */</span>
<a href="#l37.76"></a><span id="l37.76" class="difflineplus">+function test_mark_as_junk_is_deletion_mark_as_not_junk_is_exposure() {</span>
<a href="#l37.77"></a><span id="l37.77" class="difflineplus">+  mark_sub_test_start(&quot;mark as junk is deletion&quot;);</span>
<a href="#l37.78"></a><span id="l37.78" class="difflineplus">+  // create a message; it should get indexed</span>
<a href="#l37.79"></a><span id="l37.79" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l37.80"></a><span id="l37.80" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l37.81"></a><span id="l37.81" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet], {augment: true});</span>
<a href="#l37.82"></a><span id="l37.82" class="difflineplus">+</span>
<a href="#l37.83"></a><span id="l37.83" class="difflineplus">+  let glodaId = msgSet.glodaMessages[0].id;</span>
<a href="#l37.84"></a><span id="l37.84" class="difflineplus">+</span>
<a href="#l37.85"></a><span id="l37.85" class="difflineplus">+  // mark it as junk!</span>
<a href="#l37.86"></a><span id="l37.86" class="difflineplus">+  msgSet.setJunk(true);</span>
<a href="#l37.87"></a><span id="l37.87" class="difflineplus">+</span>
<a href="#l37.88"></a><span id="l37.88" class="difflineplus">+  // it will appear deleted after the event...</span>
<a href="#l37.89"></a><span id="l37.89" class="difflineplus">+  yield wait_for_gloda_indexer([], {deleted: msgSet});</span>
<a href="#l37.90"></a><span id="l37.90" class="difflineplus">+  </span>
<a href="#l37.91"></a><span id="l37.91" class="difflineplus">+</span>
<a href="#l37.92"></a><span id="l37.92" class="difflineplus">+  mark_sub_test_start(&quot;mark as non-junk gets indexed&quot;);</span>
<a href="#l37.93"></a><span id="l37.93" class="difflineplus">+  msgSet.setJunk(false);</span>
<a href="#l37.94"></a><span id="l37.94" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet], {augment: true});</span>
<a href="#l37.95"></a><span id="l37.95" class="difflineplus">+</span>
<a href="#l37.96"></a><span id="l37.96" class="difflineplus">+  // we should have reused the existing gloda message so it should keep the id</span>
<a href="#l37.97"></a><span id="l37.97" class="difflineplus">+  do_check_eq(glodaId, msgSet.glodaMessages[0].id);</span>
<a href="#l37.98"></a><span id="l37.98" class="difflineplus">+}</span>
<a href="#l37.99"></a><span id="l37.99" class="difflineplus">+</span>
<a href="#l37.100"></a><span id="l37.100" class="difflineplus">+/**</span>
<a href="#l37.101"></a><span id="l37.101" class="difflineplus">+ * Moving a message to the junk folder is equivalent to deletion.  Gloda does</span>
<a href="#l37.102"></a><span id="l37.102" class="difflineplus">+ *  not index junk folders at all, which is why this is an important and</span>
<a href="#l37.103"></a><span id="l37.103" class="difflineplus">+ *  independent determination from marking a message directly as junk.</span>
<a href="#l37.104"></a><span id="l37.104" class="difflineplus">+ * </span>
<a href="#l37.105"></a><span id="l37.105" class="difflineplus">+ * The move to the junk folder is performed without using any explicit junk</span>
<a href="#l37.106"></a><span id="l37.106" class="difflineplus">+ *  support code.  This ends up being effectively the same underlying logic test</span>
<a href="#l37.107"></a><span id="l37.107" class="difflineplus">+ *  as base_index_messages' test of moving a message to the trash folder.</span>
<a href="#l37.108"></a><span id="l37.108" class="difflineplus">+ */</span>
<a href="#l37.109"></a><span id="l37.109" class="difflineplus">+function test_message_moving_to_junk_folder_is_deletion() {</span>
<a href="#l37.110"></a><span id="l37.110" class="difflineplus">+  // create and index two messages in a conversation</span>
<a href="#l37.111"></a><span id="l37.111" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 2, msgsPerThread: 2}]);</span>
<a href="#l37.112"></a><span id="l37.112" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l37.113"></a><span id="l37.113" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet], {augment: true});</span>
<a href="#l37.114"></a><span id="l37.114" class="difflineplus">+</span>
<a href="#l37.115"></a><span id="l37.115" class="difflineplus">+  let convId = msgSet.glodaMessages[0].conversation.id;</span>
<a href="#l37.116"></a><span id="l37.116" class="difflineplus">+  let firstGlodaId = msgSet.glodaMessages[0].id;</span>
<a href="#l37.117"></a><span id="l37.117" class="difflineplus">+  let secondGlodaId = msgSet.glodaMessages[1].id;</span>
<a href="#l37.118"></a><span id="l37.118" class="difflineplus">+</span>
<a href="#l37.119"></a><span id="l37.119" class="difflineplus">+  // move them to the junk folder.</span>
<a href="#l37.120"></a><span id="l37.120" class="difflineplus">+  yield async_move_messages(msgSet, get_junk_folder());</span>
<a href="#l37.121"></a><span id="l37.121" class="difflineplus">+</span>
<a href="#l37.122"></a><span id="l37.122" class="difflineplus">+  // they will appear deleted after the events</span>
<a href="#l37.123"></a><span id="l37.123" class="difflineplus">+  yield wait_for_gloda_indexer([], {deleted: msgSet});</span>
<a href="#l37.124"></a><span id="l37.124" class="difflineplus">+</span>
<a href="#l37.125"></a><span id="l37.125" class="difflineplus">+  // we do not index the junk folder so this should actually make them appear</span>
<a href="#l37.126"></a><span id="l37.126" class="difflineplus">+  //  deleted to an unprivileged query.</span>
<a href="#l37.127"></a><span id="l37.127" class="difflineplus">+  let msgQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l37.128"></a><span id="l37.128" class="difflineplus">+  msgQuery.id(firstGlodaId, secondGlodaId);</span>
<a href="#l37.129"></a><span id="l37.129" class="difflineplus">+  queryExpect(msgQuery, []);</span>
<a href="#l37.130"></a><span id="l37.130" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l37.131"></a><span id="l37.131" class="difflineplus">+</span>
<a href="#l37.132"></a><span id="l37.132" class="difflineplus">+  // force a sweep</span>
<a href="#l37.133"></a><span id="l37.133" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l37.134"></a><span id="l37.134" class="difflineplus">+  // there should be no apparent change as the result of this pass</span>
<a href="#l37.135"></a><span id="l37.135" class="difflineplus">+  // (well, the conversation will die, but we can't see that.)</span>
<a href="#l37.136"></a><span id="l37.136" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l37.137"></a><span id="l37.137" class="difflineplus">+  </span>
<a href="#l37.138"></a><span id="l37.138" class="difflineplus">+  // the conversation should be gone</span>
<a href="#l37.139"></a><span id="l37.139" class="difflineplus">+  let convQuery = Gloda.newQuery(Gloda.NOUN_CONVERSATION);</span>
<a href="#l37.140"></a><span id="l37.140" class="difflineplus">+  convQuery.id(convId);</span>
<a href="#l37.141"></a><span id="l37.141" class="difflineplus">+  queryExpect(convQuery, []);</span>
<a href="#l37.142"></a><span id="l37.142" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l37.143"></a><span id="l37.143" class="difflineplus">+</span>
<a href="#l37.144"></a><span id="l37.144" class="difflineplus">+  // the messages should be entirely gone</span>
<a href="#l37.145"></a><span id="l37.145" class="difflineplus">+  let msgPrivQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l37.146"></a><span id="l37.146" class="difflineplus">+                                      noDbQueryValidityConstraints: true,</span>
<a href="#l37.147"></a><span id="l37.147" class="difflineplus">+                                    });</span>
<a href="#l37.148"></a><span id="l37.148" class="difflineplus">+  msgPrivQuery.id(firstGlodaId, secondGlodaId);</span>
<a href="#l37.149"></a><span id="l37.149" class="difflineplus">+  queryExpect(msgPrivQuery, []);</span>
<a href="#l37.150"></a><span id="l37.150" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l37.151"></a><span id="l37.151" class="difflineplus">+}</span>
<a href="#l37.152"></a><span id="l37.152" class="difflineplus">+</span>
<a href="#l37.153"></a><span id="l37.153" class="difflineplus">+var tests = [</span>
<a href="#l37.154"></a><span id="l37.154" class="difflineplus">+  test_never_indexes_a_message_marked_as_junk,</span>
<a href="#l37.155"></a><span id="l37.155" class="difflineplus">+  test_mark_as_junk_is_deletion_mark_as_not_junk_is_exposure,</span>
<a href="#l37.156"></a><span id="l37.156" class="difflineplus">+  test_message_moving_to_junk_folder_is_deletion,</span>
<a href="#l37.157"></a><span id="l37.157" class="difflineplus">+];</span>
<a href="#l37.158"></a><span id="l37.158">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1">rename from mailnews/db/gloda/test/unit/test_index_messages.js</span>
<a href="#l38.2"></a><span id="l38.2">rename to mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_messages.js</span>
<a href="#l38.4"></a><span id="l38.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l38.5"></a><span id="l38.5" class="difflineat">@@ -1,72 +1,236 @@</span>
<a href="#l38.6"></a><span id="l38.6" class="difflineminus">-/* This file tests our indexing prowess.  This includes both our ability to</span>
<a href="#l38.7"></a><span id="l38.7" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l38.8"></a><span id="l38.8" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l38.9"></a><span id="l38.9" class="difflineplus">+ *</span>
<a href="#l38.10"></a><span id="l38.10" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l38.11"></a><span id="l38.11" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l38.14"></a><span id="l38.14" class="difflineplus">+ *</span>
<a href="#l38.15"></a><span id="l38.15" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l38.16"></a><span id="l38.16" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l38.17"></a><span id="l38.17" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l38.18"></a><span id="l38.18" class="difflineplus">+ * License.</span>
<a href="#l38.19"></a><span id="l38.19" class="difflineplus">+ *</span>
<a href="#l38.20"></a><span id="l38.20" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l38.21"></a><span id="l38.21" class="difflineplus">+ *</span>
<a href="#l38.22"></a><span id="l38.22" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l38.23"></a><span id="l38.23" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l38.24"></a><span id="l38.24" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l38.25"></a><span id="l38.25" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l38.26"></a><span id="l38.26" class="difflineplus">+ *</span>
<a href="#l38.27"></a><span id="l38.27" class="difflineplus">+ * Contributor(s):</span>
<a href="#l38.28"></a><span id="l38.28" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l38.29"></a><span id="l38.29" class="difflineplus">+ *   Siddharth Agarwal &lt;sid.bugzilla@gmail.com&gt;</span>
<a href="#l38.30"></a><span id="l38.30" class="difflineplus">+ *</span>
<a href="#l38.31"></a><span id="l38.31" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l38.32"></a><span id="l38.32" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l38.33"></a><span id="l38.33" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l38.34"></a><span id="l38.34" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l38.35"></a><span id="l38.35" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l38.36"></a><span id="l38.36" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l38.37"></a><span id="l38.37" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l38.38"></a><span id="l38.38" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l38.39"></a><span id="l38.39" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l38.40"></a><span id="l38.40" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l38.41"></a><span id="l38.41" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l38.42"></a><span id="l38.42" class="difflineplus">+ *</span>
<a href="#l38.43"></a><span id="l38.43" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l38.44"></a><span id="l38.44" class="difflineplus">+</span>
<a href="#l38.45"></a><span id="l38.45" class="difflineplus">+/*</span>
<a href="#l38.46"></a><span id="l38.46" class="difflineplus">+ * This file tests our indexing prowess.  This includes both our ability to</span>
<a href="#l38.47"></a><span id="l38.47">  *  properly be triggered by events taking place in thunderbird as well as our</span>
<a href="#l38.48"></a><span id="l38.48">  *  ability to correctly extract/index the right data.</span>
<a href="#l38.49"></a><span id="l38.49">  * In general, if these tests pass, things are probably working quite well.</span>
<a href="#l38.50"></a><span id="l38.50">  *</span>
<a href="#l38.51"></a><span id="l38.51" class="difflineplus">+ * This test has local, IMAP online, IMAP offline, and IMAP online-become-offline</span>
<a href="#l38.52"></a><span id="l38.52" class="difflineplus">+ *  variants.  See the text_index_messages_*.js files.</span>
<a href="#l38.53"></a><span id="l38.53" class="difflineplus">+ *</span>
<a href="#l38.54"></a><span id="l38.54">  * Things we don't test that you think we might test:</span>
<a href="#l38.55"></a><span id="l38.55">  * - Full-text search.  Happens in query testing.</span>
<a href="#l38.56"></a><span id="l38.56">  */</span>
<a href="#l38.57"></a><span id="l38.57"> </span>
<a href="#l38.58"></a><span id="l38.58" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l38.59"></a><span id="l38.59"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l38.60"></a><span id="l38.60"> </span>
<a href="#l38.61"></a><span id="l38.61"> // Whether we can expect fulltext results</span>
<a href="#l38.62"></a><span id="l38.62"> var expectFulltextResults = true;</span>
<a href="#l38.63"></a><span id="l38.63"> </span>
<a href="#l38.64"></a><span id="l38.64" class="difflineminus">-// Create a message generator</span>
<a href="#l38.65"></a><span id="l38.65" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l38.66"></a><span id="l38.66" class="difflineminus">-// Create a message scenario generator using that message generator</span>
<a href="#l38.67"></a><span id="l38.67" class="difflineminus">-var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l38.68"></a><span id="l38.68" class="difflineplus">+/**</span>
<a href="#l38.69"></a><span id="l38.69" class="difflineplus">+ * Should we force our folders offline after we have indexed them once.  We do</span>
<a href="#l38.70"></a><span id="l38.70" class="difflineplus">+ * this in the online_to_offline test variant.</span>
<a href="#l38.71"></a><span id="l38.71" class="difflineplus">+ */</span>
<a href="#l38.72"></a><span id="l38.72" class="difflineplus">+var goOffline = false;</span>
<a href="#l38.73"></a><span id="l38.73" class="difflineplus">+</span>
<a href="#l38.74"></a><span id="l38.74" class="difflineplus">+/* ===== Indexing Basics ===== */</span>
<a href="#l38.75"></a><span id="l38.75" class="difflineplus">+</span>
<a href="#l38.76"></a><span id="l38.76" class="difflineplus">+/**</span>
<a href="#l38.77"></a><span id="l38.77" class="difflineplus">+ * Index a message, wait for a commit, make sure the header gets the property</span>
<a href="#l38.78"></a><span id="l38.78" class="difflineplus">+ *  set correctly.  Then modify the message, verify the dirty property shows</span>
<a href="#l38.79"></a><span id="l38.79" class="difflineplus">+ *  up, flush again, and make sure the dirty property goes clean again.</span>
<a href="#l38.80"></a><span id="l38.80" class="difflineplus">+ */</span>
<a href="#l38.81"></a><span id="l38.81" class="difflineplus">+function test_pending_commit_tracker_flushes_correctly() {</span>
<a href="#l38.82"></a><span id="l38.82" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l38.83"></a><span id="l38.83" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.84"></a><span id="l38.84" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet, {augment: true});</span>
<a href="#l38.85"></a><span id="l38.85" class="difflineplus">+</span>
<a href="#l38.86"></a><span id="l38.86" class="difflineplus">+  // before the flush, there should be no gloda-id property</span>
<a href="#l38.87"></a><span id="l38.87" class="difflineplus">+  let msgHdr = msgSet.getMsgHdr(0);</span>
<a href="#l38.88"></a><span id="l38.88" class="difflineplus">+  // get it as a string to make sure it's empty rather than possessing a value</span>
<a href="#l38.89"></a><span id="l38.89" class="difflineplus">+  do_check_eq(msgHdr.getStringProperty(&quot;gloda-id&quot;), &quot;&quot;);</span>
<a href="#l38.90"></a><span id="l38.90" class="difflineplus">+</span>
<a href="#l38.91"></a><span id="l38.91" class="difflineplus">+  yield wait_for_gloda_db_flush();</span>
<a href="#l38.92"></a><span id="l38.92" class="difflineplus">+</span>
<a href="#l38.93"></a><span id="l38.93" class="difflineplus">+  // after the flush there should be a gloda-id property and it should</span>
<a href="#l38.94"></a><span id="l38.94" class="difflineplus">+  //  equal the gloda id</span>
<a href="#l38.95"></a><span id="l38.95" class="difflineplus">+  let gmsg = msgSet.glodaMessages[0];</span>
<a href="#l38.96"></a><span id="l38.96" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-id&quot;), gmsg.id);</span>
<a href="#l38.97"></a><span id="l38.97" class="difflineplus">+</span>
<a href="#l38.98"></a><span id="l38.98" class="difflineplus">+  // make sure no dirty property was written...</span>
<a href="#l38.99"></a><span id="l38.99" class="difflineplus">+  do_check_eq(msgHdr.getStringProperty(&quot;gloda-dirty&quot;), &quot;&quot;);</span>
<a href="#l38.100"></a><span id="l38.100" class="difflineplus">+</span>
<a href="#l38.101"></a><span id="l38.101" class="difflineplus">+  // modify the message</span>
<a href="#l38.102"></a><span id="l38.102" class="difflineplus">+  msgSet.setRead(true);</span>
<a href="#l38.103"></a><span id="l38.103" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.104"></a><span id="l38.104" class="difflineplus">+</span>
<a href="#l38.105"></a><span id="l38.105" class="difflineplus">+  // now there should be a dirty property and it should be 1...</span>
<a href="#l38.106"></a><span id="l38.106" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-dirty&quot;),</span>
<a href="#l38.107"></a><span id="l38.107" class="difflineplus">+              GlodaMsgIndexer.kMessageDirty);</span>
<a href="#l38.108"></a><span id="l38.108" class="difflineplus">+</span>
<a href="#l38.109"></a><span id="l38.109" class="difflineplus">+  // flush</span>
<a href="#l38.110"></a><span id="l38.110" class="difflineplus">+  yield wait_for_gloda_db_flush();</span>
<a href="#l38.111"></a><span id="l38.111" class="difflineplus">+</span>
<a href="#l38.112"></a><span id="l38.112" class="difflineplus">+  // now dirty should be 0 and the gloda id should still be the same</span>
<a href="#l38.113"></a><span id="l38.113" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-dirty&quot;),</span>
<a href="#l38.114"></a><span id="l38.114" class="difflineplus">+              GlodaMsgIndexer.kMessageClean);</span>
<a href="#l38.115"></a><span id="l38.115" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-id&quot;), gmsg.id);</span>
<a href="#l38.116"></a><span id="l38.116" class="difflineplus">+}</span>
<a href="#l38.117"></a><span id="l38.117" class="difflineplus">+</span>
<a href="#l38.118"></a><span id="l38.118" class="difflineplus">+/**</span>
<a href="#l38.119"></a><span id="l38.119" class="difflineplus">+ * Give the indexing sweep a workout.</span>
<a href="#l38.120"></a><span id="l38.120" class="difflineplus">+ *</span>
<a href="#l38.121"></a><span id="l38.121" class="difflineplus">+ * This includes:</span>
<a href="#l38.122"></a><span id="l38.122" class="difflineplus">+ * - Basic indexing sweep across never-before-indexed folders.</span>
<a href="#l38.123"></a><span id="l38.123" class="difflineplus">+ * - Indexing sweep across folders with just some changes.</span>
<a href="#l38.124"></a><span id="l38.124" class="difflineplus">+ * - Filthy pass.</span>
<a href="#l38.125"></a><span id="l38.125" class="difflineplus">+ */</span>
<a href="#l38.126"></a><span id="l38.126" class="difflineplus">+function test_indexing_sweep() {</span>
<a href="#l38.127"></a><span id="l38.127" class="difflineplus">+  // -- Never-before-indexed folders</span>
<a href="#l38.128"></a><span id="l38.128" class="difflineplus">+  mark_sub_test_start(&quot;never before indexed folders&quot;);</span>
<a href="#l38.129"></a><span id="l38.129" class="difflineplus">+  // turn off event-driven indexing</span>
<a href="#l38.130"></a><span id="l38.130" class="difflineplus">+  configure_gloda_indexing({event: false});</span>
<a href="#l38.131"></a><span id="l38.131" class="difflineplus">+</span>
<a href="#l38.132"></a><span id="l38.132" class="difflineplus">+  let [folderA, setA1, setA2] = make_folder_with_sets([{count: 3},</span>
<a href="#l38.133"></a><span id="l38.133" class="difflineplus">+                                                       {count: 2}]);</span>
<a href="#l38.134"></a><span id="l38.134" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.135"></a><span id="l38.135" class="difflineplus">+  let [folderB, setB1, setB2] = make_folder_with_sets([{count: 3},</span>
<a href="#l38.136"></a><span id="l38.136" class="difflineplus">+                                                       {count: 2}]);</span>
<a href="#l38.137"></a><span id="l38.137" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.138"></a><span id="l38.138" class="difflineplus">+  let [folderC, setC1, setC2] = make_folder_with_sets([{count: 3},</span>
<a href="#l38.139"></a><span id="l38.139" class="difflineplus">+                                                       {count: 2}]);</span>
<a href="#l38.140"></a><span id="l38.140" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.141"></a><span id="l38.141" class="difflineplus">+</span>
<a href="#l38.142"></a><span id="l38.142" class="difflineplus">+  // Make sure that event-driven job gets nuked out of existence</span>
<a href="#l38.143"></a><span id="l38.143" class="difflineplus">+  GlodaIndexer.purgeJobsUsingFilter(function() true);</span>
<a href="#l38.144"></a><span id="l38.144" class="difflineplus">+</span>
<a href="#l38.145"></a><span id="l38.145" class="difflineplus">+  // turn on event-driven indexing again; this will trigger a sweep.</span>
<a href="#l38.146"></a><span id="l38.146" class="difflineplus">+  configure_gloda_indexing({event: true});</span>
<a href="#l38.147"></a><span id="l38.147" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.148"></a><span id="l38.148" class="difflineplus">+  yield wait_for_gloda_indexer([setA1, setA2, setB1, setB2, setC1, setC2]);</span>
<a href="#l38.149"></a><span id="l38.149" class="difflineplus">+</span>
<a href="#l38.150"></a><span id="l38.150" class="difflineplus">+</span>
<a href="#l38.151"></a><span id="l38.151" class="difflineplus">+  // -- Folders with some changes, pending commits</span>
<a href="#l38.152"></a><span id="l38.152" class="difflineplus">+  mark_sub_test_start(&quot;folders with some changes, pending commits&quot;);</span>
<a href="#l38.153"></a><span id="l38.153" class="difflineplus">+  // indexing off</span>
<a href="#l38.154"></a><span id="l38.154" class="difflineplus">+  configure_gloda_indexing({event: false});</span>
<a href="#l38.155"></a><span id="l38.155" class="difflineplus">+</span>
<a href="#l38.156"></a><span id="l38.156" class="difflineplus">+  setA1.setRead(true);</span>
<a href="#l38.157"></a><span id="l38.157" class="difflineplus">+  setB2.setRead(true);</span>
<a href="#l38.158"></a><span id="l38.158" class="difflineplus">+</span>
<a href="#l38.159"></a><span id="l38.159" class="difflineplus">+  // indexing on, killing all outstanding jobs, trigger sweep</span>
<a href="#l38.160"></a><span id="l38.160" class="difflineplus">+  GlodaIndexer.purgeJobsUsingFilter(function() true);</span>
<a href="#l38.161"></a><span id="l38.161" class="difflineplus">+  configure_gloda_indexing({event: true});</span>
<a href="#l38.162"></a><span id="l38.162" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.163"></a><span id="l38.163" class="difflineplus">+</span>
<a href="#l38.164"></a><span id="l38.164" class="difflineplus">+  yield wait_for_gloda_indexer([setA1, setB2]);</span>
<a href="#l38.165"></a><span id="l38.165" class="difflineplus">+</span>
<a href="#l38.166"></a><span id="l38.166" class="difflineplus">+</span>
<a href="#l38.167"></a><span id="l38.167" class="difflineplus">+  // -- Folders with some changes, no pending commits</span>
<a href="#l38.168"></a><span id="l38.168" class="difflineplus">+  mark_sub_test_start(&quot;folders with some changes, no pending commits&quot;);</span>
<a href="#l38.169"></a><span id="l38.169" class="difflineplus">+  // force a commit to clear out our pending commits</span>
<a href="#l38.170"></a><span id="l38.170" class="difflineplus">+  yield wait_for_gloda_db_flush();</span>
<a href="#l38.171"></a><span id="l38.171" class="difflineplus">+  // indexing off</span>
<a href="#l38.172"></a><span id="l38.172" class="difflineplus">+  configure_gloda_indexing({event: false});</span>
<a href="#l38.173"></a><span id="l38.173" class="difflineplus">+</span>
<a href="#l38.174"></a><span id="l38.174" class="difflineplus">+  setA2.setRead(true);</span>
<a href="#l38.175"></a><span id="l38.175" class="difflineplus">+  setB1.setRead(true);</span>
<a href="#l38.176"></a><span id="l38.176" class="difflineplus">+</span>
<a href="#l38.177"></a><span id="l38.177" class="difflineplus">+  // indexing on, killing all outstanding jobs, trigger sweep</span>
<a href="#l38.178"></a><span id="l38.178" class="difflineplus">+  GlodaIndexer.purgeJobsUsingFilter(function() true);</span>
<a href="#l38.179"></a><span id="l38.179" class="difflineplus">+  configure_gloda_indexing({event: true});</span>
<a href="#l38.180"></a><span id="l38.180" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.181"></a><span id="l38.181" class="difflineplus">+</span>
<a href="#l38.182"></a><span id="l38.182" class="difflineplus">+  yield wait_for_gloda_indexer([setA2, setB1]);</span>
<a href="#l38.183"></a><span id="l38.183" class="difflineplus">+</span>
<a href="#l38.184"></a><span id="l38.184" class="difflineplus">+</span>
<a href="#l38.185"></a><span id="l38.185" class="difflineplus">+  // -- Filthy foldering indexing</span>
<a href="#l38.186"></a><span id="l38.186" class="difflineplus">+  // Just mark the folder filthy and make sure that we reindex everyone.</span>
<a href="#l38.187"></a><span id="l38.187" class="difflineplus">+  // IMPORTANT!  The trick of marking the folder filthy only works because</span>
<a href="#l38.188"></a><span id="l38.188" class="difflineplus">+  //  we flushed/committed the database above; the PendingCommitTracker</span>
<a href="#l38.189"></a><span id="l38.189" class="difflineplus">+  //  is not aware of bogus filthy-marking of folders.</span>
<a href="#l38.190"></a><span id="l38.190" class="difflineplus">+  // We leave the verification of the implementation details to</span>
<a href="#l38.191"></a><span id="l38.191" class="difflineplus">+  //  test_index_sweep_folder.js.</span>
<a href="#l38.192"></a><span id="l38.192" class="difflineplus">+  mark_sub_test_start(&quot;filthy folder indexing&quot;);</span>
<a href="#l38.193"></a><span id="l38.193" class="difflineplus">+  let glodaFolderC = Gloda.getFolderForFolder(</span>
<a href="#l38.194"></a><span id="l38.194" class="difflineplus">+                       get_real_injection_folder(folderC));</span>
<a href="#l38.195"></a><span id="l38.195" class="difflineplus">+  glodaFolderC.dirtyStatus = glodaFolderC.kFolderFilthy;</span>
<a href="#l38.196"></a><span id="l38.196" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;marked gloda folder dirty&quot;, [glodaFolderC]);</span>
<a href="#l38.197"></a><span id="l38.197" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.198"></a><span id="l38.198" class="difflineplus">+  yield wait_for_gloda_indexer([setC1, setC2]);</span>
<a href="#l38.199"></a><span id="l38.199" class="difflineplus">+}</span>
<a href="#l38.200"></a><span id="l38.200"> </span>
<a href="#l38.201"></a><span id="l38.201"> /* ===== Threading / Conversation Grouping ===== */</span>
<a href="#l38.202"></a><span id="l38.202"> </span>
<a href="#l38.203"></a><span id="l38.203"> var gSynMessages = [];</span>
<a href="#l38.204"></a><span id="l38.204"> function allMessageInSameConversation(aSynthMessage, aGlodaMessage, aConvID) {</span>
<a href="#l38.205"></a><span id="l38.205">   if (aConvID === undefined)</span>
<a href="#l38.206"></a><span id="l38.206">     return aGlodaMessage.conversationID;</span>
<a href="#l38.207"></a><span id="l38.207">   do_check_eq(aConvID, aGlodaMessage.conversationID);</span>
<a href="#l38.208"></a><span id="l38.208">   // Cheat and stash the synthetic message (we need them for one of the IMAP</span>
<a href="#l38.209"></a><span id="l38.209">   // tests)</span>
<a href="#l38.210"></a><span id="l38.210">   gSynMessages.push(aSynthMessage);</span>
<a href="#l38.211"></a><span id="l38.211">   return aConvID;</span>
<a href="#l38.212"></a><span id="l38.212"> }</span>
<a href="#l38.213"></a><span id="l38.213"> </span>
<a href="#l38.214"></a><span id="l38.214" class="difflineminus">-// These are overridden by the IMAP tests as needed</span>
<a href="#l38.215"></a><span id="l38.215" class="difflineminus">-var pre_test_threading_hook = function default_pre_test_threading_hook() {</span>
<a href="#l38.216"></a><span id="l38.216" class="difflineminus">-  next_test();</span>
<a href="#l38.217"></a><span id="l38.217" class="difflineminus">-};</span>
<a href="#l38.218"></a><span id="l38.218" class="difflineminus">-var post_test_threading_hook = function default_post_test_threading_hook() {</span>
<a href="#l38.219"></a><span id="l38.219" class="difflineminus">-  next_test();</span>
<a href="#l38.220"></a><span id="l38.220" class="difflineminus">-};</span>
<a href="#l38.221"></a><span id="l38.221" class="difflineminus">-</span>
<a href="#l38.222"></a><span id="l38.222"> /**</span>
<a href="#l38.223"></a><span id="l38.223">  * Test our conversation/threading logic in the straight-forward direct</span>
<a href="#l38.224"></a><span id="l38.224">  *  reply case, the missing intermediary case, and the siblings with missing</span>
<a href="#l38.225"></a><span id="l38.225">  *  parent case.  We also test all permutations of receipt of those messages.</span>
<a href="#l38.226"></a><span id="l38.226">  * (Also tests that we index new messages.)</span>
<a href="#l38.227"></a><span id="l38.227">  */</span>
<a href="#l38.228"></a><span id="l38.228"> function test_threading() {</span>
<a href="#l38.229"></a><span id="l38.229" class="difflineminus">-  indexAndPermuteMessages(scenarios.directReply,</span>
<a href="#l38.230"></a><span id="l38.230" class="difflineminus">-                          allMessageInSameConversation);</span>
<a href="#l38.231"></a><span id="l38.231" class="difflineminus">-  indexAndPermuteMessages(scenarios.missingIntermediary,</span>
<a href="#l38.232"></a><span id="l38.232" class="difflineminus">-                          allMessageInSameConversation);</span>
<a href="#l38.233"></a><span id="l38.233" class="difflineminus">-  indexAndPermuteMessages(scenarios.siblingsMissingParent,</span>
<a href="#l38.234"></a><span id="l38.234" class="difflineminus">-                          allMessageInSameConversation,</span>
<a href="#l38.235"></a><span id="l38.235" class="difflineminus">-                          next_test);</span>
<a href="#l38.236"></a><span id="l38.236" class="difflineplus">+  mark_sub_test_start(&quot;direct reply&quot;);</span>
<a href="#l38.237"></a><span id="l38.237" class="difflineplus">+  yield indexAndPermuteMessages(scenarios.directReply,</span>
<a href="#l38.238"></a><span id="l38.238" class="difflineplus">+                                allMessageInSameConversation);</span>
<a href="#l38.239"></a><span id="l38.239" class="difflineplus">+  mark_sub_test_start(&quot;missing intermediary&quot;);</span>
<a href="#l38.240"></a><span id="l38.240" class="difflineplus">+  yield indexAndPermuteMessages(scenarios.missingIntermediary,</span>
<a href="#l38.241"></a><span id="l38.241" class="difflineplus">+                                allMessageInSameConversation);</span>
<a href="#l38.242"></a><span id="l38.242" class="difflineplus">+  mark_sub_test_start(&quot;siblings missing parent&quot;);</span>
<a href="#l38.243"></a><span id="l38.243" class="difflineplus">+  yield indexAndPermuteMessages(scenarios.siblingsMissingParent,</span>
<a href="#l38.244"></a><span id="l38.244" class="difflineplus">+                                allMessageInSameConversation);</span>
<a href="#l38.245"></a><span id="l38.245"> }</span>
<a href="#l38.246"></a><span id="l38.246"> </span>
<a href="#l38.247"></a><span id="l38.247"> /* ===== Fundamental Attributes (per fundattr.js) ===== */</span>
<a href="#l38.248"></a><span id="l38.248"> </span>
<a href="#l38.249"></a><span id="l38.249"> /**</span>
<a href="#l38.250"></a><span id="l38.250">  * Save the synthetic message created in test_attributes_fundamental for the</span>
<a href="#l38.251"></a><span id="l38.251">  *  benefit of test_attributes_fundamental_from_disk.</span>
<a href="#l38.252"></a><span id="l38.252">  */</span>
<a href="#l38.253"></a><span id="l38.253"> var fundamentalSyntheticMessage;</span>
<a href="#l38.254"></a><span id="l38.254" class="difflineplus">+var fundamentalFolderHandle;</span>
<a href="#l38.255"></a><span id="l38.255"> /**</span>
<a href="#l38.256"></a><span id="l38.256">  * Save the resulting gloda message id corresponding to the</span>
<a href="#l38.257"></a><span id="l38.257">  *  fundamentalSyntheticMessage.</span>
<a href="#l38.258"></a><span id="l38.258">  */</span>
<a href="#l38.259"></a><span id="l38.259"> var fundamentalGlodaMessageId;</span>
<a href="#l38.260"></a><span id="l38.260"> </span>
<a href="#l38.261"></a><span id="l38.261"> /**</span>
<a href="#l38.262"></a><span id="l38.262">  * Test that we extract the 'fundamental attributes' of a message properly</span>
<a href="#l38.263"></a><span id="l38.263" class="difflineat">@@ -78,90 +242,89 @@ function test_attributes_fundamental() {</span>
<a href="#l38.264"></a><span id="l38.264">   // create a synthetic message with attachment</span>
<a href="#l38.265"></a><span id="l38.265">   let smsg = msgGen.makeMessage({</span>
<a href="#l38.266"></a><span id="l38.266">     attachments: [</span>
<a href="#l38.267"></a><span id="l38.267">       {filename: 'bob.txt', body: 'I like cheese!'}</span>
<a href="#l38.268"></a><span id="l38.268">     ],</span>
<a href="#l38.269"></a><span id="l38.269">   });</span>
<a href="#l38.270"></a><span id="l38.270">   // save it off for test_attributes_fundamental_from_disk</span>
<a href="#l38.271"></a><span id="l38.271">   fundamentalSyntheticMessage = smsg;</span>
<a href="#l38.272"></a><span id="l38.272" class="difflineminus">-</span>
<a href="#l38.273"></a><span id="l38.273" class="difflineminus">-  indexMessages([smsg], verify_attributes_fundamental, next_test);</span>
<a href="#l38.274"></a><span id="l38.274" class="difflineminus">-}</span>
<a href="#l38.275"></a><span id="l38.275" class="difflineplus">+  let msgSet = new SyntheticMessageSet([smsg]);</span>
<a href="#l38.276"></a><span id="l38.276" class="difflineplus">+  let folder = fundamentalFolderHandle = make_empty_folder();</span>
<a href="#l38.277"></a><span id="l38.277" class="difflineplus">+  yield add_sets_to_folders(folder, [msgSet]);</span>
<a href="#l38.278"></a><span id="l38.278"> </span>
<a href="#l38.279"></a><span id="l38.279" class="difflineminus">-// Overridden by test_index_imap_mesasges</span>
<a href="#l38.280"></a><span id="l38.280" class="difflineminus">-var get_expected_folder_URI = function local_get_expected_folder_URI() {</span>
<a href="#l38.281"></a><span id="l38.281" class="difflineminus">-  return gLocalInboxFolder.URI;</span>
<a href="#l38.282"></a><span id="l38.282" class="difflineminus">-};</span>
<a href="#l38.283"></a><span id="l38.283" class="difflineplus">+  // if we need to go offline, let the indexing pass run, then force us offline</span>
<a href="#l38.284"></a><span id="l38.284" class="difflineplus">+  if (goOffline) {</span>
<a href="#l38.285"></a><span id="l38.285" class="difflineplus">+    yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.286"></a><span id="l38.286" class="difflineplus">+    yield make_folder_and_contents_offline(folder);</span>
<a href="#l38.287"></a><span id="l38.287" class="difflineplus">+    // now the next indexer wait will wait for the next indexing pass...</span>
<a href="#l38.288"></a><span id="l38.288" class="difflineplus">+  }</span>
<a href="#l38.289"></a><span id="l38.289" class="difflineplus">+</span>
<a href="#l38.290"></a><span id="l38.290" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet,</span>
<a href="#l38.291"></a><span id="l38.291" class="difflineplus">+                               {verifier: verify_attributes_fundamental});</span>
<a href="#l38.292"></a><span id="l38.292" class="difflineplus">+}</span>
<a href="#l38.293"></a><span id="l38.293"> </span>
<a href="#l38.294"></a><span id="l38.294"> function verify_attributes_fundamental(smsg, gmsg) {</span>
<a href="#l38.295"></a><span id="l38.295" class="difflineminus">-  try {</span>
<a href="#l38.296"></a><span id="l38.296" class="difflineminus">-    // save off the message id for test_attributes_fundamental_from_disk</span>
<a href="#l38.297"></a><span id="l38.297" class="difflineminus">-    fundamentalGlodaMessageId = gmsg.id;</span>
<a href="#l38.298"></a><span id="l38.298" class="difflineplus">+  // save off the message id for test_attributes_fundamental_from_disk</span>
<a href="#l38.299"></a><span id="l38.299" class="difflineplus">+  fundamentalGlodaMessageId = gmsg.id;</span>
<a href="#l38.300"></a><span id="l38.300"> </span>
<a href="#l38.301"></a><span id="l38.301" class="difflineminus">-    do_check_eq(gmsg.folderURI, get_expected_folder_URI());</span>
<a href="#l38.302"></a><span id="l38.302" class="difflineminus">-</span>
<a href="#l38.303"></a><span id="l38.303" class="difflineminus">-    // -- subject</span>
<a href="#l38.304"></a><span id="l38.304" class="difflineminus">-    do_check_eq(smsg.subject, gmsg.conversation.subject);</span>
<a href="#l38.305"></a><span id="l38.305" class="difflineminus">-    do_check_eq(smsg.subject, gmsg.subject);</span>
<a href="#l38.306"></a><span id="l38.306" class="difflineplus">+  do_check_eq(gmsg.folderURI,</span>
<a href="#l38.307"></a><span id="l38.307" class="difflineplus">+              get_real_injection_folder(fundamentalFolderHandle).URI);</span>
<a href="#l38.308"></a><span id="l38.308"> </span>
<a href="#l38.309"></a><span id="l38.309" class="difflineminus">-    // -- contact/identity information</span>
<a href="#l38.310"></a><span id="l38.310" class="difflineminus">-    // - from</span>
<a href="#l38.311"></a><span id="l38.311" class="difflineminus">-    // check the e-mail address</span>
<a href="#l38.312"></a><span id="l38.312" class="difflineminus">-    do_check_eq(gmsg.from.kind, &quot;email&quot;);</span>
<a href="#l38.313"></a><span id="l38.313" class="difflineminus">-    do_check_eq(smsg.fromAddress, gmsg.from.value);</span>
<a href="#l38.314"></a><span id="l38.314" class="difflineminus">-    // check the name</span>
<a href="#l38.315"></a><span id="l38.315" class="difflineminus">-    do_check_eq(smsg.fromName, gmsg.from.contact.name);</span>
<a href="#l38.316"></a><span id="l38.316" class="difflineplus">+  // -- subject</span>
<a href="#l38.317"></a><span id="l38.317" class="difflineplus">+  do_check_eq(smsg.subject, gmsg.conversation.subject);</span>
<a href="#l38.318"></a><span id="l38.318" class="difflineplus">+  do_check_eq(smsg.subject, gmsg.subject);</span>
<a href="#l38.319"></a><span id="l38.319"> </span>
<a href="#l38.320"></a><span id="l38.320" class="difflineminus">-    // - to</span>
<a href="#l38.321"></a><span id="l38.321" class="difflineminus">-    do_check_eq(smsg.toAddress, gmsg.to[0].value);</span>
<a href="#l38.322"></a><span id="l38.322" class="difflineminus">-    do_check_eq(smsg.toName, gmsg.to[0].contact.name);</span>
<a href="#l38.323"></a><span id="l38.323" class="difflineplus">+  // -- contact/identity information</span>
<a href="#l38.324"></a><span id="l38.324" class="difflineplus">+  // - from</span>
<a href="#l38.325"></a><span id="l38.325" class="difflineplus">+  // check the e-mail address</span>
<a href="#l38.326"></a><span id="l38.326" class="difflineplus">+  do_check_eq(gmsg.from.kind, &quot;email&quot;);</span>
<a href="#l38.327"></a><span id="l38.327" class="difflineplus">+  do_check_eq(smsg.fromAddress, gmsg.from.value);</span>
<a href="#l38.328"></a><span id="l38.328" class="difflineplus">+  // check the name</span>
<a href="#l38.329"></a><span id="l38.329" class="difflineplus">+  do_check_eq(smsg.fromName, gmsg.from.contact.name);</span>
<a href="#l38.330"></a><span id="l38.330"> </span>
<a href="#l38.331"></a><span id="l38.331" class="difflineminus">-    // date</span>
<a href="#l38.332"></a><span id="l38.332" class="difflineminus">-    do_check_eq(smsg.date.valueOf(), gmsg.date.valueOf());</span>
<a href="#l38.333"></a><span id="l38.333" class="difflineminus">-    </span>
<a href="#l38.334"></a><span id="l38.334" class="difflineminus">-    // -- message ID</span>
<a href="#l38.335"></a><span id="l38.335" class="difflineminus">-    do_check_eq(smsg.messageId, gmsg.headerMessageID);</span>
<a href="#l38.336"></a><span id="l38.336" class="difflineplus">+  // - to</span>
<a href="#l38.337"></a><span id="l38.337" class="difflineplus">+  do_check_eq(smsg.toAddress, gmsg.to[0].value);</span>
<a href="#l38.338"></a><span id="l38.338" class="difflineplus">+  do_check_eq(smsg.toName, gmsg.to[0].contact.name);</span>
<a href="#l38.339"></a><span id="l38.339" class="difflineplus">+</span>
<a href="#l38.340"></a><span id="l38.340" class="difflineplus">+  // date</span>
<a href="#l38.341"></a><span id="l38.341" class="difflineplus">+  do_check_eq(smsg.date.valueOf(), gmsg.date.valueOf());</span>
<a href="#l38.342"></a><span id="l38.342" class="difflineplus">+</span>
<a href="#l38.343"></a><span id="l38.343" class="difflineplus">+  // -- message ID</span>
<a href="#l38.344"></a><span id="l38.344" class="difflineplus">+  do_check_eq(smsg.messageId, gmsg.headerMessageID);</span>
<a href="#l38.345"></a><span id="l38.345"> </span>
<a href="#l38.346"></a><span id="l38.346" class="difflineminus">-    // -- attachments. We won't have these if we don't have fulltext results</span>
<a href="#l38.347"></a><span id="l38.347" class="difflineminus">-    if (expectFulltextResults) {</span>
<a href="#l38.348"></a><span id="l38.348" class="difflineminus">-      do_check_eq(gmsg.attachmentTypes.length, 1);</span>
<a href="#l38.349"></a><span id="l38.349" class="difflineminus">-      do_check_eq(gmsg.attachmentTypes[0], &quot;text/plain&quot;);</span>
<a href="#l38.350"></a><span id="l38.350" class="difflineminus">-      do_check_eq(gmsg.attachmentNames.length, 1);</span>
<a href="#l38.351"></a><span id="l38.351" class="difflineminus">-      do_check_eq(gmsg.attachmentNames[0], &quot;bob.txt&quot;);</span>
<a href="#l38.352"></a><span id="l38.352" class="difflineminus">-    }</span>
<a href="#l38.353"></a><span id="l38.353" class="difflineminus">-    else {</span>
<a href="#l38.354"></a><span id="l38.354" class="difflineminus">-      // Make sure we don't actually get attachments!</span>
<a href="#l38.355"></a><span id="l38.355" class="difflineminus">-      do_check_eq(gmsg.attachmentTypes, null);</span>
<a href="#l38.356"></a><span id="l38.356" class="difflineminus">-      do_check_eq(gmsg.attachmentNames, null);</span>
<a href="#l38.357"></a><span id="l38.357" class="difflineminus">-    }</span>
<a href="#l38.358"></a><span id="l38.358" class="difflineplus">+  // -- attachments. We won't have these if we don't have fulltext results</span>
<a href="#l38.359"></a><span id="l38.359" class="difflineplus">+  if (expectFulltextResults) {</span>
<a href="#l38.360"></a><span id="l38.360" class="difflineplus">+    do_check_eq(gmsg.attachmentTypes.length, 1);</span>
<a href="#l38.361"></a><span id="l38.361" class="difflineplus">+    do_check_eq(gmsg.attachmentTypes[0], &quot;text/plain&quot;);</span>
<a href="#l38.362"></a><span id="l38.362" class="difflineplus">+    do_check_eq(gmsg.attachmentNames.length, 1);</span>
<a href="#l38.363"></a><span id="l38.363" class="difflineplus">+    do_check_eq(gmsg.attachmentNames[0], &quot;bob.txt&quot;);</span>
<a href="#l38.364"></a><span id="l38.364">   }</span>
<a href="#l38.365"></a><span id="l38.365" class="difflineminus">-  catch (ex) {</span>
<a href="#l38.366"></a><span id="l38.366" class="difflineminus">-    // print out some info on the various states of the messages...</span>
<a href="#l38.367"></a><span id="l38.367" class="difflineminus">-    dump(&quot;***** FUNDAMENTAL ATTRIBUTE NON-MATCH\n&quot;);</span>
<a href="#l38.368"></a><span id="l38.368" class="difflineminus">-    ddumpObject(smsg, &quot;smsg&quot;, 0);</span>
<a href="#l38.369"></a><span id="l38.369" class="difflineminus">-    ddumpObject(gmsg, &quot;gmsg&quot;, 0);</span>
<a href="#l38.370"></a><span id="l38.370" class="difflineminus">-    throw ex;</span>
<a href="#l38.371"></a><span id="l38.371" class="difflineplus">+  else {</span>
<a href="#l38.372"></a><span id="l38.372" class="difflineplus">+    // Make sure we don't actually get attachments!</span>
<a href="#l38.373"></a><span id="l38.373" class="difflineplus">+    do_check_eq(gmsg.attachmentTypes, null);</span>
<a href="#l38.374"></a><span id="l38.374" class="difflineplus">+    do_check_eq(gmsg.attachmentNames, null);</span>
<a href="#l38.375"></a><span id="l38.375">   }</span>
<a href="#l38.376"></a><span id="l38.376"> }</span>
<a href="#l38.377"></a><span id="l38.377"> </span>
<a href="#l38.378"></a><span id="l38.378"> /**</span>
<a href="#l38.379"></a><span id="l38.379">  * We want to make sure that all of the fundamental properties also are there</span>
<a href="#l38.380"></a><span id="l38.380">  *  when we load them from disk.  Nuke our cache, query the message back up.</span>
<a href="#l38.381"></a><span id="l38.381">  *  We previously used getMessagesByMessageID to get the message back, but he</span>
<a href="#l38.382"></a><span id="l38.382">  *  does not perform a full load-out like a query does, so we need to use our</span>
<a href="#l38.383"></a><span id="l38.383">  *  query mechanism for this.</span>
<a href="#l38.384"></a><span id="l38.384">  */</span>
<a href="#l38.385"></a><span id="l38.385"> function test_attributes_fundamental_from_disk() {</span>
<a href="#l38.386"></a><span id="l38.386">   nukeGlodaCachesAndCollections();</span>
<a href="#l38.387"></a><span id="l38.387"> </span>
<a href="#l38.388"></a><span id="l38.388">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE).id(fundamentalGlodaMessageId);</span>
<a href="#l38.389"></a><span id="l38.389">   queryExpect(query, [fundamentalSyntheticMessage],</span>
<a href="#l38.390"></a><span id="l38.390" class="difflineminus">-      verify_attributes_fundamental_from_disk,</span>
<a href="#l38.391"></a><span id="l38.391" class="difflineminus">-      function (smsg) { return smsg.messageId; } );</span>
<a href="#l38.392"></a><span id="l38.392" class="difflineplus">+              verify_attributes_fundamental_from_disk,</span>
<a href="#l38.393"></a><span id="l38.393" class="difflineplus">+              function (smsg) { return smsg.messageId; } );</span>
<a href="#l38.394"></a><span id="l38.394" class="difflineplus">+  return false;</span>
<a href="#l38.395"></a><span id="l38.395"> }</span>
<a href="#l38.396"></a><span id="l38.396"> </span>
<a href="#l38.397"></a><span id="l38.397"> /**</span>
<a href="#l38.398"></a><span id="l38.398">  * We are just a wrapper around verify_attributes_fundamental, adapting the</span>
<a href="#l38.399"></a><span id="l38.399">  *  return callback from getMessagesByMessageID.</span>
<a href="#l38.400"></a><span id="l38.400">  *</span>
<a href="#l38.401"></a><span id="l38.401">  * @param aGlodaMessageLists This should be [[theGlodaMessage]].</span>
<a href="#l38.402"></a><span id="l38.402">  */</span>
<a href="#l38.403"></a><span id="l38.403" class="difflineat">@@ -169,104 +332,474 @@ function verify_attributes_fundamental_f</span>
<a href="#l38.404"></a><span id="l38.404">   // return the message id for test_attributes_fundamental_from_disk's benefit</span>
<a href="#l38.405"></a><span id="l38.405">   verify_attributes_fundamental(fundamentalSyntheticMessage,</span>
<a href="#l38.406"></a><span id="l38.406">                                 aGlodaMessage);</span>
<a href="#l38.407"></a><span id="l38.407">   return aGlodaMessage.headerMessageID;</span>
<a href="#l38.408"></a><span id="l38.408"> }</span>
<a href="#l38.409"></a><span id="l38.409"> </span>
<a href="#l38.410"></a><span id="l38.410"> /* ===== Explicit Attributes (per explattr.js) ===== */</span>
<a href="#l38.411"></a><span id="l38.411"> </span>
<a href="#l38.412"></a><span id="l38.412" class="difflineminus">-function expl_attr_twiddle_star(aMsgHdr, aDesiredState) {</span>
<a href="#l38.413"></a><span id="l38.413" class="difflineminus">-  aMsgHdr.markFlagged(aDesiredState);</span>
<a href="#l38.414"></a><span id="l38.414" class="difflineminus">-}</span>
<a href="#l38.415"></a><span id="l38.415" class="difflineplus">+/**</span>
<a href="#l38.416"></a><span id="l38.416" class="difflineplus">+ * Test the attributes defined by explattr.js.</span>
<a href="#l38.417"></a><span id="l38.417" class="difflineplus">+ */</span>
<a href="#l38.418"></a><span id="l38.418" class="difflineplus">+function test_attributes_explicit() {</span>
<a href="#l38.419"></a><span id="l38.419" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l38.420"></a><span id="l38.420" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.421"></a><span id="l38.421" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet, {augment: true});</span>
<a href="#l38.422"></a><span id="l38.422" class="difflineplus">+  let gmsg = msgSet.glodaMessages[0];</span>
<a href="#l38.423"></a><span id="l38.423"> </span>
<a href="#l38.424"></a><span id="l38.424" class="difflineminus">-function expl_attr_verify_star(smsg, gmsg, aExpectedState) {</span>
<a href="#l38.425"></a><span id="l38.425" class="difflineminus">-  do_check_eq(gmsg.starred, aExpectedState);</span>
<a href="#l38.426"></a><span id="l38.426" class="difflineminus">-}</span>
<a href="#l38.427"></a><span id="l38.427" class="difflineplus">+  // -- Star</span>
<a href="#l38.428"></a><span id="l38.428" class="difflineplus">+  mark_sub_test_start(&quot;Star&quot;);</span>
<a href="#l38.429"></a><span id="l38.429" class="difflineplus">+  msgSet.setStarred(true);</span>
<a href="#l38.430"></a><span id="l38.430" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.431"></a><span id="l38.431" class="difflineplus">+  do_check_eq(gmsg.starred, true);</span>
<a href="#l38.432"></a><span id="l38.432" class="difflineplus">+</span>
<a href="#l38.433"></a><span id="l38.433" class="difflineplus">+  msgSet.setStarred(false);</span>
<a href="#l38.434"></a><span id="l38.434" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.435"></a><span id="l38.435" class="difflineplus">+  do_check_eq(gmsg.starred, false);</span>
<a href="#l38.436"></a><span id="l38.436" class="difflineplus">+</span>
<a href="#l38.437"></a><span id="l38.437" class="difflineplus">+  // -- Read / Unread</span>
<a href="#l38.438"></a><span id="l38.438" class="difflineplus">+  mark_sub_test_start(&quot;Read/Unread&quot;);</span>
<a href="#l38.439"></a><span id="l38.439" class="difflineplus">+  msgSet.setRead(true);</span>
<a href="#l38.440"></a><span id="l38.440" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.441"></a><span id="l38.441" class="difflineplus">+  do_check_eq(gmsg.read, true);</span>
<a href="#l38.442"></a><span id="l38.442" class="difflineplus">+</span>
<a href="#l38.443"></a><span id="l38.443" class="difflineplus">+  msgSet.setRead(false);</span>
<a href="#l38.444"></a><span id="l38.444" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.445"></a><span id="l38.445" class="difflineplus">+  do_check_eq(gmsg.read, false);</span>
<a href="#l38.446"></a><span id="l38.446"> </span>
<a href="#l38.447"></a><span id="l38.447" class="difflineminus">-function expl_attr_twiddle_read(aMsgHdr, aDesiredState) {</span>
<a href="#l38.448"></a><span id="l38.448" class="difflineminus">-  aMsgHdr.markRead(!aMsgHdr.isRead);</span>
<a href="#l38.449"></a><span id="l38.449" class="difflineminus">-}</span>
<a href="#l38.450"></a><span id="l38.450" class="difflineplus">+  // -- Tags</span>
<a href="#l38.451"></a><span id="l38.451" class="difflineplus">+  mark_sub_test_start(&quot;Tags&quot;);</span>
<a href="#l38.452"></a><span id="l38.452" class="difflineplus">+  // note that the tag service does not guarantee stable nsIMsgTag references,</span>
<a href="#l38.453"></a><span id="l38.453" class="difflineplus">+  //  nor does noun_tag go too far out of its way to provide stability.</span>
<a href="#l38.454"></a><span id="l38.454" class="difflineplus">+  //  However, it is stable as long as we don't spook it by bringing new tags</span>
<a href="#l38.455"></a><span id="l38.455" class="difflineplus">+  //  into the equation.</span>
<a href="#l38.456"></a><span id="l38.456" class="difflineplus">+  let tagOne = TagNoun.getTag(&quot;$label1&quot;);</span>
<a href="#l38.457"></a><span id="l38.457" class="difflineplus">+  let tagTwo = TagNoun.getTag(&quot;$label2&quot;);</span>
<a href="#l38.458"></a><span id="l38.458" class="difflineplus">+</span>
<a href="#l38.459"></a><span id="l38.459" class="difflineplus">+  msgSet.addTag(tagOne.key);</span>
<a href="#l38.460"></a><span id="l38.460" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.461"></a><span id="l38.461" class="difflineplus">+  do_check_neq(gmsg.tags.indexOf(tagOne), -1);</span>
<a href="#l38.462"></a><span id="l38.462"> </span>
<a href="#l38.463"></a><span id="l38.463" class="difflineminus">-function expl_attr_verify_read(smsg, gmsg, aExpectedState) {</span>
<a href="#l38.464"></a><span id="l38.464" class="difflineminus">-  do_check_eq(gmsg.read, aExpectedState);</span>
<a href="#l38.465"></a><span id="l38.465" class="difflineminus">-}</span>
<a href="#l38.466"></a><span id="l38.466" class="difflineplus">+  msgSet.addTag(tagTwo.key);</span>
<a href="#l38.467"></a><span id="l38.467" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.468"></a><span id="l38.468" class="difflineplus">+  do_check_neq(gmsg.tags.indexOf(tagOne), -1);</span>
<a href="#l38.469"></a><span id="l38.469" class="difflineplus">+  do_check_neq(gmsg.tags.indexOf(tagTwo), -1);</span>
<a href="#l38.470"></a><span id="l38.470"> </span>
<a href="#l38.471"></a><span id="l38.471" class="difflineminus">-function expl_attr_twiddle_tags(aMsgHdr, aTagMods) {</span>
<a href="#l38.472"></a><span id="l38.472" class="difflineminus">-  // TODO: twiddle tags</span>
<a href="#l38.473"></a><span id="l38.473" class="difflineminus">-}</span>
<a href="#l38.474"></a><span id="l38.474" class="difflineplus">+  msgSet.removeTag(tagOne.key);</span>
<a href="#l38.475"></a><span id="l38.475" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.476"></a><span id="l38.476" class="difflineplus">+  do_check_eq(gmsg.tags.indexOf(tagOne), -1);</span>
<a href="#l38.477"></a><span id="l38.477" class="difflineplus">+  do_check_neq(gmsg.tags.indexOf(tagTwo), -1);</span>
<a href="#l38.478"></a><span id="l38.478"> </span>
<a href="#l38.479"></a><span id="l38.479" class="difflineminus">-function expl_attr_verify_tags(smsg, gmsg, aExpectedTags) {</span>
<a href="#l38.480"></a><span id="l38.480" class="difflineminus">-  // TODO: verify tags</span>
<a href="#l38.481"></a><span id="l38.481" class="difflineplus">+  msgSet.removeTag(tagTwo.key);</span>
<a href="#l38.482"></a><span id="l38.482" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.483"></a><span id="l38.483" class="difflineplus">+  do_check_eq(gmsg.tags.indexOf(tagOne), -1);</span>
<a href="#l38.484"></a><span id="l38.484" class="difflineplus">+  do_check_eq(gmsg.tags.indexOf(tagTwo), -1);</span>
<a href="#l38.485"></a><span id="l38.485" class="difflineplus">+</span>
<a href="#l38.486"></a><span id="l38.486" class="difflineplus">+  // -- Replied To</span>
<a href="#l38.487"></a><span id="l38.487" class="difflineplus">+</span>
<a href="#l38.488"></a><span id="l38.488" class="difflineplus">+  // -- Forwarded</span>
<a href="#l38.489"></a><span id="l38.489"> }</span>
<a href="#l38.490"></a><span id="l38.490"> </span>
<a href="#l38.491"></a><span id="l38.491" class="difflineminus">-var explicitAttributeTwiddlings = [</span>
<a href="#l38.492"></a><span id="l38.492" class="difflineminus">-  // toggle starred</span>
<a href="#l38.493"></a><span id="l38.493" class="difflineminus">-  [expl_attr_twiddle_star, expl_attr_verify_star, true],</span>
<a href="#l38.494"></a><span id="l38.494" class="difflineminus">-  [expl_attr_twiddle_star, expl_attr_verify_star, false],</span>
<a href="#l38.495"></a><span id="l38.495" class="difflineminus">-  // toggle read/unread</span>
<a href="#l38.496"></a><span id="l38.496" class="difflineminus">-  [expl_attr_twiddle_read, expl_attr_verify_read, true],</span>
<a href="#l38.497"></a><span id="l38.497" class="difflineminus">-  [expl_attr_twiddle_read, expl_attr_verify_read, false]/*,</span>
<a href="#l38.498"></a><span id="l38.498" class="difflineminus">-  // twiddle tags</span>
<a href="#l38.499"></a><span id="l38.499" class="difflineminus">-  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l38.500"></a><span id="l38.500" class="difflineminus">-   [1, &quot;funky&quot;], [&quot;funky&quot;]],</span>
<a href="#l38.501"></a><span id="l38.501" class="difflineminus">-  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l38.502"></a><span id="l38.502" class="difflineminus">-   [1, &quot;town&quot;], [&quot;funky&quot;, &quot;town&quot;]],</span>
<a href="#l38.503"></a><span id="l38.503" class="difflineminus">-  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l38.504"></a><span id="l38.504" class="difflineminus">-   [-1, &quot;funky&quot;], [&quot;town&quot;]],</span>
<a href="#l38.505"></a><span id="l38.505" class="difflineminus">-  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l38.506"></a><span id="l38.506" class="difflineminus">-   [-1, &quot;town&quot;], []],</span>
<a href="#l38.507"></a><span id="l38.507" class="difflineminus">-*/</span>
<a href="#l38.508"></a><span id="l38.508" class="difflineminus">-];</span>
<a href="#l38.509"></a><span id="l38.509" class="difflineplus">+</span>
<a href="#l38.510"></a><span id="l38.510" class="difflineplus">+/* ===== Message Deletion ===== */</span>
<a href="#l38.511"></a><span id="l38.511" class="difflineplus">+/**</span>
<a href="#l38.512"></a><span id="l38.512" class="difflineplus">+ * Test actually deleting a message on a per-message basis (not just nuking the</span>
<a href="#l38.513"></a><span id="l38.513" class="difflineplus">+ *  folder like emptying the trash does.)</span>
<a href="#l38.514"></a><span id="l38.514" class="difflineplus">+ * </span>
<a href="#l38.515"></a><span id="l38.515" class="difflineplus">+ * Logic situations:</span>
<a href="#l38.516"></a><span id="l38.516" class="difflineplus">+ * - Non-last message in a conversation, twin.</span>
<a href="#l38.517"></a><span id="l38.517" class="difflineplus">+ * - Non-last message in a conversation, not a twin.</span>
<a href="#l38.518"></a><span id="l38.518" class="difflineplus">+ * - Last message in a conversation</span>
<a href="#l38.519"></a><span id="l38.519" class="difflineplus">+ */</span>
<a href="#l38.520"></a><span id="l38.520" class="difflineplus">+function test_message_deletion() {</span>
<a href="#l38.521"></a><span id="l38.521" class="difflineplus">+  mark_sub_test_start(&quot;non-last message in conv, twin&quot;);</span>
<a href="#l38.522"></a><span id="l38.522" class="difflineplus">+  // create and index two messages in a conversation</span>
<a href="#l38.523"></a><span id="l38.523" class="difflineplus">+  let [folder, convSet] = make_folder_with_sets([{count: 2, msgsPerThread: 2}]);</span>
<a href="#l38.524"></a><span id="l38.524" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.525"></a><span id="l38.525" class="difflineplus">+  yield wait_for_gloda_indexer([convSet], {augment: true});</span>
<a href="#l38.526"></a><span id="l38.526" class="difflineplus">+</span>
<a href="#l38.527"></a><span id="l38.527" class="difflineplus">+  // Twin the first message in a different folder owing to our reliance on</span>
<a href="#l38.528"></a><span id="l38.528" class="difflineplus">+  //  message-id's in the SyntheticMessageSet logic.  (This is also why we broke</span>
<a href="#l38.529"></a><span id="l38.529" class="difflineplus">+  //  up the indexing waits too.)</span>
<a href="#l38.530"></a><span id="l38.530" class="difflineplus">+  let twinFolder = make_empty_folder();</span>
<a href="#l38.531"></a><span id="l38.531" class="difflineplus">+  let twinSet = new SyntheticMessageSet([convSet.synMessages[0]]);</span>
<a href="#l38.532"></a><span id="l38.532" class="difflineplus">+  yield add_sets_to_folder(twinFolder, [twinSet]);</span>
<a href="#l38.533"></a><span id="l38.533" class="difflineplus">+  yield wait_for_gloda_indexer([twinSet], {augment: true});</span>
<a href="#l38.534"></a><span id="l38.534" class="difflineplus">+</span>
<a href="#l38.535"></a><span id="l38.535" class="difflineplus">+  // Split the conv set into two helper sets...</span>
<a href="#l38.536"></a><span id="l38.536" class="difflineplus">+  let firstSet = convSet.slice(0, 1); // the twinned first message in the thread</span>
<a href="#l38.537"></a><span id="l38.537" class="difflineplus">+  let secondSet = convSet.slice(1, 2); // the un-twinned second thread message</span>
<a href="#l38.538"></a><span id="l38.538" class="difflineplus">+</span>
<a href="#l38.539"></a><span id="l38.539" class="difflineplus">+  // make sure we can find the message (paranoia)</span>
<a href="#l38.540"></a><span id="l38.540" class="difflineplus">+  let firstQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l38.541"></a><span id="l38.541" class="difflineplus">+  firstQuery.id(firstSet.glodaMessages[0].id);</span>
<a href="#l38.542"></a><span id="l38.542" class="difflineplus">+  let firstColl = queryExpect(firstQuery, firstSet);</span>
<a href="#l38.543"></a><span id="l38.543" class="difflineplus">+  yield false; // queryExpect is async but returns a value...</span>
<a href="#l38.544"></a><span id="l38.544" class="difflineplus">+</span>
<a href="#l38.545"></a><span id="l38.545" class="difflineplus">+  // delete it (not trash! delete!)</span>
<a href="#l38.546"></a><span id="l38.546" class="difflineplus">+  yield async_delete_messages(firstSet);</span>
<a href="#l38.547"></a><span id="l38.547" class="difflineplus">+  // which should result in an apparent deletion</span>
<a href="#l38.548"></a><span id="l38.548" class="difflineplus">+  yield wait_for_gloda_indexer([], {deleted: firstSet});</span>
<a href="#l38.549"></a><span id="l38.549" class="difflineplus">+  // and our collection from that query should now be empty</span>
<a href="#l38.550"></a><span id="l38.550" class="difflineplus">+  do_check_eq(firstColl.items.length, 0);</span>
<a href="#l38.551"></a><span id="l38.551" class="difflineplus">+</span>
<a href="#l38.552"></a><span id="l38.552" class="difflineplus">+  // make sure it no longer shows up in a standard query</span>
<a href="#l38.553"></a><span id="l38.553" class="difflineplus">+  firstColl = queryExpect(firstQuery, []);</span>
<a href="#l38.554"></a><span id="l38.554" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.555"></a><span id="l38.555" class="difflineplus">+</span>
<a href="#l38.556"></a><span id="l38.556" class="difflineplus">+  // make sure it shows up in a privileged query</span>
<a href="#l38.557"></a><span id="l38.557" class="difflineplus">+  let privQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l38.558"></a><span id="l38.558" class="difflineplus">+                      noDbQueryValidityConstraints: true,</span>
<a href="#l38.559"></a><span id="l38.559" class="difflineplus">+                    });</span>
<a href="#l38.560"></a><span id="l38.560" class="difflineplus">+  let firstGlodaId = firstSet.glodaMessages[0].id;</span>
<a href="#l38.561"></a><span id="l38.561" class="difflineplus">+  privQuery.id(firstGlodaId);</span>
<a href="#l38.562"></a><span id="l38.562" class="difflineplus">+  queryExpect(privQuery, firstSet);</span>
<a href="#l38.563"></a><span id="l38.563" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.564"></a><span id="l38.564" class="difflineplus">+</span>
<a href="#l38.565"></a><span id="l38.565" class="difflineplus">+  // force a deletion pass</span>
<a href="#l38.566"></a><span id="l38.566" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.567"></a><span id="l38.567" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l38.568"></a><span id="l38.568" class="difflineplus">+</span>
<a href="#l38.569"></a><span id="l38.569" class="difflineplus">+  // Make sure it no longer shows up in a privileged query; since it has a twin</span>
<a href="#l38.570"></a><span id="l38.570" class="difflineplus">+  //  we don't need to leave it as a ghost.</span>
<a href="#l38.571"></a><span id="l38.571" class="difflineplus">+  queryExpect(privQuery, []);</span>
<a href="#l38.572"></a><span id="l38.572" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.573"></a><span id="l38.573" class="difflineplus">+</span>
<a href="#l38.574"></a><span id="l38.574" class="difflineplus">+  // make sure the messagesText entry got blown away</span>
<a href="#l38.575"></a><span id="l38.575" class="difflineplus">+  yield sqlExpectCount(0, &quot;SELECT COUNT(*) FROM messagesText WHERE docid = ?1&quot;,</span>
<a href="#l38.576"></a><span id="l38.576" class="difflineplus">+                       firstGlodaId);</span>
<a href="#l38.577"></a><span id="l38.577" class="difflineplus">+</span>
<a href="#l38.578"></a><span id="l38.578" class="difflineplus">+  // make sure the conversation still exists...</span>
<a href="#l38.579"></a><span id="l38.579" class="difflineplus">+  let conv = twinSet.glodaMessages[0].conversation;</span>
<a href="#l38.580"></a><span id="l38.580" class="difflineplus">+  let convQuery = Gloda.newQuery(Gloda.NOUN_CONVERSATION);</span>
<a href="#l38.581"></a><span id="l38.581" class="difflineplus">+  convQuery.id(conv.id);</span>
<a href="#l38.582"></a><span id="l38.582" class="difflineplus">+  let convColl = queryExpect(convQuery, [conv]);</span>
<a href="#l38.583"></a><span id="l38.583" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.584"></a><span id="l38.584"> </span>
<a href="#l38.585"></a><span id="l38.585"> </span>
<a href="#l38.586"></a><span id="l38.586" class="difflineminus">-function test_attributes_explicit() {</span>
<a href="#l38.587"></a><span id="l38.587" class="difflineminus">-  let smsg = msgGen.makeMessage();</span>
<a href="#l38.588"></a><span id="l38.588" class="difflineplus">+  // -- non-last message, no longer a twin</span>
<a href="#l38.589"></a><span id="l38.589" class="difflineplus">+  mark_sub_test_start(&quot;non-last message in conv, no longer a twin&quot;);</span>
<a href="#l38.590"></a><span id="l38.590" class="difflineplus">+</span>
<a href="#l38.591"></a><span id="l38.591" class="difflineplus">+  // make sure nuking the twin didn't somehow kill them both</span>
<a href="#l38.592"></a><span id="l38.592" class="difflineplus">+  let twinQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l38.593"></a><span id="l38.593" class="difflineplus">+  // (let's search on the message-id now that there is no ambiguity.)</span>
<a href="#l38.594"></a><span id="l38.594" class="difflineplus">+  twinQuery.headerMessageID(twinSet.synMessages[0].messageId);</span>
<a href="#l38.595"></a><span id="l38.595" class="difflineplus">+  let twinColl = queryExpect(twinQuery, twinSet);</span>
<a href="#l38.596"></a><span id="l38.596" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.597"></a><span id="l38.597" class="difflineplus">+  </span>
<a href="#l38.598"></a><span id="l38.598" class="difflineplus">+  // delete the twin</span>
<a href="#l38.599"></a><span id="l38.599" class="difflineplus">+  yield async_delete_messages(twinSet);</span>
<a href="#l38.600"></a><span id="l38.600" class="difflineplus">+  // which should result in an apparent deletion</span>
<a href="#l38.601"></a><span id="l38.601" class="difflineplus">+  yield wait_for_gloda_indexer([], {deleted: twinSet});</span>
<a href="#l38.602"></a><span id="l38.602" class="difflineplus">+  // it should disappear from the collection</span>
<a href="#l38.603"></a><span id="l38.603" class="difflineplus">+  do_check_eq(twinColl.items.length, 0);</span>
<a href="#l38.604"></a><span id="l38.604" class="difflineplus">+</span>
<a href="#l38.605"></a><span id="l38.605" class="difflineplus">+  // no longer show up in the standard query</span>
<a href="#l38.606"></a><span id="l38.606" class="difflineplus">+  twinColl = queryExpect(twinQuery, []);</span>
<a href="#l38.607"></a><span id="l38.607" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.608"></a><span id="l38.608" class="difflineplus">+  </span>
<a href="#l38.609"></a><span id="l38.609" class="difflineplus">+  // still show up in a privileged query</span>
<a href="#l38.610"></a><span id="l38.610" class="difflineplus">+  privQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l38.611"></a><span id="l38.611" class="difflineplus">+                               noDbQueryValidityConstraints: true,</span>
<a href="#l38.612"></a><span id="l38.612" class="difflineplus">+                             });</span>
<a href="#l38.613"></a><span id="l38.613" class="difflineplus">+  privQuery.headerMessageID(twinSet.synMessages[0].messageId);</span>
<a href="#l38.614"></a><span id="l38.614" class="difflineplus">+  queryExpect(privQuery, twinSet);</span>
<a href="#l38.615"></a><span id="l38.615" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.616"></a><span id="l38.616" class="difflineplus">+</span>
<a href="#l38.617"></a><span id="l38.617" class="difflineplus">+  // force a deletion pass</span>
<a href="#l38.618"></a><span id="l38.618" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.619"></a><span id="l38.619" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l38.620"></a><span id="l38.620" class="difflineplus">+</span>
<a href="#l38.621"></a><span id="l38.621" class="difflineplus">+  // it still should show up in the privileged query; it's a ghost!</span>
<a href="#l38.622"></a><span id="l38.622" class="difflineplus">+  let privColl = queryExpect(privQuery, twinSet);</span>
<a href="#l38.623"></a><span id="l38.623" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.624"></a><span id="l38.624" class="difflineplus">+  // make sure it looks like a ghost.</span>
<a href="#l38.625"></a><span id="l38.625" class="difflineplus">+  let twinGhost = privColl.items[0];</span>
<a href="#l38.626"></a><span id="l38.626" class="difflineplus">+  do_check_eq(twinGhost._folderID, null);</span>
<a href="#l38.627"></a><span id="l38.627" class="difflineplus">+  do_check_eq(twinGhost._messageKey, null);</span>
<a href="#l38.628"></a><span id="l38.628" class="difflineplus">+</span>
<a href="#l38.629"></a><span id="l38.629" class="difflineplus">+  // make sure the conversation still exists...</span>
<a href="#l38.630"></a><span id="l38.630" class="difflineplus">+  queryExpect(convQuery, [conv]);</span>
<a href="#l38.631"></a><span id="l38.631" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.632"></a><span id="l38.632" class="difflineplus">+</span>
<a href="#l38.633"></a><span id="l38.633"> </span>
<a href="#l38.634"></a><span id="l38.634" class="difflineminus">-  twiddleAndTest(smsg, explicitAttributeTwiddlings);</span>
<a href="#l38.635"></a><span id="l38.635" class="difflineplus">+  // -- non-last message, not a twin</span>
<a href="#l38.636"></a><span id="l38.636" class="difflineplus">+  // This should blow away the message, the ghosts, and the conversation.</span>
<a href="#l38.637"></a><span id="l38.637" class="difflineplus">+  mark_sub_test_start(&quot;last message in conv&quot;);</span>
<a href="#l38.638"></a><span id="l38.638" class="difflineplus">+</span>
<a href="#l38.639"></a><span id="l38.639" class="difflineplus">+  // second message should still be around</span>
<a href="#l38.640"></a><span id="l38.640" class="difflineplus">+  let secondQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l38.641"></a><span id="l38.641" class="difflineplus">+  secondQuery.headerMessageID(secondSet.synMessages[0].messageId);</span>
<a href="#l38.642"></a><span id="l38.642" class="difflineplus">+  let secondColl = queryExpect(secondQuery, secondSet);</span>
<a href="#l38.643"></a><span id="l38.643" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.644"></a><span id="l38.644" class="difflineplus">+</span>
<a href="#l38.645"></a><span id="l38.645" class="difflineplus">+  // delete it and make sure it gets marked deleted appropriately</span>
<a href="#l38.646"></a><span id="l38.646" class="difflineplus">+  yield async_delete_messages(secondSet);</span>
<a href="#l38.647"></a><span id="l38.647" class="difflineplus">+  yield wait_for_gloda_indexer([], {deleted: secondSet});</span>
<a href="#l38.648"></a><span id="l38.648" class="difflineplus">+  do_check_eq(secondColl.items.length, 0);</span>
<a href="#l38.649"></a><span id="l38.649" class="difflineplus">+</span>
<a href="#l38.650"></a><span id="l38.650" class="difflineplus">+  // still show up in a privileged query</span>
<a href="#l38.651"></a><span id="l38.651" class="difflineplus">+  privQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l38.652"></a><span id="l38.652" class="difflineplus">+                               noDbQueryValidityConstraints: true,</span>
<a href="#l38.653"></a><span id="l38.653" class="difflineplus">+                             });</span>
<a href="#l38.654"></a><span id="l38.654" class="difflineplus">+  privQuery.headerMessageID(secondSet.synMessages[0].messageId);</span>
<a href="#l38.655"></a><span id="l38.655" class="difflineplus">+  queryExpect(privQuery, secondSet);</span>
<a href="#l38.656"></a><span id="l38.656" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.657"></a><span id="l38.657" class="difflineplus">+</span>
<a href="#l38.658"></a><span id="l38.658" class="difflineplus">+  // force a deletion pass</span>
<a href="#l38.659"></a><span id="l38.659" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.660"></a><span id="l38.660" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l38.661"></a><span id="l38.661" class="difflineplus">+</span>
<a href="#l38.662"></a><span id="l38.662" class="difflineplus">+  // it should no longer show up in a privileged query; we killed the ghosts</span>
<a href="#l38.663"></a><span id="l38.663" class="difflineplus">+  queryExpect(privQuery, []);</span>
<a href="#l38.664"></a><span id="l38.664" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.665"></a><span id="l38.665" class="difflineplus">+</span>
<a href="#l38.666"></a><span id="l38.666" class="difflineplus">+  // - the conversation should have disappeared too</span>
<a href="#l38.667"></a><span id="l38.667" class="difflineplus">+  // (we have no listener to watch for it to have disappeared from convQuery but</span>
<a href="#l38.668"></a><span id="l38.668" class="difflineplus">+  //  this is basically how glodaTestHelper does its thing anyways.)</span>
<a href="#l38.669"></a><span id="l38.669" class="difflineplus">+  do_check_eq(convColl.items.length, 0);</span>
<a href="#l38.670"></a><span id="l38.670" class="difflineplus">+</span>
<a href="#l38.671"></a><span id="l38.671" class="difflineplus">+  // make sure the query fails to find it too</span>
<a href="#l38.672"></a><span id="l38.672" class="difflineplus">+  queryExpect(convQuery, []);</span>
<a href="#l38.673"></a><span id="l38.673" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.674"></a><span id="l38.674" class="difflineplus">+</span>
<a href="#l38.675"></a><span id="l38.675" class="difflineplus">+</span>
<a href="#l38.676"></a><span id="l38.676" class="difflineplus">+  // -- identity culling verification</span>
<a href="#l38.677"></a><span id="l38.677" class="difflineplus">+  mark_sub_test_start(&quot;identity culling verification&quot;);</span>
<a href="#l38.678"></a><span id="l38.678" class="difflineplus">+  // The identities associated with that message should no longer exist, nor</span>
<a href="#l38.679"></a><span id="l38.679" class="difflineplus">+  //  should their contacts.</span>
<a href="#l38.680"></a><span id="l38.680" class="difflineplus">+</span>
<a href="#l38.681"></a><span id="l38.681"> }</span>
<a href="#l38.682"></a><span id="l38.682"> </span>
<a href="#l38.683"></a><span id="l38.683" class="difflineminus">-function do_moveMessage(aMsgHdr, aDestFolder) {</span>
<a href="#l38.684"></a><span id="l38.684" class="difflineminus">-  gCopyService.CopyMessages(aMsgHdr.folder,</span>
<a href="#l38.685"></a><span id="l38.685" class="difflineminus">-    toXPCOMArray(aMsgHdr, Components.interfaces.nsIMutableArray),</span>
<a href="#l38.686"></a><span id="l38.686" class="difflineminus">-    aDestFolder, true, null, null, true);</span>
<a href="#l38.687"></a><span id="l38.687" class="difflineminus">-}</span>
<a href="#l38.688"></a><span id="l38.688" class="difflineplus">+function test_moving_to_trash_marks_deletion() {</span>
<a href="#l38.689"></a><span id="l38.689" class="difflineplus">+  // create and index two messages in a conversation</span>
<a href="#l38.690"></a><span id="l38.690" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 2, msgsPerThread: 2}]);</span>
<a href="#l38.691"></a><span id="l38.691" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.692"></a><span id="l38.692" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet], {augment: true});</span>
<a href="#l38.693"></a><span id="l38.693" class="difflineplus">+</span>
<a href="#l38.694"></a><span id="l38.694" class="difflineplus">+  let convId = msgSet.glodaMessages[0].conversation.id;</span>
<a href="#l38.695"></a><span id="l38.695" class="difflineplus">+  let firstGlodaId = msgSet.glodaMessages[0].id;</span>
<a href="#l38.696"></a><span id="l38.696" class="difflineplus">+  let secondGlodaId = msgSet.glodaMessages[1].id;</span>
<a href="#l38.697"></a><span id="l38.697" class="difflineplus">+</span>
<a href="#l38.698"></a><span id="l38.698" class="difflineplus">+  // move them to the trash.</span>
<a href="#l38.699"></a><span id="l38.699" class="difflineplus">+  yield async_trash_messages(msgSet);</span>
<a href="#l38.700"></a><span id="l38.700" class="difflineplus">+</span>
<a href="#l38.701"></a><span id="l38.701" class="difflineplus">+  // we do not index the trash folder so this should actually make them appear</span>
<a href="#l38.702"></a><span id="l38.702" class="difflineplus">+  //  deleted to an unprivileged query.</span>
<a href="#l38.703"></a><span id="l38.703" class="difflineplus">+  let msgQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l38.704"></a><span id="l38.704" class="difflineplus">+  msgQuery.id(firstGlodaId, secondGlodaId);</span>
<a href="#l38.705"></a><span id="l38.705" class="difflineplus">+  queryExpect(msgQuery, []);</span>
<a href="#l38.706"></a><span id="l38.706" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.707"></a><span id="l38.707"> </span>
<a href="#l38.708"></a><span id="l38.708" class="difflineminus">-function verify_messageLocation(aMsgHdr, aMessage, aDestFolder) {</span>
<a href="#l38.709"></a><span id="l38.709" class="difflineminus">-  do_check_eq(aMessage.folderURI, aDestFolder.URI);</span>
<a href="#l38.710"></a><span id="l38.710" class="difflineplus">+  // they will appear deleted after the events</span>
<a href="#l38.711"></a><span id="l38.711" class="difflineplus">+  yield wait_for_gloda_indexer([], {deleted: msgSet});</span>
<a href="#l38.712"></a><span id="l38.712" class="difflineplus">+</span>
<a href="#l38.713"></a><span id="l38.713" class="difflineplus">+  // force a sweep</span>
<a href="#l38.714"></a><span id="l38.714" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.715"></a><span id="l38.715" class="difflineplus">+  // there should be no apparent change as the result of this pass</span>
<a href="#l38.716"></a><span id="l38.716" class="difflineplus">+  // (well, the conversation will die, but we can't see that.)</span>
<a href="#l38.717"></a><span id="l38.717" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l38.718"></a><span id="l38.718" class="difflineplus">+  </span>
<a href="#l38.719"></a><span id="l38.719" class="difflineplus">+  // the conversation should be gone</span>
<a href="#l38.720"></a><span id="l38.720" class="difflineplus">+  let convQuery = Gloda.newQuery(Gloda.NOUN_CONVERSATION);</span>
<a href="#l38.721"></a><span id="l38.721" class="difflineplus">+  convQuery.id(convId);</span>
<a href="#l38.722"></a><span id="l38.722" class="difflineplus">+  queryExpect(convQuery, []);</span>
<a href="#l38.723"></a><span id="l38.723" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.724"></a><span id="l38.724" class="difflineplus">+</span>
<a href="#l38.725"></a><span id="l38.725" class="difflineplus">+  // the messages should be entirely gone</span>
<a href="#l38.726"></a><span id="l38.726" class="difflineplus">+  let msgPrivQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l38.727"></a><span id="l38.727" class="difflineplus">+                                      noDbQueryValidityConstraints: true,</span>
<a href="#l38.728"></a><span id="l38.728" class="difflineplus">+                                    });</span>
<a href="#l38.729"></a><span id="l38.729" class="difflineplus">+  msgPrivQuery.id(firstGlodaId, secondGlodaId);</span>
<a href="#l38.730"></a><span id="l38.730" class="difflineplus">+  queryExpect(msgPrivQuery, []);</span>
<a href="#l38.731"></a><span id="l38.731" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.732"></a><span id="l38.732"> }</span>
<a href="#l38.733"></a><span id="l38.733"> </span>
<a href="#l38.734"></a><span id="l38.734" class="difflineminus">-/* ===== Message Moving ===== */</span>
<a href="#l38.735"></a><span id="l38.735" class="difflineminus">-const gCopyService = Cc[&quot;@mozilla.org/messenger/messagecopyservice;1&quot;]</span>
<a href="#l38.736"></a><span id="l38.736" class="difflineminus">-                      .getService(Ci.nsIMsgCopyService);</span>
<a href="#l38.737"></a><span id="l38.737" class="difflineplus">+/**</span>
<a href="#l38.738"></a><span id="l38.738" class="difflineplus">+ * Deletion that occurs because a folder got deleted.</span>
<a href="#l38.739"></a><span id="l38.739" class="difflineplus">+ *  There is no hand-holding involving the headers that were in the folder.</span>
<a href="#l38.740"></a><span id="l38.740" class="difflineplus">+ */</span>
<a href="#l38.741"></a><span id="l38.741" class="difflineplus">+function test_folder_nuking_message_deletion() {</span>
<a href="#l38.742"></a><span id="l38.742" class="difflineplus">+  // create and index two messages in a conversation</span>
<a href="#l38.743"></a><span id="l38.743" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 2, msgsPerThread: 2}]);</span>
<a href="#l38.744"></a><span id="l38.744" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.745"></a><span id="l38.745" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet], {augment: true});</span>
<a href="#l38.746"></a><span id="l38.746"> </span>
<a href="#l38.747"></a><span id="l38.747" class="difflineminus">-function test_message_moving() {</span>
<a href="#l38.748"></a><span id="l38.748" class="difflineminus">-  let rootFolder = gLocalIncomingServer.rootMsgFolder;</span>
<a href="#l38.749"></a><span id="l38.749" class="difflineminus">-  let destFolder = rootFolder.addSubfolder(&quot;move1&quot;);</span>
<a href="#l38.750"></a><span id="l38.750" class="difflineplus">+  let convId = msgSet.glodaMessages[0].conversation.id;</span>
<a href="#l38.751"></a><span id="l38.751" class="difflineplus">+  let firstGlodaId = msgSet.glodaMessages[0].id;</span>
<a href="#l38.752"></a><span id="l38.752" class="difflineplus">+  let secondGlodaId = msgSet.glodaMessages[1].id;</span>
<a href="#l38.753"></a><span id="l38.753" class="difflineplus">+</span>
<a href="#l38.754"></a><span id="l38.754" class="difflineplus">+  // Delete the folder</span>
<a href="#l38.755"></a><span id="l38.755" class="difflineplus">+  yield async_delete_folder(folder);</span>
<a href="#l38.756"></a><span id="l38.756" class="difflineplus">+  // That does generate the deletion events if the messages were in-memory,</span>
<a href="#l38.757"></a><span id="l38.757" class="difflineplus">+  //  which these are.</span>
<a href="#l38.758"></a><span id="l38.758" class="difflineplus">+  yield wait_for_gloda_indexer([], {deleted: msgSet});</span>
<a href="#l38.759"></a><span id="l38.759"> </span>
<a href="#l38.760"></a><span id="l38.760" class="difflineminus">-  let moveTestActions = [</span>
<a href="#l38.761"></a><span id="l38.761" class="difflineminus">-    [do_moveMessage, verify_messageLocation, destFolder],</span>
<a href="#l38.762"></a><span id="l38.762" class="difflineminus">-    [do_moveMessage, verify_messageLocation, gLocalInboxFolder],</span>
<a href="#l38.763"></a><span id="l38.763" class="difflineminus">-  ];</span>
<a href="#l38.764"></a><span id="l38.764" class="difflineplus">+  // this should have caused us to mark all the messages as deleted; the</span>
<a href="#l38.765"></a><span id="l38.765" class="difflineplus">+  //  messages should no longer show up in an unprivileged query</span>
<a href="#l38.766"></a><span id="l38.766" class="difflineplus">+  let msgQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l38.767"></a><span id="l38.767" class="difflineplus">+  msgQuery.id(firstGlodaId, secondGlodaId);</span>
<a href="#l38.768"></a><span id="l38.768" class="difflineplus">+  queryExpect(msgQuery, []);</span>
<a href="#l38.769"></a><span id="l38.769" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.770"></a><span id="l38.770" class="difflineplus">+  </span>
<a href="#l38.771"></a><span id="l38.771" class="difflineplus">+  // force a sweep</span>
<a href="#l38.772"></a><span id="l38.772" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.773"></a><span id="l38.773" class="difflineplus">+  // there should be no apparent change as the result of this pass</span>
<a href="#l38.774"></a><span id="l38.774" class="difflineplus">+  // (well, the conversation will die, but we can't see that.)</span>
<a href="#l38.775"></a><span id="l38.775" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l38.776"></a><span id="l38.776"> </span>
<a href="#l38.777"></a><span id="l38.777" class="difflineminus">-  let smsg = msgGen.makeMessage();</span>
<a href="#l38.778"></a><span id="l38.778" class="difflineminus">-  twiddleAndTest(smsg, moveTestActions);</span>
<a href="#l38.779"></a><span id="l38.779" class="difflineminus">-}</span>
<a href="#l38.780"></a><span id="l38.780" class="difflineplus">+  // the conversation should be gone</span>
<a href="#l38.781"></a><span id="l38.781" class="difflineplus">+  let convQuery = Gloda.newQuery(Gloda.NOUN_CONVERSATION);</span>
<a href="#l38.782"></a><span id="l38.782" class="difflineplus">+  convQuery.id(convId);</span>
<a href="#l38.783"></a><span id="l38.783" class="difflineplus">+  queryExpect(convQuery, []);</span>
<a href="#l38.784"></a><span id="l38.784" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.785"></a><span id="l38.785"> </span>
<a href="#l38.786"></a><span id="l38.786" class="difflineminus">-/* ===== Message Deletion ===== */</span>
<a href="#l38.787"></a><span id="l38.787" class="difflineminus">-function test_message_deletion() {</span>
<a href="#l38.788"></a><span id="l38.788" class="difflineplus">+  // the messages should be entirely gone</span>
<a href="#l38.789"></a><span id="l38.789" class="difflineplus">+  let msgPrivQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE, {</span>
<a href="#l38.790"></a><span id="l38.790" class="difflineplus">+                                      noDbQueryValidityConstraints: true,</span>
<a href="#l38.791"></a><span id="l38.791" class="difflineplus">+                                    });</span>
<a href="#l38.792"></a><span id="l38.792" class="difflineplus">+  msgPrivQuery.id(firstGlodaId, secondGlodaId);</span>
<a href="#l38.793"></a><span id="l38.793" class="difflineplus">+  queryExpect(msgPrivQuery, []);</span>
<a href="#l38.794"></a><span id="l38.794" class="difflineplus">+  yield false; // queryExpect is async</span>
<a href="#l38.795"></a><span id="l38.795"> }</span>
<a href="#l38.796"></a><span id="l38.796"> </span>
<a href="#l38.797"></a><span id="l38.797"> /* ===== Folder Move/Rename/Copy (Single and Nested) ===== */</span>
<a href="#l38.798"></a><span id="l38.798"> </span>
<a href="#l38.799"></a><span id="l38.799" class="difflineplus">+function test_folder_deletion_single() {</span>
<a href="#l38.800"></a><span id="l38.800" class="difflineplus">+</span>
<a href="#l38.801"></a><span id="l38.801" class="difflineplus">+}</span>
<a href="#l38.802"></a><span id="l38.802" class="difflineplus">+</span>
<a href="#l38.803"></a><span id="l38.803" class="difflineplus">+function test_folder_deletion_nested() {</span>
<a href="#l38.804"></a><span id="l38.804" class="difflineplus">+</span>
<a href="#l38.805"></a><span id="l38.805" class="difflineplus">+}</span>
<a href="#l38.806"></a><span id="l38.806" class="difflineplus">+</span>
<a href="#l38.807"></a><span id="l38.807" class="difflineplus">+</span>
<a href="#l38.808"></a><span id="l38.808" class="difflineplus">+</span>
<a href="#l38.809"></a><span id="l38.809" class="difflineplus">+/* ===== Message Moving ===== */</span>
<a href="#l38.810"></a><span id="l38.810" class="difflineplus">+</span>
<a href="#l38.811"></a><span id="l38.811" class="difflineplus">+/**</span>
<a href="#l38.812"></a><span id="l38.812" class="difflineplus">+ * Moving a message between folders should result in us knowing that the message</span>
<a href="#l38.813"></a><span id="l38.813" class="difflineplus">+ *  is in the target location.  In the case of local moves, this happens</span>
<a href="#l38.814"></a><span id="l38.814" class="difflineplus">+ *  automatically.  In the case of IMAP moves, we need to force the target folder</span>
<a href="#l38.815"></a><span id="l38.815" class="difflineplus">+ *  to be updated.</span>
<a href="#l38.816"></a><span id="l38.816" class="difflineplus">+ *</span>
<a href="#l38.817"></a><span id="l38.817" class="difflineplus">+ * @todo Implication of UIDPLUS on IMAP are not understood / tested.</span>
<a href="#l38.818"></a><span id="l38.818" class="difflineplus">+ */</span>
<a href="#l38.819"></a><span id="l38.819" class="difflineplus">+function test_message_moving() {</span>
<a href="#l38.820"></a><span id="l38.820" class="difflineplus">+  // - inject and insert</span>
<a href="#l38.821"></a><span id="l38.821" class="difflineplus">+  // source folder with the message we care about</span>
<a href="#l38.822"></a><span id="l38.822" class="difflineplus">+  let [srcFolder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l38.823"></a><span id="l38.823" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.824"></a><span id="l38.824" class="difflineplus">+  // dest folder with some messages in it to test some wacky local folder moving</span>
<a href="#l38.825"></a><span id="l38.825" class="difflineplus">+  //  logic.  (Local moves try and update the correspondence immediately.)</span>
<a href="#l38.826"></a><span id="l38.826" class="difflineplus">+  let [destFolder, ignoreSet] = make_folder_with_sets([{count: 2}]);</span>
<a href="#l38.827"></a><span id="l38.827" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.828"></a><span id="l38.828" class="difflineplus">+</span>
<a href="#l38.829"></a><span id="l38.829" class="difflineplus">+</span>
<a href="#l38.830"></a><span id="l38.830" class="difflineplus">+  // (we want the gloda message mapping...)</span>
<a href="#l38.831"></a><span id="l38.831" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet, ignoreSet], {augment: true});</span>
<a href="#l38.832"></a><span id="l38.832" class="difflineplus">+  let gmsg = msgSet.glodaMessages[0];</span>
<a href="#l38.833"></a><span id="l38.833" class="difflineplus">+</span>
<a href="#l38.834"></a><span id="l38.834" class="difflineplus">+  // - move it to a new folder</span>
<a href="#l38.835"></a><span id="l38.835" class="difflineplus">+  mark_sub_test_start(&quot;initial move&quot;);</span>
<a href="#l38.836"></a><span id="l38.836" class="difflineplus">+  yield async_move_messages(msgSet, destFolder);</span>
<a href="#l38.837"></a><span id="l38.837" class="difflineplus">+</span>
<a href="#l38.838"></a><span id="l38.838" class="difflineplus">+  // - make sure gloda sees it in the new folder</span>
<a href="#l38.839"></a><span id="l38.839" class="difflineplus">+  // (In the local case, tThe move generates an itemsModified notification, so</span>
<a href="#l38.840"></a><span id="l38.840" class="difflineplus">+  //  we see it as indexing traffic even if the indexer never goes active.)</span>
<a href="#l38.841"></a><span id="l38.841" class="difflineplus">+  // (In the IMAP case, the message actually gets reindexed in the target</span>
<a href="#l38.842"></a><span id="l38.842" class="difflineplus">+  //  folder.)</span>
<a href="#l38.843"></a><span id="l38.843" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.844"></a><span id="l38.844" class="difflineplus">+</span>
<a href="#l38.845"></a><span id="l38.845" class="difflineplus">+  do_check_eq(gmsg.folderURI,</span>
<a href="#l38.846"></a><span id="l38.846" class="difflineplus">+              get_real_injection_folder(destFolder).URI);</span>
<a href="#l38.847"></a><span id="l38.847" class="difflineplus">+</span>
<a href="#l38.848"></a><span id="l38.848" class="difflineplus">+  // - move it back to its origin folder</span>
<a href="#l38.849"></a><span id="l38.849" class="difflineplus">+  mark_sub_test_start(&quot;move it back&quot;);</span>
<a href="#l38.850"></a><span id="l38.850" class="difflineplus">+  yield async_move_messages(msgSet, srcFolder);</span>
<a href="#l38.851"></a><span id="l38.851" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l38.852"></a><span id="l38.852" class="difflineplus">+  do_check_eq(gmsg.folderURI,</span>
<a href="#l38.853"></a><span id="l38.853" class="difflineplus">+              get_real_injection_folder(srcFolder).URI);</span>
<a href="#l38.854"></a><span id="l38.854" class="difflineplus">+}</span>
<a href="#l38.855"></a><span id="l38.855" class="difflineplus">+</span>
<a href="#l38.856"></a><span id="l38.856" class="difflineplus">+/**</span>
<a href="#l38.857"></a><span id="l38.857" class="difflineplus">+ * Moving a gloda-indexed message out of a filthy folder should result in the</span>
<a href="#l38.858"></a><span id="l38.858" class="difflineplus">+ *  destination message not having a gloda-id.</span>
<a href="#l38.859"></a><span id="l38.859" class="difflineplus">+ */</span>
<a href="#l38.860"></a><span id="l38.860" class="difflineplus">+</span>
<a href="#l38.861"></a><span id="l38.861" class="difflineplus">+/* ===== Message Copying ===== */</span>
<a href="#l38.862"></a><span id="l38.862" class="difflineplus">+</span>
<a href="#l38.863"></a><span id="l38.863" class="difflineplus">+</span>
<a href="#l38.864"></a><span id="l38.864" class="difflineplus">+/* ===== Sweep Complications ==== */</span>
<a href="#l38.865"></a><span id="l38.865" class="difflineplus">+</span>
<a href="#l38.866"></a><span id="l38.866" class="difflineplus">+/**</span>
<a href="#l38.867"></a><span id="l38.867" class="difflineplus">+ * Make sure that a message indexed by event-driven indexing does not</span>
<a href="#l38.868"></a><span id="l38.868" class="difflineplus">+ *  get reindexed by sweep indexing that follows.</span>
<a href="#l38.869"></a><span id="l38.869" class="difflineplus">+ */</span>
<a href="#l38.870"></a><span id="l38.870" class="difflineplus">+function test_sweep_indexing_does_not_reindex_event_indexed() {</span>
<a href="#l38.871"></a><span id="l38.871" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l38.872"></a><span id="l38.872" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.873"></a><span id="l38.873" class="difflineplus">+</span>
<a href="#l38.874"></a><span id="l38.874" class="difflineplus">+  // wait for the event sweep to complete</span>
<a href="#l38.875"></a><span id="l38.875" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet]);</span>
<a href="#l38.876"></a><span id="l38.876" class="difflineplus">+</span>
<a href="#l38.877"></a><span id="l38.877" class="difflineplus">+  // force a sweep of the folder</span>
<a href="#l38.878"></a><span id="l38.878" class="difflineplus">+  GlodaMsgIndexer.indexFolder(get_real_injection_folder(folder));</span>
<a href="#l38.879"></a><span id="l38.879" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l38.880"></a><span id="l38.880" class="difflineplus">+}</span>
<a href="#l38.881"></a><span id="l38.881" class="difflineplus">+</span>
<a href="#l38.882"></a><span id="l38.882" class="difflineplus">+/**</span>
<a href="#l38.883"></a><span id="l38.883" class="difflineplus">+ * Verify that moving apparently gloda-indexed messages from a filthy folder or</span>
<a href="#l38.884"></a><span id="l38.884" class="difflineplus">+ *  one that simply should not be gloda indexed does not result in the target</span>
<a href="#l38.885"></a><span id="l38.885" class="difflineplus">+ *  messages having the gloda-id property on them.  To avoid messing with too</span>
<a href="#l38.886"></a><span id="l38.886" class="difflineplus">+ *  many invariants we do the 'folder should not be gloda indexed' case.</span>
<a href="#l38.887"></a><span id="l38.887" class="difflineplus">+ * Uh, and of course, the message should still get indexed once we clear the</span>
<a href="#l38.888"></a><span id="l38.888" class="difflineplus">+ *  filthy gloda-id off of it given that it is moving from a folder that is not</span>
<a href="#l38.889"></a><span id="l38.889" class="difflineplus">+ *  indexed to one that is indexed.</span>
<a href="#l38.890"></a><span id="l38.890" class="difflineplus">+ */</span>
<a href="#l38.891"></a><span id="l38.891" class="difflineplus">+function test_filthy_moves_slash_move_from_unindexed_to_indexed() {</span>
<a href="#l38.892"></a><span id="l38.892" class="difflineplus">+  // - inject</span>
<a href="#l38.893"></a><span id="l38.893" class="difflineplus">+  // the source folder needs a flag so we don't index it</span>
<a href="#l38.894"></a><span id="l38.894" class="difflineplus">+  let srcFolder = make_empty_folder(null, [Ci.nsMsgFolderFlags.Junk]);</span>
<a href="#l38.895"></a><span id="l38.895" class="difflineplus">+  // the destination folder has to be something we want to index though;</span>
<a href="#l38.896"></a><span id="l38.896" class="difflineplus">+  let destFolder = make_empty_folder();</span>
<a href="#l38.897"></a><span id="l38.897" class="difflineplus">+  let [msgSet] = make_new_sets_in_folder(srcFolder, [{count: 1}]);</span>
<a href="#l38.898"></a><span id="l38.898" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l38.899"></a><span id="l38.899" class="difflineplus">+</span>
<a href="#l38.900"></a><span id="l38.900" class="difflineplus">+  // - mark with a bogus gloda-id</span>
<a href="#l38.901"></a><span id="l38.901" class="difflineplus">+  msgSet.getMsgHdr(0).setUint32Property(&quot;gloda-id&quot;, 9999);</span>
<a href="#l38.902"></a><span id="l38.902" class="difflineplus">+</span>
<a href="#l38.903"></a><span id="l38.903" class="difflineplus">+  // - disable event driven indexing so we don't get interference from indexing</span>
<a href="#l38.904"></a><span id="l38.904" class="difflineplus">+  configure_gloda_indexing({event: false});</span>
<a href="#l38.905"></a><span id="l38.905" class="difflineplus">+</span>
<a href="#l38.906"></a><span id="l38.906" class="difflineplus">+  // - move</span>
<a href="#l38.907"></a><span id="l38.907" class="difflineplus">+  yield async_move_messages(msgSet, destFolder);</span>
<a href="#l38.908"></a><span id="l38.908" class="difflineplus">+</span>
<a href="#l38.909"></a><span id="l38.909" class="difflineplus">+  // - verify the target has no gloda-id!</span>
<a href="#l38.910"></a><span id="l38.910" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;checking&quot;, [msgSet.getMsgHdr(0)]);</span>
<a href="#l38.911"></a><span id="l38.911" class="difflineplus">+  do_check_eq(msgSet.getMsgHdr(0).getUint32Property(&quot;gloda-id&quot;), 0);</span>
<a href="#l38.912"></a><span id="l38.912" class="difflineplus">+</span>
<a href="#l38.913"></a><span id="l38.913" class="difflineplus">+  // - re-enable indexing and let the indexer run</span>
<a href="#l38.914"></a><span id="l38.914" class="difflineplus">+  // (we don't want to affect other tests)</span>
<a href="#l38.915"></a><span id="l38.915" class="difflineplus">+  configure_gloda_indexing({});</span>
<a href="#l38.916"></a><span id="l38.916" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet]);</span>
<a href="#l38.917"></a><span id="l38.917" class="difflineplus">+}</span>
<a href="#l38.918"></a><span id="l38.918"> </span>
<a href="#l38.919"></a><span id="l38.919"> var tests = [</span>
<a href="#l38.920"></a><span id="l38.920" class="difflineminus">-  function pre_test_threading() { pre_test_threading_hook(); },</span>
<a href="#l38.921"></a><span id="l38.921" class="difflineplus">+  test_pending_commit_tracker_flushes_correctly,</span>
<a href="#l38.922"></a><span id="l38.922" class="difflineplus">+  test_indexing_sweep,</span>
<a href="#l38.923"></a><span id="l38.923" class="difflineplus">+</span>
<a href="#l38.924"></a><span id="l38.924">   test_threading,</span>
<a href="#l38.925"></a><span id="l38.925" class="difflineminus">-  function post_test_threading() { post_test_threading_hook(); },</span>
<a href="#l38.926"></a><span id="l38.926">   test_attributes_fundamental,</span>
<a href="#l38.927"></a><span id="l38.927">   test_attributes_fundamental_from_disk,</span>
<a href="#l38.928"></a><span id="l38.928">   test_attributes_explicit,</span>
<a href="#l38.929"></a><span id="l38.929" class="difflineminus">-];</span>
<a href="#l38.930"></a><span id="l38.930" class="difflineplus">+</span>
<a href="#l38.931"></a><span id="l38.931" class="difflineplus">+  test_message_moving,</span>
<a href="#l38.932"></a><span id="l38.932"> </span>
<a href="#l38.933"></a><span id="l38.933" class="difflineminus">-function run_test() {</span>
<a href="#l38.934"></a><span id="l38.934" class="difflineminus">-  glodaHelperRunTests(tests);</span>
<a href="#l38.935"></a><span id="l38.935" class="difflineminus">-}</span>
<a href="#l38.936"></a><span id="l38.936" class="difflineplus">+  test_message_deletion,</span>
<a href="#l38.937"></a><span id="l38.937" class="difflineplus">+  test_moving_to_trash_marks_deletion,</span>
<a href="#l38.938"></a><span id="l38.938" class="difflineplus">+  test_folder_nuking_message_deletion,</span>
<a href="#l38.939"></a><span id="l38.939" class="difflineplus">+</span>
<a href="#l38.940"></a><span id="l38.940" class="difflineplus">+  test_sweep_indexing_does_not_reindex_event_indexed,</span>
<a href="#l38.941"></a><span id="l38.941" class="difflineplus">+</span>
<a href="#l38.942"></a><span id="l38.942" class="difflineplus">+  test_filthy_moves_slash_move_from_unindexed_to_indexed,</span>
<a href="#l38.943"></a><span id="l38.943" class="difflineplus">+];</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1">rename from mailnews/db/gloda/test/unit/test_query_messages.js</span>
<a href="#l39.2"></a><span id="l39.2">rename to mailnews/db/gloda/test/unit/base_query_messages.js</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_messages.js</span>
<a href="#l39.4"></a><span id="l39.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_query_messages.js</span>
<a href="#l39.5"></a><span id="l39.5" class="difflineat">@@ -1,8 +1,45 @@</span>
<a href="#l39.6"></a><span id="l39.6" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l39.7"></a><span id="l39.7" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l39.8"></a><span id="l39.8" class="difflineplus">+ *</span>
<a href="#l39.9"></a><span id="l39.9" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l39.10"></a><span id="l39.10" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l39.11"></a><span id="l39.11" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+ *</span>
<a href="#l39.14"></a><span id="l39.14" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l39.15"></a><span id="l39.15" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l39.16"></a><span id="l39.16" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l39.17"></a><span id="l39.17" class="difflineplus">+ * License.</span>
<a href="#l39.18"></a><span id="l39.18" class="difflineplus">+ *</span>
<a href="#l39.19"></a><span id="l39.19" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l39.20"></a><span id="l39.20" class="difflineplus">+ *</span>
<a href="#l39.21"></a><span id="l39.21" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l39.22"></a><span id="l39.22" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l39.23"></a><span id="l39.23" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l39.24"></a><span id="l39.24" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l39.25"></a><span id="l39.25" class="difflineplus">+ *</span>
<a href="#l39.26"></a><span id="l39.26" class="difflineplus">+ * Contributor(s):</span>
<a href="#l39.27"></a><span id="l39.27" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l39.28"></a><span id="l39.28" class="difflineplus">+ *</span>
<a href="#l39.29"></a><span id="l39.29" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l39.30"></a><span id="l39.30" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l39.31"></a><span id="l39.31" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l39.32"></a><span id="l39.32" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l39.33"></a><span id="l39.33" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l39.34"></a><span id="l39.34" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l39.35"></a><span id="l39.35" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l39.36"></a><span id="l39.36" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l39.37"></a><span id="l39.37" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l39.38"></a><span id="l39.38" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l39.39"></a><span id="l39.39" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l39.40"></a><span id="l39.40" class="difflineplus">+ *</span>
<a href="#l39.41"></a><span id="l39.41" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l39.42"></a><span id="l39.42" class="difflineplus">+</span>
<a href="#l39.43"></a><span id="l39.43"> /*</span>
<a href="#l39.44"></a><span id="l39.44">  * This file tests our querying support.  We build up a deterministic little</span>
<a href="#l39.45"></a><span id="l39.45">  *  'world' of messages spread across multiple conversations, multiple folders</span>
<a href="#l39.46"></a><span id="l39.46">  *  and multiple authors.  To verify expected negative results, in addition to</span>
<a href="#l39.47"></a><span id="l39.47">  *  the 'peoples' in our world clique, we also have 'outlier' contacts that do</span>
<a href="#l39.48"></a><span id="l39.48">  *  not communicate with the others (but are also spread across folders).</span>
<a href="#l39.49"></a><span id="l39.49">  *</span>
<a href="#l39.50"></a><span id="l39.50">  * This is broadly intended to test all of our query features and mechanisms</span>
<a href="#l39.51"></a><span id="l39.51" class="difflineat">@@ -10,30 +47,30 @@</span>
<a href="#l39.52"></a><span id="l39.52">  *  test_search_messages.js), but is probably not the place to test specific</span>
<a href="#l39.53"></a><span id="l39.53">  *  edge-cases if they do not easily fit into the 'world' data set.</span>
<a href="#l39.54"></a><span id="l39.54">  *</span>
<a href="#l39.55"></a><span id="l39.55">  * I feel like having the 'world' mishmash as a data source may muddle things</span>
<a href="#l39.56"></a><span id="l39.56">  *  more than it should, but it is hard to deny the benefit of not having to</span>
<a href="#l39.57"></a><span id="l39.57">  *  define a bunch of message corpuses entirely specialized for each test.</span>
<a href="#l39.58"></a><span id="l39.58">  */</span>
<a href="#l39.59"></a><span id="l39.59"> </span>
<a href="#l39.60"></a><span id="l39.60" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l39.61"></a><span id="l39.61"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l39.62"></a><span id="l39.62"> </span>
<a href="#l39.63"></a><span id="l39.63" class="difflineminus">-// Create a message generator</span>
<a href="#l39.64"></a><span id="l39.64" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l39.65"></a><span id="l39.65" class="difflineminus">-// Create a message scenario generator using that message generator</span>
<a href="#l39.66"></a><span id="l39.66" class="difflineminus">-var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l39.67"></a><span id="l39.67" class="difflineminus">-// Whether we're using a single folder to test. We need to skip a few tests if</span>
<a href="#l39.68"></a><span id="l39.68" class="difflineminus">-// we're doing so</span>
<a href="#l39.69"></a><span id="l39.69" class="difflineminus">-var singleFolder = false;</span>
<a href="#l39.70"></a><span id="l39.70" class="difflineminus">-// Whether we expect fulltext results. IMAP folders that are offline shouldn't</span>
<a href="#l39.71"></a><span id="l39.71" class="difflineminus">-// have their bodies indexed.</span>
<a href="#l39.72"></a><span id="l39.72" class="difflineplus">+/**</span>
<a href="#l39.73"></a><span id="l39.73" class="difflineplus">+ * Whether we expect fulltext results. IMAP folders that are offline shouldn't</span>
<a href="#l39.74"></a><span id="l39.74" class="difflineplus">+ * have their bodies indexed.</span>
<a href="#l39.75"></a><span id="l39.75" class="difflineplus">+ */</span>
<a href="#l39.76"></a><span id="l39.76"> var expectFulltextResults = true;</span>
<a href="#l39.77"></a><span id="l39.77"> </span>
<a href="#l39.78"></a><span id="l39.78" class="difflineplus">+/**</span>
<a href="#l39.79"></a><span id="l39.79" class="difflineplus">+ * Should we force our folders offline after we have indexed them once.  We do</span>
<a href="#l39.80"></a><span id="l39.80" class="difflineplus">+ * this in the online_to_offline test variant.</span>
<a href="#l39.81"></a><span id="l39.81" class="difflineplus">+ */</span>
<a href="#l39.82"></a><span id="l39.82" class="difflineplus">+var goOffline = false;</span>
<a href="#l39.83"></a><span id="l39.83" class="difflineplus">+</span>
<a href="#l39.84"></a><span id="l39.84"> /* ===== Populate ===== */</span>
<a href="#l39.85"></a><span id="l39.85"> var world = {</span>
<a href="#l39.86"></a><span id="l39.86">   phase: 0,</span>
<a href="#l39.87"></a><span id="l39.87"> </span>
<a href="#l39.88"></a><span id="l39.88">   // a list of tuples of [name, email] of length NUM_AUTHORS</span>
<a href="#l39.89"></a><span id="l39.89">   peoples: null,</span>
<a href="#l39.90"></a><span id="l39.90">   NUM_AUTHORS: 5,</span>
<a href="#l39.91"></a><span id="l39.91">   // maps each author (as defined by their email address) to the list of</span>
<a href="#l39.92"></a><span id="l39.92" class="difflineat">@@ -186,17 +223,17 @@ function generateFolderMessages() {</span>
<a href="#l39.93"></a><span id="l39.93">   smsg.from = world.outlierAuthor;</span>
<a href="#l39.94"></a><span id="l39.94">   smsg.to = [world.outlierFriend];</span>
<a href="#l39.95"></a><span id="l39.95">   // do not lump it</span>
<a href="#l39.96"></a><span id="l39.96">   messages.push(smsg);</span>
<a href="#l39.97"></a><span id="l39.97">   world.outlierMessages.push(smsg);</span>
<a href="#l39.98"></a><span id="l39.98"> </span>
<a href="#l39.99"></a><span id="l39.99">   world.folderClumps.push(messages);</span>
<a href="#l39.100"></a><span id="l39.100"> </span>
<a href="#l39.101"></a><span id="l39.101" class="difflineminus">-  return messages;</span>
<a href="#l39.102"></a><span id="l39.102" class="difflineplus">+  return new SyntheticMessageSet(messages);</span>
<a href="#l39.103"></a><span id="l39.103"> }</span>
<a href="#l39.104"></a><span id="l39.104"> </span>
<a href="#l39.105"></a><span id="l39.105"> /**</span>
<a href="#l39.106"></a><span id="l39.106">  * To save ourselves some lookup trouble, pretend to be a verification</span>
<a href="#l39.107"></a><span id="l39.107">  *  function so we get easy access to the gloda translations of the messages so</span>
<a href="#l39.108"></a><span id="l39.108">  *  we can cram this in various places.</span>
<a href="#l39.109"></a><span id="l39.109">  */</span>
<a href="#l39.110"></a><span id="l39.110"> function glodaInfoStasher(aSynthMessage, aGlodaMessage) {</span>
<a href="#l39.111"></a><span id="l39.111" class="difflineat">@@ -204,54 +241,57 @@ function glodaInfoStasher(aSynthMessage,</span>
<a href="#l39.112"></a><span id="l39.112">     world.glodaConversationIds[aSynthMessage.iConvo] =</span>
<a href="#l39.113"></a><span id="l39.113">       aGlodaMessage.conversation.id;</span>
<a href="#l39.114"></a><span id="l39.114">   if (world.glodaFolders.length &lt;= world.phase)</span>
<a href="#l39.115"></a><span id="l39.115">     world.glodaFolders.push(aGlodaMessage.folder);</span>
<a href="#l39.116"></a><span id="l39.116"> }</span>
<a href="#l39.117"></a><span id="l39.117"> </span>
<a href="#l39.118"></a><span id="l39.118"> // We override these for the IMAP tests</span>
<a href="#l39.119"></a><span id="l39.119"> var pre_setup_populate_hook = function default_pre_setup_populate_hook() {</span>
<a href="#l39.120"></a><span id="l39.120" class="difflineminus">-  next_test();</span>
<a href="#l39.121"></a><span id="l39.121"> };</span>
<a href="#l39.122"></a><span id="l39.122"> var post_setup_populate_hook = function default_post_setup_populate_hook() {</span>
<a href="#l39.123"></a><span id="l39.123" class="difflineminus">-  next_test();</span>
<a href="#l39.124"></a><span id="l39.124"> };</span>
<a href="#l39.125"></a><span id="l39.125"> </span>
<a href="#l39.126"></a><span id="l39.126" class="difflineminus">-var gSynMessages = [];</span>
<a href="#l39.127"></a><span id="l39.127"> // first, we must populate our message store with delicious messages.</span>
<a href="#l39.128"></a><span id="l39.128"> function setup_populate() {</span>
<a href="#l39.129"></a><span id="l39.129">   world.glodaHolderCollection = Gloda.explicitCollection(Gloda.NOUN_MESSAGE,</span>
<a href="#l39.130"></a><span id="l39.130">     []);</span>
<a href="#l39.131"></a><span id="l39.131"> </span>
<a href="#l39.132"></a><span id="l39.132">   world.peoples = msgGen.makeNamesAndAddresses(world.NUM_AUTHORS);</span>
<a href="#l39.133"></a><span id="l39.133">   world.outlierAuthor = msgGen.makeNameAndAddress();</span>
<a href="#l39.134"></a><span id="l39.134">   world.outlierFriend = msgGen.makeNameAndAddress();</span>
<a href="#l39.135"></a><span id="l39.135">   // set up the per-conversation values with blanks initially</span>
<a href="#l39.136"></a><span id="l39.136">   for (let iConvo = 0; iConvo &lt; world.NUM_CONVERSATIONS; iConvo++) {</span>
<a href="#l39.137"></a><span id="l39.137">     world.lastMessagesInConvos.push(null);</span>
<a href="#l39.138"></a><span id="l39.138">     world.conversationLists.push([]);</span>
<a href="#l39.139"></a><span id="l39.139">     world.glodaConversationIds.push(null);</span>
<a href="#l39.140"></a><span id="l39.140">   }</span>
<a href="#l39.141"></a><span id="l39.141"> </span>
<a href="#l39.142"></a><span id="l39.142" class="difflineminus">-  let messages = generateFolderMessages();</span>
<a href="#l39.143"></a><span id="l39.143" class="difflineminus">-  gSynMessages = gSynMessages.concat(messages);</span>
<a href="#l39.144"></a><span id="l39.144" class="difflineminus">-  indexMessages(messages, glodaInfoStasher, setup_populate_phase_two);</span>
<a href="#l39.145"></a><span id="l39.145" class="difflineminus">-}</span>
<a href="#l39.146"></a><span id="l39.146" class="difflineplus">+  let setOne = generateFolderMessages();</span>
<a href="#l39.147"></a><span id="l39.147" class="difflineplus">+  let folderOne = make_empty_folder();</span>
<a href="#l39.148"></a><span id="l39.148" class="difflineplus">+  yield add_sets_to_folders(folderOne, [setOne]);</span>
<a href="#l39.149"></a><span id="l39.149" class="difflineplus">+  // If this is the online_to_offline variant (indicated by goOffline) we want</span>
<a href="#l39.150"></a><span id="l39.150" class="difflineplus">+  //  to make the messages available offline.  This should trigger an event</span>
<a href="#l39.151"></a><span id="l39.151" class="difflineplus">+  //  driven re-indexing of the messages which should make the body available</span>
<a href="#l39.152"></a><span id="l39.152" class="difflineplus">+  //  for fulltext queries.</span>
<a href="#l39.153"></a><span id="l39.153" class="difflineplus">+  if (goOffline) {</span>
<a href="#l39.154"></a><span id="l39.154" class="difflineplus">+    yield wait_for_gloda_indexer(setOne);</span>
<a href="#l39.155"></a><span id="l39.155" class="difflineplus">+    yield make_folder_and_contents_offline(folderOne);</span>
<a href="#l39.156"></a><span id="l39.156" class="difflineplus">+  }</span>
<a href="#l39.157"></a><span id="l39.157" class="difflineplus">+  yield wait_for_gloda_indexer(setOne, {verifier: glodaInfoStasher});</span>
<a href="#l39.158"></a><span id="l39.158"> </span>
<a href="#l39.159"></a><span id="l39.159" class="difflineminus">-function setup_populate_phase_two() {</span>
<a href="#l39.160"></a><span id="l39.160" class="difflineminus">-  // If we have one folder, we don't attempt to populate the other one</span>
<a href="#l39.161"></a><span id="l39.161" class="difflineminus">-  if (singleFolder) {</span>
<a href="#l39.162"></a><span id="l39.162" class="difflineminus">-    next_test();</span>
<a href="#l39.163"></a><span id="l39.163" class="difflineplus">+  world.phase++;</span>
<a href="#l39.164"></a><span id="l39.164" class="difflineplus">+  let setTwo  = generateFolderMessages();</span>
<a href="#l39.165"></a><span id="l39.165" class="difflineplus">+  let folderTwo = make_empty_folder();</span>
<a href="#l39.166"></a><span id="l39.166" class="difflineplus">+  yield add_sets_to_folders(folderTwo, [setTwo]);</span>
<a href="#l39.167"></a><span id="l39.167" class="difflineplus">+  if (goOffline) {</span>
<a href="#l39.168"></a><span id="l39.168" class="difflineplus">+    yield wait_for_gloda_indexer(setTwo);</span>
<a href="#l39.169"></a><span id="l39.169" class="difflineplus">+    yield make_folder_and_contents_offline(folderTwo);</span>
<a href="#l39.170"></a><span id="l39.170">   }</span>
<a href="#l39.171"></a><span id="l39.171" class="difflineminus">-  else {</span>
<a href="#l39.172"></a><span id="l39.172" class="difflineminus">-    world.phase++;</span>
<a href="#l39.173"></a><span id="l39.173" class="difflineminus">-    let messages = generateFolderMessages();</span>
<a href="#l39.174"></a><span id="l39.174" class="difflineminus">-    gSynMessages = gSynMessages.concat(messages);</span>
<a href="#l39.175"></a><span id="l39.175" class="difflineminus">-    indexMessages(messages, glodaInfoStasher, next_test);</span>
<a href="#l39.176"></a><span id="l39.176" class="difflineminus">-  }</span>
<a href="#l39.177"></a><span id="l39.177" class="difflineplus">+  yield wait_for_gloda_indexer(setTwo, {verifier: glodaInfoStasher});</span>
<a href="#l39.178"></a><span id="l39.178"> }</span>
<a href="#l39.179"></a><span id="l39.179"> </span>
<a href="#l39.180"></a><span id="l39.180"> /* ===== Non-text queries ===== */</span>
<a href="#l39.181"></a><span id="l39.181"> </span>
<a href="#l39.182"></a><span id="l39.182"> /* === messages === */</span>
<a href="#l39.183"></a><span id="l39.183"> </span>
<a href="#l39.184"></a><span id="l39.184"> /**</span>
<a href="#l39.185"></a><span id="l39.185">  * Takes a list of mutually exclusive queries and a list of the resulting</span>
<a href="#l39.186"></a><span id="l39.186" class="difflineat">@@ -263,18 +303,18 @@ function setup_populate_phase_two() {</span>
<a href="#l39.187"></a><span id="l39.187"> function verify_nonMatches(aQueries, aCollections) {</span>
<a href="#l39.188"></a><span id="l39.188">   for (let i = 0; i &lt; aCollections.length; i++) {</span>
<a href="#l39.189"></a><span id="l39.189">     let testQuery = aQueries[i];</span>
<a href="#l39.190"></a><span id="l39.190">     let nonmatches =</span>
<a href="#l39.191"></a><span id="l39.191">       aCollections[(i+1) % aCollections.length].items;</span>
<a href="#l39.192"></a><span id="l39.192"> </span>
<a href="#l39.193"></a><span id="l39.193">     for each (let [, item] in Iterator(nonmatches)) {</span>
<a href="#l39.194"></a><span id="l39.194">       if (testQuery.test(item)) {</span>
<a href="#l39.195"></a><span id="l39.195" class="difflineminus">-        ddumpObject(item, &quot;item&quot;, 0);</span>
<a href="#l39.196"></a><span id="l39.196" class="difflineminus">-        ddumpObject(testQuery._constraints, &quot;constraints&quot;, 2);</span>
<a href="#l39.197"></a><span id="l39.197" class="difflineplus">+        logObject(item, &quot;item&quot;);</span>
<a href="#l39.198"></a><span id="l39.198" class="difflineplus">+        logObject(testQuery._constraints, &quot;constraints&quot;);</span>
<a href="#l39.199"></a><span id="l39.199">         do_throw(&quot;Something should not match query.test(), but it does: &quot; +</span>
<a href="#l39.200"></a><span id="l39.200">                  item);</span>
<a href="#l39.201"></a><span id="l39.201">       }</span>
<a href="#l39.202"></a><span id="l39.202">     }</span>
<a href="#l39.203"></a><span id="l39.203">   }</span>
<a href="#l39.204"></a><span id="l39.204"> }</span>
<a href="#l39.205"></a><span id="l39.205"> </span>
<a href="#l39.206"></a><span id="l39.206"> var ts_convNum = 0;</span>
<a href="#l39.207"></a><span id="l39.207" class="difflineat">@@ -294,173 +334,159 @@ var ts_convCollections = [];</span>
<a href="#l39.208"></a><span id="l39.208">  */</span>
<a href="#l39.209"></a><span id="l39.209"> function test_query_messages_by_conversation() {</span>
<a href="#l39.210"></a><span id="l39.210">   let convNum = ts_convNum++;</span>
<a href="#l39.211"></a><span id="l39.211">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.212"></a><span id="l39.212">   query.conversation(world.glodaConversationIds[convNum]);</span>
<a href="#l39.213"></a><span id="l39.213"> </span>
<a href="#l39.214"></a><span id="l39.214">   ts_convQueries.push(query);</span>
<a href="#l39.215"></a><span id="l39.215">   ts_convCollections.push(queryExpect(query, world.conversationLists[convNum]));</span>
<a href="#l39.216"></a><span id="l39.216" class="difflineminus">-  // queryExpect calls next_test</span>
<a href="#l39.217"></a><span id="l39.217" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.218"></a><span id="l39.218"> }</span>
<a href="#l39.219"></a><span id="l39.219"> </span>
<a href="#l39.220"></a><span id="l39.220"> /**</span>
<a href="#l39.221"></a><span id="l39.221">  * @tests gloda.query.test.kConstraintIn</span>
<a href="#l39.222"></a><span id="l39.222">  */</span>
<a href="#l39.223"></a><span id="l39.223"> function test_query_messages_by_conversation_nonmatches() {</span>
<a href="#l39.224"></a><span id="l39.224">   verify_nonMatches(ts_convQueries, ts_convCollections);</span>
<a href="#l39.225"></a><span id="l39.225" class="difflineminus">-  next_test();</span>
<a href="#l39.226"></a><span id="l39.226"> }</span>
<a href="#l39.227"></a><span id="l39.227"> </span>
<a href="#l39.228"></a><span id="l39.228"> var ts_folderNum = 0;</span>
<a href="#l39.229"></a><span id="l39.229"> var ts_folderQueries = [];</span>
<a href="#l39.230"></a><span id="l39.230"> var ts_folderCollections = [];</span>
<a href="#l39.231"></a><span id="l39.231"> /**</span>
<a href="#l39.232"></a><span id="l39.232">  * @tests gloda.noun.message.attr.folder</span>
<a href="#l39.233"></a><span id="l39.233">  * @tests gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l39.234"></a><span id="l39.234">  */</span>
<a href="#l39.235"></a><span id="l39.235"> function test_query_messages_by_folder() {</span>
<a href="#l39.236"></a><span id="l39.236" class="difflineminus">-  // If we have one folder to test with, we can't do this test more times</span>
<a href="#l39.237"></a><span id="l39.237" class="difflineminus">-  if (singleFolder &amp;&amp; ts_folderNum &gt;= 1) {</span>
<a href="#l39.238"></a><span id="l39.238" class="difflineminus">-    next_test();</span>
<a href="#l39.239"></a><span id="l39.239" class="difflineminus">-    return;</span>
<a href="#l39.240"></a><span id="l39.240" class="difflineminus">-  }</span>
<a href="#l39.241"></a><span id="l39.241" class="difflineminus">-</span>
<a href="#l39.242"></a><span id="l39.242">   let folderNum = ts_folderNum++;</span>
<a href="#l39.243"></a><span id="l39.243">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.244"></a><span id="l39.244">   query.folder(world.glodaFolders[folderNum]);</span>
<a href="#l39.245"></a><span id="l39.245"> </span>
<a href="#l39.246"></a><span id="l39.246">   ts_folderQueries.push(query);</span>
<a href="#l39.247"></a><span id="l39.247">   ts_folderCollections.push(queryExpect(query, world.folderClumps[folderNum]));</span>
<a href="#l39.248"></a><span id="l39.248" class="difflineminus">-  // queryExpect calls next_test</span>
<a href="#l39.249"></a><span id="l39.249" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.250"></a><span id="l39.250"> }</span>
<a href="#l39.251"></a><span id="l39.251"> </span>
<a href="#l39.252"></a><span id="l39.252"> /**</span>
<a href="#l39.253"></a><span id="l39.253">  * @tests gloda.query.test.kConstraintIn</span>
<a href="#l39.254"></a><span id="l39.254">  */</span>
<a href="#l39.255"></a><span id="l39.255"> function test_query_messages_by_folder_nonmatches() {</span>
<a href="#l39.256"></a><span id="l39.256" class="difflineminus">-  // No can do with one folder</span>
<a href="#l39.257"></a><span id="l39.257" class="difflineminus">-  if (!singleFolder)</span>
<a href="#l39.258"></a><span id="l39.258" class="difflineminus">-    verify_nonMatches(ts_folderQueries, ts_folderCollections);</span>
<a href="#l39.259"></a><span id="l39.259" class="difflineminus">-  next_test();</span>
<a href="#l39.260"></a><span id="l39.260" class="difflineplus">+  verify_nonMatches(ts_folderQueries, ts_folderCollections);</span>
<a href="#l39.261"></a><span id="l39.261"> }</span>
<a href="#l39.262"></a><span id="l39.262"> </span>
<a href="#l39.263"></a><span id="l39.263"> /**</span>
<a href="#l39.264"></a><span id="l39.264">  * @tests Gloda.ns.getMessageCollectionForHeader()</span>
<a href="#l39.265"></a><span id="l39.265">  */</span>
<a href="#l39.266"></a><span id="l39.266"> function test_get_message_for_header() {</span>
<a href="#l39.267"></a><span id="l39.267">   // pick an arbitrary message</span>
<a href="#l39.268"></a><span id="l39.268">   let glodaMessage = ts_convCollections[1].items[0];</span>
<a href="#l39.269"></a><span id="l39.269">   // find the synthetic message that matches (ordering must not be assumed)</span>
<a href="#l39.270"></a><span id="l39.270">   let synthMessage = [sm for each (sm in world.conversationLists[1])</span>
<a href="#l39.271"></a><span id="l39.271">                       if (sm.messageId == glodaMessage.headerMessageID)][0];</span>
<a href="#l39.272"></a><span id="l39.272">   queryExpect({queryFunc: Gloda.getMessageCollectionForHeader,</span>
<a href="#l39.273"></a><span id="l39.273">                queryThis: Gloda,</span>
<a href="#l39.274"></a><span id="l39.274">                args: [glodaMessage.folderMessage], nounId: Gloda.NOUN_MESSAGE},</span>
<a href="#l39.275"></a><span id="l39.275">               [synthMessage]);</span>
<a href="#l39.276"></a><span id="l39.276" class="difflineminus">-  // queryExpect calls next_test</span>
<a href="#l39.277"></a><span id="l39.277" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.278"></a><span id="l39.278"> }</span>
<a href="#l39.279"></a><span id="l39.279"> </span>
<a href="#l39.280"></a><span id="l39.280"> /**</span>
<a href="#l39.281"></a><span id="l39.281">  * @tests Gloda.ns.getMessageCollectionForHeaders()</span>
<a href="#l39.282"></a><span id="l39.282">  */</span>
<a href="#l39.283"></a><span id="l39.283"> function test_get_messages_for_headers() {</span>
<a href="#l39.284"></a><span id="l39.284">   let messageCollection = ts_convCollections[0];</span>
<a href="#l39.285"></a><span id="l39.285">   let headers = [m.folderMessage for each (m in messageCollection.items)];</span>
<a href="#l39.286"></a><span id="l39.286">   queryExpect({queryFunc: Gloda.getMessageCollectionForHeaders,</span>
<a href="#l39.287"></a><span id="l39.287">                queryThis: Gloda,</span>
<a href="#l39.288"></a><span id="l39.288">                args: [headers], nounId: Gloda.NOUN_MESSAGE},</span>
<a href="#l39.289"></a><span id="l39.289">               world.conversationLists[0]);</span>
<a href="#l39.290"></a><span id="l39.290" class="difflineminus">-  // queryExpect calls next_test</span>
<a href="#l39.291"></a><span id="l39.291" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.292"></a><span id="l39.292"> }</span>
<a href="#l39.293"></a><span id="l39.293"> </span>
<a href="#l39.294"></a><span id="l39.294"> // at this point we go run the identity and contact tests for side-effects</span>
<a href="#l39.295"></a><span id="l39.295"> </span>
<a href="#l39.296"></a><span id="l39.296"> var ts_messageIdentityQueries = [];</span>
<a href="#l39.297"></a><span id="l39.297"> var ts_messageIdentityCollections = [];</span>
<a href="#l39.298"></a><span id="l39.298"> /**</span>
<a href="#l39.299"></a><span id="l39.299">  * @tests gloda.noun.message.attr.involves</span>
<a href="#l39.300"></a><span id="l39.300">  * @tests gloda.datastore.sqlgen.kConstraintIn</span>
<a href="#l39.301"></a><span id="l39.301">  */</span>
<a href="#l39.302"></a><span id="l39.302"> function test_query_messages_by_identity_peoples() {</span>
<a href="#l39.303"></a><span id="l39.303">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.304"></a><span id="l39.304">   query.involves(peoplesIdentityCollection.items[0]);</span>
<a href="#l39.305"></a><span id="l39.305"> </span>
<a href="#l39.306"></a><span id="l39.306">   ts_messageIdentityQueries.push(query);</span>
<a href="#l39.307"></a><span id="l39.307">   ts_messageIdentityCollections.push(queryExpect(query, world.peoplesMessages));</span>
<a href="#l39.308"></a><span id="l39.308" class="difflineminus">-  // queryExpect calls next_test</span>
<a href="#l39.309"></a><span id="l39.309" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.310"></a><span id="l39.310"> }</span>
<a href="#l39.311"></a><span id="l39.311"> </span>
<a href="#l39.312"></a><span id="l39.312"> /**</span>
<a href="#l39.313"></a><span id="l39.313">  * @tests gloda.noun.message.attr.involves</span>
<a href="#l39.314"></a><span id="l39.314">  */</span>
<a href="#l39.315"></a><span id="l39.315"> function test_query_messages_by_identity_outlier() {</span>
<a href="#l39.316"></a><span id="l39.316">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.317"></a><span id="l39.317">   query.involves(outlierIdentityCollection.items[0]);</span>
<a href="#l39.318"></a><span id="l39.318">   // this also tests our ability to have two intersecting constraints! hooray!</span>
<a href="#l39.319"></a><span id="l39.319">   query.involves(outlierIdentityCollection.items[1]);</span>
<a href="#l39.320"></a><span id="l39.320"> </span>
<a href="#l39.321"></a><span id="l39.321">   ts_messageIdentityQueries.push(query);</span>
<a href="#l39.322"></a><span id="l39.322">   ts_messageIdentityCollections.push(queryExpect(query, world.outlierMessages));</span>
<a href="#l39.323"></a><span id="l39.323" class="difflineminus">-  // queryExpect calls next_test</span>
<a href="#l39.324"></a><span id="l39.324" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.325"></a><span id="l39.325"> }</span>
<a href="#l39.326"></a><span id="l39.326"> </span>
<a href="#l39.327"></a><span id="l39.327"> /**</span>
<a href="#l39.328"></a><span id="l39.328">  * @tests gloda.query.test.kConstraintIn</span>
<a href="#l39.329"></a><span id="l39.329">  */</span>
<a href="#l39.330"></a><span id="l39.330"> function test_query_messages_by_identity_nonmatches() {</span>
<a href="#l39.331"></a><span id="l39.331">   verify_nonMatches(ts_messageIdentityQueries, ts_messageIdentityCollections);</span>
<a href="#l39.332"></a><span id="l39.332" class="difflineminus">-  next_test();</span>
<a href="#l39.333"></a><span id="l39.333"> }</span>
<a href="#l39.334"></a><span id="l39.334"> </span>
<a href="#l39.335"></a><span id="l39.335"> function test_query_messages_by_contact() {</span>
<a href="#l39.336"></a><span id="l39.336">   // IOU</span>
<a href="#l39.337"></a><span id="l39.337" class="difflineminus">-  next_test();</span>
<a href="#l39.338"></a><span id="l39.338"> }</span>
<a href="#l39.339"></a><span id="l39.339"> </span>
<a href="#l39.340"></a><span id="l39.340"> var ts_messagesDateQuery;</span>
<a href="#l39.341"></a><span id="l39.341"> /**</span>
<a href="#l39.342"></a><span id="l39.342">  * @tests gloda.noun.message.attr.date</span>
<a href="#l39.343"></a><span id="l39.343">  * @tests gloda.datastore.sqlgen.kConstraintRanges</span>
<a href="#l39.344"></a><span id="l39.344">  */</span>
<a href="#l39.345"></a><span id="l39.345"> function test_query_messages_by_date() {</span>
<a href="#l39.346"></a><span id="l39.346">   ts_messagesDateQuery = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.347"></a><span id="l39.347">   // we are clearly relying on knowing the generation sequence here,</span>
<a href="#l39.348"></a><span id="l39.348">   //  fuggedaboutit</span>
<a href="#l39.349"></a><span id="l39.349">   ts_messagesDateQuery.dateRange([world.peoplesMessages[1].date,</span>
<a href="#l39.350"></a><span id="l39.350">                                   world.peoplesMessages[2].date]);</span>
<a href="#l39.351"></a><span id="l39.351">   queryExpect(ts_messagesDateQuery, world.peoplesMessages.slice(1, 3));</span>
<a href="#l39.352"></a><span id="l39.352" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.353"></a><span id="l39.353"> }</span>
<a href="#l39.354"></a><span id="l39.354"> </span>
<a href="#l39.355"></a><span id="l39.355"> /**</span>
<a href="#l39.356"></a><span id="l39.356">  * @tests gloda.query.test.kConstraintRanges</span>
<a href="#l39.357"></a><span id="l39.357">  */</span>
<a href="#l39.358"></a><span id="l39.358"> function test_query_messages_by_date_nonmatches() {</span>
<a href="#l39.359"></a><span id="l39.359">   if (ts_messagesDateQuery.test(world.peoplesMessages[0]) ||</span>
<a href="#l39.360"></a><span id="l39.360">       ts_messagesDateQuery.test(world.peoplesMessages[3])) {</span>
<a href="#l39.361"></a><span id="l39.361">     do_throw(&quot;The date testing mechanism is busted.&quot;);</span>
<a href="#l39.362"></a><span id="l39.362">   }</span>
<a href="#l39.363"></a><span id="l39.363" class="difflineminus">-  next_test();</span>
<a href="#l39.364"></a><span id="l39.364"> }</span>
<a href="#l39.365"></a><span id="l39.365"> </span>
<a href="#l39.366"></a><span id="l39.366"> </span>
<a href="#l39.367"></a><span id="l39.367"> /* === contacts === */</span>
<a href="#l39.368"></a><span id="l39.368"> function test_query_contacts_by_popularity() {</span>
<a href="#l39.369"></a><span id="l39.369">   // IOU</span>
<a href="#l39.370"></a><span id="l39.370" class="difflineminus">-  next_test();</span>
<a href="#l39.371"></a><span id="l39.371"> }</span>
<a href="#l39.372"></a><span id="l39.372"> </span>
<a href="#l39.373"></a><span id="l39.373"> /* === identities === */</span>
<a href="#l39.374"></a><span id="l39.374"> </span>
<a href="#l39.375"></a><span id="l39.375"> /* ===== Text-based queries ===== */</span>
<a href="#l39.376"></a><span id="l39.376"> </span>
<a href="#l39.377"></a><span id="l39.377"> /* === conversations === */</span>
<a href="#l39.378"></a><span id="l39.378"> </span>
<a href="#l39.379"></a><span id="l39.379"> function test_query_conversations_by_subject_text() {</span>
<a href="#l39.380"></a><span id="l39.380" class="difflineminus">-  next_test();</span>
<a href="#l39.381"></a><span id="l39.381"> }</span>
<a href="#l39.382"></a><span id="l39.382"> </span>
<a href="#l39.383"></a><span id="l39.383"> /* === messages === */</span>
<a href="#l39.384"></a><span id="l39.384"> </span>
<a href="#l39.385"></a><span id="l39.385"> /**</span>
<a href="#l39.386"></a><span id="l39.386">  * Test subject searching using the conversation unique subject term.</span>
<a href="#l39.387"></a><span id="l39.387">  *</span>
<a href="#l39.388"></a><span id="l39.388">  * @tests gloda.noun.message.attr.subjectMatches</span>
<a href="#l39.389"></a><span id="l39.389" class="difflineat">@@ -469,106 +495,113 @@ function test_query_conversations_by_sub</span>
<a href="#l39.390"></a><span id="l39.390"> function test_query_messages_by_subject_text() {</span>
<a href="#l39.391"></a><span id="l39.391">   // we only need to use one conversation</span>
<a href="#l39.392"></a><span id="l39.392">   let convNum = 0;</span>
<a href="#l39.393"></a><span id="l39.393"> dump(&quot;convNum: &quot; + convNum + &quot; blah: &quot; + world.conversationLists[convNum] + &quot;\n&quot;);</span>
<a href="#l39.394"></a><span id="l39.394">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.395"></a><span id="l39.395">   let convSubjectTerm = uniqueTermGenerator(</span>
<a href="#l39.396"></a><span id="l39.396">     UNIQUE_OFFSET_SUBJECT + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l39.397"></a><span id="l39.397">   query.subjectMatches(convSubjectTerm);</span>
<a href="#l39.398"></a><span id="l39.398" class="difflineminus">-  queryExpect(query, world.conversationLists[convNum]); // calls next_test</span>
<a href="#l39.399"></a><span id="l39.399" class="difflineplus">+  queryExpect(query, world.conversationLists[convNum]);</span>
<a href="#l39.400"></a><span id="l39.400" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.401"></a><span id="l39.401"> }</span>
<a href="#l39.402"></a><span id="l39.402"> </span>
<a href="#l39.403"></a><span id="l39.403"> /**</span>
<a href="#l39.404"></a><span id="l39.404">  * Test body searching using the conversation unique body term.</span>
<a href="#l39.405"></a><span id="l39.405">  *</span>
<a href="#l39.406"></a><span id="l39.406">  * @tests gloda.noun.message.attr.bodyMatches</span>
<a href="#l39.407"></a><span id="l39.407">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l39.408"></a><span id="l39.408">  */</span>
<a href="#l39.409"></a><span id="l39.409"> function test_query_messages_by_body_text() {</span>
<a href="#l39.410"></a><span id="l39.410">   // we only need to use one conversation</span>
<a href="#l39.411"></a><span id="l39.411">   let convNum = 0;</span>
<a href="#l39.412"></a><span id="l39.412">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.413"></a><span id="l39.413">   let convBodyTerm = uniqueTermGenerator(</span>
<a href="#l39.414"></a><span id="l39.414">     UNIQUE_OFFSET_BODY + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l39.415"></a><span id="l39.415">   query.bodyMatches(convBodyTerm);</span>
<a href="#l39.416"></a><span id="l39.416">   queryExpect(query, expectFulltextResults ? world.conversationLists[convNum] :</span>
<a href="#l39.417"></a><span id="l39.417" class="difflineminus">-                                             []); // calls next_test</span>
<a href="#l39.418"></a><span id="l39.418" class="difflineplus">+                                             []);</span>
<a href="#l39.419"></a><span id="l39.419" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.420"></a><span id="l39.420"> }</span>
<a href="#l39.421"></a><span id="l39.421"> </span>
<a href="#l39.422"></a><span id="l39.422"> /**</span>
<a href="#l39.423"></a><span id="l39.423">  * Test attachment name searching using the conversation unique attachment term.</span>
<a href="#l39.424"></a><span id="l39.424">  *</span>
<a href="#l39.425"></a><span id="l39.425">  * @tests gloda.noun.message.attr.attachmentNamesMatch</span>
<a href="#l39.426"></a><span id="l39.426">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l39.427"></a><span id="l39.427">  */</span>
<a href="#l39.428"></a><span id="l39.428"> function test_query_messages_by_attachment_names() {</span>
<a href="#l39.429"></a><span id="l39.429">   let convNum = 0;</span>
<a href="#l39.430"></a><span id="l39.430">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.431"></a><span id="l39.431">   let convUniqueAttachment = uniqueTermGenerator(</span>
<a href="#l39.432"></a><span id="l39.432">     UNIQUE_OFFSET_ATTACHMENT + UNIQUE_OFFSET_CONV + convNum);</span>
<a href="#l39.433"></a><span id="l39.433">   query.attachmentNamesMatch(convUniqueAttachment);</span>
<a href="#l39.434"></a><span id="l39.434">   queryExpect(query, expectFulltextResults ? world.conversationLists[convNum] :</span>
<a href="#l39.435"></a><span id="l39.435" class="difflineminus">-                                             []); // calls next_test</span>
<a href="#l39.436"></a><span id="l39.436" class="difflineplus">+                                             []);</span>
<a href="#l39.437"></a><span id="l39.437" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.438"></a><span id="l39.438"> }</span>
<a href="#l39.439"></a><span id="l39.439"> </span>
<a href="#l39.440"></a><span id="l39.440"> /**</span>
<a href="#l39.441"></a><span id="l39.441">  * Test author name fulltext searching using an arbitrary author.</span>
<a href="#l39.442"></a><span id="l39.442">  *</span>
<a href="#l39.443"></a><span id="l39.443">  * @tests gloda.noun.message.attr.authorMatches</span>
<a href="#l39.444"></a><span id="l39.444">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l39.445"></a><span id="l39.445">  */</span>
<a href="#l39.446"></a><span id="l39.446"> function test_query_messages_by_authorMatches_name() {</span>
<a href="#l39.447"></a><span id="l39.447">   let [authorName, authorMail] = world.peoples[0];</span>
<a href="#l39.448"></a><span id="l39.448">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.449"></a><span id="l39.449">   query.authorMatches(authorName);</span>
<a href="#l39.450"></a><span id="l39.450" class="difflineminus">-  queryExpect(query, world.authorGroups[authorMail]); // calls next_test</span>
<a href="#l39.451"></a><span id="l39.451" class="difflineplus">+  queryExpect(query, world.authorGroups[authorMail]);</span>
<a href="#l39.452"></a><span id="l39.452" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.453"></a><span id="l39.453"> }</span>
<a href="#l39.454"></a><span id="l39.454"> </span>
<a href="#l39.455"></a><span id="l39.455"> /**</span>
<a href="#l39.456"></a><span id="l39.456">  * Test author mail address fulltext searching using an arbitrary author.</span>
<a href="#l39.457"></a><span id="l39.457">  *</span>
<a href="#l39.458"></a><span id="l39.458">  * @tests gloda.noun.message.attr.authorMatches</span>
<a href="#l39.459"></a><span id="l39.459">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l39.460"></a><span id="l39.460">  */</span>
<a href="#l39.461"></a><span id="l39.461"> function test_query_messages_by_authorMatches_email() {</span>
<a href="#l39.462"></a><span id="l39.462">   let [authorName, authorMail] = world.peoples[0];</span>
<a href="#l39.463"></a><span id="l39.463">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.464"></a><span id="l39.464">   query.authorMatches(authorMail);</span>
<a href="#l39.465"></a><span id="l39.465" class="difflineminus">-  queryExpect(query, world.authorGroups[authorMail]); // calls next_test</span>
<a href="#l39.466"></a><span id="l39.466" class="difflineplus">+  queryExpect(query, world.authorGroups[authorMail]);</span>
<a href="#l39.467"></a><span id="l39.467" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.468"></a><span id="l39.468"> }</span>
<a href="#l39.469"></a><span id="l39.469"> </span>
<a href="#l39.470"></a><span id="l39.470"> /**</span>
<a href="#l39.471"></a><span id="l39.471">  * Test recipient name fulltext searching using an arbitrary recipient. Since</span>
<a href="#l39.472"></a><span id="l39.472">  *  all 'peoples' messages are sent to all of them, any choice from peoples</span>
<a href="#l39.473"></a><span id="l39.473">  *  gets us all 'peoplesMessages'.</span>
<a href="#l39.474"></a><span id="l39.474">  *</span>
<a href="#l39.475"></a><span id="l39.475">  * @tests gloda.noun.message.attr.recipientsMatch</span>
<a href="#l39.476"></a><span id="l39.476">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l39.477"></a><span id="l39.477">  */</span>
<a href="#l39.478"></a><span id="l39.478"> function test_query_messages_by_recipients_name() {</span>
<a href="#l39.479"></a><span id="l39.479">   let [name,] = world.peoples[0];</span>
<a href="#l39.480"></a><span id="l39.480">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.481"></a><span id="l39.481">   query.recipientsMatch(name);</span>
<a href="#l39.482"></a><span id="l39.482" class="difflineminus">-  queryExpect(query, world.peoplesMessages); // calls next_test</span>
<a href="#l39.483"></a><span id="l39.483" class="difflineplus">+  queryExpect(query, world.peoplesMessages);</span>
<a href="#l39.484"></a><span id="l39.484" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.485"></a><span id="l39.485"> }</span>
<a href="#l39.486"></a><span id="l39.486"> </span>
<a href="#l39.487"></a><span id="l39.487"> /**</span>
<a href="#l39.488"></a><span id="l39.488">  * Test recipient mail fulltext searching using an arbitrary recipient. Since</span>
<a href="#l39.489"></a><span id="l39.489">  *  all 'peoples' messages are sent to all of them, any choice from peoples</span>
<a href="#l39.490"></a><span id="l39.490">  *  gets us all 'peoplesMessages'.</span>
<a href="#l39.491"></a><span id="l39.491">  *</span>
<a href="#l39.492"></a><span id="l39.492">  * @tests gloda.noun.message.attr.recipientsMatch</span>
<a href="#l39.493"></a><span id="l39.493">  * @tests gloda.datastore.sqlgen.kConstraintFulltext</span>
<a href="#l39.494"></a><span id="l39.494">  */</span>
<a href="#l39.495"></a><span id="l39.495"> function test_query_messages_by_recipients_email() {</span>
<a href="#l39.496"></a><span id="l39.496">   let [, mail] = world.peoples[0];</span>
<a href="#l39.497"></a><span id="l39.497">   let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l39.498"></a><span id="l39.498">   query.recipientsMatch(mail);</span>
<a href="#l39.499"></a><span id="l39.499" class="difflineminus">-  queryExpect(query, world.peoplesMessages); // calls next_test</span>
<a href="#l39.500"></a><span id="l39.500" class="difflineplus">+  queryExpect(query, world.peoplesMessages);</span>
<a href="#l39.501"></a><span id="l39.501" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.502"></a><span id="l39.502"> }</span>
<a href="#l39.503"></a><span id="l39.503"> </span>
<a href="#l39.504"></a><span id="l39.504"> /* === contacts === */</span>
<a href="#l39.505"></a><span id="l39.505"> </span>
<a href="#l39.506"></a><span id="l39.506"> var contactLikeQuery;</span>
<a href="#l39.507"></a><span id="l39.507"> /**</span>
<a href="#l39.508"></a><span id="l39.508">  * @tests gloda.noun.contact.attr.name</span>
<a href="#l39.509"></a><span id="l39.509">  * @tests gloda.datastore.sqlgen.kConstraintStringLike</span>
<a href="#l39.510"></a><span id="l39.510" class="difflineat">@@ -579,55 +612,56 @@ function test_query_contacts_by_name() {</span>
<a href="#l39.511"></a><span id="l39.511">   let personName = world.peoples[0][0];</span>
<a href="#l39.512"></a><span id="l39.512">   // chop off the first and last letter...  this isn't the most edge-case</span>
<a href="#l39.513"></a><span id="l39.513">   //  handling way to roll, but LOOK OVER THERE? IS THAT ELVIS?</span>
<a href="#l39.514"></a><span id="l39.514">   let personNameSubstring = personName.substring(1, personName.length-1);</span>
<a href="#l39.515"></a><span id="l39.515">   contactLikeQuery.nameLike(contactLikeQuery.WILD, personNameSubstring,</span>
<a href="#l39.516"></a><span id="l39.516">                             contactLikeQuery.WILD);</span>
<a href="#l39.517"></a><span id="l39.517"> </span>
<a href="#l39.518"></a><span id="l39.518">   queryExpect(contactLikeQuery, [personName]);</span>
<a href="#l39.519"></a><span id="l39.519" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.520"></a><span id="l39.520"> }</span>
<a href="#l39.521"></a><span id="l39.521"> </span>
<a href="#l39.522"></a><span id="l39.522"> /**</span>
<a href="#l39.523"></a><span id="l39.523">  * @tests gloda.query.test.kConstraintStringLike</span>
<a href="#l39.524"></a><span id="l39.524">  */</span>
<a href="#l39.525"></a><span id="l39.525"> function test_query_contacts_by_name_nonmatch() {</span>
<a href="#l39.526"></a><span id="l39.526">   let otherContact = outlierIdentityCollection.items[0].contact;</span>
<a href="#l39.527"></a><span id="l39.527">   if (contactLikeQuery.test(otherContact)) {</span>
<a href="#l39.528"></a><span id="l39.528">     do_throw(&quot;The string LIKE mechanism as applied to contacts does not work.&quot;);</span>
<a href="#l39.529"></a><span id="l39.529">   }</span>
<a href="#l39.530"></a><span id="l39.530" class="difflineminus">-  next_test();</span>
<a href="#l39.531"></a><span id="l39.531"> }</span>
<a href="#l39.532"></a><span id="l39.532"> </span>
<a href="#l39.533"></a><span id="l39.533"> /* === identities === */</span>
<a href="#l39.534"></a><span id="l39.534"> </span>
<a href="#l39.535"></a><span id="l39.535"> var peoplesIdentityQuery;</span>
<a href="#l39.536"></a><span id="l39.536"> var peoplesIdentityCollection;</span>
<a href="#l39.537"></a><span id="l39.537"> function test_query_identities_for_peoples() {</span>
<a href="#l39.538"></a><span id="l39.538">   peoplesIdentityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l39.539"></a><span id="l39.539">   peoplesIdentityQuery.kind(&quot;email&quot;);</span>
<a href="#l39.540"></a><span id="l39.540">   let peopleAddrs = [nameAndAddr[1] for each (nameAndAddr in world.peoples)];</span>
<a href="#l39.541"></a><span id="l39.541">   peoplesIdentityQuery.value.apply(peoplesIdentityQuery, peopleAddrs);</span>
<a href="#l39.542"></a><span id="l39.542">   peoplesIdentityCollection = queryExpect(peoplesIdentityQuery, peopleAddrs);</span>
<a href="#l39.543"></a><span id="l39.543" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.544"></a><span id="l39.544"> }</span>
<a href="#l39.545"></a><span id="l39.545"> </span>
<a href="#l39.546"></a><span id="l39.546"> var outlierIdentityQuery;</span>
<a href="#l39.547"></a><span id="l39.547"> var outlierIdentityCollection;</span>
<a href="#l39.548"></a><span id="l39.548"> function test_query_identities_for_outliers() {</span>
<a href="#l39.549"></a><span id="l39.549">   outlierIdentityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l39.550"></a><span id="l39.550">   outlierIdentityQuery.kind(&quot;email&quot;);</span>
<a href="#l39.551"></a><span id="l39.551">   let outlierAddrs = [world.outlierAuthor[1], world.outlierFriend[1]];</span>
<a href="#l39.552"></a><span id="l39.552">   outlierIdentityQuery.value.apply(outlierIdentityQuery, outlierAddrs);</span>
<a href="#l39.553"></a><span id="l39.553">   outlierIdentityCollection = queryExpect(outlierIdentityQuery, outlierAddrs);</span>
<a href="#l39.554"></a><span id="l39.554" class="difflineplus">+  return false; // async pend on queryExpect</span>
<a href="#l39.555"></a><span id="l39.555"> }</span>
<a href="#l39.556"></a><span id="l39.556"> </span>
<a href="#l39.557"></a><span id="l39.557"> function test_query_identities_by_kind_and_value_nonmatches() {</span>
<a href="#l39.558"></a><span id="l39.558">   verify_nonMatches([peoplesIdentityQuery, outlierIdentityQuery],</span>
<a href="#l39.559"></a><span id="l39.559">                     [peoplesIdentityCollection, outlierIdentityCollection]);</span>
<a href="#l39.560"></a><span id="l39.560" class="difflineminus">-  next_test();</span>
<a href="#l39.561"></a><span id="l39.561"> }</span>
<a href="#l39.562"></a><span id="l39.562"> </span>
<a href="#l39.563"></a><span id="l39.563"> </span>
<a href="#l39.564"></a><span id="l39.564"> /* ===== Driver ===== */</span>
<a href="#l39.565"></a><span id="l39.565"> </span>
<a href="#l39.566"></a><span id="l39.566"> var tests = [</span>
<a href="#l39.567"></a><span id="l39.567">   function pre_setup_populate() { pre_setup_populate_hook(); },</span>
<a href="#l39.568"></a><span id="l39.568">   setup_populate,</span>
<a href="#l39.569"></a><span id="l39.569" class="difflineat">@@ -658,15 +692,8 @@ var tests = [</span>
<a href="#l39.570"></a><span id="l39.570">   test_query_messages_by_authorMatches_name,</span>
<a href="#l39.571"></a><span id="l39.571">   test_query_messages_by_authorMatches_email,</span>
<a href="#l39.572"></a><span id="l39.572">   test_query_messages_by_recipients_name,</span>
<a href="#l39.573"></a><span id="l39.573">   test_query_messages_by_recipients_email,</span>
<a href="#l39.574"></a><span id="l39.574">   // like</span>
<a href="#l39.575"></a><span id="l39.575">   test_query_contacts_by_name,</span>
<a href="#l39.576"></a><span id="l39.576">   test_query_contacts_by_name_nonmatch</span>
<a href="#l39.577"></a><span id="l39.577"> ];</span>
<a href="#l39.578"></a><span id="l39.578" class="difflineminus">-</span>
<a href="#l39.579"></a><span id="l39.579" class="difflineminus">-function run_test() {</span>
<a href="#l39.580"></a><span id="l39.580" class="difflineminus">-  glodaHelperRunTests(tests);</span>
<a href="#l39.581"></a><span id="l39.581" class="difflineminus">-}</span>
<a href="#l39.582"></a><span id="l39.582" class="difflineminus">-</span>
<a href="#l39.583"></a><span id="l39.583" class="difflineminus">-// use mbox injection so we get multiple folders...</span>
<a href="#l39.584"></a><span id="l39.584" class="difflineminus">-injectMessagesUsing(INJECT_MBOX);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1">new file mode 100644</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineminus">--- /dev/null</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/folderEventLogHelper.js</span>
<a href="#l40.4"></a><span id="l40.4" class="difflineat">@@ -0,0 +1,191 @@</span>
<a href="#l40.5"></a><span id="l40.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l40.6"></a><span id="l40.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l40.7"></a><span id="l40.7" class="difflineplus">+ *</span>
<a href="#l40.8"></a><span id="l40.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l40.9"></a><span id="l40.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l40.10"></a><span id="l40.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l40.11"></a><span id="l40.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineplus">+ *</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l40.14"></a><span id="l40.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l40.15"></a><span id="l40.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l40.16"></a><span id="l40.16" class="difflineplus">+ * License.</span>
<a href="#l40.17"></a><span id="l40.17" class="difflineplus">+ *</span>
<a href="#l40.18"></a><span id="l40.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l40.19"></a><span id="l40.19" class="difflineplus">+ *</span>
<a href="#l40.20"></a><span id="l40.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l40.21"></a><span id="l40.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l40.23"></a><span id="l40.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l40.24"></a><span id="l40.24" class="difflineplus">+ *</span>
<a href="#l40.25"></a><span id="l40.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l40.26"></a><span id="l40.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l40.27"></a><span id="l40.27" class="difflineplus">+ *</span>
<a href="#l40.28"></a><span id="l40.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l40.29"></a><span id="l40.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l40.30"></a><span id="l40.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l40.31"></a><span id="l40.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l40.32"></a><span id="l40.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l40.33"></a><span id="l40.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l40.34"></a><span id="l40.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l40.35"></a><span id="l40.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l40.36"></a><span id="l40.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l40.37"></a><span id="l40.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l40.38"></a><span id="l40.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l40.39"></a><span id="l40.39" class="difflineplus">+ *</span>
<a href="#l40.40"></a><span id="l40.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l40.41"></a><span id="l40.41" class="difflineplus">+</span>
<a href="#l40.42"></a><span id="l40.42" class="difflineplus">+/*</span>
<a href="#l40.43"></a><span id="l40.43" class="difflineplus">+ * Hook up folder notifications to logHelper.js.  This is for the benefit of</span>
<a href="#l40.44"></a><span id="l40.44" class="difflineplus">+ *  gloda but others can benefit too.  Cramming it in gloda's file structure</span>
<a href="#l40.45"></a><span id="l40.45" class="difflineplus">+ *  for now.</span>
<a href="#l40.46"></a><span id="l40.46" class="difflineplus">+ */</span>
<a href="#l40.47"></a><span id="l40.47" class="difflineplus">+</span>
<a href="#l40.48"></a><span id="l40.48" class="difflineplus">+function registerFolderEventLogHelper() {</span>
<a href="#l40.49"></a><span id="l40.49" class="difflineplus">+  // Bail if there's no one on the other end who cares about our very</span>
<a href="#l40.50"></a><span id="l40.50" class="difflineplus">+  //  expensive log additions.</span>
<a href="#l40.51"></a><span id="l40.51" class="difflineplus">+  // This stuff might be useful for straight console debugging, but it'll</span>
<a href="#l40.52"></a><span id="l40.52" class="difflineplus">+  //  be costly in the success case, so no go for now.</span>
<a href="#l40.53"></a><span id="l40.53" class="difflineplus">+  if (!logHelperHasInterestedListeners())</span>
<a href="#l40.54"></a><span id="l40.54" class="difflineplus">+    return;</span>
<a href="#l40.55"></a><span id="l40.55" class="difflineplus">+</span>
<a href="#l40.56"></a><span id="l40.56" class="difflineplus">+  let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l40.57"></a><span id="l40.57" class="difflineplus">+    getService(Ci.nsIMsgMailSession);</span>
<a href="#l40.58"></a><span id="l40.58" class="difflineplus">+  mailSession.AddFolderListener(_folderEventLogHelper_folderListener,</span>
<a href="#l40.59"></a><span id="l40.59" class="difflineplus">+                                Ci.nsIFolderListener.propertyFlagChanged |</span>
<a href="#l40.60"></a><span id="l40.60" class="difflineplus">+                                Ci.nsIFolderListener.event);</span>
<a href="#l40.61"></a><span id="l40.61" class="difflineplus">+  let notificationService =</span>
<a href="#l40.62"></a><span id="l40.62" class="difflineplus">+    Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;]</span>
<a href="#l40.63"></a><span id="l40.63" class="difflineplus">+      .getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l40.64"></a><span id="l40.64" class="difflineplus">+  notificationService.addListener(_folderEventLogHelper_msgFolderListener,</span>
<a href="#l40.65"></a><span id="l40.65" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.msgAdded |</span>
<a href="#l40.66"></a><span id="l40.66" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.msgsClassified |</span>
<a href="#l40.67"></a><span id="l40.67" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.msgsDeleted |</span>
<a href="#l40.68"></a><span id="l40.68" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.msgsMoveCopyCompleted |</span>
<a href="#l40.69"></a><span id="l40.69" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.folderDeleted |</span>
<a href="#l40.70"></a><span id="l40.70" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.folderMoveCopyCompleted |</span>
<a href="#l40.71"></a><span id="l40.71" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.folderRenamed |</span>
<a href="#l40.72"></a><span id="l40.72" class="difflineplus">+        Ci.nsIMsgFolderNotificationService.itemEvent);</span>
<a href="#l40.73"></a><span id="l40.73" class="difflineplus">+}</span>
<a href="#l40.74"></a><span id="l40.74" class="difflineplus">+</span>
<a href="#l40.75"></a><span id="l40.75" class="difflineplus">+/**</span>
<a href="#l40.76"></a><span id="l40.76" class="difflineplus">+ * nsIMsgFolderListener implementation to logHelper events that gloda cares</span>
<a href="#l40.77"></a><span id="l40.77" class="difflineplus">+ *  about.</span>
<a href="#l40.78"></a><span id="l40.78" class="difflineplus">+ */</span>
<a href="#l40.79"></a><span id="l40.79" class="difflineplus">+let _folderEventLogHelper_msgFolderListener = {</span>
<a href="#l40.80"></a><span id="l40.80" class="difflineplus">+  msgAdded: function felh_msgAdded(aMsg) {</span>
<a href="#l40.81"></a><span id="l40.81" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;msgAdded&quot;, [aMsg]);</span>
<a href="#l40.82"></a><span id="l40.82" class="difflineplus">+  },</span>
<a href="#l40.83"></a><span id="l40.83" class="difflineplus">+</span>
<a href="#l40.84"></a><span id="l40.84" class="difflineplus">+  msgsClassified: function felh_msgsClassified(aMsgs, aJunkProcessed,</span>
<a href="#l40.85"></a><span id="l40.85" class="difflineplus">+                                               aTraitProcessed) {</span>
<a href="#l40.86"></a><span id="l40.86" class="difflineplus">+    let args = [</span>
<a href="#l40.87"></a><span id="l40.87" class="difflineplus">+      aJunkProcessed ? &quot;junk processed&quot; : &quot;did not junk process&quot;,</span>
<a href="#l40.88"></a><span id="l40.88" class="difflineplus">+      aTraitProcessed ? &quot;trait processed&quot; : &quot;did not trait process&quot;</span>
<a href="#l40.89"></a><span id="l40.89" class="difflineplus">+    ];</span>
<a href="#l40.90"></a><span id="l40.90" class="difflineplus">+    for each (let msgHdr in fixIterator(aMsgs.enumerate(),</span>
<a href="#l40.91"></a><span id="l40.91" class="difflineplus">+                                        Components.interfaces.nsIMsgDBHdr)) {</span>
<a href="#l40.92"></a><span id="l40.92" class="difflineplus">+      args.push(msgHdr);</span>
<a href="#l40.93"></a><span id="l40.93" class="difflineplus">+    }</span>
<a href="#l40.94"></a><span id="l40.94" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;msgsClassified&quot;, args);</span>
<a href="#l40.95"></a><span id="l40.95" class="difflineplus">+  },</span>
<a href="#l40.96"></a><span id="l40.96" class="difflineplus">+</span>
<a href="#l40.97"></a><span id="l40.97" class="difflineplus">+  msgsDeleted: function felh_msgsDeleted(aMsgs) {</span>
<a href="#l40.98"></a><span id="l40.98" class="difflineplus">+    let args = [];</span>
<a href="#l40.99"></a><span id="l40.99" class="difflineplus">+    for each (let msgHdr in fixIterator(aMsgs.enumerate(),</span>
<a href="#l40.100"></a><span id="l40.100" class="difflineplus">+                                        Components.interfaces.nsIMsgDBHdr)) {</span>
<a href="#l40.101"></a><span id="l40.101" class="difflineplus">+      args.push(msgHdr);</span>
<a href="#l40.102"></a><span id="l40.102" class="difflineplus">+    }</span>
<a href="#l40.103"></a><span id="l40.103" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;msgsDeleted&quot;, args);</span>
<a href="#l40.104"></a><span id="l40.104" class="difflineplus">+  },</span>
<a href="#l40.105"></a><span id="l40.105" class="difflineplus">+</span>
<a href="#l40.106"></a><span id="l40.106" class="difflineplus">+  msgsMoveCopyCompleted: function felh_msgsMoveCopyCompleted(aMove, aSrcMsgs,</span>
<a href="#l40.107"></a><span id="l40.107" class="difflineplus">+                                                             aDestFolder,</span>
<a href="#l40.108"></a><span id="l40.108" class="difflineplus">+                                                             aDestMsgs) {</span>
<a href="#l40.109"></a><span id="l40.109" class="difflineplus">+    let args = [aMove ? &quot;moved&quot; : &quot;copied&quot;];</span>
<a href="#l40.110"></a><span id="l40.110" class="difflineplus">+    for each (let msgHdr in fixIterator(aSrcMsgs.enumerate(),</span>
<a href="#l40.111"></a><span id="l40.111" class="difflineplus">+                                        Components.interfaces.nsIMsgDBHdr)) {</span>
<a href="#l40.112"></a><span id="l40.112" class="difflineplus">+      args.push(msgHdr);</span>
<a href="#l40.113"></a><span id="l40.113" class="difflineplus">+    }</span>
<a href="#l40.114"></a><span id="l40.114" class="difflineplus">+    args.push(&quot;to&quot;);</span>
<a href="#l40.115"></a><span id="l40.115" class="difflineplus">+    args.push(aDestFolder);</span>
<a href="#l40.116"></a><span id="l40.116" class="difflineplus">+    if (aDestMsgs) {</span>
<a href="#l40.117"></a><span id="l40.117" class="difflineplus">+      args.push(&quot;dest headers:&quot;);</span>
<a href="#l40.118"></a><span id="l40.118" class="difflineplus">+      for each (let msgHdr in fixIterator(aDestMsgs.enumerate(),</span>
<a href="#l40.119"></a><span id="l40.119" class="difflineplus">+                                          Components.interfaces.nsIMsgDBHdr)) {</span>
<a href="#l40.120"></a><span id="l40.120" class="difflineplus">+        args.push(msgHdr);</span>
<a href="#l40.121"></a><span id="l40.121" class="difflineplus">+      }</span>
<a href="#l40.122"></a><span id="l40.122" class="difflineplus">+    }</span>
<a href="#l40.123"></a><span id="l40.123" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;msgsMoveCopyCompleted&quot;, args);</span>
<a href="#l40.124"></a><span id="l40.124" class="difflineplus">+  },</span>
<a href="#l40.125"></a><span id="l40.125" class="difflineplus">+</span>
<a href="#l40.126"></a><span id="l40.126" class="difflineplus">+  folderAdded: function felh_folderAdded(aFolder) {</span>
<a href="#l40.127"></a><span id="l40.127" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;folderAdded&quot;, [aFolder]);</span>
<a href="#l40.128"></a><span id="l40.128" class="difflineplus">+  },</span>
<a href="#l40.129"></a><span id="l40.129" class="difflineplus">+</span>
<a href="#l40.130"></a><span id="l40.130" class="difflineplus">+  folderDeleted: function felh_folderDeleted(aFolder) {</span>
<a href="#l40.131"></a><span id="l40.131" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;folderDeleted&quot;, [aFolder]);</span>
<a href="#l40.132"></a><span id="l40.132" class="difflineplus">+  },</span>
<a href="#l40.133"></a><span id="l40.133" class="difflineplus">+</span>
<a href="#l40.134"></a><span id="l40.134" class="difflineplus">+  folderMoveCopyCompleted: function felh_folderMoveCopyCompleted(aMove,</span>
<a href="#l40.135"></a><span id="l40.135" class="difflineplus">+                                                                 aSrcFolder,</span>
<a href="#l40.136"></a><span id="l40.136" class="difflineplus">+                                                                 aDestFolder) {</span>
<a href="#l40.137"></a><span id="l40.137" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;folderMoveCopyCompleted&quot;,</span>
<a href="#l40.138"></a><span id="l40.138" class="difflineplus">+                [aMove ? &quot;move&quot; : &quot;copy&quot;,</span>
<a href="#l40.139"></a><span id="l40.139" class="difflineplus">+                 aSrcFolder, &quot;to&quot;, aDestFolder]);</span>
<a href="#l40.140"></a><span id="l40.140" class="difflineplus">+  },</span>
<a href="#l40.141"></a><span id="l40.141" class="difflineplus">+</span>
<a href="#l40.142"></a><span id="l40.142" class="difflineplus">+  folderRenamed: function felh_folderRenamed(aOrigFolder, aNewFolder) {</span>
<a href="#l40.143"></a><span id="l40.143" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;folderRenamed&quot;, [aOrigFolder, &quot;to&quot;, aNewFolder]);</span>
<a href="#l40.144"></a><span id="l40.144" class="difflineplus">+  },</span>
<a href="#l40.145"></a><span id="l40.145" class="difflineplus">+</span>
<a href="#l40.146"></a><span id="l40.146" class="difflineplus">+  itemEvent: function felh_itemEvent(aItem, aEvent, aData) {</span>
<a href="#l40.147"></a><span id="l40.147" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;itemEvent&quot;, [aItem, aEvent, aData]);</span>
<a href="#l40.148"></a><span id="l40.148" class="difflineplus">+  }</span>
<a href="#l40.149"></a><span id="l40.149" class="difflineplus">+};</span>
<a href="#l40.150"></a><span id="l40.150" class="difflineplus">+</span>
<a href="#l40.151"></a><span id="l40.151" class="difflineplus">+</span>
<a href="#l40.152"></a><span id="l40.152" class="difflineplus">+/**</span>
<a href="#l40.153"></a><span id="l40.153" class="difflineplus">+ * nsIFolderListener implementation to logHelper stuff that gloda cares about.</span>
<a href="#l40.154"></a><span id="l40.154" class="difflineplus">+ */</span>
<a href="#l40.155"></a><span id="l40.155" class="difflineplus">+let _folderEventLogHelper_folderListener = {</span>
<a href="#l40.156"></a><span id="l40.156" class="difflineplus">+  OnItemAdded: function felh_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l40.157"></a><span id="l40.157" class="difflineplus">+  },</span>
<a href="#l40.158"></a><span id="l40.158" class="difflineplus">+  OnItemRemoved: function felh_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l40.159"></a><span id="l40.159" class="difflineplus">+  },</span>
<a href="#l40.160"></a><span id="l40.160" class="difflineplus">+  OnItemPropertyChanged: function felh_OnItemPropertyChanged(</span>
<a href="#l40.161"></a><span id="l40.161" class="difflineplus">+    aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l40.162"></a><span id="l40.162" class="difflineplus">+  },</span>
<a href="#l40.163"></a><span id="l40.163" class="difflineplus">+  OnItemIntPropertyChanged: function felh_OnItemIntPropertyChanged(</span>
<a href="#l40.164"></a><span id="l40.164" class="difflineplus">+    aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l40.165"></a><span id="l40.165" class="difflineplus">+  },</span>
<a href="#l40.166"></a><span id="l40.166" class="difflineplus">+  OnItemBoolPropertyChanged: function felh_OnItemBoolPropertyChanged(</span>
<a href="#l40.167"></a><span id="l40.167" class="difflineplus">+    aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l40.168"></a><span id="l40.168" class="difflineplus">+  },</span>
<a href="#l40.169"></a><span id="l40.169" class="difflineplus">+  OnItemUnicharPropertyChanged: function felh_OnItemUnicharPropertyChanged(</span>
<a href="#l40.170"></a><span id="l40.170" class="difflineplus">+    aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l40.171"></a><span id="l40.171" class="difflineplus">+  },</span>
<a href="#l40.172"></a><span id="l40.172" class="difflineplus">+  /**</span>
<a href="#l40.173"></a><span id="l40.173" class="difflineplus">+   * Notice when user activity adds/removes tags or changes a message's</span>
<a href="#l40.174"></a><span id="l40.174" class="difflineplus">+   *  status.</span>
<a href="#l40.175"></a><span id="l40.175" class="difflineplus">+   */</span>
<a href="#l40.176"></a><span id="l40.176" class="difflineplus">+  OnItemPropertyFlagChanged: function felh_OnItemPropertyFlagChanged(</span>
<a href="#l40.177"></a><span id="l40.177" class="difflineplus">+      aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l40.178"></a><span id="l40.178" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;OnItemPropertyFlagChanged&quot;,</span>
<a href="#l40.179"></a><span id="l40.179" class="difflineplus">+                [&quot;Header&quot;, aMsgHdr,</span>
<a href="#l40.180"></a><span id="l40.180" class="difflineplus">+                 &quot;had property &quot; + aProperty.toString() + &quot; have the &quot; +</span>
<a href="#l40.181"></a><span id="l40.181" class="difflineplus">+                 &quot;following bits change: &quot; +</span>
<a href="#l40.182"></a><span id="l40.182" class="difflineplus">+                 _explode_flags(aOldValue ^ aNewValue,</span>
<a href="#l40.183"></a><span id="l40.183" class="difflineplus">+                                Components.interfaces.nsMsgMessageFlags)]);</span>
<a href="#l40.184"></a><span id="l40.184" class="difflineplus">+  },</span>
<a href="#l40.185"></a><span id="l40.185" class="difflineplus">+</span>
<a href="#l40.186"></a><span id="l40.186" class="difflineplus">+  /**</span>
<a href="#l40.187"></a><span id="l40.187" class="difflineplus">+   * Get folder loaded notifications for folders that had to do some</span>
<a href="#l40.188"></a><span id="l40.188" class="difflineplus">+   *  (asynchronous) processing before they could be opened.</span>
<a href="#l40.189"></a><span id="l40.189" class="difflineplus">+   */</span>
<a href="#l40.190"></a><span id="l40.190" class="difflineplus">+  OnItemEvent: function felh_OnItemEvent(aFolder, aEvent) {</span>
<a href="#l40.191"></a><span id="l40.191" class="difflineplus">+    mark_action(&quot;msgEvent&quot;, &quot;OnItemEvent&quot;,</span>
<a href="#l40.192"></a><span id="l40.192" class="difflineplus">+                [aFolder, aEvent.toString()]);</span>
<a href="#l40.193"></a><span id="l40.193" class="difflineplus">+  },</span>
<a href="#l40.194"></a><span id="l40.194" class="difflineplus">+};</span>
<a href="#l40.195"></a><span id="l40.195" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/genericIndexer.js</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/genericIndexer.js</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -9,28 +9,33 @@ var GenericIndexer = {</span>
<a href="#l41.4"></a><span id="l41.4">   name: &quot;generic_indexer&quot;,</span>
<a href="#l41.5"></a><span id="l41.5">   enable: function() {</span>
<a href="#l41.6"></a><span id="l41.6">     this.enabled = true;</span>
<a href="#l41.7"></a><span id="l41.7">   },</span>
<a href="#l41.8"></a><span id="l41.8">   disable: function() {</span>
<a href="#l41.9"></a><span id="l41.9">     this.enabled = false;</span>
<a href="#l41.10"></a><span id="l41.10">   },</span>
<a href="#l41.11"></a><span id="l41.11">   get workers() {</span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-    return [[&quot;generic-new&quot;, this._worker_index_generic_new]];</span>
<a href="#l41.13"></a><span id="l41.13" class="difflineplus">+    return [</span>
<a href="#l41.14"></a><span id="l41.14" class="difflineplus">+      [&quot;generic-new&quot;, {</span>
<a href="#l41.15"></a><span id="l41.15" class="difflineplus">+         worker: this._worker_index_generic_new,</span>
<a href="#l41.16"></a><span id="l41.16" class="difflineplus">+       }]</span>
<a href="#l41.17"></a><span id="l41.17" class="difflineplus">+    ];</span>
<a href="#l41.18"></a><span id="l41.18">   },</span>
<a href="#l41.19"></a><span id="l41.19">   initialSweep: function() {</span>
<a href="#l41.20"></a><span id="l41.20">   },</span>
<a href="#l41.21"></a><span id="l41.21">   /* mock interface */</span>
<a href="#l41.22"></a><span id="l41.22">   enabled: false,</span>
<a href="#l41.23"></a><span id="l41.23">   initialSweepCalled: false,</span>
<a href="#l41.24"></a><span id="l41.24">   indexNewObjects: function(aObjects) {</span>
<a href="#l41.25"></a><span id="l41.25">     indexingInProgress = true;</span>
<a href="#l41.26"></a><span id="l41.26">     this._log.debug(&quot;enqueuing &quot; + aObjects.length +</span>
<a href="#l41.27"></a><span id="l41.27">       &quot; new generic objects with id: &quot; + aObjects[0].NOUN_ID);</span>
<a href="#l41.28"></a><span id="l41.28" class="difflineminus">-    GlodaIndexer.indexJob(new IndexingJob(&quot;generic-new&quot;, 0, null, aObjects.concat()));</span>
<a href="#l41.29"></a><span id="l41.29" class="difflineplus">+    GlodaIndexer.indexJob(new IndexingJob(&quot;generic-new&quot;, null,</span>
<a href="#l41.30"></a><span id="l41.30" class="difflineplus">+                                          aObjects.concat()));</span>
<a href="#l41.31"></a><span id="l41.31">   },</span>
<a href="#l41.32"></a><span id="l41.32">   /* implementation */</span>
<a href="#l41.33"></a><span id="l41.33">   _worker_index_generic_new: function(aJob, aCallbackHandle) {</span>
<a href="#l41.34"></a><span id="l41.34">     this._log.debug(&quot;Beginning indexing &quot; + aJob.items.length + &quot; generic new items&quot;);</span>
<a href="#l41.35"></a><span id="l41.35">     for (let [, item] in Iterator(aJob.items)) {</span>
<a href="#l41.36"></a><span id="l41.36">       this._log.debug(&quot;Indexing: &quot; + item);</span>
<a href="#l41.37"></a><span id="l41.37">       yield aCallbackHandle.pushAndGo(</span>
<a href="#l41.38"></a><span id="l41.38">         Gloda.grokNounItem(item, {}, true, true, aCallbackHandle,</span>
<a href="#l41.39"></a><span id="l41.39" class="difflineat">@@ -44,12 +49,12 @@ var GenericIndexer = {</span>
<a href="#l41.40"></a><span id="l41.40"> GlodaIndexer.registerIndexer(GenericIndexer);</span>
<a href="#l41.41"></a><span id="l41.41"> </span>
<a href="#l41.42"></a><span id="l41.42"> let indexingInProgress = false;</span>
<a href="#l41.43"></a><span id="l41.43"> function genericIndexerCallback(aStatus) {</span>
<a href="#l41.44"></a><span id="l41.44">   // If indexingInProgress is false, we've received the synthetic</span>
<a href="#l41.45"></a><span id="l41.45">   // notification, so ignore it</span>
<a href="#l41.46"></a><span id="l41.46">   if (indexingInProgress &amp;&amp; aStatus == Gloda.kIndexerIdle) {</span>
<a href="#l41.47"></a><span id="l41.47">     indexingInProgress = false;</span>
<a href="#l41.48"></a><span id="l41.48" class="difflineminus">-    next_test();</span>
<a href="#l41.49"></a><span id="l41.49" class="difflineplus">+    async_driver();</span>
<a href="#l41.50"></a><span id="l41.50">   }</span>
<a href="#l41.51"></a><span id="l41.51"> }</span>
<a href="#l41.52"></a><span id="l41.52"> Gloda.addIndexerListener(genericIndexerCallback);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineat">@@ -31,19 +31,53 @@</span>
<a href="#l42.4"></a><span id="l42.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l42.5"></a><span id="l42.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l42.6"></a><span id="l42.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l42.7"></a><span id="l42.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l42.8"></a><span id="l42.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l42.9"></a><span id="l42.9">  *</span>
<a href="#l42.10"></a><span id="l42.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l42.11"></a><span id="l42.11"> </span>
<a href="#l42.12"></a><span id="l42.12" class="difflineplus">+/*</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+ * This file provides gloda testing infrastructure.</span>
<a href="#l42.14"></a><span id="l42.14" class="difflineplus">+ *</span>
<a href="#l42.15"></a><span id="l42.15" class="difflineplus">+ * A few words about how tests should expect to interact with indexing:</span>
<a href="#l42.16"></a><span id="l42.16" class="difflineplus">+ *</span>
<a href="#l42.17"></a><span id="l42.17" class="difflineplus">+ * By default, we enable only event-driven indexing with an infinite work queue</span>
<a href="#l42.18"></a><span id="l42.18" class="difflineplus">+ *  length.  This means that all messages will be queued for indexing as they</span>
<a href="#l42.19"></a><span id="l42.19" class="difflineplus">+ *  are added or modified.  You should yield to |wait_for_gloda_indexer| to wait</span>
<a href="#l42.20"></a><span id="l42.20" class="difflineplus">+ *  until the indexer completes.  If you want to assert that certain messages</span>
<a href="#l42.21"></a><span id="l42.21" class="difflineplus">+ *  will have been indexed during that pass, you can pass them as arguments to</span>
<a href="#l42.22"></a><span id="l42.22" class="difflineplus">+ *  the function.</span>
<a href="#l42.23"></a><span id="l42.23" class="difflineplus">+ * There is no need to tell us to expect the messages to be indexed prior to the</span>
<a href="#l42.24"></a><span id="l42.24" class="difflineplus">+ *  waiting as long as nothing spins the event loop after you perform the action</span>
<a href="#l42.25"></a><span id="l42.25" class="difflineplus">+ *  that triggers indexing.  None of our existing xpcshell tests do this, but it</span>
<a href="#l42.26"></a><span id="l42.26" class="difflineplus">+ *  is part of the mozmill idiom for its waiting mechanism, so be sure to not</span>
<a href="#l42.27"></a><span id="l42.27" class="difflineplus">+ *  perform a mozmill wait without first telling us to expect the messages.</span>
<a href="#l42.28"></a><span id="l42.28" class="difflineplus">+ */</span>
<a href="#l42.29"></a><span id="l42.29" class="difflineplus">+</span>
<a href="#l42.30"></a><span id="l42.30"> // Import the main scripts that mailnews tests need to set up and tear down</span>
<a href="#l42.31"></a><span id="l42.31"> load(&quot;../../mailnews/resources/mailDirService.js&quot;);</span>
<a href="#l42.32"></a><span id="l42.32"> load(&quot;../../mailnews/resources/mailTestUtils.js&quot;);</span>
<a href="#l42.33"></a><span id="l42.33" class="difflineplus">+load(&quot;../../mailnews/resources/logHelper.js&quot;);</span>
<a href="#l42.34"></a><span id="l42.34" class="difflineplus">+load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l42.35"></a><span id="l42.35" class="difflineplus">+</span>
<a href="#l42.36"></a><span id="l42.36" class="difflineplus">+load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l42.37"></a><span id="l42.37" class="difflineplus">+load(&quot;../../mailnews/resources/messageModifier.js&quot;);</span>
<a href="#l42.38"></a><span id="l42.38" class="difflineplus">+load(&quot;../../mailnews/resources/messageInjection.js&quot;);</span>
<a href="#l42.39"></a><span id="l42.39" class="difflineplus">+</span>
<a href="#l42.40"></a><span id="l42.40" class="difflineplus">+load(&quot;resources/folderEventLogHelper.js&quot;);</span>
<a href="#l42.41"></a><span id="l42.41" class="difflineplus">+// register this before gloda gets a chance to do anything so that</span>
<a href="#l42.42"></a><span id="l42.42" class="difflineplus">+registerFolderEventLogHelper();</span>
<a href="#l42.43"></a><span id="l42.43" class="difflineplus">+</span>
<a href="#l42.44"></a><span id="l42.44" class="difflineplus">+</span>
<a href="#l42.45"></a><span id="l42.45" class="difflineplus">+// Create a message generator</span>
<a href="#l42.46"></a><span id="l42.46" class="difflineplus">+const msgGen = gMessageGenerator = new MessageGenerator();</span>
<a href="#l42.47"></a><span id="l42.47" class="difflineplus">+// Create a message scenario generator using that message generator</span>
<a href="#l42.48"></a><span id="l42.48" class="difflineplus">+const scenarios = gMessageScenarioFactory = new MessageScenarioFactory(msgGen);</span>
<a href="#l42.49"></a><span id="l42.49"> </span>
<a href="#l42.50"></a><span id="l42.50"> Components.utils.import(&quot;resource://app/modules/errUtils.js&quot;);</span>
<a href="#l42.51"></a><span id="l42.51"> </span>
<a href="#l42.52"></a><span id="l42.52"> /**</span>
<a href="#l42.53"></a><span id="l42.53">  * Create a 'me' identity of &quot;me@localhost&quot; for the benefit of Gloda.  At the</span>
<a href="#l42.54"></a><span id="l42.54">  *  time of this writing, Gloda only initializes Gloda.myIdentities and</span>
<a href="#l42.55"></a><span id="l42.55">  *  Gloda.myContact at startup with no event-driven updates.  As such, this</span>
<a href="#l42.56"></a><span id="l42.56">  *  function needs to be called prior to gloda startup.</span>
<a href="#l42.57"></a><span id="l42.57" class="difflineat">@@ -67,677 +101,435 @@ gPrefs.setBoolPref(&quot;mailnews.database.gl</span>
<a href="#l42.58"></a><span id="l42.58"> gPrefs.setBoolPref(&quot;mailnews.database.global.indexer.perform_initial_sweep&quot;,</span>
<a href="#l42.59"></a><span id="l42.59">     false);</span>
<a href="#l42.60"></a><span id="l42.60"> // yes to debug output</span>
<a href="#l42.61"></a><span id="l42.61"> gPrefs.setBoolPref(&quot;mailnews.database.global.logging.dump&quot;, true);</span>
<a href="#l42.62"></a><span id="l42.62"> </span>
<a href="#l42.63"></a><span id="l42.63"> // -- Import our modules</span>
<a href="#l42.64"></a><span id="l42.64"> Components.utils.import(&quot;resource://app/modules/gloda/public.js&quot;);</span>
<a href="#l42.65"></a><span id="l42.65"> Components.utils.import(&quot;resource://app/modules/gloda/indexer.js&quot;);</span>
<a href="#l42.66"></a><span id="l42.66" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/index_msg.js&quot;);</span>
<a href="#l42.67"></a><span id="l42.67"> Components.utils.import(&quot;resource://app/modules/gloda/datastore.js&quot;);</span>
<a href="#l42.68"></a><span id="l42.68"> Components.utils.import(&quot;resource://app/modules/gloda/collection.js&quot;);</span>
<a href="#l42.69"></a><span id="l42.69" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/datamodel.js&quot;);</span>
<a href="#l42.70"></a><span id="l42.70" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/noun_tag.js&quot;);</span>
<a href="#l42.71"></a><span id="l42.71" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/mimemsg.js&quot;);</span>
<a href="#l42.72"></a><span id="l42.72"> </span>
<a href="#l42.73"></a><span id="l42.73"> // -- Add a logger listener that throws when we give it a warning/error.</span>
<a href="#l42.74"></a><span id="l42.74"> Components.utils.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l42.75"></a><span id="l42.75"> let throwingAppender = new Log4Moz.ThrowingAppender(do_throw);</span>
<a href="#l42.76"></a><span id="l42.76"> throwingAppender.level = Log4Moz.Level.Warn;</span>
<a href="#l42.77"></a><span id="l42.77"> Log4Moz.repository.rootLogger.addAppender(throwingAppender);</span>
<a href="#l42.78"></a><span id="l42.78"> </span>
<a href="#l42.79"></a><span id="l42.79"> var LOG = Log4Moz.repository.getLogger(&quot;gloda.test&quot;);</span>
<a href="#l42.80"></a><span id="l42.80"> </span>
<a href="#l42.81"></a><span id="l42.81" class="difflineminus">-/**</span>
<a href="#l42.82"></a><span id="l42.82" class="difflineminus">- * davida's patented dump function for what ails you.</span>
<a href="#l42.83"></a><span id="l42.83" class="difflineminus">- */</span>
<a href="#l42.84"></a><span id="l42.84" class="difflineminus">-function ddumpObject(obj, name, maxDepth, curDepth)</span>
<a href="#l42.85"></a><span id="l42.85" class="difflineminus">-{</span>
<a href="#l42.86"></a><span id="l42.86" class="difflineminus">-  if (curDepth == undefined)</span>
<a href="#l42.87"></a><span id="l42.87" class="difflineminus">-    curDepth = 0;</span>
<a href="#l42.88"></a><span id="l42.88" class="difflineminus">-  if (maxDepth != undefined &amp;&amp; curDepth &gt; maxDepth)</span>
<a href="#l42.89"></a><span id="l42.89" class="difflineminus">-    return;</span>
<a href="#l42.90"></a><span id="l42.90" class="difflineminus">-</span>
<a href="#l42.91"></a><span id="l42.91" class="difflineminus">-  var i = 0;</span>
<a href="#l42.92"></a><span id="l42.92" class="difflineminus">-  for (prop in obj)</span>
<a href="#l42.93"></a><span id="l42.93" class="difflineminus">-  {</span>
<a href="#l42.94"></a><span id="l42.94" class="difflineminus">-    i++;</span>
<a href="#l42.95"></a><span id="l42.95" class="difflineminus">-    try {</span>
<a href="#l42.96"></a><span id="l42.96" class="difflineminus">-      if (typeof(obj[prop]) == &quot;object&quot;)</span>
<a href="#l42.97"></a><span id="l42.97" class="difflineminus">-      {</span>
<a href="#l42.98"></a><span id="l42.98" class="difflineminus">-        if (obj[prop] &amp;&amp; obj[prop].length != undefined)</span>
<a href="#l42.99"></a><span id="l42.99" class="difflineminus">-          ddump(name + &quot;.&quot; + prop + &quot;=[probably array, length &quot;</span>
<a href="#l42.100"></a><span id="l42.100" class="difflineminus">-                + obj[prop].length + &quot;]&quot;);</span>
<a href="#l42.101"></a><span id="l42.101" class="difflineminus">-        else</span>
<a href="#l42.102"></a><span id="l42.102" class="difflineminus">-          ddump(name + &quot;.&quot; + prop + &quot;=[&quot; + typeof(obj[prop]) + &quot;] (&quot; +</span>
<a href="#l42.103"></a><span id="l42.103" class="difflineminus">-                obj[prop] + &quot;)&quot;);</span>
<a href="#l42.104"></a><span id="l42.104" class="difflineminus">-        ddumpObject(obj[prop], name + &quot;.&quot; + prop, maxDepth, curDepth+1);</span>
<a href="#l42.105"></a><span id="l42.105" class="difflineminus">-      }</span>
<a href="#l42.106"></a><span id="l42.106" class="difflineminus">-      else if (typeof(obj[prop]) == &quot;function&quot;)</span>
<a href="#l42.107"></a><span id="l42.107" class="difflineminus">-        ddump(name + &quot;.&quot; + prop + &quot;=[function]&quot;);</span>
<a href="#l42.108"></a><span id="l42.108" class="difflineminus">-      else</span>
<a href="#l42.109"></a><span id="l42.109" class="difflineminus">-        ddump(name + &quot;.&quot; + prop + &quot;=&quot; + obj[prop]);</span>
<a href="#l42.110"></a><span id="l42.110" class="difflineminus">-    } catch (e) {</span>
<a href="#l42.111"></a><span id="l42.111" class="difflineminus">-      ddump(name + &quot;.&quot; + prop + &quot;-&gt; Exception(&quot; + e + &quot;)&quot;);</span>
<a href="#l42.112"></a><span id="l42.112" class="difflineminus">-    }</span>
<a href="#l42.113"></a><span id="l42.113" class="difflineminus">-  }</span>
<a href="#l42.114"></a><span id="l42.114" class="difflineminus">-  if (!i)</span>
<a href="#l42.115"></a><span id="l42.115" class="difflineminus">-    ddump(name + &quot; is empty&quot;);</span>
<a href="#l42.116"></a><span id="l42.116" class="difflineminus">-}</span>
<a href="#l42.117"></a><span id="l42.117" class="difflineminus">-/** its kid brother */</span>
<a href="#l42.118"></a><span id="l42.118" class="difflineminus">-function ddump(text)</span>
<a href="#l42.119"></a><span id="l42.119" class="difflineminus">-{</span>
<a href="#l42.120"></a><span id="l42.120" class="difflineminus">-    dump(text + &quot;\n&quot;);</span>
<a href="#l42.121"></a><span id="l42.121" class="difflineminus">-}</span>
<a href="#l42.122"></a><span id="l42.122" class="difflineminus">-</span>
<a href="#l42.123"></a><span id="l42.123" class="difflineminus">-function dumpExc(e, message) {</span>
<a href="#l42.124"></a><span id="l42.124" class="difflineminus">-  var objDump = getObjectTree(e,1);</span>
<a href="#l42.125"></a><span id="l42.125" class="difflineminus">-  if (typeof(e) == 'object' &amp;&amp; 'stack' in e)</span>
<a href="#l42.126"></a><span id="l42.126" class="difflineminus">-      objDump += e.stack;</span>
<a href="#l42.127"></a><span id="l42.127" class="difflineminus">-  if (typeof(message)=='undefined' || !message)</span>
<a href="#l42.128"></a><span id="l42.128" class="difflineminus">-      message='';</span>
<a href="#l42.129"></a><span id="l42.129" class="difflineminus">-  dump(message+'\n-- EXCEPTION START --\n'+objDump+'-- EXCEPTION END --\n');</span>
<a href="#l42.130"></a><span id="l42.130" class="difflineminus">-}</span>
<a href="#l42.131"></a><span id="l42.131" class="difflineminus">-</span>
<a href="#l42.132"></a><span id="l42.132" class="difflineminus">-function getObjectTree(o, recurse, compress, level)</span>
<a href="#l42.133"></a><span id="l42.133" class="difflineminus">-{</span>
<a href="#l42.134"></a><span id="l42.134" class="difflineminus">-    var s = &quot;&quot;;</span>
<a href="#l42.135"></a><span id="l42.135" class="difflineminus">-    var pfx = &quot;&quot;;</span>
<a href="#l42.136"></a><span id="l42.136" class="difflineminus">-</span>
<a href="#l42.137"></a><span id="l42.137" class="difflineminus">-    if (typeof recurse == &quot;undefined&quot;)</span>
<a href="#l42.138"></a><span id="l42.138" class="difflineminus">-        recurse = 0;</span>
<a href="#l42.139"></a><span id="l42.139" class="difflineminus">-    if (typeof level == &quot;undefined&quot;)</span>
<a href="#l42.140"></a><span id="l42.140" class="difflineminus">-        level = 0;</span>
<a href="#l42.141"></a><span id="l42.141" class="difflineminus">-    if (typeof compress == &quot;undefined&quot;)</span>
<a href="#l42.142"></a><span id="l42.142" class="difflineminus">-        compress = true;</span>
<a href="#l42.143"></a><span id="l42.143" class="difflineminus">-</span>
<a href="#l42.144"></a><span id="l42.144" class="difflineminus">-    for (var i = 0; i &lt; level; i++)</span>
<a href="#l42.145"></a><span id="l42.145" class="difflineminus">-        pfx += (compress) ? &quot;| &quot; : &quot;|  &quot;;</span>
<a href="#l42.146"></a><span id="l42.146" class="difflineminus">-</span>
<a href="#l42.147"></a><span id="l42.147" class="difflineminus">-    var tee = (compress) ? &quot;+ &quot; : &quot;+- &quot;;</span>
<a href="#l42.148"></a><span id="l42.148" class="difflineplus">+// index_msg does not export this, so we need to provide it.</span>
<a href="#l42.149"></a><span id="l42.149" class="difflineplus">+const GLODA_BAD_MESSAGE_ID = 1;</span>
<a href="#l42.150"></a><span id="l42.150"> </span>
<a href="#l42.151"></a><span id="l42.151" class="difflineminus">-    if (typeof(o) != 'object') {</span>
<a href="#l42.152"></a><span id="l42.152" class="difflineminus">-        s += pfx + tee + i + &quot; (&quot; + typeof(o) + &quot;) &quot; + o + &quot;\n&quot;;</span>
<a href="#l42.153"></a><span id="l42.153" class="difflineminus">-    } else</span>
<a href="#l42.154"></a><span id="l42.154" class="difflineminus">-    for (i in o)</span>
<a href="#l42.155"></a><span id="l42.155" class="difflineminus">-    {</span>
<a href="#l42.156"></a><span id="l42.156" class="difflineminus">-        var t;</span>
<a href="#l42.157"></a><span id="l42.157" class="difflineminus">-        try</span>
<a href="#l42.158"></a><span id="l42.158" class="difflineminus">-        {</span>
<a href="#l42.159"></a><span id="l42.159" class="difflineminus">-            t = typeof o[i];</span>
<a href="#l42.160"></a><span id="l42.160" class="difflineminus">-</span>
<a href="#l42.161"></a><span id="l42.161" class="difflineminus">-            switch (t)</span>
<a href="#l42.162"></a><span id="l42.162" class="difflineminus">-            {</span>
<a href="#l42.163"></a><span id="l42.163" class="difflineminus">-                case &quot;function&quot;:</span>
<a href="#l42.164"></a><span id="l42.164" class="difflineminus">-                    var sfunc = String(o[i]).split(&quot;\n&quot;);</span>
<a href="#l42.165"></a><span id="l42.165" class="difflineminus">-                    if (sfunc[2] == &quot;    [native code]&quot;)</span>
<a href="#l42.166"></a><span id="l42.166" class="difflineminus">-                        sfunc = &quot;[native code]&quot;;</span>
<a href="#l42.167"></a><span id="l42.167" class="difflineminus">-                    else</span>
<a href="#l42.168"></a><span id="l42.168" class="difflineminus">-                        sfunc = sfunc.length + &quot; lines&quot;;</span>
<a href="#l42.169"></a><span id="l42.169" class="difflineminus">-                    s += pfx + tee + i + &quot; (function) &quot; + sfunc + &quot;\n&quot;;</span>
<a href="#l42.170"></a><span id="l42.170" class="difflineminus">-                    break;</span>
<a href="#l42.171"></a><span id="l42.171" class="difflineminus">-</span>
<a href="#l42.172"></a><span id="l42.172" class="difflineminus">-                case &quot;object&quot;:</span>
<a href="#l42.173"></a><span id="l42.173" class="difflineminus">-                    s += pfx + tee + i + &quot; (object) &quot; + o[i] + &quot;\n&quot;;</span>
<a href="#l42.174"></a><span id="l42.174" class="difflineminus">-                    if (!compress)</span>
<a href="#l42.175"></a><span id="l42.175" class="difflineminus">-                        s += pfx + &quot;|\n&quot;;</span>
<a href="#l42.176"></a><span id="l42.176" class="difflineminus">-                    if ((i != &quot;parent&quot;) &amp;&amp; (recurse))</span>
<a href="#l42.177"></a><span id="l42.177" class="difflineminus">-                        s += getObjectTree(o[i], recurse - 1,</span>
<a href="#l42.178"></a><span id="l42.178" class="difflineminus">-                                             compress, level + 1);</span>
<a href="#l42.179"></a><span id="l42.179" class="difflineminus">-                    break;</span>
<a href="#l42.180"></a><span id="l42.180" class="difflineminus">-</span>
<a href="#l42.181"></a><span id="l42.181" class="difflineminus">-                case &quot;string&quot;:</span>
<a href="#l42.182"></a><span id="l42.182" class="difflineminus">-                    if (o[i].length &gt; 200)</span>
<a href="#l42.183"></a><span id="l42.183" class="difflineminus">-                        s += pfx + tee + i + &quot; (&quot; + t + &quot;) &quot; +</span>
<a href="#l42.184"></a><span id="l42.184" class="difflineminus">-                            o[i].length + &quot; chars\n&quot;;</span>
<a href="#l42.185"></a><span id="l42.185" class="difflineminus">-                    else</span>
<a href="#l42.186"></a><span id="l42.186" class="difflineminus">-                        s += pfx + tee + i + &quot; (&quot; + t + &quot;) '&quot; + o[i] + &quot;'\n&quot;;</span>
<a href="#l42.187"></a><span id="l42.187" class="difflineminus">-                    break;</span>
<a href="#l42.188"></a><span id="l42.188" class="difflineplus">+function _prepareIndexerForTesting() {</span>
<a href="#l42.189"></a><span id="l42.189" class="difflineplus">+  if (!GlodaIndexer.enabled)</span>
<a href="#l42.190"></a><span id="l42.190" class="difflineplus">+    do_throw(&quot;The gloda indexer is somehow not enabled.  This is problematic.&quot;);</span>
<a href="#l42.191"></a><span id="l42.191"> </span>
<a href="#l42.192"></a><span id="l42.192" class="difflineminus">-                default:</span>
<a href="#l42.193"></a><span id="l42.193" class="difflineminus">-                    s += pfx + tee + i + &quot; (&quot; + t + &quot;) &quot; + o[i] + &quot;\n&quot;;</span>
<a href="#l42.194"></a><span id="l42.194" class="difflineminus">-            }</span>
<a href="#l42.195"></a><span id="l42.195" class="difflineminus">-        }</span>
<a href="#l42.196"></a><span id="l42.196" class="difflineminus">-        catch (ex)</span>
<a href="#l42.197"></a><span id="l42.197" class="difflineminus">-        {</span>
<a href="#l42.198"></a><span id="l42.198" class="difflineminus">-            s += pfx + tee + i + &quot; (exception) &quot; + ex + &quot;\n&quot;;</span>
<a href="#l42.199"></a><span id="l42.199" class="difflineminus">-        }</span>
<a href="#l42.200"></a><span id="l42.200" class="difflineminus">-</span>
<a href="#l42.201"></a><span id="l42.201" class="difflineminus">-        if (!compress)</span>
<a href="#l42.202"></a><span id="l42.202" class="difflineminus">-            s += pfx + &quot;|\n&quot;;</span>
<a href="#l42.203"></a><span id="l42.203" class="difflineminus">-</span>
<a href="#l42.204"></a><span id="l42.204" class="difflineminus">-    }</span>
<a href="#l42.205"></a><span id="l42.205" class="difflineminus">-</span>
<a href="#l42.206"></a><span id="l42.206" class="difflineminus">-    s += pfx + &quot;*\n&quot;;</span>
<a href="#l42.207"></a><span id="l42.207" class="difflineminus">-</span>
<a href="#l42.208"></a><span id="l42.208" class="difflineminus">-    return s;</span>
<a href="#l42.209"></a><span id="l42.209" class="difflineminus">-}</span>
<a href="#l42.210"></a><span id="l42.210" class="difflineminus">-</span>
<a href="#l42.211"></a><span id="l42.211" class="difflineplus">+  // Make the indexer be more verbose about indexing for us...</span>
<a href="#l42.212"></a><span id="l42.212" class="difflineplus">+  GlodaIndexer._unitTestSuperVerbose = true;</span>
<a href="#l42.213"></a><span id="l42.213" class="difflineplus">+  GlodaMsgIndexer._unitTestSuperVerbose = true;</span>
<a href="#l42.214"></a><span id="l42.214"> </span>
<a href="#l42.215"></a><span id="l42.215" class="difflineminus">-/**</span>
<a href="#l42.216"></a><span id="l42.216" class="difflineminus">- * Inject messages using a POP3 fake-server.</span>
<a href="#l42.217"></a><span id="l42.217" class="difflineminus">- *</span>
<a href="#l42.218"></a><span id="l42.218" class="difflineminus">- * @deprecated because the fake-server sometimes does something crazy and we</span>
<a href="#l42.219"></a><span id="l42.219" class="difflineminus">- *     never really needed it anyways.  I just didn't know about the local</span>
<a href="#l42.220"></a><span id="l42.220" class="difflineminus">- *     folder addMessage method.  (so sad!)</span>
<a href="#l42.221"></a><span id="l42.221" class="difflineminus">- */</span>
<a href="#l42.222"></a><span id="l42.222" class="difflineminus">-const INJECT_FAKE_SERVER = 1;</span>
<a href="#l42.223"></a><span id="l42.223" class="difflineminus">-/** Inject messages using freshly created mboxes. */</span>
<a href="#l42.224"></a><span id="l42.224" class="difflineminus">-const INJECT_MBOX = 2;</span>
<a href="#l42.225"></a><span id="l42.225" class="difflineminus">-/** Inject messages using addMessage. */</span>
<a href="#l42.226"></a><span id="l42.226" class="difflineminus">-const INJECT_ADDMESSAGE = 3;</span>
<a href="#l42.227"></a><span id="l42.227" class="difflineminus">-/** Inject messages using the IMAP fakeserver. */</span>
<a href="#l42.228"></a><span id="l42.228" class="difflineminus">-const INJECT_IMAP_FAKE_SERVER = 4;</span>
<a href="#l42.229"></a><span id="l42.229" class="difflineminus">-</span>
<a href="#l42.230"></a><span id="l42.230" class="difflineminus">-/**</span>
<a href="#l42.231"></a><span id="l42.231" class="difflineminus">- * Convert a list of synthetic messages to a form appropriate to feed to the</span>
<a href="#l42.232"></a><span id="l42.232" class="difflineminus">- *  POP3 fakeserver.</span>
<a href="#l42.233"></a><span id="l42.233" class="difflineminus">- */</span>
<a href="#l42.234"></a><span id="l42.234" class="difflineminus">-function _synthMessagesToFakeRep(aSynthMessages) {</span>
<a href="#l42.235"></a><span id="l42.235" class="difflineminus">-  return [{fileData: msg.toMessageString(), size: -1} for each</span>
<a href="#l42.236"></a><span id="l42.236" class="difflineminus">-          (msg in aSynthMessages)];</span>
<a href="#l42.237"></a><span id="l42.237" class="difflineminus">-}</span>
<a href="#l42.238"></a><span id="l42.238" class="difflineminus">-</span>
<a href="#l42.239"></a><span id="l42.239" class="difflineminus">-function prepareIndexerForTesting() {</span>
<a href="#l42.240"></a><span id="l42.240">   // -- Lobotomize the adaptive indexer</span>
<a href="#l42.241"></a><span id="l42.241">   // The indexer doesn't need to worry about load; zero his rescheduling time.</span>
<a href="#l42.242"></a><span id="l42.242">   GlodaIndexer._INDEX_INTERVAL = 0;</span>
<a href="#l42.243"></a><span id="l42.243"> </span>
<a href="#l42.244"></a><span id="l42.244">   let realIdleService = GlodaIndexer._idleService;</span>
<a href="#l42.245"></a><span id="l42.245">   // pretend we are always idle</span>
<a href="#l42.246"></a><span id="l42.246">   GlodaIndexer._idleService = {</span>
<a href="#l42.247"></a><span id="l42.247">     idleTime: 1000,</span>
<a href="#l42.248"></a><span id="l42.248">     addIdleObserver: function() {</span>
<a href="#l42.249"></a><span id="l42.249">       realIdleService.addIdleObserver.apply(realIdleService, arguments);</span>
<a href="#l42.250"></a><span id="l42.250">     },</span>
<a href="#l42.251"></a><span id="l42.251">     removeIdleObserver: function() {</span>
<a href="#l42.252"></a><span id="l42.252">       realIdleService.removeIdleObserver.apply(realIdleService, arguments);</span>
<a href="#l42.253"></a><span id="l42.253">     }</span>
<a href="#l42.254"></a><span id="l42.254">   };</span>
<a href="#l42.255"></a><span id="l42.255"> </span>
<a href="#l42.256"></a><span id="l42.256" class="difflineplus">+  // We want the event-driven indexer to always handle indexing and never spill</span>
<a href="#l42.257"></a><span id="l42.257" class="difflineplus">+  //  to an indexing sweep unless a test intentionally does so.</span>
<a href="#l42.258"></a><span id="l42.258" class="difflineplus">+  GlodaIndexer._indexMaxEventQueueMessages = 10000;</span>
<a href="#l42.259"></a><span id="l42.259" class="difflineplus">+</span>
<a href="#l42.260"></a><span id="l42.260">   // Lobotomize the adaptive indexer</span>
<a href="#l42.261"></a><span id="l42.261">   GlodaIndexer._cpuTargetIndexTime = 10000;</span>
<a href="#l42.262"></a><span id="l42.262">   GlodaIndexer._CPU_TARGET_INDEX_TIME_ACTIVE = 10000;</span>
<a href="#l42.263"></a><span id="l42.263">   GlodaIndexer._CPU_TARGET_INDEX_TIME_IDLE = 10000;</span>
<a href="#l42.264"></a><span id="l42.264">   GlodaIndexer._CPU_IS_BUSY_TIME = 10000;</span>
<a href="#l42.265"></a><span id="l42.265">   GlodaIndexer._PAUSE_LATE_IS_BUSY_TIME = 10000;</span>
<a href="#l42.266"></a><span id="l42.266" class="difflineplus">+</span>
<a href="#l42.267"></a><span id="l42.267" class="difflineplus">+  GlodaIndexer._unitTestHookRecover = _indexMessageState._testHookRecover;</span>
<a href="#l42.268"></a><span id="l42.268" class="difflineplus">+  GlodaIndexer._unitTestHookCleanup = _indexMessageState._testHookCleanup;</span>
<a href="#l42.269"></a><span id="l42.269"> }</span>
<a href="#l42.270"></a><span id="l42.270"> </span>
<a href="#l42.271"></a><span id="l42.271" class="difflineminus">-function imsInit() {</span>
<a href="#l42.272"></a><span id="l42.272" class="difflineminus">-  dump(&quot;Initializing index message state\n&quot;);</span>
<a href="#l42.273"></a><span id="l42.273" class="difflineminus">-  let ims = indexMessageState;</span>
<a href="#l42.274"></a><span id="l42.274" class="difflineminus">-</span>
<a href="#l42.275"></a><span id="l42.275" class="difflineminus">-  if (!ims.inited) {</span>
<a href="#l42.276"></a><span id="l42.276" class="difflineminus">-    // Disable new mail notifications</span>
<a href="#l42.277"></a><span id="l42.277" class="difflineminus">-    var prefSvc = Components.classes[&quot;@mozilla.org/preferences-service;1&quot;]</span>
<a href="#l42.278"></a><span id="l42.278" class="difflineminus">-      .getService(Components.interfaces.nsIPrefBranch);</span>
<a href="#l42.279"></a><span id="l42.279" class="difflineminus">-</span>
<a href="#l42.280"></a><span id="l42.280" class="difflineminus">-    prefSvc.setBoolPref(&quot;mail.biff.play_sound&quot;, false);</span>
<a href="#l42.281"></a><span id="l42.281" class="difflineminus">-    prefSvc.setBoolPref(&quot;mail.biff.show_alert&quot;, false);</span>
<a href="#l42.282"></a><span id="l42.282" class="difflineminus">-    prefSvc.setBoolPref(&quot;mail.biff.show_tray_icon&quot;, false);</span>
<a href="#l42.283"></a><span id="l42.283" class="difflineminus">-    prefSvc.setBoolPref(&quot;mail.biff.animate_dock_icon&quot;, false);</span>
<a href="#l42.284"></a><span id="l42.284" class="difflineminus">-</span>
<a href="#l42.285"></a><span id="l42.285" class="difflineminus">-    // -- Get indexing events</span>
<a href="#l42.286"></a><span id="l42.286" class="difflineminus">-    Gloda.addIndexerListener(messageIndexerListener.onIndexNotification);</span>
<a href="#l42.287"></a><span id="l42.287" class="difflineminus">-    ims.catchAllCollection = Gloda._wildcardCollection(Gloda.NOUN_MESSAGE);</span>
<a href="#l42.288"></a><span id="l42.288" class="difflineminus">-    ims.catchAllCollection.listener = messageCollectionListener;</span>
<a href="#l42.289"></a><span id="l42.289" class="difflineminus">-</span>
<a href="#l42.290"></a><span id="l42.290" class="difflineminus">-    // Make the indexer be more verbose about indexing for us...</span>
<a href="#l42.291"></a><span id="l42.291" class="difflineminus">-    GlodaIndexer._unitTestSuperVerbose = true;</span>
<a href="#l42.292"></a><span id="l42.292" class="difflineminus">-</span>
<a href="#l42.293"></a><span id="l42.293" class="difflineminus">-    prepareIndexerForTesting();</span>
<a href="#l42.294"></a><span id="l42.294" class="difflineminus">-</span>
<a href="#l42.295"></a><span id="l42.295" class="difflineminus">-    if (ims.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l42.296"></a><span id="l42.296" class="difflineminus">-      // -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l42.297"></a><span id="l42.297" class="difflineminus">-      load(&quot;../../test_mailnewslocal/unit/head_maillocal.js&quot;);</span>
<a href="#l42.298"></a><span id="l42.298" class="difflineminus">-      // set up POP3 fakeserver to feed things in...</span>
<a href="#l42.299"></a><span id="l42.299" class="difflineminus">-      [ims.daemon, ims.server] = setupServerDaemon();</span>
<a href="#l42.300"></a><span id="l42.300" class="difflineminus">-      // (this will call loadLocalMailAccount())</span>
<a href="#l42.301"></a><span id="l42.301" class="difflineminus">-      ims.incomingServer = createPop3ServerAndLocalFolders();</span>
<a href="#l42.302"></a><span id="l42.302" class="difflineplus">+const _wait_for_gloda_indexer_defaults = {</span>
<a href="#l42.303"></a><span id="l42.303" class="difflineplus">+  verifier: null,</span>
<a href="#l42.304"></a><span id="l42.304" class="difflineplus">+  augment: false,</span>
<a href="#l42.305"></a><span id="l42.305" class="difflineplus">+  deleted: null,</span>
<a href="#l42.306"></a><span id="l42.306"> </span>
<a href="#l42.307"></a><span id="l42.307" class="difflineminus">-      ims.pop3Service = Cc[&quot;@mozilla.org/messenger/popservice;1&quot;]</span>
<a href="#l42.308"></a><span id="l42.308" class="difflineminus">-                          .getService(Ci.nsIPop3Service);</span>
<a href="#l42.309"></a><span id="l42.309" class="difflineminus">-    }</span>
<a href="#l42.310"></a><span id="l42.310" class="difflineminus">-    else if (ims.injectMechanism == INJECT_MBOX) {</span>
<a href="#l42.311"></a><span id="l42.311" class="difflineminus">-      // we need a local account to stash the mboxes under.</span>
<a href="#l42.312"></a><span id="l42.312" class="difflineminus">-      loadLocalMailAccount();</span>
<a href="#l42.313"></a><span id="l42.313" class="difflineminus">-    }</span>
<a href="#l42.314"></a><span id="l42.314" class="difflineminus">-    else if (ims.injectMechanism == INJECT_ADDMESSAGE) {</span>
<a href="#l42.315"></a><span id="l42.315" class="difflineminus">-      // we need an inbox</span>
<a href="#l42.316"></a><span id="l42.316" class="difflineminus">-      loadLocalMailAccount();</span>
<a href="#l42.317"></a><span id="l42.317" class="difflineminus">-    }</span>
<a href="#l42.318"></a><span id="l42.318" class="difflineminus">-    else if (ims.injectMechanism == INJECT_IMAP_FAKE_SERVER) {</span>
<a href="#l42.319"></a><span id="l42.319" class="difflineminus">-      // Pull in the IMAP fake server code</span>
<a href="#l42.320"></a><span id="l42.320" class="difflineminus">-      load(&quot;../../test_imap/unit/head_server.js&quot;);</span>
<a href="#l42.321"></a><span id="l42.321" class="difflineminus">-</span>
<a href="#l42.322"></a><span id="l42.322" class="difflineminus">-      // set up IMAP fakeserver and incoming server</span>
<a href="#l42.323"></a><span id="l42.323" class="difflineminus">-      ims.daemon = new imapDaemon();</span>
<a href="#l42.324"></a><span id="l42.324" class="difflineminus">-      ims.server = makeServer(ims.daemon, &quot;&quot;);</span>
<a href="#l42.325"></a><span id="l42.325" class="difflineminus">-      ims.incomingServer = createLocalIMAPServer();</span>
<a href="#l42.326"></a><span id="l42.326" class="difflineminus">-      // we need a local account for the IMAP server to have its sent messages in</span>
<a href="#l42.327"></a><span id="l42.327" class="difflineminus">-      loadLocalMailAccount();</span>
<a href="#l42.328"></a><span id="l42.328" class="difflineminus">-</span>
<a href="#l42.329"></a><span id="l42.329" class="difflineminus">-      // We need an identity so that updateFolder doesn't fail</span>
<a href="#l42.330"></a><span id="l42.330" class="difflineminus">-      let acctMgr = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;]</span>
<a href="#l42.331"></a><span id="l42.331" class="difflineminus">-                      .getService(Ci.nsIMsgAccountManager);</span>
<a href="#l42.332"></a><span id="l42.332" class="difflineminus">-      let localAccount = acctMgr.createAccount();</span>
<a href="#l42.333"></a><span id="l42.333" class="difflineminus">-      let identity = acctMgr.createIdentity();</span>
<a href="#l42.334"></a><span id="l42.334" class="difflineminus">-      localAccount.addIdentity(identity);</span>
<a href="#l42.335"></a><span id="l42.335" class="difflineminus">-      localAccount.defaultIdentity = identity;</span>
<a href="#l42.336"></a><span id="l42.336" class="difflineminus">-      localAccount.incomingServer = gLocalIncomingServer;</span>
<a href="#l42.337"></a><span id="l42.337" class="difflineminus">-      acctMgr.defaultAccount = localAccount;</span>
<a href="#l42.338"></a><span id="l42.338" class="difflineminus">-</span>
<a href="#l42.339"></a><span id="l42.339" class="difflineminus">-      // Let's also have another account, using the same identity</span>
<a href="#l42.340"></a><span id="l42.340" class="difflineminus">-      let imapAccount = acctMgr.createAccount();</span>
<a href="#l42.341"></a><span id="l42.341" class="difflineminus">-      imapAccount.addIdentity(identity);</span>
<a href="#l42.342"></a><span id="l42.342" class="difflineminus">-      imapAccount.defaultIdentity = identity;</span>
<a href="#l42.343"></a><span id="l42.343" class="difflineminus">-      imapAccount.incomingServer = ims.incomingServer;</span>
<a href="#l42.344"></a><span id="l42.344" class="difflineminus">-</span>
<a href="#l42.345"></a><span id="l42.345" class="difflineminus">-      // The server doesn't support more than one connection</span>
<a href="#l42.346"></a><span id="l42.346" class="difflineminus">-      prefSvc.setIntPref(&quot;mail.server.server1.max_cached_connections&quot;, 1);</span>
<a href="#l42.347"></a><span id="l42.347" class="difflineminus">-      // We aren't interested in downloading messages automatically</span>
<a href="#l42.348"></a><span id="l42.348" class="difflineminus">-      prefSvc.setBoolPref(&quot;mail.server.server1.download_on_biff&quot;, false);</span>
<a href="#l42.349"></a><span id="l42.349" class="difflineminus">-</span>
<a href="#l42.350"></a><span id="l42.350" class="difflineminus">-      // Set the inbox to not be offline</span>
<a href="#l42.351"></a><span id="l42.351" class="difflineminus">-      ims.imapInbox = ims.incomingServer.rootFolder.getChildNamed(&quot;Inbox&quot;);</span>
<a href="#l42.352"></a><span id="l42.352" class="difflineminus">-      ims.imapInbox.flags &amp;= ~Ci.nsMsgFolderFlags.Offline;</span>
<a href="#l42.353"></a><span id="l42.353" class="difflineminus">-    }</span>
<a href="#l42.354"></a><span id="l42.354" class="difflineminus">-</span>
<a href="#l42.355"></a><span id="l42.355" class="difflineminus">-    ims.inited = true;</span>
<a href="#l42.356"></a><span id="l42.356" class="difflineminus">-  }</span>
<a href="#l42.357"></a><span id="l42.357" class="difflineminus">-}</span>
<a href="#l42.358"></a><span id="l42.358" class="difflineplus">+  // Things should not be recovering or failing and cleaning up unless the test</span>
<a href="#l42.359"></a><span id="l42.359" class="difflineplus">+  //  is expecting it.</span>
<a href="#l42.360"></a><span id="l42.360" class="difflineplus">+  recovered: 0,</span>
<a href="#l42.361"></a><span id="l42.361" class="difflineplus">+  failedToRecover: 0,</span>
<a href="#l42.362"></a><span id="l42.362" class="difflineplus">+  cleanedUp: 0,</span>
<a href="#l42.363"></a><span id="l42.363" class="difflineplus">+  hadNoCleanUp: 0,</span>
<a href="#l42.364"></a><span id="l42.364" class="difflineplus">+};</span>
<a href="#l42.365"></a><span id="l42.365"> </span>
<a href="#l42.366"></a><span id="l42.366"> /**</span>
<a href="#l42.367"></a><span id="l42.367" class="difflineminus">- * Have gloda index the given synthetic messages, calling the verifier function</span>
<a href="#l42.368"></a><span id="l42.368" class="difflineminus">- *  (with accumulator field) once the message has been succesfully indexed.</span>
<a href="#l42.369"></a><span id="l42.369" class="difflineplus">+ * Wait for the gloda indexer to finish indexing.  When it has finished,</span>
<a href="#l42.370"></a><span id="l42.370" class="difflineplus">+ *  assert that the set of messages indexed is exactly the set passed in.</span>
<a href="#l42.371"></a><span id="l42.371" class="difflineplus">+ *  If a verification function is provided, use it on a per-message basis</span>
<a href="#l42.372"></a><span id="l42.372" class="difflineplus">+ *  to make sure the resulting gloda message looks like it should given the</span>
<a href="#l42.373"></a><span id="l42.373" class="difflineplus">+ *  synthetic message.</span>
<a href="#l42.374"></a><span id="l42.374">  *</span>
<a href="#l42.375"></a><span id="l42.375" class="difflineminus">- * We use two mechanisms to do this.  One: we create an open-ended message</span>
<a href="#l42.376"></a><span id="l42.376" class="difflineminus">- *  collection that gets notified whenever a new message hits the scene.  Two:</span>
<a href="#l42.377"></a><span id="l42.377" class="difflineminus">- *  we register as a notification listener so that we might know when indexing</span>
<a href="#l42.378"></a><span id="l42.378" class="difflineminus">- *  has completed.</span>
<a href="#l42.379"></a><span id="l42.379" class="difflineplus">+ * Note that if the indexer is not currently active we assume it has already</span>
<a href="#l42.380"></a><span id="l42.380" class="difflineplus">+ *  completed; we do not entertain the possibility that it has not yet started.</span>
<a href="#l42.381"></a><span id="l42.381" class="difflineplus">+ *  Since the indexer is 'active' as soon as it sees an event, this does mean</span>
<a href="#l42.382"></a><span id="l42.382" class="difflineplus">+ *  that you need to wait to make sure the indexing event has happened before</span>
<a href="#l42.383"></a><span id="l42.383" class="difflineplus">+ *  calling us.  This is reasonable.</span>
<a href="#l42.384"></a><span id="l42.384">  *</span>
<a href="#l42.385"></a><span id="l42.385" class="difflineminus">- * @param aSynthMessages The synthetic messages to introduce to a folder,</span>
<a href="#l42.386"></a><span id="l42.386" class="difflineminus">- *     resulting in gloda indexing them.</span>
<a href="#l42.387"></a><span id="l42.387" class="difflineminus">- * @param aVerifier The function to call to verify that the indexing had the</span>
<a href="#l42.388"></a><span id="l42.388" class="difflineminus">- *     desired result.  Takes arguments aSynthMessage (the synthetic message</span>
<a href="#l42.389"></a><span id="l42.389" class="difflineminus">- *     just indexed), aGlodaMessage (the gloda message representation of the</span>
<a href="#l42.390"></a><span id="l42.390" class="difflineminus">- *     indexed message), and aPreviousResult (the value last returned by the</span>
<a href="#l42.391"></a><span id="l42.391" class="difflineplus">+ * @param aSynMessageSets A single SyntheticMessageSet or list of</span>
<a href="#l42.392"></a><span id="l42.392" class="difflineplus">+ *     SyntheticMessageSets containing exactly the messages we should expect to</span>
<a href="#l42.393"></a><span id="l42.393" class="difflineplus">+ *     see.</span>
<a href="#l42.394"></a><span id="l42.394" class="difflineplus">+ * @param [aConfig.verifier] The function to call to verify that the indexing</span>
<a href="#l42.395"></a><span id="l42.395" class="difflineplus">+ *     had the desired result.  Takes arguments aSynthMessage (the synthetic</span>
<a href="#l42.396"></a><span id="l42.396" class="difflineplus">+ *     message just indexed), aGlodaMessage (the gloda message representation of</span>
<a href="#l42.397"></a><span id="l42.397" class="difflineplus">+ *     the indexed message), and aPreviousResult (the value last returned by the</span>
<a href="#l42.398"></a><span id="l42.398">  *     verifier function for this given set of messages, or undefined if it is</span>
<a href="#l42.399"></a><span id="l42.399">  *     the first message.)</span>
<a href="#l42.400"></a><span id="l42.400" class="difflineminus">- * @param aOnDone The function to call when we complete processing this set of</span>
<a href="#l42.401"></a><span id="l42.401" class="difflineminus">- *     messages.</span>
<a href="#l42.402"></a><span id="l42.402" class="difflineplus">+ * @param [aConfig.augment=false] Should we augment the synthetic message sets</span>
<a href="#l42.403"></a><span id="l42.403" class="difflineplus">+ *     with references to their corresponding gloda messages?  The messages</span>
<a href="#l42.404"></a><span id="l42.404" class="difflineplus">+ *     will show up in a 'glodaMessages' list on the syn set.</span>
<a href="#l42.405"></a><span id="l42.405" class="difflineplus">+ * @param [aConfig.deleted] A single SyntheticMessageSet or list of them</span>
<a href="#l42.406"></a><span id="l42.406" class="difflineplus">+ *     containing messages that should be recognized as deleted by the gloda</span>
<a href="#l42.407"></a><span id="l42.407" class="difflineplus">+ *     indexer in this pass.</span>
<a href="#l42.408"></a><span id="l42.408">  */</span>
<a href="#l42.409"></a><span id="l42.409" class="difflineminus">-function indexMessages(aSynthMessages, aVerifier, aOnDone) {</span>
<a href="#l42.410"></a><span id="l42.410" class="difflineminus">-  let ims = indexMessageState;</span>
<a href="#l42.411"></a><span id="l42.411" class="difflineminus">-  ims.expectMessages(aSynthMessages, aVerifier, aOnDone);</span>
<a href="#l42.412"></a><span id="l42.412" class="difflineplus">+function wait_for_gloda_indexer(aSynMessageSets, aConfig) {</span>
<a href="#l42.413"></a><span id="l42.413" class="difflineplus">+  let ims = _indexMessageState;</span>
<a href="#l42.414"></a><span id="l42.414"> </span>
<a href="#l42.415"></a><span id="l42.415" class="difflineminus">-  if (ims.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l42.416"></a><span id="l42.416" class="difflineminus">-    ims.daemon.setMessages(_synthMessagesToFakeRep(aSynthMessages));</span>
<a href="#l42.417"></a><span id="l42.417" class="difflineminus">-    do_timeout(0, &quot;drivePOP3FakeServer();&quot;);</span>
<a href="#l42.418"></a><span id="l42.418" class="difflineminus">-  }</span>
<a href="#l42.419"></a><span id="l42.419" class="difflineminus">-  else if (ims.injectMechanism == INJECT_MBOX) {</span>
<a href="#l42.420"></a><span id="l42.420" class="difflineminus">-    ims.mboxName = &quot;injecty&quot; + ims.nextMboxNumber++;</span>
<a href="#l42.421"></a><span id="l42.421" class="difflineminus">-    writeMessagesToMbox(aSynthMessages, gProfileDir,</span>
<a href="#l42.422"></a><span id="l42.422" class="difflineminus">-                        &quot;Mail&quot;, &quot;Local Folders&quot;, ims.mboxName);</span>
<a href="#l42.423"></a><span id="l42.423" class="difflineplus">+  if (aSynMessageSets == null)</span>
<a href="#l42.424"></a><span id="l42.424" class="difflineplus">+    aSynMessageSets = [];</span>
<a href="#l42.425"></a><span id="l42.425" class="difflineplus">+  else if (!(&quot;length&quot; in aSynMessageSets))</span>
<a href="#l42.426"></a><span id="l42.426" class="difflineplus">+    aSynMessageSets = [aSynMessageSets];</span>
<a href="#l42.427"></a><span id="l42.427" class="difflineplus">+</span>
<a href="#l42.428"></a><span id="l42.428" class="difflineplus">+  ims.synMessageSets = aSynMessageSets;</span>
<a href="#l42.429"></a><span id="l42.429"> </span>
<a href="#l42.430"></a><span id="l42.430" class="difflineminus">-    let rootFolder = gLocalIncomingServer.rootMsgFolder;</span>
<a href="#l42.431"></a><span id="l42.431" class="difflineminus">-    let subFolder = rootFolder.addSubfolder(ims.mboxName);</span>
<a href="#l42.432"></a><span id="l42.432" class="difflineminus">-    // we need to explicitly kick off indexing...</span>
<a href="#l42.433"></a><span id="l42.433" class="difflineminus">-    updateFolderAndNotify(subFolder, function() {</span>
<a href="#l42.434"></a><span id="l42.434" class="difflineminus">-      // this flag gets lost for reasons I am not entirely clear on, but gloda</span>
<a href="#l42.435"></a><span id="l42.435" class="difflineminus">-      //  really wants it to be there.</span>
<a href="#l42.436"></a><span id="l42.436" class="difflineminus">-      subFolder.setFlag(Ci.nsMsgFolderFlags.Mail);</span>
<a href="#l42.437"></a><span id="l42.437" class="difflineminus">-      GlodaIndexer.indexFolder(subFolder);</span>
<a href="#l42.438"></a><span id="l42.438" class="difflineminus">-    });</span>
<a href="#l42.439"></a><span id="l42.439" class="difflineminus">-  }</span>
<a href="#l42.440"></a><span id="l42.440" class="difflineminus">-  else if (ims.injectMechanism == INJECT_ADDMESSAGE) {</span>
<a href="#l42.441"></a><span id="l42.441" class="difflineminus">-    let localFolder = gLocalInboxFolder.QueryInterface(Ci.nsIMsgLocalMailFolder);</span>
<a href="#l42.442"></a><span id="l42.442" class="difflineminus">-    for (let [, msg] in Iterator(aSynthMessages)) {</span>
<a href="#l42.443"></a><span id="l42.443" class="difflineminus">-      localFolder.addMessage(msg.toMboxString());</span>
<a href="#l42.444"></a><span id="l42.444" class="difflineminus">-    }</span>
<a href="#l42.445"></a><span id="l42.445" class="difflineplus">+  function get_val(aKey) {</span>
<a href="#l42.446"></a><span id="l42.446" class="difflineplus">+    if (aConfig &amp;&amp; (aKey in aConfig))</span>
<a href="#l42.447"></a><span id="l42.447" class="difflineplus">+      return aConfig[aKey];</span>
<a href="#l42.448"></a><span id="l42.448" class="difflineplus">+    else</span>
<a href="#l42.449"></a><span id="l42.449" class="difflineplus">+      return _wait_for_gloda_indexer_defaults[aKey];</span>
<a href="#l42.450"></a><span id="l42.450">   }</span>
<a href="#l42.451"></a><span id="l42.451" class="difflineminus">-  else if (ims.injectMechanism == INJECT_IMAP_FAKE_SERVER) {</span>
<a href="#l42.452"></a><span id="l42.452" class="difflineminus">-    let ioService = Cc[&quot;@mozilla.org/network/io-service;1&quot;]</span>
<a href="#l42.453"></a><span id="l42.453" class="difflineminus">-                      .getService(Ci.nsIIOService);</span>
<a href="#l42.454"></a><span id="l42.454" class="difflineminus">-    let serverInbox = ims.daemon.getMailbox(&quot;INBOX&quot;);</span>
<a href="#l42.455"></a><span id="l42.455" class="difflineplus">+</span>
<a href="#l42.456"></a><span id="l42.456" class="difflineplus">+  ims.verifier = get_val(&quot;verifier&quot;);</span>
<a href="#l42.457"></a><span id="l42.457" class="difflineplus">+  ims.augmentSynSets = get_val(&quot;augment&quot;);</span>
<a href="#l42.458"></a><span id="l42.458" class="difflineplus">+  ims.deletionSynSets = get_val(&quot;deleted&quot;);</span>
<a href="#l42.459"></a><span id="l42.459" class="difflineplus">+  if (ims.deletionSynSets &amp;&amp; !(&quot;length&quot; in ims.deletionSynSets))</span>
<a href="#l42.460"></a><span id="l42.460" class="difflineplus">+    ims.deletionSynSets = [ims.deletionSynSets];</span>
<a href="#l42.461"></a><span id="l42.461" class="difflineplus">+</span>
<a href="#l42.462"></a><span id="l42.462" class="difflineplus">+  ims.expectedWorkerRecoveredCount = get_val(&quot;recovered&quot;);</span>
<a href="#l42.463"></a><span id="l42.463" class="difflineplus">+  ims.expectedFailedToRecoverCount = get_val(&quot;failedToRecover&quot;);</span>
<a href="#l42.464"></a><span id="l42.464" class="difflineplus">+  ims.expectedCleanedUpCount = get_val(&quot;cleanedUp&quot;);</span>
<a href="#l42.465"></a><span id="l42.465" class="difflineplus">+  ims.expectedHadNoCleanUpCount = get_val(&quot;hadNoCleanUp&quot;);</span>
<a href="#l42.466"></a><span id="l42.466"> </span>
<a href="#l42.467"></a><span id="l42.467" class="difflineminus">-    for (let [, msg] in Iterator(aSynthMessages)) {</span>
<a href="#l42.468"></a><span id="l42.468" class="difflineminus">-      // Generate a URI out of the message</span>
<a href="#l42.469"></a><span id="l42.469" class="difflineminus">-      let URI = ioService.newURI(&quot;data:text/plain;base64,&quot; + btoa(msg.toMessageString()), null, null);</span>
<a href="#l42.470"></a><span id="l42.470" class="difflineminus">-      // Add it to the server</span>
<a href="#l42.471"></a><span id="l42.471" class="difflineminus">-      serverInbox.addMessage(new imapMessage(URI.spec, serverInbox.uidnext++, []));</span>
<a href="#l42.472"></a><span id="l42.472" class="difflineminus">-    }</span>
<a href="#l42.473"></a><span id="l42.473" class="difflineminus">-    // Time to do stuff with the fakeserver</span>
<a href="#l42.474"></a><span id="l42.474" class="difflineminus">-    driveIMAPFakeServer();</span>
<a href="#l42.475"></a><span id="l42.475" class="difflineplus">+  // if we are still indexing, there is nothing to do right now, save off</span>
<a href="#l42.476"></a><span id="l42.476" class="difflineplus">+  //  and rely on the indexing completion state change to trigger things.</span>
<a href="#l42.477"></a><span id="l42.477" class="difflineplus">+  if (GlodaIndexer.indexing) {</span>
<a href="#l42.478"></a><span id="l42.478" class="difflineplus">+    ims.waiting = true;</span>
<a href="#l42.479"></a><span id="l42.479" class="difflineplus">+    mark_action(&quot;glodaTestHelper&quot;, &quot;waiting for indexer asynchronously&quot;, []);</span>
<a href="#l42.480"></a><span id="l42.480" class="difflineplus">+    return false;</span>
<a href="#l42.481"></a><span id="l42.481">   }</span>
<a href="#l42.482"></a><span id="l42.482" class="difflineminus">-}</span>
<a href="#l42.483"></a><span id="l42.483"> </span>
<a href="#l42.484"></a><span id="l42.484" class="difflineminus">-function injectMessagesUsing(aInjectMechanism) {</span>
<a href="#l42.485"></a><span id="l42.485" class="difflineminus">-  indexMessageState.injectMechanism = aInjectMechanism;</span>
<a href="#l42.486"></a><span id="l42.486" class="difflineplus">+  mark_action(&quot;glodaTestHelper&quot;, &quot;indexing believed already completed&quot;, []);</span>
<a href="#l42.487"></a><span id="l42.487" class="difflineplus">+  ims.assertExpectedMessagesIndexed();</span>
<a href="#l42.488"></a><span id="l42.488" class="difflineplus">+  return true;</span>
<a href="#l42.489"></a><span id="l42.489"> }</span>
<a href="#l42.490"></a><span id="l42.490"> </span>
<a href="#l42.491"></a><span id="l42.491" class="difflineminus">-var indexMessageState = {</span>
<a href="#l42.492"></a><span id="l42.492" class="difflineplus">+var _indexMessageState = {</span>
<a href="#l42.493"></a><span id="l42.493">   /** have we been initialized (hooked listeners, etc.) */</span>
<a href="#l42.494"></a><span id="l42.494" class="difflineminus">-  inited: false,</span>
<a href="#l42.495"></a><span id="l42.495" class="difflineminus">-  /** whether we're due for any index notifications */</span>
<a href="#l42.496"></a><span id="l42.496" class="difflineminus">-  expectingIndexNotifications: false,</span>
<a href="#l42.497"></a><span id="l42.497" class="difflineplus">+  _inited: false,</span>
<a href="#l42.498"></a><span id="l42.498" class="difflineplus">+</span>
<a href="#l42.499"></a><span id="l42.499" class="difflineplus">+  _init: function _indexMessageState_init() {</span>
<a href="#l42.500"></a><span id="l42.500" class="difflineplus">+    if (this._inited)</span>
<a href="#l42.501"></a><span id="l42.501" class="difflineplus">+      return;</span>
<a href="#l42.502"></a><span id="l42.502" class="difflineplus">+</span>
<a href="#l42.503"></a><span id="l42.503" class="difflineplus">+    Gloda.addIndexerListener(this.onIndexNotification);</span>
<a href="#l42.504"></a><span id="l42.504" class="difflineplus">+    this.catchAllCollection = Gloda._wildcardCollection(Gloda.NOUN_MESSAGE);</span>
<a href="#l42.505"></a><span id="l42.505" class="difflineplus">+    this.catchAllCollection.listener = this;</span>
<a href="#l42.506"></a><span id="l42.506" class="difflineplus">+</span>
<a href="#l42.507"></a><span id="l42.507" class="difflineplus">+    this._inited = true;</span>
<a href="#l42.508"></a><span id="l42.508" class="difflineplus">+  },</span>
<a href="#l42.509"></a><span id="l42.509" class="difflineplus">+</span>
<a href="#l42.510"></a><span id="l42.510">   /** our catch-all message collection that nets us all messages passing by */</span>
<a href="#l42.511"></a><span id="l42.511">   catchAllCollection: null,</span>
<a href="#l42.512"></a><span id="l42.512" class="difflineminus">-  /** the set of synthetic messages passed in to indexMessages */</span>
<a href="#l42.513"></a><span id="l42.513" class="difflineminus">-  inputMessages: null,</span>
<a href="#l42.514"></a><span id="l42.514" class="difflineminus">-  /** the gloda messages resulting from indexing corresponding to input ones */</span>
<a href="#l42.515"></a><span id="l42.515" class="difflineminus">-  glodaMessages: null,</span>
<a href="#l42.516"></a><span id="l42.516" class="difflineplus">+</span>
<a href="#l42.517"></a><span id="l42.517" class="difflineplus">+  /** the synthetic message sets passed in to |wait_for_gloda_indexer| */</span>
<a href="#l42.518"></a><span id="l42.518" class="difflineplus">+  synMessageSets: null,</span>
<a href="#l42.519"></a><span id="l42.519">   /** the user-specified accumulate-style verification func */</span>
<a href="#l42.520"></a><span id="l42.520">   verifier: null,</span>
<a href="#l42.521"></a><span id="l42.521" class="difflineminus">-  /** the result of the last call to the verification function */</span>
<a href="#l42.522"></a><span id="l42.522" class="difflineminus">-  previousValue: undefined,</span>
<a href="#l42.523"></a><span id="l42.523" class="difflineminus">-  /** the function to call once we have indexed all the messages */</span>
<a href="#l42.524"></a><span id="l42.524" class="difflineminus">-  onDone: null,</span>
<a href="#l42.525"></a><span id="l42.525" class="difflineminus">-</span>
<a href="#l42.526"></a><span id="l42.526" class="difflineminus">-  injectMechanism: INJECT_ADDMESSAGE,</span>
<a href="#l42.527"></a><span id="l42.527" class="difflineplus">+  /** should we augment the synthetic sets with gloda message info? */</span>
<a href="#l42.528"></a><span id="l42.528" class="difflineplus">+  augmentSynSets: false,</span>
<a href="#l42.529"></a><span id="l42.529" class="difflineplus">+  deletionSynSets: null,</span>
<a href="#l42.530"></a><span id="l42.530"> </span>
<a href="#l42.531"></a><span id="l42.531" class="difflineminus">-  /* === Fake Server State === */</span>
<a href="#l42.532"></a><span id="l42.532" class="difflineminus">-  /** nsMailServer instance (if POP3, with POP3_RFC1939 handler) */</span>
<a href="#l42.533"></a><span id="l42.533" class="difflineminus">-  server: null,</span>
<a href="#l42.534"></a><span id="l42.534" class="difflineminus">-  serverStarted: false,</span>
<a href="#l42.535"></a><span id="l42.535" class="difflineminus">-  /** pop3Daemon/imapDaemon instance */</span>
<a href="#l42.536"></a><span id="l42.536" class="difflineminus">-  daemon: null,</span>
<a href="#l42.537"></a><span id="l42.537" class="difflineminus">-  /** incoming pop3/imap server */</span>
<a href="#l42.538"></a><span id="l42.538" class="difflineminus">-  incomingServer: null,</span>
<a href="#l42.539"></a><span id="l42.539" class="difflineminus">-  /** pop3 service (not used for imap) */</span>
<a href="#l42.540"></a><span id="l42.540" class="difflineminus">-  pop3Service: null,</span>
<a href="#l42.541"></a><span id="l42.541" class="difflineminus">-  /** IMAP inbox */</span>
<a href="#l42.542"></a><span id="l42.542" class="difflineminus">-  imapInbox: null,</span>
<a href="#l42.543"></a><span id="l42.543" class="difflineplus">+  /** Expected value of |_workerRecoveredCount| at assertion time */</span>
<a href="#l42.544"></a><span id="l42.544" class="difflineplus">+  expectedWorkerRecoveredCount: null,</span>
<a href="#l42.545"></a><span id="l42.545" class="difflineplus">+  /** Expected value of |_workerFailedToRecoverCount| at assertion time */</span>
<a href="#l42.546"></a><span id="l42.546" class="difflineplus">+  expectedFailedToRecoverCount: null,</span>
<a href="#l42.547"></a><span id="l42.547" class="difflineplus">+  /** Expected value of |_workerCleanedUpCount| at assertion time */</span>
<a href="#l42.548"></a><span id="l42.548" class="difflineplus">+  expectedCleanedUpCount: null,</span>
<a href="#l42.549"></a><span id="l42.549" class="difflineplus">+  /** Expected value of |_workerHadNoCleanUpCount| at assertion time */</span>
<a href="#l42.550"></a><span id="l42.550" class="difflineplus">+  expectedHadNoCleanUpCount: null,</span>
<a href="#l42.551"></a><span id="l42.551"> </span>
<a href="#l42.552"></a><span id="l42.552" class="difflineminus">-  /* === MBox Injection State === */</span>
<a href="#l42.553"></a><span id="l42.553" class="difflineminus">-  nextMboxNumber: 0,</span>
<a href="#l42.554"></a><span id="l42.554" class="difflineminus">-  mboxName: null,</span>
<a href="#l42.555"></a><span id="l42.555" class="difflineminus">-</span>
<a href="#l42.556"></a><span id="l42.556" class="difflineplus">+  /** The number of times a worker had a recover helper and it recovered. */</span>
<a href="#l42.557"></a><span id="l42.557" class="difflineplus">+  _workerRecoveredCount: 0,</span>
<a href="#l42.558"></a><span id="l42.558" class="difflineplus">+  /**</span>
<a href="#l42.559"></a><span id="l42.559" class="difflineplus">+   * The number of times a worker had a recover helper and it did not recover.</span>
<a href="#l42.560"></a><span id="l42.560" class="difflineplus">+   */</span>
<a href="#l42.561"></a><span id="l42.561" class="difflineplus">+  _workerFailedToRecoverCount: 0,</span>
<a href="#l42.562"></a><span id="l42.562" class="difflineplus">+  /**</span>
<a href="#l42.563"></a><span id="l42.563" class="difflineplus">+   * The number of times a worker had a cleanup helper and it cleaned up.</span>
<a href="#l42.564"></a><span id="l42.564" class="difflineplus">+   */</span>
<a href="#l42.565"></a><span id="l42.565" class="difflineplus">+  _workerCleanedUpCount: 0,</span>
<a href="#l42.566"></a><span id="l42.566">   /**</span>
<a href="#l42.567"></a><span id="l42.567" class="difflineminus">-   * Sets up messages to expect index notifications for.</span>
<a href="#l42.568"></a><span id="l42.568" class="difflineminus">-   *</span>
<a href="#l42.569"></a><span id="l42.569" class="difflineminus">-   * @param aSynthMessages The synthetic messages to expect notifications</span>
<a href="#l42.570"></a><span id="l42.570" class="difflineminus">-   *     for. We currently don't do anything with these other than count them,</span>
<a href="#l42.571"></a><span id="l42.571" class="difflineminus">-   *     so pass whatever you want and it will be the 'source message' (1st</span>
<a href="#l42.572"></a><span id="l42.572" class="difflineminus">-   *     argument) to your verifier function.</span>
<a href="#l42.573"></a><span id="l42.573" class="difflineminus">-   * @param aVerifier The function to call to verify that the indexing had the</span>
<a href="#l42.574"></a><span id="l42.574" class="difflineminus">-   *     desired result.  Takes arguments aSynthMessage (the synthetic message</span>
<a href="#l42.575"></a><span id="l42.575" class="difflineminus">-   *     just indexed), aGlodaMessage (the gloda message representation of the</span>
<a href="#l42.576"></a><span id="l42.576" class="difflineminus">-   *     indexed message), and aPreviousResult (the value last returned by the</span>
<a href="#l42.577"></a><span id="l42.577" class="difflineminus">-   *     verifier function for this given set of messages, or undefined if it is</span>
<a href="#l42.578"></a><span id="l42.578" class="difflineminus">-   *     the first message.)</span>
<a href="#l42.579"></a><span id="l42.579" class="difflineminus">-   * @param aOnDone The function to call when we complete processing this set of</span>
<a href="#l42.580"></a><span id="l42.580" class="difflineminus">-   *     messages.</span>
<a href="#l42.581"></a><span id="l42.581" class="difflineplus">+   * The number of times a worker had no cleanup helper but there was a cleanup.</span>
<a href="#l42.582"></a><span id="l42.582">    */</span>
<a href="#l42.583"></a><span id="l42.583" class="difflineminus">-  expectMessages: function indexMessageState_expectMessages(aSynthMessages, aVerifier,</span>
<a href="#l42.584"></a><span id="l42.584" class="difflineminus">-                                                            aOnDone) {</span>
<a href="#l42.585"></a><span id="l42.585" class="difflineminus">-    dump(&quot;^^^ setting up &quot; + aSynthMessages.length + &quot; message(s) to expect\n&quot;);</span>
<a href="#l42.586"></a><span id="l42.586" class="difflineminus">-    this.inputMessages = aSynthMessages;</span>
<a href="#l42.587"></a><span id="l42.587" class="difflineminus">-    this.expectingIndexNotifications = true;</span>
<a href="#l42.588"></a><span id="l42.588" class="difflineminus">-    this.glodaMessages = [];</span>
<a href="#l42.589"></a><span id="l42.589" class="difflineminus">-    this.verifier = aVerifier;</span>
<a href="#l42.590"></a><span id="l42.590" class="difflineminus">-    this.previousValue = undefined;</span>
<a href="#l42.591"></a><span id="l42.591" class="difflineminus">-    this.onDone = aOnDone;</span>
<a href="#l42.592"></a><span id="l42.592" class="difflineplus">+  _workerHadNoCleanUpCount: 0,</span>
<a href="#l42.593"></a><span id="l42.593" class="difflineplus">+</span>
<a href="#l42.594"></a><span id="l42.594" class="difflineplus">+  _jsonifyCallbackHandleState: function(aCallbackHandle) {</span>
<a href="#l42.595"></a><span id="l42.595" class="difflineplus">+    return {</span>
<a href="#l42.596"></a><span id="l42.596" class="difflineplus">+      _stringRep: aCallbackHandle.activeStack.length + &quot; active generators&quot;,</span>
<a href="#l42.597"></a><span id="l42.597" class="difflineplus">+      activeStackLength: aCallbackHandle.activeStack.length,</span>
<a href="#l42.598"></a><span id="l42.598" class="difflineplus">+      contextStack: aCallbackHandle.contextStack,</span>
<a href="#l42.599"></a><span id="l42.599" class="difflineplus">+    };</span>
<a href="#l42.600"></a><span id="l42.600" class="difflineplus">+  },</span>
<a href="#l42.601"></a><span id="l42.601" class="difflineplus">+</span>
<a href="#l42.602"></a><span id="l42.602" class="difflineplus">+  _testHookRecover: function(aRecoverResult, aOriginEx, aActiveJob,</span>
<a href="#l42.603"></a><span id="l42.603" class="difflineplus">+                             aCallbackHandle) {</span>
<a href="#l42.604"></a><span id="l42.604" class="difflineplus">+    mark_action(&quot;glodaEvent&quot;, &quot;indexer recovery hook fired&quot;,</span>
<a href="#l42.605"></a><span id="l42.605" class="difflineplus">+                [&quot;recover result:&quot;, aRecoverResult,</span>
<a href="#l42.606"></a><span id="l42.606" class="difflineplus">+                 &quot;originating exception:&quot;, aOriginEx,</span>
<a href="#l42.607"></a><span id="l42.607" class="difflineplus">+                 &quot;active job:&quot;, aActiveJob,</span>
<a href="#l42.608"></a><span id="l42.608" class="difflineplus">+                 &quot;callbackHandle:&quot;,</span>
<a href="#l42.609"></a><span id="l42.609" class="difflineplus">+                 _indexMessageState._jsonifyCallbackHandleState(</span>
<a href="#l42.610"></a><span id="l42.610" class="difflineplus">+                   aCallbackHandle)]);</span>
<a href="#l42.611"></a><span id="l42.611" class="difflineplus">+    if (aRecoverResult)</span>
<a href="#l42.612"></a><span id="l42.612" class="difflineplus">+      _indexMessageState._workerRecoveredCount++;</span>
<a href="#l42.613"></a><span id="l42.613" class="difflineplus">+    else</span>
<a href="#l42.614"></a><span id="l42.614" class="difflineplus">+      _indexMessageState._workerFailedToRecoverCount++;</span>
<a href="#l42.615"></a><span id="l42.615" class="difflineplus">+  },</span>
<a href="#l42.616"></a><span id="l42.616" class="difflineplus">+</span>
<a href="#l42.617"></a><span id="l42.617" class="difflineplus">+  _testHookCleanup: function(aHadCleanupFunc, aOriginEx, aActiveJob,</span>
<a href="#l42.618"></a><span id="l42.618" class="difflineplus">+                             aCallbackHandle) {</span>
<a href="#l42.619"></a><span id="l42.619" class="difflineplus">+    mark_action(&quot;glodaEvent&quot;, &quot;indexer cleanup hook fired&quot;,</span>
<a href="#l42.620"></a><span id="l42.620" class="difflineplus">+                [&quot;had cleanup?&quot;, aHadCleanupFunc,</span>
<a href="#l42.621"></a><span id="l42.621" class="difflineplus">+                 &quot;originating exception:&quot;, aOriginEx,</span>
<a href="#l42.622"></a><span id="l42.622" class="difflineplus">+                 &quot;active job:&quot;, aActiveJob,</span>
<a href="#l42.623"></a><span id="l42.623" class="difflineplus">+                 &quot;callbackHandle&quot;,</span>
<a href="#l42.624"></a><span id="l42.624" class="difflineplus">+                 _indexMessageState._jsonifyCallbackHandleState(</span>
<a href="#l42.625"></a><span id="l42.625" class="difflineplus">+                   aCallbackHandle)]);</span>
<a href="#l42.626"></a><span id="l42.626" class="difflineplus">+    if (aHadCleanupFunc)</span>
<a href="#l42.627"></a><span id="l42.627" class="difflineplus">+      _indexMessageState._workerCleanedUpCount++;</span>
<a href="#l42.628"></a><span id="l42.628" class="difflineplus">+    else</span>
<a href="#l42.629"></a><span id="l42.629" class="difflineplus">+      _indexMessageState._workerHadNoCleanUpCount++;</span>
<a href="#l42.630"></a><span id="l42.630">   },</span>
<a href="#l42.631"></a><span id="l42.631"> </span>
<a href="#l42.632"></a><span id="l42.632">   /**</span>
<a href="#l42.633"></a><span id="l42.633" class="difflineminus">-   * Listener to handle the completion of the POP3 message retrieval (one way or</span>
<a href="#l42.634"></a><span id="l42.634" class="difflineminus">-   *  the other.)</span>
<a href="#l42.635"></a><span id="l42.635" class="difflineplus">+   * The gloda messages indexed since the last call to |wait_for_gloda_indexer|.</span>
<a href="#l42.636"></a><span id="l42.636">    */</span>
<a href="#l42.637"></a><span id="l42.637" class="difflineminus">-  urlListener: {</span>
<a href="#l42.638"></a><span id="l42.638" class="difflineminus">-    OnStartRunningUrl: function (url) {</span>
<a href="#l42.639"></a><span id="l42.639" class="difflineminus">-    },</span>
<a href="#l42.640"></a><span id="l42.640" class="difflineminus">-    OnStopRunningUrl: function (url, result) {</span>
<a href="#l42.641"></a><span id="l42.641" class="difflineminus">-      let ims = indexMessageState;</span>
<a href="#l42.642"></a><span id="l42.642" class="difflineminus">-      try {</span>
<a href="#l42.643"></a><span id="l42.643" class="difflineminus">-        // this returns a log of the transaction, but we don't care.  (we</span>
<a href="#l42.644"></a><span id="l42.644" class="difflineminus">-        //  assume that the POP3 stuff works.)</span>
<a href="#l42.645"></a><span id="l42.645" class="difflineminus">-        ims.server.playTransaction();</span>
<a href="#l42.646"></a><span id="l42.646" class="difflineminus">-        // doesn't hurt to break if the POP3 broke though...</span>
<a href="#l42.647"></a><span id="l42.647" class="difflineminus">-        do_check_eq(result, 0);</span>
<a href="#l42.648"></a><span id="l42.648" class="difflineminus">-      }</span>
<a href="#l42.649"></a><span id="l42.649" class="difflineminus">-      catch (e) {</span>
<a href="#l42.650"></a><span id="l42.650" class="difflineminus">-        // If we have an error, clean up nicely before we throw it.</span>
<a href="#l42.651"></a><span id="l42.651" class="difflineminus">-        ims.server.stop();</span>
<a href="#l42.652"></a><span id="l42.652" class="difflineplus">+  _glodaMessagesByMessageId: {},</span>
<a href="#l42.653"></a><span id="l42.653" class="difflineplus">+  _glodaDeletionsByMessageId: {},</span>
<a href="#l42.654"></a><span id="l42.654" class="difflineplus">+</span>
<a href="#l42.655"></a><span id="l42.655" class="difflineplus">+  assertExpectedMessagesIndexed:</span>
<a href="#l42.656"></a><span id="l42.656" class="difflineplus">+      function _indexMessageState_assertExpectedMessagesIndexed() {</span>
<a href="#l42.657"></a><span id="l42.657" class="difflineplus">+    let verifier = this.verifier;</span>
<a href="#l42.658"></a><span id="l42.658" class="difflineplus">+    let previousValue = undefined;</span>
<a href="#l42.659"></a><span id="l42.659" class="difflineplus">+</span>
<a href="#l42.660"></a><span id="l42.660" class="difflineplus">+    // - Check we have a gloda message for every syn message and verify</span>
<a href="#l42.661"></a><span id="l42.661" class="difflineplus">+    for each (let [, msgSet] in Iterator(this.synMessageSets)) {</span>
<a href="#l42.662"></a><span id="l42.662" class="difflineplus">+      if (this.augmentSynSets)</span>
<a href="#l42.663"></a><span id="l42.663" class="difflineplus">+        msgSet.glodaMessages = [];</span>
<a href="#l42.664"></a><span id="l42.664" class="difflineplus">+      for each (let [iSynMsg, synMsg] in Iterator(msgSet.synMessages)) {</span>
<a href="#l42.665"></a><span id="l42.665" class="difflineplus">+        if (!(synMsg.messageId in this._glodaMessagesByMessageId)) {</span>
<a href="#l42.666"></a><span id="l42.666" class="difflineplus">+          let msgHdr = msgSet.getMsgHdr(iSynMsg);</span>
<a href="#l42.667"></a><span id="l42.667" class="difflineplus">+          mark_failure(</span>
<a href="#l42.668"></a><span id="l42.668" class="difflineplus">+            [&quot;Header&quot;, msgHdr, &quot;in folder&quot;, msgHdr ? msgHdr.folder: &quot;no header?&quot;,</span>
<a href="#l42.669"></a><span id="l42.669" class="difflineplus">+             &quot;should have been indexed.&quot;]);</span>
<a href="#l42.670"></a><span id="l42.670" class="difflineplus">+        }</span>
<a href="#l42.671"></a><span id="l42.671"> </span>
<a href="#l42.672"></a><span id="l42.672" class="difflineminus">-        var thread = gThreadManager.currentThread;</span>
<a href="#l42.673"></a><span id="l42.673" class="difflineminus">-        while (thread.hasPendingEvents())</span>
<a href="#l42.674"></a><span id="l42.674" class="difflineminus">-          thread.processNextEvent(true);</span>
<a href="#l42.675"></a><span id="l42.675" class="difflineplus">+        let glodaMsg = this._glodaMessagesByMessageId[synMsg.messageId];</span>
<a href="#l42.676"></a><span id="l42.676" class="difflineplus">+        if (this.augmentSynSets)</span>
<a href="#l42.677"></a><span id="l42.677" class="difflineplus">+          msgSet.glodaMessages.push(glodaMsg);</span>
<a href="#l42.678"></a><span id="l42.678"> </span>
<a href="#l42.679"></a><span id="l42.679" class="difflineminus">-        do_throw(e);</span>
<a href="#l42.680"></a><span id="l42.680" class="difflineplus">+        this._glodaMessagesByMessageId[synMsg.messageId] = null;</span>
<a href="#l42.681"></a><span id="l42.681" class="difflineplus">+        if (verifier) {</span>
<a href="#l42.682"></a><span id="l42.682" class="difflineplus">+          try {</span>
<a href="#l42.683"></a><span id="l42.683" class="difflineplus">+            previousValue = verifier(synMsg, glodaMsg, previousValue);</span>
<a href="#l42.684"></a><span id="l42.684" class="difflineplus">+          }</span>
<a href="#l42.685"></a><span id="l42.685" class="difflineplus">+          catch (ex) {</span>
<a href="#l42.686"></a><span id="l42.686" class="difflineplus">+            // ugh, too verbose</span>
<a href="#l42.687"></a><span id="l42.687" class="difflineplus">+            //logObject(synMsg, &quot;synMsg&quot;);</span>
<a href="#l42.688"></a><span id="l42.688" class="difflineplus">+            //logObject(glodaMsg, &quot;glodaMsg&quot;);</span>
<a href="#l42.689"></a><span id="l42.689" class="difflineplus">+            dump(&quot;synMsg: &quot; + synMsg + &quot;\n&quot;);</span>
<a href="#l42.690"></a><span id="l42.690" class="difflineplus">+            dump(&quot;glodaMsg: &quot; + glodaMsg + &quot;\n&quot;);</span>
<a href="#l42.691"></a><span id="l42.691" class="difflineplus">+            mark_failure(</span>
<a href="#l42.692"></a><span id="l42.692" class="difflineplus">+              [&quot;Verification failure:&quot;, synMsg, &quot;is not close enough to&quot;,</span>
<a href="#l42.693"></a><span id="l42.693" class="difflineplus">+                glodaMsg, &quot;; basing this on exception:&quot;, ex]);</span>
<a href="#l42.694"></a><span id="l42.694" class="difflineplus">+          }</span>
<a href="#l42.695"></a><span id="l42.695" class="difflineplus">+        }</span>
<a href="#l42.696"></a><span id="l42.696">       }</span>
<a href="#l42.697"></a><span id="l42.697" class="difflineminus">-</span>
<a href="#l42.698"></a><span id="l42.698" class="difflineminus">-      // we are expecting the gloda indexer to receive some notification as the</span>
<a href="#l42.699"></a><span id="l42.699" class="difflineminus">-      //  result of the new messages showing up, so we don't actually need to</span>
<a href="#l42.700"></a><span id="l42.700" class="difflineminus">-      //  do anything here.</span>
<a href="#l42.701"></a><span id="l42.701">     }</span>
<a href="#l42.702"></a><span id="l42.702" class="difflineminus">-  }</span>
<a href="#l42.703"></a><span id="l42.703" class="difflineminus">-};</span>
<a href="#l42.704"></a><span id="l42.704"> </span>
<a href="#l42.705"></a><span id="l42.705" class="difflineminus">-/**</span>
<a href="#l42.706"></a><span id="l42.706" class="difflineminus">- * Perform POP3 mail fetching, seeing it through to completion.</span>
<a href="#l42.707"></a><span id="l42.707" class="difflineminus">- */</span>
<a href="#l42.708"></a><span id="l42.708" class="difflineminus">-function drivePOP3FakeServer() {</span>
<a href="#l42.709"></a><span id="l42.709" class="difflineminus">-  let ims = indexMessageState;</span>
<a href="#l42.710"></a><span id="l42.710" class="difflineminus">-dump(&quot;&gt;&gt;&gt; enter drivePOP3FakeServer\n&quot;);</span>
<a href="#l42.711"></a><span id="l42.711" class="difflineminus">-  // Handle the server in a try/catch/finally loop so that we always will stop</span>
<a href="#l42.712"></a><span id="l42.712" class="difflineminus">-  // the server if something fails.</span>
<a href="#l42.713"></a><span id="l42.713" class="difflineminus">-  try {</span>
<a href="#l42.714"></a><span id="l42.714" class="difflineminus">-    if (!(ims.serverStarted)) {</span>
<a href="#l42.715"></a><span id="l42.715" class="difflineminus">-      dump(&quot;  starting fake server\n&quot;);</span>
<a href="#l42.716"></a><span id="l42.716" class="difflineminus">-      ims.server.start(POP3_PORT);</span>
<a href="#l42.717"></a><span id="l42.717" class="difflineminus">-      ims.serverStarted = true;</span>
<a href="#l42.718"></a><span id="l42.718" class="difflineminus">-    }</span>
<a href="#l42.719"></a><span id="l42.719" class="difflineminus">-    else {</span>
<a href="#l42.720"></a><span id="l42.720" class="difflineminus">-      dump(&quot;  resetting fake server\n&quot;);</span>
<a href="#l42.721"></a><span id="l42.721" class="difflineminus">-      ims.server.resetTest();</span>
<a href="#l42.722"></a><span id="l42.722" class="difflineplus">+    // - Check that we don't have any extra gloda messages (lacking syn msgs)</span>
<a href="#l42.723"></a><span id="l42.723" class="difflineplus">+    for each (let [, glodaMsg] in Iterator(this._glodaMessagesByMessageId)) {</span>
<a href="#l42.724"></a><span id="l42.724" class="difflineplus">+      if (glodaMsg != null) {</span>
<a href="#l42.725"></a><span id="l42.725" class="difflineplus">+        // logObject is too verbose right now</span>
<a href="#l42.726"></a><span id="l42.726" class="difflineplus">+        dump(&quot;gloda message: &quot; + glodaMsg + &quot;\n&quot;);</span>
<a href="#l42.727"></a><span id="l42.727" class="difflineplus">+        mark_failure(</span>
<a href="#l42.728"></a><span id="l42.728" class="difflineplus">+          [&quot;Gloda message&quot;, glodaMsg, &quot;should not have been indexed.&quot;,</span>
<a href="#l42.729"></a><span id="l42.729" class="difflineplus">+           &quot;Source header:&quot;, glodaMsg.folderMessage]);</span>
<a href="#l42.730"></a><span id="l42.730" class="difflineplus">+      }</span>
<a href="#l42.731"></a><span id="l42.731">     }</span>
<a href="#l42.732"></a><span id="l42.732"> </span>
<a href="#l42.733"></a><span id="l42.733" class="difflineminus">-    // Now get the mail</span>
<a href="#l42.734"></a><span id="l42.734" class="difflineminus">-    dump(&quot;  issuing GetNewMail\n&quot;);</span>
<a href="#l42.735"></a><span id="l42.735" class="difflineminus">-    ims.pop3Service.GetNewMail(null, ims.urlListener, gLocalInboxFolder,</span>
<a href="#l42.736"></a><span id="l42.736" class="difflineminus">-                               ims.incomingServer);</span>
<a href="#l42.737"></a><span id="l42.737" class="difflineminus">-    dump(&quot;  issuing performTest\n&quot;)</span>
<a href="#l42.738"></a><span id="l42.738" class="difflineminus">-    ims.server.performTest();</span>
<a href="#l42.739"></a><span id="l42.739" class="difflineminus">-  }</span>
<a href="#l42.740"></a><span id="l42.740" class="difflineminus">-  catch (e) {</span>
<a href="#l42.741"></a><span id="l42.741" class="difflineminus">-    ims.server.stop();</span>
<a href="#l42.742"></a><span id="l42.742" class="difflineminus">-    do_throw(e);</span>
<a href="#l42.743"></a><span id="l42.743" class="difflineminus">-  }</span>
<a href="#l42.744"></a><span id="l42.744" class="difflineminus">-  finally {</span>
<a href="#l42.745"></a><span id="l42.745" class="difflineminus">-    dump(&quot;  draining events\n&quot;);</span>
<a href="#l42.746"></a><span id="l42.746" class="difflineminus">-    var thread = gThreadManager.currentThread;</span>
<a href="#l42.747"></a><span id="l42.747" class="difflineminus">-    while (thread.hasPendingEvents())</span>
<a href="#l42.748"></a><span id="l42.748" class="difflineminus">-      thread.processNextEvent(true);</span>
<a href="#l42.749"></a><span id="l42.749" class="difflineminus">-  }</span>
<a href="#l42.750"></a><span id="l42.750" class="difflineminus">-dump(&quot;&lt;&lt;&lt; exit drivePOP3FakeServer\n&quot;);</span>
<a href="#l42.751"></a><span id="l42.751" class="difflineminus">-}</span>
<a href="#l42.752"></a><span id="l42.752" class="difflineplus">+    if (this.deletionSynSets) {</span>
<a href="#l42.753"></a><span id="l42.753" class="difflineplus">+      for each (let [, msgSet] in Iterator(this.deletionSynSets)) {</span>
<a href="#l42.754"></a><span id="l42.754" class="difflineplus">+        for each (let [iSynMsg, synMsg] in Iterator(msgSet.synMessages)) {</span>
<a href="#l42.755"></a><span id="l42.755" class="difflineplus">+          if (!(synMsg.messageId in this._glodaDeletionsByMessageId)) {</span>
<a href="#l42.756"></a><span id="l42.756" class="difflineplus">+            do_throw(&quot;Synthetic message &quot; + synMsg + &quot; did not get deleted!&quot;);</span>
<a href="#l42.757"></a><span id="l42.757" class="difflineplus">+          }</span>
<a href="#l42.758"></a><span id="l42.758" class="difflineplus">+</span>
<a href="#l42.759"></a><span id="l42.759" class="difflineplus">+          let glodaMsg = this._glodaMessagesByMessageId[synMsg.messageId];</span>
<a href="#l42.760"></a><span id="l42.760"> </span>
<a href="#l42.761"></a><span id="l42.761" class="difflineminus">-/**</span>
<a href="#l42.762"></a><span id="l42.762" class="difflineminus">- * Perform an IMAP mail fetch, seeing it through to completion</span>
<a href="#l42.763"></a><span id="l42.763" class="difflineminus">- */</span>
<a href="#l42.764"></a><span id="l42.764" class="difflineminus">-function driveIMAPFakeServer() {</span>
<a href="#l42.765"></a><span id="l42.765" class="difflineminus">-  dump(&quot;&gt;&gt;&gt; enter driveIMAPFakeServer\n&quot;);</span>
<a href="#l42.766"></a><span id="l42.766" class="difflineminus">-  let ims = indexMessageState;</span>
<a href="#l42.767"></a><span id="l42.767" class="difflineminus">-  // Handle the server in a try/catch/finally loop so that we always will stop</span>
<a href="#l42.768"></a><span id="l42.768" class="difflineminus">-  // the server if something fails.</span>
<a href="#l42.769"></a><span id="l42.769" class="difflineminus">-  try {</span>
<a href="#l42.770"></a><span id="l42.770" class="difflineminus">-    dump(&quot;  resetting fake server\n&quot;);</span>
<a href="#l42.771"></a><span id="l42.771" class="difflineminus">-    ims.server.resetTest();</span>
<a href="#l42.772"></a><span id="l42.772" class="difflineplus">+          this._glodaDeletionsByMessageId[synMsg.messageId] = null;</span>
<a href="#l42.773"></a><span id="l42.773" class="difflineplus">+        }</span>
<a href="#l42.774"></a><span id="l42.774" class="difflineplus">+      }</span>
<a href="#l42.775"></a><span id="l42.775" class="difflineplus">+    }</span>
<a href="#l42.776"></a><span id="l42.776" class="difflineplus">+</span>
<a href="#l42.777"></a><span id="l42.777" class="difflineplus">+    // - Check that we don't have unexpected deletions</span>
<a href="#l42.778"></a><span id="l42.778" class="difflineplus">+    for each (let [messageId, glodaMsg] in</span>
<a href="#l42.779"></a><span id="l42.779" class="difflineplus">+              Iterator(this._glodaDeletionsByMessageId)) {</span>
<a href="#l42.780"></a><span id="l42.780" class="difflineplus">+      if (glodaMsg != null) {</span>
<a href="#l42.781"></a><span id="l42.781" class="difflineplus">+        logObject(glodaMsg, &quot;glodaMsg&quot;);</span>
<a href="#l42.782"></a><span id="l42.782" class="difflineplus">+        do_throw(&quot;Gloda message with message id &quot; + messageId + &quot; was &quot; +</span>
<a href="#l42.783"></a><span id="l42.783" class="difflineplus">+                 &quot;unexpectedly deleted!&quot;);</span>
<a href="#l42.784"></a><span id="l42.784" class="difflineplus">+      }</span>
<a href="#l42.785"></a><span id="l42.785" class="difflineplus">+    }</span>
<a href="#l42.786"></a><span id="l42.786"> </span>
<a href="#l42.787"></a><span id="l42.787" class="difflineminus">-    // Update the inbox</span>
<a href="#l42.788"></a><span id="l42.788" class="difflineminus">-    dump(&quot;  issuing updateFolder\n&quot;);</span>
<a href="#l42.789"></a><span id="l42.789" class="difflineminus">-    ims.imapInbox.updateFolder(null);</span>
<a href="#l42.790"></a><span id="l42.790" class="difflineminus">-    // performTest won't work here because that seemingly blocks until the</span>
<a href="#l42.791"></a><span id="l42.791" class="difflineminus">-    // socket is closed, which is something undesirable here</span>
<a href="#l42.792"></a><span id="l42.792" class="difflineminus">-  }</span>
<a href="#l42.793"></a><span id="l42.793" class="difflineminus">-  catch (e) {</span>
<a href="#l42.794"></a><span id="l42.794" class="difflineminus">-    ims.server.stop();</span>
<a href="#l42.795"></a><span id="l42.795" class="difflineminus">-    do_throw(e);</span>
<a href="#l42.796"></a><span id="l42.796" class="difflineminus">-  }</span>
<a href="#l42.797"></a><span id="l42.797" class="difflineminus">-  finally {</span>
<a href="#l42.798"></a><span id="l42.798" class="difflineminus">-    dump(&quot;  draining events\n&quot;);</span>
<a href="#l42.799"></a><span id="l42.799" class="difflineminus">-    let thread = gThreadManager.currentThread;</span>
<a href="#l42.800"></a><span id="l42.800" class="difflineminus">-    while (thread.hasPendingEvents())</span>
<a href="#l42.801"></a><span id="l42.801" class="difflineminus">-      thread.processNextEvent(true);</span>
<a href="#l42.802"></a><span id="l42.802" class="difflineminus">-  }</span>
<a href="#l42.803"></a><span id="l42.803" class="difflineminus">-  dump(&quot;&lt;&lt;&lt; exit driveIMAPFakeServer\n&quot;);</span>
<a href="#l42.804"></a><span id="l42.804" class="difflineminus">-}</span>
<a href="#l42.805"></a><span id="l42.805" class="difflineminus">-</span>
<a href="#l42.806"></a><span id="l42.806" class="difflineplus">+    if (this.expectedWorkerRecoveredCount != null &amp;&amp;</span>
<a href="#l42.807"></a><span id="l42.807" class="difflineplus">+        this.expectedWorkerRecoveredCount != this._workerRecoveredCount)</span>
<a href="#l42.808"></a><span id="l42.808" class="difflineplus">+      mark_failure([&quot;Expected worker-recovered count did not match actual!&quot;,</span>
<a href="#l42.809"></a><span id="l42.809" class="difflineplus">+                    &quot;Expected&quot;, this.expectedWorkerRecoveredCount,</span>
<a href="#l42.810"></a><span id="l42.810" class="difflineplus">+                    &quot;actual&quot;, this._workerRecoveredCount]);</span>
<a href="#l42.811"></a><span id="l42.811" class="difflineplus">+    if (this.expectedFailedToRecoverCount != null &amp;&amp;</span>
<a href="#l42.812"></a><span id="l42.812" class="difflineplus">+        this.expectedFailedToRecoverCount != this._workerFailedToRecoverCount)</span>
<a href="#l42.813"></a><span id="l42.813" class="difflineplus">+      mark_failure([&quot;Expected worker-failed-to-recover count did not match &quot; +</span>
<a href="#l42.814"></a><span id="l42.814" class="difflineplus">+                     &quot;actual!&quot;,</span>
<a href="#l42.815"></a><span id="l42.815" class="difflineplus">+                    &quot;Expected&quot;, this.expectedFailedToRecoverCount,</span>
<a href="#l42.816"></a><span id="l42.816" class="difflineplus">+                    &quot;actual&quot;, this._workerFailedToRecoverCount]);</span>
<a href="#l42.817"></a><span id="l42.817" class="difflineplus">+    if (this.expectedCleanedUpCount != null &amp;&amp;</span>
<a href="#l42.818"></a><span id="l42.818" class="difflineplus">+        this.expectedCleanedUpCount != this._workerCleanedUpCount)</span>
<a href="#l42.819"></a><span id="l42.819" class="difflineplus">+      mark_failure([&quot;Expected worker-cleaned-up count did not match actual!&quot;,</span>
<a href="#l42.820"></a><span id="l42.820" class="difflineplus">+                    &quot;Expected&quot;, this.expectedCleanedUpCount,</span>
<a href="#l42.821"></a><span id="l42.821" class="difflineplus">+                    &quot;actual&quot;, this._workerCleanedUpCount]);</span>
<a href="#l42.822"></a><span id="l42.822" class="difflineplus">+    if (this.expectedHadNoCleanUpCount != null &amp;&amp;</span>
<a href="#l42.823"></a><span id="l42.823" class="difflineplus">+        this.expectedHadNoCleanUpCount != this._workerHadNoCleanUpCount)</span>
<a href="#l42.824"></a><span id="l42.824" class="difflineplus">+      mark_failure([&quot;Expected worker-had-no-cleanup count did not match actual!&quot;,</span>
<a href="#l42.825"></a><span id="l42.825" class="difflineplus">+                    &quot;Expected&quot;, this.expectedHadNoCleanUpCount,</span>
<a href="#l42.826"></a><span id="l42.826" class="difflineplus">+                    &quot;actual&quot;, this._workerHadNoCleanUpCount]);</span>
<a href="#l42.827"></a><span id="l42.827"> </span>
<a href="#l42.828"></a><span id="l42.828" class="difflineminus">-/**</span>
<a href="#l42.829"></a><span id="l42.829" class="difflineminus">- * Tear down the fake server.  This is very important to avoid things getting</span>
<a href="#l42.830"></a><span id="l42.830" class="difflineminus">- *  upset during shutdown.  (Namely, XPConnect will get mad about running in</span>
<a href="#l42.831"></a><span id="l42.831" class="difflineminus">- *  a context without &quot;Components&quot; defined.)</span>
<a href="#l42.832"></a><span id="l42.832" class="difflineminus">- */</span>
<a href="#l42.833"></a><span id="l42.833" class="difflineminus">-function killFakeServer() {</span>
<a href="#l42.834"></a><span id="l42.834" class="difflineminus">-  dump(&quot;Killing fake server\n&quot;);</span>
<a href="#l42.835"></a><span id="l42.835" class="difflineminus">-  let ims = indexMessageState;</span>
<a href="#l42.836"></a><span id="l42.836" class="difflineplus">+    this._glodaMessagesByMessageId = {};</span>
<a href="#l42.837"></a><span id="l42.837" class="difflineplus">+    this._glodaDeletionsByMessageId = {};</span>
<a href="#l42.838"></a><span id="l42.838"> </span>
<a href="#l42.839"></a><span id="l42.839" class="difflineminus">-  ims.incomingServer.closeCachedConnections();</span>
<a href="#l42.840"></a><span id="l42.840" class="difflineminus">-</span>
<a href="#l42.841"></a><span id="l42.841" class="difflineminus">-  // No more tests, let everything finish</span>
<a href="#l42.842"></a><span id="l42.842" class="difflineminus">-  ims.server.stop();</span>
<a href="#l42.843"></a><span id="l42.843" class="difflineplus">+    this._workerRecoveredCount = 0;</span>
<a href="#l42.844"></a><span id="l42.844" class="difflineplus">+    this._workerFailedToRecoverCount = 0;</span>
<a href="#l42.845"></a><span id="l42.845" class="difflineplus">+    this._workerCleanedUpCount = 0;</span>
<a href="#l42.846"></a><span id="l42.846" class="difflineplus">+    this._workerHadNoCleanUpCount = 0;</span>
<a href="#l42.847"></a><span id="l42.847"> </span>
<a href="#l42.848"></a><span id="l42.848" class="difflineminus">-  var thread = gThreadManager.currentThread;</span>
<a href="#l42.849"></a><span id="l42.849" class="difflineminus">-  while (thread.hasPendingEvents())</span>
<a href="#l42.850"></a><span id="l42.850" class="difflineminus">-    thread.processNextEvent(true);</span>
<a href="#l42.851"></a><span id="l42.851" class="difflineminus">-</span>
<a href="#l42.852"></a><span id="l42.852" class="difflineminus">-  do_test_finished();</span>
<a href="#l42.853"></a><span id="l42.853" class="difflineminus">-}</span>
<a href="#l42.854"></a><span id="l42.854" class="difflineplus">+    // make sure xpcshell head.js knows we tested something</span>
<a href="#l42.855"></a><span id="l42.855" class="difflineplus">+    _passedChecks++;</span>
<a href="#l42.856"></a><span id="l42.856" class="difflineplus">+  },</span>
<a href="#l42.857"></a><span id="l42.857"> </span>
<a href="#l42.858"></a><span id="l42.858" class="difflineminus">-/**</span>
<a href="#l42.859"></a><span id="l42.859" class="difflineminus">- * Our catch-all collection listener.  Any time a new message gets indexed,</span>
<a href="#l42.860"></a><span id="l42.860" class="difflineminus">- *  we should receive an onItemsAdded call.  Any time an existing message</span>
<a href="#l42.861"></a><span id="l42.861" class="difflineminus">- *  gets reindexed, we should receive an onItemsModified call.  Any time an</span>
<a href="#l42.862"></a><span id="l42.862" class="difflineminus">- *  existing message actually gets purged from the system, we should receive</span>
<a href="#l42.863"></a><span id="l42.863" class="difflineminus">- *  an onItemsRemoved call.</span>
<a href="#l42.864"></a><span id="l42.864" class="difflineminus">- */</span>
<a href="#l42.865"></a><span id="l42.865" class="difflineminus">-var messageCollectionListener = {</span>
<a href="#l42.866"></a><span id="l42.866" class="difflineplus">+  /*</span>
<a href="#l42.867"></a><span id="l42.867" class="difflineplus">+   * Our catch-all collection listener.  Any time a new message gets indexed,</span>
<a href="#l42.868"></a><span id="l42.868" class="difflineplus">+   *  we should receive an onItemsAdded call.  Any time an existing message</span>
<a href="#l42.869"></a><span id="l42.869" class="difflineplus">+   *  gets reindexed, we should receive an onItemsModified call.  Any time an</span>
<a href="#l42.870"></a><span id="l42.870" class="difflineplus">+   *  existing message actually gets purged from the system, we should receive</span>
<a href="#l42.871"></a><span id="l42.871" class="difflineplus">+   *  an onItemsRemoved call.</span>
<a href="#l42.872"></a><span id="l42.872" class="difflineplus">+   */</span>
<a href="#l42.873"></a><span id="l42.873">   onItemsAdded: function(aItems) {</span>
<a href="#l42.874"></a><span id="l42.874">     dump(&quot;@@@ messageCollectionListener.onItemsAdded\n&quot;);</span>
<a href="#l42.875"></a><span id="l42.875" class="difflineminus">-    let ims = indexMessageState;</span>
<a href="#l42.876"></a><span id="l42.876" class="difflineminus">-    ims.glodaMessages = ims.glodaMessages.concat(aItems);</span>
<a href="#l42.877"></a><span id="l42.877" class="difflineplus">+</span>
<a href="#l42.878"></a><span id="l42.878" class="difflineplus">+    mark_action(&quot;glodaEvent&quot;, &quot;indexed&quot;, aItems);</span>
<a href="#l42.879"></a><span id="l42.879" class="difflineplus">+</span>
<a href="#l42.880"></a><span id="l42.880" class="difflineplus">+    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l42.881"></a><span id="l42.881" class="difflineplus">+      if (item.headerMessageID in this._glodaMessagesByMessageId)</span>
<a href="#l42.882"></a><span id="l42.882" class="difflineplus">+        mark_failure(</span>
<a href="#l42.883"></a><span id="l42.883" class="difflineplus">+          [&quot;Gloda message&quot;, item, &quot;already indexed once since the last&quot; +</span>
<a href="#l42.884"></a><span id="l42.884" class="difflineplus">+            &quot;wait_for_gloda_indexer call!&quot;]);</span>
<a href="#l42.885"></a><span id="l42.885" class="difflineplus">+</span>
<a href="#l42.886"></a><span id="l42.886" class="difflineplus">+      this._glodaMessagesByMessageId[item.headerMessageID] = item;</span>
<a href="#l42.887"></a><span id="l42.887" class="difflineplus">+    }</span>
<a href="#l42.888"></a><span id="l42.888" class="difflineplus">+</span>
<a href="#l42.889"></a><span id="l42.889">     // simulate some other activity clearing out the the current folder's</span>
<a href="#l42.890"></a><span id="l42.890">     // cached database, which used to kill the indexer's enumerator.</span>
<a href="#l42.891"></a><span id="l42.891">     if (++this._numItemsAdded == 3)</span>
<a href="#l42.892"></a><span id="l42.892" class="difflineminus">-      GlodaIndexer._indexingFolder.msgDatabase = null;</span>
<a href="#l42.893"></a><span id="l42.893" class="difflineplus">+      GlodaMsgIndexer._indexingFolder.msgDatabase = null;</span>
<a href="#l42.894"></a><span id="l42.894">   },</span>
<a href="#l42.895"></a><span id="l42.895"> </span>
<a href="#l42.896"></a><span id="l42.896">   onItemsModified: function(aItems) {</span>
<a href="#l42.897"></a><span id="l42.897">     dump(&quot;@@@ messageCollectionListener.onItemsModified\n&quot;);</span>
<a href="#l42.898"></a><span id="l42.898" class="difflineminus">-    let ims = indexMessageState;</span>
<a href="#l42.899"></a><span id="l42.899" class="difflineminus">-    ims.glodaMessages = ims.glodaMessages.concat(aItems);</span>
<a href="#l42.900"></a><span id="l42.900" class="difflineplus">+</span>
<a href="#l42.901"></a><span id="l42.901" class="difflineplus">+    mark_action(&quot;glodaEvent&quot;, &quot;indexed&quot;, aItems);</span>
<a href="#l42.902"></a><span id="l42.902" class="difflineplus">+</span>
<a href="#l42.903"></a><span id="l42.903" class="difflineplus">+    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l42.904"></a><span id="l42.904" class="difflineplus">+      if (item.headerMessageID in this._glodaMessagesByMessageId)</span>
<a href="#l42.905"></a><span id="l42.905" class="difflineplus">+        mark_failure(</span>
<a href="#l42.906"></a><span id="l42.906" class="difflineplus">+          [&quot;Gloda message&quot;, item, &quot;already indexed once since the last&quot; +</span>
<a href="#l42.907"></a><span id="l42.907" class="difflineplus">+            &quot;wait_for_gloda_indexer call!&quot;]);</span>
<a href="#l42.908"></a><span id="l42.908" class="difflineplus">+</span>
<a href="#l42.909"></a><span id="l42.909" class="difflineplus">+      this._glodaMessagesByMessageId[item.headerMessageID] = item;</span>
<a href="#l42.910"></a><span id="l42.910" class="difflineplus">+    }</span>
<a href="#l42.911"></a><span id="l42.911">   },</span>
<a href="#l42.912"></a><span id="l42.912"> </span>
<a href="#l42.913"></a><span id="l42.913">   onItemsRemoved: function(aItems) {</span>
<a href="#l42.914"></a><span id="l42.914" class="difflineminus">-    dump(&quot;!!! messageCollectionListener.onItemsRemoved\n&quot;);</span>
<a href="#l42.915"></a><span id="l42.915" class="difflineplus">+    dump(&quot;@@@ messageCollectionListener.onItemsRemoved\n&quot;);</span>
<a href="#l42.916"></a><span id="l42.916" class="difflineplus">+</span>
<a href="#l42.917"></a><span id="l42.917" class="difflineplus">+    mark_action(&quot;glodaEvent&quot;, &quot;removed&quot;, aItems);</span>
<a href="#l42.918"></a><span id="l42.918" class="difflineplus">+</span>
<a href="#l42.919"></a><span id="l42.919" class="difflineplus">+    for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l42.920"></a><span id="l42.920" class="difflineplus">+      if (item.headerMessageID in this._glodaDeletionsByMessageId)</span>
<a href="#l42.921"></a><span id="l42.921" class="difflineplus">+        mark_failure(</span>
<a href="#l42.922"></a><span id="l42.922" class="difflineplus">+          [&quot;Gloda message&quot;, item, &quot;already deleted once since the last&quot; +</span>
<a href="#l42.923"></a><span id="l42.923" class="difflineplus">+            &quot;wait_for_gloda_indexer call!&quot;]);</span>
<a href="#l42.924"></a><span id="l42.924" class="difflineplus">+</span>
<a href="#l42.925"></a><span id="l42.925" class="difflineplus">+      this._glodaDeletionsByMessageId[item.headerMessageID] = item;</span>
<a href="#l42.926"></a><span id="l42.926" class="difflineplus">+    }</span>
<a href="#l42.927"></a><span id="l42.927">   },</span>
<a href="#l42.928"></a><span id="l42.928"> </span>
<a href="#l42.929"></a><span id="l42.929" class="difflineminus">-  _numItemsAdded : 0</span>
<a href="#l42.930"></a><span id="l42.930" class="difflineminus">-};</span>
<a href="#l42.931"></a><span id="l42.931" class="difflineminus">-</span>
<a href="#l42.932"></a><span id="l42.932" class="difflineminus">-/**</span>
<a href="#l42.933"></a><span id="l42.933" class="difflineminus">- * Allow tests to register a callback to be invoked when the indexing completes.</span>
<a href="#l42.934"></a><span id="l42.934" class="difflineminus">- *   Only one at a time, etc.</span>
<a href="#l42.935"></a><span id="l42.935" class="difflineminus">- */</span>
<a href="#l42.936"></a><span id="l42.936" class="difflineminus">-function runOnIndexingComplete(aCallback) {</span>
<a href="#l42.937"></a><span id="l42.937" class="difflineminus">-  indexMessageState.expectingIndexNotifications = true;</span>
<a href="#l42.938"></a><span id="l42.938" class="difflineminus">-  messageIndexerListener.callbackOnDone = aCallback;</span>
<a href="#l42.939"></a><span id="l42.939" class="difflineminus">-}</span>
<a href="#l42.940"></a><span id="l42.940" class="difflineminus">-</span>
<a href="#l42.941"></a><span id="l42.941" class="difflineminus">-/**</span>
<a href="#l42.942"></a><span id="l42.942" class="difflineminus">- * Gloda indexer listener, used to know when all active indexing jobs have</span>
<a href="#l42.943"></a><span id="l42.943" class="difflineminus">- *  completed so that we can try and process all the things that should have</span>
<a href="#l42.944"></a><span id="l42.944" class="difflineminus">- *  been processed.</span>
<a href="#l42.945"></a><span id="l42.945" class="difflineminus">- */</span>
<a href="#l42.946"></a><span id="l42.946" class="difflineminus">-var messageIndexerListener = {</span>
<a href="#l42.947"></a><span id="l42.947" class="difflineminus">-  callbackOnDone: null,</span>
<a href="#l42.948"></a><span id="l42.948" class="difflineminus">-  onIndexNotification: function(aStatus, aPrettyName, aJobIndex, aJobTotal,</span>
<a href="#l42.949"></a><span id="l42.949" class="difflineminus">-                                aJobItemIndex, aJobItemGoal) {</span>
<a href="#l42.950"></a><span id="l42.950" class="difflineminus">-    dump(&quot;((( Index listener notified! aStatus = &quot; + aStatus + &quot;\n&quot;);</span>
<a href="#l42.951"></a><span id="l42.951" class="difflineminus">-    // Ignore moving/removing notifications</span>
<a href="#l42.952"></a><span id="l42.952" class="difflineminus">-    if (aStatus == Gloda.kIndexerMoving || aStatus == Gloda.kIndexerRemoving)</span>
<a href="#l42.953"></a><span id="l42.953" class="difflineminus">-      return;</span>
<a href="#l42.954"></a><span id="l42.954" class="difflineminus">-</span>
<a href="#l42.955"></a><span id="l42.955" class="difflineminus">-    let ims = indexMessageState;</span>
<a href="#l42.956"></a><span id="l42.956" class="difflineminus">-    // If we shouldn't be receiving notifications and we receive one with aStatus</span>
<a href="#l42.957"></a><span id="l42.957" class="difflineminus">-    // != kIndexerIdle. throw.</span>
<a href="#l42.958"></a><span id="l42.958" class="difflineminus">-    if (!ims.expectingIndexNotifications) {</span>
<a href="#l42.959"></a><span id="l42.959" class="difflineminus">-      if (aStatus == Gloda.kIndexerIdle) {</span>
<a href="#l42.960"></a><span id="l42.960" class="difflineminus">-        dump(&quot;((( Ignoring indexing notification since it's just kIndexerIdle.\n&quot;);</span>
<a href="#l42.961"></a><span id="l42.961" class="difflineminus">-        return;</span>
<a href="#l42.962"></a><span id="l42.962" class="difflineminus">-      }</span>
<a href="#l42.963"></a><span id="l42.963" class="difflineminus">-      else {</span>
<a href="#l42.964"></a><span id="l42.964" class="difflineminus">-        do_throw(&quot;Exception during index notification -- we weren't &quot; +</span>
<a href="#l42.965"></a><span id="l42.965" class="difflineminus">-                 &quot;expecting one.&quot;);</span>
<a href="#l42.966"></a><span id="l42.966" class="difflineminus">-      }</span>
<a href="#l42.967"></a><span id="l42.967" class="difflineminus">-    }</span>
<a href="#l42.968"></a><span id="l42.968" class="difflineminus">-</span>
<a href="#l42.969"></a><span id="l42.969" class="difflineminus">-    // we only care if indexing has just completed...</span>
<a href="#l42.970"></a><span id="l42.970" class="difflineminus">-    if (aStatus == Gloda.kIndexerIdle) {</span>
<a href="#l42.971"></a><span id="l42.971" class="difflineminus">-      if (messageIndexerListener.callbackOnDone) {</span>
<a href="#l42.972"></a><span id="l42.972" class="difflineminus">-        let callback = messageIndexerListener.callbackOnDone;</span>
<a href="#l42.973"></a><span id="l42.973" class="difflineminus">-        messageIndexerListener.callbackOnDone = null;</span>
<a href="#l42.974"></a><span id="l42.974" class="difflineminus">-        callback();</span>
<a href="#l42.975"></a><span id="l42.975" class="difflineminus">-      }</span>
<a href="#l42.976"></a><span id="l42.976" class="difflineplus">+  _numItemsAdded : 0,</span>
<a href="#l42.977"></a><span id="l42.977"> </span>
<a href="#l42.978"></a><span id="l42.978" class="difflineminus">-      // if we haven't seen all the messages we should see, assume that the</span>
<a href="#l42.979"></a><span id="l42.979" class="difflineminus">-      //  rest are on their way, and are just coming in a subsequent job...</span>
<a href="#l42.980"></a><span id="l42.980" class="difflineminus">-      // (Also, the first time we register our listener, we will get a synthetic</span>
<a href="#l42.981"></a><span id="l42.981" class="difflineminus">-      //  idle status; at least if the indexer is idle.)</span>
<a href="#l42.982"></a><span id="l42.982" class="difflineminus">-      let glodaLen = ims.glodaMessages.length, inputLen =</span>
<a href="#l42.983"></a><span id="l42.983" class="difflineminus">-        ims.inputMessages.length;</span>
<a href="#l42.984"></a><span id="l42.984" class="difflineminus">-      if (glodaLen &lt; inputLen) {</span>
<a href="#l42.985"></a><span id="l42.985" class="difflineminus">-        dump(&quot;((( indexing is no longer indexing, but we're still expecting &quot; +</span>
<a href="#l42.986"></a><span id="l42.986" class="difflineminus">-             inputLen + &quot; - &quot; + glodaLen + &quot; = &quot; + (inputLen - glodaLen) +</span>
<a href="#l42.987"></a><span id="l42.987" class="difflineminus">-             &quot; more results, ignoring.\n&quot;);</span>
<a href="#l42.988"></a><span id="l42.988" class="difflineminus">-        // If we're running IMAP, then update the folder once more</span>
<a href="#l42.989"></a><span id="l42.989" class="difflineminus">-        if (ims.imapInbox)</span>
<a href="#l42.990"></a><span id="l42.990" class="difflineminus">-          ims.imapInbox.updateFolder(null);</span>
<a href="#l42.991"></a><span id="l42.991" class="difflineminus">-        return;</span>
<a href="#l42.992"></a><span id="l42.992" class="difflineminus">-      }</span>
<a href="#l42.993"></a><span id="l42.993" class="difflineminus">-</span>
<a href="#l42.994"></a><span id="l42.994" class="difflineminus">-      dump(&quot;((( indexer notification (&quot; + ims.glodaMessages.length +</span>
<a href="#l42.995"></a><span id="l42.995" class="difflineminus">-           &quot; messages) about to verify: &quot; +</span>
<a href="#l42.996"></a><span id="l42.996" class="difflineminus">-           (ims.verifier ? ims.verifier.name : &quot;none&quot;) + &quot; and complete: &quot; +</span>
<a href="#l42.997"></a><span id="l42.997" class="difflineminus">-           (ims.onDone ? ims.onDone.name : &quot;none&quot;) + &quot;\n&quot;);</span>
<a href="#l42.998"></a><span id="l42.998" class="difflineminus">-      // If we're verifying messages, we shouldn't be expecting them</span>
<a href="#l42.999"></a><span id="l42.999" class="difflineminus">-      ims.expectingIndexNotifications = false;</span>
<a href="#l42.1000"></a><span id="l42.1000" class="difflineplus">+  /**</span>
<a href="#l42.1001"></a><span id="l42.1001" class="difflineplus">+   * Gloda indexer listener, used to know when all active indexing jobs have</span>
<a href="#l42.1002"></a><span id="l42.1002" class="difflineplus">+   *  completed so that we can try and process all the things that should have</span>
<a href="#l42.1003"></a><span id="l42.1003" class="difflineplus">+   *  been processed.</span>
<a href="#l42.1004"></a><span id="l42.1004" class="difflineplus">+   */</span>
<a href="#l42.1005"></a><span id="l42.1005" class="difflineplus">+  onIndexNotification: function(aStatus, aPrettyName, aJobIndex,</span>
<a href="#l42.1006"></a><span id="l42.1006" class="difflineplus">+                                aJobItemIndex, aJobItemGoal) {</span>
<a href="#l42.1007"></a><span id="l42.1007" class="difflineplus">+    let ims = _indexMessageState;</span>
<a href="#l42.1008"></a><span id="l42.1008" class="difflineplus">+    dump(&quot;((( Index listener notified! aStatus = &quot; + aStatus + &quot; waiting: &quot; +</span>
<a href="#l42.1009"></a><span id="l42.1009" class="difflineplus">+         ims.waiting + &quot;\n&quot;);</span>
<a href="#l42.1010"></a><span id="l42.1010"> </span>
<a href="#l42.1011"></a><span id="l42.1011" class="difflineminus">-      // call the verifier.  (we expect them to generate an exception if the</span>
<a href="#l42.1012"></a><span id="l42.1012" class="difflineminus">-      //  verification fails, using do_check_*/do_throw; we don't care about</span>
<a href="#l42.1013"></a><span id="l42.1013" class="difflineminus">-      //  the return value except to propagate forward to subsequent calls.)</span>
<a href="#l42.1014"></a><span id="l42.1014" class="difflineminus">-      for (let iMessage=0; iMessage &lt; ims.inputMessages.length; iMessage++) {</span>
<a href="#l42.1015"></a><span id="l42.1015" class="difflineminus">-        if (ims.verifier) {</span>
<a href="#l42.1016"></a><span id="l42.1016" class="difflineminus">-          try {</span>
<a href="#l42.1017"></a><span id="l42.1017" class="difflineminus">-            ims.previousValue = ims.verifier(ims.inputMessages[iMessage],</span>
<a href="#l42.1018"></a><span id="l42.1018" class="difflineminus">-                                             ims.glodaMessages[iMessage],</span>
<a href="#l42.1019"></a><span id="l42.1019" class="difflineminus">-                                             ims.previousValue);</span>
<a href="#l42.1020"></a><span id="l42.1020" class="difflineminus">-          }</span>
<a href="#l42.1021"></a><span id="l42.1021" class="difflineminus">-          catch (ex) {</span>
<a href="#l42.1022"></a><span id="l42.1022" class="difflineminus">-            do_throw(&quot;Exception during verification via &quot; + ims.verifier.name +</span>
<a href="#l42.1023"></a><span id="l42.1023" class="difflineminus">-                &quot; on message index: &quot; + iMessage + &quot; previous value: &quot; +</span>
<a href="#l42.1024"></a><span id="l42.1024" class="difflineminus">-                ims.previousValue + &quot; gloda message: &quot; +</span>
<a href="#l42.1025"></a><span id="l42.1025" class="difflineminus">-                ims.glodaMessages[iMessage] + &quot;\nexception: &quot; + ex);</span>
<a href="#l42.1026"></a><span id="l42.1026" class="difflineminus">-          }</span>
<a href="#l42.1027"></a><span id="l42.1027" class="difflineminus">-        }</span>
<a href="#l42.1028"></a><span id="l42.1028" class="difflineminus">-      }</span>
<a href="#l42.1029"></a><span id="l42.1029" class="difflineminus">-</span>
<a href="#l42.1030"></a><span id="l42.1030" class="difflineminus">-      dump(&quot;((( Verification complete\n&quot;);</span>
<a href="#l42.1031"></a><span id="l42.1031" class="difflineminus">-      if (ims.onDone) {</span>
<a href="#l42.1032"></a><span id="l42.1032" class="difflineminus">-        try {</span>
<a href="#l42.1033"></a><span id="l42.1033" class="difflineminus">-          ims.onDone();</span>
<a href="#l42.1034"></a><span id="l42.1034" class="difflineminus">-        }</span>
<a href="#l42.1035"></a><span id="l42.1035" class="difflineminus">-        catch (ex) {</span>
<a href="#l42.1036"></a><span id="l42.1036" class="difflineminus">-          do_throw(&quot;Exception calling ims.onDone (&quot; + ims.onDone.name + &quot;): &quot; +</span>
<a href="#l42.1037"></a><span id="l42.1037" class="difflineminus">-              ex);</span>
<a href="#l42.1038"></a><span id="l42.1038" class="difflineminus">-        }</span>
<a href="#l42.1039"></a><span id="l42.1039" class="difflineminus">-      }</span>
<a href="#l42.1040"></a><span id="l42.1040" class="difflineminus">-    }</span>
<a href="#l42.1041"></a><span id="l42.1041" class="difflineminus">-    else {</span>
<a href="#l42.1042"></a><span id="l42.1042" class="difflineminus">-      dump(&quot;((( gloda indexing listener notification. indexing: &quot; +</span>
<a href="#l42.1043"></a><span id="l42.1043" class="difflineminus">-           GlodaIndexer.indexing + &quot; status: &quot; + aStatus + &quot;\n&quot;);</span>
<a href="#l42.1044"></a><span id="l42.1044" class="difflineplus">+    // we only care if indexing has just completed and we're waiting</span>
<a href="#l42.1045"></a><span id="l42.1045" class="difflineplus">+    if (aStatus == Gloda.kIndexerIdle &amp;&amp; ims.waiting) {</span>
<a href="#l42.1046"></a><span id="l42.1046" class="difflineplus">+      ims.assertExpectedMessagesIndexed();</span>
<a href="#l42.1047"></a><span id="l42.1047" class="difflineplus">+      ims.waiting = false;</span>
<a href="#l42.1048"></a><span id="l42.1048" class="difflineplus">+      dump (&quot;  kicking driver...\n&quot;);</span>
<a href="#l42.1049"></a><span id="l42.1049" class="difflineplus">+      async_driver();</span>
<a href="#l42.1050"></a><span id="l42.1050">     }</span>
<a href="#l42.1051"></a><span id="l42.1051">   }</span>
<a href="#l42.1052"></a><span id="l42.1052"> };</span>
<a href="#l42.1053"></a><span id="l42.1053"> </span>
<a href="#l42.1054"></a><span id="l42.1054"> /**</span>
<a href="#l42.1055"></a><span id="l42.1055">  * Given a function that generates a set of synthetic messages, feed those</span>
<a href="#l42.1056"></a><span id="l42.1056">  *  messages to gloda to be indexed, verifying the resulting indexed messages</span>
<a href="#l42.1057"></a><span id="l42.1057">  *  have the desired properties by calling the provided verification function.</span>
<a href="#l42.1058"></a><span id="l42.1058" class="difflineat">@@ -747,97 +539,51 @@ var messageIndexerListener = {</span>
<a href="#l42.1059"></a><span id="l42.1059">  *</span>
<a href="#l42.1060"></a><span id="l42.1060">  * @param aScenarioMaker A function that, when called, will generate a series</span>
<a href="#l42.1061"></a><span id="l42.1061">  *   of SyntheticMessage instances.  Each call to this method should generate</span>
<a href="#l42.1062"></a><span id="l42.1062">  *   a new set of conceptually equivalent, but not identical, messages.  This</span>
<a href="#l42.1063"></a><span id="l42.1063">  *   allows us to process without having to reset our state back to nothing each</span>
<a href="#l42.1064"></a><span id="l42.1064">  *   time.  (This is more to try and make sure we run the system with a 'dirty'</span>
<a href="#l42.1065"></a><span id="l42.1065">  *   state than a bid for efficiency.)</span>
<a href="#l42.1066"></a><span id="l42.1066">  * @param aVerifier Verifier function, same signature/intent as the same</span>
<a href="#l42.1067"></a><span id="l42.1067" class="difflineminus">- *   argument for indexMessages (who we internally end up calling).</span>
<a href="#l42.1068"></a><span id="l42.1068" class="difflineminus">- * @param aOnDone The (optional) function to call when we have finished</span>
<a href="#l42.1069"></a><span id="l42.1069" class="difflineminus">- *   processing.  Note that this handler is only called when there are no</span>
<a href="#l42.1070"></a><span id="l42.1070" class="difflineminus">- *   additional jobs to be queued.  So if you queue up 5 jobs, you can pass in</span>
<a href="#l42.1071"></a><span id="l42.1071" class="difflineminus">- *   the same aOnDone handler for all of them, confident in the knowledge that</span>
<a href="#l42.1072"></a><span id="l42.1072" class="difflineminus">- *   only the last job will result in the done handler being called.</span>
<a href="#l42.1073"></a><span id="l42.1073" class="difflineplus">+ *   argument for wait_for_gloda_indexer (who we internally end up calling).</span>
<a href="#l42.1074"></a><span id="l42.1074">  */</span>
<a href="#l42.1075"></a><span id="l42.1075" class="difflineminus">-function indexAndPermuteMessages(aScenarioMaker, aVerifier, aOnDone) {</span>
<a href="#l42.1076"></a><span id="l42.1076" class="difflineminus">-  let mis = multiIndexState;</span>
<a href="#l42.1077"></a><span id="l42.1077" class="difflineminus">-</span>
<a href="#l42.1078"></a><span id="l42.1078" class="difflineminus">-  mis.queue.push([aScenarioMaker, aVerifier, aOnDone]);</span>
<a href="#l42.1079"></a><span id="l42.1079" class="difflineminus">-</span>
<a href="#l42.1080"></a><span id="l42.1080" class="difflineminus">-  // start processing it immediately if we're not doing anything...</span>
<a href="#l42.1081"></a><span id="l42.1081" class="difflineminus">-  if (!mis.active)</span>
<a href="#l42.1082"></a><span id="l42.1082" class="difflineminus">-    _multiIndexNext();</span>
<a href="#l42.1083"></a><span id="l42.1083" class="difflineplus">+function indexAndPermuteMessages(aScenarioMaker, aVerifier) {</span>
<a href="#l42.1084"></a><span id="l42.1084" class="difflineplus">+  return async_run({func: _runPermutations,</span>
<a href="#l42.1085"></a><span id="l42.1085" class="difflineplus">+                    args: [aScenarioMaker, aVerifier]});</span>
<a href="#l42.1086"></a><span id="l42.1086"> }</span>
<a href="#l42.1087"></a><span id="l42.1087"> </span>
<a href="#l42.1088"></a><span id="l42.1088"> /**</span>
<a href="#l42.1089"></a><span id="l42.1089" class="difflineminus">- * Helper function that does the actual multi-indexing work for each call</span>
<a href="#l42.1090"></a><span id="l42.1090" class="difflineminus">- *  made to indexAndPermuteMessages.  Since those calls can stack, the arguments</span>
<a href="#l42.1091"></a><span id="l42.1091" class="difflineminus">- *  are queued, and we process them when there is no (longer) a current job.</span>
<a href="#l42.1092"></a><span id="l42.1092" class="difflineminus">- *  _permutationIndexed handles the work of trying the subsequent permutations</span>
<a href="#l42.1093"></a><span id="l42.1093" class="difflineminus">- *  for each job we de-queue and initiate.</span>
<a href="#l42.1094"></a><span id="l42.1094" class="difflineplus">+ * Actual worker for |indexAndPermuteMessages|.  This only exists because</span>
<a href="#l42.1095"></a><span id="l42.1095" class="difflineplus">+ *  |indexAndPermuteMessages| can't be a generator itself, so it just shims to</span>
<a href="#l42.1096"></a><span id="l42.1096" class="difflineplus">+ *  us.</span>
<a href="#l42.1097"></a><span id="l42.1097">  */</span>
<a href="#l42.1098"></a><span id="l42.1098" class="difflineminus">-function _multiIndexNext() {</span>
<a href="#l42.1099"></a><span id="l42.1099" class="difflineminus">-  let mis = multiIndexState;</span>
<a href="#l42.1100"></a><span id="l42.1100" class="difflineminus">-</span>
<a href="#l42.1101"></a><span id="l42.1101" class="difflineminus">-  if (mis.queue.length) {</span>
<a href="#l42.1102"></a><span id="l42.1102" class="difflineminus">-    mis.active = true;</span>
<a href="#l42.1103"></a><span id="l42.1103" class="difflineminus">-</span>
<a href="#l42.1104"></a><span id="l42.1104" class="difflineminus">-    let [aScenarioMaker, aVerifier, aOnDone] = mis.queue.shift();</span>
<a href="#l42.1105"></a><span id="l42.1105" class="difflineplus">+function _runPermutations(aScenarioMaker, aVerifier) {</span>
<a href="#l42.1106"></a><span id="l42.1106" class="difflineplus">+  let folder = make_empty_folder();</span>
<a href="#l42.1107"></a><span id="l42.1107"> </span>
<a href="#l42.1108"></a><span id="l42.1108" class="difflineminus">-    let firstSet = aScenarioMaker();</span>
<a href="#l42.1109"></a><span id="l42.1109" class="difflineminus">-</span>
<a href="#l42.1110"></a><span id="l42.1110" class="difflineminus">-    mis.scenarioMaker = aScenarioMaker;</span>
<a href="#l42.1111"></a><span id="l42.1111" class="difflineminus">-    mis.verifier = aVerifier;</span>
<a href="#l42.1112"></a><span id="l42.1112" class="difflineminus">-    // 32 permutations is probably too generous, not to mention an odd choice.</span>
<a href="#l42.1113"></a><span id="l42.1113" class="difflineminus">-    mis.numPermutations = Math.min(factorial(firstSet.length), 32);</span>
<a href="#l42.1114"></a><span id="l42.1114" class="difflineminus">-    mis.nextPermutationId = 1;</span>
<a href="#l42.1115"></a><span id="l42.1115" class="difflineplus">+  // To calculate the permutations, we need to actually see what gets produced.</span>
<a href="#l42.1116"></a><span id="l42.1116" class="difflineplus">+  let scenarioMessages = aScenarioMaker();</span>
<a href="#l42.1117"></a><span id="l42.1117" class="difflineplus">+  let numPermutations = Math.min(factorial(scenarioMessages.length), 32);</span>
<a href="#l42.1118"></a><span id="l42.1118" class="difflineplus">+  for (let iPermutation = 0; iPermutation &lt; numPermutations; iPermutation++) {</span>
<a href="#l42.1119"></a><span id="l42.1119" class="difflineplus">+    mark_sub_test_start(&quot;Permutation&quot;,</span>
<a href="#l42.1120"></a><span id="l42.1120" class="difflineplus">+                        (iPermutation + 1) + &quot;/&quot; + numPermutations,</span>
<a href="#l42.1121"></a><span id="l42.1121" class="difflineplus">+                        true);</span>
<a href="#l42.1122"></a><span id="l42.1122" class="difflineplus">+    // if this is not the first time through, we need to create a new set</span>
<a href="#l42.1123"></a><span id="l42.1123" class="difflineplus">+    if (iPermutation)</span>
<a href="#l42.1124"></a><span id="l42.1124" class="difflineplus">+      scenarioMessages = aScenarioMaker();</span>
<a href="#l42.1125"></a><span id="l42.1125" class="difflineplus">+    scenarioMessages = permute(scenarioMessages, iPermutation);</span>
<a href="#l42.1126"></a><span id="l42.1126" class="difflineplus">+    let scenarioSet = new SyntheticMessageSet(scenarioMessages);</span>
<a href="#l42.1127"></a><span id="l42.1127" class="difflineplus">+    yield add_sets_to_folders(folder, [scenarioSet]);</span>
<a href="#l42.1128"></a><span id="l42.1128" class="difflineplus">+    yield wait_for_gloda_indexer(scenarioSet, aVerifier);</span>
<a href="#l42.1129"></a><span id="l42.1129"> </span>
<a href="#l42.1130"></a><span id="l42.1130" class="difflineminus">-    mis.onDone = aOnDone;</span>
<a href="#l42.1131"></a><span id="l42.1131" class="difflineminus">-</span>
<a href="#l42.1132"></a><span id="l42.1132" class="difflineminus">-    indexMessages(firstSet, mis.verifier, _permutationIndexed);</span>
<a href="#l42.1133"></a><span id="l42.1133" class="difflineminus">-  }</span>
<a href="#l42.1134"></a><span id="l42.1134" class="difflineminus">-  else {</span>
<a href="#l42.1135"></a><span id="l42.1135" class="difflineminus">-    mis.active = false;</span>
<a href="#l42.1136"></a><span id="l42.1136" class="difflineminus">-    if (mis.onDone)</span>
<a href="#l42.1137"></a><span id="l42.1137" class="difflineminus">-      mis.onDone();</span>
<a href="#l42.1138"></a><span id="l42.1138" class="difflineplus">+    mark_sub_test_end();</span>
<a href="#l42.1139"></a><span id="l42.1139">   }</span>
<a href="#l42.1140"></a><span id="l42.1140"> }</span>
<a href="#l42.1141"></a><span id="l42.1141"> </span>
<a href="#l42.1142"></a><span id="l42.1142"> /**</span>
<a href="#l42.1143"></a><span id="l42.1143" class="difflineminus">- * The onDone handler for indexAndPermuteMessages/_multiIndexNext's use of</span>
<a href="#l42.1144"></a><span id="l42.1144" class="difflineminus">- *  indexMessages under the hood.  Generates and initiates processing of then</span>
<a href="#l42.1145"></a><span id="l42.1145" class="difflineminus">- *  next permutation if any remain, otherwise deferring to _multiIndexNext to</span>
<a href="#l42.1146"></a><span id="l42.1146" class="difflineminus">- *  de-queue the next call/job or close up shop.</span>
<a href="#l42.1147"></a><span id="l42.1147" class="difflineminus">- */</span>
<a href="#l42.1148"></a><span id="l42.1148" class="difflineminus">-function _permutationIndexed() {</span>
<a href="#l42.1149"></a><span id="l42.1149" class="difflineminus">-  let mis = multiIndexState;</span>
<a href="#l42.1150"></a><span id="l42.1150" class="difflineminus">-  if (mis.nextPermutationId &lt; mis.numPermutations)</span>
<a href="#l42.1151"></a><span id="l42.1151" class="difflineminus">-    indexMessages(permute(mis.scenarioMaker(), mis.nextPermutationId++),</span>
<a href="#l42.1152"></a><span id="l42.1152" class="difflineminus">-                  mis.verifier, _permutationIndexed);</span>
<a href="#l42.1153"></a><span id="l42.1153" class="difflineminus">-  else</span>
<a href="#l42.1154"></a><span id="l42.1154" class="difflineminus">-    _multiIndexNext();</span>
<a href="#l42.1155"></a><span id="l42.1155" class="difflineminus">-}</span>
<a href="#l42.1156"></a><span id="l42.1156" class="difflineminus">-</span>
<a href="#l42.1157"></a><span id="l42.1157" class="difflineminus">-/**</span>
<a href="#l42.1158"></a><span id="l42.1158" class="difflineminus">- * The state global for indexAndPermuteMessages / _multiIndexNext /</span>
<a href="#l42.1159"></a><span id="l42.1159" class="difflineminus">- *  _permutationIndexed.</span>
<a href="#l42.1160"></a><span id="l42.1160" class="difflineminus">- */</span>
<a href="#l42.1161"></a><span id="l42.1161" class="difflineminus">-var multiIndexState = {</span>
<a href="#l42.1162"></a><span id="l42.1162" class="difflineminus">-  scenarioMaker: null,</span>
<a href="#l42.1163"></a><span id="l42.1163" class="difflineminus">-  verifier: null,</span>
<a href="#l42.1164"></a><span id="l42.1164" class="difflineminus">-  onDone: null,</span>
<a href="#l42.1165"></a><span id="l42.1165" class="difflineminus">-  numPermutations: undefined,</span>
<a href="#l42.1166"></a><span id="l42.1166" class="difflineminus">-  nextPermutationId: undefined,</span>
<a href="#l42.1167"></a><span id="l42.1167" class="difflineminus">-  active: false,</span>
<a href="#l42.1168"></a><span id="l42.1168" class="difflineminus">-  queue: []</span>
<a href="#l42.1169"></a><span id="l42.1169" class="difflineminus">-};</span>
<a href="#l42.1170"></a><span id="l42.1170" class="difflineminus">-</span>
<a href="#l42.1171"></a><span id="l42.1171" class="difflineminus">-/**</span>
<a href="#l42.1172"></a><span id="l42.1172">  * A simple factorial function used to calculate the number of permutations</span>
<a href="#l42.1173"></a><span id="l42.1173">  *  possible for a given set of messages.</span>
<a href="#l42.1174"></a><span id="l42.1174">  */</span>
<a href="#l42.1175"></a><span id="l42.1175"> function factorial(i, rv) {</span>
<a href="#l42.1176"></a><span id="l42.1176">   if (i &lt;= 1)</span>
<a href="#l42.1177"></a><span id="l42.1177">     return rv || 1;</span>
<a href="#l42.1178"></a><span id="l42.1178">   return factorial(i-1, (rv || 1) * i); // tail-call capable</span>
<a href="#l42.1179"></a><span id="l42.1179"> }</span>
<a href="#l42.1180"></a><span id="l42.1180" class="difflineat">@@ -857,64 +603,16 @@ function permute(aArray, aPermutationId)</span>
<a href="#l42.1181"></a><span id="l42.1181">     let offset = aPermutationId % l;</span>
<a href="#l42.1182"></a><span id="l42.1182">     out.push(aArray[offset]);</span>
<a href="#l42.1183"></a><span id="l42.1183">     aArray.splice(offset, 1);</span>
<a href="#l42.1184"></a><span id="l42.1184">     aPermutationId = Math.floor(aPermutationId / l);</span>
<a href="#l42.1185"></a><span id="l42.1185">   }</span>
<a href="#l42.1186"></a><span id="l42.1186">   return out;</span>
<a href="#l42.1187"></a><span id="l42.1187"> }</span>
<a href="#l42.1188"></a><span id="l42.1188"> </span>
<a href="#l42.1189"></a><span id="l42.1189" class="difflineminus">-/**</span>
<a href="#l42.1190"></a><span id="l42.1190" class="difflineminus">- * Given a SyntheticMessage instance, index it, and then process the contents</span>
<a href="#l42.1191"></a><span id="l42.1191" class="difflineminus">- *  of aActionsAndTests which provide &quot;twiddle&quot; functions that mutate the</span>
<a href="#l42.1192"></a><span id="l42.1192" class="difflineminus">- *  message and &quot;test&quot; functions that verify that the gloda message is</span>
<a href="#l42.1193"></a><span id="l42.1193" class="difflineminus">- *  accordingly updated to reflect the change.</span>
<a href="#l42.1194"></a><span id="l42.1194" class="difflineminus">- * This method automatically calls next_test when aActionsAndTests has been</span>
<a href="#l42.1195"></a><span id="l42.1195" class="difflineminus">- *  fully processed.</span>
<a href="#l42.1196"></a><span id="l42.1196" class="difflineminus">- *</span>
<a href="#l42.1197"></a><span id="l42.1197" class="difflineminus">- * @param aSynthMsg The synthetic message to index for testing.</span>
<a href="#l42.1198"></a><span id="l42.1198" class="difflineminus">- * @param aActionAndTests A list, where each sub-list is of the form [twiddle</span>
<a href="#l42.1199"></a><span id="l42.1199" class="difflineminus">- *     function, test function, twiddleValue, optionalTestValue].  The twiddle</span>
<a href="#l42.1200"></a><span id="l42.1200" class="difflineminus">- *     function is called with the nsIMsgDBHdr as its first argument and the</span>
<a href="#l42.1201"></a><span id="l42.1201" class="difflineminus">- *     twiddleValue as its second argument.  The test function is called with</span>
<a href="#l42.1202"></a><span id="l42.1202" class="difflineminus">- *     the synthetic message as its first argument, the gloda message as its</span>
<a href="#l42.1203"></a><span id="l42.1203" class="difflineminus">- *     second argument, and optionalTestValue as its third argument.  If the</span>
<a href="#l42.1204"></a><span id="l42.1204" class="difflineminus">- *     list did not contain an optionalTestValue (indicated by only having</span>
<a href="#l42.1205"></a><span id="l42.1205" class="difflineminus">- *     three elements in the list), then twiddleValue is passed instead.</span>
<a href="#l42.1206"></a><span id="l42.1206" class="difflineminus">- */</span>
<a href="#l42.1207"></a><span id="l42.1207" class="difflineminus">-function twiddleAndTest(aSynthMsg, aActionsAndTests) {</span>
<a href="#l42.1208"></a><span id="l42.1208" class="difflineminus">-  let iTwiddling = 0;</span>
<a href="#l42.1209"></a><span id="l42.1209" class="difflineminus">-  function twiddle_next_attr(smsg, gmsg) {</span>
<a href="#l42.1210"></a><span id="l42.1210" class="difflineminus">-    let curTwiddling = aActionsAndTests[iTwiddling];</span>
<a href="#l42.1211"></a><span id="l42.1211" class="difflineminus">-    let twiddleFunc = curTwiddling[0];</span>
<a href="#l42.1212"></a><span id="l42.1212" class="difflineminus">-    let desiredState = curTwiddling[2];</span>
<a href="#l42.1213"></a><span id="l42.1213" class="difflineminus">-</span>
<a href="#l42.1214"></a><span id="l42.1214" class="difflineminus">-    // the underlying nsIMsgDBHdr should exist at this point...</span>
<a href="#l42.1215"></a><span id="l42.1215" class="difflineminus">-    do_check_neq(gmsg.folderMessage, null);</span>
<a href="#l42.1216"></a><span id="l42.1216" class="difflineminus">-    // prepare</span>
<a href="#l42.1217"></a><span id="l42.1217" class="difflineminus">-    indexMessageState.expectMessages([gmsg.folderMessage], verify_next_attr);</span>
<a href="#l42.1218"></a><span id="l42.1218" class="difflineminus">-    // tell the function to perform its mutation to the desired state</span>
<a href="#l42.1219"></a><span id="l42.1219" class="difflineminus">-    twiddleFunc(gmsg.folderMessage, desiredState);</span>
<a href="#l42.1220"></a><span id="l42.1220" class="difflineminus">-  }</span>
<a href="#l42.1221"></a><span id="l42.1221" class="difflineminus">-  function verify_next_attr(smsg, gmsg) {</span>
<a href="#l42.1222"></a><span id="l42.1222" class="difflineminus">-    let curTwiddling = aActionsAndTests[iTwiddling];</span>
<a href="#l42.1223"></a><span id="l42.1223" class="difflineminus">-    let verifyFunc = curTwiddling[1];</span>
<a href="#l42.1224"></a><span id="l42.1224" class="difflineminus">-    let expectedVal = curTwiddling[curTwiddling.length == 3 ? 2 : 3];</span>
<a href="#l42.1225"></a><span id="l42.1225" class="difflineminus">-    dump(&quot;verifying: &quot; + verifyFunc.name + &quot;: &quot; + expectedVal + &quot;\n&quot;);</span>
<a href="#l42.1226"></a><span id="l42.1226" class="difflineminus">-    verifyFunc(smsg, gmsg, expectedVal);</span>
<a href="#l42.1227"></a><span id="l42.1227" class="difflineminus">-</span>
<a href="#l42.1228"></a><span id="l42.1228" class="difflineminus">-    if (++iTwiddling &lt; aActionsAndTests.length)</span>
<a href="#l42.1229"></a><span id="l42.1229" class="difflineminus">-      twiddle_next_attr(smsg, gmsg);</span>
<a href="#l42.1230"></a><span id="l42.1230" class="difflineminus">-    else</span>
<a href="#l42.1231"></a><span id="l42.1231" class="difflineminus">-      next_test();</span>
<a href="#l42.1232"></a><span id="l42.1232" class="difflineminus">-  }</span>
<a href="#l42.1233"></a><span id="l42.1233" class="difflineminus">-</span>
<a href="#l42.1234"></a><span id="l42.1234" class="difflineminus">-  indexMessages([aSynthMsg], twiddle_next_attr);</span>
<a href="#l42.1235"></a><span id="l42.1235" class="difflineminus">-}</span>
<a href="#l42.1236"></a><span id="l42.1236" class="difflineminus">-</span>
<a href="#l42.1237"></a><span id="l42.1237"> var _defaultExpectationExtractors = {};</span>
<a href="#l42.1238"></a><span id="l42.1238"> _defaultExpectationExtractors[Gloda.NOUN_MESSAGE] = [</span>
<a href="#l42.1239"></a><span id="l42.1239">   function expectExtract_message_gloda(aGlodaMessage) {</span>
<a href="#l42.1240"></a><span id="l42.1240">     return aGlodaMessage.headerMessageID;</span>
<a href="#l42.1241"></a><span id="l42.1241">   },</span>
<a href="#l42.1242"></a><span id="l42.1242">   function expectExtract_message_synth(aSynthMessage) {</span>
<a href="#l42.1243"></a><span id="l42.1243">     return aSynthMessage.messageId;</span>
<a href="#l42.1244"></a><span id="l42.1244">   }</span>
<a href="#l42.1245"></a><span id="l42.1245" class="difflineat">@@ -936,21 +634,23 @@ var _defaultExpectationExtractors = {};</span>
<a href="#l42.1246"></a><span id="l42.1246">   }</span>
<a href="#l42.1247"></a><span id="l42.1247"> ];</span>
<a href="#l42.1248"></a><span id="l42.1248"> </span>
<a href="#l42.1249"></a><span id="l42.1249"> function expectExtract_default_toString(aThing) {</span>
<a href="#l42.1250"></a><span id="l42.1250">   return aThing.toString();</span>
<a href="#l42.1251"></a><span id="l42.1251"> }</span>
<a href="#l42.1252"></a><span id="l42.1252"> </span>
<a href="#l42.1253"></a><span id="l42.1253"> /// see {queryExpect} for info on what we do</span>
<a href="#l42.1254"></a><span id="l42.1254" class="difflineminus">-function QueryExpectationListener(aExpectedSet, aGlodaExtractor, aOrderVerifier) {</span>
<a href="#l42.1255"></a><span id="l42.1255" class="difflineplus">+function QueryExpectationListener(aExpectedSet, aGlodaExtractor,</span>
<a href="#l42.1256"></a><span id="l42.1256" class="difflineplus">+                                  aOrderVerifier, aCallerStackFrame) {</span>
<a href="#l42.1257"></a><span id="l42.1257">   this.expectedSet = aExpectedSet;</span>
<a href="#l42.1258"></a><span id="l42.1258">   this.glodaExtractor = aGlodaExtractor;</span>
<a href="#l42.1259"></a><span id="l42.1259">   this.orderVerifier = aOrderVerifier;</span>
<a href="#l42.1260"></a><span id="l42.1260">   this.completed = false;</span>
<a href="#l42.1261"></a><span id="l42.1261" class="difflineplus">+  this.callerStackFrame = aCallerStackFrame;</span>
<a href="#l42.1262"></a><span id="l42.1262">   // track our current 'index' in the results for the (optional) order verifier,</span>
<a href="#l42.1263"></a><span id="l42.1263">   //  but also so we can provide slightly more useful debug output</span>
<a href="#l42.1264"></a><span id="l42.1264">   this.nextIndex = 0;</span>
<a href="#l42.1265"></a><span id="l42.1265"> }</span>
<a href="#l42.1266"></a><span id="l42.1266"> </span>
<a href="#l42.1267"></a><span id="l42.1267"> QueryExpectationListener.prototype = {</span>
<a href="#l42.1268"></a><span id="l42.1268">   onItemsAdded: function query_expectation_onItemsAdded(aItems, aCollection) {</span>
<a href="#l42.1269"></a><span id="l42.1269">     for each (let [, item] in Iterator(aItems)) {</span>
<a href="#l42.1270"></a><span id="l42.1270" class="difflineat">@@ -961,23 +661,20 @@ QueryExpectationListener.prototype = {</span>
<a href="#l42.1271"></a><span id="l42.1271">       catch (ex) {</span>
<a href="#l42.1272"></a><span id="l42.1272">         do_throw(&quot;Gloda extractor threw during query expectation for item: &quot; +</span>
<a href="#l42.1273"></a><span id="l42.1273">                  item + &quot; exception: &quot; + ex);</span>
<a href="#l42.1274"></a><span id="l42.1274">       }</span>
<a href="#l42.1275"></a><span id="l42.1275"> </span>
<a href="#l42.1276"></a><span id="l42.1276">       // make sure we were expecting this guy</span>
<a href="#l42.1277"></a><span id="l42.1277">       if (glodaStringRep in this.expectedSet)</span>
<a href="#l42.1278"></a><span id="l42.1278">         delete this.expectedSet[glodaStringRep];</span>
<a href="#l42.1279"></a><span id="l42.1279" class="difflineminus">-      else {</span>
<a href="#l42.1280"></a><span id="l42.1280" class="difflineminus">-        ddumpObject(item, &quot;item&quot;, 0);</span>
<a href="#l42.1281"></a><span id="l42.1281" class="difflineminus">-        ddumpObject(this.expectedSet, &quot;expectedSet&quot;, 1);</span>
<a href="#l42.1282"></a><span id="l42.1282" class="difflineminus">-        dump(&quot;glodaStringRep: &quot; + glodaStringRep + &quot;\n&quot;);</span>
<a href="#l42.1283"></a><span id="l42.1283" class="difflineminus">-        do_throw(&quot;Query returned unexpected result! gloda rep:&quot; +</span>
<a href="#l42.1284"></a><span id="l42.1284" class="difflineminus">-                 glodaStringRep);</span>
<a href="#l42.1285"></a><span id="l42.1285" class="difflineminus">-      }</span>
<a href="#l42.1286"></a><span id="l42.1286" class="difflineplus">+      else</span>
<a href="#l42.1287"></a><span id="l42.1287" class="difflineplus">+        mark_failure([&quot;Query returned unexpected result!&quot;, item,</span>
<a href="#l42.1288"></a><span id="l42.1288" class="difflineplus">+                      &quot;expected set&quot;, this.expectedSet,</span>
<a href="#l42.1289"></a><span id="l42.1289" class="difflineplus">+                      &quot;caller&quot;, this.callerStackFrame]);</span>
<a href="#l42.1290"></a><span id="l42.1290"> </span>
<a href="#l42.1291"></a><span id="l42.1291">       if (this.orderVerifier) {</span>
<a href="#l42.1292"></a><span id="l42.1292">         try {</span>
<a href="#l42.1293"></a><span id="l42.1293">           this.orderVerifier(this.nextIndex, item, aCollection);</span>
<a href="#l42.1294"></a><span id="l42.1294">         }</span>
<a href="#l42.1295"></a><span id="l42.1295">         catch (ex) {</span>
<a href="#l42.1296"></a><span id="l42.1296">           // if the order was wrong, we could probably go for an output of what</span>
<a href="#l42.1297"></a><span id="l42.1297">           //  we actually got...</span>
<a href="#l42.1298"></a><span id="l42.1298" class="difflineat">@@ -1013,20 +710,24 @@ QueryExpectationListener.prototype = {</span>
<a href="#l42.1299"></a><span id="l42.1299">     aCollection.becomeExplicit();</span>
<a href="#l42.1300"></a><span id="l42.1300"> </span>
<a href="#l42.1301"></a><span id="l42.1301">     // expectedSet should now be empty</span>
<a href="#l42.1302"></a><span id="l42.1302">     for each (let [key, value] in Iterator(this.expectedSet)) {</span>
<a href="#l42.1303"></a><span id="l42.1303">       dump(&quot;I have seen &quot; + this.nextIndex + &quot; results, but not:\n&quot;);</span>
<a href="#l42.1304"></a><span id="l42.1304">       do_throw(&quot;Query should have returned &quot; + key + &quot; (&quot; + value + &quot;)&quot;);</span>
<a href="#l42.1305"></a><span id="l42.1305">     }</span>
<a href="#l42.1306"></a><span id="l42.1306"> </span>
<a href="#l42.1307"></a><span id="l42.1307" class="difflineminus">-    dump(&quot;&gt;&gt;&gt; queryCompleted, advancing to next test\n&quot;);</span>
<a href="#l42.1308"></a><span id="l42.1308" class="difflineminus">-    next_test();</span>
<a href="#l42.1309"></a><span id="l42.1309" class="difflineplus">+    // xpcshell exposure that we did something</span>
<a href="#l42.1310"></a><span id="l42.1310" class="difflineplus">+    _passedChecks++;</span>
<a href="#l42.1311"></a><span id="l42.1311" class="difflineplus">+</span>
<a href="#l42.1312"></a><span id="l42.1312" class="difflineplus">+    mark_action(&quot;glodaTestHelper&quot;, &quot;query satisfied with:&quot;, aCollection.items);</span>
<a href="#l42.1313"></a><span id="l42.1313" class="difflineplus">+    dump(&quot;&gt;&gt;&gt; queryCompleted\n&quot;);</span>
<a href="#l42.1314"></a><span id="l42.1314" class="difflineplus">+    async_driver();</span>
<a href="#l42.1315"></a><span id="l42.1315">   },</span>
<a href="#l42.1316"></a><span id="l42.1316" class="difflineminus">-}</span>
<a href="#l42.1317"></a><span id="l42.1317" class="difflineplus">+};</span>
<a href="#l42.1318"></a><span id="l42.1318"> </span>
<a href="#l42.1319"></a><span id="l42.1319"> /**</span>
<a href="#l42.1320"></a><span id="l42.1320">  * Execute the given query, verifying that the result set contains exactly the</span>
<a href="#l42.1321"></a><span id="l42.1321">  *  contents of the expected set; no more, no less.  Since we expect that the</span>
<a href="#l42.1322"></a><span id="l42.1322">  *  query will result in gloda objects, but your expectations will not be posed</span>
<a href="#l42.1323"></a><span id="l42.1323">  *  in terms of gloda objects (though they could be), we rely on extractor</span>
<a href="#l42.1324"></a><span id="l42.1324">  *  functions to take the gloda result objects and the expected result objects</span>
<a href="#l42.1325"></a><span id="l42.1325">  *  into the same string.</span>
<a href="#l42.1326"></a><span id="l42.1326" class="difflineat">@@ -1037,17 +738,19 @@ QueryExpectationListener.prototype = {</span>
<a href="#l42.1327"></a><span id="l42.1327">  *  checked.</span>
<a href="#l42.1328"></a><span id="l42.1328">  *</span>
<a href="#l42.1329"></a><span id="l42.1329">  * @param aQuery Either a query to execute, or a dict with the following keys:</span>
<a href="#l42.1330"></a><span id="l42.1330">  *     - queryFunc: The function to call that returns a function.</span>
<a href="#l42.1331"></a><span id="l42.1331">  *     - queryThis: The 'this' to use for the invocation of queryFunc.</span>
<a href="#l42.1332"></a><span id="l42.1332">  *     - args: A list (possibly empty) or arguments to precede the traditional</span>
<a href="#l42.1333"></a><span id="l42.1333">  *         arguments to query.getCollection.</span>
<a href="#l42.1334"></a><span id="l42.1334">  *     - nounId: The (numeric) noun id of the noun type expected to be returned.</span>
<a href="#l42.1335"></a><span id="l42.1335" class="difflineminus">- * @param aExpectedSet The list of expected results from the query.</span>
<a href="#l42.1336"></a><span id="l42.1336" class="difflineplus">+ * @param aExpectedSet The list of expected results from the query where each</span>
<a href="#l42.1337"></a><span id="l42.1337" class="difflineplus">+ *     item is suitable for extraction using aExpectedExtractor.  We have a soft</span>
<a href="#l42.1338"></a><span id="l42.1338" class="difflineplus">+ *     spot for SyntheticMessageSets and automatically unbox them.</span>
<a href="#l42.1339"></a><span id="l42.1339">  * @param aGlodaExtractor The extractor function to take an instance of the</span>
<a href="#l42.1340"></a><span id="l42.1340">  *     gloda representation and return a string for comparison/equivalence</span>
<a href="#l42.1341"></a><span id="l42.1341">  *     against that returned by the expected extractor (against the input</span>
<a href="#l42.1342"></a><span id="l42.1342">  *     instance in aExpectedSet.)  The value returned must be unique for all</span>
<a href="#l42.1343"></a><span id="l42.1343">  *     of the expected gloda representations of the expected set.  If omitted,</span>
<a href="#l42.1344"></a><span id="l42.1344">  *     the default extractor for the gloda noun type is used.  If no default</span>
<a href="#l42.1345"></a><span id="l42.1345">  *     extractor exists, toString is called on the item.</span>
<a href="#l42.1346"></a><span id="l42.1346">  * @param aExpectedExtractor The extractor function to take an instance from the</span>
<a href="#l42.1347"></a><span id="l42.1347" class="difflineat">@@ -1062,16 +765,19 @@ QueryExpectationListener.prototype = {</span>
<a href="#l42.1348"></a><span id="l42.1348">  * @returns The collection created from the query.</span>
<a href="#l42.1349"></a><span id="l42.1349">  */</span>
<a href="#l42.1350"></a><span id="l42.1350"> function queryExpect(aQuery, aExpectedSet, aGlodaExtractor,</span>
<a href="#l42.1351"></a><span id="l42.1351">     aExpectedExtractor, aOrderVerifier) {</span>
<a href="#l42.1352"></a><span id="l42.1352">   if (aQuery.test)</span>
<a href="#l42.1353"></a><span id="l42.1353">     aQuery = {queryFunc: aQuery.getCollection, queryThis: aQuery, args: [],</span>
<a href="#l42.1354"></a><span id="l42.1354">               nounId: aQuery._nounDef.id};</span>
<a href="#l42.1355"></a><span id="l42.1355"> </span>
<a href="#l42.1356"></a><span id="l42.1356" class="difflineplus">+  if (&quot;synMessages&quot; in aExpectedSet)</span>
<a href="#l42.1357"></a><span id="l42.1357" class="difflineplus">+    aExpectedSet = aExpectedSet.synMessages;</span>
<a href="#l42.1358"></a><span id="l42.1358" class="difflineplus">+</span>
<a href="#l42.1359"></a><span id="l42.1359">   // - set extractor functions to defaults if omitted</span>
<a href="#l42.1360"></a><span id="l42.1360">   if (aGlodaExtractor == null) {</span>
<a href="#l42.1361"></a><span id="l42.1361">     if (_defaultExpectationExtractors[aQuery.nounId] !== undefined)</span>
<a href="#l42.1362"></a><span id="l42.1362">       aGlodaExtractor = _defaultExpectationExtractors[aQuery.nounId][0];</span>
<a href="#l42.1363"></a><span id="l42.1363">     else</span>
<a href="#l42.1364"></a><span id="l42.1364">       aGlodaExtractor = expectExtract_default_toString;</span>
<a href="#l42.1365"></a><span id="l42.1365">   }</span>
<a href="#l42.1366"></a><span id="l42.1366">   if (aExpectedExtractor == null) {</span>
<a href="#l42.1367"></a><span id="l42.1367" class="difflineat">@@ -1087,141 +793,248 @@ function queryExpect(aQuery, aExpectedSe</span>
<a href="#l42.1368"></a><span id="l42.1368">     try {</span>
<a href="#l42.1369"></a><span id="l42.1369">       expectedSet[aExpectedExtractor(item)] = item;</span>
<a href="#l42.1370"></a><span id="l42.1370">     }</span>
<a href="#l42.1371"></a><span id="l42.1371">     catch (ex) {</span>
<a href="#l42.1372"></a><span id="l42.1372">       do_throw(&quot;Expected extractor threw during query expectation for item: &quot; +</span>
<a href="#l42.1373"></a><span id="l42.1373">                item + &quot; exception: &quot; + ex);</span>
<a href="#l42.1374"></a><span id="l42.1374">     }</span>
<a href="#l42.1375"></a><span id="l42.1375">   }</span>
<a href="#l42.1376"></a><span id="l42.1376" class="difflineplus">+  mark_action(&quot;glodaTestHelper&quot;, &quot;expecting&quot;, [expectedSet]);</span>
<a href="#l42.1377"></a><span id="l42.1377"> </span>
<a href="#l42.1378"></a><span id="l42.1378">   // - create the listener...</span>
<a href="#l42.1379"></a><span id="l42.1379">   aQuery.args.push(new QueryExpectationListener(expectedSet,</span>
<a href="#l42.1380"></a><span id="l42.1380">                                                 aGlodaExtractor,</span>
<a href="#l42.1381"></a><span id="l42.1381" class="difflineminus">-                                                aOrderVerifier));</span>
<a href="#l42.1382"></a><span id="l42.1382" class="difflineplus">+                                                aOrderVerifier,</span>
<a href="#l42.1383"></a><span id="l42.1383" class="difflineplus">+                                                Components.stack.caller));</span>
<a href="#l42.1384"></a><span id="l42.1384">   return aQuery.queryFunc.apply(aQuery.queryThis, aQuery.args);</span>
<a href="#l42.1385"></a><span id="l42.1385"> }</span>
<a href="#l42.1386"></a><span id="l42.1386"> </span>
<a href="#l42.1387"></a><span id="l42.1387"> /**</span>
<a href="#l42.1388"></a><span id="l42.1388" class="difflineminus">- * Call the provided callback once the database has run all the async statements</span>
<a href="#l42.1389"></a><span id="l42.1389" class="difflineminus">- *  whose execution was queued prior to this call.</span>
<a href="#l42.1390"></a><span id="l42.1390" class="difflineminus">- * @param aCallback The callback to call.  No 'this' provided.</span>
<a href="#l42.1391"></a><span id="l42.1391" class="difflineplus">+ * Run an (async) SQL statement against the gloda database.  The statement</span>
<a href="#l42.1392"></a><span id="l42.1392" class="difflineplus">+ *  should be a SELECT COUNT; we check the count against aExpectedCount.</span>
<a href="#l42.1393"></a><span id="l42.1393" class="difflineplus">+ *  Any additional arguments are positionally bound to the statement.</span>
<a href="#l42.1394"></a><span id="l42.1394" class="difflineplus">+ *</span>
<a href="#l42.1395"></a><span id="l42.1395" class="difflineplus">+ * We run the statement asynchronously to get a consistent view of the database.</span>
<a href="#l42.1396"></a><span id="l42.1396">  */</span>
<a href="#l42.1397"></a><span id="l42.1397" class="difflineminus">-function notifyWhenDatastoreDone(aCallback) {</span>
<a href="#l42.1398"></a><span id="l42.1398" class="difflineplus">+function sqlExpectCount(aExpectedCount, aSQLString /* ... params */) {</span>
<a href="#l42.1399"></a><span id="l42.1399" class="difflineplus">+  let conn = GlodaDatastore.asyncConnection;</span>
<a href="#l42.1400"></a><span id="l42.1400" class="difflineplus">+  let stmt = conn.createStatement(aSQLString);</span>
<a href="#l42.1401"></a><span id="l42.1401" class="difflineplus">+</span>
<a href="#l42.1402"></a><span id="l42.1402" class="difflineplus">+  for (let iArg = 2; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l42.1403"></a><span id="l42.1403" class="difflineplus">+    GlodaDatastore._bindVariant(stmt, iArg-2, arguments[iArg]);</span>
<a href="#l42.1404"></a><span id="l42.1404" class="difflineplus">+  }</span>
<a href="#l42.1405"></a><span id="l42.1405" class="difflineplus">+</span>
<a href="#l42.1406"></a><span id="l42.1406" class="difflineplus">+  let desc = Array.slice.call(arguments, 1);</span>
<a href="#l42.1407"></a><span id="l42.1407" class="difflineplus">+  mark_action(&quot;glodaTestHelper&quot;, &quot;running SQL count&quot;, desc);</span>
<a href="#l42.1408"></a><span id="l42.1408" class="difflineplus">+  stmt.executeAsync(new _SqlExpectationListener(aExpectedCount, desc,</span>
<a href="#l42.1409"></a><span id="l42.1409" class="difflineplus">+                                                Components.stack.caller));</span>
<a href="#l42.1410"></a><span id="l42.1410" class="difflineplus">+  // we don't need the statement anymore</span>
<a href="#l42.1411"></a><span id="l42.1411" class="difflineplus">+  stmt.finalize();</span>
<a href="#l42.1412"></a><span id="l42.1412" class="difflineplus">+</span>
<a href="#l42.1413"></a><span id="l42.1413" class="difflineplus">+  return false;</span>
<a href="#l42.1414"></a><span id="l42.1414" class="difflineplus">+}</span>
<a href="#l42.1415"></a><span id="l42.1415" class="difflineplus">+</span>
<a href="#l42.1416"></a><span id="l42.1416" class="difflineplus">+function _SqlExpectationListener(aExpectedCount, aDesc, aCallerStackFrame) {</span>
<a href="#l42.1417"></a><span id="l42.1417" class="difflineplus">+  this.actualCount = null;</span>
<a href="#l42.1418"></a><span id="l42.1418" class="difflineplus">+  this.expectedCount = aExpectedCount;</span>
<a href="#l42.1419"></a><span id="l42.1419" class="difflineplus">+  this.sqlDesc = aDesc;</span>
<a href="#l42.1420"></a><span id="l42.1420" class="difflineplus">+  this.callerStackFrame = aCallerStackFrame;</span>
<a href="#l42.1421"></a><span id="l42.1421" class="difflineplus">+}</span>
<a href="#l42.1422"></a><span id="l42.1422" class="difflineplus">+_SqlExpectationListener.prototype = {</span>
<a href="#l42.1423"></a><span id="l42.1423" class="difflineplus">+  handleResult: function sel_handleResult(aResultSet) {</span>
<a href="#l42.1424"></a><span id="l42.1424" class="difflineplus">+    let row = aResultSet.getNextRow();</span>
<a href="#l42.1425"></a><span id="l42.1425" class="difflineplus">+    if (!row)</span>
<a href="#l42.1426"></a><span id="l42.1426" class="difflineplus">+      mark_failure([&quot;No result row returned from caller&quot;, this.callerStackFrame,</span>
<a href="#l42.1427"></a><span id="l42.1427" class="difflineplus">+                    &quot;SQL:&quot;, sqlDesc]);</span>
<a href="#l42.1428"></a><span id="l42.1428" class="difflineplus">+    this.actualCount = row.getInt64(0);</span>
<a href="#l42.1429"></a><span id="l42.1429" class="difflineplus">+  },</span>
<a href="#l42.1430"></a><span id="l42.1430" class="difflineplus">+</span>
<a href="#l42.1431"></a><span id="l42.1431" class="difflineplus">+  handleError: function sel_handleError(aError) {</span>
<a href="#l42.1432"></a><span id="l42.1432" class="difflineplus">+    mark_failure([&quot;SQL error from caller&quot;, this.callerStackFrame,</span>
<a href="#l42.1433"></a><span id="l42.1433" class="difflineplus">+                  &quot;result&quot;, aError, &quot;SQL: &quot;, sqlDesc]);</span>
<a href="#l42.1434"></a><span id="l42.1434" class="difflineplus">+  },</span>
<a href="#l42.1435"></a><span id="l42.1435" class="difflineplus">+</span>
<a href="#l42.1436"></a><span id="l42.1436" class="difflineplus">+  handleCompletion: function sel_handleCompletion(aReason) {</span>
<a href="#l42.1437"></a><span id="l42.1437" class="difflineplus">+    if (this.actualCount != this.expectedCount)</span>
<a href="#l42.1438"></a><span id="l42.1438" class="difflineplus">+      mark_failure([&quot;Actual count of&quot;, this.actualCount,</span>
<a href="#l42.1439"></a><span id="l42.1439" class="difflineplus">+                    &quot;does not match expected count of&quot;, this.expectedCount,</span>
<a href="#l42.1440"></a><span id="l42.1440" class="difflineplus">+                    &quot;from caller&quot;, this.callerStackFrame,</span>
<a href="#l42.1441"></a><span id="l42.1441" class="difflineplus">+                    &quot;SQL&quot;, this.sqlDesc]);</span>
<a href="#l42.1442"></a><span id="l42.1442" class="difflineplus">+    async_driver();</span>
<a href="#l42.1443"></a><span id="l42.1443" class="difflineplus">+  },</span>
<a href="#l42.1444"></a><span id="l42.1444" class="difflineplus">+};</span>
<a href="#l42.1445"></a><span id="l42.1445" class="difflineplus">+</span>
<a href="#l42.1446"></a><span id="l42.1446" class="difflineplus">+/**</span>
<a href="#l42.1447"></a><span id="l42.1447" class="difflineplus">+ * Resume execution when the db has run all the async statements whose execution</span>
<a href="#l42.1448"></a><span id="l42.1448" class="difflineplus">+ *  was queued prior to this call.  We trigger a commit to accomplish this,</span>
<a href="#l42.1449"></a><span id="l42.1449" class="difflineplus">+ *  although this could also be accomplished without a commit.  (Though we would</span>
<a href="#l42.1450"></a><span id="l42.1450" class="difflineplus">+ *  have to reach into datastore.js and get at the raw connection or extend</span>
<a href="#l42.1451"></a><span id="l42.1451" class="difflineplus">+ *  datastore to provide a way to accomplish this.)</span>
<a href="#l42.1452"></a><span id="l42.1452" class="difflineplus">+ */</span>
<a href="#l42.1453"></a><span id="l42.1453" class="difflineplus">+function wait_for_gloda_db_flush() {</span>
<a href="#l42.1454"></a><span id="l42.1454">   // we already have a mechanism to do this by forcing a commit.  arguably,</span>
<a href="#l42.1455"></a><span id="l42.1455">   //  it would be better to use a mechanism that does not induce an fsync.</span>
<a href="#l42.1456"></a><span id="l42.1456">   var savedDepth = GlodaDatastore._transactionDepth;</span>
<a href="#l42.1457"></a><span id="l42.1457">   if (!savedDepth)</span>
<a href="#l42.1458"></a><span id="l42.1458">     GlodaDatastore._beginTransaction();</span>
<a href="#l42.1459"></a><span id="l42.1459" class="difflineminus">-  GlodaDatastore.runPostCommit(aCallback);</span>
<a href="#l42.1460"></a><span id="l42.1460" class="difflineplus">+  GlodaDatastore.runPostCommit(async_driver);</span>
<a href="#l42.1461"></a><span id="l42.1461">   // we don't actually need to run things to zero... we can just wait for the</span>
<a href="#l42.1462"></a><span id="l42.1462">   //  outer transaction to close itself...</span>
<a href="#l42.1463"></a><span id="l42.1463">   GlodaDatastore._commitTransaction();</span>
<a href="#l42.1464"></a><span id="l42.1464">   if (savedDepth)</span>
<a href="#l42.1465"></a><span id="l42.1465">     GlodaDatastore._beginTransaction();</span>
<a href="#l42.1466"></a><span id="l42.1466" class="difflineplus">+  return false;</span>
<a href="#l42.1467"></a><span id="l42.1467" class="difflineplus">+}</span>
<a href="#l42.1468"></a><span id="l42.1468" class="difflineplus">+</span>
<a href="#l42.1469"></a><span id="l42.1469" class="difflineplus">+let _gloda_simulate_hang_data = null;</span>
<a href="#l42.1470"></a><span id="l42.1470" class="difflineplus">+let _gloda_simulate_hang_waiting_for_hang = false;</span>
<a href="#l42.1471"></a><span id="l42.1471" class="difflineplus">+</span>
<a href="#l42.1472"></a><span id="l42.1472" class="difflineplus">+function _simulate_hang_on_MsgHdrToMimeMessage() {</span>
<a href="#l42.1473"></a><span id="l42.1473" class="difflineplus">+  _gloda_simulate_hang_data = [MsgHdrToMimeMessage, null, arguments];</span>
<a href="#l42.1474"></a><span id="l42.1474" class="difflineplus">+  if (_gloda_simulate_hang_waiting_for_hang)</span>
<a href="#l42.1475"></a><span id="l42.1475" class="difflineplus">+    async_driver();</span>
<a href="#l42.1476"></a><span id="l42.1476" class="difflineplus">+}</span>
<a href="#l42.1477"></a><span id="l42.1477" class="difflineplus">+</span>
<a href="#l42.1478"></a><span id="l42.1478" class="difflineplus">+/**</span>
<a href="#l42.1479"></a><span id="l42.1479" class="difflineplus">+ * If you have configured gloda to hang while indexing, this is the thing</span>
<a href="#l42.1480"></a><span id="l42.1480" class="difflineplus">+ *  you wait on to make sure the indexer actually gets to the point where it</span>
<a href="#l42.1481"></a><span id="l42.1481" class="difflineplus">+ *  hangs.</span>
<a href="#l42.1482"></a><span id="l42.1482" class="difflineplus">+ */</span>
<a href="#l42.1483"></a><span id="l42.1483" class="difflineplus">+function wait_for_indexing_hang() {</span>
<a href="#l42.1484"></a><span id="l42.1484" class="difflineplus">+  // if we already hit the hang, no need to do anything async...</span>
<a href="#l42.1485"></a><span id="l42.1485" class="difflineplus">+  if (_gloda_simulate_hang_data != null)</span>
<a href="#l42.1486"></a><span id="l42.1486" class="difflineplus">+    return true;</span>
<a href="#l42.1487"></a><span id="l42.1487" class="difflineplus">+  _gloda_simulate_hang_waiting_for_hang = true;</span>
<a href="#l42.1488"></a><span id="l42.1488" class="difflineplus">+  return false;</span>
<a href="#l42.1489"></a><span id="l42.1489"> }</span>
<a href="#l42.1490"></a><span id="l42.1490"> </span>
<a href="#l42.1491"></a><span id="l42.1491" class="difflineminus">-var glodaHelperTests = [];</span>
<a href="#l42.1492"></a><span id="l42.1492" class="difflineminus">-var glodaHelperIterator = null;</span>
<a href="#l42.1493"></a><span id="l42.1493" class="difflineplus">+/**</span>
<a href="#l42.1494"></a><span id="l42.1494" class="difflineplus">+ * An injected fault exception.</span>
<a href="#l42.1495"></a><span id="l42.1495" class="difflineplus">+ */</span>
<a href="#l42.1496"></a><span id="l42.1496" class="difflineplus">+function InjectedFault(aWhy) {</span>
<a href="#l42.1497"></a><span id="l42.1497" class="difflineplus">+  this.message = aWhy;</span>
<a href="#l42.1498"></a><span id="l42.1498" class="difflineplus">+}</span>
<a href="#l42.1499"></a><span id="l42.1499" class="difflineplus">+InjectedFault.prototype = {</span>
<a href="#l42.1500"></a><span id="l42.1500" class="difflineplus">+  toString: function() {</span>
<a href="#l42.1501"></a><span id="l42.1501" class="difflineplus">+    return &quot;[InjectedFault: &quot; + this.message + &quot;]&quot;;</span>
<a href="#l42.1502"></a><span id="l42.1502" class="difflineplus">+  }</span>
<a href="#l42.1503"></a><span id="l42.1503" class="difflineplus">+};</span>
<a href="#l42.1504"></a><span id="l42.1504"> </span>
<a href="#l42.1505"></a><span id="l42.1505" class="difflineminus">-function _gh_test_iterator() {</span>
<a href="#l42.1506"></a><span id="l42.1506" class="difflineminus">-  do_test_pending();</span>
<a href="#l42.1507"></a><span id="l42.1507" class="difflineplus">+function _inject_failure_on_MsgHdrToMimeMessage() {</span>
<a href="#l42.1508"></a><span id="l42.1508" class="difflineplus">+  throw new InjectedFault(&quot;MsgHdrToMimeMessage&quot;);</span>
<a href="#l42.1509"></a><span id="l42.1509" class="difflineplus">+}</span>
<a href="#l42.1510"></a><span id="l42.1510"> </span>
<a href="#l42.1511"></a><span id="l42.1511" class="difflineminus">-  for (let iTest=0; iTest &lt; glodaHelperTests.length; iTest++) {</span>
<a href="#l42.1512"></a><span id="l42.1512" class="difflineminus">-    let test = glodaHelperTests[iTest];</span>
<a href="#l42.1513"></a><span id="l42.1513" class="difflineminus">-    // deal with parameterized tests (via parameterizeTest)</span>
<a href="#l42.1514"></a><span id="l42.1514" class="difflineminus">-    if (test.length) {</span>
<a href="#l42.1515"></a><span id="l42.1515" class="difflineminus">-      let [testFunc, parameters] = test;</span>
<a href="#l42.1516"></a><span id="l42.1516" class="difflineminus">-      for each (let [, parameter] in Iterator(parameters)) {</span>
<a href="#l42.1517"></a><span id="l42.1517" class="difflineminus">-        dump(&quot;====== Test function: &quot; + testFunc.name + &quot; Parameter: &quot; +</span>
<a href="#l42.1518"></a><span id="l42.1518" class="difflineminus">-             parameter.name + &quot;\n&quot;);</span>
<a href="#l42.1519"></a><span id="l42.1519" class="difflineminus">-        yield testFunc(parameter);</span>
<a href="#l42.1520"></a><span id="l42.1520" class="difflineminus">-      }</span>
<a href="#l42.1521"></a><span id="l42.1521" class="difflineminus">-    }</span>
<a href="#l42.1522"></a><span id="l42.1522" class="difflineminus">-    else {</span>
<a href="#l42.1523"></a><span id="l42.1523" class="difflineminus">-      dump(&quot;====== Test function: &quot; + test.name + &quot;\n&quot;);</span>
<a href="#l42.1524"></a><span id="l42.1524" class="difflineminus">-      yield test();</span>
<a href="#l42.1525"></a><span id="l42.1525" class="difflineminus">-    }</span>
<a href="#l42.1526"></a><span id="l42.1526" class="difflineminus">-  }</span>
<a href="#l42.1527"></a><span id="l42.1527" class="difflineminus">-</span>
<a href="#l42.1528"></a><span id="l42.1528" class="difflineminus">-  if (indexMessageState.injectMechanism == INJECT_FAKE_SERVER ||</span>
<a href="#l42.1529"></a><span id="l42.1529" class="difflineminus">-      indexMessageState.injectMechanism == INJECT_IMAP_FAKE_SERVER) {</span>
<a href="#l42.1530"></a><span id="l42.1530" class="difflineminus">-    do_test_pending();</span>
<a href="#l42.1531"></a><span id="l42.1531" class="difflineminus">-    // Give a bit of time for any remaining notifications to go through.</span>
<a href="#l42.1532"></a><span id="l42.1532" class="difflineminus">-    do_timeout(500, &quot;killFakeServer()&quot;);</span>
<a href="#l42.1533"></a><span id="l42.1533" class="difflineplus">+/**</span>
<a href="#l42.1534"></a><span id="l42.1534" class="difflineplus">+ * Configure gloda indexing.  For most settings, the settings get clobbered by</span>
<a href="#l42.1535"></a><span id="l42.1535" class="difflineplus">+ *  the next time this method is called.  Omitted settings reset to the defaults.</span>
<a href="#l42.1536"></a><span id="l42.1536" class="difflineplus">+ *  However, anything labeled as a 'sticky' setting stays that way until</span>
<a href="#l42.1537"></a><span id="l42.1537" class="difflineplus">+ *  explicitly changed.</span>
<a href="#l42.1538"></a><span id="l42.1538" class="difflineplus">+ *</span>
<a href="#l42.1539"></a><span id="l42.1539" class="difflineplus">+ * @param {boolean} [aArgs.event=true] Should event-driven indexing be enabled</span>
<a href="#l42.1540"></a><span id="l42.1540" class="difflineplus">+ *     (true) or disabled (false)?  Right now, this actually suppresses</span>
<a href="#l42.1541"></a><span id="l42.1541" class="difflineplus">+ *     indexing... the semantics will be ironed out as-needed.</span>
<a href="#l42.1542"></a><span id="l42.1542" class="difflineplus">+ * @param [aArgs.hangWhile] Must be either omitted (for don't force a hang) or</span>
<a href="#l42.1543"></a><span id="l42.1543" class="difflineplus">+ *     &quot;streaming&quot; indicating that we should do a no-op instead of performing</span>
<a href="#l42.1544"></a><span id="l42.1544" class="difflineplus">+ *     the message streaming.  This will manifest as a hang until</span>
<a href="#l42.1545"></a><span id="l42.1545" class="difflineplus">+ *     |resume_from_simulated_hang| is invoked or the test explicitly causes the</span>
<a href="#l42.1546"></a><span id="l42.1546" class="difflineplus">+ *     indexer to abort (in which case you do not need to call the resume</span>
<a href="#l42.1547"></a><span id="l42.1547" class="difflineplus">+ *     function.)  You must omit injectFaultIn if you use hangWhile.</span>
<a href="#l42.1548"></a><span id="l42.1548" class="difflineplus">+ * @param [aArgs.injectFaultIn=null] Must be omitted (for don't inject a</span>
<a href="#l42.1549"></a><span id="l42.1549" class="difflineplus">+ *     failure) or &quot;streaming&quot; indicating that we should inject a failure when</span>
<a href="#l42.1550"></a><span id="l42.1550" class="difflineplus">+ *     the message indexer attempts to stream a message.  The fault will be an</span>
<a href="#l42.1551"></a><span id="l42.1551" class="difflineplus">+ *     appropriate exception.  You must omit hangWhile if you use injectFaultIn.</span>
<a href="#l42.1552"></a><span id="l42.1552" class="difflineplus">+ */</span>
<a href="#l42.1553"></a><span id="l42.1553" class="difflineplus">+function configure_gloda_indexing(aArgs) {</span>
<a href="#l42.1554"></a><span id="l42.1554" class="difflineplus">+  let shouldSuppress = (&quot;event&quot; in aArgs) ? !aArgs.event : false;</span>
<a href="#l42.1555"></a><span id="l42.1555" class="difflineplus">+  if (shouldSuppress != GlodaIndexer.suppressIndexing) {</span>
<a href="#l42.1556"></a><span id="l42.1556" class="difflineplus">+    mark_action(&quot;glodaTestHelper&quot;,</span>
<a href="#l42.1557"></a><span id="l42.1557" class="difflineplus">+                &quot;setting supress indexing to &quot; + shouldSuppress, []);</span>
<a href="#l42.1558"></a><span id="l42.1558" class="difflineplus">+    GlodaIndexer.suppressIndexing = shouldSuppress;</span>
<a href="#l42.1559"></a><span id="l42.1559">   }</span>
<a href="#l42.1560"></a><span id="l42.1560"> </span>
<a href="#l42.1561"></a><span id="l42.1561" class="difflineminus">-  do_test_finished();</span>
<a href="#l42.1562"></a><span id="l42.1562" class="difflineminus">-</span>
<a href="#l42.1563"></a><span id="l42.1563" class="difflineminus">-  // once the control flow hits the root after do_test_finished, we're done,</span>
<a href="#l42.1564"></a><span id="l42.1564" class="difflineminus">-  //  so let's just yield something to avoid callers having to deal with an</span>
<a href="#l42.1565"></a><span id="l42.1565" class="difflineminus">-  //  exception indicating completion.</span>
<a href="#l42.1566"></a><span id="l42.1566" class="difflineminus">-  yield null;</span>
<a href="#l42.1567"></a><span id="l42.1567" class="difflineminus">-  yield null;</span>
<a href="#l42.1568"></a><span id="l42.1568" class="difflineplus">+  if (&quot;hangWhile&quot; in aArgs) {</span>
<a href="#l42.1569"></a><span id="l42.1569" class="difflineplus">+    mark_action(&quot;glodaTestHelper&quot;, &quot;enabling hang injection in&quot;,</span>
<a href="#l42.1570"></a><span id="l42.1570" class="difflineplus">+                [aArgs.hangWhile]);</span>
<a href="#l42.1571"></a><span id="l42.1571" class="difflineplus">+    switch (aArgs.hangWhile) {</span>
<a href="#l42.1572"></a><span id="l42.1572" class="difflineplus">+      case &quot;streaming&quot;:</span>
<a href="#l42.1573"></a><span id="l42.1573" class="difflineplus">+        GlodaMsgIndexer._MsgHdrToMimeMessageFunc =</span>
<a href="#l42.1574"></a><span id="l42.1574" class="difflineplus">+          _simulate_hang_on_MsgHdrToMimeMessage;</span>
<a href="#l42.1575"></a><span id="l42.1575" class="difflineplus">+        break;</span>
<a href="#l42.1576"></a><span id="l42.1576" class="difflineplus">+      default:</span>
<a href="#l42.1577"></a><span id="l42.1577" class="difflineplus">+        mark_failure([aArgs.hangWhile,</span>
<a href="#l42.1578"></a><span id="l42.1578" class="difflineplus">+                      &quot;is not a legal choice for hangWhile&quot;]);</span>
<a href="#l42.1579"></a><span id="l42.1579" class="difflineplus">+    }</span>
<a href="#l42.1580"></a><span id="l42.1580" class="difflineplus">+  }</span>
<a href="#l42.1581"></a><span id="l42.1581" class="difflineplus">+  else if (&quot;injectFaultIn&quot; in aArgs) {</span>
<a href="#l42.1582"></a><span id="l42.1582" class="difflineplus">+    mark_action(&quot;glodaTestHelper&quot;, &quot;enabling fault injection in&quot;,</span>
<a href="#l42.1583"></a><span id="l42.1583" class="difflineplus">+                [aArgs.hangWhile]);</span>
<a href="#l42.1584"></a><span id="l42.1584" class="difflineplus">+    switch (aArgs.injectFaultIn) {</span>
<a href="#l42.1585"></a><span id="l42.1585" class="difflineplus">+      case &quot;streaming&quot;:</span>
<a href="#l42.1586"></a><span id="l42.1586" class="difflineplus">+        GlodaMsgIndexer._MsgHdrToMimeMessageFunc =</span>
<a href="#l42.1587"></a><span id="l42.1587" class="difflineplus">+          _inject_failure_on_MsgHdrToMimeMessage;</span>
<a href="#l42.1588"></a><span id="l42.1588" class="difflineplus">+        break;</span>
<a href="#l42.1589"></a><span id="l42.1589" class="difflineplus">+      default:</span>
<a href="#l42.1590"></a><span id="l42.1590" class="difflineplus">+        mark_failure([aArgs.injectFaultIn,</span>
<a href="#l42.1591"></a><span id="l42.1591" class="difflineplus">+                      &quot;is not a legal choice for injectFaultIn&quot;]);</span>
<a href="#l42.1592"></a><span id="l42.1592" class="difflineplus">+    }</span>
<a href="#l42.1593"></a><span id="l42.1593" class="difflineplus">+  }</span>
<a href="#l42.1594"></a><span id="l42.1594" class="difflineplus">+  else {</span>
<a href="#l42.1595"></a><span id="l42.1595" class="difflineplus">+    if (GlodaMsgIndexer._MsgHdrToMimeMessageFunc != MsgHdrToMimeMessage)</span>
<a href="#l42.1596"></a><span id="l42.1596" class="difflineplus">+      mark_action(&quot;glodaTestHelper&quot;, &quot;clearing hang/fault injection&quot;, []);</span>
<a href="#l42.1597"></a><span id="l42.1597" class="difflineplus">+    GlodaMsgIndexer._MsgHdrToMimeMessageFunc = MsgHdrToMimeMessage;</span>
<a href="#l42.1598"></a><span id="l42.1598" class="difflineplus">+  }</span>
<a href="#l42.1599"></a><span id="l42.1599"> }</span>
<a href="#l42.1600"></a><span id="l42.1600"> </span>
<a href="#l42.1601"></a><span id="l42.1601" class="difflineminus">-var _next_test_currently_in_test = false;</span>
<a href="#l42.1602"></a><span id="l42.1602" class="difflineminus">-function next_test() {</span>
<a href="#l42.1603"></a><span id="l42.1603" class="difflineminus">-  // to avoid crazy messed up stacks, use a time-out to get us to our next thing</span>
<a href="#l42.1604"></a><span id="l42.1604" class="difflineminus">-  if (_next_test_currently_in_test) {</span>
<a href="#l42.1605"></a><span id="l42.1605" class="difflineminus">-    do_timeout(0, &quot;next_test()&quot;);</span>
<a href="#l42.1606"></a><span id="l42.1606" class="difflineminus">-    return;</span>
<a href="#l42.1607"></a><span id="l42.1607" class="difflineminus">-  }</span>
<a href="#l42.1608"></a><span id="l42.1608" class="difflineminus">-</span>
<a href="#l42.1609"></a><span id="l42.1609" class="difflineminus">-  _next_test_currently_in_test = true;</span>
<a href="#l42.1610"></a><span id="l42.1610" class="difflineminus">-  try {</span>
<a href="#l42.1611"></a><span id="l42.1611" class="difflineminus">-    glodaHelperIterator.next();</span>
<a href="#l42.1612"></a><span id="l42.1612" class="difflineminus">-  }</span>
<a href="#l42.1613"></a><span id="l42.1613" class="difflineminus">-  catch (ex) {</span>
<a href="#l42.1614"></a><span id="l42.1614" class="difflineminus">-    dumpExc(ex);</span>
<a href="#l42.1615"></a><span id="l42.1615" class="difflineminus">-    do_throw(&quot;Caught an exception during execution of next_test: &quot; + ex + &quot;: &quot; + ex.stack);</span>
<a href="#l42.1616"></a><span id="l42.1616" class="difflineplus">+/**</span>
<a href="#l42.1617"></a><span id="l42.1617" class="difflineplus">+ * Call this to resume from the hang induced by configuring the indexer with</span>
<a href="#l42.1618"></a><span id="l42.1618" class="difflineplus">+ *  a &quot;hangWhile&quot; argument to |configure_gloda_indexing|.</span>
<a href="#l42.1619"></a><span id="l42.1619" class="difflineplus">+ *</span>
<a href="#l42.1620"></a><span id="l42.1620" class="difflineplus">+ * @param [aJustResumeExecution=false] Should we just poke the callback driver</span>
<a href="#l42.1621"></a><span id="l42.1621" class="difflineplus">+ *     for the indexer rather than continuing the call.  You would likely want</span>
<a href="#l42.1622"></a><span id="l42.1622" class="difflineplus">+ *     to do this if you committed a lot of violence while in the simulated</span>
<a href="#l42.1623"></a><span id="l42.1623" class="difflineplus">+ *     hang and proper resumption would throw exceptions all over the place.</span>
<a href="#l42.1624"></a><span id="l42.1624" class="difflineplus">+ *     (For example; if you hang before streaming and destroy the message</span>
<a href="#l42.1625"></a><span id="l42.1625" class="difflineplus">+ *     header while suspended, resuming the attempt to stream will throw.)</span>
<a href="#l42.1626"></a><span id="l42.1626" class="difflineplus">+ */</span>
<a href="#l42.1627"></a><span id="l42.1627" class="difflineplus">+function resume_from_simulated_hang(aJustResumeExecution) {</span>
<a href="#l42.1628"></a><span id="l42.1628" class="difflineplus">+  if (aJustResumeExecution) {</span>
<a href="#l42.1629"></a><span id="l42.1629" class="difflineplus">+    mark_action(&quot;glodaTestHelper&quot;,</span>
<a href="#l42.1630"></a><span id="l42.1630" class="difflineplus">+                &quot;resuming from simulated hang with direct wrapper callback&quot;,</span>
<a href="#l42.1631"></a><span id="l42.1631" class="difflineplus">+                []);</span>
<a href="#l42.1632"></a><span id="l42.1632" class="difflineplus">+    GlodaIndexer._wrapCallbackDriver();</span>
<a href="#l42.1633"></a><span id="l42.1633">   }</span>
<a href="#l42.1634"></a><span id="l42.1634" class="difflineminus">-  _next_test_currently_in_test = false;</span>
<a href="#l42.1635"></a><span id="l42.1635" class="difflineminus">-}</span>
<a href="#l42.1636"></a><span id="l42.1636" class="difflineminus">-</span>
<a href="#l42.1637"></a><span id="l42.1637" class="difflineminus">-DEFAULT_LONGEST_TEST_RUN_CONCEIVABLE_SECS = 180;</span>
<a href="#l42.1638"></a><span id="l42.1638" class="difflineminus">-</span>
<a href="#l42.1639"></a><span id="l42.1639" class="difflineminus">-/**</span>
<a href="#l42.1640"></a><span id="l42.1640" class="difflineminus">- * Purely decorative function to help explain to people reading lists of tests</span>
<a href="#l42.1641"></a><span id="l42.1641" class="difflineminus">- *  using glodaHelperRunTests what is going on.  We just return a tuple of our</span>
<a href="#l42.1642"></a><span id="l42.1642" class="difflineminus">- *  arguments and _gh_test_iterator understands what to do with this, namely</span>
<a href="#l42.1643"></a><span id="l42.1643" class="difflineminus">- *  to run the test once for each element in the aParameters list.  If the</span>
<a href="#l42.1644"></a><span id="l42.1644" class="difflineminus">- *  elements in the aParameters list have a 'name' attribute, it will get</span>
<a href="#l42.1645"></a><span id="l42.1645" class="difflineminus">- *  printed out to help figure out what is actually happening.</span>
<a href="#l42.1646"></a><span id="l42.1646" class="difflineminus">- */</span>
<a href="#l42.1647"></a><span id="l42.1647" class="difflineminus">-function parameterizeTest(aTestFunc, aParameters) {</span>
<a href="#l42.1648"></a><span id="l42.1648" class="difflineminus">-  return [aTestFunc, aParameters];</span>
<a href="#l42.1649"></a><span id="l42.1649" class="difflineplus">+  else {</span>
<a href="#l42.1650"></a><span id="l42.1650" class="difflineplus">+    let [func, dis, args] = _gloda_simulate_hang_data;</span>
<a href="#l42.1651"></a><span id="l42.1651" class="difflineplus">+    mark_action(&quot;glodaTestHelper&quot;,</span>
<a href="#l42.1652"></a><span id="l42.1652" class="difflineplus">+                &quot;resuming from simulated hang with call to: &quot; + func.name,</span>
<a href="#l42.1653"></a><span id="l42.1653" class="difflineplus">+                []);</span>
<a href="#l42.1654"></a><span id="l42.1654" class="difflineplus">+    func.apply(dis, args);</span>
<a href="#l42.1655"></a><span id="l42.1655" class="difflineplus">+  }</span>
<a href="#l42.1656"></a><span id="l42.1656"> }</span>
<a href="#l42.1657"></a><span id="l42.1657"> </span>
<a href="#l42.1658"></a><span id="l42.1658"> /**</span>
<a href="#l42.1659"></a><span id="l42.1659">  * Test driving logic that takes a list of tests to run.  Every completed test</span>
<a href="#l42.1660"></a><span id="l42.1660">  *  needs to call (or cause to be called) next_test.</span>
<a href="#l42.1661"></a><span id="l42.1661">  *</span>
<a href="#l42.1662"></a><span id="l42.1662">  * @param aTests A list of test functions to call.</span>
<a href="#l42.1663"></a><span id="l42.1663" class="difflineminus">- * @param aLongestTestRunTimeConceivableInSecs Optional parameter</span>
<a href="#l42.1664"></a><span id="l42.1664" class="difflineminus">- * @param aDontInitIMS Optional parameter. If this is specified then the index</span>
<a href="#l42.1665"></a><span id="l42.1665" class="difflineminus">- *                     message state is not initialized</span>
<a href="#l42.1666"></a><span id="l42.1666" class="difflineplus">+ * @param [aNounID] The noun ID for the noun under test.</span>
<a href="#l42.1667"></a><span id="l42.1667">  */</span>
<a href="#l42.1668"></a><span id="l42.1668" class="difflineminus">-function glodaHelperRunTests(aTests, aLongestTestRunTimeConceivableInSecs,</span>
<a href="#l42.1669"></a><span id="l42.1669" class="difflineminus">-                             aDontInitIMS) {</span>
<a href="#l42.1670"></a><span id="l42.1670" class="difflineminus">-  if (aLongestTestRunTimeConceivableInSecs == null)</span>
<a href="#l42.1671"></a><span id="l42.1671" class="difflineminus">-    aLongestTestRunTimeConceivableInSecs =</span>
<a href="#l42.1672"></a><span id="l42.1672" class="difflineminus">-        DEFAULT_LONGEST_TEST_RUN_CONCEIVABLE_SECS;</span>
<a href="#l42.1673"></a><span id="l42.1673" class="difflineminus">-  do_timeout(aLongestTestRunTimeConceivableInSecs * 1000,</span>
<a href="#l42.1674"></a><span id="l42.1674" class="difflineminus">-      &quot;do_throw('Timeout running test, and we want you to have the log.');&quot;);</span>
<a href="#l42.1675"></a><span id="l42.1675" class="difflineplus">+function glodaHelperRunTests(aTests, aNounID) {</span>
<a href="#l42.1676"></a><span id="l42.1676" class="difflineplus">+  // Initialize the message state if we are dealing with messages.  At some</span>
<a href="#l42.1677"></a><span id="l42.1677" class="difflineplus">+  //  point we probably want to just completely generalize the indexing state.</span>
<a href="#l42.1678"></a><span id="l42.1678" class="difflineplus">+  //  That point is likely when our testing infrastructure needs the support</span>
<a href="#l42.1679"></a><span id="l42.1679" class="difflineplus">+  //  provided by _indexMessageState for things other than messages.</span>
<a href="#l42.1680"></a><span id="l42.1680" class="difflineplus">+  if (aNounID === undefined ||</span>
<a href="#l42.1681"></a><span id="l42.1681" class="difflineplus">+      aNounID == Gloda.NOUN_MESSAGE)</span>
<a href="#l42.1682"></a><span id="l42.1682" class="difflineplus">+    _indexMessageState._init();</span>
<a href="#l42.1683"></a><span id="l42.1683"> </span>
<a href="#l42.1684"></a><span id="l42.1684" class="difflineminus">-  if (!aDontInitIMS)</span>
<a href="#l42.1685"></a><span id="l42.1685" class="difflineminus">-    imsInit();</span>
<a href="#l42.1686"></a><span id="l42.1686" class="difflineminus">-  // even if we don't want to init IMS, we want to avoid anything adaptive</span>
<a href="#l42.1687"></a><span id="l42.1687" class="difflineminus">-  //  happening.</span>
<a href="#l42.1688"></a><span id="l42.1688" class="difflineminus">-  else</span>
<a href="#l42.1689"></a><span id="l42.1689" class="difflineminus">-    prepareIndexerForTesting();</span>
<a href="#l42.1690"></a><span id="l42.1690" class="difflineminus">-  glodaHelperTests = aTests;</span>
<a href="#l42.1691"></a><span id="l42.1691" class="difflineminus">-  glodaHelperIterator = _gh_test_iterator();</span>
<a href="#l42.1692"></a><span id="l42.1692" class="difflineminus">-  next_test();</span>
<a href="#l42.1693"></a><span id="l42.1693" class="difflineplus">+  _prepareIndexerForTesting();</span>
<a href="#l42.1694"></a><span id="l42.1694" class="difflineplus">+</span>
<a href="#l42.1695"></a><span id="l42.1695" class="difflineplus">+  async_run_tests(aTests);</span>
<a href="#l42.1696"></a><span id="l42.1696"> }</span>
<a href="#l42.1697"></a><span id="l42.1697"> </span>
<a href="#l42.1698"></a><span id="l42.1698"> /**</span>
<a href="#l42.1699"></a><span id="l42.1699">  * Wipe out almost everything from the clutches of the GlodaCollectionManager.</span>
<a href="#l42.1700"></a><span id="l42.1700">  * By default, it is caching things and knows about all the non-GC'ed</span>
<a href="#l42.1701"></a><span id="l42.1701">  *  collections.  Tests may want to ensure that their data is loaded from disk</span>
<a href="#l42.1702"></a><span id="l42.1702">  *  rather than relying on the cache, and so, we exist.</span>
<a href="#l42.1703"></a><span id="l42.1703">  * The exception to everything is that Gloda's concept of myContact and</span>
<a href="#l42.1704"></a><span id="l42.1704" class="difflineat">@@ -1247,40 +1060,24 @@ function nukeGlodaCachesAndCollections()</span>
<a href="#l42.1705"></a><span id="l42.1705">   // we can just blow away the known collections</span>
<a href="#l42.1706"></a><span id="l42.1706">   GlodaCollectionManager._collectionsByNoun = {};</span>
<a href="#l42.1707"></a><span id="l42.1707">   // but then we have to put the myContact / myIdentities junk back</span>
<a href="#l42.1708"></a><span id="l42.1708">   if (Gloda._myContactCollection) {</span>
<a href="#l42.1709"></a><span id="l42.1709">     GlodaCollectionManager.registerCollection(Gloda._myContactCollection);</span>
<a href="#l42.1710"></a><span id="l42.1710">     GlodaCollectionManager.registerCollection(Gloda._myIdentitiesCollection);</span>
<a href="#l42.1711"></a><span id="l42.1711">   }</span>
<a href="#l42.1712"></a><span id="l42.1712">   // don't forget our testing catch-all collection!</span>
<a href="#l42.1713"></a><span id="l42.1713" class="difflineminus">-  if (indexMessageState.catchAllCollection) {</span>
<a href="#l42.1714"></a><span id="l42.1714" class="difflineplus">+  if (_indexMessageState.catchAllCollection) {</span>
<a href="#l42.1715"></a><span id="l42.1715">     // empty it out in case it has anything in it</span>
<a href="#l42.1716"></a><span id="l42.1716" class="difflineminus">-    indexMessageState.catchAllCollection.clear();</span>
<a href="#l42.1717"></a><span id="l42.1717" class="difflineplus">+    _indexMessageState.catchAllCollection.clear();</span>
<a href="#l42.1718"></a><span id="l42.1718">     // and now we can register it</span>
<a href="#l42.1719"></a><span id="l42.1719">     GlodaCollectionManager.registerCollection(</span>
<a href="#l42.1720"></a><span id="l42.1720" class="difflineminus">-        indexMessageState.catchAllCollection);</span>
<a href="#l42.1721"></a><span id="l42.1721" class="difflineplus">+        _indexMessageState.catchAllCollection);</span>
<a href="#l42.1722"></a><span id="l42.1722">   }</span>
<a href="#l42.1723"></a><span id="l42.1723"> </span>
<a href="#l42.1724"></a><span id="l42.1724">   // caches aren't intended to be cleared, but we also don't want to lose our</span>
<a href="#l42.1725"></a><span id="l42.1725">   //  caches, so we need to create new ones from the ashes of the old ones.</span>
<a href="#l42.1726"></a><span id="l42.1726">   let oldCaches = GlodaCollectionManager._cachesByNoun;</span>
<a href="#l42.1727"></a><span id="l42.1727">   GlodaCollectionManager._cachesByNoun = {};</span>
<a href="#l42.1728"></a><span id="l42.1728">   for each (let cache in oldCaches) {</span>
<a href="#l42.1729"></a><span id="l42.1729">     GlodaCollectionManager.defineCache(cache._nounDef, cache._maxCacheSize);</span>
<a href="#l42.1730"></a><span id="l42.1730">   }</span>
<a href="#l42.1731"></a><span id="l42.1731"> }</span>
<a href="#l42.1732"></a><span id="l42.1732" class="difflineminus">-</span>
<a href="#l42.1733"></a><span id="l42.1733" class="difflineminus">-/**</span>
<a href="#l42.1734"></a><span id="l42.1734" class="difflineminus">- * Given an IMAP folder, marks it offline and downloads its messages.</span>
<a href="#l42.1735"></a><span id="l42.1735" class="difflineminus">- *</span>
<a href="#l42.1736"></a><span id="l42.1736" class="difflineminus">- * @param aFolder an IMAP message folder</span>
<a href="#l42.1737"></a><span id="l42.1737" class="difflineminus">- * @param aSynthMessages see indexMessageState.expectMessages</span>
<a href="#l42.1738"></a><span id="l42.1738" class="difflineminus">- * @param aVerifier see indexMessageState.expectMessages</span>
<a href="#l42.1739"></a><span id="l42.1739" class="difflineminus">- * @param aDone see indexMessageState.expectMessages</span>
<a href="#l42.1740"></a><span id="l42.1740" class="difflineminus">- */</span>
<a href="#l42.1741"></a><span id="l42.1741" class="difflineminus">-function imapDownloadAllMessages(aFolder, aSynthMessages, aVerifier, aDone) {</span>
<a href="#l42.1742"></a><span id="l42.1742" class="difflineminus">-  // Let the message state know that we're expecting messages</span>
<a href="#l42.1743"></a><span id="l42.1743" class="difflineminus">-  indexMessageState.expectMessages(aSynthMessages, aVerifier, aDone);</span>
<a href="#l42.1744"></a><span id="l42.1744" class="difflineminus">-  aFolder.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l42.1745"></a><span id="l42.1745" class="difflineminus">-  aFolder.downloadAllForOffline(null, null);</span>
<a href="#l42.1746"></a><span id="l42.1746" class="difflineminus">-  // The indexer listener is going to call aDone, so our job is done here</span>
<a href="#l42.1747"></a><span id="l42.1747" class="difflineminus">-}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/mockIndexer.js</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/mockIndexer.js</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineat">@@ -16,23 +16,23 @@ var MockIndexer = {</span>
<a href="#l43.4"></a><span id="l43.4">   },</span>
<a href="#l43.5"></a><span id="l43.5">   initialSweep: function() {</span>
<a href="#l43.6"></a><span id="l43.6">     this.initialSweepCalled = false;</span>
<a href="#l43.7"></a><span id="l43.7">   },</span>
<a href="#l43.8"></a><span id="l43.8">   /* mock interface */</span>
<a href="#l43.9"></a><span id="l43.9">   enabled: false,</span>
<a href="#l43.10"></a><span id="l43.10">   initialSweepCalled: false,</span>
<a href="#l43.11"></a><span id="l43.11">   indexForever: function() {</span>
<a href="#l43.12"></a><span id="l43.12" class="difflineminus">-    GlodaIndexer.indexJob(new IndexingJob(&quot;forever&quot;, 0, null));</span>
<a href="#l43.13"></a><span id="l43.13" class="difflineplus">+    GlodaIndexer.indexJob(new IndexingJob(&quot;forever&quot;, null));</span>
<a href="#l43.14"></a><span id="l43.14">   },</span>
<a href="#l43.15"></a><span id="l43.15">   stopIndexingForever: function() {</span>
<a href="#l43.16"></a><span id="l43.16">     GlodaIndexer.callbackDriver();</span>
<a href="#l43.17"></a><span id="l43.17">   },</span>
<a href="#l43.18"></a><span id="l43.18">   /* implementation */</span>
<a href="#l43.19"></a><span id="l43.19">   _worker_index_forever: function(aJob, aCallbackHandle) {</span>
<a href="#l43.20"></a><span id="l43.20">     // pretend that something async is happening, but nothing is really</span>
<a href="#l43.21"></a><span id="l43.21">     //  happening!  muahahaha!</span>
<a href="#l43.22"></a><span id="l43.22" class="difflineminus">-    // </span>
<a href="#l43.23"></a><span id="l43.23" class="difflineplus">+    //</span>
<a href="#l43.24"></a><span id="l43.24">     yield GlodaIndexer.kWorkAsync;</span>
<a href="#l43.25"></a><span id="l43.25">     yield GlodaIndexer.kWorkDone;</span>
<a href="#l43.26"></a><span id="l43.26">   }</span>
<a href="#l43.27"></a><span id="l43.27"> };</span>
<a href="#l43.28"></a><span id="l43.28"> GlodaIndexer.registerIndexer(MockIndexer);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_cleanup_msf_databases.js</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineat">@@ -1,86 +1,112 @@</span>
<a href="#l44.4"></a><span id="l44.4" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l44.5"></a><span id="l44.5" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l44.6"></a><span id="l44.6" class="difflineplus">+ *</span>
<a href="#l44.7"></a><span id="l44.7" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l44.8"></a><span id="l44.8" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l44.9"></a><span id="l44.9" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l44.10"></a><span id="l44.10" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l44.11"></a><span id="l44.11" class="difflineplus">+ *</span>
<a href="#l44.12"></a><span id="l44.12" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l44.13"></a><span id="l44.13" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l44.14"></a><span id="l44.14" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l44.15"></a><span id="l44.15" class="difflineplus">+ * License.</span>
<a href="#l44.16"></a><span id="l44.16" class="difflineplus">+ *</span>
<a href="#l44.17"></a><span id="l44.17" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l44.18"></a><span id="l44.18" class="difflineplus">+ *</span>
<a href="#l44.19"></a><span id="l44.19" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l44.20"></a><span id="l44.20" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l44.21"></a><span id="l44.21" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l44.22"></a><span id="l44.22" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l44.23"></a><span id="l44.23" class="difflineplus">+ *</span>
<a href="#l44.24"></a><span id="l44.24" class="difflineplus">+ * Contributor(s):</span>
<a href="#l44.25"></a><span id="l44.25" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l44.26"></a><span id="l44.26" class="difflineplus">+ *</span>
<a href="#l44.27"></a><span id="l44.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l44.28"></a><span id="l44.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l44.29"></a><span id="l44.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l44.30"></a><span id="l44.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l44.31"></a><span id="l44.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l44.32"></a><span id="l44.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l44.33"></a><span id="l44.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l44.34"></a><span id="l44.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l44.35"></a><span id="l44.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l44.36"></a><span id="l44.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l44.37"></a><span id="l44.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l44.38"></a><span id="l44.38" class="difflineplus">+ *</span>
<a href="#l44.39"></a><span id="l44.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l44.40"></a><span id="l44.40" class="difflineplus">+</span>
<a href="#l44.41"></a><span id="l44.41"> /* This file tests whether we cleanup after ourselves, msf-wise.</span>
<a href="#l44.42"></a><span id="l44.42">  * This is very much a white-box test; we want to make sure that all the parts</span>
<a href="#l44.43"></a><span id="l44.43">  *  of the mechanism are actually doing what we think they should be doing.</span>
<a href="#l44.44"></a><span id="l44.44" class="difflineminus">- * </span>
<a href="#l44.45"></a><span id="l44.45" class="difflineplus">+ *</span>
<a href="#l44.46"></a><span id="l44.46">  * This test should stand on its own!  It should not be lumped together with</span>
<a href="#l44.47"></a><span id="l44.47">  *  other tests unless you take care to fix all our meddling.</span>
<a href="#l44.48"></a><span id="l44.48">  */</span>
<a href="#l44.49"></a><span id="l44.49"> </span>
<a href="#l44.50"></a><span id="l44.50" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l44.51"></a><span id="l44.51"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l44.52"></a><span id="l44.52"> </span>
<a href="#l44.53"></a><span id="l44.53" class="difflineminus">-// Create a message generator</span>
<a href="#l44.54"></a><span id="l44.54" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l44.55"></a><span id="l44.55" class="difflineminus">-// Create a message scenario generator using that message generator</span>
<a href="#l44.56"></a><span id="l44.56" class="difflineminus">-var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l44.57"></a><span id="l44.57" class="difflineminus">-</span>
<a href="#l44.58"></a><span id="l44.58" class="difflineminus">-// we need datamodel to be able to manipulate the GlodaFolder prototype...</span>
<a href="#l44.59"></a><span id="l44.59" class="difflineminus">-Components.utils.import(&quot;resource://app/modules/gloda/datamodel.js&quot;);</span>
<a href="#l44.60"></a><span id="l44.60" class="difflineminus">-// we need datastore to run amok in the GlodaDatastore internals</span>
<a href="#l44.61"></a><span id="l44.61" class="difflineminus">-Components.utils.import(&quot;resource://app/modules/gloda/datastore.js&quot;);</span>
<a href="#l44.62"></a><span id="l44.62" class="difflineminus">-</span>
<a href="#l44.63"></a><span id="l44.63"> /**</span>
<a href="#l44.64"></a><span id="l44.64">  * @return the number of live gloda folders tracked by</span>
<a href="#l44.65"></a><span id="l44.65">  *     GlodaDatastore._liveGlodaFolders.</span>
<a href="#l44.66"></a><span id="l44.66">  */</span>
<a href="#l44.67"></a><span id="l44.67"> function getLiveFolderCount() {</span>
<a href="#l44.68"></a><span id="l44.68">   return [key for each (key in GlodaDatastore._liveGlodaFolders)].length;</span>
<a href="#l44.69"></a><span id="l44.69"> }</span>
<a href="#l44.70"></a><span id="l44.70"> </span>
<a href="#l44.71"></a><span id="l44.71"> /**</span>
<a href="#l44.72"></a><span id="l44.72">  * Meddle with internals of live folder tracking, create a synthetic message and</span>
<a href="#l44.73"></a><span id="l44.73" class="difflineminus">- *  index it. We do the actual work involving the headers and folders in </span>
<a href="#l44.74"></a><span id="l44.74" class="difflineminus">- *  poke_and_verify_msf_closure. </span>
<a href="#l44.75"></a><span id="l44.75" class="difflineplus">+ *  index it. We do the actual work involving the headers and folders in</span>
<a href="#l44.76"></a><span id="l44.76" class="difflineplus">+ *  poke_and_verify_msf_closure.</span>
<a href="#l44.77"></a><span id="l44.77">  */</span>
<a href="#l44.78"></a><span id="l44.78"> function test_msf_closure() {</span>
<a href="#l44.79"></a><span id="l44.79">   // before doing anything, the indexer should not be tracking any live folders</span>
<a href="#l44.80"></a><span id="l44.80">   do_check_false(GlodaDatastore._folderCleanupActive);</span>
<a href="#l44.81"></a><span id="l44.81">   do_check_eq(0, getLiveFolderCount());</span>
<a href="#l44.82"></a><span id="l44.82" class="difflineminus">-  </span>
<a href="#l44.83"></a><span id="l44.83" class="difflineplus">+</span>
<a href="#l44.84"></a><span id="l44.84">   // make the datastore's folder cleanup timer never be at risk of firing</span>
<a href="#l44.85"></a><span id="l44.85" class="difflineminus">-  GlodaIndexer._folderCleanupTimerInterval = 1000000000;</span>
<a href="#l44.86"></a><span id="l44.86" class="difflineplus">+  GlodaDatastore._folderCleanupTimerInterval = 1000000000;</span>
<a href="#l44.87"></a><span id="l44.87">   // set the acceptably old threshold so it will never age out</span>
<a href="#l44.88"></a><span id="l44.88">   GlodaFolder.prototype.ACCEPTABLY_OLD_THRESHOLD = 1000000000;</span>
<a href="#l44.89"></a><span id="l44.89" class="difflineminus">-  </span>
<a href="#l44.90"></a><span id="l44.90" class="difflineplus">+</span>
<a href="#l44.91"></a><span id="l44.91">   // create a synthetic message</span>
<a href="#l44.92"></a><span id="l44.92" class="difflineminus">-  let smsg = msgGen.makeMessage();</span>
<a href="#l44.93"></a><span id="l44.93" class="difflineminus">-  </span>
<a href="#l44.94"></a><span id="l44.94" class="difflineminus">-  indexMessages([smsg], poke_and_verify_msf_closure, next_test);</span>
<a href="#l44.95"></a><span id="l44.95" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l44.96"></a><span id="l44.96" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l44.97"></a><span id="l44.97" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet, {verifier: poke_and_verify_msf_closure});</span>
<a href="#l44.98"></a><span id="l44.98"> }</span>
<a href="#l44.99"></a><span id="l44.99"> </span>
<a href="#l44.100"></a><span id="l44.100"> /**</span>
<a href="#l44.101"></a><span id="l44.101">  * Grab the message header, see live folder, cleanup live folders, make sure</span>
<a href="#l44.102"></a><span id="l44.102">  *  live folder stayed live, change constants so folder can die, cleanup live</span>
<a href="#l44.103"></a><span id="l44.103" class="difflineminus">- *  folders, make sure folder died. </span>
<a href="#l44.104"></a><span id="l44.104" class="difflineminus">- * </span>
<a href="#l44.105"></a><span id="l44.105" class="difflineplus">+ *  folders, make sure folder died.</span>
<a href="#l44.106"></a><span id="l44.106" class="difflineplus">+ *</span>
<a href="#l44.107"></a><span id="l44.107">  * @param aSynthMessage The synthetic message we indexed.</span>
<a href="#l44.108"></a><span id="l44.108">  * @param aGlodaMessage Its exciting gloda representation</span>
<a href="#l44.109"></a><span id="l44.109">  */</span>
<a href="#l44.110"></a><span id="l44.110"> function poke_and_verify_msf_closure(aSynthMessage, aGlodaMessage) {</span>
<a href="#l44.111"></a><span id="l44.111">   // get the nsIMsgDBHdr</span>
<a href="#l44.112"></a><span id="l44.112">   let header = aGlodaMessage.folderMessage;</span>
<a href="#l44.113"></a><span id="l44.113">   // if we don't have a header, this test is unlikely to work...</span>
<a href="#l44.114"></a><span id="l44.114">   do_check_neq(header, null);</span>
<a href="#l44.115"></a><span id="l44.115" class="difflineminus">-  </span>
<a href="#l44.116"></a><span id="l44.116" class="difflineplus">+</span>
<a href="#l44.117"></a><span id="l44.117">   // we need a reference to the glodaFolder</span>
<a href="#l44.118"></a><span id="l44.118">   let glodaFolder = aGlodaMessage.folder;</span>
<a href="#l44.119"></a><span id="l44.119" class="difflineminus">-  </span>
<a href="#l44.120"></a><span id="l44.120" class="difflineplus">+</span>
<a href="#l44.121"></a><span id="l44.121">   // -- check that everyone is tracking things correctly</span>
<a href="#l44.122"></a><span id="l44.122">   // the message's folder should be holding an XPCOM reference to the folder</span>
<a href="#l44.123"></a><span id="l44.123">   do_check_neq(glodaFolder._xpcomFolder, null);</span>
<a href="#l44.124"></a><span id="l44.124">   // the cleanup timer should now be alive</span>
<a href="#l44.125"></a><span id="l44.125">   do_check_true(GlodaDatastore._folderCleanupActive);</span>
<a href="#l44.126"></a><span id="l44.126">   // live folder count should be one</span>
<a href="#l44.127"></a><span id="l44.127">   do_check_eq(1, getLiveFolderCount());</span>
<a href="#l44.128"></a><span id="l44.128" class="difflineminus">-  </span>
<a href="#l44.129"></a><span id="l44.129" class="difflineplus">+</span>
<a href="#l44.130"></a><span id="l44.130">   // -- simulate a timer cleanup firing...</span>
<a href="#l44.131"></a><span id="l44.131">   GlodaDatastore._performFolderCleanup();</span>
<a href="#l44.132"></a><span id="l44.132" class="difflineminus">-  </span>
<a href="#l44.133"></a><span id="l44.133" class="difflineplus">+</span>
<a href="#l44.134"></a><span id="l44.134">   // -- verify that things are still as they were before the cleanup firing</span>
<a href="#l44.135"></a><span id="l44.135">   // the message's folder should be holding an XPCOM reference to the folder</span>
<a href="#l44.136"></a><span id="l44.136">   do_check_neq(glodaFolder._xpcomFolder, null);</span>
<a href="#l44.137"></a><span id="l44.137">   // the cleanup timer should now be alive</span>
<a href="#l44.138"></a><span id="l44.138">   do_check_true(GlodaDatastore._folderCleanupActive);</span>
<a href="#l44.139"></a><span id="l44.139">   // live folder count should be one</span>
<a href="#l44.140"></a><span id="l44.140">   do_check_eq(1, getLiveFolderCount());</span>
<a href="#l44.141"></a><span id="l44.141"> </span>
<a href="#l44.142"></a><span id="l44.142" class="difflineat">@@ -104,14 +130,13 @@ function poke_and_verify_msf_closure(aSy</span>
<a href="#l44.143"></a><span id="l44.143">   do_check_eq(0, getLiveFolderCount());</span>
<a href="#l44.144"></a><span id="l44.144"> }</span>
<a href="#l44.145"></a><span id="l44.145"> </span>
<a href="#l44.146"></a><span id="l44.146"> var tests = [</span>
<a href="#l44.147"></a><span id="l44.147">   test_msf_closure,</span>
<a href="#l44.148"></a><span id="l44.148"> ];</span>
<a href="#l44.149"></a><span id="l44.149"> </span>
<a href="#l44.150"></a><span id="l44.150"> function run_test() {</span>
<a href="#l44.151"></a><span id="l44.151" class="difflineminus">-  // No need to involve the fake-server, plus mbox injection has the direct</span>
<a href="#l44.152"></a><span id="l44.152" class="difflineminus">-  //  side-effect of creating folders that are not the inbox, which in theory</span>
<a href="#l44.153"></a><span id="l44.153" class="difflineminus">-  //  makes us less brittle.  (Less likely other code will interfere.)</span>
<a href="#l44.154"></a><span id="l44.154" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l44.155"></a><span id="l44.155" class="difflineplus">+  // we only need to test using local folders, although it is important that</span>
<a href="#l44.156"></a><span id="l44.156" class="difflineplus">+  //  we are using a non-Inbox folder (which we are).</span>
<a href="#l44.157"></a><span id="l44.157" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l44.158"></a><span id="l44.158">   glodaHelperRunTests(tests);</span>
<a href="#l44.159"></a><span id="l44.159"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1">rename from mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js</span>
<a href="#l45.2"></a><span id="l45.2">rename to mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_gloda_content_imap_originally_offline.js</span>
<a href="#l45.4"></a><span id="l45.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_gloda_content_imap_offline.js</span>
<a href="#l45.5"></a><span id="l45.5" class="difflineat">@@ -1,17 +1,12 @@</span>
<a href="#l45.6"></a><span id="l45.6"> /* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l45.7"></a><span id="l45.7"> /**</span>
<a href="#l45.8"></a><span id="l45.8">  * Tests the operation of the GlodaContent (in connotent.js) and its exposure</span>
<a href="#l45.9"></a><span id="l45.9" class="difflineminus">- * via Gloda.getMessageContent for IMAP messages that are originally offline.</span>
<a href="#l45.10"></a><span id="l45.10" class="difflineplus">+ * via Gloda.getMessageContent for IMAP messages that are offline.</span>
<a href="#l45.11"></a><span id="l45.11">  */</span>
<a href="#l45.12"></a><span id="l45.12"> </span>
<a href="#l45.13"></a><span id="l45.13" class="difflineminus">-load(&quot;test_gloda_content.js&quot;);</span>
<a href="#l45.14"></a><span id="l45.14" class="difflineplus">+load(&quot;base_gloda_content.js&quot;);</span>
<a href="#l45.15"></a><span id="l45.15"> </span>
<a href="#l45.16"></a><span id="l45.16" class="difflineminus">-/**</span>
<a href="#l45.17"></a><span id="l45.17" class="difflineminus">- * Set the imap folder to offline before adding the messages.</span>
<a href="#l45.18"></a><span id="l45.18" class="difflineminus">- */</span>
<a href="#l45.19"></a><span id="l45.19" class="difflineminus">-var pre_inject_message_hook = function imap_pre_inject_message_hook() {</span>
<a href="#l45.20"></a><span id="l45.20" class="difflineminus">-  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l45.21"></a><span id="l45.21" class="difflineminus">-  next_test();</span>
<a href="#l45.22"></a><span id="l45.22" class="difflineminus">-};</span>
<a href="#l45.23"></a><span id="l45.23" class="difflineminus">-</span>
<a href="#l45.24"></a><span id="l45.24" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span>
<a href="#l45.25"></a><span id="l45.25" class="difflineplus">+function run_test() {</span>
<a href="#l45.26"></a><span id="l45.26" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: true});</span>
<a href="#l45.27"></a><span id="l45.27" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l45.28"></a><span id="l45.28" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1">deleted file mode 100644</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_gloda_content_imap_switched_to_offline.js</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineplus">+++ /dev/null</span>
<a href="#l46.4"></a><span id="l46.4" class="difflineat">@@ -1,19 +0,0 @@</span>
<a href="#l46.5"></a><span id="l46.5" class="difflineminus">-/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l46.6"></a><span id="l46.6" class="difflineminus">-/**</span>
<a href="#l46.7"></a><span id="l46.7" class="difflineminus">- * Tests the operation of the GlodaContent (in connotent.js) and its exposure</span>
<a href="#l46.8"></a><span id="l46.8" class="difflineminus">- * via Gloda.getMessageContent for IMAP messages that were not originally</span>
<a href="#l46.9"></a><span id="l46.9" class="difflineminus">- * offline, but were later made offline.</span>
<a href="#l46.10"></a><span id="l46.10" class="difflineminus">- */</span>
<a href="#l46.11"></a><span id="l46.11" class="difflineminus">-</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineminus">-load(&quot;test_gloda_content.js&quot;);</span>
<a href="#l46.13"></a><span id="l46.13" class="difflineminus">-</span>
<a href="#l46.14"></a><span id="l46.14" class="difflineminus">-/**</span>
<a href="#l46.15"></a><span id="l46.15" class="difflineminus">- * Set the imap folder to offline after adding the messages, then force a</span>
<a href="#l46.16"></a><span id="l46.16" class="difflineminus">- * download of all messages.</span>
<a href="#l46.17"></a><span id="l46.17" class="difflineminus">- */</span>
<a href="#l46.18"></a><span id="l46.18" class="difflineminus">-var post_inject_message_hook = function imap_post_inject_message_hook() {</span>
<a href="#l46.19"></a><span id="l46.19" class="difflineminus">-  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages,</span>
<a href="#l46.20"></a><span id="l46.20" class="difflineminus">-                          glodaInfoStasher, next_test);</span>
<a href="#l46.21"></a><span id="l46.21" class="difflineminus">-};</span>
<a href="#l46.22"></a><span id="l46.22" class="difflineminus">-</span>
<a href="#l46.23"></a><span id="l46.23" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1">new file mode 100644</span>
<a href="#l47.2"></a><span id="l47.2" class="difflineminus">--- /dev/null</span>
<a href="#l47.3"></a><span id="l47.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_gloda_content_local.js</span>
<a href="#l47.4"></a><span id="l47.4" class="difflineat">@@ -0,0 +1,12 @@</span>
<a href="#l47.5"></a><span id="l47.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l47.6"></a><span id="l47.6" class="difflineplus">+/**</span>
<a href="#l47.7"></a><span id="l47.7" class="difflineplus">+ * Tests the operation of the GlodaContent (in connotent.js) and its exposure</span>
<a href="#l47.8"></a><span id="l47.8" class="difflineplus">+ * via Gloda.getMessageContent for local messages.</span>
<a href="#l47.9"></a><span id="l47.9" class="difflineplus">+ */</span>
<a href="#l47.10"></a><span id="l47.10" class="difflineplus">+</span>
<a href="#l47.11"></a><span id="l47.11" class="difflineplus">+load(&quot;base_gloda_content.js&quot;);</span>
<a href="#l47.12"></a><span id="l47.12" class="difflineplus">+</span>
<a href="#l47.13"></a><span id="l47.13" class="difflineplus">+function run_test() {</span>
<a href="#l47.14"></a><span id="l47.14" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l47.15"></a><span id="l47.15" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l47.16"></a><span id="l47.16" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1">deleted file mode 100644</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_adaptive.js</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineplus">+++ /dev/null</span>
<a href="#l48.4"></a><span id="l48.4" class="difflineat">@@ -1,249 +0,0 @@</span>
<a href="#l48.5"></a><span id="l48.5" class="difflineminus">-/*</span>
<a href="#l48.6"></a><span id="l48.6" class="difflineminus">- * Test our adaptive indexing logic; the thing that tries to adjust our</span>
<a href="#l48.7"></a><span id="l48.7" class="difflineminus">- *  indexing constants based on perceived processor utilization.  We fake all</span>
<a href="#l48.8"></a><span id="l48.8" class="difflineminus">- *  the load stuff, of course.</span>
<a href="#l48.9"></a><span id="l48.9" class="difflineminus">- *</span>
<a href="#l48.10"></a><span id="l48.10" class="difflineminus">- * Out of necessity, this test knows about the internals of the adaptive</span>
<a href="#l48.11"></a><span id="l48.11" class="difflineminus">- *  indexing logic.</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineminus">- */</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineminus">-</span>
<a href="#l48.14"></a><span id="l48.14" class="difflineminus">-load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l48.15"></a><span id="l48.15" class="difflineminus">-load(&quot;resources/mockIndexer.js&quot;);</span>
<a href="#l48.16"></a><span id="l48.16" class="difflineminus">-load(&quot;resources/mockTimer.js&quot;);</span>
<a href="#l48.17"></a><span id="l48.17" class="difflineminus">-</span>
<a href="#l48.18"></a><span id="l48.18" class="difflineminus">-/* ===== Mock Objects ==== */</span>
<a href="#l48.19"></a><span id="l48.19" class="difflineminus">-</span>
<a href="#l48.20"></a><span id="l48.20" class="difflineminus">-var FakeStopwatch = {</span>
<a href="#l48.21"></a><span id="l48.21" class="difflineminus">-  /* (fake) public interface */</span>
<a href="#l48.22"></a><span id="l48.22" class="difflineminus">-  start: function () {</span>
<a href="#l48.23"></a><span id="l48.23" class="difflineminus">-    this.running = true;</span>
<a href="#l48.24"></a><span id="l48.24" class="difflineminus">-    dump(&quot;stopwatch started\n&quot;);</span>
<a href="#l48.25"></a><span id="l48.25" class="difflineminus">-  },</span>
<a href="#l48.26"></a><span id="l48.26" class="difflineminus">-  stop: function() {</span>
<a href="#l48.27"></a><span id="l48.27" class="difflineminus">-    this.running = false;</span>
<a href="#l48.28"></a><span id="l48.28" class="difflineminus">-    dump(&quot;stopwatch stopped\n&quot;);</span>
<a href="#l48.29"></a><span id="l48.29" class="difflineminus">-  },</span>
<a href="#l48.30"></a><span id="l48.30" class="difflineminus">-  // just always claim we're 2 seconds...</span>
<a href="#l48.31"></a><span id="l48.31" class="difflineminus">-  realTimeSeconds: 2.0,</span>
<a href="#l48.32"></a><span id="l48.32" class="difflineminus">-  cpuTimeSeconds: 0.0,</span>
<a href="#l48.33"></a><span id="l48.33" class="difflineminus">-  /* mock support */</span>
<a href="#l48.34"></a><span id="l48.34" class="difflineminus">-  running: false,</span>
<a href="#l48.35"></a><span id="l48.35" class="difflineminus">-</span>
<a href="#l48.36"></a><span id="l48.36" class="difflineminus">-  tooMuch: function() {</span>
<a href="#l48.37"></a><span id="l48.37" class="difflineminus">-    this.cpuTimeSeconds = this.realTimeSeconds;</span>
<a href="#l48.38"></a><span id="l48.38" class="difflineminus">-  },</span>
<a href="#l48.39"></a><span id="l48.39" class="difflineminus">-  tooLittle: function() {</span>
<a href="#l48.40"></a><span id="l48.40" class="difflineminus">-    this.cpuTimeSeconds = 0.0;</span>
<a href="#l48.41"></a><span id="l48.41" class="difflineminus">-  },</span>
<a href="#l48.42"></a><span id="l48.42" class="difflineminus">-  justRight: function() {</span>
<a href="#l48.43"></a><span id="l48.43" class="difflineminus">-    this.cpuTimeSeconds = this.realTimeSeconds * GlodaIndexer._cpuTarget - 0.05;</span>
<a href="#l48.44"></a><span id="l48.44" class="difflineminus">-  }</span>
<a href="#l48.45"></a><span id="l48.45" class="difflineminus">-};</span>
<a href="#l48.46"></a><span id="l48.46" class="difflineminus">-</span>
<a href="#l48.47"></a><span id="l48.47" class="difflineminus">-/* ===== Helpers ===== */</span>
<a href="#l48.48"></a><span id="l48.48" class="difflineminus">-function fireCleanStabilizeAverage() {</span>
<a href="#l48.49"></a><span id="l48.49" class="difflineminus">-  GlodaIndexer._perfSamples = [];</span>
<a href="#l48.50"></a><span id="l48.50" class="difflineminus">-  for (let iFire = 0; iFire &lt; GlodaIndexer._perfSamplePointCount; iFire++)</span>
<a href="#l48.51"></a><span id="l48.51" class="difflineminus">-    perfTimer.fireNow();</span>
<a href="#l48.52"></a><span id="l48.52" class="difflineminus">-}</span>
<a href="#l48.53"></a><span id="l48.53" class="difflineminus">-</span>
<a href="#l48.54"></a><span id="l48.54" class="difflineminus">-/* ===== Tests ===== */</span>
<a href="#l48.55"></a><span id="l48.55" class="difflineminus">-</span>
<a href="#l48.56"></a><span id="l48.56" class="difflineminus">-function test_sample_when_you_should() {</span>
<a href="#l48.57"></a><span id="l48.57" class="difflineminus">-  // imsInit clobbered this, put it back.</span>
<a href="#l48.58"></a><span id="l48.58" class="difflineminus">-  GlodaIndexer._indexInterval = GlodaIndexer._indexInterval_whenActive;</span>
<a href="#l48.59"></a><span id="l48.59" class="difflineminus">-</span>
<a href="#l48.60"></a><span id="l48.60" class="difflineminus">-  do_check_false(FakeStopwatch.running);</span>
<a href="#l48.61"></a><span id="l48.61" class="difflineminus">-  do_check_false(perfTimer.active);</span>
<a href="#l48.62"></a><span id="l48.62" class="difflineminus">-</span>
<a href="#l48.63"></a><span id="l48.63" class="difflineminus">-  MockIndexer.indexForever();</span>
<a href="#l48.64"></a><span id="l48.64" class="difflineminus">-</span>
<a href="#l48.65"></a><span id="l48.65" class="difflineminus">-  do_check_true(FakeStopwatch.running);</span>
<a href="#l48.66"></a><span id="l48.66" class="difflineminus">-  do_check_true(perfTimer.active);</span>
<a href="#l48.67"></a><span id="l48.67" class="difflineminus">-</span>
<a href="#l48.68"></a><span id="l48.68" class="difflineminus">-  next_test();</span>
<a href="#l48.69"></a><span id="l48.69" class="difflineminus">-}</span>
<a href="#l48.70"></a><span id="l48.70" class="difflineminus">-</span>
<a href="#l48.71"></a><span id="l48.71" class="difflineminus">-function test_throttle_up() {</span>
<a href="#l48.72"></a><span id="l48.72" class="difflineminus">-  let preTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.73"></a><span id="l48.73" class="difflineminus">-  let preInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l48.74"></a><span id="l48.74" class="difflineminus">-</span>
<a href="#l48.75"></a><span id="l48.75" class="difflineminus">-  FakeStopwatch.tooLittle();</span>
<a href="#l48.76"></a><span id="l48.76" class="difflineminus">-  // fire one too few times, verify that nothing happens for those pre-firing</span>
<a href="#l48.77"></a><span id="l48.77" class="difflineminus">-  //  times... (this only matters for the first time we sample per the sampler</span>
<a href="#l48.78"></a><span id="l48.78" class="difflineminus">-  //  being active...)</span>
<a href="#l48.79"></a><span id="l48.79" class="difflineminus">-  for (let iFire = 1; iFire &lt; GlodaIndexer._perfSamplePointCount; iFire++) {</span>
<a href="#l48.80"></a><span id="l48.80" class="difflineminus">-    perfTimer.fireNow();</span>
<a href="#l48.81"></a><span id="l48.81" class="difflineminus">-    do_check_eq(preTokens, GlodaIndexer._indexTokens);</span>
<a href="#l48.82"></a><span id="l48.82" class="difflineminus">-    do_check_eq(preInterval, GlodaIndexer._indexInterval);</span>
<a href="#l48.83"></a><span id="l48.83" class="difflineminus">-  }</span>
<a href="#l48.84"></a><span id="l48.84" class="difflineminus">-  // now fire with some actual effect</span>
<a href="#l48.85"></a><span id="l48.85" class="difflineminus">-  perfTimer.fireNow();</span>
<a href="#l48.86"></a><span id="l48.86" class="difflineminus">-</span>
<a href="#l48.87"></a><span id="l48.87" class="difflineminus">-  // make sure everything went in the right direction</span>
<a href="#l48.88"></a><span id="l48.88" class="difflineminus">-  do_check_true(preTokens &lt;= GlodaIndexer._indexTokens);</span>
<a href="#l48.89"></a><span id="l48.89" class="difflineminus">-  do_check_true(preInterval &gt;= GlodaIndexer._indexInterval);</span>
<a href="#l48.90"></a><span id="l48.90" class="difflineminus">-  // make sure something actually happened</span>
<a href="#l48.91"></a><span id="l48.91" class="difflineminus">-  do_check_true(((GlodaIndexer._indexTokens - preTokens) &gt; 0) ||</span>
<a href="#l48.92"></a><span id="l48.92" class="difflineminus">-                ((preInterval - GlodaIndexer._indexInterval) &gt; 0));</span>
<a href="#l48.93"></a><span id="l48.93" class="difflineminus">-</span>
<a href="#l48.94"></a><span id="l48.94" class="difflineminus">-  next_test();</span>
<a href="#l48.95"></a><span id="l48.95" class="difflineminus">-}</span>
<a href="#l48.96"></a><span id="l48.96" class="difflineminus">-</span>
<a href="#l48.97"></a><span id="l48.97" class="difflineminus">-function test_throttle_down() {</span>
<a href="#l48.98"></a><span id="l48.98" class="difflineminus">-  let preTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.99"></a><span id="l48.99" class="difflineminus">-  let preInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l48.100"></a><span id="l48.100" class="difflineminus">-</span>
<a href="#l48.101"></a><span id="l48.101" class="difflineminus">-  FakeStopwatch.tooMuch();</span>
<a href="#l48.102"></a><span id="l48.102" class="difflineminus">-  fireCleanStabilizeAverage();</span>
<a href="#l48.103"></a><span id="l48.103" class="difflineminus">-</span>
<a href="#l48.104"></a><span id="l48.104" class="difflineminus">-  // make sure everything went in the right direction</span>
<a href="#l48.105"></a><span id="l48.105" class="difflineminus">-  do_check_true(preTokens &gt;= GlodaIndexer._indexTokens);</span>
<a href="#l48.106"></a><span id="l48.106" class="difflineminus">-  do_check_true(preInterval &lt;= GlodaIndexer._indexInterval);</span>
<a href="#l48.107"></a><span id="l48.107" class="difflineminus">-  // make sure something actually happened</span>
<a href="#l48.108"></a><span id="l48.108" class="difflineminus">-  do_check_true(((GlodaIndexer._indexTokens - preTokens) &lt; 0) ||</span>
<a href="#l48.109"></a><span id="l48.109" class="difflineminus">-                ((preInterval - GlodaIndexer._indexInterval) &lt; 0));</span>
<a href="#l48.110"></a><span id="l48.110" class="difflineminus">-</span>
<a href="#l48.111"></a><span id="l48.111" class="difflineminus">-  next_test();</span>
<a href="#l48.112"></a><span id="l48.112" class="difflineminus">-}</span>
<a href="#l48.113"></a><span id="l48.113" class="difflineminus">-</span>
<a href="#l48.114"></a><span id="l48.114" class="difflineminus">-function test_nop_on_stable() {</span>
<a href="#l48.115"></a><span id="l48.115" class="difflineminus">-</span>
<a href="#l48.116"></a><span id="l48.116" class="difflineminus">-  let preTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.117"></a><span id="l48.117" class="difflineminus">-  let preInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l48.118"></a><span id="l48.118" class="difflineminus">-</span>
<a href="#l48.119"></a><span id="l48.119" class="difflineminus">-  FakeStopwatch.justRight();</span>
<a href="#l48.120"></a><span id="l48.120" class="difflineminus">-  fireCleanStabilizeAverage();</span>
<a href="#l48.121"></a><span id="l48.121" class="difflineminus">-</span>
<a href="#l48.122"></a><span id="l48.122" class="difflineminus">-  // make sure nothing happened</span>
<a href="#l48.123"></a><span id="l48.123" class="difflineminus">-  do_check_eq(preTokens, GlodaIndexer._indexTokens);</span>
<a href="#l48.124"></a><span id="l48.124" class="difflineminus">-  do_check_eq(preInterval, GlodaIndexer._indexInterval);</span>
<a href="#l48.125"></a><span id="l48.125" class="difflineminus">-</span>
<a href="#l48.126"></a><span id="l48.126" class="difflineminus">-  next_test();</span>
<a href="#l48.127"></a><span id="l48.127" class="difflineminus">-}</span>
<a href="#l48.128"></a><span id="l48.128" class="difflineminus">-</span>
<a href="#l48.129"></a><span id="l48.129" class="difflineminus">-var MAX_STEPS_TO_CAPS = 100;</span>
<a href="#l48.130"></a><span id="l48.130" class="difflineminus">-</span>
<a href="#l48.131"></a><span id="l48.131" class="difflineminus">-function test_cap_slowest() {</span>
<a href="#l48.132"></a><span id="l48.132" class="difflineminus">-  FakeStopwatch.tooMuch();</span>
<a href="#l48.133"></a><span id="l48.133" class="difflineminus">-</span>
<a href="#l48.134"></a><span id="l48.134" class="difflineminus">-  GlodaIndexer._perfSamples = [];</span>
<a href="#l48.135"></a><span id="l48.135" class="difflineminus">-</span>
<a href="#l48.136"></a><span id="l48.136" class="difflineminus">-  let lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.137"></a><span id="l48.137" class="difflineminus">-  let lastInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l48.138"></a><span id="l48.138" class="difflineminus">-  for (let steps = MAX_STEPS_TO_CAPS; steps; steps--) {</span>
<a href="#l48.139"></a><span id="l48.139" class="difflineminus">-    perfTimer.fireNow();</span>
<a href="#l48.140"></a><span id="l48.140" class="difflineminus">-</span>
<a href="#l48.141"></a><span id="l48.141" class="difflineminus">-    // make sure we're always moving in the right directions</span>
<a href="#l48.142"></a><span id="l48.142" class="difflineminus">-    do_check_true(lastTokens &gt;= GlodaIndexer._indexTokens);</span>
<a href="#l48.143"></a><span id="l48.143" class="difflineminus">-    do_check_true(lastInterval &lt;= GlodaIndexer._indexInterval);</span>
<a href="#l48.144"></a><span id="l48.144" class="difflineminus">-    lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.145"></a><span id="l48.145" class="difflineminus">-    lastInterval = GlodaIndexer._indexInterval;</span>
<a href="#l48.146"></a><span id="l48.146" class="difflineminus">-</span>
<a href="#l48.147"></a><span id="l48.147" class="difflineminus">-    // make sure we never go above the cap</span>
<a href="#l48.148"></a><span id="l48.148" class="difflineminus">-    do_check_true(GlodaIndexer._indexInterval &lt;=</span>
<a href="#l48.149"></a><span id="l48.149" class="difflineminus">-                  GlodaIndexer._MAX_TIMER_INTERVAL_MS);</span>
<a href="#l48.150"></a><span id="l48.150" class="difflineminus">-    // if we have hit the cap, give it a few more spins</span>
<a href="#l48.151"></a><span id="l48.151" class="difflineminus">-    if (GlodaIndexer._indexInterval == GlodaIndexer._MAX_TIMER_INTERVAL_MS &amp;&amp;</span>
<a href="#l48.152"></a><span id="l48.152" class="difflineminus">-        steps &gt; 5)</span>
<a href="#l48.153"></a><span id="l48.153" class="difflineminus">-      steps = 5;</span>
<a href="#l48.154"></a><span id="l48.154" class="difflineminus">-  }</span>
<a href="#l48.155"></a><span id="l48.155" class="difflineminus">-  // make sure we actual did hit the cap</span>
<a href="#l48.156"></a><span id="l48.156" class="difflineminus">-  do_check_eq(GlodaIndexer._indexInterval, GlodaIndexer._MAX_TIMER_INTERVAL_MS);</span>
<a href="#l48.157"></a><span id="l48.157" class="difflineminus">-</span>
<a href="#l48.158"></a><span id="l48.158" class="difflineminus">-  next_test();</span>
<a href="#l48.159"></a><span id="l48.159" class="difflineminus">-}</span>
<a href="#l48.160"></a><span id="l48.160" class="difflineminus">-</span>
<a href="#l48.161"></a><span id="l48.161" class="difflineminus">-function test_cap_fastest() {</span>
<a href="#l48.162"></a><span id="l48.162" class="difflineminus">-  FakeStopwatch.tooLittle();</span>
<a href="#l48.163"></a><span id="l48.163" class="difflineminus">-</span>
<a href="#l48.164"></a><span id="l48.164" class="difflineminus">-  GlodaIndexer._perfSamples = [];</span>
<a href="#l48.165"></a><span id="l48.165" class="difflineminus">-</span>
<a href="#l48.166"></a><span id="l48.166" class="difflineminus">-  let lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.167"></a><span id="l48.167" class="difflineminus">-  let lastInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l48.168"></a><span id="l48.168" class="difflineminus">-  for (let steps = MAX_STEPS_TO_CAPS; steps; steps--) {</span>
<a href="#l48.169"></a><span id="l48.169" class="difflineminus">-    perfTimer.fireNow();</span>
<a href="#l48.170"></a><span id="l48.170" class="difflineminus">-</span>
<a href="#l48.171"></a><span id="l48.171" class="difflineminus">-    // make sure we're always moving in the right directions</span>
<a href="#l48.172"></a><span id="l48.172" class="difflineminus">-    do_check_true(lastTokens &lt;= GlodaIndexer._indexTokens);</span>
<a href="#l48.173"></a><span id="l48.173" class="difflineminus">-    do_check_true(lastInterval &gt;= GlodaIndexer._indexInterval);</span>
<a href="#l48.174"></a><span id="l48.174" class="difflineminus">-    lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.175"></a><span id="l48.175" class="difflineminus">-    lastInterval = GlodaIndexer._indexInterval;</span>
<a href="#l48.176"></a><span id="l48.176" class="difflineminus">-</span>
<a href="#l48.177"></a><span id="l48.177" class="difflineminus">-    // make sure we never go below the cap</span>
<a href="#l48.178"></a><span id="l48.178" class="difflineminus">-    do_check_true(GlodaIndexer._indexInterval &gt;=</span>
<a href="#l48.179"></a><span id="l48.179" class="difflineminus">-                  GlodaIndexer._MIN_TIMER_INTERVAL_MS);</span>
<a href="#l48.180"></a><span id="l48.180" class="difflineminus">-    // if we have hit the cap, give it a few more spins</span>
<a href="#l48.181"></a><span id="l48.181" class="difflineminus">-    if (GlodaIndexer._indexInterval == GlodaIndexer._MIN_TIMER_INTERVAL_MS &amp;&amp;</span>
<a href="#l48.182"></a><span id="l48.182" class="difflineminus">-        steps &gt; 5)</span>
<a href="#l48.183"></a><span id="l48.183" class="difflineminus">-      steps = 5;</span>
<a href="#l48.184"></a><span id="l48.184" class="difflineminus">-  }</span>
<a href="#l48.185"></a><span id="l48.185" class="difflineminus">-  // make sure we actual did hit the cap</span>
<a href="#l48.186"></a><span id="l48.186" class="difflineminus">-  do_check_eq(GlodaIndexer._indexInterval, GlodaIndexer._MIN_TIMER_INTERVAL_MS);</span>
<a href="#l48.187"></a><span id="l48.187" class="difflineminus">-</span>
<a href="#l48.188"></a><span id="l48.188" class="difflineminus">-  next_test();</span>
<a href="#l48.189"></a><span id="l48.189" class="difflineminus">-}</span>
<a href="#l48.190"></a><span id="l48.190" class="difflineminus">-</span>
<a href="#l48.191"></a><span id="l48.191" class="difflineminus">-function test_idle() {</span>
<a href="#l48.192"></a><span id="l48.192" class="difflineminus">-  let activeTokens = GlodaIndexer._indexTokens;</span>
<a href="#l48.193"></a><span id="l48.193" class="difflineminus">-  let activeInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l48.194"></a><span id="l48.194" class="difflineminus">-</span>
<a href="#l48.195"></a><span id="l48.195" class="difflineminus">-  // go idle, make sure we switch to the right set of constants</span>
<a href="#l48.196"></a><span id="l48.196" class="difflineminus">-  GlodaIndexer.observe(null, &quot;idle&quot;, null);</span>
<a href="#l48.197"></a><span id="l48.197" class="difflineminus">-  do_check_eq(GlodaIndexer._cpuTarget, GlodaIndexer._cpuTarget_whenIdle);</span>
<a href="#l48.198"></a><span id="l48.198" class="difflineminus">-  do_check_eq(GlodaIndexer._indexInterval,</span>
<a href="#l48.199"></a><span id="l48.199" class="difflineminus">-              GlodaIndexer._indexInterval_whenIdle);</span>
<a href="#l48.200"></a><span id="l48.200" class="difflineminus">-  do_check_eq(GlodaIndexer._indexTokens, GlodaIndexer._indexTokens_whenIdle);</span>
<a href="#l48.201"></a><span id="l48.201" class="difflineminus">-</span>
<a href="#l48.202"></a><span id="l48.202" class="difflineminus">-  // go active, make sure we switch back</span>
<a href="#l48.203"></a><span id="l48.203" class="difflineminus">-  GlodaIndexer.observe(null, &quot;back&quot;, null);</span>
<a href="#l48.204"></a><span id="l48.204" class="difflineminus">-  do_check_eq(GlodaIndexer._cpuTarget, GlodaIndexer._cpuTarget_whenActive);</span>
<a href="#l48.205"></a><span id="l48.205" class="difflineminus">-  do_check_eq(GlodaIndexer._indexInterval,</span>
<a href="#l48.206"></a><span id="l48.206" class="difflineminus">-              GlodaIndexer._indexInterval_whenActive);</span>
<a href="#l48.207"></a><span id="l48.207" class="difflineminus">-  do_check_eq(GlodaIndexer._indexTokens, GlodaIndexer._indexTokens_whenActive);</span>
<a href="#l48.208"></a><span id="l48.208" class="difflineminus">-</span>
<a href="#l48.209"></a><span id="l48.209" class="difflineminus">-  // also make sure that what we switched to was what we were using before idle</span>
<a href="#l48.210"></a><span id="l48.210" class="difflineminus">-  //  happened...</span>
<a href="#l48.211"></a><span id="l48.211" class="difflineminus">-  do_check_eq(activeTokens, GlodaIndexer._indexTokens);</span>
<a href="#l48.212"></a><span id="l48.212" class="difflineminus">-  do_check_eq(activeInterval, GlodaIndexer._indexInterval);</span>
<a href="#l48.213"></a><span id="l48.213" class="difflineminus">-</span>
<a href="#l48.214"></a><span id="l48.214" class="difflineminus">-  next_test();</span>
<a href="#l48.215"></a><span id="l48.215" class="difflineminus">-}</span>
<a href="#l48.216"></a><span id="l48.216" class="difflineminus">-</span>
<a href="#l48.217"></a><span id="l48.217" class="difflineminus">-function test_stop_sampling_when_done() {</span>
<a href="#l48.218"></a><span id="l48.218" class="difflineminus">-  do_check_true(FakeStopwatch.running);</span>
<a href="#l48.219"></a><span id="l48.219" class="difflineminus">-</span>
<a href="#l48.220"></a><span id="l48.220" class="difflineminus">-  runOnIndexingComplete(function() {</span>
<a href="#l48.221"></a><span id="l48.221" class="difflineminus">-    do_check_false(FakeStopwatch.running);</span>
<a href="#l48.222"></a><span id="l48.222" class="difflineminus">-    do_check_false(perfTimer.active);</span>
<a href="#l48.223"></a><span id="l48.223" class="difflineminus">-</span>
<a href="#l48.224"></a><span id="l48.224" class="difflineminus">-    next_test();</span>
<a href="#l48.225"></a><span id="l48.225" class="difflineminus">-  });</span>
<a href="#l48.226"></a><span id="l48.226" class="difflineminus">-</span>
<a href="#l48.227"></a><span id="l48.227" class="difflineminus">-  MockIndexer.stopIndexingForever();</span>
<a href="#l48.228"></a><span id="l48.228" class="difflineminus">-}</span>
<a href="#l48.229"></a><span id="l48.229" class="difflineminus">-</span>
<a href="#l48.230"></a><span id="l48.230" class="difflineminus">-/* ===== Driver ====== */</span>
<a href="#l48.231"></a><span id="l48.231" class="difflineminus">-</span>
<a href="#l48.232"></a><span id="l48.232" class="difflineminus">-var tests = [</span>
<a href="#l48.233"></a><span id="l48.233" class="difflineminus">-  test_sample_when_you_should,</span>
<a href="#l48.234"></a><span id="l48.234" class="difflineminus">-  test_throttle_up,</span>
<a href="#l48.235"></a><span id="l48.235" class="difflineminus">-  test_throttle_down,</span>
<a href="#l48.236"></a><span id="l48.236" class="difflineminus">-  test_nop_on_stable,</span>
<a href="#l48.237"></a><span id="l48.237" class="difflineminus">-  test_cap_slowest,</span>
<a href="#l48.238"></a><span id="l48.238" class="difflineminus">-  test_cap_fastest,</span>
<a href="#l48.239"></a><span id="l48.239" class="difflineminus">-  test_idle,</span>
<a href="#l48.240"></a><span id="l48.240" class="difflineminus">-  test_stop_sampling_when_done</span>
<a href="#l48.241"></a><span id="l48.241" class="difflineminus">-];</span>
<a href="#l48.242"></a><span id="l48.242" class="difflineminus">-</span>
<a href="#l48.243"></a><span id="l48.243" class="difflineminus">-function run_test() {</span>
<a href="#l48.244"></a><span id="l48.244" class="difflineminus">-  // XXX we are not yet updated for the new type of adaptive indexer :(</span>
<a href="#l48.245"></a><span id="l48.245" class="difflineminus">-  return true;</span>
<a href="#l48.246"></a><span id="l48.246" class="difflineminus">-</span>
<a href="#l48.247"></a><span id="l48.247" class="difflineminus">-  // hack in our stopwatch</span>
<a href="#l48.248"></a><span id="l48.248" class="difflineminus">-  GlodaIndexer._perfStopwatch = FakeStopwatch;</span>
<a href="#l48.249"></a><span id="l48.249" class="difflineminus">-  // hack in a timer for the stopwatch control</span>
<a href="#l48.250"></a><span id="l48.250" class="difflineminus">-  var perfTimer = new MockTimer(GlodaIndexer, &quot;_perfTimer&quot;);</span>
<a href="#l48.251"></a><span id="l48.251" class="difflineminus">-</span>
<a href="#l48.252"></a><span id="l48.252" class="difflineminus">-  glodaHelperRunTests(tests);</span>
<a href="#l48.253"></a><span id="l48.253" class="difflineminus">-}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1">new file mode 100644</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineminus">--- /dev/null</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_addressbook.js</span>
<a href="#l49.4"></a><span id="l49.4" class="difflineat">@@ -0,0 +1,155 @@</span>
<a href="#l49.5"></a><span id="l49.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l49.6"></a><span id="l49.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l49.7"></a><span id="l49.7" class="difflineplus">+ *</span>
<a href="#l49.8"></a><span id="l49.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l49.9"></a><span id="l49.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l49.10"></a><span id="l49.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l49.11"></a><span id="l49.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l49.12"></a><span id="l49.12" class="difflineplus">+ *</span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l49.14"></a><span id="l49.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l49.15"></a><span id="l49.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l49.16"></a><span id="l49.16" class="difflineplus">+ * License.</span>
<a href="#l49.17"></a><span id="l49.17" class="difflineplus">+ *</span>
<a href="#l49.18"></a><span id="l49.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l49.19"></a><span id="l49.19" class="difflineplus">+ *</span>
<a href="#l49.20"></a><span id="l49.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l49.21"></a><span id="l49.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l49.22"></a><span id="l49.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l49.23"></a><span id="l49.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l49.24"></a><span id="l49.24" class="difflineplus">+ *</span>
<a href="#l49.25"></a><span id="l49.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l49.26"></a><span id="l49.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l49.27"></a><span id="l49.27" class="difflineplus">+ *</span>
<a href="#l49.28"></a><span id="l49.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l49.29"></a><span id="l49.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l49.30"></a><span id="l49.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l49.31"></a><span id="l49.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l49.32"></a><span id="l49.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l49.33"></a><span id="l49.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l49.34"></a><span id="l49.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l49.35"></a><span id="l49.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l49.36"></a><span id="l49.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l49.37"></a><span id="l49.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l49.38"></a><span id="l49.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l49.39"></a><span id="l49.39" class="difflineplus">+ *</span>
<a href="#l49.40"></a><span id="l49.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l49.41"></a><span id="l49.41" class="difflineplus">+</span>
<a href="#l49.42"></a><span id="l49.42" class="difflineplus">+load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l49.43"></a><span id="l49.43" class="difflineplus">+</span>
<a href="#l49.44"></a><span id="l49.44" class="difflineplus">+var gInbox;</span>
<a href="#l49.45"></a><span id="l49.45" class="difflineplus">+</span>
<a href="#l49.46"></a><span id="l49.46" class="difflineplus">+function add_card(aEmailAddress, aDisplayName) {</span>
<a href="#l49.47"></a><span id="l49.47" class="difflineplus">+  Cc[&quot;@mozilla.org/addressbook/services/addressCollector;1&quot;]</span>
<a href="#l49.48"></a><span id="l49.48" class="difflineplus">+    .getService(Ci.nsIAbAddressCollector)</span>
<a href="#l49.49"></a><span id="l49.49" class="difflineplus">+    .collectSingleAddress(aEmailAddress,</span>
<a href="#l49.50"></a><span id="l49.50" class="difflineplus">+                          aDisplayName, true,</span>
<a href="#l49.51"></a><span id="l49.51" class="difflineplus">+                          Ci.nsIAbPreferMailFormat.unknown,</span>
<a href="#l49.52"></a><span id="l49.52" class="difflineplus">+                          true);</span>
<a href="#l49.53"></a><span id="l49.53" class="difflineplus">+}</span>
<a href="#l49.54"></a><span id="l49.54" class="difflineplus">+</span>
<a href="#l49.55"></a><span id="l49.55" class="difflineplus">+function get_card_for_email(aEmailAddress) {</span>
<a href="#l49.56"></a><span id="l49.56" class="difflineplus">+  var books = Cc[&quot;@mozilla.org/abmanager;1&quot;]</span>
<a href="#l49.57"></a><span id="l49.57" class="difflineplus">+                .getService(Ci.nsIAbManager)</span>
<a href="#l49.58"></a><span id="l49.58" class="difflineplus">+                .directories;</span>
<a href="#l49.59"></a><span id="l49.59" class="difflineplus">+</span>
<a href="#l49.60"></a><span id="l49.60" class="difflineplus">+  let book, card;</span>
<a href="#l49.61"></a><span id="l49.61" class="difflineplus">+</span>
<a href="#l49.62"></a><span id="l49.62" class="difflineplus">+  while (books.hasMoreElements()) {</span>
<a href="#l49.63"></a><span id="l49.63" class="difflineplus">+    book = books.getNext()</span>
<a href="#l49.64"></a><span id="l49.64" class="difflineplus">+                  .QueryInterface(Ci.nsIAbDirectory);</span>
<a href="#l49.65"></a><span id="l49.65" class="difflineplus">+    var card = book.cardForEmailAddress(aEmailAddress);</span>
<a href="#l49.66"></a><span id="l49.66" class="difflineplus">+    if (card)</span>
<a href="#l49.67"></a><span id="l49.67" class="difflineplus">+      return [book, card];</span>
<a href="#l49.68"></a><span id="l49.68" class="difflineplus">+  }</span>
<a href="#l49.69"></a><span id="l49.69" class="difflineplus">+  return [null, null];</span>
<a href="#l49.70"></a><span id="l49.70" class="difflineplus">+}</span>
<a href="#l49.71"></a><span id="l49.71" class="difflineplus">+</span>
<a href="#l49.72"></a><span id="l49.72" class="difflineplus">+function delete_card(aEmailAddress) {</span>
<a href="#l49.73"></a><span id="l49.73" class="difflineplus">+  let [book, card] = get_card_for_email(aEmailAddress);</span>
<a href="#l49.74"></a><span id="l49.74" class="difflineplus">+</span>
<a href="#l49.75"></a><span id="l49.75" class="difflineplus">+  let cardArray = Cc[&quot;@mozilla.org/array;1&quot;]</span>
<a href="#l49.76"></a><span id="l49.76" class="difflineplus">+                    .createInstance(Ci.nsIMutableArray);</span>
<a href="#l49.77"></a><span id="l49.77" class="difflineplus">+  cardArray.appendElement(card, false);</span>
<a href="#l49.78"></a><span id="l49.78" class="difflineplus">+</span>
<a href="#l49.79"></a><span id="l49.79" class="difflineplus">+  Cc[&quot;@mozilla.org/abmanager;1&quot;]</span>
<a href="#l49.80"></a><span id="l49.80" class="difflineplus">+    .getService(Components.interfaces.nsIAbManager)</span>
<a href="#l49.81"></a><span id="l49.81" class="difflineplus">+    .getDirectory(book.URI)</span>
<a href="#l49.82"></a><span id="l49.82" class="difflineplus">+    .deleteCards(cardArray);</span>
<a href="#l49.83"></a><span id="l49.83" class="difflineplus">+}</span>
<a href="#l49.84"></a><span id="l49.84" class="difflineplus">+</span>
<a href="#l49.85"></a><span id="l49.85" class="difflineplus">+function get_cached_gloda_identity_for_email(aEmailAddress) {</span>
<a href="#l49.86"></a><span id="l49.86" class="difflineplus">+  return GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l49.87"></a><span id="l49.87" class="difflineplus">+    Gloda.NOUN_IDENTITY, &quot;email@&quot; + aEmailAddress.toLowerCase());</span>
<a href="#l49.88"></a><span id="l49.88" class="difflineplus">+}</span>
<a href="#l49.89"></a><span id="l49.89" class="difflineplus">+</span>
<a href="#l49.90"></a><span id="l49.90" class="difflineplus">+const EMAIL_ADDRESS = &quot;all.over@the.world&quot;;</span>
<a href="#l49.91"></a><span id="l49.91" class="difflineplus">+const DISPLAY_NAME = &quot;every day&quot;;</span>
<a href="#l49.92"></a><span id="l49.92" class="difflineplus">+</span>
<a href="#l49.93"></a><span id="l49.93" class="difflineplus">+let identityCollection;</span>
<a href="#l49.94"></a><span id="l49.94" class="difflineplus">+</span>
<a href="#l49.95"></a><span id="l49.95" class="difflineplus">+/**</span>
<a href="#l49.96"></a><span id="l49.96" class="difflineplus">+ * Create an e-mail so the identity can exist.</span>
<a href="#l49.97"></a><span id="l49.97" class="difflineplus">+ */</span>
<a href="#l49.98"></a><span id="l49.98" class="difflineplus">+function setup_create_identity() {</span>
<a href="#l49.99"></a><span id="l49.99" class="difflineplus">+  let [msgSet] = make_new_sets_in_folder(gInbox, [</span>
<a href="#l49.100"></a><span id="l49.100" class="difflineplus">+                   {count: 1, from: [DISPLAY_NAME, EMAIL_ADDRESS]}]);</span>
<a href="#l49.101"></a><span id="l49.101" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l49.102"></a><span id="l49.102" class="difflineplus">+  yield wait_for_gloda_indexer(msgSet);</span>
<a href="#l49.103"></a><span id="l49.103" class="difflineplus">+</span>
<a href="#l49.104"></a><span id="l49.104" class="difflineplus">+  // okay, but it knows it has no card because indexing thinks stuff.</span>
<a href="#l49.105"></a><span id="l49.105" class="difflineplus">+  // so let's flush all caches and create a query that just knows about the</span>
<a href="#l49.106"></a><span id="l49.106" class="difflineplus">+  //  identity.</span>
<a href="#l49.107"></a><span id="l49.107" class="difflineplus">+  nukeGlodaCachesAndCollections();</span>
<a href="#l49.108"></a><span id="l49.108" class="difflineplus">+</span>
<a href="#l49.109"></a><span id="l49.109" class="difflineplus">+  let identQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l49.110"></a><span id="l49.110" class="difflineplus">+  identQuery.kind(&quot;email&quot;);</span>
<a href="#l49.111"></a><span id="l49.111" class="difflineplus">+  identQuery.value(EMAIL_ADDRESS);</span>
<a href="#l49.112"></a><span id="l49.112" class="difflineplus">+  identityCollection = queryExpect(identQuery, [EMAIL_ADDRESS]);</span>
<a href="#l49.113"></a><span id="l49.113" class="difflineplus">+  yield false;</span>
<a href="#l49.114"></a><span id="l49.114" class="difflineplus">+</span>
<a href="#l49.115"></a><span id="l49.115" class="difflineplus">+  // now the identity exists... make sure it is in cache.</span>
<a href="#l49.116"></a><span id="l49.116" class="difflineplus">+  let identity = get_cached_gloda_identity_for_email(EMAIL_ADDRESS);</span>
<a href="#l49.117"></a><span id="l49.117" class="difflineplus">+  do_check_neq(identity, null);</span>
<a href="#l49.118"></a><span id="l49.118" class="difflineplus">+</span>
<a href="#l49.119"></a><span id="l49.119" class="difflineplus">+  // and make sure it has no idea what the current state of the card is.</span>
<a href="#l49.120"></a><span id="l49.120" class="difflineplus">+  if (identity._hasAddressBookCard !== undefined)</span>
<a href="#l49.121"></a><span id="l49.121" class="difflineplus">+    do_throw(&quot;We should have no idea about the state of the ab card, but &quot; +</span>
<a href="#l49.122"></a><span id="l49.122" class="difflineplus">+             &quot;it's: &quot; + identity._hasAddressBookCard);</span>
<a href="#l49.123"></a><span id="l49.123" class="difflineplus">+}</span>
<a href="#l49.124"></a><span id="l49.124" class="difflineplus">+</span>
<a href="#l49.125"></a><span id="l49.125" class="difflineplus">+/**</span>
<a href="#l49.126"></a><span id="l49.126" class="difflineplus">+ * (Re-)Add a card for that e-mail, make sure we update the cached identity ab</span>
<a href="#l49.127"></a><span id="l49.127" class="difflineplus">+ *  card state.</span>
<a href="#l49.128"></a><span id="l49.128" class="difflineplus">+ */</span>
<a href="#l49.129"></a><span id="l49.129" class="difflineplus">+function test_add_card_cache_indication() {</span>
<a href="#l49.130"></a><span id="l49.130" class="difflineplus">+  add_card(EMAIL_ADDRESS, DISPLAY_NAME);</span>
<a href="#l49.131"></a><span id="l49.131" class="difflineplus">+</span>
<a href="#l49.132"></a><span id="l49.132" class="difflineplus">+  let identity = get_cached_gloda_identity_for_email(EMAIL_ADDRESS);</span>
<a href="#l49.133"></a><span id="l49.133" class="difflineplus">+  do_check_eq(identity._hasAddressBookCard, true);</span>
<a href="#l49.134"></a><span id="l49.134" class="difflineplus">+}</span>
<a href="#l49.135"></a><span id="l49.135" class="difflineplus">+</span>
<a href="#l49.136"></a><span id="l49.136" class="difflineplus">+/**</span>
<a href="#l49.137"></a><span id="l49.137" class="difflineplus">+ * Remove the card we added in setup, make sure we update the cached identity</span>
<a href="#l49.138"></a><span id="l49.138" class="difflineplus">+ *  ab card state.</span>
<a href="#l49.139"></a><span id="l49.139" class="difflineplus">+ */</span>
<a href="#l49.140"></a><span id="l49.140" class="difflineplus">+function test_remove_card_cache_indication() {</span>
<a href="#l49.141"></a><span id="l49.141" class="difflineplus">+  delete_card(EMAIL_ADDRESS);</span>
<a href="#l49.142"></a><span id="l49.142" class="difflineplus">+</span>
<a href="#l49.143"></a><span id="l49.143" class="difflineplus">+  let identity = get_cached_gloda_identity_for_email(EMAIL_ADDRESS);</span>
<a href="#l49.144"></a><span id="l49.144" class="difflineplus">+  do_check_eq(identity._hasAddressBookCard, false);</span>
<a href="#l49.145"></a><span id="l49.145" class="difflineplus">+}</span>
<a href="#l49.146"></a><span id="l49.146" class="difflineplus">+</span>
<a href="#l49.147"></a><span id="l49.147" class="difflineplus">+</span>
<a href="#l49.148"></a><span id="l49.148" class="difflineplus">+let tests = [</span>
<a href="#l49.149"></a><span id="l49.149" class="difflineplus">+  setup_create_identity,</span>
<a href="#l49.150"></a><span id="l49.150" class="difflineplus">+  test_add_card_cache_indication,</span>
<a href="#l49.151"></a><span id="l49.151" class="difflineplus">+  test_remove_card_cache_indication,</span>
<a href="#l49.152"></a><span id="l49.152" class="difflineplus">+  // add it back again</span>
<a href="#l49.153"></a><span id="l49.153" class="difflineplus">+  test_add_card_cache_indication,</span>
<a href="#l49.154"></a><span id="l49.154" class="difflineplus">+];</span>
<a href="#l49.155"></a><span id="l49.155" class="difflineplus">+</span>
<a href="#l49.156"></a><span id="l49.156" class="difflineplus">+function run_test() {</span>
<a href="#l49.157"></a><span id="l49.157" class="difflineplus">+  gInbox = configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l49.158"></a><span id="l49.158" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l49.159"></a><span id="l49.159" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1">new file mode 100644</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineminus">--- /dev/null</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_bad_messages.js</span>
<a href="#l50.4"></a><span id="l50.4" class="difflineat">@@ -0,0 +1,173 @@</span>
<a href="#l50.5"></a><span id="l50.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l50.6"></a><span id="l50.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l50.7"></a><span id="l50.7" class="difflineplus">+ *</span>
<a href="#l50.8"></a><span id="l50.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l50.9"></a><span id="l50.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l50.10"></a><span id="l50.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l50.11"></a><span id="l50.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l50.12"></a><span id="l50.12" class="difflineplus">+ *</span>
<a href="#l50.13"></a><span id="l50.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l50.14"></a><span id="l50.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l50.15"></a><span id="l50.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l50.16"></a><span id="l50.16" class="difflineplus">+ * License.</span>
<a href="#l50.17"></a><span id="l50.17" class="difflineplus">+ *</span>
<a href="#l50.18"></a><span id="l50.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l50.19"></a><span id="l50.19" class="difflineplus">+ *</span>
<a href="#l50.20"></a><span id="l50.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l50.21"></a><span id="l50.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l50.22"></a><span id="l50.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l50.23"></a><span id="l50.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l50.24"></a><span id="l50.24" class="difflineplus">+ *</span>
<a href="#l50.25"></a><span id="l50.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l50.26"></a><span id="l50.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l50.27"></a><span id="l50.27" class="difflineplus">+ *</span>
<a href="#l50.28"></a><span id="l50.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l50.29"></a><span id="l50.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l50.30"></a><span id="l50.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l50.31"></a><span id="l50.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l50.32"></a><span id="l50.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l50.33"></a><span id="l50.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l50.34"></a><span id="l50.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l50.35"></a><span id="l50.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l50.36"></a><span id="l50.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l50.37"></a><span id="l50.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l50.38"></a><span id="l50.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l50.39"></a><span id="l50.39" class="difflineplus">+ *</span>
<a href="#l50.40"></a><span id="l50.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l50.41"></a><span id="l50.41" class="difflineplus">+</span>
<a href="#l50.42"></a><span id="l50.42" class="difflineplus">+/*</span>
<a href="#l50.43"></a><span id="l50.43" class="difflineplus">+ * Test that we fail on bad messages by marking the messages as bad rather than</span>
<a href="#l50.44"></a><span id="l50.44" class="difflineplus">+ *  exploding or something bad like that.</span>
<a href="#l50.45"></a><span id="l50.45" class="difflineplus">+ */</span>
<a href="#l50.46"></a><span id="l50.46" class="difflineplus">+</span>
<a href="#l50.47"></a><span id="l50.47" class="difflineplus">+load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l50.48"></a><span id="l50.48" class="difflineplus">+</span>
<a href="#l50.49"></a><span id="l50.49" class="difflineplus">+var gInbox;</span>
<a href="#l50.50"></a><span id="l50.50" class="difflineplus">+</span>
<a href="#l50.51"></a><span id="l50.51" class="difflineplus">+const illegalMessageTemplates = [</span>
<a href="#l50.52"></a><span id="l50.52" class="difflineplus">+  // -- authors</span>
<a href="#l50.53"></a><span id="l50.53" class="difflineplus">+  {</span>
<a href="#l50.54"></a><span id="l50.54" class="difflineplus">+    name: &quot;no author&quot;,</span>
<a href="#l50.55"></a><span id="l50.55" class="difflineplus">+    clobberHeaders: {</span>
<a href="#l50.56"></a><span id="l50.56" class="difflineplus">+      From: &quot;&quot;</span>
<a href="#l50.57"></a><span id="l50.57" class="difflineplus">+    }</span>
<a href="#l50.58"></a><span id="l50.58" class="difflineplus">+  },</span>
<a href="#l50.59"></a><span id="l50.59" class="difflineplus">+  {</span>
<a href="#l50.60"></a><span id="l50.60" class="difflineplus">+    name: &quot;too many authors (&gt; 1)&quot;,</span>
<a href="#l50.61"></a><span id="l50.61" class="difflineplus">+    clobberHeaders: {</span>
<a href="#l50.62"></a><span id="l50.62" class="difflineplus">+      From: &quot;Tweedle Dee &lt;dee@example.com&gt;, Tweedle Dum &lt;dum@example.com&gt;&quot;</span>
<a href="#l50.63"></a><span id="l50.63" class="difflineplus">+    }</span>
<a href="#l50.64"></a><span id="l50.64" class="difflineplus">+  }</span>
<a href="#l50.65"></a><span id="l50.65" class="difflineplus">+];</span>
<a href="#l50.66"></a><span id="l50.66" class="difflineplus">+</span>
<a href="#l50.67"></a><span id="l50.67" class="difflineplus">+/**</span>
<a href="#l50.68"></a><span id="l50.68" class="difflineplus">+ * Using exciting templates from |illegalMessageTemplates|, verify that gloda</span>
<a href="#l50.69"></a><span id="l50.69" class="difflineplus">+ *  fails to index them and marks the messages bad.</span>
<a href="#l50.70"></a><span id="l50.70" class="difflineplus">+ */</span>
<a href="#l50.71"></a><span id="l50.71" class="difflineplus">+function test_illegal_message(aInfo) {</span>
<a href="#l50.72"></a><span id="l50.72" class="difflineplus">+  // Inject the messages.</span>
<a href="#l50.73"></a><span id="l50.73" class="difflineplus">+  let [msgSet] = make_new_sets_in_folder(gInbox, [</span>
<a href="#l50.74"></a><span id="l50.74" class="difflineplus">+                   {count: 1, clobberHeaders: aInfo.clobberHeaders}]);</span>
<a href="#l50.75"></a><span id="l50.75" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l50.76"></a><span id="l50.76" class="difflineplus">+</span>
<a href="#l50.77"></a><span id="l50.77" class="difflineplus">+  // indexing should complete without actually indexing the message</span>
<a href="#l50.78"></a><span id="l50.78" class="difflineplus">+  yield wait_for_gloda_indexer([], {recovered: 1, failedToRecover: 0,</span>
<a href="#l50.79"></a><span id="l50.79" class="difflineplus">+                                    cleanedUp: 0, hadNoCleanUp: 0});</span>
<a href="#l50.80"></a><span id="l50.80" class="difflineplus">+</span>
<a href="#l50.81"></a><span id="l50.81" class="difflineplus">+  // make sure the header has the expected gloda bad message state.</span>
<a href="#l50.82"></a><span id="l50.82" class="difflineplus">+  let msgHdr = msgSet.getMsgHdr(0);</span>
<a href="#l50.83"></a><span id="l50.83" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-id&quot;), GLODA_BAD_MESSAGE_ID);</span>
<a href="#l50.84"></a><span id="l50.84" class="difflineplus">+</span>
<a href="#l50.85"></a><span id="l50.85" class="difflineplus">+  // make sure gloda does not think the message is indexed</span>
<a href="#l50.86"></a><span id="l50.86" class="difflineplus">+  do_check_eq(Gloda.isMessageIndexed(msgHdr), false);</span>
<a href="#l50.87"></a><span id="l50.87" class="difflineplus">+}</span>
<a href="#l50.88"></a><span id="l50.88" class="difflineplus">+</span>
<a href="#l50.89"></a><span id="l50.89" class="difflineplus">+/**</span>
<a href="#l50.90"></a><span id="l50.90" class="difflineplus">+ * A byzantine failure to stream should not sink us.  Fake a failure.</span>
<a href="#l50.91"></a><span id="l50.91" class="difflineplus">+ */</span>
<a href="#l50.92"></a><span id="l50.92" class="difflineplus">+function test_streaming_failure() {</span>
<a href="#l50.93"></a><span id="l50.93" class="difflineplus">+  configure_gloda_indexing({injectFaultIn: &quot;streaming&quot;});</span>
<a href="#l50.94"></a><span id="l50.94" class="difflineplus">+</span>
<a href="#l50.95"></a><span id="l50.95" class="difflineplus">+  // Inject the messages.</span>
<a href="#l50.96"></a><span id="l50.96" class="difflineplus">+  let [msgSet] = make_new_sets_in_folder(gInbox, [{count: 1}]);</span>
<a href="#l50.97"></a><span id="l50.97" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l50.98"></a><span id="l50.98" class="difflineplus">+</span>
<a href="#l50.99"></a><span id="l50.99" class="difflineplus">+  // indexing should complete without actually indexing the message</span>
<a href="#l50.100"></a><span id="l50.100" class="difflineplus">+  yield wait_for_gloda_indexer([], {recovered: 1, failedToRecover: 0,</span>
<a href="#l50.101"></a><span id="l50.101" class="difflineplus">+                                    cleanedUp: 0, hadNoCleanUp: 0});</span>
<a href="#l50.102"></a><span id="l50.102" class="difflineplus">+</span>
<a href="#l50.103"></a><span id="l50.103" class="difflineplus">+  // make sure the header has the expected gloda bad message state.</span>
<a href="#l50.104"></a><span id="l50.104" class="difflineplus">+  let msgHdr = msgSet.getMsgHdr(0);</span>
<a href="#l50.105"></a><span id="l50.105" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-id&quot;), GLODA_BAD_MESSAGE_ID);</span>
<a href="#l50.106"></a><span id="l50.106" class="difflineplus">+</span>
<a href="#l50.107"></a><span id="l50.107" class="difflineplus">+  // make sure gloda does not think the message is indexed</span>
<a href="#l50.108"></a><span id="l50.108" class="difflineplus">+  do_check_eq(Gloda.isMessageIndexed(msgHdr), false);</span>
<a href="#l50.109"></a><span id="l50.109" class="difflineplus">+</span>
<a href="#l50.110"></a><span id="l50.110" class="difflineplus">+  configure_gloda_indexing({});</span>
<a href="#l50.111"></a><span id="l50.111" class="difflineplus">+}</span>
<a href="#l50.112"></a><span id="l50.112" class="difflineplus">+</span>
<a href="#l50.113"></a><span id="l50.113" class="difflineplus">+/**</span>
<a href="#l50.114"></a><span id="l50.114" class="difflineplus">+ * If we have one bad message followed by a good message, the good message</span>
<a href="#l50.115"></a><span id="l50.115" class="difflineplus">+ *  should still get indexed.  Additionally, if we do a sweep on the folder,</span>
<a href="#l50.116"></a><span id="l50.116" class="difflineplus">+ *  we should not attempt to index the message again.</span>
<a href="#l50.117"></a><span id="l50.117" class="difflineplus">+ */</span>
<a href="#l50.118"></a><span id="l50.118" class="difflineplus">+function test_recovery_and_no_second_attempts() {</span>
<a href="#l50.119"></a><span id="l50.119" class="difflineplus">+  let [badSet, goodSet] = make_new_sets_in_folder(gInbox, [</span>
<a href="#l50.120"></a><span id="l50.120" class="difflineplus">+                   {count: 1, clobberHeaders: {From: &quot;&quot;}},</span>
<a href="#l50.121"></a><span id="l50.121" class="difflineplus">+                   {count: 1}]);</span>
<a href="#l50.122"></a><span id="l50.122" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l50.123"></a><span id="l50.123" class="difflineplus">+</span>
<a href="#l50.124"></a><span id="l50.124" class="difflineplus">+  yield wait_for_gloda_indexer([goodSet], {recovered: 1});</span>
<a href="#l50.125"></a><span id="l50.125" class="difflineplus">+</span>
<a href="#l50.126"></a><span id="l50.126" class="difflineplus">+  // index the folder; no messages should get indexed and there should be no</span>
<a href="#l50.127"></a><span id="l50.127" class="difflineplus">+  //  failure things.</span>
<a href="#l50.128"></a><span id="l50.128" class="difflineplus">+  GlodaMsgIndexer.indexFolder(gInbox);</span>
<a href="#l50.129"></a><span id="l50.129" class="difflineplus">+  yield wait_for_gloda_indexer([], {recovered: 0, failedToRecover: 0,</span>
<a href="#l50.130"></a><span id="l50.130" class="difflineplus">+                                    cleanedUp: 0, hadNoCleanUp: 0});</span>
<a href="#l50.131"></a><span id="l50.131" class="difflineplus">+}</span>
<a href="#l50.132"></a><span id="l50.132" class="difflineplus">+</span>
<a href="#l50.133"></a><span id="l50.133" class="difflineplus">+/**</span>
<a href="#l50.134"></a><span id="l50.134" class="difflineplus">+ * Make sure that we attempt to reindex a dirty bad message and that when we</span>
<a href="#l50.135"></a><span id="l50.135" class="difflineplus">+ *  fail that we clear the dirty bit.</span>
<a href="#l50.136"></a><span id="l50.136" class="difflineplus">+ */</span>
<a href="#l50.137"></a><span id="l50.137" class="difflineplus">+function test_reindex_on_dirty_clear_dirty_on_fail() {</span>
<a href="#l50.138"></a><span id="l50.138" class="difflineplus">+  // Inject a new illegal message</span>
<a href="#l50.139"></a><span id="l50.139" class="difflineplus">+  let [msgSet] = make_new_sets_in_folder(gInbox, [{</span>
<a href="#l50.140"></a><span id="l50.140" class="difflineplus">+                   count: 1,</span>
<a href="#l50.141"></a><span id="l50.141" class="difflineplus">+                   clobberHeaders: illegalMessageTemplates[0].clobberHeaders,</span>
<a href="#l50.142"></a><span id="l50.142" class="difflineplus">+                 }]);</span>
<a href="#l50.143"></a><span id="l50.143" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l50.144"></a><span id="l50.144" class="difflineplus">+</span>
<a href="#l50.145"></a><span id="l50.145" class="difflineplus">+  // indexing should complete without actually indexing the message</span>
<a href="#l50.146"></a><span id="l50.146" class="difflineplus">+  yield wait_for_gloda_indexer([], {recovered: 1, failedToRecover: 0,</span>
<a href="#l50.147"></a><span id="l50.147" class="difflineplus">+                                    cleanedUp: 0, hadNoCleanUp: 0});</span>
<a href="#l50.148"></a><span id="l50.148" class="difflineplus">+</span>
<a href="#l50.149"></a><span id="l50.149" class="difflineplus">+  // mark the message dirty, force the folder to be indexed</span>
<a href="#l50.150"></a><span id="l50.150" class="difflineplus">+  let msgHdr = msgSet.getMsgHdr(0);</span>
<a href="#l50.151"></a><span id="l50.151" class="difflineplus">+  msgHdr.setUint32Property(&quot;gloda-dirty&quot;, 1);</span>
<a href="#l50.152"></a><span id="l50.152" class="difflineplus">+  GlodaMsgIndexer.indexFolder(gInbox);</span>
<a href="#l50.153"></a><span id="l50.153" class="difflineplus">+  yield wait_for_gloda_indexer([], {recovered: 1, failedToRecover: 0,</span>
<a href="#l50.154"></a><span id="l50.154" class="difflineplus">+                                    cleanedUp: 0, hadNoCleanUp: 0});</span>
<a href="#l50.155"></a><span id="l50.155" class="difflineplus">+  // now the message should be clean</span>
<a href="#l50.156"></a><span id="l50.156" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-dirty&quot;), 0);</span>
<a href="#l50.157"></a><span id="l50.157" class="difflineplus">+</span>
<a href="#l50.158"></a><span id="l50.158" class="difflineplus">+  // eh, check again with filtyh</span>
<a href="#l50.159"></a><span id="l50.159" class="difflineplus">+  msgHdr.setUint32Property(&quot;gloda-dirty&quot;, 2);</span>
<a href="#l50.160"></a><span id="l50.160" class="difflineplus">+  GlodaMsgIndexer.indexFolder(gInbox);</span>
<a href="#l50.161"></a><span id="l50.161" class="difflineplus">+  yield wait_for_gloda_indexer([], {recovered: 1, failedToRecover: 0,</span>
<a href="#l50.162"></a><span id="l50.162" class="difflineplus">+                                    cleanedUp: 0, hadNoCleanUp: 0});</span>
<a href="#l50.163"></a><span id="l50.163" class="difflineplus">+  // now the message should be clean</span>
<a href="#l50.164"></a><span id="l50.164" class="difflineplus">+  do_check_eq(msgHdr.getUint32Property(&quot;gloda-dirty&quot;), 0);</span>
<a href="#l50.165"></a><span id="l50.165" class="difflineplus">+}</span>
<a href="#l50.166"></a><span id="l50.166" class="difflineplus">+</span>
<a href="#l50.167"></a><span id="l50.167" class="difflineplus">+let tests = [</span>
<a href="#l50.168"></a><span id="l50.168" class="difflineplus">+  parameterizeTest(test_illegal_message, illegalMessageTemplates),</span>
<a href="#l50.169"></a><span id="l50.169" class="difflineplus">+  test_streaming_failure,</span>
<a href="#l50.170"></a><span id="l50.170" class="difflineplus">+  test_recovery_and_no_second_attempts,</span>
<a href="#l50.171"></a><span id="l50.171" class="difflineplus">+  test_reindex_on_dirty_clear_dirty_on_fail,</span>
<a href="#l50.172"></a><span id="l50.172" class="difflineplus">+];</span>
<a href="#l50.173"></a><span id="l50.173" class="difflineplus">+</span>
<a href="#l50.174"></a><span id="l50.174" class="difflineplus">+function run_test() {</span>
<a href="#l50.175"></a><span id="l50.175" class="difflineplus">+  gInbox = configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l50.176"></a><span id="l50.176" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l50.177"></a><span id="l50.177" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l51.1"></a><span id="l51.1">new file mode 100644</span>
<a href="#l51.2"></a><span id="l51.2" class="difflineminus">--- /dev/null</span>
<a href="#l51.3"></a><span id="l51.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_compaction.js</span>
<a href="#l51.4"></a><span id="l51.4" class="difflineat">@@ -0,0 +1,202 @@</span>
<a href="#l51.5"></a><span id="l51.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l51.6"></a><span id="l51.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l51.7"></a><span id="l51.7" class="difflineplus">+ *</span>
<a href="#l51.8"></a><span id="l51.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l51.9"></a><span id="l51.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l51.10"></a><span id="l51.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l51.11"></a><span id="l51.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l51.12"></a><span id="l51.12" class="difflineplus">+ *</span>
<a href="#l51.13"></a><span id="l51.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l51.14"></a><span id="l51.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l51.15"></a><span id="l51.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l51.16"></a><span id="l51.16" class="difflineplus">+ * License.</span>
<a href="#l51.17"></a><span id="l51.17" class="difflineplus">+ *</span>
<a href="#l51.18"></a><span id="l51.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l51.19"></a><span id="l51.19" class="difflineplus">+ *</span>
<a href="#l51.20"></a><span id="l51.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l51.21"></a><span id="l51.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l51.22"></a><span id="l51.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l51.23"></a><span id="l51.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l51.24"></a><span id="l51.24" class="difflineplus">+ *</span>
<a href="#l51.25"></a><span id="l51.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l51.26"></a><span id="l51.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l51.27"></a><span id="l51.27" class="difflineplus">+ *</span>
<a href="#l51.28"></a><span id="l51.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l51.29"></a><span id="l51.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l51.30"></a><span id="l51.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l51.31"></a><span id="l51.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l51.32"></a><span id="l51.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l51.33"></a><span id="l51.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l51.34"></a><span id="l51.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l51.35"></a><span id="l51.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l51.36"></a><span id="l51.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l51.37"></a><span id="l51.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l51.38"></a><span id="l51.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l51.39"></a><span id="l51.39" class="difflineplus">+ *</span>
<a href="#l51.40"></a><span id="l51.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l51.41"></a><span id="l51.41" class="difflineplus">+</span>
<a href="#l51.42"></a><span id="l51.42" class="difflineplus">+/*</span>
<a href="#l51.43"></a><span id="l51.43" class="difflineplus">+ * Test that gloda does the right things in terms of compaction.  Major cases:</span>
<a href="#l51.44"></a><span id="l51.44" class="difflineplus">+ *</span>
<a href="#l51.45"></a><span id="l51.45" class="difflineplus">+ * - Compaction occurs while we are in the process of indexing a folder.  We</span>
<a href="#l51.46"></a><span id="l51.46" class="difflineplus">+ *    want to make sure we stop indexing cleanly</span>
<a href="#l51.47"></a><span id="l51.47" class="difflineplus">+ *</span>
<a href="#l51.48"></a><span id="l51.48" class="difflineplus">+ * - A folder that we have already indexed gets compacted.  We want to make sure</span>
<a href="#l51.49"></a><span id="l51.49" class="difflineplus">+ *    that we update the message keys for all involved.  This means verifying</span>
<a href="#l51.50"></a><span id="l51.50" class="difflineplus">+ *    that both the on-disk representations and in-memory representations are</span>
<a href="#l51.51"></a><span id="l51.51" class="difflineplus">+ *    correct.</span>
<a href="#l51.52"></a><span id="l51.52" class="difflineplus">+ *</span>
<a href="#l51.53"></a><span id="l51.53" class="difflineplus">+ * There is also a less interesting case:</span>
<a href="#l51.54"></a><span id="l51.54" class="difflineplus">+ *</span>
<a href="#l51.55"></a><span id="l51.55" class="difflineplus">+ * - Make sure that the indexer does not try and start indexing a folder that is</span>
<a href="#l51.56"></a><span id="l51.56" class="difflineplus">+ *    in the process of being compacted.</span>
<a href="#l51.57"></a><span id="l51.57" class="difflineplus">+ */</span>
<a href="#l51.58"></a><span id="l51.58" class="difflineplus">+</span>
<a href="#l51.59"></a><span id="l51.59" class="difflineplus">+load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l51.60"></a><span id="l51.60" class="difflineplus">+</span>
<a href="#l51.61"></a><span id="l51.61" class="difflineplus">+/**</span>
<a href="#l51.62"></a><span id="l51.62" class="difflineplus">+ * Verify that the message keys match between the message headers and the</span>
<a href="#l51.63"></a><span id="l51.63" class="difflineplus">+ *  (augmented on) gloda messages that correspond to the headers.</span>
<a href="#l51.64"></a><span id="l51.64" class="difflineplus">+ */</span>
<a href="#l51.65"></a><span id="l51.65" class="difflineplus">+function verify_message_keys(aSynSet) {</span>
<a href="#l51.66"></a><span id="l51.66" class="difflineplus">+  let iMsg = 0;</span>
<a href="#l51.67"></a><span id="l51.67" class="difflineplus">+  for each (let msgHdr in aSynSet.msgHdrs) {</span>
<a href="#l51.68"></a><span id="l51.68" class="difflineplus">+    let glodaMsg = aSynSet.glodaMessages[iMsg++];</span>
<a href="#l51.69"></a><span id="l51.69" class="difflineplus">+    if (msgHdr.messageKey != glodaMsg.messageKey)</span>
<a href="#l51.70"></a><span id="l51.70" class="difflineplus">+      mark_failure([&quot;Message header&quot;, msgHdr,</span>
<a href="#l51.71"></a><span id="l51.71" class="difflineplus">+                    &quot;should have message key &quot; + msgHdr.messageKey +</span>
<a href="#l51.72"></a><span id="l51.72" class="difflineplus">+                     &quot; but has key &quot; + glodaMsg.messageKey + &quot; per gloda msg&quot;,</span>
<a href="#l51.73"></a><span id="l51.73" class="difflineplus">+                    glodaMsg]);</span>
<a href="#l51.74"></a><span id="l51.74" class="difflineplus">+  }</span>
<a href="#l51.75"></a><span id="l51.75" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;verified message keys after compaction&quot;, []);</span>
<a href="#l51.76"></a><span id="l51.76" class="difflineplus">+}</span>
<a href="#l51.77"></a><span id="l51.77" class="difflineplus">+</span>
<a href="#l51.78"></a><span id="l51.78" class="difflineplus">+var indexingPassPermutations = [</span>
<a href="#l51.79"></a><span id="l51.79" class="difflineplus">+  {</span>
<a href="#l51.80"></a><span id="l51.80" class="difflineplus">+    name: &quot;none pending commit&quot;,</span>
<a href="#l51.81"></a><span id="l51.81" class="difflineplus">+    forceCommit: true,</span>
<a href="#l51.82"></a><span id="l51.82" class="difflineplus">+  },</span>
<a href="#l51.83"></a><span id="l51.83" class="difflineplus">+  {</span>
<a href="#l51.84"></a><span id="l51.84" class="difflineplus">+    name: &quot;all pending commit&quot;,</span>
<a href="#l51.85"></a><span id="l51.85" class="difflineplus">+    forceCommit: false,</span>
<a href="#l51.86"></a><span id="l51.86" class="difflineplus">+  },</span>
<a href="#l51.87"></a><span id="l51.87" class="difflineplus">+];</span>
<a href="#l51.88"></a><span id="l51.88" class="difflineplus">+</span>
<a href="#l51.89"></a><span id="l51.89" class="difflineplus">+/**</span>
<a href="#l51.90"></a><span id="l51.90" class="difflineplus">+ * Compact a folder that we were not indexing.  Make sure gloda's representations</span>
<a href="#l51.91"></a><span id="l51.91" class="difflineplus">+ *  get updated to the new message keys.</span>
<a href="#l51.92"></a><span id="l51.92" class="difflineplus">+ *</span>
<a href="#l51.93"></a><span id="l51.93" class="difflineplus">+ * This is parameterized because the logic has special cases to deal with</span>
<a href="#l51.94"></a><span id="l51.94" class="difflineplus">+ *  messages that were pending commit that got blown away.</span>
<a href="#l51.95"></a><span id="l51.95" class="difflineplus">+ */</span>
<a href="#l51.96"></a><span id="l51.96" class="difflineplus">+function test_compaction_indexing_pass(aParam) {</span>
<a href="#l51.97"></a><span id="l51.97" class="difflineplus">+  // Create 5 messages.  We will move just the third message so the first two</span>
<a href="#l51.98"></a><span id="l51.98" class="difflineplus">+  //  message keep their keys and the last two change.  (We want 2 for both</span>
<a href="#l51.99"></a><span id="l51.99" class="difflineplus">+  //  cases to avoid edge cases.)</span>
<a href="#l51.100"></a><span id="l51.100" class="difflineplus">+  let [folder, sameSet, moveSet, shiftSet] = make_folder_with_sets([</span>
<a href="#l51.101"></a><span id="l51.101" class="difflineplus">+    {count: 2}, {count: 1}, {count: 2}]);</span>
<a href="#l51.102"></a><span id="l51.102" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l51.103"></a><span id="l51.103" class="difflineplus">+  yield wait_for_gloda_indexer([sameSet, moveSet, shiftSet], {augment: true});</span>
<a href="#l51.104"></a><span id="l51.104" class="difflineplus">+</span>
<a href="#l51.105"></a><span id="l51.105" class="difflineplus">+  // move the message to another folder</span>
<a href="#l51.106"></a><span id="l51.106" class="difflineplus">+  let otherFolder = make_empty_folder();</span>
<a href="#l51.107"></a><span id="l51.107" class="difflineplus">+  yield async_move_messages(moveSet, otherFolder);</span>
<a href="#l51.108"></a><span id="l51.108" class="difflineplus">+  yield wait_for_gloda_indexer([moveSet]);</span>
<a href="#l51.109"></a><span id="l51.109" class="difflineplus">+</span>
<a href="#l51.110"></a><span id="l51.110" class="difflineplus">+  if (aParam.forceCommit)</span>
<a href="#l51.111"></a><span id="l51.111" class="difflineplus">+    yield wait_for_gloda_db_flush();</span>
<a href="#l51.112"></a><span id="l51.112" class="difflineplus">+</span>
<a href="#l51.113"></a><span id="l51.113" class="difflineplus">+  // compact</span>
<a href="#l51.114"></a><span id="l51.114" class="difflineplus">+  let msgFolder = get_real_injection_folder(folder);</span>
<a href="#l51.115"></a><span id="l51.115" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;triggering compaction&quot;,</span>
<a href="#l51.116"></a><span id="l51.116" class="difflineplus">+              [&quot;folder&quot;, msgFolder,</span>
<a href="#l51.117"></a><span id="l51.117" class="difflineplus">+               &quot;gloda folder&quot;, Gloda.getFolderForFolder(msgFolder)]);</span>
<a href="#l51.118"></a><span id="l51.118" class="difflineplus">+  msgFolder.compact(asyncUrlListener, null);</span>
<a href="#l51.119"></a><span id="l51.119" class="difflineplus">+  yield false;</span>
<a href="#l51.120"></a><span id="l51.120" class="difflineplus">+  // wait for the compaction job to complete</span>
<a href="#l51.121"></a><span id="l51.121" class="difflineplus">+  yield wait_for_gloda_indexer();</span>
<a href="#l51.122"></a><span id="l51.122" class="difflineplus">+</span>
<a href="#l51.123"></a><span id="l51.123" class="difflineplus">+  verify_message_keys(sameSet);</span>
<a href="#l51.124"></a><span id="l51.124" class="difflineplus">+  verify_message_keys(shiftSet);</span>
<a href="#l51.125"></a><span id="l51.125" class="difflineplus">+}</span>
<a href="#l51.126"></a><span id="l51.126" class="difflineplus">+</span>
<a href="#l51.127"></a><span id="l51.127" class="difflineplus">+/**</span>
<a href="#l51.128"></a><span id="l51.128" class="difflineplus">+ * Induce a compaction while we are in the middle of indexing.  Make sure we</span>
<a href="#l51.129"></a><span id="l51.129" class="difflineplus">+ *  clean up and that the folder ends</span>
<a href="#l51.130"></a><span id="l51.130" class="difflineplus">+ *</span>
<a href="#l51.131"></a><span id="l51.131" class="difflineplus">+ * Note that in order for compaction to happen there has to be something for</span>
<a href="#l51.132"></a><span id="l51.132" class="difflineplus">+ *  compaction to do, so our prep involves moving a message to another folder.</span>
<a href="#l51.133"></a><span id="l51.133" class="difflineplus">+ *  (Deletion actually produces more legwork for gloda whereas a local move is</span>
<a href="#l51.134"></a><span id="l51.134" class="difflineplus">+ *  almost entirely free.)</span>
<a href="#l51.135"></a><span id="l51.135" class="difflineplus">+ */</span>
<a href="#l51.136"></a><span id="l51.136" class="difflineplus">+function test_compaction_interrupting_indexing() {</span>
<a href="#l51.137"></a><span id="l51.137" class="difflineplus">+  // create a folder with a message inside.</span>
<a href="#l51.138"></a><span id="l51.138" class="difflineplus">+  let [folder, compactionFodderSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l51.139"></a><span id="l51.139" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l51.140"></a><span id="l51.140" class="difflineplus">+  yield wait_for_gloda_indexer([compactionFodderSet]);</span>
<a href="#l51.141"></a><span id="l51.141" class="difflineplus">+</span>
<a href="#l51.142"></a><span id="l51.142" class="difflineplus">+  // move that message to another folder</span>
<a href="#l51.143"></a><span id="l51.143" class="difflineplus">+  let otherFolder = make_empty_folder();</span>
<a href="#l51.144"></a><span id="l51.144" class="difflineplus">+  yield async_move_messages(compactionFodderSet, otherFolder);</span>
<a href="#l51.145"></a><span id="l51.145" class="difflineplus">+  yield wait_for_gloda_indexer([compactionFodderSet]);</span>
<a href="#l51.146"></a><span id="l51.146" class="difflineplus">+</span>
<a href="#l51.147"></a><span id="l51.147" class="difflineplus">+  // Configure the gloda indexer to hang while streaming the message.</span>
<a href="#l51.148"></a><span id="l51.148" class="difflineplus">+  configure_gloda_indexing({hangWhile: &quot;streaming&quot;});</span>
<a href="#l51.149"></a><span id="l51.149" class="difflineplus">+</span>
<a href="#l51.150"></a><span id="l51.150" class="difflineplus">+  // create a folder with a message inside.</span>
<a href="#l51.151"></a><span id="l51.151" class="difflineplus">+  let [msgSet] = make_new_sets_in_folder(folder, [{count: 1}]);</span>
<a href="#l51.152"></a><span id="l51.152" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l51.153"></a><span id="l51.153" class="difflineplus">+</span>
<a href="#l51.154"></a><span id="l51.154" class="difflineplus">+  yield wait_for_indexing_hang();</span>
<a href="#l51.155"></a><span id="l51.155" class="difflineplus">+</span>
<a href="#l51.156"></a><span id="l51.156" class="difflineplus">+  // compact!  this should kill the job (and because of the compaction; no other</span>
<a href="#l51.157"></a><span id="l51.157" class="difflineplus">+  //  reason should be able to do this.)</span>
<a href="#l51.158"></a><span id="l51.158" class="difflineplus">+  let msgFolder = get_real_injection_folder(folder);</span>
<a href="#l51.159"></a><span id="l51.159" class="difflineplus">+  msgFolder.compact(asyncUrlListener, null);</span>
<a href="#l51.160"></a><span id="l51.160" class="difflineplus">+  yield false;</span>
<a href="#l51.161"></a><span id="l51.161" class="difflineplus">+</span>
<a href="#l51.162"></a><span id="l51.162" class="difflineplus">+  // reset indexing to not hang</span>
<a href="#l51.163"></a><span id="l51.163" class="difflineplus">+  configure_gloda_indexing({});</span>
<a href="#l51.164"></a><span id="l51.164" class="difflineplus">+</span>
<a href="#l51.165"></a><span id="l51.165" class="difflineplus">+  // sorta get the event chain going again...</span>
<a href="#l51.166"></a><span id="l51.166" class="difflineplus">+  resume_from_simulated_hang(true);</span>
<a href="#l51.167"></a><span id="l51.167" class="difflineplus">+</span>
<a href="#l51.168"></a><span id="l51.168" class="difflineplus">+  // Because the folder was dirty it should actually end up getting indexed,</span>
<a href="#l51.169"></a><span id="l51.169" class="difflineplus">+  //  so in the end the message will get indexed.</span>
<a href="#l51.170"></a><span id="l51.170" class="difflineplus">+  // Also, make sure a cleanup was observed.</span>
<a href="#l51.171"></a><span id="l51.171" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet], {cleanedUp: 1});</span>
<a href="#l51.172"></a><span id="l51.172" class="difflineplus">+}</span>
<a href="#l51.173"></a><span id="l51.173" class="difflineplus">+</span>
<a href="#l51.174"></a><span id="l51.174" class="difflineplus">+/**</span>
<a href="#l51.175"></a><span id="l51.175" class="difflineplus">+ *</span>
<a href="#l51.176"></a><span id="l51.176" class="difflineplus">+ */</span>
<a href="#l51.177"></a><span id="l51.177" class="difflineplus">+function test_do_not_enter_compacting_folders() {</span>
<a href="#l51.178"></a><span id="l51.178" class="difflineplus">+  // turn off indexing...</span>
<a href="#l51.179"></a><span id="l51.179" class="difflineplus">+  configure_gloda_indexing({event: false});</span>
<a href="#l51.180"></a><span id="l51.180" class="difflineplus">+</span>
<a href="#l51.181"></a><span id="l51.181" class="difflineplus">+  // create a folder with a message inside.</span>
<a href="#l51.182"></a><span id="l51.182" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l51.183"></a><span id="l51.183" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l51.184"></a><span id="l51.184" class="difflineplus">+</span>
<a href="#l51.185"></a><span id="l51.185" class="difflineplus">+  // lie and claim we are compacting that folder</span>
<a href="#l51.186"></a><span id="l51.186" class="difflineplus">+  let glodaFolder = Gloda.getFolderForFolder(get_real_injection_folder(folder));</span>
<a href="#l51.187"></a><span id="l51.187" class="difflineplus">+  glodaFolder.compacting = true;</span>
<a href="#l51.188"></a><span id="l51.188" class="difflineplus">+</span>
<a href="#l51.189"></a><span id="l51.189" class="difflineplus">+  // now try and force ourselves to index that folder and its message...</span>
<a href="#l51.190"></a><span id="l51.190" class="difflineplus">+  // turn back on indexing...</span>
<a href="#l51.191"></a><span id="l51.191" class="difflineplus">+  configure_gloda_indexing({event: true});</span>
<a href="#l51.192"></a><span id="l51.192" class="difflineplus">+</span>
<a href="#l51.193"></a><span id="l51.193" class="difflineplus">+  // verify that the indexer completes without having indexed anything</span>
<a href="#l51.194"></a><span id="l51.194" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l51.195"></a><span id="l51.195" class="difflineplus">+}</span>
<a href="#l51.196"></a><span id="l51.196" class="difflineplus">+</span>
<a href="#l51.197"></a><span id="l51.197" class="difflineplus">+var tests = [</span>
<a href="#l51.198"></a><span id="l51.198" class="difflineplus">+  parameterizeTest(test_compaction_indexing_pass, indexingPassPermutations),</span>
<a href="#l51.199"></a><span id="l51.199" class="difflineplus">+  test_compaction_interrupting_indexing,</span>
<a href="#l51.200"></a><span id="l51.200" class="difflineplus">+  test_do_not_enter_compacting_folders,</span>
<a href="#l51.201"></a><span id="l51.201" class="difflineplus">+];</span>
<a href="#l51.202"></a><span id="l51.202" class="difflineplus">+</span>
<a href="#l51.203"></a><span id="l51.203" class="difflineplus">+function run_test() {</span>
<a href="#l51.204"></a><span id="l51.204" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l51.205"></a><span id="l51.205" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l51.206"></a><span id="l51.206" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l52.1"></a><span id="l52.1">new file mode 100644</span>
<a href="#l52.2"></a><span id="l52.2" class="difflineminus">--- /dev/null</span>
<a href="#l52.3"></a><span id="l52.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_junk_imap_offline.js</span>
<a href="#l52.4"></a><span id="l52.4" class="difflineat">@@ -0,0 +1,9 @@</span>
<a href="#l52.5"></a><span id="l52.5" class="difflineplus">+/**</span>
<a href="#l52.6"></a><span id="l52.6" class="difflineplus">+ * Test indexing support for offline IMAP junk.</span>
<a href="#l52.7"></a><span id="l52.7" class="difflineplus">+ */</span>
<a href="#l52.8"></a><span id="l52.8" class="difflineplus">+load(&quot;base_index_junk.js&quot;);</span>
<a href="#l52.9"></a><span id="l52.9" class="difflineplus">+</span>
<a href="#l52.10"></a><span id="l52.10" class="difflineplus">+function run_test() {</span>
<a href="#l52.11"></a><span id="l52.11" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: true});</span>
<a href="#l52.12"></a><span id="l52.12" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l52.13"></a><span id="l52.13" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l53.1"></a><span id="l53.1">new file mode 100644</span>
<a href="#l53.2"></a><span id="l53.2" class="difflineminus">--- /dev/null</span>
<a href="#l53.3"></a><span id="l53.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_junk_imap_online.js</span>
<a href="#l53.4"></a><span id="l53.4" class="difflineat">@@ -0,0 +1,9 @@</span>
<a href="#l53.5"></a><span id="l53.5" class="difflineplus">+/**</span>
<a href="#l53.6"></a><span id="l53.6" class="difflineplus">+ * Test indexing support for online IMAP junk.</span>
<a href="#l53.7"></a><span id="l53.7" class="difflineplus">+ */</span>
<a href="#l53.8"></a><span id="l53.8" class="difflineplus">+load(&quot;base_index_junk.js&quot;);</span>
<a href="#l53.9"></a><span id="l53.9" class="difflineplus">+</span>
<a href="#l53.10"></a><span id="l53.10" class="difflineplus">+function run_test() {</span>
<a href="#l53.11"></a><span id="l53.11" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: false});</span>
<a href="#l53.12"></a><span id="l53.12" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l53.13"></a><span id="l53.13" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l54.1"></a><span id="l54.1">new file mode 100644</span>
<a href="#l54.2"></a><span id="l54.2" class="difflineminus">--- /dev/null</span>
<a href="#l54.3"></a><span id="l54.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_junk_local.js</span>
<a href="#l54.4"></a><span id="l54.4" class="difflineat">@@ -0,0 +1,9 @@</span>
<a href="#l54.5"></a><span id="l54.5" class="difflineplus">+/**</span>
<a href="#l54.6"></a><span id="l54.6" class="difflineplus">+ * Test indexing support for local junk.</span>
<a href="#l54.7"></a><span id="l54.7" class="difflineplus">+ */</span>
<a href="#l54.8"></a><span id="l54.8" class="difflineplus">+load(&quot;base_index_junk.js&quot;);</span>
<a href="#l54.9"></a><span id="l54.9" class="difflineplus">+</span>
<a href="#l54.10"></a><span id="l54.10" class="difflineplus">+function run_test() {</span>
<a href="#l54.11"></a><span id="l54.11" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l54.12"></a><span id="l54.12" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l54.13"></a><span id="l54.13" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l55.1"></a><span id="l55.1">rename from mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js</span>
<a href="#l55.2"></a><span id="l55.2">rename to mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js</span>
<a href="#l55.3"></a><span id="l55.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages.js</span>
<a href="#l55.4"></a><span id="l55.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages_imap_offline.js</span>
<a href="#l55.5"></a><span id="l55.5" class="difflineat">@@ -1,19 +1,11 @@</span>
<a href="#l55.6"></a><span id="l55.6"> /* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l55.7"></a><span id="l55.7"> /**</span>
<a href="#l55.8"></a><span id="l55.8">  * Tests how well gloda indexes IMAP messages that are offline from the start.</span>
<a href="#l55.9"></a><span id="l55.9">  */</span>
<a href="#l55.10"></a><span id="l55.10"> </span>
<a href="#l55.11"></a><span id="l55.11" class="difflineminus">-// Most of the definitions are common, so just re-use those</span>
<a href="#l55.12"></a><span id="l55.12" class="difflineminus">-load(&quot;test_index_messages.js&quot;);</span>
<a href="#l55.13"></a><span id="l55.13" class="difflineminus">-</span>
<a href="#l55.14"></a><span id="l55.14" class="difflineminus">-var get_expected_folder_URI = function imap_get_expected_folder_URI() {</span>
<a href="#l55.15"></a><span id="l55.15" class="difflineminus">-  return indexMessageState.imapInbox.URI;</span>
<a href="#l55.16"></a><span id="l55.16" class="difflineminus">-};</span>
<a href="#l55.17"></a><span id="l55.17" class="difflineplus">+load(&quot;base_index_messages.js&quot;);</span>
<a href="#l55.18"></a><span id="l55.18"> </span>
<a href="#l55.19"></a><span id="l55.19" class="difflineminus">-var pre_test_threading_hook = function imap_pre_test_threading_hook() {</span>
<a href="#l55.20"></a><span id="l55.20" class="difflineminus">-  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l55.21"></a><span id="l55.21" class="difflineminus">-  next_test();</span>
<a href="#l55.22"></a><span id="l55.22" class="difflineminus">-};</span>
<a href="#l55.23"></a><span id="l55.23" class="difflineminus">-</span>
<a href="#l55.24"></a><span id="l55.24" class="difflineminus">-// Switch to the IMAP fake server</span>
<a href="#l55.25"></a><span id="l55.25" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span>
<a href="#l55.26"></a><span id="l55.26" class="difflineplus">+function run_test() {</span>
<a href="#l55.27"></a><span id="l55.27" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: true});</span>
<a href="#l55.28"></a><span id="l55.28" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l55.29"></a><span id="l55.29" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l56.1"></a><span id="l56.1">rename from mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js</span>
<a href="#l56.2"></a><span id="l56.2">rename to mailnews/db/gloda/test/unit/test_index_messages_imap_online.js</span>
<a href="#l56.3"></a><span id="l56.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages.js</span>
<a href="#l56.4"></a><span id="l56.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages_imap_online.js</span>
<a href="#l56.5"></a><span id="l56.5" class="difflineat">@@ -1,16 +1,14 @@</span>
<a href="#l56.6"></a><span id="l56.6"> /* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l56.7"></a><span id="l56.7"> /**</span>
<a href="#l56.8"></a><span id="l56.8">  * Tests how well gloda indexes IMAP messages that aren't offline.</span>
<a href="#l56.9"></a><span id="l56.9">  */</span>
<a href="#l56.10"></a><span id="l56.10"> </span>
<a href="#l56.11"></a><span id="l56.11"> // Most of the definitions are common, so just re-use those</span>
<a href="#l56.12"></a><span id="l56.12" class="difflineminus">-load(&quot;test_index_messages.js&quot;);</span>
<a href="#l56.13"></a><span id="l56.13" class="difflineplus">+load(&quot;base_index_messages.js&quot;);</span>
<a href="#l56.14"></a><span id="l56.14" class="difflineplus">+</span>
<a href="#l56.15"></a><span id="l56.15" class="difflineplus">+expectFulltextResults = false;</span>
<a href="#l56.16"></a><span id="l56.16"> </span>
<a href="#l56.17"></a><span id="l56.17" class="difflineminus">-var get_expected_folder_URI = function imap_get_expected_folder_URI() {</span>
<a href="#l56.18"></a><span id="l56.18" class="difflineminus">-  return indexMessageState.imapInbox.URI;</span>
<a href="#l56.19"></a><span id="l56.19" class="difflineminus">-};</span>
<a href="#l56.20"></a><span id="l56.20" class="difflineminus">-</span>
<a href="#l56.21"></a><span id="l56.21" class="difflineminus">-var expectFulltextResults = false;</span>
<a href="#l56.22"></a><span id="l56.22" class="difflineminus">-</span>
<a href="#l56.23"></a><span id="l56.23" class="difflineminus">-// Switch to the IMAP fake server</span>
<a href="#l56.24"></a><span id="l56.24" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span>
<a href="#l56.25"></a><span id="l56.25" class="difflineplus">+function run_test() {</span>
<a href="#l56.26"></a><span id="l56.26" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: false});</span>
<a href="#l56.27"></a><span id="l56.27" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l56.28"></a><span id="l56.28" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l57.1"></a><span id="l57.1">rename from mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js</span>
<a href="#l57.2"></a><span id="l57.2">rename to mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js</span>
<a href="#l57.3"></a><span id="l57.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages.js</span>
<a href="#l57.4"></a><span id="l57.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages_imap_online_to_offline.js</span>
<a href="#l57.5"></a><span id="l57.5" class="difflineat">@@ -1,21 +1,16 @@</span>
<a href="#l57.6"></a><span id="l57.6"> /* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l57.7"></a><span id="l57.7"> /**</span>
<a href="#l57.8"></a><span id="l57.8">  * Tests how well gloda indexes IMAP messages that are not offline at first, but</span>
<a href="#l57.9"></a><span id="l57.9">  * are made offline later.</span>
<a href="#l57.10"></a><span id="l57.10">  */</span>
<a href="#l57.11"></a><span id="l57.11"> </span>
<a href="#l57.12"></a><span id="l57.12" class="difflineminus">-// Most of the definitions are common, so just re-use those</span>
<a href="#l57.13"></a><span id="l57.13" class="difflineminus">-load(&quot;test_index_messages.js&quot;);</span>
<a href="#l57.14"></a><span id="l57.14" class="difflineplus">+load(&quot;base_index_messages.js&quot;);</span>
<a href="#l57.15"></a><span id="l57.15"> </span>
<a href="#l57.16"></a><span id="l57.16" class="difflineminus">-var get_expected_folder_URI = function imap_get_expected_folder_URI() {</span>
<a href="#l57.17"></a><span id="l57.17" class="difflineminus">-  return indexMessageState.imapInbox.URI;</span>
<a href="#l57.18"></a><span id="l57.18" class="difflineminus">-};</span>
<a href="#l57.19"></a><span id="l57.19" class="difflineplus">+// we want to go offline once the messages have already been indexed online</span>
<a href="#l57.20"></a><span id="l57.20" class="difflineplus">+goOffline = true;</span>
<a href="#l57.21"></a><span id="l57.21"> </span>
<a href="#l57.22"></a><span id="l57.22" class="difflineminus">-var post_test_threading_hook = function imap_post_test_threading_hook() {</span>
<a href="#l57.23"></a><span id="l57.23" class="difflineminus">-  // We aren't concerned about verification here, so just pass in null</span>
<a href="#l57.24"></a><span id="l57.24" class="difflineminus">-  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages, null,</span>
<a href="#l57.25"></a><span id="l57.25" class="difflineminus">-                          next_test);</span>
<a href="#l57.26"></a><span id="l57.26" class="difflineminus">-};</span>
<a href="#l57.27"></a><span id="l57.27" class="difflineminus">-</span>
<a href="#l57.28"></a><span id="l57.28" class="difflineminus">-// Switch to the IMAP fake server</span>
<a href="#l57.29"></a><span id="l57.29" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span>
<a href="#l57.30"></a><span id="l57.30" class="difflineplus">+function run_test() {</span>
<a href="#l57.31"></a><span id="l57.31" class="difflineplus">+  // start with the messages online</span>
<a href="#l57.32"></a><span id="l57.32" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: false});</span>
<a href="#l57.33"></a><span id="l57.33" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l57.34"></a><span id="l57.34" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l58.1"></a><span id="l58.1">deleted file mode 100644</span>
<a href="#l58.2"></a><span id="l58.2" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js</span>
<a href="#l58.3"></a><span id="l58.3" class="difflineplus">+++ /dev/null</span>
<a href="#l58.4"></a><span id="l58.4" class="difflineat">@@ -1,48 +0,0 @@</span>
<a href="#l58.5"></a><span id="l58.5" class="difflineminus">-/*</span>
<a href="#l58.6"></a><span id="l58.6" class="difflineminus">- * This file tests indexing a whole bunch of messages at once.  We</span>
<a href="#l58.7"></a><span id="l58.7" class="difflineminus">- * are primarily concerned about memory utilization and processor load.</span>
<a href="#l58.8"></a><span id="l58.8" class="difflineminus">- */</span>
<a href="#l58.9"></a><span id="l58.9" class="difflineminus">-</span>
<a href="#l58.10"></a><span id="l58.10" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l58.11"></a><span id="l58.11" class="difflineminus">-load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l58.12"></a><span id="l58.12" class="difflineminus">-</span>
<a href="#l58.13"></a><span id="l58.13" class="difflineminus">-// Create a message generator</span>
<a href="#l58.14"></a><span id="l58.14" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l58.15"></a><span id="l58.15" class="difflineminus">-// Create a message scenario generator using that message generator</span>
<a href="#l58.16"></a><span id="l58.16" class="difflineminus">-var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l58.17"></a><span id="l58.17" class="difflineminus">-</span>
<a href="#l58.18"></a><span id="l58.18" class="difflineminus">-/**</span>
<a href="#l58.19"></a><span id="l58.19" class="difflineminus">- * Provide a bunch of messages to be indexed.</span>
<a href="#l58.20"></a><span id="l58.20" class="difflineminus">- */</span>
<a href="#l58.21"></a><span id="l58.21" class="difflineminus">-var gSynMessages;</span>
<a href="#l58.22"></a><span id="l58.22" class="difflineminus">-function test_index_a_bunch() {</span>
<a href="#l58.23"></a><span id="l58.23" class="difflineminus">-  // 4-children-per, 3-deep = 21</span>
<a href="#l58.24"></a><span id="l58.24" class="difflineminus">-  // 6-children-per, 3 deep = 43</span>
<a href="#l58.25"></a><span id="l58.25" class="difflineminus">-  // 7-children-per, 3-deep = 57</span>
<a href="#l58.26"></a><span id="l58.26" class="difflineminus">-  // 4-children-per, 4-deep = 85</span>
<a href="#l58.27"></a><span id="l58.27" class="difflineminus">-  // 4-children-per, 5-deep pyramid = 341</span>
<a href="#l58.28"></a><span id="l58.28" class="difflineminus">-  // 5-children-per, 5-deep pyramid = 781</span>
<a href="#l58.29"></a><span id="l58.29" class="difflineminus">-  // 4-children-per, 6-deep pyramid = 1365 messages</span>
<a href="#l58.30"></a><span id="l58.30" class="difflineminus">-  gSynMessages = scenarios.fullPyramid(6, 3);</span>
<a href="#l58.31"></a><span id="l58.31" class="difflineminus">-  // we have no need to verify.</span>
<a href="#l58.32"></a><span id="l58.32" class="difflineminus">-  indexMessages(gSynMessages, null, next_test);</span>
<a href="#l58.33"></a><span id="l58.33" class="difflineminus">-}</span>
<a href="#l58.34"></a><span id="l58.34" class="difflineminus">-</span>
<a href="#l58.35"></a><span id="l58.35" class="difflineminus">-var pre_test_hook = function default_pre_test_hook() {</span>
<a href="#l58.36"></a><span id="l58.36" class="difflineminus">-  next_test();</span>
<a href="#l58.37"></a><span id="l58.37" class="difflineminus">-};</span>
<a href="#l58.38"></a><span id="l58.38" class="difflineminus">-var post_test_hook = function default_post_test_hook() {</span>
<a href="#l58.39"></a><span id="l58.39" class="difflineminus">-  next_test();</span>
<a href="#l58.40"></a><span id="l58.40" class="difflineminus">-};</span>
<a href="#l58.41"></a><span id="l58.41" class="difflineminus">-</span>
<a href="#l58.42"></a><span id="l58.42" class="difflineminus">-var tests = [</span>
<a href="#l58.43"></a><span id="l58.43" class="difflineminus">-  function pre_test() { pre_test_hook(); },</span>
<a href="#l58.44"></a><span id="l58.44" class="difflineminus">-  test_index_a_bunch,</span>
<a href="#l58.45"></a><span id="l58.45" class="difflineminus">-  function post_test() { post_test_hook(); },</span>
<a href="#l58.46"></a><span id="l58.46" class="difflineminus">-];</span>
<a href="#l58.47"></a><span id="l58.47" class="difflineminus">-</span>
<a href="#l58.48"></a><span id="l58.48" class="difflineminus">-function run_test() {</span>
<a href="#l58.49"></a><span id="l58.49" class="difflineminus">-  glodaHelperRunTests(tests);</span>
<a href="#l58.50"></a><span id="l58.50" class="difflineminus">-}</span>
<a href="#l58.51"></a><span id="l58.51" class="difflineminus">-</span>
<a href="#l58.52"></a><span id="l58.52" class="difflineminus">-injectMessagesUsing(INJECT_MBOX);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l59.1"></a><span id="l59.1">new file mode 100644</span>
<a href="#l59.2"></a><span id="l59.2" class="difflineminus">--- /dev/null</span>
<a href="#l59.3"></a><span id="l59.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages_local.js</span>
<a href="#l59.4"></a><span id="l59.4" class="difflineat">@@ -0,0 +1,9 @@</span>
<a href="#l59.5"></a><span id="l59.5" class="difflineplus">+/**</span>
<a href="#l59.6"></a><span id="l59.6" class="difflineplus">+ * Test indexing support for local messages.</span>
<a href="#l59.7"></a><span id="l59.7" class="difflineplus">+ */</span>
<a href="#l59.8"></a><span id="l59.8" class="difflineplus">+load(&quot;base_index_messages.js&quot;);</span>
<a href="#l59.9"></a><span id="l59.9" class="difflineplus">+</span>
<a href="#l59.10"></a><span id="l59.10" class="difflineplus">+function run_test() {</span>
<a href="#l59.11"></a><span id="l59.11" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l59.12"></a><span id="l59.12" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l59.13"></a><span id="l59.13" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l60.1"></a><span id="l60.1">deleted file mode 100644</span>
<a href="#l60.2"></a><span id="l60.2" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_non_offline_imap_messages_in_bulk.js</span>
<a href="#l60.3"></a><span id="l60.3" class="difflineplus">+++ /dev/null</span>
<a href="#l60.4"></a><span id="l60.4" class="difflineat">@@ -1,10 +0,0 @@</span>
<a href="#l60.5"></a><span id="l60.5" class="difflineminus">-/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l60.6"></a><span id="l60.6" class="difflineminus">-/**</span>
<a href="#l60.7"></a><span id="l60.7" class="difflineminus">- * Tests how well gloda indexes IMAP messages that aren't offline in bulk.</span>
<a href="#l60.8"></a><span id="l60.8" class="difflineminus">- */</span>
<a href="#l60.9"></a><span id="l60.9" class="difflineminus">-</span>
<a href="#l60.10"></a><span id="l60.10" class="difflineminus">-// The definitions are common, so just re-use those</span>
<a href="#l60.11"></a><span id="l60.11" class="difflineminus">-load(&quot;test_index_messages_in_bulk.js&quot;);</span>
<a href="#l60.12"></a><span id="l60.12" class="difflineminus">-</span>
<a href="#l60.13"></a><span id="l60.13" class="difflineminus">-// Switch to the IMAP fake server</span>
<a href="#l60.14"></a><span id="l60.14" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l61.1"></a><span id="l61.1">deleted file mode 100644</span>
<a href="#l61.2"></a><span id="l61.2" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_originally_offline_imap_messages_in_bulk.js</span>
<a href="#l61.3"></a><span id="l61.3" class="difflineplus">+++ /dev/null</span>
<a href="#l61.4"></a><span id="l61.4" class="difflineat">@@ -1,15 +0,0 @@</span>
<a href="#l61.5"></a><span id="l61.5" class="difflineminus">-/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l61.6"></a><span id="l61.6" class="difflineminus">-/**</span>
<a href="#l61.7"></a><span id="l61.7" class="difflineminus">- * Tests how well gloda indexes IMAP messages that aren't offline in bulk.</span>
<a href="#l61.8"></a><span id="l61.8" class="difflineminus">- */</span>
<a href="#l61.9"></a><span id="l61.9" class="difflineminus">-</span>
<a href="#l61.10"></a><span id="l61.10" class="difflineminus">-// The definitions are common, so just re-use those</span>
<a href="#l61.11"></a><span id="l61.11" class="difflineminus">-load(&quot;test_index_messages_in_bulk.js&quot;);</span>
<a href="#l61.12"></a><span id="l61.12" class="difflineminus">-</span>
<a href="#l61.13"></a><span id="l61.13" class="difflineminus">-var pre_test_hook = function imap_pre_test_hook() {</span>
<a href="#l61.14"></a><span id="l61.14" class="difflineminus">-  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l61.15"></a><span id="l61.15" class="difflineminus">-  next_test();</span>
<a href="#l61.16"></a><span id="l61.16" class="difflineminus">-};</span>
<a href="#l61.17"></a><span id="l61.17" class="difflineminus">-</span>
<a href="#l61.18"></a><span id="l61.18" class="difflineminus">-// Switch to the IMAP fake server</span>
<a href="#l61.19"></a><span id="l61.19" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l62.1"></a><span id="l62.1">new file mode 100644</span>
<a href="#l62.2"></a><span id="l62.2" class="difflineminus">--- /dev/null</span>
<a href="#l62.3"></a><span id="l62.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_sweep_folder.js</span>
<a href="#l62.4"></a><span id="l62.4" class="difflineat">@@ -0,0 +1,124 @@</span>
<a href="#l62.5"></a><span id="l62.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l62.6"></a><span id="l62.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l62.7"></a><span id="l62.7" class="difflineplus">+ *</span>
<a href="#l62.8"></a><span id="l62.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l62.9"></a><span id="l62.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l62.10"></a><span id="l62.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l62.11"></a><span id="l62.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l62.12"></a><span id="l62.12" class="difflineplus">+ *</span>
<a href="#l62.13"></a><span id="l62.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l62.14"></a><span id="l62.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l62.15"></a><span id="l62.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l62.16"></a><span id="l62.16" class="difflineplus">+ * License.</span>
<a href="#l62.17"></a><span id="l62.17" class="difflineplus">+ *</span>
<a href="#l62.18"></a><span id="l62.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l62.19"></a><span id="l62.19" class="difflineplus">+ *</span>
<a href="#l62.20"></a><span id="l62.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l62.21"></a><span id="l62.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l62.22"></a><span id="l62.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l62.23"></a><span id="l62.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l62.24"></a><span id="l62.24" class="difflineplus">+ *</span>
<a href="#l62.25"></a><span id="l62.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l62.26"></a><span id="l62.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l62.27"></a><span id="l62.27" class="difflineplus">+ *</span>
<a href="#l62.28"></a><span id="l62.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l62.29"></a><span id="l62.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l62.30"></a><span id="l62.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l62.31"></a><span id="l62.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l62.32"></a><span id="l62.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l62.33"></a><span id="l62.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l62.34"></a><span id="l62.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l62.35"></a><span id="l62.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l62.36"></a><span id="l62.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l62.37"></a><span id="l62.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l62.38"></a><span id="l62.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l62.39"></a><span id="l62.39" class="difflineplus">+ *</span>
<a href="#l62.40"></a><span id="l62.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l62.41"></a><span id="l62.41" class="difflineplus">+</span>
<a href="#l62.42"></a><span id="l62.42" class="difflineplus">+/* This file tests the folder indexing logic of Gloda._worker_folderIndex in</span>
<a href="#l62.43"></a><span id="l62.43" class="difflineplus">+ *  the greater context of the sweep indexing mechanism.</span>
<a href="#l62.44"></a><span id="l62.44" class="difflineplus">+ *</span>
<a href="#l62.45"></a><span id="l62.45" class="difflineplus">+ * Automated indexing is suppressed for the duration of this file.</span>
<a href="#l62.46"></a><span id="l62.46" class="difflineplus">+ *</span>
<a href="#l62.47"></a><span id="l62.47" class="difflineplus">+ * This is all white-box testing where we know and depend on how the mechanism</span>
<a href="#l62.48"></a><span id="l62.48" class="difflineplus">+ *  is supposed to work/works.  In order to test the phases of the logic we</span>
<a href="#l62.49"></a><span id="l62.49" class="difflineplus">+ *  inject failures into GlodaIndexer._indexerGetEnumerator with a wrapper to</span>
<a href="#l62.50"></a><span id="l62.50" class="difflineplus">+ *  control how far indexing gets.  We also clobber or wrap other functions as</span>
<a href="#l62.51"></a><span id="l62.51" class="difflineplus">+ *  needed.</span>
<a href="#l62.52"></a><span id="l62.52" class="difflineplus">+ */</span>
<a href="#l62.53"></a><span id="l62.53" class="difflineplus">+</span>
<a href="#l62.54"></a><span id="l62.54" class="difflineplus">+load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l62.55"></a><span id="l62.55" class="difflineplus">+</span>
<a href="#l62.56"></a><span id="l62.56" class="difflineplus">+/**</span>
<a href="#l62.57"></a><span id="l62.57" class="difflineplus">+ * We do not index news or RSS.  Make sure we stay out of those folders.</span>
<a href="#l62.58"></a><span id="l62.58" class="difflineplus">+ */</span>
<a href="#l62.59"></a><span id="l62.59" class="difflineplus">+function test_ignore_folders_we_should_not_index() {</span>
<a href="#l62.60"></a><span id="l62.60" class="difflineplus">+  // make sure it ignores news</span>
<a href="#l62.61"></a><span id="l62.61" class="difflineplus">+  // make sure it ignores RSS</span>
<a href="#l62.62"></a><span id="l62.62" class="difflineplus">+}</span>
<a href="#l62.63"></a><span id="l62.63" class="difflineplus">+</span>
<a href="#l62.64"></a><span id="l62.64" class="difflineplus">+/**</span>
<a href="#l62.65"></a><span id="l62.65" class="difflineplus">+ * When we enter a filthy folder we should be marking all the messages as filthy</span>
<a href="#l62.66"></a><span id="l62.66" class="difflineplus">+ *  and committing.</span>
<a href="#l62.67"></a><span id="l62.67" class="difflineplus">+ *</span>
<a href="#l62.68"></a><span id="l62.68" class="difflineplus">+ */</span>
<a href="#l62.69"></a><span id="l62.69" class="difflineplus">+function test_propagate_filthy_from_folder_to_messages() {</span>
<a href="#l62.70"></a><span id="l62.70" class="difflineplus">+  // mark the folder as filthy</span>
<a href="#l62.71"></a><span id="l62.71" class="difflineplus">+</span>
<a href="#l62.72"></a><span id="l62.72" class="difflineplus">+  // index the folder, aborting at the second get enumerator request</span>
<a href="#l62.73"></a><span id="l62.73" class="difflineplus">+</span>
<a href="#l62.74"></a><span id="l62.74" class="difflineplus">+  // all those messages better be filthy now!</span>
<a href="#l62.75"></a><span id="l62.75" class="difflineplus">+}</span>
<a href="#l62.76"></a><span id="l62.76" class="difflineplus">+</span>
<a href="#l62.77"></a><span id="l62.77" class="difflineplus">+/**</span>
<a href="#l62.78"></a><span id="l62.78" class="difflineplus">+ * Create a folder indexing job for the given injection folder handle.  We</span>
<a href="#l62.79"></a><span id="l62.79" class="difflineplus">+ *</span>
<a href="#l62.80"></a><span id="l62.80" class="difflineplus">+ */</span>
<a href="#l62.81"></a><span id="l62.81" class="difflineplus">+function spin_folder_indexer(aFolderHandle) {</span>
<a href="#l62.82"></a><span id="l62.82" class="difflineplus">+  let msgFolder = get_real_injection_folder(aFolderHandle);</span>
<a href="#l62.83"></a><span id="l62.83" class="difflineplus">+</span>
<a href="#l62.84"></a><span id="l62.84" class="difflineplus">+  // cheat and use indexFolder to build the job for us</span>
<a href="#l62.85"></a><span id="l62.85" class="difflineplus">+  GlodaMsgIndexer.indexFolder(msgFolder);</span>
<a href="#l62.86"></a><span id="l62.86" class="difflineplus">+  // steal that job...</span>
<a href="#l62.87"></a><span id="l62.87" class="difflineplus">+  let job = GlodaIndexer._indexQueue.pop();</span>
<a href="#l62.88"></a><span id="l62.88" class="difflineplus">+  GlodaIndexer._indexingJobGoal--;</span>
<a href="#l62.89"></a><span id="l62.89" class="difflineplus">+</span>
<a href="#l62.90"></a><span id="l62.90" class="difflineplus">+  // create the worker</span>
<a href="#l62.91"></a><span id="l62.91" class="difflineplus">+  let worker = GlodaIndexer._worker_folderIndex(job);</span>
<a href="#l62.92"></a><span id="l62.92" class="difflineplus">+</span>
<a href="#l62.93"></a><span id="l62.93" class="difflineplus">+</span>
<a href="#l62.94"></a><span id="l62.94" class="difflineplus">+}</span>
<a href="#l62.95"></a><span id="l62.95" class="difflineplus">+</span>
<a href="#l62.96"></a><span id="l62.96" class="difflineplus">+/**</span>
<a href="#l62.97"></a><span id="l62.97" class="difflineplus">+ * Make sure our counting pass and our indexing passes gets it right.  We test</span>
<a href="#l62.98"></a><span id="l62.98" class="difflineplus">+ *  with 0,1,2 messages matching.</span>
<a href="#l62.99"></a><span id="l62.99" class="difflineplus">+ */</span>
<a href="#l62.100"></a><span id="l62.100" class="difflineplus">+function test_count_and_index_messages() {</span>
<a href="#l62.101"></a><span id="l62.101" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 3}]);</span>
<a href="#l62.102"></a><span id="l62.102" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l62.103"></a><span id="l62.103" class="difflineplus">+</span>
<a href="#l62.104"></a><span id="l62.104" class="difflineplus">+  let hdrs = msgSet.msgHdrs;</span>
<a href="#l62.105"></a><span id="l62.105" class="difflineplus">+</span>
<a href="#l62.106"></a><span id="l62.106" class="difflineplus">+  // - messages with no gloda-id need to get indexed!</span>
<a href="#l62.107"></a><span id="l62.107" class="difflineplus">+</span>
<a href="#l62.108"></a><span id="l62.108" class="difflineplus">+  // - messages with gloda-id's do not get indexed</span>
<a href="#l62.109"></a><span id="l62.109" class="difflineplus">+</span>
<a href="#l62.110"></a><span id="l62.110" class="difflineplus">+  // - dirty messages get indexed</span>
<a href="#l62.111"></a><span id="l62.111" class="difflineplus">+}</span>
<a href="#l62.112"></a><span id="l62.112" class="difflineplus">+</span>
<a href="#l62.113"></a><span id="l62.113" class="difflineplus">+/**</span>
<a href="#l62.114"></a><span id="l62.114" class="difflineplus">+ * Make sure we try and index the right messages.  This is basically the</span>
<a href="#l62.115"></a><span id="l62.115" class="difflineplus">+ */</span>
<a href="#l62.116"></a><span id="l62.116" class="difflineplus">+</span>
<a href="#l62.117"></a><span id="l62.117" class="difflineplus">+let tests = [</span>
<a href="#l62.118"></a><span id="l62.118" class="difflineplus">+  test_ignore_folders_we_should_not_index,</span>
<a href="#l62.119"></a><span id="l62.119" class="difflineplus">+  test_propagate_filthy_from_folder_to_messages,</span>
<a href="#l62.120"></a><span id="l62.120" class="difflineplus">+  test_count_and_index_messages,</span>
<a href="#l62.121"></a><span id="l62.121" class="difflineplus">+];</span>
<a href="#l62.122"></a><span id="l62.122" class="difflineplus">+</span>
<a href="#l62.123"></a><span id="l62.123" class="difflineplus">+function run_test() {</span>
<a href="#l62.124"></a><span id="l62.124" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l62.125"></a><span id="l62.125" class="difflineplus">+  // we do not want the event-driven indexer crimping our style</span>
<a href="#l62.126"></a><span id="l62.126" class="difflineplus">+  configure_gloda_indexing({event: false});</span>
<a href="#l62.127"></a><span id="l62.127" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l62.128"></a><span id="l62.128" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l63.1"></a><span id="l63.1">deleted file mode 100644</span>
<a href="#l63.2"></a><span id="l63.2" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_switched_to_offline_imap_messages_in_bulk.js</span>
<a href="#l63.3"></a><span id="l63.3" class="difflineplus">+++ /dev/null</span>
<a href="#l63.4"></a><span id="l63.4" class="difflineat">@@ -1,16 +0,0 @@</span>
<a href="#l63.5"></a><span id="l63.5" class="difflineminus">-/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l63.6"></a><span id="l63.6" class="difflineminus">-/**</span>
<a href="#l63.7"></a><span id="l63.7" class="difflineminus">- * Tests how well gloda indexes IMAP messages that aren't offline in bulk.</span>
<a href="#l63.8"></a><span id="l63.8" class="difflineminus">- */</span>
<a href="#l63.9"></a><span id="l63.9" class="difflineminus">-</span>
<a href="#l63.10"></a><span id="l63.10" class="difflineminus">-// The definitions are common, so just re-use those</span>
<a href="#l63.11"></a><span id="l63.11" class="difflineminus">-load(&quot;test_index_messages_in_bulk.js&quot;);</span>
<a href="#l63.12"></a><span id="l63.12" class="difflineminus">-</span>
<a href="#l63.13"></a><span id="l63.13" class="difflineminus">-var post_test_hook = function imap_post_test_hook() {</span>
<a href="#l63.14"></a><span id="l63.14" class="difflineminus">-  // We're not verifying anything</span>
<a href="#l63.15"></a><span id="l63.15" class="difflineminus">-  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages,</span>
<a href="#l63.16"></a><span id="l63.16" class="difflineminus">-                          null, next_test);</span>
<a href="#l63.17"></a><span id="l63.17" class="difflineminus">-};</span>
<a href="#l63.18"></a><span id="l63.18" class="difflineminus">-</span>
<a href="#l63.19"></a><span id="l63.19" class="difflineminus">-// Switch to the IMAP fake server</span>
<a href="#l63.20"></a><span id="l63.20" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l64.1"></a><span id="l64.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_intl.js</span>
<a href="#l64.2"></a><span id="l64.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_intl.js</span>
<a href="#l64.3"></a><span id="l64.3" class="difflineat">@@ -1,19 +1,52 @@</span>
<a href="#l64.4"></a><span id="l64.4" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l64.5"></a><span id="l64.5" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l64.6"></a><span id="l64.6" class="difflineplus">+ *</span>
<a href="#l64.7"></a><span id="l64.7" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l64.8"></a><span id="l64.8" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l64.9"></a><span id="l64.9" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l64.10"></a><span id="l64.10" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l64.11"></a><span id="l64.11" class="difflineplus">+ *</span>
<a href="#l64.12"></a><span id="l64.12" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l64.13"></a><span id="l64.13" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l64.14"></a><span id="l64.14" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l64.15"></a><span id="l64.15" class="difflineplus">+ * License.</span>
<a href="#l64.16"></a><span id="l64.16" class="difflineplus">+ *</span>
<a href="#l64.17"></a><span id="l64.17" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l64.18"></a><span id="l64.18" class="difflineplus">+ *</span>
<a href="#l64.19"></a><span id="l64.19" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l64.20"></a><span id="l64.20" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l64.21"></a><span id="l64.21" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l64.22"></a><span id="l64.22" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l64.23"></a><span id="l64.23" class="difflineplus">+ *</span>
<a href="#l64.24"></a><span id="l64.24" class="difflineplus">+ * Contributor(s):</span>
<a href="#l64.25"></a><span id="l64.25" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l64.26"></a><span id="l64.26" class="difflineplus">+ *</span>
<a href="#l64.27"></a><span id="l64.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l64.28"></a><span id="l64.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l64.29"></a><span id="l64.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l64.30"></a><span id="l64.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l64.31"></a><span id="l64.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l64.32"></a><span id="l64.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l64.33"></a><span id="l64.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l64.34"></a><span id="l64.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l64.35"></a><span id="l64.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l64.36"></a><span id="l64.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l64.37"></a><span id="l64.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l64.38"></a><span id="l64.38" class="difflineplus">+ *</span>
<a href="#l64.39"></a><span id="l64.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l64.40"></a><span id="l64.40" class="difflineplus">+</span>
<a href="#l64.41"></a><span id="l64.41"> /*</span>
<a href="#l64.42"></a><span id="l64.42">  * Test that i18n goes through das pipes acceptably.  Currently this means:</span>
<a href="#l64.43"></a><span id="l64.43">  * - Subject, Body, and Attachment names are properly indexed.</span>
<a href="#l64.44"></a><span id="l64.44">  */</span>
<a href="#l64.45"></a><span id="l64.45"> </span>
<a href="#l64.46"></a><span id="l64.46" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l64.47"></a><span id="l64.47"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l64.48"></a><span id="l64.48"> </span>
<a href="#l64.49"></a><span id="l64.49" class="difflineminus">-// Create a message generator</span>
<a href="#l64.50"></a><span id="l64.50" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l64.51"></a><span id="l64.51" class="difflineminus">-</span>
<a href="#l64.52"></a><span id="l64.52"> /* ===== Tests ===== */</span>
<a href="#l64.53"></a><span id="l64.53"> </span>
<a href="#l64.54"></a><span id="l64.54"> var intlPhrases = [</span>
<a href="#l64.55"></a><span id="l64.55">   {</span>
<a href="#l64.56"></a><span id="l64.56">     name: &quot;Vending Machine&quot;,</span>
<a href="#l64.57"></a><span id="l64.57">     actual: '\u81ea\u52d5\u552e\u8ca8\u6a5f',</span>
<a href="#l64.58"></a><span id="l64.58">     encodings: {</span>
<a href="#l64.59"></a><span id="l64.59">       'utf-8': ['=?utf-8?b?6Ieq5YuV5ZSu6LKo5qmf?=',</span>
<a href="#l64.60"></a><span id="l64.60" class="difflineat">@@ -37,31 +70,33 @@ var resultList = [];</span>
<a href="#l64.61"></a><span id="l64.61">  *  expected/actual value.</span>
<a href="#l64.62"></a><span id="l64.62">  */</span>
<a href="#l64.63"></a><span id="l64.63"> function test_index(aPhrase) {</span>
<a href="#l64.64"></a><span id="l64.64">   // create a synthetic message for each of the delightful encoding types</span>
<a href="#l64.65"></a><span id="l64.65">   let messages = [];</span>
<a href="#l64.66"></a><span id="l64.66">   for each (let [charset, encodings] in Iterator(aPhrase.encodings)) {</span>
<a href="#l64.67"></a><span id="l64.67">     let [quoted, bodyEncoded] = encodings;</span>
<a href="#l64.68"></a><span id="l64.68"> </span>
<a href="#l64.69"></a><span id="l64.69" class="difflineminus">-    let smsg = msgGen.makeMessage({</span>
<a href="#l64.70"></a><span id="l64.70" class="difflineplus">+    let smsg = gMessageGenerator.makeMessage({</span>
<a href="#l64.71"></a><span id="l64.71">       subject: quoted,</span>
<a href="#l64.72"></a><span id="l64.72">       body: {charset: charset, encoding: &quot;8bit&quot;, body: bodyEncoded},</span>
<a href="#l64.73"></a><span id="l64.73">       attachments: [</span>
<a href="#l64.74"></a><span id="l64.74">         {filename: quoted, body: &quot;gabba gabba hey&quot;},</span>
<a href="#l64.75"></a><span id="l64.75">       ],</span>
<a href="#l64.76"></a><span id="l64.76">       // save off the actual value for checking</span>
<a href="#l64.77"></a><span id="l64.77">       callerData: [charset, aPhrase.actual]</span>
<a href="#l64.78"></a><span id="l64.78">     });</span>
<a href="#l64.79"></a><span id="l64.79"> </span>
<a href="#l64.80"></a><span id="l64.80">     messages.push(smsg);</span>
<a href="#l64.81"></a><span id="l64.81">     resultList.push(smsg);</span>
<a href="#l64.82"></a><span id="l64.82">   }</span>
<a href="#l64.83"></a><span id="l64.83" class="difflineplus">+  let synSet = new SyntheticMessageSet(messages);</span>
<a href="#l64.84"></a><span id="l64.84" class="difflineplus">+  yield add_sets_to_folder(gInbox, [synSet]);</span>
<a href="#l64.85"></a><span id="l64.85"> </span>
<a href="#l64.86"></a><span id="l64.86" class="difflineminus">-  indexMessages(messages, verify_index, next_test);</span>
<a href="#l64.87"></a><span id="l64.87" class="difflineplus">+  yield wait_for_gloda_indexer(synSet, {verifier: verify_index});</span>
<a href="#l64.88"></a><span id="l64.88"> }</span>
<a href="#l64.89"></a><span id="l64.89"> </span>
<a href="#l64.90"></a><span id="l64.90"> /**</span>
<a href="#l64.91"></a><span id="l64.91">  * Does the per-message verification for test_index.  Knows what is right for</span>
<a href="#l64.92"></a><span id="l64.92">  *  each message because of the callerData attribute on the synthetic message.</span>
<a href="#l64.93"></a><span id="l64.93">  */</span>
<a href="#l64.94"></a><span id="l64.94"> function verify_index(smsg, gmsg) {</span>
<a href="#l64.95"></a><span id="l64.95">   let [charset, actual] = smsg.callerData;</span>
<a href="#l64.96"></a><span id="l64.96" class="difflineat">@@ -103,23 +138,26 @@ var intlSearchPhrases = [</span>
<a href="#l64.97"></a><span id="l64.97"> ];</span>
<a href="#l64.98"></a><span id="l64.98"> </span>
<a href="#l64.99"></a><span id="l64.99"> function test_intl_fulltextsearch(aPhrase)</span>
<a href="#l64.100"></a><span id="l64.100"> {</span>
<a href="#l64.101"></a><span id="l64.101">   var query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l64.102"></a><span id="l64.102">   /* CJK text is bi-gram */</span>
<a href="#l64.103"></a><span id="l64.103">   query.bodyMatches(aPhrase.name);</span>
<a href="#l64.104"></a><span id="l64.104">   queryExpect(query, aPhrase.match ? resultList : []);</span>
<a href="#l64.105"></a><span id="l64.105" class="difflineplus">+  return false; // queryExpect is async</span>
<a href="#l64.106"></a><span id="l64.106"> }</span>
<a href="#l64.107"></a><span id="l64.107"> </span>
<a href="#l64.108"></a><span id="l64.108"> </span>
<a href="#l64.109"></a><span id="l64.109"> /* ===== Driver ===== */</span>
<a href="#l64.110"></a><span id="l64.110"> </span>
<a href="#l64.111"></a><span id="l64.111"> var tests = [</span>
<a href="#l64.112"></a><span id="l64.112">   parameterizeTest(test_index, intlPhrases),</span>
<a href="#l64.113"></a><span id="l64.113">   parameterizeTest(test_intl_fulltextsearch, intlSearchPhrases),</span>
<a href="#l64.114"></a><span id="l64.114"> ];</span>
<a href="#l64.115"></a><span id="l64.115"> </span>
<a href="#l64.116"></a><span id="l64.116" class="difflineplus">+var gInbox;</span>
<a href="#l64.117"></a><span id="l64.117" class="difflineplus">+</span>
<a href="#l64.118"></a><span id="l64.118"> function run_test() {</span>
<a href="#l64.119"></a><span id="l64.119">   // use mbox injection because the fake server chokes sometimes right now</span>
<a href="#l64.120"></a><span id="l64.120" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l64.121"></a><span id="l64.121" class="difflineplus">+  gInbox = configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l64.122"></a><span id="l64.122">   glodaHelperRunTests(tests);</span>
<a href="#l64.123"></a><span id="l64.123"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l65.1"></a><span id="l65.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_mime_emitter.js</span>
<a href="#l65.2"></a><span id="l65.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_mime_emitter.js</span>
<a href="#l65.3"></a><span id="l65.3" class="difflineat">@@ -1,26 +1,59 @@</span>
<a href="#l65.4"></a><span id="l65.4" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l65.5"></a><span id="l65.5" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l65.6"></a><span id="l65.6" class="difflineplus">+ *</span>
<a href="#l65.7"></a><span id="l65.7" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l65.8"></a><span id="l65.8" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l65.9"></a><span id="l65.9" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l65.10"></a><span id="l65.10" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l65.11"></a><span id="l65.11" class="difflineplus">+ *</span>
<a href="#l65.12"></a><span id="l65.12" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l65.13"></a><span id="l65.13" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l65.14"></a><span id="l65.14" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l65.15"></a><span id="l65.15" class="difflineplus">+ * License.</span>
<a href="#l65.16"></a><span id="l65.16" class="difflineplus">+ *</span>
<a href="#l65.17"></a><span id="l65.17" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l65.18"></a><span id="l65.18" class="difflineplus">+ *</span>
<a href="#l65.19"></a><span id="l65.19" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l65.20"></a><span id="l65.20" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l65.21"></a><span id="l65.21" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l65.22"></a><span id="l65.22" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l65.23"></a><span id="l65.23" class="difflineplus">+ *</span>
<a href="#l65.24"></a><span id="l65.24" class="difflineplus">+ * Contributor(s):</span>
<a href="#l65.25"></a><span id="l65.25" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l65.26"></a><span id="l65.26" class="difflineplus">+ *</span>
<a href="#l65.27"></a><span id="l65.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l65.28"></a><span id="l65.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l65.29"></a><span id="l65.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l65.30"></a><span id="l65.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l65.31"></a><span id="l65.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l65.32"></a><span id="l65.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l65.33"></a><span id="l65.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l65.34"></a><span id="l65.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l65.35"></a><span id="l65.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l65.36"></a><span id="l65.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l65.37"></a><span id="l65.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l65.38"></a><span id="l65.38" class="difflineplus">+ *</span>
<a href="#l65.39"></a><span id="l65.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l65.40"></a><span id="l65.40" class="difflineplus">+</span>
<a href="#l65.41"></a><span id="l65.41"> /*</span>
<a href="#l65.42"></a><span id="l65.42">  * General testing of the JS Mime Emitter to make sure it doesn't choke on any</span>
<a href="#l65.43"></a><span id="l65.43">  *  scenarios.</span>
<a href="#l65.44"></a><span id="l65.44">  *</span>
<a href="#l65.45"></a><span id="l65.45">  * We do not test, but should consider testing:</span>
<a href="#l65.46"></a><span id="l65.46">  * - MimeEncryptedPKCS7, whatever that translates to.</span>
<a href="#l65.47"></a><span id="l65.47">  * - apple double</span>
<a href="#l65.48"></a><span id="l65.48">  * - sun attachment</span>
<a href="#l65.49"></a><span id="l65.49">  */</span>
<a href="#l65.50"></a><span id="l65.50"> </span>
<a href="#l65.51"></a><span id="l65.51" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l65.52"></a><span id="l65.52"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l65.53"></a><span id="l65.53"> </span>
<a href="#l65.54"></a><span id="l65.54"> Components.utils.import(&quot;resource://app/modules/gloda/mimemsg.js&quot;);</span>
<a href="#l65.55"></a><span id="l65.55"> </span>
<a href="#l65.56"></a><span id="l65.56" class="difflineminus">-// Create a message generator</span>
<a href="#l65.57"></a><span id="l65.57" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l65.58"></a><span id="l65.58" class="difflineminus">-</span>
<a href="#l65.59"></a><span id="l65.59"> var partText = new SyntheticPartLeaf(&quot;I am text! Woo!&quot;);</span>
<a href="#l65.60"></a><span id="l65.60"> var partHtml = new SyntheticPartLeaf(</span>
<a href="#l65.61"></a><span id="l65.61">   &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;I am HTML! Woo! &lt;/body&gt;&lt;/html&gt;&quot;,</span>
<a href="#l65.62"></a><span id="l65.62">   {</span>
<a href="#l65.63"></a><span id="l65.63">     contentType: &quot;text/html&quot;</span>
<a href="#l65.64"></a><span id="l65.64">   }</span>
<a href="#l65.65"></a><span id="l65.65"> );</span>
<a href="#l65.66"></a><span id="l65.66"> var partAlternative = new SyntheticPartMultiAlternative([partText, partHtml]);</span>
<a href="#l65.67"></a><span id="l65.67" class="difflineat">@@ -192,41 +225,26 @@ var messageInfos = [</span>
<a href="#l65.68"></a><span id="l65.68">   },</span>
<a href="#l65.69"></a><span id="l65.69">   // -- multipart/parallel (allegedly the same as mixed)</span>
<a href="#l65.70"></a><span id="l65.70">   {</span>
<a href="#l65.71"></a><span id="l65.71">     name: 'multipart/parallel',</span>
<a href="#l65.72"></a><span id="l65.72">     bodyPart: new SyntheticPartMultiParallel([partText, partTachImage]),</span>
<a href="#l65.73"></a><span id="l65.73">   }</span>
<a href="#l65.74"></a><span id="l65.74"> ];</span>
<a href="#l65.75"></a><span id="l65.75"> </span>
<a href="#l65.76"></a><span id="l65.76" class="difflineminus">-function setup_create_message(info) {</span>
<a href="#l65.77"></a><span id="l65.77" class="difflineminus">-  info._synMsg = msgGen.makeMessage(info);</span>
<a href="#l65.78"></a><span id="l65.78" class="difflineminus">-  next_test();</span>
<a href="#l65.79"></a><span id="l65.79" class="difflineminus">-}</span>
<a href="#l65.80"></a><span id="l65.80" class="difflineminus">-</span>
<a href="#l65.81"></a><span id="l65.81" class="difflineminus">-var emittyFolder;</span>
<a href="#l65.82"></a><span id="l65.82" class="difflineminus">-</span>
<a href="#l65.83"></a><span id="l65.83" class="difflineminus">-/**</span>
<a href="#l65.84"></a><span id="l65.84" class="difflineminus">- * Actually inject all the messages we created above.</span>
<a href="#l65.85"></a><span id="l65.85" class="difflineminus">- */</span>
<a href="#l65.86"></a><span id="l65.86" class="difflineminus">-function setup_inject_messages() {</span>
<a href="#l65.87"></a><span id="l65.87" class="difflineminus">-  let synMessages = [info._synMsg for each</span>
<a href="#l65.88"></a><span id="l65.88" class="difflineminus">-                      ([, info] in Iterator(messageInfos))];</span>
<a href="#l65.89"></a><span id="l65.89" class="difflineminus">-  writeMessagesToMbox(synMessages, gProfileDir,</span>
<a href="#l65.90"></a><span id="l65.90" class="difflineminus">-                      &quot;Mail&quot;, &quot;Local Folders&quot;, &quot;emitty&quot;);</span>
<a href="#l65.91"></a><span id="l65.91" class="difflineminus">-  emittyFolder = gLocalIncomingServer.rootMsgFolder.addSubfolder(&quot;emitty&quot;);</span>
<a href="#l65.92"></a><span id="l65.92" class="difflineminus">-  updateFolderAndNotify(emittyFolder, next_test);</span>
<a href="#l65.93"></a><span id="l65.93" class="difflineminus">-}</span>
<a href="#l65.94"></a><span id="l65.94"> </span>
<a href="#l65.95"></a><span id="l65.95"> function test_stream_message(info) {</span>
<a href="#l65.96"></a><span id="l65.96" class="difflineminus">-  let msgHdr =</span>
<a href="#l65.97"></a><span id="l65.97" class="difflineminus">-    emittyFolder.msgDatabase.getMsgHdrForMessageID(info._synMsg.messageId);</span>
<a href="#l65.98"></a><span id="l65.98" class="difflineplus">+  let synMsg = gMessageGenerator.makeMessage(info);</span>
<a href="#l65.99"></a><span id="l65.99" class="difflineplus">+  let synSet = new SyntheticMessageSet([synMsg]);</span>
<a href="#l65.100"></a><span id="l65.100" class="difflineplus">+  yield add_sets_to_folder(gInbox, [synSet]);</span>
<a href="#l65.101"></a><span id="l65.101" class="difflineplus">+</span>
<a href="#l65.102"></a><span id="l65.102" class="difflineplus">+  let msgHdr = synSet.getMsgHdr(0);</span>
<a href="#l65.103"></a><span id="l65.103"> </span>
<a href="#l65.104"></a><span id="l65.104">   MsgHdrToMimeMessage(msgHdr, null, function(aMsgHdr, aMimeMsg) {</span>
<a href="#l65.105"></a><span id="l65.105" class="difflineminus">-    verify_stream_message(info, info._synMsg, aMsgHdr, aMimeMsg);</span>
<a href="#l65.106"></a><span id="l65.106" class="difflineplus">+    verify_stream_message(info, synMsg, aMsgHdr, aMimeMsg);</span>
<a href="#l65.107"></a><span id="l65.107">   });</span>
<a href="#l65.108"></a><span id="l65.108"> }</span>
<a href="#l65.109"></a><span id="l65.109"> </span>
<a href="#l65.110"></a><span id="l65.110"> var deathToNewlineTypeThings = /[\r\n]+/g;</span>
<a href="#l65.111"></a><span id="l65.111"> </span>
<a href="#l65.112"></a><span id="l65.112"> function verify_body_part_equivalence(aSynBodyPart, aMimePart) {</span>
<a href="#l65.113"></a><span id="l65.113">   // the content-type devoid of parameters should match</span>
<a href="#l65.114"></a><span id="l65.114">   do_check_eq(aSynBodyPart._contentType, aMimePart.contentType);</span>
<a href="#l65.115"></a><span id="l65.115" class="difflineat">@@ -284,24 +302,26 @@ function verify_stream_message(aInfo, aS</span>
<a href="#l65.116"></a><span id="l65.116">     do_throw(ex);</span>
<a href="#l65.117"></a><span id="l65.117">   }</span>
<a href="#l65.118"></a><span id="l65.118"> </span>
<a href="#l65.119"></a><span id="l65.119">   dump(&quot;Everything is just fine.\n&quot;);</span>
<a href="#l65.120"></a><span id="l65.120">   dump(&quot;Synthetic looks like:\n  &quot; + aSynMsg.prettyString() +</span>
<a href="#l65.121"></a><span id="l65.121">        &quot;\n\n&quot;);</span>
<a href="#l65.122"></a><span id="l65.122">   dump(&quot;MIME looks like:\n  &quot; + aMimeMsg.prettyString(true, &quot;  &quot;) + &quot;\n\n&quot;);</span>
<a href="#l65.123"></a><span id="l65.123"> </span>
<a href="#l65.124"></a><span id="l65.124" class="difflineminus">-  next_test();</span>
<a href="#l65.125"></a><span id="l65.125" class="difflineplus">+  async_driver();</span>
<a href="#l65.126"></a><span id="l65.126"> }</span>
<a href="#l65.127"></a><span id="l65.127"> </span>
<a href="#l65.128"></a><span id="l65.128"> /* ===== Driver ===== */</span>
<a href="#l65.129"></a><span id="l65.129"> </span>
<a href="#l65.130"></a><span id="l65.130"> var tests = [</span>
<a href="#l65.131"></a><span id="l65.131" class="difflineminus">-  parameterizeTest(setup_create_message, messageInfos),</span>
<a href="#l65.132"></a><span id="l65.132" class="difflineminus">-  setup_inject_messages,</span>
<a href="#l65.133"></a><span id="l65.133">   parameterizeTest(test_stream_message, messageInfos),</span>
<a href="#l65.134"></a><span id="l65.134"> ];</span>
<a href="#l65.135"></a><span id="l65.135"> </span>
<a href="#l65.136"></a><span id="l65.136" class="difflineplus">+var gInbox;</span>
<a href="#l65.137"></a><span id="l65.137" class="difflineplus">+</span>
<a href="#l65.138"></a><span id="l65.138"> function run_test() {</span>
<a href="#l65.139"></a><span id="l65.139">   // use mbox injection because the fake server chokes sometimes right now</span>
<a href="#l65.140"></a><span id="l65.140" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l65.141"></a><span id="l65.141" class="difflineplus">+  gInbox = configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l65.142"></a><span id="l65.142" class="difflineplus">+  // we do not require gloda indexing of anything.</span>
<a href="#l65.143"></a><span id="l65.143" class="difflineplus">+  configure_gloda_indexing({event: false});</span>
<a href="#l65.144"></a><span id="l65.144">   glodaHelperRunTests(tests);</span>
<a href="#l65.145"></a><span id="l65.145"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l66.1"></a><span id="l66.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_noun_mimetype.js</span>
<a href="#l66.2"></a><span id="l66.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_noun_mimetype.js</span>
<a href="#l66.3"></a><span id="l66.3" class="difflineat">@@ -1,8 +1,45 @@</span>
<a href="#l66.4"></a><span id="l66.4" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l66.5"></a><span id="l66.5" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l66.6"></a><span id="l66.6" class="difflineplus">+ *</span>
<a href="#l66.7"></a><span id="l66.7" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l66.8"></a><span id="l66.8" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l66.9"></a><span id="l66.9" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l66.10"></a><span id="l66.10" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l66.11"></a><span id="l66.11" class="difflineplus">+ *</span>
<a href="#l66.12"></a><span id="l66.12" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l66.13"></a><span id="l66.13" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l66.14"></a><span id="l66.14" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l66.15"></a><span id="l66.15" class="difflineplus">+ * License.</span>
<a href="#l66.16"></a><span id="l66.16" class="difflineplus">+ *</span>
<a href="#l66.17"></a><span id="l66.17" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l66.18"></a><span id="l66.18" class="difflineplus">+ *</span>
<a href="#l66.19"></a><span id="l66.19" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l66.20"></a><span id="l66.20" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l66.21"></a><span id="l66.21" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l66.22"></a><span id="l66.22" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l66.23"></a><span id="l66.23" class="difflineplus">+ *</span>
<a href="#l66.24"></a><span id="l66.24" class="difflineplus">+ * Contributor(s):</span>
<a href="#l66.25"></a><span id="l66.25" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l66.26"></a><span id="l66.26" class="difflineplus">+ *</span>
<a href="#l66.27"></a><span id="l66.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l66.28"></a><span id="l66.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l66.29"></a><span id="l66.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l66.30"></a><span id="l66.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l66.31"></a><span id="l66.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l66.32"></a><span id="l66.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l66.33"></a><span id="l66.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l66.34"></a><span id="l66.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l66.35"></a><span id="l66.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l66.36"></a><span id="l66.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l66.37"></a><span id="l66.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l66.38"></a><span id="l66.38" class="difflineplus">+ *</span>
<a href="#l66.39"></a><span id="l66.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l66.40"></a><span id="l66.40" class="difflineplus">+</span>
<a href="#l66.41"></a><span id="l66.41"> /*</span>
<a href="#l66.42"></a><span id="l66.42">  * Test noun_mimetype.  Exists because I just changed its implementation and I'm</span>
<a href="#l66.43"></a><span id="l66.43">  * afraid I may have damaged it and it's hard to tell, so ironically a unit test</span>
<a href="#l66.44"></a><span id="l66.44">  * is the easiest solution.  (Don't you hate it when the right thing to do is</span>
<a href="#l66.45"></a><span id="l66.45">  * also the easy thing to do?)</span>
<a href="#l66.46"></a><span id="l66.46">  */</span>
<a href="#l66.47"></a><span id="l66.47"> </span>
<a href="#l66.48"></a><span id="l66.48"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l66.49"></a><span id="l66.49" class="difflineat">@@ -28,17 +65,17 @@ function new_pass() {</span>
<a href="#l66.50"></a><span id="l66.50">     MimeTypeNoun._highID = 0;</span>
<a href="#l66.51"></a><span id="l66.51">     MimeTypeNoun._init();</span>
<a href="#l66.52"></a><span id="l66.52">   }</span>
<a href="#l66.53"></a><span id="l66.53">   curPassResults = [];</span>
<a href="#l66.54"></a><span id="l66.54">   passResults.push(curPassResults);</span>
<a href="#l66.55"></a><span id="l66.55"> </span>
<a href="#l66.56"></a><span id="l66.56">   // the mime type does some async stuff... make sure we don't advance until</span>
<a href="#l66.57"></a><span id="l66.57">   //  it is done with said stuff.</span>
<a href="#l66.58"></a><span id="l66.58" class="difflineminus">-  notifyWhenDatastoreDone(next_test);</span>
<a href="#l66.59"></a><span id="l66.59" class="difflineplus">+  yield wait_for_gloda_db_flush();</span>
<a href="#l66.60"></a><span id="l66.60"> }</span>
<a href="#l66.61"></a><span id="l66.61"> </span>
<a href="#l66.62"></a><span id="l66.62"> function test_basics() {</span>
<a href="#l66.63"></a><span id="l66.63">   let python;</span>
<a href="#l66.64"></a><span id="l66.64">   // if this is not the first pass, check for python before other things to</span>
<a href="#l66.65"></a><span id="l66.65">   //  make sure we're not just relying on consistent logic rather than actual</span>
<a href="#l66.66"></a><span id="l66.66">   //  persistence</span>
<a href="#l66.67"></a><span id="l66.67">   if (passResults.length)</span>
<a href="#l66.68"></a><span id="l66.68" class="difflineat">@@ -74,36 +111,31 @@ function test_basics() {</span>
<a href="#l66.69"></a><span id="l66.69">   // same blocks</span>
<a href="#l66.70"></a><span id="l66.70">   do_check_eq(Math.floor(jpeg.id / BLOCK_SIZE),</span>
<a href="#l66.71"></a><span id="l66.71">               Math.floor(png.id / BLOCK_SIZE));</span>
<a href="#l66.72"></a><span id="l66.72">   do_check_eq(Math.floor(html.id / BLOCK_SIZE),</span>
<a href="#l66.73"></a><span id="l66.73">               Math.floor(plain.id / BLOCK_SIZE));</span>
<a href="#l66.74"></a><span id="l66.74">   // different blocks</span>
<a href="#l66.75"></a><span id="l66.75">   do_check_neq(Math.floor(jpeg.id / BLOCK_SIZE),</span>
<a href="#l66.76"></a><span id="l66.76">                Math.floor(html.id / BLOCK_SIZE));</span>
<a href="#l66.77"></a><span id="l66.77" class="difflineminus">-</span>
<a href="#l66.78"></a><span id="l66.78" class="difflineminus">-  next_test();</span>
<a href="#l66.79"></a><span id="l66.79"> }</span>
<a href="#l66.80"></a><span id="l66.80"> </span>
<a href="#l66.81"></a><span id="l66.81"> function test_parameters() {</span>
<a href="#l66.82"></a><span id="l66.82">   let plain = MimeTypeNoun.getMimeType(&quot;text/plain&quot;);</span>
<a href="#l66.83"></a><span id="l66.83">   do_check_eq(plain, MimeTypeNoun.getMimeType('text/plain; charset=&quot;UTF-8&quot;'));</span>
<a href="#l66.84"></a><span id="l66.84" class="difflineminus">-</span>
<a href="#l66.85"></a><span id="l66.85" class="difflineminus">-  next_test();</span>
<a href="#l66.86"></a><span id="l66.86"> }</span>
<a href="#l66.87"></a><span id="l66.87"> </span>
<a href="#l66.88"></a><span id="l66.88"> function verify_passes_are_the_same() {</span>
<a href="#l66.89"></a><span id="l66.89">   var firstPassResults = passResults[0];</span>
<a href="#l66.90"></a><span id="l66.90">   for (let iType = 0; iType &lt; curPassResults.length; iType++) {</span>
<a href="#l66.91"></a><span id="l66.91">     for (let iPass = 1; iPass &lt; passResults.length; iPass++) {</span>
<a href="#l66.92"></a><span id="l66.92">       do_check_eq(firstPassResults[iType].id,</span>
<a href="#l66.93"></a><span id="l66.93">                   passResults[iPass][iType].id);</span>
<a href="#l66.94"></a><span id="l66.94">     }</span>
<a href="#l66.95"></a><span id="l66.95">   }</span>
<a href="#l66.96"></a><span id="l66.96" class="difflineminus">-  next_test();</span>
<a href="#l66.97"></a><span id="l66.97"> }</span>
<a href="#l66.98"></a><span id="l66.98"> </span>
<a href="#l66.99"></a><span id="l66.99"> /* ===== Driver ===== */</span>
<a href="#l66.100"></a><span id="l66.100"> </span>
<a href="#l66.101"></a><span id="l66.101"> var tests = [</span>
<a href="#l66.102"></a><span id="l66.102">   // do two passes of test_basics making sure that persisted values really</span>
<a href="#l66.103"></a><span id="l66.103">   //  persist...</span>
<a href="#l66.104"></a><span id="l66.104">   new_pass,</span>
<a href="#l66.105"></a><span id="l66.105" class="difflineat">@@ -112,12 +144,10 @@ var tests = [</span>
<a href="#l66.106"></a><span id="l66.106">   test_basics,</span>
<a href="#l66.107"></a><span id="l66.107">   verify_passes_are_the_same,</span>
<a href="#l66.108"></a><span id="l66.108"> </span>
<a href="#l66.109"></a><span id="l66.109">   test_parameters,</span>
<a href="#l66.110"></a><span id="l66.110"> </span>
<a href="#l66.111"></a><span id="l66.111"> ];</span>
<a href="#l66.112"></a><span id="l66.112"> </span>
<a href="#l66.113"></a><span id="l66.113"> function run_test() {</span>
<a href="#l66.114"></a><span id="l66.114" class="difflineminus">-  // use mbox injection so we get multiple folders...</span>
<a href="#l66.115"></a><span id="l66.115" class="difflineminus">-  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l66.116"></a><span id="l66.116">   glodaHelperRunTests(tests);</span>
<a href="#l66.117"></a><span id="l66.117"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l67.1"></a><span id="l67.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l67.2"></a><span id="l67.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_core.js</span>
<a href="#l67.3"></a><span id="l67.3" class="difflineat">@@ -1,8 +1,45 @@</span>
<a href="#l67.4"></a><span id="l67.4" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l67.5"></a><span id="l67.5" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l67.6"></a><span id="l67.6" class="difflineplus">+ *</span>
<a href="#l67.7"></a><span id="l67.7" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l67.8"></a><span id="l67.8" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l67.9"></a><span id="l67.9" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l67.10"></a><span id="l67.10" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l67.11"></a><span id="l67.11" class="difflineplus">+ *</span>
<a href="#l67.12"></a><span id="l67.12" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l67.13"></a><span id="l67.13" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l67.14"></a><span id="l67.14" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l67.15"></a><span id="l67.15" class="difflineplus">+ * License.</span>
<a href="#l67.16"></a><span id="l67.16" class="difflineplus">+ *</span>
<a href="#l67.17"></a><span id="l67.17" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l67.18"></a><span id="l67.18" class="difflineplus">+ *</span>
<a href="#l67.19"></a><span id="l67.19" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l67.20"></a><span id="l67.20" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l67.21"></a><span id="l67.21" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l67.22"></a><span id="l67.22" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l67.23"></a><span id="l67.23" class="difflineplus">+ *</span>
<a href="#l67.24"></a><span id="l67.24" class="difflineplus">+ * Contributor(s):</span>
<a href="#l67.25"></a><span id="l67.25" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l67.26"></a><span id="l67.26" class="difflineplus">+ *</span>
<a href="#l67.27"></a><span id="l67.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l67.28"></a><span id="l67.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l67.29"></a><span id="l67.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l67.30"></a><span id="l67.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l67.31"></a><span id="l67.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l67.32"></a><span id="l67.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l67.33"></a><span id="l67.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l67.34"></a><span id="l67.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l67.35"></a><span id="l67.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l67.36"></a><span id="l67.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l67.37"></a><span id="l67.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l67.38"></a><span id="l67.38" class="difflineplus">+ *</span>
<a href="#l67.39"></a><span id="l67.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l67.40"></a><span id="l67.40" class="difflineplus">+</span>
<a href="#l67.41"></a><span id="l67.41"> /*</span>
<a href="#l67.42"></a><span id="l67.42">  * Test the mechanics our query functionality.  Tests in this file are intended</span>
<a href="#l67.43"></a><span id="l67.43">  *  to cover extreme boundary cases and things that are just unlikely to happen</span>
<a href="#l67.44"></a><span id="l67.44">  *  in reasonable message use-cases.  (Which is to say, it could be hard to</span>
<a href="#l67.45"></a><span id="l67.45">  *  formulate a set of synthetic messages that result in the situation we want</span>
<a href="#l67.46"></a><span id="l67.46">  *  to test for.)</span>
<a href="#l67.47"></a><span id="l67.47">  */</span>
<a href="#l67.48"></a><span id="l67.48"> </span>
<a href="#l67.49"></a><span id="l67.49" class="difflineat">@@ -157,18 +194,16 @@ function setup_test_noun_and_attributes(</span>
<a href="#l67.50"></a><span id="l67.50">   Gloda.defineAttribute({</span>
<a href="#l67.51"></a><span id="l67.51">     provider: WidgetProvider, extensionName: EXT_NAME,</span>
<a href="#l67.52"></a><span id="l67.52">     attributeType: Gloda.kAttrFundamental,</span>
<a href="#l67.53"></a><span id="l67.53">     attributeName: &quot;multiIntAttr&quot;,</span>
<a href="#l67.54"></a><span id="l67.54">     singular: false,</span>
<a href="#l67.55"></a><span id="l67.55">     subjectNouns: [WidgetNoun.id],</span>
<a href="#l67.56"></a><span id="l67.56">     objectNoun: Gloda.NOUN_NUMBER</span>
<a href="#l67.57"></a><span id="l67.57">   });</span>
<a href="#l67.58"></a><span id="l67.58" class="difflineminus">-</span>
<a href="#l67.59"></a><span id="l67.59" class="difflineminus">-  next_test();</span>
<a href="#l67.60"></a><span id="l67.60"> }</span>
<a href="#l67.61"></a><span id="l67.61"> </span>
<a href="#l67.62"></a><span id="l67.62"> /* ===== Tests ===== */</span>
<a href="#l67.63"></a><span id="l67.63"> </span>
<a href="#l67.64"></a><span id="l67.64"> ALPHABET = &quot;abcdefghijklmnopqrstuvwxyz&quot;;</span>
<a href="#l67.65"></a><span id="l67.65"> function test_lots_of_string_constraints() {</span>
<a href="#l67.66"></a><span id="l67.66">   let stringConstraints = [];</span>
<a href="#l67.67"></a><span id="l67.67">   for (let i = 0; i &lt; 2049; i++) {</span>
<a href="#l67.68"></a><span id="l67.68" class="difflineat">@@ -182,16 +217,17 @@ function test_lots_of_string_constraints</span>
<a href="#l67.69"></a><span id="l67.69">                            // to quote it won't get quietly eaten.)</span>
<a href="#l67.70"></a><span id="l67.70">                            &quot;'&quot; + '&quot;');</span>
<a href="#l67.71"></a><span id="l67.71">   }</span>
<a href="#l67.72"></a><span id="l67.72"> </span>
<a href="#l67.73"></a><span id="l67.73">   let query = Gloda.newQuery(WidgetNoun.id);</span>
<a href="#l67.74"></a><span id="l67.74">   query.str.apply(query, stringConstraints);</span>
<a href="#l67.75"></a><span id="l67.75"> </span>
<a href="#l67.76"></a><span id="l67.76">   queryExpect(query, []);</span>
<a href="#l67.77"></a><span id="l67.77" class="difflineplus">+  return false; // queryExpect is async</span>
<a href="#l67.78"></a><span id="l67.78"> }</span>
<a href="#l67.79"></a><span id="l67.79"> </span>
<a href="#l67.80"></a><span id="l67.80"> /* === Query === */</span>
<a href="#l67.81"></a><span id="l67.81"> </span>
<a href="#l67.82"></a><span id="l67.82"> /**</span>
<a href="#l67.83"></a><span id="l67.83">  * Use a counter so that each test can have its own unique value for intCol so</span>
<a href="#l67.84"></a><span id="l67.84">  *  that it can use that as a constraint.  Otherwise we would need to purge</span>
<a href="#l67.85"></a><span id="l67.85">  *  between every test.  That's not an unreasonable alternative, but this works.</span>
<a href="#l67.86"></a><span id="l67.86" class="difflineat">@@ -219,24 +255,26 @@ function setup_non_singular_values() {</span>
<a href="#l67.87"></a><span id="l67.87">     new Widget(testUnique, origin, &quot;s1&quot;, 0, &quot;&quot;, &quot;&quot;),</span>
<a href="#l67.88"></a><span id="l67.88">     new Widget(testUnique, origin, &quot;s2&quot;, 0, &quot;&quot;, &quot;&quot;),</span>
<a href="#l67.89"></a><span id="l67.89">   ];</span>
<a href="#l67.90"></a><span id="l67.90">   nonSingularWidgets[0].multiIntAttr = [1, 2];</span>
<a href="#l67.91"></a><span id="l67.91">   nonSingularWidgets[1].multiIntAttr = [3];</span>
<a href="#l67.92"></a><span id="l67.92">   singularWidgets[0].multiIntAttr = [];</span>
<a href="#l67.93"></a><span id="l67.93">   // and don't bother setting it on singularWidgets[1]</span>
<a href="#l67.94"></a><span id="l67.94"> </span>
<a href="#l67.95"></a><span id="l67.95" class="difflineminus">-  GenericIndexer.indexNewObjects(nonSingularWidgets.concat(singularWidgets));</span>
<a href="#l67.96"></a><span id="l67.96" class="difflineplus">+  yield GenericIndexer.indexNewObjects(</span>
<a href="#l67.97"></a><span id="l67.97" class="difflineplus">+    nonSingularWidgets.concat(singularWidgets));</span>
<a href="#l67.98"></a><span id="l67.98"> }</span>
<a href="#l67.99"></a><span id="l67.99"> </span>
<a href="#l67.100"></a><span id="l67.100"> function test_query_has_value_for_non_singular() {</span>
<a href="#l67.101"></a><span id="l67.101">   let query = Gloda.newQuery(WidgetNoun.id);</span>
<a href="#l67.102"></a><span id="l67.102">   query.inum(testUnique);</span>
<a href="#l67.103"></a><span id="l67.103">   query.multiIntAttr();</span>
<a href="#l67.104"></a><span id="l67.104">   queryExpect(query, nonSingularWidgets);</span>
<a href="#l67.105"></a><span id="l67.105" class="difflineplus">+  return false;</span>
<a href="#l67.106"></a><span id="l67.106"> }</span>
<a href="#l67.107"></a><span id="l67.107"> </span>
<a href="#l67.108"></a><span id="l67.108"> /* === Search === */</span>
<a href="#l67.109"></a><span id="l67.109"> /*</span>
<a href="#l67.110"></a><span id="l67.110">  * The conceit of our search is that more recent messages are better than older</span>
<a href="#l67.111"></a><span id="l67.111">  *  messages.  But at the same time, we care about some messages more than</span>
<a href="#l67.112"></a><span id="l67.112">  *  others (in general), and we care about messages that match search terms</span>
<a href="#l67.113"></a><span id="l67.113">  *  more strongly too.  So we introduce a general 'score' heuristic which we</span>
<a href="#l67.114"></a><span id="l67.114" class="difflineat">@@ -292,17 +330,17 @@ function setup_search_ranking_idiom() {</span>
<a href="#l67.115"></a><span id="l67.115">     new Widget(5, origin, &quot;&quot;, 1, &quot;&quot;, &quot;bar&quot;), // 2 + 0</span>
<a href="#l67.116"></a><span id="l67.116">     new Widget(4, daymore, &quot;&quot;, 0, &quot;bar&quot;, &quot;bar&quot;), // 2 + 0+</span>
<a href="#l67.117"></a><span id="l67.117">     new Widget(3, origin, &quot;&quot;, 1, &quot;bar&quot;, &quot;baz&quot;), // 3 + 0</span>
<a href="#l67.118"></a><span id="l67.118">     new Widget(2, monthmore, &quot;&quot;, 0, &quot;&quot;, &quot;bar&quot;), // 1 + 4</span>
<a href="#l67.119"></a><span id="l67.119">     new Widget(1, origin, &quot;&quot;, 0, &quot;bar baz&quot;, &quot;bar baz bar bar&quot;), // 6 + 0</span>
<a href="#l67.120"></a><span id="l67.120">     new Widget(0, origin, &quot;&quot;, 1, &quot;bar baz&quot;, &quot;bar baz bar bar&quot;) // 7 + 0</span>
<a href="#l67.121"></a><span id="l67.121">   ];</span>
<a href="#l67.122"></a><span id="l67.122"> </span>
<a href="#l67.123"></a><span id="l67.123" class="difflineminus">-  GenericIndexer.indexNewObjects(fooWidgets.concat(barBazWidgets));</span>
<a href="#l67.124"></a><span id="l67.124" class="difflineplus">+  yield GenericIndexer.indexNewObjects(fooWidgets.concat(barBazWidgets));</span>
<a href="#l67.125"></a><span id="l67.125"> }</span>
<a href="#l67.126"></a><span id="l67.126"> </span>
<a href="#l67.127"></a><span id="l67.127"> // add one because the last snippet shouldn't have a trailing space</span>
<a href="#l67.128"></a><span id="l67.128"> const OFFSET_SCORE_SQL_SNIPPET =</span>
<a href="#l67.129"></a><span id="l67.129">   &quot;(((length(osets) + 1) / &quot; + OFFSET_CHARS_PER_FULLTEXT_MATCH + &quot;) * &quot; +</span>
<a href="#l67.130"></a><span id="l67.130">   SCORE_FOR_FULLTEXT_MATCH + &quot;)&quot;;</span>
<a href="#l67.131"></a><span id="l67.131"> </span>
<a href="#l67.132"></a><span id="l67.132"> const SCORE_SQL_SNIPPET =</span>
<a href="#l67.133"></a><span id="l67.133" class="difflineat">@@ -337,32 +375,36 @@ function test_search_ranking_idiom_offse</span>
<a href="#l67.134"></a><span id="l67.134">     // osets becomes 0-based column number 7</span>
<a href="#l67.135"></a><span id="l67.135">     // dascore becomes 0-based column number 8</span>
<a href="#l67.136"></a><span id="l67.136">     outerWrapColumns: [DASCORE_SQL_SNIPPET + &quot; AS dascore&quot;],</span>
<a href="#l67.137"></a><span id="l67.137">     // save our extra columns for analysis and debugging</span>
<a href="#l67.138"></a><span id="l67.138">     stashColumns: [7, 8]</span>
<a href="#l67.139"></a><span id="l67.139">   });</span>
<a href="#l67.140"></a><span id="l67.140">   query.fulltextAll(&quot;foo&quot;);</span>
<a href="#l67.141"></a><span id="l67.141">   query.orderBy('-dascore');</span>
<a href="#l67.142"></a><span id="l67.142" class="difflineminus">-  queryExpect(query, fooWidgets, null, null, verify_widget_order_and_stashing);</span>
<a href="#l67.143"></a><span id="l67.143" class="difflineplus">+  queryExpect(query, fooWidgets, null, null,</span>
<a href="#l67.144"></a><span id="l67.144" class="difflineplus">+              verify_widget_order_and_stashing);</span>
<a href="#l67.145"></a><span id="l67.145" class="difflineplus">+  return false; // queryExpect is async</span>
<a href="#l67.146"></a><span id="l67.146"> }</span>
<a href="#l67.147"></a><span id="l67.147"> </span>
<a href="#l67.148"></a><span id="l67.148"> function test_search_ranking_idiom_score() {</span>
<a href="#l67.149"></a><span id="l67.149">   let query = Gloda.newQuery(WidgetNoun.id, {</span>
<a href="#l67.150"></a><span id="l67.150">     explicitSQL: WIDGET_FULLTEXT_QUERY_EXPLICIT_SQL,</span>
<a href="#l67.151"></a><span id="l67.151">     // osets becomes 0-based column number 7</span>
<a href="#l67.152"></a><span id="l67.152">     // dascore becomes 0-based column number 8</span>
<a href="#l67.153"></a><span id="l67.153">     outerWrapColumns: [DASCORE_SQL_SNIPPET + &quot; AS dascore&quot;,</span>
<a href="#l67.154"></a><span id="l67.154">                        SCORE_SQL_SNIPPET + &quot; AS dabore&quot;, &quot;dateCol&quot;],</span>
<a href="#l67.155"></a><span id="l67.155">     // save our extra columns for analysis and debugging</span>
<a href="#l67.156"></a><span id="l67.156">     stashColumns: [7, 8, 9, 10]</span>
<a href="#l67.157"></a><span id="l67.157">   });</span>
<a href="#l67.158"></a><span id="l67.158">   query.fulltextAll(&quot;bar OR baz&quot;);</span>
<a href="#l67.159"></a><span id="l67.159">   query.orderBy('-dascore');</span>
<a href="#l67.160"></a><span id="l67.160" class="difflineminus">-  queryExpect(query, barBazWidgets, null, null, verify_widget_order_and_stashing);</span>
<a href="#l67.161"></a><span id="l67.161" class="difflineplus">+  queryExpect(query, barBazWidgets, null, null,</span>
<a href="#l67.162"></a><span id="l67.162" class="difflineplus">+              verify_widget_order_and_stashing);</span>
<a href="#l67.163"></a><span id="l67.163" class="difflineplus">+  return false; // queryExpect is async</span>
<a href="#l67.164"></a><span id="l67.164"> }</span>
<a href="#l67.165"></a><span id="l67.165"> </span>
<a href="#l67.166"></a><span id="l67.166"> </span>
<a href="#l67.167"></a><span id="l67.167"> /* ===== Driver ===== */</span>
<a href="#l67.168"></a><span id="l67.168"> </span>
<a href="#l67.169"></a><span id="l67.169"> var tests = [</span>
<a href="#l67.170"></a><span id="l67.170">   setup_test_noun_and_attributes,</span>
<a href="#l67.171"></a><span id="l67.171">   test_lots_of_string_constraints,</span>
<a href="#l67.172"></a><span id="l67.172" class="difflineat">@@ -370,10 +412,10 @@ var tests = [</span>
<a href="#l67.173"></a><span id="l67.173">   test_query_has_value_for_non_singular,</span>
<a href="#l67.174"></a><span id="l67.174">   setup_search_ranking_idiom,</span>
<a href="#l67.175"></a><span id="l67.175">   test_search_ranking_idiom_offsets,</span>
<a href="#l67.176"></a><span id="l67.176">   test_search_ranking_idiom_score,</span>
<a href="#l67.177"></a><span id="l67.177"> ];</span>
<a href="#l67.178"></a><span id="l67.178"> </span>
<a href="#l67.179"></a><span id="l67.179"> function run_test() {</span>
<a href="#l67.180"></a><span id="l67.180">   // Don't initialize the index message state</span>
<a href="#l67.181"></a><span id="l67.181" class="difflineminus">-  glodaHelperRunTests(tests, null, true);</span>
<a href="#l67.182"></a><span id="l67.182" class="difflineplus">+  glodaHelperRunTests(tests, &quot;widget&quot;);</span>
<a href="#l67.183"></a><span id="l67.183"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l68.1"></a><span id="l68.1">rename from mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js</span>
<a href="#l68.2"></a><span id="l68.2">rename to mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js</span>
<a href="#l68.3"></a><span id="l68.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_originally_offline_imap_messages.js</span>
<a href="#l68.4"></a><span id="l68.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_messages_imap_offline.js</span>
<a href="#l68.5"></a><span id="l68.5" class="difflineat">@@ -1,16 +1,11 @@</span>
<a href="#l68.6"></a><span id="l68.6"> /* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l68.7"></a><span id="l68.7"> /**</span>
<a href="#l68.8"></a><span id="l68.8">  * Test query support for IMAP messages that were offline before they were</span>
<a href="#l68.9"></a><span id="l68.9">  * indexed.</span>
<a href="#l68.10"></a><span id="l68.10">  */</span>
<a href="#l68.11"></a><span id="l68.11" class="difflineminus">-load(&quot;test_query_messages.js&quot;);</span>
<a href="#l68.12"></a><span id="l68.12" class="difflineplus">+load(&quot;base_query_messages.js&quot;);</span>
<a href="#l68.13"></a><span id="l68.13"> </span>
<a href="#l68.14"></a><span id="l68.14" class="difflineminus">-// Set the inbox to offline before proceeding</span>
<a href="#l68.15"></a><span id="l68.15" class="difflineminus">-var pre_setup_populate_hook = function imap_pre_setup_populate_hook() {</span>
<a href="#l68.16"></a><span id="l68.16" class="difflineminus">-  indexMessageState.imapInbox.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l68.17"></a><span id="l68.17" class="difflineminus">-  next_test();</span>
<a href="#l68.18"></a><span id="l68.18" class="difflineminus">-};</span>
<a href="#l68.19"></a><span id="l68.19" class="difflineminus">-</span>
<a href="#l68.20"></a><span id="l68.20" class="difflineminus">-// TODO: Make this use multiple folders, like the local folders test</span>
<a href="#l68.21"></a><span id="l68.21" class="difflineminus">-var singleFolder = true;</span>
<a href="#l68.22"></a><span id="l68.22" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span>
<a href="#l68.23"></a><span id="l68.23" class="difflineplus">+function run_test() {</span>
<a href="#l68.24"></a><span id="l68.24" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: true});</span>
<a href="#l68.25"></a><span id="l68.25" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l68.26"></a><span id="l68.26" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l69.1"></a><span id="l69.1">rename from mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js</span>
<a href="#l69.2"></a><span id="l69.2">rename to mailnews/db/gloda/test/unit/test_query_messages_imap_online.js</span>
<a href="#l69.3"></a><span id="l69.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_non_offline_imap_messages.js</span>
<a href="#l69.4"></a><span id="l69.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_messages_imap_online.js</span>
<a href="#l69.5"></a><span id="l69.5" class="difflineat">@@ -1,10 +1,12 @@</span>
<a href="#l69.6"></a><span id="l69.6"> /* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l69.7"></a><span id="l69.7"> /**</span>
<a href="#l69.8"></a><span id="l69.8">  * Test query support for IMAP messages that aren't offline.</span>
<a href="#l69.9"></a><span id="l69.9">  */</span>
<a href="#l69.10"></a><span id="l69.10" class="difflineminus">-load(&quot;test_query_messages.js&quot;);</span>
<a href="#l69.11"></a><span id="l69.11" class="difflineplus">+load(&quot;base_query_messages.js&quot;);</span>
<a href="#l69.12"></a><span id="l69.12" class="difflineplus">+</span>
<a href="#l69.13"></a><span id="l69.13" class="difflineplus">+expectFulltextResults = false;</span>
<a href="#l69.14"></a><span id="l69.14"> </span>
<a href="#l69.15"></a><span id="l69.15" class="difflineminus">-var expectFulltextResults = false;</span>
<a href="#l69.16"></a><span id="l69.16" class="difflineminus">-// TODO: Make this use multiple folders, like the local folders test</span>
<a href="#l69.17"></a><span id="l69.17" class="difflineminus">-var singleFolder = true;</span>
<a href="#l69.18"></a><span id="l69.18" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span>
<a href="#l69.19"></a><span id="l69.19" class="difflineplus">+function run_test() {</span>
<a href="#l69.20"></a><span id="l69.20" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: false});</span>
<a href="#l69.21"></a><span id="l69.21" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l69.22"></a><span id="l69.22" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l70.1"></a><span id="l70.1">rename from mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js</span>
<a href="#l70.2"></a><span id="l70.2">rename to mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js</span>
<a href="#l70.3"></a><span id="l70.3" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_query_switched_to_offline_imap_messages.js</span>
<a href="#l70.4"></a><span id="l70.4" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_messages_imap_online_to_offline.js</span>
<a href="#l70.5"></a><span id="l70.5" class="difflineat">@@ -1,19 +1,15 @@</span>
<a href="#l70.6"></a><span id="l70.6"> /* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l70.7"></a><span id="l70.7"> /**</span>
<a href="#l70.8"></a><span id="l70.8">  * Test query support for IMAP messages that were indexed, then made available</span>
<a href="#l70.9"></a><span id="l70.9">  * offline.</span>
<a href="#l70.10"></a><span id="l70.10">  */</span>
<a href="#l70.11"></a><span id="l70.11" class="difflineminus">-load(&quot;test_query_messages.js&quot;);</span>
<a href="#l70.12"></a><span id="l70.12" class="difflineplus">+load(&quot;base_query_messages.js&quot;);</span>
<a href="#l70.13"></a><span id="l70.13" class="difflineplus">+</span>
<a href="#l70.14"></a><span id="l70.14" class="difflineplus">+// we want to go offline once the messages have already been indexed online</span>
<a href="#l70.15"></a><span id="l70.15" class="difflineplus">+goOffline = true;</span>
<a href="#l70.16"></a><span id="l70.16"> </span>
<a href="#l70.17"></a><span id="l70.17" class="difflineminus">-/**</span>
<a href="#l70.18"></a><span id="l70.18" class="difflineminus">- * Set the imap folder to offline after adding the messages, then force a</span>
<a href="#l70.19"></a><span id="l70.19" class="difflineminus">- * download of all messages.</span>
<a href="#l70.20"></a><span id="l70.20" class="difflineminus">- */</span>
<a href="#l70.21"></a><span id="l70.21" class="difflineminus">-var post_setup_populate_hook = function imap_post_setup_populate_hook() {</span>
<a href="#l70.22"></a><span id="l70.22" class="difflineminus">-  imapDownloadAllMessages(indexMessageState.imapInbox, gSynMessages, null,</span>
<a href="#l70.23"></a><span id="l70.23" class="difflineminus">-                          next_test);</span>
<a href="#l70.24"></a><span id="l70.24" class="difflineminus">-};</span>
<a href="#l70.25"></a><span id="l70.25" class="difflineminus">-</span>
<a href="#l70.26"></a><span id="l70.26" class="difflineminus">-// TODO: Make this use multiple folders, like the local folders test</span>
<a href="#l70.27"></a><span id="l70.27" class="difflineminus">-var singleFolder = true;</span>
<a href="#l70.28"></a><span id="l70.28" class="difflineminus">-injectMessagesUsing(INJECT_IMAP_FAKE_SERVER);</span>
<a href="#l70.29"></a><span id="l70.29" class="difflineplus">+function run_test() {</span>
<a href="#l70.30"></a><span id="l70.30" class="difflineplus">+  // start with the messages online</span>
<a href="#l70.31"></a><span id="l70.31" class="difflineplus">+  configure_message_injection({mode: &quot;imap&quot;, offline: false});</span>
<a href="#l70.32"></a><span id="l70.32" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l70.33"></a><span id="l70.33" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l71.1"></a><span id="l71.1">new file mode 100644</span>
<a href="#l71.2"></a><span id="l71.2" class="difflineminus">--- /dev/null</span>
<a href="#l71.3"></a><span id="l71.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_messages_local.js</span>
<a href="#l71.4"></a><span id="l71.4" class="difflineat">@@ -0,0 +1,10 @@</span>
<a href="#l71.5"></a><span id="l71.5" class="difflineplus">+/* -*- Mode: JavaScript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l71.6"></a><span id="l71.6" class="difflineplus">+/**</span>
<a href="#l71.7"></a><span id="l71.7" class="difflineplus">+ * Test query support for local messages.</span>
<a href="#l71.8"></a><span id="l71.8" class="difflineplus">+ */</span>
<a href="#l71.9"></a><span id="l71.9" class="difflineplus">+load(&quot;base_query_messages.js&quot;);</span>
<a href="#l71.10"></a><span id="l71.10" class="difflineplus">+</span>
<a href="#l71.11"></a><span id="l71.11" class="difflineplus">+function run_test() {</span>
<a href="#l71.12"></a><span id="l71.12" class="difflineplus">+  configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l71.13"></a><span id="l71.13" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l71.14"></a><span id="l71.14" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l72.1"></a><span id="l72.1">deleted file mode 100644</span>
<a href="#l72.2"></a><span id="l72.2" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_search_messages.js</span>
<a href="#l72.3"></a><span id="l72.3" class="difflineplus">+++ /dev/null</span>
<a href="#l72.4"></a><span id="l72.4" class="difflineat">@@ -1,90 +0,0 @@</span>
<a href="#l72.5"></a><span id="l72.5" class="difflineminus">-/*</span>
<a href="#l72.6"></a><span id="l72.6" class="difflineminus">- *</span>
<a href="#l72.7"></a><span id="l72.7" class="difflineminus">- */</span>
<a href="#l72.8"></a><span id="l72.8" class="difflineminus">-</span>
<a href="#l72.9"></a><span id="l72.9" class="difflineminus">-load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l72.10"></a><span id="l72.10" class="difflineminus">-load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l72.11"></a><span id="l72.11" class="difflineminus">-</span>
<a href="#l72.12"></a><span id="l72.12" class="difflineminus">-Components.utils.import(&quot;resource://app/modules/gloda/msg_search.js&quot;);</span>
<a href="#l72.13"></a><span id="l72.13" class="difflineminus">-</span>
<a href="#l72.14"></a><span id="l72.14" class="difflineminus">-// Create a message generator</span>
<a href="#l72.15"></a><span id="l72.15" class="difflineminus">-var msgGen = new MessageGenerator();</span>
<a href="#l72.16"></a><span id="l72.16" class="difflineminus">-// Create a message scenario generator using that message generator</span>
<a href="#l72.17"></a><span id="l72.17" class="difflineminus">-var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l72.18"></a><span id="l72.18" class="difflineminus">-</span>
<a href="#l72.19"></a><span id="l72.19" class="difflineminus">-var synthMessagesByCategory = {};</span>
<a href="#l72.20"></a><span id="l72.20" class="difflineminus">-</span>
<a href="#l72.21"></a><span id="l72.21" class="difflineminus">-var abFriends = null;</span>
<a href="#l72.22"></a><span id="l72.22" class="difflineminus">-</span>
<a href="#l72.23"></a><span id="l72.23" class="difflineminus">-function makeCatSynMsg(aCategories, aSynArgs) {</span>
<a href="#l72.24"></a><span id="l72.24" class="difflineminus">-</span>
<a href="#l72.25"></a><span id="l72.25" class="difflineminus">-}</span>
<a href="#l72.26"></a><span id="l72.26" class="difflineminus">-</span>
<a href="#l72.27"></a><span id="l72.27" class="difflineminus">-/**</span>
<a href="#l72.28"></a><span id="l72.28" class="difflineminus">- *</span>
<a href="#l72.29"></a><span id="l72.29" class="difflineminus">- *</span>
<a href="#l72.30"></a><span id="l72.30" class="difflineminus">- *</span>
<a href="#l72.31"></a><span id="l72.31" class="difflineminus">- * Base requirements:</span>
<a href="#l72.32"></a><span id="l72.32" class="difflineminus">- * - Messages distributed over multiple folders.</span>
<a href="#l72.33"></a><span id="l72.33" class="difflineminus">- * - All messages must match our base query of &quot;baz&quot;.</span>
<a href="#l72.34"></a><span id="l72.34" class="difflineminus">- *</span>
<a href="#l72.35"></a><span id="l72.35" class="difflineminus">- * Intended functionality corpus will be used to test:</span>
<a href="#l72.36"></a><span id="l72.36" class="difflineminus">- * - Subject as more important than body.</span>
<a href="#l72.37"></a><span id="l72.37" class="difflineminus">- * - Message attachment name as more important than body.</span>
<a href="#l72.38"></a><span id="l72.38" class="difflineminus">- * - Inclusion of all search terms not attributable to contacts is bonused.</span>
<a href="#l72.39"></a><span id="l72.39" class="difflineminus">- * - Involvement of self and contacts in the address book is tested.</span>
<a href="#l72.40"></a><span id="l72.40" class="difflineminus">- */</span>
<a href="#l72.41"></a><span id="l72.41" class="difflineminus">-function setup_search_messages() {</span>
<a href="#l72.42"></a><span id="l72.42" class="difflineminus">-  let meAddress = [Gloda.myContact.name, Gloda.myContact.identities[0].value];</span>
<a href="#l72.43"></a><span id="l72.43" class="difflineminus">-  let abFriend1 = msgGen.makeNameAndAddress();</span>
<a href="#l72.44"></a><span id="l72.44" class="difflineminus">-  let abFriend2 = msgGen.makeNameAndAddress();</span>
<a href="#l72.45"></a><span id="l72.45" class="difflineminus">-  abFriends = [abFriend1, abFriend2];</span>
<a href="#l72.46"></a><span id="l72.46" class="difflineminus">-</span>
<a href="#l72.47"></a><span id="l72.47" class="difflineminus">-  makeCatSynMsg([&quot;from:me&quot;, &quot;body&quot;],</span>
<a href="#l72.48"></a><span id="l72.48" class="difflineminus">-    {from: meAddress, subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l72.49"></a><span id="l72.49" class="difflineminus">-  makeCatSynMsg([&quot;from:friend&quot;, &quot;body&quot;],</span>
<a href="#l72.50"></a><span id="l72.50" class="difflineminus">-    {from: abFriend1, subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l72.51"></a><span id="l72.51" class="difflineminus">-  makeCatSynMsg([&quot;from:me&quot;, &quot;to:friend&quot;, &quot;body&quot;],</span>
<a href="#l72.52"></a><span id="l72.52" class="difflineminus">-    {from: meAddress, to: [abFriend1], subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l72.53"></a><span id="l72.53" class="difflineminus">-  makeCatSynMsg([&quot;from:friend&quot;, &quot;to:friend&quot;, &quot;body&quot;],</span>
<a href="#l72.54"></a><span id="l72.54" class="difflineminus">-    {from: abFriend1, to: [abFriend2], subject: &quot;blah&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l72.55"></a><span id="l72.55" class="difflineminus">-</span>
<a href="#l72.56"></a><span id="l72.56" class="difflineminus">-  makeCatSynMsg([&quot;subject&quot;],</span>
<a href="#l72.57"></a><span id="l72.57" class="difflineminus">-    {subject: &quot;baz&quot;, body: {body: &quot;blah&quot;}});</span>
<a href="#l72.58"></a><span id="l72.58" class="difflineminus">-  makeCatSynMsg([&quot;subject&quot;, &quot;body&quot;],</span>
<a href="#l72.59"></a><span id="l72.59" class="difflineminus">-    {subject: &quot;baz&quot;, body: {body: &quot;baz&quot;}});</span>
<a href="#l72.60"></a><span id="l72.60" class="difflineminus">-  makeCatSynMsg([&quot;attachment&quot;],</span>
<a href="#l72.61"></a><span id="l72.61" class="difflineminus">-    {subject: &quot;blah&quot;, body: {body: &quot;blah&quot;},</span>
<a href="#l72.62"></a><span id="l72.62" class="difflineminus">-     attachments: [{filename: &quot;baz.blah&quot;, body: &quot;blah&quot;}]});</span>
<a href="#l72.63"></a><span id="l72.63" class="difflineminus">-}</span>
<a href="#l72.64"></a><span id="l72.64" class="difflineminus">-</span>
<a href="#l72.65"></a><span id="l72.65" class="difflineminus">-var gSearcher;</span>
<a href="#l72.66"></a><span id="l72.66" class="difflineminus">-</span>
<a href="#l72.67"></a><span id="l72.67" class="difflineminus">-function run_search() {</span>
<a href="#l72.68"></a><span id="l72.68" class="difflineminus">-  gSearcher = new GlodaMsgSearcher();</span>
<a href="#l72.69"></a><span id="l72.69" class="difflineminus">-</span>
<a href="#l72.70"></a><span id="l72.70" class="difflineminus">-}</span>
<a href="#l72.71"></a><span id="l72.71" class="difflineminus">-</span>
<a href="#l72.72"></a><span id="l72.72" class="difflineminus">-/**</span>
<a href="#l72.73"></a><span id="l72.73" class="difflineminus">- * We have the following scoring heuristics for unfaceted search:</span>
<a href="#l72.74"></a><span id="l72.74" class="difflineminus">- * - Message Annotation Bonuses:</span>
<a href="#l72.75"></a><span id="l72.75" class="difflineminus">- *   - Starred Messages (Strong)</span>
<a href="#l72.76"></a><span id="l72.76" class="difflineminus">- *   - Tagged Messages (Weak; may be automated and represent boring things.)</span>
<a href="#l72.77"></a><span id="l72.77" class="difflineminus">- * - Message Interest Bonuses.  We don't track message interest yet.  Psych!</span>
<a href="#l72.78"></a><span id="l72.78" class="difflineminus">- * - Contact match bonus:</span>
<a href="#l72.79"></a><span id="l72.79" class="difflineminus">- *   - We found a limited set of cont</span>
<a href="#l72.80"></a><span id="l72.80" class="difflineminus">- *</span>
<a href="#l72.81"></a><span id="l72.81" class="difflineminus">- * Our general testing sequence is this:</span>
<a href="#l72.82"></a><span id="l72.82" class="difflineminus">- * - Create a bunch of messages and index them [setup_search_messages]</span>
<a href="#l72.83"></a><span id="l72.83" class="difflineminus">- * - Peform any desired mutations on those messages or the involved contacts</span>
<a href="#l72.84"></a><span id="l72.84" class="difflineminus">- *   (star/tag/etc.) [twiddle_search_messages]</span>
<a href="#l72.85"></a><span id="l72.85" class="difflineminus">- * - Issue our search query</span>
<a href="#l72.86"></a><span id="l72.86" class="difflineminus">- * - Re-score the results from the search query</span>
<a href="#l72.87"></a><span id="l72.87" class="difflineminus">- */</span>
<a href="#l72.88"></a><span id="l72.88" class="difflineminus">-function verify_unfaceted_heuristics() {</span>
<a href="#l72.89"></a><span id="l72.89" class="difflineminus">-</span>
<a href="#l72.90"></a><span id="l72.90" class="difflineminus">-}</span>
<a href="#l72.91"></a><span id="l72.91" class="difflineminus">-</span>
<a href="#l72.92"></a><span id="l72.92" class="difflineminus">-function run_test() {</span>
<a href="#l72.93"></a><span id="l72.93" class="difflineminus">-  </span>
<a href="#l72.94"></a><span id="l72.94" class="difflineminus">-}</span>
<a href="#l72.95"></a><span id="l72.95">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l73.1"></a><span id="l73.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l73.2"></a><span id="l73.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l73.3"></a><span id="l73.3" class="difflineat">@@ -5043,19 +5043,19 @@ nsImapMailFolder::OnStopRunningUrl(nsIUR</span>
<a href="#l73.4"></a><span id="l73.4">       }</span>
<a href="#l73.5"></a><span id="l73.5"> </span>
<a href="#l73.6"></a><span id="l73.6">       // Notify move, copy or delete (online operations)</span>
<a href="#l73.7"></a><span id="l73.7">       // Not sure whether nsImapDeleteMsg is even used, deletes in all three models use nsImapAddMsgFlags.</span>
<a href="#l73.8"></a><span id="l73.8">       nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l73.9"></a><span id="l73.9">       if (notifier &amp;&amp; m_copyState)</span>
<a href="#l73.10"></a><span id="l73.10">       {</span>
<a href="#l73.11"></a><span id="l73.11">         if (imapAction == nsIImapUrl::nsImapOnlineMove)</span>
<a href="#l73.12"></a><span id="l73.12" class="difflineminus">-          notifier-&gt;NotifyMsgsMoveCopyCompleted(PR_TRUE, m_copyState-&gt;m_messages, this);</span>
<a href="#l73.13"></a><span id="l73.13" class="difflineplus">+          notifier-&gt;NotifyMsgsMoveCopyCompleted(PR_TRUE, m_copyState-&gt;m_messages, this, nsnull);</span>
<a href="#l73.14"></a><span id="l73.14">         else if (imapAction == nsIImapUrl::nsImapOnlineCopy)</span>
<a href="#l73.15"></a><span id="l73.15" class="difflineminus">-          notifier-&gt;NotifyMsgsMoveCopyCompleted(PR_FALSE, m_copyState-&gt;m_messages, this);</span>
<a href="#l73.16"></a><span id="l73.16" class="difflineplus">+          notifier-&gt;NotifyMsgsMoveCopyCompleted(PR_FALSE, m_copyState-&gt;m_messages, this, nsnull);</span>
<a href="#l73.17"></a><span id="l73.17">         else if (imapAction == nsIImapUrl::nsImapDeleteMsg)</span>
<a href="#l73.18"></a><span id="l73.18">           notifier-&gt;NotifyMsgsDeleted(m_copyState-&gt;m_messages);</span>
<a href="#l73.19"></a><span id="l73.19">       }</span>
<a href="#l73.20"></a><span id="l73.20"> </span>
<a href="#l73.21"></a><span id="l73.21">       switch(imapAction)</span>
<a href="#l73.22"></a><span id="l73.22">       {</span>
<a href="#l73.23"></a><span id="l73.23">       case nsIImapUrl::nsImapDeleteMsg:</span>
<a href="#l73.24"></a><span id="l73.24">       case nsIImapUrl::nsImapOnlineMove:</span>
<a href="#l73.25"></a><span id="l73.25" class="difflineat">@@ -6530,17 +6530,17 @@ nsImapMailFolder::CopyNextStreamMessage(</span>
<a href="#l73.26"></a><span id="l73.26">   {</span>
<a href="#l73.27"></a><span id="l73.27">     // Notify of move/copy completion in case we have some source headers</span>
<a href="#l73.28"></a><span id="l73.28">     nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l73.29"></a><span id="l73.29">     if (notifier)</span>
<a href="#l73.30"></a><span id="l73.30">     {</span>
<a href="#l73.31"></a><span id="l73.31">       PRUint32 numHdrs;</span>
<a href="#l73.32"></a><span id="l73.32">       mailCopyState-&gt;m_messages-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l73.33"></a><span id="l73.33">       if (numHdrs)</span>
<a href="#l73.34"></a><span id="l73.34" class="difflineminus">-        notifier-&gt;NotifyMsgsMoveCopyCompleted(mailCopyState-&gt;m_isMove, mailCopyState-&gt;m_messages, this);</span>
<a href="#l73.35"></a><span id="l73.35" class="difflineplus">+        notifier-&gt;NotifyMsgsMoveCopyCompleted(mailCopyState-&gt;m_isMove, mailCopyState-&gt;m_messages, this, nsnull);</span>
<a href="#l73.36"></a><span id="l73.36">     }</span>
<a href="#l73.37"></a><span id="l73.37"> </span>
<a href="#l73.38"></a><span id="l73.38"> </span>
<a href="#l73.39"></a><span id="l73.39">     if (mailCopyState-&gt;m_isMove)</span>
<a href="#l73.40"></a><span id="l73.40">     {</span>
<a href="#l73.41"></a><span id="l73.41">       nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder(do_QueryInterface(mailCopyState-&gt;m_srcSupport, &amp;rv));</span>
<a href="#l73.42"></a><span id="l73.42">       if (NS_SUCCEEDED(rv) &amp;&amp; srcFolder)</span>
<a href="#l73.43"></a><span id="l73.43">       {</span>
<a href="#l73.44"></a><span id="l73.44" class="difflineat">@@ -7062,17 +7062,17 @@ nsresult nsImapMailFolder::CopyMessagesO</span>
<a href="#l73.45"></a><span id="l73.45"> </span>
<a href="#l73.46"></a><span id="l73.46">   // Do this before delete, as it destroys the messages</span>
<a href="#l73.47"></a><span id="l73.47">   PRUint32 numHdrs;</span>
<a href="#l73.48"></a><span id="l73.48">   msgHdrsCopied-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l73.49"></a><span id="l73.49">   if (numHdrs)</span>
<a href="#l73.50"></a><span id="l73.50">   {</span>
<a href="#l73.51"></a><span id="l73.51">     nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l73.52"></a><span id="l73.52">     if (notifier)</span>
<a href="#l73.53"></a><span id="l73.53" class="difflineminus">-      notifier-&gt;NotifyMsgsMoveCopyCompleted(isMove, msgHdrsCopied, this);</span>
<a href="#l73.54"></a><span id="l73.54" class="difflineplus">+      notifier-&gt;NotifyMsgsMoveCopyCompleted(isMove, msgHdrsCopied, this, nsnull);</span>
<a href="#l73.55"></a><span id="l73.55">   }</span>
<a href="#l73.56"></a><span id="l73.56"> </span>
<a href="#l73.57"></a><span id="l73.57">   if (isMove &amp;&amp; (deleteToTrash || deleteImmediately))</span>
<a href="#l73.58"></a><span id="l73.58">     sourceMailDB-&gt;DeleteMessages(&amp;keysToDelete, nsnull);</span>
<a href="#l73.59"></a><span id="l73.59"> </span>
<a href="#l73.60"></a><span id="l73.60">   nsCOMPtr&lt;nsISupports&gt; srcSupport = do_QueryInterface(srcFolder);</span>
<a href="#l73.61"></a><span id="l73.61">   OnCopyCompleted(srcSupport, rv);</span>
<a href="#l73.62"></a><span id="l73.62"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l74.1"></a><span id="l74.1" class="difflineminus">--- a/mailnews/imap/test/unit/head_server.js</span>
<a href="#l74.2"></a><span id="l74.2" class="difflineplus">+++ b/mailnews/imap/test/unit/head_server.js</span>
<a href="#l74.3"></a><span id="l74.3" class="difflineat">@@ -5,17 +5,17 @@ load(&quot;../../mailnews/fakeserver/imapd.js</span>
<a href="#l74.4"></a><span id="l74.4"> // And mailnews scripts</span>
<a href="#l74.5"></a><span id="l74.5"> load(&quot;../../mailnews/resources/mailDirService.js&quot;);</span>
<a href="#l74.6"></a><span id="l74.6"> load(&quot;../../mailnews/resources/mailTestUtils.js&quot;);</span>
<a href="#l74.7"></a><span id="l74.7"> </span>
<a href="#l74.8"></a><span id="l74.8"> const IMAP_PORT = 1024 + 143;</span>
<a href="#l74.9"></a><span id="l74.9"> </span>
<a href="#l74.10"></a><span id="l74.10"> function makeServer(daemon, infoString) {</span>
<a href="#l74.11"></a><span id="l74.11">   if (infoString in configurations)</span>
<a href="#l74.12"></a><span id="l74.12" class="difflineminus">-    return makeHandler(daemon, configurations[infoString].join(&quot;,&quot;));</span>
<a href="#l74.13"></a><span id="l74.13" class="difflineplus">+    return makeServer(daemon, configurations[infoString].join(&quot;,&quot;));</span>
<a href="#l74.14"></a><span id="l74.14"> </span>
<a href="#l74.15"></a><span id="l74.15">   var handler = new IMAP_RFC3501_handler(daemon);</span>
<a href="#l74.16"></a><span id="l74.16">   if (!infoString)</span>
<a href="#l74.17"></a><span id="l74.17">     infoString = &quot;&quot;;</span>
<a href="#l74.18"></a><span id="l74.18"> </span>
<a href="#l74.19"></a><span id="l74.19">   var parts = infoString.split(/ *, */);</span>
<a href="#l74.20"></a><span id="l74.20">   for each (var part in parts) {</span>
<a href="#l74.21"></a><span id="l74.21">     if (part.substring(0, 3) == &quot;RFC&quot;)</span>
<a href="#l74.22"></a><span id="l74.22" class="difflineat">@@ -24,17 +24,17 @@ function makeServer(daemon, infoString) </span>
<a href="#l74.23"></a><span id="l74.23">   var server = new nsMailServer(handler);</span>
<a href="#l74.24"></a><span id="l74.24">   server.start(IMAP_PORT);</span>
<a href="#l74.25"></a><span id="l74.25">   return server;</span>
<a href="#l74.26"></a><span id="l74.26"> }</span>
<a href="#l74.27"></a><span id="l74.27"> </span>
<a href="#l74.28"></a><span id="l74.28"> function createLocalIMAPServer() {</span>
<a href="#l74.29"></a><span id="l74.29">   var acctmgr = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;]</span>
<a href="#l74.30"></a><span id="l74.30">                   .getService(Ci.nsIMsgAccountManager);</span>
<a href="#l74.31"></a><span id="l74.31" class="difflineminus">-  </span>
<a href="#l74.32"></a><span id="l74.32" class="difflineplus">+</span>
<a href="#l74.33"></a><span id="l74.33">   var server = acctmgr.createIncomingServer(&quot;user&quot;, &quot;localhost&quot;, &quot;imap&quot;);</span>
<a href="#l74.34"></a><span id="l74.34">   server.port = IMAP_PORT;</span>
<a href="#l74.35"></a><span id="l74.35">   server.username = &quot;user&quot;;</span>
<a href="#l74.36"></a><span id="l74.36">   server.password = &quot;password&quot;;</span>
<a href="#l74.37"></a><span id="l74.37">   server.valid = false;</span>
<a href="#l74.38"></a><span id="l74.38"> </span>
<a href="#l74.39"></a><span id="l74.39">   var account = acctmgr.createAccount();</span>
<a href="#l74.40"></a><span id="l74.40">   account.incomingServer = server;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l75.1"></a><span id="l75.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_autosync_date_constraints.js</span>
<a href="#l75.2"></a><span id="l75.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_autosync_date_constraints.js</span>
<a href="#l75.3"></a><span id="l75.3" class="difflineat">@@ -1,17 +1,16 @@</span>
<a href="#l75.4"></a><span id="l75.4"> /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l75.5"></a><span id="l75.5"> /*</span>
<a href="#l75.6"></a><span id="l75.6">  * Test autosync date constraints</span>
<a href="#l75.7"></a><span id="l75.7">  */</span>
<a href="#l75.8"></a><span id="l75.8"> </span>
<a href="#l75.9"></a><span id="l75.9"> var gIMAPDaemon, gServer, gIMAPIncomingServer;</span>
<a href="#l75.10"></a><span id="l75.10"> </span>
<a href="#l75.11"></a><span id="l75.11"> load(&quot;../../mailnews/resources/messageGenerator.js&quot;);</span>
<a href="#l75.12"></a><span id="l75.12" class="difflineminus">-load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l75.13"></a><span id="l75.13"> </span>
<a href="#l75.14"></a><span id="l75.14"> const gIMAPService = Cc[&quot;@mozilla.org/messenger/messageservice;1?type=imap&quot;]</span>
<a href="#l75.15"></a><span id="l75.15">                        .getService(Ci.nsIMsgMessageService);</span>
<a href="#l75.16"></a><span id="l75.16"> </span>
<a href="#l75.17"></a><span id="l75.17"> // Globals</span>
<a href="#l75.18"></a><span id="l75.18"> var gRootFolder;</span>
<a href="#l75.19"></a><span id="l75.19"> var gIMAPInbox, gIMAPTrashFolder, gMsgImapInboxFolder;</span>
<a href="#l75.20"></a><span id="l75.20"> var gIMAPDaemon, gServer, gIMAPIncomingServer;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l76.1"></a><span id="l76.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_imapPasswordFailure.js</span>
<a href="#l76.2"></a><span id="l76.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_imapPasswordFailure.js</span>
<a href="#l76.3"></a><span id="l76.3" class="difflineat">@@ -7,17 +7,16 @@</span>
<a href="#l76.4"></a><span id="l76.4">  *   - Check cancel does what it should do.</span>
<a href="#l76.5"></a><span id="l76.5">  *   - Re-initiate connection, this time select enter new password, check that</span>
<a href="#l76.6"></a><span id="l76.6">  *     we get a new password prompt and can enter the password.</span>
<a href="#l76.7"></a><span id="l76.7">  */</span>
<a href="#l76.8"></a><span id="l76.8"> </span>
<a href="#l76.9"></a><span id="l76.9"> Components.utils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l76.10"></a><span id="l76.10"> </span>
<a href="#l76.11"></a><span id="l76.11"> load(&quot;../../mailnews/resources/alertTestUtils.js&quot;);</span>
<a href="#l76.12"></a><span id="l76.12" class="difflineminus">-load(&quot;../../mailnews/resources/asyncTestUtils.js&quot;);</span>
<a href="#l76.13"></a><span id="l76.13"> </span>
<a href="#l76.14"></a><span id="l76.14"> const kUserName = &quot;user&quot;;</span>
<a href="#l76.15"></a><span id="l76.15"> const kInvalidPassword = &quot;imaptest&quot;;</span>
<a href="#l76.16"></a><span id="l76.16"> const kValidPassword = &quot;password&quot;;</span>
<a href="#l76.17"></a><span id="l76.17"> </span>
<a href="#l76.18"></a><span id="l76.18"> var dummyDocShell =</span>
<a href="#l76.19"></a><span id="l76.19"> {</span>
<a href="#l76.20"></a><span id="l76.20">   getInterface: function (iid) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l77.1"></a><span id="l77.1" class="difflineminus">--- a/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js</span>
<a href="#l77.2"></a><span id="l77.2" class="difflineplus">+++ b/mailnews/imap/test/unit/test_nsIMsgFolderListenerIMAP.js</span>
<a href="#l77.3"></a><span id="l77.3" class="difflineat">@@ -58,17 +58,18 @@ function copyFileMessage(file, messageId</span>
<a href="#l77.4"></a><span id="l77.4">   // the copy listener, without which it will *not* send the notification.</span>
<a href="#l77.5"></a><span id="l77.5"> </span>
<a href="#l77.6"></a><span id="l77.6">   // ...but wait, nsImapProtocol.cpp requires SEARCH afterwards to retrieve the</span>
<a href="#l77.7"></a><span id="l77.7">   // message header, and fakeserver doesn't implement it yet. So get it to fail</span>
<a href="#l77.8"></a><span id="l77.8">   // earlier by *not* sending the message id.</span>
<a href="#l77.9"></a><span id="l77.9">   // copyListener.mMessageId = messageId;</span>
<a href="#l77.10"></a><span id="l77.10"> </span>
<a href="#l77.11"></a><span id="l77.11">   // Instead store the message id in gExpectedEvents, so we can match that up</span>
<a href="#l77.12"></a><span id="l77.12" class="difflineminus">-  gExpectedEvents = [[gMFNService.msgAdded, {expectedMessageId: messageId}]];</span>
<a href="#l77.13"></a><span id="l77.13" class="difflineplus">+  gExpectedEvents = [[gMFNService.msgAdded, {expectedMessageId: messageId}],</span>
<a href="#l77.14"></a><span id="l77.14" class="difflineplus">+                     [gMFNService.msgsClassified, [messageId], false, false]];</span>
<a href="#l77.15"></a><span id="l77.15">   destFolder.updateFolder(null);</span>
<a href="#l77.16"></a><span id="l77.16">   gCopyService.CopyFileMessage(file, destFolder, null, true, 0, &quot;&quot;, copyListener, null);</span>
<a href="#l77.17"></a><span id="l77.17">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l77.18"></a><span id="l77.18">   gServer.performTest(&quot;APPEND&quot;);</span>
<a href="#l77.19"></a><span id="l77.19">   // Allow some time for the append operation to complete, so update folder</span>
<a href="#l77.20"></a><span id="l77.20">   // every second</span>
<a href="#l77.21"></a><span id="l77.21">   gFolderBeingUpdated = destFolder;</span>
<a href="#l77.22"></a><span id="l77.22">   doUpdateFolder(gTest);</span>
<a href="#l77.23"></a><span id="l77.23" class="difflineat">@@ -98,16 +99,19 @@ function addMessagesToServer(messages, m</span>
<a href="#l77.24"></a><span id="l77.24">   // For every message we have, we need to convert it to a file:/// URI</span>
<a href="#l77.25"></a><span id="l77.25">   messages.forEach(function (message)</span>
<a href="#l77.26"></a><span id="l77.26">   {</span>
<a href="#l77.27"></a><span id="l77.27">     let URI = ioService.newFileURI(message.file).QueryInterface(Ci.nsIFileURL);</span>
<a href="#l77.28"></a><span id="l77.28">     message.spec = URI.spec;</span>
<a href="#l77.29"></a><span id="l77.29">     // We can't get the headers again, so just pass on the message id</span>
<a href="#l77.30"></a><span id="l77.30">     gExpectedEvents.push([gMFNService.msgAdded, {expectedMessageId: message.messageId}]);</span>
<a href="#l77.31"></a><span id="l77.31">   });</span>
<a href="#l77.32"></a><span id="l77.32" class="difflineplus">+  gExpectedEvents.push([gMFNService.msgsClassified,</span>
<a href="#l77.33"></a><span id="l77.33" class="difflineplus">+                        [hdr.messageId for each (hdr in messages)],</span>
<a href="#l77.34"></a><span id="l77.34" class="difflineplus">+                        false, false]);</span>
<a href="#l77.35"></a><span id="l77.35"> </span>
<a href="#l77.36"></a><span id="l77.36">   // Create the imapMessages and store them on the mailbox</span>
<a href="#l77.37"></a><span id="l77.37">   messages.forEach(function (message)</span>
<a href="#l77.38"></a><span id="l77.38">   {</span>
<a href="#l77.39"></a><span id="l77.39">     mailbox.addMessage(new imapMessage(message.spec, mailbox.uidnext++, []));</span>
<a href="#l77.40"></a><span id="l77.40">   });</span>
<a href="#l77.41"></a><span id="l77.41"> </span>
<a href="#l77.42"></a><span id="l77.42">   // No copy listener notification for this</span>
<a href="#l77.43"></a><span id="l77.43" class="difflineat">@@ -126,18 +130,22 @@ function copyMessages(messages, isMove, </span>
<a href="#l77.44"></a><span id="l77.44">   });</span>
<a href="#l77.45"></a><span id="l77.45">   gExpectedEvents = [[gMFNService.msgsMoveCopyCompleted, isMove, messages, destFolder]];</span>
<a href="#l77.46"></a><span id="l77.46">   // We'll also get the msgAdded events when we go and update the destination</span>
<a href="#l77.47"></a><span id="l77.47">   // folder</span>
<a href="#l77.48"></a><span id="l77.48">   messages.forEach(function (message)</span>
<a href="#l77.49"></a><span id="l77.49">   {</span>
<a href="#l77.50"></a><span id="l77.50">     // We can't use the headers directly, because the notifications we'll</span>
<a href="#l77.51"></a><span id="l77.51">     // receive are for message headers in the destination folder</span>
<a href="#l77.52"></a><span id="l77.52" class="difflineminus">-    gExpectedEvents.push([gMFNService.msgAdded, {expectedMessageId: message.messageId}]);</span>
<a href="#l77.53"></a><span id="l77.53" class="difflineplus">+    gExpectedEvents.push([gMFNService.msgAdded,</span>
<a href="#l77.54"></a><span id="l77.54" class="difflineplus">+                          {expectedMessageId: message.messageId}]);</span>
<a href="#l77.55"></a><span id="l77.55">   });</span>
<a href="#l77.56"></a><span id="l77.56" class="difflineplus">+  gExpectedEvents.push([gMFNService.msgsClassified,</span>
<a href="#l77.57"></a><span id="l77.57" class="difflineplus">+                        [hdr.messageId for each (hdr in messages)],</span>
<a href="#l77.58"></a><span id="l77.58" class="difflineplus">+                        false, false]);</span>
<a href="#l77.59"></a><span id="l77.59">   gCopyService.CopyMessages(srcFolder, array, destFolder, isMove, copyListener, null, true);</span>
<a href="#l77.60"></a><span id="l77.60">   gCurrStatus |= kStatus.functionCallDone;</span>
<a href="#l77.61"></a><span id="l77.61"> </span>
<a href="#l77.62"></a><span id="l77.62">   gServer.performTest(&quot;COPY&quot;);</span>
<a href="#l77.63"></a><span id="l77.63"> </span>
<a href="#l77.64"></a><span id="l77.64">   gFolderBeingUpdated = destFolder;</span>
<a href="#l77.65"></a><span id="l77.65">   doUpdateFolder(gTest);</span>
<a href="#l77.66"></a><span id="l77.66">   if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l77.67"></a><span id="l77.67" class="difflineat">@@ -182,17 +190,17 @@ const gTestArray =</span>
<a href="#l77.68"></a><span id="l77.68"> ];</span>
<a href="#l77.69"></a><span id="l77.69"> </span>
<a href="#l77.70"></a><span id="l77.70"> function run_test()</span>
<a href="#l77.71"></a><span id="l77.71"> {</span>
<a href="#l77.72"></a><span id="l77.72">   // This is before any of the actual tests, so...</span>
<a href="#l77.73"></a><span id="l77.73">   gTest = 0;</span>
<a href="#l77.74"></a><span id="l77.74"> </span>
<a href="#l77.75"></a><span id="l77.75">   // Add a listener.</span>
<a href="#l77.76"></a><span id="l77.76" class="difflineminus">-  gMFNService.addListener(gMFListener, gMFNService.all);</span>
<a href="#l77.77"></a><span id="l77.77" class="difflineplus">+  gMFNService.addListener(gMFListener, allTestedEvents);</span>
<a href="#l77.78"></a><span id="l77.78">   gIMAPDaemon = new imapDaemon();</span>
<a href="#l77.79"></a><span id="l77.79">   gServer = makeServer(gIMAPDaemon, &quot;&quot;);</span>
<a href="#l77.80"></a><span id="l77.80"> </span>
<a href="#l77.81"></a><span id="l77.81">   gIMAPIncomingServer = createLocalIMAPServer();</span>
<a href="#l77.82"></a><span id="l77.82"> </span>
<a href="#l77.83"></a><span id="l77.83">   // Also make sure a local folders server is created, as that's what is used</span>
<a href="#l77.84"></a><span id="l77.84">   // for sent items</span>
<a href="#l77.85"></a><span id="l77.85">   loadLocalMailAccount();</span>
<a href="#l77.86"></a><span id="l77.86" class="difflineat">@@ -226,17 +234,17 @@ function run_test()</span>
<a href="#l77.87"></a><span id="l77.87">   prefBranch.setBoolPref(&quot;mail.server.server1.download_on_biff&quot;, false);</span>
<a href="#l77.88"></a><span id="l77.88"> </span>
<a href="#l77.89"></a><span id="l77.89">   // Get the server list...</span>
<a href="#l77.90"></a><span id="l77.90">   gIMAPIncomingServer.performExpand(null);</span>
<a href="#l77.91"></a><span id="l77.91"> </span>
<a href="#l77.92"></a><span id="l77.92">   // We get these notifications on initial discovery</span>
<a href="#l77.93"></a><span id="l77.93">   gRootFolder = gIMAPIncomingServer.rootFolder;</span>
<a href="#l77.94"></a><span id="l77.94">   gIMAPInbox = gRootFolder.getChildNamed(&quot;Inbox&quot;);</span>
<a href="#l77.95"></a><span id="l77.95" class="difflineminus">-  gExpectedEvents = [[gMFNService.folderAdded, gRootFolder, &quot;Trash&quot;, </span>
<a href="#l77.96"></a><span id="l77.96" class="difflineplus">+  gExpectedEvents = [[gMFNService.folderAdded, gRootFolder, &quot;Trash&quot;,</span>
<a href="#l77.97"></a><span id="l77.97">                      &quot;gIMAPTrashFolder&quot;]];</span>
<a href="#l77.98"></a><span id="l77.98">   gCurrStatus |= kStatus.onStopCopyDone | kStatus.functionCallDone;</span>
<a href="#l77.99"></a><span id="l77.99"> </span>
<a href="#l77.100"></a><span id="l77.100">   gServer.performTest(&quot;SUBSCRIBE&quot;);</span>
<a href="#l77.101"></a><span id="l77.101"> </span>
<a href="#l77.102"></a><span id="l77.102">   // &quot;Master&quot; do_test_pending(), paired with a do_test_finished() at the end of</span>
<a href="#l77.103"></a><span id="l77.103">   // all the operations.</span>
<a href="#l77.104"></a><span id="l77.104">   do_test_pending();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l78.1"></a><span id="l78.1" class="difflineminus">--- a/mailnews/local/src/nsLocalMailFolder.cpp</span>
<a href="#l78.2"></a><span id="l78.2" class="difflineplus">+++ b/mailnews/local/src/nsLocalMailFolder.cpp</span>
<a href="#l78.3"></a><span id="l78.3" class="difflineat">@@ -25,16 +25,17 @@</span>
<a href="#l78.4"></a><span id="l78.4">  *   bienvenu@nventure.com</span>
<a href="#l78.5"></a><span id="l78.5">  *   warren@netscape.com</span>
<a href="#l78.6"></a><span id="l78.6">  *   alecf@netscape.com</span>
<a href="#l78.7"></a><span id="l78.7">  *   sspitzer@netscape.com</span>
<a href="#l78.8"></a><span id="l78.8">  *   Pierre Phaneuf &lt;pp@ludusdesign.com&gt;</span>
<a href="#l78.9"></a><span id="l78.9">  *   Howard Chu &lt;hyc@highlandsun.com&gt;</span>
<a href="#l78.10"></a><span id="l78.10">  *   William Bonnet &lt;wbonnet@on-x.com&gt;</span>
<a href="#l78.11"></a><span id="l78.11">  *   Siddharth Agarwal &lt;sid1337@gmail.com&gt;</span>
<a href="#l78.12"></a><span id="l78.12" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l78.13"></a><span id="l78.13">  *</span>
<a href="#l78.14"></a><span id="l78.14">  * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l78.15"></a><span id="l78.15">  * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l78.16"></a><span id="l78.16">  * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l78.17"></a><span id="l78.17">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l78.18"></a><span id="l78.18">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l78.19"></a><span id="l78.19">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l78.20"></a><span id="l78.20">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l78.21"></a><span id="l78.21" class="difflineat">@@ -1577,16 +1578,21 @@ nsMsgLocalMailFolder::InitCopyState(nsIS</span>
<a href="#l78.22"></a><span id="l78.22">   mCopyState-&gt;m_isFolder = isFolder;</span>
<a href="#l78.23"></a><span id="l78.23">   mCopyState-&gt;m_allowUndo = allowUndo;</span>
<a href="#l78.24"></a><span id="l78.24">   mCopyState-&gt;m_msgWindow = msgWindow;</span>
<a href="#l78.25"></a><span id="l78.25">   rv = messages-&gt;GetLength(&amp;mCopyState-&gt;m_totalMsgCount);</span>
<a href="#l78.26"></a><span id="l78.26">   if (listener)</span>
<a href="#l78.27"></a><span id="l78.27">     mCopyState-&gt;m_listener = do_QueryInterface(listener, &amp;rv);</span>
<a href="#l78.28"></a><span id="l78.28">   mCopyState-&gt;m_copyingMultipleMessages = PR_FALSE;</span>
<a href="#l78.29"></a><span id="l78.29">   mCopyState-&gt;m_wholeMsgInStream = PR_FALSE;</span>
<a href="#l78.30"></a><span id="l78.30" class="difflineplus">+</span>
<a href="#l78.31"></a><span id="l78.31" class="difflineplus">+  // If we have source messages then we need destination messages too.</span>
<a href="#l78.32"></a><span id="l78.32" class="difflineplus">+  if (messages)</span>
<a href="#l78.33"></a><span id="l78.33" class="difflineplus">+    mCopyState-&gt;m_destMessages = do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l78.34"></a><span id="l78.34" class="difflineplus">+</span>
<a href="#l78.35"></a><span id="l78.35">   return rv;</span>
<a href="#l78.36"></a><span id="l78.36"> }</span>
<a href="#l78.37"></a><span id="l78.37"> </span>
<a href="#l78.38"></a><span id="l78.38"> NS_IMETHODIMP nsMsgLocalMailFolder::OnAnnouncerGoingAway(nsIDBChangeAnnouncer *instigator)</span>
<a href="#l78.39"></a><span id="l78.39"> {</span>
<a href="#l78.40"></a><span id="l78.40">   if (mCopyState)</span>
<a href="#l78.41"></a><span id="l78.41">     mCopyState-&gt;m_destDB = nsnull;</span>
<a href="#l78.42"></a><span id="l78.42">   return nsMsgDBFolder::OnAnnouncerGoingAway(instigator);</span>
<a href="#l78.43"></a><span id="l78.43" class="difflineat">@@ -2603,19 +2609,22 @@ NS_IMETHODIMP nsMsgLocalMailFolder::EndC</span>
<a href="#l78.44"></a><span id="l78.44">     if(!mCopyState-&gt;m_parseMsgState)</span>
<a href="#l78.45"></a><span id="l78.45">     {</span>
<a href="#l78.46"></a><span id="l78.46">       if(mCopyState-&gt;m_destDB)</span>
<a href="#l78.47"></a><span id="l78.47">       {</span>
<a href="#l78.48"></a><span id="l78.48">         rv = mCopyState-&gt;m_destDB-&gt;CopyHdrFromExistingHdr(mCopyState-&gt;m_curDstKey,</span>
<a href="#l78.49"></a><span id="l78.49">           mCopyState-&gt;m_message, PR_TRUE,</span>
<a href="#l78.50"></a><span id="l78.50">           getter_AddRefs(newHdr));</span>
<a href="#l78.51"></a><span id="l78.51">         PRUint32 newHdrFlags;</span>
<a href="#l78.52"></a><span id="l78.52" class="difflineminus">-        // turn off offline flag - it's not valid for local mail folders.</span>
<a href="#l78.53"></a><span id="l78.53">         if (newHdr)</span>
<a href="#l78.54"></a><span id="l78.54" class="difflineplus">+        {</span>
<a href="#l78.55"></a><span id="l78.55" class="difflineplus">+          // turn off offline flag - it's not valid for local mail folders.</span>
<a href="#l78.56"></a><span id="l78.56">           newHdr-&gt;AndFlags(~nsMsgMessageFlags::Offline, &amp;newHdrFlags);</span>
<a href="#l78.57"></a><span id="l78.57" class="difflineplus">+          mCopyState-&gt;m_destMessages-&gt;AppendElement(newHdr, PR_FALSE);</span>
<a href="#l78.58"></a><span id="l78.58" class="difflineplus">+        }</span>
<a href="#l78.59"></a><span id="l78.59">       }</span>
<a href="#l78.60"></a><span id="l78.60">       // we can do undo with the dest folder db, see bug #198909</span>
<a href="#l78.61"></a><span id="l78.61">       //else</span>
<a href="#l78.62"></a><span id="l78.62">       //  mCopyState-&gt;m_undoMsgTxn = nsnull; //null out the transaction because we can't undo w/o the msg db</span>
<a href="#l78.63"></a><span id="l78.63">     }</span>
<a href="#l78.64"></a><span id="l78.64"> </span>
<a href="#l78.65"></a><span id="l78.65">     // if we plan on allowing undo, (if we have a mCopyState-&gt;m_parseMsgState or not)</span>
<a href="#l78.66"></a><span id="l78.66">     // we need to save the source and dest keys on the undo txn.</span>
<a href="#l78.67"></a><span id="l78.67" class="difflineat">@@ -2684,16 +2693,18 @@ NS_IMETHODIMP nsMsgLocalMailFolder::EndC</span>
<a href="#l78.68"></a><span id="l78.68">         if (localUndoTxn)</span>
<a href="#l78.69"></a><span id="l78.69">         {</span>
<a href="#l78.70"></a><span id="l78.70">           // ** jt - recording the message size for possible undo use; the</span>
<a href="#l78.71"></a><span id="l78.71">           // message size is different for pop3 and imap4 messages</span>
<a href="#l78.72"></a><span id="l78.72">           PRUint32 msgSize;</span>
<a href="#l78.73"></a><span id="l78.73">           newHdr-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l78.74"></a><span id="l78.74">           localUndoTxn-&gt;AddDstMsgSize(msgSize);</span>
<a href="#l78.75"></a><span id="l78.75">         }</span>
<a href="#l78.76"></a><span id="l78.76" class="difflineplus">+</span>
<a href="#l78.77"></a><span id="l78.77" class="difflineplus">+        mCopyState-&gt;m_destMessages-&gt;AppendElement(newHdr, PR_FALSE);</span>
<a href="#l78.78"></a><span id="l78.78">       }</span>
<a href="#l78.79"></a><span id="l78.79">       // msgDb-&gt;SetSummaryValid(PR_TRUE);</span>
<a href="#l78.80"></a><span id="l78.80">       // msgDb-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l78.81"></a><span id="l78.81">     }</span>
<a href="#l78.82"></a><span id="l78.82">     else</span>
<a href="#l78.83"></a><span id="l78.83">       mCopyState-&gt;m_undoMsgTxn = nsnull; //null out the transaction because we can't undo w/o the msg db</span>
<a href="#l78.84"></a><span id="l78.84"> </span>
<a href="#l78.85"></a><span id="l78.85">     mCopyState-&gt;m_parseMsgState-&gt;Clear();</span>
<a href="#l78.86"></a><span id="l78.86" class="difflineat">@@ -2719,17 +2730,19 @@ NS_IMETHODIMP nsMsgLocalMailFolder::EndC</span>
<a href="#l78.87"></a><span id="l78.87">     mCopyState-&gt;m_messages-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l78.88"></a><span id="l78.88"> </span>
<a href="#l78.89"></a><span id="l78.89">     if (multipleCopiesFinished &amp;&amp; numHdrs &amp;&amp; !mCopyState-&gt;m_isFolder)</span>
<a href="#l78.90"></a><span id="l78.90">     {</span>
<a href="#l78.91"></a><span id="l78.91">       // we need to send this notification before we delete the source messages,</span>
<a href="#l78.92"></a><span id="l78.92">       // because deleting the source messages clears out the src msg db hdr.</span>
<a href="#l78.93"></a><span id="l78.93">       nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l78.94"></a><span id="l78.94">       if (notifier)</span>
<a href="#l78.95"></a><span id="l78.95" class="difflineminus">-        notifier-&gt;NotifyMsgsMoveCopyCompleted(mCopyState-&gt;m_isMove, mCopyState-&gt;m_messages, this);</span>
<a href="#l78.96"></a><span id="l78.96" class="difflineplus">+        notifier-&gt;NotifyMsgsMoveCopyCompleted(mCopyState-&gt;m_isMove,</span>
<a href="#l78.97"></a><span id="l78.97" class="difflineplus">+                                              mCopyState-&gt;m_messages,</span>
<a href="#l78.98"></a><span id="l78.98" class="difflineplus">+                                              this, mCopyState-&gt;m_destMessages);</span>
<a href="#l78.99"></a><span id="l78.99">     }</span>
<a href="#l78.100"></a><span id="l78.100"> </span>
<a href="#l78.101"></a><span id="l78.101">     if(!mCopyState-&gt;m_isMove)</span>
<a href="#l78.102"></a><span id="l78.102">     {</span>
<a href="#l78.103"></a><span id="l78.103">       if (multipleCopiesFinished)</span>
<a href="#l78.104"></a><span id="l78.104">       {</span>
<a href="#l78.105"></a><span id="l78.105">         nsCOMPtr&lt;nsIMsgFolder&gt; srcFolder;</span>
<a href="#l78.106"></a><span id="l78.106">         srcFolder = do_QueryInterface(mCopyState-&gt;m_srcSupport);</span>
<a href="#l78.107"></a><span id="l78.107" class="difflineat">@@ -2758,17 +2771,25 @@ NS_IMETHODIMP nsMsgLocalMailFolder::EndC</span>
<a href="#l78.108"></a><span id="l78.108">     }</span>
<a href="#l78.109"></a><span id="l78.109">     // Send the itemAdded notification in case we didn't send the itemMoveCopyCompleted notification earlier.</span>
<a href="#l78.110"></a><span id="l78.110">     // Posting news messages involves this, yet doesn't have the newHdr initialized, so don't send any</span>
<a href="#l78.111"></a><span id="l78.111">     // notifications in that case.</span>
<a href="#l78.112"></a><span id="l78.112">     if (!numHdrs &amp;&amp; newHdr)</span>
<a href="#l78.113"></a><span id="l78.113">     {</span>
<a href="#l78.114"></a><span id="l78.114">       nsCOMPtr&lt;nsIMsgFolderNotificationService&gt; notifier(do_GetService(NS_MSGNOTIFICATIONSERVICE_CONTRACTID));</span>
<a href="#l78.115"></a><span id="l78.115">       if (notifier)</span>
<a href="#l78.116"></a><span id="l78.116" class="difflineplus">+      {</span>
<a href="#l78.117"></a><span id="l78.117">         notifier-&gt;NotifyMsgAdded(newHdr);</span>
<a href="#l78.118"></a><span id="l78.118" class="difflineplus">+        // We do not appear to trigger classification in this case, so let's</span>
<a href="#l78.119"></a><span id="l78.119" class="difflineplus">+        // paper over the abyss by just sending the classification notification.</span>
<a href="#l78.120"></a><span id="l78.120" class="difflineplus">+        nsCOMPtr &lt;nsIMutableArray&gt; oneHeaderArray =</span>
<a href="#l78.121"></a><span id="l78.121" class="difflineplus">+          do_CreateInstance(NS_ARRAY_CONTRACTID);</span>
<a href="#l78.122"></a><span id="l78.122" class="difflineplus">+        oneHeaderArray-&gt;AppendElement(newHdr, PR_FALSE);</span>
<a href="#l78.123"></a><span id="l78.123" class="difflineplus">+        notifier-&gt;NotifyMsgsClassified(oneHeaderArray, PR_FALSE, PR_FALSE);</span>
<a href="#l78.124"></a><span id="l78.124" class="difflineplus">+      }</span>
<a href="#l78.125"></a><span id="l78.125">     }</span>
<a href="#l78.126"></a><span id="l78.126">   }</span>
<a href="#l78.127"></a><span id="l78.127">   return rv;</span>
<a href="#l78.128"></a><span id="l78.128"> }</span>
<a href="#l78.129"></a><span id="l78.129"> </span>
<a href="#l78.130"></a><span id="l78.130"> static PRBool gGotGlobalPrefs;</span>
<a href="#l78.131"></a><span id="l78.131"> static PRBool gDeleteFromServerOnMove;</span>
<a href="#l78.132"></a><span id="l78.132"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l79.1"></a><span id="l79.1" class="difflineminus">--- a/mailnews/local/src/nsLocalMailFolder.h</span>
<a href="#l79.2"></a><span id="l79.2" class="difflineplus">+++ b/mailnews/local/src/nsLocalMailFolder.h</span>
<a href="#l79.3"></a><span id="l79.3" class="difflineat">@@ -62,33 +62,37 @@ class nsParseMailMessageState;</span>
<a href="#l79.4"></a><span id="l79.4"> </span>
<a href="#l79.5"></a><span id="l79.5"> struct nsLocalMailCopyState</span>
<a href="#l79.6"></a><span id="l79.6"> {</span>
<a href="#l79.7"></a><span id="l79.7">   nsLocalMailCopyState();</span>
<a href="#l79.8"></a><span id="l79.8">   virtual ~nsLocalMailCopyState();</span>
<a href="#l79.9"></a><span id="l79.9">   </span>
<a href="#l79.10"></a><span id="l79.10">   nsCOMPtr &lt;nsIOutputStream&gt; m_fileStream;</span>
<a href="#l79.11"></a><span id="l79.11">   nsCOMPtr&lt;nsISupports&gt; m_srcSupport;</span>
<a href="#l79.12"></a><span id="l79.12" class="difflineplus">+  /// Source nsIMsgDBHdr instances.</span>
<a href="#l79.13"></a><span id="l79.13">   nsCOMPtr&lt;nsIArray&gt; m_messages;</span>
<a href="#l79.14"></a><span id="l79.14" class="difflineplus">+  /// Destination nsIMsgDBHdr instances.</span>
<a href="#l79.15"></a><span id="l79.15" class="difflineplus">+  nsCOMPtr&lt;nsIMutableArray&gt; m_destMessages;</span>
<a href="#l79.16"></a><span id="l79.16">   nsRefPtr&lt;nsLocalMoveCopyMsgTxn&gt; m_undoMsgTxn;</span>
<a href="#l79.17"></a><span id="l79.17">   nsCOMPtr&lt;nsIMsgDBHdr&gt; m_message; // current copy message</span>
<a href="#l79.18"></a><span id="l79.18">   nsMsgMessageFlagType m_flags; // current copy message flags</span>
<a href="#l79.19"></a><span id="l79.19">   nsRefPtr&lt;nsParseMailMessageState&gt; m_parseMsgState;</span>
<a href="#l79.20"></a><span id="l79.20">   nsCOMPtr&lt;nsIMsgCopyServiceListener&gt; m_listener;</span>
<a href="#l79.21"></a><span id="l79.21">   nsCOMPtr&lt;nsIMsgWindow&gt; m_msgWindow;</span>
<a href="#l79.22"></a><span id="l79.22">   nsCOMPtr&lt;nsIMsgDatabase&gt; m_destDB;</span>
<a href="#l79.23"></a><span id="l79.23"> </span>
<a href="#l79.24"></a><span id="l79.24">   // for displaying status;</span>
<a href="#l79.25"></a><span id="l79.25">   nsCOMPtr &lt;nsIMsgStatusFeedback&gt; m_statusFeedback;</span>
<a href="#l79.26"></a><span id="l79.26">   nsCOMPtr &lt;nsIStringBundle&gt; m_stringBundle;</span>
<a href="#l79.27"></a><span id="l79.27">   PRInt64 m_lastProgressTime;</span>
<a href="#l79.28"></a><span id="l79.28"> </span>
<a href="#l79.29"></a><span id="l79.29">   nsMsgKey m_curDstKey;</span>
<a href="#l79.30"></a><span id="l79.30">   PRUint32 m_curCopyIndex;</span>
<a href="#l79.31"></a><span id="l79.31">   nsCOMPtr &lt;nsIMsgMessageService&gt; m_messageService;</span>
<a href="#l79.32"></a><span id="l79.32" class="difflineplus">+  /// The number of messages in m_messages.</span>
<a href="#l79.33"></a><span id="l79.33">   PRUint32 m_totalMsgCount;</span>
<a href="#l79.34"></a><span id="l79.34">   char *m_dataBuffer;</span>
<a href="#l79.35"></a><span id="l79.35">   PRUint32 m_dataBufferSize;</span>
<a href="#l79.36"></a><span id="l79.36">   PRUint32 m_leftOver;</span>
<a href="#l79.37"></a><span id="l79.37">   PRPackedBool m_isMove;</span>
<a href="#l79.38"></a><span id="l79.38">   PRPackedBool m_isFolder;   // isFolder move/copy</span>
<a href="#l79.39"></a><span id="l79.39">   PRPackedBool m_dummyEnvelopeNeeded;</span>
<a href="#l79.40"></a><span id="l79.40">   PRPackedBool m_copyingMultipleMessages;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l80.1"></a><span id="l80.1" class="difflineminus">--- a/mailnews/local/src/nsRssIncomingServer.cpp</span>
<a href="#l80.2"></a><span id="l80.2" class="difflineplus">+++ b/mailnews/local/src/nsRssIncomingServer.cpp</span>
<a href="#l80.3"></a><span id="l80.3" class="difflineat">@@ -258,22 +258,31 @@ NS_IMETHODIMP nsRssIncomingServer::GetCa</span>
<a href="#l80.4"></a><span id="l80.4">   return NS_OK;</span>
<a href="#l80.5"></a><span id="l80.5"> }</span>
<a href="#l80.6"></a><span id="l80.6"> </span>
<a href="#l80.7"></a><span id="l80.7"> NS_IMETHODIMP nsRssIncomingServer::MsgAdded(nsIMsgDBHdr *aMsg)</span>
<a href="#l80.8"></a><span id="l80.8"> {</span>
<a href="#l80.9"></a><span id="l80.9">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l80.10"></a><span id="l80.10"> }</span>
<a href="#l80.11"></a><span id="l80.11"> </span>
<a href="#l80.12"></a><span id="l80.12" class="difflineplus">+NS_IMETHODIMP nsRssIncomingServer::MsgsClassified(nsIArray *aMsgs,</span>
<a href="#l80.13"></a><span id="l80.13" class="difflineplus">+                                                  PRBool aJunkProcessed,</span>
<a href="#l80.14"></a><span id="l80.14" class="difflineplus">+                                                  PRBool aTraitProcessed)</span>
<a href="#l80.15"></a><span id="l80.15" class="difflineplus">+{</span>
<a href="#l80.16"></a><span id="l80.16" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l80.17"></a><span id="l80.17" class="difflineplus">+}</span>
<a href="#l80.18"></a><span id="l80.18" class="difflineplus">+</span>
<a href="#l80.19"></a><span id="l80.19"> NS_IMETHODIMP nsRssIncomingServer::MsgsDeleted(nsIArray *aMsgs)</span>
<a href="#l80.20"></a><span id="l80.20"> {</span>
<a href="#l80.21"></a><span id="l80.21">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l80.22"></a><span id="l80.22"> }</span>
<a href="#l80.23"></a><span id="l80.23"> </span>
<a href="#l80.24"></a><span id="l80.24" class="difflineminus">-NS_IMETHODIMP nsRssIncomingServer::MsgsMoveCopyCompleted(PRBool aMove, nsIArray *aSrcMsgs, nsIMsgFolder *aDestFolder)</span>
<a href="#l80.25"></a><span id="l80.25" class="difflineplus">+NS_IMETHODIMP nsRssIncomingServer::MsgsMoveCopyCompleted(</span>
<a href="#l80.26"></a><span id="l80.26" class="difflineplus">+  PRBool aMove, nsIArray *aSrcMsgs, nsIMsgFolder *aDestFolder,</span>
<a href="#l80.27"></a><span id="l80.27" class="difflineplus">+  nsIArray *aDestMsgs)</span>
<a href="#l80.28"></a><span id="l80.28"> {</span>
<a href="#l80.29"></a><span id="l80.29">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l80.30"></a><span id="l80.30"> }</span>
<a href="#l80.31"></a><span id="l80.31"> </span>
<a href="#l80.32"></a><span id="l80.32"> NS_IMETHODIMP nsRssIncomingServer::FolderAdded(nsIMsgFolder *aFolder)</span>
<a href="#l80.33"></a><span id="l80.33"> {</span>
<a href="#l80.34"></a><span id="l80.34">   return FolderChanged(aFolder, PR_FALSE);</span>
<a href="#l80.35"></a><span id="l80.35"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l81.1"></a><span id="l81.1" class="difflineminus">--- a/mailnews/test/fakeserver/maild.js</span>
<a href="#l81.2"></a><span id="l81.2" class="difflineplus">+++ b/mailnews/test/fakeserver/maild.js</span>
<a href="#l81.3"></a><span id="l81.3" class="difflineat">@@ -117,16 +117,23 @@ function nsMailServer(handler) {</span>
<a href="#l81.4"></a><span id="l81.4">   this._socket = null;</span>
<a href="#l81.5"></a><span id="l81.5"> </span>
<a href="#l81.6"></a><span id="l81.6">   /**</span>
<a href="#l81.7"></a><span id="l81.7">    * True if the socket in this is closed (and closure notifications have been</span>
<a href="#l81.8"></a><span id="l81.8">    * sent and processed if the socket was ever opened), false otherwise.</span>
<a href="#l81.9"></a><span id="l81.9">    */</span>
<a href="#l81.10"></a><span id="l81.10">   this._socketClosed = true;</span>
<a href="#l81.11"></a><span id="l81.11"> </span>
<a href="#l81.12"></a><span id="l81.12" class="difflineplus">+  /**</span>
<a href="#l81.13"></a><span id="l81.13" class="difflineplus">+   * Should we log transactions?  This only matters if you want to inspect the</span>
<a href="#l81.14"></a><span id="l81.14" class="difflineplus">+   * protocol traffic.  Defaults to true because this was written for protocol</span>
<a href="#l81.15"></a><span id="l81.15" class="difflineplus">+   * testing.</span>
<a href="#l81.16"></a><span id="l81.16" class="difflineplus">+   */</span>
<a href="#l81.17"></a><span id="l81.17" class="difflineplus">+  this._logTransactions = true;</span>
<a href="#l81.18"></a><span id="l81.18" class="difflineplus">+</span>
<a href="#l81.19"></a><span id="l81.19">   this._handler = handler;</span>
<a href="#l81.20"></a><span id="l81.20">   this._readers = [];</span>
<a href="#l81.21"></a><span id="l81.21">   this._test = false;</span>
<a href="#l81.22"></a><span id="l81.22"> </span>
<a href="#l81.23"></a><span id="l81.23">   /**</span>
<a href="#l81.24"></a><span id="l81.24">    * An array to hold refs to all the input streams below, so that they don't</span>
<a href="#l81.25"></a><span id="l81.25">    * get GCed</span>
<a href="#l81.26"></a><span id="l81.26">    */</span>
<a href="#l81.27"></a><span id="l81.27" class="difflineat">@@ -138,17 +145,18 @@ nsMailServer.prototype = {</span>
<a href="#l81.28"></a><span id="l81.28">       print(&quot;Received Connection from &quot; + trans.host + &quot;:&quot; + trans.port);</span>
<a href="#l81.29"></a><span id="l81.29"> </span>
<a href="#l81.30"></a><span id="l81.30">     const SEGMENT_SIZE = 1024;</span>
<a href="#l81.31"></a><span id="l81.31">     const SEGMENT_COUNT = 1024;</span>
<a href="#l81.32"></a><span id="l81.32">     var input = trans.openInputStream(0, SEGMENT_SIZE, SEGMENT_COUNT)</span>
<a href="#l81.33"></a><span id="l81.33">                      .QueryInterface(Ci.nsIAsyncInputStream);</span>
<a href="#l81.34"></a><span id="l81.34">     this._inputStreams.push(input);</span>
<a href="#l81.35"></a><span id="l81.35"> </span>
<a href="#l81.36"></a><span id="l81.36" class="difflineminus">-    var reader = new nsMailReader(this, this._handler, trans, this._debug);</span>
<a href="#l81.37"></a><span id="l81.37" class="difflineplus">+    var reader = new nsMailReader(this, this._handler, trans, this._debug,</span>
<a href="#l81.38"></a><span id="l81.38" class="difflineplus">+                                  this._logTransactions);</span>
<a href="#l81.39"></a><span id="l81.39">     this._readers.push(reader);</span>
<a href="#l81.40"></a><span id="l81.40"> </span>
<a href="#l81.41"></a><span id="l81.41">     // Note: must use main thread here, or we might get a GC that will cause</span>
<a href="#l81.42"></a><span id="l81.42">     //       threadsafety assertions.  We really need to fix XPConnect so that</span>
<a href="#l81.43"></a><span id="l81.43">     //       you can actually do things in multi-threaded JS.  :-(</span>
<a href="#l81.44"></a><span id="l81.44">     input.asyncWait(reader, 0, 0, gThreadManager.mainThread);</span>
<a href="#l81.45"></a><span id="l81.45">     this._test = true;</span>
<a href="#l81.46"></a><span id="l81.46">   },</span>
<a href="#l81.47"></a><span id="l81.47" class="difflineat">@@ -298,33 +306,37 @@ function readTo(input, count, arr) {</span>
<a href="#l81.48"></a><span id="l81.48">  * The return of postCommand is ignored. The return of onMultiline is a bit</span>
<a href="#l81.49"></a><span id="l81.49">  * complicated: it may or may not return a response string (returning one is</span>
<a href="#l81.50"></a><span id="l81.50">  * necessary to trigger the postCommand handler).</span>
<a href="#l81.51"></a><span id="l81.51">  *</span>
<a href="#l81.52"></a><span id="l81.52">  * This object has the following supplemental functions for use by handlers:</span>
<a href="#l81.53"></a><span id="l81.53">  * closeSocket  Performs a server-side socket closing</span>
<a href="#l81.54"></a><span id="l81.54">  * setMultiline Sets the multiline mode based on the argument</span>
<a href="#l81.55"></a><span id="l81.55">  *****************************************************************************/</span>
<a href="#l81.56"></a><span id="l81.56" class="difflineminus">-function nsMailReader(server, handler, transport, debug) {</span>
<a href="#l81.57"></a><span id="l81.57" class="difflineplus">+function nsMailReader(server, handler, transport, debug, logTransaction) {</span>
<a href="#l81.58"></a><span id="l81.58">   this._debug = debug;</span>
<a href="#l81.59"></a><span id="l81.59">   this._server = server;</span>
<a href="#l81.60"></a><span id="l81.60">   this._buffer = [];</span>
<a href="#l81.61"></a><span id="l81.61">   this._lines = [];</span>
<a href="#l81.62"></a><span id="l81.62">   this._handler = handler;</span>
<a href="#l81.63"></a><span id="l81.63">   this._transport = transport;</span>
<a href="#l81.64"></a><span id="l81.64">   var output = transport.openOutputStream(Ci.nsITransport.OPEN_BLOCKING, 0, 0);</span>
<a href="#l81.65"></a><span id="l81.65">   this._output = output;</span>
<a href="#l81.66"></a><span id="l81.66" class="difflineminus">-  this.transaction = { us : [], them : [] };</span>
<a href="#l81.67"></a><span id="l81.67" class="difflineplus">+  if (logTransaction)</span>
<a href="#l81.68"></a><span id="l81.68" class="difflineplus">+    this.transaction = { us : [], them : [] };</span>
<a href="#l81.69"></a><span id="l81.69" class="difflineplus">+  else</span>
<a href="#l81.70"></a><span id="l81.70" class="difflineplus">+    this.transaction = null;</span>
<a href="#l81.71"></a><span id="l81.71"> </span>
<a href="#l81.72"></a><span id="l81.72">   // Send response line</span>
<a href="#l81.73"></a><span id="l81.73">   var response = this._handler.onStartup();</span>
<a href="#l81.74"></a><span id="l81.74">   response = response.replace(/([^\r])\n/g,&quot;$1\r\n&quot;);</span>
<a href="#l81.75"></a><span id="l81.75">   if (response.charAt(response.length-1) != '\n')</span>
<a href="#l81.76"></a><span id="l81.76">     response = response + &quot;\r\n&quot;;</span>
<a href="#l81.77"></a><span id="l81.77" class="difflineminus">-  this.transaction.us.push(response);</span>
<a href="#l81.78"></a><span id="l81.78" class="difflineplus">+  if (this.transaction)</span>
<a href="#l81.79"></a><span id="l81.79" class="difflineplus">+    this.transaction.us.push(response);</span>
<a href="#l81.80"></a><span id="l81.80">   this._output.write(response, response.length);</span>
<a href="#l81.81"></a><span id="l81.81">   this._output.flush();</span>
<a href="#l81.82"></a><span id="l81.82"> </span>
<a href="#l81.83"></a><span id="l81.83">   this._multiline = false;</span>
<a href="#l81.84"></a><span id="l81.84"> </span>
<a href="#l81.85"></a><span id="l81.85">   this._isRunning = true;</span>
<a href="#l81.86"></a><span id="l81.86">   </span>
<a href="#l81.87"></a><span id="l81.87">   this.observer = {</span>
<a href="#l81.88"></a><span id="l81.88" class="difflineat">@@ -397,17 +409,18 @@ nsMailReader.prototype = {</span>
<a href="#l81.89"></a><span id="l81.89">         } else if (this._expectPassword) {</span>
<a href="#l81.90"></a><span id="l81.90">           dump(&quot;expecting password\n&quot;);</span>
<a href="#l81.91"></a><span id="l81.91">           response = this._handler.onPassword(line);</span>
<a href="#l81.92"></a><span id="l81.92"> </span>
<a href="#l81.93"></a><span id="l81.93">           if (response == undefined)</span>
<a href="#l81.94"></a><span id="l81.94">             continue;</span>
<a href="#l81.95"></a><span id="l81.95">         } else {</span>
<a href="#l81.96"></a><span id="l81.96">           // Record the transaction</span>
<a href="#l81.97"></a><span id="l81.97" class="difflineminus">-          this.transaction.them.push(line);</span>
<a href="#l81.98"></a><span id="l81.98" class="difflineplus">+          if (this.transaction)</span>
<a href="#l81.99"></a><span id="l81.99" class="difflineplus">+            this.transaction.them.push(line);</span>
<a href="#l81.100"></a><span id="l81.100"> </span>
<a href="#l81.101"></a><span id="l81.101">           // Find the command and splice it out...</span>
<a href="#l81.102"></a><span id="l81.102">           var splitter = line.indexOf(&quot; &quot;);</span>
<a href="#l81.103"></a><span id="l81.103">           var command = splitter == -1 ? line : line.substring(0,splitter);</span>
<a href="#l81.104"></a><span id="l81.104">           var args = splitter == -1 ? &quot;&quot; : line.substring(splitter+1);</span>
<a href="#l81.105"></a><span id="l81.105"> </span>
<a href="#l81.106"></a><span id="l81.106">           // By convention, commands are uppercase</span>
<a href="#l81.107"></a><span id="l81.107">           command = command.toUpperCase();</span>
<a href="#l81.108"></a><span id="l81.108" class="difflineat">@@ -443,17 +456,18 @@ nsMailReader.prototype = {</span>
<a href="#l81.109"></a><span id="l81.109">       if (this._debug == fsDebugRecvSend) {</span>
<a href="#l81.110"></a><span id="l81.110">         print(&quot;SEND: &quot; + response.split(&quot; &quot;, 1)[0]);</span>
<a href="#l81.111"></a><span id="l81.111">       }</span>
<a href="#l81.112"></a><span id="l81.112">       else if (this._debug == fsDebugAll) {</span>
<a href="#l81.113"></a><span id="l81.113">         var responses = response.split(&quot;\n&quot;);</span>
<a href="#l81.114"></a><span id="l81.114">         responses.forEach(function (line) { print(&quot;SEND: &quot; + line); });</span>
<a href="#l81.115"></a><span id="l81.115">       }</span>
<a href="#l81.116"></a><span id="l81.116"> </span>
<a href="#l81.117"></a><span id="l81.117" class="difflineminus">-      this.transaction.us.push(response);</span>
<a href="#l81.118"></a><span id="l81.118" class="difflineplus">+      if (this.transaction)</span>
<a href="#l81.119"></a><span id="l81.119" class="difflineplus">+        this.transaction.us.push(response);</span>
<a href="#l81.120"></a><span id="l81.120">       this._output.write(response, response.length);</span>
<a href="#l81.121"></a><span id="l81.121">       this._output.flush();</span>
<a href="#l81.122"></a><span id="l81.122"> </span>
<a href="#l81.123"></a><span id="l81.123">       if (this._signalStop)</span>
<a href="#l81.124"></a><span id="l81.124">         this._realCloseSocket();</span>
<a href="#l81.125"></a><span id="l81.125">     }</span>
<a href="#l81.126"></a><span id="l81.126"> </span>
<a href="#l81.127"></a><span id="l81.127">     if (this._isRunning) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l82.1"></a><span id="l82.1" class="difflineminus">--- a/mailnews/test/resources/asyncTestUtils.js</span>
<a href="#l82.2"></a><span id="l82.2" class="difflineplus">+++ b/mailnews/test/resources/asyncTestUtils.js</span>
<a href="#l82.3"></a><span id="l82.3" class="difflineat">@@ -14,80 +14,127 @@</span>
<a href="#l82.4"></a><span id="l82.4">  * function test_some_stuff() {</span>
<a href="#l82.5"></a><span id="l82.5">  *   yield async_run({func: something_async});</span>
<a href="#l82.6"></a><span id="l82.6">  *   yield async_run({func: something_that_maybe_is_async});</span>
<a href="#l82.7"></a><span id="l82.7">  *   something_that_is_definitely_not_async();</span>
<a href="#l82.8"></a><span id="l82.8">  *   do_test_finished();</span>
<a href="#l82.9"></a><span id="l82.9">  * }</span>
<a href="#l82.10"></a><span id="l82.10">  */</span>
<a href="#l82.11"></a><span id="l82.11"> </span>
<a href="#l82.12"></a><span id="l82.12" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/errUtils.js&quot;);</span>
<a href="#l82.13"></a><span id="l82.13" class="difflineplus">+</span>
<a href="#l82.14"></a><span id="l82.14" class="difflineplus">+/**</span>
<a href="#l82.15"></a><span id="l82.15" class="difflineplus">+ * Url listener that can wrap another listener and trigger a callback, but</span>
<a href="#l82.16"></a><span id="l82.16" class="difflineplus">+ *  definitely calls async_driver to resume asynchronous processing.  Use</span>
<a href="#l82.17"></a><span id="l82.17" class="difflineplus">+ *  |asyncUrlListener| if you just need a url listener that resumes processing</span>
<a href="#l82.18"></a><span id="l82.18" class="difflineplus">+ *  without any additional legwork.</span>
<a href="#l82.19"></a><span id="l82.19" class="difflineplus">+ *</span>
<a href="#l82.20"></a><span id="l82.20" class="difflineplus">+ * @param [aWrapped] The nsIUrlListener to pass all notifications through to.</span>
<a href="#l82.21"></a><span id="l82.21" class="difflineplus">+ *     This gets called prior to the callback (or async resumption).</span>
<a href="#l82.22"></a><span id="l82.22" class="difflineplus">+ * @param [aCallback] The callback to call when the URL stops running.  It will</span>
<a href="#l82.23"></a><span id="l82.23" class="difflineplus">+ *     be provided with the same arguments the method receives.  If you need</span>
<a href="#l82.24"></a><span id="l82.24" class="difflineplus">+ *     to do anything non-trivial, you are strongly advised to just use</span>
<a href="#l82.25"></a><span id="l82.25" class="difflineplus">+ *     async_run to push another function/generator function onto the async</span>
<a href="#l82.26"></a><span id="l82.26" class="difflineplus">+ *     stack rather than trying to maintain a convoluted callback mechanism</span>
<a href="#l82.27"></a><span id="l82.27" class="difflineplus">+ *     yourself.</span>
<a href="#l82.28"></a><span id="l82.28" class="difflineplus">+ * @param [aPromise] The promise to notify on completion.  If not specified, we</span>
<a href="#l82.29"></a><span id="l82.29" class="difflineplus">+ *     simply call async_driver instead.</span>
<a href="#l82.30"></a><span id="l82.30" class="difflineplus">+ */</span>
<a href="#l82.31"></a><span id="l82.31" class="difflineplus">+function AsyncUrlListener(aWrapped, aCallback, aPromise) {</span>
<a href="#l82.32"></a><span id="l82.32" class="difflineplus">+  this.wrapped = aWrapped ? aWrapped.QueryInterface(Ci.nsIUrlListener) : null;</span>
<a href="#l82.33"></a><span id="l82.33" class="difflineplus">+  this.callback = aCallback;</span>
<a href="#l82.34"></a><span id="l82.34" class="difflineplus">+  this.promise = aPromise;</span>
<a href="#l82.35"></a><span id="l82.35" class="difflineplus">+}</span>
<a href="#l82.36"></a><span id="l82.36" class="difflineplus">+AsyncUrlListener.prototype = {</span>
<a href="#l82.37"></a><span id="l82.37" class="difflineplus">+  OnStartRunningUrl: function asyncUrlListener_OnStartRunningUrl(</span>
<a href="#l82.38"></a><span id="l82.38" class="difflineplus">+                         aUrl) {</span>
<a href="#l82.39"></a><span id="l82.39" class="difflineplus">+    if (this.wrapped)</span>
<a href="#l82.40"></a><span id="l82.40" class="difflineplus">+      this.wrapped.OnStartRunningUrl(aUrl);</span>
<a href="#l82.41"></a><span id="l82.41" class="difflineplus">+  },</span>
<a href="#l82.42"></a><span id="l82.42" class="difflineplus">+  OnStopRunningUrl: function asyncUrlListener_OnStopRunningUrl(</span>
<a href="#l82.43"></a><span id="l82.43" class="difflineplus">+                         aUrl, aExitCode) {</span>
<a href="#l82.44"></a><span id="l82.44" class="difflineplus">+    if (this.wrapped)</span>
<a href="#l82.45"></a><span id="l82.45" class="difflineplus">+      this.wrapped.OnStopRunningUrl(aUrl, aExitCode);</span>
<a href="#l82.46"></a><span id="l82.46" class="difflineplus">+    if (this.callback)</span>
<a href="#l82.47"></a><span id="l82.47" class="difflineplus">+      this.callback(aUrl, aExitCode);</span>
<a href="#l82.48"></a><span id="l82.48" class="difflineplus">+    if (this.promise)</span>
<a href="#l82.49"></a><span id="l82.49" class="difflineplus">+      this.promise();</span>
<a href="#l82.50"></a><span id="l82.50" class="difflineplus">+    else</span>
<a href="#l82.51"></a><span id="l82.51" class="difflineplus">+      async_driver();</span>
<a href="#l82.52"></a><span id="l82.52" class="difflineplus">+  }</span>
<a href="#l82.53"></a><span id="l82.53" class="difflineplus">+};</span>
<a href="#l82.54"></a><span id="l82.54" class="difflineplus">+</span>
<a href="#l82.55"></a><span id="l82.55" class="difflineplus">+/**</span>
<a href="#l82.56"></a><span id="l82.56" class="difflineplus">+ * nsIUrlListener that calls async_driver when the URL stops running.  Pass this</span>
<a href="#l82.57"></a><span id="l82.57" class="difflineplus">+ *  in as an argument to asynchronous native mechanisms that use a URL listener</span>
<a href="#l82.58"></a><span id="l82.58" class="difflineplus">+ *  to notify when they complete.  If you need to wrap an existing listener</span>
<a href="#l82.59"></a><span id="l82.59" class="difflineplus">+ *  and/or have a callback notified before triggering the async process, create</span>
<a href="#l82.60"></a><span id="l82.60" class="difflineplus">+ *  your own instance of |AsyncUrlListener|.</span>
<a href="#l82.61"></a><span id="l82.61" class="difflineplus">+ */</span>
<a href="#l82.62"></a><span id="l82.62" class="difflineplus">+var asyncUrlListener = new AsyncUrlListener();</span>
<a href="#l82.63"></a><span id="l82.63" class="difflineplus">+</span>
<a href="#l82.64"></a><span id="l82.64"> var asyncCopyListener = {</span>
<a href="#l82.65"></a><span id="l82.65">   OnStartCopy: function() {},</span>
<a href="#l82.66"></a><span id="l82.66">   OnProgress: function(aProgress, aProgressMax) {},</span>
<a href="#l82.67"></a><span id="l82.67">   SetMessageKey: function(aMsgKey) {},</span>
<a href="#l82.68"></a><span id="l82.68">   GetMessageId: function() {},</span>
<a href="#l82.69"></a><span id="l82.69">   OnStopCopy: function(aStatus) {</span>
<a href="#l82.70"></a><span id="l82.70">     async_driver();</span>
<a href="#l82.71"></a><span id="l82.71">   }</span>
<a href="#l82.72"></a><span id="l82.72"> };</span>
<a href="#l82.73"></a><span id="l82.73"> </span>
<a href="#l82.74"></a><span id="l82.74"> /**</span>
<a href="#l82.75"></a><span id="l82.75" class="difflineminus">- * Delete one or more synthetic messages.  If using SyntheticMessageSets, call</span>
<a href="#l82.76"></a><span id="l82.76" class="difflineminus">- *  once for each SyntheticMessageSet.  Otherwise, we take synthetic message</span>
<a href="#l82.77"></a><span id="l82.77" class="difflineminus">- *  instances that are assumed to live in gTestFolder.  The arguments can be one</span>
<a href="#l82.78"></a><span id="l82.78" class="difflineminus">- *  or more synthetic message instances or a singe list of synthetic messages.</span>
<a href="#l82.79"></a><span id="l82.79" class="difflineminus">- *  (Synthetic messages are from messageGenerator.js, SyntheticMessageSets are</span>
<a href="#l82.80"></a><span id="l82.80" class="difflineminus">- *  from messageModifier.js)</span>
<a href="#l82.81"></a><span id="l82.81" class="difflineplus">+ * Move the messages to the trash; do not use this on messages that are already</span>
<a href="#l82.82"></a><span id="l82.82" class="difflineplus">+ *  in the trash, we are not clever enough for that.</span>
<a href="#l82.83"></a><span id="l82.83">  *</span>
<a href="#l82.84"></a><span id="l82.84" class="difflineminus">- * Usage example using a SyntheticMessageSet (which defines the folder):</span>
<a href="#l82.85"></a><span id="l82.85" class="difflineminus">- *  yield async_delete_messages(syntheticMessageSet);</span>
<a href="#l82.86"></a><span id="l82.86" class="difflineminus">- *  yield async_delete_messages(new SyntheticMessageSet(folder, [synMsg]);</span>
<a href="#l82.87"></a><span id="l82.87" class="difflineminus">- * Usage example assuming gTestFolder:</span>
<a href="#l82.88"></a><span id="l82.88" class="difflineminus">- *  yield async_delete_messages(synMsg);</span>
<a href="#l82.89"></a><span id="l82.89" class="difflineminus">- *  yield async_delete_messages(synMsg1, synMsg2);</span>
<a href="#l82.90"></a><span id="l82.90" class="difflineminus">- *  yield async_delete_messages([synMsg1, synMsg2]);</span>
<a href="#l82.91"></a><span id="l82.91" class="difflineplus">+ * @param aSynMessageSet The set of messages to trash.  The messages do not all</span>
<a href="#l82.92"></a><span id="l82.92" class="difflineplus">+ *     have to be in the same folder, but we have to trash them folder by</span>
<a href="#l82.93"></a><span id="l82.93" class="difflineplus">+ *     folder if they are not.</span>
<a href="#l82.94"></a><span id="l82.94">  */</span>
<a href="#l82.95"></a><span id="l82.95" class="difflineminus">-function async_delete_messages() {</span>
<a href="#l82.96"></a><span id="l82.96" class="difflineminus">-  let synMessages;</span>
<a href="#l82.97"></a><span id="l82.97" class="difflineminus">-  if (arguments.length &gt; 1)</span>
<a href="#l82.98"></a><span id="l82.98" class="difflineminus">-    synMessages = arguments;</span>
<a href="#l82.99"></a><span id="l82.99" class="difflineminus">-  else if (arguments[0].length)</span>
<a href="#l82.100"></a><span id="l82.100" class="difflineminus">-    synMessages = arguments[0];</span>
<a href="#l82.101"></a><span id="l82.101" class="difflineminus">-  else</span>
<a href="#l82.102"></a><span id="l82.102" class="difflineminus">-    synMessages = [arguments[0]];</span>
<a href="#l82.103"></a><span id="l82.103" class="difflineminus">-</span>
<a href="#l82.104"></a><span id="l82.104" class="difflineminus">-  if (synMessages.length == 0)</span>
<a href="#l82.105"></a><span id="l82.105" class="difflineminus">-    do_throw(&quot;You need to tell us to delete at least one thing!&quot;);</span>
<a href="#l82.106"></a><span id="l82.106" class="difflineplus">+function async_trash_messages(aSynMessageSet) {</span>
<a href="#l82.107"></a><span id="l82.107" class="difflineplus">+  mark_action(&quot;messageInjection&quot;, &quot;trashing messages&quot;,</span>
<a href="#l82.108"></a><span id="l82.108" class="difflineplus">+              aSynMessageSet.msgHdrList);</span>
<a href="#l82.109"></a><span id="l82.109" class="difflineplus">+  return async_run({func: function () {</span>
<a href="#l82.110"></a><span id="l82.110" class="difflineplus">+      for (let [folder, xpcomHdrArray] in</span>
<a href="#l82.111"></a><span id="l82.111" class="difflineplus">+           aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l82.112"></a><span id="l82.112" class="difflineplus">+        mark_action(&quot;messageInjection&quot;, &quot;trashing messages in folder&quot;,</span>
<a href="#l82.113"></a><span id="l82.113" class="difflineplus">+                    [folder]);</span>
<a href="#l82.114"></a><span id="l82.114" class="difflineplus">+        folder.deleteMessages(xpcomHdrArray, null, false, true,</span>
<a href="#l82.115"></a><span id="l82.115" class="difflineplus">+                              asyncCopyListener,</span>
<a href="#l82.116"></a><span id="l82.116" class="difflineplus">+                              /* do not allow undo, currently leaks */ false);</span>
<a href="#l82.117"></a><span id="l82.117" class="difflineplus">+        yield false;</span>
<a href="#l82.118"></a><span id="l82.118" class="difflineplus">+      }</span>
<a href="#l82.119"></a><span id="l82.119" class="difflineplus">+    },</span>
<a href="#l82.120"></a><span id="l82.120" class="difflineplus">+  });</span>
<a href="#l82.121"></a><span id="l82.121" class="difflineplus">+}</span>
<a href="#l82.122"></a><span id="l82.122"> </span>
<a href="#l82.123"></a><span id="l82.123" class="difflineminus">-  // SyntheticMessageSet case</span>
<a href="#l82.124"></a><span id="l82.124" class="difflineminus">-  if (synMessages[0].synMessages) {</span>
<a href="#l82.125"></a><span id="l82.125" class="difflineminus">-    let messageSet = synMessages[0];</span>
<a href="#l82.126"></a><span id="l82.126" class="difflineminus">-    // because synthetic message sets</span>
<a href="#l82.127"></a><span id="l82.127" class="difflineminus">-    return async_run({func: function () {</span>
<a href="#l82.128"></a><span id="l82.128" class="difflineminus">-        for (let [folder, xpcomHdrArray] in</span>
<a href="#l82.129"></a><span id="l82.129" class="difflineminus">-             messageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l82.130"></a><span id="l82.130" class="difflineminus">-          folder.deleteMessages(xpcomHdrArray, null, false, true,</span>
<a href="#l82.131"></a><span id="l82.131" class="difflineminus">-                                asyncCopyListener, true);</span>
<a href="#l82.132"></a><span id="l82.132" class="difflineminus">-          yield false;</span>
<a href="#l82.133"></a><span id="l82.133" class="difflineminus">-        }</span>
<a href="#l82.134"></a><span id="l82.134" class="difflineminus">-      },</span>
<a href="#l82.135"></a><span id="l82.135" class="difflineminus">-    });</span>
<a href="#l82.136"></a><span id="l82.136" class="difflineplus">+/**</span>
<a href="#l82.137"></a><span id="l82.137" class="difflineplus">+ * Delete all of the messages in a SyntheticMessageSet like the user performed a</span>
<a href="#l82.138"></a><span id="l82.138" class="difflineplus">+ *  shift-delete (or if the messages were already in the trash).</span>
<a href="#l82.139"></a><span id="l82.139" class="difflineplus">+ *</span>
<a href="#l82.140"></a><span id="l82.140" class="difflineplus">+ * This is actually a synchronous operation.  I'm surprised too.</span>
<a href="#l82.141"></a><span id="l82.141" class="difflineplus">+ *</span>
<a href="#l82.142"></a><span id="l82.142" class="difflineplus">+ * @param aSynMessageSet The set of messages to delete.  The messages do not all</span>
<a href="#l82.143"></a><span id="l82.143" class="difflineplus">+ *     have to be in the same folder, but we have to delete them folder by</span>
<a href="#l82.144"></a><span id="l82.144" class="difflineplus">+ *     folder if they are not.</span>
<a href="#l82.145"></a><span id="l82.145" class="difflineplus">+ */</span>
<a href="#l82.146"></a><span id="l82.146" class="difflineplus">+function async_delete_messages(aSynMessageSet) {</span>
<a href="#l82.147"></a><span id="l82.147" class="difflineplus">+  mark_action(&quot;messageInjection&quot;, &quot;deleting messages&quot;,</span>
<a href="#l82.148"></a><span id="l82.148" class="difflineplus">+              aSynMessageSet.msgHdrList);</span>
<a href="#l82.149"></a><span id="l82.149" class="difflineplus">+  for (let [folder, xpcomHdrArray] in</span>
<a href="#l82.150"></a><span id="l82.150" class="difflineplus">+       aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l82.151"></a><span id="l82.151" class="difflineplus">+    mark_action(&quot;messageInjection&quot;, &quot;deleting messages in folder&quot;,</span>
<a href="#l82.152"></a><span id="l82.152" class="difflineplus">+                [folder]);</span>
<a href="#l82.153"></a><span id="l82.153" class="difflineplus">+    folder.deleteMessages(xpcomHdrArray, null,</span>
<a href="#l82.154"></a><span id="l82.154" class="difflineplus">+                          /* delete storage */ true,</span>
<a href="#l82.155"></a><span id="l82.155" class="difflineplus">+                          /* is move? */ false,</span>
<a href="#l82.156"></a><span id="l82.156" class="difflineplus">+                          asyncCopyListener,</span>
<a href="#l82.157"></a><span id="l82.157" class="difflineplus">+                          /* do not allow undo, currently leaks */ false);</span>
<a href="#l82.158"></a><span id="l82.158">   }</span>
<a href="#l82.159"></a><span id="l82.159" class="difflineminus">-  // a list of synthetic messages case</span>
<a href="#l82.160"></a><span id="l82.160" class="difflineminus">-  else {</span>
<a href="#l82.161"></a><span id="l82.161" class="difflineminus">-    let msgDatabase = gTestFolder.msgDatabase;</span>
<a href="#l82.162"></a><span id="l82.162" class="difflineminus">-    let hdrArr = Cc[&quot;@mozilla.org/array;1&quot;].createInstance(Ci.nsIMutableArray);</span>
<a href="#l82.163"></a><span id="l82.163" class="difflineminus">-    synMessages.forEach(function (synMsg) {</span>
<a href="#l82.164"></a><span id="l82.164" class="difflineminus">-      hdrArr.appendElement(msgDatabase.getMsgHdrForMessageID(synMsg.messageId),</span>
<a href="#l82.165"></a><span id="l82.165" class="difflineminus">-                           false);</span>
<a href="#l82.166"></a><span id="l82.166" class="difflineminus">-    });</span>
<a href="#l82.167"></a><span id="l82.167" class="difflineminus">-    gTestFolder.deleteMessages(hdrArr, null, false, true, asyncCopyListener,</span>
<a href="#l82.168"></a><span id="l82.168" class="difflineminus">-                               true);</span>
<a href="#l82.169"></a><span id="l82.169" class="difflineminus">-    return false;</span>
<a href="#l82.170"></a><span id="l82.170" class="difflineminus">-  }</span>
<a href="#l82.171"></a><span id="l82.171" class="difflineplus">+  return true;</span>
<a href="#l82.172"></a><span id="l82.172"> }</span>
<a href="#l82.173"></a><span id="l82.173"> </span>
<a href="#l82.174"></a><span id="l82.174"> </span>
<a href="#l82.175"></a><span id="l82.175"> var asyncGeneratorStack = [];</span>
<a href="#l82.176"></a><span id="l82.176"> </span>
<a href="#l82.177"></a><span id="l82.177"> /**</span>
<a href="#l82.178"></a><span id="l82.178">  * Run a function that may or may not be a generator.  All functions, generator</span>
<a href="#l82.179"></a><span id="l82.179">  *  or not, must return false if they do not want the async_driver to run the</span>
<a href="#l82.180"></a><span id="l82.180" class="difflineat">@@ -107,17 +154,21 @@ var asyncGeneratorStack = [];</span>
<a href="#l82.181"></a><span id="l82.181">  *  yield async_run({func: a_normal_function});</span>
<a href="#l82.182"></a><span id="l82.182">  *  yield async_run({func: a_generator_function});</span>
<a href="#l82.183"></a><span id="l82.183">  *  yield async_run({dis: Foo, func: Foo.func, args: [1, 2, 3]});</span>
<a href="#l82.184"></a><span id="l82.184">  */</span>
<a href="#l82.185"></a><span id="l82.185"> function async_run(aArgs) {</span>
<a href="#l82.186"></a><span id="l82.186">   let result = aArgs.func.apply(aArgs.dis || null, aArgs.args || []);</span>
<a href="#l82.187"></a><span id="l82.187">   if (result &amp;&amp; result.next) {</span>
<a href="#l82.188"></a><span id="l82.188">     asyncGeneratorStack.push([result, aArgs.func.name]);</span>
<a href="#l82.189"></a><span id="l82.189" class="difflineminus">-    return _async_driver();</span>
<a href="#l82.190"></a><span id="l82.190" class="difflineplus">+    // Use the timer variant in case the asynchronous sub-call is able to run</span>
<a href="#l82.191"></a><span id="l82.191" class="difflineplus">+    //  to completion.  If we didn't do this, we might end up trying to re-call</span>
<a href="#l82.192"></a><span id="l82.192" class="difflineplus">+    //  into the same generator that is currently active.  We can obviously</span>
<a href="#l82.193"></a><span id="l82.193" class="difflineplus">+    //  make _async_driver more clever to deal with this if we have a reason.</span>
<a href="#l82.194"></a><span id="l82.194" class="difflineplus">+    return async_driver();</span>
<a href="#l82.195"></a><span id="l82.195">   }</span>
<a href="#l82.196"></a><span id="l82.196">   else {</span>
<a href="#l82.197"></a><span id="l82.197">     if (result === undefined)</span>
<a href="#l82.198"></a><span id="l82.198">       return true;</span>
<a href="#l82.199"></a><span id="l82.199">     else</span>
<a href="#l82.200"></a><span id="l82.200">       return result;</span>
<a href="#l82.201"></a><span id="l82.201">   }</span>
<a href="#l82.202"></a><span id="l82.202"> }</span>
<a href="#l82.203"></a><span id="l82.203" class="difflineat">@@ -130,39 +181,46 @@ function async_run(aArgs) {</span>
<a href="#l82.204"></a><span id="l82.204">  * Note: This function actually schedules the real driver to run after a</span>
<a href="#l82.205"></a><span id="l82.205">  *  timeout. This is to ensure that if you call us from a notification event</span>
<a href="#l82.206"></a><span id="l82.206">  *  that all the other things getting notified get a chance to do their work</span>
<a href="#l82.207"></a><span id="l82.207">  *  before we actually continue execution.  It also keeps our stack traces</span>
<a href="#l82.208"></a><span id="l82.208">  *  cleaner.</span>
<a href="#l82.209"></a><span id="l82.209">  */</span>
<a href="#l82.210"></a><span id="l82.210"> function async_driver() {</span>
<a href="#l82.211"></a><span id="l82.211">   do_timeout_function(0, _async_driver);</span>
<a href="#l82.212"></a><span id="l82.212" class="difflineplus">+  return false;</span>
<a href="#l82.213"></a><span id="l82.213"> }</span>
<a href="#l82.214"></a><span id="l82.214"> </span>
<a href="#l82.215"></a><span id="l82.215"> // the real driver!</span>
<a href="#l82.216"></a><span id="l82.216"> function _async_driver() {</span>
<a href="#l82.217"></a><span id="l82.217">   let curGenerator;</span>
<a href="#l82.218"></a><span id="l82.218">   while (asyncGeneratorStack.length) {</span>
<a href="#l82.219"></a><span id="l82.219">     curGenerator = asyncGeneratorStack[asyncGeneratorStack.length-1][0];</span>
<a href="#l82.220"></a><span id="l82.220">     try {</span>
<a href="#l82.221"></a><span id="l82.221">       while (curGenerator.next()) {</span>
<a href="#l82.222"></a><span id="l82.222">       }</span>
<a href="#l82.223"></a><span id="l82.223">       return false;</span>
<a href="#l82.224"></a><span id="l82.224">     }</span>
<a href="#l82.225"></a><span id="l82.225">     catch (ex) {</span>
<a href="#l82.226"></a><span id="l82.226">       if (ex != StopIteration) {</span>
<a href="#l82.227"></a><span id="l82.227" class="difflineplus">+        let asyncStack = [];</span>
<a href="#l82.228"></a><span id="l82.228">         dump(&quot;*******************************************\n&quot;);</span>
<a href="#l82.229"></a><span id="l82.229">         dump(&quot;Generator explosion!\n&quot;);</span>
<a href="#l82.230"></a><span id="l82.230">         dump(&quot;Unhappiness at: &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;\n&quot;);</span>
<a href="#l82.231"></a><span id="l82.231">         dump(&quot;Because: &quot; + ex + &quot;\n&quot;);</span>
<a href="#l82.232"></a><span id="l82.232" class="difflineplus">+        dump(&quot;Stack:\n  &quot; + ex.stack.replace(&quot;\n&quot;, &quot;\n  &quot;, &quot;g&quot;) + &quot;\n&quot;);</span>
<a href="#l82.233"></a><span id="l82.233">         dump(&quot;**** Async Generator Stack source functions:\n&quot;);</span>
<a href="#l82.234"></a><span id="l82.234">         for (let i = asyncGeneratorStack.length - 1; i &gt;= 0; i--) {</span>
<a href="#l82.235"></a><span id="l82.235">           dump(&quot;  &quot; + asyncGeneratorStack[i][1] + &quot;\n&quot;);</span>
<a href="#l82.236"></a><span id="l82.236" class="difflineplus">+          asyncStack.push(asyncGeneratorStack[i][1]);</span>
<a href="#l82.237"></a><span id="l82.237">         }</span>
<a href="#l82.238"></a><span id="l82.238" class="difflineminus">-        do_throw(ex);</span>
<a href="#l82.239"></a><span id="l82.239" class="difflineplus">+        dump(&quot;*********\n&quot;);</span>
<a href="#l82.240"></a><span id="l82.240" class="difflineplus">+        logException(ex);</span>
<a href="#l82.241"></a><span id="l82.241" class="difflineplus">+        mark_failure([&quot;Generator explosion. ex:&quot;, ex, &quot;async stack&quot;,</span>
<a href="#l82.242"></a><span id="l82.242" class="difflineplus">+                      asyncStack]);</span>
<a href="#l82.243"></a><span id="l82.243">       }</span>
<a href="#l82.244"></a><span id="l82.244">       asyncGeneratorStack.pop();</span>
<a href="#l82.245"></a><span id="l82.245">     }</span>
<a href="#l82.246"></a><span id="l82.246">   }</span>
<a href="#l82.247"></a><span id="l82.247">   return true;</span>
<a href="#l82.248"></a><span id="l82.248"> }</span>
<a href="#l82.249"></a><span id="l82.249"> </span>
<a href="#l82.250"></a><span id="l82.250"> var ASYNC_TEST_RUNNER_HELPERS = [];</span>
<a href="#l82.251"></a><span id="l82.251" class="difflineat">@@ -174,16 +232,24 @@ var ASYNC_TEST_RUNNER_HELPERS = [];</span>
<a href="#l82.252"></a><span id="l82.252">  * @param aHelper A helper object which may have the following functions:</span>
<a href="#l82.253"></a><span id="l82.253">  * - postTest: This gets called after each test completes.</span>
<a href="#l82.254"></a><span id="l82.254">  * - onTimeout: This gets called if a test times out.</span>
<a href="#l82.255"></a><span id="l82.255">  */</span>
<a href="#l82.256"></a><span id="l82.256"> function async_test_runner_register_helper(aHelper) {</span>
<a href="#l82.257"></a><span id="l82.257">   ASYNC_TEST_RUNNER_HELPERS.push(aHelper);</span>
<a href="#l82.258"></a><span id="l82.258"> }</span>
<a href="#l82.259"></a><span id="l82.259"> </span>
<a href="#l82.260"></a><span id="l82.260" class="difflineplus">+/**</span>
<a href="#l82.261"></a><span id="l82.261" class="difflineplus">+ * Functions to run after the last test has completed.</span>
<a href="#l82.262"></a><span id="l82.262" class="difflineplus">+ */</span>
<a href="#l82.263"></a><span id="l82.263" class="difflineplus">+var ASYNC_TEST_RUNNER_FINAL_CLEANUP_HELPERS = [];</span>
<a href="#l82.264"></a><span id="l82.264" class="difflineplus">+function async_test_runner_register_final_cleanup_helper(aHelper) {</span>
<a href="#l82.265"></a><span id="l82.265" class="difflineplus">+  ASYNC_TEST_RUNNER_FINAL_CLEANUP_HELPERS.push(aHelper);</span>
<a href="#l82.266"></a><span id="l82.266" class="difflineplus">+}</span>
<a href="#l82.267"></a><span id="l82.267" class="difflineplus">+</span>
<a href="#l82.268"></a><span id="l82.268"> function _async_test_runner_postTest() {</span>
<a href="#l82.269"></a><span id="l82.269">   for each (let [, helper] in Iterator(ASYNC_TEST_RUNNER_HELPERS)) {</span>
<a href="#l82.270"></a><span id="l82.270">     if (helper.postTest)</span>
<a href="#l82.271"></a><span id="l82.271">       helper.postTest();</span>
<a href="#l82.272"></a><span id="l82.272">   }</span>
<a href="#l82.273"></a><span id="l82.273"> }</span>
<a href="#l82.274"></a><span id="l82.274"> </span>
<a href="#l82.275"></a><span id="l82.275"> function _async_test_runner_timeout() {</span>
<a href="#l82.276"></a><span id="l82.276" class="difflineat">@@ -241,25 +307,83 @@ function _async_test_runner(aTests) {</span>
<a href="#l82.277"></a><span id="l82.277">             paramDesc = parameter.name;</span>
<a href="#l82.278"></a><span id="l82.278">             args = [parameter];</span>
<a href="#l82.279"></a><span id="l82.279">           }</span>
<a href="#l82.280"></a><span id="l82.280">         }</span>
<a href="#l82.281"></a><span id="l82.281">         else {</span>
<a href="#l82.282"></a><span id="l82.282">           paramDesc = parameter.toString();</span>
<a href="#l82.283"></a><span id="l82.283">           args = [parameter];</span>
<a href="#l82.284"></a><span id="l82.284">         }</span>
<a href="#l82.285"></a><span id="l82.285" class="difflineminus">-        dump(&quot;=== Running test: &quot; + testFunc.name + &quot; Parameter: &quot; +</span>
<a href="#l82.286"></a><span id="l82.286" class="difflineminus">-             paramDesc + &quot;\n&quot;);</span>
<a href="#l82.287"></a><span id="l82.287" class="difflineplus">+        mark_test_start(testFunc.name, paramDesc);</span>
<a href="#l82.288"></a><span id="l82.288">         yield async_run({func: testFunc, args: args});</span>
<a href="#l82.289"></a><span id="l82.289">         _async_test_runner_postTest();</span>
<a href="#l82.290"></a><span id="l82.290" class="difflineplus">+        mark_test_end();</span>
<a href="#l82.291"></a><span id="l82.291">       }</span>
<a href="#l82.292"></a><span id="l82.292"> </span>
<a href="#l82.293"></a><span id="l82.293">     }</span>
<a href="#l82.294"></a><span id="l82.294">     else {</span>
<a href="#l82.295"></a><span id="l82.295" class="difflineminus">-      dump(&quot;=== Running test: &quot; + test.name + &quot;\n&quot;);</span>
<a href="#l82.296"></a><span id="l82.296" class="difflineplus">+      mark_test_start(test.name);</span>
<a href="#l82.297"></a><span id="l82.297">       yield async_run({func: test});</span>
<a href="#l82.298"></a><span id="l82.298">       _async_test_runner_postTest();</span>
<a href="#l82.299"></a><span id="l82.299" class="difflineplus">+      mark_test_end();</span>
<a href="#l82.300"></a><span id="l82.300">     }</span>
<a href="#l82.301"></a><span id="l82.301">   }</span>
<a href="#l82.302"></a><span id="l82.302"> </span>
<a href="#l82.303"></a><span id="l82.303">   dump(&quot;=== (Done With Tests)\n&quot;);</span>
<a href="#l82.304"></a><span id="l82.304" class="difflineplus">+</span>
<a href="#l82.305"></a><span id="l82.305" class="difflineplus">+  for each (let [, cleanupHelper] in</span>
<a href="#l82.306"></a><span id="l82.306" class="difflineplus">+            Iterator(ASYNC_TEST_RUNNER_FINAL_CLEANUP_HELPERS)) {</span>
<a href="#l82.307"></a><span id="l82.307" class="difflineplus">+    try {</span>
<a href="#l82.308"></a><span id="l82.308" class="difflineplus">+      cleanupHelper();</span>
<a href="#l82.309"></a><span id="l82.309" class="difflineplus">+    }</span>
<a href="#l82.310"></a><span id="l82.310" class="difflineplus">+    catch (ex) {</span>
<a href="#l82.311"></a><span id="l82.311" class="difflineplus">+      mark_failure([&quot;Problem during asyncTestUtils cleanup helper&quot;,</span>
<a href="#l82.312"></a><span id="l82.312" class="difflineplus">+                     cleanupHelper.name, &quot;exception:&quot;, ex]);</span>
<a href="#l82.313"></a><span id="l82.313" class="difflineplus">+    }</span>
<a href="#l82.314"></a><span id="l82.314" class="difflineplus">+  }</span>
<a href="#l82.315"></a><span id="l82.315" class="difflineplus">+</span>
<a href="#l82.316"></a><span id="l82.316" class="difflineplus">+  mark_all_tests_run();</span>
<a href="#l82.317"></a><span id="l82.317" class="difflineplus">+</span>
<a href="#l82.318"></a><span id="l82.318">   do_test_finished();</span>
<a href="#l82.319"></a><span id="l82.319"> }</span>
<a href="#l82.320"></a><span id="l82.320" class="difflineplus">+</span>
<a href="#l82.321"></a><span id="l82.321" class="difflineplus">+var _async_promises = [];</span>
<a href="#l82.322"></a><span id="l82.322" class="difflineplus">+var _waiting_for_async_promises = false;</span>
<a href="#l82.323"></a><span id="l82.323" class="difflineplus">+/**</span>
<a href="#l82.324"></a><span id="l82.324" class="difflineplus">+ * Create an asynchronous promise, which is basically a 'future' where we don't</span>
<a href="#l82.325"></a><span id="l82.325" class="difflineplus">+ *  care about the result value, but we do care about the side-effects.</span>
<a href="#l82.326"></a><span id="l82.326" class="difflineplus">+ * This allows code that does not need to run-to-completion at the time the user</span>
<a href="#l82.327"></a><span id="l82.327" class="difflineplus">+ *  calls it to allow code that depends on it having run to explicitly wait for</span>
<a href="#l82.328"></a><span id="l82.328" class="difflineplus">+ *  its completion.  Rather than bother with actually exposing the promises, we</span>
<a href="#l82.329"></a><span id="l82.329" class="difflineplus">+ *  just have code with such dependencies to call |wait_for_async_promises| to</span>
<a href="#l82.330"></a><span id="l82.330" class="difflineplus">+ *  ensure that all promises have been fulfilled.</span>
<a href="#l82.331"></a><span id="l82.331" class="difflineplus">+ *</span>
<a href="#l82.332"></a><span id="l82.332" class="difflineplus">+ * For a realistic use-case, this allows messageInjection.js' make_empty_folder</span>
<a href="#l82.333"></a><span id="l82.333" class="difflineplus">+ *  to perform an asynchronous operation (the creation of a folder) but not have</span>
<a href="#l82.334"></a><span id="l82.334" class="difflineplus">+ *  to return an asynchronous result indicator.  This simplifies calling code</span>
<a href="#l82.335"></a><span id="l82.335" class="difflineplus">+ *  and avoids complicating the functions that combine make_empty_folder with</span>
<a href="#l82.336"></a><span id="l82.336" class="difflineplus">+ *  other functionality.  The message injection code is where we end up waiting</span>
<a href="#l82.337"></a><span id="l82.337" class="difflineplus">+ *  on the promises (if required).</span>
<a href="#l82.338"></a><span id="l82.338" class="difflineplus">+ */</span>
<a href="#l82.339"></a><span id="l82.339" class="difflineplus">+function async_create_promise() {</span>
<a href="#l82.340"></a><span id="l82.340" class="difflineplus">+  function promise_completed() {</span>
<a href="#l82.341"></a><span id="l82.341" class="difflineplus">+    _async_promises.splice(_async_promises.indexOf(promise_completed), 1);</span>
<a href="#l82.342"></a><span id="l82.342" class="difflineplus">+    if (_waiting_for_async_promises) {</span>
<a href="#l82.343"></a><span id="l82.343" class="difflineplus">+      async_driver();</span>
<a href="#l82.344"></a><span id="l82.344" class="difflineplus">+      _waiting_for_async_promises = false;</span>
<a href="#l82.345"></a><span id="l82.345" class="difflineplus">+    }</span>
<a href="#l82.346"></a><span id="l82.346" class="difflineplus">+  }</span>
<a href="#l82.347"></a><span id="l82.347" class="difflineplus">+  _async_promises.push(promise_completed);</span>
<a href="#l82.348"></a><span id="l82.348" class="difflineplus">+</span>
<a href="#l82.349"></a><span id="l82.349" class="difflineplus">+  return promise_completed;</span>
<a href="#l82.350"></a><span id="l82.350" class="difflineplus">+}</span>
<a href="#l82.351"></a><span id="l82.351" class="difflineplus">+</span>
<a href="#l82.352"></a><span id="l82.352" class="difflineplus">+/**</span>
<a href="#l82.353"></a><span id="l82.353" class="difflineplus">+ * Wait for all asynchronous promises to have been fulfilled.</span>
<a href="#l82.354"></a><span id="l82.354" class="difflineplus">+ */</span>
<a href="#l82.355"></a><span id="l82.355" class="difflineplus">+function wait_for_async_promises() {</span>
<a href="#l82.356"></a><span id="l82.356" class="difflineplus">+  if (_async_promises.length) {</span>
<a href="#l82.357"></a><span id="l82.357" class="difflineplus">+    _waiting_for_async_promises = true;</span>
<a href="#l82.358"></a><span id="l82.358" class="difflineplus">+    return false;</span>
<a href="#l82.359"></a><span id="l82.359" class="difflineplus">+  }</span>
<a href="#l82.360"></a><span id="l82.360" class="difflineplus">+</span>
<a href="#l82.361"></a><span id="l82.361" class="difflineplus">+  return true;</span>
<a href="#l82.362"></a><span id="l82.362" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l83.1"></a><span id="l83.1">new file mode 100644</span>
<a href="#l83.2"></a><span id="l83.2" class="difflineminus">--- /dev/null</span>
<a href="#l83.3"></a><span id="l83.3" class="difflineplus">+++ b/mailnews/test/resources/logHelper.js</span>
<a href="#l83.4"></a><span id="l83.4" class="difflineat">@@ -0,0 +1,570 @@</span>
<a href="#l83.5"></a><span id="l83.5" class="difflineplus">+/*</span>
<a href="#l83.6"></a><span id="l83.6" class="difflineplus">+ * Makes everything awesome if you are Andrew.  Some day it will make everything</span>
<a href="#l83.7"></a><span id="l83.7" class="difflineplus">+ *  awesome if you are not awesome too.</span>
<a href="#l83.8"></a><span id="l83.8" class="difflineplus">+ *</span>
<a href="#l83.9"></a><span id="l83.9" class="difflineplus">+ * Right now the most meaningful thing to know is that if XPCOM failures happen</span>
<a href="#l83.10"></a><span id="l83.10" class="difflineplus">+ *  (and get reported to the error console), this will induce a unit test</span>
<a href="#l83.11"></a><span id="l83.11" class="difflineplus">+ *  failure.  You should think this is awesome no matter whether you are Andrew</span>
<a href="#l83.12"></a><span id="l83.12" class="difflineplus">+ *  or not.</span>
<a href="#l83.13"></a><span id="l83.13" class="difflineplus">+ */</span>
<a href="#l83.14"></a><span id="l83.14" class="difflineplus">+</span>
<a href="#l83.15"></a><span id="l83.15" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/log4moz.js&quot;);</span>
<a href="#l83.16"></a><span id="l83.16" class="difflineplus">+// We need loadFileToString and honestly this is no crazier a dependency than</span>
<a href="#l83.17"></a><span id="l83.17" class="difflineplus">+//  gloda's Log4Moz</span>
<a href="#l83.18"></a><span id="l83.18" class="difflineplus">+Components.utils.import(&quot;resource://app/modules/gloda/utils.js&quot;);</span>
<a href="#l83.19"></a><span id="l83.19" class="difflineplus">+</span>
<a href="#l83.20"></a><span id="l83.20" class="difflineplus">+var _testLogger;</span>
<a href="#l83.21"></a><span id="l83.21" class="difflineplus">+var _xpcshellLogger;</span>
<a href="#l83.22"></a><span id="l83.22" class="difflineplus">+var _testLoggerContexts = [];</span>
<a href="#l83.23"></a><span id="l83.23" class="difflineplus">+var _testLoggerActiveContext;</span>
<a href="#l83.24"></a><span id="l83.24" class="difflineplus">+</span>
<a href="#l83.25"></a><span id="l83.25" class="difflineplus">+var _logHelperInterestedListeners = false;</span>
<a href="#l83.26"></a><span id="l83.26" class="difflineplus">+</span>
<a href="#l83.27"></a><span id="l83.27" class="difflineplus">+/**</span>
<a href="#l83.28"></a><span id="l83.28" class="difflineplus">+ * Let other test helping code decide whether to register for potentially</span>
<a href="#l83.29"></a><span id="l83.29" class="difflineplus">+ *  expensive notifications based on whether anyone can even hear those</span>
<a href="#l83.30"></a><span id="l83.30" class="difflineplus">+ *  results.</span>
<a href="#l83.31"></a><span id="l83.31" class="difflineplus">+ */</span>
<a href="#l83.32"></a><span id="l83.32" class="difflineplus">+function logHelperHasInterestedListeners() {</span>
<a href="#l83.33"></a><span id="l83.33" class="difflineplus">+  return _logHelperInterestedListeners;</span>
<a href="#l83.34"></a><span id="l83.34" class="difflineplus">+}</span>
<a href="#l83.35"></a><span id="l83.35" class="difflineplus">+</span>
<a href="#l83.36"></a><span id="l83.36" class="difflineplus">+/**</span>
<a href="#l83.37"></a><span id="l83.37" class="difflineplus">+ * Tunnel nsIScriptErrors that show up on the error console to Log4Moz.  We could</span>
<a href="#l83.38"></a><span id="l83.38" class="difflineplus">+ *  send everything but I think only script errors are likely of much concern.</span>
<a href="#l83.39"></a><span id="l83.39" class="difflineplus">+ *  Also, this nicely avoids infinite recursions no matter what you do since</span>
<a href="#l83.40"></a><span id="l83.40" class="difflineplus">+ *  what we publish is not going to end up as an nsIScriptError.</span>
<a href="#l83.41"></a><span id="l83.41" class="difflineplus">+ *</span>
<a href="#l83.42"></a><span id="l83.42" class="difflineplus">+ * This is based on my (asuth') exmmad extension.</span>
<a href="#l83.43"></a><span id="l83.43" class="difflineplus">+ */</span>
<a href="#l83.44"></a><span id="l83.44" class="difflineplus">+let _errorConsoleTunnel = {</span>
<a href="#l83.45"></a><span id="l83.45" class="difflineplus">+  initialize: function () {</span>
<a href="#l83.46"></a><span id="l83.46" class="difflineplus">+    this.consoleService = Cc[&quot;@mozilla.org/consoleservice;1&quot;]</span>
<a href="#l83.47"></a><span id="l83.47" class="difflineplus">+                            .getService(Ci.nsIConsoleService);</span>
<a href="#l83.48"></a><span id="l83.48" class="difflineplus">+    this.consoleService.registerListener(this);</span>
<a href="#l83.49"></a><span id="l83.49" class="difflineplus">+</span>
<a href="#l83.50"></a><span id="l83.50" class="difflineplus">+    // we need to unregister our listener at shutdown if we don't want explosions</span>
<a href="#l83.51"></a><span id="l83.51" class="difflineplus">+    this.observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;]</span>
<a href="#l83.52"></a><span id="l83.52" class="difflineplus">+                             .getService(Ci.nsIObserverService);</span>
<a href="#l83.53"></a><span id="l83.53" class="difflineplus">+    this.observerService.addObserver(this, &quot;quit-application&quot;, false);</span>
<a href="#l83.54"></a><span id="l83.54" class="difflineplus">+  },</span>
<a href="#l83.55"></a><span id="l83.55" class="difflineplus">+</span>
<a href="#l83.56"></a><span id="l83.56" class="difflineplus">+  shutdown: function () {</span>
<a href="#l83.57"></a><span id="l83.57" class="difflineplus">+    this.consoleService.unregisterListener(this);</span>
<a href="#l83.58"></a><span id="l83.58" class="difflineplus">+    this.observerService.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l83.59"></a><span id="l83.59" class="difflineplus">+    this.consoleService = null;</span>
<a href="#l83.60"></a><span id="l83.60" class="difflineplus">+    this.observerService = null;</span>
<a href="#l83.61"></a><span id="l83.61" class="difflineplus">+  },</span>
<a href="#l83.62"></a><span id="l83.62" class="difflineplus">+</span>
<a href="#l83.63"></a><span id="l83.63" class="difflineplus">+  observe: function (aMessage, aTopic, aData) {</span>
<a href="#l83.64"></a><span id="l83.64" class="difflineplus">+    if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l83.65"></a><span id="l83.65" class="difflineplus">+      this.shutdown();</span>
<a href="#l83.66"></a><span id="l83.66" class="difflineplus">+      return;</span>
<a href="#l83.67"></a><span id="l83.67" class="difflineplus">+    }</span>
<a href="#l83.68"></a><span id="l83.68" class="difflineplus">+</span>
<a href="#l83.69"></a><span id="l83.69" class="difflineplus">+    // meh, let's just use mark_failure for now.</span>
<a href="#l83.70"></a><span id="l83.70" class="difflineplus">+    // and let's avoid feedback loops (happens in mozmill)</span>
<a href="#l83.71"></a><span id="l83.71" class="difflineplus">+    if ((aMessage instanceof Components.interfaces.nsIScriptError) &amp;&amp;</span>
<a href="#l83.72"></a><span id="l83.72" class="difflineplus">+        (aMessage.errorMessage.indexOf(&quot;Error console says&quot;) == -1))</span>
<a href="#l83.73"></a><span id="l83.73" class="difflineplus">+      mark_failure([&quot;Error console says&quot;, aMessage]);</span>
<a href="#l83.74"></a><span id="l83.74" class="difflineplus">+  }</span>
<a href="#l83.75"></a><span id="l83.75" class="difflineplus">+};</span>
<a href="#l83.76"></a><span id="l83.76" class="difflineplus">+</span>
<a href="#l83.77"></a><span id="l83.77" class="difflineplus">+/**</span>
<a href="#l83.78"></a><span id="l83.78" class="difflineplus">+ * Initialize logging.  The idea is to:</span>
<a href="#l83.79"></a><span id="l83.79" class="difflineplus">+ *</span>
<a href="#l83.80"></a><span id="l83.80" class="difflineplus">+ * - Always create a dump appender on 'test'.</span>
<a href="#l83.81"></a><span id="l83.81" class="difflineplus">+ * - Check if there's a desire to use a logsploder style network connection</span>
<a href="#l83.82"></a><span id="l83.82" class="difflineplus">+ *    based on the presence of an appropriate file in 'tmp'.  This should be</span>
<a href="#l83.83"></a><span id="l83.83" class="difflineplus">+ *    harmless in cases where there is not such a file.</span>
<a href="#l83.84"></a><span id="l83.84" class="difflineplus">+ *</span>
<a href="#l83.85"></a><span id="l83.85" class="difflineplus">+ * We will wrap the interesting xpcshell functions if we believe there is an</span>
<a href="#l83.86"></a><span id="l83.86" class="difflineplus">+ *  endpoint that cares about these things (such as logsploder).</span>
<a href="#l83.87"></a><span id="l83.87" class="difflineplus">+ */</span>
<a href="#l83.88"></a><span id="l83.88" class="difflineplus">+function _init_log_helper() {</span>
<a href="#l83.89"></a><span id="l83.89" class="difflineplus">+  let rootLogger = Log4Moz.repository.rootLogger;</span>
<a href="#l83.90"></a><span id="l83.90" class="difflineplus">+  rootLogger.level = Log4Moz.Level.All;</span>
<a href="#l83.91"></a><span id="l83.91" class="difflineplus">+</span>
<a href="#l83.92"></a><span id="l83.92" class="difflineplus">+  // - dump on test</span>
<a href="#l83.93"></a><span id="l83.93" class="difflineplus">+  _testLogger = Log4Moz.repository.getLogger(&quot;test.test&quot;);</span>
<a href="#l83.94"></a><span id="l83.94" class="difflineplus">+  let formatter = new Log4Moz.BasicFormatter();</span>
<a href="#l83.95"></a><span id="l83.95" class="difflineplus">+  let dapp = new Log4Moz.DumpAppender(formatter);</span>
<a href="#l83.96"></a><span id="l83.96" class="difflineplus">+  dapp.level = Log4Moz.Level.All;</span>
<a href="#l83.97"></a><span id="l83.97" class="difflineplus">+  _testLogger.addAppender(dapp);</span>
<a href="#l83.98"></a><span id="l83.98" class="difflineplus">+</span>
<a href="#l83.99"></a><span id="l83.99" class="difflineplus">+  // - silent category for xpcshell stuff that already gets dump()ed</span>
<a href="#l83.100"></a><span id="l83.100" class="difflineplus">+  _xpcshellLogger = Log4Moz.repository.getLogger(&quot;xpcshell&quot;);</span>
<a href="#l83.101"></a><span id="l83.101" class="difflineplus">+</span>
<a href="#l83.102"></a><span id="l83.102" class="difflineplus">+  // - logsploder</span>
<a href="#l83.103"></a><span id="l83.103" class="difflineplus">+  let file = Cc[&quot;@mozilla.org/file/directory_service;1&quot;]</span>
<a href="#l83.104"></a><span id="l83.104" class="difflineplus">+               .getService(Ci.nsIProperties)</span>
<a href="#l83.105"></a><span id="l83.105" class="difflineplus">+               .get(&quot;TmpD&quot;, Ci.nsIFile);</span>
<a href="#l83.106"></a><span id="l83.106" class="difflineplus">+  file.append(&quot;logsploder.ptr&quot;);</span>
<a href="#l83.107"></a><span id="l83.107" class="difflineplus">+  if (file.exists()) {</span>
<a href="#l83.108"></a><span id="l83.108" class="difflineplus">+    _logHelperInterestedListeners = true;</span>
<a href="#l83.109"></a><span id="l83.109" class="difflineplus">+</span>
<a href="#l83.110"></a><span id="l83.110" class="difflineplus">+    let data = GlodaUtils.loadFileToString(file);</span>
<a href="#l83.111"></a><span id="l83.111" class="difflineplus">+    data = data.trim();</span>
<a href="#l83.112"></a><span id="l83.112" class="difflineplus">+    let [host, port] = data.split(&quot;:&quot;);</span>
<a href="#l83.113"></a><span id="l83.113" class="difflineplus">+    let jf = new Log4Moz.JSONFormatter();</span>
<a href="#l83.114"></a><span id="l83.114" class="difflineplus">+    let sapp = new Log4Moz.SocketAppender(host, Number(port), jf);</span>
<a href="#l83.115"></a><span id="l83.115" class="difflineplus">+    // this goes on the root so it can see all</span>
<a href="#l83.116"></a><span id="l83.116" class="difflineplus">+    rootLogger.addAppender(sapp);</span>
<a href="#l83.117"></a><span id="l83.117" class="difflineplus">+  }</span>
<a href="#l83.118"></a><span id="l83.118" class="difflineplus">+</span>
<a href="#l83.119"></a><span id="l83.119" class="difflineplus">+  // Create a console listener reporting thinger in all cases.  Since XPCOM</span>
<a href="#l83.120"></a><span id="l83.120" class="difflineplus">+  //  failures will show up via the error console, this allows our test to fail</span>
<a href="#l83.121"></a><span id="l83.121" class="difflineplus">+  //  in more situations where we might otherwise silently be cool with bad</span>
<a href="#l83.122"></a><span id="l83.122" class="difflineplus">+  //  things happening.</span>
<a href="#l83.123"></a><span id="l83.123" class="difflineplus">+  _errorConsoleTunnel.initialize();</span>
<a href="#l83.124"></a><span id="l83.124" class="difflineplus">+</span>
<a href="#l83.125"></a><span id="l83.125" class="difflineplus">+  if (_logHelperInterestedListeners) {</span>
<a href="#l83.126"></a><span id="l83.126" class="difflineplus">+    _wrap_xpcshell_functions();</span>
<a href="#l83.127"></a><span id="l83.127" class="difflineplus">+</span>
<a href="#l83.128"></a><span id="l83.128" class="difflineplus">+    // Send a message telling the listeners about the test file being run.</span>
<a href="#l83.129"></a><span id="l83.129" class="difflineplus">+    _xpcshellLogger.info({</span>
<a href="#l83.130"></a><span id="l83.130" class="difflineplus">+      _jsonMe: true,</span>
<a href="#l83.131"></a><span id="l83.131" class="difflineplus">+      _isContext: true,</span>
<a href="#l83.132"></a><span id="l83.132" class="difflineplus">+      _specialContext: &quot;lifecycle&quot;,</span>
<a href="#l83.133"></a><span id="l83.133" class="difflineplus">+      _id: &quot;start&quot;,</span>
<a href="#l83.134"></a><span id="l83.134" class="difflineplus">+      testFile: _TEST_FILE,</span>
<a href="#l83.135"></a><span id="l83.135" class="difflineplus">+    });</span>
<a href="#l83.136"></a><span id="l83.136" class="difflineplus">+  }</span>
<a href="#l83.137"></a><span id="l83.137" class="difflineplus">+}</span>
<a href="#l83.138"></a><span id="l83.138" class="difflineplus">+_init_log_helper();</span>
<a href="#l83.139"></a><span id="l83.139" class="difflineplus">+</span>
<a href="#l83.140"></a><span id="l83.140" class="difflineplus">+function _cleanup_log_helper() {</span>
<a href="#l83.141"></a><span id="l83.141" class="difflineplus">+  let rootLogger = Log4Moz.repository.rootLogger;</span>
<a href="#l83.142"></a><span id="l83.142" class="difflineplus">+  for each (let [, appender] in Iterator(rootLogger.appenders)) {</span>
<a href="#l83.143"></a><span id="l83.143" class="difflineplus">+    if (&quot;closeStream&quot; in appender)</span>
<a href="#l83.144"></a><span id="l83.144" class="difflineplus">+      appender.closeStream();</span>
<a href="#l83.145"></a><span id="l83.145" class="difflineplus">+  }</span>
<a href="#l83.146"></a><span id="l83.146" class="difflineplus">+  rootLogger._appenders = [];</span>
<a href="#l83.147"></a><span id="l83.147" class="difflineplus">+}</span>
<a href="#l83.148"></a><span id="l83.148" class="difflineplus">+</span>
<a href="#l83.149"></a><span id="l83.149" class="difflineplus">+/**</span>
<a href="#l83.150"></a><span id="l83.150" class="difflineplus">+ * Mark the start of a test.  This creates nice console output as well as</span>
<a href="#l83.151"></a><span id="l83.151" class="difflineplus">+ *  setting up logging contexts so that use of other helpers in here like</span>
<a href="#l83.152"></a><span id="l83.152" class="difflineplus">+ *  mark_action get associated with the context.</span>
<a href="#l83.153"></a><span id="l83.153" class="difflineplus">+ *</span>
<a href="#l83.154"></a><span id="l83.154" class="difflineplus">+ * This will likely only be used by the test driver framework, such as</span>
<a href="#l83.155"></a><span id="l83.155" class="difflineplus">+ *  asyncTestUtils.js.  However, |mark_sub_test_start| is for user test code.</span>
<a href="#l83.156"></a><span id="l83.156" class="difflineplus">+ */</span>
<a href="#l83.157"></a><span id="l83.157" class="difflineplus">+function mark_test_start(aName, aParameter, aDepth) {</span>
<a href="#l83.158"></a><span id="l83.158" class="difflineplus">+  if (aDepth == null)</span>
<a href="#l83.159"></a><span id="l83.159" class="difflineplus">+    aDepth = 0;</span>
<a href="#l83.160"></a><span id="l83.160" class="difflineplus">+</span>
<a href="#l83.161"></a><span id="l83.161" class="difflineplus">+  // clear out any existing contexts</span>
<a href="#l83.162"></a><span id="l83.162" class="difflineplus">+  mark_test_end(aDepth);</span>
<a href="#l83.163"></a><span id="l83.163" class="difflineplus">+</span>
<a href="#l83.164"></a><span id="l83.164" class="difflineplus">+  let term = (aDepth == 0) ? &quot;test&quot; : &quot;subtest&quot;;</span>
<a href="#l83.165"></a><span id="l83.165" class="difflineplus">+  _testLoggerActiveContext = _testLogger.newContext({</span>
<a href="#l83.166"></a><span id="l83.166" class="difflineplus">+    type: term,</span>
<a href="#l83.167"></a><span id="l83.167" class="difflineplus">+    name: aName,</span>
<a href="#l83.168"></a><span id="l83.168" class="difflineplus">+    parameter: aParameter</span>
<a href="#l83.169"></a><span id="l83.169" class="difflineplus">+  });</span>
<a href="#l83.170"></a><span id="l83.170" class="difflineplus">+  if (_testLoggerContexts.length) {</span>
<a href="#l83.171"></a><span id="l83.171" class="difflineplus">+    _testLoggerActiveContext._contextDepth = _testLoggerContexts.length;</span>
<a href="#l83.172"></a><span id="l83.172" class="difflineplus">+    _testLoggerActiveContext._contextParentId =</span>
<a href="#l83.173"></a><span id="l83.173" class="difflineplus">+      _testLoggerContexts[_testLoggerContexts.length-1]._id;</span>
<a href="#l83.174"></a><span id="l83.174" class="difflineplus">+  }</span>
<a href="#l83.175"></a><span id="l83.175" class="difflineplus">+  _testLoggerContexts.push(_testLoggerActiveContext);</span>
<a href="#l83.176"></a><span id="l83.176" class="difflineplus">+</span>
<a href="#l83.177"></a><span id="l83.177" class="difflineplus">+  _testLogger.info(_testLoggerActiveContext,</span>
<a href="#l83.178"></a><span id="l83.178" class="difflineplus">+                   &quot;Starting &quot; + term + &quot;: &quot; + aName +</span>
<a href="#l83.179"></a><span id="l83.179" class="difflineplus">+                   (aParameter ? (&quot;, &quot; + aParameter) : &quot;&quot;));</span>
<a href="#l83.180"></a><span id="l83.180" class="difflineplus">+}</span>
<a href="#l83.181"></a><span id="l83.181" class="difflineplus">+</span>
<a href="#l83.182"></a><span id="l83.182" class="difflineplus">+/**</span>
<a href="#l83.183"></a><span id="l83.183" class="difflineplus">+ * Mark the end of a test started by |mark_test_start|.</span>
<a href="#l83.184"></a><span id="l83.184" class="difflineplus">+ */</span>
<a href="#l83.185"></a><span id="l83.185" class="difflineplus">+function mark_test_end(aPopTo) {</span>
<a href="#l83.186"></a><span id="l83.186" class="difflineplus">+  if (aPopTo === undefined)</span>
<a href="#l83.187"></a><span id="l83.187" class="difflineplus">+    aPopTo = 0;</span>
<a href="#l83.188"></a><span id="l83.188" class="difflineplus">+  // clear out any existing contexts</span>
<a href="#l83.189"></a><span id="l83.189" class="difflineplus">+  while (_testLoggerContexts.length &gt; aPopTo) {</span>
<a href="#l83.190"></a><span id="l83.190" class="difflineplus">+    let context = _testLoggerContexts.pop();</span>
<a href="#l83.191"></a><span id="l83.191" class="difflineplus">+    context.finish();</span>
<a href="#l83.192"></a><span id="l83.192" class="difflineplus">+    _testLogger.info(context, &quot;Finished &quot; + context.type + &quot;: &quot; + context.name +</span>
<a href="#l83.193"></a><span id="l83.193" class="difflineplus">+                     (context.parameter ? (&quot;, &quot; + context.parameter) : &quot;&quot;));</span>
<a href="#l83.194"></a><span id="l83.194" class="difflineplus">+  }</span>
<a href="#l83.195"></a><span id="l83.195" class="difflineplus">+}</span>
<a href="#l83.196"></a><span id="l83.196" class="difflineplus">+</span>
<a href="#l83.197"></a><span id="l83.197" class="difflineplus">+/**</span>
<a href="#l83.198"></a><span id="l83.198" class="difflineplus">+ * For user test code and test support code to mark sub-regions of tests.</span>
<a href="#l83.199"></a><span id="l83.199" class="difflineplus">+ *</span>
<a href="#l83.200"></a><span id="l83.200" class="difflineplus">+ * @param aName The name of the (sub) test.</span>
<a href="#l83.201"></a><span id="l83.201" class="difflineplus">+ * @param [aParameter=null] The parameter if the test is being parameterized.</span>
<a href="#l83.202"></a><span id="l83.202" class="difflineplus">+ * @param [aNest=false] Should this nest inside other sub-tests?  If you omit or</span>
<a href="#l83.203"></a><span id="l83.203" class="difflineplus">+ *     pass false, we will close out any existing sub-tests.  If you pass true,</span>
<a href="#l83.204"></a><span id="l83.204" class="difflineplus">+ *     we nest inside the previous test/sub-test and rely on you to call</span>
<a href="#l83.205"></a><span id="l83.205" class="difflineplus">+ *     |mark_sub_test_end|.  Sub tests can lost no longer than their parent.</span>
<a href="#l83.206"></a><span id="l83.206" class="difflineplus">+ *     You should strongly consider using the aNest parameter if you are</span>
<a href="#l83.207"></a><span id="l83.207" class="difflineplus">+ *     test support code.</span>
<a href="#l83.208"></a><span id="l83.208" class="difflineplus">+ */</span>
<a href="#l83.209"></a><span id="l83.209" class="difflineplus">+function mark_sub_test_start(aName, aParameter, aNest) {</span>
<a href="#l83.210"></a><span id="l83.210" class="difflineplus">+  let depth = aNest ? _testLoggerContexts.length : 1;</span>
<a href="#l83.211"></a><span id="l83.211" class="difflineplus">+  mark_test_start(aName, aParameter, depth);</span>
<a href="#l83.212"></a><span id="l83.212" class="difflineplus">+}</span>
<a href="#l83.213"></a><span id="l83.213" class="difflineplus">+</span>
<a href="#l83.214"></a><span id="l83.214" class="difflineplus">+/**</span>
<a href="#l83.215"></a><span id="l83.215" class="difflineplus">+ * Mark the end of a sub-test.  Because sub-tests can't outlive their parents,</span>
<a href="#l83.216"></a><span id="l83.216" class="difflineplus">+ *  there is no ambiguity about what sub-test we are closing out.</span>
<a href="#l83.217"></a><span id="l83.217" class="difflineplus">+ */</span>
<a href="#l83.218"></a><span id="l83.218" class="difflineplus">+function mark_sub_test_end() {</span>
<a href="#l83.219"></a><span id="l83.219" class="difflineplus">+  if (_testLoggerContexts.length &lt;= 1)</span>
<a href="#l83.220"></a><span id="l83.220" class="difflineplus">+    return;</span>
<a href="#l83.221"></a><span id="l83.221" class="difflineplus">+  mark_test_end(_testLoggerContexts.length - 1);</span>
<a href="#l83.222"></a><span id="l83.222" class="difflineplus">+}</span>
<a href="#l83.223"></a><span id="l83.223" class="difflineplus">+</span>
<a href="#l83.224"></a><span id="l83.224" class="difflineplus">+/**</span>
<a href="#l83.225"></a><span id="l83.225" class="difflineplus">+ * Express that all tests were run to completion.  This helps the listener</span>
<a href="#l83.226"></a><span id="l83.226" class="difflineplus">+ *  distinguish between succesful termination and abort-style termination where</span>
<a href="#l83.227"></a><span id="l83.227" class="difflineplus">+ *  the process just keeled over and on one told us.</span>
<a href="#l83.228"></a><span id="l83.228" class="difflineplus">+ *</span>
<a href="#l83.229"></a><span id="l83.229" class="difflineplus">+ * This also tells us to clean up.</span>
<a href="#l83.230"></a><span id="l83.230" class="difflineplus">+ */</span>
<a href="#l83.231"></a><span id="l83.231" class="difflineplus">+function mark_all_tests_run() {</span>
<a href="#l83.232"></a><span id="l83.232" class="difflineplus">+  // make sure all tests get closed out</span>
<a href="#l83.233"></a><span id="l83.233" class="difflineplus">+  mark_test_end();</span>
<a href="#l83.234"></a><span id="l83.234" class="difflineplus">+</span>
<a href="#l83.235"></a><span id="l83.235" class="difflineplus">+  _xpcshellLogger.info({</span>
<a href="#l83.236"></a><span id="l83.236" class="difflineplus">+    _jsonMe: true,</span>
<a href="#l83.237"></a><span id="l83.237" class="difflineplus">+    _isContext: true,</span>
<a href="#l83.238"></a><span id="l83.238" class="difflineplus">+    _specialContext: &quot;lifecycle&quot;,</span>
<a href="#l83.239"></a><span id="l83.239" class="difflineplus">+    _id: &quot;finish&quot;,</span>
<a href="#l83.240"></a><span id="l83.240" class="difflineplus">+    done: true,</span>
<a href="#l83.241"></a><span id="l83.241" class="difflineplus">+  });</span>
<a href="#l83.242"></a><span id="l83.242" class="difflineplus">+</span>
<a href="#l83.243"></a><span id="l83.243" class="difflineplus">+  _cleanup_log_helper();</span>
<a href="#l83.244"></a><span id="l83.244" class="difflineplus">+}</span>
<a href="#l83.245"></a><span id="l83.245" class="difflineplus">+</span>
<a href="#l83.246"></a><span id="l83.246" class="difflineplus">+function _explode_flags(aFlagWord, aFlagDefs) {</span>
<a href="#l83.247"></a><span id="l83.247" class="difflineplus">+  let flagList = [];</span>
<a href="#l83.248"></a><span id="l83.248" class="difflineplus">+</span>
<a href="#l83.249"></a><span id="l83.249" class="difflineplus">+  for each (let [flagName, flagVal] in Iterator(aFlagDefs)) {</span>
<a href="#l83.250"></a><span id="l83.250" class="difflineplus">+    if (flagVal &amp; aFlagWord)</span>
<a href="#l83.251"></a><span id="l83.251" class="difflineplus">+      flagList.push(flagName);</span>
<a href="#l83.252"></a><span id="l83.252" class="difflineplus">+  }</span>
<a href="#l83.253"></a><span id="l83.253" class="difflineplus">+</span>
<a href="#l83.254"></a><span id="l83.254" class="difflineplus">+  return flagList;</span>
<a href="#l83.255"></a><span id="l83.255" class="difflineplus">+}</span>
<a href="#l83.256"></a><span id="l83.256" class="difflineplus">+</span>
<a href="#l83.257"></a><span id="l83.257" class="difflineplus">+let _registered_json_normalizers = [];</span>
<a href="#l83.258"></a><span id="l83.258" class="difflineplus">+</span>
<a href="#l83.259"></a><span id="l83.259" class="difflineplus">+/**</span>
<a href="#l83.260"></a><span id="l83.260" class="difflineplus">+ * Like __simple_obj_copy but it does not assume things are objects.  This is</span>
<a href="#l83.261"></a><span id="l83.261" class="difflineplus">+ *  used by obj copying for aray copyiong.</span>
<a href="#l83.262"></a><span id="l83.262" class="difflineplus">+ */</span>
<a href="#l83.263"></a><span id="l83.263" class="difflineplus">+function __simple_value_copy(aObj, aDepthAllowed) {</span>
<a href="#l83.264"></a><span id="l83.264" class="difflineplus">+  if (aObj == null || typeof(aObj) != &quot;object&quot;)</span>
<a href="#l83.265"></a><span id="l83.265" class="difflineplus">+    return aObj;</span>
<a href="#l83.266"></a><span id="l83.266" class="difflineplus">+  return __simple_obj_copy(aObj, aDepthAllowed);</span>
<a href="#l83.267"></a><span id="l83.267" class="difflineplus">+}</span>
<a href="#l83.268"></a><span id="l83.268" class="difflineplus">+</span>
<a href="#l83.269"></a><span id="l83.269" class="difflineplus">+/**</span>
<a href="#l83.270"></a><span id="l83.270" class="difflineplus">+ * Simple object copier to limit accidentally JSON-ing a ridiculously complex</span>
<a href="#l83.271"></a><span id="l83.271" class="difflineplus">+ *  object graph or getting tripped up by prototypes.</span>
<a href="#l83.272"></a><span id="l83.272" class="difflineplus">+ *</span>
<a href="#l83.273"></a><span id="l83.273" class="difflineplus">+ * @param aObj Input object.</span>
<a href="#l83.274"></a><span id="l83.274" class="difflineplus">+ * @param aDepthAllowed How many times we are allowed to recursively call</span>
<a href="#l83.275"></a><span id="l83.275" class="difflineplus">+ *     ourselves.</span>
<a href="#l83.276"></a><span id="l83.276" class="difflineplus">+ */</span>
<a href="#l83.277"></a><span id="l83.277" class="difflineplus">+function __simple_obj_copy(aObj, aDepthAllowed) {</span>
<a href="#l83.278"></a><span id="l83.278" class="difflineplus">+  let oot = {};</span>
<a href="#l83.279"></a><span id="l83.279" class="difflineplus">+  let nextDepth = aDepthAllowed - 1;</span>
<a href="#l83.280"></a><span id="l83.280" class="difflineplus">+  for each (let [key, value] in Iterator(aObj)) {</span>
<a href="#l83.281"></a><span id="l83.281" class="difflineplus">+    if (value == null) {</span>
<a href="#l83.282"></a><span id="l83.282" class="difflineplus">+      oot[key] = null;</span>
<a href="#l83.283"></a><span id="l83.283" class="difflineplus">+    }</span>
<a href="#l83.284"></a><span id="l83.284" class="difflineplus">+    else if (typeof(value) != &quot;object&quot;) {</span>
<a href="#l83.285"></a><span id="l83.285" class="difflineplus">+      oot[key] = value;</span>
<a href="#l83.286"></a><span id="l83.286" class="difflineplus">+    }</span>
<a href="#l83.287"></a><span id="l83.287" class="difflineplus">+    // steal control flow if no more depth is allowed</span>
<a href="#l83.288"></a><span id="l83.288" class="difflineplus">+    else if (!aDepthAllowed) {</span>
<a href="#l83.289"></a><span id="l83.289" class="difflineplus">+      oot[key] = &quot;truncated, string rep: &quot; + value.toString();</span>
<a href="#l83.290"></a><span id="l83.290" class="difflineplus">+    }</span>
<a href="#l83.291"></a><span id="l83.291" class="difflineplus">+    // array?  we don't count that as depth for now.</span>
<a href="#l83.292"></a><span id="l83.292" class="difflineplus">+    else if (&quot;length&quot; in value) {</span>
<a href="#l83.293"></a><span id="l83.293" class="difflineplus">+      oot[key] = [__simple_value_copy(v, nextDepth) for each</span>
<a href="#l83.294"></a><span id="l83.294" class="difflineplus">+                   ([, v] in Iterator(value))];</span>
<a href="#l83.295"></a><span id="l83.295" class="difflineplus">+    }</span>
<a href="#l83.296"></a><span id="l83.296" class="difflineplus">+    // it's another object! woo!</span>
<a href="#l83.297"></a><span id="l83.297" class="difflineplus">+    else {</span>
<a href="#l83.298"></a><span id="l83.298" class="difflineplus">+      oot[key] = _normalize_for_json(value, nextDepth, true);</span>
<a href="#l83.299"></a><span id="l83.299" class="difflineplus">+    }</span>
<a href="#l83.300"></a><span id="l83.300" class="difflineplus">+  }</span>
<a href="#l83.301"></a><span id="l83.301" class="difflineplus">+</span>
<a href="#l83.302"></a><span id="l83.302" class="difflineplus">+  // let's take advantage of the object's native toString now</span>
<a href="#l83.303"></a><span id="l83.303" class="difflineplus">+  oot._stringRep = aObj.toString();</span>
<a href="#l83.304"></a><span id="l83.304" class="difflineplus">+</span>
<a href="#l83.305"></a><span id="l83.305" class="difflineplus">+  return oot;</span>
<a href="#l83.306"></a><span id="l83.306" class="difflineplus">+}</span>
<a href="#l83.307"></a><span id="l83.307" class="difflineplus">+</span>
<a href="#l83.308"></a><span id="l83.308" class="difflineplus">+const _INTERESTING_MESSAGE_HEADER_PROPERTIES = {</span>
<a href="#l83.309"></a><span id="l83.309" class="difflineplus">+  &quot;gloda-id&quot;: 0,</span>
<a href="#l83.310"></a><span id="l83.310" class="difflineplus">+  &quot;gloda-dirty&quot;: 0,</span>
<a href="#l83.311"></a><span id="l83.311" class="difflineplus">+};</span>
<a href="#l83.312"></a><span id="l83.312" class="difflineplus">+</span>
<a href="#l83.313"></a><span id="l83.313" class="difflineplus">+</span>
<a href="#l83.314"></a><span id="l83.314" class="difflineplus">+/**</span>
<a href="#l83.315"></a><span id="l83.315" class="difflineplus">+ * Given an object, attempt to normalize it into an interesting JSON</span>
<a href="#l83.316"></a><span id="l83.316" class="difflineplus">+ *  representation.</span>
<a href="#l83.317"></a><span id="l83.317" class="difflineplus">+ *</span>
<a href="#l83.318"></a><span id="l83.318" class="difflineplus">+ * We transform generally interesting mail objects like:</span>
<a href="#l83.319"></a><span id="l83.319" class="difflineplus">+ * - nsIMsgFolder</span>
<a href="#l83.320"></a><span id="l83.320" class="difflineplus">+ * - nsIMsgDBHdr</span>
<a href="#l83.321"></a><span id="l83.321" class="difflineplus">+ */</span>
<a href="#l83.322"></a><span id="l83.322" class="difflineplus">+function _normalize_for_json(aObj, aDepthAllowed, aJsonMeNotNeeded) {</span>
<a href="#l83.323"></a><span id="l83.323" class="difflineplus">+  if (aDepthAllowed === undefined)</span>
<a href="#l83.324"></a><span id="l83.324" class="difflineplus">+    aDepthAllowed = 2;</span>
<a href="#l83.325"></a><span id="l83.325" class="difflineplus">+</span>
<a href="#l83.326"></a><span id="l83.326" class="difflineplus">+  // if it's a simple type just return it direct</span>
<a href="#l83.327"></a><span id="l83.327" class="difflineplus">+  if (typeof(aObj) != &quot;object&quot;)</span>
<a href="#l83.328"></a><span id="l83.328" class="difflineplus">+    return aObj;</span>
<a href="#l83.329"></a><span id="l83.329" class="difflineplus">+  else if (aObj == null)</span>
<a href="#l83.330"></a><span id="l83.330" class="difflineplus">+    return aObj;</span>
<a href="#l83.331"></a><span id="l83.331" class="difflineplus">+</span>
<a href="#l83.332"></a><span id="l83.332" class="difflineplus">+  // === Mail Specific ===</span>
<a href="#l83.333"></a><span id="l83.333" class="difflineplus">+  // (but common and few enough to not split out)</span>
<a href="#l83.334"></a><span id="l83.334" class="difflineplus">+  if (aObj instanceof Ci.nsIMsgFolder) {</span>
<a href="#l83.335"></a><span id="l83.335" class="difflineplus">+    let flags = aObj.flags;</span>
<a href="#l83.336"></a><span id="l83.336" class="difflineplus">+    return {</span>
<a href="#l83.337"></a><span id="l83.337" class="difflineplus">+      type: &quot;folder&quot;,</span>
<a href="#l83.338"></a><span id="l83.338" class="difflineplus">+      name: aObj.prettiestName,</span>
<a href="#l83.339"></a><span id="l83.339" class="difflineplus">+      uri: aObj.URI,</span>
<a href="#l83.340"></a><span id="l83.340" class="difflineplus">+      flags: _explode_flags(aObj.flags,</span>
<a href="#l83.341"></a><span id="l83.341" class="difflineplus">+                            Ci.nsMsgFolderFlags),</span>
<a href="#l83.342"></a><span id="l83.342" class="difflineplus">+    };</span>
<a href="#l83.343"></a><span id="l83.343" class="difflineplus">+  }</span>
<a href="#l83.344"></a><span id="l83.344" class="difflineplus">+  else if (aObj instanceof Ci.nsIMsgDBHdr) {</span>
<a href="#l83.345"></a><span id="l83.345" class="difflineplus">+    let properties = {};</span>
<a href="#l83.346"></a><span id="l83.346" class="difflineplus">+    for each (let [name, propType] in</span>
<a href="#l83.347"></a><span id="l83.347" class="difflineplus">+              Iterator(_INTERESTING_MESSAGE_HEADER_PROPERTIES)) {</span>
<a href="#l83.348"></a><span id="l83.348" class="difflineplus">+      if (propType == 0)</span>
<a href="#l83.349"></a><span id="l83.349" class="difflineplus">+        properties[name] = (aObj.getStringProperty(name) != &quot;&quot;) ?</span>
<a href="#l83.350"></a><span id="l83.350" class="difflineplus">+                             aObj.getUint32Property(name) : null;</span>
<a href="#l83.351"></a><span id="l83.351" class="difflineplus">+      else</span>
<a href="#l83.352"></a><span id="l83.352" class="difflineplus">+        properties[name] = aObj.getStringProperty(name);</span>
<a href="#l83.353"></a><span id="l83.353" class="difflineplus">+    }</span>
<a href="#l83.354"></a><span id="l83.354" class="difflineplus">+    return {</span>
<a href="#l83.355"></a><span id="l83.355" class="difflineplus">+      type: &quot;msgHdr&quot;,</span>
<a href="#l83.356"></a><span id="l83.356" class="difflineplus">+      name: aObj.folder.URI + &quot;#&quot; + aObj.messageKey,</span>
<a href="#l83.357"></a><span id="l83.357" class="difflineplus">+      subject: aObj.mime2DecodedSubject,</span>
<a href="#l83.358"></a><span id="l83.358" class="difflineplus">+      from: aObj.mime2DecodedAuthor,</span>
<a href="#l83.359"></a><span id="l83.359" class="difflineplus">+      to: aObj.mime2DecodedRecipients,</span>
<a href="#l83.360"></a><span id="l83.360" class="difflineplus">+      messageKey: aObj.messageKey,</span>
<a href="#l83.361"></a><span id="l83.361" class="difflineplus">+      messageId: aObj.messageId,</span>
<a href="#l83.362"></a><span id="l83.362" class="difflineplus">+      flags: _explode_flags(aObj.flags,</span>
<a href="#l83.363"></a><span id="l83.363" class="difflineplus">+                            Ci.nsMsgMessageFlags),</span>
<a href="#l83.364"></a><span id="l83.364" class="difflineplus">+      interestingProperties: properties,</span>
<a href="#l83.365"></a><span id="l83.365" class="difflineplus">+    };</span>
<a href="#l83.366"></a><span id="l83.366" class="difflineplus">+  }</span>
<a href="#l83.367"></a><span id="l83.367" class="difflineplus">+  // === Generic ===</span>
<a href="#l83.368"></a><span id="l83.368" class="difflineplus">+  // Although straight JS exceptions should serialize pretty well, we can</span>
<a href="#l83.369"></a><span id="l83.369" class="difflineplus">+  //  improve things by making &quot;stack&quot; more friendly.</span>
<a href="#l83.370"></a><span id="l83.370" class="difflineplus">+  else if (aObj instanceof Error) {</span>
<a href="#l83.371"></a><span id="l83.371" class="difflineplus">+    return {</span>
<a href="#l83.372"></a><span id="l83.372" class="difflineplus">+      message: aObj.message,</span>
<a href="#l83.373"></a><span id="l83.373" class="difflineplus">+      fileName: aObj.fileName,</span>
<a href="#l83.374"></a><span id="l83.374" class="difflineplus">+      lineNumber: aObj.lineNumber,</span>
<a href="#l83.375"></a><span id="l83.375" class="difflineplus">+      name: aObj.name,</span>
<a href="#l83.376"></a><span id="l83.376" class="difflineplus">+      stack: aObj.stack ? aObj.stack.split(/\n\r?/g) : null,</span>
<a href="#l83.377"></a><span id="l83.377" class="difflineplus">+      _stringRep: aObj.message,</span>
<a href="#l83.378"></a><span id="l83.378" class="difflineplus">+    };</span>
<a href="#l83.379"></a><span id="l83.379" class="difflineplus">+  }</span>
<a href="#l83.380"></a><span id="l83.380" class="difflineplus">+  else if (aObj instanceof Ci.nsIStackFrame) {</span>
<a href="#l83.381"></a><span id="l83.381" class="difflineplus">+    return {</span>
<a href="#l83.382"></a><span id="l83.382" class="difflineplus">+      type: &quot;stackFrame&quot;,</span>
<a href="#l83.383"></a><span id="l83.383" class="difflineplus">+      name: aObj.name,</span>
<a href="#l83.384"></a><span id="l83.384" class="difflineplus">+      fileName: aObj.filename, // intentionally lower-case</span>
<a href="#l83.385"></a><span id="l83.385" class="difflineplus">+      lineNumber: aObj.lineNumber,</span>
<a href="#l83.386"></a><span id="l83.386" class="difflineplus">+    };</span>
<a href="#l83.387"></a><span id="l83.387" class="difflineplus">+  }</span>
<a href="#l83.388"></a><span id="l83.388" class="difflineplus">+  else if (aObj instanceof Ci.nsIScriptError) {</span>
<a href="#l83.389"></a><span id="l83.389" class="difflineplus">+    return {</span>
<a href="#l83.390"></a><span id="l83.390" class="difflineplus">+      type: &quot;stackFrame&quot;,</span>
<a href="#l83.391"></a><span id="l83.391" class="difflineplus">+      name: aObj.errorMessage,</span>
<a href="#l83.392"></a><span id="l83.392" class="difflineplus">+      category: aObj.category,</span>
<a href="#l83.393"></a><span id="l83.393" class="difflineplus">+      fileName: aObj.sourceName,</span>
<a href="#l83.394"></a><span id="l83.394" class="difflineplus">+      lineNumber: aObj.lineNumber,</span>
<a href="#l83.395"></a><span id="l83.395" class="difflineplus">+    };</span>
<a href="#l83.396"></a><span id="l83.396" class="difflineplus">+  }</span>
<a href="#l83.397"></a><span id="l83.397" class="difflineplus">+  else {</span>
<a href="#l83.398"></a><span id="l83.398" class="difflineplus">+    for each (let [, [checkType, handler]] in</span>
<a href="#l83.399"></a><span id="l83.399" class="difflineplus">+              Iterator(_registered_json_normalizers)) {</span>
<a href="#l83.400"></a><span id="l83.400" class="difflineplus">+      if (aObj instanceof checkType)</span>
<a href="#l83.401"></a><span id="l83.401" class="difflineplus">+        return handler(aObj);</span>
<a href="#l83.402"></a><span id="l83.402" class="difflineplus">+    }</span>
<a href="#l83.403"></a><span id="l83.403" class="difflineplus">+  }</span>
<a href="#l83.404"></a><span id="l83.404" class="difflineplus">+</span>
<a href="#l83.405"></a><span id="l83.405" class="difflineplus">+  let simple_obj = __simple_obj_copy(aObj, aDepthAllowed);</span>
<a href="#l83.406"></a><span id="l83.406" class="difflineplus">+  if (!aJsonMeNotNeeded)</span>
<a href="#l83.407"></a><span id="l83.407" class="difflineplus">+    simple_obj.__proto__ = _fake_json_proto;</span>
<a href="#l83.408"></a><span id="l83.408" class="difflineplus">+  return simple_obj;</span>
<a href="#l83.409"></a><span id="l83.409" class="difflineplus">+}</span>
<a href="#l83.410"></a><span id="l83.410" class="difflineplus">+</span>
<a href="#l83.411"></a><span id="l83.411" class="difflineplus">+function register_json_normalizer(aType, aHandler) {</span>
<a href="#l83.412"></a><span id="l83.412" class="difflineplus">+  _registered_json_normalizers.push([aType, aHandler]);</span>
<a href="#l83.413"></a><span id="l83.413" class="difflineplus">+}</span>
<a href="#l83.414"></a><span id="l83.414" class="difflineplus">+</span>
<a href="#l83.415"></a><span id="l83.415" class="difflineplus">+/**</span>
<a href="#l83.416"></a><span id="l83.416" class="difflineplus">+ * Helper for |mark_action| that creates json-transportable representation so</span>
<a href="#l83.417"></a><span id="l83.417" class="difflineplus">+ *  cool UI on the other end can do something.</span>
<a href="#l83.418"></a><span id="l83.418" class="difflineplus">+ */</span>
<a href="#l83.419"></a><span id="l83.419" class="difflineplus">+function _MarkAction(aWho, aWhat, aArgs) {</span>
<a href="#l83.420"></a><span id="l83.420" class="difflineplus">+  this.type = &quot;action&quot;;</span>
<a href="#l83.421"></a><span id="l83.421" class="difflineplus">+  this.who = aWho;</span>
<a href="#l83.422"></a><span id="l83.422" class="difflineplus">+  this.what = aWhat;</span>
<a href="#l83.423"></a><span id="l83.423" class="difflineplus">+  this.args = aArgs;</span>
<a href="#l83.424"></a><span id="l83.424" class="difflineplus">+}</span>
<a href="#l83.425"></a><span id="l83.425" class="difflineplus">+_MarkAction.prototype = {</span>
<a href="#l83.426"></a><span id="l83.426" class="difflineplus">+  _jsonMe: true,</span>
<a href="#l83.427"></a><span id="l83.427" class="difflineplus">+  toString: function() {</span>
<a href="#l83.428"></a><span id="l83.428" class="difflineplus">+    let argStr;</span>
<a href="#l83.429"></a><span id="l83.429" class="difflineplus">+    if (this.args) {</span>
<a href="#l83.430"></a><span id="l83.430" class="difflineplus">+      argStr = &quot;:&quot;;</span>
<a href="#l83.431"></a><span id="l83.431" class="difflineplus">+      for each (let [, arg] in Iterator(this.args)) {</span>
<a href="#l83.432"></a><span id="l83.432" class="difflineplus">+        if (arg != null &amp;&amp; (typeof(arg) == &quot;object&quot;) &amp;&amp; (&quot;type&quot; in arg)) {</span>
<a href="#l83.433"></a><span id="l83.433" class="difflineplus">+          if (&quot;name&quot; in arg)</span>
<a href="#l83.434"></a><span id="l83.434" class="difflineplus">+            argStr += &quot; &quot; + arg.type + &quot;: &quot; + arg.name;</span>
<a href="#l83.435"></a><span id="l83.435" class="difflineplus">+          else</span>
<a href="#l83.436"></a><span id="l83.436" class="difflineplus">+            argStr += &quot; &quot; + arg.type;</span>
<a href="#l83.437"></a><span id="l83.437" class="difflineplus">+        }</span>
<a href="#l83.438"></a><span id="l83.438" class="difflineplus">+        else</span>
<a href="#l83.439"></a><span id="l83.439" class="difflineplus">+          argStr += &quot; &quot; + arg;</span>
<a href="#l83.440"></a><span id="l83.440" class="difflineplus">+      }</span>
<a href="#l83.441"></a><span id="l83.441" class="difflineplus">+    }</span>
<a href="#l83.442"></a><span id="l83.442" class="difflineplus">+    else</span>
<a href="#l83.443"></a><span id="l83.443" class="difflineplus">+      argStr = &quot;&quot;;</span>
<a href="#l83.444"></a><span id="l83.444" class="difflineplus">+    return this.who + &quot; &quot; + this.what + argStr;</span>
<a href="#l83.445"></a><span id="l83.445" class="difflineplus">+  }</span>
<a href="#l83.446"></a><span id="l83.446" class="difflineplus">+};</span>
<a href="#l83.447"></a><span id="l83.447" class="difflineplus">+</span>
<a href="#l83.448"></a><span id="l83.448" class="difflineplus">+/**</span>
<a href="#l83.449"></a><span id="l83.449" class="difflineplus">+ * Report performance of an action (by testing code).  You would use this rather</span>
<a href="#l83.450"></a><span id="l83.450" class="difflineplus">+ *  than dump because we attempt to do interesting and useful logging things.</span>
<a href="#l83.451"></a><span id="l83.451" class="difflineplus">+ *  In the future, this may mean prettier logs when buildbot runs a test and it</span>
<a href="#l83.452"></a><span id="l83.452" class="difflineplus">+ *  fails, but right now it means great fun for people who use logsploder and</span>
<a href="#l83.453"></a><span id="l83.453" class="difflineplus">+ *  just nicely formatted text for people looking at the console output.</span>
<a href="#l83.454"></a><span id="l83.454" class="difflineplus">+ *</span>
<a href="#l83.455"></a><span id="l83.455" class="difflineplus">+ * @param aWho Think of this like a logger handle... it might be soon.</span>
<a href="#l83.456"></a><span id="l83.456" class="difflineplus">+ * @param aWhat What did you do?</span>
<a href="#l83.457"></a><span id="l83.457" class="difflineplus">+ * @param aArgs A list of arguments, which could each be something like an</span>
<a href="#l83.458"></a><span id="l83.458" class="difflineplus">+ *     nsIMsgFolder or nsIMsgDBHdr or something like that.  It uses</span>
<a href="#l83.459"></a><span id="l83.459" class="difflineplus">+ *     |_normalize_for_json| which can handle some native objects, be extended</span>
<a href="#l83.460"></a><span id="l83.460" class="difflineplus">+ *     to handle more, and does a fair job on straight JS objects.</span>
<a href="#l83.461"></a><span id="l83.461" class="difflineplus">+ */</span>
<a href="#l83.462"></a><span id="l83.462" class="difflineplus">+function mark_action(aWho, aWhat, aArgs) {</span>
<a href="#l83.463"></a><span id="l83.463" class="difflineplus">+  let logger = Log4Moz.repository.getLogger(&quot;test.&quot; + aWho);</span>
<a href="#l83.464"></a><span id="l83.464" class="difflineplus">+</span>
<a href="#l83.465"></a><span id="l83.465" class="difflineplus">+  aArgs = [_normalize_for_json(arg) for each ([, arg] in Iterator(aArgs))];</span>
<a href="#l83.466"></a><span id="l83.466" class="difflineplus">+  logger.info(_testLoggerActiveContext, new _MarkAction(aWho, aWhat, aArgs));</span>
<a href="#l83.467"></a><span id="l83.467" class="difflineplus">+}</span>
<a href="#l83.468"></a><span id="l83.468" class="difflineplus">+</span>
<a href="#l83.469"></a><span id="l83.469" class="difflineplus">+/*</span>
<a href="#l83.470"></a><span id="l83.470" class="difflineplus">+ * Wrap the xpcshell test functions that do interesting things.  The idea is</span>
<a href="#l83.471"></a><span id="l83.471" class="difflineplus">+ *  that we clobber these only if we're going to value-add; that decision</span>
<a href="#l83.472"></a><span id="l83.472" class="difflineplus">+ *  gets made up top in the initialization function.</span>
<a href="#l83.473"></a><span id="l83.473" class="difflineplus">+ *</span>
<a href="#l83.474"></a><span id="l83.474" class="difflineplus">+ * Since eq/neq fall-through to do_throw in the explosion case, we don't handle</span>
<a href="#l83.475"></a><span id="l83.475" class="difflineplus">+ *  that since the scoping means that we're going to see the resulting</span>
<a href="#l83.476"></a><span id="l83.476" class="difflineplus">+ *  do_throw.</span>
<a href="#l83.477"></a><span id="l83.477" class="difflineplus">+ */</span>
<a href="#l83.478"></a><span id="l83.478" class="difflineplus">+</span>
<a href="#l83.479"></a><span id="l83.479" class="difflineplus">+var _orig_do_throw;</span>
<a href="#l83.480"></a><span id="l83.480" class="difflineplus">+var _orig_do_check_neq;</span>
<a href="#l83.481"></a><span id="l83.481" class="difflineplus">+var _orig_do_check_eq;</span>
<a href="#l83.482"></a><span id="l83.482" class="difflineplus">+// do_check_true is implemented in terms of do_check_eq</span>
<a href="#l83.483"></a><span id="l83.483" class="difflineplus">+// do_check_false is implemented in terms of do_check_eq</span>
<a href="#l83.484"></a><span id="l83.484" class="difflineplus">+</span>
<a href="#l83.485"></a><span id="l83.485" class="difflineplus">+function _CheckAction(aSuccess, aLeft, aRight, aStack) {</span>
<a href="#l83.486"></a><span id="l83.486" class="difflineplus">+  this.type = &quot;check&quot;;</span>
<a href="#l83.487"></a><span id="l83.487" class="difflineplus">+  this.success = aSuccess;</span>
<a href="#l83.488"></a><span id="l83.488" class="difflineplus">+  this.left = _normalize_for_json(aLeft);</span>
<a href="#l83.489"></a><span id="l83.489" class="difflineplus">+  this.right = _normalize_for_json(aRight);</span>
<a href="#l83.490"></a><span id="l83.490" class="difflineplus">+  this.stack = _normalize_for_json(aStack);</span>
<a href="#l83.491"></a><span id="l83.491" class="difflineplus">+}</span>
<a href="#l83.492"></a><span id="l83.492" class="difflineplus">+_CheckAction.prototype = {</span>
<a href="#l83.493"></a><span id="l83.493" class="difflineplus">+  _jsonMe: true,</span>
<a href="#l83.494"></a><span id="l83.494" class="difflineplus">+  // we don't need a toString because we should not go out to the console</span>
<a href="#l83.495"></a><span id="l83.495" class="difflineplus">+};</span>
<a href="#l83.496"></a><span id="l83.496" class="difflineplus">+</span>
<a href="#l83.497"></a><span id="l83.497" class="difflineplus">+/**</span>
<a href="#l83.498"></a><span id="l83.498" class="difflineplus">+ * Representation of a failure from do_throw.</span>
<a href="#l83.499"></a><span id="l83.499" class="difflineplus">+ */</span>
<a href="#l83.500"></a><span id="l83.500" class="difflineplus">+function _Failure(aText, aStack) {</span>
<a href="#l83.501"></a><span id="l83.501" class="difflineplus">+  this.type = &quot;failure&quot;;</span>
<a href="#l83.502"></a><span id="l83.502" class="difflineplus">+  this.text = aText;</span>
<a href="#l83.503"></a><span id="l83.503" class="difflineplus">+  this.stack = _normalize_for_json(aStack);</span>
<a href="#l83.504"></a><span id="l83.504" class="difflineplus">+}</span>
<a href="#l83.505"></a><span id="l83.505" class="difflineplus">+_Failure.prototype = {</span>
<a href="#l83.506"></a><span id="l83.506" class="difflineplus">+  _jsonMe: true,</span>
<a href="#l83.507"></a><span id="l83.507" class="difflineplus">+};</span>
<a href="#l83.508"></a><span id="l83.508" class="difflineplus">+</span>
<a href="#l83.509"></a><span id="l83.509" class="difflineplus">+let _fake_json_proto = {</span>
<a href="#l83.510"></a><span id="l83.510" class="difflineplus">+  _jsonMe: true,</span>
<a href="#l83.511"></a><span id="l83.511" class="difflineplus">+};</span>
<a href="#l83.512"></a><span id="l83.512" class="difflineplus">+</span>
<a href="#l83.513"></a><span id="l83.513" class="difflineplus">+function mark_failure(aRichString) {</span>
<a href="#l83.514"></a><span id="l83.514" class="difflineplus">+  let args = [_testLoggerActiveContext];</span>
<a href="#l83.515"></a><span id="l83.515" class="difflineplus">+  let text = &quot;&quot;;</span>
<a href="#l83.516"></a><span id="l83.516" class="difflineplus">+  for each (let [i, richThing] in Iterator(aRichString)) {</span>
<a href="#l83.517"></a><span id="l83.517" class="difflineplus">+    text += (i ? &quot; &quot; : &quot;&quot;) + richThing;</span>
<a href="#l83.518"></a><span id="l83.518" class="difflineplus">+    if (richThing == null || typeof(richThing) != &quot;object&quot;)</span>
<a href="#l83.519"></a><span id="l83.519" class="difflineplus">+      args.push(richThing);</span>
<a href="#l83.520"></a><span id="l83.520" class="difflineplus">+    else {</span>
<a href="#l83.521"></a><span id="l83.521" class="difflineplus">+      let jsonThing = _normalize_for_json(richThing);</span>
<a href="#l83.522"></a><span id="l83.522" class="difflineplus">+      // hook things up to be json serialized.</span>
<a href="#l83.523"></a><span id="l83.523" class="difflineplus">+      if (!(&quot;_jsonMe&quot; in jsonThing))</span>
<a href="#l83.524"></a><span id="l83.524" class="difflineplus">+        jsonThing.__proto__ = _fake_json_proto;</span>
<a href="#l83.525"></a><span id="l83.525" class="difflineplus">+      args.push(jsonThing);</span>
<a href="#l83.526"></a><span id="l83.526" class="difflineplus">+    }</span>
<a href="#l83.527"></a><span id="l83.527" class="difflineplus">+  }</span>
<a href="#l83.528"></a><span id="l83.528" class="difflineplus">+  _xpcshellLogger.info.apply(_xpcshellLogger, args);</span>
<a href="#l83.529"></a><span id="l83.529" class="difflineplus">+</span>
<a href="#l83.530"></a><span id="l83.530" class="difflineplus">+  do_throw(text, Components.stack.caller);</span>
<a href="#l83.531"></a><span id="l83.531" class="difflineplus">+}</span>
<a href="#l83.532"></a><span id="l83.532" class="difflineplus">+</span>
<a href="#l83.533"></a><span id="l83.533" class="difflineplus">+function _wrapped_do_throw(text, stack) {</span>
<a href="#l83.534"></a><span id="l83.534" class="difflineplus">+  if (!stack)</span>
<a href="#l83.535"></a><span id="l83.535" class="difflineplus">+    stack = Components.stack.caller;</span>
<a href="#l83.536"></a><span id="l83.536" class="difflineplus">+</span>
<a href="#l83.537"></a><span id="l83.537" class="difflineplus">+  // We need to use an info because otherwise explosion loggers can get angry</span>
<a href="#l83.538"></a><span id="l83.538" class="difflineplus">+  //  and they may be indiscriminate about what they subscribe to.</span>
<a href="#l83.539"></a><span id="l83.539" class="difflineplus">+  _xpcshellLogger.info(_testLoggerActiveContext,</span>
<a href="#l83.540"></a><span id="l83.540" class="difflineplus">+                        new _Failure(text, stack));</span>
<a href="#l83.541"></a><span id="l83.541" class="difflineplus">+</span>
<a href="#l83.542"></a><span id="l83.542" class="difflineplus">+  return _orig_do_throw(text, stack);</span>
<a href="#l83.543"></a><span id="l83.543" class="difflineplus">+}</span>
<a href="#l83.544"></a><span id="l83.544" class="difflineplus">+</span>
<a href="#l83.545"></a><span id="l83.545" class="difflineplus">+function _wrapped_do_check_neq(left, right, stack) {</span>
<a href="#l83.546"></a><span id="l83.546" class="difflineplus">+  if (!stack)</span>
<a href="#l83.547"></a><span id="l83.547" class="difflineplus">+    stack = Components.stack.caller;</span>
<a href="#l83.548"></a><span id="l83.548" class="difflineplus">+</span>
<a href="#l83.549"></a><span id="l83.549" class="difflineplus">+  _xpcshellLogger.info(_testLoggerActiveContext,</span>
<a href="#l83.550"></a><span id="l83.550" class="difflineplus">+                       new _CheckAction(left != right,</span>
<a href="#l83.551"></a><span id="l83.551" class="difflineplus">+                                        left, right, stack));</span>
<a href="#l83.552"></a><span id="l83.552" class="difflineplus">+</span>
<a href="#l83.553"></a><span id="l83.553" class="difflineplus">+  return _orig_do_check_neq(left, right, stack);</span>
<a href="#l83.554"></a><span id="l83.554" class="difflineplus">+}</span>
<a href="#l83.555"></a><span id="l83.555" class="difflineplus">+</span>
<a href="#l83.556"></a><span id="l83.556" class="difflineplus">+function _wrapped_do_check_eq(left, right, stack) {</span>
<a href="#l83.557"></a><span id="l83.557" class="difflineplus">+  if (!stack)</span>
<a href="#l83.558"></a><span id="l83.558" class="difflineplus">+    stack = Components.stack.caller;</span>
<a href="#l83.559"></a><span id="l83.559" class="difflineplus">+</span>
<a href="#l83.560"></a><span id="l83.560" class="difflineplus">+  _xpcshellLogger.info(_testLoggerActiveContext,</span>
<a href="#l83.561"></a><span id="l83.561" class="difflineplus">+                       new _CheckAction(left == right,</span>
<a href="#l83.562"></a><span id="l83.562" class="difflineplus">+                                        left, right, stack));</span>
<a href="#l83.563"></a><span id="l83.563" class="difflineplus">+</span>
<a href="#l83.564"></a><span id="l83.564" class="difflineplus">+  return _orig_do_check_eq(left, right, stack);</span>
<a href="#l83.565"></a><span id="l83.565" class="difflineplus">+}</span>
<a href="#l83.566"></a><span id="l83.566" class="difflineplus">+</span>
<a href="#l83.567"></a><span id="l83.567" class="difflineplus">+function _wrap_xpcshell_functions() {</span>
<a href="#l83.568"></a><span id="l83.568" class="difflineplus">+  _orig_do_throw = do_throw;</span>
<a href="#l83.569"></a><span id="l83.569" class="difflineplus">+  do_throw = _wrapped_do_throw;</span>
<a href="#l83.570"></a><span id="l83.570" class="difflineplus">+  _orig_do_check_neq = do_check_neq;</span>
<a href="#l83.571"></a><span id="l83.571" class="difflineplus">+  do_check_neq = _wrapped_do_check_neq;</span>
<a href="#l83.572"></a><span id="l83.572" class="difflineplus">+  _orig_do_check_eq = do_check_eq;</span>
<a href="#l83.573"></a><span id="l83.573" class="difflineplus">+  do_check_eq = _wrapped_do_check_eq;</span>
<a href="#l83.574"></a><span id="l83.574" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l84.1"></a><span id="l84.1" class="difflineminus">--- a/mailnews/test/resources/mailTestUtils.js</span>
<a href="#l84.2"></a><span id="l84.2" class="difflineplus">+++ b/mailnews/test/resources/mailTestUtils.js</span>
<a href="#l84.3"></a><span id="l84.3" class="difflineat">@@ -214,18 +214,18 @@ function loadFileToString(aFile, aCharse</span>
<a href="#l84.4"></a><span id="l84.4"> </span>
<a href="#l84.5"></a><span id="l84.5">   return data;</span>
<a href="#l84.6"></a><span id="l84.6"> }</span>
<a href="#l84.7"></a><span id="l84.7"> </span>
<a href="#l84.8"></a><span id="l84.8"> /**</span>
<a href="#l84.9"></a><span id="l84.9">  * A variant of do_timeout that accepts an actual function instead of</span>
<a href="#l84.10"></a><span id="l84.10">  *  requiring you to pass a string to evaluate.  If the function throws an</span>
<a href="#l84.11"></a><span id="l84.11">  *  exception when invoked, we will use do_throw to ensure that the test fails.</span>
<a href="#l84.12"></a><span id="l84.12" class="difflineminus">- * </span>
<a href="#l84.13"></a><span id="l84.13" class="difflineminus">- * @param aDelayInMS The number of milliseconds to wait before firing the timer. </span>
<a href="#l84.14"></a><span id="l84.14" class="difflineplus">+ *</span>
<a href="#l84.15"></a><span id="l84.15" class="difflineplus">+ * @param aDelayInMS The number of milliseconds to wait before firing the timer.</span>
<a href="#l84.16"></a><span id="l84.16">  * @param aFunc The function to invoke when the timer fires.</span>
<a href="#l84.17"></a><span id="l84.17">  * @param aFuncThis Optional 'this' pointer to use.</span>
<a href="#l84.18"></a><span id="l84.18">  * @param aFuncArgs Optional list of arguments to pass to the function.</span>
<a href="#l84.19"></a><span id="l84.19">  */</span>
<a href="#l84.20"></a><span id="l84.20"> function do_timeout_function(aDelayInMS, aFunc, aFuncThis, aFuncArgs) {</span>
<a href="#l84.21"></a><span id="l84.21">   let timer = Components.classes[&quot;@mozilla.org/timer;1&quot;]</span>
<a href="#l84.22"></a><span id="l84.22">                         .createInstance(Components.interfaces.nsITimer);</span>
<a href="#l84.23"></a><span id="l84.23">   let wrappedFunc = function() {</span>
<a href="#l84.24"></a><span id="l84.24" class="difflineat">@@ -241,29 +241,32 @@ function do_timeout_function(aDelayInMS,</span>
<a href="#l84.25"></a><span id="l84.25">   timer.initWithCallback(wrappedFunc, aDelayInMS,</span>
<a href="#l84.26"></a><span id="l84.26">     Components.interfaces.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l84.27"></a><span id="l84.27"> }</span>
<a href="#l84.28"></a><span id="l84.28"> </span>
<a href="#l84.29"></a><span id="l84.29"> /**</span>
<a href="#l84.30"></a><span id="l84.30">  * Ensure the given nsIMsgFolder's database is up-to-date, calling the provided</span>
<a href="#l84.31"></a><span id="l84.31">  *  callback once the folder has been loaded.  (This may be instantly or</span>
<a href="#l84.32"></a><span id="l84.32">  *  after a re-parse.)</span>
<a href="#l84.33"></a><span id="l84.33" class="difflineminus">- * </span>
<a href="#l84.34"></a><span id="l84.34" class="difflineplus">+ *</span>
<a href="#l84.35"></a><span id="l84.35">  * @param aFolder The nsIMsgFolder whose database you want to ensure is</span>
<a href="#l84.36"></a><span id="l84.36">  *     up-to-date.</span>
<a href="#l84.37"></a><span id="l84.37">  * @param aCallback The callback function to invoke once the folder has been</span>
<a href="#l84.38"></a><span id="l84.38">  *     loaded.</span>
<a href="#l84.39"></a><span id="l84.39">  * @param aCallbackThis The 'this' to use when calling the callback.  Pass null</span>
<a href="#l84.40"></a><span id="l84.40">  *     if your callback does not rely on 'this'.</span>
<a href="#l84.41"></a><span id="l84.41">  * @param aCallbackArgs A list of arguments to pass to the callback via apply.</span>
<a href="#l84.42"></a><span id="l84.42">  *     If you provide [1,2,3], we will effectively call:</span>
<a href="#l84.43"></a><span id="l84.43">  *     aCallbackThis.aCallback(1,2,3);</span>
<a href="#l84.44"></a><span id="l84.44" class="difflineplus">+ * @param [aSomeoneElseWillTriggerTheUpdate=false] If this is true, we do not</span>
<a href="#l84.45"></a><span id="l84.45" class="difflineplus">+ *     trigger the updateFolder call and it is assumed someone else is taking</span>
<a href="#l84.46"></a><span id="l84.46" class="difflineplus">+ *     care of that.</span>
<a href="#l84.47"></a><span id="l84.47">  */</span>
<a href="#l84.48"></a><span id="l84.48"> function updateFolderAndNotify(aFolder, aCallback, aCallbackThis,</span>
<a href="#l84.49"></a><span id="l84.49" class="difflineminus">-    aCallbackArgs) {</span>
<a href="#l84.50"></a><span id="l84.50" class="difflineplus">+    aCallbackArgs, aSomeoneElseWillTriggerTheUpdate) {</span>
<a href="#l84.51"></a><span id="l84.51">   // register for the folder loaded notification ahead of time... even though</span>
<a href="#l84.52"></a><span id="l84.52">   //  we may not need it...</span>
<a href="#l84.53"></a><span id="l84.53">   let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;]</span>
<a href="#l84.54"></a><span id="l84.54">                       .getService(Ci.nsIMsgMailSession);</span>
<a href="#l84.55"></a><span id="l84.55">   let atomService = Cc[&quot;@mozilla.org/atom-service;1&quot;]</span>
<a href="#l84.56"></a><span id="l84.56">                       .getService(Ci.nsIAtomService);</span>
<a href="#l84.57"></a><span id="l84.57">   let kFolderLoadedAtom = atomService.getAtom(&quot;FolderLoaded&quot;);</span>
<a href="#l84.58"></a><span id="l84.58"> </span>
<a href="#l84.59"></a><span id="l84.59" class="difflineat">@@ -273,12 +276,13 @@ function updateFolderAndNotify(aFolder, </span>
<a href="#l84.60"></a><span id="l84.60">         mailSession.RemoveFolderListener(this);</span>
<a href="#l84.61"></a><span id="l84.61">         aCallback.apply(aCallbackThis, aCallbackArgs);</span>
<a href="#l84.62"></a><span id="l84.62">       }</span>
<a href="#l84.63"></a><span id="l84.63">     }</span>
<a href="#l84.64"></a><span id="l84.64">   };</span>
<a href="#l84.65"></a><span id="l84.65"> </span>
<a href="#l84.66"></a><span id="l84.66">   mailSession.AddFolderListener(folderListener, Ci.nsIFolderListener.event);</span>
<a href="#l84.67"></a><span id="l84.67"> </span>
<a href="#l84.68"></a><span id="l84.68" class="difflineminus">-  aFolder.updateFolder(null);</span>
<a href="#l84.69"></a><span id="l84.69" class="difflineplus">+  if (!aSomeoneElseWillTriggerTheUpdate)</span>
<a href="#l84.70"></a><span id="l84.70" class="difflineplus">+    aFolder.updateFolder(null);</span>
<a href="#l84.71"></a><span id="l84.71"> }</span>
<a href="#l84.72"></a><span id="l84.72"> </span>
<a href="#l84.73"></a><span id="l84.73"> } // gMailTestUtils_js__</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l85.1"></a><span id="l85.1" class="difflineminus">--- a/mailnews/test/resources/messageGenerator.js</span>
<a href="#l85.2"></a><span id="l85.2" class="difflineplus">+++ b/mailnews/test/resources/messageGenerator.js</span>
<a href="#l85.3"></a><span id="l85.3" class="difflineat">@@ -337,21 +337,32 @@ SyntheticPartMultiSignedPGP.prototype = </span>
<a href="#l85.4"></a><span id="l85.4">   },</span>
<a href="#l85.5"></a><span id="l85.5"> };</span>
<a href="#l85.6"></a><span id="l85.6"> </span>
<a href="#l85.7"></a><span id="l85.7"> </span>
<a href="#l85.8"></a><span id="l85.8"> /**</span>
<a href="#l85.9"></a><span id="l85.9">  * A synthetic message, created by the MessageGenerator.  Captures both the</span>
<a href="#l85.10"></a><span id="l85.10">  *  ingredients that went into the synthetic message as well as the rfc822 form</span>
<a href="#l85.11"></a><span id="l85.11">  *  of the message.</span>
<a href="#l85.12"></a><span id="l85.12" class="difflineplus">+ * </span>
<a href="#l85.13"></a><span id="l85.13" class="difflineplus">+ * @param [aHeaders] A dictionary of rfc822 header payloads.  The key should be</span>
<a href="#l85.14"></a><span id="l85.14" class="difflineplus">+ *     capitalized as you want it to appear in the output.  This requires</span>
<a href="#l85.15"></a><span id="l85.15" class="difflineplus">+ *     adherence to convention of this class.  You are best to just use the</span>
<a href="#l85.16"></a><span id="l85.16" class="difflineplus">+ *     helpers provided by this class.</span>
<a href="#l85.17"></a><span id="l85.17" class="difflineplus">+ * @param [aBodyPart] An instance of one of the many Synthetic part types</span>
<a href="#l85.18"></a><span id="l85.18" class="difflineplus">+ *     available in this file.</span>
<a href="#l85.19"></a><span id="l85.19" class="difflineplus">+ * @param [aMetaState] A dictionary of meta-state about the message that is only</span>
<a href="#l85.20"></a><span id="l85.20" class="difflineplus">+ *     relevant to the messageInjection logic and perhaps some testing logic.</span>
<a href="#l85.21"></a><span id="l85.21" class="difflineplus">+ * @param [aMetaState.junk=false] Is the method junk?</span>
<a href="#l85.22"></a><span id="l85.22">  */</span>
<a href="#l85.23"></a><span id="l85.23" class="difflineminus">-function SyntheticMessage(aHeaders, aBodyPart) {</span>
<a href="#l85.24"></a><span id="l85.24" class="difflineplus">+function SyntheticMessage(aHeaders, aBodyPart, aMetaState) {</span>
<a href="#l85.25"></a><span id="l85.25">   // we currently do not need to call SyntheticPart's constructor...</span>
<a href="#l85.26"></a><span id="l85.26">   this.headers = aHeaders || {};</span>
<a href="#l85.27"></a><span id="l85.27">   this.bodyPart = aBodyPart || new SyntheticPartLeaf(&quot;&quot;);</span>
<a href="#l85.28"></a><span id="l85.28" class="difflineplus">+  this.metaState = aMetaState || {junk: false};</span>
<a href="#l85.29"></a><span id="l85.29"> }</span>
<a href="#l85.30"></a><span id="l85.30"> </span>
<a href="#l85.31"></a><span id="l85.31"> SyntheticMessage.prototype = {</span>
<a href="#l85.32"></a><span id="l85.32">   __proto__: SyntheticPart.prototype,</span>
<a href="#l85.33"></a><span id="l85.33">   _contentType: 'message/rfc822',</span>
<a href="#l85.34"></a><span id="l85.34">   _charset: null,</span>
<a href="#l85.35"></a><span id="l85.35">   _format: null,</span>
<a href="#l85.36"></a><span id="l85.36">   _encoding: null,</span>
<a href="#l85.37"></a><span id="l85.37" class="difflineat">@@ -762,39 +773,58 @@ MessageGenerator.prototype = {</span>
<a href="#l85.38"></a><span id="l85.38"> </span>
<a href="#l85.39"></a><span id="l85.39">   /**</span>
<a href="#l85.40"></a><span id="l85.40">    * Create a SyntheticMessage.  All arguments are optional, but allow</span>
<a href="#l85.41"></a><span id="l85.41">    *  additional control.  With no arguments specified, a new name/address will</span>
<a href="#l85.42"></a><span id="l85.42">    *  be generated that has not been used before, and sent to a new name/address</span>
<a href="#l85.43"></a><span id="l85.43">    *  that has not been used before.</span>
<a href="#l85.44"></a><span id="l85.44">    *</span>
<a href="#l85.45"></a><span id="l85.45">    * @param aArgs An object with any of the following attributes provided:</span>
<a href="#l85.46"></a><span id="l85.46" class="difflineminus">-   *     age: A dictionary with potential attributes 'minutes', 'hours', 'days',</span>
<a href="#l85.47"></a><span id="l85.47" class="difflineminus">-   *         'weeks' to specify the message be created that far in the past.</span>
<a href="#l85.48"></a><span id="l85.48" class="difflineminus">-   *     attachments: A list of dictionaries suitable for passing to</span>
<a href="#l85.49"></a><span id="l85.49" class="difflineminus">-   *         syntheticPartLeaf, plus a 'body' attribute that has already been</span>
<a href="#l85.50"></a><span id="l85.50" class="difflineminus">-   *         encoded.  Line chopping is on you FOR NOW.</span>
<a href="#l85.51"></a><span id="l85.51" class="difflineminus">-   *     body: A dictionary suitable for passing to SyntheticPart plus a 'body'</span>
<a href="#l85.52"></a><span id="l85.52" class="difflineminus">-   *         attribute that has already been encoded (if encoding is required).</span>
<a href="#l85.53"></a><span id="l85.53" class="difflineminus">-   *         Line chopping is on you FOR NOW.  Alternately, use bodyPart.</span>
<a href="#l85.54"></a><span id="l85.54" class="difflineminus">-   *     bodyPart: A SyntheticPart to uses as the body.  If you provide an</span>
<a href="#l85.55"></a><span id="l85.55" class="difflineminus">-   *         attachments value, this part will be wrapped in a multipart/mixed</span>
<a href="#l85.56"></a><span id="l85.56" class="difflineminus">-   *         to also hold your attachments.  (You can put attachments in the</span>
<a href="#l85.57"></a><span id="l85.57" class="difflineminus">-   *         bodyPart directly if you want and not use attachments.)</span>
<a href="#l85.58"></a><span id="l85.58" class="difflineminus">-   *     callerData: A value to propagate to the callerData attribute on the</span>
<a href="#l85.59"></a><span id="l85.59" class="difflineminus">-   *         resulting message.</span>
<a href="#l85.60"></a><span id="l85.60" class="difflineminus">-   *     inReplyTo: the SyntheticMessage this message should be in reply-to.</span>
<a href="#l85.61"></a><span id="l85.61" class="difflineminus">-   *         If that message was in reply to another message, we will</span>
<a href="#l85.62"></a><span id="l85.62" class="difflineminus">-   *         appropriately compensate for that.  If a SyntheticMessageSet is</span>
<a href="#l85.63"></a><span id="l85.63" class="difflineminus">-   *         provided we will use the first message in the set.</span>
<a href="#l85.64"></a><span id="l85.64" class="difflineminus">-   *     replyAll: a boolean indicating whether this should be a reply-to-all or</span>
<a href="#l85.65"></a><span id="l85.65" class="difflineminus">-   *         just to the author of the message.  (er, to-only, not cc.)</span>
<a href="#l85.66"></a><span id="l85.66" class="difflineminus">-   *     subject: The subject to use; you are responsible for doing any encoding</span>
<a href="#l85.67"></a><span id="l85.67" class="difflineminus">-   *         before passing it in.</span>
<a href="#l85.68"></a><span id="l85.68" class="difflineminus">-   *     toCount: the number of people who the message should be to.</span>
<a href="#l85.69"></a><span id="l85.69" class="difflineplus">+   * @param [aArgs.age] A dictionary with potential attributes 'minutes',</span>
<a href="#l85.70"></a><span id="l85.70" class="difflineplus">+   *     'hours', 'days', 'weeks' to specify the message be created that far in</span>
<a href="#l85.71"></a><span id="l85.71" class="difflineplus">+   *     the past.</span>
<a href="#l85.72"></a><span id="l85.72" class="difflineplus">+   * @param [aArgs.attachments] A list of dictionaries suitable for passing to</span>
<a href="#l85.73"></a><span id="l85.73" class="difflineplus">+   *     syntheticPartLeaf, plus a 'body' attribute that has already been</span>
<a href="#l85.74"></a><span id="l85.74" class="difflineplus">+   *     encoded.  Line chopping is on you FOR NOW.</span>
<a href="#l85.75"></a><span id="l85.75" class="difflineplus">+   * @param [aArgs.body] A dictionary suitable for passing to SyntheticPart plus</span>
<a href="#l85.76"></a><span id="l85.76" class="difflineplus">+   *     a 'body' attribute that has already been encoded (if encoding is</span>
<a href="#l85.77"></a><span id="l85.77" class="difflineplus">+   *     required).  Line chopping is on you FOR NOW.  Alternately, use</span>
<a href="#l85.78"></a><span id="l85.78" class="difflineplus">+   *     bodyPart.</span>
<a href="#l85.79"></a><span id="l85.79" class="difflineplus">+   * @param [aArgs.bodyPart] A SyntheticPart to uses as the body.  If you</span>
<a href="#l85.80"></a><span id="l85.80" class="difflineplus">+   *     provide an attachments value, this part will be wrapped in a</span>
<a href="#l85.81"></a><span id="l85.81" class="difflineplus">+   *     multipart/mixed to also hold your attachments.  (You can put</span>
<a href="#l85.82"></a><span id="l85.82" class="difflineplus">+   *     attachments in the bodyPart directly if you want and not use</span>
<a href="#l85.83"></a><span id="l85.83" class="difflineplus">+   *     attachments.)</span>
<a href="#l85.84"></a><span id="l85.84" class="difflineplus">+   * @param [aArgs.callerData] A value to propagate to the callerData attribute</span>
<a href="#l85.85"></a><span id="l85.85" class="difflineplus">+   *     on the resulting message.</span>
<a href="#l85.86"></a><span id="l85.86" class="difflineplus">+   * @param [aArgs.cc] A list of cc recipients (name and address pairs).  If</span>
<a href="#l85.87"></a><span id="l85.87" class="difflineplus">+   *     omitted, no cc is generated.</span>
<a href="#l85.88"></a><span id="l85.88" class="difflineplus">+   * @param [aArgs.from] The name and value pair this message should be from.</span>
<a href="#l85.89"></a><span id="l85.89" class="difflineplus">+   *     Defaults to the first recipient if this is a reply, otherwise a new</span>
<a href="#l85.90"></a><span id="l85.90" class="difflineplus">+   *     person is synthesized via |makeNameAndAddress|.</span>
<a href="#l85.91"></a><span id="l85.91" class="difflineplus">+   * @param [aArgs.inReplyTo] the SyntheticMessage this message should be in</span>
<a href="#l85.92"></a><span id="l85.92" class="difflineplus">+   *     reply-to.  If that message was in reply to another message, we will</span>
<a href="#l85.93"></a><span id="l85.93" class="difflineplus">+   *     appropriately compensate for that.  If a SyntheticMessageSet is</span>
<a href="#l85.94"></a><span id="l85.94" class="difflineplus">+   *     provided we will use the first message in the set.</span>
<a href="#l85.95"></a><span id="l85.95" class="difflineplus">+   * @param [aArgs.replyAll] a boolean indicating whether this should be a</span>
<a href="#l85.96"></a><span id="l85.96" class="difflineplus">+   *     reply-to-all or just to the author of the message.  (er, to-only, not</span>
<a href="#l85.97"></a><span id="l85.97" class="difflineplus">+   *     cc.)</span>
<a href="#l85.98"></a><span id="l85.98" class="difflineplus">+   * @param [aArgs.subject] subject to use; you are responsible for doing any</span>
<a href="#l85.99"></a><span id="l85.99" class="difflineplus">+   *     encoding before passing it in.</span>
<a href="#l85.100"></a><span id="l85.100" class="difflineplus">+   * @param [aArgs.to] The list of recipients for this message, defaults to a</span>
<a href="#l85.101"></a><span id="l85.101" class="difflineplus">+   *     set of toCount newly created persons.</span>
<a href="#l85.102"></a><span id="l85.102" class="difflineplus">+   * @param [aArgs.toCount=1] the number of people who the message should be to.</span>
<a href="#l85.103"></a><span id="l85.103" class="difflineplus">+   * @param [aArgs.clobberHeaders] An object whose contents will overwrite the</span>
<a href="#l85.104"></a><span id="l85.104" class="difflineplus">+   *     contents of the headers object.  This should only be used to construct</span>
<a href="#l85.105"></a><span id="l85.105" class="difflineplus">+   *     illegal header values; general usage should use another explicit</span>
<a href="#l85.106"></a><span id="l85.106" class="difflineplus">+   *     mechanism.</span>
<a href="#l85.107"></a><span id="l85.107" class="difflineplus">+   * @param [aArgs.junk] Should this message be flagged as junk for the benefit</span>
<a href="#l85.108"></a><span id="l85.108" class="difflineplus">+   *     of the messageInjection helper so that it can know to flag the message</span>
<a href="#l85.109"></a><span id="l85.109" class="difflineplus">+   *     as junk?  We have no concept of marking a message as definitely not</span>
<a href="#l85.110"></a><span id="l85.110" class="difflineplus">+   *     junk at this point.</span>
<a href="#l85.111"></a><span id="l85.111">    * @returns a SyntheticMessage fashioned just to your liking.</span>
<a href="#l85.112"></a><span id="l85.112">    */</span>
<a href="#l85.113"></a><span id="l85.113">   makeMessage: function(aArgs) {</span>
<a href="#l85.114"></a><span id="l85.114">     aArgs = aArgs || {};</span>
<a href="#l85.115"></a><span id="l85.115">     let msg = new SyntheticMessage();</span>
<a href="#l85.116"></a><span id="l85.116"> </span>
<a href="#l85.117"></a><span id="l85.117">     if (aArgs.inReplyTo) {</span>
<a href="#l85.118"></a><span id="l85.118">       // If inReplyTo is a SyntheticMessageSet, just use the first message in</span>
<a href="#l85.119"></a><span id="l85.119" class="difflineat">@@ -844,16 +874,28 @@ MessageGenerator.prototype = {</span>
<a href="#l85.120"></a><span id="l85.120">       if (age.weeks)</span>
<a href="#l85.121"></a><span id="l85.121">         ts -= age.weeks * 7 * 24 * 60 * 60 * 1000;</span>
<a href="#l85.122"></a><span id="l85.122">       msg.date = new Date(ts);</span>
<a href="#l85.123"></a><span id="l85.123">     }</span>
<a href="#l85.124"></a><span id="l85.124">     else {</span>
<a href="#l85.125"></a><span id="l85.125">       msg.date = this.makeDate();</span>
<a href="#l85.126"></a><span id="l85.126">     }</span>
<a href="#l85.127"></a><span id="l85.127"> </span>
<a href="#l85.128"></a><span id="l85.128" class="difflineplus">+    if (&quot;clobberHeaders&quot; in aArgs) {</span>
<a href="#l85.129"></a><span id="l85.129" class="difflineplus">+      for each (let [key, value] in Iterator(aArgs.clobberHeaders)) {</span>
<a href="#l85.130"></a><span id="l85.130" class="difflineplus">+        msg.headers[key] = value;</span>
<a href="#l85.131"></a><span id="l85.131" class="difflineplus">+        // clobber helper...</span>
<a href="#l85.132"></a><span id="l85.132" class="difflineplus">+        if (key == &quot;From&quot;)</span>
<a href="#l85.133"></a><span id="l85.133" class="difflineplus">+          msg._from = [&quot;&quot;, &quot;&quot;];</span>
<a href="#l85.134"></a><span id="l85.134" class="difflineplus">+      }</span>
<a href="#l85.135"></a><span id="l85.135" class="difflineplus">+    }</span>
<a href="#l85.136"></a><span id="l85.136" class="difflineplus">+</span>
<a href="#l85.137"></a><span id="l85.137" class="difflineplus">+    if (&quot;junk&quot; in aArgs &amp;&amp; aArgs.junk)</span>
<a href="#l85.138"></a><span id="l85.138" class="difflineplus">+      msg.metaState.junk = true;</span>
<a href="#l85.139"></a><span id="l85.139" class="difflineplus">+</span>
<a href="#l85.140"></a><span id="l85.140">     let bodyPart;</span>
<a href="#l85.141"></a><span id="l85.141">     if (aArgs.bodyPart)</span>
<a href="#l85.142"></a><span id="l85.142">       bodyPart = aArgs.bodyPart;</span>
<a href="#l85.143"></a><span id="l85.143">     else if (aArgs.body)</span>
<a href="#l85.144"></a><span id="l85.144">       bodyPart = new SyntheticPartLeaf(aArgs.body.body, aArgs.body);</span>
<a href="#l85.145"></a><span id="l85.145">     else // different messages should have a chance at different bodies</span>
<a href="#l85.146"></a><span id="l85.146">       bodyPart = new SyntheticPartLeaf(&quot;Hello &quot; + msg.toName + &quot;!&quot;);</span>
<a href="#l85.147"></a><span id="l85.147"> </span>
<a href="#l85.148"></a><span id="l85.148" class="difflineat">@@ -872,31 +914,36 @@ MessageGenerator.prototype = {</span>
<a href="#l85.149"></a><span id="l85.149"> </span>
<a href="#l85.150"></a><span id="l85.150">     return msg;</span>
<a href="#l85.151"></a><span id="l85.151">   },</span>
<a href="#l85.152"></a><span id="l85.152"> </span>
<a href="#l85.153"></a><span id="l85.153">   MAKE_MESSAGES_DEFAULTS: {</span>
<a href="#l85.154"></a><span id="l85.154">     count: 10,</span>
<a href="#l85.155"></a><span id="l85.155">   },</span>
<a href="#l85.156"></a><span id="l85.156">   MAKE_MESSAGES_PROPAGATE: ['attachments', 'body', 'cc', 'from', 'inReplyTo',</span>
<a href="#l85.157"></a><span id="l85.157" class="difflineminus">-                            'subject', 'to'],</span>
<a href="#l85.158"></a><span id="l85.158" class="difflineplus">+                            'subject', 'to', 'clobberHeaders', 'junk'],</span>
<a href="#l85.159"></a><span id="l85.159">   /**</span>
<a href="#l85.160"></a><span id="l85.160">    * Given a set definition, produce a list of synthetic messages.</span>
<a href="#l85.161"></a><span id="l85.161">    *</span>
<a href="#l85.162"></a><span id="l85.162">    * The set definition supports the following attributes:</span>
<a href="#l85.163"></a><span id="l85.163">    *  count: The number of messages to create.</span>
<a href="#l85.164"></a><span id="l85.164">    *  age: As used by makeMessage.</span>
<a href="#l85.165"></a><span id="l85.165">    *  age_incr: Similar to age, but used to increment the values in the age</span>
<a href="#l85.166"></a><span id="l85.166">    *      dictionary (assuming a value of zero if omitted).</span>
<a href="#l85.167"></a><span id="l85.167" class="difflineplus">+   *  @param [aSetDef.msgsPerThread=1] The number of messages per thread.  If</span>
<a href="#l85.168"></a><span id="l85.168" class="difflineplus">+   *      you want to create direct-reply threads, you can pass a value for this</span>
<a href="#l85.169"></a><span id="l85.169" class="difflineplus">+   *      and have it not be one.  If you need fancier reply situations,</span>
<a href="#l85.170"></a><span id="l85.170" class="difflineplus">+   *      directly use a scenario or hook us up to support that.</span>
<a href="#l85.171"></a><span id="l85.171">    *</span>
<a href="#l85.172"></a><span id="l85.172">    * Also supported are the following attributes as defined by makeMessage:</span>
<a href="#l85.173"></a><span id="l85.173" class="difflineminus">-   *  attachments, body, from, inReplyTo, subject, to</span>
<a href="#l85.174"></a><span id="l85.174" class="difflineplus">+   *  attachments, body, from, inReplyTo, subject, to, clobberHeaders, junk</span>
<a href="#l85.175"></a><span id="l85.175">    *</span>
<a href="#l85.176"></a><span id="l85.176" class="difflineminus">-   * If omitted, the following defaults are used:</span>
<a href="#l85.177"></a><span id="l85.177" class="difflineminus">-   *  count: 10</span>
<a href="#l85.178"></a><span id="l85.178" class="difflineplus">+   * If omitted, the following defaults are used, but don't depend on this as we</span>
<a href="#l85.179"></a><span id="l85.179" class="difflineplus">+   *  can change these at any time:</span>
<a href="#l85.180"></a><span id="l85.180" class="difflineplus">+   * - count: 10</span>
<a href="#l85.181"></a><span id="l85.181">    */</span>
<a href="#l85.182"></a><span id="l85.182">   makeMessages: function MessageGenerator_makeMessages(aSetDef) {</span>
<a href="#l85.183"></a><span id="l85.183">     let messages = [];</span>
<a href="#l85.184"></a><span id="l85.184"> </span>
<a href="#l85.185"></a><span id="l85.185">     let args = {};</span>
<a href="#l85.186"></a><span id="l85.186">     // zero out all the age_incr fields in age (if present)</span>
<a href="#l85.187"></a><span id="l85.187">     if (aSetDef.age_incr) {</span>
<a href="#l85.188"></a><span id="l85.188">       args.age = {};</span>
<a href="#l85.189"></a><span id="l85.189" class="difflineat">@@ -911,18 +958,26 @@ MessageGenerator.prototype = {</span>
<a href="#l85.190"></a><span id="l85.190">     }</span>
<a href="#l85.191"></a><span id="l85.191">     // just copy over any attributes found from MAKE_MESSAGES_PROPAGATE</span>
<a href="#l85.192"></a><span id="l85.192">     for each (let [, propAttrName] in Iterator(this.MAKE_MESSAGES_PROPAGATE)) {</span>
<a href="#l85.193"></a><span id="l85.193">       if (aSetDef[propAttrName])</span>
<a href="#l85.194"></a><span id="l85.194">         args[propAttrName] = aSetDef[propAttrName];</span>
<a href="#l85.195"></a><span id="l85.195">     }</span>
<a href="#l85.196"></a><span id="l85.196"> </span>
<a href="#l85.197"></a><span id="l85.197">     let count = aSetDef.count || this.MAKE_MESSAGES_DEFAULTS.count;</span>
<a href="#l85.198"></a><span id="l85.198" class="difflineplus">+    let messagsPerThread = aSetDef.msgsPerThread || 1;</span>
<a href="#l85.199"></a><span id="l85.199" class="difflineplus">+    let lastMessage = null;</span>
<a href="#l85.200"></a><span id="l85.200">     for (let iMsg = 0; iMsg &lt; count; iMsg++) {</span>
<a href="#l85.201"></a><span id="l85.201" class="difflineminus">-      messages.push(this.makeMessage(args));</span>
<a href="#l85.202"></a><span id="l85.202" class="difflineplus">+      // primitive threading support...</span>
<a href="#l85.203"></a><span id="l85.203" class="difflineplus">+      if (lastMessage &amp;&amp; (iMsg % messagsPerThread != 0))</span>
<a href="#l85.204"></a><span id="l85.204" class="difflineplus">+        args.inReplyTo = lastMessage;</span>
<a href="#l85.205"></a><span id="l85.205" class="difflineplus">+      else</span>
<a href="#l85.206"></a><span id="l85.206" class="difflineplus">+        args.inReplyTo = null;</span>
<a href="#l85.207"></a><span id="l85.207" class="difflineplus">+      lastMessage = this.makeMessage(args);</span>
<a href="#l85.208"></a><span id="l85.208" class="difflineplus">+      messages.push(lastMessage);</span>
<a href="#l85.209"></a><span id="l85.209"> </span>
<a href="#l85.210"></a><span id="l85.210">       if (aSetDef.age_incr) {</span>
<a href="#l85.211"></a><span id="l85.211">         for (let [unit, delta] in Iterator(aSetDef.age_incr))</span>
<a href="#l85.212"></a><span id="l85.212">           args.age[unit] += delta;</span>
<a href="#l85.213"></a><span id="l85.213">       }</span>
<a href="#l85.214"></a><span id="l85.214">     }</span>
<a href="#l85.215"></a><span id="l85.215"> </span>
<a href="#l85.216"></a><span id="l85.216">     return messages;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l86.1"></a><span id="l86.1">new file mode 100644</span>
<a href="#l86.2"></a><span id="l86.2" class="difflineminus">--- /dev/null</span>
<a href="#l86.3"></a><span id="l86.3" class="difflineplus">+++ b/mailnews/test/resources/messageInjection.js</span>
<a href="#l86.4"></a><span id="l86.4" class="difflineat">@@ -0,0 +1,900 @@</span>
<a href="#l86.5"></a><span id="l86.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l86.6"></a><span id="l86.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l86.7"></a><span id="l86.7" class="difflineplus">+ *</span>
<a href="#l86.8"></a><span id="l86.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l86.9"></a><span id="l86.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l86.10"></a><span id="l86.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l86.11"></a><span id="l86.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l86.12"></a><span id="l86.12" class="difflineplus">+ *</span>
<a href="#l86.13"></a><span id="l86.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l86.14"></a><span id="l86.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l86.15"></a><span id="l86.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l86.16"></a><span id="l86.16" class="difflineplus">+ * License.</span>
<a href="#l86.17"></a><span id="l86.17" class="difflineplus">+ *</span>
<a href="#l86.18"></a><span id="l86.18" class="difflineplus">+ * The Original Code is Thunderbird Mail Client.</span>
<a href="#l86.19"></a><span id="l86.19" class="difflineplus">+ *</span>
<a href="#l86.20"></a><span id="l86.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l86.21"></a><span id="l86.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l86.22"></a><span id="l86.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2009</span>
<a href="#l86.23"></a><span id="l86.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l86.24"></a><span id="l86.24" class="difflineplus">+ *</span>
<a href="#l86.25"></a><span id="l86.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l86.26"></a><span id="l86.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l86.27"></a><span id="l86.27" class="difflineplus">+ *</span>
<a href="#l86.28"></a><span id="l86.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l86.29"></a><span id="l86.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l86.30"></a><span id="l86.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l86.31"></a><span id="l86.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l86.32"></a><span id="l86.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l86.33"></a><span id="l86.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l86.34"></a><span id="l86.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l86.35"></a><span id="l86.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l86.36"></a><span id="l86.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l86.37"></a><span id="l86.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l86.38"></a><span id="l86.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l86.39"></a><span id="l86.39" class="difflineplus">+ *</span>
<a href="#l86.40"></a><span id="l86.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l86.41"></a><span id="l86.41" class="difflineplus">+</span>
<a href="#l86.42"></a><span id="l86.42" class="difflineplus">+var gMessageGenerator, gMessageScenarioFactory;</span>
<a href="#l86.43"></a><span id="l86.43" class="difflineplus">+</span>
<a href="#l86.44"></a><span id="l86.44" class="difflineplus">+/**</span>
<a href="#l86.45"></a><span id="l86.45" class="difflineplus">+ * @param aInjectionConfig.mode One of &quot;local&quot;, &quot;pop&quot;, &quot;imap&quot;.</span>
<a href="#l86.46"></a><span id="l86.46" class="difflineplus">+ * @param [aInjectionConfig.offline] Should the folder be marked offline (and</span>
<a href="#l86.47"></a><span id="l86.47" class="difflineplus">+ *     fully downloaded)?  Only relevant for IMAP.</span>
<a href="#l86.48"></a><span id="l86.48" class="difflineplus">+ *</span>
<a href="#l86.49"></a><span id="l86.49" class="difflineplus">+ * @return {nsIMsgFolder} The Inbox folder.  You do not have to use this to</span>
<a href="#l86.50"></a><span id="l86.50" class="difflineplus">+ *     put messages in; you can create one (or more) using |make_empty_folder|.</span>
<a href="#l86.51"></a><span id="l86.51" class="difflineplus">+ */</span>
<a href="#l86.52"></a><span id="l86.52" class="difflineplus">+function configure_message_injection(aInjectionConfig) {</span>
<a href="#l86.53"></a><span id="l86.53" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.54"></a><span id="l86.54" class="difflineplus">+  mis.injectionConfig = aInjectionConfig;</span>
<a href="#l86.55"></a><span id="l86.55" class="difflineplus">+</span>
<a href="#l86.56"></a><span id="l86.56" class="difflineplus">+  // Disable new mail notifications</span>
<a href="#l86.57"></a><span id="l86.57" class="difflineplus">+  var prefSvc = Cc[&quot;@mozilla.org/preferences-service;1&quot;]</span>
<a href="#l86.58"></a><span id="l86.58" class="difflineplus">+                  .getService(Ci.nsIPrefBranch);</span>
<a href="#l86.59"></a><span id="l86.59" class="difflineplus">+</span>
<a href="#l86.60"></a><span id="l86.60" class="difflineplus">+  prefSvc.setBoolPref(&quot;mail.biff.play_sound&quot;, false);</span>
<a href="#l86.61"></a><span id="l86.61" class="difflineplus">+  prefSvc.setBoolPref(&quot;mail.biff.show_alert&quot;, false);</span>
<a href="#l86.62"></a><span id="l86.62" class="difflineplus">+  prefSvc.setBoolPref(&quot;mail.biff.show_tray_icon&quot;, false);</span>
<a href="#l86.63"></a><span id="l86.63" class="difflineplus">+  prefSvc.setBoolPref(&quot;mail.biff.animate_dock_icon&quot;, false);</span>
<a href="#l86.64"></a><span id="l86.64" class="difflineplus">+</span>
<a href="#l86.65"></a><span id="l86.65" class="difflineplus">+</span>
<a href="#l86.66"></a><span id="l86.66" class="difflineplus">+  // we need to pull in the notification service so we get events?</span>
<a href="#l86.67"></a><span id="l86.67" class="difflineplus">+  mis.mfnService = Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;]</span>
<a href="#l86.68"></a><span id="l86.68" class="difflineplus">+                     .getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l86.69"></a><span id="l86.69" class="difflineplus">+</span>
<a href="#l86.70"></a><span id="l86.70" class="difflineplus">+</span>
<a href="#l86.71"></a><span id="l86.71" class="difflineplus">+  let acctMgr = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;]</span>
<a href="#l86.72"></a><span id="l86.72" class="difflineplus">+                  .getService(Ci.nsIMsgAccountManager);</span>
<a href="#l86.73"></a><span id="l86.73" class="difflineplus">+</span>
<a href="#l86.74"></a><span id="l86.74" class="difflineplus">+  if (mis.injectionConfig.mode == &quot;pop&quot;) {</span>
<a href="#l86.75"></a><span id="l86.75" class="difflineplus">+    // -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l86.76"></a><span id="l86.76" class="difflineplus">+    load(&quot;../../test_mailnewslocal/unit/head_maillocal.js&quot;);</span>
<a href="#l86.77"></a><span id="l86.77" class="difflineplus">+    // set up POP3 fakeserver to feed things in...</span>
<a href="#l86.78"></a><span id="l86.78" class="difflineplus">+    [mis.daemon, mis.server] = setupServerDaemon();</span>
<a href="#l86.79"></a><span id="l86.79" class="difflineplus">+    // (this will call loadLocalMailAccount())</span>
<a href="#l86.80"></a><span id="l86.80" class="difflineplus">+    mis.incomingServer = createPop3ServerAndLocalFolders();</span>
<a href="#l86.81"></a><span id="l86.81" class="difflineplus">+</span>
<a href="#l86.82"></a><span id="l86.82" class="difflineplus">+    // do not log transactions; it's just a memory leak to us</span>
<a href="#l86.83"></a><span id="l86.83" class="difflineplus">+    mis.server._logTransactions = false;</span>
<a href="#l86.84"></a><span id="l86.84" class="difflineplus">+</span>
<a href="#l86.85"></a><span id="l86.85" class="difflineplus">+    mis.rootFolder = mis.incomingServer.rootMsgFolder;</span>
<a href="#l86.86"></a><span id="l86.86" class="difflineplus">+    mis.inboxFolder = mis.rootFolder.getChildNamed(&quot;Inbox&quot;);</span>
<a href="#l86.87"></a><span id="l86.87" class="difflineplus">+</span>
<a href="#l86.88"></a><span id="l86.88" class="difflineplus">+    mis.pop3Service = Cc[&quot;@mozilla.org/messenger/popservice;1&quot;]</span>
<a href="#l86.89"></a><span id="l86.89" class="difflineplus">+      .getService(Ci.nsIPop3Service);</span>
<a href="#l86.90"></a><span id="l86.90" class="difflineplus">+</span>
<a href="#l86.91"></a><span id="l86.91" class="difflineplus">+    mis.server.start(POP3_PORT);</span>
<a href="#l86.92"></a><span id="l86.92" class="difflineplus">+  }</span>
<a href="#l86.93"></a><span id="l86.93" class="difflineplus">+  else if (mis.injectionConfig.mode == &quot;local&quot;) {</span>
<a href="#l86.94"></a><span id="l86.94" class="difflineplus">+    // This does createIncomingServer() and createAccount(), sets the server as</span>
<a href="#l86.95"></a><span id="l86.95" class="difflineplus">+    //  the account's server, then sets the server</span>
<a href="#l86.96"></a><span id="l86.96" class="difflineplus">+    try {</span>
<a href="#l86.97"></a><span id="l86.97" class="difflineplus">+      acctMgr.createLocalMailAccount();</span>
<a href="#l86.98"></a><span id="l86.98" class="difflineplus">+    }</span>
<a href="#l86.99"></a><span id="l86.99" class="difflineplus">+    catch (ex) {</span>
<a href="#l86.100"></a><span id="l86.100" class="difflineplus">+      // This will fail if someone already called this.  Like in the mozmill</span>
<a href="#l86.101"></a><span id="l86.101" class="difflineplus">+      //  case.</span>
<a href="#l86.102"></a><span id="l86.102" class="difflineplus">+    }</span>
<a href="#l86.103"></a><span id="l86.103" class="difflineplus">+</span>
<a href="#l86.104"></a><span id="l86.104" class="difflineplus">+    let localAccount = acctMgr.FindAccountForServer(acctMgr.localFoldersServer);</span>
<a href="#l86.105"></a><span id="l86.105" class="difflineplus">+</span>
<a href="#l86.106"></a><span id="l86.106" class="difflineplus">+    // We need an identity or we get angry warnings.</span>
<a href="#l86.107"></a><span id="l86.107" class="difflineplus">+    let identity = acctMgr.createIdentity();</span>
<a href="#l86.108"></a><span id="l86.108" class="difflineplus">+    localAccount.addIdentity(identity);</span>
<a href="#l86.109"></a><span id="l86.109" class="difflineplus">+    localAccount.defaultIdentity = identity;</span>
<a href="#l86.110"></a><span id="l86.110" class="difflineplus">+</span>
<a href="#l86.111"></a><span id="l86.111" class="difflineplus">+    mis.incomingServer = acctMgr.localFoldersServer;</span>
<a href="#l86.112"></a><span id="l86.112" class="difflineplus">+    // Note: Inbox is not created automatically when there is no deferred server,</span>
<a href="#l86.113"></a><span id="l86.113" class="difflineplus">+    // so we need to create it.</span>
<a href="#l86.114"></a><span id="l86.114" class="difflineplus">+    mis.rootFolder = mis.incomingServer.rootMsgFolder;</span>
<a href="#l86.115"></a><span id="l86.115" class="difflineplus">+    mis.inboxFolder = mis.rootFolder.addSubfolder(&quot;Inbox&quot;);</span>
<a href="#l86.116"></a><span id="l86.116" class="difflineplus">+    // a local inbox should have a Mail flag!</span>
<a href="#l86.117"></a><span id="l86.117" class="difflineplus">+    mis.inboxFolder.setFlag(Ci.nsMsgFolderFlags.Mail);</span>
<a href="#l86.118"></a><span id="l86.118" class="difflineplus">+    mis.inboxFolder.setFlag(Ci.nsMsgFolderFlags.Inbox);</span>
<a href="#l86.119"></a><span id="l86.119" class="difflineplus">+</span>
<a href="#l86.120"></a><span id="l86.120" class="difflineplus">+    // Force an initialization of the Inbox folder database.</span>
<a href="#l86.121"></a><span id="l86.121" class="difflineplus">+    let unused = mis.inboxFolder.prettiestName;</span>
<a href="#l86.122"></a><span id="l86.122" class="difflineplus">+  }</span>
<a href="#l86.123"></a><span id="l86.123" class="difflineplus">+  else if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l86.124"></a><span id="l86.124" class="difflineplus">+    const gPrefs = Cc[&quot;@mozilla.org/preferences-service;1&quot;]</span>
<a href="#l86.125"></a><span id="l86.125" class="difflineplus">+                     .getService(Ci.nsIPrefBranch);</span>
<a href="#l86.126"></a><span id="l86.126" class="difflineplus">+    // Disable autosync in favor of our explicitly forcing downloads of all</span>
<a href="#l86.127"></a><span id="l86.127" class="difflineplus">+    //  messages in a folder.  This is being done speculatively because when we</span>
<a href="#l86.128"></a><span id="l86.128" class="difflineplus">+    //  didn't do this we got tripped up by the semaphore being in use and</span>
<a href="#l86.129"></a><span id="l86.129" class="difflineplus">+    //  concern over inability to hang a listener off of the completion of the</span>
<a href="#l86.130"></a><span id="l86.130" class="difflineplus">+    //  download.  (Although I'm sure there are various ways we could do it.)</span>
<a href="#l86.131"></a><span id="l86.131" class="difflineplus">+    gPrefs.setBoolPref(&quot;mail.server.default.autosync_offline_stores&quot;, false);</span>
<a href="#l86.132"></a><span id="l86.132" class="difflineplus">+    // Set the offline property based on the configured setting.  This will</span>
<a href="#l86.133"></a><span id="l86.133" class="difflineplus">+    //  affect newly created folders.</span>
<a href="#l86.134"></a><span id="l86.134" class="difflineplus">+    gPrefs.setBoolPref(&quot;mail.server.default.offline_download&quot;,</span>
<a href="#l86.135"></a><span id="l86.135" class="difflineplus">+                       mis.injectionConfig.offline);</span>
<a href="#l86.136"></a><span id="l86.136" class="difflineplus">+</span>
<a href="#l86.137"></a><span id="l86.137" class="difflineplus">+    // Pull in the IMAP fake server code</span>
<a href="#l86.138"></a><span id="l86.138" class="difflineplus">+    load(&quot;../../test_imap/unit/head_server.js&quot;);</span>
<a href="#l86.139"></a><span id="l86.139" class="difflineplus">+</span>
<a href="#l86.140"></a><span id="l86.140" class="difflineplus">+    // set up IMAP fakeserver and incoming server</span>
<a href="#l86.141"></a><span id="l86.141" class="difflineplus">+    mis.daemon = new imapDaemon();</span>
<a href="#l86.142"></a><span id="l86.142" class="difflineplus">+    mis.server = makeServer(mis.daemon, &quot;&quot;);</span>
<a href="#l86.143"></a><span id="l86.143" class="difflineplus">+    mis.incomingServer = createLocalIMAPServer();</span>
<a href="#l86.144"></a><span id="l86.144" class="difflineplus">+    //mis.server._debug = 3;</span>
<a href="#l86.145"></a><span id="l86.145" class="difflineplus">+</span>
<a href="#l86.146"></a><span id="l86.146" class="difflineplus">+    // do not log transactions; it's just a memory leak to us</span>
<a href="#l86.147"></a><span id="l86.147" class="difflineplus">+    mis.server._logTransactions = false;</span>
<a href="#l86.148"></a><span id="l86.148" class="difflineplus">+</span>
<a href="#l86.149"></a><span id="l86.149" class="difflineplus">+    // we need a local account for the IMAP server to have its sent messages in</span>
<a href="#l86.150"></a><span id="l86.150" class="difflineplus">+    acctMgr.createLocalMailAccount();</span>
<a href="#l86.151"></a><span id="l86.151" class="difflineplus">+</span>
<a href="#l86.152"></a><span id="l86.152" class="difflineplus">+    // We need an identity so that updateFolder doesn't fail</span>
<a href="#l86.153"></a><span id="l86.153" class="difflineplus">+    let localAccount = acctMgr.createAccount();</span>
<a href="#l86.154"></a><span id="l86.154" class="difflineplus">+    let identity = acctMgr.createIdentity();</span>
<a href="#l86.155"></a><span id="l86.155" class="difflineplus">+    localAccount.addIdentity(identity);</span>
<a href="#l86.156"></a><span id="l86.156" class="difflineplus">+    localAccount.defaultIdentity = identity;</span>
<a href="#l86.157"></a><span id="l86.157" class="difflineplus">+    localAccount.incomingServer = mis.incomingServer;</span>
<a href="#l86.158"></a><span id="l86.158" class="difflineplus">+    acctMgr.defaultAccount = localAccount;</span>
<a href="#l86.159"></a><span id="l86.159" class="difflineplus">+</span>
<a href="#l86.160"></a><span id="l86.160" class="difflineplus">+    // Let's also have another account, using the same identity</span>
<a href="#l86.161"></a><span id="l86.161" class="difflineplus">+    let imapAccount = acctMgr.createAccount();</span>
<a href="#l86.162"></a><span id="l86.162" class="difflineplus">+    imapAccount.addIdentity(identity);</span>
<a href="#l86.163"></a><span id="l86.163" class="difflineplus">+    imapAccount.defaultIdentity = identity;</span>
<a href="#l86.164"></a><span id="l86.164" class="difflineplus">+    imapAccount.incomingServer = mis.incomingServer;</span>
<a href="#l86.165"></a><span id="l86.165" class="difflineplus">+</span>
<a href="#l86.166"></a><span id="l86.166" class="difflineplus">+    // The server doesn't support more than one connection</span>
<a href="#l86.167"></a><span id="l86.167" class="difflineplus">+    prefSvc.setIntPref(&quot;mail.server.server1.max_cached_connections&quot;, 1);</span>
<a href="#l86.168"></a><span id="l86.168" class="difflineplus">+    // We aren't interested in downloading messages automatically</span>
<a href="#l86.169"></a><span id="l86.169" class="difflineplus">+    prefSvc.setBoolPref(&quot;mail.server.server1.download_on_biff&quot;, false);</span>
<a href="#l86.170"></a><span id="l86.170" class="difflineplus">+</span>
<a href="#l86.171"></a><span id="l86.171" class="difflineplus">+    mis.rootFolder = mis.incomingServer.rootMsgFolder;</span>
<a href="#l86.172"></a><span id="l86.172" class="difflineplus">+</span>
<a href="#l86.173"></a><span id="l86.173" class="difflineplus">+    mis.inboxFolder = mis.rootFolder.getChildNamed(&quot;Inbox&quot;);</span>
<a href="#l86.174"></a><span id="l86.174" class="difflineplus">+    // make sure the inbox's offline state is correct. (may be excessive now</span>
<a href="#l86.175"></a><span id="l86.175" class="difflineplus">+    //  that we set the pref above?)</span>
<a href="#l86.176"></a><span id="l86.176" class="difflineplus">+    if (mis.injectionConfig.offline)</span>
<a href="#l86.177"></a><span id="l86.177" class="difflineplus">+      mis.inboxFolder.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l86.178"></a><span id="l86.178" class="difflineplus">+    else</span>
<a href="#l86.179"></a><span id="l86.179" class="difflineplus">+      mis.inboxFolder.clearFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l86.180"></a><span id="l86.180" class="difflineplus">+</span>
<a href="#l86.181"></a><span id="l86.181" class="difflineplus">+    mis.mainThread = Cc[&quot;@mozilla.org/thread-manager;1&quot;]</span>
<a href="#l86.182"></a><span id="l86.182" class="difflineplus">+                       .getService()</span>
<a href="#l86.183"></a><span id="l86.183" class="difflineplus">+                       .mainThread;</span>
<a href="#l86.184"></a><span id="l86.184" class="difflineplus">+    mis.imapService = Cc[&quot;@mozilla.org/messenger/imapservice;1&quot;]</span>
<a href="#l86.185"></a><span id="l86.185" class="difflineplus">+                        .getService(Ci.nsIImapService);</span>
<a href="#l86.186"></a><span id="l86.186" class="difflineplus">+</span>
<a href="#l86.187"></a><span id="l86.187" class="difflineplus">+    mis.handleUriToRealFolder = {};</span>
<a href="#l86.188"></a><span id="l86.188" class="difflineplus">+    mis.handleUriToFakeFolder = {};</span>
<a href="#l86.189"></a><span id="l86.189" class="difflineplus">+    mis.realUriToFakeFolder = {};</span>
<a href="#l86.190"></a><span id="l86.190" class="difflineplus">+    mis.realUriToFakeFolder[mis.inboxFolder.URI] =</span>
<a href="#l86.191"></a><span id="l86.191" class="difflineplus">+      mis.daemon.getMailbox(&quot;INBOX&quot;);</span>
<a href="#l86.192"></a><span id="l86.192" class="difflineplus">+  }</span>
<a href="#l86.193"></a><span id="l86.193" class="difflineplus">+  else {</span>
<a href="#l86.194"></a><span id="l86.194" class="difflineplus">+    do_throw(&quot;Illegal injection config option: &quot; + mis.injectionConfig.mode);</span>
<a href="#l86.195"></a><span id="l86.195" class="difflineplus">+  }</span>
<a href="#l86.196"></a><span id="l86.196" class="difflineplus">+</span>
<a href="#l86.197"></a><span id="l86.197" class="difflineplus">+  mis.trashFolder = mis.rootFolder.getFolderWithFlags(</span>
<a href="#l86.198"></a><span id="l86.198" class="difflineplus">+                      Ci.nsMsgFolderFlags.Trash);</span>
<a href="#l86.199"></a><span id="l86.199" class="difflineplus">+  mark_action(&quot;messageInjection&quot;, &quot;trash folder is&quot;, [mis.trashFolder]);</span>
<a href="#l86.200"></a><span id="l86.200" class="difflineplus">+  mis.junkHandle = null;</span>
<a href="#l86.201"></a><span id="l86.201" class="difflineplus">+  mis.junkFolder = null;</span>
<a href="#l86.202"></a><span id="l86.202" class="difflineplus">+</span>
<a href="#l86.203"></a><span id="l86.203" class="difflineplus">+  return mis.inboxFolder;</span>
<a href="#l86.204"></a><span id="l86.204" class="difflineplus">+}</span>
<a href="#l86.205"></a><span id="l86.205" class="difflineplus">+</span>
<a href="#l86.206"></a><span id="l86.206" class="difflineplus">+function message_injection_is_local() {</span>
<a href="#l86.207"></a><span id="l86.207" class="difflineplus">+  return _messageInjectionSetup.injectionConfig.mode == &quot;local&quot;;</span>
<a href="#l86.208"></a><span id="l86.208" class="difflineplus">+}</span>
<a href="#l86.209"></a><span id="l86.209" class="difflineplus">+</span>
<a href="#l86.210"></a><span id="l86.210" class="difflineplus">+async_test_runner_register_final_cleanup_helper(_cleanup_message_injection);</span>
<a href="#l86.211"></a><span id="l86.211" class="difflineplus">+</span>
<a href="#l86.212"></a><span id="l86.212" class="difflineplus">+function _cleanup_message_injection() {</span>
<a href="#l86.213"></a><span id="l86.213" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.214"></a><span id="l86.214" class="difflineplus">+</span>
<a href="#l86.215"></a><span id="l86.215" class="difflineplus">+  if (mis.injectionConfig.mode == &quot;pop&quot; ||</span>
<a href="#l86.216"></a><span id="l86.216" class="difflineplus">+      mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l86.217"></a><span id="l86.217" class="difflineplus">+    mis.incomingServer.closeCachedConnections();</span>
<a href="#l86.218"></a><span id="l86.218" class="difflineplus">+</span>
<a href="#l86.219"></a><span id="l86.219" class="difflineplus">+    // No more tests, let everything finish.</span>
<a href="#l86.220"></a><span id="l86.220" class="difflineplus">+    // (This spins its own event loop...)</span>
<a href="#l86.221"></a><span id="l86.221" class="difflineplus">+    mis.server.stop();</span>
<a href="#l86.222"></a><span id="l86.222" class="difflineplus">+  }</span>
<a href="#l86.223"></a><span id="l86.223" class="difflineplus">+</span>
<a href="#l86.224"></a><span id="l86.224" class="difflineplus">+  // Clean out mis; we don't just null the global because it's conceivable we</span>
<a href="#l86.225"></a><span id="l86.225" class="difflineplus">+  //  might still have some closures floating about.</span>
<a href="#l86.226"></a><span id="l86.226" class="difflineplus">+  for each (let key in Iterator(mis, true))</span>
<a href="#l86.227"></a><span id="l86.227" class="difflineplus">+    delete mis[key];</span>
<a href="#l86.228"></a><span id="l86.228" class="difflineplus">+}</span>
<a href="#l86.229"></a><span id="l86.229" class="difflineplus">+</span>
<a href="#l86.230"></a><span id="l86.230" class="difflineplus">+const _messageInjectionSetup = {</span>
<a href="#l86.231"></a><span id="l86.231" class="difflineplus">+  _nextUniqueFolderId: 0,</span>
<a href="#l86.232"></a><span id="l86.232" class="difflineplus">+</span>
<a href="#l86.233"></a><span id="l86.233" class="difflineplus">+  injectionConfig: {</span>
<a href="#l86.234"></a><span id="l86.234" class="difflineplus">+    mode: &quot;none&quot;,</span>
<a href="#l86.235"></a><span id="l86.235" class="difflineplus">+  },</span>
<a href="#l86.236"></a><span id="l86.236" class="difflineplus">+  listeners: [],</span>
<a href="#l86.237"></a><span id="l86.237" class="difflineplus">+  notifyListeners: function(aHandlerName, aArgs) {</span>
<a href="#l86.238"></a><span id="l86.238" class="difflineplus">+    for each (let [, listener] in Iterator(this.listeners)) {</span>
<a href="#l86.239"></a><span id="l86.239" class="difflineplus">+      if (aHandlerName in listener)</span>
<a href="#l86.240"></a><span id="l86.240" class="difflineplus">+        listener[aHandlerName].apply(listener, aArgs);</span>
<a href="#l86.241"></a><span id="l86.241" class="difflineplus">+    }</span>
<a href="#l86.242"></a><span id="l86.242" class="difflineplus">+  },</span>
<a href="#l86.243"></a><span id="l86.243" class="difflineplus">+</span>
<a href="#l86.244"></a><span id="l86.244" class="difflineplus">+  /**</span>
<a href="#l86.245"></a><span id="l86.245" class="difflineplus">+   * The nsIMsgIncomingServer</span>
<a href="#l86.246"></a><span id="l86.246" class="difflineplus">+   */</span>
<a href="#l86.247"></a><span id="l86.247" class="difflineplus">+  incomingServer: null,</span>
<a href="#l86.248"></a><span id="l86.248" class="difflineplus">+</span>
<a href="#l86.249"></a><span id="l86.249" class="difflineplus">+  /**</span>
<a href="#l86.250"></a><span id="l86.250" class="difflineplus">+   * The incoming server's (synthetic) root message folder.</span>
<a href="#l86.251"></a><span id="l86.251" class="difflineplus">+   */</span>
<a href="#l86.252"></a><span id="l86.252" class="difflineplus">+  rootFolder: null,</span>
<a href="#l86.253"></a><span id="l86.253" class="difflineplus">+</span>
<a href="#l86.254"></a><span id="l86.254" class="difflineplus">+  /**</span>
<a href="#l86.255"></a><span id="l86.255" class="difflineplus">+   * The nsIMsgFolder that is the inbox.</span>
<a href="#l86.256"></a><span id="l86.256" class="difflineplus">+   */</span>
<a href="#l86.257"></a><span id="l86.257" class="difflineplus">+  inboxFolder: null,</span>
<a href="#l86.258"></a><span id="l86.258" class="difflineplus">+</span>
<a href="#l86.259"></a><span id="l86.259" class="difflineplus">+  /**</span>
<a href="#l86.260"></a><span id="l86.260" class="difflineplus">+   * Fakeserver daemon, if applicable.</span>
<a href="#l86.261"></a><span id="l86.261" class="difflineplus">+   */</span>
<a href="#l86.262"></a><span id="l86.262" class="difflineplus">+  daemon: null,</span>
<a href="#l86.263"></a><span id="l86.263" class="difflineplus">+  /**</span>
<a href="#l86.264"></a><span id="l86.264" class="difflineplus">+   * Fakeserver server instance, if applicable.</span>
<a href="#l86.265"></a><span id="l86.265" class="difflineplus">+   */</span>
<a href="#l86.266"></a><span id="l86.266" class="difflineplus">+  server: null,</span>
<a href="#l86.267"></a><span id="l86.267" class="difflineplus">+};</span>
<a href="#l86.268"></a><span id="l86.268" class="difflineplus">+</span>
<a href="#l86.269"></a><span id="l86.269" class="difflineplus">+/**</span>
<a href="#l86.270"></a><span id="l86.270" class="difflineplus">+ * Register a listener to be notified when interesting things happen involving</span>
<a href="#l86.271"></a><span id="l86.271" class="difflineplus">+ *  calls made to the message injection API.</span>
<a href="#l86.272"></a><span id="l86.272" class="difflineplus">+ *</span>
<a href="#l86.273"></a><span id="l86.273" class="difflineplus">+ * @param aListener.onVirtualFolderCreated Called when a virtual folder is</span>
<a href="#l86.274"></a><span id="l86.274" class="difflineplus">+ *     created using |make_virtual_folder|.  The argument is the nsIMsgFolder</span>
<a href="#l86.275"></a><span id="l86.275" class="difflineplus">+ *     that defines the virtual folder.</span>
<a href="#l86.276"></a><span id="l86.276" class="difflineplus">+ */</span>
<a href="#l86.277"></a><span id="l86.277" class="difflineplus">+function register_message_injection_listener(aListener) {</span>
<a href="#l86.278"></a><span id="l86.278" class="difflineplus">+  _messageInjectionSetup.listeners.push(aListener);</span>
<a href="#l86.279"></a><span id="l86.279" class="difflineplus">+}</span>
<a href="#l86.280"></a><span id="l86.280" class="difflineplus">+</span>
<a href="#l86.281"></a><span id="l86.281" class="difflineplus">+/**</span>
<a href="#l86.282"></a><span id="l86.282" class="difflineplus">+ * Convert a list of synthetic messages to a form appropriate to feed to the</span>
<a href="#l86.283"></a><span id="l86.283" class="difflineplus">+ *  POP3 fakeserver.</span>
<a href="#l86.284"></a><span id="l86.284" class="difflineplus">+ */</span>
<a href="#l86.285"></a><span id="l86.285" class="difflineplus">+function _synthMessagesToFakeRep(aSynthMessages) {</span>
<a href="#l86.286"></a><span id="l86.286" class="difflineplus">+  return [{fileData: msg.toMessageString(), size: -1} for each</span>
<a href="#l86.287"></a><span id="l86.287" class="difflineplus">+          (msg in aSynthMessages)];</span>
<a href="#l86.288"></a><span id="l86.288" class="difflineplus">+}</span>
<a href="#l86.289"></a><span id="l86.289" class="difflineplus">+</span>
<a href="#l86.290"></a><span id="l86.290" class="difflineplus">+</span>
<a href="#l86.291"></a><span id="l86.291" class="difflineplus">+SEARCH_TERM_MAP_HELPER = {</span>
<a href="#l86.292"></a><span id="l86.292" class="difflineplus">+  subject: Components.interfaces.nsMsgSearchAttrib.Subject,</span>
<a href="#l86.293"></a><span id="l86.293" class="difflineplus">+  body: Components.interfaces.nsMsgSearchAttrib.Body,</span>
<a href="#l86.294"></a><span id="l86.294" class="difflineplus">+  from: Components.interfaces.nsMsgSearchAttrib.Sender,</span>
<a href="#l86.295"></a><span id="l86.295" class="difflineplus">+  to: Components.interfaces.nsMsgSearchAttrib.To,</span>
<a href="#l86.296"></a><span id="l86.296" class="difflineplus">+  cc: Components.interfaces.nsMsgSearchAttrib.CC,</span>
<a href="#l86.297"></a><span id="l86.297" class="difflineplus">+  recipient: Components.interfaces.nsMsgSearchAttrib.ToOrCC,</span>
<a href="#l86.298"></a><span id="l86.298" class="difflineplus">+  involves: Components.interfaces.nsMsgSearchAttrib.AllAddresses,</span>
<a href="#l86.299"></a><span id="l86.299" class="difflineplus">+  age: Components.interfaces.nsMsgSearchAttrib.AgeInDays,</span>
<a href="#l86.300"></a><span id="l86.300" class="difflineplus">+  tags: Components.interfaces.nsMsgSearchAttrib.Keywords,</span>
<a href="#l86.301"></a><span id="l86.301" class="difflineplus">+};</span>
<a href="#l86.302"></a><span id="l86.302" class="difflineplus">+</span>
<a href="#l86.303"></a><span id="l86.303" class="difflineplus">+/**</span>
<a href="#l86.304"></a><span id="l86.304" class="difflineplus">+ * Create and return an empty folder.  If you want to delete this folder</span>
<a href="#l86.305"></a><span id="l86.305" class="difflineplus">+ *  you must call |delete_folder| to kill it!  If you want to rename it, you</span>
<a href="#l86.306"></a><span id="l86.306" class="difflineplus">+ *  must implement a method called rename_folder and then call it.</span>
<a href="#l86.307"></a><span id="l86.307" class="difflineplus">+ *</span>
<a href="#l86.308"></a><span id="l86.308" class="difflineplus">+ * @param [aFolderName] A folder name with no support for hierarchy at this</span>
<a href="#l86.309"></a><span id="l86.309" class="difflineplus">+ *     time.  A name of the form &quot;gabba#&quot; will be autogenerated if you do not</span>
<a href="#l86.310"></a><span id="l86.310" class="difflineplus">+ *     provide one.</span>
<a href="#l86.311"></a><span id="l86.311" class="difflineplus">+ * @param [aSpecialFlags] A list of nsMsgFolderFlags bits to set.</span>
<a href="#l86.312"></a><span id="l86.312" class="difflineplus">+ * @return A folder handle thing that you can pass in to our methods that</span>
<a href="#l86.313"></a><span id="l86.313" class="difflineplus">+ *     expect actual folders.</span>
<a href="#l86.314"></a><span id="l86.314" class="difflineplus">+ */</span>
<a href="#l86.315"></a><span id="l86.315" class="difflineplus">+function make_empty_folder(aFolderName, aSpecialFlags) {</span>
<a href="#l86.316"></a><span id="l86.316" class="difflineplus">+  if (aFolderName == null)</span>
<a href="#l86.317"></a><span id="l86.317" class="difflineplus">+    aFolderName = &quot;gabba&quot; + _messageInjectionSetup._nextUniqueFolderId++;</span>
<a href="#l86.318"></a><span id="l86.318" class="difflineplus">+  let testFolder;</span>
<a href="#l86.319"></a><span id="l86.319" class="difflineplus">+</span>
<a href="#l86.320"></a><span id="l86.320" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.321"></a><span id="l86.321" class="difflineplus">+</span>
<a href="#l86.322"></a><span id="l86.322" class="difflineplus">+  if (mis.injectionConfig.mode == &quot;local&quot;) {</span>
<a href="#l86.323"></a><span id="l86.323" class="difflineplus">+    testFolder = mis.rootFolder.addSubfolder(aFolderName);</span>
<a href="#l86.324"></a><span id="l86.324" class="difflineplus">+    // it seems dumb that we have to set this.</span>
<a href="#l86.325"></a><span id="l86.325" class="difflineplus">+    testFolder.setFlag(Ci.nsMsgFolderFlags.Mail);</span>
<a href="#l86.326"></a><span id="l86.326" class="difflineplus">+    if (aSpecialFlags) {</span>
<a href="#l86.327"></a><span id="l86.327" class="difflineplus">+      for each (let [, flag] in Iterator(aSpecialFlags)) {</span>
<a href="#l86.328"></a><span id="l86.328" class="difflineplus">+        testFolder.setFlag(flag);</span>
<a href="#l86.329"></a><span id="l86.329" class="difflineplus">+      }</span>
<a href="#l86.330"></a><span id="l86.330" class="difflineplus">+    }</span>
<a href="#l86.331"></a><span id="l86.331" class="difflineplus">+    _messageInjectionSetup.notifyListeners(&quot;onRealFolderCreated&quot;,</span>
<a href="#l86.332"></a><span id="l86.332" class="difflineplus">+                                           [testFolder]);</span>
<a href="#l86.333"></a><span id="l86.333" class="difflineplus">+  }</span>
<a href="#l86.334"></a><span id="l86.334" class="difflineplus">+  else if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l86.335"></a><span id="l86.335" class="difflineplus">+    let promise_completed = async_create_promise();</span>
<a href="#l86.336"></a><span id="l86.336" class="difflineplus">+</span>
<a href="#l86.337"></a><span id="l86.337" class="difflineplus">+    testFolder = mis.rootFolder.URI + &quot;/&quot; + aFolderName;</span>
<a href="#l86.338"></a><span id="l86.338" class="difflineplus">+</span>
<a href="#l86.339"></a><span id="l86.339" class="difflineplus">+    // Tell the IMAP service to create the folder, adding a listener that</span>
<a href="#l86.340"></a><span id="l86.340" class="difflineplus">+    //  hooks up the 'handle' URI -&gt; actual folder mapping.</span>
<a href="#l86.341"></a><span id="l86.341" class="difflineplus">+    mis.imapService.createFolder(</span>
<a href="#l86.342"></a><span id="l86.342" class="difflineplus">+      mis.mainThread,</span>
<a href="#l86.343"></a><span id="l86.343" class="difflineplus">+      mis.rootFolder,</span>
<a href="#l86.344"></a><span id="l86.344" class="difflineplus">+      aFolderName,</span>
<a href="#l86.345"></a><span id="l86.345" class="difflineplus">+      new AsyncUrlListener(mis.rootFolder, function() {</span>
<a href="#l86.346"></a><span id="l86.346" class="difflineplus">+        // get the newly created nsIMsgFolder folder</span>
<a href="#l86.347"></a><span id="l86.347" class="difflineplus">+        let msgFolder = mis.rootFolder.getChildNamed(aFolderName);</span>
<a href="#l86.348"></a><span id="l86.348" class="difflineplus">+</span>
<a href="#l86.349"></a><span id="l86.349" class="difflineplus">+        if (aSpecialFlags) {</span>
<a href="#l86.350"></a><span id="l86.350" class="difflineplus">+          for each (let [, flag] in Iterator(aSpecialFlags)) {</span>
<a href="#l86.351"></a><span id="l86.351" class="difflineplus">+            msgFolder.setFlag(flag);</span>
<a href="#l86.352"></a><span id="l86.352" class="difflineplus">+          }</span>
<a href="#l86.353"></a><span id="l86.353" class="difflineplus">+        }</span>
<a href="#l86.354"></a><span id="l86.354" class="difflineplus">+</span>
<a href="#l86.355"></a><span id="l86.355" class="difflineplus">+        // get a reference to the fake server folder</span>
<a href="#l86.356"></a><span id="l86.356" class="difflineplus">+        let fakeFolder = mis.daemon.getMailbox(aFolderName);</span>
<a href="#l86.357"></a><span id="l86.357" class="difflineplus">+        // establish the mapping</span>
<a href="#l86.358"></a><span id="l86.358" class="difflineplus">+        mis.handleUriToRealFolder[testFolder] = msgFolder;</span>
<a href="#l86.359"></a><span id="l86.359" class="difflineplus">+        mis.handleUriToFakeFolder[testFolder] = fakeFolder;</span>
<a href="#l86.360"></a><span id="l86.360" class="difflineplus">+        mis.realUriToFakeFolder[msgFolder.URI] = fakeFolder;</span>
<a href="#l86.361"></a><span id="l86.361" class="difflineplus">+</span>
<a href="#l86.362"></a><span id="l86.362" class="difflineplus">+        // notify listeners</span>
<a href="#l86.363"></a><span id="l86.363" class="difflineplus">+        _messageInjectionSetup.notifyListeners(&quot;onRealFolderCreated&quot;,</span>
<a href="#l86.364"></a><span id="l86.364" class="difflineplus">+                                               [msgFolder]);</span>
<a href="#l86.365"></a><span id="l86.365" class="difflineplus">+      }, promise_completed));</span>
<a href="#l86.366"></a><span id="l86.366" class="difflineplus">+   }</span>
<a href="#l86.367"></a><span id="l86.367" class="difflineplus">+  else if (_messageInjectionSetup.injectionConfig.mode == &quot;pop&quot;) {</span>
<a href="#l86.368"></a><span id="l86.368" class="difflineplus">+    throw new Error(&quot;You cannot create new folders for POP, I assume.\n&quot;);</span>
<a href="#l86.369"></a><span id="l86.369" class="difflineplus">+  }</span>
<a href="#l86.370"></a><span id="l86.370" class="difflineplus">+</span>
<a href="#l86.371"></a><span id="l86.371" class="difflineplus">+  return testFolder;</span>
<a href="#l86.372"></a><span id="l86.372" class="difflineplus">+}</span>
<a href="#l86.373"></a><span id="l86.373" class="difflineplus">+</span>
<a href="#l86.374"></a><span id="l86.374" class="difflineplus">+/**</span>
<a href="#l86.375"></a><span id="l86.375" class="difflineplus">+ * Get/create the junk folder.</span>
<a href="#l86.376"></a><span id="l86.376" class="difflineplus">+ */</span>
<a href="#l86.377"></a><span id="l86.377" class="difflineplus">+function get_junk_folder() {</span>
<a href="#l86.378"></a><span id="l86.378" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.379"></a><span id="l86.379" class="difflineplus">+</span>
<a href="#l86.380"></a><span id="l86.380" class="difflineplus">+  if (!mis.junkHandle)</span>
<a href="#l86.381"></a><span id="l86.381" class="difflineplus">+    mis.junkHandle = make_empty_folder(&quot;Junk&quot;, [Ci.nsMsgFolderFlags.Junk]);</span>
<a href="#l86.382"></a><span id="l86.382" class="difflineplus">+</span>
<a href="#l86.383"></a><span id="l86.383" class="difflineplus">+  return mis.junkHandle;</span>
<a href="#l86.384"></a><span id="l86.384" class="difflineplus">+}</span>
<a href="#l86.385"></a><span id="l86.385" class="difflineplus">+</span>
<a href="#l86.386"></a><span id="l86.386" class="difflineplus">+/**</span>
<a href="#l86.387"></a><span id="l86.387" class="difflineplus">+ * Create and return a virtual folder.</span>
<a href="#l86.388"></a><span id="l86.388" class="difflineplus">+ *</span>
<a href="#l86.389"></a><span id="l86.389" class="difflineplus">+ * @param aFolders The real folders this virtual folder should draw from.</span>
<a href="#l86.390"></a><span id="l86.390" class="difflineplus">+ * @param aSearchDef The search definition to use to build the list of search</span>
<a href="#l86.391"></a><span id="l86.391" class="difflineplus">+ *     terms that populate this virtual folder.  Keys should be stuff from</span>
<a href="#l86.392"></a><span id="l86.392" class="difflineplus">+ *     SEARCH_TERM_MAP_HELPER and values should be strings to search for within</span>
<a href="#l86.393"></a><span id="l86.393" class="difflineplus">+ *     those attribute things.</span>
<a href="#l86.394"></a><span id="l86.394" class="difflineplus">+ * @param aBooleanAnd Should the search terms be and-ed together.</span>
<a href="#l86.395"></a><span id="l86.395" class="difflineplus">+ * @param [aName] Name to use.</span>
<a href="#l86.396"></a><span id="l86.396" class="difflineplus">+ */</span>
<a href="#l86.397"></a><span id="l86.397" class="difflineplus">+function make_virtual_folder(aFolders, aSearchDef, aBooleanAnd, aName) {</span>
<a href="#l86.398"></a><span id="l86.398" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.399"></a><span id="l86.399" class="difflineplus">+  let name = aName ? aName : &quot;virt&quot; + mis._nextUniqueFolderId++;</span>
<a href="#l86.400"></a><span id="l86.400" class="difflineplus">+</span>
<a href="#l86.401"></a><span id="l86.401" class="difflineplus">+  let terms = [];</span>
<a href="#l86.402"></a><span id="l86.402" class="difflineplus">+  let termCreator = Components.classes[&quot;@mozilla.org/messenger/searchSession;1&quot;]</span>
<a href="#l86.403"></a><span id="l86.403" class="difflineplus">+                              .createInstance(Ci.nsIMsgSearchSession);</span>
<a href="#l86.404"></a><span id="l86.404" class="difflineplus">+  for each (let [key, val] in Iterator(aSearchDef)) {</span>
<a href="#l86.405"></a><span id="l86.405" class="difflineplus">+    let term = termCreator.createTerm();</span>
<a href="#l86.406"></a><span id="l86.406" class="difflineplus">+    let value = term.value;</span>
<a href="#l86.407"></a><span id="l86.407" class="difflineplus">+    value.str = val;</span>
<a href="#l86.408"></a><span id="l86.408" class="difflineplus">+    term.value = value;</span>
<a href="#l86.409"></a><span id="l86.409" class="difflineplus">+    term.attrib = SEARCH_TERM_MAP_HELPER[key];</span>
<a href="#l86.410"></a><span id="l86.410" class="difflineplus">+    term.op = Components.interfaces.nsMsgSearchOp.Contains;</span>
<a href="#l86.411"></a><span id="l86.411" class="difflineplus">+    term.booleanAnd = Boolean(aBooleanAnd);</span>
<a href="#l86.412"></a><span id="l86.412" class="difflineplus">+    terms.push(term);</span>
<a href="#l86.413"></a><span id="l86.413" class="difflineplus">+  }</span>
<a href="#l86.414"></a><span id="l86.414" class="difflineplus">+  // create an ALL case if we didn't add any terms</span>
<a href="#l86.415"></a><span id="l86.415" class="difflineplus">+  if (terms.length == 0) {</span>
<a href="#l86.416"></a><span id="l86.416" class="difflineplus">+    let term = termCreator.createTerm();</span>
<a href="#l86.417"></a><span id="l86.417" class="difflineplus">+    term.matchAll = true;</span>
<a href="#l86.418"></a><span id="l86.418" class="difflineplus">+    terms.push(term);</span>
<a href="#l86.419"></a><span id="l86.419" class="difflineplus">+  }</span>
<a href="#l86.420"></a><span id="l86.420" class="difflineplus">+</span>
<a href="#l86.421"></a><span id="l86.421" class="difflineplus">+  let wrapped = VirtualFolderHelper.createNewVirtualFolder(</span>
<a href="#l86.422"></a><span id="l86.422" class="difflineplus">+    name, mis.rootFolder, aFolders, terms,</span>
<a href="#l86.423"></a><span id="l86.423" class="difflineplus">+    /* online */ false);</span>
<a href="#l86.424"></a><span id="l86.424" class="difflineplus">+  _messageInjectionSetup.notifyListeners(&quot;onVirtualFolderCreated&quot;,</span>
<a href="#l86.425"></a><span id="l86.425" class="difflineplus">+                                         [wrapped.virtualFolder]);</span>
<a href="#l86.426"></a><span id="l86.426" class="difflineplus">+  return wrapped.virtualFolder;</span>
<a href="#l86.427"></a><span id="l86.427" class="difflineplus">+}</span>
<a href="#l86.428"></a><span id="l86.428" class="difflineplus">+</span>
<a href="#l86.429"></a><span id="l86.429" class="difflineplus">+/**</span>
<a href="#l86.430"></a><span id="l86.430" class="difflineplus">+ * Mark the folder as offline and force all of its messages to be downloaded.</span>
<a href="#l86.431"></a><span id="l86.431" class="difflineplus">+ *  This is an asynchronous operation that will call async_driver once the</span>
<a href="#l86.432"></a><span id="l86.432" class="difflineplus">+ *  download is completed.</span>
<a href="#l86.433"></a><span id="l86.433" class="difflineplus">+ */</span>
<a href="#l86.434"></a><span id="l86.434" class="difflineplus">+function make_folder_and_contents_offline(aFolderHandle) {</span>
<a href="#l86.435"></a><span id="l86.435" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.436"></a><span id="l86.436" class="difflineplus">+  if (mis.injectionConfig.mode != &quot;imap&quot;)</span>
<a href="#l86.437"></a><span id="l86.437" class="difflineplus">+    return true;</span>
<a href="#l86.438"></a><span id="l86.438" class="difflineplus">+</span>
<a href="#l86.439"></a><span id="l86.439" class="difflineplus">+  let msgFolder = get_real_injection_folder(aFolderHandle);</span>
<a href="#l86.440"></a><span id="l86.440" class="difflineplus">+  msgFolder.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l86.441"></a><span id="l86.441" class="difflineplus">+  msgFolder.downloadAllForOffline(asyncUrlListener, null);</span>
<a href="#l86.442"></a><span id="l86.442" class="difflineplus">+  return false;</span>
<a href="#l86.443"></a><span id="l86.443" class="difflineplus">+}</span>
<a href="#l86.444"></a><span id="l86.444" class="difflineplus">+</span>
<a href="#l86.445"></a><span id="l86.445" class="difflineplus">+/**</span>
<a href="#l86.446"></a><span id="l86.446" class="difflineplus">+ * Create a new local folder, populating it with messages according to the set</span>
<a href="#l86.447"></a><span id="l86.447" class="difflineplus">+ *  definition provided.</span>
<a href="#l86.448"></a><span id="l86.448" class="difflineplus">+ *</span>
<a href="#l86.449"></a><span id="l86.449" class="difflineplus">+ * @param aSynSetDefs A synthetic set definition, as appropriate to pass to</span>
<a href="#l86.450"></a><span id="l86.450" class="difflineplus">+ *     make_new_sets_in_folder.</span>
<a href="#l86.451"></a><span id="l86.451" class="difflineplus">+ * @return A list whose first element is the nsIMsgLocalMailFolder created and</span>
<a href="#l86.452"></a><span id="l86.452" class="difflineplus">+ *     whose subsequent items are the SyntheticMessageSets used to populate the</span>
<a href="#l86.453"></a><span id="l86.453" class="difflineplus">+ *     folder (as returned by make_new_sets_in_folder).</span>
<a href="#l86.454"></a><span id="l86.454" class="difflineplus">+ */</span>
<a href="#l86.455"></a><span id="l86.455" class="difflineplus">+function make_folder_with_sets(aSynSetDefs) {</span>
<a href="#l86.456"></a><span id="l86.456" class="difflineplus">+  let msgFolder = make_empty_folder();</span>
<a href="#l86.457"></a><span id="l86.457" class="difflineplus">+  let results = make_new_sets_in_folder(msgFolder, aSynSetDefs);</span>
<a href="#l86.458"></a><span id="l86.458" class="difflineplus">+  // results may be referenced by add_sets_to_folders in an async fashion, so</span>
<a href="#l86.459"></a><span id="l86.459" class="difflineplus">+  //  don't change it.</span>
<a href="#l86.460"></a><span id="l86.460" class="difflineplus">+  results = results.concat();</span>
<a href="#l86.461"></a><span id="l86.461" class="difflineplus">+  results.unshift(msgFolder);</span>
<a href="#l86.462"></a><span id="l86.462" class="difflineplus">+  return results;</span>
<a href="#l86.463"></a><span id="l86.463" class="difflineplus">+}</span>
<a href="#l86.464"></a><span id="l86.464" class="difflineplus">+</span>
<a href="#l86.465"></a><span id="l86.465" class="difflineplus">+/**</span>
<a href="#l86.466"></a><span id="l86.466" class="difflineplus">+ * Create multiple new local folders, populating them with messages according to</span>
<a href="#l86.467"></a><span id="l86.467" class="difflineplus">+ *  the set definitions provided.  Differs from make_folder_with_sets by taking</span>
<a href="#l86.468"></a><span id="l86.468" class="difflineplus">+ *  the number of folders to create and return the list of created folders as</span>
<a href="#l86.469"></a><span id="l86.469" class="difflineplus">+ *  the first element in the returned list.  This method is simple enough that</span>
<a href="#l86.470"></a><span id="l86.470" class="difflineplus">+ *  the limited code duplication is deemed acceptable in support of readability.</span>
<a href="#l86.471"></a><span id="l86.471" class="difflineplus">+ *</span>
<a href="#l86.472"></a><span id="l86.472" class="difflineplus">+ * @param aSynSetDefs A synthetic set definition, as appropriate to pass to</span>
<a href="#l86.473"></a><span id="l86.473" class="difflineplus">+ *     make_new_sets_in_folder.</span>
<a href="#l86.474"></a><span id="l86.474" class="difflineplus">+ * @return A list whose first element is the nsIMsgLocalMailFolder created and</span>
<a href="#l86.475"></a><span id="l86.475" class="difflineplus">+ *     whose subsequent items are the SyntheticMessageSets used to populate the</span>
<a href="#l86.476"></a><span id="l86.476" class="difflineplus">+ *     folder (as returned by make_new_sets_in_folder).</span>
<a href="#l86.477"></a><span id="l86.477" class="difflineplus">+ */</span>
<a href="#l86.478"></a><span id="l86.478" class="difflineplus">+function make_folders_with_sets(aFolderCount, aSynSetDefs) {</span>
<a href="#l86.479"></a><span id="l86.479" class="difflineplus">+  let msgFolders = [];</span>
<a href="#l86.480"></a><span id="l86.480" class="difflineplus">+  for (let i = 0; i &lt; aFolderCount; i++)</span>
<a href="#l86.481"></a><span id="l86.481" class="difflineplus">+    msgFolders.push(make_empty_folder());</span>
<a href="#l86.482"></a><span id="l86.482" class="difflineplus">+  let results = make_new_sets_in_folders(msgFolders, aSynSetDefs);</span>
<a href="#l86.483"></a><span id="l86.483" class="difflineplus">+  // results may be referenced by add_sets_to_folders in an async fashion, so</span>
<a href="#l86.484"></a><span id="l86.484" class="difflineplus">+  //  don't change it.</span>
<a href="#l86.485"></a><span id="l86.485" class="difflineplus">+  results = results.concat();</span>
<a href="#l86.486"></a><span id="l86.486" class="difflineplus">+  results.unshift(msgFolders);</span>
<a href="#l86.487"></a><span id="l86.487" class="difflineplus">+  return results;</span>
<a href="#l86.488"></a><span id="l86.488" class="difflineplus">+}</span>
<a href="#l86.489"></a><span id="l86.489" class="difflineplus">+</span>
<a href="#l86.490"></a><span id="l86.490" class="difflineplus">+/**</span>
<a href="#l86.491"></a><span id="l86.491" class="difflineplus">+ * Given one or more existing local folder, create new message sets and add them</span>
<a href="#l86.492"></a><span id="l86.492" class="difflineplus">+ *  to the folders using</span>
<a href="#l86.493"></a><span id="l86.493" class="difflineplus">+ *</span>
<a href="#l86.494"></a><span id="l86.494" class="difflineplus">+ * @param aMsgFolders A single nsIMsgLocalMailFolder or a list of them.  The</span>
<a href="#l86.495"></a><span id="l86.495" class="difflineplus">+ *     synthetic messages will be added to the folder(s).</span>
<a href="#l86.496"></a><span id="l86.496" class="difflineplus">+ * @param aSynSetDefs Either an integer describing the number of sets of</span>
<a href="#l86.497"></a><span id="l86.497" class="difflineplus">+ *     messages to create (using default parameters), or a list of set</span>
<a href="#l86.498"></a><span id="l86.498" class="difflineplus">+ *     definition objects as defined by MessageGenerator.makeMessages.</span>
<a href="#l86.499"></a><span id="l86.499" class="difflineplus">+ * @return A list of SyntheticMessageSet objects, each corresponding to the</span>
<a href="#l86.500"></a><span id="l86.500" class="difflineplus">+ *     entry in aSynSetDefs (or implied if an integer was passed).</span>
<a href="#l86.501"></a><span id="l86.501" class="difflineplus">+ */</span>
<a href="#l86.502"></a><span id="l86.502" class="difflineplus">+function make_new_sets_in_folders(aMsgFolders, aSynSetDefs) {</span>
<a href="#l86.503"></a><span id="l86.503" class="difflineplus">+  // is it just a count of the number of plain vanilla sets to create?</span>
<a href="#l86.504"></a><span id="l86.504" class="difflineplus">+  if (typeof(aSynSetDefs) == &quot;number&quot;) {</span>
<a href="#l86.505"></a><span id="l86.505" class="difflineplus">+    let setCount = aSynSetDefs;</span>
<a href="#l86.506"></a><span id="l86.506" class="difflineplus">+    aSynSetDefs = [];</span>
<a href="#l86.507"></a><span id="l86.507" class="difflineplus">+    for (let iSet = 0; iSet &lt; setCount; iSet++)</span>
<a href="#l86.508"></a><span id="l86.508" class="difflineplus">+      aSynSetDefs.push({});</span>
<a href="#l86.509"></a><span id="l86.509" class="difflineplus">+  }</span>
<a href="#l86.510"></a><span id="l86.510" class="difflineplus">+  // now it must be a list of set descriptors</span>
<a href="#l86.511"></a><span id="l86.511" class="difflineplus">+</span>
<a href="#l86.512"></a><span id="l86.512" class="difflineplus">+  // - create the synthetic message sets</span>
<a href="#l86.513"></a><span id="l86.513" class="difflineplus">+  let messageSets = [];</span>
<a href="#l86.514"></a><span id="l86.514" class="difflineplus">+  for each (let [, synSetDef] in Iterator(aSynSetDefs)) {</span>
<a href="#l86.515"></a><span id="l86.515" class="difflineplus">+    let messages = gMessageGenerator.makeMessages(synSetDef);</span>
<a href="#l86.516"></a><span id="l86.516" class="difflineplus">+    messageSets.push(new SyntheticMessageSet(messages));</span>
<a href="#l86.517"></a><span id="l86.517" class="difflineplus">+  }</span>
<a href="#l86.518"></a><span id="l86.518" class="difflineplus">+</span>
<a href="#l86.519"></a><span id="l86.519" class="difflineplus">+  // - add the messages to the folders (interleaving them)</span>
<a href="#l86.520"></a><span id="l86.520" class="difflineplus">+  add_sets_to_folders(aMsgFolders, messageSets);</span>
<a href="#l86.521"></a><span id="l86.521" class="difflineplus">+</span>
<a href="#l86.522"></a><span id="l86.522" class="difflineplus">+  return messageSets;</span>
<a href="#l86.523"></a><span id="l86.523" class="difflineplus">+}</span>
<a href="#l86.524"></a><span id="l86.524" class="difflineplus">+/** singular folder alias for single-folder users' readability */</span>
<a href="#l86.525"></a><span id="l86.525" class="difflineplus">+let make_new_sets_in_folder = make_new_sets_in_folders;</span>
<a href="#l86.526"></a><span id="l86.526" class="difflineplus">+</span>
<a href="#l86.527"></a><span id="l86.527" class="difflineplus">+/**</span>
<a href="#l86.528"></a><span id="l86.528" class="difflineplus">+ * An iterator that generates an infinite sequence of its argument.  So</span>
<a href="#l86.529"></a><span id="l86.529" class="difflineplus">+ *  _looperator(1, 2, 3) will generate the iteration stream: [1, 2, 3, 1, 2, 3,</span>
<a href="#l86.530"></a><span id="l86.530" class="difflineplus">+ *  1, 2, 3, ...].  For use by add_sets_across_folders.</span>
<a href="#l86.531"></a><span id="l86.531" class="difflineplus">+ */</span>
<a href="#l86.532"></a><span id="l86.532" class="difflineplus">+function _looperator(aList) {</span>
<a href="#l86.533"></a><span id="l86.533" class="difflineplus">+  if (aList.length == 0)</span>
<a href="#l86.534"></a><span id="l86.534" class="difflineplus">+    throw Exception(&quot;aList must have at least one item!&quot;);</span>
<a href="#l86.535"></a><span id="l86.535" class="difflineplus">+</span>
<a href="#l86.536"></a><span id="l86.536" class="difflineplus">+  let i = 0, length = aList.length;</span>
<a href="#l86.537"></a><span id="l86.537" class="difflineplus">+  while (true) {</span>
<a href="#l86.538"></a><span id="l86.538" class="difflineplus">+    yield aList[i];</span>
<a href="#l86.539"></a><span id="l86.539" class="difflineplus">+    i = (i + 1) % length;</span>
<a href="#l86.540"></a><span id="l86.540" class="difflineplus">+  }</span>
<a href="#l86.541"></a><span id="l86.541" class="difflineplus">+}</span>
<a href="#l86.542"></a><span id="l86.542" class="difflineplus">+</span>
<a href="#l86.543"></a><span id="l86.543" class="difflineplus">+/**</span>
<a href="#l86.544"></a><span id="l86.544" class="difflineplus">+ * This mechanism works around limitations in the new-handling logic that can</span>
<a href="#l86.545"></a><span id="l86.545" class="difflineplus">+ *  cause the msgsClassified event to be produced for messages multiple times.</span>
<a href="#l86.546"></a><span id="l86.546" class="difflineplus">+ *  We can generally avoid this problem in the local case, but it is harder</span>
<a href="#l86.547"></a><span id="l86.547" class="difflineplus">+ *  to workaround in the IMAP case because so many events are out of our</span>
<a href="#l86.548"></a><span id="l86.548" class="difflineplus">+ *  control.  By using the msgAdded notification we can trickily interpose</span>
<a href="#l86.549"></a><span id="l86.549" class="difflineplus">+ *  ourselves, however.</span>
<a href="#l86.550"></a><span id="l86.550" class="difflineplus">+ */</span>
<a href="#l86.551"></a><span id="l86.551" class="difflineplus">+let _imapNewMessagesWorkaround = {</span>
<a href="#l86.552"></a><span id="l86.552" class="difflineplus">+  _registered: false,</span>
<a href="#l86.553"></a><span id="l86.553" class="difflineplus">+  _register: function i_am_one_of_jacks_organs_with_a_bad_attitude() {</span>
<a href="#l86.554"></a><span id="l86.554" class="difflineplus">+    let notificationService =</span>
<a href="#l86.555"></a><span id="l86.555" class="difflineplus">+      Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;]</span>
<a href="#l86.556"></a><span id="l86.556" class="difflineplus">+        .getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l86.557"></a><span id="l86.557" class="difflineplus">+    notificationService.addListener(this,</span>
<a href="#l86.558"></a><span id="l86.558" class="difflineplus">+      Ci.nsIMsgFolderNotificationService.msgAdded);</span>
<a href="#l86.559"></a><span id="l86.559" class="difflineplus">+</span>
<a href="#l86.560"></a><span id="l86.560" class="difflineplus">+    this._registered = true;</span>
<a href="#l86.561"></a><span id="l86.561" class="difflineplus">+  },</span>
<a href="#l86.562"></a><span id="l86.562" class="difflineplus">+</span>
<a href="#l86.563"></a><span id="l86.563" class="difflineplus">+  _numberOfMessagesToGoPerFolder: {},</span>
<a href="#l86.564"></a><span id="l86.564" class="difflineplus">+</span>
<a href="#l86.565"></a><span id="l86.565" class="difflineplus">+  msgAdded: function that_last_function_name_was_a_fight_club_reference(</span>
<a href="#l86.566"></a><span id="l86.566" class="difflineplus">+              aMsgHdr) {</span>
<a href="#l86.567"></a><span id="l86.567" class="difflineplus">+    let folder = aMsgHdr.folder;</span>
<a href="#l86.568"></a><span id="l86.568" class="difflineplus">+    let uri = folder.URI;</span>
<a href="#l86.569"></a><span id="l86.569" class="difflineplus">+    if (uri in this._numberOfMessagesToGoPerFolder) {</span>
<a href="#l86.570"></a><span id="l86.570" class="difflineplus">+      if (--this._numberOfMessagesToGoPerFolder[uri] == 0) {</span>
<a href="#l86.571"></a><span id="l86.571" class="difflineplus">+        delete this._numberOfMessagesToGoPerFolder[uri];</span>
<a href="#l86.572"></a><span id="l86.572" class="difflineplus">+        mark_action(&quot;messageInjection&quot;,</span>
<a href="#l86.573"></a><span id="l86.573" class="difflineplus">+                    &quot;clearing new messages to avoid classified problems&quot;,</span>
<a href="#l86.574"></a><span id="l86.574" class="difflineplus">+                    [folder]);</span>
<a href="#l86.575"></a><span id="l86.575" class="difflineplus">+        folder.clearNewMessages();</span>
<a href="#l86.576"></a><span id="l86.576" class="difflineplus">+      }</span>
<a href="#l86.577"></a><span id="l86.577" class="difflineplus">+    }</span>
<a href="#l86.578"></a><span id="l86.578" class="difflineplus">+  },</span>
<a href="#l86.579"></a><span id="l86.579" class="difflineplus">+</span>
<a href="#l86.580"></a><span id="l86.580" class="difflineplus">+  /**</span>
<a href="#l86.581"></a><span id="l86.581" class="difflineplus">+   * Log that one or more messages are expected to be added in the given folder</span>
<a href="#l86.582"></a><span id="l86.582" class="difflineplus">+   *  so that we have an accurate count.  We need to generate the</span>
<a href="#l86.583"></a><span id="l86.583" class="difflineplus">+   *  clearNewMessages call when the last message gets msgAdded.</span>
<a href="#l86.584"></a><span id="l86.584" class="difflineplus">+   */</span>
<a href="#l86.585"></a><span id="l86.585" class="difflineplus">+  expectMessageInFolder:</span>
<a href="#l86.586"></a><span id="l86.586" class="difflineplus">+      function you_see_the_workaround_makes_me_feel_many_complex_emotions(</span>
<a href="#l86.587"></a><span id="l86.587" class="difflineplus">+        aFolder, aCount) {</span>
<a href="#l86.588"></a><span id="l86.588" class="difflineplus">+    if (!this._registered)</span>
<a href="#l86.589"></a><span id="l86.589" class="difflineplus">+        this._register();</span>
<a href="#l86.590"></a><span id="l86.590" class="difflineplus">+    if (aCount == undefined)</span>
<a href="#l86.591"></a><span id="l86.591" class="difflineplus">+      aCount = 1;</span>
<a href="#l86.592"></a><span id="l86.592" class="difflineplus">+    let uri = aFolder.URI;</span>
<a href="#l86.593"></a><span id="l86.593" class="difflineplus">+    if (uri in this._numberOfMessagesToGoPerFolder)</span>
<a href="#l86.594"></a><span id="l86.594" class="difflineplus">+      this._numberOfMessagesToGoPerFolder[uri] += aCount;</span>
<a href="#l86.595"></a><span id="l86.595" class="difflineplus">+    else</span>
<a href="#l86.596"></a><span id="l86.596" class="difflineplus">+      this._numberOfMessagesToGoPerFolder[uri] = aCount;</span>
<a href="#l86.597"></a><span id="l86.597" class="difflineplus">+  },</span>
<a href="#l86.598"></a><span id="l86.598" class="difflineplus">+};</span>
<a href="#l86.599"></a><span id="l86.599" class="difflineplus">+</span>
<a href="#l86.600"></a><span id="l86.600" class="difflineplus">+/**</span>
<a href="#l86.601"></a><span id="l86.601" class="difflineplus">+ * Spreads the messages in aMessageSets across the folders in aMsgFolders.  Each</span>
<a href="#l86.602"></a><span id="l86.602" class="difflineplus">+ *  message set is spread in a round-robin fashion across all folders.  At the</span>
<a href="#l86.603"></a><span id="l86.603" class="difflineplus">+ *  same time, each message-sets insertion is interleaved with the other message</span>
<a href="#l86.604"></a><span id="l86.604" class="difflineplus">+ *  sets.  This distributes message across multiple folders for useful</span>
<a href="#l86.605"></a><span id="l86.605" class="difflineplus">+ *  cross-folder threading testing (via the round robin) while also hopefully</span>
<a href="#l86.606"></a><span id="l86.606" class="difflineplus">+ *  avoiding making things pathologically easy for the code under test (by way</span>
<a href="#l86.607"></a><span id="l86.607" class="difflineplus">+ *  of the interleaving.)</span>
<a href="#l86.608"></a><span id="l86.608" class="difflineplus">+ *</span>
<a href="#l86.609"></a><span id="l86.609" class="difflineplus">+ * For example, given the following 2 input message sets:</span>
<a href="#l86.610"></a><span id="l86.610" class="difflineplus">+ *  message set 'lower': [a b c d e f]</span>
<a href="#l86.611"></a><span id="l86.611" class="difflineplus">+ *  message set 'upper': [A B C D E F G H]</span>
<a href="#l86.612"></a><span id="l86.612" class="difflineplus">+ *</span>
<a href="#l86.613"></a><span id="l86.613" class="difflineplus">+ * across 2 folders:</span>
<a href="#l86.614"></a><span id="l86.614" class="difflineplus">+ *  folder 1: [a A c C e E G]</span>
<a href="#l86.615"></a><span id="l86.615" class="difflineplus">+ *  folder 2: [b B d D f F H]</span>
<a href="#l86.616"></a><span id="l86.616" class="difflineplus">+ * across 3 folders:</span>
<a href="#l86.617"></a><span id="l86.617" class="difflineplus">+ *  folder 1: [a A d D G]</span>
<a href="#l86.618"></a><span id="l86.618" class="difflineplus">+ *  folder 2: [b B e E H]</span>
<a href="#l86.619"></a><span id="l86.619" class="difflineplus">+ *  folder 3: [c C f F]</span>
<a href="#l86.620"></a><span id="l86.620" class="difflineplus">+ *</span>
<a href="#l86.621"></a><span id="l86.621" class="difflineplus">+ * @param aMsgFolders An nsIMsgLocalMailFolder to add the message sets to or a</span>
<a href="#l86.622"></a><span id="l86.622" class="difflineplus">+ *     list of them.</span>
<a href="#l86.623"></a><span id="l86.623" class="difflineplus">+ * @param aMessageSets A list of SyntheticMessageSets.</span>
<a href="#l86.624"></a><span id="l86.624" class="difflineplus">+ *</span>
<a href="#l86.625"></a><span id="l86.625" class="difflineplus">+ * @return true if we were able to do the injection synchronously, false if we</span>
<a href="#l86.626"></a><span id="l86.626" class="difflineplus">+ *     kicked off an asynchronous process and we will call |async_driver| when</span>
<a href="#l86.627"></a><span id="l86.627" class="difflineplus">+ *     we are done.  This is consistent with  asyncTestUtils support.</span>
<a href="#l86.628"></a><span id="l86.628" class="difflineplus">+ */</span>
<a href="#l86.629"></a><span id="l86.629" class="difflineplus">+function add_sets_to_folders(aMsgFolders, aMessageSets) {</span>
<a href="#l86.630"></a><span id="l86.630" class="difflineplus">+  if ((typeof(aMsgFolders) == &quot;string&quot;) || !('length' in aMsgFolders))</span>
<a href="#l86.631"></a><span id="l86.631" class="difflineplus">+    aMsgFolders = [aMsgFolders];</span>
<a href="#l86.632"></a><span id="l86.632" class="difflineplus">+</span>
<a href="#l86.633"></a><span id="l86.633" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.634"></a><span id="l86.634" class="difflineplus">+</span>
<a href="#l86.635"></a><span id="l86.635" class="difflineplus">+  let iterFolders, folderList;</span>
<a href="#l86.636"></a><span id="l86.636" class="difflineplus">+  let ioService, popMessages, msgHdrs;</span>
<a href="#l86.637"></a><span id="l86.637" class="difflineplus">+</span>
<a href="#l86.638"></a><span id="l86.638" class="difflineplus">+  // -- Pre-loop</span>
<a href="#l86.639"></a><span id="l86.639" class="difflineplus">+  if (mis.injectionConfig.mode == &quot;local&quot;) {</span>
<a href="#l86.640"></a><span id="l86.640" class="difflineplus">+    for each (let [, folder] in Iterator(aMsgFolders)) {</span>
<a href="#l86.641"></a><span id="l86.641" class="difflineplus">+      if (!(folder instanceof Components.interfaces.nsIMsgLocalMailFolder))</span>
<a href="#l86.642"></a><span id="l86.642" class="difflineplus">+        throw Exception(&quot;All folders in aMsgFolders must be local folders!&quot;);</span>
<a href="#l86.643"></a><span id="l86.643" class="difflineplus">+    }</span>
<a href="#l86.644"></a><span id="l86.644" class="difflineplus">+    folderList = aMsgFolders;</span>
<a href="#l86.645"></a><span id="l86.645" class="difflineplus">+  }</span>
<a href="#l86.646"></a><span id="l86.646" class="difflineplus">+  else if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l86.647"></a><span id="l86.647" class="difflineplus">+    // no protection is possible because of our dependency on promises,</span>
<a href="#l86.648"></a><span id="l86.648" class="difflineplus">+    //  although we could check that the fake URL is one we handed out.</span>
<a href="#l86.649"></a><span id="l86.649" class="difflineplus">+    folderList = aMsgFolders;</span>
<a href="#l86.650"></a><span id="l86.650" class="difflineplus">+</span>
<a href="#l86.651"></a><span id="l86.651" class="difflineplus">+    ioService = Cc[&quot;@mozilla.org/network/io-service;1&quot;]</span>
<a href="#l86.652"></a><span id="l86.652" class="difflineplus">+                  .getService(Ci.nsIIOService);</span>
<a href="#l86.653"></a><span id="l86.653" class="difflineplus">+  }</span>
<a href="#l86.654"></a><span id="l86.654" class="difflineplus">+  else if (mis.injectionConfig.mode == &quot;pop&quot;) {</span>
<a href="#l86.655"></a><span id="l86.655" class="difflineplus">+    for each (let [, folder] in Iterator(aMsgFolders)) {</span>
<a href="#l86.656"></a><span id="l86.656" class="difflineplus">+      if (folder.URI != mis.inboxFolder.URI)</span>
<a href="#l86.657"></a><span id="l86.657" class="difflineplus">+        throw new Exception(&quot;We only support the Inbox for POP injection&quot;);</span>
<a href="#l86.658"></a><span id="l86.658" class="difflineplus">+    }</span>
<a href="#l86.659"></a><span id="l86.659" class="difflineplus">+    folderList = aMsgFolders;</span>
<a href="#l86.660"></a><span id="l86.660" class="difflineplus">+</span>
<a href="#l86.661"></a><span id="l86.661" class="difflineplus">+    // ugh, so this is really a degenerate case where everything we do is</span>
<a href="#l86.662"></a><span id="l86.662" class="difflineplus">+    //  overkill, but let's try this at least.</span>
<a href="#l86.663"></a><span id="l86.663" class="difflineplus">+    popMessages = [];</span>
<a href="#l86.664"></a><span id="l86.664" class="difflineplus">+  }</span>
<a href="#l86.665"></a><span id="l86.665" class="difflineplus">+  else {</span>
<a href="#l86.666"></a><span id="l86.666" class="difflineplus">+    do_throw(&quot;Message injection is not configured!&quot;);</span>
<a href="#l86.667"></a><span id="l86.667" class="difflineplus">+  }</span>
<a href="#l86.668"></a><span id="l86.668" class="difflineplus">+  iterFolders = _looperator(aMsgFolders);</span>
<a href="#l86.669"></a><span id="l86.669" class="difflineplus">+</span>
<a href="#l86.670"></a><span id="l86.670" class="difflineplus">+  if (mis.injectionConfig.mode == &quot;local&quot;) {</span>
<a href="#l86.671"></a><span id="l86.671" class="difflineplus">+    let iPerSet = 0, folder = iterFolders.next();</span>
<a href="#l86.672"></a><span id="l86.672" class="difflineplus">+    // loop, incrementing our subscript until all message sets are out of messages</span>
<a href="#l86.673"></a><span id="l86.673" class="difflineplus">+    let didSomething;</span>
<a href="#l86.674"></a><span id="l86.674" class="difflineplus">+    do {</span>
<a href="#l86.675"></a><span id="l86.675" class="difflineplus">+      didSomething = false;</span>
<a href="#l86.676"></a><span id="l86.676" class="difflineplus">+      // for each message set, if it is not out of messages, add the message</span>
<a href="#l86.677"></a><span id="l86.677" class="difflineplus">+      for each (let [, messageSet] in Iterator(aMessageSets)) {</span>
<a href="#l86.678"></a><span id="l86.678" class="difflineplus">+        if (iPerSet &lt; messageSet.synMessages.length) {</span>
<a href="#l86.679"></a><span id="l86.679" class="difflineplus">+          let synMsg = messageSet._trackMessageAddition(folder, iPerSet);</span>
<a href="#l86.680"></a><span id="l86.680" class="difflineplus">+          folder.gettingNewMessages = true;</span>
<a href="#l86.681"></a><span id="l86.681" class="difflineplus">+          folder.addMessage(synMsg.toMboxString());</span>
<a href="#l86.682"></a><span id="l86.682" class="difflineplus">+          // if we need to mark the message as junk grab the header and do so</span>
<a href="#l86.683"></a><span id="l86.683" class="difflineplus">+          // (The message set can mark the whole set as junk, but not just</span>
<a href="#l86.684"></a><span id="l86.684" class="difflineplus">+          //  specific messages.)</span>
<a href="#l86.685"></a><span id="l86.685" class="difflineplus">+          if (synMsg.metaState.junk) {</span>
<a href="#l86.686"></a><span id="l86.686" class="difflineplus">+            let msgHdr = messageSet.getMsgHdr(iPerSet);</span>
<a href="#l86.687"></a><span id="l86.687" class="difflineplus">+            msgHdr.setStringProperty(&quot;junkscore&quot;, &quot;100&quot;);</span>
<a href="#l86.688"></a><span id="l86.688" class="difflineplus">+          }</span>
<a href="#l86.689"></a><span id="l86.689" class="difflineplus">+          folder.gettingNewMessages = false;</span>
<a href="#l86.690"></a><span id="l86.690" class="difflineplus">+          folder.hasNewMessages = true;</span>
<a href="#l86.691"></a><span id="l86.691" class="difflineplus">+          didSomething = true;</span>
<a href="#l86.692"></a><span id="l86.692" class="difflineplus">+        }</span>
<a href="#l86.693"></a><span id="l86.693" class="difflineplus">+      }</span>
<a href="#l86.694"></a><span id="l86.694" class="difflineplus">+      iPerSet++;</span>
<a href="#l86.695"></a><span id="l86.695" class="difflineplus">+      folder = iterFolders.next();</span>
<a href="#l86.696"></a><span id="l86.696" class="difflineplus">+    } while (didSomething);</span>
<a href="#l86.697"></a><span id="l86.697" class="difflineplus">+</span>
<a href="#l86.698"></a><span id="l86.698" class="difflineplus">+    // make sure that junk filtering gets a turn</span>
<a href="#l86.699"></a><span id="l86.699" class="difflineplus">+    // XXX we probably need to be doing more in terms of filters here,</span>
<a href="#l86.700"></a><span id="l86.700" class="difflineplus">+    //  although since filters really want to be run on the inbox, there</span>
<a href="#l86.701"></a><span id="l86.701" class="difflineplus">+    //  are separate potential semantic issues involved.</span>
<a href="#l86.702"></a><span id="l86.702" class="difflineplus">+    for each (let [, folder] in Iterator(aMsgFolders)) {</span>
<a href="#l86.703"></a><span id="l86.703" class="difflineplus">+      // XXX Pretend we live in an ideal world by clearing the new list before</span>
<a href="#l86.704"></a><span id="l86.704" class="difflineplus">+      //  invoking callFilterPlugins.  Because it processes the union of the</span>
<a href="#l86.705"></a><span id="l86.705" class="difflineplus">+      //  new list and the saved new list (which is populated when you call</span>
<a href="#l86.706"></a><span id="l86.706" class="difflineplus">+      //  clearNewMessages and cleared by callFilterPlugins), by calling</span>
<a href="#l86.707"></a><span id="l86.707" class="difflineplus">+      //  clearNewMessages before callFilterPlugins we ensure that the message</span>
<a href="#l86.708"></a><span id="l86.708" class="difflineplus">+      //  only gets seen by the method once.</span>
<a href="#l86.709"></a><span id="l86.709" class="difflineplus">+      // The downside is that code in reality can be disappointed to get the</span>
<a href="#l86.710"></a><span id="l86.710" class="difflineplus">+      //  notification more than once.</span>
<a href="#l86.711"></a><span id="l86.711" class="difflineplus">+      folder.clearNewMessages();</span>
<a href="#l86.712"></a><span id="l86.712" class="difflineplus">+      folder.callFilterPlugins(null);</span>
<a href="#l86.713"></a><span id="l86.713" class="difflineplus">+    }</span>
<a href="#l86.714"></a><span id="l86.714" class="difflineplus">+  }</span>
<a href="#l86.715"></a><span id="l86.715" class="difflineplus">+  else if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l86.716"></a><span id="l86.716" class="difflineplus">+    // we need to call updateFolder on all the folders, not just the first</span>
<a href="#l86.717"></a><span id="l86.717" class="difflineplus">+    //  one...</span>
<a href="#l86.718"></a><span id="l86.718" class="difflineplus">+    return async_run({func: function() {</span>
<a href="#l86.719"></a><span id="l86.719" class="difflineplus">+      yield wait_for_async_promises();</span>
<a href="#l86.720"></a><span id="l86.720" class="difflineplus">+</span>
<a href="#l86.721"></a><span id="l86.721" class="difflineplus">+      let iPerSet = 0, folder = iterFolders.next();</span>
<a href="#l86.722"></a><span id="l86.722" class="difflineplus">+      let didSomething;</span>
<a href="#l86.723"></a><span id="l86.723" class="difflineplus">+      do {</span>
<a href="#l86.724"></a><span id="l86.724" class="difflineplus">+        didSomething = false;</span>
<a href="#l86.725"></a><span id="l86.725" class="difflineplus">+        for each (let [, messageSet] in Iterator(aMessageSets)) {</span>
<a href="#l86.726"></a><span id="l86.726" class="difflineplus">+          if (iPerSet &lt; messageSet.synMessages.length) {</span>
<a href="#l86.727"></a><span id="l86.727" class="difflineplus">+            didSomething = true;</span>
<a href="#l86.728"></a><span id="l86.728" class="difflineplus">+</span>
<a href="#l86.729"></a><span id="l86.729" class="difflineplus">+            let realFolder = mis.handleUriToRealFolder[folder];</span>
<a href="#l86.730"></a><span id="l86.730" class="difflineplus">+            let fakeFolder = mis.handleUriToFakeFolder[folder];</span>
<a href="#l86.731"></a><span id="l86.731" class="difflineplus">+            let synMsg = messageSet._trackMessageAddition(realFolder, iPerSet);</span>
<a href="#l86.732"></a><span id="l86.732" class="difflineplus">+            let msgURI =</span>
<a href="#l86.733"></a><span id="l86.733" class="difflineplus">+              ioService.newURI(&quot;data:text/plain;base64,&quot; +</span>
<a href="#l86.734"></a><span id="l86.734" class="difflineplus">+                               btoa(synMsg.toMessageString()),</span>
<a href="#l86.735"></a><span id="l86.735" class="difflineplus">+                               null, null);</span>
<a href="#l86.736"></a><span id="l86.736" class="difflineplus">+            let imapMsg = new imapMessage(msgURI.spec, fakeFolder.uidnext++, []);</span>
<a href="#l86.737"></a><span id="l86.737" class="difflineplus">+            // If the message's meta-state indicates it is junk, set that flag.</span>
<a href="#l86.738"></a><span id="l86.738" class="difflineplus">+            // There is also a NotJunk flag, but we're not playing with that</span>
<a href="#l86.739"></a><span id="l86.739" class="difflineplus">+            //  right now; as long as nothing is ever marked as junk, the junk</span>
<a href="#l86.740"></a><span id="l86.740" class="difflineplus">+            //  classifier won't run, so it's moot for now.</span>
<a href="#l86.741"></a><span id="l86.741" class="difflineplus">+            if (synMsg.metaState.junk)</span>
<a href="#l86.742"></a><span id="l86.742" class="difflineplus">+              imapMsg.setFlag(&quot;Junk&quot;);</span>
<a href="#l86.743"></a><span id="l86.743" class="difflineplus">+            fakeFolder.addMessage(imapMsg);</span>
<a href="#l86.744"></a><span id="l86.744" class="difflineplus">+            _imapNewMessagesWorkaround.expectMessageInFolder(realFolder);</span>
<a href="#l86.745"></a><span id="l86.745" class="difflineplus">+          }</span>
<a href="#l86.746"></a><span id="l86.746" class="difflineplus">+        }</span>
<a href="#l86.747"></a><span id="l86.747" class="difflineplus">+        iPerSet++;</span>
<a href="#l86.748"></a><span id="l86.748" class="difflineplus">+        folder = iterFolders.next();</span>
<a href="#l86.749"></a><span id="l86.749" class="difflineplus">+      } while (didSomething);</span>
<a href="#l86.750"></a><span id="l86.750" class="difflineplus">+</span>
<a href="#l86.751"></a><span id="l86.751" class="difflineplus">+      for (let iFolder = 0; iFolder &lt; aMsgFolders.length; iFolder++) {</span>
<a href="#l86.752"></a><span id="l86.752" class="difflineplus">+        let realFolder = mis.handleUriToRealFolder[aMsgFolders[iFolder]];</span>
<a href="#l86.753"></a><span id="l86.753" class="difflineplus">+        mark_action(&quot;messageInjection&quot;, &quot;forcing update of folder&quot;,</span>
<a href="#l86.754"></a><span id="l86.754" class="difflineplus">+                    [realFolder]);</span>
<a href="#l86.755"></a><span id="l86.755" class="difflineplus">+        updateFolderAndNotify(realFolder, async_driver);</span>
<a href="#l86.756"></a><span id="l86.756" class="difflineplus">+        yield false;</span>
<a href="#l86.757"></a><span id="l86.757" class="difflineplus">+</span>
<a href="#l86.758"></a><span id="l86.758" class="difflineplus">+        // XXX Ideal-world-pretending just like the local case for problems with</span>
<a href="#l86.759"></a><span id="l86.759" class="difflineplus">+        //  the new list and callFilterPlugins.  We do this after updateFolder</span>
<a href="#l86.760"></a><span id="l86.760" class="difflineplus">+        //  because the new headers aren't known until this point.  For this</span>
<a href="#l86.761"></a><span id="l86.761" class="difflineplus">+        //  to work (which it appears to do), we must be doing this before</span>
<a href="#l86.762"></a><span id="l86.762" class="difflineplus">+        //  callFilterPlugins happens.  Not sure of exactly how that is managing</span>
<a href="#l86.763"></a><span id="l86.763" class="difflineplus">+        //  to happen, but I guess it is.</span>
<a href="#l86.764"></a><span id="l86.764" class="difflineplus">+        realFolder.clearNewMessages();</span>
<a href="#l86.765"></a><span id="l86.765" class="difflineplus">+</span>
<a href="#l86.766"></a><span id="l86.766" class="difflineplus">+        // compel download of the messages if appropriate</span>
<a href="#l86.767"></a><span id="l86.767" class="difflineplus">+        if (realFolder.flags &amp; Ci.nsMsgFolderFlags.Offline) {</span>
<a href="#l86.768"></a><span id="l86.768" class="difflineplus">+          mark_action(&quot;messageInjection&quot;, &quot;offlining messages&quot;, [realFolder]);</span>
<a href="#l86.769"></a><span id="l86.769" class="difflineplus">+          realFolder.downloadAllForOffline(asyncUrlListener, null);</span>
<a href="#l86.770"></a><span id="l86.770" class="difflineplus">+          yield false;</span>
<a href="#l86.771"></a><span id="l86.771" class="difflineplus">+        }</span>
<a href="#l86.772"></a><span id="l86.772" class="difflineplus">+      }</span>
<a href="#l86.773"></a><span id="l86.773" class="difflineplus">+    }});</span>
<a href="#l86.774"></a><span id="l86.774" class="difflineplus">+  }</span>
<a href="#l86.775"></a><span id="l86.775" class="difflineplus">+  else if (mis.injectionConfig.mode == &quot;pop&quot;) {</span>
<a href="#l86.776"></a><span id="l86.776" class="difflineplus">+    let iPerSet = 0, folder = iterFolders.next();</span>
<a href="#l86.777"></a><span id="l86.777" class="difflineplus">+    // loop, incrementing our subscript until all message sets are out of messages</span>
<a href="#l86.778"></a><span id="l86.778" class="difflineplus">+    let didSomething;</span>
<a href="#l86.779"></a><span id="l86.779" class="difflineplus">+    do {</span>
<a href="#l86.780"></a><span id="l86.780" class="difflineplus">+      didSomething = false;</span>
<a href="#l86.781"></a><span id="l86.781" class="difflineplus">+      // for each message set, if it is not out of messages, add the message</span>
<a href="#l86.782"></a><span id="l86.782" class="difflineplus">+      for each (let [, messageSet] in Iterator(aMessageSets)) {</span>
<a href="#l86.783"></a><span id="l86.783" class="difflineplus">+        if (iPerSet &lt; messageSet.synMessages.length) {</span>
<a href="#l86.784"></a><span id="l86.784" class="difflineplus">+          popMessages.push(messageSet._trackMessageAddition(folder, iPerSet));</span>
<a href="#l86.785"></a><span id="l86.785" class="difflineplus">+          didSomething = true;</span>
<a href="#l86.786"></a><span id="l86.786" class="difflineplus">+        }</span>
<a href="#l86.787"></a><span id="l86.787" class="difflineplus">+      }</span>
<a href="#l86.788"></a><span id="l86.788" class="difflineplus">+      iPerSet++;</span>
<a href="#l86.789"></a><span id="l86.789" class="difflineplus">+      folder = iterFolders.next();</span>
<a href="#l86.790"></a><span id="l86.790" class="difflineplus">+    } while (didSomething);</span>
<a href="#l86.791"></a><span id="l86.791" class="difflineplus">+</span>
<a href="#l86.792"></a><span id="l86.792" class="difflineplus">+    ims.daemon.setMessages(_synthMessagesToFakeRep(popMessages));</span>
<a href="#l86.793"></a><span id="l86.793" class="difflineplus">+    ims.pop3Service.GetNewMail(null, asyncUrlListener, mis.inboxFolder,</span>
<a href="#l86.794"></a><span id="l86.794" class="difflineplus">+                               mis.incomingServer);</span>
<a href="#l86.795"></a><span id="l86.795" class="difflineplus">+    return false; // wait for the url listener to be notified</span>
<a href="#l86.796"></a><span id="l86.796" class="difflineplus">+  }</span>
<a href="#l86.797"></a><span id="l86.797" class="difflineplus">+</span>
<a href="#l86.798"></a><span id="l86.798" class="difflineplus">+  return true;</span>
<a href="#l86.799"></a><span id="l86.799" class="difflineplus">+};</span>
<a href="#l86.800"></a><span id="l86.800" class="difflineplus">+/** singular function name for understandability of single-folder users */</span>
<a href="#l86.801"></a><span id="l86.801" class="difflineplus">+let add_sets_to_folder = add_sets_to_folders;</span>
<a href="#l86.802"></a><span id="l86.802" class="difflineplus">+</span>
<a href="#l86.803"></a><span id="l86.803" class="difflineplus">+function get_real_injection_folder(aFolderHandle) {</span>
<a href="#l86.804"></a><span id="l86.804" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.805"></a><span id="l86.805" class="difflineplus">+  if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l86.806"></a><span id="l86.806" class="difflineplus">+    return mis.handleUriToRealFolder[aFolderHandle];</span>
<a href="#l86.807"></a><span id="l86.807" class="difflineplus">+  }</span>
<a href="#l86.808"></a><span id="l86.808" class="difflineplus">+  return aFolderHandle;</span>
<a href="#l86.809"></a><span id="l86.809" class="difflineplus">+}</span>
<a href="#l86.810"></a><span id="l86.810" class="difflineplus">+</span>
<a href="#l86.811"></a><span id="l86.811" class="difflineplus">+/**</span>
<a href="#l86.812"></a><span id="l86.812" class="difflineplus">+ * Helper function for any of the convenience functions that integrate</span>
<a href="#l86.813"></a><span id="l86.813" class="difflineplus">+ *  message injection.</span>
<a href="#l86.814"></a><span id="l86.814" class="difflineplus">+ */</span>
<a href="#l86.815"></a><span id="l86.815" class="difflineplus">+function wait_for_message_injection() {</span>
<a href="#l86.816"></a><span id="l86.816" class="difflineplus">+  let mis = _messageInjectionSetup;</span>
<a href="#l86.817"></a><span id="l86.817" class="difflineplus">+  if (mis.injectionConfig.mode == &quot;imap&quot; ||</span>
<a href="#l86.818"></a><span id="l86.818" class="difflineplus">+      mis.injectionConfig.mode == &quot;pop&quot;)</span>
<a href="#l86.819"></a><span id="l86.819" class="difflineplus">+    return false;</span>
<a href="#l86.820"></a><span id="l86.820" class="difflineplus">+  else</span>
<a href="#l86.821"></a><span id="l86.821" class="difflineplus">+    return true;</span>
<a href="#l86.822"></a><span id="l86.822" class="difflineplus">+}</span>
<a href="#l86.823"></a><span id="l86.823" class="difflineplus">+</span>
<a href="#l86.824"></a><span id="l86.824" class="difflineplus">+/**</span>
<a href="#l86.825"></a><span id="l86.825" class="difflineplus">+ * Asynchronously move messages in the given set to the destination folder.</span>
<a href="#l86.826"></a><span id="l86.826" class="difflineplus">+ *</span>
<a href="#l86.827"></a><span id="l86.827" class="difflineplus">+ * The IMAP case is much more complex, at least in the unit testing world:</span>
<a href="#l86.828"></a><span id="l86.828" class="difflineplus">+ * XXX We have to force an update of the source folder because the fake</span>
<a href="#l86.829"></a><span id="l86.829" class="difflineplus">+ *  server only allows one connection and that one connection currently</span>
<a href="#l86.830"></a><span id="l86.830" class="difflineplus">+ *  is focused on destFolder; we have to force an update of srcFolder to</span>
<a href="#l86.831"></a><span id="l86.831" class="difflineplus">+ *  get the move to actually hit the IMAP server.</span>
<a href="#l86.832"></a><span id="l86.832" class="difflineplus">+ */</span>
<a href="#l86.833"></a><span id="l86.833" class="difflineplus">+function async_move_messages(aSynMessageSet, aDestFolder) {</span>
<a href="#l86.834"></a><span id="l86.834" class="difflineplus">+  mark_action(&quot;messageInjection&quot;, &quot;moving messages&quot;, aSynMessageSet.msgHdrList);</span>
<a href="#l86.835"></a><span id="l86.835" class="difflineplus">+  return async_run({func: function () {</span>
<a href="#l86.836"></a><span id="l86.836" class="difflineplus">+      // we need to make sure all folder promises are fulfilled</span>
<a href="#l86.837"></a><span id="l86.837" class="difflineplus">+      yield wait_for_async_promises();</span>
<a href="#l86.838"></a><span id="l86.838" class="difflineplus">+      // and then we can make sure we have the actual folder</span>
<a href="#l86.839"></a><span id="l86.839" class="difflineplus">+      let realDestFolder = get_real_injection_folder(aDestFolder);</span>
<a href="#l86.840"></a><span id="l86.840" class="difflineplus">+</span>
<a href="#l86.841"></a><span id="l86.841" class="difflineplus">+      let copyService = Cc[&quot;@mozilla.org/messenger/messagecopyservice;1&quot;]</span>
<a href="#l86.842"></a><span id="l86.842" class="difflineplus">+                          .getService(Ci.nsIMsgCopyService);</span>
<a href="#l86.843"></a><span id="l86.843" class="difflineplus">+      for (let [folder, xpcomHdrArray] in</span>
<a href="#l86.844"></a><span id="l86.844" class="difflineplus">+           aSynMessageSet.foldersWithXpcomHdrArrays) {</span>
<a href="#l86.845"></a><span id="l86.845" class="difflineplus">+        mark_action(&quot;messageInjection&quot;,</span>
<a href="#l86.846"></a><span id="l86.846" class="difflineplus">+                    &quot;moving messages&quot;,</span>
<a href="#l86.847"></a><span id="l86.847" class="difflineplus">+                    [&quot;from&quot;, folder, &quot;to&quot;, realDestFolder]);</span>
<a href="#l86.848"></a><span id="l86.848" class="difflineplus">+        _imapNewMessagesWorkaround.expectMessageInFolder(realDestFolder,</span>
<a href="#l86.849"></a><span id="l86.849" class="difflineplus">+                                                         xpcomHdrArray.length);</span>
<a href="#l86.850"></a><span id="l86.850" class="difflineplus">+        copyService.CopyMessages(folder, xpcomHdrArray,</span>
<a href="#l86.851"></a><span id="l86.851" class="difflineplus">+                                 realDestFolder, /* move */ true,</span>
<a href="#l86.852"></a><span id="l86.852" class="difflineplus">+                                 asyncCopyListener, null,</span>
<a href="#l86.853"></a><span id="l86.853" class="difflineplus">+                                 /* do not allow undo, leaks */ false);</span>
<a href="#l86.854"></a><span id="l86.854" class="difflineplus">+        // update the synthetic message set's folder entry...</span>
<a href="#l86.855"></a><span id="l86.855" class="difflineplus">+        aSynMessageSet._folderSwap(folder, realDestFolder);</span>
<a href="#l86.856"></a><span id="l86.856" class="difflineplus">+        yield false;</span>
<a href="#l86.857"></a><span id="l86.857" class="difflineplus">+</span>
<a href="#l86.858"></a><span id="l86.858" class="difflineplus">+        // IMAP special case per function doc...</span>
<a href="#l86.859"></a><span id="l86.859" class="difflineplus">+        if (!message_injection_is_local()) {</span>
<a href="#l86.860"></a><span id="l86.860" class="difflineplus">+          mark_action(&quot;messageInjection&quot;,</span>
<a href="#l86.861"></a><span id="l86.861" class="difflineplus">+                      &quot;forcing update of folder so IMAP move issued&quot;,</span>
<a href="#l86.862"></a><span id="l86.862" class="difflineplus">+                      [folder]);</span>
<a href="#l86.863"></a><span id="l86.863" class="difflineplus">+          // update the source folder to force it to issue the move</span>
<a href="#l86.864"></a><span id="l86.864" class="difflineplus">+          updateFolderAndNotify(folder, async_driver);</span>
<a href="#l86.865"></a><span id="l86.865" class="difflineplus">+          yield false;</span>
<a href="#l86.866"></a><span id="l86.866" class="difflineplus">+</span>
<a href="#l86.867"></a><span id="l86.867" class="difflineplus">+          mark_action(&quot;messageInjection&quot;,</span>
<a href="#l86.868"></a><span id="l86.868" class="difflineplus">+                      &quot;forcing update of folder so IMAP moved header seen&quot;,</span>
<a href="#l86.869"></a><span id="l86.869" class="difflineplus">+                      [realDestFolder]);</span>
<a href="#l86.870"></a><span id="l86.870" class="difflineplus">+          // update the dest folder to see the new header.</span>
<a href="#l86.871"></a><span id="l86.871" class="difflineplus">+          updateFolderAndNotify(realDestFolder, async_driver);</span>
<a href="#l86.872"></a><span id="l86.872" class="difflineplus">+          yield false;</span>
<a href="#l86.873"></a><span id="l86.873" class="difflineplus">+</span>
<a href="#l86.874"></a><span id="l86.874" class="difflineplus">+          // compel download of messages in dest folder if appropriate</span>
<a href="#l86.875"></a><span id="l86.875" class="difflineplus">+          if (realDestFolder.flags &amp; Ci.nsMsgFolderFlags.Offline) {</span>
<a href="#l86.876"></a><span id="l86.876" class="difflineplus">+            mark_action(&quot;messageInjection&quot;, &quot;offlining messages&quot;,</span>
<a href="#l86.877"></a><span id="l86.877" class="difflineplus">+                        [realDestFolder]);</span>
<a href="#l86.878"></a><span id="l86.878" class="difflineplus">+            realDestFolder.downloadAllForOffline(asyncUrlListener, null);</span>
<a href="#l86.879"></a><span id="l86.879" class="difflineplus">+            yield false;</span>
<a href="#l86.880"></a><span id="l86.880" class="difflineplus">+          }</span>
<a href="#l86.881"></a><span id="l86.881" class="difflineplus">+        }</span>
<a href="#l86.882"></a><span id="l86.882" class="difflineplus">+      }</span>
<a href="#l86.883"></a><span id="l86.883" class="difflineplus">+    },</span>
<a href="#l86.884"></a><span id="l86.884" class="difflineplus">+  });</span>
<a href="#l86.885"></a><span id="l86.885" class="difflineplus">+}</span>
<a href="#l86.886"></a><span id="l86.886" class="difflineplus">+</span>
<a href="#l86.887"></a><span id="l86.887" class="difflineplus">+/**</span>
<a href="#l86.888"></a><span id="l86.888" class="difflineplus">+ * Empty the trash.</span>
<a href="#l86.889"></a><span id="l86.889" class="difflineplus">+ */</span>
<a href="#l86.890"></a><span id="l86.890" class="difflineplus">+function async_empty_trash() {</span>
<a href="#l86.891"></a><span id="l86.891" class="difflineplus">+  _messageInjectionSetup.trashFolder.emptyTrash(null, asyncUrlListener);</span>
<a href="#l86.892"></a><span id="l86.892" class="difflineplus">+  return false;</span>
<a href="#l86.893"></a><span id="l86.893" class="difflineplus">+}</span>
<a href="#l86.894"></a><span id="l86.894" class="difflineplus">+</span>
<a href="#l86.895"></a><span id="l86.895" class="difflineplus">+/**</span>
<a href="#l86.896"></a><span id="l86.896" class="difflineplus">+ * Delete the given folder, removing the storage.  We do not move it to the</span>
<a href="#l86.897"></a><span id="l86.897" class="difflineplus">+ *  trash.</span>
<a href="#l86.898"></a><span id="l86.898" class="difflineplus">+ */</span>
<a href="#l86.899"></a><span id="l86.899" class="difflineplus">+function async_delete_folder(aFolder) {</span>
<a href="#l86.900"></a><span id="l86.900" class="difflineplus">+  let realFolder = get_real_injection_folder(aFolder);</span>
<a href="#l86.901"></a><span id="l86.901" class="difflineplus">+  mark_action(&quot;messageInjection&quot;, &quot;deleting folder&quot;, [realFolder]);</span>
<a href="#l86.902"></a><span id="l86.902" class="difflineplus">+  realFolder.parent.propagateDelete(realFolder, true, null);</span>
<a href="#l86.903"></a><span id="l86.903" class="difflineplus">+  return true;</span>
<a href="#l86.904"></a><span id="l86.904" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l87.1"></a><span id="l87.1" class="difflineminus">--- a/mailnews/test/resources/messageModifier.js</span>
<a href="#l87.2"></a><span id="l87.2" class="difflineplus">+++ b/mailnews/test/resources/messageModifier.js</span>
<a href="#l87.3"></a><span id="l87.3" class="difflineat">@@ -72,24 +72,40 @@ function SyntheticMessageSet(aSynMessage</span>
<a href="#l87.4"></a><span id="l87.4">     this.msgFolders = aMsgFolders;</span>
<a href="#l87.5"></a><span id="l87.5"> </span>
<a href="#l87.6"></a><span id="l87.6">   if (aFolderIndices == null)</span>
<a href="#l87.7"></a><span id="l87.7">     this.folderIndices = [null for each (blah in Iterator(aSynMessages))];</span>
<a href="#l87.8"></a><span id="l87.8">   else</span>
<a href="#l87.9"></a><span id="l87.9">     this.folderIndices = aFolderIndices;</span>
<a href="#l87.10"></a><span id="l87.10"> }</span>
<a href="#l87.11"></a><span id="l87.11"> SyntheticMessageSet.prototype = {</span>
<a href="#l87.12"></a><span id="l87.12" class="difflineminus">-  addMessageToFolderByIndex: function(aFolder, aMessageIndex) {</span>
<a href="#l87.13"></a><span id="l87.13" class="difflineplus">+  /**</span>
<a href="#l87.14"></a><span id="l87.14" class="difflineplus">+   * Helper method for messageInjection to use to tell us it is injecting a</span>
<a href="#l87.15"></a><span id="l87.15" class="difflineplus">+   *  message in a given folder.  As a convenience, we also return the</span>
<a href="#l87.16"></a><span id="l87.16" class="difflineplus">+   *  synthetic message.</span>
<a href="#l87.17"></a><span id="l87.17" class="difflineplus">+   *</span>
<a href="#l87.18"></a><span id="l87.18" class="difflineplus">+   * @protected</span>
<a href="#l87.19"></a><span id="l87.19" class="difflineplus">+   */</span>
<a href="#l87.20"></a><span id="l87.20" class="difflineplus">+  _trackMessageAddition: function(aFolder, aMessageIndex) {</span>
<a href="#l87.21"></a><span id="l87.21">     let aFolderIndex = this.msgFolders.indexOf(aFolder);</span>
<a href="#l87.22"></a><span id="l87.22">     if (aFolderIndex == -1)</span>
<a href="#l87.23"></a><span id="l87.23">       aFolderIndex = this.msgFolders.push(aFolder) - 1;</span>
<a href="#l87.24"></a><span id="l87.24">     this.folderIndices[aMessageIndex] = aFolderIndex;</span>
<a href="#l87.25"></a><span id="l87.25" class="difflineminus">-    aFolder.addMessage(this.synMessages[aMessageIndex].toMboxString());</span>
<a href="#l87.26"></a><span id="l87.26" class="difflineplus">+    return this.synMessages[aMessageIndex];</span>
<a href="#l87.27"></a><span id="l87.27">   },</span>
<a href="#l87.28"></a><span id="l87.28">   /**</span>
<a href="#l87.29"></a><span id="l87.29" class="difflineplus">+   * Helper method for use by |async_move_messages| to tell us that it moved</span>
<a href="#l87.30"></a><span id="l87.30" class="difflineplus">+   *  all the messages from aOldFolder to aNewFolder.</span>
<a href="#l87.31"></a><span id="l87.31" class="difflineplus">+   */</span>
<a href="#l87.32"></a><span id="l87.32" class="difflineplus">+  _folderSwap: function(aOldFolder, aNewFolder) {</span>
<a href="#l87.33"></a><span id="l87.33" class="difflineplus">+    let folderIndex = this.msgFolders.indexOf(aOldFolder);</span>
<a href="#l87.34"></a><span id="l87.34" class="difflineplus">+    this.msgFolders[folderIndex] = aNewFolder;</span>
<a href="#l87.35"></a><span id="l87.35" class="difflineplus">+  },</span>
<a href="#l87.36"></a><span id="l87.36" class="difflineplus">+</span>
<a href="#l87.37"></a><span id="l87.37" class="difflineplus">+  /**</span>
<a href="#l87.38"></a><span id="l87.38">    * Union this set with another set and return the (new) result.</span>
<a href="#l87.39"></a><span id="l87.39">    *</span>
<a href="#l87.40"></a><span id="l87.40">    * @param aOtherSet The other synthetic message set.</span>
<a href="#l87.41"></a><span id="l87.41">    * @returns a new SyntheticMessageSet containing the union of this set and</span>
<a href="#l87.42"></a><span id="l87.42">    *     the other set.</span>
<a href="#l87.43"></a><span id="l87.43">    */</span>
<a href="#l87.44"></a><span id="l87.44">   union: function(aOtherSet) {</span>
<a href="#l87.45"></a><span id="l87.45">     let messages = this.synMessages.concat(aOtherSet.synMessages);</span>
<a href="#l87.46"></a><span id="l87.46" class="difflineat">@@ -115,29 +131,47 @@ SyntheticMessageSet.prototype = {</span>
<a href="#l87.47"></a><span id="l87.47">         indices.push(folderUrisToIndices[folder.URI]);</span>
<a href="#l87.48"></a><span id="l87.48">       }</span>
<a href="#l87.49"></a><span id="l87.49">     }</span>
<a href="#l87.50"></a><span id="l87.50"> </span>
<a href="#l87.51"></a><span id="l87.51">     return new SyntheticMessageSet(messages, folders, indices);</span>
<a href="#l87.52"></a><span id="l87.52">   },</span>
<a href="#l87.53"></a><span id="l87.53"> </span>
<a href="#l87.54"></a><span id="l87.54">   /**</span>
<a href="#l87.55"></a><span id="l87.55" class="difflineminus">-   * @return a JS list of the message headers for all messages inserted into a</span>
<a href="#l87.56"></a><span id="l87.56" class="difflineminus">-   *     folder.</span>
<a href="#l87.57"></a><span id="l87.57" class="difflineplus">+   * Get the single message header of the message at the given index; use</span>
<a href="#l87.58"></a><span id="l87.58" class="difflineplus">+   *  |msgHdrs| or |xpcomHdrArray| if you want to get all the headers at once.</span>
<a href="#l87.59"></a><span id="l87.59" class="difflineplus">+   */</span>
<a href="#l87.60"></a><span id="l87.60" class="difflineplus">+  getMsgHdr: function(aIndex) {</span>
<a href="#l87.61"></a><span id="l87.61" class="difflineplus">+    let folder = this.msgFolders[this.folderIndices[aIndex]];</span>
<a href="#l87.62"></a><span id="l87.62" class="difflineplus">+    let synMsg = this.synMessages[aIndex];</span>
<a href="#l87.63"></a><span id="l87.63" class="difflineplus">+    return folder.msgDatabase.getMsgHdrForMessageID(synMsg.messageId);</span>
<a href="#l87.64"></a><span id="l87.64" class="difflineplus">+  },</span>
<a href="#l87.65"></a><span id="l87.65" class="difflineplus">+</span>
<a href="#l87.66"></a><span id="l87.66" class="difflineplus">+  /**</span>
<a href="#l87.67"></a><span id="l87.67" class="difflineplus">+   * @return a JS iterator of the message headers for all messages inserted into</span>
<a href="#l87.68"></a><span id="l87.68" class="difflineplus">+   *     a folder.</span>
<a href="#l87.69"></a><span id="l87.69">    */</span>
<a href="#l87.70"></a><span id="l87.70">   get msgHdrs() {</span>
<a href="#l87.71"></a><span id="l87.71" class="difflineplus">+    // get the databases</span>
<a href="#l87.72"></a><span id="l87.72">     let msgDatabases = [folder.msgDatabase for each</span>
<a href="#l87.73"></a><span id="l87.73">                         ([, folder] in Iterator(this.msgFolders))];</span>
<a href="#l87.74"></a><span id="l87.74">     for (let [iMsg, synMsg] in Iterator(this.synMessages)) {</span>
<a href="#l87.75"></a><span id="l87.75">       let folderIndex = this.folderIndices[iMsg];</span>
<a href="#l87.76"></a><span id="l87.76">       if (folderIndex != null)</span>
<a href="#l87.77"></a><span id="l87.77">         yield msgDatabases[folderIndex].getMsgHdrForMessageID(synMsg.messageId);</span>
<a href="#l87.78"></a><span id="l87.78">     }</span>
<a href="#l87.79"></a><span id="l87.79">   },</span>
<a href="#l87.80"></a><span id="l87.80">   /**</span>
<a href="#l87.81"></a><span id="l87.81" class="difflineplus">+   * @return a JS list of the message headers for all messages inserted into a</span>
<a href="#l87.82"></a><span id="l87.82" class="difflineplus">+   *     folder.</span>
<a href="#l87.83"></a><span id="l87.83" class="difflineplus">+   */</span>
<a href="#l87.84"></a><span id="l87.84" class="difflineplus">+  get msgHdrList() {</span>
<a href="#l87.85"></a><span id="l87.85" class="difflineplus">+    return [msgHdr for each (msgHdr in this.msgHdrs)];</span>
<a href="#l87.86"></a><span id="l87.86" class="difflineplus">+  },</span>
<a href="#l87.87"></a><span id="l87.87" class="difflineplus">+  /**</span>
<a href="#l87.88"></a><span id="l87.88">    * @return an nsIMutableArray of the message headers for all messages inserted</span>
<a href="#l87.89"></a><span id="l87.89">    *     into a folder.</span>
<a href="#l87.90"></a><span id="l87.90">    */</span>
<a href="#l87.91"></a><span id="l87.91">   get xpcomHdrArray() {</span>
<a href="#l87.92"></a><span id="l87.92">     return toXPCOMArray(this.msgHdrs,</span>
<a href="#l87.93"></a><span id="l87.93">                         Components.interfaces.nsIMutableArray);</span>
<a href="#l87.94"></a><span id="l87.94">   },</span>
<a href="#l87.95"></a><span id="l87.95">   /**</span>
<a href="#l87.96"></a><span id="l87.96" class="difflineat">@@ -169,17 +203,17 @@ SyntheticMessageSet.prototype = {</span>
<a href="#l87.97"></a><span id="l87.97">   },</span>
<a href="#l87.98"></a><span id="l87.98">   setRead: function(aRead) {</span>
<a href="#l87.99"></a><span id="l87.99">     for each (let msgHdr in this.msgHdrs) {</span>
<a href="#l87.100"></a><span id="l87.100">       msgHdr.markRead(aRead);</span>
<a href="#l87.101"></a><span id="l87.101">     }</span>
<a href="#l87.102"></a><span id="l87.102">   },</span>
<a href="#l87.103"></a><span id="l87.103">   setStarred: function(aStarred) {</span>
<a href="#l87.104"></a><span id="l87.104">     for each (let msgHdr in this.msgHdrs) {</span>
<a href="#l87.105"></a><span id="l87.105" class="difflineminus">-      msgHdr.markFlagged(aRead);</span>
<a href="#l87.106"></a><span id="l87.106" class="difflineplus">+      msgHdr.markFlagged(aStarred);</span>
<a href="#l87.107"></a><span id="l87.107">     }</span>
<a href="#l87.108"></a><span id="l87.108">   },</span>
<a href="#l87.109"></a><span id="l87.109">   addTag: function(aTagName) {</span>
<a href="#l87.110"></a><span id="l87.110">     for (let [folder, xpcomHdrArray] in this.foldersWithXpcomHdrArrays) {</span>
<a href="#l87.111"></a><span id="l87.111">       folder.addKeywordsToMessages(xpcomHdrArray, aTagName);</span>
<a href="#l87.112"></a><span id="l87.112">     }</span>
<a href="#l87.113"></a><span id="l87.113">   },</span>
<a href="#l87.114"></a><span id="l87.114">   removeTag: function(aTagName) {</span>
<a href="#l87.115"></a><span id="l87.115" class="difflineat">@@ -188,29 +222,45 @@ SyntheticMessageSet.prototype = {</span>
<a href="#l87.116"></a><span id="l87.116">     }</span>
<a href="#l87.117"></a><span id="l87.117">   },</span>
<a href="#l87.118"></a><span id="l87.118">   /**</span>
<a href="#l87.119"></a><span id="l87.119">    * Sets the junk score for the messages to junk/non-junk.  It does not</span>
<a href="#l87.120"></a><span id="l87.120">    *  involve the bayesian classifier because we really don't want it</span>
<a href="#l87.121"></a><span id="l87.121">    *  affecting our unit tests!  (Unless we were testing the bayesian</span>
<a href="#l87.122"></a><span id="l87.122">    *  classifier.  Which I'm conveniently not.  Feel free to add a</span>
<a href="#l87.123"></a><span id="l87.123">    *  &quot;setJunkForRealsies&quot; method if you are.)</span>
<a href="#l87.124"></a><span id="l87.124" class="difflineplus">+   *</span>
<a href="#l87.125"></a><span id="l87.125" class="difflineplus">+   * Generates a JunkStatusChanged nsIMsgFolderListener itemEvent notification.</span>
<a href="#l87.126"></a><span id="l87.126">    */</span>
<a href="#l87.127"></a><span id="l87.127">   setJunk: function(aIsJunk) {</span>
<a href="#l87.128"></a><span id="l87.128">     let junkscore = aIsJunk ? &quot;100&quot; : &quot;0&quot;;</span>
<a href="#l87.129"></a><span id="l87.129">     for each (let msgHdr in this.msgHdrs) {</span>
<a href="#l87.130"></a><span id="l87.130">       msgHdr.setStringProperty(&quot;junkscore&quot;, junkscore);</span>
<a href="#l87.131"></a><span id="l87.131">     };</span>
<a href="#l87.132"></a><span id="l87.132" class="difflineplus">+</span>
<a href="#l87.133"></a><span id="l87.133" class="difflineplus">+    let notificationService =</span>
<a href="#l87.134"></a><span id="l87.134" class="difflineplus">+      Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;]</span>
<a href="#l87.135"></a><span id="l87.135" class="difflineplus">+        .getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l87.136"></a><span id="l87.136" class="difflineplus">+    let atomService = Cc[&quot;@mozilla.org/atom-service;1&quot;].</span>
<a href="#l87.137"></a><span id="l87.137" class="difflineplus">+                        getService(Ci.nsIAtomService);</span>
<a href="#l87.138"></a><span id="l87.138" class="difflineplus">+    let atom = atomService.getAtom(aIsJunk ? &quot;junk&quot; : &quot;notjunk&quot;);</span>
<a href="#l87.139"></a><span id="l87.139" class="difflineplus">+    notificationService.notifyItemEvent(this.xpcomHdrArray,</span>
<a href="#l87.140"></a><span id="l87.140" class="difflineplus">+                                        &quot;JunkStatusChanged&quot;,</span>
<a href="#l87.141"></a><span id="l87.141" class="difflineplus">+                                        atom);</span>
<a href="#l87.142"></a><span id="l87.142">   },</span>
<a href="#l87.143"></a><span id="l87.143"> </span>
<a href="#l87.144"></a><span id="l87.144">   /**</span>
<a href="#l87.145"></a><span id="l87.145">    * Slice the message set using the exact Array.slice semantics (because we</span>
<a href="#l87.146"></a><span id="l87.146">    *  call Array.slice).</span>
<a href="#l87.147"></a><span id="l87.147">    */</span>
<a href="#l87.148"></a><span id="l87.148">   slice: function() {</span>
<a href="#l87.149"></a><span id="l87.149">     let slicedMessages = this.synMessages.slice.apply(this.synMessages,</span>
<a href="#l87.150"></a><span id="l87.150">                                                       arguments);</span>
<a href="#l87.151"></a><span id="l87.151">     let slicedIndices = this.folderIndices.slice.apply(this.folderIndices,</span>
<a href="#l87.152"></a><span id="l87.152">                                                        arguments);</span>
<a href="#l87.153"></a><span id="l87.153" class="difflineminus">-    return new SyntheticMessageSet(slicedMessages, this.msgFolders,</span>
<a href="#l87.154"></a><span id="l87.154" class="difflineminus">-                                   slicedIndices);</span>
<a href="#l87.155"></a><span id="l87.155" class="difflineplus">+    let sliced = new SyntheticMessageSet(slicedMessages, this.msgFolders,</span>
<a href="#l87.156"></a><span id="l87.156" class="difflineplus">+                                         slicedIndices);</span>
<a href="#l87.157"></a><span id="l87.157" class="difflineplus">+    if ((&quot;glodaMessages&quot; in this) &amp;&amp; this.glodaMessages)</span>
<a href="#l87.158"></a><span id="l87.158" class="difflineplus">+      sliced.glodaMessages = this.glodaMessages.slice.apply(this.glodaMessages,</span>
<a href="#l87.159"></a><span id="l87.159" class="difflineplus">+                                                            arguments);</span>
<a href="#l87.160"></a><span id="l87.160" class="difflineplus">+    return sliced;</span>
<a href="#l87.161"></a><span id="l87.161">   }</span>
<a href="#l87.162"></a><span id="l87.162"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l88.1"></a><span id="l88.1" class="difflineminus">--- a/mailnews/test/resources/msgFolderListenerSetup.js</span>
<a href="#l88.2"></a><span id="l88.2" class="difflineplus">+++ b/mailnews/test/resources/msgFolderListenerSetup.js</span>
<a href="#l88.3"></a><span id="l88.3" class="difflineat">@@ -19,16 +19,28 @@</span>
<a href="#l88.4"></a><span id="l88.4">  */</span>
<a href="#l88.5"></a><span id="l88.5"> </span>
<a href="#l88.6"></a><span id="l88.6"> const nsIMsgDBHdr = Ci.nsIMsgDBHdr;</span>
<a href="#l88.7"></a><span id="l88.7"> const nsIArray = Ci.nsIArray;</span>
<a href="#l88.8"></a><span id="l88.8"> const nsIMsgFolder = Ci.nsIMsgFolder;</span>
<a href="#l88.9"></a><span id="l88.9"> </span>
<a href="#l88.10"></a><span id="l88.10"> const gMFNService = Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;]</span>
<a href="#l88.11"></a><span id="l88.11">                       .getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l88.12"></a><span id="l88.12" class="difflineplus">+</span>
<a href="#l88.13"></a><span id="l88.13" class="difflineplus">+const allTestedEvents =</span>
<a href="#l88.14"></a><span id="l88.14" class="difflineplus">+  gMFNService.msgAdded |</span>
<a href="#l88.15"></a><span id="l88.15" class="difflineplus">+  gMFNService.msgsClassified |</span>
<a href="#l88.16"></a><span id="l88.16" class="difflineplus">+  gMFNService.msgsDeleted |</span>
<a href="#l88.17"></a><span id="l88.17" class="difflineplus">+  gMFNService.msgsMoveCopyCompleted |</span>
<a href="#l88.18"></a><span id="l88.18" class="difflineplus">+  gMFNService.folderAdded |</span>
<a href="#l88.19"></a><span id="l88.19" class="difflineplus">+  gMFNService.folderDeleted |</span>
<a href="#l88.20"></a><span id="l88.20" class="difflineplus">+  gMFNService.folderMoveCopyCompleted |</span>
<a href="#l88.21"></a><span id="l88.21" class="difflineplus">+  gMFNService.folderRenamed |</span>
<a href="#l88.22"></a><span id="l88.22" class="difflineplus">+  gMFNService.itemEvent;</span>
<a href="#l88.23"></a><span id="l88.23" class="difflineplus">+</span>
<a href="#l88.24"></a><span id="l88.24"> const gCopyService = Cc[&quot;@mozilla.org/messenger/messagecopyservice;1&quot;]</span>
<a href="#l88.25"></a><span id="l88.25">                       .getService(Ci.nsIMsgCopyService);</span>
<a href="#l88.26"></a><span id="l88.26"> </span>
<a href="#l88.27"></a><span id="l88.27"> // Current test being executed</span>
<a href="#l88.28"></a><span id="l88.28"> var gTest = 1;</span>
<a href="#l88.29"></a><span id="l88.29"> </span>
<a href="#l88.30"></a><span id="l88.30"> // Which events are expected</span>
<a href="#l88.31"></a><span id="l88.31"> var gExpectedEvents;</span>
<a href="#l88.32"></a><span id="l88.32" class="difflineat">@@ -59,32 +71,55 @@ var gMFListener =</span>
<a href="#l88.33"></a><span id="l88.33">     // so use the aMsg we got instead</span>
<a href="#l88.34"></a><span id="l88.34">     gMsgHdrs.push({hdr: aMsg, ID: aMsg.messageId});</span>
<a href="#l88.35"></a><span id="l88.35">     if (gExpectedEvents.length == 0)</span>
<a href="#l88.36"></a><span id="l88.36">     {</span>
<a href="#l88.37"></a><span id="l88.37">       gCurrStatus |= kStatus.notificationsDone;</span>
<a href="#l88.38"></a><span id="l88.38">       if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l88.39"></a><span id="l88.39">         resetStatusAndProceed();</span>
<a href="#l88.40"></a><span id="l88.40">     }</span>
<a href="#l88.41"></a><span id="l88.41" class="difflineplus">+    else if (gExpectedEvents[0][0] == gMFNService.msgsClassified)</span>
<a href="#l88.42"></a><span id="l88.42" class="difflineplus">+    {</span>
<a href="#l88.43"></a><span id="l88.43" class="difflineplus">+      // XXX this is a hack to deal with limitations of the classification logic</span>
<a href="#l88.44"></a><span id="l88.44" class="difflineplus">+      //  and the new list.  We want to issue a call to clear the list once all</span>
<a href="#l88.45"></a><span id="l88.45" class="difflineplus">+      //  the messages have been added, which would be when the next expected</span>
<a href="#l88.46"></a><span id="l88.46" class="difflineplus">+      //  event is msgsClassified.  (The limitation is that if we don't do this,</span>
<a href="#l88.47"></a><span id="l88.47" class="difflineplus">+      //  we can end up getting told about this message again later.)</span>
<a href="#l88.48"></a><span id="l88.48" class="difflineplus">+      aMsg.folder.clearNewMessages();</span>
<a href="#l88.49"></a><span id="l88.49" class="difflineplus">+    }</span>
<a href="#l88.50"></a><span id="l88.50" class="difflineplus">+  },</span>
<a href="#l88.51"></a><span id="l88.51" class="difflineplus">+</span>
<a href="#l88.52"></a><span id="l88.52" class="difflineplus">+  msgsClassified: function(aMsgs, aJunkProcessed, aTraitProcessed)</span>
<a href="#l88.53"></a><span id="l88.53" class="difflineplus">+  {</span>
<a href="#l88.54"></a><span id="l88.54" class="difflineplus">+    dump(&quot;classified id: &quot; + aMsgs.queryElementAt(0, Ci.nsIMsgDBHdr).messageId + &quot;\n&quot;);</span>
<a href="#l88.55"></a><span id="l88.55" class="difflineplus">+    verify([gMFNService.msgsClassified, aMsgs, aJunkProcessed,</span>
<a href="#l88.56"></a><span id="l88.56" class="difflineplus">+              aTraitProcessed]);</span>
<a href="#l88.57"></a><span id="l88.57" class="difflineplus">+    if (gExpectedEvents.length == 0)</span>
<a href="#l88.58"></a><span id="l88.58" class="difflineplus">+    {</span>
<a href="#l88.59"></a><span id="l88.59" class="difflineplus">+      gCurrStatus |= kStatus.notificationsDone;</span>
<a href="#l88.60"></a><span id="l88.60" class="difflineplus">+      if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l88.61"></a><span id="l88.61" class="difflineplus">+        resetStatusAndProceed();</span>
<a href="#l88.62"></a><span id="l88.62" class="difflineplus">+    }</span>
<a href="#l88.63"></a><span id="l88.63">   },</span>
<a href="#l88.64"></a><span id="l88.64"> </span>
<a href="#l88.65"></a><span id="l88.65">   msgsDeleted: function(aMsgs)</span>
<a href="#l88.66"></a><span id="l88.66">   {</span>
<a href="#l88.67"></a><span id="l88.67">     verify([gMFNService.msgsDeleted, aMsgs]);</span>
<a href="#l88.68"></a><span id="l88.68">     if (gExpectedEvents.length == 0)</span>
<a href="#l88.69"></a><span id="l88.69">     {</span>
<a href="#l88.70"></a><span id="l88.70">       gCurrStatus |= kStatus.notificationsDone;</span>
<a href="#l88.71"></a><span id="l88.71">       if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l88.72"></a><span id="l88.72">         resetStatusAndProceed();</span>
<a href="#l88.73"></a><span id="l88.73">     }</span>
<a href="#l88.74"></a><span id="l88.74">   },</span>
<a href="#l88.75"></a><span id="l88.75"> </span>
<a href="#l88.76"></a><span id="l88.76" class="difflineminus">-  msgsMoveCopyCompleted: function(aMove, aSrcMsgs, aDestFolder)</span>
<a href="#l88.77"></a><span id="l88.77" class="difflineplus">+  msgsMoveCopyCompleted: function(aMove, aSrcMsgs, aDestFolder, aDestMsgs)</span>
<a href="#l88.78"></a><span id="l88.78">   {</span>
<a href="#l88.79"></a><span id="l88.79" class="difflineminus">-    verify([gMFNService.msgsMoveCopyCompleted, aMove, aSrcMsgs, aDestFolder]);</span>
<a href="#l88.80"></a><span id="l88.80" class="difflineplus">+    verify([gMFNService.msgsMoveCopyCompleted, aMove, aSrcMsgs, aDestFolder,</span>
<a href="#l88.81"></a><span id="l88.81" class="difflineplus">+            aDestMsgs]);</span>
<a href="#l88.82"></a><span id="l88.82">     if (gExpectedEvents.length == 0)</span>
<a href="#l88.83"></a><span id="l88.83">     {</span>
<a href="#l88.84"></a><span id="l88.84">       gCurrStatus |= kStatus.notificationsDone;</span>
<a href="#l88.85"></a><span id="l88.85">       if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l88.86"></a><span id="l88.86">         resetStatusAndProceed();</span>
<a href="#l88.87"></a><span id="l88.87">     }</span>
<a href="#l88.88"></a><span id="l88.88">   },</span>
<a href="#l88.89"></a><span id="l88.89"> </span>
<a href="#l88.90"></a><span id="l88.90" class="difflineat">@@ -125,16 +160,29 @@ var gMFListener =</span>
<a href="#l88.91"></a><span id="l88.91">   {</span>
<a href="#l88.92"></a><span id="l88.92">     verify([gMFNService.folderRenamed, aOrigFolder, aNewFolder]);</span>
<a href="#l88.93"></a><span id="l88.93">     if (gExpectedEvents.length == 0)</span>
<a href="#l88.94"></a><span id="l88.94">     {</span>
<a href="#l88.95"></a><span id="l88.95">       gCurrStatus |= kStatus.notificationsDone;</span>
<a href="#l88.96"></a><span id="l88.96">       if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l88.97"></a><span id="l88.97">         resetStatusAndProceed();</span>
<a href="#l88.98"></a><span id="l88.98">     }</span>
<a href="#l88.99"></a><span id="l88.99" class="difflineplus">+  },</span>
<a href="#l88.100"></a><span id="l88.100" class="difflineplus">+</span>
<a href="#l88.101"></a><span id="l88.101" class="difflineplus">+  itemEvent: function(aFolder, aEvent, aBetterBeNull)</span>
<a href="#l88.102"></a><span id="l88.102" class="difflineplus">+  {</span>
<a href="#l88.103"></a><span id="l88.103" class="difflineplus">+    // we currently require the third argument to be null...</span>
<a href="#l88.104"></a><span id="l88.104" class="difflineplus">+    do_check_eq(aBetterBeNull, null);</span>
<a href="#l88.105"></a><span id="l88.105" class="difflineplus">+    verify([gMFNService.itemEvent, aFolder, aEvent]);</span>
<a href="#l88.106"></a><span id="l88.106" class="difflineplus">+    if (gExpectedEvents.length == 0)</span>
<a href="#l88.107"></a><span id="l88.107" class="difflineplus">+    {</span>
<a href="#l88.108"></a><span id="l88.108" class="difflineplus">+      gCurrStatus |= kStatus.notificationsDone;</span>
<a href="#l88.109"></a><span id="l88.109" class="difflineplus">+      if (gCurrStatus == kStatus.everythingDone)</span>
<a href="#l88.110"></a><span id="l88.110" class="difflineplus">+        resetStatusAndProceed();</span>
<a href="#l88.111"></a><span id="l88.111" class="difflineplus">+    }</span>
<a href="#l88.112"></a><span id="l88.112">   }</span>
<a href="#l88.113"></a><span id="l88.113"> };</span>
<a href="#l88.114"></a><span id="l88.114"> </span>
<a href="#l88.115"></a><span id="l88.115"> // Copy listener, for proceeding after each operation.</span>
<a href="#l88.116"></a><span id="l88.116"> var copyListener =</span>
<a href="#l88.117"></a><span id="l88.117"> {</span>
<a href="#l88.118"></a><span id="l88.118">   // For CopyFileMessage: this should be the folder the message is being stored to</span>
<a href="#l88.119"></a><span id="l88.119">   mFolderStoredIn: null,</span>
<a href="#l88.120"></a><span id="l88.120" class="difflineat">@@ -219,42 +267,93 @@ function verify(event)</span>
<a href="#l88.121"></a><span id="l88.121">   // Check: make sure we actually have an item to process</span>
<a href="#l88.122"></a><span id="l88.122">   do_check_true(gExpectedEvents.length &gt;= 1);</span>
<a href="#l88.123"></a><span id="l88.123">   var expected = gExpectedEvents.shift();</span>
<a href="#l88.124"></a><span id="l88.124"> </span>
<a href="#l88.125"></a><span id="l88.125">   // Check: events match.</span>
<a href="#l88.126"></a><span id="l88.126">   var eventType = expected[0];</span>
<a href="#l88.127"></a><span id="l88.127">   do_check_eq(event[0], eventType);</span>
<a href="#l88.128"></a><span id="l88.128"> </span>
<a href="#l88.129"></a><span id="l88.129" class="difflineplus">+  dump(&quot;..... Verifying event type &quot; + eventType + &quot;\n&quot;);</span>
<a href="#l88.130"></a><span id="l88.130" class="difflineplus">+</span>
<a href="#l88.131"></a><span id="l88.131">   switch (eventType)</span>
<a href="#l88.132"></a><span id="l88.132">   {</span>
<a href="#l88.133"></a><span id="l88.133">   case gMFNService.msgAdded:</span>
<a href="#l88.134"></a><span id="l88.134">     // So for IMAP right now, we aren't able to get the actual nsIMsgDBHdr.</span>
<a href="#l88.135"></a><span id="l88.135">     // Instead, we'll match up message ids as a (poor?) substitute.</span>
<a href="#l88.136"></a><span id="l88.136">     if (expected[1].expectedMessageId)</span>
<a href="#l88.137"></a><span id="l88.137">     {</span>
<a href="#l88.138"></a><span id="l88.138">       do_check_eq(event[1].messageId, expected[1].expectedMessageId);</span>
<a href="#l88.139"></a><span id="l88.139">       break;</span>
<a href="#l88.140"></a><span id="l88.140">     }</span>
<a href="#l88.141"></a><span id="l88.141">     // If we do have a header, fall through to the case below</span>
<a href="#l88.142"></a><span id="l88.142">   case gMFNService.msgsDeleted:</span>
<a href="#l88.143"></a><span id="l88.143">   case gMFNService.folderDeleted:</span>
<a href="#l88.144"></a><span id="l88.144">     // Check: headers match/folder matches.</span>
<a href="#l88.145"></a><span id="l88.145">     hasExactlyElements(expected[1], event[1]);</span>
<a href="#l88.146"></a><span id="l88.146">     break;</span>
<a href="#l88.147"></a><span id="l88.147" class="difflineplus">+  case gMFNService.msgsClassified:</span>
<a href="#l88.148"></a><span id="l88.148" class="difflineplus">+    // In the IMAP case expected[1] is a list of mesage-id strings whereas in</span>
<a href="#l88.149"></a><span id="l88.149" class="difflineplus">+    // the local case (where we are copying from files), we actually have</span>
<a href="#l88.150"></a><span id="l88.150" class="difflineplus">+    // the headers.</span>
<a href="#l88.151"></a><span id="l88.151" class="difflineplus">+    if (typeof(expected[1][0]) == &quot;string&quot;) { // IMAP; message id strings</span>
<a href="#l88.152"></a><span id="l88.152" class="difflineplus">+      // The IMAP case has additional complexity in that the 'new message'</span>
<a href="#l88.153"></a><span id="l88.153" class="difflineplus">+      // list is not tailored to our needs and so may over-report about</span>
<a href="#l88.154"></a><span id="l88.154" class="difflineplus">+      // new messagse.  So to deal with this we make sure the msgsClassified</span>
<a href="#l88.155"></a><span id="l88.155" class="difflineplus">+      // event is telling us about at least the N expected events and that</span>
<a href="#l88.156"></a><span id="l88.156" class="difflineplus">+      // the last N of these events match</span>
<a href="#l88.157"></a><span id="l88.157" class="difflineplus">+      if (event[1].length &lt; expected[1].length)</span>
<a href="#l88.158"></a><span id="l88.158" class="difflineplus">+        do_throw(&quot;Not enough reported classified messages.&quot;);</span>
<a href="#l88.159"></a><span id="l88.159" class="difflineplus">+      let ignoreCount = event[1].length - expected[1].length;</span>
<a href="#l88.160"></a><span id="l88.160" class="difflineplus">+      for (let i = 0; i &lt; expected[1].length; i++) {</span>
<a href="#l88.161"></a><span id="l88.161" class="difflineplus">+        let eventHeader = event[1].queryElementAt(i + ignoreCount,</span>
<a href="#l88.162"></a><span id="l88.162" class="difflineplus">+                                                  nsIMsgDBHdr);</span>
<a href="#l88.163"></a><span id="l88.163" class="difflineplus">+        do_check_eq(expected[1][i], eventHeader.messageId);</span>
<a href="#l88.164"></a><span id="l88.164" class="difflineplus">+      }</span>
<a href="#l88.165"></a><span id="l88.165" class="difflineplus">+    }</span>
<a href="#l88.166"></a><span id="l88.166" class="difflineplus">+    else { // actual headers</span>
<a href="#l88.167"></a><span id="l88.167" class="difflineplus">+      hasExactlyElements(expected[1], event[1]);</span>
<a href="#l88.168"></a><span id="l88.168" class="difflineplus">+    }</span>
<a href="#l88.169"></a><span id="l88.169" class="difflineplus">+    // aJunkProcessed: was the message processed for junk?</span>
<a href="#l88.170"></a><span id="l88.170" class="difflineplus">+    do_check_eq(expected[2], event[2]);</span>
<a href="#l88.171"></a><span id="l88.171" class="difflineplus">+    // aTraitProcessed: was the message processed for traits?</span>
<a href="#l88.172"></a><span id="l88.172" class="difflineplus">+    do_check_eq(expected[3], event[3]);</span>
<a href="#l88.173"></a><span id="l88.173" class="difflineplus">+    break;</span>
<a href="#l88.174"></a><span id="l88.174">   case gMFNService.msgsMoveCopyCompleted:</span>
<a href="#l88.175"></a><span id="l88.175">   case gMFNService.folderMoveCopyCompleted:</span>
<a href="#l88.176"></a><span id="l88.176">     // Check: Move or copy as expected.</span>
<a href="#l88.177"></a><span id="l88.177">     do_check_eq(expected[1], event[1]);</span>
<a href="#l88.178"></a><span id="l88.178"> </span>
<a href="#l88.179"></a><span id="l88.179">     // Check: headers match/folder matches.</span>
<a href="#l88.180"></a><span id="l88.180">     hasExactlyElements(expected[2], event[2]);</span>
<a href="#l88.181"></a><span id="l88.181"> </span>
<a href="#l88.182"></a><span id="l88.182">     // Check: destination folder matches.</span>
<a href="#l88.183"></a><span id="l88.183">     do_check_eq(expected[3], event[3]);</span>
<a href="#l88.184"></a><span id="l88.184" class="difflineplus">+</span>
<a href="#l88.185"></a><span id="l88.185" class="difflineplus">+    if (eventType == gMFNService.folderMoveCopyCompleted)</span>
<a href="#l88.186"></a><span id="l88.186" class="difflineplus">+      break;</span>
<a href="#l88.187"></a><span id="l88.187" class="difflineplus">+</span>
<a href="#l88.188"></a><span id="l88.188" class="difflineplus">+    // Check: destination headers.  We only expect these in the local folder</span>
<a href="#l88.189"></a><span id="l88.189" class="difflineplus">+    //  case, and in that case, we will not have heard about the headers ahead</span>
<a href="#l88.190"></a><span id="l88.190" class="difflineplus">+    //  of time, so the best we can do is make sure they match up.  To this end,</span>
<a href="#l88.191"></a><span id="l88.191" class="difflineplus">+    //  if null is expected then we check for null.  If true is expected, then</span>
<a href="#l88.192"></a><span id="l88.192" class="difflineplus">+    //  we check that the message-id header values match up.</span>
<a href="#l88.193"></a><span id="l88.193" class="difflineplus">+    if (expected[4] == null)</span>
<a href="#l88.194"></a><span id="l88.194" class="difflineplus">+    {</span>
<a href="#l88.195"></a><span id="l88.195" class="difflineplus">+      do_check_eq(null, event[4]);</span>
<a href="#l88.196"></a><span id="l88.196" class="difflineplus">+    }</span>
<a href="#l88.197"></a><span id="l88.197" class="difflineplus">+    else</span>
<a href="#l88.198"></a><span id="l88.198" class="difflineplus">+    {</span>
<a href="#l88.199"></a><span id="l88.199" class="difflineplus">+      for (let iMsg = 0; iMsg &lt; event[2].length; iMsg++)</span>
<a href="#l88.200"></a><span id="l88.200" class="difflineplus">+      {</span>
<a href="#l88.201"></a><span id="l88.201" class="difflineplus">+        let srcHdr = event[2].queryElementAt(iMsg, nsIMsgDBHdr);</span>
<a href="#l88.202"></a><span id="l88.202" class="difflineplus">+        let destHdr = event[4].queryElementAt(iMsg, nsIMsgDBHdr);</span>
<a href="#l88.203"></a><span id="l88.203" class="difflineplus">+        do_check_eq(srcHdr.messageId, destHdr.messageId);</span>
<a href="#l88.204"></a><span id="l88.204" class="difflineplus">+      }</span>
<a href="#l88.205"></a><span id="l88.205" class="difflineplus">+    }</span>
<a href="#l88.206"></a><span id="l88.206">     break;</span>
<a href="#l88.207"></a><span id="l88.207">   case gMFNService.folderAdded:</span>
<a href="#l88.208"></a><span id="l88.208">     // Check: parent folder matches</span>
<a href="#l88.209"></a><span id="l88.209">     do_check_eq(event[1].parent, expected[1]);</span>
<a href="#l88.210"></a><span id="l88.210"> </span>
<a href="#l88.211"></a><span id="l88.211">     // Check: folder name matches</span>
<a href="#l88.212"></a><span id="l88.212">     do_check_eq(event[1].prettyName, expected[2]);</span>
<a href="#l88.213"></a><span id="l88.213">     do_check_eq(event[1].name, expected[2]);</span>
<a href="#l88.214"></a><span id="l88.214" class="difflineat">@@ -265,10 +364,16 @@ function verify(event)</span>
<a href="#l88.215"></a><span id="l88.215">     break;</span>
<a href="#l88.216"></a><span id="l88.216">   case gMFNService.folderRenamed:</span>
<a href="#l88.217"></a><span id="l88.217">     // Check: source folder matches</span>
<a href="#l88.218"></a><span id="l88.218">     hasExactlyElements(expected[1], event[1]);</span>
<a href="#l88.219"></a><span id="l88.219"> </span>
<a href="#l88.220"></a><span id="l88.220">     // Check: destination folder name matches</span>
<a href="#l88.221"></a><span id="l88.221">     do_check_eq(expected[2], event[2].prettiestName);</span>
<a href="#l88.222"></a><span id="l88.222">     break;</span>
<a href="#l88.223"></a><span id="l88.223" class="difflineplus">+  case gMFNService.itemEvent:</span>
<a href="#l88.224"></a><span id="l88.224" class="difflineplus">+    // the event string should match</span>
<a href="#l88.225"></a><span id="l88.225" class="difflineplus">+    do_check_eq(expected[2], event[2]);</span>
<a href="#l88.226"></a><span id="l88.226" class="difflineplus">+    // and so should the folder we are talking about</span>
<a href="#l88.227"></a><span id="l88.227" class="difflineplus">+    do_check_eq(expected[1], event[1]);</span>
<a href="#l88.228"></a><span id="l88.228" class="difflineplus">+    break;</span>
<a href="#l88.229"></a><span id="l88.229">   }</span>
<a href="#l88.230"></a><span id="l88.230"> }</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

