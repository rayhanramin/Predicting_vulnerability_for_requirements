<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 26544:96a805927f55f7b51227b75bb34f8ad34905c0b0</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 96a805927f55f7b51227b75bb34f8ad34905c0b0" />
<meta property="og:url" content="/comm-central/rev/96a805927f55f7b51227b75bb34f8ad34905c0b0" />
<meta property="og:description" content="Bug 1546364 - replace tabs with spaces in ldap/ C files and fix comments badly formatted by reformatting. rs=white-space-only" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 96a805927f55f7b51227b75bb34f8ad34905c0b0 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/96a805927f55f7b51227b75bb34f8ad34905c0b0">shortlog</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/96a805927f55f7b51227b75bb34f8ad34905c0b0">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0">files</a> |
changeset |
<a href="/comm-central/raw-rev/96a805927f55f7b51227b75bb34f8ad34905c0b0">raw</a>  | <a href="/comm-central/archive/96a805927f55f7b51227b75bb34f8ad34905c0b0.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">Bug 1546364</a> - replace tabs with spaces in ldap/ C files and fix comments badly formatted by reformatting. rs=white-space-only
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 09 May 2019 00:04:18 +0200</td></tr>

<tr>
 <td>changeset 26544</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/96a805927f55f7b51227b75bb34f8ad34905c0b0">96a805927f55f7b51227b75bb34f8ad34905c0b0</a></td>
</tr>



<tr>
<td>parent 26543</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/83bbcac4d9a6d8b877cc97821c1f3410badf6417">83bbcac4d9a6d8b877cc97821c1f3410badf6417</a>
</td>
</tr>

<tr>
<td>child 26545</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/dc3b0d8e71393fd75e8788646f629ee5e9324ca5">dc3b0d8e71393fd75e8788646f629ee5e9324ca5</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=96a805927f55f7b51227b75bb34f8ad34905c0b0">15889</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Wed, 08 May 2019 22:55:04 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@8d4257424669 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=8d425742466967aa0e90945d2f9d386dabb53fcc">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=8d425742466967aa0e90945d2f9d386dabb53fcc&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=8d425742466967aa0e90945d2f9d386dabb53fcc&newProject=comm-central&newRevision=83bbcac4d9a6d8b877cc97821c1f3410badf6417&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=8d425742466967aa0e90945d2f9d386dabb53fcc&newProject=comm-central&newRevision=83bbcac4d9a6d8b877cc97821c1f3410badf6417&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=8d425742466967aa0e90945d2f9d386dabb53fcc&newProject=comm-central&newRevision=83bbcac4d9a6d8b877cc97821c1f3410badf6417&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28white-space-only%29&revcount=50">white-space-only</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">1546364</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">Bug 1546364</a> - replace tabs with spaces in ldap/ C files and fix comments badly formatted by reformatting. rs=white-space-only
# ignore-this-changeset</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/decode.c">ldap/c-sdk/libraries/liblber/decode.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/decode.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/decode.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/decode.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/decode.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/decode.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/io.c">ldap/c-sdk/libraries/liblber/io.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/io.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/io.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/io.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/io.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/liblber/io.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/abandon.c">ldap/c-sdk/libraries/libldap/abandon.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/abandon.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/abandon.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/abandon.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/abandon.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/abandon.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/add.c">ldap/c-sdk/libraries/libldap/add.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/add.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/add.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/add.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/add.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/add.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/bind.c">ldap/c-sdk/libraries/libldap/bind.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/bind.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/bind.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/bind.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/bind.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/bind.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charray.c">ldap/c-sdk/libraries/libldap/charray.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charray.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charray.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charray.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charray.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charray.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charset.c">ldap/c-sdk/libraries/libldap/charset.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charset.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charset.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charset.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charset.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/charset.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/cldap.c">ldap/c-sdk/libraries/libldap/cldap.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/cldap.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/cldap.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/cldap.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/cldap.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/cldap.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/compare.c">ldap/c-sdk/libraries/libldap/compare.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/compare.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/compare.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/compare.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/compare.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/compare.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/control.c">ldap/c-sdk/libraries/libldap/control.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/control.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/control.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/control.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/control.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/control.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/delete.c">ldap/c-sdk/libraries/libldap/delete.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/delete.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/delete.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/delete.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/delete.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/delete.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/error.c">ldap/c-sdk/libraries/libldap/error.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/error.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/error.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/error.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/error.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/error.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/extendop.c">ldap/c-sdk/libraries/libldap/extendop.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/extendop.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/extendop.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/extendop.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/extendop.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/extendop.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdn.c">ldap/c-sdk/libraries/libldap/getdn.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdn.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdn.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdn.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdn.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdn.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdxbyname.c">ldap/c-sdk/libraries/libldap/getdxbyname.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdxbyname.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdxbyname.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdxbyname.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdxbyname.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/getdxbyname.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/memcache.c">ldap/c-sdk/libraries/libldap/memcache.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/memcache.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/memcache.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/memcache.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/memcache.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/memcache.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/modify.c">ldap/c-sdk/libraries/libldap/modify.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/modify.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/modify.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/modify.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/modify.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/modify.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/mozock.c">ldap/c-sdk/libraries/libldap/mozock.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/mozock.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/mozock.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/mozock.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/mozock.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/mozock.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/open.c">ldap/c-sdk/libraries/libldap/open.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/open.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/open.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/open.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/open.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/open.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/os-ip.c">ldap/c-sdk/libraries/libldap/os-ip.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/os-ip.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/os-ip.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/os-ip.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/os-ip.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/os-ip.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">ldap/c-sdk/libraries/libldap/proxyauthctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/proxyauthctrl.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/psearch.c">ldap/c-sdk/libraries/libldap/psearch.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/psearch.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/psearch.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/psearch.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/psearch.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/psearch.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwmodext.c">ldap/c-sdk/libraries/libldap/pwmodext.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwmodext.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwmodext.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwmodext.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwmodext.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwmodext.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwpctrl.c">ldap/c-sdk/libraries/libldap/pwpctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwpctrl.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwpctrl.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwpctrl.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwpctrl.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/pwpctrl.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/referral.c">ldap/c-sdk/libraries/libldap/referral.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/referral.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/referral.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/referral.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/referral.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/referral.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/regex.c">ldap/c-sdk/libraries/libldap/regex.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/regex.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/regex.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/regex.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/regex.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/regex.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/rename.c">ldap/c-sdk/libraries/libldap/rename.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/rename.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/rename.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/rename.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/rename.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/rename.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/request.c">ldap/c-sdk/libraries/libldap/request.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/request.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/request.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/request.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/request.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/request.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/result.c">ldap/c-sdk/libraries/libldap/result.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/result.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/result.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/result.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/result.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/result.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/saslbind.c">ldap/c-sdk/libraries/libldap/saslbind.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/saslbind.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/saslbind.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/saslbind.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/saslbind.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/saslbind.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/sbind.c">ldap/c-sdk/libraries/libldap/sbind.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/sbind.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/sbind.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/sbind.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/sbind.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/sbind.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/search.c">ldap/c-sdk/libraries/libldap/search.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/search.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/search.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/search.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/search.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/search.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/test.c">ldap/c-sdk/libraries/libldap/test.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/test.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/test.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/test.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/test.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/test.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/tmplout.c">ldap/c-sdk/libraries/libldap/tmplout.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/tmplout.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/tmplout.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/tmplout.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/tmplout.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/tmplout.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/ufn.c">ldap/c-sdk/libraries/libldap/ufn.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/ufn.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/ufn.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/ufn.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/ufn.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/ufn.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/url.c">ldap/c-sdk/libraries/libldap/url.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/url.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/url.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/url.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/url.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/url.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/userstatusctrl.c">ldap/c-sdk/libraries/libldap/userstatusctrl.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/userstatusctrl.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/userstatusctrl.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/userstatusctrl.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/userstatusctrl.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldap/userstatusctrl.c">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldif/line64.c">ldap/c-sdk/libraries/libldif/line64.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldif/line64.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldif/line64.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldif/line64.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldif/line64.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libldif/line64.c">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">ldap/c-sdk/libraries/libprldap/ldappr-threads.c</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">file</a> |
<a href="/comm-central/annotate/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">annotate</a> |
<a href="/comm-central/diff/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">diff</a> |
<a href="/comm-central/comparison/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">comparison</a> |
<a href="/comm-central/log/96a805927f55f7b51227b75bb34f8ad34905c0b0/ldap/c-sdk/libraries/libprldap/ldappr-threads.c">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/decode.c</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/decode.c</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -97,18 +97,18 @@ ber_tag_t LDAP_CALL ber_skip_tag(BerElem</span>
<a href="#l1.4"></a><span id="l1.4">   ber_len_t netlen;</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6">   /*</span>
<a href="#l1.7"></a><span id="l1.7">    * Any ber element looks like this: tag length contents.</span>
<a href="#l1.8"></a><span id="l1.8">    * Assuming everything's ok, we return the tag byte (we</span>
<a href="#l1.9"></a><span id="l1.9">    * can assume a single byte), and return the length in len.</span>
<a href="#l1.10"></a><span id="l1.10">    *</span>
<a href="#l1.11"></a><span id="l1.11">    * Assumptions:</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-   *	1) definite lengths</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineminus">-   *	2) primitive encodings used whenever possible</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+   * 1) definite lengths</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+   * 2) primitive encodings used whenever possible</span>
<a href="#l1.16"></a><span id="l1.16">    */</span>
<a href="#l1.17"></a><span id="l1.17"> </span>
<a href="#l1.18"></a><span id="l1.18">   /*</span>
<a href="#l1.19"></a><span id="l1.19">    * First, we read the tag.</span>
<a href="#l1.20"></a><span id="l1.20">    */</span>
<a href="#l1.21"></a><span id="l1.21"> </span>
<a href="#l1.22"></a><span id="l1.22">   if ((tag = ber_get_tag(ber)) == LBER_DEFAULT) return (LBER_DEFAULT);</span>
<a href="#l1.23"></a><span id="l1.23"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/ldap/c-sdk/libraries/liblber/io.c</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/liblber/io.c</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -1279,19 +1279,19 @@ ber_uint_t LDAP_CALL ber_get_next_buffer</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5">   /*</span>
<a href="#l2.6"></a><span id="l2.6">    * Any ber element looks like this: tag length contents.</span>
<a href="#l2.7"></a><span id="l2.7">    * Assuming everything's ok, we return the tag byte (we</span>
<a href="#l2.8"></a><span id="l2.8">    * can assume a single byte), return the length in len,</span>
<a href="#l2.9"></a><span id="l2.9">    * and the rest of the undecoded element in buf.</span>
<a href="#l2.10"></a><span id="l2.10">    *</span>
<a href="#l2.11"></a><span id="l2.11">    * Assumptions:</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-   *	1) small tags (less than 128)</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-   *	2) definite lengths</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineminus">-   *	3) primitive encodings used whenever possible</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+   * 1) small tags (less than 128)</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+   * 2) definite lengths</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+   * 3) primitive encodings used whenever possible</span>
<a href="#l2.18"></a><span id="l2.18">    */</span>
<a href="#l2.19"></a><span id="l2.19"> </span>
<a href="#l2.20"></a><span id="l2.20">   /*</span>
<a href="#l2.21"></a><span id="l2.21">    * first time through - malloc the buffer, set up ptrs, and</span>
<a href="#l2.22"></a><span id="l2.22">    * read the tag and the length and as much of the rest as we can</span>
<a href="#l2.23"></a><span id="l2.23">    */</span>
<a href="#l2.24"></a><span id="l2.24"> </span>
<a href="#l2.25"></a><span id="l2.25">   sb.p = buffer;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/abandon.c</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/abandon.c</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -54,23 +54,23 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l3.4"></a><span id="l3.4"> static int do_abandon(LDAP *ld, int origid, int msgid,</span>
<a href="#l3.5"></a><span id="l3.5">                       LDAPControl **serverctrls, LDAPControl **clientctrls);</span>
<a href="#l3.6"></a><span id="l3.6"> static int nsldapi_send_abandon_message(LDAP *ld, LDAPConn *lc, BerElement *ber,</span>
<a href="#l3.7"></a><span id="l3.7">                                         int abandon_msgid);</span>
<a href="#l3.8"></a><span id="l3.8"> </span>
<a href="#l3.9"></a><span id="l3.9"> /*</span>
<a href="#l3.10"></a><span id="l3.10">  * ldap_abandon - perform an ldap abandon operation. Parameters:</span>
<a href="#l3.11"></a><span id="l3.11">  *</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">- *	ld		LDAP descriptor</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">- *	msgid		The message id of the operation to abandon</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+ * ld     LDAP descriptor</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+ * msgid  The message id of the operation to abandon</span>
<a href="#l3.16"></a><span id="l3.16">  *</span>
<a href="#l3.17"></a><span id="l3.17">  * ldap_abandon returns 0 if everything went ok, -1 otherwise.</span>
<a href="#l3.18"></a><span id="l3.18">  *</span>
<a href="#l3.19"></a><span id="l3.19">  * Example:</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineminus">- *	ldap_abandon( ld, msgid );</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+ * ldap_abandon(ld, msgid);</span>
<a href="#l3.22"></a><span id="l3.22">  */</span>
<a href="#l3.23"></a><span id="l3.23"> int LDAP_CALL ldap_abandon(LDAP *ld, int msgid) {</span>
<a href="#l3.24"></a><span id="l3.24">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_abandon %d\n&quot;, msgid, 0, 0);</span>
<a href="#l3.25"></a><span id="l3.25">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;4e65747363617065\n&quot;, msgid, 0, 0);</span>
<a href="#l3.26"></a><span id="l3.26">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;466f726576657221\n&quot;, msgid, 0, 0);</span>
<a href="#l3.27"></a><span id="l3.27"> </span>
<a href="#l3.28"></a><span id="l3.28">   if (ldap_abandon_ext(ld, msgid, NULL, NULL) == LDAP_SUCCESS) {</span>
<a href="#l3.29"></a><span id="l3.29">     return (0);</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineat">@@ -117,17 +117,17 @@ int LDAP_CALL ldap_abandon_ext(LDAP *ld,</span>
<a href="#l3.31"></a><span id="l3.31"> static int do_abandon(LDAP *ld, int origid, int msgid,</span>
<a href="#l3.32"></a><span id="l3.32">                       LDAPControl **serverctrls, LDAPControl **clientctrls) {</span>
<a href="#l3.33"></a><span id="l3.33">   BerElement *ber;</span>
<a href="#l3.34"></a><span id="l3.34">   int i, bererr, lderr, sendabandon;</span>
<a href="#l3.35"></a><span id="l3.35">   LDAPRequest *lr = NULL;</span>
<a href="#l3.36"></a><span id="l3.36"> </span>
<a href="#l3.37"></a><span id="l3.37">   /*</span>
<a href="#l3.38"></a><span id="l3.38">    * An abandon request looks like this:</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineminus">-   *	AbandonRequest ::= MessageID</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+   * AbandonRequest ::= MessageID</span>
<a href="#l3.41"></a><span id="l3.41">    */</span>
<a href="#l3.42"></a><span id="l3.42">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;do_abandon origid %d, msgid %d\n&quot;, origid, msgid,</span>
<a href="#l3.43"></a><span id="l3.43">             0);</span>
<a href="#l3.44"></a><span id="l3.44"> </span>
<a href="#l3.45"></a><span id="l3.45">   /* optimistic */</span>
<a href="#l3.46"></a><span id="l3.46">   lderr = LDAP_SUCCESS;</span>
<a href="#l3.47"></a><span id="l3.47"> </span>
<a href="#l3.48"></a><span id="l3.48">   /*</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/add.c</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/add.c</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -48,31 +48,31 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l4.4"></a><span id="l4.4"> #  endif</span>
<a href="#l4.5"></a><span id="l4.5"> #endif</span>
<a href="#l4.6"></a><span id="l4.6"> </span>
<a href="#l4.7"></a><span id="l4.7"> #include &quot;ldap-int.h&quot;</span>
<a href="#l4.8"></a><span id="l4.8"> </span>
<a href="#l4.9"></a><span id="l4.9"> /*</span>
<a href="#l4.10"></a><span id="l4.10">  * ldap_add - initiate an ldap add operation.  Parameters:</span>
<a href="#l4.11"></a><span id="l4.11">  *</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">- *	ld		LDAP descriptor</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineminus">- *	dn		DN of the entry to add</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineminus">- *	mods		List of attributes for the entry.  This is a null-</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineminus">- *			terminated array of pointers to LDAPMod structures.</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineminus">- *			only the type and values in the structures need be</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">- *			filled in.</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+ *  ld    LDAP descriptor</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+ *  dn    DN of the entry to add</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+ *  mods  List of attributes for the entry.  This is a null-</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+ *        terminated array of pointers to LDAPMod structures.</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+ *        only the type and values in the structures need be</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+ *        filled in.</span>
<a href="#l4.24"></a><span id="l4.24">  *</span>
<a href="#l4.25"></a><span id="l4.25">  * Example:</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineminus">- *	LDAPMod	*attrs[] = {</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineminus">- *			{ 0, &quot;cn&quot;, { &quot;babs jensen&quot;, &quot;babs&quot;, 0 } },</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineminus">- *			{ 0, &quot;sn&quot;, { &quot;jensen&quot;, 0 } },</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineminus">- *			{ 0, &quot;objectClass&quot;, { &quot;person&quot;, 0 } },</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineminus">- *			0</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">- *		}</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineminus">- *	msgid = ldap_add( ld, dn, attrs );</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+ * LDAPMod  *attrs[] = {</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+ *     { 0, &quot;cn&quot;, { &quot;babs jensen&quot;, &quot;babs&quot;, 0 } },</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+ *     { 0, &quot;sn&quot;, { &quot;jensen&quot;, 0 } },</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+ *     { 0, &quot;objectClass&quot;, { &quot;person&quot;, 0 } },</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+ *     0</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+ *   }</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+ * msgid = ldap_add(ld, dn, attrs);</span>
<a href="#l4.40"></a><span id="l4.40">  */</span>
<a href="#l4.41"></a><span id="l4.41"> int LDAP_CALL ldap_add(LDAP *ld, const char *dn, LDAPMod **attrs) {</span>
<a href="#l4.42"></a><span id="l4.42">   int msgid;</span>
<a href="#l4.43"></a><span id="l4.43"> </span>
<a href="#l4.44"></a><span id="l4.44">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_add\n&quot;, 0, 0, 0);</span>
<a href="#l4.45"></a><span id="l4.45"> </span>
<a href="#l4.46"></a><span id="l4.46">   if (ldap_add_ext(ld, dn, attrs, NULL, NULL, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l4.47"></a><span id="l4.47">     return (msgid);</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineat">@@ -88,23 +88,23 @@ int LDAP_CALL ldap_add(LDAP *ld, const c</span>
<a href="#l4.49"></a><span id="l4.49"> int LDAP_CALL ldap_add_ext(LDAP *ld, const char *dn, LDAPMod **attrs,</span>
<a href="#l4.50"></a><span id="l4.50">                            LDAPControl **serverctrls, LDAPControl **clientctrls,</span>
<a href="#l4.51"></a><span id="l4.51">                            int *msgidp) {</span>
<a href="#l4.52"></a><span id="l4.52">   BerElement *ber;</span>
<a href="#l4.53"></a><span id="l4.53">   int i, rc, lderr;</span>
<a href="#l4.54"></a><span id="l4.54"> </span>
<a href="#l4.55"></a><span id="l4.55">   /*</span>
<a href="#l4.56"></a><span id="l4.56">    * An add request looks like this:</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineminus">-   *	AddRequest ::= SEQUENCE {</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineminus">-   *		entry	DistinguishedName,</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineminus">-   *		attrs	SEQUENCE OF SEQUENCE {</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineminus">-   *			type	AttributeType,</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineminus">-   *			values	SET OF AttributeValue</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineminus">-   *		}</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineminus">-   *	}</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+   * AddRequest ::= SEQUENCE {</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineplus">+   *   entry DistinguishedName,</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+   *   attrs SEQUENCE OF SEQUENCE {</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+   *     type AttributeType,</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+   *     values SET OF AttributeValue</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+   *   }</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+   * }</span>
<a href="#l4.71"></a><span id="l4.71">    */</span>
<a href="#l4.72"></a><span id="l4.72"> </span>
<a href="#l4.73"></a><span id="l4.73">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_add_ext\n&quot;, 0, 0, 0);</span>
<a href="#l4.74"></a><span id="l4.74"> </span>
<a href="#l4.75"></a><span id="l4.75">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l4.76"></a><span id="l4.76">     return (LDAP_PARAM_ERROR);</span>
<a href="#l4.77"></a><span id="l4.77">   }</span>
<a href="#l4.78"></a><span id="l4.78"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/bind.c</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/bind.c</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -50,31 +50,31 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l5.4"></a><span id="l5.4">  * ldap_bind - bind to the ldap server. The dn and password</span>
<a href="#l5.5"></a><span id="l5.5">  * of the entry to which to bind are supplied, along with the authentication</span>
<a href="#l5.6"></a><span id="l5.6">  * method to use.  The msgid of the bind request is returned on success,</span>
<a href="#l5.7"></a><span id="l5.7">  * -1 if there's trouble.  Note, the kerberos support assumes the user already</span>
<a href="#l5.8"></a><span id="l5.8">  * has a valid tgt for now.  ldap_result() should be called to find out the</span>
<a href="#l5.9"></a><span id="l5.9">  * outcome of the bind request.</span>
<a href="#l5.10"></a><span id="l5.10">  *</span>
<a href="#l5.11"></a><span id="l5.11">  * Example:</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">- *	ldap_bind( ld, &quot;cn=manager, o=university of michigan, c=us&quot;, &quot;secret&quot;,</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineminus">- *	    LDAP_AUTH_SIMPLE )</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+ * ldap_bind(ld, &quot;cn=manager, o=university of michigan, c=us&quot;, &quot;secret&quot;,</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+ *           LDAP_AUTH_SIMPLE)</span>
<a href="#l5.16"></a><span id="l5.16">  */</span>
<a href="#l5.17"></a><span id="l5.17"> </span>
<a href="#l5.18"></a><span id="l5.18"> int LDAP_CALL ldap_bind(LDAP *ld, const char *dn, const char *passwd,</span>
<a href="#l5.19"></a><span id="l5.19">                         int authmethod) {</span>
<a href="#l5.20"></a><span id="l5.20">   /*</span>
<a href="#l5.21"></a><span id="l5.21">    * The bind request looks like this:</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineminus">-   *	BindRequest ::= SEQUENCE {</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineminus">-   *		version		INTEGER,</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineminus">-   *		name		DistinguishedName,	 -- who</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineminus">-   *		authentication	CHOICE {</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineminus">-   *			simple		[0] OCTET STRING -- passwd</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineminus">-   *		}</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineminus">-   *	}</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+   * BindRequest ::= SEQUENCE {</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+   *   version INTEGER,</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+   *   name DistinguishedName,   -- who</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+   *   authentication CHOICE {</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+   *     simple [0] OCTET STRING -- passwd</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+   *   }</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+   * }</span>
<a href="#l5.36"></a><span id="l5.36">    * all wrapped up in an LDAPMessage sequence.</span>
<a href="#l5.37"></a><span id="l5.37">    */</span>
<a href="#l5.38"></a><span id="l5.38"> </span>
<a href="#l5.39"></a><span id="l5.39">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_bind\n&quot;, 0, 0, 0);</span>
<a href="#l5.40"></a><span id="l5.40"> </span>
<a href="#l5.41"></a><span id="l5.41">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l5.42"></a><span id="l5.42">     return (-1);</span>
<a href="#l5.43"></a><span id="l5.43">   }</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineat">@@ -93,20 +93,20 @@ int LDAP_CALL ldap_bind(LDAP *ld, const </span>
<a href="#l5.45"></a><span id="l5.45">  * ldap_bind_s - bind to the ldap server.  The dn and password</span>
<a href="#l5.46"></a><span id="l5.46">  * of the entry to which to bind are supplied, along with the authentication</span>
<a href="#l5.47"></a><span id="l5.47">  * method to use.  This routine just calls whichever bind routine is</span>
<a href="#l5.48"></a><span id="l5.48">  * appropriate and returns the result of the bind (e.g. LDAP_SUCCESS or</span>
<a href="#l5.49"></a><span id="l5.49">  * some other error indication).  Note, the kerberos support assumes the</span>
<a href="#l5.50"></a><span id="l5.50">  * user already has a valid tgt for now.</span>
<a href="#l5.51"></a><span id="l5.51">  *</span>
<a href="#l5.52"></a><span id="l5.52">  * Examples:</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineminus">- *	ldap_bind_s( ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineminus">- *	    &quot;secret&quot;, LDAP_AUTH_SIMPLE )</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineminus">- *	ldap_bind_s( ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineminus">- *	    NULL, LDAP_AUTH_KRBV4 )</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+ * ldap_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+ *             &quot;secret&quot;, LDAP_AUTH_SIMPLE)</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+ * ldap_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+ *             NULL, LDAP_AUTH_KRBV4)</span>
<a href="#l5.61"></a><span id="l5.61">  */</span>
<a href="#l5.62"></a><span id="l5.62"> int LDAP_CALL ldap_bind_s(LDAP *ld, const char *dn, const char *passwd,</span>
<a href="#l5.63"></a><span id="l5.63">                           int authmethod) {</span>
<a href="#l5.64"></a><span id="l5.64">   int err;</span>
<a href="#l5.65"></a><span id="l5.65"> </span>
<a href="#l5.66"></a><span id="l5.66">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_bind_s\n&quot;, 0, 0, 0);</span>
<a href="#l5.67"></a><span id="l5.67"> </span>
<a href="#l5.68"></a><span id="l5.68">   switch (authmethod) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/charray.c</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/charray.c</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -152,17 +152,17 @@ char **LDAP_CALL ldap_charray_dup(char *</span>
<a href="#l6.4"></a><span id="l6.4">   new[i] = NULL;</span>
<a href="#l6.5"></a><span id="l6.5"> </span>
<a href="#l6.6"></a><span id="l6.6">   return (new);</span>
<a href="#l6.7"></a><span id="l6.7"> }</span>
<a href="#l6.8"></a><span id="l6.8"> </span>
<a href="#l6.9"></a><span id="l6.9"> /*</span>
<a href="#l6.10"></a><span id="l6.10">  * Tokenize the string str, return NULL upon any memory failure.</span>
<a href="#l6.11"></a><span id="l6.11">  * XXX: on many platforms this function is not thread safe because it</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">- *	uses strtok().</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+ * uses strtok().</span>
<a href="#l6.14"></a><span id="l6.14">  */</span>
<a href="#l6.15"></a><span id="l6.15"> char **LDAP_CALL ldap_str2charray(char *str, char *brkstr)</span>
<a href="#l6.16"></a><span id="l6.16"> /* This implementation fails if brkstr contains multibyte characters.</span>
<a href="#l6.17"></a><span id="l6.17">    But it works OK if str is UTF-8 and brkstr is 7-bit ASCII.</span>
<a href="#l6.18"></a><span id="l6.18">  */</span>
<a href="#l6.19"></a><span id="l6.19"> {</span>
<a href="#l6.20"></a><span id="l6.20">   char **res;</span>
<a href="#l6.21"></a><span id="l6.21">   char *s;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/charset.c</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/charset.c</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -143,18 +143,18 @@ int ldap_translate_to_t61(LDAP *ld, char</span>
<a href="#l7.4"></a><span id="l7.4">  * the following ISO_8859 to/afrom T.61 character set translation code is</span>
<a href="#l7.5"></a><span id="l7.5">  * based on the code found in Enrique Silvestre Mora's iso-t61.c, found</span>
<a href="#l7.6"></a><span id="l7.6">  * as part of this package:</span>
<a href="#l7.7"></a><span id="l7.7">  *   ftp://pereiii.uji.es/pub/uji-ftp/unix/ldap/iso-t61.translation.tar.Z</span>
<a href="#l7.8"></a><span id="l7.8">  * Enrique is now (10/95) at this address: enrique.silvestre@uv.es</span>
<a href="#l7.9"></a><span id="l7.9">  *</span>
<a href="#l7.10"></a><span id="l7.10">  * changes made by mcs@umich.edu 12 October 1995:</span>
<a href="#l7.11"></a><span id="l7.11">  *   Change calling conventions of iso8859_t61() and t61_iso8859() to</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">- *	match libldap conventions; rename to ldap_8859_to_t61() and</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">- *	ldap_t61_to_8859().</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+ *   match libldap conventions; rename to ldap_8859_to_t61() and</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+ *   ldap_t61_to_8859().</span>
<a href="#l7.16"></a><span id="l7.16">  *   Change conversion routines to deal with non-zero terminated strings.</span>
<a href="#l7.17"></a><span id="l7.17">  *   ANSI-ize functions and include prototypes.</span>
<a href="#l7.18"></a><span id="l7.18">  */</span>
<a href="#l7.19"></a><span id="l7.19"> </span>
<a href="#l7.20"></a><span id="l7.20"> /* iso-t61.c - ISO-T61 translation routines (version: 0.2.1, July-1994) */</span>
<a href="#l7.21"></a><span id="l7.21"> /*</span>
<a href="#l7.22"></a><span id="l7.22">  * Copyright (c) 1994 Enrique Silvestre Mora, Universitat Jaume I, Spain.</span>
<a href="#l7.23"></a><span id="l7.23">  * All rights reserved.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/cldap.c</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/cldap.c</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -102,18 +102,18 @@ static int cldap_result();</span>
<a href="#l8.4"></a><span id="l8.4"> static int cldap_parsemsg();</span>
<a href="#l8.5"></a><span id="l8.5"> #  endif /* NEEDPROTOS */</span>
<a href="#l8.6"></a><span id="l8.6"> </span>
<a href="#l8.7"></a><span id="l8.7"> /*</span>
<a href="#l8.8"></a><span id="l8.8">  * cldap_open - initialize and connect to an ldap server.  A magic cookie to</span>
<a href="#l8.9"></a><span id="l8.9">  * be used for future communication is returned on success, NULL on failure.</span>
<a href="#l8.10"></a><span id="l8.10">  *</span>
<a href="#l8.11"></a><span id="l8.11">  * Example:</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">- *	LDAP	*ld;</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineminus">- *	ld = cldap_open( hostname, port );</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+ * LDAP  *ld;</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+ * ld = cldap_open(hostname, port);</span>
<a href="#l8.16"></a><span id="l8.16">  */</span>
<a href="#l8.17"></a><span id="l8.17"> </span>
<a href="#l8.18"></a><span id="l8.18"> LDAP *cldap_open(char *host, int port) {</span>
<a href="#l8.19"></a><span id="l8.19">   int s;</span>
<a href="#l8.20"></a><span id="l8.20">   ldap_x_in_addr_t address;</span>
<a href="#l8.21"></a><span id="l8.21">   struct sockaddr_in sock;</span>
<a href="#l8.22"></a><span id="l8.22">   struct hostent *hp;</span>
<a href="#l8.23"></a><span id="l8.23">   LDAP *ld;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/compare.c</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/compare.c</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -51,17 +51,17 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l9.4"></a><span id="l9.4"> #include &quot;ldap-int.h&quot;</span>
<a href="#l9.5"></a><span id="l9.5"> </span>
<a href="#l9.6"></a><span id="l9.6"> /*</span>
<a href="#l9.7"></a><span id="l9.7">  * ldap_compare - perform an ldap compare operation.  The dn</span>
<a href="#l9.8"></a><span id="l9.8">  * of the entry to compare to and the attribute and value to compare (in</span>
<a href="#l9.9"></a><span id="l9.9">  * attr and value) are supplied.  The msgid of the response is returned.</span>
<a href="#l9.10"></a><span id="l9.10">  *</span>
<a href="#l9.11"></a><span id="l9.11">  * Example:</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">- *	ldap_compare( ld, &quot;c=us@cn=bob&quot;, &quot;userPassword&quot;, &quot;secret&quot; )</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+ * ldap_compare(ld, &quot;c=us@cn=bob&quot;, &quot;userPassword&quot;, &quot;secret&quot;)</span>
<a href="#l9.14"></a><span id="l9.14">  */</span>
<a href="#l9.15"></a><span id="l9.15"> int LDAP_CALL ldap_compare(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l9.16"></a><span id="l9.16">                            const char *value) {</span>
<a href="#l9.17"></a><span id="l9.17">   int msgid;</span>
<a href="#l9.18"></a><span id="l9.18">   struct berval bv;</span>
<a href="#l9.19"></a><span id="l9.19"> </span>
<a href="#l9.20"></a><span id="l9.20">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_compare\n&quot;, 0, 0, 0);</span>
<a href="#l9.21"></a><span id="l9.21"> </span>
<a href="#l9.22"></a><span id="l9.22" class="difflineat">@@ -78,23 +78,23 @@ int LDAP_CALL ldap_compare(LDAP *ld, con</span>
<a href="#l9.23"></a><span id="l9.23"> int LDAP_CALL ldap_compare_ext(LDAP *ld, const char *dn, const char *attr,</span>
<a href="#l9.24"></a><span id="l9.24">                                const struct berval *bvalue,</span>
<a href="#l9.25"></a><span id="l9.25">                                LDAPControl **serverctrls,</span>
<a href="#l9.26"></a><span id="l9.26">                                LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l9.27"></a><span id="l9.27">   BerElement *ber;</span>
<a href="#l9.28"></a><span id="l9.28">   int rc, lderr;</span>
<a href="#l9.29"></a><span id="l9.29"> </span>
<a href="#l9.30"></a><span id="l9.30">   /* The compare request looks like this:</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-   *	CompareRequest ::= SEQUENCE {</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineminus">-   *		entry	DistinguishedName,</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineminus">-   *		ava	SEQUENCE {</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineminus">-   *			type	AttributeType,</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineminus">-   *			value	AttributeValue</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineminus">-   *		}</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineminus">-   *	}</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+   * CompareRequest ::= SEQUENCE {</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+   *   entry DistinguishedName,</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+   *   ava SEQUENCE {</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+   *     type AttributeType,</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+   *     value AttributeValue</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+   *   }</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+   * }</span>
<a href="#l9.45"></a><span id="l9.45">    * and must be wrapped in an LDAPMessage.</span>
<a href="#l9.46"></a><span id="l9.46">    */</span>
<a href="#l9.47"></a><span id="l9.47"> </span>
<a href="#l9.48"></a><span id="l9.48">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_compare_ext\n&quot;, 0, 0, 0);</span>
<a href="#l9.49"></a><span id="l9.49"> </span>
<a href="#l9.50"></a><span id="l9.50">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l9.51"></a><span id="l9.51">     return (LDAP_PARAM_ERROR);</span>
<a href="#l9.52"></a><span id="l9.52">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/control.c</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/control.c</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -144,23 +144,23 @@ int nsldapi_get_controls(BerElement *ber</span>
<a href="#l10.4"></a><span id="l10.4">   char *last;</span>
<a href="#l10.5"></a><span id="l10.5"> </span>
<a href="#l10.6"></a><span id="l10.6">   /*</span>
<a href="#l10.7"></a><span id="l10.7">    * Each LDAPMessage can have a set of controls appended</span>
<a href="#l10.8"></a><span id="l10.8">    * to it. Controls are used to extend the functionality</span>
<a href="#l10.9"></a><span id="l10.9">    * of an LDAP operation (e.g., add an attribute size limit</span>
<a href="#l10.10"></a><span id="l10.10">    * to the search operation). These controls look like this:</span>
<a href="#l10.11"></a><span id="l10.11">    *</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-   *	Controls ::= SEQUENCE OF Control</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+   * Controls ::= SEQUENCE OF Control</span>
<a href="#l10.14"></a><span id="l10.14">    *</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineminus">-   *	Control ::= SEQUENCE {</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineminus">-   *		controlType	LDAPOID,</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineminus">-   *		criticality	BOOLEAN DEFAULT FALSE,</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineminus">-   *		controlValue	OCTET STRING</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineminus">-   *	}</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+   * Control ::= SEQUENCE {</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+   *   controlType LDAPOID,</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+   *   criticality BOOLEAN DEFAULT FALSE,</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+   *   controlValue OCTET STRING</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+   * }</span>
<a href="#l10.25"></a><span id="l10.25">    */</span>
<a href="#l10.26"></a><span id="l10.26">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;=&gt; nsldapi_get_controls\n&quot;, 0, 0, 0);</span>
<a href="#l10.27"></a><span id="l10.27"> </span>
<a href="#l10.28"></a><span id="l10.28">   *controlsp = NULL;</span>
<a href="#l10.29"></a><span id="l10.29"> </span>
<a href="#l10.30"></a><span id="l10.30">   /*</span>
<a href="#l10.31"></a><span id="l10.31">    * check to see if controls were included</span>
<a href="#l10.32"></a><span id="l10.32">    */</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineat">@@ -331,48 +331,48 @@ LDAPControl *LDAP_CALL ldap_find_control</span>
<a href="#l10.34"></a><span id="l10.34"> }</span>
<a href="#l10.35"></a><span id="l10.35"> </span>
<a href="#l10.36"></a><span id="l10.36"> #if 0</span>
<a href="#l10.37"></a><span id="l10.37"> LDAPControl **</span>
<a href="#l10.38"></a><span id="l10.38"> LDAP_CALL</span>
<a href="#l10.39"></a><span id="l10.39"> ldap_control_append( LDAPControl **ctrl_src, LDAPControl *ctrl )</span>
<a href="#l10.40"></a><span id="l10.40"> {</span>
<a href="#l10.41"></a><span id="l10.41">     int nctrls = 0;</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineminus">-	LDAPControl **ctrlp;</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineminus">-	int i;</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+  LDAPControl **ctrlp;</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+  int i;</span>
<a href="#l10.46"></a><span id="l10.46"> </span>
<a href="#l10.47"></a><span id="l10.47" class="difflineminus">-	if ( NULL == ctrl )</span>
<a href="#l10.48"></a><span id="l10.48" class="difflineminus">-	    return ( NULL );</span>
<a href="#l10.49"></a><span id="l10.49" class="difflineplus">+  if (NULL == ctrl)</span>
<a href="#l10.50"></a><span id="l10.50" class="difflineplus">+    return (NULL);</span>
<a href="#l10.51"></a><span id="l10.51"> </span>
<a href="#l10.52"></a><span id="l10.52" class="difflineminus">-	/* Count the existing controls */</span>
<a href="#l10.53"></a><span id="l10.53" class="difflineminus">-	if ( NULL != ctrl_src ) {</span>
<a href="#l10.54"></a><span id="l10.54" class="difflineminus">-		while( NULL != ctrl_src[nctrls] ) {</span>
<a href="#l10.55"></a><span id="l10.55" class="difflineminus">-			nctrls++;</span>
<a href="#l10.56"></a><span id="l10.56" class="difflineminus">-		}</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineminus">-	}</span>
<a href="#l10.58"></a><span id="l10.58" class="difflineplus">+  /* Count the existing controls */</span>
<a href="#l10.59"></a><span id="l10.59" class="difflineplus">+  if (NULL != ctrl_src) {</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineplus">+    while (NULL != ctrl_src[nctrls]) {</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineplus">+      nctrls++;</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+    }</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineplus">+  }</span>
<a href="#l10.64"></a><span id="l10.64"> </span>
<a href="#l10.65"></a><span id="l10.65" class="difflineminus">-	/* allocate the new control structure */</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineminus">-	if ( ( ctrlp = (LDAPControl **)NSLDAPI_MALLOC( sizeof(LDAPControl *)</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineminus">-	    * (nctrls + 2) ) ) == NULL ) {</span>
<a href="#l10.68"></a><span id="l10.68" class="difflineminus">-		return( NULL );</span>
<a href="#l10.69"></a><span id="l10.69" class="difflineminus">-	}</span>
<a href="#l10.70"></a><span id="l10.70" class="difflineminus">-	memset( ctrlp, 0, sizeof(*ctrlp) * (nctrls + 2) );</span>
<a href="#l10.71"></a><span id="l10.71" class="difflineplus">+  /* allocate the new control structure */</span>
<a href="#l10.72"></a><span id="l10.72" class="difflineplus">+  if ((ctrlp = (LDAPControl **)NSLDAPI_MALLOC(sizeof(LDAPControl *)</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineplus">+      *(nctrls + 2))) == NULL) {</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineplus">+    return(NULL);</span>
<a href="#l10.75"></a><span id="l10.75" class="difflineplus">+  }</span>
<a href="#l10.76"></a><span id="l10.76" class="difflineplus">+  memset(ctrlp, 0, sizeof(*ctrlp) * (nctrls + 2));</span>
<a href="#l10.77"></a><span id="l10.77"> </span>
<a href="#l10.78"></a><span id="l10.78" class="difflineminus">-	for( i = 0; i &lt; (nctrls + 1); i++ ) {</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineminus">-	    if ( i &lt; nctrls ) {</span>
<a href="#l10.80"></a><span id="l10.80" class="difflineminus">-		    ctrlp[i] = ldap_control_dup( ctrl_src[i] );</span>
<a href="#l10.81"></a><span id="l10.81" class="difflineminus">-	    } else {</span>
<a href="#l10.82"></a><span id="l10.82" class="difflineminus">-		    ctrlp[i] = ldap_control_dup( ctrl );</span>
<a href="#l10.83"></a><span id="l10.83" class="difflineminus">-	    }</span>
<a href="#l10.84"></a><span id="l10.84" class="difflineminus">-	    if ( NULL == ctrlp[i] ) {</span>
<a href="#l10.85"></a><span id="l10.85" class="difflineminus">-		    ldap_controls_free( ctrlp );</span>
<a href="#l10.86"></a><span id="l10.86" class="difflineminus">-		    return( NULL );</span>
<a href="#l10.87"></a><span id="l10.87" class="difflineminus">-	    }</span>
<a href="#l10.88"></a><span id="l10.88" class="difflineminus">-	}</span>
<a href="#l10.89"></a><span id="l10.89" class="difflineminus">-	return ctrlp;</span>
<a href="#l10.90"></a><span id="l10.90" class="difflineplus">+  for (i = 0; i &lt; (nctrls + 1); i++) {</span>
<a href="#l10.91"></a><span id="l10.91" class="difflineplus">+      if (i &lt; nctrls) {</span>
<a href="#l10.92"></a><span id="l10.92" class="difflineplus">+        ctrlp[i] = ldap_control_dup(ctrl_src[i]);</span>
<a href="#l10.93"></a><span id="l10.93" class="difflineplus">+      } else {</span>
<a href="#l10.94"></a><span id="l10.94" class="difflineplus">+        ctrlp[i] = ldap_control_dup(ctrl);</span>
<a href="#l10.95"></a><span id="l10.95" class="difflineplus">+      }</span>
<a href="#l10.96"></a><span id="l10.96" class="difflineplus">+      if (NULL == ctrlp[i]) {</span>
<a href="#l10.97"></a><span id="l10.97" class="difflineplus">+        ldap_controls_free(ctrlp);</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineplus">+        return(NULL);</span>
<a href="#l10.99"></a><span id="l10.99" class="difflineplus">+      }</span>
<a href="#l10.100"></a><span id="l10.100" class="difflineplus">+  }</span>
<a href="#l10.101"></a><span id="l10.101" class="difflineplus">+  return ctrlp;</span>
<a href="#l10.102"></a><span id="l10.102"> }</span>
<a href="#l10.103"></a><span id="l10.103"> #endif /* 0 */</span>
<a href="#l10.104"></a><span id="l10.104"> </span>
<a href="#l10.105"></a><span id="l10.105"> /*</span>
<a href="#l10.106"></a><span id="l10.106">  * Replace *ldctrls with a copy of newctrls.</span>
<a href="#l10.107"></a><span id="l10.107">  * returns 0 if successful.</span>
<a href="#l10.108"></a><span id="l10.108">  * return -1 if not and set error code inside LDAP *ld.</span>
<a href="#l10.109"></a><span id="l10.109">  */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/delete.c</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/delete.c</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -44,21 +44,21 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l11.4"></a><span id="l11.4"> #  endif</span>
<a href="#l11.5"></a><span id="l11.5"> #endif</span>
<a href="#l11.6"></a><span id="l11.6"> </span>
<a href="#l11.7"></a><span id="l11.7"> #include &quot;ldap-int.h&quot;</span>
<a href="#l11.8"></a><span id="l11.8"> </span>
<a href="#l11.9"></a><span id="l11.9"> /*</span>
<a href="#l11.10"></a><span id="l11.10">  * ldap_delete - initiate an ldap delete operation. Parameters:</span>
<a href="#l11.11"></a><span id="l11.11">  *</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">- *	ld		LDAP descriptor</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineminus">- *	dn		DN of the object to delete</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+ * ld    LDAP descriptor</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+ * dn    DN of the object to delete</span>
<a href="#l11.16"></a><span id="l11.16">  *</span>
<a href="#l11.17"></a><span id="l11.17">  * Example:</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineminus">- *	msgid = ldap_delete( ld, dn );</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+ * msgid = ldap_delete(ld, dn);</span>
<a href="#l11.20"></a><span id="l11.20">  */</span>
<a href="#l11.21"></a><span id="l11.21"> int LDAP_CALL ldap_delete(LDAP *ld, const char *dn) {</span>
<a href="#l11.22"></a><span id="l11.22">   int msgid;</span>
<a href="#l11.23"></a><span id="l11.23"> </span>
<a href="#l11.24"></a><span id="l11.24">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_delete\n&quot;, 0, 0, 0);</span>
<a href="#l11.25"></a><span id="l11.25"> </span>
<a href="#l11.26"></a><span id="l11.26">   if (ldap_delete_ext(ld, dn, NULL, NULL, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l11.27"></a><span id="l11.27">     return (msgid);</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineat">@@ -70,17 +70,17 @@ int LDAP_CALL ldap_delete(LDAP *ld, cons</span>
<a href="#l11.29"></a><span id="l11.29"> int LDAP_CALL ldap_delete_ext(LDAP *ld, const char *dn,</span>
<a href="#l11.30"></a><span id="l11.30">                               LDAPControl **serverctrls,</span>
<a href="#l11.31"></a><span id="l11.31">                               LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l11.32"></a><span id="l11.32">   BerElement *ber;</span>
<a href="#l11.33"></a><span id="l11.33">   int rc, lderr;</span>
<a href="#l11.34"></a><span id="l11.34"> </span>
<a href="#l11.35"></a><span id="l11.35">   /*</span>
<a href="#l11.36"></a><span id="l11.36">    * A delete request looks like this:</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineminus">-   *	DelRequet ::= DistinguishedName,</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+   * DelRequet ::= DistinguishedName,</span>
<a href="#l11.39"></a><span id="l11.39">    */</span>
<a href="#l11.40"></a><span id="l11.40"> </span>
<a href="#l11.41"></a><span id="l11.41">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_delete_ext\n&quot;, 0, 0, 0);</span>
<a href="#l11.42"></a><span id="l11.42"> </span>
<a href="#l11.43"></a><span id="l11.43">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l11.44"></a><span id="l11.44">     return (LDAP_PARAM_ERROR);</span>
<a href="#l11.45"></a><span id="l11.45">   }</span>
<a href="#l11.46"></a><span id="l11.46"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/error.c</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/error.c</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -345,30 +345,30 @@ int nsldapi_parse_result(LDAP *ld, int m</span>
<a href="#l12.4"></a><span id="l12.4">   ber_len_t len;</span>
<a href="#l12.5"></a><span id="l12.5">   ber_int_t errcode;</span>
<a href="#l12.6"></a><span id="l12.6">   int berrc, err;</span>
<a href="#l12.7"></a><span id="l12.7">   char *m, *e;</span>
<a href="#l12.8"></a><span id="l12.8"> </span>
<a href="#l12.9"></a><span id="l12.9">   /*</span>
<a href="#l12.10"></a><span id="l12.10">    * Parse the result message.  LDAPv3 result messages look like this:</span>
<a href="#l12.11"></a><span id="l12.11">    *</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-   *	LDAPResult ::= SEQUENCE {</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineminus">-   *		resultCode	ENUMERATED { ... },</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineminus">-   *		matchedDN	LDAPDN,</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineminus">-   *		errorMessage	LDAPString,</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineminus">-   *		referral	[3] Referral OPTIONAL</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineminus">-   *		opSpecificStuff	OPTIONAL</span>
<a href="#l12.18"></a><span id="l12.18" class="difflineminus">-   *	}</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+   * LDAPResult ::= SEQUENCE {</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineplus">+   *   resultCode ENUMERATED { ... },</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+   *   matchedDN LDAPDN,</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+   *   errorMessage LDAPString,</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineplus">+   *   referral [3] Referral OPTIONAL</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineplus">+   *   opSpecificStuff OPTIONAL</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+   * }</span>
<a href="#l12.26"></a><span id="l12.26">    *</span>
<a href="#l12.27"></a><span id="l12.27">    * all wrapped up in an LDAPMessage sequence which looks like this:</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineminus">-   *	LDAPMessage ::= SEQUENCE {</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineminus">-   *		messageID	MessageID,</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineminus">-   *		LDAPResult	CHOICE { ... },	// message type</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineminus">-   *		controls	[0] Controls OPTIONAL</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineminus">-   *	}</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+   * LDAPMessage ::= SEQUENCE {</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+   *   messageID MessageID,</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+   *   LDAPResult CHOICE { ... },  // message type</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+   *   controls [0] Controls OPTIONAL</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+   * }</span>
<a href="#l12.38"></a><span id="l12.38">    *</span>
<a href="#l12.39"></a><span id="l12.39">    * LDAPv2 messages don't include referrals or controls.</span>
<a href="#l12.40"></a><span id="l12.40">    * LDAPv1 messages don't include matchedDN, referrals, or controls.</span>
<a href="#l12.41"></a><span id="l12.41">    *</span>
<a href="#l12.42"></a><span id="l12.42">    * ldap_result() pulls out the message id, so by the time a result</span>
<a href="#l12.43"></a><span id="l12.43">    * message gets here we are sitting at the start of the LDAPResult.</span>
<a href="#l12.44"></a><span id="l12.44">    */</span>
<a href="#l12.45"></a><span id="l12.45"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/extendop.c</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/extendop.c</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -37,37 +37,37 @@</span>
<a href="#l13.4"></a><span id="l13.4"> #include &quot;ldap-int.h&quot;</span>
<a href="#l13.5"></a><span id="l13.5"> </span>
<a href="#l13.6"></a><span id="l13.6"> /*</span>
<a href="#l13.7"></a><span id="l13.7">  * ldap_extended_operation - initiate an arbitrary ldapv3 extended operation.</span>
<a href="#l13.8"></a><span id="l13.8">  * the oid and data of the extended operation are supplied. Returns an</span>
<a href="#l13.9"></a><span id="l13.9">  * LDAP error code.</span>
<a href="#l13.10"></a><span id="l13.10">  *</span>
<a href="#l13.11"></a><span id="l13.11">  * Example:</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">- *	struct berval	exdata;</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineminus">- *	char		*exoid;</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineminus">- *	int		err, msgid;</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineminus">- *	... fill in oid and data ...</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineminus">- *	err = ldap_extended_operation( ld, exoid, &amp;exdata, NULL, NULL, &amp;msgid );</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+ * struct berval exdata;</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+ * char *exoid;</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+ * int err, msgid;</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+ * ... fill in oid and data ...</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+ * err = ldap_extended_operation(ld, exoid, &amp;exdata, NULL, NULL, &amp;msgid);</span>
<a href="#l13.22"></a><span id="l13.22">  */</span>
<a href="#l13.23"></a><span id="l13.23"> </span>
<a href="#l13.24"></a><span id="l13.24"> int LDAP_CALL ldap_extended_operation(LDAP *ld, const char *exoid,</span>
<a href="#l13.25"></a><span id="l13.25">                                       const struct berval *exdata,</span>
<a href="#l13.26"></a><span id="l13.26">                                       LDAPControl **serverctrls,</span>
<a href="#l13.27"></a><span id="l13.27">                                       LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l13.28"></a><span id="l13.28">   BerElement *ber;</span>
<a href="#l13.29"></a><span id="l13.29">   int rc, msgid;</span>
<a href="#l13.30"></a><span id="l13.30"> </span>
<a href="#l13.31"></a><span id="l13.31">   /*</span>
<a href="#l13.32"></a><span id="l13.32">    * the ldapv3 extended operation request looks like this:</span>
<a href="#l13.33"></a><span id="l13.33">    *</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineminus">-   *	ExtendedRequest ::= [APPLICATION 23] SEQUENCE {</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineminus">-   *		requestName	LDAPOID,</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineminus">-   *		requestValue	OCTET STRING</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineminus">-   *	}</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineplus">+   * ExtendedRequest ::= [APPLICATION 23] SEQUENCE {</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineplus">+   *   requestName  LDAPOID,</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineplus">+   *   requestValue  OCTET STRING</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+   * }</span>
<a href="#l13.42"></a><span id="l13.42">    *</span>
<a href="#l13.43"></a><span id="l13.43">    * all wrapped up in an LDAPMessage sequence.</span>
<a href="#l13.44"></a><span id="l13.44">    */</span>
<a href="#l13.45"></a><span id="l13.45"> </span>
<a href="#l13.46"></a><span id="l13.46">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_extended_operation\n&quot;, 0, 0, 0);</span>
<a href="#l13.47"></a><span id="l13.47"> </span>
<a href="#l13.48"></a><span id="l13.48">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l13.49"></a><span id="l13.49">     return (LDAP_PARAM_ERROR);</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineat">@@ -86,25 +86,25 @@ int LDAP_CALL ldap_extended_operation(LD</span>
<a href="#l13.51"></a><span id="l13.51">     return (rc);</span>
<a href="#l13.52"></a><span id="l13.52">   }</span>
<a href="#l13.53"></a><span id="l13.53"> </span>
<a href="#l13.54"></a><span id="l13.54">   LDAP_MUTEX_LOCK(ld, LDAP_MSGID_LOCK);</span>
<a href="#l13.55"></a><span id="l13.55">   msgid = ++ld-&gt;ld_msgid;</span>
<a href="#l13.56"></a><span id="l13.56">   LDAP_MUTEX_UNLOCK(ld, LDAP_MSGID_LOCK);</span>
<a href="#l13.57"></a><span id="l13.57"> </span>
<a href="#l13.58"></a><span id="l13.58"> #if 0</span>
<a href="#l13.59"></a><span id="l13.59" class="difflineminus">-	if ( ld-&gt;ld_cache_on &amp;&amp; ld-&gt;ld_cache_extendedop != NULL ) {</span>
<a href="#l13.60"></a><span id="l13.60" class="difflineminus">-		LDAP_MUTEX_LOCK( ld, LDAP_CACHE_LOCK );</span>
<a href="#l13.61"></a><span id="l13.61" class="difflineminus">-		if ( (rc = (ld-&gt;ld_cache_extendedop)( ld, msgid,</span>
<a href="#l13.62"></a><span id="l13.62" class="difflineminus">-		    LDAP_REQ_EXTENDED, exoid, cred )) != 0 ) {</span>
<a href="#l13.63"></a><span id="l13.63" class="difflineminus">-			LDAP_MUTEX_UNLOCK( ld, LDAP_CACHE_LOCK );</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineminus">-			return( rc );</span>
<a href="#l13.65"></a><span id="l13.65" class="difflineminus">-		}</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineminus">-		LDAP_MUTEX_UNLOCK( ld, LDAP_CACHE_LOCK );</span>
<a href="#l13.67"></a><span id="l13.67" class="difflineminus">-	}</span>
<a href="#l13.68"></a><span id="l13.68" class="difflineplus">+  if (ld-&gt;ld_cache_on &amp;&amp; ld-&gt;ld_cache_extendedop != NULL) {</span>
<a href="#l13.69"></a><span id="l13.69" class="difflineplus">+    LDAP_MUTEX_LOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l13.70"></a><span id="l13.70" class="difflineplus">+    if ((rc = (ld-&gt;ld_cache_extendedop)(ld, msgid,</span>
<a href="#l13.71"></a><span id="l13.71" class="difflineplus">+               LDAP_REQ_EXTENDED, exoid, cred )) != 0) {</span>
<a href="#l13.72"></a><span id="l13.72" class="difflineplus">+      LDAP_MUTEX_UNLOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l13.73"></a><span id="l13.73" class="difflineplus">+      return(rc);</span>
<a href="#l13.74"></a><span id="l13.74" class="difflineplus">+    }</span>
<a href="#l13.75"></a><span id="l13.75" class="difflineplus">+    LDAP_MUTEX_UNLOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l13.76"></a><span id="l13.76" class="difflineplus">+  }</span>
<a href="#l13.77"></a><span id="l13.77"> #endif</span>
<a href="#l13.78"></a><span id="l13.78"> </span>
<a href="#l13.79"></a><span id="l13.79">   /* create a message to send */</span>
<a href="#l13.80"></a><span id="l13.80">   if ((rc = nsldapi_alloc_ber_with_options(ld, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l13.81"></a><span id="l13.81">     return (rc);</span>
<a href="#l13.82"></a><span id="l13.82">   }</span>
<a href="#l13.83"></a><span id="l13.83"> </span>
<a href="#l13.84"></a><span id="l13.84">   /* fill it in */</span>
<a href="#l13.85"></a><span id="l13.85" class="difflineat">@@ -139,21 +139,21 @@ int LDAP_CALL ldap_extended_operation(LD</span>
<a href="#l13.86"></a><span id="l13.86"> }</span>
<a href="#l13.87"></a><span id="l13.87"> </span>
<a href="#l13.88"></a><span id="l13.88"> /*</span>
<a href="#l13.89"></a><span id="l13.89">  * ldap_extended_operation_s - perform an arbitrary ldapv3 extended operation.</span>
<a href="#l13.90"></a><span id="l13.90">  * the oid and data of the extended operation are supplied. LDAP_SUCCESS</span>
<a href="#l13.91"></a><span id="l13.91">  * is returned upon success, the ldap error code otherwise.</span>
<a href="#l13.92"></a><span id="l13.92">  *</span>
<a href="#l13.93"></a><span id="l13.93">  * Example:</span>
<a href="#l13.94"></a><span id="l13.94" class="difflineminus">- *	struct berval	exdata, exretval;</span>
<a href="#l13.95"></a><span id="l13.95" class="difflineminus">- *	char		*exoid;</span>
<a href="#l13.96"></a><span id="l13.96" class="difflineminus">- *	int		rc;</span>
<a href="#l13.97"></a><span id="l13.97" class="difflineminus">- *	... fill in oid and data ...</span>
<a href="#l13.98"></a><span id="l13.98" class="difflineminus">- *	rc = ldap_extended_operation_s( ld, exoid, &amp;exdata, &amp;exretval );</span>
<a href="#l13.99"></a><span id="l13.99" class="difflineplus">+ * struct berval exdata, exretval;</span>
<a href="#l13.100"></a><span id="l13.100" class="difflineplus">+ * char *exoid;</span>
<a href="#l13.101"></a><span id="l13.101" class="difflineplus">+ * int rc;</span>
<a href="#l13.102"></a><span id="l13.102" class="difflineplus">+ * ... fill in oid and data ...</span>
<a href="#l13.103"></a><span id="l13.103" class="difflineplus">+ * rc = ldap_extended_operation_s(ld, exoid, &amp;exdata, &amp;exretval);</span>
<a href="#l13.104"></a><span id="l13.104">  */</span>
<a href="#l13.105"></a><span id="l13.105"> int LDAP_CALL ldap_extended_operation_s(LDAP *ld, const char *requestoid,</span>
<a href="#l13.106"></a><span id="l13.106">                                         const struct berval *requestdata,</span>
<a href="#l13.107"></a><span id="l13.107">                                         LDAPControl **serverctrls,</span>
<a href="#l13.108"></a><span id="l13.108">                                         LDAPControl **clientctrls,</span>
<a href="#l13.109"></a><span id="l13.109">                                         char **retoidp,</span>
<a href="#l13.110"></a><span id="l13.110">                                         struct berval **retdatap) {</span>
<a href="#l13.111"></a><span id="l13.111">   int err, msgid;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getdn.c</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getdn.c</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -201,19 +201,19 @@ static char **ldap_explode(const char *d</span>
<a href="#l14.4"></a><span id="l14.4"> </span>
<a href="#l14.5"></a><span id="l14.5">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_explode\n&quot;, 0, 0, 0);</span>
<a href="#l14.6"></a><span id="l14.6"> </span>
<a href="#l14.7"></a><span id="l14.7">   if (dn == NULL) {</span>
<a href="#l14.8"></a><span id="l14.8">     dn = &quot;&quot;;</span>
<a href="#l14.9"></a><span id="l14.9">   }</span>
<a href="#l14.10"></a><span id="l14.10"> </span>
<a href="#l14.11"></a><span id="l14.11"> #if 0</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">-	if ( ldap_is_dns_dn( dn ) ) {</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineminus">-		return( ldap_explode_dns( dn ) );</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineminus">-	}</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+  if (ldap_is_dns_dn(dn)) {</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+    return(ldap_explode_dns(dn));</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+  }</span>
<a href="#l14.18"></a><span id="l14.18"> #endif</span>
<a href="#l14.19"></a><span id="l14.19"> </span>
<a href="#l14.20"></a><span id="l14.20">   while (ldap_utf8isspace((char *)dn)) { /* ignore leading spaces */</span>
<a href="#l14.21"></a><span id="l14.21">     ++dn;</span>
<a href="#l14.22"></a><span id="l14.22">   }</span>
<a href="#l14.23"></a><span id="l14.23"> </span>
<a href="#l14.24"></a><span id="l14.24">   p = rdnstart = (char *)dn;</span>
<a href="#l14.25"></a><span id="l14.25">   state = OUTQUOTE;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/getdxbyname.c</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/getdxbyname.c</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -87,17 +87,17 @@ XXX not MT - safe XXX</span>
<a href="#l15.4"></a><span id="l15.4"> </span>
<a href="#l15.5"></a><span id="l15.5"> extern int h_errno;</span>
<a href="#l15.6"></a><span id="l15.6"> extern char *h_errlist[];</span>
<a href="#l15.7"></a><span id="l15.7"> </span>
<a href="#l15.8"></a><span id="l15.8"> #  define MAX_TO_SORT 32</span>
<a href="#l15.9"></a><span id="l15.9"> </span>
<a href="#l15.10"></a><span id="l15.10"> /*</span>
<a href="#l15.11"></a><span id="l15.11">  * nsldapi_getdxbyname - lookup DNS DX records for domain and return an ordered</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">- *	array.</span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+ * array.</span>
<a href="#l15.14"></a><span id="l15.14">  */</span>
<a href="#l15.15"></a><span id="l15.15"> char **nsldapi_getdxbyname(char *domain) {</span>
<a href="#l15.16"></a><span id="l15.16">   unsigned char buf[PACKETSZ];</span>
<a href="#l15.17"></a><span id="l15.17">   char **dxs;</span>
<a href="#l15.18"></a><span id="l15.18">   int rc;</span>
<a href="#l15.19"></a><span id="l15.19"> </span>
<a href="#l15.20"></a><span id="l15.20">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_getdxbyname( %s )\n&quot;, domain, 0, 0);</span>
<a href="#l15.21"></a><span id="l15.21"> </span>
<a href="#l15.22"></a><span id="l15.22" class="difflineat">@@ -127,17 +127,17 @@ static char **decode_answer(unsigned cha</span>
<a href="#l15.23"></a><span id="l15.23">   HEADER *hp;</span>
<a href="#l15.24"></a><span id="l15.24">   char buf[256], **dxs;</span>
<a href="#l15.25"></a><span id="l15.25">   unsigned char *eom, *p;</span>
<a href="#l15.26"></a><span id="l15.26">   int ancount, err, rc, type, class, dx_count, rr_len;</span>
<a href="#l15.27"></a><span id="l15.27">   int dx_pref[MAX_TO_SORT];</span>
<a href="#l15.28"></a><span id="l15.28"> </span>
<a href="#l15.29"></a><span id="l15.29"> #  ifdef LDAP_DEBUG</span>
<a href="#l15.30"></a><span id="l15.30">   if (ldap_debug &amp; LDAP_DEBUG_PACKETS) {</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineminus">-    /*	__p_query( answer );	*/</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+    /* __p_query(answer);  */</span>
<a href="#l15.33"></a><span id="l15.33">   }</span>
<a href="#l15.34"></a><span id="l15.34"> #  endif /* LDAP_DEBUG */</span>
<a href="#l15.35"></a><span id="l15.35"> </span>
<a href="#l15.36"></a><span id="l15.36">   dxs = NULL;</span>
<a href="#l15.37"></a><span id="l15.37">   hp = (HEADER *)answer;</span>
<a href="#l15.38"></a><span id="l15.38">   eom = answer + len;</span>
<a href="#l15.39"></a><span id="l15.39"> </span>
<a href="#l15.40"></a><span id="l15.40">   if (len &lt; sizeof(*hp)) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/geteffectiverightsctrl.c</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -39,17 +39,17 @@</span>
<a href="#l16.4"></a><span id="l16.4"> /* ldap_create_geteffectiveRights_control</span>
<a href="#l16.5"></a><span id="l16.5"> </span>
<a href="#l16.6"></a><span id="l16.6">    Create Effective Rights control.</span>
<a href="#l16.7"></a><span id="l16.7"> </span>
<a href="#l16.8"></a><span id="l16.8">    Parameters are</span>
<a href="#l16.9"></a><span id="l16.9"> </span>
<a href="#l16.10"></a><span id="l16.10">    ld              LDAP pointer to the desired connection</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-   authzid		   RFC2829 section 9, eg &quot;dn:&lt;DN&gt;&quot;.</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+   authzid         RFC2829 section 9, eg &quot;dn:&lt;DN&gt;&quot;.</span>
<a href="#l16.14"></a><span id="l16.14">                    NULL or empty string means get bound user's rights,</span>
<a href="#l16.15"></a><span id="l16.15">                    just &quot;dn:&quot; means get anonymous user's rights.</span>
<a href="#l16.16"></a><span id="l16.16"> </span>
<a href="#l16.17"></a><span id="l16.17">    attrlist        additional attributes for which rights info is</span>
<a href="#l16.18"></a><span id="l16.18">                    requested. NULL means &quot;just the ones returned</span>
<a href="#l16.19"></a><span id="l16.19">                    with the search operation&quot;.</span>
<a href="#l16.20"></a><span id="l16.20"> </span>
<a href="#l16.21"></a><span id="l16.21">    ctl_iscritical  Indicates whether the control is critical of not. If</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/memcache.c</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/memcache.c</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -34,17 +34,17 @@</span>
<a href="#l17.4"></a><span id="l17.4">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l17.5"></a><span id="l17.5">  *</span>
<a href="#l17.6"></a><span id="l17.6">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l17.7"></a><span id="l17.7"> /*</span>
<a href="#l17.8"></a><span id="l17.8">  *</span>
<a href="#l17.9"></a><span id="l17.9">  *  memcache.c - routines that implement an in-memory cache.</span>
<a href="#l17.10"></a><span id="l17.10">  *</span>
<a href="#l17.11"></a><span id="l17.11">  *  To Do:  1) ber_dup_ext().</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">- *	    2) referrals and reference?</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+ *          2) referrals and reference?</span>
<a href="#l17.14"></a><span id="l17.14">  */</span>
<a href="#l17.15"></a><span id="l17.15"> </span>
<a href="#l17.16"></a><span id="l17.16"> #include &lt;assert.h&gt;</span>
<a href="#l17.17"></a><span id="l17.17"> #include &quot;ldap-int.h&quot;</span>
<a href="#l17.18"></a><span id="l17.18"> </span>
<a href="#l17.19"></a><span id="l17.19"> /*</span>
<a href="#l17.20"></a><span id="l17.20">  * Extra size allocated to BerElement.</span>
<a href="#l17.21"></a><span id="l17.21">  * XXXmcs: must match EXBUFSIZ in liblber/io.c?</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineat">@@ -1015,17 +1015,17 @@ static int memcache_remove(LDAP *ld, int</span>
<a href="#l17.23"></a><span id="l17.23"> /* Wipes out everything in the temporary cache directory. */</span>
<a href="#l17.24"></a><span id="l17.24"> static int</span>
<a href="#l17.25"></a><span id="l17.25"> memcache_remove_all(LDAP *ld)</span>
<a href="#l17.26"></a><span id="l17.26"> {</span>
<a href="#l17.27"></a><span id="l17.27">     if (!memcache_exist(ld))</span>
<a href="#l17.28"></a><span id="l17.28">         return LDAP_LOCAL_ERROR;</span>
<a href="#l17.29"></a><span id="l17.29"> </span>
<a href="#l17.30"></a><span id="l17.30">     return memcache_access(ld-&gt;ld_memcache, MEMCACHE_ACCESS_DELETE_ALL,</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineminus">-	                   NULL, NULL, NULL);</span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+                           NULL, NULL, NULL);</span>
<a href="#l17.33"></a><span id="l17.33"> }</span>
<a href="#l17.34"></a><span id="l17.34"> #endif /* 0 */</span>
<a href="#l17.35"></a><span id="l17.35"> </span>
<a href="#l17.36"></a><span id="l17.36"> /* Returns TRUE or FALSE */</span>
<a href="#l17.37"></a><span id="l17.37"> static int memcache_exist(LDAP *ld) { return (ld-&gt;ld_memcache != NULL); }</span>
<a href="#l17.38"></a><span id="l17.38"> </span>
<a href="#l17.39"></a><span id="l17.39"> /* Attaches cached entries to an ldap handle. */</span>
<a href="#l17.40"></a><span id="l17.40"> static int memcache_add_to_ld(LDAP *ld, int msgid, LDAPMessage *pMsg) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/modify.c</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/modify.c</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -48,29 +48,29 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l18.4"></a><span id="l18.4"> #  endif</span>
<a href="#l18.5"></a><span id="l18.5"> #endif</span>
<a href="#l18.6"></a><span id="l18.6"> </span>
<a href="#l18.7"></a><span id="l18.7"> #include &quot;ldap-int.h&quot;</span>
<a href="#l18.8"></a><span id="l18.8"> </span>
<a href="#l18.9"></a><span id="l18.9"> /*</span>
<a href="#l18.10"></a><span id="l18.10">  * ldap_modify - initiate an ldap modify operation.  Parameters:</span>
<a href="#l18.11"></a><span id="l18.11">  *</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">- *	ld		LDAP descriptor</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineminus">- *	dn		DN of the object to modify</span>
<a href="#l18.14"></a><span id="l18.14" class="difflineminus">- *	mods		List of modifications to make.  This is null-terminated</span>
<a href="#l18.15"></a><span id="l18.15" class="difflineminus">- *			array of struct ldapmod's, specifying the modifications</span>
<a href="#l18.16"></a><span id="l18.16" class="difflineminus">- *			to perform.</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineplus">+ * ld    LDAP descriptor</span>
<a href="#l18.18"></a><span id="l18.18" class="difflineplus">+ * dn    DN of the object to modify</span>
<a href="#l18.19"></a><span id="l18.19" class="difflineplus">+ * mods  List of modifications to make.  This is null-terminated</span>
<a href="#l18.20"></a><span id="l18.20" class="difflineplus">+ *       array of struct ldapmod's, specifying the modifications</span>
<a href="#l18.21"></a><span id="l18.21" class="difflineplus">+ *       to perform.</span>
<a href="#l18.22"></a><span id="l18.22">  *</span>
<a href="#l18.23"></a><span id="l18.23">  * Example:</span>
<a href="#l18.24"></a><span id="l18.24" class="difflineminus">- *	LDAPMod	*mods[] = {</span>
<a href="#l18.25"></a><span id="l18.25" class="difflineminus">- *			{ LDAP_MOD_ADD, &quot;cn&quot;, { &quot;babs jensen&quot;, &quot;babs&quot;, 0 } },</span>
<a href="#l18.26"></a><span id="l18.26" class="difflineminus">- *			{ LDAP_MOD_REPLACE, &quot;sn&quot;, { &quot;jensen&quot;, 0 } },</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineminus">- *			0</span>
<a href="#l18.28"></a><span id="l18.28" class="difflineminus">- *		}</span>
<a href="#l18.29"></a><span id="l18.29" class="difflineminus">- *	msgid = ldap_modify( ld, dn, mods );</span>
<a href="#l18.30"></a><span id="l18.30" class="difflineplus">+ * LDAPMod  *mods[] = {</span>
<a href="#l18.31"></a><span id="l18.31" class="difflineplus">+ *     { LDAP_MOD_ADD, &quot;cn&quot;, { &quot;babs jensen&quot;, &quot;babs&quot;, 0 } },</span>
<a href="#l18.32"></a><span id="l18.32" class="difflineplus">+ *     { LDAP_MOD_REPLACE, &quot;sn&quot;, { &quot;jensen&quot;, 0 } },</span>
<a href="#l18.33"></a><span id="l18.33" class="difflineplus">+ *     0</span>
<a href="#l18.34"></a><span id="l18.34" class="difflineplus">+ *   }</span>
<a href="#l18.35"></a><span id="l18.35" class="difflineplus">+ * msgid = ldap_modify(ld, dn, mods);</span>
<a href="#l18.36"></a><span id="l18.36">  */</span>
<a href="#l18.37"></a><span id="l18.37"> int LDAP_CALL ldap_modify(LDAP *ld, const char *dn, LDAPMod **mods) {</span>
<a href="#l18.38"></a><span id="l18.38">   int msgid;</span>
<a href="#l18.39"></a><span id="l18.39"> </span>
<a href="#l18.40"></a><span id="l18.40">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_modify\n&quot;, 0, 0, 0);</span>
<a href="#l18.41"></a><span id="l18.41"> </span>
<a href="#l18.42"></a><span id="l18.42">   if (ldap_modify_ext(ld, dn, mods, NULL, NULL, &amp;msgid) == LDAP_SUCCESS) {</span>
<a href="#l18.43"></a><span id="l18.43">     return (msgid);</span>
<a href="#l18.44"></a><span id="l18.44" class="difflineat">@@ -82,30 +82,30 @@ int LDAP_CALL ldap_modify(LDAP *ld, cons</span>
<a href="#l18.45"></a><span id="l18.45"> int LDAP_CALL ldap_modify_ext(LDAP *ld, const char *dn, LDAPMod **mods,</span>
<a href="#l18.46"></a><span id="l18.46">                               LDAPControl **serverctrls,</span>
<a href="#l18.47"></a><span id="l18.47">                               LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l18.48"></a><span id="l18.48">   BerElement *ber;</span>
<a href="#l18.49"></a><span id="l18.49">   int i, rc, lderr;</span>
<a href="#l18.50"></a><span id="l18.50"> </span>
<a href="#l18.51"></a><span id="l18.51">   /*</span>
<a href="#l18.52"></a><span id="l18.52">    * A modify request looks like this:</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineminus">-   *	ModifyRequet ::= SEQUENCE {</span>
<a href="#l18.54"></a><span id="l18.54" class="difflineminus">-   *		object		DistinguishedName,</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineminus">-   *		modifications	SEQUENCE OF SEQUENCE {</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineminus">-   *			operation	ENUMERATED {</span>
<a href="#l18.57"></a><span id="l18.57" class="difflineminus">-   *				add	(0),</span>
<a href="#l18.58"></a><span id="l18.58" class="difflineminus">-   *				delete	(1),</span>
<a href="#l18.59"></a><span id="l18.59" class="difflineminus">-   *				replace	(2)</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineminus">-   *			},</span>
<a href="#l18.61"></a><span id="l18.61" class="difflineminus">-   *			modification	SEQUENCE {</span>
<a href="#l18.62"></a><span id="l18.62" class="difflineminus">-   *				type	AttributeType,</span>
<a href="#l18.63"></a><span id="l18.63" class="difflineminus">-   *				values	SET OF AttributeValue</span>
<a href="#l18.64"></a><span id="l18.64" class="difflineminus">-   *			}</span>
<a href="#l18.65"></a><span id="l18.65" class="difflineminus">-   *		}</span>
<a href="#l18.66"></a><span id="l18.66" class="difflineminus">-   *	}</span>
<a href="#l18.67"></a><span id="l18.67" class="difflineplus">+   * ModifyRequet ::= SEQUENCE {</span>
<a href="#l18.68"></a><span id="l18.68" class="difflineplus">+   *   object DistinguishedName,</span>
<a href="#l18.69"></a><span id="l18.69" class="difflineplus">+   *   modifications SEQUENCE OF SEQUENCE {</span>
<a href="#l18.70"></a><span id="l18.70" class="difflineplus">+   *     operation ENUMERATED {</span>
<a href="#l18.71"></a><span id="l18.71" class="difflineplus">+   *       add     (0),</span>
<a href="#l18.72"></a><span id="l18.72" class="difflineplus">+   *       delete  (1),</span>
<a href="#l18.73"></a><span id="l18.73" class="difflineplus">+   *       replace (2)</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineplus">+   *     },</span>
<a href="#l18.75"></a><span id="l18.75" class="difflineplus">+   *     modification  SEQUENCE {</span>
<a href="#l18.76"></a><span id="l18.76" class="difflineplus">+   *       type AttributeType,</span>
<a href="#l18.77"></a><span id="l18.77" class="difflineplus">+   *       values SET OF AttributeValue</span>
<a href="#l18.78"></a><span id="l18.78" class="difflineplus">+   *     }</span>
<a href="#l18.79"></a><span id="l18.79" class="difflineplus">+   *   }</span>
<a href="#l18.80"></a><span id="l18.80" class="difflineplus">+   * }</span>
<a href="#l18.81"></a><span id="l18.81">    */</span>
<a href="#l18.82"></a><span id="l18.82"> </span>
<a href="#l18.83"></a><span id="l18.83">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_modify_ext\n&quot;, 0, 0, 0);</span>
<a href="#l18.84"></a><span id="l18.84"> </span>
<a href="#l18.85"></a><span id="l18.85">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l18.86"></a><span id="l18.86">     return (LDAP_PARAM_ERROR);</span>
<a href="#l18.87"></a><span id="l18.87">   }</span>
<a href="#l18.88"></a><span id="l18.88">   if (!NSLDAPI_VALID_LDAPMESSAGE_POINTER(msgidp)) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/mozock.c</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/mozock.c</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -38,35 +38,36 @@</span>
<a href="#l19.4"></a><span id="l19.4"> #ifdef _WINDOWS</span>
<a href="#l19.5"></a><span id="l19.5"> #  define FD_SETSIZE 30000</span>
<a href="#l19.6"></a><span id="l19.6"> #endif</span>
<a href="#l19.7"></a><span id="l19.7"> </span>
<a href="#l19.8"></a><span id="l19.8"> #include &lt;windows.h&gt;</span>
<a href="#l19.9"></a><span id="l19.9"> #include &lt;winsock.h&gt;</span>
<a href="#l19.10"></a><span id="l19.10"> #include &lt;string.h&gt;</span>
<a href="#l19.11"></a><span id="l19.11"> </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-//	Purpose of this file is to implement an intermediate layer to our</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineminus">-//network 		services, the winsock. 	This intermediate layer will be able to</span>
<a href="#l19.14"></a><span id="l19.14" class="difflineminus">-//function with and without a working 		winsock being present. 	The attempt to</span>
<a href="#l19.15"></a><span id="l19.15" class="difflineminus">-//activate the winsock happens as would normally be expected,</span>
<a href="#l19.16"></a><span id="l19.16" class="difflineminus">-//              through the calling application's entry point to us, WSAStartup.</span>
<a href="#l19.17"></a><span id="l19.17" class="difflineplus">+// Purpose of this file is to implement an intermediate layer to our network</span>
<a href="#l19.18"></a><span id="l19.18" class="difflineplus">+// services, the winsock.</span>
<a href="#l19.19"></a><span id="l19.19" class="difflineplus">+// This intermediate layer will be able to function with and without a working</span>
<a href="#l19.20"></a><span id="l19.20" class="difflineplus">+// winsock being present.</span>
<a href="#l19.21"></a><span id="l19.21" class="difflineplus">+// The attempt to activate the winsock happens as would normally be expected,</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineplus">+// through the calling application's entry point to us, WSAStartup.</span>
<a href="#l19.23"></a><span id="l19.23"> </span>
<a href="#l19.24"></a><span id="l19.24" class="difflineminus">-//	Name of the winsock we would like to load.</span>
<a href="#l19.25"></a><span id="l19.25" class="difflineminus">-//	Diffs between OSs, Win32s is out in the cold if running 32 bits unless</span>
<a href="#l19.26"></a><span id="l19.26" class="difflineminus">-//		they also have a winsock name wsock32.dll.</span>
<a href="#l19.27"></a><span id="l19.27" class="difflineplus">+// Name of the winsock we would like to load.</span>
<a href="#l19.28"></a><span id="l19.28" class="difflineplus">+// Diffs between OSs, Win32s is out in the cold if running 32 bits unless</span>
<a href="#l19.29"></a><span id="l19.29" class="difflineplus">+// they also have a winsock name wsock32.dll.</span>
<a href="#l19.30"></a><span id="l19.30"> #ifndef _WIN32</span>
<a href="#l19.31"></a><span id="l19.31"> #  define SZWINSOCK &quot;winsock.dll&quot;</span>
<a href="#l19.32"></a><span id="l19.32"> #else</span>
<a href="#l19.33"></a><span id="l19.33"> #  define SZWINSOCK &quot;wsock32.dll&quot;</span>
<a href="#l19.34"></a><span id="l19.34"> #endif</span>
<a href="#l19.35"></a><span id="l19.35"> </span>
<a href="#l19.36"></a><span id="l19.36" class="difflineminus">-//	Here is the enumeration for the winsock functions we have currently</span>
<a href="#l19.37"></a><span id="l19.37" class="difflineminus">-//		overridden (needed to run).  Add more when needed.</span>
<a href="#l19.38"></a><span id="l19.38" class="difflineminus">-//	We use these to access proc addresses, and to hold a table of strings</span>
<a href="#l19.39"></a><span id="l19.39" class="difflineminus">-//		to obtain the proc addresses.</span>
<a href="#l19.40"></a><span id="l19.40" class="difflineplus">+// Here is the enumeration for the winsock functions we have currently</span>
<a href="#l19.41"></a><span id="l19.41" class="difflineplus">+// overridden (needed to run).  Add more when needed.</span>
<a href="#l19.42"></a><span id="l19.42" class="difflineplus">+// We use these to access proc addresses, and to hold a table of strings</span>
<a href="#l19.43"></a><span id="l19.43" class="difflineplus">+// to obtain the proc addresses.</span>
<a href="#l19.44"></a><span id="l19.44"> enum SockProc {</span>
<a href="#l19.45"></a><span id="l19.45">   sp_WSAAsyncGetHostByName = 0,</span>
<a href="#l19.46"></a><span id="l19.46">   sp_WSAAsyncSelect,</span>
<a href="#l19.47"></a><span id="l19.47">   sp_WSACleanup,</span>
<a href="#l19.48"></a><span id="l19.48">   sp_WSAGetLastError,</span>
<a href="#l19.49"></a><span id="l19.49">   sp_WSASetLastError,</span>
<a href="#l19.50"></a><span id="l19.50">   sp_WSAStartup,</span>
<a href="#l19.51"></a><span id="l19.51">   sp___WSAFDIsSet,</span>
<a href="#l19.52"></a><span id="l19.52" class="difflineat">@@ -91,22 +92,22 @@ enum SockProc {</span>
<a href="#l19.53"></a><span id="l19.53">   sp_recv,</span>
<a href="#l19.54"></a><span id="l19.54">   sp_select,</span>
<a href="#l19.55"></a><span id="l19.55">   sp_send,</span>
<a href="#l19.56"></a><span id="l19.56">   sp_setsockopt,</span>
<a href="#l19.57"></a><span id="l19.57">   sp_shutdown,</span>
<a href="#l19.58"></a><span id="l19.58">   sp_socket,</span>
<a href="#l19.59"></a><span id="l19.59">   sp_inet_ntoa,</span>
<a href="#l19.60"></a><span id="l19.60"> </span>
<a href="#l19.61"></a><span id="l19.61" class="difflineminus">-  sp_MaxProcs  //	Total count.</span>
<a href="#l19.62"></a><span id="l19.62" class="difflineplus">+  sp_MaxProcs  // Total count.</span>
<a href="#l19.63"></a><span id="l19.63"> };</span>
<a href="#l19.64"></a><span id="l19.64"> </span>
<a href="#l19.65"></a><span id="l19.65" class="difflineminus">-//	Array of function names used in GetProcAddress to fill in our</span>
<a href="#l19.66"></a><span id="l19.66" class="difflineminus">-//		proc array when needed.</span>
<a href="#l19.67"></a><span id="l19.67" class="difflineminus">-//	This array must match the enumerations exactly.</span>
<a href="#l19.68"></a><span id="l19.68" class="difflineplus">+// Array of function names used in GetProcAddress to fill in our</span>
<a href="#l19.69"></a><span id="l19.69" class="difflineplus">+// proc array when needed.</span>
<a href="#l19.70"></a><span id="l19.70" class="difflineplus">+// This array must match the enumerations exactly.</span>
<a href="#l19.71"></a><span id="l19.71"> char *spName[(int)sp_MaxProcs] = {&quot;WSAAsyncGetHostByName&quot;,</span>
<a href="#l19.72"></a><span id="l19.72">                                   &quot;WSAAsyncSelect&quot;,</span>
<a href="#l19.73"></a><span id="l19.73">                                   &quot;WSACleanup&quot;,</span>
<a href="#l19.74"></a><span id="l19.74">                                   &quot;WSAGetLastError&quot;,</span>
<a href="#l19.75"></a><span id="l19.75">                                   &quot;WSASetLastError&quot;,</span>
<a href="#l19.76"></a><span id="l19.76">                                   &quot;WSAStartup&quot;,</span>
<a href="#l19.77"></a><span id="l19.77">                                   &quot;__WSAFDIsSet&quot;,</span>
<a href="#l19.78"></a><span id="l19.78">                                   &quot;accept&quot;,</span>
<a href="#l19.79"></a><span id="l19.79" class="difflineat">@@ -130,27 +131,27 @@ char *spName[(int)sp_MaxProcs] = {&quot;WSAAs</span>
<a href="#l19.80"></a><span id="l19.80">                                   &quot;recv&quot;,</span>
<a href="#l19.81"></a><span id="l19.81">                                   &quot;select&quot;,</span>
<a href="#l19.82"></a><span id="l19.82">                                   &quot;send&quot;,</span>
<a href="#l19.83"></a><span id="l19.83">                                   &quot;setsockopt&quot;,</span>
<a href="#l19.84"></a><span id="l19.84">                                   &quot;shutdown&quot;,</span>
<a href="#l19.85"></a><span id="l19.85">                                   &quot;socket&quot;,</span>
<a href="#l19.86"></a><span id="l19.86">                                   &quot;inet_ntoa&quot;};</span>
<a href="#l19.87"></a><span id="l19.87"> </span>
<a href="#l19.88"></a><span id="l19.88" class="difflineminus">-//	Array of proc addresses to the winsock functions.</span>
<a href="#l19.89"></a><span id="l19.89" class="difflineminus">-//      These can be NULL, indicating their absence (as in the case we couldn't</span>
<a href="#l19.90"></a><span id="l19.90" class="difflineminus">-//              load the winsock.dll or one of the functions wasn't loaded).</span>
<a href="#l19.91"></a><span id="l19.91" class="difflineminus">-//	The procs assigned in must corellate with the enumerations exactly.</span>
<a href="#l19.92"></a><span id="l19.92" class="difflineplus">+// Array of proc addresses to the winsock functions.</span>
<a href="#l19.93"></a><span id="l19.93" class="difflineplus">+// These can be NULL, indicating their absence (as in the case we couldn't</span>
<a href="#l19.94"></a><span id="l19.94" class="difflineplus">+// load the winsock.dll or one of the functions wasn't loaded).</span>
<a href="#l19.95"></a><span id="l19.95" class="difflineplus">+// The procs assigned in must corellate with the enumerations exactly.</span>
<a href="#l19.96"></a><span id="l19.96"> FARPROC spArray[(int)sp_MaxProcs];</span>
<a href="#l19.97"></a><span id="l19.97"> </span>
<a href="#l19.98"></a><span id="l19.98" class="difflineminus">-//	Typedef all the different types of functions that we must cast the</span>
<a href="#l19.99"></a><span id="l19.99" class="difflineminus">-//		procs to in order to call without the compiler barfing.</span>
<a href="#l19.100"></a><span id="l19.100" class="difflineminus">-//	Prefix is always sp.</span>
<a href="#l19.101"></a><span id="l19.101" class="difflineminus">-//	Retval is next, spelled out.</span>
<a href="#l19.102"></a><span id="l19.102" class="difflineminus">-//	Parameters in their order are next, spelled out.</span>
<a href="#l19.103"></a><span id="l19.103" class="difflineplus">+// Typedef all the different types of functions that we must cast the</span>
<a href="#l19.104"></a><span id="l19.104" class="difflineplus">+// procs to in order to call without the compiler barfing.</span>
<a href="#l19.105"></a><span id="l19.105" class="difflineplus">+// Prefix is always sp.</span>
<a href="#l19.106"></a><span id="l19.106" class="difflineplus">+// Retval is next, spelled out.</span>
<a href="#l19.107"></a><span id="l19.107" class="difflineplus">+// Parameters in their order are next, spelled out.</span>
<a href="#l19.108"></a><span id="l19.108"> typedef int(PASCAL FAR *sp_int_WORD_LPWSADATA)(WORD, LPWSADATA);</span>
<a href="#l19.109"></a><span id="l19.109"> typedef int(PASCAL FAR *sp_int_void)(void);</span>
<a href="#l19.110"></a><span id="l19.110"> typedef HANDLE(PASCAL FAR *sp_HANDLE_HWND_uint_ccharFARp_charFARp_int)(</span>
<a href="#l19.111"></a><span id="l19.111">     HWND, unsigned int, const char FAR *, char FAR *, int);</span>
<a href="#l19.112"></a><span id="l19.112"> typedef int(PASCAL FAR *sp_int_SOCKET_HWND_uint_long)(SOCKET, HWND,</span>
<a href="#l19.113"></a><span id="l19.113">                                                       unsigned int, long);</span>
<a href="#l19.114"></a><span id="l19.114"> typedef void(PASCAL FAR *sp_void_int)(int);</span>
<a href="#l19.115"></a><span id="l19.115"> typedef int(PASCAL FAR *sp_int_SOCKET_fdsetFARp)(SOCKET, fd_set FAR *);</span>
<a href="#l19.116"></a><span id="l19.116" class="difflineat">@@ -185,21 +186,21 @@ typedef int(PASCAL FAR *sp_int_SOCKET_cc</span>
<a href="#l19.117"></a><span id="l19.117"> typedef int(PASCAL FAR *sp_int_SOCKET_int_int_ccharFARp_int)(SOCKET, int, int,</span>
<a href="#l19.118"></a><span id="l19.118">                                                              const char FAR *,</span>
<a href="#l19.119"></a><span id="l19.119">                                                              int);</span>
<a href="#l19.120"></a><span id="l19.120"> typedef SOCKET(PASCAL FAR *sp_SOCKET_int_int_int)(int, int, int);</span>
<a href="#l19.121"></a><span id="l19.121"> typedef char FAR *(PASCAL FAR *sp_charFARp_in_addr)(struct in_addr in);</span>
<a href="#l19.122"></a><span id="l19.122"> typedef struct protoent FAR *(PASCAL FAR *sp_protoentFARcchar)(</span>
<a href="#l19.123"></a><span id="l19.123">     const char FAR *);</span>
<a href="#l19.124"></a><span id="l19.124"> </span>
<a href="#l19.125"></a><span id="l19.125" class="difflineminus">-//	Handle to the winsock, if loaded.</span>
<a href="#l19.126"></a><span id="l19.126" class="difflineplus">+// Handle to the winsock, if loaded.</span>
<a href="#l19.127"></a><span id="l19.127"> HINSTANCE hWinsock = NULL;</span>
<a href="#l19.128"></a><span id="l19.128"> </span>
<a href="#l19.129"></a><span id="l19.129"> #ifndef _WIN32</span>
<a href="#l19.130"></a><span id="l19.130" class="difflineminus">-//	Last error code for the winsock.</span>
<a href="#l19.131"></a><span id="l19.131" class="difflineplus">+// Last error code for the winsock.</span>
<a href="#l19.132"></a><span id="l19.132"> int ispError = 0;</span>
<a href="#l19.133"></a><span id="l19.133"> #endif</span>
<a href="#l19.134"></a><span id="l19.134"> </span>
<a href="#l19.135"></a><span id="l19.135"> BOOL IsWinsockLoaded(int sp) {</span>
<a href="#l19.136"></a><span id="l19.136">   if (hWinsock == NULL) {</span>
<a href="#l19.137"></a><span id="l19.137">     WSADATA wsaData;</span>
<a href="#l19.138"></a><span id="l19.138"> #ifdef _WIN32</span>
<a href="#l19.139"></a><span id="l19.139">     static LONG sc_init = 0;</span>
<a href="#l19.140"></a><span id="l19.140" class="difflineat">@@ -218,33 +219,32 @@ BOOL IsWinsockLoaded(int sp) {</span>
<a href="#l19.141"></a><span id="l19.141">     if (hWinsock == NULL) {</span>
<a href="#l19.142"></a><span id="l19.142"> #endif</span>
<a href="#l19.143"></a><span id="l19.143">       WSAStartup(0x0101, &amp;wsaData);</span>
<a href="#l19.144"></a><span id="l19.144"> #ifdef _WIN32</span>
<a href="#l19.145"></a><span id="l19.145">     }</span>
<a href="#l19.146"></a><span id="l19.146">     LeaveCriticalSection(&amp;sc);</span>
<a href="#l19.147"></a><span id="l19.147"> #endif</span>
<a href="#l19.148"></a><span id="l19.148">   }</span>
<a href="#l19.149"></a><span id="l19.149" class="difflineminus">-//	Quick macro to tell if the winsock has actually loaded for a particular</span>
<a href="#l19.150"></a><span id="l19.150" class="difflineminus">-//		function.</span>
<a href="#l19.151"></a><span id="l19.151" class="difflineminus">-//  Debug version is a little more strict to make sure you get the names right.</span>
<a href="#l19.152"></a><span id="l19.152" class="difflineplus">+// Quick macro to tell if the winsock has actually loaded for a particular</span>
<a href="#l19.153"></a><span id="l19.153" class="difflineplus">+// function.</span>
<a href="#l19.154"></a><span id="l19.154" class="difflineplus">+// Debug version is a little more strict to make sure you get the names right.</span>
<a href="#l19.155"></a><span id="l19.155"> #ifdef DEBUG</span>
<a href="#l19.156"></a><span id="l19.156">   return hWinsock != NULL &amp;&amp; spArray[(int)(sp)] != NULL;</span>
<a href="#l19.157"></a><span id="l19.157" class="difflineminus">-#else  //  A little faster</span>
<a href="#l19.158"></a><span id="l19.158" class="difflineplus">+#else  // A little faster</span>
<a href="#l19.159"></a><span id="l19.159">   return hWinsock != NULL;</span>
<a href="#l19.160"></a><span id="l19.160"> #endif</span>
<a href="#l19.161"></a><span id="l19.161"> }</span>
<a href="#l19.162"></a><span id="l19.162"> </span>
<a href="#l19.163"></a><span id="l19.163" class="difflineminus">-//	Here are the functions that we have taken over by not directly linking</span>
<a href="#l19.164"></a><span id="l19.164" class="difflineminus">-//		with the winsock import library or importing through the def</span>
<a href="#l19.165"></a><span id="l19.165" class="difflineminus">-//file.</span>
<a href="#l19.166"></a><span id="l19.166" class="difflineplus">+// Here are the functions that we have taken over by not directly linking</span>
<a href="#l19.167"></a><span id="l19.167" class="difflineplus">+// with the winsock import library or importing through the def file.</span>
<a href="#l19.168"></a><span id="l19.168"> </span>
<a href="#l19.169"></a><span id="l19.169"> /* In win16 we simulate blocking commands as follows.  Prior to issuing the</span>
<a href="#l19.170"></a><span id="l19.170">  * command we make the socket not-blocking (WSAAsyncSelect does that).</span>
<a href="#l19.171"></a><span id="l19.171" class="difflineminus">- * We then issue the command and see if it would have blocked.	If so, we</span>
<a href="#l19.172"></a><span id="l19.172" class="difflineplus">+ * We then issue the command and see if it would have blocked.  If so, we</span>
<a href="#l19.173"></a><span id="l19.173">  * yield the processor and go to sleep until an event occurs that unblocks</span>
<a href="#l19.174"></a><span id="l19.174">  * us (WSAAsyncSelect allowed us to register what that condition is).  We</span>
<a href="#l19.175"></a><span id="l19.175">  * keep repeating until we do not get a would-block indication when issuing</span>
<a href="#l19.176"></a><span id="l19.176">  * the command.  At that time we unregister the notification condition and</span>
<a href="#l19.177"></a><span id="l19.177">  * return the result of the command to the caller.</span>
<a href="#l19.178"></a><span id="l19.178">  */</span>
<a href="#l19.179"></a><span id="l19.179"> </span>
<a href="#l19.180"></a><span id="l19.180"> //#ifndef _WIN32</span>
<a href="#l19.181"></a><span id="l19.181" class="difflineat">@@ -271,111 +271,111 @@ BOOL IsWinsockLoaded(int sp) {</span>
<a href="#l19.182"></a><span id="l19.182"> #else</span>
<a href="#l19.183"></a><span id="l19.183"> #  define NON_BLOCKING(command, condition, index, type) \</span>
<a href="#l19.184"></a><span id="l19.184">     if (IsWinsockLoaded(index)) {                       \</span>
<a href="#l19.185"></a><span id="l19.185">       return command;                                   \</span>
<a href="#l19.186"></a><span id="l19.186">     }</span>
<a href="#l19.187"></a><span id="l19.187"> #endif</span>
<a href="#l19.188"></a><span id="l19.188"> </span>
<a href="#l19.189"></a><span id="l19.189"> int PASCAL FAR WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData) {</span>
<a href="#l19.190"></a><span id="l19.190" class="difflineminus">-  //	Our default return value is failure, though we change this regardless.</span>
<a href="#l19.191"></a><span id="l19.191" class="difflineplus">+  // Our default return value is failure, though we change this regardless.</span>
<a href="#l19.192"></a><span id="l19.192">   int iRetval = WSAVERNOTSUPPORTED;</span>
<a href="#l19.193"></a><span id="l19.193">   HINSTANCE MyHandle;</span>
<a href="#l19.194"></a><span id="l19.194"> </span>
<a href="#l19.195"></a><span id="l19.195" class="difflineminus">-  //	Before doing anything, clear out our proc array.</span>
<a href="#l19.196"></a><span id="l19.196" class="difflineplus">+  // Before doing anything, clear out our proc array.</span>
<a href="#l19.197"></a><span id="l19.197">   memset(spArray, 0, sizeof(spArray));</span>
<a href="#l19.198"></a><span id="l19.198"> </span>
<a href="#l19.199"></a><span id="l19.199" class="difflineminus">-  //	attempt to load the real winsock.</span>
<a href="#l19.200"></a><span id="l19.200" class="difflineplus">+  // attempt to load the real winsock.</span>
<a href="#l19.201"></a><span id="l19.201">   MyHandle = LoadLibrary(SZWINSOCK);</span>
<a href="#l19.202"></a><span id="l19.202"> #ifdef _WIN32</span>
<a href="#l19.203"></a><span id="l19.203">   if (MyHandle != NULL) {</span>
<a href="#l19.204"></a><span id="l19.204"> #else</span>
<a href="#l19.205"></a><span id="l19.205">   if (MyHandle &gt; HINSTANCE_ERROR) {</span>
<a href="#l19.206"></a><span id="l19.206"> #endif</span>
<a href="#l19.207"></a><span id="l19.207" class="difflineminus">-    //	Winsock was loaded.</span>
<a href="#l19.208"></a><span id="l19.208" class="difflineminus">-    //	Get the proc addresses for each needed function next.</span>
<a href="#l19.209"></a><span id="l19.209" class="difflineplus">+    // Winsock was loaded.</span>
<a href="#l19.210"></a><span id="l19.210" class="difflineplus">+    // Get the proc addresses for each needed function next.</span>
<a href="#l19.211"></a><span id="l19.211">     int spTraverse;</span>
<a href="#l19.212"></a><span id="l19.212">     for (spTraverse = 0; spTraverse &lt; (int)sp_MaxProcs; spTraverse++) {</span>
<a href="#l19.213"></a><span id="l19.213">       spArray[spTraverse] = GetProcAddress(MyHandle, spName[spTraverse]);</span>
<a href="#l19.214"></a><span id="l19.214">       if (NULL == spArray[spTraverse])</span>
<a href="#l19.215"></a><span id="l19.215" class="difflineminus">-        return iRetval;  //	Bad winsock?  Bad function name?</span>
<a href="#l19.216"></a><span id="l19.216" class="difflineplus">+        return iRetval;  // Bad winsock? Bad function name?</span>
<a href="#l19.217"></a><span id="l19.217">     }</span>
<a href="#l19.218"></a><span id="l19.218"> </span>
<a href="#l19.219"></a><span id="l19.219">     hWinsock = MyHandle;</span>
<a href="#l19.220"></a><span id="l19.220" class="difflineminus">-    //	AllRight, attempt to make our first proxied call.</span>
<a href="#l19.221"></a><span id="l19.221" class="difflineplus">+    // AllRight, attempt to make our first proxied call.</span>
<a href="#l19.222"></a><span id="l19.222">     if (IsWinsockLoaded(sp_WSAStartup)) {</span>
<a href="#l19.223"></a><span id="l19.223">       iRetval = ((sp_int_WORD_LPWSADATA)spArray[sp_WSAStartup])(</span>
<a href="#l19.224"></a><span id="l19.224">           wVersionRequested, lpWSAData);</span>
<a href="#l19.225"></a><span id="l19.225">     }</span>
<a href="#l19.226"></a><span id="l19.226"> </span>
<a href="#l19.227"></a><span id="l19.227" class="difflineminus">-    //	If the return value is still an error at this point, we unload the DLL,</span>
<a href="#l19.228"></a><span id="l19.228" class="difflineminus">-    //		so that we can act as though nothing happened and the user</span>
<a href="#l19.229"></a><span id="l19.229" class="difflineminus">-    //		gets no network access.</span>
<a href="#l19.230"></a><span id="l19.230" class="difflineplus">+    // If the return value is still an error at this point, we unload the DLL,</span>
<a href="#l19.231"></a><span id="l19.231" class="difflineplus">+    // so that we can act as though nothing happened and the user</span>
<a href="#l19.232"></a><span id="l19.232" class="difflineplus">+    // gets no network access.</span>
<a href="#l19.233"></a><span id="l19.233">     if (iRetval != 0) {</span>
<a href="#l19.234"></a><span id="l19.234" class="difflineminus">-      //	Clear out our proc array.</span>
<a href="#l19.235"></a><span id="l19.235" class="difflineplus">+      // Clear out our proc array.</span>
<a href="#l19.236"></a><span id="l19.236">       memset(spArray, 0, sizeof(spArray));</span>
<a href="#l19.237"></a><span id="l19.237"> </span>
<a href="#l19.238"></a><span id="l19.238" class="difflineminus">-      //	Free up the winsock.</span>
<a href="#l19.239"></a><span id="l19.239" class="difflineplus">+      // Free up the winsock.</span>
<a href="#l19.240"></a><span id="l19.240">       FreeLibrary(MyHandle);</span>
<a href="#l19.241"></a><span id="l19.241">       MyHandle = NULL;</span>
<a href="#l19.242"></a><span id="l19.242">     }</span>
<a href="#l19.243"></a><span id="l19.243">   }</span>
<a href="#l19.244"></a><span id="l19.244"> #ifndef _WIN32</span>
<a href="#l19.245"></a><span id="l19.245">   else {</span>
<a href="#l19.246"></a><span id="l19.246" class="difflineminus">-    //	Failed to load.</span>
<a href="#l19.247"></a><span id="l19.247" class="difflineminus">-    //	Set this to NULL so it is clear.</span>
<a href="#l19.248"></a><span id="l19.248" class="difflineplus">+    // Failed to load.</span>
<a href="#l19.249"></a><span id="l19.249" class="difflineplus">+    // Set this to NULL so it is clear.</span>
<a href="#l19.250"></a><span id="l19.250">     hWinsock = NULL;</span>
<a href="#l19.251"></a><span id="l19.251">   }</span>
<a href="#l19.252"></a><span id="l19.252"> #endif</span>
<a href="#l19.253"></a><span id="l19.253"> </span>
<a href="#l19.254"></a><span id="l19.254" class="difflineminus">-  //      Check our return value, if it isn't success, then we need to fake</span>
<a href="#l19.255"></a><span id="l19.255" class="difflineminus">-  //		our own winsock implementation.</span>
<a href="#l19.256"></a><span id="l19.256" class="difflineplus">+  // Check our return value, if it isn't success, then we need to fake</span>
<a href="#l19.257"></a><span id="l19.257" class="difflineplus">+  // our own winsock implementation.</span>
<a href="#l19.258"></a><span id="l19.258">   if (iRetval != 0) {</span>
<a href="#l19.259"></a><span id="l19.259" class="difflineminus">-    //	We always return success.</span>
<a href="#l19.260"></a><span id="l19.260" class="difflineplus">+    // We always return success.</span>
<a href="#l19.261"></a><span id="l19.261">     iRetval = 0;</span>
<a href="#l19.262"></a><span id="l19.262"> </span>
<a href="#l19.263"></a><span id="l19.263" class="difflineminus">-    //	Fill in the structure.</span>
<a href="#l19.264"></a><span id="l19.264" class="difflineminus">-    //	Return the version requested as the version supported.</span>
<a href="#l19.265"></a><span id="l19.265" class="difflineplus">+    // Fill in the structure.</span>
<a href="#l19.266"></a><span id="l19.266" class="difflineplus">+    // Return the version requested as the version supported.</span>
<a href="#l19.267"></a><span id="l19.267">     lpWSAData-&gt;wVersion = wVersionRequested;</span>
<a href="#l19.268"></a><span id="l19.268">     lpWSAData-&gt;wHighVersion = wVersionRequested;</span>
<a href="#l19.269"></a><span id="l19.269"> </span>
<a href="#l19.270"></a><span id="l19.270" class="difflineminus">-    //	Fill in a description.</span>
<a href="#l19.271"></a><span id="l19.271" class="difflineplus">+    // Fill in a description.</span>
<a href="#l19.272"></a><span id="l19.272">     strcpy(lpWSAData-&gt;szDescription, &quot;Mozock DLL internal implementation.&quot;);</span>
<a href="#l19.273"></a><span id="l19.273">     strcpy(lpWSAData-&gt;szSystemStatus,</span>
<a href="#l19.274"></a><span id="l19.274">            &quot;Winsock running, allowing no network access.&quot;);</span>
<a href="#l19.275"></a><span id="l19.275"> </span>
<a href="#l19.276"></a><span id="l19.276" class="difflineminus">-    //	Report a nice round number for sockets and datagram sizes.</span>
<a href="#l19.277"></a><span id="l19.277" class="difflineplus">+    // Report a nice round number for sockets and datagram sizes.</span>
<a href="#l19.278"></a><span id="l19.278">     lpWSAData-&gt;iMaxSockets = 4096;</span>
<a href="#l19.279"></a><span id="l19.279">     lpWSAData-&gt;iMaxUdpDg = 4096;</span>
<a href="#l19.280"></a><span id="l19.280"> </span>
<a href="#l19.281"></a><span id="l19.281" class="difflineminus">-    //	No vendor information.</span>
<a href="#l19.282"></a><span id="l19.282" class="difflineplus">+    // No vendor information.</span>
<a href="#l19.283"></a><span id="l19.283">     lpWSAData-&gt;lpVendorInfo = NULL;</span>
<a href="#l19.284"></a><span id="l19.284">   }</span>
<a href="#l19.285"></a><span id="l19.285"> </span>
<a href="#l19.286"></a><span id="l19.286">   return (iRetval);</span>
<a href="#l19.287"></a><span id="l19.287"> }</span>
<a href="#l19.288"></a><span id="l19.288"> </span>
<a href="#l19.289"></a><span id="l19.289"> int PASCAL FAR WSACleanup(void) {</span>
<a href="#l19.290"></a><span id="l19.290">   int iRetval = 0;</span>
<a href="#l19.291"></a><span id="l19.291"> </span>
<a href="#l19.292"></a><span id="l19.292" class="difflineminus">-  //	Handling normally or internally.</span>
<a href="#l19.293"></a><span id="l19.293" class="difflineplus">+  // Handling normally or internally.</span>
<a href="#l19.294"></a><span id="l19.294">   // When IsWinsockLoaded() is called and hWinsock is NULL, it winds up calling</span>
<a href="#l19.295"></a><span id="l19.295">   // WSAStartup which wedges rpcrt4.dll on win95 with some winsock</span>
<a href="#l19.296"></a><span id="l19.296">   // implementations. Bug: 81359.</span>
<a href="#l19.297"></a><span id="l19.297">   if (hWinsock &amp;&amp; IsWinsockLoaded(sp_WSACleanup)) {</span>
<a href="#l19.298"></a><span id="l19.298" class="difflineminus">-    //	Call their cleanup routine.</span>
<a href="#l19.299"></a><span id="l19.299" class="difflineminus">-    //	We could set the return value here, but it is meaning less.</span>
<a href="#l19.300"></a><span id="l19.300" class="difflineminus">-    //	We always return success.</span>
<a href="#l19.301"></a><span id="l19.301" class="difflineplus">+    // Call their cleanup routine.</span>
<a href="#l19.302"></a><span id="l19.302" class="difflineplus">+    // We could set the return value here, but it is meaning less.</span>
<a href="#l19.303"></a><span id="l19.303" class="difflineplus">+    // We always return success.</span>
<a href="#l19.304"></a><span id="l19.304">     iRetval = ((sp_int_void)spArray[sp_WSACleanup])();</span>
<a href="#l19.305"></a><span id="l19.305">     // ASSERT(iRetval == 0);</span>
<a href="#l19.306"></a><span id="l19.306">     iRetval = 0;</span>
<a href="#l19.307"></a><span id="l19.307">   }</span>
<a href="#l19.308"></a><span id="l19.308"> </span>
<a href="#l19.309"></a><span id="l19.309" class="difflineminus">-  //	Whether or not it succeeded, we free off the library here.</span>
<a href="#l19.310"></a><span id="l19.310" class="difflineminus">-  //	Clear out our proc table too.</span>
<a href="#l19.311"></a><span id="l19.311" class="difflineplus">+  // Whether or not it succeeded, we free off the library here.</span>
<a href="#l19.312"></a><span id="l19.312" class="difflineplus">+  // Clear out our proc table too.</span>
<a href="#l19.313"></a><span id="l19.313">   memset(spArray, 0, sizeof(spArray));</span>
<a href="#l19.314"></a><span id="l19.314">   if (hWinsock != NULL) {</span>
<a href="#l19.315"></a><span id="l19.315">     FreeLibrary(hWinsock);</span>
<a href="#l19.316"></a><span id="l19.316">     hWinsock = NULL;</span>
<a href="#l19.317"></a><span id="l19.317">   }</span>
<a href="#l19.318"></a><span id="l19.318"> </span>
<a href="#l19.319"></a><span id="l19.319">   return (iRetval);</span>
<a href="#l19.320"></a><span id="l19.320"> }</span>
<a href="#l19.321"></a><span id="l19.321" class="difflineat">@@ -385,136 +385,136 @@ HANDLE PASCAL FAR WSAAsyncGetHostByName(</span>
<a href="#l19.322"></a><span id="l19.322">                                         int buflen) {</span>
<a href="#l19.323"></a><span id="l19.323">   // Normal or shim.</span>
<a href="#l19.324"></a><span id="l19.324">   if (IsWinsockLoaded(sp_WSAAsyncGetHostByName)) {</span>
<a href="#l19.325"></a><span id="l19.325">     return (</span>
<a href="#l19.326"></a><span id="l19.326">         ((sp_HANDLE_HWND_uint_ccharFARp_charFARp_int)</span>
<a href="#l19.327"></a><span id="l19.327">              spArray[sp_WSAAsyncGetHostByName])(hWnd, wMsg, name, buf, buflen));</span>
<a href="#l19.328"></a><span id="l19.328">   }</span>
<a href="#l19.329"></a><span id="l19.329"> </span>
<a href="#l19.330"></a><span id="l19.330" class="difflineminus">-  //	Must return error here.</span>
<a href="#l19.331"></a><span id="l19.331" class="difflineminus">-  //	Set our last error value to be that the net is down.</span>
<a href="#l19.332"></a><span id="l19.332" class="difflineplus">+  // Must return error here.</span>
<a href="#l19.333"></a><span id="l19.333" class="difflineplus">+  // Set our last error value to be that the net is down.</span>
<a href="#l19.334"></a><span id="l19.334">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.335"></a><span id="l19.335">   return (NULL);</span>
<a href="#l19.336"></a><span id="l19.336"> }</span>
<a href="#l19.337"></a><span id="l19.337"> </span>
<a href="#l19.338"></a><span id="l19.338"> int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, unsigned int wMsg,</span>
<a href="#l19.339"></a><span id="l19.339">                               long lEvent) {</span>
<a href="#l19.340"></a><span id="l19.340" class="difflineminus">-  //	Normal or shim.</span>
<a href="#l19.341"></a><span id="l19.341" class="difflineplus">+  // Normal or shim.</span>
<a href="#l19.342"></a><span id="l19.342">   if (IsWinsockLoaded(sp_WSAAsyncSelect)) {</span>
<a href="#l19.343"></a><span id="l19.343">     return (((sp_int_SOCKET_HWND_uint_long)spArray[sp_WSAAsyncSelect])(</span>
<a href="#l19.344"></a><span id="l19.344">         s, hWnd, wMsg, lEvent));</span>
<a href="#l19.345"></a><span id="l19.345">   }</span>
<a href="#l19.346"></a><span id="l19.346"> </span>
<a href="#l19.347"></a><span id="l19.347" class="difflineminus">-  //	Must return error here.</span>
<a href="#l19.348"></a><span id="l19.348" class="difflineplus">+  // Must return error here.</span>
<a href="#l19.349"></a><span id="l19.349">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.350"></a><span id="l19.350">   return (SOCKET_ERROR);</span>
<a href="#l19.351"></a><span id="l19.351"> }</span>
<a href="#l19.352"></a><span id="l19.352"> </span>
<a href="#l19.353"></a><span id="l19.353"> int PASCAL FAR WSAGetLastError(void) {</span>
<a href="#l19.354"></a><span id="l19.354" class="difflineminus">-  //	See if someone else can handle.</span>
<a href="#l19.355"></a><span id="l19.355" class="difflineplus">+  // See if someone else can handle.</span>
<a href="#l19.356"></a><span id="l19.356">   if (IsWinsockLoaded(sp_WSAGetLastError)) {</span>
<a href="#l19.357"></a><span id="l19.357">     return (((sp_int_void)spArray[sp_WSAGetLastError])());</span>
<a href="#l19.358"></a><span id="l19.358">   }</span>
<a href="#l19.359"></a><span id="l19.359"> </span>
<a href="#l19.360"></a><span id="l19.360"> #ifndef _WIN32</span>
<a href="#l19.361"></a><span id="l19.361">   {</span>
<a href="#l19.362"></a><span id="l19.362" class="difflineminus">-    //	Fake it.</span>
<a href="#l19.363"></a><span id="l19.363" class="difflineplus">+    // Fake it.</span>
<a href="#l19.364"></a><span id="l19.364">     int iRetval = ispError;</span>
<a href="#l19.365"></a><span id="l19.365">     ispError = 0;</span>
<a href="#l19.366"></a><span id="l19.366">     return (iRetval);</span>
<a href="#l19.367"></a><span id="l19.367">   }</span>
<a href="#l19.368"></a><span id="l19.368"> #else</span>
<a href="#l19.369"></a><span id="l19.369" class="difflineminus">-  //	Use default OS handler.</span>
<a href="#l19.370"></a><span id="l19.370" class="difflineplus">+  // Use default OS handler.</span>
<a href="#l19.371"></a><span id="l19.371">   return (GetLastError());</span>
<a href="#l19.372"></a><span id="l19.372"> #endif</span>
<a href="#l19.373"></a><span id="l19.373"> }</span>
<a href="#l19.374"></a><span id="l19.374"> </span>
<a href="#l19.375"></a><span id="l19.375"> void PASCAL FAR WSASetLastError(int iError) {</span>
<a href="#l19.376"></a><span id="l19.376" class="difflineminus">-  //	See if someone else can handle.</span>
<a href="#l19.377"></a><span id="l19.377" class="difflineplus">+  // See if someone else can handle.</span>
<a href="#l19.378"></a><span id="l19.378">   if (IsWinsockLoaded(sp_WSASetLastError)) {</span>
<a href="#l19.379"></a><span id="l19.379">     ((sp_void_int)spArray[sp_WSASetLastError])(iError);</span>
<a href="#l19.380"></a><span id="l19.380">     return;</span>
<a href="#l19.381"></a><span id="l19.381">   }</span>
<a href="#l19.382"></a><span id="l19.382"> </span>
<a href="#l19.383"></a><span id="l19.383"> #ifndef _WIN32</span>
<a href="#l19.384"></a><span id="l19.384" class="difflineminus">-  //	Fake it.</span>
<a href="#l19.385"></a><span id="l19.385" class="difflineplus">+  // Fake it.</span>
<a href="#l19.386"></a><span id="l19.386">   ispError = iError;</span>
<a href="#l19.387"></a><span id="l19.387">   return;</span>
<a href="#l19.388"></a><span id="l19.388"> #else</span>
<a href="#l19.389"></a><span id="l19.389" class="difflineminus">-  //	Use default OS handler.</span>
<a href="#l19.390"></a><span id="l19.390" class="difflineplus">+  // Use default OS handler.</span>
<a href="#l19.391"></a><span id="l19.391">   SetLastError(iError);</span>
<a href="#l19.392"></a><span id="l19.392">   return;</span>
<a href="#l19.393"></a><span id="l19.393"> #endif</span>
<a href="#l19.394"></a><span id="l19.394"> }</span>
<a href="#l19.395"></a><span id="l19.395"> </span>
<a href="#l19.396"></a><span id="l19.396"> int PASCAL FAR __WSAFDIsSet(SOCKET fd, fd_set FAR *set) {</span>
<a href="#l19.397"></a><span id="l19.397">   int i;</span>
<a href="#l19.398"></a><span id="l19.398"> </span>
<a href="#l19.399"></a><span id="l19.399" class="difflineminus">-  //	See if someone else will handle.</span>
<a href="#l19.400"></a><span id="l19.400" class="difflineplus">+  // See if someone else will handle.</span>
<a href="#l19.401"></a><span id="l19.401">   if (IsWinsockLoaded(sp___WSAFDIsSet)) {</span>
<a href="#l19.402"></a><span id="l19.402">     return (((sp_int_SOCKET_fdsetFARp)spArray[sp___WSAFDIsSet])(fd, set));</span>
<a href="#l19.403"></a><span id="l19.403">   }</span>
<a href="#l19.404"></a><span id="l19.404"> </span>
<a href="#l19.405"></a><span id="l19.405" class="difflineminus">-  //	Default implementation.</span>
<a href="#l19.406"></a><span id="l19.406" class="difflineplus">+  // Default implementation.</span>
<a href="#l19.407"></a><span id="l19.407">   i = set-&gt;fd_count;</span>
<a href="#l19.408"></a><span id="l19.408">   while (i--) {</span>
<a href="#l19.409"></a><span id="l19.409">     if (set-&gt;fd_array[i] == fd) {</span>
<a href="#l19.410"></a><span id="l19.410">       return 1;</span>
<a href="#l19.411"></a><span id="l19.411">     }</span>
<a href="#l19.412"></a><span id="l19.412">   }</span>
<a href="#l19.413"></a><span id="l19.413">   return 0;</span>
<a href="#l19.414"></a><span id="l19.414"> }</span>
<a href="#l19.415"></a><span id="l19.415"> </span>
<a href="#l19.416"></a><span id="l19.416"> SOCKET PASCAL FAR accept(SOCKET s, struct sockaddr FAR *addr,</span>
<a href="#l19.417"></a><span id="l19.417">                          int FAR *addrlen) {</span>
<a href="#l19.418"></a><span id="l19.418" class="difflineminus">-  //	Internally or shim</span>
<a href="#l19.419"></a><span id="l19.419" class="difflineplus">+  // Internally or shim</span>
<a href="#l19.420"></a><span id="l19.420">   NON_BLOCKING((((sp_SOCKET_SOCKET_sockaddrFARp_intFARp)spArray[sp_accept])(</span>
<a href="#l19.421"></a><span id="l19.421">                    s, addr, addrlen)),</span>
<a href="#l19.422"></a><span id="l19.422">                FD_ACCEPT, sp_accept, SOCKET);</span>
<a href="#l19.423"></a><span id="l19.423"> </span>
<a href="#l19.424"></a><span id="l19.424" class="difflineminus">-  //	Fail.</span>
<a href="#l19.425"></a><span id="l19.425" class="difflineplus">+  // Fail.</span>
<a href="#l19.426"></a><span id="l19.426">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.427"></a><span id="l19.427">   return (INVALID_SOCKET);</span>
<a href="#l19.428"></a><span id="l19.428"> }</span>
<a href="#l19.429"></a><span id="l19.429"> </span>
<a href="#l19.430"></a><span id="l19.430"> int PASCAL FAR bind(SOCKET s, const struct sockaddr FAR *name, int namelen) {</span>
<a href="#l19.431"></a><span id="l19.431" class="difflineminus">-  //	Internally or shim</span>
<a href="#l19.432"></a><span id="l19.432" class="difflineplus">+  // Internally or shim</span>
<a href="#l19.433"></a><span id="l19.433">   if (IsWinsockLoaded(sp_bind)) {</span>
<a href="#l19.434"></a><span id="l19.434">     return (</span>
<a href="#l19.435"></a><span id="l19.435">         ((sp_int_SOCKET_csockaddrFARp_int)spArray[sp_bind])(s, name, namelen));</span>
<a href="#l19.436"></a><span id="l19.436">   }</span>
<a href="#l19.437"></a><span id="l19.437"> </span>
<a href="#l19.438"></a><span id="l19.438" class="difflineminus">-  //	Fail.</span>
<a href="#l19.439"></a><span id="l19.439" class="difflineplus">+  // Fail.</span>
<a href="#l19.440"></a><span id="l19.440">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.441"></a><span id="l19.441">   return (SOCKET_ERROR);</span>
<a href="#l19.442"></a><span id="l19.442"> }</span>
<a href="#l19.443"></a><span id="l19.443"> </span>
<a href="#l19.444"></a><span id="l19.444"> int PASCAL FAR closesocket(SOCKET s) {</span>
<a href="#l19.445"></a><span id="l19.445" class="difflineminus">-  //	Internally or shim.</span>
<a href="#l19.446"></a><span id="l19.446" class="difflineplus">+  // Internally or shim.</span>
<a href="#l19.447"></a><span id="l19.447">   NON_BLOCKING((((sp_int_SOCKET)spArray[sp_closesocket])(s)), FD_CLOSE,</span>
<a href="#l19.448"></a><span id="l19.448">                sp_closesocket, int);</span>
<a href="#l19.449"></a><span id="l19.449"> </span>
<a href="#l19.450"></a><span id="l19.450" class="difflineminus">-  //	Error.</span>
<a href="#l19.451"></a><span id="l19.451" class="difflineplus">+  // Error.</span>
<a href="#l19.452"></a><span id="l19.452">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.453"></a><span id="l19.453">   return (SOCKET_ERROR);</span>
<a href="#l19.454"></a><span id="l19.454"> }</span>
<a href="#l19.455"></a><span id="l19.455"> </span>
<a href="#l19.456"></a><span id="l19.456"> int PASCAL FAR connect(SOCKET s, const struct sockaddr FAR *name, int namelen) {</span>
<a href="#l19.457"></a><span id="l19.457" class="difflineminus">-  //	Internally or shim.</span>
<a href="#l19.458"></a><span id="l19.458" class="difflineplus">+  // Internally or shim.</span>
<a href="#l19.459"></a><span id="l19.459">   if (IsWinsockLoaded(sp_connect)) {</span>
<a href="#l19.460"></a><span id="l19.460">     /* This could block and so it would seem that the NON_BLOCK</span>
<a href="#l19.461"></a><span id="l19.461">      * macro should be used here.  However it was causing a crash</span>
<a href="#l19.462"></a><span id="l19.462">      * and so it was decided to allow blocking here instead</span>
<a href="#l19.463"></a><span id="l19.463">      */</span>
<a href="#l19.464"></a><span id="l19.464">     return (((sp_int_SOCKET_csockaddrFARp_int)spArray[sp_connect])(s, name,</span>
<a href="#l19.465"></a><span id="l19.465">                                                                    namelen));</span>
<a href="#l19.466"></a><span id="l19.466">   }</span>
<a href="#l19.467"></a><span id="l19.467"> </span>
<a href="#l19.468"></a><span id="l19.468" class="difflineminus">-  //	Err.</span>
<a href="#l19.469"></a><span id="l19.469" class="difflineplus">+  // Err.</span>
<a href="#l19.470"></a><span id="l19.470">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.471"></a><span id="l19.471">   return (SOCKET_ERROR);</span>
<a href="#l19.472"></a><span id="l19.472"> }</span>
<a href="#l19.473"></a><span id="l19.473"> </span>
<a href="#l19.474"></a><span id="l19.474"> struct hostent FAR *PASCAL FAR gethostbyname(const char FAR *name) {</span>
<a href="#l19.475"></a><span id="l19.475">   if (IsWinsockLoaded(sp_gethostbyname)) {</span>
<a href="#l19.476"></a><span id="l19.476">     return (((sp_hostentFARp_ccharFARp)spArray[sp_gethostbyname])(name));</span>
<a href="#l19.477"></a><span id="l19.477">   }</span>
<a href="#l19.478"></a><span id="l19.478" class="difflineat">@@ -590,60 +590,60 @@ u_long PASCAL FAR htonl(u_long hostlong)</span>
<a href="#l19.479"></a><span id="l19.479">     return (((sp_ulong_ulong)spArray[sp_htonl])(hostlong));</span>
<a href="#l19.480"></a><span id="l19.480">   }</span>
<a href="#l19.481"></a><span id="l19.481"> </span>
<a href="#l19.482"></a><span id="l19.482"> #ifndef _WIN32</span>
<a href="#l19.483"></a><span id="l19.483">   return (((hostlong &amp; 0xff) &lt;&lt; 24) + ((hostlong &amp; 0xff00) &lt;&lt; 8) +</span>
<a href="#l19.484"></a><span id="l19.484">           ((hostlong &amp; 0xff0000) &gt;&gt; 8) + ((hostlong &amp; 0xff000000) &gt;&gt; 24));</span>
<a href="#l19.485"></a><span id="l19.485"> </span>
<a href="#l19.486"></a><span id="l19.486"> #else</span>
<a href="#l19.487"></a><span id="l19.487" class="difflineminus">-  //	Just return what was passed in.</span>
<a href="#l19.488"></a><span id="l19.488" class="difflineplus">+  // Just return what was passed in.</span>
<a href="#l19.489"></a><span id="l19.489">   return (hostlong);</span>
<a href="#l19.490"></a><span id="l19.490"> #endif</span>
<a href="#l19.491"></a><span id="l19.491"> }</span>
<a href="#l19.492"></a><span id="l19.492"> </span>
<a href="#l19.493"></a><span id="l19.493"> u_short PASCAL FAR htons(u_short hostshort) {</span>
<a href="#l19.494"></a><span id="l19.494">   if (IsWinsockLoaded(sp_htons)) {</span>
<a href="#l19.495"></a><span id="l19.495">     return (((sp_ushort_ushort)spArray[sp_htons])(hostshort));</span>
<a href="#l19.496"></a><span id="l19.496">   }</span>
<a href="#l19.497"></a><span id="l19.497"> </span>
<a href="#l19.498"></a><span id="l19.498"> #ifndef _WIN32</span>
<a href="#l19.499"></a><span id="l19.499">   return (((hostshort &amp; 0xff) &lt;&lt; 8) + ((hostshort &amp; 0xff00) &gt;&gt; 8));</span>
<a href="#l19.500"></a><span id="l19.500"> </span>
<a href="#l19.501"></a><span id="l19.501"> #else</span>
<a href="#l19.502"></a><span id="l19.502" class="difflineminus">-  //	Just return what was passed in.</span>
<a href="#l19.503"></a><span id="l19.503" class="difflineplus">+  // Just return what was passed in.</span>
<a href="#l19.504"></a><span id="l19.504">   return (hostshort);</span>
<a href="#l19.505"></a><span id="l19.505"> #endif</span>
<a href="#l19.506"></a><span id="l19.506"> }</span>
<a href="#l19.507"></a><span id="l19.507"> </span>
<a href="#l19.508"></a><span id="l19.508"> u_long PASCAL FAR ntohl(u_long hostlong) {</span>
<a href="#l19.509"></a><span id="l19.509">   if (IsWinsockLoaded(sp_ntohl)) {</span>
<a href="#l19.510"></a><span id="l19.510">     return (((sp_ulong_ulong)spArray[sp_ntohl])(hostlong));</span>
<a href="#l19.511"></a><span id="l19.511">   }</span>
<a href="#l19.512"></a><span id="l19.512"> </span>
<a href="#l19.513"></a><span id="l19.513"> #ifndef _WIN32</span>
<a href="#l19.514"></a><span id="l19.514">   return (((hostlong &amp; 0xff) &lt;&lt; 24) + ((hostlong &amp; 0xff00) &lt;&lt; 8) +</span>
<a href="#l19.515"></a><span id="l19.515">           ((hostlong &amp; 0xff0000) &gt;&gt; 8) + ((hostlong &amp; 0xff000000) &gt;&gt; 24));</span>
<a href="#l19.516"></a><span id="l19.516"> </span>
<a href="#l19.517"></a><span id="l19.517"> #else</span>
<a href="#l19.518"></a><span id="l19.518" class="difflineminus">-  //	Just return what was passed in.</span>
<a href="#l19.519"></a><span id="l19.519" class="difflineplus">+  // Just return what was passed in.</span>
<a href="#l19.520"></a><span id="l19.520">   return (hostlong);</span>
<a href="#l19.521"></a><span id="l19.521"> #endif</span>
<a href="#l19.522"></a><span id="l19.522"> }</span>
<a href="#l19.523"></a><span id="l19.523"> </span>
<a href="#l19.524"></a><span id="l19.524"> u_short PASCAL FAR ntohs(u_short hostshort) {</span>
<a href="#l19.525"></a><span id="l19.525">   if (IsWinsockLoaded(sp_ntohs)) {</span>
<a href="#l19.526"></a><span id="l19.526">     return (((sp_ushort_ushort)spArray[sp_ntohs])(hostshort));</span>
<a href="#l19.527"></a><span id="l19.527">   }</span>
<a href="#l19.528"></a><span id="l19.528"> </span>
<a href="#l19.529"></a><span id="l19.529"> #ifndef _WIN32</span>
<a href="#l19.530"></a><span id="l19.530">   return (((hostshort &amp; 0xff) &lt;&lt; 8) + ((hostshort &amp; 0xff00) &gt;&gt; 8));</span>
<a href="#l19.531"></a><span id="l19.531"> </span>
<a href="#l19.532"></a><span id="l19.532"> #else</span>
<a href="#l19.533"></a><span id="l19.533" class="difflineminus">-  //	Just return what was passed in.</span>
<a href="#l19.534"></a><span id="l19.534" class="difflineplus">+  // Just return what was passed in.</span>
<a href="#l19.535"></a><span id="l19.535">   return (hostshort);</span>
<a href="#l19.536"></a><span id="l19.536"> #endif</span>
<a href="#l19.537"></a><span id="l19.537"> }</span>
<a href="#l19.538"></a><span id="l19.538"> </span>
<a href="#l19.539"></a><span id="l19.539"> unsigned long PASCAL FAR inet_addr(const char FAR *cp) {</span>
<a href="#l19.540"></a><span id="l19.540">   if (IsWinsockLoaded(sp_inet_addr)) {</span>
<a href="#l19.541"></a><span id="l19.541">     return (((sp_ulong_ccharFARp)spArray[sp_inet_addr])(cp));</span>
<a href="#l19.542"></a><span id="l19.542">   }</span>
<a href="#l19.543"></a><span id="l19.543" class="difflineat">@@ -677,31 +677,31 @@ int PASCAL FAR recv(SOCKET s, char FAR *</span>
<a href="#l19.544"></a><span id="l19.544"> </span>
<a href="#l19.545"></a><span id="l19.545">   WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.546"></a><span id="l19.546">   return (SOCKET_ERROR);</span>
<a href="#l19.547"></a><span id="l19.547"> }</span>
<a href="#l19.548"></a><span id="l19.548"> </span>
<a href="#l19.549"></a><span id="l19.549"> int PASCAL FAR select(int nfds, fd_set FAR *readfds, fd_set FAR *writefds,</span>
<a href="#l19.550"></a><span id="l19.550">                       fd_set FAR *exceptfds,</span>
<a href="#l19.551"></a><span id="l19.551">                       const struct timeval FAR *timeout) {</span>
<a href="#l19.552"></a><span id="l19.552" class="difflineminus">-  //  If there's nothing to do, stop now before we go off into dll land.</span>
<a href="#l19.553"></a><span id="l19.553" class="difflineminus">-  //	Optimization, boyz.</span>
<a href="#l19.554"></a><span id="l19.554" class="difflineplus">+  // If there's nothing to do, stop now before we go off into dll land.</span>
<a href="#l19.555"></a><span id="l19.555" class="difflineplus">+  // Optimization, boyz.</span>
<a href="#l19.556"></a><span id="l19.556">   if ((readfds &amp;&amp; readfds-&gt;fd_count) || (writefds &amp;&amp; writefds-&gt;fd_count) ||</span>
<a href="#l19.557"></a><span id="l19.557">       (exceptfds &amp;&amp; exceptfds-&gt;fd_count)) {</span>
<a href="#l19.558"></a><span id="l19.558">     if (IsWinsockLoaded(sp_select)) {</span>
<a href="#l19.559"></a><span id="l19.559">       return (((sp_int_int_fdsetFARp_fdsetFARp_fdsetFARp_ctimevalFARp)</span>
<a href="#l19.560"></a><span id="l19.560">                    spArray[sp_select])(nfds, readfds, writefds, exceptfds,</span>
<a href="#l19.561"></a><span id="l19.561">                                        timeout));</span>
<a href="#l19.562"></a><span id="l19.562">     }</span>
<a href="#l19.563"></a><span id="l19.563"> </span>
<a href="#l19.564"></a><span id="l19.564">     WSASetLastError(WSAENETDOWN);</span>
<a href="#l19.565"></a><span id="l19.565">     return (SOCKET_ERROR);</span>
<a href="#l19.566"></a><span id="l19.566">   }</span>
<a href="#l19.567"></a><span id="l19.567"> </span>
<a href="#l19.568"></a><span id="l19.568" class="difflineminus">-  //	No need to go to the DLL, there is nothing to do.</span>
<a href="#l19.569"></a><span id="l19.569" class="difflineplus">+  // No need to go to the DLL, there is nothing to do.</span>
<a href="#l19.570"></a><span id="l19.570">   return (0);</span>
<a href="#l19.571"></a><span id="l19.571"> }</span>
<a href="#l19.572"></a><span id="l19.572"> </span>
<a href="#l19.573"></a><span id="l19.573"> int PASCAL FAR send(SOCKET s, const char FAR *buf, int len, int flags) {</span>
<a href="#l19.574"></a><span id="l19.574">   NON_BLOCKING(</span>
<a href="#l19.575"></a><span id="l19.575"> </span>
<a href="#l19.576"></a><span id="l19.576">       (((sp_int_SOCKET_ccharFARp_int_int)spArray[sp_send])(s, buf, len, flags)),</span>
<a href="#l19.577"></a><span id="l19.577">       FD_WRITE, sp_send, int);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/open.c</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/open.c</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -310,17 +310,17 @@ static struct ldap_thread_fns nsldapi_de</span>
<a href="#l20.4"></a><span id="l20.4">     (void (*)(int, char *, char *, void *))set_ld_error,</span>
<a href="#l20.5"></a><span id="l20.5">     0};</span>
<a href="#l20.6"></a><span id="l20.6"> </span>
<a href="#l20.7"></a><span id="l20.7"> static struct ldap_extra_thread_fns nsldapi_default_extra_thread_fns = {0, 0, 0,</span>
<a href="#l20.8"></a><span id="l20.8">                                                                         0, 0,</span>
<a href="#l20.9"></a><span id="l20.9"> #  ifdef _WINDOWS</span>
<a href="#l20.10"></a><span id="l20.10">                                                                         0</span>
<a href="#l20.11"></a><span id="l20.11"> #  else</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-		(void *(*)(void))pthread_self</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+   (void *(*)(void))pthread_self</span>
<a href="#l20.14"></a><span id="l20.14"> #  endif /* _WINDOWS */</span>
<a href="#l20.15"></a><span id="l20.15"> };</span>
<a href="#l20.16"></a><span id="l20.16"> #endif /* use_pthreads || _windows */</span>
<a href="#l20.17"></a><span id="l20.17"> </span>
<a href="#l20.18"></a><span id="l20.18"> void nsldapi_initialize_defaults(void) {</span>
<a href="#l20.19"></a><span id="l20.19"> #ifdef _WINDOWS</span>
<a href="#l20.20"></a><span id="l20.20">   pthread_mutex_init(&amp;nsldapi_init_mutex, NULL);</span>
<a href="#l20.21"></a><span id="l20.21"> #endif /* _WINDOWS */</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineat">@@ -420,28 +420,27 @@ void nsldapi_initialize_defaults(void) {</span>
<a href="#l20.23"></a><span id="l20.23"> #else</span>
<a href="#l20.24"></a><span id="l20.24">   nsldapi_initialized = 1;</span>
<a href="#l20.25"></a><span id="l20.25"> #endif /* use_pthreads || _windows */</span>
<a href="#l20.26"></a><span id="l20.26"> }</span>
<a href="#l20.27"></a><span id="l20.27"> </span>
<a href="#l20.28"></a><span id="l20.28"> /*</span>
<a href="#l20.29"></a><span id="l20.29">  * ldap_version - report version levels for important properties</span>
<a href="#l20.30"></a><span id="l20.30">  * This function is deprecated.  Use ldap_get_option( ..., LDAP_OPT_API_INFO,</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineminus">- *	... ) instead.</span>
<a href="#l20.32"></a><span id="l20.32" class="difflineplus">+ * ... ) instead.</span>
<a href="#l20.33"></a><span id="l20.33">  *</span>
<a href="#l20.34"></a><span id="l20.34">  * Example:</span>
<a href="#l20.35"></a><span id="l20.35" class="difflineminus">- *	LDAPVersion ver;</span>
<a href="#l20.36"></a><span id="l20.36" class="difflineminus">- *	ldap_version( &amp;ver );</span>
<a href="#l20.37"></a><span id="l20.37" class="difflineminus">- *  if ( (ver.sdk_version &lt; 100) || (ver.SSL_version &lt; 300) )</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineminus">- *      fprintf( stderr, &quot;LDAP SDK level insufficient\n&quot; );</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+ * LDAPVersion ver;</span>
<a href="#l20.40"></a><span id="l20.40" class="difflineplus">+ * ldap_version(&amp;ver);</span>
<a href="#l20.41"></a><span id="l20.41" class="difflineplus">+ * if ((ver.sdk_version &lt; 100) || (ver.SSL_version &lt; 300))</span>
<a href="#l20.42"></a><span id="l20.42" class="difflineplus">+ *   fprintf(stderr, &quot;LDAP SDK level insufficient\n&quot;);</span>
<a href="#l20.43"></a><span id="l20.43">  *</span>
<a href="#l20.44"></a><span id="l20.44">  * or:</span>
<a href="#l20.45"></a><span id="l20.45" class="difflineminus">- *  if ( ldap_version(NULL) &lt; 100 )</span>
<a href="#l20.46"></a><span id="l20.46" class="difflineminus">- *      fprintf( stderr, &quot;LDAP SDK level insufficient\n&quot; );</span>
<a href="#l20.47"></a><span id="l20.47" class="difflineminus">- *</span>
<a href="#l20.48"></a><span id="l20.48" class="difflineplus">+ * if (ldap_version(NULL) &lt; 100)</span>
<a href="#l20.49"></a><span id="l20.49" class="difflineplus">+ *   fprintf(stderr, &quot;LDAP SDK level insufficient\n&quot;);</span>
<a href="#l20.50"></a><span id="l20.50">  */</span>
<a href="#l20.51"></a><span id="l20.51"> </span>
<a href="#l20.52"></a><span id="l20.52"> int LDAP_CALL ldap_version(LDAPVersion *ver) {</span>
<a href="#l20.53"></a><span id="l20.53">   if (NULL != ver) {</span>
<a href="#l20.54"></a><span id="l20.54">     memset(ver, 0, sizeof(*ver));</span>
<a href="#l20.55"></a><span id="l20.55">     ver-&gt;sdk_version = (int)(VI_PRODUCTVERSION * 100);</span>
<a href="#l20.56"></a><span id="l20.56">     ver-&gt;protocol_version = LDAP_VERSION_MAX * 100;</span>
<a href="#l20.57"></a><span id="l20.57">     ver-&gt;SSL_version = SSL_VERSION * 100;</span>
<a href="#l20.58"></a><span id="l20.58" class="difflineat">@@ -462,18 +461,18 @@ int LDAP_CALL ldap_version(LDAPVersion *</span>
<a href="#l20.59"></a><span id="l20.59"> }</span>
<a href="#l20.60"></a><span id="l20.60"> </span>
<a href="#l20.61"></a><span id="l20.61"> /*</span>
<a href="#l20.62"></a><span id="l20.62">  * ldap_open - initialize and connect to an ldap server.  A magic cookie to</span>
<a href="#l20.63"></a><span id="l20.63">  * be used for future communication is returned on success, NULL on failure.</span>
<a href="#l20.64"></a><span id="l20.64">  * &quot;host&quot; may be a space-separated list of hosts or IP addresses</span>
<a href="#l20.65"></a><span id="l20.65">  *</span>
<a href="#l20.66"></a><span id="l20.66">  * Example:</span>
<a href="#l20.67"></a><span id="l20.67" class="difflineminus">- *	LDAP	*ld;</span>
<a href="#l20.68"></a><span id="l20.68" class="difflineminus">- *	ld = ldap_open( hostname, port );</span>
<a href="#l20.69"></a><span id="l20.69" class="difflineplus">+ * LDAP  *ld;</span>
<a href="#l20.70"></a><span id="l20.70" class="difflineplus">+ * ld = ldap_open(hostname, port);</span>
<a href="#l20.71"></a><span id="l20.71">  */</span>
<a href="#l20.72"></a><span id="l20.72"> </span>
<a href="#l20.73"></a><span id="l20.73"> LDAP *LDAP_CALL ldap_open(const char *host, int port) {</span>
<a href="#l20.74"></a><span id="l20.74">   LDAP *ld;</span>
<a href="#l20.75"></a><span id="l20.75"> </span>
<a href="#l20.76"></a><span id="l20.76">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_open\n&quot;, 0, 0, 0);</span>
<a href="#l20.77"></a><span id="l20.77"> </span>
<a href="#l20.78"></a><span id="l20.78">   if ((ld = ldap_init(host, port)) == NULL) {</span>
<a href="#l20.79"></a><span id="l20.79" class="difflineat">@@ -499,18 +498,18 @@ LDAP *LDAP_CALL ldap_open(const char *ho</span>
<a href="#l20.80"></a><span id="l20.80">  * future communication is returned on success, NULL on failure.</span>
<a href="#l20.81"></a><span id="l20.81">  * &quot;defhost&quot; may be a space-separated list of hosts or IP addresses</span>
<a href="#l20.82"></a><span id="l20.82">  *</span>
<a href="#l20.83"></a><span id="l20.83">  * NOTE: If you want to use IPv6, you must use prldap creating a LDAP handle</span>
<a href="#l20.84"></a><span id="l20.84">  * with prldap_init instead of ldap_init. Or install the NSPR functions</span>
<a href="#l20.85"></a><span id="l20.85">  * by calling prldap_install_routines. (See the nspr samples in examples)</span>
<a href="#l20.86"></a><span id="l20.86">  *</span>
<a href="#l20.87"></a><span id="l20.87">  * Example:</span>
<a href="#l20.88"></a><span id="l20.88" class="difflineminus">- *	LDAP	*ld;</span>
<a href="#l20.89"></a><span id="l20.89" class="difflineminus">- *	ld = ldap_init( default_hostname, default_port );</span>
<a href="#l20.90"></a><span id="l20.90" class="difflineplus">+ * LDAP  *ld;</span>
<a href="#l20.91"></a><span id="l20.91" class="difflineplus">+ * ld = ldap_init(default_hostname, default_port);</span>
<a href="#l20.92"></a><span id="l20.92">  */</span>
<a href="#l20.93"></a><span id="l20.93"> LDAP *LDAP_CALL ldap_init(const char *defhost, int defport) {</span>
<a href="#l20.94"></a><span id="l20.94">   LDAP *ld;</span>
<a href="#l20.95"></a><span id="l20.95"> </span>
<a href="#l20.96"></a><span id="l20.96">   if (!nsldapi_initialized) {</span>
<a href="#l20.97"></a><span id="l20.97">     nsldapi_initialize_defaults();</span>
<a href="#l20.98"></a><span id="l20.98">   }</span>
<a href="#l20.99"></a><span id="l20.99"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/os-ip.c</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/os-ip.c</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -363,18 +363,18 @@ static int nsldapi_os_connect_with_to(LB</span>
<a href="#l21.4"></a><span id="l21.4"> #    ifdef LDAP_DEBUG</span>
<a href="#l21.5"></a><span id="l21.5">   } else if (ldap_debug &amp; LDAP_DEBUG_TRACE) {</span>
<a href="#l21.6"></a><span id="l21.6">     perror(&quot;poll error: sockfd not set&quot;);</span>
<a href="#l21.7"></a><span id="l21.7"> #    endif</span>
<a href="#l21.8"></a><span id="l21.8">   }</span>
<a href="#l21.9"></a><span id="l21.9"> </span>
<a href="#l21.10"></a><span id="l21.10"> #  else /* NSLDAPI_HAVE_POLL */</span>
<a href="#l21.11"></a><span id="l21.11">   /* if timeval structure == NULL, select will block indefinitely */</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-  /* 			!= NULL, and value == 0, select will */</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineminus">-  /* 			         not block */</span>
<a href="#l21.14"></a><span id="l21.14" class="difflineplus">+  /*                      != NULL, and value == 0, select will */</span>
<a href="#l21.15"></a><span id="l21.15" class="difflineplus">+  /*                               not block */</span>
<a href="#l21.16"></a><span id="l21.16">   /* Windows is a bit quirky on how it behaves w.r.t nonblocking */</span>
<a href="#l21.17"></a><span id="l21.17">   /* connects.  If the connect fails, the exception fd, eset, is */</span>
<a href="#l21.18"></a><span id="l21.18">   /* set to show the failure.  The first argument in select is */</span>
<a href="#l21.19"></a><span id="l21.19">   /* ignored */</span>
<a href="#l21.20"></a><span id="l21.20"> </span>
<a href="#l21.21"></a><span id="l21.21"> #    ifdef _WINDOWS</span>
<a href="#l21.22"></a><span id="l21.22">   if ((n = select(sockfd + 1, &amp;rset, &amp;wset, &amp;eset,</span>
<a href="#l21.23"></a><span id="l21.23">                   (msec != LDAP_X_IO_TIMEOUT_NO_TIMEOUT) ? &amp;tval : NULL)) ==</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/proxyauthctrl.c</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/proxyauthctrl.c</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -39,17 +39,17 @@</span>
<a href="#l22.4"></a><span id="l22.4"> /* ldap_create_proxyauth_control</span>
<a href="#l22.5"></a><span id="l22.5"> </span>
<a href="#l22.6"></a><span id="l22.6">    Create a &quot;version 1&quot; proxied authorization control.</span>
<a href="#l22.7"></a><span id="l22.7"> </span>
<a href="#l22.8"></a><span id="l22.8">    Parameters are</span>
<a href="#l22.9"></a><span id="l22.9"> </span>
<a href="#l22.10"></a><span id="l22.10">    ld              LDAP pointer to the desired connection</span>
<a href="#l22.11"></a><span id="l22.11"> </span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-   dn		   The dn used in the proxy auth</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+   dn              The dn used in the proxy auth</span>
<a href="#l22.14"></a><span id="l22.14"> </span>
<a href="#l22.15"></a><span id="l22.15">    ctl_iscritical  Indicates whether the control is critical of not. If</span>
<a href="#l22.16"></a><span id="l22.16">                    this field is non-zero, the operation will only be car-</span>
<a href="#l22.17"></a><span id="l22.17">                    ried out if the control is recognized by the server</span>
<a href="#l22.18"></a><span id="l22.18">                    and/or client</span>
<a href="#l22.19"></a><span id="l22.19"> </span>
<a href="#l22.20"></a><span id="l22.20">    ctrlp           the address of a place to put the constructed control</span>
<a href="#l22.21"></a><span id="l22.21"> */</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineat">@@ -94,17 +94,17 @@ int LDAP_CALL ldap_create_proxyauth_cont</span>
<a href="#l22.23"></a><span id="l22.23"> /* ldap_create_proxiedauth_control</span>
<a href="#l22.24"></a><span id="l22.24"> </span>
<a href="#l22.25"></a><span id="l22.25">    Create a &quot;version 2&quot; proxied authorization control.</span>
<a href="#l22.26"></a><span id="l22.26"> </span>
<a href="#l22.27"></a><span id="l22.27">    Parameters are</span>
<a href="#l22.28"></a><span id="l22.28"> </span>
<a href="#l22.29"></a><span id="l22.29">    ld              LDAP pointer to the desired connection</span>
<a href="#l22.30"></a><span id="l22.30"> </span>
<a href="#l22.31"></a><span id="l22.31" class="difflineminus">-   authzid		   The authorization identity used in the proxy auth,</span>
<a href="#l22.32"></a><span id="l22.32" class="difflineplus">+   authzid         The authorization identity used in the proxy auth,</span>
<a href="#l22.33"></a><span id="l22.33">                    e.g., dn:uid=bjensen,dc=example,dc=com</span>
<a href="#l22.34"></a><span id="l22.34"> </span>
<a href="#l22.35"></a><span id="l22.35">    ctrlp           the address of a place to put the constructed control</span>
<a href="#l22.36"></a><span id="l22.36"> */</span>
<a href="#l22.37"></a><span id="l22.37"> </span>
<a href="#l22.38"></a><span id="l22.38"> int LDAP_CALL ldap_create_proxiedauth_control(LDAP *ld, const char *authzid,</span>
<a href="#l22.39"></a><span id="l22.39">                                               LDAPControl **ctrlp) {</span>
<a href="#l22.40"></a><span id="l22.40">   BerElement *ber;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/psearch.c</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/psearch.c</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -54,25 +54,25 @@ int LDAP_CALL ldap_create_persistentsear</span>
<a href="#l23.4"></a><span id="l23.4">   if (ctrlp == NULL || (changetypes &amp; ~LDAP_CHANGETYPE_ANY) != 0) {</span>
<a href="#l23.5"></a><span id="l23.5">     rc = LDAP_PARAM_ERROR;</span>
<a href="#l23.6"></a><span id="l23.6">     goto report_error_and_return;</span>
<a href="#l23.7"></a><span id="l23.7">   }</span>
<a href="#l23.8"></a><span id="l23.8"> </span>
<a href="#l23.9"></a><span id="l23.9">   /*</span>
<a href="#l23.10"></a><span id="l23.10">    * create a Persistent Search control.  The control value looks like this:</span>
<a href="#l23.11"></a><span id="l23.11">    *</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-   *	PersistentSearch ::= SEQUENCE {</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineminus">-   *		changeTypes INTEGER,</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineminus">-   *		-- the changeTypes field is the logical OR of</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineminus">-   *		-- one or more of these values: add (1), delete (2),</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineminus">-   *		-- modify (4), modDN (8).  It specifies which types of</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineminus">-   *		-- changes will cause an entry to be returned.</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineminus">-   *		changesOnly BOOLEAN, -- skip initial search?</span>
<a href="#l23.19"></a><span id="l23.19" class="difflineminus">-   *		returnECs BOOLEAN,   -- return &quot;Entry Change&quot; controls?</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineminus">-   *	}</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+   * PersistentSearch ::= SEQUENCE {</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+   *   changeTypes INTEGER,</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+   *   -- the changeTypes field is the logical OR of</span>
<a href="#l23.24"></a><span id="l23.24" class="difflineplus">+   *   -- one or more of these values: add (1), delete (2),</span>
<a href="#l23.25"></a><span id="l23.25" class="difflineplus">+   *   -- modify (4), modDN (8).  It specifies which types of</span>
<a href="#l23.26"></a><span id="l23.26" class="difflineplus">+   *   -- changes will cause an entry to be returned.</span>
<a href="#l23.27"></a><span id="l23.27" class="difflineplus">+   *   changesOnly BOOLEAN, -- skip initial search?</span>
<a href="#l23.28"></a><span id="l23.28" class="difflineplus">+   *   returnECs BOOLEAN,   -- return &quot;Entry Change&quot; controls?</span>
<a href="#l23.29"></a><span id="l23.29" class="difflineplus">+   * }</span>
<a href="#l23.30"></a><span id="l23.30">    */</span>
<a href="#l23.31"></a><span id="l23.31">   if ((nsldapi_alloc_ber_with_options(ld, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l23.32"></a><span id="l23.32">     rc = LDAP_NO_MEMORY;</span>
<a href="#l23.33"></a><span id="l23.33">     goto report_error_and_return;</span>
<a href="#l23.34"></a><span id="l23.34">   }</span>
<a href="#l23.35"></a><span id="l23.35"> </span>
<a href="#l23.36"></a><span id="l23.36">   if (ber_printf(ber, &quot;{ibb}&quot;, changetypes, changesonly, return_echg_ctls) ==</span>
<a href="#l23.37"></a><span id="l23.37">       -1) {</span>
<a href="#l23.38"></a><span id="l23.38" class="difflineat">@@ -118,26 +118,26 @@ int LDAP_CALL ldap_parse_entrychange_con</span>
<a href="#l23.39"></a><span id="l23.39">     rc = LDAP_CONTROL_NOT_FOUND;</span>
<a href="#l23.40"></a><span id="l23.40">     goto report_error_and_return;</span>
<a href="#l23.41"></a><span id="l23.41">   }</span>
<a href="#l23.42"></a><span id="l23.42"> </span>
<a href="#l23.43"></a><span id="l23.43">   /*</span>
<a href="#l23.44"></a><span id="l23.44">    * allocate a BER element from the control value and parse it.  The control</span>
<a href="#l23.45"></a><span id="l23.45">    * value should look like this:</span>
<a href="#l23.46"></a><span id="l23.46">    *</span>
<a href="#l23.47"></a><span id="l23.47" class="difflineminus">-   *	EntryChangeNotification ::= SEQUENCE {</span>
<a href="#l23.48"></a><span id="l23.48" class="difflineminus">-   *	     changeType ENUMERATED {</span>
<a href="#l23.49"></a><span id="l23.49" class="difflineminus">-   *	 	add             (1),  -- these values match the</span>
<a href="#l23.50"></a><span id="l23.50" class="difflineminus">-   *	 	delete          (2),  -- values used for changeTypes</span>
<a href="#l23.51"></a><span id="l23.51" class="difflineminus">-   *	 	modify          (4),  -- in the PersistentSearch control.</span>
<a href="#l23.52"></a><span id="l23.52" class="difflineminus">-   *	 	modDN           (8),</span>
<a href="#l23.53"></a><span id="l23.53" class="difflineminus">-   *	     },</span>
<a href="#l23.54"></a><span id="l23.54" class="difflineminus">-   *	     previousDN   LDAPDN OPTIONAL,     -- modDN ops. only</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineminus">-   *	     changeNumber INTEGER OPTIONAL,    -- if supported</span>
<a href="#l23.56"></a><span id="l23.56" class="difflineminus">-   *	}</span>
<a href="#l23.57"></a><span id="l23.57" class="difflineplus">+   * EntryChangeNotification ::= SEQUENCE {</span>
<a href="#l23.58"></a><span id="l23.58" class="difflineplus">+   *   changeType ENUMERATED {</span>
<a href="#l23.59"></a><span id="l23.59" class="difflineplus">+   *     add             (1),  -- these values match the</span>
<a href="#l23.60"></a><span id="l23.60" class="difflineplus">+   *     delete          (2),  -- values used for changeTypes</span>
<a href="#l23.61"></a><span id="l23.61" class="difflineplus">+   *     modify          (4),  -- in the PersistentSearch control.</span>
<a href="#l23.62"></a><span id="l23.62" class="difflineplus">+   *     modDN           (8),</span>
<a href="#l23.63"></a><span id="l23.63" class="difflineplus">+   *   },</span>
<a href="#l23.64"></a><span id="l23.64" class="difflineplus">+   *   previousDN   LDAPDN OPTIONAL,     -- modDN ops. only</span>
<a href="#l23.65"></a><span id="l23.65" class="difflineplus">+   *   changeNumber INTEGER OPTIONAL,    -- if supported</span>
<a href="#l23.66"></a><span id="l23.66" class="difflineplus">+   * }</span>
<a href="#l23.67"></a><span id="l23.67">    */</span>
<a href="#l23.68"></a><span id="l23.68">   if ((ber = ber_init(&amp;(ctrls[i]-&gt;ldctl_value))) == NULL) {</span>
<a href="#l23.69"></a><span id="l23.69">     rc = LDAP_NO_MEMORY;</span>
<a href="#l23.70"></a><span id="l23.70">     goto report_error_and_return;</span>
<a href="#l23.71"></a><span id="l23.71">   }</span>
<a href="#l23.72"></a><span id="l23.72"> </span>
<a href="#l23.73"></a><span id="l23.73">   if (ber_scanf(ber, &quot;{e&quot;, &amp;along) == LBER_ERROR) {</span>
<a href="#l23.74"></a><span id="l23.74">     ber_free(ber, 1);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/pwmodext.c</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/pwmodext.c</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -62,19 +62,19 @@ int LDAP_CALL ldap_passwd(LDAP *ld, stru</span>
<a href="#l24.4"></a><span id="l24.4">   if (userid || oldpasswd || newpasswd) {</span>
<a href="#l24.5"></a><span id="l24.5">     if ((nsldapi_alloc_ber_with_options(ld, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l24.6"></a><span id="l24.6">       LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l24.7"></a><span id="l24.7">       return (LDAP_NO_MEMORY);</span>
<a href="#l24.8"></a><span id="l24.8">     }</span>
<a href="#l24.9"></a><span id="l24.9"> </span>
<a href="#l24.10"></a><span id="l24.10">     /*</span>
<a href="#l24.11"></a><span id="l24.11">      * PasswdModifyRequestValue ::= SEQUENCE {</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-     *	 userIdentity    [0]  OCTET STRING OPTIONAL</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineminus">-     *	 oldPasswd       [1]  OCTET STRING OPTIONAL</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineminus">-     *	 newPasswd       [2]  OCTET STRING OPTIONAL }</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+     *   userIdentity    [0]  OCTET STRING OPTIONAL</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+     *   oldPasswd       [1]  OCTET STRING OPTIONAL</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+     *   newPasswd       [2]  OCTET STRING OPTIONAL }</span>
<a href="#l24.18"></a><span id="l24.18">      */</span>
<a href="#l24.19"></a><span id="l24.19">     if (LBER_ERROR == (ber_printf(ber, &quot;{&quot;))) {</span>
<a href="#l24.20"></a><span id="l24.20">       LDAP_SET_LDERRNO(ld, LDAP_ENCODING_ERROR, NULL, NULL);</span>
<a href="#l24.21"></a><span id="l24.21">       ber_free(ber, 1);</span>
<a href="#l24.22"></a><span id="l24.22">       return (LDAP_ENCODING_ERROR);</span>
<a href="#l24.23"></a><span id="l24.23">     }</span>
<a href="#l24.24"></a><span id="l24.24"> </span>
<a href="#l24.25"></a><span id="l24.25">     if (userid &amp;&amp; userid-&gt;bv_val &amp;&amp; userid-&gt;bv_len) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/pwpctrl.c</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/pwpctrl.c</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -142,29 +142,30 @@ int LDAP_CALL ldap_parse_passwordpolicy_</span>
<a href="#l25.4"></a><span id="l25.4">   if ((ber = ber_init(&amp;ctrlp-&gt;ldctl_value)) == NULL) {</span>
<a href="#l25.5"></a><span id="l25.5">     LDAP_SET_LDERRNO(ld, LDAP_NO_MEMORY, NULL, NULL);</span>
<a href="#l25.6"></a><span id="l25.6">     return (LDAP_NO_MEMORY);</span>
<a href="#l25.7"></a><span id="l25.7">   }</span>
<a href="#l25.8"></a><span id="l25.8"> </span>
<a href="#l25.9"></a><span id="l25.9">   /*</span>
<a href="#l25.10"></a><span id="l25.10">    * The control value should look like this:</span>
<a href="#l25.11"></a><span id="l25.11">    *</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-   *	PasswordPolicyResponseValue ::= SEQUENCE {</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineminus">-   *		warning [0] CHOICE {</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineminus">-   *			timeBeforeExpiration        [0] INTEGER (0 .. maxInt),</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineminus">-   *			graceLoginsRemaining        [1] INTEGER (0 .. maxInt) }</span>
<a href="#l25.16"></a><span id="l25.16" class="difflineminus">-   *OPTIONAL error       [1] ENUMERATED { passwordExpired             (0),</span>
<a href="#l25.17"></a><span id="l25.17" class="difflineminus">-   *			accountLocked               (1),</span>
<a href="#l25.18"></a><span id="l25.18" class="difflineminus">-   *			changeAfterReset            (2),</span>
<a href="#l25.19"></a><span id="l25.19" class="difflineminus">-   *			passwordModNotAllowed       (3),</span>
<a href="#l25.20"></a><span id="l25.20" class="difflineminus">-   *			mustSupplyOldPassword       (4),</span>
<a href="#l25.21"></a><span id="l25.21" class="difflineminus">-   *			insufficientPasswordQuality (5),</span>
<a href="#l25.22"></a><span id="l25.22" class="difflineminus">-   *			passwordTooShort            (6),</span>
<a href="#l25.23"></a><span id="l25.23" class="difflineminus">-   *			passwordTooYoung            (7),</span>
<a href="#l25.24"></a><span id="l25.24" class="difflineminus">-   *			passwordInHistory           (8) } OPTIONAL }</span>
<a href="#l25.25"></a><span id="l25.25" class="difflineplus">+   * PasswordPolicyResponseValue ::= SEQUENCE {</span>
<a href="#l25.26"></a><span id="l25.26" class="difflineplus">+   *   warning [0] CHOICE {</span>
<a href="#l25.27"></a><span id="l25.27" class="difflineplus">+   *     timeBeforeExpiration        [0] INTEGER (0 .. maxInt),</span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+   *     graceLoginsRemaining        [1] INTEGER (0 .. maxInt) } OPTIONAL</span>
<a href="#l25.29"></a><span id="l25.29" class="difflineplus">+   *   error   [1] ENUMERATED {</span>
<a href="#l25.30"></a><span id="l25.30" class="difflineplus">+   *     passwordExpired             (0),</span>
<a href="#l25.31"></a><span id="l25.31" class="difflineplus">+   *     accountLocked               (1),</span>
<a href="#l25.32"></a><span id="l25.32" class="difflineplus">+   *     changeAfterReset            (2),</span>
<a href="#l25.33"></a><span id="l25.33" class="difflineplus">+   *     passwordModNotAllowed       (3),</span>
<a href="#l25.34"></a><span id="l25.34" class="difflineplus">+   *     mustSupplyOldPassword       (4),</span>
<a href="#l25.35"></a><span id="l25.35" class="difflineplus">+   *     insufficientPasswordQuality (5),</span>
<a href="#l25.36"></a><span id="l25.36" class="difflineplus">+   *     passwordTooShort            (6),</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineplus">+   *     passwordTooYoung            (7),</span>
<a href="#l25.38"></a><span id="l25.38" class="difflineplus">+   *     passwordInHistory           (8) } OPTIONAL }</span>
<a href="#l25.39"></a><span id="l25.39">    */</span>
<a href="#l25.40"></a><span id="l25.40"> </span>
<a href="#l25.41"></a><span id="l25.41">   if (ber_scanf(ber, &quot;{&quot;) == LBER_ERROR) {</span>
<a href="#l25.42"></a><span id="l25.42">     LDAP_SET_LDERRNO(ld, LDAP_DECODING_ERROR, NULL, NULL);</span>
<a href="#l25.43"></a><span id="l25.43">     ber_free(ber, 1);</span>
<a href="#l25.44"></a><span id="l25.44">     return (LDAP_DECODING_ERROR);</span>
<a href="#l25.45"></a><span id="l25.45">   }</span>
<a href="#l25.46"></a><span id="l25.46"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/referral.c</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/referral.c</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -115,25 +115,25 @@ int nsldapi_parse_reference(LDAP *ld, Be</span>
<a href="#l26.4"></a><span id="l26.4">   int err;</span>
<a href="#l26.5"></a><span id="l26.5">   BerElement ber;</span>
<a href="#l26.6"></a><span id="l26.6">   char **refs;</span>
<a href="#l26.7"></a><span id="l26.7"> </span>
<a href="#l26.8"></a><span id="l26.8">   /*</span>
<a href="#l26.9"></a><span id="l26.9">    * Parse a searchResultReference message.  These are used in LDAPv3</span>
<a href="#l26.10"></a><span id="l26.10">    * and beyond and look like this:</span>
<a href="#l26.11"></a><span id="l26.11">    *</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-   *	SearchResultReference ::= [APPLICATION 19] SEQUENCE OF LDAPURL</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+   * SearchResultReference ::= [APPLICATION 19] SEQUENCE OF LDAPURL</span>
<a href="#l26.14"></a><span id="l26.14">    *</span>
<a href="#l26.15"></a><span id="l26.15">    * all wrapped up in an LDAPMessage sequence which looks like this:</span>
<a href="#l26.16"></a><span id="l26.16">    *</span>
<a href="#l26.17"></a><span id="l26.17" class="difflineminus">-   *	LDAPMessage ::= SEQUENCE {</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineminus">-   *		messageID	MessageID,</span>
<a href="#l26.19"></a><span id="l26.19" class="difflineminus">-   *		SearchResultReference</span>
<a href="#l26.20"></a><span id="l26.20" class="difflineminus">-   *		controls	[0] Controls OPTIONAL</span>
<a href="#l26.21"></a><span id="l26.21" class="difflineminus">-   *	}</span>
<a href="#l26.22"></a><span id="l26.22" class="difflineplus">+   * LDAPMessage ::= SEQUENCE {</span>
<a href="#l26.23"></a><span id="l26.23" class="difflineplus">+   *   messageID  MessageID,</span>
<a href="#l26.24"></a><span id="l26.24" class="difflineplus">+   *   SearchResultReference</span>
<a href="#l26.25"></a><span id="l26.25" class="difflineplus">+   *   controls  [0] Controls OPTIONAL</span>
<a href="#l26.26"></a><span id="l26.26" class="difflineplus">+   * }</span>
<a href="#l26.27"></a><span id="l26.27">    *</span>
<a href="#l26.28"></a><span id="l26.28">    * ldap_result() pulls out the message id, so by the time a result</span>
<a href="#l26.29"></a><span id="l26.29">    * message gets here we are conveniently sitting at the start of the</span>
<a href="#l26.30"></a><span id="l26.30">    * SearchResultReference itself.</span>
<a href="#l26.31"></a><span id="l26.31">    */</span>
<a href="#l26.32"></a><span id="l26.32">   err = LDAP_SUCCESS; /* optimistic */</span>
<a href="#l26.33"></a><span id="l26.33">   ber = *rber;        /* struct copy */</span>
<a href="#l26.34"></a><span id="l26.34"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/regex.c</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/regex.c</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -61,67 +61,67 @@</span>
<a href="#l27.4"></a><span id="l27.4">  * pmatch call.</span>
<a href="#l27.5"></a><span id="l27.5">  *</span>
<a href="#l27.6"></a><span id="l27.6">  * Use a bitmap table to set char bits in an</span>
<a href="#l27.7"></a><span id="l27.7">  * 8-bit chunk.</span>
<a href="#l27.8"></a><span id="l27.8">  *</span>
<a href="#l27.9"></a><span id="l27.9">  * Interfaces:</span>
<a href="#l27.10"></a><span id="l27.10">  *      re_comp:        compile a regular expression into a NFA.</span>
<a href="#l27.11"></a><span id="l27.11">  *</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">- *			char *re_comp(s)</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineminus">- *			char *s;</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+ *      char *re_comp(s)</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+ *      char *s;</span>
<a href="#l27.16"></a><span id="l27.16">  *</span>
<a href="#l27.17"></a><span id="l27.17">  *      re_exec:        execute the NFA to match a pattern.</span>
<a href="#l27.18"></a><span id="l27.18">  *</span>
<a href="#l27.19"></a><span id="l27.19" class="difflineminus">- *			int re_exec(s)</span>
<a href="#l27.20"></a><span id="l27.20" class="difflineminus">- *			char *s;</span>
<a href="#l27.21"></a><span id="l27.21" class="difflineplus">+ *      int re_exec(s)</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineplus">+ *      char *s;</span>
<a href="#l27.23"></a><span id="l27.23">  *</span>
<a href="#l27.24"></a><span id="l27.24" class="difflineminus">- *	re_modw		change re_exec's understanding of what a &quot;word&quot;</span>
<a href="#l27.25"></a><span id="l27.25" class="difflineminus">- *			looks like (for \&lt; and \&gt;) by adding into the</span>
<a href="#l27.26"></a><span id="l27.26" class="difflineminus">- *			hidden word-syntax table.</span>
<a href="#l27.27"></a><span id="l27.27" class="difflineplus">+ *      re_modw    change re_exec's understanding of what a &quot;word&quot;</span>
<a href="#l27.28"></a><span id="l27.28" class="difflineplus">+ *      looks like (for \&lt; and \&gt;) by adding into the</span>
<a href="#l27.29"></a><span id="l27.29" class="difflineplus">+ *      hidden word-syntax table.</span>
<a href="#l27.30"></a><span id="l27.30">  *</span>
<a href="#l27.31"></a><span id="l27.31" class="difflineminus">- *			void re_modw(s)</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineminus">- *			char *s;</span>
<a href="#l27.33"></a><span id="l27.33" class="difflineplus">+ *      void re_modw(s)</span>
<a href="#l27.34"></a><span id="l27.34" class="difflineplus">+ *      char *s;</span>
<a href="#l27.35"></a><span id="l27.35">  *</span>
<a href="#l27.36"></a><span id="l27.36" class="difflineminus">- *      re_subs:	substitute the matched portions in a new string.</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineplus">+ *      re_subs:  substitute the matched portions in a new string.</span>
<a href="#l27.38"></a><span id="l27.38">  *</span>
<a href="#l27.39"></a><span id="l27.39" class="difflineminus">- *			int re_subs(src, dst)</span>
<a href="#l27.40"></a><span id="l27.40" class="difflineminus">- *			char *src;</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineminus">- *			char *dst;</span>
<a href="#l27.42"></a><span id="l27.42" class="difflineplus">+ *      int re_subs(src, dst)</span>
<a href="#l27.43"></a><span id="l27.43" class="difflineplus">+ *      char *src;</span>
<a href="#l27.44"></a><span id="l27.44" class="difflineplus">+ *      char *dst;</span>
<a href="#l27.45"></a><span id="l27.45">  *</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineminus">- *	re_fail:	failure routine for re_exec.</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+ *      re_fail:  failure routine for re_exec.</span>
<a href="#l27.48"></a><span id="l27.48">  *</span>
<a href="#l27.49"></a><span id="l27.49" class="difflineminus">- *			void re_fail(msg, op)</span>
<a href="#l27.50"></a><span id="l27.50" class="difflineminus">- *			char *msg;</span>
<a href="#l27.51"></a><span id="l27.51" class="difflineminus">- *			char op;</span>
<a href="#l27.52"></a><span id="l27.52" class="difflineplus">+ *      void re_fail(msg, op)</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineplus">+ *      char *msg;</span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+ *      char op;</span>
<a href="#l27.55"></a><span id="l27.55">  *</span>
<a href="#l27.56"></a><span id="l27.56">  * Regular Expressions:</span>
<a href="#l27.57"></a><span id="l27.57">  *</span>
<a href="#l27.58"></a><span id="l27.58">  *      [1]     char    matches itself, unless it is a special</span>
<a href="#l27.59"></a><span id="l27.59">  *                      character (metachar): . \ [ ] * + ^ $</span>
<a href="#l27.60"></a><span id="l27.60">  *</span>
<a href="#l27.61"></a><span id="l27.61">  *      [2]     .       matches any character.</span>
<a href="#l27.62"></a><span id="l27.62">  *</span>
<a href="#l27.63"></a><span id="l27.63">  *      [3]     \       matches the character following it, except</span>
<a href="#l27.64"></a><span id="l27.64" class="difflineminus">- *			when followed by a left or right round bracket,</span>
<a href="#l27.65"></a><span id="l27.65" class="difflineminus">- *			a digit 1 to 9 or a left or right angle bracket.</span>
<a href="#l27.66"></a><span id="l27.66" class="difflineminus">- *			(see [7], [8] and [9])</span>
<a href="#l27.67"></a><span id="l27.67" class="difflineminus">- *			It is used as an escape character for all</span>
<a href="#l27.68"></a><span id="l27.68" class="difflineminus">- *			other meta-characters, and itself. When used</span>
<a href="#l27.69"></a><span id="l27.69" class="difflineminus">- *			in a set ([4]), it is treated as an ordinary</span>
<a href="#l27.70"></a><span id="l27.70" class="difflineminus">- *			character.</span>
<a href="#l27.71"></a><span id="l27.71" class="difflineplus">+ *      when followed by a left or right round bracket,</span>
<a href="#l27.72"></a><span id="l27.72" class="difflineplus">+ *      a digit 1 to 9 or a left or right angle bracket.</span>
<a href="#l27.73"></a><span id="l27.73" class="difflineplus">+ *      (see [7], [8] and [9])</span>
<a href="#l27.74"></a><span id="l27.74" class="difflineplus">+ *      It is used as an escape character for all</span>
<a href="#l27.75"></a><span id="l27.75" class="difflineplus">+ *      other meta-characters, and itself. When used</span>
<a href="#l27.76"></a><span id="l27.76" class="difflineplus">+ *      in a set ([4]), it is treated as an ordinary</span>
<a href="#l27.77"></a><span id="l27.77" class="difflineplus">+ *      character.</span>
<a href="#l27.78"></a><span id="l27.78">  *</span>
<a href="#l27.79"></a><span id="l27.79">  *      [4]     [set]   matches one of the characters in the set.</span>
<a href="#l27.80"></a><span id="l27.80">  *                      If the first character in the set is &quot;^&quot;,</span>
<a href="#l27.81"></a><span id="l27.81">  *                      it matches a character NOT in the set, i.e.</span>
<a href="#l27.82"></a><span id="l27.82" class="difflineminus">- *			complements the set. A shorthand S-E is</span>
<a href="#l27.83"></a><span id="l27.83" class="difflineminus">- *			used to specify a set of characters S up to</span>
<a href="#l27.84"></a><span id="l27.84" class="difflineminus">- *			E, inclusive. The special characters &quot;]&quot; and</span>
<a href="#l27.85"></a><span id="l27.85" class="difflineminus">- *			&quot;-&quot; have no special meaning if they appear</span>
<a href="#l27.86"></a><span id="l27.86" class="difflineminus">- *			as the first chars in the set.</span>
<a href="#l27.87"></a><span id="l27.87" class="difflineplus">+ *      complements the set. A shorthand S-E is</span>
<a href="#l27.88"></a><span id="l27.88" class="difflineplus">+ *      used to specify a set of characters S up to</span>
<a href="#l27.89"></a><span id="l27.89" class="difflineplus">+ *      E, inclusive. The special characters &quot;]&quot; and</span>
<a href="#l27.90"></a><span id="l27.90" class="difflineplus">+ *      &quot;-&quot; have no special meaning if they appear</span>
<a href="#l27.91"></a><span id="l27.91" class="difflineplus">+ *      as the first chars in the set.</span>
<a href="#l27.92"></a><span id="l27.92">  *                      examples:        match:</span>
<a href="#l27.93"></a><span id="l27.93">  *</span>
<a href="#l27.94"></a><span id="l27.94">  *                              [a-z]    any lowercase alpha</span>
<a href="#l27.95"></a><span id="l27.95">  *</span>
<a href="#l27.96"></a><span id="l27.96">  *                              [^]-]    any char except ] and -</span>
<a href="#l27.97"></a><span id="l27.97">  *</span>
<a href="#l27.98"></a><span id="l27.98">  *                              [^A-Z]   any char except uppercase</span>
<a href="#l27.99"></a><span id="l27.99">  *                                       alpha</span>
<a href="#l27.100"></a><span id="l27.100" class="difflineat">@@ -133,84 +133,84 @@</span>
<a href="#l27.101"></a><span id="l27.101">  *                      that form.</span>
<a href="#l27.102"></a><span id="l27.102">  *</span>
<a href="#l27.103"></a><span id="l27.103">  *      [6]     +       same as [5], except it matches one or more.</span>
<a href="#l27.104"></a><span id="l27.104">  *</span>
<a href="#l27.105"></a><span id="l27.105">  *      [7]             a regular expression in the form [1] to [10], enclosed</span>
<a href="#l27.106"></a><span id="l27.106">  *                      as \(form\) matches what form matches. The enclosure</span>
<a href="#l27.107"></a><span id="l27.107">  *                      creates a set of tags, used for [8] and for</span>
<a href="#l27.108"></a><span id="l27.108">  *                      pattern substution. The tagged forms are numbered</span>
<a href="#l27.109"></a><span id="l27.109" class="difflineminus">- *			starting from 1.</span>
<a href="#l27.110"></a><span id="l27.110" class="difflineplus">+ *      starting from 1.</span>
<a href="#l27.111"></a><span id="l27.111">  *</span>
<a href="#l27.112"></a><span id="l27.112">  *      [8]             a \ followed by a digit 1 to 9 matches whatever a</span>
<a href="#l27.113"></a><span id="l27.113">  *                      previously tagged regular expression ([7]) matched.</span>
<a href="#l27.114"></a><span id="l27.114">  *</span>
<a href="#l27.115"></a><span id="l27.115" class="difflineminus">- *	[9]	\&lt;	a regular expression starting with a \&lt; construct</span>
<a href="#l27.116"></a><span id="l27.116" class="difflineminus">- *		\&gt;	and/or ending with a \&gt; construct, restricts the</span>
<a href="#l27.117"></a><span id="l27.117" class="difflineminus">- *			pattern matching to the beginning of a word, and/or</span>
<a href="#l27.118"></a><span id="l27.118" class="difflineminus">- *			the end of a word. A word is defined to be a character</span>
<a href="#l27.119"></a><span id="l27.119" class="difflineminus">- *			string beginning and/or ending with the characters</span>
<a href="#l27.120"></a><span id="l27.120" class="difflineminus">- *			A-Z a-z 0-9 and _. It must also be preceded and/or</span>
<a href="#l27.121"></a><span id="l27.121" class="difflineminus">- *			followed by any character outside those mentioned.</span>
<a href="#l27.122"></a><span id="l27.122" class="difflineplus">+ *      [9]             \&lt;  a regular expression starting with a \&lt; construct</span>
<a href="#l27.123"></a><span id="l27.123" class="difflineplus">+ *                      \&gt;  and/or ending with a \&gt; construct, restricts the</span>
<a href="#l27.124"></a><span id="l27.124" class="difflineplus">+ *                      pattern matching to the beginning of a word, and/or</span>
<a href="#l27.125"></a><span id="l27.125" class="difflineplus">+ *                      the end of a word. A word is defined to be a character</span>
<a href="#l27.126"></a><span id="l27.126" class="difflineplus">+ *                      string beginning and/or ending with the characters</span>
<a href="#l27.127"></a><span id="l27.127" class="difflineplus">+ *                      A-Z a-z 0-9 and _. It must also be preceded and/or</span>
<a href="#l27.128"></a><span id="l27.128" class="difflineplus">+ *                      followed by any character outside those mentioned.</span>
<a href="#l27.129"></a><span id="l27.129">  *</span>
<a href="#l27.130"></a><span id="l27.130">  *      [10]            a composite regular expression xy where x and y</span>
<a href="#l27.131"></a><span id="l27.131">  *                      are in the form [1] to [10] matches the longest</span>
<a href="#l27.132"></a><span id="l27.132">  *                      match of x followed by a match for y.</span>
<a href="#l27.133"></a><span id="l27.133">  *</span>
<a href="#l27.134"></a><span id="l27.134" class="difflineminus">- *      [11]	^	a regular expression starting with a ^ character</span>
<a href="#l27.135"></a><span id="l27.135" class="difflineminus">- *		$	and/or ending with a $ character, restricts the</span>
<a href="#l27.136"></a><span id="l27.136" class="difflineplus">+ *      [11]            ^  a regular expression starting with a ^ character</span>
<a href="#l27.137"></a><span id="l27.137" class="difflineplus">+ *                      $  and/or ending with a $ character, restricts the</span>
<a href="#l27.138"></a><span id="l27.138">  *                      pattern matching to the beginning of the line,</span>
<a href="#l27.139"></a><span id="l27.139">  *                      or the end of line. [anchors] Elsewhere in the</span>
<a href="#l27.140"></a><span id="l27.140" class="difflineminus">- *			pattern, ^ and $ are treated as ordinary characters.</span>
<a href="#l27.141"></a><span id="l27.141" class="difflineplus">+ *                      pattern, ^ and $ are treated as ordinary characters.</span>
<a href="#l27.142"></a><span id="l27.142">  *</span>
<a href="#l27.143"></a><span id="l27.143">  *</span>
<a href="#l27.144"></a><span id="l27.144">  * Acknowledgements:</span>
<a href="#l27.145"></a><span id="l27.145">  *</span>
<a href="#l27.146"></a><span id="l27.146" class="difflineminus">- *	HCR's Hugh Redelmeier has been most helpful in various</span>
<a href="#l27.147"></a><span id="l27.147" class="difflineminus">- *	stages of development. He convinced me to include BOW</span>
<a href="#l27.148"></a><span id="l27.148" class="difflineminus">- *	and EOW constructs, originally invented by Rob Pike at</span>
<a href="#l27.149"></a><span id="l27.149" class="difflineminus">- *	the University of Toronto.</span>
<a href="#l27.150"></a><span id="l27.150" class="difflineplus">+ * HCR's Hugh Redelmeier has been most helpful in various</span>
<a href="#l27.151"></a><span id="l27.151" class="difflineplus">+ * stages of development. He convinced me to include BOW</span>
<a href="#l27.152"></a><span id="l27.152" class="difflineplus">+ * and EOW constructs, originally invented by Rob Pike at</span>
<a href="#l27.153"></a><span id="l27.153" class="difflineplus">+ * the University of Toronto.</span>
<a href="#l27.154"></a><span id="l27.154">  *</span>
<a href="#l27.155"></a><span id="l27.155">  * References:</span>
<a href="#l27.156"></a><span id="l27.156" class="difflineminus">- *              Software tools			Kernighan &amp; Plauger</span>
<a href="#l27.157"></a><span id="l27.157" class="difflineplus">+ *              Software tools     Kernighan &amp; Plauger</span>
<a href="#l27.158"></a><span id="l27.158">  *              Software tools in Pascal        Kernighan &amp; Plauger</span>
<a href="#l27.159"></a><span id="l27.159">  *              Grep [rsx-11 C dist]            David Conroy</span>
<a href="#l27.160"></a><span id="l27.160" class="difflineminus">- *		ed - text editor		Un*x Programmer's Manual</span>
<a href="#l27.161"></a><span id="l27.161" class="difflineminus">- *		Advanced editing on Un*x	B. W. Kernighan</span>
<a href="#l27.162"></a><span id="l27.162" class="difflineminus">- *		RegExp routines			Henry Spencer</span>
<a href="#l27.163"></a><span id="l27.163" class="difflineplus">+ *              ed - text editor    Un*x Programmer's Manual</span>
<a href="#l27.164"></a><span id="l27.164" class="difflineplus">+ *              Advanced editing on Un*x  B. W. Kernighan</span>
<a href="#l27.165"></a><span id="l27.165" class="difflineplus">+ *              RegExp routines      Henry Spencer</span>
<a href="#l27.166"></a><span id="l27.166">  *</span>
<a href="#l27.167"></a><span id="l27.167">  * Notes:</span>
<a href="#l27.168"></a><span id="l27.168">  *</span>
<a href="#l27.169"></a><span id="l27.169" class="difflineminus">- *	This implementation uses a bit-set representation for character</span>
<a href="#l27.170"></a><span id="l27.170" class="difflineminus">- *	classes for speed and compactness. Each character is represented</span>
<a href="#l27.171"></a><span id="l27.171" class="difflineminus">- *	by one bit in a 128-bit block. Thus, CCL always takes a</span>
<a href="#l27.172"></a><span id="l27.172" class="difflineminus">- *	constant 16 bytes in the internal nfa, and re_exec does a single</span>
<a href="#l27.173"></a><span id="l27.173" class="difflineminus">- *	bit comparison to locate the character in the set.</span>
<a href="#l27.174"></a><span id="l27.174" class="difflineplus">+ * This implementation uses a bit-set representation for character</span>
<a href="#l27.175"></a><span id="l27.175" class="difflineplus">+ * classes for speed and compactness. Each character is represented</span>
<a href="#l27.176"></a><span id="l27.176" class="difflineplus">+ * by one bit in a 128-bit block. Thus, CCL always takes a</span>
<a href="#l27.177"></a><span id="l27.177" class="difflineplus">+ * constant 16 bytes in the internal nfa, and re_exec does a single</span>
<a href="#l27.178"></a><span id="l27.178" class="difflineplus">+ * bit comparison to locate the character in the set.</span>
<a href="#l27.179"></a><span id="l27.179">  *</span>
<a href="#l27.180"></a><span id="l27.180">  * Examples:</span>
<a href="#l27.181"></a><span id="l27.181">  *</span>
<a href="#l27.182"></a><span id="l27.182" class="difflineminus">- *	pattern:	foo*.*</span>
<a href="#l27.183"></a><span id="l27.183" class="difflineminus">- *	compile:	CHR f CHR o CLO CHR o END CLO ANY END END</span>
<a href="#l27.184"></a><span id="l27.184" class="difflineminus">- *	matches:	fo foo fooo foobar fobar foxx ...</span>
<a href="#l27.185"></a><span id="l27.185" class="difflineplus">+ * pattern:  foo*.*</span>
<a href="#l27.186"></a><span id="l27.186" class="difflineplus">+ * compile:  CHR f CHR o CLO CHR o END CLO ANY END END</span>
<a href="#l27.187"></a><span id="l27.187" class="difflineplus">+ * matches:  fo foo fooo foobar fobar foxx ...</span>
<a href="#l27.188"></a><span id="l27.188">  *</span>
<a href="#l27.189"></a><span id="l27.189" class="difflineminus">- *	pattern:	fo[ob]a[rz]</span>
<a href="#l27.190"></a><span id="l27.190" class="difflineminus">- *	compile:	CHR f CHR o CCL bitset CHR a CCL bitset END</span>
<a href="#l27.191"></a><span id="l27.191" class="difflineminus">- *	matches:	fobar fooar fobaz fooaz</span>
<a href="#l27.192"></a><span id="l27.192" class="difflineplus">+ * pattern:  fo[ob]a[rz]</span>
<a href="#l27.193"></a><span id="l27.193" class="difflineplus">+ * compile:  CHR f CHR o CCL bitset CHR a CCL bitset END</span>
<a href="#l27.194"></a><span id="l27.194" class="difflineplus">+ * matches:  fobar fooar fobaz fooaz</span>
<a href="#l27.195"></a><span id="l27.195">  *</span>
<a href="#l27.196"></a><span id="l27.196" class="difflineminus">- *	pattern:	foo\\+</span>
<a href="#l27.197"></a><span id="l27.197" class="difflineminus">- *	compile:	CHR f CHR o CHR o CHR \ CLO CHR \ END END</span>
<a href="#l27.198"></a><span id="l27.198" class="difflineminus">- *	matches:	foo\ foo\\ foo\\\  ...</span>
<a href="#l27.199"></a><span id="l27.199" class="difflineplus">+ * pattern:  foo\\+</span>
<a href="#l27.200"></a><span id="l27.200" class="difflineplus">+ * compile:  CHR f CHR o CHR o CHR \ CLO CHR \ END END</span>
<a href="#l27.201"></a><span id="l27.201" class="difflineplus">+ * matches:  foo\ foo\\ foo\\\  ...</span>
<a href="#l27.202"></a><span id="l27.202">  *</span>
<a href="#l27.203"></a><span id="l27.203" class="difflineminus">- *	pattern:	\(foo\)[1-3]\1	(same as foo[1-3]foo)</span>
<a href="#l27.204"></a><span id="l27.204" class="difflineminus">- *	compile:	BOT 1 CHR f CHR o CHR o EOT 1 CCL bitset REF 1 END</span>
<a href="#l27.205"></a><span id="l27.205" class="difflineminus">- *	matches:	foo1foo foo2foo foo3foo</span>
<a href="#l27.206"></a><span id="l27.206" class="difflineplus">+ * pattern:  \(foo\)[1-3]\1  (same as foo[1-3]foo)</span>
<a href="#l27.207"></a><span id="l27.207" class="difflineplus">+ * compile:  BOT 1 CHR f CHR o CHR o EOT 1 CCL bitset REF 1 END</span>
<a href="#l27.208"></a><span id="l27.208" class="difflineplus">+ * matches:  foo1foo foo2foo foo3foo</span>
<a href="#l27.209"></a><span id="l27.209">  *</span>
<a href="#l27.210"></a><span id="l27.210" class="difflineminus">- *	pattern:	\(fo.*\)-\1</span>
<a href="#l27.211"></a><span id="l27.211" class="difflineminus">- *	compile:	BOT 1 CHR f CHR o CLO ANY END EOT 1 CHR - REF 1 END</span>
<a href="#l27.212"></a><span id="l27.212" class="difflineminus">- *	matches:	foo-foo fo-fo fob-fob foobar-foobar ...</span>
<a href="#l27.213"></a><span id="l27.213" class="difflineplus">+ * pattern:  \(fo.*\)-\1</span>
<a href="#l27.214"></a><span id="l27.214" class="difflineplus">+ * compile:  BOT 1 CHR f CHR o CLO ANY END EOT 1 CHR - REF 1 END</span>
<a href="#l27.215"></a><span id="l27.215" class="difflineplus">+ * matches:  foo-foo fo-fo fob-fob foobar-foobar ...</span>
<a href="#l27.216"></a><span id="l27.216">  */</span>
<a href="#l27.217"></a><span id="l27.217"> </span>
<a href="#l27.218"></a><span id="l27.218"> #  define MAXNFA 1024</span>
<a href="#l27.219"></a><span id="l27.219"> #  define MAXTAG 10</span>
<a href="#l27.220"></a><span id="l27.220"> </span>
<a href="#l27.221"></a><span id="l27.221"> #  define OKP 1</span>
<a href="#l27.222"></a><span id="l27.222"> #  define NOP 0</span>
<a href="#l27.223"></a><span id="l27.223"> </span>
<a href="#l27.224"></a><span id="l27.224" class="difflineat">@@ -466,33 +466,33 @@ static REGEXCHAR *eopat[MAXTAG];</span>
<a href="#l27.225"></a><span id="l27.225"> #  ifdef NEEDPROTOS</span>
<a href="#l27.226"></a><span id="l27.226"> static REGEXCHAR *pmatch(REGEXCHAR *lp, REGEXCHAR *ap);</span>
<a href="#l27.227"></a><span id="l27.227"> #  else  /* NEEDPROTOS */</span>
<a href="#l27.228"></a><span id="l27.228"> static REGEXCHAR *pmatch();</span>
<a href="#l27.229"></a><span id="l27.229"> #  endif /* NEEDPROTOS */</span>
<a href="#l27.230"></a><span id="l27.230"> </span>
<a href="#l27.231"></a><span id="l27.231"> /*</span>
<a href="#l27.232"></a><span id="l27.232">  * re_exec:</span>
<a href="#l27.233"></a><span id="l27.233" class="difflineminus">- * 	execute nfa to find a match.</span>
<a href="#l27.234"></a><span id="l27.234" class="difflineplus">+ *   execute nfa to find a match.</span>
<a href="#l27.235"></a><span id="l27.235">  *</span>
<a href="#l27.236"></a><span id="l27.236" class="difflineminus">- *	special cases: (nfa[0])</span>
<a href="#l27.237"></a><span id="l27.237" class="difflineminus">- *		BOL</span>
<a href="#l27.238"></a><span id="l27.238" class="difflineminus">- *			Match only once, starting from the</span>
<a href="#l27.239"></a><span id="l27.239" class="difflineminus">- *			beginning.</span>
<a href="#l27.240"></a><span id="l27.240" class="difflineminus">- *		CHR</span>
<a href="#l27.241"></a><span id="l27.241" class="difflineminus">- *			First locate the character without</span>
<a href="#l27.242"></a><span id="l27.242" class="difflineminus">- *			calling pmatch, and if found, call</span>
<a href="#l27.243"></a><span id="l27.243" class="difflineminus">- *			pmatch for the remaining string.</span>
<a href="#l27.244"></a><span id="l27.244" class="difflineminus">- *		END</span>
<a href="#l27.245"></a><span id="l27.245" class="difflineminus">- *			re_comp failed, poor luser did not</span>
<a href="#l27.246"></a><span id="l27.246" class="difflineminus">- *			check for it. Fail fast.</span>
<a href="#l27.247"></a><span id="l27.247" class="difflineplus">+ * special cases: (nfa[0])</span>
<a href="#l27.248"></a><span id="l27.248" class="difflineplus">+ *   BOL</span>
<a href="#l27.249"></a><span id="l27.249" class="difflineplus">+ *     Match only once, starting from the</span>
<a href="#l27.250"></a><span id="l27.250" class="difflineplus">+ *     beginning.</span>
<a href="#l27.251"></a><span id="l27.251" class="difflineplus">+ *   CHR</span>
<a href="#l27.252"></a><span id="l27.252" class="difflineplus">+ *     First locate the character without</span>
<a href="#l27.253"></a><span id="l27.253" class="difflineplus">+ *     calling pmatch, and if found, call</span>
<a href="#l27.254"></a><span id="l27.254" class="difflineplus">+ *     pmatch for the remaining string.</span>
<a href="#l27.255"></a><span id="l27.255" class="difflineplus">+ *   END</span>
<a href="#l27.256"></a><span id="l27.256" class="difflineplus">+ *     re_comp failed, poor luser did not</span>
<a href="#l27.257"></a><span id="l27.257" class="difflineplus">+ *     check for it. Fail fast.</span>
<a href="#l27.258"></a><span id="l27.258">  *</span>
<a href="#l27.259"></a><span id="l27.259" class="difflineminus">- *	If a match is found, bopat[0] and eopat[0] are set</span>
<a href="#l27.260"></a><span id="l27.260" class="difflineminus">- *	to the beginning and the end of the matched fragment,</span>
<a href="#l27.261"></a><span id="l27.261" class="difflineminus">- *	respectively.</span>
<a href="#l27.262"></a><span id="l27.262" class="difflineplus">+ * If a match is found, bopat[0] and eopat[0] are set</span>
<a href="#l27.263"></a><span id="l27.263" class="difflineplus">+ * to the beginning and the end of the matched fragment,</span>
<a href="#l27.264"></a><span id="l27.264" class="difflineplus">+ * respectively.</span>
<a href="#l27.265"></a><span id="l27.265">  *</span>
<a href="#l27.266"></a><span id="l27.266">  */</span>
<a href="#l27.267"></a><span id="l27.267"> </span>
<a href="#l27.268"></a><span id="l27.268"> int LDAP_CALL re_exec(const char *lp) {</span>
<a href="#l27.269"></a><span id="l27.269">   register REGEXCHAR c;</span>
<a href="#l27.270"></a><span id="l27.270">   register REGEXCHAR *ep = 0;</span>
<a href="#l27.271"></a><span id="l27.271">   register REGEXCHAR *ap = nfa;</span>
<a href="#l27.272"></a><span id="l27.272"> </span>
<a href="#l27.273"></a><span id="l27.273" class="difflineat">@@ -533,55 +533,55 @@ int LDAP_CALL re_exec(const char *lp) {</span>
<a href="#l27.274"></a><span id="l27.274">   bopat[0] = (REGEXCHAR *)lp;</span>
<a href="#l27.275"></a><span id="l27.275">   eopat[0] = ep;</span>
<a href="#l27.276"></a><span id="l27.276">   return 1;</span>
<a href="#l27.277"></a><span id="l27.277"> }</span>
<a href="#l27.278"></a><span id="l27.278"> </span>
<a href="#l27.279"></a><span id="l27.279"> /*</span>
<a href="#l27.280"></a><span id="l27.280">  * pmatch: internal routine for the hard part</span>
<a href="#l27.281"></a><span id="l27.281">  *</span>
<a href="#l27.282"></a><span id="l27.282" class="difflineminus">- * 	This code is partly snarfed from an early grep written by</span>
<a href="#l27.283"></a><span id="l27.283" class="difflineminus">- *	David Conroy. The backref and tag stuff, and various other</span>
<a href="#l27.284"></a><span id="l27.284" class="difflineminus">- *	innovations are by oz.</span>
<a href="#l27.285"></a><span id="l27.285" class="difflineplus">+ * This code is partly snarfed from an early grep written by</span>
<a href="#l27.286"></a><span id="l27.286" class="difflineplus">+ * David Conroy. The backref and tag stuff, and various other</span>
<a href="#l27.287"></a><span id="l27.287" class="difflineplus">+ * innovations are by oz.</span>
<a href="#l27.288"></a><span id="l27.288">  *</span>
<a href="#l27.289"></a><span id="l27.289" class="difflineminus">- *	special case optimizations: (nfa[n], nfa[n+1])</span>
<a href="#l27.290"></a><span id="l27.290" class="difflineminus">- *		CLO ANY</span>
<a href="#l27.291"></a><span id="l27.291" class="difflineminus">- *			We KNOW .* will match everything up to the</span>
<a href="#l27.292"></a><span id="l27.292" class="difflineminus">- *			end of line. Thus, directly go to the end of</span>
<a href="#l27.293"></a><span id="l27.293" class="difflineminus">- *			line, without recursive pmatch calls. As in</span>
<a href="#l27.294"></a><span id="l27.294" class="difflineminus">- *			the other closure cases, the remaining pattern</span>
<a href="#l27.295"></a><span id="l27.295" class="difflineminus">- *			must be matched by moving backwards on the</span>
<a href="#l27.296"></a><span id="l27.296" class="difflineminus">- *			string recursively, to find a match for xy</span>
<a href="#l27.297"></a><span id="l27.297" class="difflineminus">- *			(x is &quot;.*&quot; and y is the remaining pattern)</span>
<a href="#l27.298"></a><span id="l27.298" class="difflineminus">- *			where the match satisfies the LONGEST match for</span>
<a href="#l27.299"></a><span id="l27.299" class="difflineminus">- *			x followed by a match for y.</span>
<a href="#l27.300"></a><span id="l27.300" class="difflineminus">- *		CLO CHR</span>
<a href="#l27.301"></a><span id="l27.301" class="difflineminus">- *			We can again scan the string forward for the</span>
<a href="#l27.302"></a><span id="l27.302" class="difflineminus">- *			single char and at the point of failure, we</span>
<a href="#l27.303"></a><span id="l27.303" class="difflineminus">- *			execute the remaining nfa recursively, same as</span>
<a href="#l27.304"></a><span id="l27.304" class="difflineminus">- *			above.</span>
<a href="#l27.305"></a><span id="l27.305" class="difflineplus">+ * special case optimizations: (nfa[n], nfa[n+1])</span>
<a href="#l27.306"></a><span id="l27.306" class="difflineplus">+ *   CLO ANY</span>
<a href="#l27.307"></a><span id="l27.307" class="difflineplus">+ *     We KNOW .* will match everything up to the</span>
<a href="#l27.308"></a><span id="l27.308" class="difflineplus">+ *     end of line. Thus, directly go to the end of</span>
<a href="#l27.309"></a><span id="l27.309" class="difflineplus">+ *     line, without recursive pmatch calls. As in</span>
<a href="#l27.310"></a><span id="l27.310" class="difflineplus">+ *     the other closure cases, the remaining pattern</span>
<a href="#l27.311"></a><span id="l27.311" class="difflineplus">+ *     must be matched by moving backwards on the</span>
<a href="#l27.312"></a><span id="l27.312" class="difflineplus">+ *     string recursively, to find a match for xy</span>
<a href="#l27.313"></a><span id="l27.313" class="difflineplus">+ *     (x is &quot;.*&quot; and y is the remaining pattern)</span>
<a href="#l27.314"></a><span id="l27.314" class="difflineplus">+ *     where the match satisfies the LONGEST match for</span>
<a href="#l27.315"></a><span id="l27.315" class="difflineplus">+ *     x followed by a match for y.</span>
<a href="#l27.316"></a><span id="l27.316" class="difflineplus">+ *   CLO CHR</span>
<a href="#l27.317"></a><span id="l27.317" class="difflineplus">+ *     We can again scan the string forward for the</span>
<a href="#l27.318"></a><span id="l27.318" class="difflineplus">+ *     single char and at the point of failure, we</span>
<a href="#l27.319"></a><span id="l27.319" class="difflineplus">+ *     execute the remaining nfa recursively, same as</span>
<a href="#l27.320"></a><span id="l27.320" class="difflineplus">+ *     above.</span>
<a href="#l27.321"></a><span id="l27.321">  *</span>
<a href="#l27.322"></a><span id="l27.322" class="difflineminus">- *	At the end of a successful match, bopat[n] and eopat[n]</span>
<a href="#l27.323"></a><span id="l27.323" class="difflineminus">- *	are set to the beginning and end of subpatterns matched</span>
<a href="#l27.324"></a><span id="l27.324" class="difflineminus">- *	by tagged expressions (n = 1 to 9).</span>
<a href="#l27.325"></a><span id="l27.325" class="difflineplus">+ * At the end of a successful match, bopat[n] and eopat[n]</span>
<a href="#l27.326"></a><span id="l27.326" class="difflineplus">+ * are set to the beginning and end of subpatterns matched</span>
<a href="#l27.327"></a><span id="l27.327" class="difflineplus">+ * by tagged expressions (n = 1 to 9).</span>
<a href="#l27.328"></a><span id="l27.328">  *</span>
<a href="#l27.329"></a><span id="l27.329">  */</span>
<a href="#l27.330"></a><span id="l27.330"> </span>
<a href="#l27.331"></a><span id="l27.331"> #  ifndef re_fail</span>
<a href="#l27.332"></a><span id="l27.332"> extern void re_fail();</span>
<a href="#l27.333"></a><span id="l27.333"> #  endif /* re_fail */</span>
<a href="#l27.334"></a><span id="l27.334"> </span>
<a href="#l27.335"></a><span id="l27.335"> /*</span>
<a href="#l27.336"></a><span id="l27.336">  * character classification table for word boundary operators BOW</span>
<a href="#l27.337"></a><span id="l27.337">  * and EOW. the reason for not using ctype macros is that we can</span>
<a href="#l27.338"></a><span id="l27.338">  * let the user add into our own table. see re_modw. This table</span>
<a href="#l27.339"></a><span id="l27.339">  * is not in the bitset form, since we may wish to extend it in the</span>
<a href="#l27.340"></a><span id="l27.340">  * future for other character classifications.</span>
<a href="#l27.341"></a><span id="l27.341">  *</span>
<a href="#l27.342"></a><span id="l27.342" class="difflineminus">- *	TRUE for 0-9 A-Z a-z _</span>
<a href="#l27.343"></a><span id="l27.343" class="difflineplus">+ * TRUE for 0-9 A-Z a-z _</span>
<a href="#l27.344"></a><span id="l27.344">  */</span>
<a href="#l27.345"></a><span id="l27.345"> static char chrtyp[MAXCHR] = {</span>
<a href="#l27.346"></a><span id="l27.346">     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<a href="#l27.347"></a><span id="l27.347">     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<a href="#l27.348"></a><span id="l27.348">     0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1,</span>
<a href="#l27.349"></a><span id="l27.349">     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,</span>
<a href="#l27.350"></a><span id="l27.350">     1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,</span>
<a href="#l27.351"></a><span id="l27.351">     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};</span>
<a href="#l27.352"></a><span id="l27.352" class="difflineat">@@ -591,25 +591,25 @@ static char chrtyp[MAXCHR] = {</span>
<a href="#l27.353"></a><span id="l27.353"> #  define iswordc(x) chrtyp[inascii(x)]</span>
<a href="#l27.354"></a><span id="l27.354"> #  define isinset(x, y) \</span>
<a href="#l27.355"></a><span id="l27.355">     (((y)&amp;HIBIT) ? 0 : ((x)[((y)&amp;BLKIND) &gt;&gt; 3] &amp; bitarr[(y)&amp;BITIND]))</span>
<a href="#l27.356"></a><span id="l27.356"> </span>
<a href="#l27.357"></a><span id="l27.357"> /*</span>
<a href="#l27.358"></a><span id="l27.358">  * skip values for CLO XXX to skip past the closure</span>
<a href="#l27.359"></a><span id="l27.359">  */</span>
<a href="#l27.360"></a><span id="l27.360"> </span>
<a href="#l27.361"></a><span id="l27.361" class="difflineminus">-#  define ANYSKIP 2  /* [CLO] ANY END ...	     */</span>
<a href="#l27.362"></a><span id="l27.362" class="difflineplus">+#  define ANYSKIP 2  /* [CLO] ANY END ...       */</span>
<a href="#l27.363"></a><span id="l27.363"> #  define CHRSKIP 3  /* [CLO] CHR chr END ...     */</span>
<a href="#l27.364"></a><span id="l27.364"> #  define CCLSKIP 18 /* [CLO] CCL 16bytes END ... */</span>
<a href="#l27.365"></a><span id="l27.365"> </span>
<a href="#l27.366"></a><span id="l27.366"> static REGEXCHAR *pmatch(REGEXCHAR *lp, REGEXCHAR *ap) {</span>
<a href="#l27.367"></a><span id="l27.367">   register int op, c, n;</span>
<a href="#l27.368"></a><span id="l27.368">   register REGEXCHAR *e;  /* extra pointer for CLO */</span>
<a href="#l27.369"></a><span id="l27.369">   register REGEXCHAR *bp; /* beginning of subpat.. */</span>
<a href="#l27.370"></a><span id="l27.370" class="difflineminus">-  register REGEXCHAR *ep; /* ending of subpat..	 */</span>
<a href="#l27.371"></a><span id="l27.371" class="difflineplus">+  register REGEXCHAR *ep; /* ending of subpat..   */</span>
<a href="#l27.372"></a><span id="l27.372">   REGEXCHAR *are;         /* to save the line ptr. */</span>
<a href="#l27.373"></a><span id="l27.373"> </span>
<a href="#l27.374"></a><span id="l27.374">   while ((op = *ap++) != END) switch (op) {</span>
<a href="#l27.375"></a><span id="l27.375">       case CHR:</span>
<a href="#l27.376"></a><span id="l27.376">         if (*lp++ != *ap++) return 0;</span>
<a href="#l27.377"></a><span id="l27.377">         break;</span>
<a href="#l27.378"></a><span id="l27.378">       case ANY:</span>
<a href="#l27.379"></a><span id="l27.379">         if (!*lp++) return 0;</span>
<a href="#l27.380"></a><span id="l27.380" class="difflineat">@@ -676,23 +676,23 @@ static REGEXCHAR *pmatch(REGEXCHAR *lp, </span>
<a href="#l27.381"></a><span id="l27.381">         re_fail(&quot;re_exec: bad nfa.&quot;, op);</span>
<a href="#l27.382"></a><span id="l27.382">         return 0;</span>
<a href="#l27.383"></a><span id="l27.383">     }</span>
<a href="#l27.384"></a><span id="l27.384">   return lp;</span>
<a href="#l27.385"></a><span id="l27.385"> }</span>
<a href="#l27.386"></a><span id="l27.386"> </span>
<a href="#l27.387"></a><span id="l27.387"> /*</span>
<a href="#l27.388"></a><span id="l27.388">  * re_modw:</span>
<a href="#l27.389"></a><span id="l27.389" class="difflineminus">- *	add new characters into the word table to change re_exec's</span>
<a href="#l27.390"></a><span id="l27.390" class="difflineminus">- *	understanding of what a word should look like. Note that we</span>
<a href="#l27.391"></a><span id="l27.391" class="difflineminus">- *	only accept additions into the word definition.</span>
<a href="#l27.392"></a><span id="l27.392" class="difflineplus">+ * add new characters into the word table to change re_exec's</span>
<a href="#l27.393"></a><span id="l27.393" class="difflineplus">+ * understanding of what a word should look like. Note that we</span>
<a href="#l27.394"></a><span id="l27.394" class="difflineplus">+ * only accept additions into the word definition.</span>
<a href="#l27.395"></a><span id="l27.395">  *</span>
<a href="#l27.396"></a><span id="l27.396" class="difflineminus">- *	If the string parameter is 0 or null string, the table is</span>
<a href="#l27.397"></a><span id="l27.397" class="difflineminus">- *	reset back to the default containing A-Z a-z 0-9 _. [We use</span>
<a href="#l27.398"></a><span id="l27.398" class="difflineminus">- *	the compact bitset representation for the default table]</span>
<a href="#l27.399"></a><span id="l27.399" class="difflineplus">+ * If the string parameter is 0 or null string, the table is</span>
<a href="#l27.400"></a><span id="l27.400" class="difflineplus">+ * reset back to the default containing A-Z a-z 0-9 _. [We use</span>
<a href="#l27.401"></a><span id="l27.401" class="difflineplus">+ * the compact bitset representation for the default table]</span>
<a href="#l27.402"></a><span id="l27.402">  */</span>
<a href="#l27.403"></a><span id="l27.403"> </span>
<a href="#l27.404"></a><span id="l27.404"> static REGEXCHAR deftab[16] = {0,    0,    0,    0,    0,    0,    0377, 003,</span>
<a href="#l27.405"></a><span id="l27.405">                                0376, 0377, 0377, 0207, 0376, 0377, 0377, 007};</span>
<a href="#l27.406"></a><span id="l27.406"> </span>
<a href="#l27.407"></a><span id="l27.407"> void LDAP_CALL re_modw(char *s) {</span>
<a href="#l27.408"></a><span id="l27.408">   register int i;</span>
<a href="#l27.409"></a><span id="l27.409"> </span>
<a href="#l27.410"></a><span id="l27.410" class="difflineat">@@ -700,23 +700,23 @@ void LDAP_CALL re_modw(char *s) {</span>
<a href="#l27.411"></a><span id="l27.411">     for (i = 0; i &lt; MAXCHR; i++)</span>
<a href="#l27.412"></a><span id="l27.412">       if (!isinset(deftab, i)) iswordc(i) = 0;</span>
<a href="#l27.413"></a><span id="l27.413">   } else</span>
<a href="#l27.414"></a><span id="l27.414">     while (*s) iswordc(*s++) = 1;</span>
<a href="#l27.415"></a><span id="l27.415"> }</span>
<a href="#l27.416"></a><span id="l27.416"> </span>
<a href="#l27.417"></a><span id="l27.417"> /*</span>
<a href="#l27.418"></a><span id="l27.418">  * re_subs:</span>
<a href="#l27.419"></a><span id="l27.419" class="difflineminus">- *	substitute the matched portions of the src in dst.</span>
<a href="#l27.420"></a><span id="l27.420" class="difflineplus">+ * substitute the matched portions of the src in dst.</span>
<a href="#l27.421"></a><span id="l27.421">  *</span>
<a href="#l27.422"></a><span id="l27.422" class="difflineminus">- *	&amp;	substitute the entire matched pattern.</span>
<a href="#l27.423"></a><span id="l27.423" class="difflineplus">+ * &amp;  substitute the entire matched pattern.</span>
<a href="#l27.424"></a><span id="l27.424">  *</span>
<a href="#l27.425"></a><span id="l27.425" class="difflineminus">- *	\digit	substitute a subpattern, with the given	tag number.</span>
<a href="#l27.426"></a><span id="l27.426" class="difflineminus">- *		Tags are numbered from 1 to 9. If the particular</span>
<a href="#l27.427"></a><span id="l27.427" class="difflineminus">- *		tagged subpattern does not exist, null is substituted.</span>
<a href="#l27.428"></a><span id="l27.428" class="difflineplus">+ * \digit  substitute a subpattern, with the given  tag number.</span>
<a href="#l27.429"></a><span id="l27.429" class="difflineplus">+ *   Tags are numbered from 1 to 9. If the particular</span>
<a href="#l27.430"></a><span id="l27.430" class="difflineplus">+ *   tagged subpattern does not exist, null is substituted.</span>
<a href="#l27.431"></a><span id="l27.431">  */</span>
<a href="#l27.432"></a><span id="l27.432"> int LDAP_CALL re_subs(char *src, char *dst) {</span>
<a href="#l27.433"></a><span id="l27.433">   register char c;</span>
<a href="#l27.434"></a><span id="l27.434">   register int pin;</span>
<a href="#l27.435"></a><span id="l27.435">   register REGEXCHAR *bp;</span>
<a href="#l27.436"></a><span id="l27.436">   register REGEXCHAR *ep;</span>
<a href="#l27.437"></a><span id="l27.437"> </span>
<a href="#l27.438"></a><span id="l27.438">   if (!*src || !bopat[0]) return 0;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/rename.c</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/rename.c</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -48,48 +48,49 @@ static char copyright[] = &quot;@(#) Copyrigh</span>
<a href="#l28.4"></a><span id="l28.4"> #  endif</span>
<a href="#l28.5"></a><span id="l28.5"> #endif</span>
<a href="#l28.6"></a><span id="l28.6"> </span>
<a href="#l28.7"></a><span id="l28.7"> #include &quot;ldap-int.h&quot;</span>
<a href="#l28.8"></a><span id="l28.8"> </span>
<a href="#l28.9"></a><span id="l28.9"> /*</span>
<a href="#l28.10"></a><span id="l28.10">  * ldap_rename - initiate an ldap modifyDN operation. Parameters:</span>
<a href="#l28.11"></a><span id="l28.11">  *</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">- *	ld		LDAP descriptor</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineminus">- *	dn		DN of the object to modify</span>
<a href="#l28.14"></a><span id="l28.14" class="difflineminus">- *	newrdn		RDN that will form leftmost component of entry's new</span>
<a href="#l28.15"></a><span id="l28.15" class="difflineminus">- *name newparent       if present, this is the Distinguished Name of the entry</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineminus">- *                      which becomes the immediate parent of the existing entry</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineminus">- *	deleteoldrdn	nonzero means to delete old rdn values from the entry</span>
<a href="#l28.18"></a><span id="l28.18" class="difflineminus">- *                      while zero means to retain them as attributes of the</span>
<a href="#l28.19"></a><span id="l28.19" class="difflineminus">- *entry serverctrls     list of LDAP server controls clientctrls     list of</span>
<a href="#l28.20"></a><span id="l28.20" class="difflineminus">- *client controls msgidp          this result parameter will be set to the</span>
<a href="#l28.21"></a><span id="l28.21" class="difflineminus">- *message id of the request if the ldap_rename() call succeeds</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineplus">+ * ld             LDAP descriptor</span>
<a href="#l28.23"></a><span id="l28.23" class="difflineplus">+ * dn             DN of the object to modify</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineplus">+ * newrdn         RDN that will form leftmost component of entry's new name</span>
<a href="#l28.25"></a><span id="l28.25" class="difflineplus">+ * newparent      if present, this is the Distinguished Name of the entry</span>
<a href="#l28.26"></a><span id="l28.26" class="difflineplus">+ *                which becomes the immediate parent of the existing entry</span>
<a href="#l28.27"></a><span id="l28.27" class="difflineplus">+ * deleteoldrdn   nonzero means to delete old rdn values from the entry</span>
<a href="#l28.28"></a><span id="l28.28" class="difflineplus">+ *                while zero means to retain them as attributes of the entry</span>
<a href="#l28.29"></a><span id="l28.29" class="difflineplus">+ * serverctrls    list of LDAP server controls</span>
<a href="#l28.30"></a><span id="l28.30" class="difflineplus">+ * clientctrls    list of client controls</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineplus">+ * msgidp         this result parameter will be set to the message id of the</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+ *                request if the ldap_rename() call succeeds</span>
<a href="#l28.33"></a><span id="l28.33">  *</span>
<a href="#l28.34"></a><span id="l28.34">  * Example:</span>
<a href="#l28.35"></a><span id="l28.35" class="difflineminus">- *      int rc;</span>
<a href="#l28.36"></a><span id="l28.36" class="difflineminus">- *	rc = ldap_rename( ld, dn, newrdn, newparent, deleteoldrdn, serverctrls,</span>
<a href="#l28.37"></a><span id="l28.37" class="difflineminus">- *clientctrls, &amp;msgid );</span>
<a href="#l28.38"></a><span id="l28.38" class="difflineplus">+ * int rc;</span>
<a href="#l28.39"></a><span id="l28.39" class="difflineplus">+ * rc = ldap_rename(ld, dn, newrdn, newparent, deleteoldrdn, serverctrls,</span>
<a href="#l28.40"></a><span id="l28.40" class="difflineplus">+ *                  clientctrls, &amp;msgid);</span>
<a href="#l28.41"></a><span id="l28.41">  */</span>
<a href="#l28.42"></a><span id="l28.42"> int LDAP_CALL</span>
<a href="#l28.43"></a><span id="l28.43"> ldap_rename(LDAP *ld, const char *dn, const char *newrdn, const char *newparent,</span>
<a href="#l28.44"></a><span id="l28.44">             int deleteoldrdn, LDAPControl **serverctrls,</span>
<a href="#l28.45"></a><span id="l28.45">             LDAPControl **clientctrls, /* not used for anything yet */</span>
<a href="#l28.46"></a><span id="l28.46">             int *msgidp) {</span>
<a href="#l28.47"></a><span id="l28.47">   BerElement *ber;</span>
<a href="#l28.48"></a><span id="l28.48">   int rc, err;</span>
<a href="#l28.49"></a><span id="l28.49"> </span>
<a href="#l28.50"></a><span id="l28.50">   /*</span>
<a href="#l28.51"></a><span id="l28.51">    * A modify dn request looks like this:</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineminus">-   *	ModifyDNRequest ::= SEQUENCE {</span>
<a href="#l28.53"></a><span id="l28.53" class="difflineminus">-   *		entry		LDAPDN,</span>
<a href="#l28.54"></a><span id="l28.54" class="difflineminus">-   *		newrdn		RelativeLDAPDN,</span>
<a href="#l28.55"></a><span id="l28.55" class="difflineminus">-   *              newparent       [0] LDAPDN OPTIONAL,</span>
<a href="#l28.56"></a><span id="l28.56" class="difflineminus">-   *		deleteoldrdn	BOOLEAN</span>
<a href="#l28.57"></a><span id="l28.57" class="difflineminus">-   *	}</span>
<a href="#l28.58"></a><span id="l28.58" class="difflineplus">+   * ModifyDNRequest ::= SEQUENCE {</span>
<a href="#l28.59"></a><span id="l28.59" class="difflineplus">+   *   entry  LDAPDN,</span>
<a href="#l28.60"></a><span id="l28.60" class="difflineplus">+   *   newrdn  RelativeLDAPDN,</span>
<a href="#l28.61"></a><span id="l28.61" class="difflineplus">+   *   newparent [0] LDAPDN OPTIONAL,</span>
<a href="#l28.62"></a><span id="l28.62" class="difflineplus">+   *   deleteoldrdn  BOOLEAN</span>
<a href="#l28.63"></a><span id="l28.63" class="difflineplus">+   * }</span>
<a href="#l28.64"></a><span id="l28.64">    */</span>
<a href="#l28.65"></a><span id="l28.65"> </span>
<a href="#l28.66"></a><span id="l28.66">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_rename\n&quot;, 0, 0, 0);</span>
<a href="#l28.67"></a><span id="l28.67"> </span>
<a href="#l28.68"></a><span id="l28.68">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l28.69"></a><span id="l28.69">     return (LDAP_PARAM_ERROR);</span>
<a href="#l28.70"></a><span id="l28.70">   }</span>
<a href="#l28.71"></a><span id="l28.71">   if (NULL == newrdn) {</span>
<a href="#l28.72"></a><span id="l28.72" class="difflineat">@@ -123,25 +124,25 @@ ldap_rename(LDAP *ld, const char *dn, co</span>
<a href="#l28.73"></a><span id="l28.73">       if ((rc = (ld-&gt;ld_cache_modrdn)(ld, *msgidp, LDAP_REQ_MODRDN, dn, newrdn,</span>
<a href="#l28.74"></a><span id="l28.74">                                       deleteoldrdn)) != 0) {</span>
<a href="#l28.75"></a><span id="l28.75">         *msgidp = rc;</span>
<a href="#l28.76"></a><span id="l28.76">         LDAP_MUTEX_UNLOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l28.77"></a><span id="l28.77">         return (LDAP_SUCCESS);</span>
<a href="#l28.78"></a><span id="l28.78">       }</span>
<a href="#l28.79"></a><span id="l28.79">       LDAP_MUTEX_UNLOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l28.80"></a><span id="l28.80"> #if 0</span>
<a href="#l28.81"></a><span id="l28.81" class="difflineminus">-		} else if ( ld-&gt;ld_cache_rename != NULL ) {</span>
<a href="#l28.82"></a><span id="l28.82" class="difflineminus">-			LDAP_MUTEX_LOCK( ld, LDAP_CACHE_LOCK );</span>
<a href="#l28.83"></a><span id="l28.83" class="difflineminus">-			if ( (rc = (ld-&gt;ld_cache_rename)( ld, *msgidp,</span>
<a href="#l28.84"></a><span id="l28.84" class="difflineminus">-			    LDAP_REQ_MODDN, dn, newrdn, newparent,</span>
<a href="#l28.85"></a><span id="l28.85" class="difflineminus">-			    deleteoldrdn )) != 0 ) {   </span>
<a href="#l28.86"></a><span id="l28.86" class="difflineminus">-				*msgidp = rc;</span>
<a href="#l28.87"></a><span id="l28.87" class="difflineminus">-				return( LDAP_SUCCESS );</span>
<a href="#l28.88"></a><span id="l28.88" class="difflineminus">-			}</span>
<a href="#l28.89"></a><span id="l28.89" class="difflineminus">-			LDAP_MUTEX_UNLOCK( ld, LDAP_CACHE_LOCK );</span>
<a href="#l28.90"></a><span id="l28.90" class="difflineplus">+    } else if (ld-&gt;ld_cache_rename != NULL) {</span>
<a href="#l28.91"></a><span id="l28.91" class="difflineplus">+      LDAP_MUTEX_LOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l28.92"></a><span id="l28.92" class="difflineplus">+      if ((rc = (ld-&gt;ld_cache_rename)(ld, *msgidp,</span>
<a href="#l28.93"></a><span id="l28.93" class="difflineplus">+                 LDAP_REQ_MODDN, dn, newrdn, newparent,</span>
<a href="#l28.94"></a><span id="l28.94" class="difflineplus">+                 deleteoldrdn )) != 0) {   </span>
<a href="#l28.95"></a><span id="l28.95" class="difflineplus">+        *msgidp = rc;</span>
<a href="#l28.96"></a><span id="l28.96" class="difflineplus">+        return(LDAP_SUCCESS);</span>
<a href="#l28.97"></a><span id="l28.97" class="difflineplus">+      }</span>
<a href="#l28.98"></a><span id="l28.98" class="difflineplus">+      LDAP_MUTEX_UNLOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l28.99"></a><span id="l28.99"> #endif</span>
<a href="#l28.100"></a><span id="l28.100">     }</span>
<a href="#l28.101"></a><span id="l28.101">   }</span>
<a href="#l28.102"></a><span id="l28.102"> </span>
<a href="#l28.103"></a><span id="l28.103">   /* create a message to send */</span>
<a href="#l28.104"></a><span id="l28.104">   if ((err = nsldapi_alloc_ber_with_options(ld, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l28.105"></a><span id="l28.105">     return (err);</span>
<a href="#l28.106"></a><span id="l28.106">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/request.c</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/request.c</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -469,21 +469,21 @@ int nsldapi_send_ber_message(LDAP *ld, S</span>
<a href="#l29.4"></a><span id="l29.4">   return (rc);</span>
<a href="#l29.5"></a><span id="l29.5"> }</span>
<a href="#l29.6"></a><span id="l29.6"> </span>
<a href="#l29.7"></a><span id="l29.7"> /*</span>
<a href="#l29.8"></a><span id="l29.8">  * nsldapi_send_pending_requests_nolock(): Send one or more pending requests</span>
<a href="#l29.9"></a><span id="l29.9">  * that are associated with connection 'lc'.</span>
<a href="#l29.10"></a><span id="l29.10">  *</span>
<a href="#l29.11"></a><span id="l29.11">  * Return values:  0 -- success.</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">- *		  -1 -- fatal error; connection closed.</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+ *                -1 -- fatal error; connection closed.</span>
<a href="#l29.14"></a><span id="l29.14">  *</span>
<a href="#l29.15"></a><span id="l29.15">  * Must be called with these two mutexes locked, in this order:</span>
<a href="#l29.16"></a><span id="l29.16" class="difflineminus">- *	LDAP_CONN_LOCK</span>
<a href="#l29.17"></a><span id="l29.17" class="difflineminus">- *	LDAP_REQ_LOCK</span>
<a href="#l29.18"></a><span id="l29.18" class="difflineplus">+ * LDAP_CONN_LOCK</span>
<a href="#l29.19"></a><span id="l29.19" class="difflineplus">+ * LDAP_REQ_LOCK</span>
<a href="#l29.20"></a><span id="l29.20">  */</span>
<a href="#l29.21"></a><span id="l29.21"> int nsldapi_send_pending_requests_nolock(LDAP *ld, LDAPConn *lc) {</span>
<a href="#l29.22"></a><span id="l29.22">   int err;</span>
<a href="#l29.23"></a><span id="l29.23">   int waiting_for_a_response = 0;</span>
<a href="#l29.24"></a><span id="l29.24">   int rc = 0;</span>
<a href="#l29.25"></a><span id="l29.25">   LDAPRequest *lr;</span>
<a href="#l29.26"></a><span id="l29.26">   char *logname = &quot;nsldapi_send_pending_requests_nolock&quot;;</span>
<a href="#l29.27"></a><span id="l29.27"> </span>
<a href="#l29.28"></a><span id="l29.28" class="difflineat">@@ -984,18 +984,18 @@ void nsldapi_free_request(LDAP *ld, LDAP</span>
<a href="#l29.29"></a><span id="l29.29">   }</span>
<a href="#l29.30"></a><span id="l29.30">   NSLDAPI_FREE(lr);</span>
<a href="#l29.31"></a><span id="l29.31"> }</span>
<a href="#l29.32"></a><span id="l29.32"> </span>
<a href="#l29.33"></a><span id="l29.33"> /*</span>
<a href="#l29.34"></a><span id="l29.34">  * Add a request to the end of the list of outstanding requests.</span>
<a href="#l29.35"></a><span id="l29.35">  * This function must be called with these two locks in hand, acquired in</span>
<a href="#l29.36"></a><span id="l29.36">  * this order:</span>
<a href="#l29.37"></a><span id="l29.37" class="difflineminus">- *	LDAP_CONN_LOCK</span>
<a href="#l29.38"></a><span id="l29.38" class="difflineminus">- *	LDAP_REQ_LOCK</span>
<a href="#l29.39"></a><span id="l29.39" class="difflineplus">+ * LDAP_CONN_LOCK</span>
<a href="#l29.40"></a><span id="l29.40" class="difflineplus">+ * LDAP_REQ_LOCK</span>
<a href="#l29.41"></a><span id="l29.41">  */</span>
<a href="#l29.42"></a><span id="l29.42"> void nsldapi_queue_request_nolock(LDAP *ld, LDAPRequest *lr) {</span>
<a href="#l29.43"></a><span id="l29.43">   if (NULL == ld-&gt;ld_requests) {</span>
<a href="#l29.44"></a><span id="l29.44">     ld-&gt;ld_requests = lr;</span>
<a href="#l29.45"></a><span id="l29.45">   } else {</span>
<a href="#l29.46"></a><span id="l29.46">     LDAPRequest *tmplr;</span>
<a href="#l29.47"></a><span id="l29.47"> </span>
<a href="#l29.48"></a><span id="l29.48">     for (tmplr = ld-&gt;ld_requests; tmplr-&gt;lr_next != NULL;</span>
<a href="#l29.49"></a><span id="l29.49" class="difflineat">@@ -1151,18 +1151,18 @@ int nsldapi_chase_v3_refs(LDAP *ld, LDAP</span>
<a href="#l29.50"></a><span id="l29.50"> </span>
<a href="#l29.51"></a><span id="l29.51">   return (rc); /* last error is as good as any other I guess... */</span>
<a href="#l29.52"></a><span id="l29.52"> }</span>
<a href="#l29.53"></a><span id="l29.53"> </span>
<a href="#l29.54"></a><span id="l29.54"> /*</span>
<a href="#l29.55"></a><span id="l29.55">  * returns an LDAP error code</span>
<a href="#l29.56"></a><span id="l29.56">  *</span>
<a href="#l29.57"></a><span id="l29.57">  * XXXmcs: this function used to have #ifdef LDAP_DNS code in it but I</span>
<a href="#l29.58"></a><span id="l29.58" class="difflineminus">- *	removed it when I improved the parsing (we don't define LDAP_DNS</span>
<a href="#l29.59"></a><span id="l29.59" class="difflineminus">- *	here at Netscape).</span>
<a href="#l29.60"></a><span id="l29.60" class="difflineplus">+ * removed it when I improved the parsing (we don't define LDAP_DNS</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineplus">+ * here at Netscape).</span>
<a href="#l29.62"></a><span id="l29.62">  */</span>
<a href="#l29.63"></a><span id="l29.63"> static int chase_one_referral(LDAP *ld, LDAPRequest *lr, LDAPRequest *origreq,</span>
<a href="#l29.64"></a><span id="l29.64">                               char *refurl, char *desc, int *unknownp,</span>
<a href="#l29.65"></a><span id="l29.65">                               int is_reference) {</span>
<a href="#l29.66"></a><span id="l29.66">   int rc, tmprc, secure, msgid;</span>
<a href="#l29.67"></a><span id="l29.67">   LDAPServer *srv;</span>
<a href="#l29.68"></a><span id="l29.68">   BerElement *ber;</span>
<a href="#l29.69"></a><span id="l29.69">   LDAPURLDesc *ludp;</span>
<a href="#l29.70"></a><span id="l29.70" class="difflineat">@@ -1455,19 +1455,19 @@ LDAPRequest *nsldapi_find_request_by_msg</span>
<a href="#l29.71"></a><span id="l29.71">  * Sockbuf &quot;sb.&quot;  sb == NULL means we don't know specifically where</span>
<a href="#l29.72"></a><span id="l29.72">  * the problem was so we assume all connections are bad.</span>
<a href="#l29.73"></a><span id="l29.73">  */</span>
<a href="#l29.74"></a><span id="l29.74"> void nsldapi_connection_lost_nolock(LDAP *ld, Sockbuf *sb) {</span>
<a href="#l29.75"></a><span id="l29.75">   LDAPRequest *lr;</span>
<a href="#l29.76"></a><span id="l29.76"> </span>
<a href="#l29.77"></a><span id="l29.77">   /*</span>
<a href="#l29.78"></a><span id="l29.78">    * change status of all pending requests that are associated with &quot;sb</span>
<a href="#l29.79"></a><span id="l29.79" class="difflineminus">-   *	to &quot;connection dead.&quot;</span>
<a href="#l29.80"></a><span id="l29.80" class="difflineplus">+   * to &quot;connection dead.&quot;</span>
<a href="#l29.81"></a><span id="l29.81">    * also change the connection status to &quot;dead&quot; and remove it from</span>
<a href="#l29.82"></a><span id="l29.82" class="difflineminus">-   *	the list of sockets we are interested in.</span>
<a href="#l29.83"></a><span id="l29.83" class="difflineplus">+   * the list of sockets we are interested in.</span>
<a href="#l29.84"></a><span id="l29.84">    */</span>
<a href="#l29.85"></a><span id="l29.85">   for (lr = ld-&gt;ld_requests; lr != NULL; lr = lr-&gt;lr_next) {</span>
<a href="#l29.86"></a><span id="l29.86">     if (sb == NULL || (lr-&gt;lr_conn != NULL &amp;&amp; lr-&gt;lr_conn-&gt;lconn_sb == sb)) {</span>
<a href="#l29.87"></a><span id="l29.87">       lr-&gt;lr_status = LDAP_REQST_CONNDEAD;</span>
<a href="#l29.88"></a><span id="l29.88">       if (lr-&gt;lr_conn != NULL) {</span>
<a href="#l29.89"></a><span id="l29.89">         lr-&gt;lr_conn-&gt;lconn_status = LDAP_CONNST_DEAD;</span>
<a href="#l29.90"></a><span id="l29.90">         nsldapi_iostatus_interest_clear(ld, lr-&gt;lr_conn-&gt;lconn_sb);</span>
<a href="#l29.91"></a><span id="l29.91">       }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/result.c</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/result.c</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -72,27 +72,27 @@ static int build_result_ber(LDAP *ld, Be</span>
<a href="#l30.4"></a><span id="l30.4"> static void merge_error_info(LDAP *ld, LDAPRequest *parentr, LDAPRequest *lr);</span>
<a href="#l30.5"></a><span id="l30.5"> #if defined(CLDAP)</span>
<a href="#l30.6"></a><span id="l30.6"> static int cldap_select1(LDAP *ld, struct timeval *timeout);</span>
<a href="#l30.7"></a><span id="l30.7"> #endif</span>
<a href="#l30.8"></a><span id="l30.8"> static void link_pend(LDAP *ld, LDAPPend *lp);</span>
<a href="#l30.9"></a><span id="l30.9"> </span>
<a href="#l30.10"></a><span id="l30.10"> /*</span>
<a href="#l30.11"></a><span id="l30.11">  * ldap_result - wait for an ldap result response to a message from the</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">- * ldap server.  If msgid is -1, any message will be accepted, otherwise</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineminus">- * ldap_result will wait for a response with msgid.  If all is 0 the</span>
<a href="#l30.14"></a><span id="l30.14" class="difflineplus">+ * ldap server. If msgid is -1, any message will be accepted, otherwise</span>
<a href="#l30.15"></a><span id="l30.15" class="difflineplus">+ * ldap_result will wait for a response with msgid. If all is 0 the</span>
<a href="#l30.16"></a><span id="l30.16">  * first message with id msgid will be accepted, otherwise, ldap_result</span>
<a href="#l30.17"></a><span id="l30.17">  * will wait for all responses with id msgid and then return a pointer to</span>
<a href="#l30.18"></a><span id="l30.18" class="difflineminus">- * the entire list of messages.  This is only useful for search responses,</span>
<a href="#l30.19"></a><span id="l30.19" class="difflineplus">+ * the entire list of messages. This is only useful for search responses,</span>
<a href="#l30.20"></a><span id="l30.20">  * which can be of two message types (zero or more entries, followed by an</span>
<a href="#l30.21"></a><span id="l30.21" class="difflineminus">- * ldap result).  The type of the first message received is returned.</span>
<a href="#l30.22"></a><span id="l30.22" class="difflineplus">+ * ldap result). The type of the first message received is returned.</span>
<a href="#l30.23"></a><span id="l30.23">  * When waiting, any messages that have been abandoned are discarded.</span>
<a href="#l30.24"></a><span id="l30.24">  *</span>
<a href="#l30.25"></a><span id="l30.25">  * Example:</span>
<a href="#l30.26"></a><span id="l30.26" class="difflineminus">- *	ldap_result( s, msgid, all, timeout, result )</span>
<a href="#l30.27"></a><span id="l30.27" class="difflineplus">+ * ldap_result(s, msgid, all, timeout, result)</span>
<a href="#l30.28"></a><span id="l30.28">  */</span>
<a href="#l30.29"></a><span id="l30.29"> int LDAP_CALL ldap_result(LDAP *ld, int msgid, int all, struct timeval *timeout,</span>
<a href="#l30.30"></a><span id="l30.30">                           LDAPMessage **result) {</span>
<a href="#l30.31"></a><span id="l30.31">   int rc;</span>
<a href="#l30.32"></a><span id="l30.32"> </span>
<a href="#l30.33"></a><span id="l30.33">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_result\n&quot;, 0, 0, 0);</span>
<a href="#l30.34"></a><span id="l30.34"> </span>
<a href="#l30.35"></a><span id="l30.35">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l30.36"></a><span id="l30.36" class="difflineat">@@ -113,17 +113,17 @@ int nsldapi_result_nolock(LDAP *ld, int </span>
<a href="#l30.37"></a><span id="l30.37">   int rc;</span>
<a href="#l30.38"></a><span id="l30.38"> </span>
<a href="#l30.39"></a><span id="l30.39">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;nsldapi_result_nolock (msgid=%d, all=%d)\n&quot;,</span>
<a href="#l30.40"></a><span id="l30.40">             msgid, all, 0);</span>
<a href="#l30.41"></a><span id="l30.41"> </span>
<a href="#l30.42"></a><span id="l30.42">   /*</span>
<a href="#l30.43"></a><span id="l30.43">    * First, look through the list of responses we have received on</span>
<a href="#l30.44"></a><span id="l30.44">    * this association and see if the response we're interested in</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineminus">-   * is there.  If it is, return it.  If not, call wait4msg() to</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineplus">+   * is there. If it is, return it. If not, call wait4msg() to</span>
<a href="#l30.47"></a><span id="l30.47">    * wait until it arrives or timeout occurs.</span>
<a href="#l30.48"></a><span id="l30.48">    */</span>
<a href="#l30.49"></a><span id="l30.49"> </span>
<a href="#l30.50"></a><span id="l30.50">   if (result == NULL) {</span>
<a href="#l30.51"></a><span id="l30.51">     LDAP_SET_LDERRNO(ld, LDAP_PARAM_ERROR, NULL, NULL);</span>
<a href="#l30.52"></a><span id="l30.52">     return (-1);</span>
<a href="#l30.53"></a><span id="l30.53">   }</span>
<a href="#l30.54"></a><span id="l30.54"> </span>
<a href="#l30.55"></a><span id="l30.55" class="difflineat">@@ -143,17 +143,17 @@ int nsldapi_result_nolock(LDAP *ld, int </span>
<a href="#l30.56"></a><span id="l30.56">                          (all || NSLDAPI_IS_SEARCH_RESULT(rc)), *result);</span>
<a href="#l30.57"></a><span id="l30.57">   }</span>
<a href="#l30.58"></a><span id="l30.58"> </span>
<a href="#l30.59"></a><span id="l30.59">   return (rc);</span>
<a href="#l30.60"></a><span id="l30.60"> }</span>
<a href="#l30.61"></a><span id="l30.61"> </span>
<a href="#l30.62"></a><span id="l30.62"> /*</span>
<a href="#l30.63"></a><span id="l30.63">  * Look through the list of queued responses for a message that matches the</span>
<a href="#l30.64"></a><span id="l30.64" class="difflineminus">- * criteria in the msgid and all parameters.  msgid == LDAP_RES_ANY matches</span>
<a href="#l30.65"></a><span id="l30.65" class="difflineplus">+ * criteria in the msgid and all parameters. msgid == LDAP_RES_ANY matches</span>
<a href="#l30.66"></a><span id="l30.66">  * all ids.</span>
<a href="#l30.67"></a><span id="l30.67">  *</span>
<a href="#l30.68"></a><span id="l30.68">  * If an appropriate message is found, a non-zero value is returned and the</span>
<a href="#l30.69"></a><span id="l30.69">  * message is dequeued and assigned to *result.</span>
<a href="#l30.70"></a><span id="l30.70">  *</span>
<a href="#l30.71"></a><span id="l30.71">  * If not, *result is set to NULL and this function returns 0.</span>
<a href="#l30.72"></a><span id="l30.72">  */</span>
<a href="#l30.73"></a><span id="l30.73"> static int check_response_queue(LDAP *ld, int msgid, int all,</span>
<a href="#l30.74"></a><span id="l30.74" class="difflineat">@@ -280,21 +280,21 @@ static int wait4msg(LDAP *ld, int msgid,</span>
<a href="#l30.75"></a><span id="l30.75">   } else {</span>
<a href="#l30.76"></a><span id="l30.76">     LDAPDebug(LDAP_DEBUG_TRACE, &quot;wait4msg (timeout %ld sec, %ld usec)\n&quot;,</span>
<a href="#l30.77"></a><span id="l30.77">               timeout-&gt;tv_sec, (long)timeout-&gt;tv_usec, 0);</span>
<a href="#l30.78"></a><span id="l30.78">   }</span>
<a href="#l30.79"></a><span id="l30.79"> #endif /* LDAP_DEBUG */</span>
<a href="#l30.80"></a><span id="l30.80"> </span>
<a href="#l30.81"></a><span id="l30.81">   /* check the cache */</span>
<a href="#l30.82"></a><span id="l30.82">   if (ld-&gt;ld_cache_on &amp;&amp; ld-&gt;ld_cache_result != NULL) {</span>
<a href="#l30.83"></a><span id="l30.83" class="difflineminus">-    /* if ( unlock_permitted ) LDAP_MUTEX_UNLOCK( ld ); */</span>
<a href="#l30.84"></a><span id="l30.84" class="difflineplus">+    /* if (unlock_permitted) LDAP_MUTEX_UNLOCK(ld); */</span>
<a href="#l30.85"></a><span id="l30.85">     LDAP_MUTEX_LOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l30.86"></a><span id="l30.86">     rc = (ld-&gt;ld_cache_result)(ld, msgid, all, timeout, result);</span>
<a href="#l30.87"></a><span id="l30.87">     LDAP_MUTEX_UNLOCK(ld, LDAP_CACHE_LOCK);</span>
<a href="#l30.88"></a><span id="l30.88" class="difflineminus">-    /* if ( unlock_permitted ) LDAP_MUTEX_LOCK( ld ); */</span>
<a href="#l30.89"></a><span id="l30.89" class="difflineplus">+    /* if (unlock_permitted) LDAP_MUTEX_LOCK(ld); */</span>
<a href="#l30.90"></a><span id="l30.90">     if (rc != NSLDAPI_RESULT_TIMEOUT) {</span>
<a href="#l30.91"></a><span id="l30.91">       return (rc);</span>
<a href="#l30.92"></a><span id="l30.92">     }</span>
<a href="#l30.93"></a><span id="l30.93">     if (ld-&gt;ld_cache_strategy == LDAP_CACHE_LOCALDB) {</span>
<a href="#l30.94"></a><span id="l30.94">       LDAP_SET_LDERRNO(ld, LDAP_TIMEOUT, NULL, NULL);</span>
<a href="#l30.95"></a><span id="l30.95">       return (NSLDAPI_RESULT_TIMEOUT);</span>
<a href="#l30.96"></a><span id="l30.96">     }</span>
<a href="#l30.97"></a><span id="l30.97">   }</span>
<a href="#l30.98"></a><span id="l30.98" class="difflineat">@@ -457,17 +457,17 @@ static int wait4msg(LDAP *ld, int msgid,</span>
<a href="#l30.99"></a><span id="l30.99"> </span>
<a href="#l30.100"></a><span id="l30.100">       LDAP_MUTEX_UNLOCK(ld, LDAP_REQ_LOCK);</span>
<a href="#l30.101"></a><span id="l30.101">       LDAP_MUTEX_UNLOCK(ld, LDAP_CONN_LOCK);</span>
<a href="#l30.102"></a><span id="l30.102">     }</span>
<a href="#l30.103"></a><span id="l30.103"> </span>
<a href="#l30.104"></a><span id="l30.104">     /*</span>
<a href="#l30.105"></a><span id="l30.105">      * It is possible that recursion occurred while chasing</span>
<a href="#l30.106"></a><span id="l30.106">      * referrals and as a result the message we are looking</span>
<a href="#l30.107"></a><span id="l30.107" class="difflineminus">-     * for may have been placed on the response queue.  Look</span>
<a href="#l30.108"></a><span id="l30.108" class="difflineplus">+     * for may have been placed on the response queue. Look</span>
<a href="#l30.109"></a><span id="l30.109">      * for it there before continuing so we don't end up</span>
<a href="#l30.110"></a><span id="l30.110">      * waiting on the network for a message that we already</span>
<a href="#l30.111"></a><span id="l30.111">      * received!</span>
<a href="#l30.112"></a><span id="l30.112">      */</span>
<a href="#l30.113"></a><span id="l30.113">     if (rc == NSLDAPI_RESULT_NOT_FOUND &amp;&amp;</span>
<a href="#l30.114"></a><span id="l30.114">         check_response_queue(ld, msgid, all, 0, result) != 0) {</span>
<a href="#l30.115"></a><span id="l30.115">       LDAP_SET_LDERRNO(ld, LDAP_SUCCESS, NULL, NULL);</span>
<a href="#l30.116"></a><span id="l30.116">       rc = (*result)-&gt;lm_msgtype;</span>
<a href="#l30.117"></a><span id="l30.117" class="difflineat">@@ -1117,19 +1117,19 @@ static int cldap_select1(LDAP *ld, struc</span>
<a href="#l30.118"></a><span id="l30.118"> </span>
<a href="#l30.119"></a><span id="l30.119">     pollfds[0].lpoll_fd = ld-&gt;ld_sbp-&gt;sb_sd;</span>
<a href="#l30.120"></a><span id="l30.120">     pollfds[0].lpoll_arg = ld-&gt;ld_sbp-&gt;sb_arg;</span>
<a href="#l30.121"></a><span id="l30.121">     pollfds[0].lpoll_events = LDAP_X_POLLIN;</span>
<a href="#l30.122"></a><span id="l30.122">     pollfds[0].lpoll_revents = 0;</span>
<a href="#l30.123"></a><span id="l30.123">     rc = ld-&gt;ld_extpoll_fn(pollfds, 1, nsldapi_tv2ms(timeout),</span>
<a href="#l30.124"></a><span id="l30.124">                            ld-&gt;ld_ext_session_arg);</span>
<a href="#l30.125"></a><span id="l30.125">   } else {</span>
<a href="#l30.126"></a><span id="l30.126" class="difflineminus">-                LDAPDebug( LDAP_DEBUG_ANY,</span>
<a href="#l30.127"></a><span id="l30.127" class="difflineminus">-		    &quot;nsldapi_iostatus_poll: unknown I/O type %d\n&quot;,</span>
<a href="#l30.128"></a><span id="l30.128" class="difflineminus">-		rc = 0; /* simulate a timeout (what else to do?) */</span>
<a href="#l30.129"></a><span id="l30.129" class="difflineplus">+    LDAPDebug(LDAP_DEBUG_ANY,</span>
<a href="#l30.130"></a><span id="l30.130" class="difflineplus">+        &quot;nsldapi_iostatus_poll: unknown I/O type %d\n&quot;,</span>
<a href="#l30.131"></a><span id="l30.131" class="difflineplus">+     rc = 0; /* simulate a timeout (what else to do?) */</span>
<a href="#l30.132"></a><span id="l30.132">   }</span>
<a href="#l30.133"></a><span id="l30.133"> </span>
<a href="#l30.134"></a><span id="l30.134">   return (rc);</span>
<a href="#l30.135"></a><span id="l30.135"> }</span>
<a href="#l30.136"></a><span id="l30.136"> #  endif /* !macintosh */</span>
<a href="#l30.137"></a><span id="l30.137"> </span>
<a href="#l30.138"></a><span id="l30.138"> #  ifdef macintosh</span>
<a href="#l30.139"></a><span id="l30.139"> static int cldap_select1(LDAP *ld, struct timeval *timeout) {</span>
<a href="#l30.140"></a><span id="l30.140" class="difflineat">@@ -1147,20 +1147,20 @@ static int cldap_select1(LDAP *ld, struc</span>
<a href="#l30.141"></a><span id="l30.141">   FD_ZERO(&amp;readfds);</span>
<a href="#l30.142"></a><span id="l30.142">   FD_SET(ld-&gt;ld_sbp-&gt;sb_sd, &amp;readfds);</span>
<a href="#l30.143"></a><span id="l30.143"> </span>
<a href="#l30.144"></a><span id="l30.144">   if (NSLDAPI_IO_TYPE_STANDARD == ld-&gt;ldiou_type &amp;&amp; NULL != ld-&gt;ld_select_fn) {</span>
<a href="#l30.145"></a><span id="l30.145">     rc = ld-&gt;ld_select_fn(1, &amp;readfds, 0, 0, timeout);</span>
<a href="#l30.146"></a><span id="l30.146">   } else if (NSLDAPI_IO_TYPE_EXTENDED == ld-&gt;ldiou_type &amp;&amp;</span>
<a href="#l30.147"></a><span id="l30.147">              NULL != ld-&gt;ld_extselect_fn) {</span>
<a href="#l30.148"></a><span id="l30.148">             rc = ld-&gt;ld_extselect_fn( ld-&gt;ld_ext_session_arg, 1, &amp;readfds, 0,</span>
<a href="#l30.149"></a><span id="l30.149" class="difflineminus">-		0, timeout ) );</span>
<a href="#l30.150"></a><span id="l30.150" class="difflineplus">+    0, timeout));</span>
<a href="#l30.151"></a><span id="l30.151">   } else {</span>
<a href="#l30.152"></a><span id="l30.152">     /* XXXmcs: UNIX platforms should use poll() */</span>
<a href="#l30.153"></a><span id="l30.153" class="difflineminus">-            rc = select( 1, &amp;readfds, 0, 0, timeout ) );</span>
<a href="#l30.154"></a><span id="l30.154" class="difflineplus">+            rc = select(1, &amp;readfds, 0, 0, timeout));</span>
<a href="#l30.155"></a><span id="l30.155">   }</span>
<a href="#l30.156"></a><span id="l30.156"> </span>
<a href="#l30.157"></a><span id="l30.157">   return (rc == SOCKET_ERROR ? -1 : rc);</span>
<a href="#l30.158"></a><span id="l30.158"> }</span>
<a href="#l30.159"></a><span id="l30.159"> #  endif /* WINSOCK || _WINDOWS */</span>
<a href="#l30.160"></a><span id="l30.160"> #endif   /* CLDAP */</span>
<a href="#l30.161"></a><span id="l30.161"> </span>
<a href="#l30.162"></a><span id="l30.162"> int LDAP_CALL ldap_msgfree(LDAPMessage *lm) {</span>
<a href="#l30.163"></a><span id="l30.163" class="difflineat">@@ -1176,18 +1176,18 @@ int LDAP_CALL ldap_msgfree(LDAPMessage *</span>
<a href="#l30.164"></a><span id="l30.164">     NSLDAPI_FREE((char *)lm);</span>
<a href="#l30.165"></a><span id="l30.165">   }</span>
<a href="#l30.166"></a><span id="l30.166"> </span>
<a href="#l30.167"></a><span id="l30.167">   return (type);</span>
<a href="#l30.168"></a><span id="l30.168"> }</span>
<a href="#l30.169"></a><span id="l30.169"> </span>
<a href="#l30.170"></a><span id="l30.170"> /*</span>
<a href="#l30.171"></a><span id="l30.171">  * ldap_msgdelete - delete a message.  It returns:</span>
<a href="#l30.172"></a><span id="l30.172" class="difflineminus">- *	0	if the entire message was deleted</span>
<a href="#l30.173"></a><span id="l30.173" class="difflineminus">- *	-1	if the message was not found, or only part of it was found</span>
<a href="#l30.174"></a><span id="l30.174" class="difflineplus">+ *   0  if the entire message was deleted</span>
<a href="#l30.175"></a><span id="l30.175" class="difflineplus">+ *  -1  if the message was not found, or only part of it was found</span>
<a href="#l30.176"></a><span id="l30.176">  */</span>
<a href="#l30.177"></a><span id="l30.177"> int ldap_msgdelete(LDAP *ld, int msgid) {</span>
<a href="#l30.178"></a><span id="l30.178">   LDAPMessage *lm, *prev;</span>
<a href="#l30.179"></a><span id="l30.179">   int msgtype;</span>
<a href="#l30.180"></a><span id="l30.180"> </span>
<a href="#l30.181"></a><span id="l30.181">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_msgdelete\n&quot;, 0, 0, 0);</span>
<a href="#l30.182"></a><span id="l30.182"> </span>
<a href="#l30.183"></a><span id="l30.183">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/saslbind.c</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/saslbind.c</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -499,45 +499,45 @@ static int nsldapi_sasl_do_bind(LDAP *ld</span>
<a href="#l31.4"></a><span id="l31.4"> </span>
<a href="#l31.5"></a><span id="l31.5"> /*</span>
<a href="#l31.6"></a><span id="l31.6">  * ldap_sasl_bind - authenticate to the ldap server.  The dn, mechanism,</span>
<a href="#l31.7"></a><span id="l31.7">  * and credentials of the entry to which to bind are supplied. An LDAP</span>
<a href="#l31.8"></a><span id="l31.8">  * error code is returned and if LDAP_SUCCESS is returned *msgidp is set</span>
<a href="#l31.9"></a><span id="l31.9">  * to the id of the request initiated.</span>
<a href="#l31.10"></a><span id="l31.10">  *</span>
<a href="#l31.11"></a><span id="l31.11">  * Example:</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineminus">- *	struct berval	creds;</span>
<a href="#l31.13"></a><span id="l31.13" class="difflineminus">- *	LDAPControl	**ctrls;</span>
<a href="#l31.14"></a><span id="l31.14" class="difflineminus">- *	int		err, msgid;</span>
<a href="#l31.15"></a><span id="l31.15" class="difflineminus">- *	... fill in creds with credentials ...</span>
<a href="#l31.16"></a><span id="l31.16" class="difflineminus">- *	... fill in ctrls with server controls ...</span>
<a href="#l31.17"></a><span id="l31.17" class="difflineminus">- *	err = ldap_sasl_bind( ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l31.18"></a><span id="l31.18" class="difflineminus">- *	    &quot;mechanismname&quot;, &amp;creds, ctrls, NULL, &amp;msgid );</span>
<a href="#l31.19"></a><span id="l31.19" class="difflineplus">+ * struct berval  creds;</span>
<a href="#l31.20"></a><span id="l31.20" class="difflineplus">+ * LDAPControl  **ctrls;</span>
<a href="#l31.21"></a><span id="l31.21" class="difflineplus">+ * int    err, msgid;</span>
<a href="#l31.22"></a><span id="l31.22" class="difflineplus">+ * ... fill in creds with credentials ...</span>
<a href="#l31.23"></a><span id="l31.23" class="difflineplus">+ * ... fill in ctrls with server controls ...</span>
<a href="#l31.24"></a><span id="l31.24" class="difflineplus">+ * err = ldap_sasl_bind(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l31.25"></a><span id="l31.25" class="difflineplus">+ *                      &quot;mechanismname&quot;, &amp;creds, ctrls, NULL, &amp;msgid);</span>
<a href="#l31.26"></a><span id="l31.26">  */</span>
<a href="#l31.27"></a><span id="l31.27"> int LDAP_CALL ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,</span>
<a href="#l31.28"></a><span id="l31.28">                              const struct berval *cred,</span>
<a href="#l31.29"></a><span id="l31.29">                              LDAPControl **serverctrls,</span>
<a href="#l31.30"></a><span id="l31.30">                              LDAPControl **clientctrls, int *msgidp) {</span>
<a href="#l31.31"></a><span id="l31.31">   BerElement *ber;</span>
<a href="#l31.32"></a><span id="l31.32">   int rc, simple, msgid, ldapversion;</span>
<a href="#l31.33"></a><span id="l31.33"> </span>
<a href="#l31.34"></a><span id="l31.34">   /*</span>
<a href="#l31.35"></a><span id="l31.35">    * The ldapv3 bind request looks like this:</span>
<a href="#l31.36"></a><span id="l31.36" class="difflineminus">-   *	BindRequest ::= SEQUENCE {</span>
<a href="#l31.37"></a><span id="l31.37" class="difflineminus">-   *		version		INTEGER,</span>
<a href="#l31.38"></a><span id="l31.38" class="difflineminus">-   *		name		DistinguishedName,	 -- who</span>
<a href="#l31.39"></a><span id="l31.39" class="difflineminus">-   *		authentication	CHOICE {</span>
<a href="#l31.40"></a><span id="l31.40" class="difflineminus">-   *			simple		[0] OCTET STRING, -- passwd</span>
<a href="#l31.41"></a><span id="l31.41" class="difflineminus">-   *			sasl		[3] SaslCredentials -- v3 only</span>
<a href="#l31.42"></a><span id="l31.42" class="difflineminus">-   *		}</span>
<a href="#l31.43"></a><span id="l31.43" class="difflineminus">-   *	}</span>
<a href="#l31.44"></a><span id="l31.44" class="difflineminus">-   *	SaslCredentials ::= SEQUENCE {</span>
<a href="#l31.45"></a><span id="l31.45" class="difflineminus">-   *		mechanism	LDAPString,</span>
<a href="#l31.46"></a><span id="l31.46" class="difflineminus">-   * 		credentials	OCTET STRING</span>
<a href="#l31.47"></a><span id="l31.47" class="difflineminus">-   *	}</span>
<a href="#l31.48"></a><span id="l31.48" class="difflineplus">+   * BindRequest ::= SEQUENCE {</span>
<a href="#l31.49"></a><span id="l31.49" class="difflineplus">+   *   version INTEGER,</span>
<a href="#l31.50"></a><span id="l31.50" class="difflineplus">+   *   name DistinguishedName,      -- who</span>
<a href="#l31.51"></a><span id="l31.51" class="difflineplus">+   *   authentication CHOICE {</span>
<a href="#l31.52"></a><span id="l31.52" class="difflineplus">+   *     simple [0] OCTET STRING,   -- passwd</span>
<a href="#l31.53"></a><span id="l31.53" class="difflineplus">+   *     sasl   [3] SaslCredentials -- v3 only</span>
<a href="#l31.54"></a><span id="l31.54" class="difflineplus">+   *   }</span>
<a href="#l31.55"></a><span id="l31.55" class="difflineplus">+   * }</span>
<a href="#l31.56"></a><span id="l31.56" class="difflineplus">+   * SaslCredentials ::= SEQUENCE {</span>
<a href="#l31.57"></a><span id="l31.57" class="difflineplus">+   *   mechanism  LDAPString,</span>
<a href="#l31.58"></a><span id="l31.58" class="difflineplus">+   *   credentials  OCTET STRING</span>
<a href="#l31.59"></a><span id="l31.59" class="difflineplus">+   * }</span>
<a href="#l31.60"></a><span id="l31.60">    * all wrapped up in an LDAPMessage sequence.</span>
<a href="#l31.61"></a><span id="l31.61">    */</span>
<a href="#l31.62"></a><span id="l31.62"> </span>
<a href="#l31.63"></a><span id="l31.63">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_sasl_bind\n&quot;, 0, 0, 0);</span>
<a href="#l31.64"></a><span id="l31.64"> </span>
<a href="#l31.65"></a><span id="l31.65">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l31.66"></a><span id="l31.66">     return (LDAP_PARAM_ERROR);</span>
<a href="#l31.67"></a><span id="l31.67">   }</span>
<a href="#l31.68"></a><span id="l31.68" class="difflineat">@@ -624,20 +624,20 @@ int LDAP_CALL ldap_sasl_bind(LDAP *ld, c</span>
<a href="#l31.69"></a><span id="l31.69"> </span>
<a href="#l31.70"></a><span id="l31.70"> /*</span>
<a href="#l31.71"></a><span id="l31.71">  * ldap_sasl_bind_s - bind to the ldap server using sasl authentication</span>
<a href="#l31.72"></a><span id="l31.72">  * The dn, mechanism, and credentials of the entry to which to bind are</span>
<a href="#l31.73"></a><span id="l31.73">  * supplied.  LDAP_SUCCESS is returned upon success, the ldap error code</span>
<a href="#l31.74"></a><span id="l31.74">  * otherwise.</span>
<a href="#l31.75"></a><span id="l31.75">  *</span>
<a href="#l31.76"></a><span id="l31.76">  * Example:</span>
<a href="#l31.77"></a><span id="l31.77" class="difflineminus">- *	struct berval	creds;</span>
<a href="#l31.78"></a><span id="l31.78" class="difflineminus">- *	... fill in creds with credentials ...</span>
<a href="#l31.79"></a><span id="l31.79" class="difflineminus">- *	ldap_sasl_bind_s( ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l31.80"></a><span id="l31.80" class="difflineminus">- *	    &quot;mechanismname&quot;, &amp;creds )</span>
<a href="#l31.81"></a><span id="l31.81" class="difflineplus">+ * struct berval  creds;</span>
<a href="#l31.82"></a><span id="l31.82" class="difflineplus">+ * ... fill in creds with credentials ...</span>
<a href="#l31.83"></a><span id="l31.83" class="difflineplus">+ * ldap_sasl_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l31.84"></a><span id="l31.84" class="difflineplus">+ *                  &quot;mechanismname&quot;, &amp;creds)</span>
<a href="#l31.85"></a><span id="l31.85">  */</span>
<a href="#l31.86"></a><span id="l31.86"> int LDAP_CALL ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,</span>
<a href="#l31.87"></a><span id="l31.87">                                const struct berval *cred,</span>
<a href="#l31.88"></a><span id="l31.88">                                LDAPControl **serverctrls,</span>
<a href="#l31.89"></a><span id="l31.89">                                LDAPControl **clientctrls,</span>
<a href="#l31.90"></a><span id="l31.90">                                struct berval **servercredp) {</span>
<a href="#l31.91"></a><span id="l31.91">   return (nsldapi_sasl_bind_s(ld, dn, mechanism, cred, serverctrls, clientctrls,</span>
<a href="#l31.92"></a><span id="l31.92">                               servercredp, NULL));</span>
<a href="#l31.93"></a><span id="l31.93" class="difflineat">@@ -752,20 +752,20 @@ int LDAP_CALL ldap_parse_sasl_bind_resul</span>
<a href="#l31.94"></a><span id="l31.94">   ber_len_t len;</span>
<a href="#l31.95"></a><span id="l31.95">   char *m, *e;</span>
<a href="#l31.96"></a><span id="l31.96"> </span>
<a href="#l31.97"></a><span id="l31.97">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_parse_sasl_bind_result\n&quot;, 0, 0, 0);</span>
<a href="#l31.98"></a><span id="l31.98"> </span>
<a href="#l31.99"></a><span id="l31.99">   /*</span>
<a href="#l31.100"></a><span id="l31.100">    * the ldapv3 SASL bind response looks like this:</span>
<a href="#l31.101"></a><span id="l31.101">    *</span>
<a href="#l31.102"></a><span id="l31.102" class="difflineminus">-   *	BindResponse ::= [APPLICATION 1] SEQUENCE {</span>
<a href="#l31.103"></a><span id="l31.103" class="difflineminus">-   *		COMPONENTS OF LDAPResult,</span>
<a href="#l31.104"></a><span id="l31.104" class="difflineminus">-   *		serverSaslCreds [7] OCTET STRING OPTIONAL</span>
<a href="#l31.105"></a><span id="l31.105" class="difflineminus">-   *	}</span>
<a href="#l31.106"></a><span id="l31.106" class="difflineplus">+   * BindResponse ::= [APPLICATION 1] SEQUENCE {</span>
<a href="#l31.107"></a><span id="l31.107" class="difflineplus">+   *   COMPONENTS OF LDAPResult,</span>
<a href="#l31.108"></a><span id="l31.108" class="difflineplus">+   *   serverSaslCreds [7] OCTET STRING OPTIONAL</span>
<a href="#l31.109"></a><span id="l31.109" class="difflineplus">+   * }</span>
<a href="#l31.110"></a><span id="l31.110">    *</span>
<a href="#l31.111"></a><span id="l31.111">    * all wrapped up in an LDAPMessage sequence.</span>
<a href="#l31.112"></a><span id="l31.112">    */</span>
<a href="#l31.113"></a><span id="l31.113"> </span>
<a href="#l31.114"></a><span id="l31.114">   if (!NSLDAPI_VALID_LDAP_POINTER(ld) ||</span>
<a href="#l31.115"></a><span id="l31.115">       !NSLDAPI_VALID_LDAPMESSAGE_BINDRESULT_POINTER(res)) {</span>
<a href="#l31.116"></a><span id="l31.116">     return (LDAP_PARAM_ERROR);</span>
<a href="#l31.117"></a><span id="l31.117">   }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/sbind.c</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/sbind.c</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -54,18 +54,18 @@ static int simple_bind_nolock(LDAP *ld, </span>
<a href="#l32.4"></a><span id="l32.4">                               int unlock_permitted);</span>
<a href="#l32.5"></a><span id="l32.5"> </span>
<a href="#l32.6"></a><span id="l32.6"> /*</span>
<a href="#l32.7"></a><span id="l32.7">  * ldap_simple_bind - bind to the ldap server.  The dn and</span>
<a href="#l32.8"></a><span id="l32.8">  * password of the entry to which to bind are supplied.  The message id</span>
<a href="#l32.9"></a><span id="l32.9">  * of the request initiated is returned.</span>
<a href="#l32.10"></a><span id="l32.10">  *</span>
<a href="#l32.11"></a><span id="l32.11">  * Example:</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">- *	ldap_simple_bind( ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineminus">- *	    &quot;secret&quot; )</span>
<a href="#l32.14"></a><span id="l32.14" class="difflineplus">+ * ldap_simple_bind(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l32.15"></a><span id="l32.15" class="difflineplus">+ *                  &quot;secret&quot;)</span>
<a href="#l32.16"></a><span id="l32.16">  */</span>
<a href="#l32.17"></a><span id="l32.17"> </span>
<a href="#l32.18"></a><span id="l32.18"> int LDAP_CALL ldap_simple_bind(LDAP *ld, const char *dn, const char *passwd) {</span>
<a href="#l32.19"></a><span id="l32.19">   int rc;</span>
<a href="#l32.20"></a><span id="l32.20"> </span>
<a href="#l32.21"></a><span id="l32.21">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_simple_bind\n&quot;, 0, 0, 0);</span>
<a href="#l32.22"></a><span id="l32.22"> </span>
<a href="#l32.23"></a><span id="l32.23">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span>
<a href="#l32.24"></a><span id="l32.24" class="difflineat">@@ -83,23 +83,23 @@ int LDAP_CALL ldap_simple_bind(LDAP *ld,</span>
<a href="#l32.25"></a><span id="l32.25"> </span>
<a href="#l32.26"></a><span id="l32.26"> static int simple_bind_nolock(LDAP *ld, const char *dn, const char *passwd,</span>
<a href="#l32.27"></a><span id="l32.27">                               int unlock_permitted) {</span>
<a href="#l32.28"></a><span id="l32.28">   BerElement *ber;</span>
<a href="#l32.29"></a><span id="l32.29">   int rc, msgid;</span>
<a href="#l32.30"></a><span id="l32.30"> </span>
<a href="#l32.31"></a><span id="l32.31">   /*</span>
<a href="#l32.32"></a><span id="l32.32">    * The bind request looks like this:</span>
<a href="#l32.33"></a><span id="l32.33" class="difflineminus">-   *	BindRequest ::= SEQUENCE {</span>
<a href="#l32.34"></a><span id="l32.34" class="difflineminus">-   *		version		INTEGER,</span>
<a href="#l32.35"></a><span id="l32.35" class="difflineminus">-   *		name		DistinguishedName,	 -- who</span>
<a href="#l32.36"></a><span id="l32.36" class="difflineminus">-   *		authentication	CHOICE {</span>
<a href="#l32.37"></a><span id="l32.37" class="difflineminus">-   *			simple		[0] OCTET STRING -- passwd</span>
<a href="#l32.38"></a><span id="l32.38" class="difflineminus">-   *		}</span>
<a href="#l32.39"></a><span id="l32.39" class="difflineminus">-   *	}</span>
<a href="#l32.40"></a><span id="l32.40" class="difflineplus">+   * BindRequest ::= SEQUENCE {</span>
<a href="#l32.41"></a><span id="l32.41" class="difflineplus">+   *   version INTEGER,</span>
<a href="#l32.42"></a><span id="l32.42" class="difflineplus">+   *   name DistinguishedName,   -- who</span>
<a href="#l32.43"></a><span id="l32.43" class="difflineplus">+   *   authentication CHOICE {</span>
<a href="#l32.44"></a><span id="l32.44" class="difflineplus">+   *     simple [0] OCTET STRING -- passwd</span>
<a href="#l32.45"></a><span id="l32.45" class="difflineplus">+   *   }</span>
<a href="#l32.46"></a><span id="l32.46" class="difflineplus">+   * }</span>
<a href="#l32.47"></a><span id="l32.47">    * all wrapped up in an LDAPMessage sequence.</span>
<a href="#l32.48"></a><span id="l32.48">    */</span>
<a href="#l32.49"></a><span id="l32.49"> </span>
<a href="#l32.50"></a><span id="l32.50">   LDAP_MUTEX_LOCK(ld, LDAP_MSGID_LOCK);</span>
<a href="#l32.51"></a><span id="l32.51">   msgid = ++ld-&gt;ld_msgid;</span>
<a href="#l32.52"></a><span id="l32.52">   LDAP_MUTEX_UNLOCK(ld, LDAP_MSGID_LOCK);</span>
<a href="#l32.53"></a><span id="l32.53"> </span>
<a href="#l32.54"></a><span id="l32.54">   if (dn == NULL) dn = &quot;&quot;;</span>
<a href="#l32.55"></a><span id="l32.55" class="difflineat">@@ -147,18 +147,18 @@ static int simple_bind_nolock(LDAP *ld, </span>
<a href="#l32.56"></a><span id="l32.56"> </span>
<a href="#l32.57"></a><span id="l32.57"> /*</span>
<a href="#l32.58"></a><span id="l32.58">  * ldap_simple_bind - bind to the ldap server using simple</span>
<a href="#l32.59"></a><span id="l32.59">  * authentication.  The dn and password of the entry to which to bind are</span>
<a href="#l32.60"></a><span id="l32.60">  * supplied.  LDAP_SUCCESS is returned upon success, the ldap error code</span>
<a href="#l32.61"></a><span id="l32.61">  * otherwise.</span>
<a href="#l32.62"></a><span id="l32.62">  *</span>
<a href="#l32.63"></a><span id="l32.63">  * Example:</span>
<a href="#l32.64"></a><span id="l32.64" class="difflineminus">- *	ldap_simple_bind_s( ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l32.65"></a><span id="l32.65" class="difflineminus">- *	    &quot;secret&quot; )</span>
<a href="#l32.66"></a><span id="l32.66" class="difflineplus">+ * ldap_simple_bind_s(ld, &quot;cn=manager, o=university of michigan, c=us&quot;,</span>
<a href="#l32.67"></a><span id="l32.67" class="difflineplus">+ *                    &quot;secret&quot;)</span>
<a href="#l32.68"></a><span id="l32.68">  */</span>
<a href="#l32.69"></a><span id="l32.69"> int LDAP_CALL ldap_simple_bind_s(LDAP *ld, const char *dn, const char *passwd) {</span>
<a href="#l32.70"></a><span id="l32.70">   int msgid;</span>
<a href="#l32.71"></a><span id="l32.71">   LDAPMessage *result;</span>
<a href="#l32.72"></a><span id="l32.72"> </span>
<a href="#l32.73"></a><span id="l32.73">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_simple_bind_s\n&quot;, 0, 0, 0);</span>
<a href="#l32.74"></a><span id="l32.74"> </span>
<a href="#l32.75"></a><span id="l32.75">   if (!NSLDAPI_VALID_LDAP_POINTER(ld)) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/search.c</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/search.c</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -71,29 +71,29 @@ static int nsldapi_search_s(LDAP *ld, co</span>
<a href="#l33.4"></a><span id="l33.4">                             LDAPControl **serverctrls,</span>
<a href="#l33.5"></a><span id="l33.5">                             LDAPControl **clientctrls,</span>
<a href="#l33.6"></a><span id="l33.6">                             struct timeval *localtimeoutp, int timelimit,</span>
<a href="#l33.7"></a><span id="l33.7">                             int sizelimit, LDAPMessage **res);</span>
<a href="#l33.8"></a><span id="l33.8"> </span>
<a href="#l33.9"></a><span id="l33.9"> /*</span>
<a href="#l33.10"></a><span id="l33.10">  * ldap_search - initiate an ldap search operation.  Parameters:</span>
<a href="#l33.11"></a><span id="l33.11">  *</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">- *	ld		LDAP descriptor</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineminus">- *	base		DN of the base object</span>
<a href="#l33.14"></a><span id="l33.14" class="difflineminus">- *	scope		the search scope - one of LDAP_SCOPE_BASE,</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineminus">- *			    LDAP_SCOPE_ONELEVEL, LDAP_SCOPE_SUBTREE</span>
<a href="#l33.16"></a><span id="l33.16" class="difflineminus">- *	filter		a string containing the search filter</span>
<a href="#l33.17"></a><span id="l33.17" class="difflineminus">- *			(e.g., &quot;(|(cn=bob)(sn=bob))&quot;)</span>
<a href="#l33.18"></a><span id="l33.18" class="difflineminus">- *	attrs		list of attribute types to return for matches</span>
<a href="#l33.19"></a><span id="l33.19" class="difflineminus">- *	attrsonly	1 =&gt; attributes only 0 =&gt; attributes and values</span>
<a href="#l33.20"></a><span id="l33.20" class="difflineplus">+ * ld         LDAP descriptor</span>
<a href="#l33.21"></a><span id="l33.21" class="difflineplus">+ * base       DN of the base object</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineplus">+ * scope      the search scope - one of LDAP_SCOPE_BASE,</span>
<a href="#l33.23"></a><span id="l33.23" class="difflineplus">+ *            LDAP_SCOPE_ONELEVEL, LDAP_SCOPE_SUBTREE</span>
<a href="#l33.24"></a><span id="l33.24" class="difflineplus">+ * filter     a string containing the search filter</span>
<a href="#l33.25"></a><span id="l33.25" class="difflineplus">+ *            (e.g., &quot;(|(cn=bob)(sn=bob))&quot;)</span>
<a href="#l33.26"></a><span id="l33.26" class="difflineplus">+ * attrs      list of attribute types to return for matches</span>
<a href="#l33.27"></a><span id="l33.27" class="difflineplus">+ * attrsonly  1 =&gt; attributes only 0 =&gt; attributes and values</span>
<a href="#l33.28"></a><span id="l33.28">  *</span>
<a href="#l33.29"></a><span id="l33.29">  * Example:</span>
<a href="#l33.30"></a><span id="l33.30" class="difflineminus">- *	char	*attrs[] = { &quot;mail&quot;, &quot;title&quot;, 0 };</span>
<a href="#l33.31"></a><span id="l33.31" class="difflineminus">- *	msgid = ldap_search( ld, &quot;c=us@o=UM&quot;, LDAP_SCOPE_SUBTREE, &quot;cn~=bob&quot;,</span>
<a href="#l33.32"></a><span id="l33.32" class="difflineminus">- *	    attrs, attrsonly );</span>
<a href="#l33.33"></a><span id="l33.33" class="difflineplus">+ * char  *attrs[] = { &quot;mail&quot;, &quot;title&quot;, 0 };</span>
<a href="#l33.34"></a><span id="l33.34" class="difflineplus">+ * msgid = ldap_search(ld, &quot;c=us@o=UM&quot;, LDAP_SCOPE_SUBTREE, &quot;cn~=bob&quot;,</span>
<a href="#l33.35"></a><span id="l33.35" class="difflineplus">+ *                     attrs, attrsonly);</span>
<a href="#l33.36"></a><span id="l33.36">  */</span>
<a href="#l33.37"></a><span id="l33.37"> int LDAP_CALL ldap_search(LDAP *ld, const char *base, int scope,</span>
<a href="#l33.38"></a><span id="l33.38">                           const char *filter, char **attrs, int attrsonly) {</span>
<a href="#l33.39"></a><span id="l33.39">   int msgid;</span>
<a href="#l33.40"></a><span id="l33.40"> </span>
<a href="#l33.41"></a><span id="l33.41">   LDAPDebug(LDAP_DEBUG_TRACE, &quot;ldap_search\n&quot;, 0, 0, 0);</span>
<a href="#l33.42"></a><span id="l33.42"> </span>
<a href="#l33.43"></a><span id="l33.43">   if (ldap_search_ext(ld, base, scope, filter, attrs, attrsonly, NULL, NULL,</span>
<a href="#l33.44"></a><span id="l33.44" class="difflineat">@@ -248,35 +248,35 @@ int nsldapi_build_search_req(</span>
<a href="#l33.45"></a><span id="l33.45">     int sizelimit,             /* if -1, ld-&gt;ld_sizelimit is used */</span>
<a href="#l33.46"></a><span id="l33.46">     int msgid, BerElement **berp) {</span>
<a href="#l33.47"></a><span id="l33.47">   BerElement *ber;</span>
<a href="#l33.48"></a><span id="l33.48">   int err;</span>
<a href="#l33.49"></a><span id="l33.49">   char *fdup;</span>
<a href="#l33.50"></a><span id="l33.50"> </span>
<a href="#l33.51"></a><span id="l33.51">   /*</span>
<a href="#l33.52"></a><span id="l33.52">    * Create the search request.  It looks like this:</span>
<a href="#l33.53"></a><span id="l33.53" class="difflineminus">-   *	SearchRequest := [APPLICATION 3] SEQUENCE {</span>
<a href="#l33.54"></a><span id="l33.54" class="difflineminus">-   *		baseObject	DistinguishedName,</span>
<a href="#l33.55"></a><span id="l33.55" class="difflineminus">-   *		scope		ENUMERATED {</span>
<a href="#l33.56"></a><span id="l33.56" class="difflineminus">-   *			baseObject	(0),</span>
<a href="#l33.57"></a><span id="l33.57" class="difflineminus">-   *			singleLevel	(1),</span>
<a href="#l33.58"></a><span id="l33.58" class="difflineminus">-   *			wholeSubtree	(2)</span>
<a href="#l33.59"></a><span id="l33.59" class="difflineminus">-   *		},</span>
<a href="#l33.60"></a><span id="l33.60" class="difflineminus">-   *		derefAliases	ENUMERATED {</span>
<a href="#l33.61"></a><span id="l33.61" class="difflineminus">-   *			neverDerefaliases	(0),</span>
<a href="#l33.62"></a><span id="l33.62" class="difflineminus">-   *			derefInSearching	(1),</span>
<a href="#l33.63"></a><span id="l33.63" class="difflineminus">-   *			derefFindingBaseObj	(2),</span>
<a href="#l33.64"></a><span id="l33.64" class="difflineminus">-   *			alwaysDerefAliases	(3)</span>
<a href="#l33.65"></a><span id="l33.65" class="difflineminus">-   *		},</span>
<a href="#l33.66"></a><span id="l33.66" class="difflineminus">-   *		sizelimit	INTEGER (0 .. 65535),</span>
<a href="#l33.67"></a><span id="l33.67" class="difflineminus">-   *		timelimit	INTEGER (0 .. 65535),</span>
<a href="#l33.68"></a><span id="l33.68" class="difflineminus">-   *		attrsOnly	BOOLEAN,</span>
<a href="#l33.69"></a><span id="l33.69" class="difflineminus">-   *		filter		Filter,</span>
<a href="#l33.70"></a><span id="l33.70" class="difflineminus">-   *		attributes	SEQUENCE OF AttributeType</span>
<a href="#l33.71"></a><span id="l33.71" class="difflineminus">-   *	}</span>
<a href="#l33.72"></a><span id="l33.72" class="difflineplus">+   * SearchRequest := [APPLICATION 3] SEQUENCE {</span>
<a href="#l33.73"></a><span id="l33.73" class="difflineplus">+   *   baseObject DistinguishedName,</span>
<a href="#l33.74"></a><span id="l33.74" class="difflineplus">+   *   scope ENUMERATED {</span>
<a href="#l33.75"></a><span id="l33.75" class="difflineplus">+   *     baseObject   (0),</span>
<a href="#l33.76"></a><span id="l33.76" class="difflineplus">+   *     singleLevel  (1),</span>
<a href="#l33.77"></a><span id="l33.77" class="difflineplus">+   *     wholeSubtree (2)</span>
<a href="#l33.78"></a><span id="l33.78" class="difflineplus">+   *   },</span>
<a href="#l33.79"></a><span id="l33.79" class="difflineplus">+   *   derefAliases ENUMERATED {</span>
<a href="#l33.80"></a><span id="l33.80" class="difflineplus">+   *     neverDerefaliases   (0),</span>
<a href="#l33.81"></a><span id="l33.81" class="difflineplus">+   *     derefInSearching    (1),</span>
<a href="#l33.82"></a><span id="l33.82" class="difflineplus">+   *     derefFindingBaseObj (2),</span>
<a href="#l33.83"></a><span id="l33.83" class="difflineplus">+   *     alwaysDerefAliases  (3)</span>
<a href="#l33.84"></a><span id="l33.84" class="difflineplus">+   *   },</span>
<a href="#l33.85"></a><span id="l33.85" class="difflineplus">+   *   sizelimit  INTEGER (0 .. 65535),</span>
<a href="#l33.86"></a><span id="l33.86" class="difflineplus">+   *   timelimit  INTEGER (0 .. 65535),</span>
<a href="#l33.87"></a><span id="l33.87" class="difflineplus">+   *   attrsOnly  BOOLEAN,</span>
<a href="#l33.88"></a><span id="l33.88" class="difflineplus">+   *   filter    Filter,</span>
<a href="#l33.89"></a><span id="l33.89" class="difflineplus">+   *   attributes  SEQUENCE OF AttributeType</span>
<a href="#l33.90"></a><span id="l33.90" class="difflineplus">+   * }</span>
<a href="#l33.91"></a><span id="l33.91">    * wrapped in an ldap message.</span>
<a href="#l33.92"></a><span id="l33.92">    */</span>
<a href="#l33.93"></a><span id="l33.93"> </span>
<a href="#l33.94"></a><span id="l33.94">   /* create a message to send */</span>
<a href="#l33.95"></a><span id="l33.95">   if ((err = nsldapi_alloc_ber_with_options(ld, &amp;ber)) != LDAP_SUCCESS) {</span>
<a href="#l33.96"></a><span id="l33.96">     return (err);</span>
<a href="#l33.97"></a><span id="l33.97">   }</span>
<a href="#l33.98"></a><span id="l33.98"> </span>
<a href="#l33.99"></a><span id="l33.99" class="difflineat">@@ -536,21 +536,21 @@ static int put_filter_list(BerElement *b</span>
<a href="#l33.100"></a><span id="l33.100"> </span>
<a href="#l33.101"></a><span id="l33.101">   return (0);</span>
<a href="#l33.102"></a><span id="l33.102"> }</span>
<a href="#l33.103"></a><span id="l33.103"> </span>
<a href="#l33.104"></a><span id="l33.104"> /*</span>
<a href="#l33.105"></a><span id="l33.105">  * is_valid_attr - returns 1 if a is a syntactically valid left-hand side</span>
<a href="#l33.106"></a><span id="l33.106">  * of a filter expression, 0 otherwise.  A valid string may contain only</span>
<a href="#l33.107"></a><span id="l33.107">  * letters, numbers, hyphens, semi-colons, colons and periods. examples:</span>
<a href="#l33.108"></a><span id="l33.108" class="difflineminus">- *	cn</span>
<a href="#l33.109"></a><span id="l33.109" class="difflineminus">- *	cn;lang-fr</span>
<a href="#l33.110"></a><span id="l33.110" class="difflineminus">- *	1.2.3.4;binary;dynamic</span>
<a href="#l33.111"></a><span id="l33.111" class="difflineminus">- *	mail;dynamic</span>
<a href="#l33.112"></a><span id="l33.112" class="difflineminus">- *	cn:dn:1.2.3.4</span>
<a href="#l33.113"></a><span id="l33.113" class="difflineplus">+ * cn</span>
<a href="#l33.114"></a><span id="l33.114" class="difflineplus">+ * cn;lang-fr</span>
<a href="#l33.115"></a><span id="l33.115" class="difflineplus">+ * 1.2.3.4;binary;dynamic</span>
<a href="#l33.116"></a><span id="l33.116" class="difflineplus">+ * mail;dynamic</span>
<a href="#l33.117"></a><span id="l33.117" class="difflineplus">+ * cn:dn:1.2.3.4</span>
<a href="#l33.118"></a><span id="l33.118">  *</span>
<a href="#l33.119"></a><span id="l33.119">  * For compatibility with older servers, we also allow underscores in</span>
<a href="#l33.120"></a><span id="l33.120">  * attribute types, even through they are not allowed by the LDAPv3 RFCs.</span>
<a href="#l33.121"></a><span id="l33.121">  */</span>
<a href="#l33.122"></a><span id="l33.122"> static int is_valid_attr(char *a) {</span>
<a href="#l33.123"></a><span id="l33.123">   for (; *a; a++) {</span>
<a href="#l33.124"></a><span id="l33.124">     if (!isascii(*a)) {</span>
<a href="#l33.125"></a><span id="l33.125">       return (0);</span>
<a href="#l33.126"></a><span id="l33.126" class="difflineat">@@ -626,17 +626,17 @@ static int put_simple_filter(BerElement </span>
<a href="#l33.127"></a><span id="l33.127">       break;</span>
<a href="#l33.128"></a><span id="l33.128">     case '~':</span>
<a href="#l33.129"></a><span id="l33.129">       ftype = LDAP_FILTER_APPROX;</span>
<a href="#l33.130"></a><span id="l33.130">       break;</span>
<a href="#l33.131"></a><span id="l33.131">     case ':': /* extended filter - v3 only */</span>
<a href="#l33.132"></a><span id="l33.132">       /*</span>
<a href="#l33.133"></a><span id="l33.133">        * extended filter looks like this:</span>
<a href="#l33.134"></a><span id="l33.134">        *</span>
<a href="#l33.135"></a><span id="l33.135" class="difflineminus">-       *	[type][':dn'][':'oid]':='value</span>
<a href="#l33.136"></a><span id="l33.136" class="difflineplus">+       * [type][':dn'][':'oid]':='value</span>
<a href="#l33.137"></a><span id="l33.137">        *</span>
<a href="#l33.138"></a><span id="l33.138">        * where one of type or :oid is required.</span>
<a href="#l33.139"></a><span id="l33.139">        *</span>
<a href="#l33.140"></a><span id="l33.140">        */</span>
<a href="#l33.141"></a><span id="l33.141">       ftype = LDAP_FILTER_EXTENDED;</span>
<a href="#l33.142"></a><span id="l33.142">       s2 = s3 = NULL;</span>
<a href="#l33.143"></a><span id="l33.143">       if ((s2 = strrchr(str, ':')) == NULL) {</span>
<a href="#l33.144"></a><span id="l33.144">         goto free_and_return;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/test.c</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/test.c</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -347,18 +347,16 @@ static void add_control(LDAPControl ***c</span>
<a href="#l34.4"></a><span id="l34.4"> #ifdef TEST_CUSTOM_MALLOC</span>
<a href="#l34.5"></a><span id="l34.5"> </span>
<a href="#l34.6"></a><span id="l34.6"> typedef struct my_malloc_info {</span>
<a href="#l34.7"></a><span id="l34.7">   long mmi_magic;</span>
<a href="#l34.8"></a><span id="l34.8">   size_t mmi_actualsize;</span>
<a href="#l34.9"></a><span id="l34.9"> } MyMallocInfo;</span>
<a href="#l34.10"></a><span id="l34.10"> #  define MY_MALLOC_MAGIC_NUMBER 0x19940618</span>
<a href="#l34.11"></a><span id="l34.11"> </span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-#  define MY_MALLOC_CHECK_MAGIC(p)	if ( ((MyMallocInfo *)( (p) - sizeof()</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineminus">-</span>
<a href="#l34.14"></a><span id="l34.14"> void *my_malloc(size_t size) {</span>
<a href="#l34.15"></a><span id="l34.15">   void *p;</span>
<a href="#l34.16"></a><span id="l34.16">   MyMallocInfo *mmip;</span>
<a href="#l34.17"></a><span id="l34.17"> </span>
<a href="#l34.18"></a><span id="l34.18">   if ((p = malloc(size + sizeof(struct my_malloc_info))) != NULL) {</span>
<a href="#l34.19"></a><span id="l34.19">     mmip = (MyMallocInfo *)p;</span>
<a href="#l34.20"></a><span id="l34.20">     mmip-&gt;mmi_magic = MY_MALLOC_MAGIC_NUMBER;</span>
<a href="#l34.21"></a><span id="l34.21">     mmip-&gt;mmi_actualsize = size;</span>
<a href="#l34.22"></a><span id="l34.22" class="difflineat">@@ -427,17 +425,17 @@ void *my_realloc(void *ptr, size_t size)</span>
<a href="#l34.23"></a><span id="l34.23"> #endif /* TEST_CUSTOM_MALLOC */</span>
<a href="#l34.24"></a><span id="l34.24"> </span>
<a href="#l34.25"></a><span id="l34.25"> int</span>
<a href="#l34.26"></a><span id="l34.26"> #ifdef WINSOCK</span>
<a href="#l34.27"></a><span id="l34.27"> ldapmain(</span>
<a href="#l34.28"></a><span id="l34.28"> #else  /* WINSOCK */</span>
<a href="#l34.29"></a><span id="l34.29"> main(</span>
<a href="#l34.30"></a><span id="l34.30"> #endif /* WINSOCK */</span>
<a href="#l34.31"></a><span id="l34.31" class="difflineminus">-	int argc, char **argv )</span>
<a href="#l34.32"></a><span id="l34.32" class="difflineplus">+ int argc, char **argv )</span>
<a href="#l34.33"></a><span id="l34.33"> {</span>
<a href="#l34.34"></a><span id="l34.34">   LDAP *ld;</span>
<a href="#l34.35"></a><span id="l34.35">   int rc, i, c, port, cldapflg, errflg, method, id, msgtype;</span>
<a href="#l34.36"></a><span id="l34.36">   int version;</span>
<a href="#l34.37"></a><span id="l34.37">   char line[256], command1, command2, command3;</span>
<a href="#l34.38"></a><span id="l34.38">   char passwd[64], dn[256], rdn[64], attr[64], value[256];</span>
<a href="#l34.39"></a><span id="l34.39">   char filter[256], *host, **types;</span>
<a href="#l34.40"></a><span id="l34.40">   char **exdn, *fnname;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/tmplout.c</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/tmplout.c</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -873,17 +873,17 @@ static char *time2text(char *ldtimestr, </span>
<a href="#l35.4"></a><span id="l35.4">  */</span>
<a href="#l35.5"></a><span id="l35.5"> </span>
<a href="#l35.6"></a><span id="l35.6"> static int dmsize[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};</span>
<a href="#l35.7"></a><span id="l35.7"> </span>
<a href="#l35.8"></a><span id="l35.8"> #define dysize(y) \</span>
<a href="#l35.9"></a><span id="l35.9">   (((y) % 4) ? 365 : (((y) % 100) ? 366 : (((y) % 400) ? 365 : 366)))</span>
<a href="#l35.10"></a><span id="l35.10"> </span>
<a href="#l35.11"></a><span id="l35.11"> /*</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-#define	YEAR(y)		((y) &gt;= 100 ? (y) : (y) + 1900)</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+#define  YEAR(y) ((y) &gt;= 100 ? (y) : (y) + 1900)</span>
<a href="#l35.14"></a><span id="l35.14"> */</span>
<a href="#l35.15"></a><span id="l35.15"> #define YEAR(y) (((y) &lt; 1900) ? ((y) + 1900) : (y))</span>
<a href="#l35.16"></a><span id="l35.16"> </span>
<a href="#l35.17"></a><span id="l35.17"> /*  */</span>
<a href="#l35.18"></a><span id="l35.18"> </span>
<a href="#l35.19"></a><span id="l35.19"> static long gtime(struct tm *tm) {</span>
<a href="#l35.20"></a><span id="l35.20">   register int i, sec, mins, hour, mday, mon, year;</span>
<a href="#l35.21"></a><span id="l35.21">   register long result;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/ufn.c</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/ufn.c</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -62,39 +62,39 @@ static LDAPMessage *ldap_msg_merge(LDAP </span>
<a href="#l36.4"></a><span id="l36.4"> static LDAPMessage *ldap_ufn_expand(LDAP *ld,</span>
<a href="#l36.5"></a><span id="l36.5">                                     LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l36.6"></a><span id="l36.6">                                     void *cancelparm, char **dns, char *filter,</span>
<a href="#l36.7"></a><span id="l36.7">                                     int scope, char **attrs, int aonly,</span>
<a href="#l36.8"></a><span id="l36.8">                                     int *err);</span>
<a href="#l36.9"></a><span id="l36.9"> </span>
<a href="#l36.10"></a><span id="l36.10"> /*</span>
<a href="#l36.11"></a><span id="l36.11">  * ldap_ufn_search_ctx - do user friendly searching; provide cancel feature;</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">- *			specify ldapfilter.conf tags for each phase of search</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+ *     specify ldapfilter.conf tags for each phase of search</span>
<a href="#l36.14"></a><span id="l36.14">  *</span>
<a href="#l36.15"></a><span id="l36.15" class="difflineminus">- *	ld		LDAP descriptor</span>
<a href="#l36.16"></a><span id="l36.16" class="difflineminus">- *	ufncomp		the exploded user friendly name to look for</span>
<a href="#l36.17"></a><span id="l36.17" class="difflineminus">- *	ncomp		number of elements in ufncomp</span>
<a href="#l36.18"></a><span id="l36.18" class="difflineminus">- *	prefix		where to start searching</span>
<a href="#l36.19"></a><span id="l36.19" class="difflineminus">- *	attrs		list of attribute types to return for matches</span>
<a href="#l36.20"></a><span id="l36.20" class="difflineminus">- *	attrsonly	1 =&gt; attributes only 0 =&gt; attributes and values</span>
<a href="#l36.21"></a><span id="l36.21" class="difflineminus">- *	res		will contain the result of the search</span>
<a href="#l36.22"></a><span id="l36.22" class="difflineminus">- *	cancelproc	routine that returns non-zero if operation should be</span>
<a href="#l36.23"></a><span id="l36.23" class="difflineminus">- *			cancelled.  This can be NULL.  If it is non-NULL, the</span>
<a href="#l36.24"></a><span id="l36.24" class="difflineminus">- *			routine will be called periodically.</span>
<a href="#l36.25"></a><span id="l36.25" class="difflineminus">- *	cancelparm	void * that is passed to cancelproc</span>
<a href="#l36.26"></a><span id="l36.26" class="difflineminus">- *	tag[123]	the ldapfilter.conf tag that will be used in phases</span>
<a href="#l36.27"></a><span id="l36.27" class="difflineminus">- *			1, 2, and 3 of the search, respectively</span>
<a href="#l36.28"></a><span id="l36.28" class="difflineplus">+ * ld          LDAP descriptor</span>
<a href="#l36.29"></a><span id="l36.29" class="difflineplus">+ * ufncomp     the exploded user friendly name to look for</span>
<a href="#l36.30"></a><span id="l36.30" class="difflineplus">+ * ncomp       number of elements in ufncomp</span>
<a href="#l36.31"></a><span id="l36.31" class="difflineplus">+ * prefix      where to start searching</span>
<a href="#l36.32"></a><span id="l36.32" class="difflineplus">+ * attrs       list of attribute types to return for matches</span>
<a href="#l36.33"></a><span id="l36.33" class="difflineplus">+ * attrsonly   1 =&gt; attributes only 0 =&gt; attributes and values</span>
<a href="#l36.34"></a><span id="l36.34" class="difflineplus">+ * res         will contain the result of the search</span>
<a href="#l36.35"></a><span id="l36.35" class="difflineplus">+ * cancelproc  routine that returns non-zero if operation should be</span>
<a href="#l36.36"></a><span id="l36.36" class="difflineplus">+ *             cancelled.  This can be NULL.  If it is non-NULL, the</span>
<a href="#l36.37"></a><span id="l36.37" class="difflineplus">+ *             routine will be called periodically.</span>
<a href="#l36.38"></a><span id="l36.38" class="difflineplus">+ * cancelparm  void * that is passed to cancelproc</span>
<a href="#l36.39"></a><span id="l36.39" class="difflineplus">+ * tag[123]    the ldapfilter.conf tag that will be used in phases</span>
<a href="#l36.40"></a><span id="l36.40" class="difflineplus">+ *             1, 2, and 3 of the search, respectively</span>
<a href="#l36.41"></a><span id="l36.41">  *</span>
<a href="#l36.42"></a><span id="l36.42">  * Example:</span>
<a href="#l36.43"></a><span id="l36.43" class="difflineminus">- *	char		*attrs[] = { &quot;mail&quot;, &quot;title&quot;, 0 };</span>
<a href="#l36.44"></a><span id="l36.44" class="difflineminus">- *	char		*ufncomp[] = { &quot;howes&quot;, &quot;umich&quot;, &quot;us&quot;, 0 }</span>
<a href="#l36.45"></a><span id="l36.45" class="difflineminus">- *	LDAPMessage	*res;</span>
<a href="#l36.46"></a><span id="l36.46" class="difflineminus">- *	error = ldap_ufn_search_ctx( ld, ufncomp, 3, NULL, attrs, attrsonly,</span>
<a href="#l36.47"></a><span id="l36.47" class="difflineminus">- *			&amp;res, acancelproc, along, &quot;ufn first&quot;,</span>
<a href="#l36.48"></a><span id="l36.48" class="difflineminus">- *			&quot;ufn intermediate&quot;, &quot;ufn last&quot; );</span>
<a href="#l36.49"></a><span id="l36.49" class="difflineplus">+ * char *attrs[] = { &quot;mail&quot;, &quot;title&quot;, 0 };</span>
<a href="#l36.50"></a><span id="l36.50" class="difflineplus">+ * char *ufncomp[] = { &quot;howes&quot;, &quot;umich&quot;, &quot;us&quot;, 0 }</span>
<a href="#l36.51"></a><span id="l36.51" class="difflineplus">+ * LDAPMessage *res;</span>
<a href="#l36.52"></a><span id="l36.52" class="difflineplus">+ * error = ldap_ufn_search_ctx(ld, ufncomp, 3, NULL, attrs, attrsonly,</span>
<a href="#l36.53"></a><span id="l36.53" class="difflineplus">+ *                             &amp;res, acancelproc, along, &quot;ufn first&quot;,</span>
<a href="#l36.54"></a><span id="l36.54" class="difflineplus">+ *                             &quot;ufn intermediate&quot;, &quot;ufn last&quot;);</span>
<a href="#l36.55"></a><span id="l36.55">  */</span>
<a href="#l36.56"></a><span id="l36.56"> </span>
<a href="#l36.57"></a><span id="l36.57"> static int ldap_ufn_search_ctx(LDAP *ld, char **ufncomp, int ncomp,</span>
<a href="#l36.58"></a><span id="l36.58">                                char *prefix, char **attrs, int attrsonly,</span>
<a href="#l36.59"></a><span id="l36.59">                                LDAPMessage **res,</span>
<a href="#l36.60"></a><span id="l36.60">                                LDAP_CANCELPROC_CALLBACK *cancelproc,</span>
<a href="#l36.61"></a><span id="l36.61">                                void *cancelparm, char *tag1, char *tag2,</span>
<a href="#l36.62"></a><span id="l36.62">                                char *tag3) {</span>
<a href="#l36.63"></a><span id="l36.63" class="difflineat">@@ -104,19 +104,19 @@ static int ldap_ufn_search_ctx(LDAP *ld,</span>
<a href="#l36.64"></a><span id="l36.64">   LDAPFiltInfo *fi;</span>
<a href="#l36.65"></a><span id="l36.65">   LDAPMessage *tmpcand;</span>
<a href="#l36.66"></a><span id="l36.66">   LDAPMessage *candidates;</span>
<a href="#l36.67"></a><span id="l36.67">   static char *objattrs[] = {&quot;objectClass&quot;, NULL};</span>
<a href="#l36.68"></a><span id="l36.68"> </span>
<a href="#l36.69"></a><span id="l36.69">   /*</span>
<a href="#l36.70"></a><span id="l36.70">    * look up ufn components from most to least significant.</span>
<a href="#l36.71"></a><span id="l36.71">    * there are 3 phases.</span>
<a href="#l36.72"></a><span id="l36.72" class="difflineminus">-   * 	phase 1	search the root for orgs or countries</span>
<a href="#l36.73"></a><span id="l36.73" class="difflineminus">-   * 	phase 2	search for orgs</span>
<a href="#l36.74"></a><span id="l36.74" class="difflineminus">-   * 	phase 3	search for a person</span>
<a href="#l36.75"></a><span id="l36.75" class="difflineplus">+   *   phase 1  search the root for orgs or countries</span>
<a href="#l36.76"></a><span id="l36.76" class="difflineplus">+   *   phase 2  search for orgs</span>
<a href="#l36.77"></a><span id="l36.77" class="difflineplus">+   *   phase 3  search for a person</span>
<a href="#l36.78"></a><span id="l36.78">    * in phases 1 and 2, we are building a list of candidate DNs,</span>
<a href="#l36.79"></a><span id="l36.79">    * below which we will search for the final component of the ufn.</span>
<a href="#l36.80"></a><span id="l36.80">    * for each component we try the filters listed in the</span>
<a href="#l36.81"></a><span id="l36.81">    * filterconfig file, first one-level (except the last compoment),</span>
<a href="#l36.82"></a><span id="l36.82">    * then subtree.  if any of them produce any results, we go on to</span>
<a href="#l36.83"></a><span id="l36.83">    * the next component.</span>
<a href="#l36.84"></a><span id="l36.84">    */</span>
<a href="#l36.85"></a><span id="l36.85"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/url.c</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/url.c</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -38,17 +38,17 @@</span>
<a href="#l37.4"></a><span id="l37.4">  *  Copyright (c) 1996 Regents of the University of Michigan.</span>
<a href="#l37.5"></a><span id="l37.5">  *  All rights reserved.</span>
<a href="#l37.6"></a><span id="l37.6">  *</span>
<a href="#l37.7"></a><span id="l37.7">  */</span>
<a href="#l37.8"></a><span id="l37.8"> /*  LIBLDAP url.c -- LDAP URL related routines</span>
<a href="#l37.9"></a><span id="l37.9">  *</span>
<a href="#l37.10"></a><span id="l37.10">  *  LDAP URLs look like this:</span>
<a href="#l37.11"></a><span id="l37.11">  *    l d a p : / / [ hostport ] [ / dn [ ? [ attributes ] [ ? [ scope ]</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">- *			[ ? [ filter ] [ ? extensions ] ] ] ] ]</span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+ *                  [ ? [ filter ] [ ? extensions ] ] ] ] ]</span>
<a href="#l37.14"></a><span id="l37.14">  *</span>
<a href="#l37.15"></a><span id="l37.15">  *  where:</span>
<a href="#l37.16"></a><span id="l37.16">  *   hostport is a host or a host:port list that can be space-separated.</span>
<a href="#l37.17"></a><span id="l37.17">  *   attributes is a comma separated list</span>
<a href="#l37.18"></a><span id="l37.18">  *   scope is one of these three strings:  base one sub (default=base)</span>
<a href="#l37.19"></a><span id="l37.19">  *   filter is a string-represented filter as in RFC 2254</span>
<a href="#l37.20"></a><span id="l37.20">  *   extensions is a comma-separated list of name=value pairs.</span>
<a href="#l37.21"></a><span id="l37.21">  *</span>
<a href="#l37.22"></a><span id="l37.22" class="difflineat">@@ -149,19 +149,19 @@ int LDAP_CALL ldap_url_parse(const char </span>
<a href="#l37.23"></a><span id="l37.23">   }</span>
<a href="#l37.24"></a><span id="l37.24"> </span>
<a href="#l37.25"></a><span id="l37.25">   return (rc);</span>
<a href="#l37.26"></a><span id="l37.26"> }</span>
<a href="#l37.27"></a><span id="l37.27"> </span>
<a href="#l37.28"></a><span id="l37.28"> /*</span>
<a href="#l37.29"></a><span id="l37.29">  * like ldap_url_parse() with a few exceptions:</span>
<a href="#l37.30"></a><span id="l37.30">  *   1) if dn_required is zero, a missing DN does not generate an error</span>
<a href="#l37.31"></a><span id="l37.31" class="difflineminus">- *	(we just leave the lud_dn field NULL)</span>
<a href="#l37.32"></a><span id="l37.32" class="difflineplus">+ *      (we just leave the lud_dn field NULL)</span>
<a href="#l37.33"></a><span id="l37.33">  *   2) no defaults are set for lud_scope and lud_filter (they are set to -1</span>
<a href="#l37.34"></a><span id="l37.34" class="difflineminus">- *	and NULL respectively if no SCOPE or FILTER are present in the URL).</span>
<a href="#l37.35"></a><span id="l37.35" class="difflineplus">+ *      and NULL respectively if no SCOPE or FILTER are present in the URL).</span>
<a href="#l37.36"></a><span id="l37.36">  *   3) when there is a zero-length DN in a URL we do not set lud_dn to NULL.</span>
<a href="#l37.37"></a><span id="l37.37">  *</span>
<a href="#l37.38"></a><span id="l37.38">  * note that LDAPv3 URL extensions are ignored unless they are marked</span>
<a href="#l37.39"></a><span id="l37.39">  * critical, in which case an LDAP_URL_UNRECOGNIZED_CRITICAL_EXTENSION error</span>
<a href="#l37.40"></a><span id="l37.40">  * is returned.</span>
<a href="#l37.41"></a><span id="l37.41">  */</span>
<a href="#l37.42"></a><span id="l37.42"> int nsldapi_url_parse(const char *url, LDAPURLDesc **ludpp, int dn_required) {</span>
<a href="#l37.43"></a><span id="l37.43">   LDAPURLDesc *ludp;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldap/userstatusctrl.c</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldap/userstatusctrl.c</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -119,27 +119,27 @@ int LDAP_CALL ldap_parse_userstatus_cont</span>
<a href="#l38.4"></a><span id="l38.4">     return (LDAP_NO_MEMORY);</span>
<a href="#l38.5"></a><span id="l38.5">   }</span>
<a href="#l38.6"></a><span id="l38.6"> </span>
<a href="#l38.7"></a><span id="l38.7">   memset(us, 0, sizeof(struct LDAPuserstatus));</span>
<a href="#l38.8"></a><span id="l38.8"> </span>
<a href="#l38.9"></a><span id="l38.9">   /*</span>
<a href="#l38.10"></a><span id="l38.10">    * The control value should look like this:</span>
<a href="#l38.11"></a><span id="l38.11">    *</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-   *	ACCOUNT_USABLE_RESPONSE::= CHOICE {</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineminus">-   * 		is_available		[0] INTEGER, ** seconds before expiration</span>
<a href="#l38.14"></a><span id="l38.14" class="difflineminus">-   *** is_not_available	[1] More_info</span>
<a href="#l38.15"></a><span id="l38.15" class="difflineminus">-   *	}</span>
<a href="#l38.16"></a><span id="l38.16" class="difflineminus">-   *	More_info::= SEQUENCE {</span>
<a href="#l38.17"></a><span id="l38.17" class="difflineminus">-   *		inactive				[0] BOOLEAN DEFAULT</span>
<a href="#l38.18"></a><span id="l38.18" class="difflineminus">-   *FALSE, reset					[1] BOOLEAN DEFAULT</span>
<a href="#l38.19"></a><span id="l38.19" class="difflineminus">-   *FALSE, expired					[2] BOOLEAN DEFAULT</span>
<a href="#l38.20"></a><span id="l38.20" class="difflineminus">-   *FALSE, remaining_grace			[3] INTEGER OPTIONAL,</span>
<a href="#l38.21"></a><span id="l38.21" class="difflineminus">-   *		seconds_before_unlock	[4] INTEGER OPTIONAL</span>
<a href="#l38.22"></a><span id="l38.22" class="difflineminus">-   *	}</span>
<a href="#l38.23"></a><span id="l38.23" class="difflineplus">+   *  ACCOUNT_USABLE_RESPONSE::= CHOICE {</span>
<a href="#l38.24"></a><span id="l38.24" class="difflineplus">+   *    is_available      [0] INTEGER, ** seconds before expiration **</span>
<a href="#l38.25"></a><span id="l38.25" class="difflineplus">+   *    is_not_available  [1] More_info</span>
<a href="#l38.26"></a><span id="l38.26" class="difflineplus">+   *  }</span>
<a href="#l38.27"></a><span id="l38.27" class="difflineplus">+   *  More_info::= SEQUENCE {</span>
<a href="#l38.28"></a><span id="l38.28" class="difflineplus">+   *    inactive               [0] BOOLEAN DEFAULT FALSE,</span>
<a href="#l38.29"></a><span id="l38.29" class="difflineplus">+   *    reset                  [1] BOOLEAN DEFAULT FALSE,</span>
<a href="#l38.30"></a><span id="l38.30" class="difflineplus">+   *    expired                [2] BOOLEAN DEFAULT FALSE,</span>
<a href="#l38.31"></a><span id="l38.31" class="difflineplus">+   *    remaining_grace        [3] INTEGER OPTIONAL,</span>
<a href="#l38.32"></a><span id="l38.32" class="difflineplus">+   *    seconds_before_unlock  [4] INTEGER OPTIONAL</span>
<a href="#l38.33"></a><span id="l38.33" class="difflineplus">+   *  }</span>
<a href="#l38.34"></a><span id="l38.34">    */</span>
<a href="#l38.35"></a><span id="l38.35"> </span>
<a href="#l38.36"></a><span id="l38.36">   if ((ber_scanf(ber, &quot;t&quot;, &amp;tag)) == LBER_ERROR) {</span>
<a href="#l38.37"></a><span id="l38.37">     LDAP_SET_LDERRNO(ld, LDAP_DECODING_ERROR, NULL, NULL);</span>
<a href="#l38.38"></a><span id="l38.38">     ber_free(ber, 1);</span>
<a href="#l38.39"></a><span id="l38.39">     return (LDAP_DECODING_ERROR);</span>
<a href="#l38.40"></a><span id="l38.40">   }</span>
<a href="#l38.41"></a><span id="l38.41"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libldif/line64.c</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libldif/line64.c</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -177,19 +177,19 @@ int ldif_parse_line(char *line, char **t</span>
<a href="#l39.4"></a><span id="l39.4">   return (0);</span>
<a href="#l39.5"></a><span id="l39.5"> }</span>
<a href="#l39.6"></a><span id="l39.6"> </span>
<a href="#l39.7"></a><span id="l39.7"> /*</span>
<a href="#l39.8"></a><span id="l39.8">  * ldif_base64_decode - take the BASE64-encoded characters in &quot;src&quot;</span>
<a href="#l39.9"></a><span id="l39.9">  * (a zero-terminated string) and decode them into the the buffer &quot;dst&quot;.</span>
<a href="#l39.10"></a><span id="l39.10">  * &quot;src&quot; and &quot;dst&quot; can be the same if in-place decoding is desired.</span>
<a href="#l39.11"></a><span id="l39.11">  * &quot;dst&quot; must be large enough to hold the decoded octets.  No more than</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">- *	3 * strlen( src ) / 4 bytes will be produced.</span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+ * 3 * strlen(src) / 4 bytes will be produced.</span>
<a href="#l39.14"></a><span id="l39.14">  * &quot;dst&quot; may contain zero octets anywhere within it, but it is not</span>
<a href="#l39.15"></a><span id="l39.15" class="difflineminus">- *	zero-terminated by this function.</span>
<a href="#l39.16"></a><span id="l39.16" class="difflineplus">+ * zero-terminated by this function.</span>
<a href="#l39.17"></a><span id="l39.17">  *</span>
<a href="#l39.18"></a><span id="l39.18">  * The number of bytes copied to &quot;dst&quot; is returned if all goes well.</span>
<a href="#l39.19"></a><span id="l39.19">  * -1 is returned if the BASE64 encoding in &quot;src&quot; is invalid.</span>
<a href="#l39.20"></a><span id="l39.20">  */</span>
<a href="#l39.21"></a><span id="l39.21"> </span>
<a href="#l39.22"></a><span id="l39.22"> int ldif_base64_decode(char *src, unsigned char *dst) {</span>
<a href="#l39.23"></a><span id="l39.23">   char *p, *stop;</span>
<a href="#l39.24"></a><span id="l39.24">   unsigned char nib, *byte;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/ldap/c-sdk/libraries/libprldap/ldappr-threads.c</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/ldap/c-sdk/libraries/libprldap/ldappr-threads.c</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -348,17 +348,17 @@ static PRStatus prldap_init_tpd(void) {</span>
<a href="#l40.4"></a><span id="l40.4">   prldap_map_list = NULL;</span>
<a href="#l40.5"></a><span id="l40.5"> </span>
<a href="#l40.6"></a><span id="l40.6">   return (PR_SUCCESS);</span>
<a href="#l40.7"></a><span id="l40.7"> }</span>
<a href="#l40.8"></a><span id="l40.8"> </span>
<a href="#l40.9"></a><span id="l40.9"> /*</span>
<a href="#l40.10"></a><span id="l40.10">  * Function: prldap_allocate_map()</span>
<a href="#l40.11"></a><span id="l40.11">  * Description: allocate a thread-private data map to use for a new</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">- *	LDAP session handle.</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+ * LDAP session handle.</span>
<a href="#l40.14"></a><span id="l40.14">  * Returns: a pointer to the TPD map or NULL if none available.</span>
<a href="#l40.15"></a><span id="l40.15">  */</span>
<a href="#l40.16"></a><span id="l40.16"> static PRLDAP_TPDMap *prldap_allocate_map(LDAP *ld) {</span>
<a href="#l40.17"></a><span id="l40.17">   PRLDAP_TPDMap *map, *prevmap;</span>
<a href="#l40.18"></a><span id="l40.18"> </span>
<a href="#l40.19"></a><span id="l40.19">   PR_Lock(prldap_map_mutex);</span>
<a href="#l40.20"></a><span id="l40.20"> </span>
<a href="#l40.21"></a><span id="l40.21">   /*</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineat">@@ -408,17 +408,17 @@ static PRLDAP_TPDMap *prldap_allocate_ma</span>
<a href="#l40.23"></a><span id="l40.23">   PR_Unlock(prldap_map_mutex);</span>
<a href="#l40.24"></a><span id="l40.24"> </span>
<a href="#l40.25"></a><span id="l40.25">   return (map);</span>
<a href="#l40.26"></a><span id="l40.26"> }</span>
<a href="#l40.27"></a><span id="l40.27"> </span>
<a href="#l40.28"></a><span id="l40.28"> /*</span>
<a href="#l40.29"></a><span id="l40.29">  * Function: prldap_return_map()</span>
<a href="#l40.30"></a><span id="l40.30">  * Description: return a thread-private data map to the pool of ones</span>
<a href="#l40.31"></a><span id="l40.31" class="difflineminus">- *	available for re-use.</span>
<a href="#l40.32"></a><span id="l40.32" class="difflineplus">+ * available for re-use.</span>
<a href="#l40.33"></a><span id="l40.33">  */</span>
<a href="#l40.34"></a><span id="l40.34"> static void prldap_return_map(PRLDAP_TPDMap *map) {</span>
<a href="#l40.35"></a><span id="l40.35">   PRLDAP_ErrorInfo *eip;</span>
<a href="#l40.36"></a><span id="l40.36"> </span>
<a href="#l40.37"></a><span id="l40.37">   PR_Lock(prldap_map_mutex);</span>
<a href="#l40.38"></a><span id="l40.38"> </span>
<a href="#l40.39"></a><span id="l40.39">   /*</span>
<a href="#l40.40"></a><span id="l40.40">    * Dispose of thread-private LDAP error information.  Note that this</span>
<a href="#l40.41"></a><span id="l40.41" class="difflineat">@@ -471,17 +471,17 @@ static int prldap_set_thread_private(PRI</span>
<a href="#l40.42"></a><span id="l40.42"> </span>
<a href="#l40.43"></a><span id="l40.43">   tsdhdr-&gt;ptpdh_dataitems[tpdindex] = priv;</span>
<a href="#l40.44"></a><span id="l40.44">   return (0);</span>
<a href="#l40.45"></a><span id="l40.45"> }</span>
<a href="#l40.46"></a><span id="l40.46"> </span>
<a href="#l40.47"></a><span id="l40.47"> /*</span>
<a href="#l40.48"></a><span id="l40.48">  * Function: prldap_get_thread_private()</span>
<a href="#l40.49"></a><span id="l40.49">  * Description: retrieve a piece of thread-private data.  If not set,</span>
<a href="#l40.50"></a><span id="l40.50" class="difflineminus">- *	NULL is returned.</span>
<a href="#l40.51"></a><span id="l40.51" class="difflineplus">+ * NULL is returned.</span>
<a href="#l40.52"></a><span id="l40.52">  * Returns: 0 if successful and -1 if not.</span>
<a href="#l40.53"></a><span id="l40.53">  */</span>
<a href="#l40.54"></a><span id="l40.54"> static void *prldap_get_thread_private(PRInt32 tpdindex) {</span>
<a href="#l40.55"></a><span id="l40.55">   PRLDAP_TPDHeader *tsdhdr;</span>
<a href="#l40.56"></a><span id="l40.56"> </span>
<a href="#l40.57"></a><span id="l40.57">   tsdhdr = (PRLDAP_TPDHeader *)PR_GetThreadPrivate(prldap_tpdindex);</span>
<a href="#l40.58"></a><span id="l40.58">   if (tsdhdr == NULL) {</span>
<a href="#l40.59"></a><span id="l40.59">     return (NULL); /* no thread private data */</span>
<a href="#l40.60"></a><span id="l40.60" class="difflineat">@@ -537,17 +537,17 @@ static PRLDAP_TPDHeader *prldap_tsd_real</span>
<a href="#l40.61"></a><span id="l40.61">   }</span>
<a href="#l40.62"></a><span id="l40.62"> </span>
<a href="#l40.63"></a><span id="l40.63">   return (tsdhdr);</span>
<a href="#l40.64"></a><span id="l40.64"> }</span>
<a href="#l40.65"></a><span id="l40.65"> </span>
<a href="#l40.66"></a><span id="l40.66"> /*</span>
<a href="#l40.67"></a><span id="l40.67">  * Function: prldap_tsd_destroy()</span>
<a href="#l40.68"></a><span id="l40.68">  * Description: Free a thread-private data array. Installed as an NSPR TPD</span>
<a href="#l40.69"></a><span id="l40.69" class="difflineminus">- *	destructor function</span>
<a href="#l40.70"></a><span id="l40.70" class="difflineplus">+ * destructor function</span>
<a href="#l40.71"></a><span id="l40.71">  * Returns: nothing.</span>
<a href="#l40.72"></a><span id="l40.72">  */</span>
<a href="#l40.73"></a><span id="l40.73"> static void prldap_tsd_destroy(void *priv) {</span>
<a href="#l40.74"></a><span id="l40.74">   PRLDAP_TPDHeader *tsdhdr;</span>
<a href="#l40.75"></a><span id="l40.75">   PRLDAP_ErrorInfo *eip;</span>
<a href="#l40.76"></a><span id="l40.76">   int i;</span>
<a href="#l40.77"></a><span id="l40.77"> </span>
<a href="#l40.78"></a><span id="l40.78">   tsdhdr = (PRLDAP_TPDHeader *)priv;</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:32Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

