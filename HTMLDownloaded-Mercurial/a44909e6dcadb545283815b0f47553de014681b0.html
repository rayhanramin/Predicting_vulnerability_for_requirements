<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 2091:a44909e6dcadb545283815b0f47553de014681b0</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ a44909e6dcadb545283815b0f47553de014681b0" />
<meta property="og:url" content="/comm-central/rev/a44909e6dcadb545283815b0f47553de014681b0" />
<meta property="og:description" content="Bug 470329 - gloda indexer throttling logic needs to be adaptive. r/sr=dmose." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / a44909e6dcadb545283815b0f47553de014681b0 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/a44909e6dcadb545283815b0f47553de014681b0">shortlog</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/a44909e6dcadb545283815b0f47553de014681b0">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0">files</a> |
changeset |
<a href="/comm-central/raw-rev/a44909e6dcadb545283815b0f47553de014681b0">raw</a>  | <a href="/comm-central/archive/a44909e6dcadb545283815b0f47553de014681b0.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=470329">Bug 470329</a> - gloda indexer throttling logic needs to be adaptive. r/sr=dmose.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Thu, 26 Feb 2009 13:15:30 -0800</td></tr>

<tr>
 <td>changeset 2091</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/a44909e6dcadb545283815b0f47553de014681b0">a44909e6dcadb545283815b0f47553de014681b0</a></td>
</tr>



<tr>
<td>parent 2090</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/81b62dba7723f5139682c9a2bc12b2871e60ec00">81b62dba7723f5139682c9a2bc12b2871e60ec00</a>
</td>
</tr>

<tr>
<td>child 2092</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/7c41136fa251ba5dafd11a2b6a56fb0b8ca0e695">7c41136fa251ba5dafd11a2b6a56fb0b8ca0e695</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=a44909e6dcadb545283815b0f47553de014681b0">1688</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Thu, 26 Feb 2009 21:15:46 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a44909e6dcad [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a44909e6dcadb545283815b0f47553de014681b0">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a44909e6dcadb545283815b0f47553de014681b0&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a44909e6dcadb545283815b0f47553de014681b0&newProject=comm-central&newRevision=a44909e6dcadb545283815b0f47553de014681b0&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a44909e6dcadb545283815b0f47553de014681b0&newProject=comm-central&newRevision=a44909e6dcadb545283815b0f47553de014681b0&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a44909e6dcadb545283815b0f47553de014681b0&newProject=comm-central&newRevision=a44909e6dcadb545283815b0f47553de014681b0&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>

<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=470329">470329</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=470329">Bug 470329</a> - gloda indexer throttling logic needs to be adaptive. r/sr=dmose.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/build/nsMsgFactory.cpp">mailnews/base/build/nsMsgFactory.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/build/nsMsgFactory.cpp">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/build/nsMsgFactory.cpp">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/build/nsMsgFactory.cpp">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/build/nsMsgFactory.cpp">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/build/nsMsgFactory.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/Makefile.in">mailnews/base/public/Makefile.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/Makefile.in">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/Makefile.in">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/Makefile.in">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/Makefile.in">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/Makefile.in">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/nsIStopwatch.idl">mailnews/base/public/nsIStopwatch.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/nsIStopwatch.idl">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/nsIStopwatch.idl">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/nsIStopwatch.idl">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/nsIStopwatch.idl">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/public/nsIStopwatch.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/Makefile.in">mailnews/base/util/Makefile.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/Makefile.in">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/Makefile.in">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/Makefile.in">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/Makefile.in">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/Makefile.in">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.cpp">mailnews/base/util/nsStopwatch.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.cpp">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.cpp">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.cpp">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.cpp">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.h">mailnews/base/util/nsStopwatch.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.h">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.h">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.h">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.h">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/base/util/nsStopwatch.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/indexer.js">mailnews/db/gloda/modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/utils.js">mailnews/db/gloda/modules/utils.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/utils.js">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/utils.js">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/utils.js">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/utils.js">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/modules/utils.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/glodaTestHelper.js">mailnews/db/gloda/test/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockIndexer.js">mailnews/db/gloda/test/resources/mockIndexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockIndexer.js">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockIndexer.js">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockIndexer.js">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockIndexer.js">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockIndexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockTimer.js">mailnews/db/gloda/test/resources/mockTimer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockTimer.js">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockTimer.js">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockTimer.js">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockTimer.js">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/resources/mockTimer.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/unit/test_index_adaptive.js">mailnews/db/gloda/test/unit/test_index_adaptive.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/unit/test_index_adaptive.js">file</a> |
<a href="/comm-central/annotate/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/unit/test_index_adaptive.js">annotate</a> |
<a href="/comm-central/diff/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/unit/test_index_adaptive.js">diff</a> |
<a href="/comm-central/comparison/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/unit/test_index_adaptive.js">comparison</a> |
<a href="/comm-central/log/a44909e6dcadb545283815b0f47553de014681b0/mailnews/db/gloda/test/unit/test_index_adaptive.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/base/build/nsMsgFactory.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/base/build/nsMsgFactory.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -118,16 +118,18 @@</span>
<a href="#l1.4"></a><span id="l1.4"> #endif</span>
<a href="#l1.5"></a><span id="l1.5"> #if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_GTK2)</span>
<a href="#l1.6"></a><span id="l1.6"> #include &quot;nsMessengerUnixIntegration.h&quot;</span>
<a href="#l1.7"></a><span id="l1.7"> #endif</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9"> #include &quot;nsCURILoader.h&quot;</span>
<a href="#l1.10"></a><span id="l1.10"> #include &quot;nsMessengerContentHandler.h&quot;</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+#include &quot;nsStopwatch.h&quot;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+</span>
<a href="#l1.14"></a><span id="l1.14"> // private factory declarations for each component we know how to produce</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMessengerBootstrap)</span>
<a href="#l1.17"></a><span id="l1.17"> NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsMsgMailSession, Init)</span>
<a href="#l1.18"></a><span id="l1.18"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMessenger)</span>
<a href="#l1.19"></a><span id="l1.19"> NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsMsgAccountManager, Init)</span>
<a href="#l1.20"></a><span id="l1.20"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMsgAccount)</span>
<a href="#l1.21"></a><span id="l1.21"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMsgIdentity)</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -178,16 +180,17 @@ NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsMe</span>
<a href="#l1.23"></a><span id="l1.23"> #endif</span>
<a href="#l1.24"></a><span id="l1.24"> #if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_GTK2)</span>
<a href="#l1.25"></a><span id="l1.25"> NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsMessengerUnixIntegration, Init)</span>
<a href="#l1.26"></a><span id="l1.26"> #endif</span>
<a href="#l1.27"></a><span id="l1.27"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMessengerContentHandler)</span>
<a href="#l1.28"></a><span id="l1.28"> NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsMsgContentPolicy, Init)</span>
<a href="#l1.29"></a><span id="l1.29"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMailDirProvider)</span>
<a href="#l1.30"></a><span id="l1.30"> NS_GENERIC_FACTORY_CONSTRUCTOR(nsMsgShutdownService)</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+NS_GENERIC_FACTORY_CONSTRUCTOR(nsStopwatch)</span>
<a href="#l1.32"></a><span id="l1.32"> </span>
<a href="#l1.33"></a><span id="l1.33"> static NS_METHOD</span>
<a href="#l1.34"></a><span id="l1.34"> RegisterMailnewsContentPolicy(nsIComponentManager *aCompMgr, nsIFile *aPath,</span>
<a href="#l1.35"></a><span id="l1.35">                               const char *registryLocation, const char *componentType,</span>
<a href="#l1.36"></a><span id="l1.36">                               const nsModuleComponentInfo *info)</span>
<a href="#l1.37"></a><span id="l1.37"> {</span>
<a href="#l1.38"></a><span id="l1.38">   nsresult rv;</span>
<a href="#l1.39"></a><span id="l1.39">   nsCOMPtr&lt;nsICategoryManager&gt; catman =</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineat">@@ -505,13 +508,18 @@ static const nsModuleComponentInfo gComp</span>
<a href="#l1.41"></a><span id="l1.41">     },</span>
<a href="#l1.42"></a><span id="l1.42">     {</span>
<a href="#l1.43"></a><span id="l1.43">       &quot;mail director provider&quot;,</span>
<a href="#l1.44"></a><span id="l1.44">       MAILDIRPROVIDER_CID,</span>
<a href="#l1.45"></a><span id="l1.45">       NS_MAILDIRPROVIDER_CONTRACTID,</span>
<a href="#l1.46"></a><span id="l1.46">       nsMailDirProviderConstructor,</span>
<a href="#l1.47"></a><span id="l1.47">       nsMailDirProvider::Register,</span>
<a href="#l1.48"></a><span id="l1.48">       nsMailDirProvider::Unregister</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+    },</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+    {</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+      &quot;stopwatch&quot;, NS_STOPWATCH_CID,</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+      NS_STOPWATCH_CONTRACTID,</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+      nsStopwatchConstructor</span>
<a href="#l1.54"></a><span id="l1.54">     }</span>
<a href="#l1.55"></a><span id="l1.55"> };</span>
<a href="#l1.56"></a><span id="l1.56"> </span>
<a href="#l1.57"></a><span id="l1.57"> NS_IMPL_NSGETMODULE(nsMsgBaseModule, gComponents)</span>
<a href="#l1.58"></a><span id="l1.58">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/base/public/Makefile.in</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/base/public/Makefile.in</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -96,12 +96,13 @@ XPIDLSRCS	= \</span>
<a href="#l2.4"></a><span id="l2.4"> 		nsIMessengerOSIntegration.idl \</span>
<a href="#l2.5"></a><span id="l2.5"> 		nsIMsgMdnGenerator.idl	        \</span>
<a href="#l2.6"></a><span id="l2.6"> 		nsISpamSettings.idl	        \</span>
<a href="#l2.7"></a><span id="l2.7"> 		nsIMapiRegistry.idl \</span>
<a href="#l2.8"></a><span id="l2.8"> 		nsIMsgCustomColumnHandler.idl \</span>
<a href="#l2.9"></a><span id="l2.9"> 		nsIMsgShutdown.idl \</span>
<a href="#l2.10"></a><span id="l2.10"> 		nsMsgFolderFlags.idl \</span>
<a href="#l2.11"></a><span id="l2.11"> 		nsMsgMessageFlags.idl \</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+		nsIStopwatch.idl \</span>
<a href="#l2.13"></a><span id="l2.13"> 		$(NULL)</span>
<a href="#l2.14"></a><span id="l2.14"> </span>
<a href="#l2.15"></a><span id="l2.15"> include $(topsrcdir)/config/rules.mk</span>
<a href="#l2.16"></a><span id="l2.16"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">new file mode 100644</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineminus">--- /dev/null</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineplus">+++ b/mailnews/base/public/nsIStopwatch.idl</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineat">@@ -0,0 +1,77 @@</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+ *</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+ *</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+ * License.</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+ *</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+ * The Original Code is mozilla.org code.</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+ *</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 1998</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+ *</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+ *</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+ * either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+ * or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+ *</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+#include &quot;nsISupports.idl&quot;</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+/**</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+ * Simple stopwatch mechanism for determining the amount of wall-clock time and</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+ * CPU time (user + system) that has elapsed.  It is not fancy.  It is either</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+ * running or it is not.  If you want coherent cpu and real time values, then</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+ * you had better stop it first.  It does not keep counting when stopped,</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+ * although one could add a resumeRetroactive or something to accomplish that.</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+ */</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+[scriptable, uuid(7a671d6e-d48f-4a4f-b87e-644815a5e381)]</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+interface nsIStopwatch : nsISupports {</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+  /**</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+   * Start the stopwatch; all counters are reset to zero.  If you want to</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+   * keep the already accumulated values, use resume instead.</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+   */</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+  void start();</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+  /**</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+   * Stop the stopwatch.</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+   */</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+  void stop();</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+  /**</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+   * Resume the stopwatch without clearing the existing counters.  Any time</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+   * already accumulated on cpuTime/realTime will be kept.</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+   */</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+  void resume();</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+  /**</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+   * The total CPU time (user + system) in seconds accumulated between calls to</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+   * start/resume and stop.  You have to stop the stopwatch to cause this value</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+   * to update.</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+   */</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+  readonly attribute double cpuTimeSeconds;</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+  /**</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+   * The total wall clock time in seconds accumulated between calls to</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+   * start/resume and stop.  You have to stop the stopwatch to cause this value</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+   * to update.</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+   */</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+  readonly attribute double realTimeSeconds;</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/base/util/Makefile.in</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/base/util/Makefile.in</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -97,16 +97,17 @@ CPPSRCS		= \</span>
<a href="#l4.4"></a><span id="l4.4"> 		nsMsgUtils.cpp \</span>
<a href="#l4.5"></a><span id="l4.5"> 		nsMsgProtocol.cpp \</span>
<a href="#l4.6"></a><span id="l4.6"> 		nsMsgMailNewsUrl.cpp \</span>
<a href="#l4.7"></a><span id="l4.7"> 		nsMsgTxn.cpp \</span>
<a href="#l4.8"></a><span id="l4.8"> 		nsMsgI18N.cpp \</span>
<a href="#l4.9"></a><span id="l4.9"> 		nsImapMoveCoalescer.cpp \</span>
<a href="#l4.10"></a><span id="l4.10"> 		nsMsgFileStream.cpp \</span>
<a href="#l4.11"></a><span id="l4.11"> 		nsMsgReadStateTxn.cpp \</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+		nsStopwatch.cpp \</span>
<a href="#l4.13"></a><span id="l4.13"> 		$(NULL)</span>
<a href="#l4.14"></a><span id="l4.14"> </span>
<a href="#l4.15"></a><span id="l4.15"> EXPORTS		= \</span>
<a href="#l4.16"></a><span id="l4.16"> 		nsMsgLineBuffer.h \</span>
<a href="#l4.17"></a><span id="l4.17"> 		nsMsgKeySet.h \</span>
<a href="#l4.18"></a><span id="l4.18"> 		nsMsgDBFolder.h \</span>
<a href="#l4.19"></a><span id="l4.19"> 		nsMsgIdentity.h \</span>
<a href="#l4.20"></a><span id="l4.20"> 		nsMsgIncomingServer.h \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1">new file mode 100644</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineminus">--- /dev/null</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineplus">+++ b/mailnews/base/util/nsStopwatch.cpp</span>
<a href="#l5.4"></a><span id="l5.4" class="difflineat">@@ -0,0 +1,170 @@</span>
<a href="#l5.5"></a><span id="l5.5" class="difflineplus">+#include &lt;stdio.h&gt;</span>
<a href="#l5.6"></a><span id="l5.6" class="difflineplus">+#include &lt;time.h&gt;</span>
<a href="#l5.7"></a><span id="l5.7" class="difflineplus">+#ifdef XP_UNIX</span>
<a href="#l5.8"></a><span id="l5.8" class="difflineplus">+#include &lt;unistd.h&gt;</span>
<a href="#l5.9"></a><span id="l5.9" class="difflineplus">+#include &lt;sys/times.h&gt;</span>
<a href="#l5.10"></a><span id="l5.10" class="difflineplus">+#include &lt;errno.h&gt;</span>
<a href="#l5.11"></a><span id="l5.11" class="difflineplus">+#endif</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+#ifdef XP_WIN</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+#include &quot;windows.h&quot;</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+#endif</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+#include &quot;nsIClassInfoImpl.h&quot;</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+#include &quot;nsStopwatch.h&quot;</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+/*</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+ * This basis for the logic in this file comes from (will used to come from):</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+ *  (mozilla/)modules/libutil/public/stopwatch.cpp.</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+ *  </span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+ * It was no longer used in the mozilla tree, and is being migrated to</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineplus">+ * comm-central where we actually have a need for it.  (&quot;Being&quot; in the sense</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineplus">+ * that it will not be removed immediately from mozilla-central.)</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+ * </span>
<a href="#l5.28"></a><span id="l5.28" class="difflineplus">+ * Simplification and general clean-up has been performed and the fix for</span>
<a href="#l5.29"></a><span id="l5.29" class="difflineplus">+ * bug 96669 has been integrated.</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineplus">+ */</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+NS_DECL_CLASSINFO(nsStopwatch)</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+NS_IMPL_ISUPPORTS1_CI(nsStopwatch, nsIStopwatch)</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+#ifdef WINCE</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineplus">+#error &quot;WINCE apparently does not provide the clock support we require.&quot;</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineplus">+#endif</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineplus">+</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineplus">+#ifdef XP_UNIX</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineplus">+/** the number of ticks per second */</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+static double gTicks = 0;</span>
<a href="#l5.42"></a><span id="l5.42" class="difflineplus">+#elif defined(WIN32)</span>
<a href="#l5.43"></a><span id="l5.43" class="difflineplus">+// a tick every 100ns, 10 per us, 10 * 1000 per ms, 10 * 1000 * 1000 per sec.</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineplus">+#define TICKS_PER_SECOND 10000000.0</span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+// subtract off to get to the unix epoch</span>
<a href="#l5.46"></a><span id="l5.46" class="difflineplus">+#define UNIX_EPOCH_IN_FILE_TIME 116444736000000000L</span>
<a href="#l5.47"></a><span id="l5.47" class="difflineplus">+#endif // XP_UNIX</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineplus">+</span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+nsStopwatch::nsStopwatch()</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineplus">+ : fTotalRealTimeSecs(0.0)</span>
<a href="#l5.51"></a><span id="l5.51" class="difflineplus">+ , fTotalCpuTimeSecs(0.0)</span>
<a href="#l5.52"></a><span id="l5.52" class="difflineplus">+ , fRunning(false)</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineplus">+{</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineplus">+#ifdef XP_UNIX</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+  // idempotent in the event of a race under all coherency models</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+  if (!gTicks)</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+  {</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+    gTicks = (clock_t)sysconf(_SC_CLK_TCK);</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineplus">+    // in event of failure, pick an arbitrary value so we don't divide by zero.</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+    if (errno)</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+      gTicks = 1000000L;</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+  }</span>
<a href="#l5.63"></a><span id="l5.63" class="difflineplus">+#endif</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineplus">+}</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+nsStopwatch::~nsStopwatch()</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineplus">+{</span>
<a href="#l5.68"></a><span id="l5.68" class="difflineplus">+}</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineplus">+</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+NS_IMETHODIMP nsStopwatch::Start()</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+{</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+  fTotalRealTimeSecs = 0.0;</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+  fTotalCpuTimeSecs = 0.0;</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+  return Resume();</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+}</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineplus">+</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+NS_IMETHODIMP nsStopwatch::Stop()</span>
<a href="#l5.78"></a><span id="l5.78" class="difflineplus">+{</span>
<a href="#l5.79"></a><span id="l5.79" class="difflineplus">+  fStopRealTimeSecs = GetRealTime();</span>
<a href="#l5.80"></a><span id="l5.80" class="difflineplus">+  fStopCpuTimeSecs  = GetCPUTime();</span>
<a href="#l5.81"></a><span id="l5.81" class="difflineplus">+  if (fRunning)</span>
<a href="#l5.82"></a><span id="l5.82" class="difflineplus">+  {</span>
<a href="#l5.83"></a><span id="l5.83" class="difflineplus">+    fTotalCpuTimeSecs  += fStopCpuTimeSecs  - fStartCpuTimeSecs;</span>
<a href="#l5.84"></a><span id="l5.84" class="difflineplus">+    fTotalRealTimeSecs += fStopRealTimeSecs - fStartRealTimeSecs;</span>
<a href="#l5.85"></a><span id="l5.85" class="difflineplus">+  }</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineplus">+  fRunning = false;</span>
<a href="#l5.87"></a><span id="l5.87" class="difflineplus">+  return NS_OK;</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineplus">+}</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+NS_IMETHODIMP nsStopwatch::Resume()</span>
<a href="#l5.91"></a><span id="l5.91" class="difflineplus">+{</span>
<a href="#l5.92"></a><span id="l5.92" class="difflineplus">+  if (!fRunning)</span>
<a href="#l5.93"></a><span id="l5.93" class="difflineplus">+  {</span>
<a href="#l5.94"></a><span id="l5.94" class="difflineplus">+    fStartRealTimeSecs = GetRealTime();</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineplus">+    fStartCpuTimeSecs  = GetCPUTime();</span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+  }</span>
<a href="#l5.97"></a><span id="l5.97" class="difflineplus">+  fRunning = true;</span>
<a href="#l5.98"></a><span id="l5.98" class="difflineplus">+  return NS_OK;</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineplus">+}</span>
<a href="#l5.100"></a><span id="l5.100" class="difflineplus">+</span>
<a href="#l5.101"></a><span id="l5.101" class="difflineplus">+NS_IMETHODIMP nsStopwatch::GetCpuTimeSeconds(double *result)</span>
<a href="#l5.102"></a><span id="l5.102" class="difflineplus">+{</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineplus">+  NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l5.104"></a><span id="l5.104" class="difflineplus">+  *result = fTotalCpuTimeSecs;</span>
<a href="#l5.105"></a><span id="l5.105" class="difflineplus">+  return NS_OK;</span>
<a href="#l5.106"></a><span id="l5.106" class="difflineplus">+}</span>
<a href="#l5.107"></a><span id="l5.107" class="difflineplus">+</span>
<a href="#l5.108"></a><span id="l5.108" class="difflineplus">+NS_IMETHODIMP nsStopwatch::GetRealTimeSeconds(double *result)</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineplus">+{</span>
<a href="#l5.110"></a><span id="l5.110" class="difflineplus">+  NS_ENSURE_ARG_POINTER(result);</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineplus">+  *result = fTotalRealTimeSecs;</span>
<a href="#l5.112"></a><span id="l5.112" class="difflineplus">+  return NS_OK;</span>
<a href="#l5.113"></a><span id="l5.113" class="difflineplus">+}</span>
<a href="#l5.114"></a><span id="l5.114" class="difflineplus">+</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineplus">+double nsStopwatch::GetRealTime()</span>
<a href="#l5.116"></a><span id="l5.116" class="difflineplus">+{</span>
<a href="#l5.117"></a><span id="l5.117" class="difflineplus">+#if defined(XP_UNIX)</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineplus">+  struct tms cpt;</span>
<a href="#l5.119"></a><span id="l5.119" class="difflineplus">+  return (double)times(&amp;cpt) / gTicks;</span>
<a href="#l5.120"></a><span id="l5.120" class="difflineplus">+#elif defined(WIN32)</span>
<a href="#l5.121"></a><span id="l5.121" class="difflineplus">+  union     {FILETIME ftFileTime;</span>
<a href="#l5.122"></a><span id="l5.122" class="difflineplus">+             __int64  ftInt64;</span>
<a href="#l5.123"></a><span id="l5.123" class="difflineplus">+            } ftRealTime; // time the process has spent in kernel mode</span>
<a href="#l5.124"></a><span id="l5.124" class="difflineplus">+  SYSTEMTIME st;</span>
<a href="#l5.125"></a><span id="l5.125" class="difflineplus">+  GetSystemTime(&amp;st);</span>
<a href="#l5.126"></a><span id="l5.126" class="difflineplus">+  SystemTimeToFileTime(&amp;st,&amp;ftRealTime.ftFileTime);</span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+  return (double)(ftRealTime.ftInt64 - UNIX_EPOCH_IN_FILE_TIME) /</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineplus">+                 TICKS_PER_SECOND;</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineplus">+#endif</span>
<a href="#l5.130"></a><span id="l5.130" class="difflineplus">+}</span>
<a href="#l5.131"></a><span id="l5.131" class="difflineplus">+</span>
<a href="#l5.132"></a><span id="l5.132" class="difflineplus">+double nsStopwatch::GetCPUTime()</span>
<a href="#l5.133"></a><span id="l5.133" class="difflineplus">+{</span>
<a href="#l5.134"></a><span id="l5.134" class="difflineplus">+#if defined(XP_UNIX)</span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+  struct tms cpt;</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineplus">+  times(&amp;cpt);</span>
<a href="#l5.137"></a><span id="l5.137" class="difflineplus">+  return (double)(cpt.tms_utime+cpt.tms_stime) / gTicks;</span>
<a href="#l5.138"></a><span id="l5.138" class="difflineplus">+#elif defined(WIN32)</span>
<a href="#l5.139"></a><span id="l5.139" class="difflineplus">+</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineplus">+  DWORD       ret;</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineplus">+  FILETIME    ftCreate,       // when the process was created</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineplus">+              ftExit;         // when the process exited</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineplus">+</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineplus">+  union     {FILETIME ftFileTime;</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineplus">+             __int64  ftInt64;</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineplus">+            } ftKernel; // time the process has spent in kernel mode</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineplus">+</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineplus">+  union     {FILETIME ftFileTime;</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineplus">+             __int64  ftInt64;</span>
<a href="#l5.150"></a><span id="l5.150" class="difflineplus">+            } ftUser;   // time the process has spent in user mode</span>
<a href="#l5.151"></a><span id="l5.151" class="difflineplus">+</span>
<a href="#l5.152"></a><span id="l5.152" class="difflineplus">+  HANDLE hProcess = GetCurrentProcess();</span>
<a href="#l5.153"></a><span id="l5.153" class="difflineplus">+  ret = GetProcessTimes (hProcess, &amp;ftCreate, &amp;ftExit,</span>
<a href="#l5.154"></a><span id="l5.154" class="difflineplus">+                                   &amp;ftKernel.ftFileTime,</span>
<a href="#l5.155"></a><span id="l5.155" class="difflineplus">+                                   &amp;ftUser.ftFileTime);</span>
<a href="#l5.156"></a><span id="l5.156" class="difflineplus">+  if (ret != PR_TRUE)</span>
<a href="#l5.157"></a><span id="l5.157" class="difflineplus">+  {</span>
<a href="#l5.158"></a><span id="l5.158" class="difflineplus">+    ret = GetLastError ();</span>
<a href="#l5.159"></a><span id="l5.159" class="difflineplus">+#ifdef DEBUG</span>
<a href="#l5.160"></a><span id="l5.160" class="difflineplus">+    printf(&quot;%s 0x%lx\n&quot;,&quot; Error on GetProcessTimes&quot;, (int)ret);</span>
<a href="#l5.161"></a><span id="l5.161" class="difflineplus">+#endif</span>
<a href="#l5.162"></a><span id="l5.162" class="difflineplus">+  }</span>
<a href="#l5.163"></a><span id="l5.163" class="difflineplus">+</span>
<a href="#l5.164"></a><span id="l5.164" class="difflineplus">+  /*</span>
<a href="#l5.165"></a><span id="l5.165" class="difflineplus">+   * Process times are returned in a 64-bit structure, as the number of</span>
<a href="#l5.166"></a><span id="l5.166" class="difflineplus">+   * 100 nanosecond ticks since 1 January 1601.  User mode and kernel mode</span>
<a href="#l5.167"></a><span id="l5.167" class="difflineplus">+   * times for this process are in separate 64-bit structures.</span>
<a href="#l5.168"></a><span id="l5.168" class="difflineplus">+   * To convert to floating point seconds, we will:</span>
<a href="#l5.169"></a><span id="l5.169" class="difflineplus">+   *</span>
<a href="#l5.170"></a><span id="l5.170" class="difflineplus">+   *          Convert sum of high 32-bit quantities to 64-bit int</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineplus">+   */</span>
<a href="#l5.172"></a><span id="l5.172" class="difflineplus">+  return (double) (ftKernel.ftInt64 + ftUser.ftInt64) / TICKS_PER_SECOND;</span>
<a href="#l5.173"></a><span id="l5.173" class="difflineplus">+#endif</span>
<a href="#l5.174"></a><span id="l5.174" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1">new file mode 100644</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineminus">--- /dev/null</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineplus">+++ b/mailnews/base/util/nsStopwatch.h</span>
<a href="#l6.4"></a><span id="l6.4" class="difflineat">@@ -0,0 +1,45 @@</span>
<a href="#l6.5"></a><span id="l6.5" class="difflineplus">+#ifndef _nsStopwatch_h_</span>
<a href="#l6.6"></a><span id="l6.6" class="difflineplus">+#define _nsStopwatch_h_</span>
<a href="#l6.7"></a><span id="l6.7" class="difflineplus">+</span>
<a href="#l6.8"></a><span id="l6.8" class="difflineplus">+#include &quot;nsIStopwatch.h&quot;</span>
<a href="#l6.9"></a><span id="l6.9" class="difflineplus">+</span>
<a href="#l6.10"></a><span id="l6.10" class="difflineplus">+#include &quot;msgCore.h&quot;</span>
<a href="#l6.11"></a><span id="l6.11" class="difflineplus">+</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+#define NS_STOPWATCH_CID \</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+{0x6ef7eafd, 0x72d0, 0x4c56, {0x94, 0x09, 0x67, 0xe1, 0x6d, 0x0f, 0x25, 0x5b}}</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+#define NS_STOPWATCH_CONTRACTID &quot;@mozilla.org/stopwatch;1&quot;</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+#undef  IMETHOD_VISIBILITY</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+#define IMETHOD_VISIBILITY NS_VISIBILITY_DEFAULT</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+class NS_MSG_BASE nsStopwatch : public nsIStopwatch</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+{</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+public:</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+  NS_DECL_ISUPPORTS</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+  NS_DECL_NSISTOPWATCH</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+  nsStopwatch();</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+  virtual ~nsStopwatch();</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+private:</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineplus">+  /// Wall-clock start time in seconds since unix epoch.</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+  double fStartRealTimeSecs;</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+  /// Wall-clock stop time in seconds since unix epoch.</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+  double fStopRealTimeSecs;</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+  /// CPU-clock start time in seconds (of CPU time used since app start)</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+  double fStartCpuTimeSecs;</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+  /// CPU-clock stop time in seconds (of CPU time used since app start)</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+  double fStopCpuTimeSecs;</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+  /// Total wall-clock time elapsed in seconds. </span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+  double fTotalRealTimeSecs;</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+  /// Total CPU time elapsed in seconds.</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+  double fTotalCpuTimeSecs;</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+  /// Is the timer running?</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+  bool fRunning;</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  </span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+  static double GetRealTime();</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+  static double GetCPUTime();</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+};</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+#endif // _nsStopwatch_h_</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -291,16 +291,25 @@ var GlodaIndexer = {</span>
<a href="#l7.4"></a><span id="l7.4">    */</span>
<a href="#l7.5"></a><span id="l7.5">   _timer: null,</span>
<a href="#l7.6"></a><span id="l7.6">   /**</span>
<a href="#l7.7"></a><span id="l7.7">    * Our nsITimer that we use to schedule events in the &quot;far&quot; future.  For now,</span>
<a href="#l7.8"></a><span id="l7.8">    *  this means not compelling an initial indexing sweep until some number of</span>
<a href="#l7.9"></a><span id="l7.9">    *  seconds after startup. </span>
<a href="#l7.10"></a><span id="l7.10">    */</span>
<a href="#l7.11"></a><span id="l7.11">   _longTimer: null,</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+  /**</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+   * Our performance stopwatch that helps us adapt our indexing constants so</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+   *  as to not explode your computer.  Kind of us, no?</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+   */</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+  _perfStopwatch: null,</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+  /**</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+   * Of course, we need a timer to actually drive our stopwatch usage.</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+   */</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+  _perfTimer: null,</span>
<a href="#l7.21"></a><span id="l7.21"> </span>
<a href="#l7.22"></a><span id="l7.22">   _inited: false,</span>
<a href="#l7.23"></a><span id="l7.23">   /**</span>
<a href="#l7.24"></a><span id="l7.24">    * Initialize the indexer.</span>
<a href="#l7.25"></a><span id="l7.25">    */</span>
<a href="#l7.26"></a><span id="l7.26">   _init: function gloda_index_init() {</span>
<a href="#l7.27"></a><span id="l7.27">     if (this._inited)</span>
<a href="#l7.28"></a><span id="l7.28">       return;</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineat">@@ -312,16 +321,25 @@ var GlodaIndexer = {</span>
<a href="#l7.30"></a><span id="l7.30">     this._msgFolderListener.indexer = this;</span>
<a href="#l7.31"></a><span id="l7.31">     </span>
<a href="#l7.32"></a><span id="l7.32">     this._callbackHandle.init();</span>
<a href="#l7.33"></a><span id="l7.33">     </span>
<a href="#l7.34"></a><span id="l7.34">     // create the timer that drives our intermittent indexing</span>
<a href="#l7.35"></a><span id="l7.35">     this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l7.36"></a><span id="l7.36">     // create the timer for larger offsets independent of indexing</span>
<a href="#l7.37"></a><span id="l7.37">     this._longTimer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineplus">+    </span>
<a href="#l7.39"></a><span id="l7.39" class="difflineplus">+    // create our performance stopwatch and timer</span>
<a href="#l7.40"></a><span id="l7.40" class="difflineplus">+    try {</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineplus">+    this._perfStopwatch = Cc[&quot;@mozilla.org/stopwatch;1&quot;]</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineplus">+                            .createInstance(Ci.nsIStopwatch);</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineplus">+    } catch (ex) {</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+      this._log.error(&quot;problem creating stopwatch!: &quot; + ex);</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineplus">+    }</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineplus">+    this._perfTimer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l7.47"></a><span id="l7.47"> </span>
<a href="#l7.48"></a><span id="l7.48">     // figure out if event-driven indexing should be enabled...</span>
<a href="#l7.49"></a><span id="l7.49">     let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l7.50"></a><span id="l7.50">                         getService(Ci.nsIPrefService);</span>
<a href="#l7.51"></a><span id="l7.51">     let branch = prefService.getBranch(&quot;mailnews.database.global.indexer.&quot;);</span>
<a href="#l7.52"></a><span id="l7.52">     let eventDrivenEnabled = false; // default</span>
<a href="#l7.53"></a><span id="l7.53">     let performInitialSweep = true; // default</span>
<a href="#l7.54"></a><span id="l7.54">     try {</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineat">@@ -360,16 +378,22 @@ var GlodaIndexer = {</span>
<a href="#l7.56"></a><span id="l7.56">       this._timer.cancel();</span>
<a href="#l7.57"></a><span id="l7.57">     } catch (ex) {}</span>
<a href="#l7.58"></a><span id="l7.58">     this._timer = null;</span>
<a href="#l7.59"></a><span id="l7.59">     try {</span>
<a href="#l7.60"></a><span id="l7.60">       this._longTimer.cancel();</span>
<a href="#l7.61"></a><span id="l7.61">     } catch (ex) {}</span>
<a href="#l7.62"></a><span id="l7.62">     this._longTimer = null;</span>
<a href="#l7.63"></a><span id="l7.63">     </span>
<a href="#l7.64"></a><span id="l7.64" class="difflineplus">+    this._perfStopwatch = null;</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineplus">+    try {</span>
<a href="#l7.66"></a><span id="l7.66" class="difflineplus">+      this._perfTimer.cancel();</span>
<a href="#l7.67"></a><span id="l7.67" class="difflineplus">+    } catch (ex) {}</span>
<a href="#l7.68"></a><span id="l7.68" class="difflineplus">+    this._perfTimer = null;</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineplus">+    </span>
<a href="#l7.70"></a><span id="l7.70">     this._indexerIsShutdown = true;</span>
<a href="#l7.71"></a><span id="l7.71">     </span>
<a href="#l7.72"></a><span id="l7.72">     if (!this.enabled)</span>
<a href="#l7.73"></a><span id="l7.73">       return true;</span>
<a href="#l7.74"></a><span id="l7.74">     </span>
<a href="#l7.75"></a><span id="l7.75">     this._log.info(&quot;Shutting Down&quot;);</span>
<a href="#l7.76"></a><span id="l7.76"> </span>
<a href="#l7.77"></a><span id="l7.77">     this.suppressIndexing = true;</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineat">@@ -529,16 +553,20 @@ var GlodaIndexer = {</span>
<a href="#l7.79"></a><span id="l7.79">     if (!this._indexingDesired &amp;&amp; aShouldIndex) {</span>
<a href="#l7.80"></a><span id="l7.80">       this._indexingDesired = true;</span>
<a href="#l7.81"></a><span id="l7.81">       if (this.enabled &amp;&amp; !this._indexingActive &amp;&amp; !this._suppressIndexing) {</span>
<a href="#l7.82"></a><span id="l7.82">         this._log.info(&quot;+++ Indexing Queue Processing Commencing&quot;);</span>
<a href="#l7.83"></a><span id="l7.83">         this._indexingActive = true;</span>
<a href="#l7.84"></a><span id="l7.84">         this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l7.85"></a><span id="l7.85">                                      this._indexInterval,</span>
<a href="#l7.86"></a><span id="l7.86">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineplus">+        // Start the performance sampling timer since indexing is now active.</span>
<a href="#l7.88"></a><span id="l7.88" class="difflineplus">+        // (That's the dude who tracks processor utilization and adjusts our</span>
<a href="#l7.89"></a><span id="l7.89" class="difflineplus">+        // indexing constants.)</span>
<a href="#l7.90"></a><span id="l7.90" class="difflineplus">+        this.perfSampling = true;</span>
<a href="#l7.91"></a><span id="l7.91">       }</span>
<a href="#l7.92"></a><span id="l7.92">     }</span>
<a href="#l7.93"></a><span id="l7.93">   },</span>
<a href="#l7.94"></a><span id="l7.94">   </span>
<a href="#l7.95"></a><span id="l7.95">   _suppressIndexing: false,</span>
<a href="#l7.96"></a><span id="l7.96">   /**</span>
<a href="#l7.97"></a><span id="l7.97">    * Set whether or not indexing should be suppressed.  This is to allow us to</span>
<a href="#l7.98"></a><span id="l7.98">    *  avoid running down a laptop's battery when it is not on AC.  Only code</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineat">@@ -553,16 +581,23 @@ var GlodaIndexer = {</span>
<a href="#l7.100"></a><span id="l7.100">     //  to do, and the indexing process had actually stopped.</span>
<a href="#l7.101"></a><span id="l7.101">     if (!this._suppressIndexing &amp;&amp; this._indexingDesired &amp;&amp;</span>
<a href="#l7.102"></a><span id="l7.102">         !this._indexingActive) {</span>
<a href="#l7.103"></a><span id="l7.103">         this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l7.104"></a><span id="l7.104">         this._indexingActive = true;</span>
<a href="#l7.105"></a><span id="l7.105">         this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l7.106"></a><span id="l7.106">                                      this._indexInterval,</span>
<a href="#l7.107"></a><span id="l7.107">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineplus">+        // Start the performance sampling clock now rather than in the timer</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineplus">+        //  callbacks because it reduces the number of states the system can</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineplus">+        //  be in.  If we are indexing and we are in control of utilization,</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineplus">+        //  sampling is active.  If we are indexing but not in control, we do</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+        //  stop sampling (not ideal, but realistic).  If we are not indexing,</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineplus">+        //  we are not performance sampling.</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineplus">+        this.perfSampling = true;</span>
<a href="#l7.115"></a><span id="l7.115">     }</span>
<a href="#l7.116"></a><span id="l7.116">   },</span>
<a href="#l7.117"></a><span id="l7.117"> </span>
<a href="#l7.118"></a><span id="l7.118">   /**</span>
<a href="#l7.119"></a><span id="l7.119">    * Our timer-driven callback to schedule our first initial indexing sweep.</span>
<a href="#l7.120"></a><span id="l7.120">    *  Because it is invoked by an nsITimer it operates without the benefit of</span>
<a href="#l7.121"></a><span id="l7.121">    *  a 'this' context and must use GlodaIndexer instead of this.</span>
<a href="#l7.122"></a><span id="l7.122">    * Since an initial sweep could have been performed before we get invoked,</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineat">@@ -586,17 +621,152 @@ var GlodaIndexer = {</span>
<a href="#l7.124"></a><span id="l7.124">   set indexingSweepNeeded(aNeeded) {</span>
<a href="#l7.125"></a><span id="l7.125">     if (!this._indexingSweepActive &amp;&amp; aNeeded) {</span>
<a href="#l7.126"></a><span id="l7.126">       this._indexQueue.push(new IndexingJob(&quot;sweep&quot;, 0, null));</span>
<a href="#l7.127"></a><span id="l7.127">       this._indexingJobGoal++;</span>
<a href="#l7.128"></a><span id="l7.128">       this._indexingSweepActive = true;</span>
<a href="#l7.129"></a><span id="l7.129">       this.indexing = true;</span>
<a href="#l7.130"></a><span id="l7.130">     }</span>
<a href="#l7.131"></a><span id="l7.131">   },</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineminus">-</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineplus">+  </span>
<a href="#l7.134"></a><span id="l7.134" class="difflineplus">+  /**</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineplus">+   * Number of milliseconds between performance samples.</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+   */</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineplus">+  _PERF_SAMPLE_RATE_MS: 1000,</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+  set perfSampling(aEnable) {</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+    if (aEnable) {</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+      this._perfSamples = [];</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+      this._perfTimer.initWithCallback(this._perfTimerFire,</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+                                       this._PERF_SAMPLE_RATE_MS,</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineplus">+          Ci.nsITimer.TYPE_REPEATING_SLACK);</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineplus">+      this._perfStopwatch.start();</span>
<a href="#l7.145"></a><span id="l7.145" class="difflineplus">+    }</span>
<a href="#l7.146"></a><span id="l7.146" class="difflineplus">+    else {</span>
<a href="#l7.147"></a><span id="l7.147" class="difflineplus">+      this._perfTimer.cancel();</span>
<a href="#l7.148"></a><span id="l7.148" class="difflineplus">+      // we stop the stopwatch mainly so our state makes sense to anyone</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineplus">+      //  debugging and for our unit test.  In reality, the stopwatch only</span>
<a href="#l7.150"></a><span id="l7.150" class="difflineplus">+      //  does work on the calls to start and stop, and no expense is incurred</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+      //  in the interim, so this is actually expense with no benefit.  But it's</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineplus">+      //  not much of an expense.</span>
<a href="#l7.153"></a><span id="l7.153" class="difflineplus">+      this._perfStopwatch.stop();</span>
<a href="#l7.154"></a><span id="l7.154" class="difflineplus">+    }</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineplus">+  },</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineplus">+  </span>
<a href="#l7.157"></a><span id="l7.157" class="difflineplus">+  /**</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineplus">+   * Number of performance samples to average together.  We average to try and</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineplus">+   *  stabilize our decision making in the face of transient thunderbird CPU</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineplus">+   *  utilization spikes that are not our fault.  (User activity, garbage</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+   *  collection, etc.</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+   */</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+  _perfSamplePointCount: 2,</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineplus">+  _perfSamples: [],</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineplus">+  _perfTimerFire: function() {</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineplus">+    GlodaIndexer.perfTimerFire();</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+  },</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+  /**</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+   * Smallest allowable sleep time, in milliseconds.  This must be a multiple of</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+   *  _TIMER_STEP_SIZE.  Keep in mind that we effectively run in a timer-with-</span>
<a href="#l7.171"></a><span id="l7.171" class="difflineplus">+   *  slack mode of operation.  This means that the time between our timer</span>
<a href="#l7.172"></a><span id="l7.172" class="difflineplus">+   *  firing is actually (_indexInterval + the time we actually spend</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineplus">+   *  processing), so 1000/_indexInterval is really our maximum firing rate if</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineplus">+   *  we did no work.</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineplus">+   */</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+  _MIN_TIMER_INTERVAL_MS: 20,</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+  /**</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+   * The timer interval adjustment size, in milliseconds.</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineplus">+   */</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+  _TIMER_STEP_SIZE: 10,</span>
<a href="#l7.181"></a><span id="l7.181" class="difflineplus">+  /**</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineplus">+   * The maximum amount of time in milliseconds we will sleep between firings.</span>
<a href="#l7.183"></a><span id="l7.183" class="difflineplus">+   *  The reason we cap ourselves is that although we are aware of our cpu</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineplus">+   *  utilization, the autosync logic is not.  The autosync logic can easily</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineplus">+   *  drive thunderbird's utilization above our acceptable threshold for</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineplus">+   *  extended periods of time, resulting in our logic deciding to back off</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+   *  every time it makes a decision, even though it will have no meaningful</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineplus">+   *  impact.  If we did not do this, it might be some time before indexing</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineplus">+   *  would resume at any meaningful rate.</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineplus">+   */</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineplus">+  _MAX_TIMER_INTERVAL_MS: 400,</span>
<a href="#l7.192"></a><span id="l7.192" class="difflineplus">+  /**</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineplus">+   * Periodic performance adjustment logic.  The overall goal is to adjust our</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineplus">+   *  rate of work so that we don't interfere with the user's activities when</span>
<a href="#l7.195"></a><span id="l7.195" class="difflineplus">+   *  they are around (non-idle), and the system in general (when idle).  Being</span>
<a href="#l7.196"></a><span id="l7.196" class="difflineplus">+   *  nice when idle isn't quite as important, but is a good idea so that when</span>
<a href="#l7.197"></a><span id="l7.197" class="difflineplus">+   *  the user un-idles we are able to back off nicely.  Also, we give other</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineplus">+   *  processes on the system a chance to do something.</span>
<a href="#l7.199"></a><span id="l7.199" class="difflineplus">+   * </span>
<a href="#l7.200"></a><span id="l7.200" class="difflineplus">+   * The two knobs we have to play with are:</span>
<a href="#l7.201"></a><span id="l7.201" class="difflineplus">+   * - The amount of time we sleep between work batch processing.  Keep in mind</span>
<a href="#l7.202"></a><span id="l7.202" class="difflineplus">+   *   that many of our operations are actually asynchronous, so we aren't</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineplus">+   *   entirely starving the event queue.  However, a lot of the async stuff</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineplus">+   *   can end up not having any actual delay between events. For example, we</span>
<a href="#l7.205"></a><span id="l7.205" class="difflineplus">+   *   only index offline message bodies, so there's no network latency</span>
<a href="#l7.206"></a><span id="l7.206" class="difflineplus">+   *   involved, just disk IO; the only meaningful latency will be the initial</span>
<a href="#l7.207"></a><span id="l7.207" class="difflineplus">+   *   disk seek (if there is one... pre-fetching may seriously be our friend).</span>
<a href="#l7.208"></a><span id="l7.208" class="difflineplus">+   * - The amount of work we do between intentional sleeps (number of tokens).</span>
<a href="#l7.209"></a><span id="l7.209" class="difflineplus">+   * </span>
<a href="#l7.210"></a><span id="l7.210" class="difflineplus">+   * In order to maintain responsiveness, I assert that we want to minimize the</span>
<a href="#l7.211"></a><span id="l7.211" class="difflineplus">+   *  length of the time we are dominating the event queue.  This suggests</span>
<a href="#l7.212"></a><span id="l7.212" class="difflineplus">+   *  that we want break up our blocks of work frequently.  But not so</span>
<a href="#l7.213"></a><span id="l7.213" class="difflineplus">+   *  frequently that there is a lot of waste.  Accordingly our algorithm is</span>
<a href="#l7.214"></a><span id="l7.214" class="difflineplus">+   *  basically:</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineplus">+   *  </span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+   * Using too much cpu:</span>
<a href="#l7.217"></a><span id="l7.217" class="difflineplus">+   *  First, do less work per slice = reduce tokens.</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineplus">+   *  Second, space our work batches out more = increase sleep time.</span>
<a href="#l7.219"></a><span id="l7.219" class="difflineplus">+   *  </span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+   * Using less cpu than budgeted:</span>
<a href="#l7.221"></a><span id="l7.221" class="difflineplus">+   *  First, reduce the spacing between our work batches = decrease sleep time.</span>
<a href="#l7.222"></a><span id="l7.222" class="difflineplus">+   *  Second, do more work per slice = increase tokens.</span>
<a href="#l7.223"></a><span id="l7.223" class="difflineplus">+   */</span>
<a href="#l7.224"></a><span id="l7.224" class="difflineplus">+  perfTimerFire: function perfTimerFire() {</span>
<a href="#l7.225"></a><span id="l7.225" class="difflineplus">+    let stopwatch = this._perfStopwatch;</span>
<a href="#l7.226"></a><span id="l7.226" class="difflineplus">+    stopwatch.stop();</span>
<a href="#l7.227"></a><span id="l7.227" class="difflineplus">+    </span>
<a href="#l7.228"></a><span id="l7.228" class="difflineplus">+    let realTime = stopwatch.realTimeSeconds;</span>
<a href="#l7.229"></a><span id="l7.229" class="difflineplus">+    let cpuTime = stopwatch.cpuTimeSeconds;</span>
<a href="#l7.230"></a><span id="l7.230" class="difflineplus">+    </span>
<a href="#l7.231"></a><span id="l7.231" class="difflineplus">+    let dir = &quot;none&quot;, averagePercent = 0;</span>
<a href="#l7.232"></a><span id="l7.232" class="difflineplus">+    if (realTime) {</span>
<a href="#l7.233"></a><span id="l7.233" class="difflineplus">+      while (this._perfSamples.length &gt;= this._perfSamplePointCount)</span>
<a href="#l7.234"></a><span id="l7.234" class="difflineplus">+        this._perfSamples.shift();</span>
<a href="#l7.235"></a><span id="l7.235" class="difflineplus">+      </span>
<a href="#l7.236"></a><span id="l7.236" class="difflineplus">+      let cpuPercent = cpuTime / realTime;</span>
<a href="#l7.237"></a><span id="l7.237" class="difflineplus">+      this._perfSamples.push(cpuPercent);</span>
<a href="#l7.238"></a><span id="l7.238" class="difflineplus">+      </span>
<a href="#l7.239"></a><span id="l7.239" class="difflineplus">+      if (this._perfSamples.length == this._perfSamplePointCount) { </span>
<a href="#l7.240"></a><span id="l7.240" class="difflineplus">+        for (let i = 0; i &lt; this._perfSamples.length; i++)</span>
<a href="#l7.241"></a><span id="l7.241" class="difflineplus">+          averagePercent += this._perfSamples[i];</span>
<a href="#l7.242"></a><span id="l7.242" class="difflineplus">+        averagePercent /= this._perfSamples.length;</span>
<a href="#l7.243"></a><span id="l7.243" class="difflineplus">+        </span>
<a href="#l7.244"></a><span id="l7.244" class="difflineplus">+        if (averagePercent &gt; this._cpuTarget) {</span>
<a href="#l7.245"></a><span id="l7.245" class="difflineplus">+          dir = &quot;down&quot;;</span>
<a href="#l7.246"></a><span id="l7.246" class="difflineplus">+          if (this._indexTokens &gt; 1)</span>
<a href="#l7.247"></a><span id="l7.247" class="difflineplus">+            this._indexTokens--;</span>
<a href="#l7.248"></a><span id="l7.248" class="difflineplus">+          else if (this._indexInterval &lt; this._MAX_TIMER_INTERVAL_MS)</span>
<a href="#l7.249"></a><span id="l7.249" class="difflineplus">+            this._indexInterval += this._TIMER_STEP_SIZE;</span>
<a href="#l7.250"></a><span id="l7.250" class="difflineplus">+        }</span>
<a href="#l7.251"></a><span id="l7.251" class="difflineplus">+        else if (averagePercent + 0.1 &lt; this._cpuTarget) {</span>
<a href="#l7.252"></a><span id="l7.252" class="difflineplus">+          dir = &quot;up&quot;;</span>
<a href="#l7.253"></a><span id="l7.253" class="difflineplus">+          if (this._indexInterval &gt; this._MIN_TIMER_INTERVAL_MS)</span>
<a href="#l7.254"></a><span id="l7.254" class="difflineplus">+            this._indexInterval -= this._TIMER_STEP_SIZE;</span>
<a href="#l7.255"></a><span id="l7.255" class="difflineplus">+          else</span>
<a href="#l7.256"></a><span id="l7.256" class="difflineplus">+            this._indexTokens++;</span>
<a href="#l7.257"></a><span id="l7.257" class="difflineplus">+        }</span>
<a href="#l7.258"></a><span id="l7.258" class="difflineplus">+      }</span>
<a href="#l7.259"></a><span id="l7.259" class="difflineplus">+    </span>
<a href="#l7.260"></a><span id="l7.260" class="difflineplus">+      GlodaIndexer._log.debug(&quot;PERFORMANCE &quot; + dir +</span>
<a href="#l7.261"></a><span id="l7.261" class="difflineplus">+                              &quot; average: &quot; + averagePercent +</span>
<a href="#l7.262"></a><span id="l7.262" class="difflineplus">+                              &quot; interval: &quot; + this._indexInterval +</span>
<a href="#l7.263"></a><span id="l7.263" class="difflineplus">+                              &quot; tokens: &quot; + this._indexTokens);</span>
<a href="#l7.264"></a><span id="l7.264" class="difflineplus">+    }</span>
<a href="#l7.265"></a><span id="l7.265" class="difflineplus">+    </span>
<a href="#l7.266"></a><span id="l7.266" class="difflineplus">+    stopwatch.start();</span>
<a href="#l7.267"></a><span id="l7.267" class="difflineplus">+  },</span>
<a href="#l7.268"></a><span id="l7.268" class="difflineplus">+  </span>
<a href="#l7.269"></a><span id="l7.269">   /**</span>
<a href="#l7.270"></a><span id="l7.270">    * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l7.271"></a><span id="l7.271">    *  are gloda message rows flagged for deletion.  If this value is a boolean,</span>
<a href="#l7.272"></a><span id="l7.272">    *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l7.273"></a><span id="l7.273">    *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l7.274"></a><span id="l7.274">    *  the database.</span>
<a href="#l7.275"></a><span id="l7.275">    */</span>
<a href="#l7.276"></a><span id="l7.276">   pendingDeletions: null,</span>
<a href="#l7.277"></a><span id="l7.277" class="difflineat">@@ -679,41 +849,45 @@ var GlodaIndexer = {</span>
<a href="#l7.278"></a><span id="l7.278">    */</span>
<a href="#l7.279"></a><span id="l7.279">   _indexIdleThresholdSecs: 15,</span>
<a href="#l7.280"></a><span id="l7.280">   </span>
<a href="#l7.281"></a><span id="l7.281">   /**</span>
<a href="#l7.282"></a><span id="l7.282">    * The time delay in milliseconds before we should schedule our initial sweep.</span>
<a href="#l7.283"></a><span id="l7.283">    */</span>
<a href="#l7.284"></a><span id="l7.284">   _initialSweepDelay: 10000,</span>
<a href="#l7.285"></a><span id="l7.285">   </span>
<a href="#l7.286"></a><span id="l7.286" class="difflineplus">+  _cpuTarget: 0.4,</span>
<a href="#l7.287"></a><span id="l7.287" class="difflineplus">+  _cpuTarget_whenActive: 0.4,</span>
<a href="#l7.288"></a><span id="l7.288" class="difflineplus">+  _cpuTarget_whenIdle: 0.8,</span>
<a href="#l7.289"></a><span id="l7.289" class="difflineplus">+  </span>
<a href="#l7.290"></a><span id="l7.290">   /**</span>
<a href="#l7.291"></a><span id="l7.291">    * The time interval, in milliseconds between performing indexing work.</span>
<a href="#l7.292"></a><span id="l7.292">    *  This may be altered by user session (in)activity.</span>
<a href="#l7.293"></a><span id="l7.293">    */ </span>
<a href="#l7.294"></a><span id="l7.294" class="difflineminus">-  _indexInterval: 100,</span>
<a href="#l7.295"></a><span id="l7.295" class="difflineminus">-  _indexInterval_whenActive: 100,</span>
<a href="#l7.296"></a><span id="l7.296" class="difflineplus">+  _indexInterval: 60,</span>
<a href="#l7.297"></a><span id="l7.297" class="difflineplus">+  _indexInterval_whenActive: 60,</span>
<a href="#l7.298"></a><span id="l7.298">   _indexInterval_whenIdle: 20,</span>
<a href="#l7.299"></a><span id="l7.299">   /**</span>
<a href="#l7.300"></a><span id="l7.300">    * Number of indexing 'tokens' we are allowed to consume before yielding for</span>
<a href="#l7.301"></a><span id="l7.301">    *  each incremental pass.  Consider a single token equal to indexing a single</span>
<a href="#l7.302"></a><span id="l7.302">    *  medium-sized message.  This may be altered by user session (in)activity.</span>
<a href="#l7.303"></a><span id="l7.303">    * Because we fetch message bodies, which is potentially asynchronous, this</span>
<a href="#l7.304"></a><span id="l7.304">    *  is not a precise knob to twiddle.</span>
<a href="#l7.305"></a><span id="l7.305">    */</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineminus">-  _indexTokens: 2,</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineminus">-  _indexTokens_whenActive: 2,</span>
<a href="#l7.308"></a><span id="l7.308" class="difflineplus">+  _indexTokens: 5,</span>
<a href="#l7.309"></a><span id="l7.309" class="difflineplus">+  _indexTokens_whenActive: 5,</span>
<a href="#l7.310"></a><span id="l7.310">   _indexTokens_whenIdle: 10,</span>
<a href="#l7.311"></a><span id="l7.311">   </span>
<a href="#l7.312"></a><span id="l7.312">   /**</span>
<a href="#l7.313"></a><span id="l7.313">    * Number of indexing 'tokens' we consume before we issue a commit.  The</span>
<a href="#l7.314"></a><span id="l7.314">    *  goal is to de-couple our time scheduling from our commit schedule.  It's</span>
<a href="#l7.315"></a><span id="l7.315">    *  far better for user responsiveness to take lots of little bites instead</span>
<a href="#l7.316"></a><span id="l7.316">    *  of a few big ones, but bites that result in commits cannot be little... </span>
<a href="#l7.317"></a><span id="l7.317">    */</span>
<a href="#l7.318"></a><span id="l7.318" class="difflineminus">-  _indexCommitTokens: 10,</span>
<a href="#l7.319"></a><span id="l7.319" class="difflineplus">+  _indexCommitTokens: 40,</span>
<a href="#l7.320"></a><span id="l7.320">   </span>
<a href="#l7.321"></a><span id="l7.321">   /**</span>
<a href="#l7.322"></a><span id="l7.322">    * The number of messages that we should queue for processing before letting</span>
<a href="#l7.323"></a><span id="l7.323">    *  them fall on the floor and relying on our folder-walking logic to ensure</span>
<a href="#l7.324"></a><span id="l7.324">    *  that the messages are indexed.</span>
<a href="#l7.325"></a><span id="l7.325">    * The reason we allow for queueing messages in an event-driven fashion is</span>
<a href="#l7.326"></a><span id="l7.326">    *  that once we have reached a steady-state, it is preferable to be able to</span>
<a href="#l7.327"></a><span id="l7.327">    *  deal with new messages and modified meta-data in a prompt fasion rather</span>
<a href="#l7.328"></a><span id="l7.328" class="difflineat">@@ -833,17 +1007,21 @@ var GlodaIndexer = {</span>
<a href="#l7.329"></a><span id="l7.329">     // leave the folder if we haven't explicitly left it.</span>
<a href="#l7.330"></a><span id="l7.330">     if (this._indexingFolder !== null) {</span>
<a href="#l7.331"></a><span id="l7.331">       this._indexerLeaveFolder();</span>
<a href="#l7.332"></a><span id="l7.332">     }</span>
<a href="#l7.333"></a><span id="l7.333">     </span>
<a href="#l7.334"></a><span id="l7.334">     this._indexingGlodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l7.335"></a><span id="l7.335">     this._indexingFolder = this._indexingGlodaFolder.getXPCOMFolder(</span>
<a href="#l7.336"></a><span id="l7.336">                              this._indexingGlodaFolder.kActivityIndexing);</span>
<a href="#l7.337"></a><span id="l7.337" class="difflineminus">-    </span>
<a href="#l7.338"></a><span id="l7.338" class="difflineplus">+</span>
<a href="#l7.339"></a><span id="l7.339" class="difflineplus">+    // The processor utilization required to enter a folder is not our</span>
<a href="#l7.340"></a><span id="l7.340" class="difflineplus">+    //  fault; don't sample this.  We turn it back on once we are in the folder.</span>
<a href="#l7.341"></a><span id="l7.341" class="difflineplus">+    this.perfSampling = false;</span>
<a href="#l7.342"></a><span id="l7.342" class="difflineplus">+</span>
<a href="#l7.343"></a><span id="l7.343">     if (this._indexingFolder)</span>
<a href="#l7.344"></a><span id="l7.344">       this._log.debug(&quot;Entering folder: &quot; + this._indexingFolder.URI);</span>
<a href="#l7.345"></a><span id="l7.345"> </span>
<a href="#l7.346"></a><span id="l7.346">     try {</span>
<a href="#l7.347"></a><span id="l7.347">       // The msf may need to be created or otherwise updated for local folders.</span>
<a href="#l7.348"></a><span id="l7.348">       // This may require yielding until such time as the msf has been created.</span>
<a href="#l7.349"></a><span id="l7.349">       try {</span>
<a href="#l7.350"></a><span id="l7.350">         if (this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineat">@@ -870,16 +1048,18 @@ var GlodaIndexer = {</span>
<a href="#l7.352"></a><span id="l7.352">       }</span>
<a href="#l7.353"></a><span id="l7.353">       // we get an nsIMsgDatabase out of this (unsurprisingly) which</span>
<a href="#l7.354"></a><span id="l7.354">       //  explicitly inherits from nsIDBChangeAnnouncer, which has the</span>
<a href="#l7.355"></a><span id="l7.355">       //  AddListener call we want.</span>
<a href="#l7.356"></a><span id="l7.356">       if (this._indexingDatabase == null)</span>
<a href="#l7.357"></a><span id="l7.357">         this._indexingDatabase = this._indexingFolder.msgDatabase;</span>
<a href="#l7.358"></a><span id="l7.358">       if (aNeedIterator)</span>
<a href="#l7.359"></a><span id="l7.359">         this._indexerGetIterator();</span>
<a href="#l7.360"></a><span id="l7.360" class="difflineplus">+      // re-enable performance sampling; we're responsible for our actions again</span>
<a href="#l7.361"></a><span id="l7.361" class="difflineplus">+      this.perfSampling = true;</span>
<a href="#l7.362"></a><span id="l7.362">       this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l7.363"></a><span id="l7.363">     }</span>
<a href="#l7.364"></a><span id="l7.364">     catch (ex) {</span>
<a href="#l7.365"></a><span id="l7.365">       this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l7.366"></a><span id="l7.366">                       (this._indexingFolder ?</span>
<a href="#l7.367"></a><span id="l7.367">                          this._indexingFolder.prettiestName : &quot;unknown&quot;) + </span>
<a href="#l7.368"></a><span id="l7.368">                       &quot;, skipping. Error was: &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l7.369"></a><span id="l7.369">                       ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l7.370"></a><span id="l7.370" class="difflineat">@@ -905,16 +1085,18 @@ var GlodaIndexer = {</span>
<a href="#l7.371"></a><span id="l7.371">    */</span>
<a href="#l7.372"></a><span id="l7.372">   _indexerCompletePendingFolderEntry:</span>
<a href="#l7.373"></a><span id="l7.373">       function gloda_indexer_indexerCompletePendingFolderEntry() {</span>
<a href="#l7.374"></a><span id="l7.374">     this._indexingDatabase = this._indexingFolder.msgDatabase;</span>
<a href="#l7.375"></a><span id="l7.375">     if (this._pendingFolderWantsIterator)</span>
<a href="#l7.376"></a><span id="l7.376">       this._indexerGetIterator();</span>
<a href="#l7.377"></a><span id="l7.377">     this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l7.378"></a><span id="l7.378">     this._log.debug(&quot;...Folder Loaded!&quot;);</span>
<a href="#l7.379"></a><span id="l7.379" class="difflineplus">+    // re-enable performance sampling; we're responsible for our actions again</span>
<a href="#l7.380"></a><span id="l7.380" class="difflineplus">+    this.perfSampling = true;</span>
<a href="#l7.381"></a><span id="l7.381"> </span>
<a href="#l7.382"></a><span id="l7.382">     // the load is no longer pending; we certainly don't want more notifications </span>
<a href="#l7.383"></a><span id="l7.383">     this._pendingFolderEntry = null;</span>
<a href="#l7.384"></a><span id="l7.384">     // indexerEnterFolder returned kWorkAsync, which means we need to notify</span>
<a href="#l7.385"></a><span id="l7.385">     //  the callback driver to get things going again.</span>
<a href="#l7.386"></a><span id="l7.386">     this.callbackDriver();</span>
<a href="#l7.387"></a><span id="l7.387">   },</span>
<a href="#l7.388"></a><span id="l7.388">   </span>
<a href="#l7.389"></a><span id="l7.389" class="difflineat">@@ -1038,18 +1220,21 @@ var GlodaIndexer = {</span>
<a href="#l7.390"></a><span id="l7.390">           this._batch = null;</span>
<a href="#l7.391"></a><span id="l7.391">           // (intentional fall-through to re-scheduling logic) </span>
<a href="#l7.392"></a><span id="l7.392">         // the batch wants to get re-scheduled, do so.</span>
<a href="#l7.393"></a><span id="l7.393">         case this.kWorkPause:</span>
<a href="#l7.394"></a><span id="l7.394">           if (this.indexing)</span>
<a href="#l7.395"></a><span id="l7.395">             this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l7.396"></a><span id="l7.396">                                          this._indexInterval,</span>
<a href="#l7.397"></a><span id="l7.397">                                          Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineminus">-          else // it's important to indicate no more callbacks are in flight</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineplus">+          else { // it's important to indicate no more callbacks are in flight</span>
<a href="#l7.400"></a><span id="l7.400">             this._indexingActive = false;</span>
<a href="#l7.401"></a><span id="l7.401" class="difflineplus">+            // we're not indexing anymore, so we're not sampling anymore.</span>
<a href="#l7.402"></a><span id="l7.402" class="difflineplus">+            this.perfSampling = false;</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineplus">+          }</span>
<a href="#l7.404"></a><span id="l7.404">           break;</span>
<a href="#l7.405"></a><span id="l7.405">         case this.kWorkAsync:</span>
<a href="#l7.406"></a><span id="l7.406">           // there is nothing to do.  some other code is now responsible for</span>
<a href="#l7.407"></a><span id="l7.407">           //  calling us.</span>
<a href="#l7.408"></a><span id="l7.408">           break;</span>
<a href="#l7.409"></a><span id="l7.409">       }</span>
<a href="#l7.410"></a><span id="l7.410">     }</span>
<a href="#l7.411"></a><span id="l7.411">     finally {    </span>
<a href="#l7.412"></a><span id="l7.412" class="difflineat">@@ -1108,42 +1293,46 @@ var GlodaIndexer = {</span>
<a href="#l7.413"></a><span id="l7.413">        last yield kWorkAsync */</span>
<a href="#l7.414"></a><span id="l7.414">     onItemsAdded: function() {},</span>
<a href="#l7.415"></a><span id="l7.415">     onItemsModified: function() {},</span>
<a href="#l7.416"></a><span id="l7.416">     onItemsRemoved: function() {},</span>
<a href="#l7.417"></a><span id="l7.417">     onQueryCompleted: function(aCollection) {</span>
<a href="#l7.418"></a><span id="l7.418">       GlodaIndexer.callbackDriver();</span>
<a href="#l7.419"></a><span id="l7.419">     }</span>
<a href="#l7.420"></a><span id="l7.420">   },</span>
<a href="#l7.421"></a><span id="l7.421" class="difflineminus">-  _forceGCCounter: 0,</span>
<a href="#l7.422"></a><span id="l7.422" class="difflineminus">-  FORCE_GC_THRESHOLD: 256,</span>
<a href="#l7.423"></a><span id="l7.423">   _workBatchData: undefined,</span>
<a href="#l7.424"></a><span id="l7.424">   /**</span>
<a href="#l7.425"></a><span id="l7.425">    * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l7.426"></a><span id="l7.426">    *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l7.427"></a><span id="l7.427">    *  _actualWorker generator which is doing the work.</span>
<a href="#l7.428"></a><span id="l7.428">    * workBatch will only produce kWorkAsync and kWorkDone notifications.</span>
<a href="#l7.429"></a><span id="l7.429">    *  If _actualWorker returns kWorkSync and there are still tokens available,</span>
<a href="#l7.430"></a><span id="l7.430">    *  workBatch will keep driving _actualWorker until it encounters a</span>
<a href="#l7.431"></a><span id="l7.431">    *  kWorkAsync (which workBatch will yield to callbackDriver), or it runs</span>
<a href="#l7.432"></a><span id="l7.432">    *  out of tokens and yields a kWorkDone. </span>
<a href="#l7.433"></a><span id="l7.433">    */</span>
<a href="#l7.434"></a><span id="l7.434">   workBatch: function gloda_index_workBatch() {</span>
<a href="#l7.435"></a><span id="l7.435">     let commitTokens = this._indexCommitTokens;</span>
<a href="#l7.436"></a><span id="l7.436">     GlodaDatastore._beginTransaction();</span>
<a href="#l7.437"></a><span id="l7.437"> </span>
<a href="#l7.438"></a><span id="l7.438">     while (commitTokens &gt; 0) {</span>
<a href="#l7.439"></a><span id="l7.439" class="difflineplus">+      // both explicit work activity points (sync + async) and transfer of</span>
<a href="#l7.440"></a><span id="l7.440" class="difflineplus">+      //  control return (via kWorkDone*) results in a token being eaten.  The</span>
<a href="#l7.441"></a><span id="l7.441" class="difflineplus">+      //  idea now is to make tokens less precious so that the adaptive logic</span>
<a href="#l7.442"></a><span id="l7.442" class="difflineplus">+      //  can adjust them with less impact.  (Before this change, doing 1</span>
<a href="#l7.443"></a><span id="l7.443" class="difflineplus">+      //  token's work per cycle ended up being an entire non-idle time-slice's</span>
<a href="#l7.444"></a><span id="l7.444" class="difflineplus">+      //  work.)</span>
<a href="#l7.445"></a><span id="l7.445">       for (let tokensLeft = this._indexTokens; tokensLeft &gt; 0;</span>
<a href="#l7.446"></a><span id="l7.446">           tokensLeft--, commitTokens--) {</span>
<a href="#l7.447"></a><span id="l7.447">         // we need to periodically force a GC to avoid excessive process size</span>
<a href="#l7.448"></a><span id="l7.448">         //  and because nsAutoLock is a jerk on debug builds</span>
<a href="#l7.449"></a><span id="l7.449" class="difflineminus">-        if (++this._forceGCCounter &gt;= this.FORCE_GC_THRESHOLD) {</span>
<a href="#l7.450"></a><span id="l7.450" class="difflineminus">-          Cu.forceGC();</span>
<a href="#l7.451"></a><span id="l7.451" class="difflineminus">-          this._forceGCCounter = 0;</span>
<a href="#l7.452"></a><span id="l7.452" class="difflineminus">-        }</span>
<a href="#l7.453"></a><span id="l7.453" class="difflineplus">+        // there is a constant in GlodaUtils that may need to be adjusted (and</span>
<a href="#l7.454"></a><span id="l7.454" class="difflineplus">+        //  potentially augmented with time-awareness) as token logic is</span>
<a href="#l7.455"></a><span id="l7.455" class="difflineplus">+        //  adjusted; or just for tuning purposes.</span>
<a href="#l7.456"></a><span id="l7.456" class="difflineplus">+        GlodaUtils.maybeGarbageCollect();</span>
<a href="#l7.457"></a><span id="l7.457">         </span>
<a href="#l7.458"></a><span id="l7.458">         if ((this._callbackHandle.activeIterator === null) &amp;&amp;</span>
<a href="#l7.459"></a><span id="l7.459">             !this._hireJobWorker()) {</span>
<a href="#l7.460"></a><span id="l7.460">           commitTokens = 0;</span>
<a href="#l7.461"></a><span id="l7.461">           break;</span>
<a href="#l7.462"></a><span id="l7.462">         }</span>
<a href="#l7.463"></a><span id="l7.463">       </span>
<a href="#l7.464"></a><span id="l7.464">         // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l7.465"></a><span id="l7.465" class="difflineat">@@ -1156,21 +1345,19 @@ var GlodaIndexer = {</span>
<a href="#l7.466"></a><span id="l7.466">               this._workBatchData = undefined;</span>
<a href="#l7.467"></a><span id="l7.467">               break;</span>
<a href="#l7.468"></a><span id="l7.468">             case this.kWorkAsync:</span>
<a href="#l7.469"></a><span id="l7.469">               this._workBatchData = yield this.kWorkAsync;</span>
<a href="#l7.470"></a><span id="l7.470">               break;</span>
<a href="#l7.471"></a><span id="l7.471">             case this.kWorkDone:</span>
<a href="#l7.472"></a><span id="l7.472">               this._callbackHandle.pop();</span>
<a href="#l7.473"></a><span id="l7.473">               this._workBatchData = undefined;</span>
<a href="#l7.474"></a><span id="l7.474" class="difflineminus">-              tokensLeft++; // don't eat a token for this pass</span>
<a href="#l7.475"></a><span id="l7.475">               break;</span>
<a href="#l7.476"></a><span id="l7.476">             case this.kWorkDoneWithResult:</span>
<a href="#l7.477"></a><span id="l7.477">               this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l7.478"></a><span id="l7.478" class="difflineminus">-              tokensLeft++; // don't eat a token for this pass</span>
<a href="#l7.479"></a><span id="l7.479">               continue;</span>
<a href="#l7.480"></a><span id="l7.480">           }</span>
<a href="#l7.481"></a><span id="l7.481">         }</span>
<a href="#l7.482"></a><span id="l7.482">         catch (ex) {</span>
<a href="#l7.483"></a><span id="l7.483">           // Try and recover if the job is recoverable and the iterator that</span>
<a href="#l7.484"></a><span id="l7.484">           //  experienced the problem wasn't the job worker.  (If it was the</span>
<a href="#l7.485"></a><span id="l7.485">           //  job worker, we can't rely on its state to be intact.) </span>
<a href="#l7.486"></a><span id="l7.486">           if (this._curIndexingJob.recoverable &gt; 0 &amp;&amp;</span>
<a href="#l7.487"></a><span id="l7.487" class="difflineat">@@ -1223,16 +1410,18 @@ var GlodaIndexer = {</span>
<a href="#l7.488"></a><span id="l7.488">       this._log.info(&quot;--- Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l7.489"></a><span id="l7.489">       </span>
<a href="#l7.490"></a><span id="l7.490">       if (this._indexingFolder !== null) {</span>
<a href="#l7.491"></a><span id="l7.491">         this._indexerLeaveFolder(true);</span>
<a href="#l7.492"></a><span id="l7.492">       }</span>
<a href="#l7.493"></a><span id="l7.493">       </span>
<a href="#l7.494"></a><span id="l7.494">       this._curIndexingJob = null;</span>
<a href="#l7.495"></a><span id="l7.495">       this._indexingDesired = false;</span>
<a href="#l7.496"></a><span id="l7.496" class="difflineplus">+      // we're not indexing anymore, so we're not sampling anymore</span>
<a href="#l7.497"></a><span id="l7.497" class="difflineplus">+      this.perfSampling = false;</span>
<a href="#l7.498"></a><span id="l7.498">       this._indexingJobCount = 0;</span>
<a href="#l7.499"></a><span id="l7.499">       this._indexingJobGoal = 0;</span>
<a href="#l7.500"></a><span id="l7.500">       return false;</span>
<a href="#l7.501"></a><span id="l7.501">     }</span>
<a href="#l7.502"></a><span id="l7.502"> </span>
<a href="#l7.503"></a><span id="l7.503">     //this._log.debug(&quot;++ Pulling job from queue of size &quot; +</span>
<a href="#l7.504"></a><span id="l7.504">     //                this._indexQueue.length);</span>
<a href="#l7.505"></a><span id="l7.505">     let job = this._curIndexingJob = this._indexQueue.shift();</span>
<a href="#l7.506"></a><span id="l7.506" class="difflineat">@@ -1390,17 +1579,17 @@ var GlodaIndexer = {</span>
<a href="#l7.507"></a><span id="l7.507">     </span>
<a href="#l7.508"></a><span id="l7.508">     if (!this.shouldIndexFolder(this._indexingFolder))</span>
<a href="#l7.509"></a><span id="l7.509">       yield this.kWorkDone;</span>
<a href="#l7.510"></a><span id="l7.510">     </span>
<a href="#l7.511"></a><span id="l7.511">     aJob.goal = this._indexingFolder.getTotalMessages(false);</span>
<a href="#l7.512"></a><span id="l7.512">     </span>
<a href="#l7.513"></a><span id="l7.513">     // there is of course a cost to all this header investigation even if we</span>
<a href="#l7.514"></a><span id="l7.514">     //  don't do something.  so we will yield with kWorkSync for every block. </span>
<a href="#l7.515"></a><span id="l7.515" class="difflineminus">-    const HEADER_CHECK_BLOCK_SIZE = 100;</span>
<a href="#l7.516"></a><span id="l7.516" class="difflineplus">+    const HEADER_CHECK_BLOCK_SIZE = 10;</span>
<a href="#l7.517"></a><span id="l7.517">     </span>
<a href="#l7.518"></a><span id="l7.518">     let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l7.519"></a><span id="l7.519">     // we can safely presume if we are here that this folder has been selected</span>
<a href="#l7.520"></a><span id="l7.520">     //  for offline processing...</span>
<a href="#l7.521"></a><span id="l7.521"> </span>
<a href="#l7.522"></a><span id="l7.522">     // Handle the filthy case.  A filthy folder may have misleading properties</span>
<a href="#l7.523"></a><span id="l7.523">     //  on the message that claim the message is indexed.  They are misleading</span>
<a href="#l7.524"></a><span id="l7.524">     //  because the database, for whatever reason, does not have the messages</span>
<a href="#l7.525"></a><span id="l7.525" class="difflineat">@@ -1430,22 +1619,23 @@ var GlodaIndexer = {</span>
<a href="#l7.526"></a><span id="l7.526">         //  so no action is required.</span>
<a href="#l7.527"></a><span id="l7.527">       }</span>
<a href="#l7.528"></a><span id="l7.528">       // this will automatically persist to the database</span>
<a href="#l7.529"></a><span id="l7.529">       glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l7.530"></a><span id="l7.530">       </span>
<a href="#l7.531"></a><span id="l7.531">       // We used up the iterator, get a new one.</span>
<a href="#l7.532"></a><span id="l7.532">       this._indexerGetIterator();</span>
<a href="#l7.533"></a><span id="l7.533">     }</span>
<a href="#l7.534"></a><span id="l7.534" class="difflineminus">-    </span>
<a href="#l7.535"></a><span id="l7.535" class="difflineplus">+</span>
<a href="#l7.536"></a><span id="l7.536">     for (let msgHdr in this._indexingIterator) {</span>
<a href="#l7.537"></a><span id="l7.537">       // per above, we want to periodically release control while doing all</span>
<a href="#l7.538"></a><span id="l7.538">       //  this header traversal/investigation.</span>
<a href="#l7.539"></a><span id="l7.539" class="difflineminus">-      if (++aJob.offset % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l7.540"></a><span id="l7.540" class="difflineplus">+      if (++aJob.offset % HEADER_CHECK_BLOCK_SIZE == 0) {</span>
<a href="#l7.541"></a><span id="l7.541">         yield this.kWorkSync;</span>
<a href="#l7.542"></a><span id="l7.542" class="difflineplus">+      }</span>
<a href="#l7.543"></a><span id="l7.543">       </span>
<a href="#l7.544"></a><span id="l7.544">       if ((isLocal || (msgHdr.flags &amp; MSG_FLAG_OFFLINE)) &amp;&amp;</span>
<a href="#l7.545"></a><span id="l7.545">           !(msgHdr.flags &amp; MSG_FLAG_EXPUNGED)) {</span>
<a href="#l7.546"></a><span id="l7.546">         // this returns 0 when missing</span>
<a href="#l7.547"></a><span id="l7.547">         let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l7.548"></a><span id="l7.548">                              this.GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l7.549"></a><span id="l7.549">         </span>
<a href="#l7.550"></a><span id="l7.550">         // if it has a gloda message id, it has been indexed, but it still</span>
<a href="#l7.551"></a><span id="l7.551" class="difflineat">@@ -1652,24 +1842,34 @@ var GlodaIndexer = {</span>
<a href="#l7.552"></a><span id="l7.552">   },</span>
<a href="#l7.553"></a><span id="l7.553">   </span>
<a href="#l7.554"></a><span id="l7.554">   /* *********** Event Processing *********** */</span>
<a href="#l7.555"></a><span id="l7.555">   observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l7.556"></a><span id="l7.556">     // idle</span>
<a href="#l7.557"></a><span id="l7.557">     if (aTopic == &quot;idle&quot;) {</span>
<a href="#l7.558"></a><span id="l7.558">       if (this.indexing)</span>
<a href="#l7.559"></a><span id="l7.559">         this._log.debug(&quot;Detected idle, throttling up.&quot;);</span>
<a href="#l7.560"></a><span id="l7.560" class="difflineplus">+      // save off our adapted active values</span>
<a href="#l7.561"></a><span id="l7.561" class="difflineplus">+      this._indexInterval_whenActive = this._indexInterval;</span>
<a href="#l7.562"></a><span id="l7.562" class="difflineplus">+      this._indexTokens_whenActive = this._indexTokens;</span>
<a href="#l7.563"></a><span id="l7.563" class="difflineplus">+      // start using our idle values</span>
<a href="#l7.564"></a><span id="l7.564">       this._indexInterval = this._indexInterval_whenIdle;</span>
<a href="#l7.565"></a><span id="l7.565">       this._indexTokens = this._indexTokens_whenIdle;</span>
<a href="#l7.566"></a><span id="l7.566" class="difflineplus">+      this._cpuTarget = this._cpuTarget_whenIdle; // (don't need to save)</span>
<a href="#l7.567"></a><span id="l7.567">     }</span>
<a href="#l7.568"></a><span id="l7.568">     else if (aTopic == &quot;back&quot;) {</span>
<a href="#l7.569"></a><span id="l7.569">       if (this.indexing)</span>
<a href="#l7.570"></a><span id="l7.570">         this._log.debug(&quot;Detected un-idle, throttling down.&quot;);</span>
<a href="#l7.571"></a><span id="l7.571" class="difflineplus">+      // save off our idle values</span>
<a href="#l7.572"></a><span id="l7.572" class="difflineplus">+      this._indexInterval_whenIdle = this._indexInterval;</span>
<a href="#l7.573"></a><span id="l7.573" class="difflineplus">+      this._indexTokens_whenIdle = this._indexTokens;</span>
<a href="#l7.574"></a><span id="l7.574" class="difflineplus">+      // start using our active values</span>
<a href="#l7.575"></a><span id="l7.575">       this._indexInterval = this._indexInterval_whenActive;</span>
<a href="#l7.576"></a><span id="l7.576">       this._indexTokens = this._indexTokens_whenActive;</span>
<a href="#l7.577"></a><span id="l7.577" class="difflineplus">+      this._cpuTarget = this._cpuTarget_whenActive; // (don't need to save)</span>
<a href="#l7.578"></a><span id="l7.578">     }</span>
<a href="#l7.579"></a><span id="l7.579">     // offline status</span>
<a href="#l7.580"></a><span id="l7.580">     else if (aTopic == &quot;network:offline-status-changed&quot;) {</span>
<a href="#l7.581"></a><span id="l7.581">       if (aData == &quot;offline&quot;) {</span>
<a href="#l7.582"></a><span id="l7.582">         this.suppressIndexing = true;</span>
<a href="#l7.583"></a><span id="l7.583">       }</span>
<a href="#l7.584"></a><span id="l7.584">       else { // online</span>
<a href="#l7.585"></a><span id="l7.585">         this.suppressIndexing = false;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/db/gloda/modules/utils.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/utils.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -149,9 +149,54 @@ var GlodaUtils = {</span>
<a href="#l8.4"></a><span id="l8.4">       str = sstream.read(4096);</span>
<a href="#l8.5"></a><span id="l8.5">     }</span>
<a href="#l8.6"></a><span id="l8.6"> </span>
<a href="#l8.7"></a><span id="l8.7">     sstream.close();</span>
<a href="#l8.8"></a><span id="l8.8">     fstream.close();</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10">     return data;</span>
<a href="#l8.11"></a><span id="l8.11">   },</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+  </span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+  /**</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+   * Force a garbage-collection sweep.  Gloda has to force garbage collection</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+   *  periodically because XPConnect's XPCJSRuntime::DeferredRelease mechanism</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+   *  can end up holding onto a ridiculously high number of XPConnect objects in</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+   *  between normal garbage collections.  This has mainly posed a problem</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+   *  because nsAutolock is a jerk in DEBUG builds, but in theory this also</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+   *  helps us even out our memory usage.</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+   * We also are starting to do this more to try and keep the garbage collection</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+   *  durations acceptable.  We intentionally avoid triggering the cycle</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+   *  collector in those cases, as we do presume a non-trivial fixed cost for</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+   *  cycle collection.  (And really all we want is XPConnect to not be a jerk.)</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineplus">+   * This method exists mainly to centralize our GC activities and because if</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineplus">+   *  we do start involving the cycle collector, that is a non-trivial block of</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineplus">+   *  code to copy-and-paste all over the place (at least in a module).</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineplus">+   * </span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+   * @param aCycleCollecting Do we need the cycle collector to run?  Currently</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+   *     unused / unimplemented, but we would use</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+   *     nsIDOMWindowUtils.garbageCollect() to do so.</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+   */</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+  forceGarbageCollection:</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+    function gloda_utils_garbageCollection(aCycleCollecting) {</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+    Cu.forceGC();</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+  },</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+  </span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+  _forceGCCounter: 0,</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+  /**</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+   * The question of when we should actually force the garbage collection is</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+   *  tricky.  Right now, our only caller is from the indexer, and the indexer</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+   *  issues its calls based on token consumption, which is already a fairly</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+   *  nebulous sort of thing.  On the upside, tokens do correlate with</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineplus">+   *  XPConnect activity fairly well, although just how much does vary a bit.</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+   */</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+  FORCE_GC_THRESHOLD: 64,</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+  /**</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineplus">+   * Along the lines of forceGarbageCollection, allow code to hint that it is</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+   *  doing a fair bit of garbage generation as it relates to XPConnect and that</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+   *  we should note it and consider garbage collecting.</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineplus">+   */</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineplus">+  maybeGarbageCollect: function gloda_utils_maybeGarbageCollect() {</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineplus">+    if (++this._forceGCCounter &gt;= this.FORCE_GC_THRESHOLD) {</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineplus">+      GlodaUtils.forceGarbageCollection(false);</span>
<a href="#l8.54"></a><span id="l8.54" class="difflineplus">+      this._forceGCCounter = 0;</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineplus">+    }</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineplus">+  }</span>
<a href="#l8.57"></a><span id="l8.57"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/db/gloda/test/resources/glodaTestHelper.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/db/gloda/test/resources/glodaTestHelper.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -215,16 +215,18 @@ function imsInit() {</span>
<a href="#l9.4"></a><span id="l9.4">     prefSvc.setBoolPref(&quot;mail.biff.animate_dock_icon&quot;, false);</span>
<a href="#l9.5"></a><span id="l9.5">   </span>
<a href="#l9.6"></a><span id="l9.6">     Gloda.addIndexerListener(messageIndexerListener.onIndexNotification);</span>
<a href="#l9.7"></a><span id="l9.7">     ims.catchAllCollection = Gloda._wildcardCollection(Gloda.NOUN_MESSAGE);</span>
<a href="#l9.8"></a><span id="l9.8">     ims.catchAllCollection.listener = messageCollectionListener;</span>
<a href="#l9.9"></a><span id="l9.9">     </span>
<a href="#l9.10"></a><span id="l9.10">     // The indexer doesn't need to worry about load; zero his rescheduling time. </span>
<a href="#l9.11"></a><span id="l9.11">     GlodaIndexer._indexInterval = 0;</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+    // And it doesn't need to adjust its performance, either.</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+    GlodaIndexer._PERF_SAMPLE_RATE_MS = 24 * 60 * 60 * 1000;</span>
<a href="#l9.14"></a><span id="l9.14">     </span>
<a href="#l9.15"></a><span id="l9.15">     if (ims.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l9.16"></a><span id="l9.16">       // set up POP3 fakeserver to feed things in...</span>
<a href="#l9.17"></a><span id="l9.17">       [ims.daemon, ims.server] = setupServerDaemon();</span>
<a href="#l9.18"></a><span id="l9.18">       // (this will call loadLocalMailAccount())</span>
<a href="#l9.19"></a><span id="l9.19">       ims.incomingServer = createPop3ServerAndLocalFolders();</span>
<a href="#l9.20"></a><span id="l9.20">   </span>
<a href="#l9.21"></a><span id="l9.21">       ims.pop3Service = Cc[&quot;@mozilla.org/messenger/popservice;1&quot;]</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineat">@@ -465,25 +467,40 @@ var messageCollectionListener = {</span>
<a href="#l9.23"></a><span id="l9.23">   },</span>
<a href="#l9.24"></a><span id="l9.24">   </span>
<a href="#l9.25"></a><span id="l9.25">   onItemsRemoved: function(aItems) {</span>
<a href="#l9.26"></a><span id="l9.26">     dump(&quot;!!! messageCollectionListener.onItemsRemoved\n&quot;);</span>
<a href="#l9.27"></a><span id="l9.27">   }</span>
<a href="#l9.28"></a><span id="l9.28"> };</span>
<a href="#l9.29"></a><span id="l9.29"> </span>
<a href="#l9.30"></a><span id="l9.30"> /**</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineplus">+ * Allow tests to register a callback to be invoked when the indexing completes.</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+ *   Only one at a time, etc.  </span>
<a href="#l9.33"></a><span id="l9.33" class="difflineplus">+ */</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineplus">+function runOnIndexingComplete(aCallback) {</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+  messageIndexerListener.callbackOnDone = aCallback; </span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+}</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+/**</span>
<a href="#l9.39"></a><span id="l9.39">  * Gloda indexer listener, used to know when all active indexing jobs have</span>
<a href="#l9.40"></a><span id="l9.40">  *  completed so that we can try and process all the things that should have</span>
<a href="#l9.41"></a><span id="l9.41">  *  been processed.</span>
<a href="#l9.42"></a><span id="l9.42">  */</span>
<a href="#l9.43"></a><span id="l9.43"> var messageIndexerListener = {</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+  callbackOnDone: null,</span>
<a href="#l9.45"></a><span id="l9.45">   onIndexNotification: function(aStatus, aPrettyName, aJobIndex, aJobTotal,</span>
<a href="#l9.46"></a><span id="l9.46">                                 aJobItemIndex, aJobItemGoal) {</span>
<a href="#l9.47"></a><span id="l9.47">     // we only care if indexing has just completed...</span>
<a href="#l9.48"></a><span id="l9.48">     if (!GlodaIndexer.indexing) {</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineplus">+      if (messageIndexerListener.callbackOnDone) {</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+        let callback = messageIndexerListener.callbackOnDone;</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+        messageIndexerListener.callbackOnDone = null;</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineplus">+        callback();</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineplus">+      }</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+      </span>
<a href="#l9.55"></a><span id="l9.55">       let ims = indexMessageState;</span>
<a href="#l9.56"></a><span id="l9.56">       </span>
<a href="#l9.57"></a><span id="l9.57">       // this is just the synthetic notification if inputMessages is null</span>
<a href="#l9.58"></a><span id="l9.58">       if (ims.inputMessages === null) {</span>
<a href="#l9.59"></a><span id="l9.59">         dump(&quot;((( ignoring indexing notification, assuming synthetic &quot; +</span>
<a href="#l9.60"></a><span id="l9.60">              &quot;notification.\n&quot;);</span>
<a href="#l9.61"></a><span id="l9.61">         return;</span>
<a href="#l9.62"></a><span id="l9.62">       }</span>
<a href="#l9.63"></a><span id="l9.63" class="difflineat">@@ -885,17 +902,16 @@ function _gh_test_iterator() {</span>
<a href="#l9.64"></a><span id="l9.64">     killFakeServer();</span>
<a href="#l9.65"></a><span id="l9.65">   }</span>
<a href="#l9.66"></a><span id="l9.66"> </span>
<a href="#l9.67"></a><span id="l9.67">   do_test_finished();</span>
<a href="#l9.68"></a><span id="l9.68">   </span>
<a href="#l9.69"></a><span id="l9.69">   // once the control flow hits the root after do_test_finished, we're done,</span>
<a href="#l9.70"></a><span id="l9.70">   //  so let's just yield something to avoid callers having to deal with an</span>
<a href="#l9.71"></a><span id="l9.71">   //  exception indicating completion.</span>
<a href="#l9.72"></a><span id="l9.72" class="difflineminus">-  glodaHelperIterator = null;</span>
<a href="#l9.73"></a><span id="l9.73">   yield null;</span>
<a href="#l9.74"></a><span id="l9.74"> }</span>
<a href="#l9.75"></a><span id="l9.75"> </span>
<a href="#l9.76"></a><span id="l9.76"> var _next_test_currently_in_test = false;</span>
<a href="#l9.77"></a><span id="l9.77"> function next_test() {</span>
<a href="#l9.78"></a><span id="l9.78">   // to avoid crazy messed up stacks, use a time-out to get us to our next thing</span>
<a href="#l9.79"></a><span id="l9.79">   if (_next_test_currently_in_test) {</span>
<a href="#l9.80"></a><span id="l9.80">     do_timeout(0, &quot;next_test()&quot;);</span>
<a href="#l9.81"></a><span id="l9.81" class="difflineat">@@ -918,17 +934,17 @@ DEFAULT_LONGEST_TEST_RUN_CONCEIVABLE_SEC</span>
<a href="#l9.82"></a><span id="l9.82"> /**</span>
<a href="#l9.83"></a><span id="l9.83">  * Test driving logic that takes a list of tests to run.  Every completed test</span>
<a href="#l9.84"></a><span id="l9.84">  *  needs to call (or cause to be called) next_test.</span>
<a href="#l9.85"></a><span id="l9.85">  * </span>
<a href="#l9.86"></a><span id="l9.86">  * @param aTests A list of test functions to call.</span>
<a href="#l9.87"></a><span id="l9.87">  * @param aLongestTestRunTimeConceivableInSecs Optional parameter </span>
<a href="#l9.88"></a><span id="l9.88">  */</span>
<a href="#l9.89"></a><span id="l9.89"> function glodaHelperRunTests(aTests, aLongestTestRunTimeConceivableInSecs) {</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineminus">-  if (aLongestTestRunTimeConceivableInSecs === undefined)</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+  if (aLongestTestRunTimeConceivableInSecs == null)</span>
<a href="#l9.92"></a><span id="l9.92">     aLongestTestRunTimeConceivableInSecs =</span>
<a href="#l9.93"></a><span id="l9.93">         DEFAULT_LONGEST_TEST_RUN_CONCEIVABLE_SECS;</span>
<a href="#l9.94"></a><span id="l9.94">   do_timeout(aLongestTestRunTimeConceivableInSecs * 1000,</span>
<a href="#l9.95"></a><span id="l9.95">       &quot;do_throw('Timeout running test, and we want you to have the log.');&quot;);</span>
<a href="#l9.96"></a><span id="l9.96">   </span>
<a href="#l9.97"></a><span id="l9.97">   imsInit();</span>
<a href="#l9.98"></a><span id="l9.98">   glodaHelperTests = aTests;</span>
<a href="#l9.99"></a><span id="l9.99">   glodaHelperIterator = _gh_test_iterator();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineminus">--- /dev/null</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineplus">+++ b/mailnews/db/gloda/test/resources/mockIndexer.js</span>
<a href="#l10.4"></a><span id="l10.4" class="difflineat">@@ -0,0 +1,38 @@</span>
<a href="#l10.5"></a><span id="l10.5" class="difflineplus">+/**</span>
<a href="#l10.6"></a><span id="l10.6" class="difflineplus">+ * A mock gloda indexer.  Right now it just exists to let us cause the indexer</span>
<a href="#l10.7"></a><span id="l10.7" class="difflineplus">+ *  to think it is indexing but really have nothing going on.</span>
<a href="#l10.8"></a><span id="l10.8" class="difflineplus">+ */</span>
<a href="#l10.9"></a><span id="l10.9" class="difflineplus">+var MockIndexer = {</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineplus">+  /* public interface */</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+  name: &quot;mock_indexer&quot;,</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+  enable: function() {</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+    this.enabled = true;</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+  },</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+  disable: function() {</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+    this.enabled = false;</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+  },</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+  get workers() {</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+    return [[&quot;forever&quot;, this._worker_index_forever]];</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+  },</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+  initialSweep: function() {</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+    this.initialSweepCalled = false;</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+  },</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+  /* mock interface */</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+  enabled: false,</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+  initialSweepCalled: false,</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+  indexForever: function() {</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineplus">+    GlodaIndexer.indexJob(new IndexingJob(&quot;forever&quot;, 0, null));</span>
<a href="#l10.29"></a><span id="l10.29" class="difflineplus">+  },</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineplus">+  stopIndexingForever: function() {</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+    GlodaIndexer.callbackDriver();</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+  },</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineplus">+  /* implementation */</span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+  _worker_index_forever: function(aJob, aCallbackHandle) {</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+    // pretend that something async is happening, but nothing is really</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+    //  happening!  muahahaha!</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+    // </span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+    yield GlodaIndexer.kWorkAsync;</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+    yield GlodaIndexer.kWorkDone;</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineplus">+  }</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineplus">+};</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+GlodaIndexer.registerIndexer(MockIndexer);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1">new file mode 100644</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineminus">--- /dev/null</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineplus">+++ b/mailnews/db/gloda/test/resources/mockTimer.js</span>
<a href="#l11.4"></a><span id="l11.4" class="difflineat">@@ -0,0 +1,77 @@</span>
<a href="#l11.5"></a><span id="l11.5" class="difflineplus">+/**</span>
<a href="#l11.6"></a><span id="l11.6" class="difflineplus">+ * Mock nsITimer implementation.  Intended to be clobbered into place after the</span>
<a href="#l11.7"></a><span id="l11.7" class="difflineplus">+ *  actual timer would normally be constructed.  Has a helpful method to help</span>
<a href="#l11.8"></a><span id="l11.8" class="difflineplus">+ *  you do that, too!</span>
<a href="#l11.9"></a><span id="l11.9" class="difflineplus">+ */</span>
<a href="#l11.10"></a><span id="l11.10" class="difflineplus">+function MockTimer(aObj, aAttrName) {</span>
<a href="#l11.11"></a><span id="l11.11" class="difflineplus">+  if (aObj &amp;&amp; aAttrName)</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+    this.clobber(aObj, aAttrName);</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+}</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+MockTimer.prototype = {</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+  /* public interface */</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+  TYPE_ONE_SHOT: 0,</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+  TYPE_REPEATING_SLACK: 1,</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineplus">+  TYPE_REPEATING_PRECISE: 2,</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+  initWithCallback: function(aCallback, aDelay, aType) {</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineplus">+    if (aCallback instanceof Ci.nsITimerCallback)</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineplus">+      this.callback = aCallback;</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+    else // it was just a function that we need to dress up.</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+      this.callback = {notify: function() {aCallback();}};</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineplus">+    this.delay = aDelay;</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+    this.type = aType;</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+  },</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineplus">+  init: function(aObserver, aDelay, aType) {</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+    this.observer = aObserver;</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+    this.delay = aDelay;</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineplus">+    this.type = aType;</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineplus">+    this.callback = null;</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+  },</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineplus">+  cancel: function() {</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineplus">+    this.callback = null;</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+  },</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+  delay: 0,</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+  type: 0,</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+  _callback: null,</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineplus">+  _activeCallback: null,</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+  get callback() {</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineplus">+    return this._callback || this._activeCallback;</span>
<a href="#l11.42"></a><span id="l11.42" class="difflineplus">+  },</span>
<a href="#l11.43"></a><span id="l11.43" class="difflineplus">+  set callback(aCallback) {</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineplus">+    this._callback = aCallback;</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineplus">+  },</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineplus">+  get target() {</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineplus">+    throw Error(&quot;Homey don't play that&quot;);</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineplus">+  },</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+  /* private */</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineplus">+  observer: null,</span>
<a href="#l11.51"></a><span id="l11.51" class="difflineplus">+  /* mock interface */</span>
<a href="#l11.52"></a><span id="l11.52" class="difflineplus">+  get oneShot() {</span>
<a href="#l11.53"></a><span id="l11.53" class="difflineplus">+    return this.type == this.TYPE_ONE_SHOT;</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineplus">+  },</span>
<a href="#l11.55"></a><span id="l11.55" class="difflineplus">+  clobber: function(aObj, aAttrName) {</span>
<a href="#l11.56"></a><span id="l11.56" class="difflineplus">+    let realTimer = aObj[aAttrName];</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineplus">+    realTimer.cancel();</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineplus">+    this.delay = realTimer.delay;</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineplus">+    this.type = realTimer.type;</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineplus">+    this.callback = realTimer.callback;</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+    aObj[aAttrName] = this;</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineplus">+  },</span>
<a href="#l11.63"></a><span id="l11.63" class="difflineplus">+  fireNow: function() {</span>
<a href="#l11.64"></a><span id="l11.64" class="difflineplus">+    if (this._callback) {</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineplus">+      this._activeCallback = this._callback;</span>
<a href="#l11.66"></a><span id="l11.66" class="difflineplus">+      if (this.oneShot)</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineplus">+        this._callback = null;</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineplus">+      this._activeCallback.notify();</span>
<a href="#l11.69"></a><span id="l11.69" class="difflineplus">+      this._activeCallback = null;</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineplus">+    }</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineplus">+    else if (this.observer) {</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineplus">+      let observer = this.observer;</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineplus">+      if (this.oneShot)</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineplus">+        this.observer = null;</span>
<a href="#l11.75"></a><span id="l11.75" class="difflineplus">+      observer.observe(this, &quot;timer-callback&quot;, null);</span>
<a href="#l11.76"></a><span id="l11.76" class="difflineplus">+    }</span>
<a href="#l11.77"></a><span id="l11.77" class="difflineplus">+  },</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineplus">+  get active() {</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineplus">+    return (this.callback != null) || (this.observer != null);</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineplus">+  }</span>
<a href="#l11.81"></a><span id="l11.81" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1">new file mode 100644</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineminus">--- /dev/null</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_adaptive.js</span>
<a href="#l12.4"></a><span id="l12.4" class="difflineat">@@ -0,0 +1,246 @@</span>
<a href="#l12.5"></a><span id="l12.5" class="difflineplus">+/*</span>
<a href="#l12.6"></a><span id="l12.6" class="difflineplus">+ * Test our adaptive indexing logic; the thing that tries to adjust our</span>
<a href="#l12.7"></a><span id="l12.7" class="difflineplus">+ *  indexing constants based on perceived processor utilization.  We fake all</span>
<a href="#l12.8"></a><span id="l12.8" class="difflineplus">+ *  the load stuff, of course.</span>
<a href="#l12.9"></a><span id="l12.9" class="difflineplus">+ * </span>
<a href="#l12.10"></a><span id="l12.10" class="difflineplus">+ * Out of necessity, this test knows about the internals of the adaptive</span>
<a href="#l12.11"></a><span id="l12.11" class="difflineplus">+ *  indexing logic.</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+ */</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+do_import_script(&quot;../mailnews/db/gloda/test/resources/glodaTestHelper.js&quot;);</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+do_import_script(&quot;../mailnews/db/gloda/test/resources/mockIndexer.js&quot;);</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+do_import_script(&quot;../mailnews/db/gloda/test/resources/mockTimer.js&quot;);</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineplus">+</span>
<a href="#l12.18"></a><span id="l12.18" class="difflineplus">+/* ===== Mock Objects ==== */</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineplus">+var FakeStopwatch = {</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+  /* (fake) public interface */</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+  start: function () {</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineplus">+    this.running = true;</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineplus">+    dump(&quot;stopwatch started\n&quot;);</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+  },</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineplus">+  stop: function() {</span>
<a href="#l12.27"></a><span id="l12.27" class="difflineplus">+    this.running = false;</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+    dump(&quot;stopwatch stopped\n&quot;);</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineplus">+  },</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+  // just always claim we're 2 seconds...</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+  realTimeSeconds: 2.0,</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+  cpuTimeSeconds: 0.0,</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+  /* mock support */</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+  running: false,</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+  </span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+  tooMuch: function() {</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+    this.cpuTimeSeconds = this.realTimeSeconds;</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+  },</span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+  tooLittle: function() {</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineplus">+    this.cpuTimeSeconds = 0.0;</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineplus">+  },</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineplus">+  justRight: function() {</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineplus">+    this.cpuTimeSeconds = this.realTimeSeconds * GlodaIndexer._cpuTarget - 0.05;</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+  }</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineplus">+};</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineplus">+</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineplus">+// hack in our stopwatch</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+GlodaIndexer._perfStopwatch = FakeStopwatch;</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineplus">+// hack in a timer for the stopwatch control</span>
<a href="#l12.50"></a><span id="l12.50" class="difflineplus">+var perfTimer = new MockTimer(GlodaIndexer, &quot;_perfTimer&quot;);</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineplus">+</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+/* ===== Helpers ===== */</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+function fireCleanStabilizeAverage() {</span>
<a href="#l12.54"></a><span id="l12.54" class="difflineplus">+  GlodaIndexer._perfSamples = [];</span>
<a href="#l12.55"></a><span id="l12.55" class="difflineplus">+  for (let iFire = 0; iFire &lt; GlodaIndexer._perfSamplePointCount; iFire++)</span>
<a href="#l12.56"></a><span id="l12.56" class="difflineplus">+    perfTimer.fireNow();</span>
<a href="#l12.57"></a><span id="l12.57" class="difflineplus">+}</span>
<a href="#l12.58"></a><span id="l12.58" class="difflineplus">+</span>
<a href="#l12.59"></a><span id="l12.59" class="difflineplus">+/* ===== Tests ===== */</span>
<a href="#l12.60"></a><span id="l12.60" class="difflineplus">+</span>
<a href="#l12.61"></a><span id="l12.61" class="difflineplus">+function test_sample_when_you_should() {</span>
<a href="#l12.62"></a><span id="l12.62" class="difflineplus">+  // imsInit clobbered this, put it back.</span>
<a href="#l12.63"></a><span id="l12.63" class="difflineplus">+  GlodaIndexer._indexInterval = GlodaIndexer._indexInterval_whenActive;</span>
<a href="#l12.64"></a><span id="l12.64" class="difflineplus">+  </span>
<a href="#l12.65"></a><span id="l12.65" class="difflineplus">+  do_check_false(FakeStopwatch.running);</span>
<a href="#l12.66"></a><span id="l12.66" class="difflineplus">+  do_check_false(perfTimer.active);</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineplus">+  </span>
<a href="#l12.68"></a><span id="l12.68" class="difflineplus">+  MockIndexer.indexForever();</span>
<a href="#l12.69"></a><span id="l12.69" class="difflineplus">+  </span>
<a href="#l12.70"></a><span id="l12.70" class="difflineplus">+  do_check_true(FakeStopwatch.running);</span>
<a href="#l12.71"></a><span id="l12.71" class="difflineplus">+  do_check_true(perfTimer.active);</span>
<a href="#l12.72"></a><span id="l12.72" class="difflineplus">+  </span>
<a href="#l12.73"></a><span id="l12.73" class="difflineplus">+  next_test();</span>
<a href="#l12.74"></a><span id="l12.74" class="difflineplus">+}</span>
<a href="#l12.75"></a><span id="l12.75" class="difflineplus">+</span>
<a href="#l12.76"></a><span id="l12.76" class="difflineplus">+function test_throttle_up() {</span>
<a href="#l12.77"></a><span id="l12.77" class="difflineplus">+  let preTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.78"></a><span id="l12.78" class="difflineplus">+  let preInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l12.79"></a><span id="l12.79" class="difflineplus">+  </span>
<a href="#l12.80"></a><span id="l12.80" class="difflineplus">+  FakeStopwatch.tooLittle();</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineplus">+  // fire one too few times, verify that nothing happens for those pre-firing</span>
<a href="#l12.82"></a><span id="l12.82" class="difflineplus">+  //  times... (this only matters for the first time we sample per the sampler</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineplus">+  //  being active...)</span>
<a href="#l12.84"></a><span id="l12.84" class="difflineplus">+  for (let iFire = 1; iFire &lt; GlodaIndexer._perfSamplePointCount; iFire++) {</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineplus">+    perfTimer.fireNow();</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineplus">+    do_check_eq(preTokens, GlodaIndexer._indexTokens);</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineplus">+    do_check_eq(preInterval, GlodaIndexer._indexInterval);</span>
<a href="#l12.88"></a><span id="l12.88" class="difflineplus">+  }</span>
<a href="#l12.89"></a><span id="l12.89" class="difflineplus">+  // now fire with some actual effect</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineplus">+  perfTimer.fireNow();</span>
<a href="#l12.91"></a><span id="l12.91" class="difflineplus">+  </span>
<a href="#l12.92"></a><span id="l12.92" class="difflineplus">+  // make sure everything went in the right direction</span>
<a href="#l12.93"></a><span id="l12.93" class="difflineplus">+  do_check_true(preTokens &lt;= GlodaIndexer._indexTokens);</span>
<a href="#l12.94"></a><span id="l12.94" class="difflineplus">+  do_check_true(preInterval &gt;= GlodaIndexer._indexInterval);</span>
<a href="#l12.95"></a><span id="l12.95" class="difflineplus">+  // make sure something actually happened</span>
<a href="#l12.96"></a><span id="l12.96" class="difflineplus">+  do_check_true(((GlodaIndexer._indexTokens - preTokens) &gt; 0) ||</span>
<a href="#l12.97"></a><span id="l12.97" class="difflineplus">+                ((preInterval - GlodaIndexer._indexInterval) &gt; 0));</span>
<a href="#l12.98"></a><span id="l12.98" class="difflineplus">+                </span>
<a href="#l12.99"></a><span id="l12.99" class="difflineplus">+  next_test();</span>
<a href="#l12.100"></a><span id="l12.100" class="difflineplus">+}</span>
<a href="#l12.101"></a><span id="l12.101" class="difflineplus">+</span>
<a href="#l12.102"></a><span id="l12.102" class="difflineplus">+function test_throttle_down() {</span>
<a href="#l12.103"></a><span id="l12.103" class="difflineplus">+  let preTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineplus">+  let preInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l12.105"></a><span id="l12.105" class="difflineplus">+</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineplus">+  FakeStopwatch.tooMuch();</span>
<a href="#l12.107"></a><span id="l12.107" class="difflineplus">+  fireCleanStabilizeAverage();</span>
<a href="#l12.108"></a><span id="l12.108" class="difflineplus">+</span>
<a href="#l12.109"></a><span id="l12.109" class="difflineplus">+  // make sure everything went in the right direction</span>
<a href="#l12.110"></a><span id="l12.110" class="difflineplus">+  do_check_true(preTokens &gt;= GlodaIndexer._indexTokens);</span>
<a href="#l12.111"></a><span id="l12.111" class="difflineplus">+  do_check_true(preInterval &lt;= GlodaIndexer._indexInterval);</span>
<a href="#l12.112"></a><span id="l12.112" class="difflineplus">+  // make sure something actually happened</span>
<a href="#l12.113"></a><span id="l12.113" class="difflineplus">+  do_check_true(((GlodaIndexer._indexTokens - preTokens) &lt; 0) ||</span>
<a href="#l12.114"></a><span id="l12.114" class="difflineplus">+                ((preInterval - GlodaIndexer._indexInterval) &lt; 0));</span>
<a href="#l12.115"></a><span id="l12.115" class="difflineplus">+  </span>
<a href="#l12.116"></a><span id="l12.116" class="difflineplus">+  next_test();</span>
<a href="#l12.117"></a><span id="l12.117" class="difflineplus">+}</span>
<a href="#l12.118"></a><span id="l12.118" class="difflineplus">+</span>
<a href="#l12.119"></a><span id="l12.119" class="difflineplus">+function test_nop_on_stable() {</span>
<a href="#l12.120"></a><span id="l12.120" class="difflineplus">+</span>
<a href="#l12.121"></a><span id="l12.121" class="difflineplus">+  let preTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.122"></a><span id="l12.122" class="difflineplus">+  let preInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l12.123"></a><span id="l12.123" class="difflineplus">+</span>
<a href="#l12.124"></a><span id="l12.124" class="difflineplus">+  FakeStopwatch.justRight();</span>
<a href="#l12.125"></a><span id="l12.125" class="difflineplus">+  fireCleanStabilizeAverage();</span>
<a href="#l12.126"></a><span id="l12.126" class="difflineplus">+</span>
<a href="#l12.127"></a><span id="l12.127" class="difflineplus">+  // make sure nothing happened</span>
<a href="#l12.128"></a><span id="l12.128" class="difflineplus">+  do_check_eq(preTokens, GlodaIndexer._indexTokens);</span>
<a href="#l12.129"></a><span id="l12.129" class="difflineplus">+  do_check_eq(preInterval, GlodaIndexer._indexInterval);</span>
<a href="#l12.130"></a><span id="l12.130" class="difflineplus">+  </span>
<a href="#l12.131"></a><span id="l12.131" class="difflineplus">+  next_test();</span>
<a href="#l12.132"></a><span id="l12.132" class="difflineplus">+}</span>
<a href="#l12.133"></a><span id="l12.133" class="difflineplus">+</span>
<a href="#l12.134"></a><span id="l12.134" class="difflineplus">+var MAX_STEPS_TO_CAPS = 100;</span>
<a href="#l12.135"></a><span id="l12.135" class="difflineplus">+</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineplus">+function test_cap_slowest() {</span>
<a href="#l12.137"></a><span id="l12.137" class="difflineplus">+  FakeStopwatch.tooMuch();</span>
<a href="#l12.138"></a><span id="l12.138" class="difflineplus">+</span>
<a href="#l12.139"></a><span id="l12.139" class="difflineplus">+  GlodaIndexer._perfSamples = [];</span>
<a href="#l12.140"></a><span id="l12.140" class="difflineplus">+  </span>
<a href="#l12.141"></a><span id="l12.141" class="difflineplus">+  let lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.142"></a><span id="l12.142" class="difflineplus">+  let lastInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l12.143"></a><span id="l12.143" class="difflineplus">+  for (let steps = MAX_STEPS_TO_CAPS; steps; steps--) {</span>
<a href="#l12.144"></a><span id="l12.144" class="difflineplus">+    perfTimer.fireNow();</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineplus">+    </span>
<a href="#l12.146"></a><span id="l12.146" class="difflineplus">+    // make sure we're always moving in the right directions</span>
<a href="#l12.147"></a><span id="l12.147" class="difflineplus">+    do_check_true(lastTokens &gt;= GlodaIndexer._indexTokens);</span>
<a href="#l12.148"></a><span id="l12.148" class="difflineplus">+    do_check_true(lastInterval &lt;= GlodaIndexer._indexInterval);</span>
<a href="#l12.149"></a><span id="l12.149" class="difflineplus">+    lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.150"></a><span id="l12.150" class="difflineplus">+    lastInterval = GlodaIndexer._indexInterval;</span>
<a href="#l12.151"></a><span id="l12.151" class="difflineplus">+    </span>
<a href="#l12.152"></a><span id="l12.152" class="difflineplus">+    // make sure we never go above the cap</span>
<a href="#l12.153"></a><span id="l12.153" class="difflineplus">+    do_check_true(GlodaIndexer._indexInterval &lt;=</span>
<a href="#l12.154"></a><span id="l12.154" class="difflineplus">+                  GlodaIndexer._MAX_TIMER_INTERVAL_MS);</span>
<a href="#l12.155"></a><span id="l12.155" class="difflineplus">+    // if we have hit the cap, give it a few more spins </span>
<a href="#l12.156"></a><span id="l12.156" class="difflineplus">+    if (GlodaIndexer._indexInterval == GlodaIndexer._MAX_TIMER_INTERVAL_MS &amp;&amp;</span>
<a href="#l12.157"></a><span id="l12.157" class="difflineplus">+        steps &gt; 5)</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineplus">+      steps = 5;</span>
<a href="#l12.159"></a><span id="l12.159" class="difflineplus">+  }</span>
<a href="#l12.160"></a><span id="l12.160" class="difflineplus">+  // make sure we actual did hit the cap</span>
<a href="#l12.161"></a><span id="l12.161" class="difflineplus">+  do_check_eq(GlodaIndexer._indexInterval, GlodaIndexer._MAX_TIMER_INTERVAL_MS);</span>
<a href="#l12.162"></a><span id="l12.162" class="difflineplus">+  </span>
<a href="#l12.163"></a><span id="l12.163" class="difflineplus">+  next_test();</span>
<a href="#l12.164"></a><span id="l12.164" class="difflineplus">+}</span>
<a href="#l12.165"></a><span id="l12.165" class="difflineplus">+</span>
<a href="#l12.166"></a><span id="l12.166" class="difflineplus">+function test_cap_fastest() {</span>
<a href="#l12.167"></a><span id="l12.167" class="difflineplus">+  FakeStopwatch.tooLittle();</span>
<a href="#l12.168"></a><span id="l12.168" class="difflineplus">+  </span>
<a href="#l12.169"></a><span id="l12.169" class="difflineplus">+  GlodaIndexer._perfSamples = [];</span>
<a href="#l12.170"></a><span id="l12.170" class="difflineplus">+  </span>
<a href="#l12.171"></a><span id="l12.171" class="difflineplus">+  let lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.172"></a><span id="l12.172" class="difflineplus">+  let lastInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l12.173"></a><span id="l12.173" class="difflineplus">+  for (let steps = MAX_STEPS_TO_CAPS; steps; steps--) {</span>
<a href="#l12.174"></a><span id="l12.174" class="difflineplus">+    perfTimer.fireNow();</span>
<a href="#l12.175"></a><span id="l12.175" class="difflineplus">+    </span>
<a href="#l12.176"></a><span id="l12.176" class="difflineplus">+    // make sure we're always moving in the right directions</span>
<a href="#l12.177"></a><span id="l12.177" class="difflineplus">+    do_check_true(lastTokens &lt;= GlodaIndexer._indexTokens);</span>
<a href="#l12.178"></a><span id="l12.178" class="difflineplus">+    do_check_true(lastInterval &gt;= GlodaIndexer._indexInterval);</span>
<a href="#l12.179"></a><span id="l12.179" class="difflineplus">+    lastTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.180"></a><span id="l12.180" class="difflineplus">+    lastInterval = GlodaIndexer._indexInterval;</span>
<a href="#l12.181"></a><span id="l12.181" class="difflineplus">+    </span>
<a href="#l12.182"></a><span id="l12.182" class="difflineplus">+    // make sure we never go below the cap</span>
<a href="#l12.183"></a><span id="l12.183" class="difflineplus">+    do_check_true(GlodaIndexer._indexInterval &gt;=</span>
<a href="#l12.184"></a><span id="l12.184" class="difflineplus">+                  GlodaIndexer._MIN_TIMER_INTERVAL_MS);</span>
<a href="#l12.185"></a><span id="l12.185" class="difflineplus">+    // if we have hit the cap, give it a few more spins </span>
<a href="#l12.186"></a><span id="l12.186" class="difflineplus">+    if (GlodaIndexer._indexInterval == GlodaIndexer._MIN_TIMER_INTERVAL_MS &amp;&amp;</span>
<a href="#l12.187"></a><span id="l12.187" class="difflineplus">+        steps &gt; 5)</span>
<a href="#l12.188"></a><span id="l12.188" class="difflineplus">+      steps = 5;</span>
<a href="#l12.189"></a><span id="l12.189" class="difflineplus">+  }</span>
<a href="#l12.190"></a><span id="l12.190" class="difflineplus">+  // make sure we actual did hit the cap</span>
<a href="#l12.191"></a><span id="l12.191" class="difflineplus">+  do_check_eq(GlodaIndexer._indexInterval, GlodaIndexer._MIN_TIMER_INTERVAL_MS);</span>
<a href="#l12.192"></a><span id="l12.192" class="difflineplus">+  </span>
<a href="#l12.193"></a><span id="l12.193" class="difflineplus">+  next_test();</span>
<a href="#l12.194"></a><span id="l12.194" class="difflineplus">+}</span>
<a href="#l12.195"></a><span id="l12.195" class="difflineplus">+</span>
<a href="#l12.196"></a><span id="l12.196" class="difflineplus">+function test_idle() {</span>
<a href="#l12.197"></a><span id="l12.197" class="difflineplus">+  let activeTokens = GlodaIndexer._indexTokens;</span>
<a href="#l12.198"></a><span id="l12.198" class="difflineplus">+  let activeInterval =  GlodaIndexer._indexInterval;</span>
<a href="#l12.199"></a><span id="l12.199" class="difflineplus">+  </span>
<a href="#l12.200"></a><span id="l12.200" class="difflineplus">+  // go idle, make sure we switch to the right set of constants</span>
<a href="#l12.201"></a><span id="l12.201" class="difflineplus">+  GlodaIndexer.observe(null, &quot;idle&quot;, null);</span>
<a href="#l12.202"></a><span id="l12.202" class="difflineplus">+  do_check_eq(GlodaIndexer._cpuTarget, GlodaIndexer._cpuTarget_whenIdle);</span>
<a href="#l12.203"></a><span id="l12.203" class="difflineplus">+  do_check_eq(GlodaIndexer._indexInterval,</span>
<a href="#l12.204"></a><span id="l12.204" class="difflineplus">+              GlodaIndexer._indexInterval_whenIdle);</span>
<a href="#l12.205"></a><span id="l12.205" class="difflineplus">+  do_check_eq(GlodaIndexer._indexTokens, GlodaIndexer._indexTokens_whenIdle);</span>
<a href="#l12.206"></a><span id="l12.206" class="difflineplus">+  </span>
<a href="#l12.207"></a><span id="l12.207" class="difflineplus">+  // go active, make sure we switch back</span>
<a href="#l12.208"></a><span id="l12.208" class="difflineplus">+  GlodaIndexer.observe(null, &quot;back&quot;, null);</span>
<a href="#l12.209"></a><span id="l12.209" class="difflineplus">+  do_check_eq(GlodaIndexer._cpuTarget, GlodaIndexer._cpuTarget_whenActive);</span>
<a href="#l12.210"></a><span id="l12.210" class="difflineplus">+  do_check_eq(GlodaIndexer._indexInterval,</span>
<a href="#l12.211"></a><span id="l12.211" class="difflineplus">+              GlodaIndexer._indexInterval_whenActive);</span>
<a href="#l12.212"></a><span id="l12.212" class="difflineplus">+  do_check_eq(GlodaIndexer._indexTokens, GlodaIndexer._indexTokens_whenActive);</span>
<a href="#l12.213"></a><span id="l12.213" class="difflineplus">+  </span>
<a href="#l12.214"></a><span id="l12.214" class="difflineplus">+  // also make sure that what we switched to was what we were using before idle</span>
<a href="#l12.215"></a><span id="l12.215" class="difflineplus">+  //  happened...</span>
<a href="#l12.216"></a><span id="l12.216" class="difflineplus">+  do_check_eq(activeTokens, GlodaIndexer._indexTokens);</span>
<a href="#l12.217"></a><span id="l12.217" class="difflineplus">+  do_check_eq(activeInterval, GlodaIndexer._indexInterval);</span>
<a href="#l12.218"></a><span id="l12.218" class="difflineplus">+  </span>
<a href="#l12.219"></a><span id="l12.219" class="difflineplus">+  next_test();</span>
<a href="#l12.220"></a><span id="l12.220" class="difflineplus">+}</span>
<a href="#l12.221"></a><span id="l12.221" class="difflineplus">+</span>
<a href="#l12.222"></a><span id="l12.222" class="difflineplus">+function test_stop_sampling_when_done() {</span>
<a href="#l12.223"></a><span id="l12.223" class="difflineplus">+  do_check_true(FakeStopwatch.running);</span>
<a href="#l12.224"></a><span id="l12.224" class="difflineplus">+</span>
<a href="#l12.225"></a><span id="l12.225" class="difflineplus">+  runOnIndexingComplete(function() {</span>
<a href="#l12.226"></a><span id="l12.226" class="difflineplus">+    do_check_false(FakeStopwatch.running);</span>
<a href="#l12.227"></a><span id="l12.227" class="difflineplus">+    do_check_false(perfTimer.active);</span>
<a href="#l12.228"></a><span id="l12.228" class="difflineplus">+  </span>
<a href="#l12.229"></a><span id="l12.229" class="difflineplus">+    next_test();</span>
<a href="#l12.230"></a><span id="l12.230" class="difflineplus">+  });</span>
<a href="#l12.231"></a><span id="l12.231" class="difflineplus">+  </span>
<a href="#l12.232"></a><span id="l12.232" class="difflineplus">+  MockIndexer.stopIndexingForever();</span>
<a href="#l12.233"></a><span id="l12.233" class="difflineplus">+}</span>
<a href="#l12.234"></a><span id="l12.234" class="difflineplus">+</span>
<a href="#l12.235"></a><span id="l12.235" class="difflineplus">+/* ===== Driver ====== */</span>
<a href="#l12.236"></a><span id="l12.236" class="difflineplus">+</span>
<a href="#l12.237"></a><span id="l12.237" class="difflineplus">+var tests = [</span>
<a href="#l12.238"></a><span id="l12.238" class="difflineplus">+  test_sample_when_you_should,</span>
<a href="#l12.239"></a><span id="l12.239" class="difflineplus">+  test_throttle_up,</span>
<a href="#l12.240"></a><span id="l12.240" class="difflineplus">+  test_throttle_down,</span>
<a href="#l12.241"></a><span id="l12.241" class="difflineplus">+  test_nop_on_stable,</span>
<a href="#l12.242"></a><span id="l12.242" class="difflineplus">+  test_cap_slowest,</span>
<a href="#l12.243"></a><span id="l12.243" class="difflineplus">+  test_cap_fastest,</span>
<a href="#l12.244"></a><span id="l12.244" class="difflineplus">+  test_idle,</span>
<a href="#l12.245"></a><span id="l12.245" class="difflineplus">+  test_stop_sampling_when_done</span>
<a href="#l12.246"></a><span id="l12.246" class="difflineplus">+];</span>
<a href="#l12.247"></a><span id="l12.247" class="difflineplus">+</span>
<a href="#l12.248"></a><span id="l12.248" class="difflineplus">+function run_test() {</span>
<a href="#l12.249"></a><span id="l12.249" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l12.250"></a><span id="l12.250" class="difflineplus">+}</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

