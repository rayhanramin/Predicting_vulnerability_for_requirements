<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 1004:a79b923a9cba395cb3911b27c9599ffb8c997caf</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ a79b923a9cba395cb3911b27c9599ffb8c997caf" />
<meta property="og:url" content="/comm-central/rev/a79b923a9cba395cb3911b27c9599ffb8c997caf" />
<meta property="og:description" content="Merge Gloda changes to tip; these are currently not yet reviewed or turned on.  Review will before this code is turned on by default." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / a79b923a9cba395cb3911b27c9599ffb8c997caf 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/a79b923a9cba395cb3911b27c9599ffb8c997caf">shortlog</a> |
<a href="/comm-central/log/a79b923a9cba395cb3911b27c9599ffb8c997caf">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/a79b923a9cba395cb3911b27c9599ffb8c997caf">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/a79b923a9cba395cb3911b27c9599ffb8c997caf">files</a> |
changeset |
<a href="/comm-central/raw-rev/a79b923a9cba395cb3911b27c9599ffb8c997caf">raw</a>  | <a href="/comm-central/archive/a79b923a9cba395cb3911b27c9599ffb8c997caf.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
Merge Gloda changes to tip; these are currently not yet reviewed or turned on.  Review will before this code is turned on by default.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#68;&#97;&#110;&#32;&#77;&#111;&#115;&#101;&#100;&#97;&#108;&#101;&#32;&#60;&#100;&#109;&#111;&#115;&#101;&#64;&#109;&#111;&#122;&#105;&#108;&#108;&#97;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 04 Nov 2008 11:52:46 -0800</td></tr>

<tr>
 <td>changeset 1004</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/a79b923a9cba395cb3911b27c9599ffb8c997caf">a79b923a9cba395cb3911b27c9599ffb8c997caf</a></td>
</tr>



<tr>
<td>parent 817</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/3800bcea163a11767d9c7492164e576213fc15ec">3800bcea163a11767d9c7492164e576213fc15ec</a> (current diff)
</td>
</tr>
<tr>
<td>parent 1003</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/1f72e947eeb15896260fd4937ec3a1e647e10bf0">1f72e947eeb15896260fd4937ec3a1e647e10bf0</a> (<a href="/comm-central/rev/1f72e947eeb15896260fd4937ec3a1e647e10bf0:a79b923a9cba">diff</a>)
</td>
</tr>

<tr>
<td>child 1005</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/21dc49e33c230b1f77b9e95a66b9f297d23808b3">21dc49e33c230b1f77b9e95a66b9f297d23808b3</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=a79b923a9cba395cb3911b27c9599ffb8c997caf">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">Merge Gloda changes to tip; these are currently not yet reviewed or turned on.  Review will before this code is turned on by default.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/.hgtags</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/.hgtags</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -3,8 +3,20 @@ 474f19a1b5fccec46bbeeeacd6f3cd368f3543a4</span>
<a href="#l1.4"></a><span id="l1.4"> d7ce1e64f1cc52003e3f3f326bd8f5260ce03733 SEAMONKEY_2_0a1_BUILD1</span>
<a href="#l1.5"></a><span id="l1.5"> d7ce1e64f1cc52003e3f3f326bd8f5260ce03733 SEAMONKEY_2_0a1_RELEASE</span>
<a href="#l1.6"></a><span id="l1.6"> 7fe8dc6fc848247b3df68fb7c6cbcd7c4665d497 THUNDERBIRD_3_0a3_RELEASE</span>
<a href="#l1.7"></a><span id="l1.7"> 7fe8dc6fc848247b3df68fb7c6cbcd7c4665d497 THUNDERBIRD_3_0a3_BUILD1</span>
<a href="#l1.8"></a><span id="l1.8"> 841a3d525cd73daac28e3d49b016bb46e6fcccbd THUNDERBIRD_3_0a3_RELEASE</span>
<a href="#l1.9"></a><span id="l1.9"> 841a3d525cd73daac28e3d49b016bb46e6fcccbd THUNDERBIRD_3_0a3_BUILD1</span>
<a href="#l1.10"></a><span id="l1.10"> 0000000000000000000000000000000000000000 THUNDERBIRD_3_0a3_RELEASE</span>
<a href="#l1.11"></a><span id="l1.11"> 0000000000000000000000000000000000000000 THUNDERBIRD_3_0a3_BUILD1</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+93bb9e91d8cd4caa82602289230c380e10ceb3b1 gloda-milestone-0</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+a3ff3e9b9edd130cebdf4ac48c7155265589a5d5 stable</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+4b665f55dc96f043ac129be3f1c886546b5b9e6d gloda-milestone-1</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+cb593cb6c3e57a01ac066c50362b37f8bdb2c2fc stable</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+9f65871c06614dbec00b278cd60321713c01e028 stable</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+c1902489c55f67799d41e7b032497ca04de6aa7c stable</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+fe9ea5855aee1bfd0825edeaadc7547fd87504e4 stable</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+8dfd8299e8a5f146d81040a844320e473e8a0fc2 stable</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+3d52bc12f0f5d699a465432dc577cd479e12e0e7 stable-with-mods</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+08c2e01d2acf8333311f497d050b22b01e72e460 stable-with-mods</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+1936d4ec8044fd4cfdc636b43ec5e7488f86388c stable</span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+8e9fe32109b8a7232a5844320ca273bf5c3a4528 unstable</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1">new file mode 100644</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineminus">--- /dev/null</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineplus">+++ b/mailnews/db/gloda/.project</span>
<a href="#l2.4"></a><span id="l2.4" class="difflineat">@@ -0,0 +1,11 @@</span>
<a href="#l2.5"></a><span id="l2.5" class="difflineplus">+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<a href="#l2.6"></a><span id="l2.6" class="difflineplus">+&lt;projectDescription&gt;</span>
<a href="#l2.7"></a><span id="l2.7" class="difflineplus">+	&lt;name&gt;gloda&lt;/name&gt;</span>
<a href="#l2.8"></a><span id="l2.8" class="difflineplus">+	&lt;comment&gt;&lt;/comment&gt;</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineplus">+	&lt;projects&gt;</span>
<a href="#l2.10"></a><span id="l2.10" class="difflineplus">+	&lt;/projects&gt;</span>
<a href="#l2.11"></a><span id="l2.11" class="difflineplus">+	&lt;buildSpec&gt;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+	&lt;/buildSpec&gt;</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+	&lt;natures&gt;</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+	&lt;/natures&gt;</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+&lt;/projectDescription&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">new file mode 100644</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineminus">--- /dev/null</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineplus">+++ b/mailnews/db/gloda/Makefile.in</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineat">@@ -0,0 +1,53 @@</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+#</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+# ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+# Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+#</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+# The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+# the License. You may obtain a copy of the License at</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+# http://www.mozilla.org/MPL/</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+#</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+# for the specific language governing rights and limitations under the</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+# License.</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+#</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+# The Original Code is mozilla.org code.</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+#</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+# The Initial Developer of the Original Code is</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+# Mozilla Messaging, Inc.</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+#</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+# Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+# the Initial Developer. All Rights Reserved.</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+#</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+# Contributor(s):</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+#</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+# Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+# either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+# or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+# in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+# of those above. If you wish to allow use of your version of this file only</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+# under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+# use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+# decision by deleting the provisions above and replace them with the notice</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+# and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+# the provisions above, a recipient may use your version of this file under</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+# the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+#</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+# ***** END LICENSE BLOCK *****</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+DEPTH		= ../../..</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+topsrcdir	= @top_srcdir@</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+srcdir		= @srcdir@</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+VPATH		= @srcdir@</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+include $(DEPTH)/config/autoconf.mk</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+DIRS		= modules components</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+#DIRS        = components</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+ifdef ENABLE_TESTS</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+DIRS += test</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+endif</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+include $(topsrcdir)/config/rules.mk</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1">new file mode 100755</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineminus">--- /dev/null</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineplus">+++ b/mailnews/db/gloda/build.sh</span>
<a href="#l4.4"></a><span id="l4.4" class="difflineat">@@ -0,0 +1,128 @@</span>
<a href="#l4.5"></a><span id="l4.5" class="difflineplus">+#!/bin/bash</span>
<a href="#l4.6"></a><span id="l4.6" class="difflineplus">+# build.sh -- builds JAR and XPI files for mozilla extensions</span>
<a href="#l4.7"></a><span id="l4.7" class="difflineplus">+#   by Nickolay Ponomarev &lt;asqueella@gmail.com&gt;</span>
<a href="#l4.8"></a><span id="l4.8" class="difflineplus">+#   (original version based on Nathan Yergler's build script)</span>
<a href="#l4.9"></a><span id="l4.9" class="difflineplus">+# Most recent version is at &lt;http://kb.mozillazine.org/Bash_build_script&gt;</span>
<a href="#l4.10"></a><span id="l4.10" class="difflineplus">+</span>
<a href="#l4.11"></a><span id="l4.11" class="difflineplus">+# This script assumes the following directory structure:</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+# ./</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+#   chrome.manifest (optional - for newer extensions)</span>
<a href="#l4.14"></a><span id="l4.14" class="difflineplus">+#   install.rdf</span>
<a href="#l4.15"></a><span id="l4.15" class="difflineplus">+#   (other files listed in $ROOT_FILES)</span>
<a href="#l4.16"></a><span id="l4.16" class="difflineplus">+#</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineplus">+#   content/    |</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+#   locale/     |} these can be named arbitrary and listed in $CHROME_PROVIDERS</span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+#   skin/       |</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+#</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+#   defaults/   |</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+#   components/ |} these must be listed in $ROOT_DIRS in order to be packaged</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+#   ...         |</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+#</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+# It uses a temporary directory ./build when building; don't use that!</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+# Script's output is:</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+# ./$APP_NAME.xpi</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+# ./$APP_NAME.jar  (only if $KEEP_JAR=1)</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+# ./files -- the list of packaged files</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+#</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+# Note: It modifies chrome.manifest when packaging so that it points to </span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+#       chrome/$APP_NAME.jar!/*</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+#</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+# default configuration file is ./config_build.sh, unless another file is </span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+# specified in command-line. Available config variables:</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+APP_NAME=          # short-name, jar and xpi files name. Must be lowercase with no spaces</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+CHROME_PROVIDERS=  # which chrome providers we have (space-separated list)</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+CLEAN_UP=          # delete the jar / &quot;files&quot; when done?       (1/0)</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+ROOT_FILES=        # put these files in root of xpi (space separated list of leaf filenames)</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+ROOT_DIRS=         # ...and these directories       (space separated list)</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+BEFORE_BUILD=      # run this before building       (bash command)</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+AFTER_BUILD=       # ...and this after the build    (bash command)</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+if [ -z $1 ]; then</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+  . ./config_build.sh</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+else</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+  . $1</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+fi</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+if [ -z $APP_NAME ]; then</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineplus">+  echo &quot;You need to create build config file first!&quot;</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineplus">+  echo &quot;Read comments at the beginning of this script for more info.&quot;</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineplus">+  exit;</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+fi</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+ROOT_DIR=`pwd`</span>
<a href="#l4.58"></a><span id="l4.58" class="difflineplus">+TMP_DIR=build</span>
<a href="#l4.59"></a><span id="l4.59" class="difflineplus">+</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+#uncomment to debug</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+#set -x</span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+# remove any left-over files from previous build</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+rm -f $APP_NAME.jar $APP_NAME.xpi files</span>
<a href="#l4.65"></a><span id="l4.65" class="difflineplus">+rm -rf $TMP_DIR</span>
<a href="#l4.66"></a><span id="l4.66" class="difflineplus">+</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineplus">+$BEFORE_BUILD</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+mkdir --parents --verbose $TMP_DIR/chrome</span>
<a href="#l4.70"></a><span id="l4.70" class="difflineplus">+</span>
<a href="#l4.71"></a><span id="l4.71" class="difflineplus">+# generate the JAR file, excluding CVS and temporary files</span>
<a href="#l4.72"></a><span id="l4.72" class="difflineplus">+JAR_FILE=$TMP_DIR/chrome/$APP_NAME.jar</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineplus">+echo &quot;Generating $JAR_FILE...&quot;</span>
<a href="#l4.74"></a><span id="l4.74" class="difflineplus">+for CHROME_SUBDIR in $CHROME_PROVIDERS; do</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineplus">+  find $CHROME_SUBDIR -path '*CVS*' -prune -o -type f -print | grep -v \~ &gt;&gt; files</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineplus">+done</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+zip -0 -r $JAR_FILE `cat files`</span>
<a href="#l4.79"></a><span id="l4.79" class="difflineplus">+# The following statement should be used instead if you don't wish to use the JAR file</span>
<a href="#l4.80"></a><span id="l4.80" class="difflineplus">+#cp --verbose --parents `cat files` $TMP_DIR/chrome</span>
<a href="#l4.81"></a><span id="l4.81" class="difflineplus">+</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineplus">+# prepare components and defaults</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineplus">+echo &quot;Copying various files to $TMP_DIR folder...&quot;</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+for DIR in $ROOT_DIRS; do</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+  mkdir $TMP_DIR/$DIR</span>
<a href="#l4.86"></a><span id="l4.86" class="difflineplus">+  FILES=&quot;`find $DIR -path '*CVS*' -prune -o -type f -print | grep -v \~`&quot;</span>
<a href="#l4.87"></a><span id="l4.87" class="difflineplus">+  echo $FILES &gt;&gt; files</span>
<a href="#l4.88"></a><span id="l4.88" class="difflineplus">+  cp --verbose --parents $FILES $TMP_DIR</span>
<a href="#l4.89"></a><span id="l4.89" class="difflineplus">+done</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineplus">+</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineplus">+# Copy other files to the root of future XPI.</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+for ROOT_FILE in $ROOT_FILES install.rdf chrome.manifest; do</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+  cp --verbose $ROOT_FILE $TMP_DIR</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+  if [ -f $ROOT_FILE ]; then</span>
<a href="#l4.95"></a><span id="l4.95" class="difflineplus">+    echo $ROOT_FILE &gt;&gt; files</span>
<a href="#l4.96"></a><span id="l4.96" class="difflineplus">+  fi</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineplus">+done</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+</span>
<a href="#l4.99"></a><span id="l4.99" class="difflineplus">+cd $TMP_DIR</span>
<a href="#l4.100"></a><span id="l4.100" class="difflineplus">+</span>
<a href="#l4.101"></a><span id="l4.101" class="difflineplus">+if [ -f &quot;chrome.manifest&quot; ]; then</span>
<a href="#l4.102"></a><span id="l4.102" class="difflineplus">+  echo &quot;Preprocessing chrome.manifest...&quot;</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineplus">+  # You think this is scary?</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+  #s/^(content\s+\S*\s+)(\S*\/)$/\1jar:chrome\/$APP_NAME\.jar!\/\2/</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineplus">+  #s/^(skin|locale)(\s+\S*\s+\S*\s+)(.*\/)$/\1\2jar:chrome\/$APP_NAME\.jar!\/\3/</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+  #</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+  # Then try this! (Same, but with characters escaped for bash :)</span>
<a href="#l4.108"></a><span id="l4.108" class="difflineplus">+  sed -i -r s/^\(content\\s+\\S*\\s+\)\(\\S*\\/\)$/\\1jar:chrome\\/$APP_NAME\\.jar!\\/\\2/ chrome.manifest</span>
<a href="#l4.109"></a><span id="l4.109" class="difflineplus">+  sed -i -r s/^\(skin\|locale\)\(\\s+\\S*\\s+\\S*\\s+\)\(.*\\/\)$/\\1\\2jar:chrome\\/$APP_NAME\\.jar!\\/\\3/ chrome.manifest</span>
<a href="#l4.110"></a><span id="l4.110" class="difflineplus">+</span>
<a href="#l4.111"></a><span id="l4.111" class="difflineplus">+  # (it simply adds jar:chrome/whatever.jar!/ at appropriate positions of chrome.manifest)</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineplus">+fi</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineplus">+</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineplus">+# generate the XPI file</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineplus">+echo &quot;Generating $APP_NAME.xpi...&quot;</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineplus">+zip -r ../$APP_NAME.xpi *</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineplus">+</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineplus">+cd &quot;$ROOT_DIR&quot;</span>
<a href="#l4.119"></a><span id="l4.119" class="difflineplus">+</span>
<a href="#l4.120"></a><span id="l4.120" class="difflineplus">+echo &quot;Cleanup...&quot;</span>
<a href="#l4.121"></a><span id="l4.121" class="difflineplus">+if [ $CLEAN_UP = 0 ]; then</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineplus">+  # save the jar file</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineplus">+  mv $TMP_DIR/chrome/$APP_NAME.jar .</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineplus">+else</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+  rm ./files</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineplus">+fi</span>
<a href="#l4.127"></a><span id="l4.127" class="difflineplus">+</span>
<a href="#l4.128"></a><span id="l4.128" class="difflineplus">+# remove the working files</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineplus">+rm -rf $TMP_DIR</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineplus">+echo &quot;Done!&quot;</span>
<a href="#l4.131"></a><span id="l4.131" class="difflineplus">+</span>
<a href="#l4.132"></a><span id="l4.132" class="difflineplus">+$AFTER_BUILD</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1">new file mode 100644</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineminus">--- /dev/null</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineplus">+++ b/mailnews/db/gloda/chrome.manifest</span>
<a href="#l5.4"></a><span id="l5.4" class="difflineat">@@ -0,0 +1,5 @@</span>
<a href="#l5.5"></a><span id="l5.5" class="difflineplus">+content	gloda	content/</span>
<a href="#l5.6"></a><span id="l5.6" class="difflineplus">+locale	gloda	en-US	locale/en-US/</span>
<a href="#l5.7"></a><span id="l5.7" class="difflineplus">+skin	gloda	classic/1.0	skin/</span>
<a href="#l5.8"></a><span id="l5.8" class="difflineplus">+overlay	chrome://messenger/content/messenger.xul	chrome://gloda/content/thunderbirdOverlay.xul</span>
<a href="#l5.9"></a><span id="l5.9" class="difflineplus">+resource gloda ./</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1">new file mode 100644</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineminus">--- /dev/null</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineplus">+++ b/mailnews/db/gloda/components/Makefile.in</span>
<a href="#l6.4"></a><span id="l6.4" class="difflineat">@@ -0,0 +1,50 @@</span>
<a href="#l6.5"></a><span id="l6.5" class="difflineplus">+#</span>
<a href="#l6.6"></a><span id="l6.6" class="difflineplus">+# ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l6.7"></a><span id="l6.7" class="difflineplus">+# Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l6.8"></a><span id="l6.8" class="difflineplus">+#</span>
<a href="#l6.9"></a><span id="l6.9" class="difflineplus">+# The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l6.10"></a><span id="l6.10" class="difflineplus">+# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l6.11"></a><span id="l6.11" class="difflineplus">+# the License. You may obtain a copy of the License at</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+# http://www.mozilla.org/MPL/</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+#</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+# for the specific language governing rights and limitations under the</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+# License.</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+#</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+# The Original Code is mozilla.org code.</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+#</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+# The Initial Developer of the Original Code is</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+# Mozilla Messaging, Inc.</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+#</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+# Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+# the Initial Developer. All Rights Reserved.</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+#</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+# Contributor(s):</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+#</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineplus">+# Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineplus">+# either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+# or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+# in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineplus">+# of those above. If you wish to allow use of your version of this file only</span>
<a href="#l6.34"></a><span id="l6.34" class="difflineplus">+# under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l6.35"></a><span id="l6.35" class="difflineplus">+# use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l6.36"></a><span id="l6.36" class="difflineplus">+# decision by deleting the provisions above and replace them with the notice</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+# and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+# the provisions above, a recipient may use your version of this file under</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+# the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+#</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+# ***** END LICENSE BLOCK *****</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+DEPTH		= ../../../..</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+topsrcdir	= @top_srcdir@</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+srcdir		= @srcdir@</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+VPATH		= @srcdir@</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+include $(DEPTH)/config/autoconf.mk</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+MODULE = mailnewsglobaldb</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+EXTRA_COMPONENTS = $(wildcard $(srcdir)/*.js)</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+include $(topsrcdir)/config/rules.mk</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1">new file mode 100644</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineminus">--- /dev/null</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineplus">+++ b/mailnews/db/gloda/components/glautocomp.js</span>
<a href="#l7.4"></a><span id="l7.4" class="difflineat">@@ -0,0 +1,494 @@</span>
<a href="#l7.5"></a><span id="l7.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l7.6"></a><span id="l7.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l7.7"></a><span id="l7.7" class="difflineplus">+ *</span>
<a href="#l7.8"></a><span id="l7.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l7.9"></a><span id="l7.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l7.10"></a><span id="l7.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l7.11"></a><span id="l7.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+ *</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+ * License.</span>
<a href="#l7.17"></a><span id="l7.17" class="difflineplus">+ *</span>
<a href="#l7.18"></a><span id="l7.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l7.19"></a><span id="l7.19" class="difflineplus">+ *</span>
<a href="#l7.20"></a><span id="l7.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l7.21"></a><span id="l7.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l7.23"></a><span id="l7.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineplus">+ *</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l7.26"></a><span id="l7.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l7.27"></a><span id="l7.27" class="difflineplus">+ *   Mark Banner &lt;bugzilla@standard8.plus.com&gt;</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineplus">+ *</span>
<a href="#l7.29"></a><span id="l7.29" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l7.30"></a><span id="l7.30" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l7.34"></a><span id="l7.34" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l7.36"></a><span id="l7.36" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l7.37"></a><span id="l7.37" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l7.40"></a><span id="l7.40" class="difflineplus">+ *</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineplus">+</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l7.45"></a><span id="l7.45" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l7.46"></a><span id="l7.46" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l7.47"></a><span id="l7.47" class="difflineplus">+</span>
<a href="#l7.48"></a><span id="l7.48" class="difflineplus">+Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l7.49"></a><span id="l7.49" class="difflineplus">+</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineplus">+var LOG = null;</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+</span>
<a href="#l7.52"></a><span id="l7.52" class="difflineplus">+var Gloda = null;</span>
<a href="#l7.53"></a><span id="l7.53" class="difflineplus">+var GlodaUtils = null;</span>
<a href="#l7.54"></a><span id="l7.54" class="difflineplus">+var MultiSuffixTree = null;</span>
<a href="#l7.55"></a><span id="l7.55" class="difflineplus">+var TagNoun = null;</span>
<a href="#l7.56"></a><span id="l7.56" class="difflineplus">+var FreeTagNoun = null;</span>
<a href="#l7.57"></a><span id="l7.57" class="difflineplus">+</span>
<a href="#l7.58"></a><span id="l7.58" class="difflineplus">+function ResultRowSingle(aItem, aCriteriaType, aCriteria, aExplicitNounID) {</span>
<a href="#l7.59"></a><span id="l7.59" class="difflineplus">+  this.nounID = aExplicitNounID || aItem.NOUN_ID;</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineplus">+  this.nounDef = Gloda._nounIDToDef[this.nounID];</span>
<a href="#l7.61"></a><span id="l7.61" class="difflineplus">+  this.criteriaType = aCriteriaType;</span>
<a href="#l7.62"></a><span id="l7.62" class="difflineplus">+  this.criteria = aCriteria;</span>
<a href="#l7.63"></a><span id="l7.63" class="difflineplus">+  this.item = aItem;</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineplus">+}</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineplus">+ResultRowSingle.prototype = {</span>
<a href="#l7.66"></a><span id="l7.66" class="difflineplus">+  multi: false</span>
<a href="#l7.67"></a><span id="l7.67" class="difflineplus">+};</span>
<a href="#l7.68"></a><span id="l7.68" class="difflineplus">+</span>
<a href="#l7.69"></a><span id="l7.69" class="difflineplus">+function ResultRowMulti(aNounID, aCriteriaType, aCriteria, aQuery) {</span>
<a href="#l7.70"></a><span id="l7.70" class="difflineplus">+  this.nounID = aNounID;</span>
<a href="#l7.71"></a><span id="l7.71" class="difflineplus">+  this.nounDef = Gloda._nounIDToDef[aNounID];</span>
<a href="#l7.72"></a><span id="l7.72" class="difflineplus">+  this.criteriaType = aCriteriaType;</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineplus">+  this.criteria = aCriteria;</span>
<a href="#l7.74"></a><span id="l7.74" class="difflineplus">+  this.collection = aQuery.getCollection(this);</span>
<a href="#l7.75"></a><span id="l7.75" class="difflineplus">+  this.renderer = null;</span>
<a href="#l7.76"></a><span id="l7.76" class="difflineplus">+}</span>
<a href="#l7.77"></a><span id="l7.77" class="difflineplus">+ResultRowMulti.prototype = {</span>
<a href="#l7.78"></a><span id="l7.78" class="difflineplus">+  multi: true,</span>
<a href="#l7.79"></a><span id="l7.79" class="difflineplus">+  onItemsAdded: function(aItems) {</span>
<a href="#l7.80"></a><span id="l7.80" class="difflineplus">+    LOG.debug(&quot;RRM onItemsAdded: &quot; + aItems.length + &quot;: &quot; + aItems);</span>
<a href="#l7.81"></a><span id="l7.81" class="difflineplus">+    if (this.renderer) {</span>
<a href="#l7.82"></a><span id="l7.82" class="difflineplus">+      LOG.debug(&quot;RRM rendering...&quot;);</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineplus">+      for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l7.84"></a><span id="l7.84" class="difflineplus">+        LOG.debug(&quot;RRM ...&quot; + item);</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineplus">+        this.renderer.renderItem(item);</span>
<a href="#l7.86"></a><span id="l7.86" class="difflineplus">+      }</span>
<a href="#l7.87"></a><span id="l7.87" class="difflineplus">+    }</span>
<a href="#l7.88"></a><span id="l7.88" class="difflineplus">+  },</span>
<a href="#l7.89"></a><span id="l7.89" class="difflineplus">+  onItemsModified: function(aItems) {</span>
<a href="#l7.90"></a><span id="l7.90" class="difflineplus">+  },</span>
<a href="#l7.91"></a><span id="l7.91" class="difflineplus">+  onItemsRemoved: function(aItems) {</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineplus">+  },</span>
<a href="#l7.93"></a><span id="l7.93" class="difflineplus">+  onQueryCompleted: function() {</span>
<a href="#l7.94"></a><span id="l7.94" class="difflineplus">+  }</span>
<a href="#l7.95"></a><span id="l7.95" class="difflineplus">+}</span>
<a href="#l7.96"></a><span id="l7.96" class="difflineplus">+</span>
<a href="#l7.97"></a><span id="l7.97" class="difflineplus">+function nsAutoCompleteGlodaResult(aListener, aCompleter, aString) {</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineplus">+  this.listener = aListener;</span>
<a href="#l7.99"></a><span id="l7.99" class="difflineplus">+  this.completer = aCompleter;</span>
<a href="#l7.100"></a><span id="l7.100" class="difflineplus">+  this.searchString = aString;</span>
<a href="#l7.101"></a><span id="l7.101" class="difflineplus">+  this._results = [];</span>
<a href="#l7.102"></a><span id="l7.102" class="difflineplus">+  this._pendingCount = 0;</span>
<a href="#l7.103"></a><span id="l7.103" class="difflineplus">+  this._problem = false;</span>
<a href="#l7.104"></a><span id="l7.104" class="difflineplus">+  </span>
<a href="#l7.105"></a><span id="l7.105" class="difflineplus">+  this.wrappedJSObject = this;</span>
<a href="#l7.106"></a><span id="l7.106" class="difflineplus">+}</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineplus">+nsAutoCompleteGlodaResult.prototype = {</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineplus">+  getObjectAt: function(aIndex) {</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineplus">+    return this._results[aIndex];</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineplus">+  },</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineplus">+  markPending: function ACGR_markPending(aCompleter) {</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+    this._pendingCount++;</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineplus">+  },</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineplus">+  markCompleted: function ACGR_markCompleted(aCompleter) {</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineplus">+    if (--this._pendingCount == 0) {</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineplus">+      LOG.debug(&quot;Notifying completion.&quot;);</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineplus">+      this.listener.onSearchResult(this.completer, this);</span>
<a href="#l7.118"></a><span id="l7.118" class="difflineplus">+    }</span>
<a href="#l7.119"></a><span id="l7.119" class="difflineplus">+  },</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineplus">+  addRows: function ACGR_addRows(aRows) {</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+    if (!aRows.length)</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineplus">+      return;</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineplus">+    LOG.debug(&quot;Adding &quot; + aRows.length + &quot; rows (&quot; + this._pendingCount +</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineplus">+              &quot; jobs still pending)&quot;);</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineplus">+    this._results.push.apply(this._results, aRows); </span>
<a href="#l7.126"></a><span id="l7.126" class="difflineplus">+    this.listener.onSearchResult(this.completer, this);</span>
<a href="#l7.127"></a><span id="l7.127" class="difflineplus">+  },</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineplus">+  // ==== nsIAutoCompleteResult</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineplus">+  searchString: null,</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+  get searchResult() {</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineplus">+    if (this._problem)</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+      return Ci.nsIAutoCompleteResult.RESULT_FAILURE;</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineplus">+    if (this._results.length)</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineplus">+      return (!this._pendingCount) ? Ci.nsIAutoCompleteResult.RESULT_SUCCESS</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineplus">+                          : Ci.nsIAutoCompleteResult.RESULT_SUCCESS_ONGOING;</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+    else</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineplus">+      return (!this._pendingCount) ? Ci.nsIAutoCompleteResult.RESULT_NOMATCH</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+                          : Ci.nsIAutoCompleteResult.RESULT_NOMATCH_ONGOING;</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+  },</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+  defaultIndex: -1,</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+  errorDescription: null,</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+  get matchCount() {</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineplus">+    return (this._results === null) ? 0 : this._results.length;</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineplus">+  },</span>
<a href="#l7.145"></a><span id="l7.145" class="difflineplus">+  // this is the lower text, (shows the url in firefox)</span>
<a href="#l7.146"></a><span id="l7.146" class="difflineplus">+  // we try and show the contact's name here.</span>
<a href="#l7.147"></a><span id="l7.147" class="difflineplus">+  getValueAt: function(aIndex) {</span>
<a href="#l7.148"></a><span id="l7.148" class="difflineplus">+    let thing = this._results[aIndex];</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineplus">+    return thing.name || thing.value || thing.subject;</span>
<a href="#l7.150"></a><span id="l7.150" class="difflineplus">+  },</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+  // rich uses this to be the &quot;title&quot;.  it is the upper text</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineplus">+  // we try and show the identity here.</span>
<a href="#l7.153"></a><span id="l7.153" class="difflineplus">+  getCommentAt: function(aIndex) {</span>
<a href="#l7.154"></a><span id="l7.154" class="difflineplus">+    let thing = this._results[aIndex];</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineplus">+    if (thing.value) // identity</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineplus">+      return thing.contact.name;</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineplus">+    else</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineplus">+      return thing.name || thing.subject;</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineplus">+  },</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineplus">+  // rich uses this to be the &quot;type&quot;</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+  getStyleAt: function(aIndex) {</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+    let row = this._results[aIndex];</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+    if (row.multi)</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineplus">+      return &quot;gloda-multi&quot;;</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineplus">+    else</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineplus">+      return &quot;gloda-single-&quot; + row.nounDef.name;</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+  },</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+  // rich uses this to be the icon</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+  getImageAt: function(aIndex) {</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+    let thing = this._results[aIndex];</span>
<a href="#l7.171"></a><span id="l7.171" class="difflineplus">+    if (!thing.value)</span>
<a href="#l7.172"></a><span id="l7.172" class="difflineplus">+      return null;</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineplus">+</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineplus">+    let md5hash = GlodaUtils.md5HashString(thing.value);</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineplus">+    let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash +</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+                                &quot;?d=identicon&amp;s=32&amp;r=g&quot;;</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+    return gravURL;</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+  },</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineplus">+  removeValueAt: function() {},</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+</span>
<a href="#l7.181"></a><span id="l7.181" class="difflineplus">+  _stop: function() {</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineplus">+  },</span>
<a href="#l7.183"></a><span id="l7.183" class="difflineplus">+};</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineplus">+</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineplus">+const MAX_POPULAR_CONTACTS = 200;</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineplus">+</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+/**</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineplus">+ * Complete contacts/identities based on name/email.  Instant phase is based on</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineplus">+ *  a suffix-tree built of popular contacts/identities.  Delayed phase relies</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineplus">+ *  on a LIKE search of all known contacts.</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineplus">+ */</span>
<a href="#l7.192"></a><span id="l7.192" class="difflineplus">+function ContactIdentityCompleter() {</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineplus">+  // get all the contacts</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineplus">+  let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l7.195"></a><span id="l7.195" class="difflineplus">+  contactQuery.orderBy(&quot;-popularity&quot;).limit(MAX_POPULAR_CONTACTS);</span>
<a href="#l7.196"></a><span id="l7.196" class="difflineplus">+  this.contactCollection = contactQuery.getCollection(this, null);</span>
<a href="#l7.197"></a><span id="l7.197" class="difflineplus">+}</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineplus">+ContactIdentityCompleter.prototype = {</span>
<a href="#l7.199"></a><span id="l7.199" class="difflineplus">+  _popularitySorter: function(a, b){ return b.popularity - a.popularity; },</span>
<a href="#l7.200"></a><span id="l7.200" class="difflineplus">+  complete: function ContactIdentityCompleter_complete(aResult, aString) {</span>
<a href="#l7.201"></a><span id="l7.201" class="difflineplus">+    if (aString.length &lt; 3)</span>
<a href="#l7.202"></a><span id="l7.202" class="difflineplus">+      return false;</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineplus">+</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineplus">+    let matches;</span>
<a href="#l7.205"></a><span id="l7.205" class="difflineplus">+    if (this.suffixTree) {</span>
<a href="#l7.206"></a><span id="l7.206" class="difflineplus">+      matches = this.suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l7.207"></a><span id="l7.207" class="difflineplus">+      LOG.debug(&quot;CIC: Suffix Tree found &quot; + matches.length + &quot; matches.&quot;)</span>
<a href="#l7.208"></a><span id="l7.208" class="difflineplus">+    }</span>
<a href="#l7.209"></a><span id="l7.209" class="difflineplus">+    else</span>
<a href="#l7.210"></a><span id="l7.210" class="difflineplus">+      matches = [];</span>
<a href="#l7.211"></a><span id="l7.211" class="difflineplus">+</span>
<a href="#l7.212"></a><span id="l7.212" class="difflineplus">+    // let's filter out duplicates due to identity/contact double-hits by</span>
<a href="#l7.213"></a><span id="l7.213" class="difflineplus">+    //  establishing a map based on the contact id for these guys.</span>
<a href="#l7.214"></a><span id="l7.214" class="difflineplus">+    // let's also favor identities as we do it, because that gets us the</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineplus">+    //  most accurate gravat, potentially</span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+    let contactToThing = {};</span>
<a href="#l7.217"></a><span id="l7.217" class="difflineplus">+    for (let iMatch = 0; iMatch &lt; matches.length; iMatch++) {</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineplus">+      let thing = matches[iMatch];</span>
<a href="#l7.219"></a><span id="l7.219" class="difflineplus">+      if (thing.NOUN_ID == Gloda.NOUN_CONTACT &amp;&amp; !(thing.id in contactToThing))</span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+        contactToThing[thing.id] = thing;</span>
<a href="#l7.221"></a><span id="l7.221" class="difflineplus">+      else if (thing.NOUN_ID == Gloda.NOUN_IDENTITY)</span>
<a href="#l7.222"></a><span id="l7.222" class="difflineplus">+        contactToThing[thing.contactID] = thing;</span>
<a href="#l7.223"></a><span id="l7.223" class="difflineplus">+    }</span>
<a href="#l7.224"></a><span id="l7.224" class="difflineplus">+    // and since we can now map from contacts down to identities, map contacts</span>
<a href="#l7.225"></a><span id="l7.225" class="difflineplus">+    //  to the first identity for them that we find...</span>
<a href="#l7.226"></a><span id="l7.226" class="difflineplus">+    matches = [val.NOUN_ID == Gloda.NOUN_IDENTITY ? val : val.identities[0]</span>
<a href="#l7.227"></a><span id="l7.227" class="difflineplus">+               for each ([iVal, val] in Iterator(contactToThing))];</span>
<a href="#l7.228"></a><span id="l7.228" class="difflineplus">+</span>
<a href="#l7.229"></a><span id="l7.229" class="difflineplus">+    let rows = [new ResultRowSingle(match, &quot;text&quot;, aResult.searchString)</span>
<a href="#l7.230"></a><span id="l7.230" class="difflineplus">+                for each ([iMatch, match] in Iterator(matches))];</span>
<a href="#l7.231"></a><span id="l7.231" class="difflineplus">+    aResult.addRows(rows);</span>
<a href="#l7.232"></a><span id="l7.232" class="difflineplus">+</span>
<a href="#l7.233"></a><span id="l7.233" class="difflineplus">+    // - match against database contacts / identities</span>
<a href="#l7.234"></a><span id="l7.234" class="difflineplus">+    let pending = {contactToThing: contactToThing, pendingCount: 2};</span>
<a href="#l7.235"></a><span id="l7.235" class="difflineplus">+    </span>
<a href="#l7.236"></a><span id="l7.236" class="difflineplus">+    LOG.debug(&quot;CIC: issuing contact LIKE query&quot;);</span>
<a href="#l7.237"></a><span id="l7.237" class="difflineplus">+    let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l7.238"></a><span id="l7.238" class="difflineplus">+    contactQuery.nameLike(contactQuery.WILD, aString, contactQuery.WILD);</span>
<a href="#l7.239"></a><span id="l7.239" class="difflineplus">+    pending.contactColl = contactQuery.getCollection(this, aResult);</span>
<a href="#l7.240"></a><span id="l7.240" class="difflineplus">+</span>
<a href="#l7.241"></a><span id="l7.241" class="difflineplus">+    LOG.debug(&quot;CIC: issuing identity LIKE query&quot;);</span>
<a href="#l7.242"></a><span id="l7.242" class="difflineplus">+    let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l7.243"></a><span id="l7.243" class="difflineplus">+    identityQuery.kind(&quot;email&quot;).valueLike(identityQuery.WILD, aString,</span>
<a href="#l7.244"></a><span id="l7.244" class="difflineplus">+        identityQuery.WILD);</span>
<a href="#l7.245"></a><span id="l7.245" class="difflineplus">+    pending.identityColl = identityQuery.getCollection(this, aResult);</span>
<a href="#l7.246"></a><span id="l7.246" class="difflineplus">+    </span>
<a href="#l7.247"></a><span id="l7.247" class="difflineplus">+    aResult._contactCompleterPending = pending;</span>
<a href="#l7.248"></a><span id="l7.248" class="difflineplus">+</span>
<a href="#l7.249"></a><span id="l7.249" class="difflineplus">+    return true;</span>
<a href="#l7.250"></a><span id="l7.250" class="difflineplus">+  },</span>
<a href="#l7.251"></a><span id="l7.251" class="difflineplus">+  onItemsAdded: function(aItems, aCollection) {</span>
<a href="#l7.252"></a><span id="l7.252" class="difflineplus">+  },</span>
<a href="#l7.253"></a><span id="l7.253" class="difflineplus">+  onItemsModified: function(aItems, aCollection) {</span>
<a href="#l7.254"></a><span id="l7.254" class="difflineplus">+  },</span>
<a href="#l7.255"></a><span id="l7.255" class="difflineplus">+  onItemsRemoved: function(aItems, aCollection) {</span>
<a href="#l7.256"></a><span id="l7.256" class="difflineplus">+  },</span>
<a href="#l7.257"></a><span id="l7.257" class="difflineplus">+  onQueryCompleted: function(aCollection) {</span>
<a href="#l7.258"></a><span id="l7.258" class="difflineplus">+    // handle the initial setup case...</span>
<a href="#l7.259"></a><span id="l7.259" class="difflineplus">+    if (aCollection.data == null) {</span>
<a href="#l7.260"></a><span id="l7.260" class="difflineplus">+      LOG.debug(&quot;CIC: Initial query found &quot; + aCollection.items.length);</span>
<a href="#l7.261"></a><span id="l7.261" class="difflineplus">+      // cheat and explicitly add our own contact...</span>
<a href="#l7.262"></a><span id="l7.262" class="difflineplus">+      if (!(Gloda.myContact.id in this.contactCollection._idMap))</span>
<a href="#l7.263"></a><span id="l7.263" class="difflineplus">+        this.contactCollection._onItemsAdded([Gloda.myContact]);</span>
<a href="#l7.264"></a><span id="l7.264" class="difflineplus">+        </span>
<a href="#l7.265"></a><span id="l7.265" class="difflineplus">+      // the set of identities owned by the contacts is automatically loaded as part</span>
<a href="#l7.266"></a><span id="l7.266" class="difflineplus">+      //  of the contact loading...</span>
<a href="#l7.267"></a><span id="l7.267" class="difflineplus">+      // (but only if we actually have any contacts)</span>
<a href="#l7.268"></a><span id="l7.268" class="difflineplus">+      this.identityCollection =</span>
<a href="#l7.269"></a><span id="l7.269" class="difflineplus">+        this.contactCollection.subCollections[Gloda.NOUN_IDENTITY];</span>
<a href="#l7.270"></a><span id="l7.270" class="difflineplus">+</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineplus">+      let contactNames = [(c.name.replace(&quot; &quot;, &quot;&quot;).toLowerCase() || &quot;x&quot;) for each</span>
<a href="#l7.272"></a><span id="l7.272" class="difflineplus">+                          ([, c] in Iterator(this.contactCollection.items))];</span>
<a href="#l7.273"></a><span id="l7.273" class="difflineplus">+      // if we had no contacts, we will have no identity collection!</span>
<a href="#l7.274"></a><span id="l7.274" class="difflineplus">+      let identityMails;</span>
<a href="#l7.275"></a><span id="l7.275" class="difflineplus">+      if (this.identityCollection)</span>
<a href="#l7.276"></a><span id="l7.276" class="difflineplus">+        identityMails = [i.value.toLowerCase() for each</span>
<a href="#l7.277"></a><span id="l7.277" class="difflineplus">+                         ([, i] in Iterator(this.identityCollection.items))];</span>
<a href="#l7.278"></a><span id="l7.278" class="difflineplus">+</span>
<a href="#l7.279"></a><span id="l7.279" class="difflineplus">+      this.suffixTree = new MultiSuffixTree(contactNames.concat(identityMails),</span>
<a href="#l7.280"></a><span id="l7.280" class="difflineplus">+        this.contactCollection.items.concat(this.identityCollection.items));</span>
<a href="#l7.281"></a><span id="l7.281" class="difflineplus">+      </span>
<a href="#l7.282"></a><span id="l7.282" class="difflineplus">+      return;</span>
<a href="#l7.283"></a><span id="l7.283" class="difflineplus">+    }</span>
<a href="#l7.284"></a><span id="l7.284" class="difflineplus">+    </span>
<a href="#l7.285"></a><span id="l7.285" class="difflineplus">+    LOG.debug(&quot;CIC: LIKE query found &quot; + aCollection.items.length);</span>
<a href="#l7.286"></a><span id="l7.286" class="difflineplus">+    </span>
<a href="#l7.287"></a><span id="l7.287" class="difflineplus">+    // handle the completion case</span>
<a href="#l7.288"></a><span id="l7.288" class="difflineplus">+    let result = aCollection.data;</span>
<a href="#l7.289"></a><span id="l7.289" class="difflineplus">+    let pending = result._contactCompleterPending;</span>
<a href="#l7.290"></a><span id="l7.290" class="difflineplus">+    </span>
<a href="#l7.291"></a><span id="l7.291" class="difflineplus">+    if (--pending.pendingCount == 0) {</span>
<a href="#l7.292"></a><span id="l7.292" class="difflineplus">+      let possibleDudes = [];</span>
<a href="#l7.293"></a><span id="l7.293" class="difflineplus">+      </span>
<a href="#l7.294"></a><span id="l7.294" class="difflineplus">+      let contactToThing = pending.contactToThing;</span>
<a href="#l7.295"></a><span id="l7.295" class="difflineplus">+      </span>
<a href="#l7.296"></a><span id="l7.296" class="difflineplus">+      let items;</span>
<a href="#l7.297"></a><span id="l7.297" class="difflineplus">+      </span>
<a href="#l7.298"></a><span id="l7.298" class="difflineplus">+      // check identities first because they are better than contacts in terms</span>
<a href="#l7.299"></a><span id="l7.299" class="difflineplus">+      //  of display</span>
<a href="#l7.300"></a><span id="l7.300" class="difflineplus">+      items = pending.identityColl.items;</span>
<a href="#l7.301"></a><span id="l7.301" class="difflineplus">+      for (let iIdentity = 0; iIdentity &lt; items.length; iIdentity++){</span>
<a href="#l7.302"></a><span id="l7.302" class="difflineplus">+        let identity = items[iIdentity];</span>
<a href="#l7.303"></a><span id="l7.303" class="difflineplus">+        if (!(identity.contactID in contactToThing)) {</span>
<a href="#l7.304"></a><span id="l7.304" class="difflineplus">+          contactToThing[identity.contactID] = identity;</span>
<a href="#l7.305"></a><span id="l7.305" class="difflineplus">+          possibleDudes.push(identity);</span>
<a href="#l7.306"></a><span id="l7.306" class="difflineplus">+          // augment the identity with its contact's popularity</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineplus">+          identity.popularity = identity.contact.popularity;</span>
<a href="#l7.308"></a><span id="l7.308" class="difflineplus">+        }</span>
<a href="#l7.309"></a><span id="l7.309" class="difflineplus">+      }</span>
<a href="#l7.310"></a><span id="l7.310" class="difflineplus">+      items = pending.contactColl.items;</span>
<a href="#l7.311"></a><span id="l7.311" class="difflineplus">+      for (let iContact = 0; iContact &lt; items.length; iContact++) {</span>
<a href="#l7.312"></a><span id="l7.312" class="difflineplus">+        let contact = items[iContact];</span>
<a href="#l7.313"></a><span id="l7.313" class="difflineplus">+        if (!(contact.id in contactToThing)) {</span>
<a href="#l7.314"></a><span id="l7.314" class="difflineplus">+          contactToThing[contact.id] = contact;</span>
<a href="#l7.315"></a><span id="l7.315" class="difflineplus">+          possibleDudes.push(contact.identities[0]);</span>
<a href="#l7.316"></a><span id="l7.316" class="difflineplus">+        }</span>
<a href="#l7.317"></a><span id="l7.317" class="difflineplus">+      }</span>
<a href="#l7.318"></a><span id="l7.318" class="difflineplus">+      </span>
<a href="#l7.319"></a><span id="l7.319" class="difflineplus">+      // sort in order of descending popularity</span>
<a href="#l7.320"></a><span id="l7.320" class="difflineplus">+      possibleDudes.sort(this._popularitySorter);</span>
<a href="#l7.321"></a><span id="l7.321" class="difflineplus">+      let rows = [new ResultRowSingle(dude, &quot;text&quot;, result.searchString)</span>
<a href="#l7.322"></a><span id="l7.322" class="difflineplus">+                  for each ([iDude, dude] in Iterator(possibleDudes))];</span>
<a href="#l7.323"></a><span id="l7.323" class="difflineplus">+      result.addRows(rows);</span>
<a href="#l7.324"></a><span id="l7.324" class="difflineplus">+      result.markCompleted(this);</span>
<a href="#l7.325"></a><span id="l7.325" class="difflineplus">+      </span>
<a href="#l7.326"></a><span id="l7.326" class="difflineplus">+      // the collections no longer care about the result, make it clear.</span>
<a href="#l7.327"></a><span id="l7.327" class="difflineplus">+      delete pending.identityColl.data;</span>
<a href="#l7.328"></a><span id="l7.328" class="difflineplus">+      delete pending.contactColl.data;</span>
<a href="#l7.329"></a><span id="l7.329" class="difflineplus">+      // the result object no longer needs us or our data</span>
<a href="#l7.330"></a><span id="l7.330" class="difflineplus">+      delete result._contactCompleterPending;</span>
<a href="#l7.331"></a><span id="l7.331" class="difflineplus">+    }</span>
<a href="#l7.332"></a><span id="l7.332" class="difflineplus">+    else {</span>
<a href="#l7.333"></a><span id="l7.333" class="difflineplus">+      LOG.debug(&quot;ignoring... pending is still: &quot; + pending.pendingCount);</span>
<a href="#l7.334"></a><span id="l7.334" class="difflineplus">+    }</span>
<a href="#l7.335"></a><span id="l7.335" class="difflineplus">+  }</span>
<a href="#l7.336"></a><span id="l7.336" class="difflineplus">+};</span>
<a href="#l7.337"></a><span id="l7.337" class="difflineplus">+</span>
<a href="#l7.338"></a><span id="l7.338" class="difflineplus">+/**</span>
<a href="#l7.339"></a><span id="l7.339" class="difflineplus">+ * Complete tags that are used on contacts.</span>
<a href="#l7.340"></a><span id="l7.340" class="difflineplus">+ */</span>
<a href="#l7.341"></a><span id="l7.341" class="difflineplus">+function ContactTagCompleter() {</span>
<a href="#l7.342"></a><span id="l7.342" class="difflineplus">+  FreeTagNoun.populateKnownFreeTags();</span>
<a href="#l7.343"></a><span id="l7.343" class="difflineplus">+  this._buildSuffixTree();</span>
<a href="#l7.344"></a><span id="l7.344" class="difflineplus">+  FreeTagNoun.addListener(this);</span>
<a href="#l7.345"></a><span id="l7.345" class="difflineplus">+}</span>
<a href="#l7.346"></a><span id="l7.346" class="difflineplus">+ContactTagCompleter.prototype = {</span>
<a href="#l7.347"></a><span id="l7.347" class="difflineplus">+  _buildSuffixTree: function() {</span>
<a href="#l7.348"></a><span id="l7.348" class="difflineplus">+    let tagNames = [], tags = [];</span>
<a href="#l7.349"></a><span id="l7.349" class="difflineplus">+    for (let [tagName, tag] in Iterator(FreeTagNoun.knownFreeTags)) {</span>
<a href="#l7.350"></a><span id="l7.350" class="difflineplus">+      tagNames.push(tagName.toLowerCase());</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineplus">+      tags.push(tag);</span>
<a href="#l7.352"></a><span id="l7.352" class="difflineplus">+      LOG.debug(&quot;contact tag: &quot; + tagName);</span>
<a href="#l7.353"></a><span id="l7.353" class="difflineplus">+    }</span>
<a href="#l7.354"></a><span id="l7.354" class="difflineplus">+    this._suffixTree = new MultiSuffixTree(tagNames, tags);</span>
<a href="#l7.355"></a><span id="l7.355" class="difflineplus">+    this._suffixTreeDirty = false;</span>
<a href="#l7.356"></a><span id="l7.356" class="difflineplus">+  },</span>
<a href="#l7.357"></a><span id="l7.357" class="difflineplus">+  onFreeTagAdded: function(aTag) {</span>
<a href="#l7.358"></a><span id="l7.358" class="difflineplus">+    this._suffixTreeDirty = true;</span>
<a href="#l7.359"></a><span id="l7.359" class="difflineplus">+  },</span>
<a href="#l7.360"></a><span id="l7.360" class="difflineplus">+  complete: function ContactTagCompleter_complete(aResult, aString) {</span>
<a href="#l7.361"></a><span id="l7.361" class="difflineplus">+    // now is not the best time to do this; have onFreeTagAdded use a timer.</span>
<a href="#l7.362"></a><span id="l7.362" class="difflineplus">+    if (this._suffixTreeDirty)</span>
<a href="#l7.363"></a><span id="l7.363" class="difflineplus">+      this._buildSuffixTree();</span>
<a href="#l7.364"></a><span id="l7.364" class="difflineplus">+    </span>
<a href="#l7.365"></a><span id="l7.365" class="difflineplus">+    if (aString.length &lt; 2)</span>
<a href="#l7.366"></a><span id="l7.366" class="difflineplus">+      return false; // no async mechanism that will add new rows</span>
<a href="#l7.367"></a><span id="l7.367" class="difflineplus">+    </span>
<a href="#l7.368"></a><span id="l7.368" class="difflineplus">+    LOG.debug(&quot;Completing on contact tags...&quot;);</span>
<a href="#l7.369"></a><span id="l7.369" class="difflineplus">+    </span>
<a href="#l7.370"></a><span id="l7.370" class="difflineplus">+    tags = this._suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l7.371"></a><span id="l7.371" class="difflineplus">+    let rows = [];</span>
<a href="#l7.372"></a><span id="l7.372" class="difflineplus">+    for each (let [iTag, tag] in Iterator(tags)) {</span>
<a href="#l7.373"></a><span id="l7.373" class="difflineplus">+      let query = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l7.374"></a><span id="l7.374" class="difflineplus">+      LOG.debug(&quot;  checking for contact tag: &quot; + tag.name);</span>
<a href="#l7.375"></a><span id="l7.375" class="difflineplus">+      query.freeTags(tag);</span>
<a href="#l7.376"></a><span id="l7.376" class="difflineplus">+      let resRow = new ResultRowMulti(Gloda.NOUN_CONTACT, &quot;tag&quot;, tag.name,</span>
<a href="#l7.377"></a><span id="l7.377" class="difflineplus">+                                      query);</span>
<a href="#l7.378"></a><span id="l7.378" class="difflineplus">+      rows.push(resRow);</span>
<a href="#l7.379"></a><span id="l7.379" class="difflineplus">+    }</span>
<a href="#l7.380"></a><span id="l7.380" class="difflineplus">+    aResult.addRows(rows);</span>
<a href="#l7.381"></a><span id="l7.381" class="difflineplus">+    </span>
<a href="#l7.382"></a><span id="l7.382" class="difflineplus">+    return false; // no async mechanism that will add new rows</span>
<a href="#l7.383"></a><span id="l7.383" class="difflineplus">+  }</span>
<a href="#l7.384"></a><span id="l7.384" class="difflineplus">+};</span>
<a href="#l7.385"></a><span id="l7.385" class="difflineplus">+</span>
<a href="#l7.386"></a><span id="l7.386" class="difflineplus">+/**</span>
<a href="#l7.387"></a><span id="l7.387" class="difflineplus">+ * Complete tags that are used on messages</span>
<a href="#l7.388"></a><span id="l7.388" class="difflineplus">+ */</span>
<a href="#l7.389"></a><span id="l7.389" class="difflineplus">+function MessageTagCompleter() {</span>
<a href="#l7.390"></a><span id="l7.390" class="difflineplus">+  this._buildSuffixTree();</span>
<a href="#l7.391"></a><span id="l7.391" class="difflineplus">+}</span>
<a href="#l7.392"></a><span id="l7.392" class="difflineplus">+MessageTagCompleter.prototype = {</span>
<a href="#l7.393"></a><span id="l7.393" class="difflineplus">+  _buildSuffixTree: function MessageTagCompleter__buildSufficeTree() {</span>
<a href="#l7.394"></a><span id="l7.394" class="difflineplus">+    let tagNames = [], tags = [];</span>
<a href="#l7.395"></a><span id="l7.395" class="difflineplus">+    let tagArray = TagNoun.getAllTags();</span>
<a href="#l7.396"></a><span id="l7.396" class="difflineplus">+    for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l7.397"></a><span id="l7.397" class="difflineplus">+      let tag = tagArray[iTag];</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineplus">+      tagNames.push(tag.tag.toLowerCase());</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineplus">+      tags.push(tag);</span>
<a href="#l7.400"></a><span id="l7.400" class="difflineplus">+      LOG.debug(&quot;message tag: &quot; + tag.tag);</span>
<a href="#l7.401"></a><span id="l7.401" class="difflineplus">+    }</span>
<a href="#l7.402"></a><span id="l7.402" class="difflineplus">+    this._suffixTree = new MultiSuffixTree(tagNames, tags);</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineplus">+    this._suffixTreeDirty = false;</span>
<a href="#l7.404"></a><span id="l7.404" class="difflineplus">+  },</span>
<a href="#l7.405"></a><span id="l7.405" class="difflineplus">+  complete: function MessageTagCompleter_complete(aResult, aString) {</span>
<a href="#l7.406"></a><span id="l7.406" class="difflineplus">+    if (aString.length &lt; 2)</span>
<a href="#l7.407"></a><span id="l7.407" class="difflineplus">+      return false;</span>
<a href="#l7.408"></a><span id="l7.408" class="difflineplus">+    </span>
<a href="#l7.409"></a><span id="l7.409" class="difflineplus">+    LOG.debug(&quot;Completing on message tags...&quot;);</span>
<a href="#l7.410"></a><span id="l7.410" class="difflineplus">+    </span>
<a href="#l7.411"></a><span id="l7.411" class="difflineplus">+    tags = this._suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l7.412"></a><span id="l7.412" class="difflineplus">+    let rows = [];</span>
<a href="#l7.413"></a><span id="l7.413" class="difflineplus">+    for each (let [, tag] in Iterator(tags)) {</span>
<a href="#l7.414"></a><span id="l7.414" class="difflineplus">+      LOG.debug(&quot; found message tag: &quot; + tag.tag);</span>
<a href="#l7.415"></a><span id="l7.415" class="difflineplus">+      let resRow = new ResultRowSingle(tag, &quot;tag&quot;, tag.tag, TagNoun.id);</span>
<a href="#l7.416"></a><span id="l7.416" class="difflineplus">+      rows.push(resRow);</span>
<a href="#l7.417"></a><span id="l7.417" class="difflineplus">+    }</span>
<a href="#l7.418"></a><span id="l7.418" class="difflineplus">+    aResult.addRows(rows);</span>
<a href="#l7.419"></a><span id="l7.419" class="difflineplus">+    </span>
<a href="#l7.420"></a><span id="l7.420" class="difflineplus">+    return false; // no async mechanism that will add new rows</span>
<a href="#l7.421"></a><span id="l7.421" class="difflineplus">+  }</span>
<a href="#l7.422"></a><span id="l7.422" class="difflineplus">+};</span>
<a href="#l7.423"></a><span id="l7.423" class="difflineplus">+</span>
<a href="#l7.424"></a><span id="l7.424" class="difflineplus">+function nsAutoCompleteGloda() {</span>
<a href="#l7.425"></a><span id="l7.425" class="difflineplus">+  this.wrappedJSObject = this;</span>
<a href="#l7.426"></a><span id="l7.426" class="difflineplus">+</span>
<a href="#l7.427"></a><span id="l7.427" class="difflineplus">+  // set up our awesome globals!</span>
<a href="#l7.428"></a><span id="l7.428" class="difflineplus">+  if (Gloda === null) {</span>
<a href="#l7.429"></a><span id="l7.429" class="difflineplus">+    let loadNS = {};</span>
<a href="#l7.430"></a><span id="l7.430" class="difflineplus">+</span>
<a href="#l7.431"></a><span id="l7.431" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/public.js&quot;, loadNS);</span>
<a href="#l7.432"></a><span id="l7.432" class="difflineplus">+    Gloda = loadNS.Gloda;</span>
<a href="#l7.433"></a><span id="l7.433" class="difflineplus">+</span>
<a href="#l7.434"></a><span id="l7.434" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/utils.js&quot;, loadNS);</span>
<a href="#l7.435"></a><span id="l7.435" class="difflineplus">+    GlodaUtils = loadNS.GlodaUtils;</span>
<a href="#l7.436"></a><span id="l7.436" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/suffixtree.js&quot;, loadNS);</span>
<a href="#l7.437"></a><span id="l7.437" class="difflineplus">+    MultiSuffixTree = loadNS.MultiSuffixTree;</span>
<a href="#l7.438"></a><span id="l7.438" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/noun_tag.js&quot;, loadNS);</span>
<a href="#l7.439"></a><span id="l7.439" class="difflineplus">+    TagNoun = loadNS.TagNoun;</span>
<a href="#l7.440"></a><span id="l7.440" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/noun_freetag.js&quot;, loadNS);</span>
<a href="#l7.441"></a><span id="l7.441" class="difflineplus">+    FreeTagNoun = loadNS.FreeTagNoun;</span>
<a href="#l7.442"></a><span id="l7.442" class="difflineplus">+</span>
<a href="#l7.443"></a><span id="l7.443" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;, loadNS);</span>
<a href="#l7.444"></a><span id="l7.444" class="difflineplus">+    LOG = loadNS[&quot;Log4Moz&quot;].Service.getLogger(&quot;gloda.autocomp&quot;);</span>
<a href="#l7.445"></a><span id="l7.445" class="difflineplus">+  }</span>
<a href="#l7.446"></a><span id="l7.446" class="difflineplus">+</span>
<a href="#l7.447"></a><span id="l7.447" class="difflineplus">+  LOG.debug(&quot;initializing completers&quot;);</span>
<a href="#l7.448"></a><span id="l7.448" class="difflineplus">+</span>
<a href="#l7.449"></a><span id="l7.449" class="difflineplus">+  this.completers = [];</span>
<a href="#l7.450"></a><span id="l7.450" class="difflineplus">+  </span>
<a href="#l7.451"></a><span id="l7.451" class="difflineplus">+  this.curResult = null;</span>
<a href="#l7.452"></a><span id="l7.452" class="difflineplus">+</span>
<a href="#l7.453"></a><span id="l7.453" class="difflineplus">+dump(&quot;init CIC\n&quot;);</span>
<a href="#l7.454"></a><span id="l7.454" class="difflineplus">+  LOG.debug(&quot;initializing ContactIdentityCompleter&quot;);</span>
<a href="#l7.455"></a><span id="l7.455" class="difflineplus">+  try {</span>
<a href="#l7.456"></a><span id="l7.456" class="difflineplus">+  this.completers.push(new ContactIdentityCompleter());</span>
<a href="#l7.457"></a><span id="l7.457" class="difflineplus">+  } catch (ex) {dump(&quot;CICEX: &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);}</span>
<a href="#l7.458"></a><span id="l7.458" class="difflineplus">+dump(&quot;init CTC\n&quot;);</span>
<a href="#l7.459"></a><span id="l7.459" class="difflineplus">+  LOG.debug(&quot;initializing ContactTagCompleter&quot;);</span>
<a href="#l7.460"></a><span id="l7.460" class="difflineplus">+  this.completers.push(new ContactTagCompleter());</span>
<a href="#l7.461"></a><span id="l7.461" class="difflineplus">+dump(&quot;init MTC\n&quot;);</span>
<a href="#l7.462"></a><span id="l7.462" class="difflineplus">+  LOG.debug(&quot;initializing MessageTagCompleter&quot;);</span>
<a href="#l7.463"></a><span id="l7.463" class="difflineplus">+  try {</span>
<a href="#l7.464"></a><span id="l7.464" class="difflineplus">+  this.completers.push(new MessageTagCompleter());</span>
<a href="#l7.465"></a><span id="l7.465" class="difflineplus">+  } catch (ex) {dump(&quot;MTCEX: &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);}</span>
<a href="#l7.466"></a><span id="l7.466" class="difflineplus">+  </span>
<a href="#l7.467"></a><span id="l7.467" class="difflineplus">+  LOG.debug(&quot;initialized completers&quot;);</span>
<a href="#l7.468"></a><span id="l7.468" class="difflineplus">+}</span>
<a href="#l7.469"></a><span id="l7.469" class="difflineplus">+</span>
<a href="#l7.470"></a><span id="l7.470" class="difflineplus">+nsAutoCompleteGloda.prototype = {</span>
<a href="#l7.471"></a><span id="l7.471" class="difflineplus">+  classDescription: &quot;AutoCompleteGloda&quot;,</span>
<a href="#l7.472"></a><span id="l7.472" class="difflineplus">+  contractID: &quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;,</span>
<a href="#l7.473"></a><span id="l7.473" class="difflineplus">+  classID: Components.ID(&quot;{3bbe4d77-3f70-4252-9500-bc00c26f476c}&quot;),</span>
<a href="#l7.474"></a><span id="l7.474" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([</span>
<a href="#l7.475"></a><span id="l7.475" class="difflineplus">+      Components.interfaces.nsIAutoCompleteSearch]),</span>
<a href="#l7.476"></a><span id="l7.476" class="difflineplus">+</span>
<a href="#l7.477"></a><span id="l7.477" class="difflineplus">+  startSearch: function(aString, aParam, aResult, aListener) {</span>
<a href="#l7.478"></a><span id="l7.478" class="difflineplus">+    let result = new nsAutoCompleteGlodaResult(aListener, this, aString);</span>
<a href="#l7.479"></a><span id="l7.479" class="difflineplus">+    // save this for hacky access to the search.  I somewhat suspect we simply</span>
<a href="#l7.480"></a><span id="l7.480" class="difflineplus">+    //  should not be using the formal autocomplete mechanism at all.</span>
<a href="#l7.481"></a><span id="l7.481" class="difflineplus">+    this.curResult = result;</span>
<a href="#l7.482"></a><span id="l7.482" class="difflineplus">+    </span>
<a href="#l7.483"></a><span id="l7.483" class="difflineplus">+    for each (let [iCompleter, completer] in Iterator(this.completers)) {</span>
<a href="#l7.484"></a><span id="l7.484" class="difflineplus">+      // they will return true if they have something pending.</span>
<a href="#l7.485"></a><span id="l7.485" class="difflineplus">+      if (completer.complete(result, aString))</span>
<a href="#l7.486"></a><span id="l7.486" class="difflineplus">+        result.markPending(completer);</span>
<a href="#l7.487"></a><span id="l7.487" class="difflineplus">+    }</span>
<a href="#l7.488"></a><span id="l7.488" class="difflineplus">+    </span>
<a href="#l7.489"></a><span id="l7.489" class="difflineplus">+    aListener.onSearchResult(this, result);</span>
<a href="#l7.490"></a><span id="l7.490" class="difflineplus">+  },</span>
<a href="#l7.491"></a><span id="l7.491" class="difflineplus">+</span>
<a href="#l7.492"></a><span id="l7.492" class="difflineplus">+  stopSearch: function() {</span>
<a href="#l7.493"></a><span id="l7.493" class="difflineplus">+  },</span>
<a href="#l7.494"></a><span id="l7.494" class="difflineplus">+};</span>
<a href="#l7.495"></a><span id="l7.495" class="difflineplus">+</span>
<a href="#l7.496"></a><span id="l7.496" class="difflineplus">+function NSGetModule(compMgr, fileSpec) {</span>
<a href="#l7.497"></a><span id="l7.497" class="difflineplus">+  return XPCOMUtils.generateModule([nsAutoCompleteGloda]);</span>
<a href="#l7.498"></a><span id="l7.498" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1">new file mode 100644</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineminus">--- /dev/null</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineplus">+++ b/mailnews/db/gloda/components/jsmimeemitter.js</span>
<a href="#l8.4"></a><span id="l8.4" class="difflineat">@@ -0,0 +1,456 @@</span>
<a href="#l8.5"></a><span id="l8.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l8.6"></a><span id="l8.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l8.7"></a><span id="l8.7" class="difflineplus">+ *</span>
<a href="#l8.8"></a><span id="l8.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l8.9"></a><span id="l8.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l8.10"></a><span id="l8.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l8.11"></a><span id="l8.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+ * </span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+ * License.</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+ *</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+ *</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineplus">+ *</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineplus">+ *</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+ * </span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineplus">+Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+const kStateUnknown = 0;</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineplus">+const kStateInHeaders = 1;</span>
<a href="#l8.51"></a><span id="l8.51" class="difflineplus">+const kStateInBody = 2;</span>
<a href="#l8.52"></a><span id="l8.52" class="difflineplus">+const kStateInAttachment = 3;</span>
<a href="#l8.53"></a><span id="l8.53" class="difflineplus">+</span>
<a href="#l8.54"></a><span id="l8.54" class="difflineplus">+/**</span>
<a href="#l8.55"></a><span id="l8.55" class="difflineplus">+ * Custom nsIMimeEmitter to build a sub-optimal javascript representation of a</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineplus">+ *  MIME message.  The intent is that a better mechanism than is evolved to</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineplus">+ *  provide a javascript-accessible representation of the message.</span>
<a href="#l8.58"></a><span id="l8.58" class="difflineplus">+ *</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineplus">+ * Processing occurs in two passes.  During the first pass, libmime is parsing</span>
<a href="#l8.60"></a><span id="l8.60" class="difflineplus">+ *  the stream it is receiving, and generating header and body events for all</span>
<a href="#l8.61"></a><span id="l8.61" class="difflineplus">+ *  MimeMessage instances it encounters.  This provides us with the knowledge</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineplus">+ *  of each nested message in addition to the top level message, their headers</span>
<a href="#l8.63"></a><span id="l8.63" class="difflineplus">+ *  and sort-of their bodies.  The sort-of is that we may get more than</span>
<a href="#l8.64"></a><span id="l8.64" class="difflineplus">+ *  would normally be displayed in cases involving multipart/alternatives.</span>
<a href="#l8.65"></a><span id="l8.65" class="difflineplus">+ * During the second pass, the libmime object model is traversed, generating</span>
<a href="#l8.66"></a><span id="l8.66" class="difflineplus">+ *  attachment notifications for all leaf nodes.  From our perspective, this</span>
<a href="#l8.67"></a><span id="l8.67" class="difflineplus">+ *  means file attachments and embedded messages (message/rfc822).  We use this</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineplus">+ *  pass to create the attachment objects and properly structure the MIME part</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineplus">+ *  hierarchy.  We extract the 'part name' (ex: 1.2.2.1) from the URL provided</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineplus">+ *  with the attacment and rely on the fact that the attachment notifications</span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+ *  are generated as the result of an in-order traversal of the hierarchy.  We</span>
<a href="#l8.72"></a><span id="l8.72" class="difflineplus">+ *  generate MimeUnknown instances for apparent leaf nodes (nodes for whom</span>
<a href="#l8.73"></a><span id="l8.73" class="difflineplus">+ *  we did not hear about and do not know of any of their children), and</span>
<a href="#l8.74"></a><span id="l8.74" class="difflineplus">+ *  MimeContainer instances for apparent container nodes (nodes for whom we</span>
<a href="#l8.75"></a><span id="l8.75" class="difflineplus">+ *  know about one or more children).</span>
<a href="#l8.76"></a><span id="l8.76" class="difflineplus">+ */</span>
<a href="#l8.77"></a><span id="l8.77" class="difflineplus">+function MimeMessageEmitter() {</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineplus">+  this._mimeMsg = {};</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineplus">+  Cu.import(&quot;resource://gloda/modules/mimemsg.js&quot;, this._mimeMsg);</span>
<a href="#l8.80"></a><span id="l8.80" class="difflineplus">+</span>
<a href="#l8.81"></a><span id="l8.81" class="difflineplus">+  this._url = null;</span>
<a href="#l8.82"></a><span id="l8.82" class="difflineplus">+  this._channel = null;</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineplus">+</span>
<a href="#l8.84"></a><span id="l8.84" class="difflineplus">+  this._inputStream = null;</span>
<a href="#l8.85"></a><span id="l8.85" class="difflineplus">+  this._outputStream = null;</span>
<a href="#l8.86"></a><span id="l8.86" class="difflineplus">+  </span>
<a href="#l8.87"></a><span id="l8.87" class="difflineplus">+  this._outputListener = null;</span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+  </span>
<a href="#l8.89"></a><span id="l8.89" class="difflineplus">+  this._rootMsg = null;</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineplus">+  this._messageStack = [];</span>
<a href="#l8.91"></a><span id="l8.91" class="difflineplus">+  this._parentMsg = null;</span>
<a href="#l8.92"></a><span id="l8.92" class="difflineplus">+  this._curMsg = null;</span>
<a href="#l8.93"></a><span id="l8.93" class="difflineplus">+  </span>
<a href="#l8.94"></a><span id="l8.94" class="difflineplus">+  this._messageIndex = 0;</span>
<a href="#l8.95"></a><span id="l8.95" class="difflineplus">+  this._allSubMessages = [];</span>
<a href="#l8.96"></a><span id="l8.96" class="difflineplus">+  </span>
<a href="#l8.97"></a><span id="l8.97" class="difflineplus">+  this._partMap = {};</span>
<a href="#l8.98"></a><span id="l8.98" class="difflineplus">+  this._curPart = null;</span>
<a href="#l8.99"></a><span id="l8.99" class="difflineplus">+  this._curBodyPart = null;</span>
<a href="#l8.100"></a><span id="l8.100" class="difflineplus">+  </span>
<a href="#l8.101"></a><span id="l8.101" class="difflineplus">+  this._state = kStateUnknown;</span>
<a href="#l8.102"></a><span id="l8.102" class="difflineplus">+}</span>
<a href="#l8.103"></a><span id="l8.103" class="difflineplus">+</span>
<a href="#l8.104"></a><span id="l8.104" class="difflineplus">+MimeMessageEmitter.prototype = {</span>
<a href="#l8.105"></a><span id="l8.105" class="difflineplus">+  classDescription: &quot;JS Mime Message Emitter&quot;,</span>
<a href="#l8.106"></a><span id="l8.106" class="difflineplus">+  classID: Components.ID(&quot;{8cddbbbc-7ced-46b0-a936-8cddd1928c24}&quot;),</span>
<a href="#l8.107"></a><span id="l8.107" class="difflineplus">+  contractID: &quot;@mozilla.org/gloda/jsmimeemitter;1&quot;,</span>
<a href="#l8.108"></a><span id="l8.108" class="difflineplus">+  </span>
<a href="#l8.109"></a><span id="l8.109" class="difflineplus">+  _partRE: new RegExp(&quot;^[^?]+\?(?:[^&amp;]+&amp;)*part=([^&amp;]+)(?:&amp;[^&amp;]+)*$&quot;),</span>
<a href="#l8.110"></a><span id="l8.110" class="difflineplus">+  </span>
<a href="#l8.111"></a><span id="l8.111" class="difflineplus">+  _xpcom_categories: [{</span>
<a href="#l8.112"></a><span id="l8.112" class="difflineplus">+    category: &quot;mime-emitter&quot;,</span>
<a href="#l8.113"></a><span id="l8.113" class="difflineplus">+    entry:</span>
<a href="#l8.114"></a><span id="l8.114" class="difflineplus">+      &quot;@mozilla.org/messenger/mimeemitter;1?type=application/x-js-mime-message&quot;,</span>
<a href="#l8.115"></a><span id="l8.115" class="difflineplus">+  }],</span>
<a href="#l8.116"></a><span id="l8.116" class="difflineplus">+  </span>
<a href="#l8.117"></a><span id="l8.117" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIMimeEmitter]),</span>
<a href="#l8.118"></a><span id="l8.118" class="difflineplus">+</span>
<a href="#l8.119"></a><span id="l8.119" class="difflineplus">+  initialize: function mime_emitter_initialize(aUrl, aChannel, aFormat) {</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineplus">+    this._url = aUrl;</span>
<a href="#l8.121"></a><span id="l8.121" class="difflineplus">+    this._curMsg = this._parentMsg = this._rootMsg = new this._mimeMsg.MimeMessage();</span>
<a href="#l8.122"></a><span id="l8.122" class="difflineplus">+    this._curMsg.partName = &quot;&quot;;</span>
<a href="#l8.123"></a><span id="l8.123" class="difflineplus">+    this._partMap[&quot;&quot;] = this._curMsg;</span>
<a href="#l8.124"></a><span id="l8.124" class="difflineplus">+    </span>
<a href="#l8.125"></a><span id="l8.125" class="difflineplus">+    this._mimeMsg.MsgHdrToMimeMessage.RESULT_RENDEVOUZ[aUrl.spec] =</span>
<a href="#l8.126"></a><span id="l8.126" class="difflineplus">+      this._rootMsg;</span>
<a href="#l8.127"></a><span id="l8.127" class="difflineplus">+    </span>
<a href="#l8.128"></a><span id="l8.128" class="difflineplus">+    this._channel = aChannel;</span>
<a href="#l8.129"></a><span id="l8.129" class="difflineplus">+  },</span>
<a href="#l8.130"></a><span id="l8.130" class="difflineplus">+  </span>
<a href="#l8.131"></a><span id="l8.131" class="difflineplus">+  complete: function mime_emitter_complete() {</span>
<a href="#l8.132"></a><span id="l8.132" class="difflineplus">+    // dump(&quot;!!!!\n!!!!\n!!!!\n&quot; + this._rootMsg.prettyString() + &quot;\n&quot;);</span>
<a href="#l8.133"></a><span id="l8.133" class="difflineplus">+    this._url = null;</span>
<a href="#l8.134"></a><span id="l8.134" class="difflineplus">+    this._channel = null;</span>
<a href="#l8.135"></a><span id="l8.135" class="difflineplus">+    </span>
<a href="#l8.136"></a><span id="l8.136" class="difflineplus">+    this._inputStream = null;</span>
<a href="#l8.137"></a><span id="l8.137" class="difflineplus">+    this._outputStream = null;</span>
<a href="#l8.138"></a><span id="l8.138" class="difflineplus">+    </span>
<a href="#l8.139"></a><span id="l8.139" class="difflineplus">+    this._outputListener = null;</span>
<a href="#l8.140"></a><span id="l8.140" class="difflineplus">+</span>
<a href="#l8.141"></a><span id="l8.141" class="difflineplus">+    this._curMsg = this._parentMsg = this._messageStack = this._rootMsg = null;</span>
<a href="#l8.142"></a><span id="l8.142" class="difflineplus">+    this._messageIndex = null;</span>
<a href="#l8.143"></a><span id="l8.143" class="difflineplus">+    this._allSubMessages = null;</span>
<a href="#l8.144"></a><span id="l8.144" class="difflineplus">+    </span>
<a href="#l8.145"></a><span id="l8.145" class="difflineplus">+    this._partMap = null;</span>
<a href="#l8.146"></a><span id="l8.146" class="difflineplus">+    this._curPart = null;</span>
<a href="#l8.147"></a><span id="l8.147" class="difflineplus">+    this._curBodyPart = null;</span>
<a href="#l8.148"></a><span id="l8.148" class="difflineplus">+  },</span>
<a href="#l8.149"></a><span id="l8.149" class="difflineplus">+  </span>
<a href="#l8.150"></a><span id="l8.150" class="difflineplus">+  setPipe: function mime_emitter_setPipe(aInputStream, aOutputStream) {</span>
<a href="#l8.151"></a><span id="l8.151" class="difflineplus">+    this._inputStream = aInputStream;</span>
<a href="#l8.152"></a><span id="l8.152" class="difflineplus">+    this._outputStream = aOutputStream;</span>
<a href="#l8.153"></a><span id="l8.153" class="difflineplus">+  },</span>
<a href="#l8.154"></a><span id="l8.154" class="difflineplus">+  set outputListener(aListener) {</span>
<a href="#l8.155"></a><span id="l8.155" class="difflineplus">+    this._outputListener = aListener;</span>
<a href="#l8.156"></a><span id="l8.156" class="difflineplus">+  },</span>
<a href="#l8.157"></a><span id="l8.157" class="difflineplus">+  get outputListener() {</span>
<a href="#l8.158"></a><span id="l8.158" class="difflineplus">+    return this._outputListener;</span>
<a href="#l8.159"></a><span id="l8.159" class="difflineplus">+  }, </span>
<a href="#l8.160"></a><span id="l8.160" class="difflineplus">+  </span>
<a href="#l8.161"></a><span id="l8.161" class="difflineplus">+  _beginPayload: function mime_emitter__beginPayload(aContentType, aIsPart) {</span>
<a href="#l8.162"></a><span id="l8.162" class="difflineplus">+    aContentType = aContentType.toLowerCase();</span>
<a href="#l8.163"></a><span id="l8.163" class="difflineplus">+    if (aContentType == &quot;text/plain&quot; || aContentType == &quot;text/html&quot;) {</span>
<a href="#l8.164"></a><span id="l8.164" class="difflineplus">+      this._curBodyPart = new this._mimeMsg.MimeBody(aContentType, aIsPart);</span>
<a href="#l8.165"></a><span id="l8.165" class="difflineplus">+      this._parentMsg.bodyParts.push(this._curBodyPart);</span>
<a href="#l8.166"></a><span id="l8.166" class="difflineplus">+      this._curPart = aIsPart ? this._curBodyPart : null;</span>
<a href="#l8.167"></a><span id="l8.167" class="difflineplus">+    }</span>
<a href="#l8.168"></a><span id="l8.168" class="difflineplus">+    else if (aContentType == &quot;message/rfc822&quot;) {</span>
<a href="#l8.169"></a><span id="l8.169" class="difflineplus">+      // startBody will take care of this</span>
<a href="#l8.170"></a><span id="l8.170" class="difflineplus">+      this._curPart = this._curBodyPart = null;</span>
<a href="#l8.171"></a><span id="l8.171" class="difflineplus">+    }</span>
<a href="#l8.172"></a><span id="l8.172" class="difflineplus">+    // this is going to fall-down with TNEF encapsulation and such, we really</span>
<a href="#l8.173"></a><span id="l8.173" class="difflineplus">+    //  need to just be consuming the object model.</span>
<a href="#l8.174"></a><span id="l8.174" class="difflineplus">+    else if (aContentType.indexOf(&quot;multipart/&quot;) == 0) {</span>
<a href="#l8.175"></a><span id="l8.175" class="difflineplus">+      this._curBodyPart = null;</span>
<a href="#l8.176"></a><span id="l8.176" class="difflineplus">+      // alternatives are always parts for part numbering purposes</span>
<a href="#l8.177"></a><span id="l8.177" class="difflineplus">+      this._curPart = aIsPart ? new this._mimeMsg.MimeContainer(aContentType)</span>
<a href="#l8.178"></a><span id="l8.178" class="difflineplus">+                              : null;</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineplus">+    }</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineplus">+    else {</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineplus">+      this._curBodyPart = null;</span>
<a href="#l8.182"></a><span id="l8.182" class="difflineplus">+      this._curPart = aIsPart ?</span>
<a href="#l8.183"></a><span id="l8.183" class="difflineplus">+        new this._mimeMsg.MimeUnknown(aContentType, aIsPart) : null;</span>
<a href="#l8.184"></a><span id="l8.184" class="difflineplus">+    }</span>
<a href="#l8.185"></a><span id="l8.185" class="difflineplus">+  },</span>
<a href="#l8.186"></a><span id="l8.186" class="difflineplus">+  </span>
<a href="#l8.187"></a><span id="l8.187" class="difflineplus">+  // ----- Header Routines</span>
<a href="#l8.188"></a><span id="l8.188" class="difflineplus">+  startHeader: function mime_emitter_startHeader(aIsRootMailHeader,</span>
<a href="#l8.189"></a><span id="l8.189" class="difflineplus">+      aIsHeaderOnly, aMsgID, aOutputCharset) {</span>
<a href="#l8.190"></a><span id="l8.190" class="difflineplus">+    this._state = kStateInHeaders;</span>
<a href="#l8.191"></a><span id="l8.191" class="difflineplus">+    if (aIsRootMailHeader) {</span>
<a href="#l8.192"></a><span id="l8.192" class="difflineplus">+      this.updateCharacterSet(aOutputCharset);</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineplus">+      // nothing to do curMsg-wise, already initialized.</span>
<a href="#l8.194"></a><span id="l8.194" class="difflineplus">+    }</span>
<a href="#l8.195"></a><span id="l8.195" class="difflineplus">+    else {</span>
<a href="#l8.196"></a><span id="l8.196" class="difflineplus">+      this._curMsg = new this._mimeMsg.MimeMessage();</span>
<a href="#l8.197"></a><span id="l8.197" class="difflineplus">+      </span>
<a href="#l8.198"></a><span id="l8.198" class="difflineplus">+      this._curMsg.partName = this._savedPartPath;</span>
<a href="#l8.199"></a><span id="l8.199" class="difflineplus">+      this._placePart(this._curMsg);</span>
<a href="#l8.200"></a><span id="l8.200" class="difflineplus">+      delete this._savedPartPath;</span>
<a href="#l8.201"></a><span id="l8.201" class="difflineplus">+      </span>
<a href="#l8.202"></a><span id="l8.202" class="difflineplus">+      this._parentMsg.messages.push(this._curMsg);</span>
<a href="#l8.203"></a><span id="l8.203" class="difflineplus">+      this._allSubMessages.push(this._curMsg);</span>
<a href="#l8.204"></a><span id="l8.204" class="difflineplus">+    }</span>
<a href="#l8.205"></a><span id="l8.205" class="difflineplus">+  },</span>
<a href="#l8.206"></a><span id="l8.206" class="difflineplus">+  addHeaderField: function mime_emitter_addHeaderField(aField, aValue) {</span>
<a href="#l8.207"></a><span id="l8.207" class="difflineplus">+    if (this._state == kStateInBody) {</span>
<a href="#l8.208"></a><span id="l8.208" class="difflineplus">+      aField = aField.toLowerCase();</span>
<a href="#l8.209"></a><span id="l8.209" class="difflineplus">+      let indexSemi = aValue.indexOf(&quot;;&quot;);</span>
<a href="#l8.210"></a><span id="l8.210" class="difflineplus">+      if (indexSemi &gt;= 0)</span>
<a href="#l8.211"></a><span id="l8.211" class="difflineplus">+        aValue = aValue.substring(0, indexSemi);</span>
<a href="#l8.212"></a><span id="l8.212" class="difflineplus">+      if (aField == &quot;content-type&quot;)</span>
<a href="#l8.213"></a><span id="l8.213" class="difflineplus">+        this._beginPayload(aValue, true);</span>
<a href="#l8.214"></a><span id="l8.214" class="difflineplus">+      else if (aField == &quot;x-jsemitter-part-path&quot;) {</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineplus">+        if (this._curPart) {</span>
<a href="#l8.216"></a><span id="l8.216" class="difflineplus">+          this._curPart.partName = aValue;</span>
<a href="#l8.217"></a><span id="l8.217" class="difflineplus">+          this._placePart(this._curPart);</span>
<a href="#l8.218"></a><span id="l8.218" class="difflineplus">+        }</span>
<a href="#l8.219"></a><span id="l8.219" class="difflineplus">+        else</span>
<a href="#l8.220"></a><span id="l8.220" class="difflineplus">+          this._savedPartPath = aValue;</span>
<a href="#l8.221"></a><span id="l8.221" class="difflineplus">+      }</span>
<a href="#l8.222"></a><span id="l8.222" class="difflineplus">+      return;</span>
<a href="#l8.223"></a><span id="l8.223" class="difflineplus">+    }</span>
<a href="#l8.224"></a><span id="l8.224" class="difflineplus">+    if (this._state != kStateInHeaders)</span>
<a href="#l8.225"></a><span id="l8.225" class="difflineplus">+      return;</span>
<a href="#l8.226"></a><span id="l8.226" class="difflineplus">+    let lowerField = aField.toLowerCase();</span>
<a href="#l8.227"></a><span id="l8.227" class="difflineplus">+    if (lowerField in this._curMsg.headers)</span>
<a href="#l8.228"></a><span id="l8.228" class="difflineplus">+      this._curMsg.headers[lowerField].push(aValue);</span>
<a href="#l8.229"></a><span id="l8.229" class="difflineplus">+    else</span>
<a href="#l8.230"></a><span id="l8.230" class="difflineplus">+      this._curMsg.headers[lowerField] = [aValue];</span>
<a href="#l8.231"></a><span id="l8.231" class="difflineplus">+  },</span>
<a href="#l8.232"></a><span id="l8.232" class="difflineplus">+  addAllHeaders: function mime_emitter_addAllHeaders(aAllHeaders, aHeaderSize) {</span>
<a href="#l8.233"></a><span id="l8.233" class="difflineplus">+    // This is called by the parsing code after the calls to AddHeaderField (or</span>
<a href="#l8.234"></a><span id="l8.234" class="difflineplus">+    //  AddAttachmentField if the part is an attachment), and seems to serve</span>
<a href="#l8.235"></a><span id="l8.235" class="difflineplus">+    //  a specialized, quasi-redundant purpose.  (nsMimeBaseEmitter creates a</span>
<a href="#l8.236"></a><span id="l8.236" class="difflineplus">+    //  nsIMimeHeaders instance and hands it to the nsIMsgMailNewsUrl.)</span>
<a href="#l8.237"></a><span id="l8.237" class="difflineplus">+    // nop</span>
<a href="#l8.238"></a><span id="l8.238" class="difflineplus">+  },</span>
<a href="#l8.239"></a><span id="l8.239" class="difflineplus">+  writeHTMLHeaders: function mime_emitter_writeHTMLHeaders() {</span>
<a href="#l8.240"></a><span id="l8.240" class="difflineplus">+    // It does't look like this should even be part of the interface; I think</span>
<a href="#l8.241"></a><span id="l8.241" class="difflineplus">+    //  only the nsMimeHtmlDisplayEmitter::EndHeader call calls this signature.</span>
<a href="#l8.242"></a><span id="l8.242" class="difflineplus">+    // nop</span>
<a href="#l8.243"></a><span id="l8.243" class="difflineplus">+  },</span>
<a href="#l8.244"></a><span id="l8.244" class="difflineplus">+  endHeader: function mime_emitter_endHeader() {</span>
<a href="#l8.245"></a><span id="l8.245" class="difflineplus">+  },</span>
<a href="#l8.246"></a><span id="l8.246" class="difflineplus">+  updateCharacterSet: function mime_emitter_updateCharacterSet(aCharset) {</span>
<a href="#l8.247"></a><span id="l8.247" class="difflineplus">+    // for non US-ASCII, ISO-8859-1, or UTF-8 charsets (case-insensitive),</span>
<a href="#l8.248"></a><span id="l8.248" class="difflineplus">+    //  nsMimeBaseEmitter grabs the channel's content type, nukes the &quot;charset=&quot;</span>
<a href="#l8.249"></a><span id="l8.249" class="difflineplus">+    //  parameter if it exists, and tells the channel the updated content type</span>
<a href="#l8.250"></a><span id="l8.250" class="difflineplus">+    //  and new character set.</span>
<a href="#l8.251"></a><span id="l8.251" class="difflineplus">+    </span>
<a href="#l8.252"></a><span id="l8.252" class="difflineplus">+    // Disabling for now; we get a NS_ERROR_NOT_IMPLEMENTED from the channel</span>
<a href="#l8.253"></a><span id="l8.253" class="difflineplus">+    //  when we try and set the contentCharset... and I'm not totally up on the</span>
<a href="#l8.254"></a><span id="l8.254" class="difflineplus">+    //  intent of why we were doing this in the first place.</span>
<a href="#l8.255"></a><span id="l8.255" class="difflineplus">+    /*</span>
<a href="#l8.256"></a><span id="l8.256" class="difflineplus">+    let upperCharset = aCharset.toUpperCase();</span>
<a href="#l8.257"></a><span id="l8.257" class="difflineplus">+    </span>
<a href="#l8.258"></a><span id="l8.258" class="difflineplus">+    if ((upperCharset != &quot;US-ASCII&quot;) &amp;&amp; (upperCharset != &quot;ISO-8859-1&quot;) &amp;&amp;</span>
<a href="#l8.259"></a><span id="l8.259" class="difflineplus">+        (upperCharset != &quot;UTF-8&quot;)) {  </span>
<a href="#l8.260"></a><span id="l8.260" class="difflineplus">+    </span>
<a href="#l8.261"></a><span id="l8.261" class="difflineplus">+      let curContentType = this._channel.contentType;</span>
<a href="#l8.262"></a><span id="l8.262" class="difflineplus">+      let charsetIndex = curContentType.toLowerCase().indexOf(&quot;charset=&quot;);</span>
<a href="#l8.263"></a><span id="l8.263" class="difflineplus">+      if (charsetIndex &gt;= 0) {</span>
<a href="#l8.264"></a><span id="l8.264" class="difflineplus">+        // assume a space or semicolon delimits</span>
<a href="#l8.265"></a><span id="l8.265" class="difflineplus">+        curContentType = curContentType.substring(0, charsetIndex-1);</span>
<a href="#l8.266"></a><span id="l8.266" class="difflineplus">+      }</span>
<a href="#l8.267"></a><span id="l8.267" class="difflineplus">+      </span>
<a href="#l8.268"></a><span id="l8.268" class="difflineplus">+      this._channel.contentType = curContentType;</span>
<a href="#l8.269"></a><span id="l8.269" class="difflineplus">+      this._channel.contentCharset = aCharset;</span>
<a href="#l8.270"></a><span id="l8.270" class="difflineplus">+    }</span>
<a href="#l8.271"></a><span id="l8.271" class="difflineplus">+    */</span>
<a href="#l8.272"></a><span id="l8.272" class="difflineplus">+  },</span>
<a href="#l8.273"></a><span id="l8.273" class="difflineplus">+  </span>
<a href="#l8.274"></a><span id="l8.274" class="difflineplus">+  /**</span>
<a href="#l8.275"></a><span id="l8.275" class="difflineplus">+   * Place a part in its proper location.  We know that we are called as a</span>
<a href="#l8.276"></a><span id="l8.276" class="difflineplus">+   *  result of in-order traversal, so this is wildly easy to deal with.</span>
<a href="#l8.277"></a><span id="l8.277" class="difflineplus">+   */</span>
<a href="#l8.278"></a><span id="l8.278" class="difflineplus">+  _placePart: function(aPart) {</span>
<a href="#l8.279"></a><span id="l8.279" class="difflineplus">+    let partName = aPart.partName;</span>
<a href="#l8.280"></a><span id="l8.280" class="difflineplus">+    this._partMap[partName] = aPart;</span>
<a href="#l8.281"></a><span id="l8.281" class="difflineplus">+    let parentName = partName.substring(0, partName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l8.282"></a><span id="l8.282" class="difflineplus">+    let parentPart = this._partMap[parentName];</span>
<a href="#l8.283"></a><span id="l8.283" class="difflineplus">+    parentPart.parts.push(aPart);</span>
<a href="#l8.284"></a><span id="l8.284" class="difflineplus">+  },</span>
<a href="#l8.285"></a><span id="l8.285" class="difflineplus">+  </span>
<a href="#l8.286"></a><span id="l8.286" class="difflineplus">+  /**</span>
<a href="#l8.287"></a><span id="l8.287" class="difflineplus">+   * In the case of attachments, we need to replace an existing part with a</span>
<a href="#l8.288"></a><span id="l8.288" class="difflineplus">+   *  more representative part...</span>
<a href="#l8.289"></a><span id="l8.289" class="difflineplus">+   */</span>
<a href="#l8.290"></a><span id="l8.290" class="difflineplus">+  _replacePart: function(aPart) {</span>
<a href="#l8.291"></a><span id="l8.291" class="difflineplus">+    let partName = aPart.partName;</span>
<a href="#l8.292"></a><span id="l8.292" class="difflineplus">+    this._partMap[partName] = aPart;</span>
<a href="#l8.293"></a><span id="l8.293" class="difflineplus">+    </span>
<a href="#l8.294"></a><span id="l8.294" class="difflineplus">+    let parentName = partName.substring(0, partName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l8.295"></a><span id="l8.295" class="difflineplus">+    let parentPart = this._partMap[parentName];</span>
<a href="#l8.296"></a><span id="l8.296" class="difflineplus">+    </span>
<a href="#l8.297"></a><span id="l8.297" class="difflineplus">+    let childNamePart = partName.substring(partName.lastIndexOf(&quot;.&quot;)+1);</span>
<a href="#l8.298"></a><span id="l8.298" class="difflineplus">+    let childIndex = parseInt(childNamePart) - 1;</span>
<a href="#l8.299"></a><span id="l8.299" class="difflineplus">+    </span>
<a href="#l8.300"></a><span id="l8.300" class="difflineplus">+    let oldPart = parentPart.parts[childIndex];</span>
<a href="#l8.301"></a><span id="l8.301" class="difflineplus">+    parentPart.parts[childIndex] = aPart;</span>
<a href="#l8.302"></a><span id="l8.302" class="difflineplus">+    aPart.parts = oldPart.parts;</span>
<a href="#l8.303"></a><span id="l8.303" class="difflineplus">+</span>
<a href="#l8.304"></a><span id="l8.304" class="difflineplus">+    // - remove it if it was a body part.  This can happen for text/plain</span>
<a href="#l8.305"></a><span id="l8.305" class="difflineplus">+    //  attachments.  Like patches.</span>
<a href="#l8.306"></a><span id="l8.306" class="difflineplus">+    // (climb the parents until we find a message/bodyparts holder...)</span>
<a href="#l8.307"></a><span id="l8.307" class="difflineplus">+    while (parentPart.partName &amp;&amp; !parentPart.bodyParts) {</span>
<a href="#l8.308"></a><span id="l8.308" class="difflineplus">+      parentName = parentName.substring(0, parentName.lastIndexOf(&quot;.&quot;));</span>
<a href="#l8.309"></a><span id="l8.309" class="difflineplus">+      parentPart = this._partMap[parentName];</span>
<a href="#l8.310"></a><span id="l8.310" class="difflineplus">+    }</span>
<a href="#l8.311"></a><span id="l8.311" class="difflineplus">+    if (parentPart.bodyParts &amp;&amp; parentPart.bodyParts.indexOf(oldPart) &gt;= 0)</span>
<a href="#l8.312"></a><span id="l8.312" class="difflineplus">+      parentPart.bodyParts.splice(parentPart.bodyParts.indexOf(oldPart), 1);</span>
<a href="#l8.313"></a><span id="l8.313" class="difflineplus">+  },</span>
<a href="#l8.314"></a><span id="l8.314" class="difflineplus">+  </span>
<a href="#l8.315"></a><span id="l8.315" class="difflineplus">+  /**</span>
<a href="#l8.316"></a><span id="l8.316" class="difflineplus">+   * Put a part at its proper location.  We rely on this method to be called</span>
<a href="#l8.317"></a><span id="l8.317" class="difflineplus">+   *  in the the sequence generated by StartAttachment (an in-order traversal</span>
<a href="#l8.318"></a><span id="l8.318" class="difflineplus">+   *  of the MIME structure).</span>
<a href="#l8.319"></a><span id="l8.319" class="difflineplus">+   */</span>
<a href="#l8.320"></a><span id="l8.320" class="difflineplus">+  _putPart: function(aPartPath, aPathSoFar, aPart, aParent) {</span>
<a href="#l8.321"></a><span id="l8.321" class="difflineplus">+    let dotIndex = aPartPath.indexOf(&quot;.&quot;);</span>
<a href="#l8.322"></a><span id="l8.322" class="difflineplus">+    let curPath, remPath;</span>
<a href="#l8.323"></a><span id="l8.323" class="difflineplus">+    if (dotIndex &gt;= 0) {</span>
<a href="#l8.324"></a><span id="l8.324" class="difflineplus">+      curPath = aPartPath.substring(0, dotIndex);</span>
<a href="#l8.325"></a><span id="l8.325" class="difflineplus">+      remPath = aPartPath.substring(dotIndex+1);</span>
<a href="#l8.326"></a><span id="l8.326" class="difflineplus">+    }</span>
<a href="#l8.327"></a><span id="l8.327" class="difflineplus">+    else {</span>
<a href="#l8.328"></a><span id="l8.328" class="difflineplus">+      curPath = aPartPath;</span>
<a href="#l8.329"></a><span id="l8.329" class="difflineplus">+      remPath = null;</span>
<a href="#l8.330"></a><span id="l8.330" class="difflineplus">+    }</span>
<a href="#l8.331"></a><span id="l8.331" class="difflineplus">+    let newPathSoFar = aPathSoFar + &quot;.&quot; + curPath;</span>
<a href="#l8.332"></a><span id="l8.332" class="difflineplus">+    let curIndex = parseInt(curPath) - 1;</span>
<a href="#l8.333"></a><span id="l8.333" class="difflineplus">+</span>
<a href="#l8.334"></a><span id="l8.334" class="difflineplus">+    // for parts that should exist, try and find them in the part map, otherwise</span>
<a href="#l8.335"></a><span id="l8.335" class="difflineplus">+    //  create MimeUnknowns</span>
<a href="#l8.336"></a><span id="l8.336" class="difflineplus">+    while (curIndex &gt; aParent.parts.length) {</span>
<a href="#l8.337"></a><span id="l8.337" class="difflineplus">+      let tempPath = aPathSoFar + &quot;.&quot; + aParent.parts.length;</span>
<a href="#l8.338"></a><span id="l8.338" class="difflineplus">+      if (tempPath in this._partMap)</span>
<a href="#l8.339"></a><span id="l8.339" class="difflineplus">+        aParent.parts.push(this._partMap[tempPath]);</span>
<a href="#l8.340"></a><span id="l8.340" class="difflineplus">+      else {</span>
<a href="#l8.341"></a><span id="l8.341" class="difflineplus">+        let newPart = new this._mimeMsg.MimeUnknown(&quot;unknown/unknown&quot;, true);</span>
<a href="#l8.342"></a><span id="l8.342" class="difflineplus">+        newPart.partName = tempPath;</span>
<a href="#l8.343"></a><span id="l8.343" class="difflineplus">+        aParent.parts.push(newPart);</span>
<a href="#l8.344"></a><span id="l8.344" class="difflineplus">+      }</span>
<a href="#l8.345"></a><span id="l8.345" class="difflineplus">+    }</span>
<a href="#l8.346"></a><span id="l8.346" class="difflineplus">+    </span>
<a href="#l8.347"></a><span id="l8.347" class="difflineplus">+    // are we a leaf?</span>
<a href="#l8.348"></a><span id="l8.348" class="difflineplus">+    if (remPath !== null) {</span>
<a href="#l8.349"></a><span id="l8.349" class="difflineplus">+      // no, we are not a leaf</span>
<a href="#l8.350"></a><span id="l8.350" class="difflineplus">+      if (curIndex == aParent.parts.length) {</span>
<a href="#l8.351"></a><span id="l8.351" class="difflineplus">+        // and we need to add a container</span>
<a href="#l8.352"></a><span id="l8.352" class="difflineplus">+        if (newPathSoFar in this._partMap)</span>
<a href="#l8.353"></a><span id="l8.353" class="difflineplus">+          aParent.parts.push(this._partMap[newPathSoFar]);</span>
<a href="#l8.354"></a><span id="l8.354" class="difflineplus">+        else {</span>
<a href="#l8.355"></a><span id="l8.355" class="difflineplus">+          let newPart = new this._mimeMsg.MimeContainer(&quot;multipart/unknown&quot;,</span>
<a href="#l8.356"></a><span id="l8.356" class="difflineplus">+                                                        true);</span>
<a href="#l8.357"></a><span id="l8.357" class="difflineplus">+          newPart.partName = newPathSoFar;</span>
<a href="#l8.358"></a><span id="l8.358" class="difflineplus">+          aParent.parts.push(newPart);</span>
<a href="#l8.359"></a><span id="l8.359" class="difflineplus">+        }</span>
<a href="#l8.360"></a><span id="l8.360" class="difflineplus">+      }</span>
<a href="#l8.361"></a><span id="l8.361" class="difflineplus">+      this._putPart(remPath, newPathSoFar, aPart, aParent.parts[curIndex]);</span>
<a href="#l8.362"></a><span id="l8.362" class="difflineplus">+    }</span>
<a href="#l8.363"></a><span id="l8.363" class="difflineplus">+    else {</span>
<a href="#l8.364"></a><span id="l8.364" class="difflineplus">+      // yes, we are a leaf, we just go here...</span>
<a href="#l8.365"></a><span id="l8.365" class="difflineplus">+      aParent.parts.push(aPart);</span>
<a href="#l8.366"></a><span id="l8.366" class="difflineplus">+    }</span>
<a href="#l8.367"></a><span id="l8.367" class="difflineplus">+  },</span>
<a href="#l8.368"></a><span id="l8.368" class="difflineplus">+  </span>
<a href="#l8.369"></a><span id="l8.369" class="difflineplus">+  // ----- Attachment Routines</span>
<a href="#l8.370"></a><span id="l8.370" class="difflineplus">+  // The attachment processing happens after the initial streaming phase (during</span>
<a href="#l8.371"></a><span id="l8.371" class="difflineplus">+  //  which time we receive the messages, both bodies and headers).  Our caller</span>
<a href="#l8.372"></a><span id="l8.372" class="difflineplus">+  //  traverses the libmime child object hierarchy, emitting an attachment for</span>
<a href="#l8.373"></a><span id="l8.373" class="difflineplus">+  //  each leaf object or sub-message.</span>
<a href="#l8.374"></a><span id="l8.374" class="difflineplus">+  startAttachment: function mime_emitter_startAttachment(aName, aContentType,</span>
<a href="#l8.375"></a><span id="l8.375" class="difflineplus">+      aUrl, aNotDownloaded) {</span>
<a href="#l8.376"></a><span id="l8.376" class="difflineplus">+    this._state = kStateInAttachment;</span>
<a href="#l8.377"></a><span id="l8.377" class="difflineplus">+    // we need to strip our magic flags from the URL</span>
<a href="#l8.378"></a><span id="l8.378" class="difflineplus">+    aURl = aUrl.replace(&quot;header=filter&amp;emitter=js&amp;&quot;, &quot;&quot;);</span>
<a href="#l8.379"></a><span id="l8.379" class="difflineplus">+    </span>
<a href="#l8.380"></a><span id="l8.380" class="difflineplus">+    // the url should contain a part= piece that tells us the part name, which</span>
<a href="#l8.381"></a><span id="l8.381" class="difflineplus">+    //  we then use to figure out where.</span>
<a href="#l8.382"></a><span id="l8.382" class="difflineplus">+    let partMatch = this._partRE.exec(aUrl);</span>
<a href="#l8.383"></a><span id="l8.383" class="difflineplus">+    let partName = partMatch[1];</span>
<a href="#l8.384"></a><span id="l8.384" class="difflineplus">+</span>
<a href="#l8.385"></a><span id="l8.385" class="difflineplus">+    let part;</span>
<a href="#l8.386"></a><span id="l8.386" class="difflineplus">+    if (aContentType == &quot;message/rfc822&quot;) {</span>
<a href="#l8.387"></a><span id="l8.387" class="difflineplus">+      // we already have all we need to know about the message, ignore it</span>
<a href="#l8.388"></a><span id="l8.388" class="difflineplus">+      return;</span>
<a href="#l8.389"></a><span id="l8.389" class="difflineplus">+    }</span>
<a href="#l8.390"></a><span id="l8.390" class="difflineplus">+    else {</span>
<a href="#l8.391"></a><span id="l8.391" class="difflineplus">+      // create the attachment</span>
<a href="#l8.392"></a><span id="l8.392" class="difflineplus">+      part = new this._mimeMsg.MimeMessageAttachment(partName,</span>
<a href="#l8.393"></a><span id="l8.393" class="difflineplus">+          aName, aContentType, aUrl, aNotDownloaded);</span>
<a href="#l8.394"></a><span id="l8.394" class="difflineplus">+    }</span>
<a href="#l8.395"></a><span id="l8.395" class="difflineplus">+    </span>
<a href="#l8.396"></a><span id="l8.396" class="difflineplus">+    if (part.isRealAttachment) {</span>
<a href="#l8.397"></a><span id="l8.397" class="difflineplus">+      // replace the existing part with the attachment...</span>
<a href="#l8.398"></a><span id="l8.398" class="difflineplus">+      this._replacePart(part);</span>
<a href="#l8.399"></a><span id="l8.399" class="difflineplus">+    }</span>
<a href="#l8.400"></a><span id="l8.400" class="difflineplus">+  },</span>
<a href="#l8.401"></a><span id="l8.401" class="difflineplus">+  addAttachmentField: function mime_emitter_addAttachmentField(aField, aValue) {</span>
<a href="#l8.402"></a><span id="l8.402" class="difflineplus">+    // this only gives us X-Mozilla-PartURL, which is the same as aUrl we</span>
<a href="#l8.403"></a><span id="l8.403" class="difflineplus">+    //  already got previously, so need to do anything with this.</span>
<a href="#l8.404"></a><span id="l8.404" class="difflineplus">+  },</span>
<a href="#l8.405"></a><span id="l8.405" class="difflineplus">+  endAttachment: function mime_emitter_endAttachment() {</span>
<a href="#l8.406"></a><span id="l8.406" class="difflineplus">+    // don't need to do anything here, since we don't care about the headers.</span>
<a href="#l8.407"></a><span id="l8.407" class="difflineplus">+  },</span>
<a href="#l8.408"></a><span id="l8.408" class="difflineplus">+  endAllAttachments: function mime_emitter_endAllAttachments() {</span>
<a href="#l8.409"></a><span id="l8.409" class="difflineplus">+    // nop</span>
<a href="#l8.410"></a><span id="l8.410" class="difflineplus">+  },</span>
<a href="#l8.411"></a><span id="l8.411" class="difflineplus">+  </span>
<a href="#l8.412"></a><span id="l8.412" class="difflineplus">+  // ----- Body Routines</span>
<a href="#l8.413"></a><span id="l8.413" class="difflineplus">+  startBody: function mime_emitter_startBody(aIsBodyOnly, aMsgID, aOutCharset) {</span>
<a href="#l8.414"></a><span id="l8.414" class="difflineplus">+    this._state = kStateInBody;</span>
<a href="#l8.415"></a><span id="l8.415" class="difflineplus">+    </span>
<a href="#l8.416"></a><span id="l8.416" class="difflineplus">+    this._messageStack.push(this._curMsg);</span>
<a href="#l8.417"></a><span id="l8.417" class="difflineplus">+    this._parentMsg = this._curMsg;</span>
<a href="#l8.418"></a><span id="l8.418" class="difflineplus">+</span>
<a href="#l8.419"></a><span id="l8.419" class="difflineplus">+    // begin payload processing</span>
<a href="#l8.420"></a><span id="l8.420" class="difflineplus">+    let contentType = this._curMsg.get(&quot;content-type&quot;, &quot;text/plain&quot;);</span>
<a href="#l8.421"></a><span id="l8.421" class="difflineplus">+    let indexSemi = contentType.indexOf(&quot;;&quot;);</span>
<a href="#l8.422"></a><span id="l8.422" class="difflineplus">+    if (indexSemi &gt;= 0)</span>
<a href="#l8.423"></a><span id="l8.423" class="difflineplus">+      contentType = contentType.substring(0, indexSemi);</span>
<a href="#l8.424"></a><span id="l8.424" class="difflineplus">+    this._beginPayload(contentType, true);</span>
<a href="#l8.425"></a><span id="l8.425" class="difflineplus">+    if (this._parentMsg.partName == &quot;&quot;)</span>
<a href="#l8.426"></a><span id="l8.426" class="difflineplus">+      this._curPart.partName = &quot;1&quot;;</span>
<a href="#l8.427"></a><span id="l8.427" class="difflineplus">+    else</span>
<a href="#l8.428"></a><span id="l8.428" class="difflineplus">+      this._curPart.partName = this._curMsg.partName + &quot;.1&quot;;</span>
<a href="#l8.429"></a><span id="l8.429" class="difflineplus">+    this._placePart(this._curPart);</span>
<a href="#l8.430"></a><span id="l8.430" class="difflineplus">+  },</span>
<a href="#l8.431"></a><span id="l8.431" class="difflineplus">+  </span>
<a href="#l8.432"></a><span id="l8.432" class="difflineplus">+  writeBody: function mime_emitter_writeBody(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l8.433"></a><span id="l8.433" class="difflineplus">+    if (this._curBodyPart)</span>
<a href="#l8.434"></a><span id="l8.434" class="difflineplus">+      this._curBodyPart.body += aBuf;</span>
<a href="#l8.435"></a><span id="l8.435" class="difflineplus">+  },</span>
<a href="#l8.436"></a><span id="l8.436" class="difflineplus">+  </span>
<a href="#l8.437"></a><span id="l8.437" class="difflineplus">+  endBody: function mime_emitter_endBody() {</span>
<a href="#l8.438"></a><span id="l8.438" class="difflineplus">+    this._messageStack.pop();</span>
<a href="#l8.439"></a><span id="l8.439" class="difflineplus">+    this._parentMsg = this._messageStack[this._messageStack.length - 1];</span>
<a href="#l8.440"></a><span id="l8.440" class="difflineplus">+  },</span>
<a href="#l8.441"></a><span id="l8.441" class="difflineplus">+  </span>
<a href="#l8.442"></a><span id="l8.442" class="difflineplus">+  // ----- Generic Write (confusing)</span>
<a href="#l8.443"></a><span id="l8.443" class="difflineplus">+  // (binary data writing...)</span>
<a href="#l8.444"></a><span id="l8.444" class="difflineplus">+  write: function mime_emitter_write(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l8.445"></a><span id="l8.445" class="difflineplus">+    // we don't actually ever get called because we don't have the attachment</span>
<a href="#l8.446"></a><span id="l8.446" class="difflineplus">+    //  binary payloads pass through us, but we do the following just in case</span>
<a href="#l8.447"></a><span id="l8.447" class="difflineplus">+    //  we did get called (otherwise the caller gets mad and throws exceptions).</span>
<a href="#l8.448"></a><span id="l8.448" class="difflineplus">+    aOutAmountWritten.value = aSize;</span>
<a href="#l8.449"></a><span id="l8.449" class="difflineplus">+  },</span>
<a href="#l8.450"></a><span id="l8.450" class="difflineplus">+  </span>
<a href="#l8.451"></a><span id="l8.451" class="difflineplus">+  // (string writing)</span>
<a href="#l8.452"></a><span id="l8.452" class="difflineplus">+  utilityWrite: function mime_emitter_utilityWrite(aBuf) {</span>
<a href="#l8.453"></a><span id="l8.453" class="difflineplus">+    this.write(aBuf, aBuf.length, {});</span>
<a href="#l8.454"></a><span id="l8.454" class="difflineplus">+  },</span>
<a href="#l8.455"></a><span id="l8.455" class="difflineplus">+};</span>
<a href="#l8.456"></a><span id="l8.456" class="difflineplus">+</span>
<a href="#l8.457"></a><span id="l8.457" class="difflineplus">+var components = [MimeMessageEmitter];</span>
<a href="#l8.458"></a><span id="l8.458" class="difflineplus">+function NSGetModule(compMgr, fileSpec) {</span>
<a href="#l8.459"></a><span id="l8.459" class="difflineplus">+  return XPCOMUtils.generateModule(components);</span>
<a href="#l8.460"></a><span id="l8.460" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1">new file mode 100644</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineminus">--- /dev/null</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineplus">+++ b/mailnews/db/gloda/config_build.sh</span>
<a href="#l9.4"></a><span id="l9.4" class="difflineat">@@ -0,0 +1,9 @@</span>
<a href="#l9.5"></a><span id="l9.5" class="difflineplus">+#!/bin/bash</span>
<a href="#l9.6"></a><span id="l9.6" class="difflineplus">+# Build config for build.sh</span>
<a href="#l9.7"></a><span id="l9.7" class="difflineplus">+APP_NAME=gloda</span>
<a href="#l9.8"></a><span id="l9.8" class="difflineplus">+CHROME_PROVIDERS=&quot;content locale skin&quot;</span>
<a href="#l9.9"></a><span id="l9.9" class="difflineplus">+CLEAN_UP=1</span>
<a href="#l9.10"></a><span id="l9.10" class="difflineplus">+ROOT_FILES=</span>
<a href="#l9.11"></a><span id="l9.11" class="difflineplus">+ROOT_DIRS=&quot;defaults modules&quot;</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+BEFORE_BUILD=</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+AFTER_BUILD=</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineminus">--- /dev/null</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineplus">+++ b/mailnews/db/gloda/content/glodacomplete.css</span>
<a href="#l10.4"></a><span id="l10.4" class="difflineat">@@ -0,0 +1,42 @@</span>
<a href="#l10.5"></a><span id="l10.5" class="difflineplus">+textbox[type=&quot;glodacomplete&quot;] {</span>
<a href="#l10.6"></a><span id="l10.6" class="difflineplus">+  -moz-binding: url(&quot;chrome://global/content/bindings/autocomplete.xml#autocomplete&quot;);</span>
<a href="#l10.7"></a><span id="l10.7" class="difflineplus">+}</span>
<a href="#l10.8"></a><span id="l10.8" class="difflineplus">+</span>
<a href="#l10.9"></a><span id="l10.9" class="difflineplus">+panel[type=&quot;glodacomplete-richlistbox&quot;] {</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#glodacomplete-rich-result-popup&quot;);</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+}</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+.autocomplete-richlistbox {</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+  -moz-binding: url(&quot;chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistbox&quot;);</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+  -moz-user-focus: ignore;</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+  -moz-appearance: none;</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+}</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+.autocomplete-richlistbox &gt; scrollbox {</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+  overflow-x: hidden !important;</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+}</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+.autocomplete-richlistitem[type=&quot;gloda-single-tag&quot;] {</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#gloda-single-tag-item&quot;);</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+  overflow: -moz-hidden-unscrollable;</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+}</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineplus">+.autocomplete-richlistitem[type=&quot;gloda-single-identity&quot;] {</span>
<a href="#l10.29"></a><span id="l10.29" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#gloda-single-identity-item&quot;);</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineplus">+  -moz-box-orient: vertical;</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+  overflow: -moz-hidden-unscrollable;</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+}</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineplus">+</span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+richlistitem[type=&quot;gloda-contact-chunk&quot;] {</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#gloda-contact-chunk&quot;);</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+  -moz-box-orient: vertical;</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+  overflow: -moz-hidden-unscrollable;</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+}</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineplus">+.autocomplete-richlistitem[type=&quot;gloda-multi&quot;] {</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#gloda-multi-item&quot;);</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineplus">+  -moz-box-orient: vertical;</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+  overflow: -moz-hidden-unscrollable;</span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+}</span>
<a href="#l10.45"></a><span id="l10.45" class="difflineplus">+</span>
<a href="#l10.46"></a><span id="l10.46" class="difflineplus">+/* .autocomplete-history-dropmarker wants to be optional, but we don't care */</span>
<a href="#l10.47"></a><span id="l10.47">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1">new file mode 100644</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineminus">--- /dev/null</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineplus">+++ b/mailnews/db/gloda/content/glodacomplete.xml</span>
<a href="#l11.4"></a><span id="l11.4" class="difflineat">@@ -0,0 +1,624 @@</span>
<a href="#l11.5"></a><span id="l11.5" class="difflineplus">+&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<a href="#l11.6"></a><span id="l11.6" class="difflineplus">+</span>
<a href="#l11.7"></a><span id="l11.7" class="difflineplus">+&lt;!-- ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l11.8"></a><span id="l11.8" class="difflineplus">+   - Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l11.9"></a><span id="l11.9" class="difflineplus">+   -</span>
<a href="#l11.10"></a><span id="l11.10" class="difflineplus">+   - The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l11.11"></a><span id="l11.11" class="difflineplus">+   - 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+   - the License. You may obtain a copy of the License at</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+   - http://www.mozilla.org/MPL/</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+   -</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineplus">+   - Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineplus">+   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineplus">+   - for the specific language governing rights and limitations under the</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineplus">+   - License.</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineplus">+   -</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineplus">+   - The Original Code is mozilla.org browser.</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineplus">+   -</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineplus">+   - The Initial Developer of the Original Code is</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineplus">+   - Joe Hewitt.</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineplus">+   - Portions created by the Initial Developer are Copyright (C) 2003</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineplus">+   - the Initial Developer. All Rights Reserved.</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineplus">+   -</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineplus">+   - Contributor(s):</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+   - Pierre Chanial (p_ch@verizon.net)</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+   - Dean Tessman   (dean_tessman@hotmail.com)</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineplus">+   - Masayuki Nakano (masayuki@d-toybox.com)</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineplus">+   - Pamela Greene (pamg.bugs@gmail.com)</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+   - Edward Lee (edward.lee@engineering.uiuc.edu)</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineplus">+   - Andrew Sutherland (asutherland@asutherland.org)</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineplus">+   -</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineplus">+   - Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+   - either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+   - the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineplus">+   - in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineplus">+   - of those above. If you wish to allow use of your version of this file only</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineplus">+   - under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineplus">+   - use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l11.42"></a><span id="l11.42" class="difflineplus">+   - decision by deleting the provisions above and replace them with the notice</span>
<a href="#l11.43"></a><span id="l11.43" class="difflineplus">+   - and other provisions required by the LGPL or the GPL. If you do not delete</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineplus">+   - the provisions above, a recipient may use your version of this file under</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineplus">+   - the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineplus">+   -</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineplus">+   - ***** END LICENSE BLOCK ***** --&gt;</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineplus">+</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+&lt;bindings id=&quot;autocompleteBindings&quot;</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineplus">+          xmlns=&quot;http://www.mozilla.org/xbl&quot;</span>
<a href="#l11.51"></a><span id="l11.51" class="difflineplus">+          xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;</span>
<a href="#l11.52"></a><span id="l11.52" class="difflineplus">+          xmlns:xul=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;</span>
<a href="#l11.53"></a><span id="l11.53" class="difflineplus">+          xmlns:xbl=&quot;http://www.mozilla.org/xbl&quot;&gt;</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineplus">+</span>
<a href="#l11.55"></a><span id="l11.55" class="difflineplus">+  &lt;binding id=&quot;glodacomplete-rich-result-popup&quot; extends=&quot;chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup&quot;&gt;</span>
<a href="#l11.56"></a><span id="l11.56" class="difflineplus">+    &lt;implementation implements=&quot;nsIAutoCompletePopup&quot;&gt;</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineplus">+      &lt;method name=&quot;_appendCurrentResult&quot;&gt;</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineplus">+          var controller = this.mInput.controller;</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineplus">+</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineplus">+          // Process maxRows per chunk to improve performance and user experience</span>
<a href="#l11.63"></a><span id="l11.63" class="difflineplus">+          for (let i = 0; i &lt; this.maxRows; i++) {</span>
<a href="#l11.64"></a><span id="l11.64" class="difflineplus">+            if (this._currentIndex &gt;= this._matchCount)</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineplus">+              return;</span>
<a href="#l11.66"></a><span id="l11.66" class="difflineplus">+</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineplus">+            var existingItemsCount = this.richlistbox.childNodes.length;</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineplus">+            var item;</span>
<a href="#l11.69"></a><span id="l11.69" class="difflineplus">+</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineplus">+            // trim the leading/trailing whitespace</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineplus">+            var trimmedSearchString = controller.searchString.replace(/^\s+/, &quot;&quot;).replace(/\s+$/, &quot;&quot;);</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineplus">+</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineplus">+            // Unescape the URI spec for showing as an entry in the popup</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineplus">+            let url = Components.classes[&quot;@mozilla.org/intl/texttosuburi;1&quot;].</span>
<a href="#l11.75"></a><span id="l11.75" class="difflineplus">+              getService(Components.interfaces.nsITextToSubURI).</span>
<a href="#l11.76"></a><span id="l11.76" class="difflineplus">+              unEscapeURIForUI(&quot;UTF-8&quot;, controller.getValueAt(this._currentIndex));</span>
<a href="#l11.77"></a><span id="l11.77" class="difflineplus">+</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineplus">+            if (this._currentIndex &lt; existingItemsCount) {</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineplus">+              // re-use the existing item</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineplus">+              item = this.richlistbox.childNodes[this._currentIndex];</span>
<a href="#l11.81"></a><span id="l11.81" class="difflineplus">+</span>
<a href="#l11.82"></a><span id="l11.82" class="difflineplus">+              // Completely re-use the existing richlistitem if it's the same</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineplus">+              if (item.getAttribute(&quot;text&quot;) == trimmedSearchString &amp;&amp;</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineplus">+                  item.getAttribute(&quot;url&quot;) == url) {</span>
<a href="#l11.85"></a><span id="l11.85" class="difflineplus">+                item.collapsed = false;</span>
<a href="#l11.86"></a><span id="l11.86" class="difflineplus">+                this._currentIndex++;</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineplus">+                continue;</span>
<a href="#l11.88"></a><span id="l11.88" class="difflineplus">+              }</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineplus">+            }</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineplus">+            else {</span>
<a href="#l11.91"></a><span id="l11.91" class="difflineplus">+              // need to create a new item</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineplus">+              item = document.createElementNS(&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;, &quot;richlistitem&quot;);</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineplus">+            }</span>
<a href="#l11.94"></a><span id="l11.94" class="difflineplus">+            </span>
<a href="#l11.95"></a><span id="l11.95" class="difflineplus">+            var glodaCompleter =  Components.</span>
<a href="#l11.96"></a><span id="l11.96" class="difflineplus">+              classes[&quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;].</span>
<a href="#l11.97"></a><span id="l11.97" class="difflineplus">+              getService(). //Components.interfaces.nsIAutoCompleteSearch)</span>
<a href="#l11.98"></a><span id="l11.98" class="difflineplus">+              wrappedJSObject;</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineplus">+            var result = glodaCompleter.curResult;</span>
<a href="#l11.100"></a><span id="l11.100" class="difflineplus">+</span>
<a href="#l11.101"></a><span id="l11.101" class="difflineplus">+            // set these attributes before we set the class</span>
<a href="#l11.102"></a><span id="l11.102" class="difflineplus">+            // so that we can use them from the contructor</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineplus">+            var row = result.getObjectAt(this._currentIndex);</span>
<a href="#l11.104"></a><span id="l11.104" class="difflineplus">+            var obj = row.item;</span>
<a href="#l11.105"></a><span id="l11.105" class="difflineplus">+            item.setAttribute(&quot;text&quot;, trimmedSearchString);</span>
<a href="#l11.106"></a><span id="l11.106" class="difflineplus">+            item.setAttribute(&quot;type&quot;, result.getStyleAt(this._currentIndex));</span>
<a href="#l11.107"></a><span id="l11.107" class="difflineplus">+</span>
<a href="#l11.108"></a><span id="l11.108" class="difflineplus">+            item.row = row;</span>
<a href="#l11.109"></a><span id="l11.109" class="difflineplus">+</span>
<a href="#l11.110"></a><span id="l11.110" class="difflineplus">+            if (this._currentIndex &lt; existingItemsCount) {</span>
<a href="#l11.111"></a><span id="l11.111" class="difflineplus">+              // re-use the existing item</span>
<a href="#l11.112"></a><span id="l11.112" class="difflineplus">+              item._adjustAcItem();</span>
<a href="#l11.113"></a><span id="l11.113" class="difflineplus">+              item.collapsed = false;</span>
<a href="#l11.114"></a><span id="l11.114" class="difflineplus">+            }</span>
<a href="#l11.115"></a><span id="l11.115" class="difflineplus">+            else {</span>
<a href="#l11.116"></a><span id="l11.116" class="difflineplus">+              // set the class at the end so we can use the attributes</span>
<a href="#l11.117"></a><span id="l11.117" class="difflineplus">+              // in the xbl constructor</span>
<a href="#l11.118"></a><span id="l11.118" class="difflineplus">+              item.className = &quot;autocomplete-richlistitem&quot;;</span>
<a href="#l11.119"></a><span id="l11.119" class="difflineplus">+              this.richlistbox.appendChild(item);</span>
<a href="#l11.120"></a><span id="l11.120" class="difflineplus">+            }</span>
<a href="#l11.121"></a><span id="l11.121" class="difflineplus">+</span>
<a href="#l11.122"></a><span id="l11.122" class="difflineplus">+            this._currentIndex++;</span>
<a href="#l11.123"></a><span id="l11.123" class="difflineplus">+          }</span>
<a href="#l11.124"></a><span id="l11.124" class="difflineplus">+</span>
<a href="#l11.125"></a><span id="l11.125" class="difflineplus">+          // yield after each batch of items so that typing the url bar is responsive</span>
<a href="#l11.126"></a><span id="l11.126" class="difflineplus">+          setTimeout(function (self) { self._appendCurrentResult(); }, 0, this);</span>
<a href="#l11.127"></a><span id="l11.127" class="difflineplus">+        ]]&gt;</span>
<a href="#l11.128"></a><span id="l11.128" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.129"></a><span id="l11.129" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.130"></a><span id="l11.130" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l11.131"></a><span id="l11.131" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l11.132"></a><span id="l11.132" class="difflineplus">+</span>
<a href="#l11.133"></a><span id="l11.133" class="difflineplus">+  &lt;!-- This is autocomplete.xml's autocomplete-richlistitem duplicated and</span>
<a href="#l11.134"></a><span id="l11.134" class="difflineplus">+       modified to include its useful helper functions, but eliminating anything</span>
<a href="#l11.135"></a><span id="l11.135" class="difflineplus">+       that assumes specific content sub-items.  Namely, url/title/etc.  --&gt;</span>
<a href="#l11.136"></a><span id="l11.136" class="difflineplus">+  &lt;binding id=&quot;glodacomplete-base-richlistitem&quot; extends=&quot;chrome://global/content/bindings/richlistbox.xml#richlistitem&quot;&gt;</span>
<a href="#l11.137"></a><span id="l11.137" class="difflineplus">+    &lt;implementation implements=&quot;nsIDOMXULSelectControlItemElement&quot;&gt;</span>
<a href="#l11.138"></a><span id="l11.138" class="difflineplus">+      &lt;field name=&quot;_boundaryCutoff&quot;&gt;null&lt;/field&gt;</span>
<a href="#l11.139"></a><span id="l11.139" class="difflineplus">+</span>
<a href="#l11.140"></a><span id="l11.140" class="difflineplus">+      &lt;property name=&quot;boundaryCutoff&quot; readonly=&quot;true&quot;&gt;</span>
<a href="#l11.141"></a><span id="l11.141" class="difflineplus">+        &lt;getter&gt;</span>
<a href="#l11.142"></a><span id="l11.142" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.143"></a><span id="l11.143" class="difflineplus">+          if (!this._boundaryCutoff) {</span>
<a href="#l11.144"></a><span id="l11.144" class="difflineplus">+            this._boundaryCutoff =</span>
<a href="#l11.145"></a><span id="l11.145" class="difflineplus">+              Components.classes[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l11.146"></a><span id="l11.146" class="difflineplus">+              getService(Components.interfaces.nsIPrefBranch).</span>
<a href="#l11.147"></a><span id="l11.147" class="difflineplus">+              getIntPref(&quot;toolkit.autocomplete.richBoundaryCutoff&quot;);</span>
<a href="#l11.148"></a><span id="l11.148" class="difflineplus">+          }</span>
<a href="#l11.149"></a><span id="l11.149" class="difflineplus">+          return this._boundaryCutoff;</span>
<a href="#l11.150"></a><span id="l11.150" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.151"></a><span id="l11.151" class="difflineplus">+        &lt;/getter&gt;</span>
<a href="#l11.152"></a><span id="l11.152" class="difflineplus">+      &lt;/property&gt;</span>
<a href="#l11.153"></a><span id="l11.153" class="difflineplus">+</span>
<a href="#l11.154"></a><span id="l11.154" class="difflineplus">+      &lt;method name=&quot;_getBoundaryIndices&quot;&gt;</span>
<a href="#l11.155"></a><span id="l11.155" class="difflineplus">+        &lt;parameter name=&quot;aText&quot;/&gt;</span>
<a href="#l11.156"></a><span id="l11.156" class="difflineplus">+        &lt;parameter name=&quot;aSearchTokens&quot;/&gt;</span>
<a href="#l11.157"></a><span id="l11.157" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.158"></a><span id="l11.158" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.159"></a><span id="l11.159" class="difflineplus">+          // Short circuit for empty search ([&quot;&quot;] == &quot;&quot;)</span>
<a href="#l11.160"></a><span id="l11.160" class="difflineplus">+          if (aSearchTokens == &quot;&quot;)</span>
<a href="#l11.161"></a><span id="l11.161" class="difflineplus">+            return [0, aText.length];</span>
<a href="#l11.162"></a><span id="l11.162" class="difflineplus">+</span>
<a href="#l11.163"></a><span id="l11.163" class="difflineplus">+          // Find which regions of text match the search terms</span>
<a href="#l11.164"></a><span id="l11.164" class="difflineplus">+          let regions = [];</span>
<a href="#l11.165"></a><span id="l11.165" class="difflineplus">+          for each (let search in aSearchTokens) {</span>
<a href="#l11.166"></a><span id="l11.166" class="difflineplus">+            let matchIndex;</span>
<a href="#l11.167"></a><span id="l11.167" class="difflineplus">+            let startIndex = 0;</span>
<a href="#l11.168"></a><span id="l11.168" class="difflineplus">+            let searchLen = search.length;</span>
<a href="#l11.169"></a><span id="l11.169" class="difflineplus">+</span>
<a href="#l11.170"></a><span id="l11.170" class="difflineplus">+            // Find all matches of the search terms, but stop early for perf</span>
<a href="#l11.171"></a><span id="l11.171" class="difflineplus">+            let lowerText = aText.toLowerCase().substr(0, this.boundaryCutoff);</span>
<a href="#l11.172"></a><span id="l11.172" class="difflineplus">+            while ((matchIndex = lowerText.indexOf(search, startIndex)) &gt;= 0) {</span>
<a href="#l11.173"></a><span id="l11.173" class="difflineplus">+              // Start the next search from where this one finished</span>
<a href="#l11.174"></a><span id="l11.174" class="difflineplus">+              startIndex = matchIndex + searchLen;</span>
<a href="#l11.175"></a><span id="l11.175" class="difflineplus">+              regions.push([matchIndex, startIndex]);</span>
<a href="#l11.176"></a><span id="l11.176" class="difflineplus">+            }</span>
<a href="#l11.177"></a><span id="l11.177" class="difflineplus">+          }</span>
<a href="#l11.178"></a><span id="l11.178" class="difflineplus">+</span>
<a href="#l11.179"></a><span id="l11.179" class="difflineplus">+          // Sort the regions by start position then end position</span>
<a href="#l11.180"></a><span id="l11.180" class="difflineplus">+          regions = regions.sort(function(a, b) let (start = a[0] - b[0])</span>
<a href="#l11.181"></a><span id="l11.181" class="difflineplus">+            start == 0 ? a[1] - b[1] : start);</span>
<a href="#l11.182"></a><span id="l11.182" class="difflineplus">+</span>
<a href="#l11.183"></a><span id="l11.183" class="difflineplus">+          // Generate the boundary indices from each region</span>
<a href="#l11.184"></a><span id="l11.184" class="difflineplus">+          let start = 0;</span>
<a href="#l11.185"></a><span id="l11.185" class="difflineplus">+          let end = 0;</span>
<a href="#l11.186"></a><span id="l11.186" class="difflineplus">+          let boundaries = [];</span>
<a href="#l11.187"></a><span id="l11.187" class="difflineplus">+          let len = regions.length;</span>
<a href="#l11.188"></a><span id="l11.188" class="difflineplus">+          for (let i = 0; i &lt; len; i++) {</span>
<a href="#l11.189"></a><span id="l11.189" class="difflineplus">+            // We have a new boundary if the start of the next is past the end</span>
<a href="#l11.190"></a><span id="l11.190" class="difflineplus">+            let region = regions[i];</span>
<a href="#l11.191"></a><span id="l11.191" class="difflineplus">+            if (region[0] &gt; end) {</span>
<a href="#l11.192"></a><span id="l11.192" class="difflineplus">+              // First index is the beginning of match</span>
<a href="#l11.193"></a><span id="l11.193" class="difflineplus">+              boundaries.push(start);</span>
<a href="#l11.194"></a><span id="l11.194" class="difflineplus">+              // Second index is the beginning of non-match</span>
<a href="#l11.195"></a><span id="l11.195" class="difflineplus">+              boundaries.push(end);</span>
<a href="#l11.196"></a><span id="l11.196" class="difflineplus">+</span>
<a href="#l11.197"></a><span id="l11.197" class="difflineplus">+              // Track the new region now that we've stored the previous one</span>
<a href="#l11.198"></a><span id="l11.198" class="difflineplus">+              start = region[0];</span>
<a href="#l11.199"></a><span id="l11.199" class="difflineplus">+            }</span>
<a href="#l11.200"></a><span id="l11.200" class="difflineplus">+</span>
<a href="#l11.201"></a><span id="l11.201" class="difflineplus">+            // Push back the end index for the current or new region</span>
<a href="#l11.202"></a><span id="l11.202" class="difflineplus">+            end = Math.max(end, region[1]);</span>
<a href="#l11.203"></a><span id="l11.203" class="difflineplus">+          }</span>
<a href="#l11.204"></a><span id="l11.204" class="difflineplus">+</span>
<a href="#l11.205"></a><span id="l11.205" class="difflineplus">+          // Add the last region</span>
<a href="#l11.206"></a><span id="l11.206" class="difflineplus">+          boundaries.push(start);</span>
<a href="#l11.207"></a><span id="l11.207" class="difflineplus">+          boundaries.push(end);</span>
<a href="#l11.208"></a><span id="l11.208" class="difflineplus">+</span>
<a href="#l11.209"></a><span id="l11.209" class="difflineplus">+          // Put on the end boundary if necessary</span>
<a href="#l11.210"></a><span id="l11.210" class="difflineplus">+          if (end &lt; aText.length)</span>
<a href="#l11.211"></a><span id="l11.211" class="difflineplus">+            boundaries.push(aText.length);</span>
<a href="#l11.212"></a><span id="l11.212" class="difflineplus">+</span>
<a href="#l11.213"></a><span id="l11.213" class="difflineplus">+          // Skip the first item because it's always 0</span>
<a href="#l11.214"></a><span id="l11.214" class="difflineplus">+          return boundaries.slice(1);</span>
<a href="#l11.215"></a><span id="l11.215" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.216"></a><span id="l11.216" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.217"></a><span id="l11.217" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.218"></a><span id="l11.218" class="difflineplus">+</span>
<a href="#l11.219"></a><span id="l11.219" class="difflineplus">+      &lt;method name=&quot;_getSearchTokens&quot;&gt;</span>
<a href="#l11.220"></a><span id="l11.220" class="difflineplus">+        &lt;parameter name=&quot;aSearch&quot;/&gt;</span>
<a href="#l11.221"></a><span id="l11.221" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.222"></a><span id="l11.222" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.223"></a><span id="l11.223" class="difflineplus">+          let search = aSearch.toLowerCase();</span>
<a href="#l11.224"></a><span id="l11.224" class="difflineplus">+          return search.split(/\s+/);</span>
<a href="#l11.225"></a><span id="l11.225" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.226"></a><span id="l11.226" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.227"></a><span id="l11.227" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.228"></a><span id="l11.228" class="difflineplus">+</span>
<a href="#l11.229"></a><span id="l11.229" class="difflineplus">+      &lt;method name=&quot;_needsAlternateEmphasis&quot;&gt;</span>
<a href="#l11.230"></a><span id="l11.230" class="difflineplus">+        &lt;parameter name=&quot;aText&quot;/&gt;</span>
<a href="#l11.231"></a><span id="l11.231" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.232"></a><span id="l11.232" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.233"></a><span id="l11.233" class="difflineplus">+          for (let i = aText.length; --i &gt;= 0; ) {</span>
<a href="#l11.234"></a><span id="l11.234" class="difflineplus">+            let charCode = aText.charCodeAt(i);</span>
<a href="#l11.235"></a><span id="l11.235" class="difflineplus">+            // Arabic, Syriac, Indic languages are likely to have ligatures</span>
<a href="#l11.236"></a><span id="l11.236" class="difflineplus">+            // that are broken when using the main emphasis styling</span>
<a href="#l11.237"></a><span id="l11.237" class="difflineplus">+            if (0x0600 &lt;= charCode &amp;&amp; charCode &lt;= 0x109F)</span>
<a href="#l11.238"></a><span id="l11.238" class="difflineplus">+              return true;</span>
<a href="#l11.239"></a><span id="l11.239" class="difflineplus">+          }</span>
<a href="#l11.240"></a><span id="l11.240" class="difflineplus">+</span>
<a href="#l11.241"></a><span id="l11.241" class="difflineplus">+          return false;</span>
<a href="#l11.242"></a><span id="l11.242" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.243"></a><span id="l11.243" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.244"></a><span id="l11.244" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.245"></a><span id="l11.245" class="difflineplus">+</span>
<a href="#l11.246"></a><span id="l11.246" class="difflineplus">+      &lt;method name=&quot;_setUpDescription&quot;&gt;</span>
<a href="#l11.247"></a><span id="l11.247" class="difflineplus">+        &lt;parameter name=&quot;aDescriptionElement&quot;/&gt;</span>
<a href="#l11.248"></a><span id="l11.248" class="difflineplus">+        &lt;parameter name=&quot;aText&quot;/&gt;</span>
<a href="#l11.249"></a><span id="l11.249" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.250"></a><span id="l11.250" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.251"></a><span id="l11.251" class="difflineplus">+          // Get rid of all previous text</span>
<a href="#l11.252"></a><span id="l11.252" class="difflineplus">+          while (aDescriptionElement.hasChildNodes())</span>
<a href="#l11.253"></a><span id="l11.253" class="difflineplus">+            aDescriptionElement.removeChild(aDescriptionElement.firstChild);</span>
<a href="#l11.254"></a><span id="l11.254" class="difflineplus">+</span>
<a href="#l11.255"></a><span id="l11.255" class="difflineplus">+          // Get the indices that separate match and non-match text</span>
<a href="#l11.256"></a><span id="l11.256" class="difflineplus">+          let search = this.getAttribute(&quot;text&quot;);</span>
<a href="#l11.257"></a><span id="l11.257" class="difflineplus">+          let tokens = this._getSearchTokens(search);</span>
<a href="#l11.258"></a><span id="l11.258" class="difflineplus">+          let indices = this._getBoundaryIndices(aText, tokens);</span>
<a href="#l11.259"></a><span id="l11.259" class="difflineplus">+</span>
<a href="#l11.260"></a><span id="l11.260" class="difflineplus">+          // If we're searching for something that needs alternate emphasis,</span>
<a href="#l11.261"></a><span id="l11.261" class="difflineplus">+          // we'll need to check the text that we match</span>
<a href="#l11.262"></a><span id="l11.262" class="difflineplus">+          let checkAlt = this._needsAlternateEmphasis(search);</span>
<a href="#l11.263"></a><span id="l11.263" class="difflineplus">+</span>
<a href="#l11.264"></a><span id="l11.264" class="difflineplus">+          let next;</span>
<a href="#l11.265"></a><span id="l11.265" class="difflineplus">+          let start = 0;</span>
<a href="#l11.266"></a><span id="l11.266" class="difflineplus">+          let len = indices.length;</span>
<a href="#l11.267"></a><span id="l11.267" class="difflineplus">+          // Even indexed boundaries are matches, so skip the 0th if it's empty</span>
<a href="#l11.268"></a><span id="l11.268" class="difflineplus">+          for (let i = indices[0] == 0 ? 1 : 0; i &lt; len; i++) {</span>
<a href="#l11.269"></a><span id="l11.269" class="difflineplus">+            next = indices[i];</span>
<a href="#l11.270"></a><span id="l11.270" class="difflineplus">+            let text = aText.substr(start, next - start);</span>
<a href="#l11.271"></a><span id="l11.271" class="difflineplus">+            start = next;</span>
<a href="#l11.272"></a><span id="l11.272" class="difflineplus">+</span>
<a href="#l11.273"></a><span id="l11.273" class="difflineplus">+            if (i % 2 == 0) {</span>
<a href="#l11.274"></a><span id="l11.274" class="difflineplus">+              // Emphasize the text for even indices</span>
<a href="#l11.275"></a><span id="l11.275" class="difflineplus">+              let span = aDescriptionElement.appendChild(</span>
<a href="#l11.276"></a><span id="l11.276" class="difflineplus">+                document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;span&quot;));</span>
<a href="#l11.277"></a><span id="l11.277" class="difflineplus">+              span.className = checkAlt &amp;&amp; this._needsAlternateEmphasis(text) ?</span>
<a href="#l11.278"></a><span id="l11.278" class="difflineplus">+                &quot;ac-emphasize-alt&quot; : &quot;ac-emphasize-text&quot;;</span>
<a href="#l11.279"></a><span id="l11.279" class="difflineplus">+              span.textContent = text;</span>
<a href="#l11.280"></a><span id="l11.280" class="difflineplus">+            } else {</span>
<a href="#l11.281"></a><span id="l11.281" class="difflineplus">+              // Otherwise, it's plain text</span>
<a href="#l11.282"></a><span id="l11.282" class="difflineplus">+              aDescriptionElement.appendChild(document.createTextNode(text));</span>
<a href="#l11.283"></a><span id="l11.283" class="difflineplus">+            }</span>
<a href="#l11.284"></a><span id="l11.284" class="difflineplus">+          }</span>
<a href="#l11.285"></a><span id="l11.285" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.286"></a><span id="l11.286" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.287"></a><span id="l11.287" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.288"></a><span id="l11.288" class="difflineplus">+</span>
<a href="#l11.289"></a><span id="l11.289" class="difflineplus">+      &lt;method name=&quot;_setUpOverflow&quot;&gt;</span>
<a href="#l11.290"></a><span id="l11.290" class="difflineplus">+        &lt;parameter name=&quot;aParentBox&quot;/&gt;</span>
<a href="#l11.291"></a><span id="l11.291" class="difflineplus">+        &lt;parameter name=&quot;aEllipsis&quot;/&gt;</span>
<a href="#l11.292"></a><span id="l11.292" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.293"></a><span id="l11.293" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.294"></a><span id="l11.294" class="difflineplus">+          // Hide the ellipsis incase there's just enough to not underflow</span>
<a href="#l11.295"></a><span id="l11.295" class="difflineplus">+          aEllipsis.hidden = true;</span>
<a href="#l11.296"></a><span id="l11.296" class="difflineplus">+</span>
<a href="#l11.297"></a><span id="l11.297" class="difflineplus">+          // Start with the parent's width and subtract off its children</span>
<a href="#l11.298"></a><span id="l11.298" class="difflineplus">+          let tooltip = [];</span>
<a href="#l11.299"></a><span id="l11.299" class="difflineplus">+          let children = aParentBox.childNodes;</span>
<a href="#l11.300"></a><span id="l11.300" class="difflineplus">+          let widthDiff = aParentBox.boxObject.width;</span>
<a href="#l11.301"></a><span id="l11.301" class="difflineplus">+</span>
<a href="#l11.302"></a><span id="l11.302" class="difflineplus">+          for (let i = 0; i &lt; children.length; i++) {</span>
<a href="#l11.303"></a><span id="l11.303" class="difflineplus">+            // Only consider a child if it actually takes up space</span>
<a href="#l11.304"></a><span id="l11.304" class="difflineplus">+            let childWidth = children[i].boxObject.width;</span>
<a href="#l11.305"></a><span id="l11.305" class="difflineplus">+            if (childWidth &gt; 0) {</span>
<a href="#l11.306"></a><span id="l11.306" class="difflineplus">+              // Subtract a little less to account for subpixel rounding</span>
<a href="#l11.307"></a><span id="l11.307" class="difflineplus">+              widthDiff -= childWidth - .5;</span>
<a href="#l11.308"></a><span id="l11.308" class="difflineplus">+</span>
<a href="#l11.309"></a><span id="l11.309" class="difflineplus">+              // Add to the tooltip if it's not hidden and has text</span>
<a href="#l11.310"></a><span id="l11.310" class="difflineplus">+              let childText = children[i].textContent;</span>
<a href="#l11.311"></a><span id="l11.311" class="difflineplus">+              if (childText)</span>
<a href="#l11.312"></a><span id="l11.312" class="difflineplus">+                tooltip.push(childText);</span>
<a href="#l11.313"></a><span id="l11.313" class="difflineplus">+            }</span>
<a href="#l11.314"></a><span id="l11.314" class="difflineplus">+          }</span>
<a href="#l11.315"></a><span id="l11.315" class="difflineplus">+</span>
<a href="#l11.316"></a><span id="l11.316" class="difflineplus">+          // If the children take up more space than the parent.. overflow!</span>
<a href="#l11.317"></a><span id="l11.317" class="difflineplus">+          if (widthDiff &lt; 0) {</span>
<a href="#l11.318"></a><span id="l11.318" class="difflineplus">+            // Re-show the ellipsis now that we know it's needed</span>
<a href="#l11.319"></a><span id="l11.319" class="difflineplus">+            aEllipsis.hidden = false;</span>
<a href="#l11.320"></a><span id="l11.320" class="difflineplus">+</span>
<a href="#l11.321"></a><span id="l11.321" class="difflineplus">+            // Separate text components with a ndash --</span>
<a href="#l11.322"></a><span id="l11.322" class="difflineplus">+            aParentBox.tooltipText = tooltip.join(&quot; \u2013 &quot;);</span>
<a href="#l11.323"></a><span id="l11.323" class="difflineplus">+          }</span>
<a href="#l11.324"></a><span id="l11.324" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.325"></a><span id="l11.325" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.326"></a><span id="l11.326" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.327"></a><span id="l11.327" class="difflineplus">+</span>
<a href="#l11.328"></a><span id="l11.328" class="difflineplus">+      &lt;method name=&quot;_doUnderflow&quot;&gt;</span>
<a href="#l11.329"></a><span id="l11.329" class="difflineplus">+        &lt;parameter name=&quot;aName&quot;/&gt;</span>
<a href="#l11.330"></a><span id="l11.330" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.331"></a><span id="l11.331" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.332"></a><span id="l11.332" class="difflineplus">+          // Hide the ellipsis right when we know we're underflowing instead of</span>
<a href="#l11.333"></a><span id="l11.333" class="difflineplus">+          // waiting for the timeout to trigger the _setUpOverflow calculations</span>
<a href="#l11.334"></a><span id="l11.334" class="difflineplus">+          this[aName + &quot;Box&quot;].tooltipText = &quot;&quot;;</span>
<a href="#l11.335"></a><span id="l11.335" class="difflineplus">+          this[aName + &quot;OverflowEllipsis&quot;].hidden = true;</span>
<a href="#l11.336"></a><span id="l11.336" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.337"></a><span id="l11.337" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.338"></a><span id="l11.338" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.339"></a><span id="l11.339" class="difflineplus">+</span>
<a href="#l11.340"></a><span id="l11.340" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l11.341"></a><span id="l11.341" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l11.342"></a><span id="l11.342" class="difflineplus">+</span>
<a href="#l11.343"></a><span id="l11.343" class="difflineplus">+  &lt;binding id=&quot;gloda-single-tag-item&quot; extends=&quot;chrome://gloda/content/glodacomplete.xml#glodacomplete-base-richlistitem&quot;&gt;</span>
<a href="#l11.344"></a><span id="l11.344" class="difflineplus">+    &lt;content orient=&quot;vertical&quot;&gt;</span>
<a href="#l11.345"></a><span id="l11.345" class="difflineplus">+      &lt;xul:description anonid=&quot;explanation&quot;/&gt;</span>
<a href="#l11.346"></a><span id="l11.346" class="difflineplus">+    &lt;/content&gt;</span>
<a href="#l11.347"></a><span id="l11.347" class="difflineplus">+    &lt;implementation implements=&quot;nsIDOMXULSelectControlItemElement&quot;&gt;</span>
<a href="#l11.348"></a><span id="l11.348" class="difflineplus">+      &lt;constructor&gt;</span>
<a href="#l11.349"></a><span id="l11.349" class="difflineplus">+        &lt;![CDATA[</span>
<a href="#l11.350"></a><span id="l11.350" class="difflineplus">+            this._explanation = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;explanation&quot;);</span>
<a href="#l11.351"></a><span id="l11.351" class="difflineplus">+</span>
<a href="#l11.352"></a><span id="l11.352" class="difflineplus">+            this._adjustAcItem();</span>
<a href="#l11.353"></a><span id="l11.353" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.354"></a><span id="l11.354" class="difflineplus">+      &lt;/constructor&gt;</span>
<a href="#l11.355"></a><span id="l11.355" class="difflineplus">+      </span>
<a href="#l11.356"></a><span id="l11.356" class="difflineplus">+      &lt;property name=&quot;label&quot; readonly=&quot;true&quot;&gt;</span>
<a href="#l11.357"></a><span id="l11.357" class="difflineplus">+        &lt;getter&gt;</span>
<a href="#l11.358"></a><span id="l11.358" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.359"></a><span id="l11.359" class="difflineplus">+            return &quot;tag &quot; + this.row.item.tag;</span>
<a href="#l11.360"></a><span id="l11.360" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.361"></a><span id="l11.361" class="difflineplus">+        &lt;/getter&gt;</span>
<a href="#l11.362"></a><span id="l11.362" class="difflineplus">+      &lt;/property&gt;</span>
<a href="#l11.363"></a><span id="l11.363" class="difflineplus">+      </span>
<a href="#l11.364"></a><span id="l11.364" class="difflineplus">+      &lt;method name=&quot;_adjustAcItem&quot;&gt;</span>
<a href="#l11.365"></a><span id="l11.365" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.366"></a><span id="l11.366" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.367"></a><span id="l11.367" class="difflineplus">+          this._explanation.value = &quot;messages tagged &quot; + this.row.item.tag;</span>
<a href="#l11.368"></a><span id="l11.368" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.369"></a><span id="l11.369" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.370"></a><span id="l11.370" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.371"></a><span id="l11.371" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l11.372"></a><span id="l11.372" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l11.373"></a><span id="l11.373" class="difflineplus">+</span>
<a href="#l11.374"></a><span id="l11.374" class="difflineplus">+  &lt;binding id=&quot;gloda-single-identity-item&quot; extends=&quot;chrome://gloda/content/glodacomplete.xml#glodacomplete-base-richlistitem&quot;&gt;</span>
<a href="#l11.375"></a><span id="l11.375" class="difflineplus">+    &lt;content&gt;</span>
<a href="#l11.376"></a><span id="l11.376" class="difflineplus">+      &lt;xul:hbox&gt;</span>
<a href="#l11.377"></a><span id="l11.377" class="difflineplus">+	    &lt;xul:image anonid=&quot;picture&quot;/&gt;</span>
<a href="#l11.378"></a><span id="l11.378" class="difflineplus">+	    &lt;xul:vbox&gt;</span>
<a href="#l11.379"></a><span id="l11.379" class="difflineplus">+	      &lt;xul:hbox&gt;</span>
<a href="#l11.380"></a><span id="l11.380" class="difflineplus">+	        &lt;xul:hbox anonid=&quot;name-box&quot; class=&quot;ac-title&quot; flex=&quot;1&quot;</span>
<a href="#l11.381"></a><span id="l11.381" class="difflineplus">+	                  onunderflow=&quot;_doUnderflow('_name');&quot;&gt;</span>
<a href="#l11.382"></a><span id="l11.382" class="difflineplus">+	          &lt;xul:description anonid=&quot;name&quot; class=&quot;ac-normal-text ac-comment&quot;</span>
<a href="#l11.383"></a><span id="l11.383" class="difflineplus">+	                           xbl:inherits=&quot;selected&quot;/&gt;</span>
<a href="#l11.384"></a><span id="l11.384" class="difflineplus">+	        &lt;/xul:hbox&gt;</span>
<a href="#l11.385"></a><span id="l11.385" class="difflineplus">+	        &lt;xul:label anonid=&quot;name-overflow-ellipsis&quot; xbl:inherits=&quot;selected&quot;</span>
<a href="#l11.386"></a><span id="l11.386" class="difflineplus">+	                   class=&quot;ac-ellipsis-after ac-comment&quot; hidden=&quot;true&quot;/&gt;</span>
<a href="#l11.387"></a><span id="l11.387" class="difflineplus">+	      &lt;/xul:hbox&gt;</span>
<a href="#l11.388"></a><span id="l11.388" class="difflineplus">+	      &lt;xul:hbox&gt;</span>
<a href="#l11.389"></a><span id="l11.389" class="difflineplus">+	        &lt;xul:hbox anonid=&quot;identity-box&quot; class=&quot;ac-url&quot; flex=&quot;1&quot;</span>
<a href="#l11.390"></a><span id="l11.390" class="difflineplus">+	                  onunderflow=&quot;_doUnderflow('_identity');&quot;&gt;</span>
<a href="#l11.391"></a><span id="l11.391" class="difflineplus">+	          &lt;xul:description anonid=&quot;identity&quot; class=&quot;ac-normal-text ac-url-text&quot;</span>
<a href="#l11.392"></a><span id="l11.392" class="difflineplus">+	                           xbl:inherits=&quot;selected&quot;/&gt;</span>
<a href="#l11.393"></a><span id="l11.393" class="difflineplus">+	        &lt;/xul:hbox&gt;</span>
<a href="#l11.394"></a><span id="l11.394" class="difflineplus">+	        &lt;xul:label anonid=&quot;identity-overflow-ellipsis&quot; xbl:inherits=&quot;selected&quot;</span>
<a href="#l11.395"></a><span id="l11.395" class="difflineplus">+	                   class=&quot;ac-ellipsis-after ac-url-text&quot; hidden=&quot;true&quot;/&gt;</span>
<a href="#l11.396"></a><span id="l11.396" class="difflineplus">+	        &lt;xul:image anonid=&quot;type-image&quot; class=&quot;ac-type-icon&quot;/&gt;</span>
<a href="#l11.397"></a><span id="l11.397" class="difflineplus">+	      &lt;/xul:hbox&gt;</span>
<a href="#l11.398"></a><span id="l11.398" class="difflineplus">+	    &lt;/xul:vbox&gt;</span>
<a href="#l11.399"></a><span id="l11.399" class="difflineplus">+	  &lt;/xul:hbox&gt;</span>
<a href="#l11.400"></a><span id="l11.400" class="difflineplus">+    &lt;/content&gt;</span>
<a href="#l11.401"></a><span id="l11.401" class="difflineplus">+    &lt;implementation implements=&quot;nsIDOMXULSelectControlItemElement&quot;&gt;</span>
<a href="#l11.402"></a><span id="l11.402" class="difflineplus">+      &lt;constructor&gt;</span>
<a href="#l11.403"></a><span id="l11.403" class="difflineplus">+        &lt;![CDATA[</span>
<a href="#l11.404"></a><span id="l11.404" class="difflineplus">+            let ellipsis = &quot;\u2026&quot;;</span>
<a href="#l11.405"></a><span id="l11.405" class="difflineplus">+            try {</span>
<a href="#l11.406"></a><span id="l11.406" class="difflineplus">+              ellipsis = Components.classes[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l11.407"></a><span id="l11.407" class="difflineplus">+                getService(Components.interfaces.nsIPrefBranch).</span>
<a href="#l11.408"></a><span id="l11.408" class="difflineplus">+                getComplexValue(&quot;intl.ellipsis&quot;,</span>
<a href="#l11.409"></a><span id="l11.409" class="difflineplus">+                  Components.interfaces.nsIPrefLocalizedString).data;</span>
<a href="#l11.410"></a><span id="l11.410" class="difflineplus">+            } catch (ex) {</span>
<a href="#l11.411"></a><span id="l11.411" class="difflineplus">+              // Do nothing.. we already have a default</span>
<a href="#l11.412"></a><span id="l11.412" class="difflineplus">+            }</span>
<a href="#l11.413"></a><span id="l11.413" class="difflineplus">+</span>
<a href="#l11.414"></a><span id="l11.414" class="difflineplus">+            this._identityOverflowEllipsis = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity-overflow-ellipsis&quot;);</span>
<a href="#l11.415"></a><span id="l11.415" class="difflineplus">+            this._nameOverflowEllipsis = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name-overflow-ellipsis&quot;);</span>
<a href="#l11.416"></a><span id="l11.416" class="difflineplus">+</span>
<a href="#l11.417"></a><span id="l11.417" class="difflineplus">+            this._identityOverflowEllipsis.value = ellipsis;</span>
<a href="#l11.418"></a><span id="l11.418" class="difflineplus">+            this._nameOverflowEllipsis.value = ellipsis;</span>
<a href="#l11.419"></a><span id="l11.419" class="difflineplus">+</span>
<a href="#l11.420"></a><span id="l11.420" class="difflineplus">+            this._typeImage = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;type-image&quot;);</span>
<a href="#l11.421"></a><span id="l11.421" class="difflineplus">+</span>
<a href="#l11.422"></a><span id="l11.422" class="difflineplus">+            this._identityBox = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity-box&quot;);</span>
<a href="#l11.423"></a><span id="l11.423" class="difflineplus">+            this._identity = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity&quot;);</span>
<a href="#l11.424"></a><span id="l11.424" class="difflineplus">+</span>
<a href="#l11.425"></a><span id="l11.425" class="difflineplus">+            this._nameBox = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name-box&quot;);</span>
<a href="#l11.426"></a><span id="l11.426" class="difflineplus">+            this._name = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name&quot;);</span>
<a href="#l11.427"></a><span id="l11.427" class="difflineplus">+            </span>
<a href="#l11.428"></a><span id="l11.428" class="difflineplus">+            this._picture = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;picture&quot;);</span>
<a href="#l11.429"></a><span id="l11.429" class="difflineplus">+</span>
<a href="#l11.430"></a><span id="l11.430" class="difflineplus">+            this._adjustAcItem();</span>
<a href="#l11.431"></a><span id="l11.431" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.432"></a><span id="l11.432" class="difflineplus">+      &lt;/constructor&gt;</span>
<a href="#l11.433"></a><span id="l11.433" class="difflineplus">+      </span>
<a href="#l11.434"></a><span id="l11.434" class="difflineplus">+      &lt;property name=&quot;label&quot; readonly=&quot;true&quot;&gt;</span>
<a href="#l11.435"></a><span id="l11.435" class="difflineplus">+        &lt;getter&gt;</span>
<a href="#l11.436"></a><span id="l11.436" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.437"></a><span id="l11.437" class="difflineplus">+            var identity = this.row.item;</span>
<a href="#l11.438"></a><span id="l11.438" class="difflineplus">+            return identity.accessibleLabel;</span>
<a href="#l11.439"></a><span id="l11.439" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.440"></a><span id="l11.440" class="difflineplus">+        &lt;/getter&gt;</span>
<a href="#l11.441"></a><span id="l11.441" class="difflineplus">+      &lt;/property&gt;</span>
<a href="#l11.442"></a><span id="l11.442" class="difflineplus">+      </span>
<a href="#l11.443"></a><span id="l11.443" class="difflineplus">+      &lt;method name=&quot;_adjustAcItem&quot;&gt;</span>
<a href="#l11.444"></a><span id="l11.444" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.445"></a><span id="l11.445" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.446"></a><span id="l11.446" class="difflineplus">+          var identity = this.row.item;</span>
<a href="#l11.447"></a><span id="l11.447" class="difflineplus">+          </span>
<a href="#l11.448"></a><span id="l11.448" class="difflineplus">+          if (identity == null)</span>
<a href="#l11.449"></a><span id="l11.449" class="difflineplus">+            return;</span>
<a href="#l11.450"></a><span id="l11.450" class="difflineplus">+          </span>
<a href="#l11.451"></a><span id="l11.451" class="difflineplus">+          // I guess we should get the picture size from CSS or something?</span>
<a href="#l11.452"></a><span id="l11.452" class="difflineplus">+          this._picture.src = identity.pictureURL(32);</span>
<a href="#l11.453"></a><span id="l11.453" class="difflineplus">+          </span>
<a href="#l11.454"></a><span id="l11.454" class="difflineplus">+          // Emphasize the matching search terms for the description</span>
<a href="#l11.455"></a><span id="l11.455" class="difflineplus">+          this._setUpDescription(this._name, identity.contact.name);</span>
<a href="#l11.456"></a><span id="l11.456" class="difflineplus">+          this._setUpDescription(this._identity, identity.value);</span>
<a href="#l11.457"></a><span id="l11.457" class="difflineplus">+</span>
<a href="#l11.458"></a><span id="l11.458" class="difflineplus">+          // Set up overflow on a timeout because the contents of the box</span>
<a href="#l11.459"></a><span id="l11.459" class="difflineplus">+          // might not have a width yet even though we just changed them</span>
<a href="#l11.460"></a><span id="l11.460" class="difflineplus">+          setTimeout(this._setUpOverflow, 0, this._nameBox, this._nameOverflowEllipsis);</span>
<a href="#l11.461"></a><span id="l11.461" class="difflineplus">+          setTimeout(this._setUpOverflow, 0, this._identityBox, this._identityOverflowEllipsis);</span>
<a href="#l11.462"></a><span id="l11.462" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.463"></a><span id="l11.463" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.464"></a><span id="l11.464" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.465"></a><span id="l11.465" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l11.466"></a><span id="l11.466" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l11.467"></a><span id="l11.467" class="difflineplus">+</span>
<a href="#l11.468"></a><span id="l11.468" class="difflineplus">+  &lt;binding id=&quot;gloda-contact-chunk&quot; extends=&quot;chrome://gloda/content/glodacomplete.xml#glodacomplete-base-richlistitem&quot;&gt;</span>
<a href="#l11.469"></a><span id="l11.469" class="difflineplus">+    &lt;content orient=&quot;horizontal&quot;&gt;</span>
<a href="#l11.470"></a><span id="l11.470" class="difflineplus">+      &lt;xul:image anonid=&quot;picture&quot;/&gt;</span>
<a href="#l11.471"></a><span id="l11.471" class="difflineplus">+      &lt;xul:vbox&gt;</span>
<a href="#l11.472"></a><span id="l11.472" class="difflineplus">+        &lt;xul:hbox&gt;</span>
<a href="#l11.473"></a><span id="l11.473" class="difflineplus">+          &lt;xul:hbox anonid=&quot;name-box&quot; class=&quot;ac-title&quot; flex=&quot;1&quot;</span>
<a href="#l11.474"></a><span id="l11.474" class="difflineplus">+                    onunderflow=&quot;_doUnderflow('_name');&quot;&gt;</span>
<a href="#l11.475"></a><span id="l11.475" class="difflineplus">+            &lt;xul:description anonid=&quot;name&quot; class=&quot;ac-normal-text ac-comment&quot;</span>
<a href="#l11.476"></a><span id="l11.476" class="difflineplus">+                             xbl:inherits=&quot;selected&quot;/&gt;</span>
<a href="#l11.477"></a><span id="l11.477" class="difflineplus">+          &lt;/xul:hbox&gt;</span>
<a href="#l11.478"></a><span id="l11.478" class="difflineplus">+          &lt;xul:label anonid=&quot;name-overflow-ellipsis&quot; xbl:inherits=&quot;selected&quot;</span>
<a href="#l11.479"></a><span id="l11.479" class="difflineplus">+                     class=&quot;ac-ellipsis-after ac-comment&quot; hidden=&quot;true&quot;/&gt;</span>
<a href="#l11.480"></a><span id="l11.480" class="difflineplus">+        &lt;/xul:hbox&gt;</span>
<a href="#l11.481"></a><span id="l11.481" class="difflineplus">+        &lt;xul:hbox&gt;</span>
<a href="#l11.482"></a><span id="l11.482" class="difflineplus">+          &lt;xul:hbox anonid=&quot;identity-box&quot; class=&quot;ac-url&quot; flex=&quot;1&quot;</span>
<a href="#l11.483"></a><span id="l11.483" class="difflineplus">+                    onunderflow=&quot;_doUnderflow('_identity');&quot;&gt;</span>
<a href="#l11.484"></a><span id="l11.484" class="difflineplus">+            &lt;xul:description anonid=&quot;identity&quot; class=&quot;ac-normal-text ac-url-text&quot;</span>
<a href="#l11.485"></a><span id="l11.485" class="difflineplus">+                             xbl:inherits=&quot;selected&quot;/&gt;</span>
<a href="#l11.486"></a><span id="l11.486" class="difflineplus">+          &lt;/xul:hbox&gt;</span>
<a href="#l11.487"></a><span id="l11.487" class="difflineplus">+          &lt;xul:label anonid=&quot;identity-overflow-ellipsis&quot; xbl:inherits=&quot;selected&quot;</span>
<a href="#l11.488"></a><span id="l11.488" class="difflineplus">+                     class=&quot;ac-ellipsis-after ac-url-text&quot; hidden=&quot;true&quot;/&gt;</span>
<a href="#l11.489"></a><span id="l11.489" class="difflineplus">+          &lt;xul:image anonid=&quot;type-image&quot; class=&quot;ac-type-icon&quot;/&gt;</span>
<a href="#l11.490"></a><span id="l11.490" class="difflineplus">+        &lt;/xul:hbox&gt;</span>
<a href="#l11.491"></a><span id="l11.491" class="difflineplus">+      &lt;/xul:vbox&gt;</span>
<a href="#l11.492"></a><span id="l11.492" class="difflineplus">+    &lt;/content&gt;</span>
<a href="#l11.493"></a><span id="l11.493" class="difflineplus">+    &lt;implementation&gt;</span>
<a href="#l11.494"></a><span id="l11.494" class="difflineplus">+      &lt;constructor&gt;</span>
<a href="#l11.495"></a><span id="l11.495" class="difflineplus">+        &lt;![CDATA[</span>
<a href="#l11.496"></a><span id="l11.496" class="difflineplus">+            let ellipsis = &quot;\u2026&quot;;</span>
<a href="#l11.497"></a><span id="l11.497" class="difflineplus">+            try {</span>
<a href="#l11.498"></a><span id="l11.498" class="difflineplus">+              ellipsis = Components.classes[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l11.499"></a><span id="l11.499" class="difflineplus">+                getService(Components.interfaces.nsIPrefBranch).</span>
<a href="#l11.500"></a><span id="l11.500" class="difflineplus">+                getComplexValue(&quot;intl.ellipsis&quot;,</span>
<a href="#l11.501"></a><span id="l11.501" class="difflineplus">+                  Components.interfaces.nsIPrefLocalizedString).data;</span>
<a href="#l11.502"></a><span id="l11.502" class="difflineplus">+            } catch (ex) {</span>
<a href="#l11.503"></a><span id="l11.503" class="difflineplus">+              // Do nothing.. we already have a default</span>
<a href="#l11.504"></a><span id="l11.504" class="difflineplus">+            }</span>
<a href="#l11.505"></a><span id="l11.505" class="difflineplus">+</span>
<a href="#l11.506"></a><span id="l11.506" class="difflineplus">+            this._identityOverflowEllipsis = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity-overflow-ellipsis&quot;);</span>
<a href="#l11.507"></a><span id="l11.507" class="difflineplus">+            this._nameOverflowEllipsis = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name-overflow-ellipsis&quot;);</span>
<a href="#l11.508"></a><span id="l11.508" class="difflineplus">+</span>
<a href="#l11.509"></a><span id="l11.509" class="difflineplus">+            this._identityOverflowEllipsis.value = ellipsis;</span>
<a href="#l11.510"></a><span id="l11.510" class="difflineplus">+            this._nameOverflowEllipsis.value = ellipsis;</span>
<a href="#l11.511"></a><span id="l11.511" class="difflineplus">+</span>
<a href="#l11.512"></a><span id="l11.512" class="difflineplus">+            this._typeImage = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;type-image&quot;);</span>
<a href="#l11.513"></a><span id="l11.513" class="difflineplus">+</span>
<a href="#l11.514"></a><span id="l11.514" class="difflineplus">+            this._identityBox = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity-box&quot;);</span>
<a href="#l11.515"></a><span id="l11.515" class="difflineplus">+            this._identity = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity&quot;);</span>
<a href="#l11.516"></a><span id="l11.516" class="difflineplus">+</span>
<a href="#l11.517"></a><span id="l11.517" class="difflineplus">+            this._nameBox = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name-box&quot;);</span>
<a href="#l11.518"></a><span id="l11.518" class="difflineplus">+            this._name = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name&quot;);</span>
<a href="#l11.519"></a><span id="l11.519" class="difflineplus">+            </span>
<a href="#l11.520"></a><span id="l11.520" class="difflineplus">+            this._picture = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;picture&quot;);</span>
<a href="#l11.521"></a><span id="l11.521" class="difflineplus">+</span>
<a href="#l11.522"></a><span id="l11.522" class="difflineplus">+            this._adjustAcItem();</span>
<a href="#l11.523"></a><span id="l11.523" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.524"></a><span id="l11.524" class="difflineplus">+      &lt;/constructor&gt;</span>
<a href="#l11.525"></a><span id="l11.525" class="difflineplus">+      </span>
<a href="#l11.526"></a><span id="l11.526" class="difflineplus">+      &lt;property name=&quot;label&quot; readonly=&quot;true&quot;&gt;</span>
<a href="#l11.527"></a><span id="l11.527" class="difflineplus">+        &lt;getter&gt;</span>
<a href="#l11.528"></a><span id="l11.528" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.529"></a><span id="l11.529" class="difflineplus">+            var identity = this.obj;</span>
<a href="#l11.530"></a><span id="l11.530" class="difflineplus">+            return identity.accessibleLabel;</span>
<a href="#l11.531"></a><span id="l11.531" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.532"></a><span id="l11.532" class="difflineplus">+        &lt;/getter&gt;</span>
<a href="#l11.533"></a><span id="l11.533" class="difflineplus">+      &lt;/property&gt;</span>
<a href="#l11.534"></a><span id="l11.534" class="difflineplus">+      </span>
<a href="#l11.535"></a><span id="l11.535" class="difflineplus">+      &lt;method name=&quot;_adjustAcItem&quot;&gt;</span>
<a href="#l11.536"></a><span id="l11.536" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.537"></a><span id="l11.537" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.538"></a><span id="l11.538" class="difflineplus">+          var contact = this.obj;</span>
<a href="#l11.539"></a><span id="l11.539" class="difflineplus">+          </span>
<a href="#l11.540"></a><span id="l11.540" class="difflineplus">+          if (contact == null)</span>
<a href="#l11.541"></a><span id="l11.541" class="difflineplus">+            return;</span>
<a href="#l11.542"></a><span id="l11.542" class="difflineplus">+          </span>
<a href="#l11.543"></a><span id="l11.543" class="difflineplus">+          var identity = contact.identities[0];</span>
<a href="#l11.544"></a><span id="l11.544" class="difflineplus">+          </span>
<a href="#l11.545"></a><span id="l11.545" class="difflineplus">+          // I guess we should get the picture size from CSS or something?</span>
<a href="#l11.546"></a><span id="l11.546" class="difflineplus">+          this._picture.src = identity.pictureURL(32);</span>
<a href="#l11.547"></a><span id="l11.547" class="difflineplus">+          </span>
<a href="#l11.548"></a><span id="l11.548" class="difflineplus">+          // Emphasize the matching search terms for the description</span>
<a href="#l11.549"></a><span id="l11.549" class="difflineplus">+          this._setUpDescription(this._name, contact.name);</span>
<a href="#l11.550"></a><span id="l11.550" class="difflineplus">+          this._setUpDescription(this._identity, identity.value);</span>
<a href="#l11.551"></a><span id="l11.551" class="difflineplus">+</span>
<a href="#l11.552"></a><span id="l11.552" class="difflineplus">+          // Set up overflow on a timeout because the contents of the box</span>
<a href="#l11.553"></a><span id="l11.553" class="difflineplus">+          // might not have a width yet even though we just changed them</span>
<a href="#l11.554"></a><span id="l11.554" class="difflineplus">+          setTimeout(this._setUpOverflow, 0, this._nameBox, this._nameOverflowEllipsis);</span>
<a href="#l11.555"></a><span id="l11.555" class="difflineplus">+          setTimeout(this._setUpOverflow, 0, this._identityBox, this._identityOverflowEllipsis);</span>
<a href="#l11.556"></a><span id="l11.556" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.557"></a><span id="l11.557" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.558"></a><span id="l11.558" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.559"></a><span id="l11.559" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l11.560"></a><span id="l11.560" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l11.561"></a><span id="l11.561" class="difflineplus">+</span>
<a href="#l11.562"></a><span id="l11.562" class="difflineplus">+  &lt;binding id=&quot;gloda-multi-item&quot; extends=&quot;chrome://gloda/content/glodacomplete.xml#glodacomplete-base-richlistitem&quot;&gt;</span>
<a href="#l11.563"></a><span id="l11.563" class="difflineplus">+    &lt;content orient=&quot;vertical&quot;&gt;</span>
<a href="#l11.564"></a><span id="l11.564" class="difflineplus">+      &lt;xul:description anonid=&quot;explanation&quot;/&gt;</span>
<a href="#l11.565"></a><span id="l11.565" class="difflineplus">+      &lt;xul:hbox anonid=&quot;identity-holder&quot; flex=&quot;1&quot;&gt;</span>
<a href="#l11.566"></a><span id="l11.566" class="difflineplus">+      &lt;/xul:hbox&gt;</span>
<a href="#l11.567"></a><span id="l11.567" class="difflineplus">+    &lt;/content&gt;</span>
<a href="#l11.568"></a><span id="l11.568" class="difflineplus">+    &lt;implementation implements=&quot;nsIDOMXULSelectControlItemElement&quot;&gt;</span>
<a href="#l11.569"></a><span id="l11.569" class="difflineplus">+      &lt;constructor&gt;</span>
<a href="#l11.570"></a><span id="l11.570" class="difflineplus">+        &lt;![CDATA[</span>
<a href="#l11.571"></a><span id="l11.571" class="difflineplus">+            this._explanation = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;explanation&quot;);</span>
<a href="#l11.572"></a><span id="l11.572" class="difflineplus">+            this._identityHolder = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity-holder&quot;);</span>
<a href="#l11.573"></a><span id="l11.573" class="difflineplus">+</span>
<a href="#l11.574"></a><span id="l11.574" class="difflineplus">+            this._adjustAcItem();</span>
<a href="#l11.575"></a><span id="l11.575" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.576"></a><span id="l11.576" class="difflineplus">+      &lt;/constructor&gt;</span>
<a href="#l11.577"></a><span id="l11.577" class="difflineplus">+      </span>
<a href="#l11.578"></a><span id="l11.578" class="difflineplus">+      &lt;property name=&quot;label&quot; readonly=&quot;true&quot;&gt;</span>
<a href="#l11.579"></a><span id="l11.579" class="difflineplus">+        &lt;getter&gt;</span>
<a href="#l11.580"></a><span id="l11.580" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.581"></a><span id="l11.581" class="difflineplus">+            return this._explanation.value;</span>
<a href="#l11.582"></a><span id="l11.582" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.583"></a><span id="l11.583" class="difflineplus">+        &lt;/getter&gt;</span>
<a href="#l11.584"></a><span id="l11.584" class="difflineplus">+      &lt;/property&gt;</span>
<a href="#l11.585"></a><span id="l11.585" class="difflineplus">+      </span>
<a href="#l11.586"></a><span id="l11.586" class="difflineplus">+      &lt;method name=&quot;renderItem&quot;&gt;</span>
<a href="#l11.587"></a><span id="l11.587" class="difflineplus">+        &lt;parameter name=&quot;aObj&quot;/&gt;</span>
<a href="#l11.588"></a><span id="l11.588" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.589"></a><span id="l11.589" class="difflineplus">+          var node = document.createElementNS(</span>
<a href="#l11.590"></a><span id="l11.590" class="difflineplus">+            &quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;,</span>
<a href="#l11.591"></a><span id="l11.591" class="difflineplus">+            &quot;richlistitem&quot;);</span>
<a href="#l11.592"></a><span id="l11.592" class="difflineplus">+          </span>
<a href="#l11.593"></a><span id="l11.593" class="difflineplus">+          node.obj = aObj;</span>
<a href="#l11.594"></a><span id="l11.594" class="difflineplus">+          node.setAttribute(&quot;type&quot;,</span>
<a href="#l11.595"></a><span id="l11.595" class="difflineplus">+                            &quot;gloda-&quot; + this.row.nounDef.name + &quot;-chunk&quot;);</span>
<a href="#l11.596"></a><span id="l11.596" class="difflineplus">+          </span>
<a href="#l11.597"></a><span id="l11.597" class="difflineplus">+          this._identityHolder.appendChild(node);</span>
<a href="#l11.598"></a><span id="l11.598" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.599"></a><span id="l11.599" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.600"></a><span id="l11.600" class="difflineplus">+      </span>
<a href="#l11.601"></a><span id="l11.601" class="difflineplus">+      &lt;method name=&quot;_adjustAcItem&quot;&gt;</span>
<a href="#l11.602"></a><span id="l11.602" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l11.603"></a><span id="l11.603" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l11.604"></a><span id="l11.604" class="difflineplus">+          // clear out any lingering children</span>
<a href="#l11.605"></a><span id="l11.605" class="difflineplus">+          while (this._identityHolder.hasChildNodes())</span>
<a href="#l11.606"></a><span id="l11.606" class="difflineplus">+            this._identityHolder.removeChild(this._identityHolder.firstChild);</span>
<a href="#l11.607"></a><span id="l11.607" class="difflineplus">+          </span>
<a href="#l11.608"></a><span id="l11.608" class="difflineplus">+          var row = this.row;</span>
<a href="#l11.609"></a><span id="l11.609" class="difflineplus">+          if (row == null)</span>
<a href="#l11.610"></a><span id="l11.610" class="difflineplus">+            return;</span>
<a href="#l11.611"></a><span id="l11.611" class="difflineplus">+          </span>
<a href="#l11.612"></a><span id="l11.612" class="difflineplus">+          this._explanation.value = row.nounDef.name + &quot;s &quot; +</span>
<a href="#l11.613"></a><span id="l11.613" class="difflineplus">+            row.criteriaType + &quot;ed &quot; + row.criteria;</span>
<a href="#l11.614"></a><span id="l11.614" class="difflineplus">+          </span>
<a href="#l11.615"></a><span id="l11.615" class="difflineplus">+          // render anyone already in there</span>
<a href="#l11.616"></a><span id="l11.616" class="difflineplus">+          for each (let item in row.collection.items) {</span>
<a href="#l11.617"></a><span id="l11.617" class="difflineplus">+            this.renderItem(item);</span>
<a href="#l11.618"></a><span id="l11.618" class="difflineplus">+          }</span>
<a href="#l11.619"></a><span id="l11.619" class="difflineplus">+          // listen up, yo.</span>
<a href="#l11.620"></a><span id="l11.620" class="difflineplus">+          row.renderer = this;</span>
<a href="#l11.621"></a><span id="l11.621" class="difflineplus">+          ]]&gt;</span>
<a href="#l11.622"></a><span id="l11.622" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l11.623"></a><span id="l11.623" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l11.624"></a><span id="l11.624" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l11.625"></a><span id="l11.625" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l11.626"></a><span id="l11.626" class="difflineplus">+</span>
<a href="#l11.627"></a><span id="l11.627" class="difflineplus">+</span>
<a href="#l11.628"></a><span id="l11.628" class="difflineplus">+&lt;/bindings&gt;</span>
<a href="#l11.629"></a><span id="l11.629">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1">new file mode 100644</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineminus">--- /dev/null</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineplus">+++ b/mailnews/db/gloda/content/options.xul</span>
<a href="#l12.4"></a><span id="l12.4" class="difflineat">@@ -0,0 +1,52 @@</span>
<a href="#l12.5"></a><span id="l12.5" class="difflineplus">+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<a href="#l12.6"></a><span id="l12.6" class="difflineplus">+&lt;!-- ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l12.7"></a><span id="l12.7" class="difflineplus">+  -   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l12.8"></a><span id="l12.8" class="difflineplus">+  -</span>
<a href="#l12.9"></a><span id="l12.9" class="difflineplus">+  - The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l12.10"></a><span id="l12.10" class="difflineplus">+  - 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l12.11"></a><span id="l12.11" class="difflineplus">+  - the License. You may obtain a copy of the License at</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+  - http://www.mozilla.org/MPL/</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+  - </span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+  - Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+  - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+  - for the specific language governing rights and limitations under the</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineplus">+  - License.</span>
<a href="#l12.18"></a><span id="l12.18" class="difflineplus">+  -</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+  - The Original Code is Thunderbird Global Database.</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineplus">+  -</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+  - The Initial Developer of the Original Code is</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+  - Mozilla Messaging, Inc.</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineplus">+  - Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineplus">+  - the Initial Developer. All Rights Reserved.</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+  -</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineplus">+  - Contributor(s):</span>
<a href="#l12.27"></a><span id="l12.27" class="difflineplus">+  -   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+  -</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineplus">+  - Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+  - either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+  - the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+  - in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+  - of those above. If you wish to allow use of your version of this file only</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+  - under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+  - use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+  - decision by deleting the provisions above and replace them with the notice</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+  - and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+  - the provisions above, a recipient may use your version of this file under</span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+  - the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineplus">+  - </span>
<a href="#l12.41"></a><span id="l12.41" class="difflineplus">+  - ***** END LICENSE BLOCK ***** --&gt;</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineplus">+</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineplus">+&lt;?xml-stylesheet href=&quot;chrome://global/skin/&quot; type=&quot;text/css&quot;?&gt;</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+&lt;!DOCTYPE prefwindow SYSTEM &quot;chrome://gloda/locale/prefwindow.dtd&quot;&gt;</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineplus">+&lt;prefwindow id=&quot;glodaPreferences&quot; xmlns=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot; title=&quot;&amp;prefwindow.title;&quot;&gt;</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineplus">+  &lt;prefpane id=&quot;pane1&quot; label=&quot;&amp;pane1.title;&quot;&gt;</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineplus">+    &lt;preferences&gt;</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+      &lt;preference id=&quot;boolpref1&quot; name=&quot;extensions.gloda.boolpref&quot; type=&quot;bool&quot;/&gt;</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineplus">+      &lt;preference id=&quot;intpref1&quot; name=&quot;extensions.gloda.intpref&quot; type=&quot;int&quot;/&gt;</span>
<a href="#l12.50"></a><span id="l12.50" class="difflineplus">+      &lt;preference id=&quot;stringpref1&quot; name=&quot;extensions.gloda.stringpref&quot; type=&quot;string&quot;/&gt; &lt;!-- note that this is only an ASCII string - use unichar for unicode strings --&gt;</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineplus">+    &lt;/preferences&gt;</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+    &lt;checkbox id=&quot;checkboolpref&quot; preference=&quot;boolpref1&quot; label=&quot;&amp;checkboolpref.label;&quot; accesskey=&quot;&amp;checkboolpref.accesskey;&quot;/&gt;</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+    &lt;label accesskey=&quot;&amp;intpref.accesskey;&quot; control=&quot;textintpref&quot;&gt;&amp;intpref.label;&lt;/label&gt;&lt;textbox id=&quot;textintpref&quot; preference=&quot;intpref1&quot;/&gt;</span>
<a href="#l12.54"></a><span id="l12.54" class="difflineplus">+    &lt;label accesskey=&quot;&amp;stringpref.accesskey;&quot; control=&quot;textstringpref&quot;&gt;&amp;stringpref.label;&lt;/label&gt;&lt;textbox id=&quot;textstringpref&quot; preference=&quot;stringpref1&quot;/&gt;</span>
<a href="#l12.55"></a><span id="l12.55" class="difflineplus">+  &lt;/prefpane&gt;</span>
<a href="#l12.56"></a><span id="l12.56" class="difflineplus">+&lt;/prefwindow&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1">new file mode 100644</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineminus">--- /dev/null</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineplus">+++ b/mailnews/db/gloda/content/overlay.js</span>
<a href="#l13.4"></a><span id="l13.4" class="difflineat">@@ -0,0 +1,68 @@</span>
<a href="#l13.5"></a><span id="l13.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l13.6"></a><span id="l13.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l13.7"></a><span id="l13.7" class="difflineplus">+ *</span>
<a href="#l13.8"></a><span id="l13.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l13.9"></a><span id="l13.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l13.10"></a><span id="l13.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l13.11"></a><span id="l13.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+ * </span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+ * License.</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+ *</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+ *</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineplus">+ *</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l13.26"></a><span id="l13.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineplus">+ *</span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l13.29"></a><span id="l13.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l13.30"></a><span id="l13.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l13.33"></a><span id="l13.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineplus">+ * </span>
<a href="#l13.40"></a><span id="l13.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+</span>
<a href="#l13.42"></a><span id="l13.42" class="difflineplus">+// get the core</span>
<a href="#l13.43"></a><span id="l13.43" class="difflineplus">+Components.utils.import(&quot;resource://gloda/modules/public.js&quot;);</span>
<a href="#l13.44"></a><span id="l13.44" class="difflineplus">+</span>
<a href="#l13.45"></a><span id="l13.45" class="difflineplus">+var gloda = {</span>
<a href="#l13.46"></a><span id="l13.46" class="difflineplus">+  _mimeMsg: {},</span>
<a href="#l13.47"></a><span id="l13.47" class="difflineplus">+  </span>
<a href="#l13.48"></a><span id="l13.48" class="difflineplus">+  onLoad: function() {</span>
<a href="#l13.49"></a><span id="l13.49" class="difflineplus">+    // initialization code</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineplus">+    this.initialized = true;</span>
<a href="#l13.51"></a><span id="l13.51" class="difflineplus">+    this.strings = document.getElementById(&quot;gloda-strings&quot;);</span>
<a href="#l13.52"></a><span id="l13.52" class="difflineplus">+  },</span>
<a href="#l13.53"></a><span id="l13.53" class="difflineplus">+  onIndexEverythingCommand: function(e) {</span>
<a href="#l13.54"></a><span id="l13.54" class="difflineplus">+    GlodaIndexer.indexEverything();</span>
<a href="#l13.55"></a><span id="l13.55" class="difflineplus">+  },</span>
<a href="#l13.56"></a><span id="l13.56" class="difflineplus">+  onIndexAddressBookCommand: function(e) {</span>
<a href="#l13.57"></a><span id="l13.57" class="difflineplus">+    // TODO support address-book indexing or something.</span>
<a href="#l13.58"></a><span id="l13.58" class="difflineplus">+  },  </span>
<a href="#l13.59"></a><span id="l13.59" class="difflineplus">+  indexSelectedMessages: function () {</span>
<a href="#l13.60"></a><span id="l13.60" class="difflineplus">+    var dbView = GetDBView();</span>
<a href="#l13.61"></a><span id="l13.61" class="difflineplus">+    var indices = GetSelectedIndices(dbView);</span>
<a href="#l13.62"></a><span id="l13.62" class="difflineplus">+    var toindex = [];</span>
<a href="#l13.63"></a><span id="l13.63" class="difflineplus">+    for (var iIndex=0; iIndex &lt; indices.length; iIndex++) {</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineplus">+      var actualIndex = indices[iIndex];</span>
<a href="#l13.65"></a><span id="l13.65" class="difflineplus">+      var folder = dbView.getFolderForViewIndex(actualIndex);</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineplus">+      var msgKey = dbView.getKeyAt(actualIndex);</span>
<a href="#l13.67"></a><span id="l13.67" class="difflineplus">+      toindex.push([folder, msgKey]);</span>
<a href="#l13.68"></a><span id="l13.68" class="difflineplus">+    }</span>
<a href="#l13.69"></a><span id="l13.69" class="difflineplus">+    GlodaIndexer.indexMessages(toindex);</span>
<a href="#l13.70"></a><span id="l13.70" class="difflineplus">+  },</span>
<a href="#l13.71"></a><span id="l13.71" class="difflineplus">+};</span>
<a href="#l13.72"></a><span id="l13.72" class="difflineplus">+window.addEventListener(&quot;load&quot;, function(e) { gloda.onLoad(e); }, false);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1">new file mode 100644</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineminus">--- /dev/null</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineplus">+++ b/mailnews/db/gloda/content/thunderbirdOverlay.xul</span>
<a href="#l14.4"></a><span id="l14.4" class="difflineat">@@ -0,0 +1,70 @@</span>
<a href="#l14.5"></a><span id="l14.5" class="difflineplus">+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<a href="#l14.6"></a><span id="l14.6" class="difflineplus">+&lt;!-- ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l14.7"></a><span id="l14.7" class="difflineplus">+  -   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l14.8"></a><span id="l14.8" class="difflineplus">+  -</span>
<a href="#l14.9"></a><span id="l14.9" class="difflineplus">+  - The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l14.10"></a><span id="l14.10" class="difflineplus">+  - 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l14.11"></a><span id="l14.11" class="difflineplus">+  - the License. You may obtain a copy of the License at</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+  - http://www.mozilla.org/MPL/</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+  - </span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+  - Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+  - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+  - for the specific language governing rights and limitations under the</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+  - License.</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+  -</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+  - The Original Code is Thunderbird Global Database.</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+  -</span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+  - The Initial Developer of the Original Code is</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+  - Mozilla Messaging, Inc.</span>
<a href="#l14.23"></a><span id="l14.23" class="difflineplus">+  - Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+  - the Initial Developer. All Rights Reserved.</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+  -</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+  - Contributor(s):</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+  -   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+  -</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+  - Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+  - either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+  - the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+  - in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+  - of those above. If you wish to allow use of your version of this file only</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+  - under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineplus">+  - use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineplus">+  - decision by deleting the provisions above and replace them with the notice</span>
<a href="#l14.37"></a><span id="l14.37" class="difflineplus">+  - and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l14.38"></a><span id="l14.38" class="difflineplus">+  - the provisions above, a recipient may use your version of this file under</span>
<a href="#l14.39"></a><span id="l14.39" class="difflineplus">+  - the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l14.40"></a><span id="l14.40" class="difflineplus">+  - </span>
<a href="#l14.41"></a><span id="l14.41" class="difflineplus">+  - ***** END LICENSE BLOCK ***** --&gt;</span>
<a href="#l14.42"></a><span id="l14.42" class="difflineplus">+</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineplus">+&lt;!DOCTYPE overlay SYSTEM &quot;chrome://gloda/locale/gloda.dtd&quot;&gt;</span>
<a href="#l14.44"></a><span id="l14.44" class="difflineplus">+&lt;overlay id=&quot;gloda-overlay&quot;</span>
<a href="#l14.45"></a><span id="l14.45" class="difflineplus">+         xmlns=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;&gt;</span>
<a href="#l14.46"></a><span id="l14.46" class="difflineplus">+  &lt;script src=&quot;overlay.js&quot;/&gt;</span>
<a href="#l14.47"></a><span id="l14.47" class="difflineplus">+  &lt;stringbundleset id=&quot;stringbundleset&quot;&gt;</span>
<a href="#l14.48"></a><span id="l14.48" class="difflineplus">+    &lt;stringbundle id=&quot;gloda-strings&quot; src=&quot;chrome://gloda/locale/gloda.properties&quot;/&gt;</span>
<a href="#l14.49"></a><span id="l14.49" class="difflineplus">+  &lt;/stringbundleset&gt;</span>
<a href="#l14.50"></a><span id="l14.50" class="difflineplus">+</span>
<a href="#l14.51"></a><span id="l14.51" class="difflineplus">+  &lt;menupopup id=&quot;taskPopup&quot;&gt;</span>
<a href="#l14.52"></a><span id="l14.52" class="difflineplus">+    &lt;menuitem id=&quot;gloda-hello&quot; label=&quot;&amp;glodaIndexEverything.label;&quot; </span>
<a href="#l14.53"></a><span id="l14.53" class="difflineplus">+              oncommand=&quot;gloda.onIndexEverythingCommand(event);&quot;/&gt;</span>
<a href="#l14.54"></a><span id="l14.54" class="difflineplus">+    &lt;menuitem id=&quot;gloda-hello&quot; label=&quot;&amp;glodaIndexAddressBook.label;&quot; </span>
<a href="#l14.55"></a><span id="l14.55" class="difflineplus">+              oncommand=&quot;gloda.onIndexAddressBookCommand(event);&quot;/&gt;</span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+  &lt;/menupopup&gt;</span>
<a href="#l14.57"></a><span id="l14.57" class="difflineplus">+  </span>
<a href="#l14.58"></a><span id="l14.58" class="difflineplus">+  &lt;popup id=&quot;folderPaneContext&quot;&gt;</span>
<a href="#l14.59"></a><span id="l14.59" class="difflineplus">+    &lt;menuseparator id=&quot;folderPaneContext-sep-gloda&quot;/&gt;</span>
<a href="#l14.60"></a><span id="l14.60" class="difflineplus">+    &lt;menuitem id=&quot;folderPaneContext-gloda-index&quot;</span>
<a href="#l14.61"></a><span id="l14.61" class="difflineplus">+              label=&quot;&amp;folderContextGlodaIndex.label;&quot;</span>
<a href="#l14.62"></a><span id="l14.62" class="difflineplus">+              accesskey=&quot;&amp;folderContextGlodaIndex.accesskey;&quot;</span>
<a href="#l14.63"></a><span id="l14.63" class="difflineplus">+              oncommand=&quot;GlodaIndexer.indexFolderByURI(GetSelectedFolderURI());&quot;/&gt;</span>
<a href="#l14.64"></a><span id="l14.64" class="difflineplus">+  &lt;/popup&gt;</span>
<a href="#l14.65"></a><span id="l14.65" class="difflineplus">+</span>
<a href="#l14.66"></a><span id="l14.66" class="difflineplus">+  &lt;popup id=&quot;threadPaneContext&quot;&gt;</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineplus">+    &lt;menuseparator id=&quot;threadPaneContext-sep-gloda&quot;/&gt;</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineplus">+    &lt;menuitem id=&quot;threadPaneContext-gloda-index&quot;</span>
<a href="#l14.69"></a><span id="l14.69" class="difflineplus">+              label=&quot;&amp;threadContextGlodaIndex.label;&quot;</span>
<a href="#l14.70"></a><span id="l14.70" class="difflineplus">+              accesskey=&quot;&amp;threadContextGlodaIndex.accesskey;&quot;</span>
<a href="#l14.71"></a><span id="l14.71" class="difflineplus">+              oncommand=&quot;gloda.indexSelectedMessages();&quot;/&gt;</span>
<a href="#l14.72"></a><span id="l14.72" class="difflineplus">+  &lt;/popup&gt;</span>
<a href="#l14.73"></a><span id="l14.73" class="difflineplus">+</span>
<a href="#l14.74"></a><span id="l14.74" class="difflineplus">+&lt;/overlay&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineminus">--- /dev/null</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineplus">+++ b/mailnews/db/gloda/defaults/preferences/gloda.js</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineat">@@ -0,0 +1,5 @@</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+pref(&quot;extensions.gloda.boolpref&quot;, false);</span>
<a href="#l15.6"></a><span id="l15.6" class="difflineplus">+pref(&quot;extensions.gloda.intpref&quot;, 0);</span>
<a href="#l15.7"></a><span id="l15.7" class="difflineplus">+pref(&quot;extensions.gloda.stringpref&quot;, &quot;A string&quot;);</span>
<a href="#l15.8"></a><span id="l15.8" class="difflineplus">+// See http://kb.mozillazine.org/Localize_extension_descriptions</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+pref(&quot;extensions.gloda@mozillamessaging.com.description&quot;, &quot;chrome://gloda/locale/gloda.properties&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1">new file mode 100644</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineminus">--- /dev/null</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineplus">+++ b/mailnews/db/gloda/install.rdf</span>
<a href="#l16.4"></a><span id="l16.4" class="difflineat">@@ -0,0 +1,20 @@</span>
<a href="#l16.5"></a><span id="l16.5" class="difflineplus">+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<a href="#l16.6"></a><span id="l16.6" class="difflineplus">+&lt;RDF xmlns=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; </span>
<a href="#l16.7"></a><span id="l16.7" class="difflineplus">+ xmlns:em=&quot;http://www.mozilla.org/2004/em-rdf#&quot;&gt;</span>
<a href="#l16.8"></a><span id="l16.8" class="difflineplus">+  &lt;Description about=&quot;urn:mozilla:install-manifest&quot;&gt;</span>
<a href="#l16.9"></a><span id="l16.9" class="difflineplus">+    &lt;em:id&gt;gloda@mozillamessaging.com&lt;/em:id&gt;</span>
<a href="#l16.10"></a><span id="l16.10" class="difflineplus">+    &lt;em:name&gt;Global Database&lt;/em:name&gt;</span>
<a href="#l16.11"></a><span id="l16.11" class="difflineplus">+    &lt;em:version&gt;0.0.1&lt;/em:version&gt;</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+    &lt;em:creator&gt;Mozilla Messaging, Inc.&lt;/em:creator&gt;</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+    &lt;em:contributor&gt;Andrew Sutherland &amp;lt;asutherland@asutherland.org&amp;gt;&lt;/em:contributor&gt;</span>
<a href="#l16.14"></a><span id="l16.14" class="difflineplus">+    &lt;em:description&gt;Adds a global database to Thunderbird&lt;/em:description&gt;</span>
<a href="#l16.15"></a><span id="l16.15" class="difflineplus">+    &lt;em:optionsURL&gt;chrome://gloda/content/options.xul&lt;/em:optionsURL&gt;</span>
<a href="#l16.16"></a><span id="l16.16" class="difflineplus">+    &lt;em:targetApplication&gt;</span>
<a href="#l16.17"></a><span id="l16.17" class="difflineplus">+      &lt;Description&gt;</span>
<a href="#l16.18"></a><span id="l16.18" class="difflineplus">+        &lt;em:id&gt;{3550f703-e582-4d05-9a08-453d09bdfdc6}&lt;/em:id&gt; &lt;!-- thunderbird --&gt;</span>
<a href="#l16.19"></a><span id="l16.19" class="difflineplus">+        &lt;em:minVersion&gt;3.0a2pre&lt;/em:minVersion&gt;</span>
<a href="#l16.20"></a><span id="l16.20" class="difflineplus">+        &lt;em:maxVersion&gt;3.0.*&lt;/em:maxVersion&gt;</span>
<a href="#l16.21"></a><span id="l16.21" class="difflineplus">+      &lt;/Description&gt;</span>
<a href="#l16.22"></a><span id="l16.22" class="difflineplus">+    &lt;/em:targetApplication&gt;</span>
<a href="#l16.23"></a><span id="l16.23" class="difflineplus">+  &lt;/Description&gt;</span>
<a href="#l16.24"></a><span id="l16.24" class="difflineplus">+&lt;/RDF&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1">new file mode 100644</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineminus">--- /dev/null</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineplus">+++ b/mailnews/db/gloda/jar.mn</span>
<a href="#l17.4"></a><span id="l17.4" class="difflineat">@@ -0,0 +1,11 @@</span>
<a href="#l17.5"></a><span id="l17.5" class="difflineplus">+gloda.jar:</span>
<a href="#l17.6"></a><span id="l17.6" class="difflineplus">+% content gloda   %content/</span>
<a href="#l17.7"></a><span id="l17.7" class="difflineplus">+% locale  gloda   en-US   %locale/en-US/</span>
<a href="#l17.8"></a><span id="l17.8" class="difflineplus">+% overlay chrome://messenger/content/messenger.xul    chrome://gloda/content/thunderbirdOverlay.xul</span>
<a href="#l17.9"></a><span id="l17.9" class="difflineplus">+% resource gloda ../</span>
<a href="#l17.10"></a><span id="l17.10" class="difflineplus">+  locale/en-US/gloda.dtd           (locale/en-US/gloda.dtd)</span>
<a href="#l17.11"></a><span id="l17.11" class="difflineplus">+  locale/en-US/gloda.properties    (locale/en-US/gloda.properties)</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineplus">+  content/overlay.js               (content/overlay.js)</span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+  content/thunderbirdOverlay.xul   (content/thunderbirdOverlay.xul)</span>
<a href="#l17.14"></a><span id="l17.14" class="difflineplus">+  content/glodacomplete.css        (content/glodacomplete.css)</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineplus">+  content/glodacomplete.xml        (content/glodacomplete.xml)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1">new file mode 100644</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineminus">--- /dev/null</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineplus">+++ b/mailnews/db/gloda/locale/en-US/gloda.dtd</span>
<a href="#l18.4"></a><span id="l18.4" class="difflineat">@@ -0,0 +1,6 @@</span>
<a href="#l18.5"></a><span id="l18.5" class="difflineplus">+&lt;!ENTITY glodaIndexEverything.label &quot;Index Everything&quot;&gt;</span>
<a href="#l18.6"></a><span id="l18.6" class="difflineplus">+&lt;!ENTITY glodaIndexAddressBook.label &quot;Index Addressbook&quot;&gt;</span>
<a href="#l18.7"></a><span id="l18.7" class="difflineplus">+&lt;!ENTITY folderContextGlodaIndex.label &quot;Gloda Index&quot;&gt;</span>
<a href="#l18.8"></a><span id="l18.8" class="difflineplus">+&lt;!ENTITY folderContextGlodaIndex.accesskey &quot;x&quot;&gt;</span>
<a href="#l18.9"></a><span id="l18.9" class="difflineplus">+&lt;!ENTITY threadContextGlodaIndex.label &quot;Gloda Index&quot;&gt;</span>
<a href="#l18.10"></a><span id="l18.10" class="difflineplus">+&lt;!ENTITY threadContextGlodaIndex.accesskey &quot;x&quot;&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1">new file mode 100644</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineminus">--- /dev/null</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineplus">+++ b/mailnews/db/gloda/locale/en-US/gloda.properties</span>
<a href="#l19.4"></a><span id="l19.4" class="difflineat">@@ -0,0 +1,8 @@</span>
<a href="#l19.5"></a><span id="l19.5" class="difflineplus">+prefMessage=Int Pref Value: %d</span>
<a href="#l19.6"></a><span id="l19.6" class="difflineplus">+extensions.gloda.description=Adds a global database to Thunderbird</span>
<a href="#l19.7"></a><span id="l19.7" class="difflineplus">+shutdownTaskName=Global Database Indexer</span>
<a href="#l19.8"></a><span id="l19.8" class="difflineplus">+actionIdle=Idle</span>
<a href="#l19.9"></a><span id="l19.9" class="difflineplus">+actionIndexing=Indexing</span>
<a href="#l19.10"></a><span id="l19.10" class="difflineplus">+actionDeindexing=De-Indexing</span>
<a href="#l19.11"></a><span id="l19.11" class="difflineplus">+actionMoving=Move Processing</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineplus">+messageIndexingExplanation=some messages</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1">new file mode 100644</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineminus">--- /dev/null</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineplus">+++ b/mailnews/db/gloda/locale/en-US/prefwindow.dtd</span>
<a href="#l20.4"></a><span id="l20.4" class="difflineat">@@ -0,0 +1,8 @@</span>
<a href="#l20.5"></a><span id="l20.5" class="difflineplus">+&lt;!ENTITY prefwindow.title &quot;Global Database Has No Preferences&quot;&gt;</span>
<a href="#l20.6"></a><span id="l20.6" class="difflineplus">+&lt;!ENTITY pane1.title &quot;Global Database Has No Preferences&quot;&gt;</span>
<a href="#l20.7"></a><span id="l20.7" class="difflineplus">+&lt;!ENTITY checkboolpref.label &quot;I like cookies&quot;&gt;</span>
<a href="#l20.8"></a><span id="l20.8" class="difflineplus">+&lt;!ENTITY checkboolpref.accesskey &quot;l&quot;&gt;</span>
<a href="#l20.9"></a><span id="l20.9" class="difflineplus">+&lt;!ENTITY intpref.label &quot;I would eat this many cookies&quot;&gt;</span>
<a href="#l20.10"></a><span id="l20.10" class="difflineplus">+&lt;!ENTITY intpref.accesskey &quot;e&quot;&gt;</span>
<a href="#l20.11"></a><span id="l20.11" class="difflineplus">+&lt;!ENTITY stringpref.label &quot;Name of my favorite cookie&quot;&gt;</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineplus">+&lt;!ENTITY stringpref.accesskey &quot;f&quot;&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1">new file mode 100644</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineminus">--- /dev/null</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/Makefile.in</span>
<a href="#l21.4"></a><span id="l21.4" class="difflineat">@@ -0,0 +1,50 @@</span>
<a href="#l21.5"></a><span id="l21.5" class="difflineplus">+#</span>
<a href="#l21.6"></a><span id="l21.6" class="difflineplus">+# ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l21.7"></a><span id="l21.7" class="difflineplus">+# Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l21.8"></a><span id="l21.8" class="difflineplus">+#</span>
<a href="#l21.9"></a><span id="l21.9" class="difflineplus">+# The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l21.10"></a><span id="l21.10" class="difflineplus">+# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l21.11"></a><span id="l21.11" class="difflineplus">+# the License. You may obtain a copy of the License at</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineplus">+# http://www.mozilla.org/MPL/</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+#</span>
<a href="#l21.14"></a><span id="l21.14" class="difflineplus">+# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l21.15"></a><span id="l21.15" class="difflineplus">+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l21.16"></a><span id="l21.16" class="difflineplus">+# for the specific language governing rights and limitations under the</span>
<a href="#l21.17"></a><span id="l21.17" class="difflineplus">+# License.</span>
<a href="#l21.18"></a><span id="l21.18" class="difflineplus">+#</span>
<a href="#l21.19"></a><span id="l21.19" class="difflineplus">+# The Original Code is mozilla.org code.</span>
<a href="#l21.20"></a><span id="l21.20" class="difflineplus">+#</span>
<a href="#l21.21"></a><span id="l21.21" class="difflineplus">+# The Initial Developer of the Original Code is</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineplus">+# Mozilla Messaging, Inc.</span>
<a href="#l21.23"></a><span id="l21.23" class="difflineplus">+#</span>
<a href="#l21.24"></a><span id="l21.24" class="difflineplus">+# Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l21.25"></a><span id="l21.25" class="difflineplus">+# the Initial Developer. All Rights Reserved.</span>
<a href="#l21.26"></a><span id="l21.26" class="difflineplus">+#</span>
<a href="#l21.27"></a><span id="l21.27" class="difflineplus">+# Contributor(s):</span>
<a href="#l21.28"></a><span id="l21.28" class="difflineplus">+#</span>
<a href="#l21.29"></a><span id="l21.29" class="difflineplus">+# Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l21.30"></a><span id="l21.30" class="difflineplus">+# either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l21.31"></a><span id="l21.31" class="difflineplus">+# or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l21.32"></a><span id="l21.32" class="difflineplus">+# in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l21.33"></a><span id="l21.33" class="difflineplus">+# of those above. If you wish to allow use of your version of this file only</span>
<a href="#l21.34"></a><span id="l21.34" class="difflineplus">+# under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l21.35"></a><span id="l21.35" class="difflineplus">+# use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l21.36"></a><span id="l21.36" class="difflineplus">+# decision by deleting the provisions above and replace them with the notice</span>
<a href="#l21.37"></a><span id="l21.37" class="difflineplus">+# and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l21.38"></a><span id="l21.38" class="difflineplus">+# the provisions above, a recipient may use your version of this file under</span>
<a href="#l21.39"></a><span id="l21.39" class="difflineplus">+# the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l21.40"></a><span id="l21.40" class="difflineplus">+#</span>
<a href="#l21.41"></a><span id="l21.41" class="difflineplus">+# ***** END LICENSE BLOCK *****</span>
<a href="#l21.42"></a><span id="l21.42" class="difflineplus">+</span>
<a href="#l21.43"></a><span id="l21.43" class="difflineplus">+DEPTH		= ../../../..</span>
<a href="#l21.44"></a><span id="l21.44" class="difflineplus">+topsrcdir	= @top_srcdir@</span>
<a href="#l21.45"></a><span id="l21.45" class="difflineplus">+srcdir		= @srcdir@</span>
<a href="#l21.46"></a><span id="l21.46" class="difflineplus">+VPATH		= @srcdir@</span>
<a href="#l21.47"></a><span id="l21.47" class="difflineplus">+</span>
<a href="#l21.48"></a><span id="l21.48" class="difflineplus">+include $(DEPTH)/config/autoconf.mk</span>
<a href="#l21.49"></a><span id="l21.49" class="difflineplus">+</span>
<a href="#l21.50"></a><span id="l21.50" class="difflineplus">+MODULE = mailnewsglobaldb</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+</span>
<a href="#l21.52"></a><span id="l21.52" class="difflineplus">+EXTRA_JS_MODULES = $(wildcard $(srcdir)/*.js)</span>
<a href="#l21.53"></a><span id="l21.53" class="difflineplus">+</span>
<a href="#l21.54"></a><span id="l21.54" class="difflineplus">+include $(topsrcdir)/config/rules.mk</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1">new file mode 100644</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineminus">--- /dev/null</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/collection.js</span>
<a href="#l22.4"></a><span id="l22.4" class="difflineat">@@ -0,0 +1,718 @@</span>
<a href="#l22.5"></a><span id="l22.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l22.6"></a><span id="l22.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l22.7"></a><span id="l22.7" class="difflineplus">+ *</span>
<a href="#l22.8"></a><span id="l22.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l22.9"></a><span id="l22.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l22.10"></a><span id="l22.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l22.11"></a><span id="l22.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineplus">+ * </span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l22.14"></a><span id="l22.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l22.15"></a><span id="l22.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l22.16"></a><span id="l22.16" class="difflineplus">+ * License.</span>
<a href="#l22.17"></a><span id="l22.17" class="difflineplus">+ *</span>
<a href="#l22.18"></a><span id="l22.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l22.19"></a><span id="l22.19" class="difflineplus">+ *</span>
<a href="#l22.20"></a><span id="l22.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l22.21"></a><span id="l22.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l22.23"></a><span id="l22.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l22.24"></a><span id="l22.24" class="difflineplus">+ *</span>
<a href="#l22.25"></a><span id="l22.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l22.26"></a><span id="l22.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l22.27"></a><span id="l22.27" class="difflineplus">+ *</span>
<a href="#l22.28"></a><span id="l22.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l22.29"></a><span id="l22.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l22.30"></a><span id="l22.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l22.31"></a><span id="l22.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l22.32"></a><span id="l22.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l22.33"></a><span id="l22.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l22.34"></a><span id="l22.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l22.35"></a><span id="l22.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l22.36"></a><span id="l22.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l22.37"></a><span id="l22.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l22.38"></a><span id="l22.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l22.39"></a><span id="l22.39" class="difflineplus">+ * </span>
<a href="#l22.40"></a><span id="l22.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l22.41"></a><span id="l22.41" class="difflineplus">+</span>
<a href="#l22.42"></a><span id="l22.42" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaCollection', 'GlodaCollectionManager'];</span>
<a href="#l22.43"></a><span id="l22.43" class="difflineplus">+</span>
<a href="#l22.44"></a><span id="l22.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l22.45"></a><span id="l22.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l22.46"></a><span id="l22.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l22.47"></a><span id="l22.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l22.48"></a><span id="l22.48" class="difflineplus">+</span>
<a href="#l22.49"></a><span id="l22.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l22.50"></a><span id="l22.50" class="difflineplus">+</span>
<a href="#l22.51"></a><span id="l22.51" class="difflineplus">+const LOG = Log4Moz.Service.getLogger(&quot;gloda.collection&quot;);</span>
<a href="#l22.52"></a><span id="l22.52" class="difflineplus">+</span>
<a href="#l22.53"></a><span id="l22.53" class="difflineplus">+/**</span>
<a href="#l22.54"></a><span id="l22.54" class="difflineplus">+ * @namespace Central registry and logic for all collections. </span>
<a href="#l22.55"></a><span id="l22.55" class="difflineplus">+ *</span>
<a href="#l22.56"></a><span id="l22.56" class="difflineplus">+ * The collection manager is a singleton that has the following tasks:</span>
<a href="#l22.57"></a><span id="l22.57" class="difflineplus">+ * - Let views of objects (nouns) know when their objects have changed.  For</span>
<a href="#l22.58"></a><span id="l22.58" class="difflineplus">+ *   example, an attribute has changed due to user action.</span>
<a href="#l22.59"></a><span id="l22.59" class="difflineplus">+ * - Let views of objects based on queries know when new objects match their</span>
<a href="#l22.60"></a><span id="l22.60" class="difflineplus">+ *   query, or when their existing objects no longer match due to changes.</span>
<a href="#l22.61"></a><span id="l22.61" class="difflineplus">+ * - Caching/object-identity maintenance.  It is ideal if we only ever have</span>
<a href="#l22.62"></a><span id="l22.62" class="difflineplus">+ *   one instance of an object at a time.  (More specifically, only one instance</span>
<a href="#l22.63"></a><span id="l22.63" class="difflineplus">+ *   per database row 'id'.)  The collection mechanism lets us find existing</span>
<a href="#l22.64"></a><span id="l22.64" class="difflineplus">+ *   instances to this end.  Caching can be directly integrated by being treated</span>
<a href="#l22.65"></a><span id="l22.65" class="difflineplus">+ *   as a special collection.</span>
<a href="#l22.66"></a><span id="l22.66" class="difflineplus">+ */</span>
<a href="#l22.67"></a><span id="l22.67" class="difflineplus">+var GlodaCollectionManager = {</span>
<a href="#l22.68"></a><span id="l22.68" class="difflineplus">+  _collectionsByNoun: {},</span>
<a href="#l22.69"></a><span id="l22.69" class="difflineplus">+  _cachesByNoun: {},</span>
<a href="#l22.70"></a><span id="l22.70" class="difflineplus">+</span>
<a href="#l22.71"></a><span id="l22.71" class="difflineplus">+  /**</span>
<a href="#l22.72"></a><span id="l22.72" class="difflineplus">+   * Registers the existence of a collection with the collection manager.  This</span>
<a href="#l22.73"></a><span id="l22.73" class="difflineplus">+   *  is done using a weak reference so that the collection can go away if it</span>
<a href="#l22.74"></a><span id="l22.74" class="difflineplus">+   *  wants to.</span>
<a href="#l22.75"></a><span id="l22.75" class="difflineplus">+   */</span>
<a href="#l22.76"></a><span id="l22.76" class="difflineplus">+  registerCollection: function gloda_colm_registerCollection(aCollection) {</span>
<a href="#l22.77"></a><span id="l22.77" class="difflineplus">+    let collections;</span>
<a href="#l22.78"></a><span id="l22.78" class="difflineplus">+    let nounID = aCollection.query._nounDef.id;</span>
<a href="#l22.79"></a><span id="l22.79" class="difflineplus">+    if (!(nounID in this._collectionsByNoun))</span>
<a href="#l22.80"></a><span id="l22.80" class="difflineplus">+      collections = this._collectionsByNoun[nounID] = [];</span>
<a href="#l22.81"></a><span id="l22.81" class="difflineplus">+    else {</span>
<a href="#l22.82"></a><span id="l22.82" class="difflineplus">+      // purge dead weak references while we're at it</span>
<a href="#l22.83"></a><span id="l22.83" class="difflineplus">+      collections = this._collectionsByNoun[nounID].filter(function (aRef) {</span>
<a href="#l22.84"></a><span id="l22.84" class="difflineplus">+        return aRef.get(); });</span>
<a href="#l22.85"></a><span id="l22.85" class="difflineplus">+      this._collectionsByNoun[nounID] = collections;</span>
<a href="#l22.86"></a><span id="l22.86" class="difflineplus">+    }</span>
<a href="#l22.87"></a><span id="l22.87" class="difflineplus">+    collections.push(Cu.getWeakReference(aCollection));</span>
<a href="#l22.88"></a><span id="l22.88" class="difflineplus">+  },</span>
<a href="#l22.89"></a><span id="l22.89" class="difflineplus">+  </span>
<a href="#l22.90"></a><span id="l22.90" class="difflineplus">+  getCollectionsForNounID: function gloda_colm_getCollectionsForNounID(aNounID){</span>
<a href="#l22.91"></a><span id="l22.91" class="difflineplus">+    if (!(aNounID in this._collectionsByNoun))</span>
<a href="#l22.92"></a><span id="l22.92" class="difflineplus">+      return [];</span>
<a href="#l22.93"></a><span id="l22.93" class="difflineplus">+    </span>
<a href="#l22.94"></a><span id="l22.94" class="difflineplus">+    // generator would be nice, but I suspect get() is too expensive to use</span>
<a href="#l22.95"></a><span id="l22.95" class="difflineplus">+    //  twice (guard/predicate and value)</span>
<a href="#l22.96"></a><span id="l22.96" class="difflineplus">+    let weakCollections = this._collectionsByNoun[aNounID];</span>
<a href="#l22.97"></a><span id="l22.97" class="difflineplus">+    let collections = [];</span>
<a href="#l22.98"></a><span id="l22.98" class="difflineplus">+    for (let iColl = 0; iColl &lt; weakCollections.length; iColl++) {</span>
<a href="#l22.99"></a><span id="l22.99" class="difflineplus">+      let collection = weakCollections[iColl].get();</span>
<a href="#l22.100"></a><span id="l22.100" class="difflineplus">+      if (collection)</span>
<a href="#l22.101"></a><span id="l22.101" class="difflineplus">+        collections.push(collection);</span>
<a href="#l22.102"></a><span id="l22.102" class="difflineplus">+    }</span>
<a href="#l22.103"></a><span id="l22.103" class="difflineplus">+    return collections;</span>
<a href="#l22.104"></a><span id="l22.104" class="difflineplus">+  },</span>
<a href="#l22.105"></a><span id="l22.105" class="difflineplus">+  </span>
<a href="#l22.106"></a><span id="l22.106" class="difflineplus">+  defineCache: function gloda_colm_defineCache(aNounDef, aCacheSize) {</span>
<a href="#l22.107"></a><span id="l22.107" class="difflineplus">+    this._cachesByNoun[aNounDef.id] = new GlodaLRUCacheCollection(aNounDef,</span>
<a href="#l22.108"></a><span id="l22.108" class="difflineplus">+                                                                   aCacheSize);</span>
<a href="#l22.109"></a><span id="l22.109" class="difflineplus">+  },</span>
<a href="#l22.110"></a><span id="l22.110" class="difflineplus">+  </span>
<a href="#l22.111"></a><span id="l22.111" class="difflineplus">+  /**</span>
<a href="#l22.112"></a><span id="l22.112" class="difflineplus">+   * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l22.113"></a><span id="l22.113" class="difflineplus">+   *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l22.114"></a><span id="l22.114" class="difflineplus">+   *  but rather a collection, it is added to the cache.)</span>
<a href="#l22.115"></a><span id="l22.115" class="difflineplus">+   */</span>
<a href="#l22.116"></a><span id="l22.116" class="difflineplus">+  cacheLookupOne: function gloda_colm_cacheLookupOne(aNounID, aID, aDoCache) {</span>
<a href="#l22.117"></a><span id="l22.117" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l22.118"></a><span id="l22.118" class="difflineplus">+    </span>
<a href="#l22.119"></a><span id="l22.119" class="difflineplus">+    if (cache) {</span>
<a href="#l22.120"></a><span id="l22.120" class="difflineplus">+      if (aID in cache._idMap) {</span>
<a href="#l22.121"></a><span id="l22.121" class="difflineplus">+        let item = cache._idMap[aID];</span>
<a href="#l22.122"></a><span id="l22.122" class="difflineplus">+        return cache.hit(item);</span>
<a href="#l22.123"></a><span id="l22.123" class="difflineplus">+      }</span>
<a href="#l22.124"></a><span id="l22.124" class="difflineplus">+    }</span>
<a href="#l22.125"></a><span id="l22.125" class="difflineplus">+    </span>
<a href="#l22.126"></a><span id="l22.126" class="difflineplus">+    if (aDoCache === false)</span>
<a href="#l22.127"></a><span id="l22.127" class="difflineplus">+      cache = null;</span>
<a href="#l22.128"></a><span id="l22.128" class="difflineplus">+  </span>
<a href="#l22.129"></a><span id="l22.129" class="difflineplus">+    for each (let [iCollection, collection] in</span>
<a href="#l22.130"></a><span id="l22.130" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l22.131"></a><span id="l22.131" class="difflineplus">+      if (aID in collection._idMap) {</span>
<a href="#l22.132"></a><span id="l22.132" class="difflineplus">+        let item = collection._idMap[aID];</span>
<a href="#l22.133"></a><span id="l22.133" class="difflineplus">+        if (cache)</span>
<a href="#l22.134"></a><span id="l22.134" class="difflineplus">+          cache.add([item]);</span>
<a href="#l22.135"></a><span id="l22.135" class="difflineplus">+        return item;</span>
<a href="#l22.136"></a><span id="l22.136" class="difflineplus">+      }</span>
<a href="#l22.137"></a><span id="l22.137" class="difflineplus">+    }</span>
<a href="#l22.138"></a><span id="l22.138" class="difflineplus">+    </span>
<a href="#l22.139"></a><span id="l22.139" class="difflineplus">+    return null;</span>
<a href="#l22.140"></a><span id="l22.140" class="difflineplus">+  },</span>
<a href="#l22.141"></a><span id="l22.141" class="difflineplus">+</span>
<a href="#l22.142"></a><span id="l22.142" class="difflineplus">+  /**</span>
<a href="#l22.143"></a><span id="l22.143" class="difflineplus">+   * Lookup multiple nouns by ID from the cache/existing collections.</span>
<a href="#l22.144"></a><span id="l22.144" class="difflineplus">+   * @return [The number that were found, the number that were not found.]</span>
<a href="#l22.145"></a><span id="l22.145" class="difflineplus">+   */</span>
<a href="#l22.146"></a><span id="l22.146" class="difflineplus">+  cacheLookupMany: function gloda_colm_cacheLookupMany(aNounID, aIDMap,</span>
<a href="#l22.147"></a><span id="l22.147" class="difflineplus">+      aTargetMap, aDoCache) {</span>
<a href="#l22.148"></a><span id="l22.148" class="difflineplus">+    let foundCount = 0, notFoundCount = 0, notFound = {};</span>
<a href="#l22.149"></a><span id="l22.149" class="difflineplus">+    </span>
<a href="#l22.150"></a><span id="l22.150" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l22.151"></a><span id="l22.151" class="difflineplus">+    </span>
<a href="#l22.152"></a><span id="l22.152" class="difflineplus">+    if (cache) {</span>
<a href="#l22.153"></a><span id="l22.153" class="difflineplus">+      for (let key in aIDMap) {</span>
<a href="#l22.154"></a><span id="l22.154" class="difflineplus">+        let cacheValue = cache._idMap[key];</span>
<a href="#l22.155"></a><span id="l22.155" class="difflineplus">+        if (cacheValue === undefined) {</span>
<a href="#l22.156"></a><span id="l22.156" class="difflineplus">+          notFoundCount++;</span>
<a href="#l22.157"></a><span id="l22.157" class="difflineplus">+          notFound[key] = null;</span>
<a href="#l22.158"></a><span id="l22.158" class="difflineplus">+        }</span>
<a href="#l22.159"></a><span id="l22.159" class="difflineplus">+        else {</span>
<a href="#l22.160"></a><span id="l22.160" class="difflineplus">+          foundCount++;</span>
<a href="#l22.161"></a><span id="l22.161" class="difflineplus">+          aTargetMap[key] = cacheValue;</span>
<a href="#l22.162"></a><span id="l22.162" class="difflineplus">+          cache.hit(cacheValue);</span>
<a href="#l22.163"></a><span id="l22.163" class="difflineplus">+        }</span>
<a href="#l22.164"></a><span id="l22.164" class="difflineplus">+      }</span>
<a href="#l22.165"></a><span id="l22.165" class="difflineplus">+    }</span>
<a href="#l22.166"></a><span id="l22.166" class="difflineplus">+</span>
<a href="#l22.167"></a><span id="l22.167" class="difflineplus">+    if (aDoCache === false)</span>
<a href="#l22.168"></a><span id="l22.168" class="difflineplus">+      cache = null;</span>
<a href="#l22.169"></a><span id="l22.169" class="difflineplus">+    </span>
<a href="#l22.170"></a><span id="l22.170" class="difflineplus">+    for each (let [iCollection, collection] in</span>
<a href="#l22.171"></a><span id="l22.171" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l22.172"></a><span id="l22.172" class="difflineplus">+      for (let key in notFound) {</span>
<a href="#l22.173"></a><span id="l22.173" class="difflineplus">+        let collValue = collection._idMap[key];</span>
<a href="#l22.174"></a><span id="l22.174" class="difflineplus">+        if (collValue !== undefined) {</span>
<a href="#l22.175"></a><span id="l22.175" class="difflineplus">+          aTargetMap[key] = collValue;</span>
<a href="#l22.176"></a><span id="l22.176" class="difflineplus">+          delete notFound[key];</span>
<a href="#l22.177"></a><span id="l22.177" class="difflineplus">+          foundCount++;</span>
<a href="#l22.178"></a><span id="l22.178" class="difflineplus">+          notFoundCount--;</span>
<a href="#l22.179"></a><span id="l22.179" class="difflineplus">+          if (cache)</span>
<a href="#l22.180"></a><span id="l22.180" class="difflineplus">+            cache.add([collValue]);</span>
<a href="#l22.181"></a><span id="l22.181" class="difflineplus">+        }</span>
<a href="#l22.182"></a><span id="l22.182" class="difflineplus">+      }</span>
<a href="#l22.183"></a><span id="l22.183" class="difflineplus">+    }</span>
<a href="#l22.184"></a><span id="l22.184" class="difflineplus">+    </span>
<a href="#l22.185"></a><span id="l22.185" class="difflineplus">+    return [foundCount, notFoundCount, notFound];</span>
<a href="#l22.186"></a><span id="l22.186" class="difflineplus">+  },</span>
<a href="#l22.187"></a><span id="l22.187" class="difflineplus">+  </span>
<a href="#l22.188"></a><span id="l22.188" class="difflineplus">+  /**</span>
<a href="#l22.189"></a><span id="l22.189" class="difflineplus">+   * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l22.190"></a><span id="l22.190" class="difflineplus">+   *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l22.191"></a><span id="l22.191" class="difflineplus">+   *  but rather a collection, it is added to the cache.)</span>
<a href="#l22.192"></a><span id="l22.192" class="difflineplus">+   */</span>
<a href="#l22.193"></a><span id="l22.193" class="difflineplus">+  cacheLookupOneByUniqueValue:</span>
<a href="#l22.194"></a><span id="l22.194" class="difflineplus">+      function gloda_colm_cacheLookupOneByUniqueValue(aNounID, aUniqueValue,</span>
<a href="#l22.195"></a><span id="l22.195" class="difflineplus">+                                                      aDoCache) {</span>
<a href="#l22.196"></a><span id="l22.196" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l22.197"></a><span id="l22.197" class="difflineplus">+    </span>
<a href="#l22.198"></a><span id="l22.198" class="difflineplus">+    if (cache) {</span>
<a href="#l22.199"></a><span id="l22.199" class="difflineplus">+      if (aUniqueValue in cache._uniqueValueMap) {</span>
<a href="#l22.200"></a><span id="l22.200" class="difflineplus">+        let item = cache._uniqueValueMap[aUniqueValue];</span>
<a href="#l22.201"></a><span id="l22.201" class="difflineplus">+        return cache.hit(item);</span>
<a href="#l22.202"></a><span id="l22.202" class="difflineplus">+      }</span>
<a href="#l22.203"></a><span id="l22.203" class="difflineplus">+    }</span>
<a href="#l22.204"></a><span id="l22.204" class="difflineplus">+    </span>
<a href="#l22.205"></a><span id="l22.205" class="difflineplus">+    if (aDoCache === false)</span>
<a href="#l22.206"></a><span id="l22.206" class="difflineplus">+      cache = null;</span>
<a href="#l22.207"></a><span id="l22.207" class="difflineplus">+  </span>
<a href="#l22.208"></a><span id="l22.208" class="difflineplus">+    for each (let [iCollection, collection] in</span>
<a href="#l22.209"></a><span id="l22.209" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l22.210"></a><span id="l22.210" class="difflineplus">+      if (aUniqueValue in collection._uniqueValueMap) {</span>
<a href="#l22.211"></a><span id="l22.211" class="difflineplus">+        let item = collection._uniqueValueMap[aUniqueValue];</span>
<a href="#l22.212"></a><span id="l22.212" class="difflineplus">+        if (cache)</span>
<a href="#l22.213"></a><span id="l22.213" class="difflineplus">+          cache.add([item]);</span>
<a href="#l22.214"></a><span id="l22.214" class="difflineplus">+        return item;</span>
<a href="#l22.215"></a><span id="l22.215" class="difflineplus">+      }</span>
<a href="#l22.216"></a><span id="l22.216" class="difflineplus">+    }</span>
<a href="#l22.217"></a><span id="l22.217" class="difflineplus">+    </span>
<a href="#l22.218"></a><span id="l22.218" class="difflineplus">+    return null;</span>
<a href="#l22.219"></a><span id="l22.219" class="difflineplus">+  },</span>
<a href="#l22.220"></a><span id="l22.220" class="difflineplus">+  </span>
<a href="#l22.221"></a><span id="l22.221" class="difflineplus">+  /**</span>
<a href="#l22.222"></a><span id="l22.222" class="difflineplus">+   * Checks whether the provided item with the given id is actually a duplicate</span>
<a href="#l22.223"></a><span id="l22.223" class="difflineplus">+   *  of an instance that already exists in the cache/a collection.  If it is,</span>
<a href="#l22.224"></a><span id="l22.224" class="difflineplus">+   *  the pre-existing instance is returned and counts as a cache hit.  If it</span>
<a href="#l22.225"></a><span id="l22.225" class="difflineplus">+   *  is not, the passed-in instance is added to the cache and returned.</span>
<a href="#l22.226"></a><span id="l22.226" class="difflineplus">+   */</span>
<a href="#l22.227"></a><span id="l22.227" class="difflineplus">+  cacheLoadUnifyOne: function gloda_colm_cacheLoadUnifyOne(aItem) {</span>
<a href="#l22.228"></a><span id="l22.228" class="difflineplus">+    let items = [aItem];</span>
<a href="#l22.229"></a><span id="l22.229" class="difflineplus">+    this.cacheLoadUnify(aItem.NOUN_ID, items);</span>
<a href="#l22.230"></a><span id="l22.230" class="difflineplus">+    return items[0];</span>
<a href="#l22.231"></a><span id="l22.231" class="difflineplus">+  },</span>
<a href="#l22.232"></a><span id="l22.232" class="difflineplus">+</span>
<a href="#l22.233"></a><span id="l22.233" class="difflineplus">+  /**</span>
<a href="#l22.234"></a><span id="l22.234" class="difflineplus">+   * Given a list of items, check if any of them already have duplicate,</span>
<a href="#l22.235"></a><span id="l22.235" class="difflineplus">+   *  canonical, instances in the cache or collections.  Items with pre-existing</span>
<a href="#l22.236"></a><span id="l22.236" class="difflineplus">+   *  instances are replaced by those instances in the provided list, and each</span>
<a href="#l22.237"></a><span id="l22.237" class="difflineplus">+   *  counts as a cache hit.  Items without pre-existing instances are added</span>
<a href="#l22.238"></a><span id="l22.238" class="difflineplus">+   *  to the cache and left intact.</span>
<a href="#l22.239"></a><span id="l22.239" class="difflineplus">+   */</span>
<a href="#l22.240"></a><span id="l22.240" class="difflineplus">+  cacheLoadUnify: function gloda_colm_cacheLoadUnify(aNounID, aItems,</span>
<a href="#l22.241"></a><span id="l22.241" class="difflineplus">+      aCacheIfMissing) {</span>
<a href="#l22.242"></a><span id="l22.242" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l22.243"></a><span id="l22.243" class="difflineplus">+    if (aCacheIfMissing === undefined)</span>
<a href="#l22.244"></a><span id="l22.244" class="difflineplus">+      aCacheIfMissing = true; </span>
<a href="#l22.245"></a><span id="l22.245" class="difflineplus">+    </span>
<a href="#l22.246"></a><span id="l22.246" class="difflineplus">+    // track the items we haven't yet found in a cache/collection (value) and</span>
<a href="#l22.247"></a><span id="l22.247" class="difflineplus">+    //  their index in aItems (key).  We're somewhat abusing the dictionary</span>
<a href="#l22.248"></a><span id="l22.248" class="difflineplus">+    //  metaphor with the intent of storing tuples here.  We also do it because</span>
<a href="#l22.249"></a><span id="l22.249" class="difflineplus">+    //  it allows random-access deletion theoretically without cost.  (Since</span>
<a href="#l22.250"></a><span id="l22.250" class="difflineplus">+    //  we delete during iteration, that may be wrong, but it sounds like the</span>
<a href="#l22.251"></a><span id="l22.251" class="difflineplus">+    //  semantics still work?)</span>
<a href="#l22.252"></a><span id="l22.252" class="difflineplus">+    let unresolvedIndexToItem = {};</span>
<a href="#l22.253"></a><span id="l22.253" class="difflineplus">+    let numUnresolved = 0;</span>
<a href="#l22.254"></a><span id="l22.254" class="difflineplus">+    </span>
<a href="#l22.255"></a><span id="l22.255" class="difflineplus">+    if (cache) {</span>
<a href="#l22.256"></a><span id="l22.256" class="difflineplus">+      for (let iItem = 0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l22.257"></a><span id="l22.257" class="difflineplus">+        let item = aItems[iItem];</span>
<a href="#l22.258"></a><span id="l22.258" class="difflineplus">+        </span>
<a href="#l22.259"></a><span id="l22.259" class="difflineplus">+        if (item.id in cache._idMap) {</span>
<a href="#l22.260"></a><span id="l22.260" class="difflineplus">+          let realItem = cache._idMap[item.id];</span>
<a href="#l22.261"></a><span id="l22.261" class="difflineplus">+          // update the caller's array with the reference to the 'real' item</span>
<a href="#l22.262"></a><span id="l22.262" class="difflineplus">+          aItems[iItem] = realItem;</span>
<a href="#l22.263"></a><span id="l22.263" class="difflineplus">+          cache.hit(realItem);</span>
<a href="#l22.264"></a><span id="l22.264" class="difflineplus">+        }</span>
<a href="#l22.265"></a><span id="l22.265" class="difflineplus">+        else {</span>
<a href="#l22.266"></a><span id="l22.266" class="difflineplus">+          unresolvedIndexToItem[iItem] = item;</span>
<a href="#l22.267"></a><span id="l22.267" class="difflineplus">+          numUnresolved++;</span>
<a href="#l22.268"></a><span id="l22.268" class="difflineplus">+        }</span>
<a href="#l22.269"></a><span id="l22.269" class="difflineplus">+      }</span>
<a href="#l22.270"></a><span id="l22.270" class="difflineplus">+      </span>
<a href="#l22.271"></a><span id="l22.271" class="difflineplus">+      // we're done if everyone was a hit.</span>
<a href="#l22.272"></a><span id="l22.272" class="difflineplus">+      if (numUnresolved == 0)</span>
<a href="#l22.273"></a><span id="l22.273" class="difflineplus">+        return;</span>
<a href="#l22.274"></a><span id="l22.274" class="difflineplus">+    }</span>
<a href="#l22.275"></a><span id="l22.275" class="difflineplus">+    else {</span>
<a href="#l22.276"></a><span id="l22.276" class="difflineplus">+      for (let iItem = 0; iItem &lt; aItems.length; iItem++) {</span>
<a href="#l22.277"></a><span id="l22.277" class="difflineplus">+        unresolvedIndexToItem[iItem] = aItems[iItem];</span>
<a href="#l22.278"></a><span id="l22.278" class="difflineplus">+      }</span>
<a href="#l22.279"></a><span id="l22.279" class="difflineplus">+      numUnresolved = aItems.length;</span>
<a href="#l22.280"></a><span id="l22.280" class="difflineplus">+    }</span>
<a href="#l22.281"></a><span id="l22.281" class="difflineplus">+  </span>
<a href="#l22.282"></a><span id="l22.282" class="difflineplus">+    let needToCache = [];</span>
<a href="#l22.283"></a><span id="l22.283" class="difflineplus">+    // next, let's fall back to our collections</span>
<a href="#l22.284"></a><span id="l22.284" class="difflineplus">+    for each (let [iCollection, collection] in</span>
<a href="#l22.285"></a><span id="l22.285" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l22.286"></a><span id="l22.286" class="difflineplus">+      for (let [iItem, item] in Iterator(unresolvedIndexToItem)) {</span>
<a href="#l22.287"></a><span id="l22.287" class="difflineplus">+        if (item.id in collection._idMap) {</span>
<a href="#l22.288"></a><span id="l22.288" class="difflineplus">+          let realItem = collection._idMap[item.id];</span>
<a href="#l22.289"></a><span id="l22.289" class="difflineplus">+          // update the caller's array to now have the 'real' object</span>
<a href="#l22.290"></a><span id="l22.290" class="difflineplus">+          aItems[iItem] = realItem;</span>
<a href="#l22.291"></a><span id="l22.291" class="difflineplus">+          // flag that we need to cache this guy (we use an inclusive cache)</span>
<a href="#l22.292"></a><span id="l22.292" class="difflineplus">+          needToCache.push(realItem);</span>
<a href="#l22.293"></a><span id="l22.293" class="difflineplus">+          // we no longer need to resolve this item...</span>
<a href="#l22.294"></a><span id="l22.294" class="difflineplus">+          delete unresolvedIndexToItem[iItem];</span>
<a href="#l22.295"></a><span id="l22.295" class="difflineplus">+          // stop checking collections if we got everybody</span>
<a href="#l22.296"></a><span id="l22.296" class="difflineplus">+          if (--numUnresolved == 0)</span>
<a href="#l22.297"></a><span id="l22.297" class="difflineplus">+            break;</span>
<a href="#l22.298"></a><span id="l22.298" class="difflineplus">+        }</span>
<a href="#l22.299"></a><span id="l22.299" class="difflineplus">+      }</span>
<a href="#l22.300"></a><span id="l22.300" class="difflineplus">+    }</span>
<a href="#l22.301"></a><span id="l22.301" class="difflineplus">+    </span>
<a href="#l22.302"></a><span id="l22.302" class="difflineplus">+    // anything left in unresolvedIndexToItem should be added to the cache</span>
<a href="#l22.303"></a><span id="l22.303" class="difflineplus">+    //  unless !aCacheIfMissing.  plus, we already have 'needToCache'</span>
<a href="#l22.304"></a><span id="l22.304" class="difflineplus">+    if (cache &amp;&amp; aCacheIfMissing) {</span>
<a href="#l22.305"></a><span id="l22.305" class="difflineplus">+      cache.add(needToCache.concat([val for each</span>
<a href="#l22.306"></a><span id="l22.306" class="difflineplus">+                                    (val in unresolvedIndexToItem)]));</span>
<a href="#l22.307"></a><span id="l22.307" class="difflineplus">+    }</span>
<a href="#l22.308"></a><span id="l22.308" class="difflineplus">+    </span>
<a href="#l22.309"></a><span id="l22.309" class="difflineplus">+    return aItems;</span>
<a href="#l22.310"></a><span id="l22.310" class="difflineplus">+  },</span>
<a href="#l22.311"></a><span id="l22.311" class="difflineplus">+  </span>
<a href="#l22.312"></a><span id="l22.312" class="difflineplus">+  cacheCommitDirty: function glod_colm_cacheCommitDirty() {</span>
<a href="#l22.313"></a><span id="l22.313" class="difflineplus">+    for each (let cache in this._cachesByNoun) {</span>
<a href="#l22.314"></a><span id="l22.314" class="difflineplus">+      cache.commitDirty();</span>
<a href="#l22.315"></a><span id="l22.315" class="difflineplus">+    }</span>
<a href="#l22.316"></a><span id="l22.316" class="difflineplus">+  },</span>
<a href="#l22.317"></a><span id="l22.317" class="difflineplus">+</span>
<a href="#l22.318"></a><span id="l22.318" class="difflineplus">+  /**</span>
<a href="#l22.319"></a><span id="l22.319" class="difflineplus">+   * Notifies the collection manager that an item has been loaded and should</span>
<a href="#l22.320"></a><span id="l22.320" class="difflineplus">+   *  be cached, assuming caching is active.</span>
<a href="#l22.321"></a><span id="l22.321" class="difflineplus">+   */    </span>
<a href="#l22.322"></a><span id="l22.322" class="difflineplus">+  itemLoaded: function gloda_colm_itemsLoaded(aItem) {</span>
<a href="#l22.323"></a><span id="l22.323" class="difflineplus">+    let cache = this._cachesByNoun[aItem.NOUN_ID];</span>
<a href="#l22.324"></a><span id="l22.324" class="difflineplus">+    if (cache) {</span>
<a href="#l22.325"></a><span id="l22.325" class="difflineplus">+      cache.add([aItem]);</span>
<a href="#l22.326"></a><span id="l22.326" class="difflineplus">+    }</span>
<a href="#l22.327"></a><span id="l22.327" class="difflineplus">+  },</span>
<a href="#l22.328"></a><span id="l22.328" class="difflineplus">+</span>
<a href="#l22.329"></a><span id="l22.329" class="difflineplus">+  /**</span>
<a href="#l22.330"></a><span id="l22.330" class="difflineplus">+   * Notifies the collection manager that multiple items has been loaded and</span>
<a href="#l22.331"></a><span id="l22.331" class="difflineplus">+   *  should be cached, assuming caching is active.</span>
<a href="#l22.332"></a><span id="l22.332" class="difflineplus">+   */  </span>
<a href="#l22.333"></a><span id="l22.333" class="difflineplus">+  itemsLoaded: function gloda_colm_itemsLoaded(aNounID, aItems) {</span>
<a href="#l22.334"></a><span id="l22.334" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l22.335"></a><span id="l22.335" class="difflineplus">+    if (cache) {</span>
<a href="#l22.336"></a><span id="l22.336" class="difflineplus">+      cache.add(aItems);</span>
<a href="#l22.337"></a><span id="l22.337" class="difflineplus">+    }</span>
<a href="#l22.338"></a><span id="l22.338" class="difflineplus">+  },</span>
<a href="#l22.339"></a><span id="l22.339" class="difflineplus">+  </span>
<a href="#l22.340"></a><span id="l22.340" class="difflineplus">+  /**</span>
<a href="#l22.341"></a><span id="l22.341" class="difflineplus">+   * This should be called when items are added to the global database.  This</span>
<a href="#l22.342"></a><span id="l22.342" class="difflineplus">+   *  should generally mean during indexing by indexers or an attribute</span>
<a href="#l22.343"></a><span id="l22.343" class="difflineplus">+   *  provider.</span>
<a href="#l22.344"></a><span id="l22.344" class="difflineplus">+   * We walk all existing collections for the given noun type and add the items</span>
<a href="#l22.345"></a><span id="l22.345" class="difflineplus">+   *  to the collection if the item meets the query that defines the collection.</span>
<a href="#l22.346"></a><span id="l22.346" class="difflineplus">+   */</span>
<a href="#l22.347"></a><span id="l22.347" class="difflineplus">+  itemsAdded: function gloda_colm_itemsAdded(aNounID, aItems) {</span>
<a href="#l22.348"></a><span id="l22.348" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l22.349"></a><span id="l22.349" class="difflineplus">+    if (cache) {</span>
<a href="#l22.350"></a><span id="l22.350" class="difflineplus">+      cache.add(aItems);</span>
<a href="#l22.351"></a><span id="l22.351" class="difflineplus">+    }</span>
<a href="#l22.352"></a><span id="l22.352" class="difflineplus">+</span>
<a href="#l22.353"></a><span id="l22.353" class="difflineplus">+    for each (let [iCollection, collection] in</span>
<a href="#l22.354"></a><span id="l22.354" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l22.355"></a><span id="l22.355" class="difflineplus">+      let addItems = [item for each ([i, item] in Iterator(aItems))</span>
<a href="#l22.356"></a><span id="l22.356" class="difflineplus">+                      if (collection.query.test(item))];</span>
<a href="#l22.357"></a><span id="l22.357" class="difflineplus">+      if (addItems.length)</span>
<a href="#l22.358"></a><span id="l22.358" class="difflineplus">+        collection._onItemsAdded(addItems);</span>
<a href="#l22.359"></a><span id="l22.359" class="difflineplus">+    }</span>
<a href="#l22.360"></a><span id="l22.360" class="difflineplus">+  },</span>
<a href="#l22.361"></a><span id="l22.361" class="difflineplus">+  /**</span>
<a href="#l22.362"></a><span id="l22.362" class="difflineplus">+   * This should be called when items in the global database are modified.  For</span>
<a href="#l22.363"></a><span id="l22.363" class="difflineplus">+   *  example, as a result of indexing.  This should generally only be called</span>
<a href="#l22.364"></a><span id="l22.364" class="difflineplus">+   *  by indexers or by attribute providers.</span>
<a href="#l22.365"></a><span id="l22.365" class="difflineplus">+   * We walk all existing collections for the given noun type.  For items</span>
<a href="#l22.366"></a><span id="l22.366" class="difflineplus">+   *  currently included in each collection but should no longer be (per the</span>
<a href="#l22.367"></a><span id="l22.367" class="difflineplus">+   *  collection's defining query) we generate onItemsRemoved events.  For items</span>
<a href="#l22.368"></a><span id="l22.368" class="difflineplus">+   *  not currently included in the collection but should now be, we generate</span>
<a href="#l22.369"></a><span id="l22.369" class="difflineplus">+   *  onItemsAdded events.  For items included that still match the query, we</span>
<a href="#l22.370"></a><span id="l22.370" class="difflineplus">+   *  generate onItemsModified events.</span>
<a href="#l22.371"></a><span id="l22.371" class="difflineplus">+   */</span>
<a href="#l22.372"></a><span id="l22.372" class="difflineplus">+  itemsModified: function gloda_colm_itemsModified(aNounID, aItems) {</span>
<a href="#l22.373"></a><span id="l22.373" class="difflineplus">+    for each (let [iCollection, collection] in</span>
<a href="#l22.374"></a><span id="l22.374" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l22.375"></a><span id="l22.375" class="difflineplus">+      let added = [], modified = [], removed = [];</span>
<a href="#l22.376"></a><span id="l22.376" class="difflineplus">+      for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l22.377"></a><span id="l22.377" class="difflineplus">+        if (item.id in collection._idMap) {</span>
<a href="#l22.378"></a><span id="l22.378" class="difflineplus">+          // currently in... but should it still be there?</span>
<a href="#l22.379"></a><span id="l22.379" class="difflineplus">+          if (collection.query.test(item))</span>
<a href="#l22.380"></a><span id="l22.380" class="difflineplus">+            modified.push(item); // yes, keep it</span>
<a href="#l22.381"></a><span id="l22.381" class="difflineplus">+          else</span>
<a href="#l22.382"></a><span id="l22.382" class="difflineplus">+            removed.push(item); // no, bin it</span>
<a href="#l22.383"></a><span id="l22.383" class="difflineplus">+        }</span>
<a href="#l22.384"></a><span id="l22.384" class="difflineplus">+        else if (collection.query.test(item)) // not in, should it be?</span>
<a href="#l22.385"></a><span id="l22.385" class="difflineplus">+          added.push(item); // yep, add it</span>
<a href="#l22.386"></a><span id="l22.386" class="difflineplus">+      }</span>
<a href="#l22.387"></a><span id="l22.387" class="difflineplus">+      if (added.length)</span>
<a href="#l22.388"></a><span id="l22.388" class="difflineplus">+        collection._onItemsAdded(added);</span>
<a href="#l22.389"></a><span id="l22.389" class="difflineplus">+      if (modified.length)</span>
<a href="#l22.390"></a><span id="l22.390" class="difflineplus">+        collection._onItemsModified(modified);</span>
<a href="#l22.391"></a><span id="l22.391" class="difflineplus">+      if (removed.length)</span>
<a href="#l22.392"></a><span id="l22.392" class="difflineplus">+        collection._onItemsRemoved(removed);</span>
<a href="#l22.393"></a><span id="l22.393" class="difflineplus">+    }</span>
<a href="#l22.394"></a><span id="l22.394" class="difflineplus">+  },</span>
<a href="#l22.395"></a><span id="l22.395" class="difflineplus">+  /**</span>
<a href="#l22.396"></a><span id="l22.396" class="difflineplus">+   * This should be called when items in the global database are permanently</span>
<a href="#l22.397"></a><span id="l22.397" class="difflineplus">+   *  deleted.  (This is distinct from concepts like message deletion which may</span>
<a href="#l22.398"></a><span id="l22.398" class="difflineplus">+   *  involved trash folders or other modified forms of existence.  Deleted</span>
<a href="#l22.399"></a><span id="l22.399" class="difflineplus">+   *  means the data is gone and if it were to come back, it would come back</span>
<a href="#l22.400"></a><span id="l22.400" class="difflineplus">+   *  with a brand new unique id and we would get an itemsAdded event.)</span>
<a href="#l22.401"></a><span id="l22.401" class="difflineplus">+   * We walk all existing collections for the given noun type.  For items</span>
<a href="#l22.402"></a><span id="l22.402" class="difflineplus">+   *  currently in the collection, we generate onItemsRemoved events.</span>
<a href="#l22.403"></a><span id="l22.403" class="difflineplus">+   */</span>
<a href="#l22.404"></a><span id="l22.404" class="difflineplus">+  itemsDeleted: function gloda_colm_itemsDeleted(aNounID, aItems) {</span>
<a href="#l22.405"></a><span id="l22.405" class="difflineplus">+    // cache</span>
<a href="#l22.406"></a><span id="l22.406" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l22.407"></a><span id="l22.407" class="difflineplus">+    if (cache) {</span>
<a href="#l22.408"></a><span id="l22.408" class="difflineplus">+      for each (let [iItem, item] in Iterator(aItem)) {</span>
<a href="#l22.409"></a><span id="l22.409" class="difflineplus">+        if (item.id in cache._idMap)</span>
<a href="#l22.410"></a><span id="l22.410" class="difflineplus">+          cache.delete(item);</span>
<a href="#l22.411"></a><span id="l22.411" class="difflineplus">+      }</span>
<a href="#l22.412"></a><span id="l22.412" class="difflineplus">+    }</span>
<a href="#l22.413"></a><span id="l22.413" class="difflineplus">+</span>
<a href="#l22.414"></a><span id="l22.414" class="difflineplus">+    // collections</span>
<a href="#l22.415"></a><span id="l22.415" class="difflineplus">+    for each (let [iCollection, collection] in</span>
<a href="#l22.416"></a><span id="l22.416" class="difflineplus">+              Iterator(this.getCollectionsForNounID(aNounID))) {</span>
<a href="#l22.417"></a><span id="l22.417" class="difflineplus">+      let removeItems = [item for each ([i, item] in Iterator(aItems))</span>
<a href="#l22.418"></a><span id="l22.418" class="difflineplus">+                         if (item.id in collection._idMap)];</span>
<a href="#l22.419"></a><span id="l22.419" class="difflineplus">+      if (removeItems.length)</span>
<a href="#l22.420"></a><span id="l22.420" class="difflineplus">+        collection._onItemsRemoved(removeItems);</span>
<a href="#l22.421"></a><span id="l22.421" class="difflineplus">+    }</span>
<a href="#l22.422"></a><span id="l22.422" class="difflineplus">+  },</span>
<a href="#l22.423"></a><span id="l22.423" class="difflineplus">+};</span>
<a href="#l22.424"></a><span id="l22.424" class="difflineplus">+</span>
<a href="#l22.425"></a><span id="l22.425" class="difflineplus">+/**</span>
<a href="#l22.426"></a><span id="l22.426" class="difflineplus">+ * @class A current view of the set of first-class nouns meeting a given query.</span>
<a href="#l22.427"></a><span id="l22.427" class="difflineplus">+ *  Assuming a listener is present, events are</span>
<a href="#l22.428"></a><span id="l22.428" class="difflineplus">+ *  generated when new objects meet the query, existing objects no longer meet</span>
<a href="#l22.429"></a><span id="l22.429" class="difflineplus">+ *  the query, or existing objects have experienced a change in attributes that</span>
<a href="#l22.430"></a><span id="l22.430" class="difflineplus">+ *  does not affect their ability to be present (but the listener may care about</span>
<a href="#l22.431"></a><span id="l22.431" class="difflineplus">+ *  because it is exposing those attributes).</span>
<a href="#l22.432"></a><span id="l22.432" class="difflineplus">+ * @constructor </span>
<a href="#l22.433"></a><span id="l22.433" class="difflineplus">+ */</span>
<a href="#l22.434"></a><span id="l22.434" class="difflineplus">+function GlodaCollection(aNounDef, aItems, aQuery, aListener,</span>
<a href="#l22.435"></a><span id="l22.435" class="difflineplus">+      aMasterCollection) {</span>
<a href="#l22.436"></a><span id="l22.436" class="difflineplus">+  // if aNounDef is null, we are just being invoked for subclassing</span>
<a href="#l22.437"></a><span id="l22.437" class="difflineplus">+  if (aNounDef === undefined)</span>
<a href="#l22.438"></a><span id="l22.438" class="difflineplus">+    return;</span>
<a href="#l22.439"></a><span id="l22.439" class="difflineplus">+</span>
<a href="#l22.440"></a><span id="l22.440" class="difflineplus">+  this._nounDef = aNounDef;</span>
<a href="#l22.441"></a><span id="l22.441" class="difflineplus">+  // should we also maintain a unique value mapping...</span>
<a href="#l22.442"></a><span id="l22.442" class="difflineplus">+  if (this._nounDef.usesUniqueValue)</span>
<a href="#l22.443"></a><span id="l22.443" class="difflineplus">+    this._uniqueValueMap = {};</span>
<a href="#l22.444"></a><span id="l22.444" class="difflineplus">+</span>
<a href="#l22.445"></a><span id="l22.445" class="difflineplus">+  this.pendingItems = [];</span>
<a href="#l22.446"></a><span id="l22.446" class="difflineplus">+  this._pendingIdMap = {};</span>
<a href="#l22.447"></a><span id="l22.447" class="difflineplus">+  this.items = [];</span>
<a href="#l22.448"></a><span id="l22.448" class="difflineplus">+  this._idMap = {};</span>
<a href="#l22.449"></a><span id="l22.449" class="difflineplus">+  </span>
<a href="#l22.450"></a><span id="l22.450" class="difflineplus">+  // force the listener to null for our call to _onItemsAdded; no events for</span>
<a href="#l22.451"></a><span id="l22.451" class="difflineplus">+  //  the initial load-out.</span>
<a href="#l22.452"></a><span id="l22.452" class="difflineplus">+  this._listener = null;</span>
<a href="#l22.453"></a><span id="l22.453" class="difflineplus">+  if (aItems &amp;&amp; aItems.length)</span>
<a href="#l22.454"></a><span id="l22.454" class="difflineplus">+    this._onItemsAdded(aItems);</span>
<a href="#l22.455"></a><span id="l22.455" class="difflineplus">+  </span>
<a href="#l22.456"></a><span id="l22.456" class="difflineplus">+  this.query = aQuery || null;</span>
<a href="#l22.457"></a><span id="l22.457" class="difflineplus">+  if (this.query)</span>
<a href="#l22.458"></a><span id="l22.458" class="difflineplus">+    this.query.collection = this;</span>
<a href="#l22.459"></a><span id="l22.459" class="difflineplus">+  this._listener = aListener || null;</span>
<a href="#l22.460"></a><span id="l22.460" class="difflineplus">+  </span>
<a href="#l22.461"></a><span id="l22.461" class="difflineplus">+  this.deferredCount = 0;</span>
<a href="#l22.462"></a><span id="l22.462" class="difflineplus">+  this.resolvedCount = 0;</span>
<a href="#l22.463"></a><span id="l22.463" class="difflineplus">+  </span>
<a href="#l22.464"></a><span id="l22.464" class="difflineplus">+  if (aMasterCollection) {</span>
<a href="#l22.465"></a><span id="l22.465" class="difflineplus">+    this.masterCollection = aMasterCollection.masterCollection;</span>
<a href="#l22.466"></a><span id="l22.466" class="difflineplus">+  }</span>
<a href="#l22.467"></a><span id="l22.467" class="difflineplus">+  else {</span>
<a href="#l22.468"></a><span id="l22.468" class="difflineplus">+    this.masterCollection = this;</span>
<a href="#l22.469"></a><span id="l22.469" class="difflineplus">+    /** a dictionary of dictionaries. at the top level, the keys are noun IDs.</span>
<a href="#l22.470"></a><span id="l22.470" class="difflineplus">+     * each of these sub-dictionaries maps the IDs of desired noun instances to</span>
<a href="#l22.471"></a><span id="l22.471" class="difflineplus">+     * the actual instance, or null if it has not yet been loaded.</span>
<a href="#l22.472"></a><span id="l22.472" class="difflineplus">+     */ </span>
<a href="#l22.473"></a><span id="l22.473" class="difflineplus">+    this.referencesByNounID = {};</span>
<a href="#l22.474"></a><span id="l22.474" class="difflineplus">+    /**</span>
<a href="#l22.475"></a><span id="l22.475" class="difflineplus">+     * a dictionary of dictionaries. at the top level, the keys are noun IDs.</span>
<a href="#l22.476"></a><span id="l22.476" class="difflineplus">+     * each of the sub-dictionaries maps the IDs of the _recognized parent</span>
<a href="#l22.477"></a><span id="l22.477" class="difflineplus">+     * noun_ to the list of children, or null if the list has not yet been</span>
<a href="#l22.478"></a><span id="l22.478" class="difflineplus">+     * populated.</span>
<a href="#l22.479"></a><span id="l22.479" class="difflineplus">+     * </span>
<a href="#l22.480"></a><span id="l22.480" class="difflineplus">+     * So if we have a noun definition A with ID 1 who is the recognized parent</span>
<a href="#l22.481"></a><span id="l22.481" class="difflineplus">+     *  noun of noun definition B with ID 2, AND we have an instance A(1) with</span>
<a href="#l22.482"></a><span id="l22.482" class="difflineplus">+     *  two children B(10), B(11), then an example might be: {2: {1: [10, 11]}}.</span>
<a href="#l22.483"></a><span id="l22.483" class="difflineplus">+     */</span>
<a href="#l22.484"></a><span id="l22.484" class="difflineplus">+    this.inverseReferencesByNounID = {};</span>
<a href="#l22.485"></a><span id="l22.485" class="difflineplus">+    this.subCollections = {};</span>
<a href="#l22.486"></a><span id="l22.486" class="difflineplus">+  }</span>
<a href="#l22.487"></a><span id="l22.487" class="difflineplus">+}</span>
<a href="#l22.488"></a><span id="l22.488" class="difflineplus">+</span>
<a href="#l22.489"></a><span id="l22.489" class="difflineplus">+GlodaCollection.prototype = {</span>
<a href="#l22.490"></a><span id="l22.490" class="difflineplus">+  get listener() { return this._listener; },</span>
<a href="#l22.491"></a><span id="l22.491" class="difflineplus">+  set listener(aListener) { this._listener = aListener; },</span>
<a href="#l22.492"></a><span id="l22.492" class="difflineplus">+  </span>
<a href="#l22.493"></a><span id="l22.493" class="difflineplus">+  /**</span>
<a href="#l22.494"></a><span id="l22.494" class="difflineplus">+   * Clear the contents of this collection.  This only makes sense for explicit</span>
<a href="#l22.495"></a><span id="l22.495" class="difflineplus">+   *  collections or wildcard collections.  (Actual query-based collections</span>
<a href="#l22.496"></a><span id="l22.496" class="difflineplus">+   *  should represent the state of the query, so unless we're going to delete</span>
<a href="#l22.497"></a><span id="l22.497" class="difflineplus">+   *  all the items, clearing the collection would violate that constraint.)</span>
<a href="#l22.498"></a><span id="l22.498" class="difflineplus">+   */</span>
<a href="#l22.499"></a><span id="l22.499" class="difflineplus">+  clear: function gloda_coll_clear() {</span>
<a href="#l22.500"></a><span id="l22.500" class="difflineplus">+    this._idMap = {};</span>
<a href="#l22.501"></a><span id="l22.501" class="difflineplus">+    if (this._uniqueValueMap)</span>
<a href="#l22.502"></a><span id="l22.502" class="difflineplus">+      this._uniqueValueMap = {};</span>
<a href="#l22.503"></a><span id="l22.503" class="difflineplus">+    this.items = [];</span>
<a href="#l22.504"></a><span id="l22.504" class="difflineplus">+  },</span>
<a href="#l22.505"></a><span id="l22.505" class="difflineplus">+</span>
<a href="#l22.506"></a><span id="l22.506" class="difflineplus">+  _onItemsAdded: function gloda_coll_onItemsAdded(aItems) {</span>
<a href="#l22.507"></a><span id="l22.507" class="difflineplus">+    this.items.push.apply(this.items, aItems);</span>
<a href="#l22.508"></a><span id="l22.508" class="difflineplus">+    if (this._uniqueValueMap) {</span>
<a href="#l22.509"></a><span id="l22.509" class="difflineplus">+      for each (let [iItem, item] in Iterator(this.items)) {</span>
<a href="#l22.510"></a><span id="l22.510" class="difflineplus">+        this._idMap[item.id] = item;</span>
<a href="#l22.511"></a><span id="l22.511" class="difflineplus">+        this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l22.512"></a><span id="l22.512" class="difflineplus">+      }</span>
<a href="#l22.513"></a><span id="l22.513" class="difflineplus">+    }</span>
<a href="#l22.514"></a><span id="l22.514" class="difflineplus">+    else {</span>
<a href="#l22.515"></a><span id="l22.515" class="difflineplus">+      for each (let [iItem, item] in Iterator(this.items)) {</span>
<a href="#l22.516"></a><span id="l22.516" class="difflineplus">+        this._idMap[item.id] = item;</span>
<a href="#l22.517"></a><span id="l22.517" class="difflineplus">+      }</span>
<a href="#l22.518"></a><span id="l22.518" class="difflineplus">+    }</span>
<a href="#l22.519"></a><span id="l22.519" class="difflineplus">+    if (this._listener) {</span>
<a href="#l22.520"></a><span id="l22.520" class="difflineplus">+      try {</span>
<a href="#l22.521"></a><span id="l22.521" class="difflineplus">+        this._listener.onItemsAdded(aItems, this);</span>
<a href="#l22.522"></a><span id="l22.522" class="difflineplus">+      }</span>
<a href="#l22.523"></a><span id="l22.523" class="difflineplus">+      catch (ex) {</span>
<a href="#l22.524"></a><span id="l22.524" class="difflineplus">+        LOG.error(&quot;caught exception from listener in onItemsAdded: &quot; + </span>
<a href="#l22.525"></a><span id="l22.525" class="difflineplus">+            ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l22.526"></a><span id="l22.526" class="difflineplus">+      }</span>
<a href="#l22.527"></a><span id="l22.527" class="difflineplus">+    }</span>
<a href="#l22.528"></a><span id="l22.528" class="difflineplus">+  },</span>
<a href="#l22.529"></a><span id="l22.529" class="difflineplus">+  </span>
<a href="#l22.530"></a><span id="l22.530" class="difflineplus">+  _onItemsModified: function gloda_coll_onItemsModified(aItems) {</span>
<a href="#l22.531"></a><span id="l22.531" class="difflineplus">+    if (this._listener) {</span>
<a href="#l22.532"></a><span id="l22.532" class="difflineplus">+      try {</span>
<a href="#l22.533"></a><span id="l22.533" class="difflineplus">+        this._listener.onItemsModified(aItems, this);</span>
<a href="#l22.534"></a><span id="l22.534" class="difflineplus">+      }</span>
<a href="#l22.535"></a><span id="l22.535" class="difflineplus">+      catch (ex) {</span>
<a href="#l22.536"></a><span id="l22.536" class="difflineplus">+        LOG.error(&quot;caught exception from listener in onItemsModified: &quot; + </span>
<a href="#l22.537"></a><span id="l22.537" class="difflineplus">+            ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l22.538"></a><span id="l22.538" class="difflineplus">+      }</span>
<a href="#l22.539"></a><span id="l22.539" class="difflineplus">+    }</span>
<a href="#l22.540"></a><span id="l22.540" class="difflineplus">+  },</span>
<a href="#l22.541"></a><span id="l22.541" class="difflineplus">+  </span>
<a href="#l22.542"></a><span id="l22.542" class="difflineplus">+  /**</span>
<a href="#l22.543"></a><span id="l22.543" class="difflineplus">+   * Given a list of items that definitely no longer belong in this collection,</span>
<a href="#l22.544"></a><span id="l22.544" class="difflineplus">+   *  remove them from the collection and notify the listener.  The 'tricky'</span>
<a href="#l22.545"></a><span id="l22.545" class="difflineplus">+   *  part is that we need to remove the deleted items from our list of items.</span>
<a href="#l22.546"></a><span id="l22.546" class="difflineplus">+   */</span>
<a href="#l22.547"></a><span id="l22.547" class="difflineplus">+  _onItemsRemoved: function gloda_coll_onItemsRemoved(aItems) {</span>
<a href="#l22.548"></a><span id="l22.548" class="difflineplus">+    // we want to avoid the O(n^2) deletion performance case, and deletion</span>
<a href="#l22.549"></a><span id="l22.549" class="difflineplus">+    //  should be rare enough that the extra cost of building the deletion map</span>
<a href="#l22.550"></a><span id="l22.550" class="difflineplus">+    //  should never be a real problem.</span>
<a href="#l22.551"></a><span id="l22.551" class="difflineplus">+    let deleteMap = {};</span>
<a href="#l22.552"></a><span id="l22.552" class="difflineplus">+    // build the delete map while also nuking from our id map/unique value map</span>
<a href="#l22.553"></a><span id="l22.553" class="difflineplus">+    for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l22.554"></a><span id="l22.554" class="difflineplus">+      deleteMap[item.id] = true;</span>
<a href="#l22.555"></a><span id="l22.555" class="difflineplus">+      delete this._idMap[item.id];</span>
<a href="#l22.556"></a><span id="l22.556" class="difflineplus">+      if (this._uniqueValueMap)</span>
<a href="#l22.557"></a><span id="l22.557" class="difflineplus">+        delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l22.558"></a><span id="l22.558" class="difflineplus">+    }</span>
<a href="#l22.559"></a><span id="l22.559" class="difflineplus">+    let items = this.items;</span>
<a href="#l22.560"></a><span id="l22.560" class="difflineplus">+    // in-place filter.  probably needless optimization.</span>
<a href="#l22.561"></a><span id="l22.561" class="difflineplus">+    let iWrite=0;</span>
<a href="#l22.562"></a><span id="l22.562" class="difflineplus">+    for (let iRead = 0; iRead &lt; items.length; iRead++) {</span>
<a href="#l22.563"></a><span id="l22.563" class="difflineplus">+      let item = items[iRead];</span>
<a href="#l22.564"></a><span id="l22.564" class="difflineplus">+      if (!(item.id in deleteMap))</span>
<a href="#l22.565"></a><span id="l22.565" class="difflineplus">+        items[iWrite++] = item;</span>
<a href="#l22.566"></a><span id="l22.566" class="difflineplus">+    }</span>
<a href="#l22.567"></a><span id="l22.567" class="difflineplus">+    items.slice(iWrite);</span>
<a href="#l22.568"></a><span id="l22.568" class="difflineplus">+    </span>
<a href="#l22.569"></a><span id="l22.569" class="difflineplus">+    if (this._listener) {</span>
<a href="#l22.570"></a><span id="l22.570" class="difflineplus">+      try {</span>
<a href="#l22.571"></a><span id="l22.571" class="difflineplus">+        this._listener.onItemsRemoved(aItems, this);</span>
<a href="#l22.572"></a><span id="l22.572" class="difflineplus">+      }</span>
<a href="#l22.573"></a><span id="l22.573" class="difflineplus">+      catch (ex) {</span>
<a href="#l22.574"></a><span id="l22.574" class="difflineplus">+        LOG.error(&quot;caught exception from listener in onItemsRemoved: &quot; + </span>
<a href="#l22.575"></a><span id="l22.575" class="difflineplus">+            ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l22.576"></a><span id="l22.576" class="difflineplus">+      }</span>
<a href="#l22.577"></a><span id="l22.577" class="difflineplus">+    }</span>
<a href="#l22.578"></a><span id="l22.578" class="difflineplus">+  },</span>
<a href="#l22.579"></a><span id="l22.579" class="difflineplus">+</span>
<a href="#l22.580"></a><span id="l22.580" class="difflineplus">+  _onQueryCompleted: function gloda_coll_onQueryCompleted() {</span>
<a href="#l22.581"></a><span id="l22.581" class="difflineplus">+    if (this._listener &amp;&amp; this._listener.onQueryCompleted)</span>
<a href="#l22.582"></a><span id="l22.582" class="difflineplus">+      this._listener.onQueryCompleted(this);</span>
<a href="#l22.583"></a><span id="l22.583" class="difflineplus">+  }</span>
<a href="#l22.584"></a><span id="l22.584" class="difflineplus">+};</span>
<a href="#l22.585"></a><span id="l22.585" class="difflineplus">+</span>
<a href="#l22.586"></a><span id="l22.586" class="difflineplus">+/**</span>
<a href="#l22.587"></a><span id="l22.587" class="difflineplus">+ * Create an LRU cache collection for the given noun with the given size.</span>
<a href="#l22.588"></a><span id="l22.588" class="difflineplus">+ * @constructor</span>
<a href="#l22.589"></a><span id="l22.589" class="difflineplus">+ */</span>
<a href="#l22.590"></a><span id="l22.590" class="difflineplus">+function GlodaLRUCacheCollection(aNounDef, aCacheSize) {</span>
<a href="#l22.591"></a><span id="l22.591" class="difflineplus">+  GlodaCollection.call(this, aNounDef, null, null, null);</span>
<a href="#l22.592"></a><span id="l22.592" class="difflineplus">+  </span>
<a href="#l22.593"></a><span id="l22.593" class="difflineplus">+  this._head = null; // aka oldest!</span>
<a href="#l22.594"></a><span id="l22.594" class="difflineplus">+  this._tail = null; // aka newest!</span>
<a href="#l22.595"></a><span id="l22.595" class="difflineplus">+  this._size = 0;</span>
<a href="#l22.596"></a><span id="l22.596" class="difflineplus">+  // let's keep things sane, and simplify our logic a little...</span>
<a href="#l22.597"></a><span id="l22.597" class="difflineplus">+  if (aCacheSize &lt; 32)</span>
<a href="#l22.598"></a><span id="l22.598" class="difflineplus">+    aCacheSize = 32;</span>
<a href="#l22.599"></a><span id="l22.599" class="difflineplus">+  this._maxCacheSize = aCacheSize;</span>
<a href="#l22.600"></a><span id="l22.600" class="difflineplus">+}</span>
<a href="#l22.601"></a><span id="l22.601" class="difflineplus">+/**</span>
<a href="#l22.602"></a><span id="l22.602" class="difflineplus">+ * @class A LRU-discard cache.  We use a doubly linked-list for the eviction</span>
<a href="#l22.603"></a><span id="l22.603" class="difflineplus">+ *  tracking.  Since we require that there is at most one LRU-discard cache per</span>
<a href="#l22.604"></a><span id="l22.604" class="difflineplus">+ *  noun class, we simplify our lives by adding our own attributes to the</span>
<a href="#l22.605"></a><span id="l22.605" class="difflineplus">+ *  cached objects.</span>
<a href="#l22.606"></a><span id="l22.606" class="difflineplus">+ * @augments GlodaCollection</span>
<a href="#l22.607"></a><span id="l22.607" class="difflineplus">+ */</span>
<a href="#l22.608"></a><span id="l22.608" class="difflineplus">+GlodaLRUCacheCollection.prototype = new GlodaCollection;</span>
<a href="#l22.609"></a><span id="l22.609" class="difflineplus">+GlodaLRUCacheCollection.prototype.add = function cache_add(aItems) {</span>
<a href="#l22.610"></a><span id="l22.610" class="difflineplus">+  for each (let [iItem, item] in Iterator(aItems)) {</span>
<a href="#l22.611"></a><span id="l22.611" class="difflineplus">+    if (item.id in this._idMap) {</span>
<a href="#l22.612"></a><span id="l22.612" class="difflineplus">+      // DEBUGME so, we're dealing with this, but it shouldn't happen.  need</span>
<a href="#l22.613"></a><span id="l22.613" class="difflineplus">+      //  trace-debuggage.</span>
<a href="#l22.614"></a><span id="l22.614" class="difflineplus">+      continue;</span>
<a href="#l22.615"></a><span id="l22.615" class="difflineplus">+    }</span>
<a href="#l22.616"></a><span id="l22.616" class="difflineplus">+    this._idMap[item.id] = item;</span>
<a href="#l22.617"></a><span id="l22.617" class="difflineplus">+    if (this._uniqueValueMap)</span>
<a href="#l22.618"></a><span id="l22.618" class="difflineplus">+      this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l22.619"></a><span id="l22.619" class="difflineplus">+    </span>
<a href="#l22.620"></a><span id="l22.620" class="difflineplus">+    item._lruPrev = this._tail;</span>
<a href="#l22.621"></a><span id="l22.621" class="difflineplus">+    // we do have to make sure that we will set _head the first time we insert</span>
<a href="#l22.622"></a><span id="l22.622" class="difflineplus">+    //  something</span>
<a href="#l22.623"></a><span id="l22.623" class="difflineplus">+    if (this._tail !== null)</span>
<a href="#l22.624"></a><span id="l22.624" class="difflineplus">+      this._tail._lruNext = item;</span>
<a href="#l22.625"></a><span id="l22.625" class="difflineplus">+    else</span>
<a href="#l22.626"></a><span id="l22.626" class="difflineplus">+      this._head = item;</span>
<a href="#l22.627"></a><span id="l22.627" class="difflineplus">+    item._lruNext = null;</span>
<a href="#l22.628"></a><span id="l22.628" class="difflineplus">+    this._tail = item;</span>
<a href="#l22.629"></a><span id="l22.629" class="difflineplus">+    </span>
<a href="#l22.630"></a><span id="l22.630" class="difflineplus">+    this._size++;</span>
<a href="#l22.631"></a><span id="l22.631" class="difflineplus">+  }</span>
<a href="#l22.632"></a><span id="l22.632" class="difflineplus">+  </span>
<a href="#l22.633"></a><span id="l22.633" class="difflineplus">+  while (this._size &gt; this._maxCacheSize) {</span>
<a href="#l22.634"></a><span id="l22.634" class="difflineplus">+    let item = this._head;</span>
<a href="#l22.635"></a><span id="l22.635" class="difflineplus">+    </span>
<a href="#l22.636"></a><span id="l22.636" class="difflineplus">+    // we never have to deal with the possibility of needing to make _head/_tail</span>
<a href="#l22.637"></a><span id="l22.637" class="difflineplus">+    //  null.</span>
<a href="#l22.638"></a><span id="l22.638" class="difflineplus">+    this._head = item._lruNext;</span>
<a href="#l22.639"></a><span id="l22.639" class="difflineplus">+    this._head._lruPrev = null;</span>
<a href="#l22.640"></a><span id="l22.640" class="difflineplus">+    // (because we are nice, we will delete the properties...)</span>
<a href="#l22.641"></a><span id="l22.641" class="difflineplus">+    delete item._lruNext;</span>
<a href="#l22.642"></a><span id="l22.642" class="difflineplus">+    delete item._lruPrev;</span>
<a href="#l22.643"></a><span id="l22.643" class="difflineplus">+    </span>
<a href="#l22.644"></a><span id="l22.644" class="difflineplus">+    // nuke from our id map</span>
<a href="#l22.645"></a><span id="l22.645" class="difflineplus">+    delete this._idMap[item.id];</span>
<a href="#l22.646"></a><span id="l22.646" class="difflineplus">+    if (this._uniqueValueMap)</span>
<a href="#l22.647"></a><span id="l22.647" class="difflineplus">+      delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l22.648"></a><span id="l22.648" class="difflineplus">+    </span>
<a href="#l22.649"></a><span id="l22.649" class="difflineplus">+    // flush dirty items to disk (they may not have this attribute, in which</span>
<a href="#l22.650"></a><span id="l22.650" class="difflineplus">+    //  case, this returns false, which is fine.)</span>
<a href="#l22.651"></a><span id="l22.651" class="difflineplus">+    if (item.dirty) {</span>
<a href="#l22.652"></a><span id="l22.652" class="difflineplus">+      this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l22.653"></a><span id="l22.653" class="difflineplus">+      delete item.dirty;</span>
<a href="#l22.654"></a><span id="l22.654" class="difflineplus">+    }</span>
<a href="#l22.655"></a><span id="l22.655" class="difflineplus">+    </span>
<a href="#l22.656"></a><span id="l22.656" class="difflineplus">+    this._size--;</span>
<a href="#l22.657"></a><span id="l22.657" class="difflineplus">+  }</span>
<a href="#l22.658"></a><span id="l22.658" class="difflineplus">+};</span>
<a href="#l22.659"></a><span id="l22.659" class="difflineplus">+</span>
<a href="#l22.660"></a><span id="l22.660" class="difflineplus">+GlodaLRUCacheCollection.prototype.hit = function cache_hit(aItem) {</span>
<a href="#l22.661"></a><span id="l22.661" class="difflineplus">+  // don't do anything in the 0 or 1 items case, or if we're already</span>
<a href="#l22.662"></a><span id="l22.662" class="difflineplus">+  //  the last item</span>
<a href="#l22.663"></a><span id="l22.663" class="difflineplus">+  if ((this._head === this._tail) || (this._tail === aItem))</span>
<a href="#l22.664"></a><span id="l22.664" class="difflineplus">+    return aItem;</span>
<a href="#l22.665"></a><span id="l22.665" class="difflineplus">+</span>
<a href="#l22.666"></a><span id="l22.666" class="difflineplus">+  // - unlink the item  </span>
<a href="#l22.667"></a><span id="l22.667" class="difflineplus">+  if (aItem._lruPrev !== null)</span>
<a href="#l22.668"></a><span id="l22.668" class="difflineplus">+    aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l22.669"></a><span id="l22.669" class="difflineplus">+  else</span>
<a href="#l22.670"></a><span id="l22.670" class="difflineplus">+    this._head = aItem._lruNext;</span>
<a href="#l22.671"></a><span id="l22.671" class="difflineplus">+  // (_lruNext cannot be null)</span>
<a href="#l22.672"></a><span id="l22.672" class="difflineplus">+  aItem._lruNext._lruPrev = aItem._lruPrev;</span>
<a href="#l22.673"></a><span id="l22.673" class="difflineplus">+  // - link it in to the end</span>
<a href="#l22.674"></a><span id="l22.674" class="difflineplus">+  this._tail._lruNext = aItem; </span>
<a href="#l22.675"></a><span id="l22.675" class="difflineplus">+  aItem._lruPrev = this._tail;</span>
<a href="#l22.676"></a><span id="l22.676" class="difflineplus">+  aItem._lruNext = null;</span>
<a href="#l22.677"></a><span id="l22.677" class="difflineplus">+  // update tail tracking</span>
<a href="#l22.678"></a><span id="l22.678" class="difflineplus">+  this._tail = aItem;</span>
<a href="#l22.679"></a><span id="l22.679" class="difflineplus">+  </span>
<a href="#l22.680"></a><span id="l22.680" class="difflineplus">+  return aItem;</span>
<a href="#l22.681"></a><span id="l22.681" class="difflineplus">+};</span>
<a href="#l22.682"></a><span id="l22.682" class="difflineplus">+</span>
<a href="#l22.683"></a><span id="l22.683" class="difflineplus">+GlodaLRUCacheCollection.prototype.deleted = function cache_deleted(aItem) {</span>
<a href="#l22.684"></a><span id="l22.684" class="difflineplus">+  // unlink the item  </span>
<a href="#l22.685"></a><span id="l22.685" class="difflineplus">+  if (aItem._lruPrev !== null)</span>
<a href="#l22.686"></a><span id="l22.686" class="difflineplus">+    aItem._lruPrev._lruNext = aItem._lruNext;</span>
<a href="#l22.687"></a><span id="l22.687" class="difflineplus">+  else</span>
<a href="#l22.688"></a><span id="l22.688" class="difflineplus">+    this._head = aItem._lruNext;</span>
<a href="#l22.689"></a><span id="l22.689" class="difflineplus">+  if (aItem._lruNext !== null)</span>
<a href="#l22.690"></a><span id="l22.690" class="difflineplus">+    aItem._lruNext._lruPrev = aItem._lruPrev;</span>
<a href="#l22.691"></a><span id="l22.691" class="difflineplus">+  else</span>
<a href="#l22.692"></a><span id="l22.692" class="difflineplus">+    this._tail = aItem._lruPrev;</span>
<a href="#l22.693"></a><span id="l22.693" class="difflineplus">+</span>
<a href="#l22.694"></a><span id="l22.694" class="difflineplus">+  // (because we are nice, we will delete the properties...)</span>
<a href="#l22.695"></a><span id="l22.695" class="difflineplus">+  delete aItem._lruNext;</span>
<a href="#l22.696"></a><span id="l22.696" class="difflineplus">+  delete aItem._lruPrev;</span>
<a href="#l22.697"></a><span id="l22.697" class="difflineplus">+    </span>
<a href="#l22.698"></a><span id="l22.698" class="difflineplus">+  // nuke from our id map</span>
<a href="#l22.699"></a><span id="l22.699" class="difflineplus">+  delete this._idMap[aItem.id];</span>
<a href="#l22.700"></a><span id="l22.700" class="difflineplus">+  if (this._uniqueValueMap)</span>
<a href="#l22.701"></a><span id="l22.701" class="difflineplus">+    delete this._uniqueValueMap[aItem.uniqueValue];</span>
<a href="#l22.702"></a><span id="l22.702" class="difflineplus">+  </span>
<a href="#l22.703"></a><span id="l22.703" class="difflineplus">+  this._size--;</span>
<a href="#l22.704"></a><span id="l22.704" class="difflineplus">+}</span>
<a href="#l22.705"></a><span id="l22.705" class="difflineplus">+</span>
<a href="#l22.706"></a><span id="l22.706" class="difflineplus">+/**</span>
<a href="#l22.707"></a><span id="l22.707" class="difflineplus">+ * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l22.708"></a><span id="l22.708" class="difflineplus">+ *  dirty.</span>
<a href="#l22.709"></a><span id="l22.709" class="difflineplus">+ */</span>
<a href="#l22.710"></a><span id="l22.710" class="difflineplus">+GlodaLRUCacheCollection.prototype.commitDirty = function cache_commitDirty() {</span>
<a href="#l22.711"></a><span id="l22.711" class="difflineplus">+  // we can only do this if there is an update method available...</span>
<a href="#l22.712"></a><span id="l22.712" class="difflineplus">+  if (!this._nounDef.objUpdate)</span>
<a href="#l22.713"></a><span id="l22.713" class="difflineplus">+    return;</span>
<a href="#l22.714"></a><span id="l22.714" class="difflineplus">+</span>
<a href="#l22.715"></a><span id="l22.715" class="difflineplus">+  for each (let [iItem, item] in Iterator(this._idMap)) {</span>
<a href="#l22.716"></a><span id="l22.716" class="difflineplus">+    if (item.dirty) {</span>
<a href="#l22.717"></a><span id="l22.717" class="difflineplus">+      LOG.debug(&quot;flushing dirty: &quot; + item);</span>
<a href="#l22.718"></a><span id="l22.718" class="difflineplus">+      this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l22.719"></a><span id="l22.719" class="difflineplus">+      delete item.dirty;</span>
<a href="#l22.720"></a><span id="l22.720" class="difflineplus">+    }</span>
<a href="#l22.721"></a><span id="l22.721" class="difflineplus">+  }</span>
<a href="#l22.722"></a><span id="l22.722" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1">new file mode 100644</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineminus">--- /dev/null</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/connotent.js</span>
<a href="#l23.4"></a><span id="l23.4" class="difflineat">@@ -0,0 +1,229 @@</span>
<a href="#l23.5"></a><span id="l23.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l23.6"></a><span id="l23.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l23.7"></a><span id="l23.7" class="difflineplus">+ *</span>
<a href="#l23.8"></a><span id="l23.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l23.9"></a><span id="l23.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l23.10"></a><span id="l23.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l23.11"></a><span id="l23.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineplus">+ * </span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l23.16"></a><span id="l23.16" class="difflineplus">+ * License.</span>
<a href="#l23.17"></a><span id="l23.17" class="difflineplus">+ *</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l23.19"></a><span id="l23.19" class="difflineplus">+ *</span>
<a href="#l23.20"></a><span id="l23.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l23.24"></a><span id="l23.24" class="difflineplus">+ *</span>
<a href="#l23.25"></a><span id="l23.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l23.26"></a><span id="l23.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l23.27"></a><span id="l23.27" class="difflineplus">+ *</span>
<a href="#l23.28"></a><span id="l23.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l23.29"></a><span id="l23.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l23.30"></a><span id="l23.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l23.31"></a><span id="l23.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l23.32"></a><span id="l23.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l23.33"></a><span id="l23.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l23.34"></a><span id="l23.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l23.35"></a><span id="l23.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l23.36"></a><span id="l23.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l23.37"></a><span id="l23.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l23.38"></a><span id="l23.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l23.39"></a><span id="l23.39" class="difflineplus">+ * </span>
<a href="#l23.40"></a><span id="l23.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l23.41"></a><span id="l23.41" class="difflineplus">+</span>
<a href="#l23.42"></a><span id="l23.42" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaContent'];</span>
<a href="#l23.43"></a><span id="l23.43" class="difflineplus">+</span>
<a href="#l23.44"></a><span id="l23.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l23.45"></a><span id="l23.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l23.46"></a><span id="l23.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l23.47"></a><span id="l23.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l23.48"></a><span id="l23.48" class="difflineplus">+</span>
<a href="#l23.49"></a><span id="l23.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l23.50"></a><span id="l23.50" class="difflineplus">+</span>
<a href="#l23.51"></a><span id="l23.51" class="difflineplus">+const LOG = Log4Moz.Service.getLogger(&quot;gloda.connotent&quot;);</span>
<a href="#l23.52"></a><span id="l23.52" class="difflineplus">+</span>
<a href="#l23.53"></a><span id="l23.53" class="difflineplus">+function GlodaContent() {</span>
<a href="#l23.54"></a><span id="l23.54" class="difflineplus">+  this._contentPriority = null;</span>
<a href="#l23.55"></a><span id="l23.55" class="difflineplus">+  this._producing = false;</span>
<a href="#l23.56"></a><span id="l23.56" class="difflineplus">+  this._hunks = [];</span>
<a href="#l23.57"></a><span id="l23.57" class="difflineplus">+}</span>
<a href="#l23.58"></a><span id="l23.58" class="difflineplus">+</span>
<a href="#l23.59"></a><span id="l23.59" class="difflineplus">+GlodaContent.prototype = {</span>
<a href="#l23.60"></a><span id="l23.60" class="difflineplus">+  kPriorityBase: 0,</span>
<a href="#l23.61"></a><span id="l23.61" class="difflineplus">+  kPriorityPerfect: 100,</span>
<a href="#l23.62"></a><span id="l23.62" class="difflineplus">+  </span>
<a href="#l23.63"></a><span id="l23.63" class="difflineplus">+  kHunkMeta: 1,</span>
<a href="#l23.64"></a><span id="l23.64" class="difflineplus">+  kHunkQuoted: 2,</span>
<a href="#l23.65"></a><span id="l23.65" class="difflineplus">+  kHunkContent: 3,</span>
<a href="#l23.66"></a><span id="l23.66" class="difflineplus">+  </span>
<a href="#l23.67"></a><span id="l23.67" class="difflineplus">+  _resetContent: function gloda_content__resetContent() {</span>
<a href="#l23.68"></a><span id="l23.68" class="difflineplus">+    this._keysAndValues = [];</span>
<a href="#l23.69"></a><span id="l23.69" class="difflineplus">+    this._keysAndDeltaValues = [];</span>
<a href="#l23.70"></a><span id="l23.70" class="difflineplus">+    this._hunks = [];</span>
<a href="#l23.71"></a><span id="l23.71" class="difflineplus">+    this._curHunk = null;</span>
<a href="#l23.72"></a><span id="l23.72" class="difflineplus">+  },</span>
<a href="#l23.73"></a><span id="l23.73" class="difflineplus">+  </span>
<a href="#l23.74"></a><span id="l23.74" class="difflineplus">+  /* ===== Consumer API ===== */</span>
<a href="#l23.75"></a><span id="l23.75" class="difflineplus">+  hasContent: function gloda_content_hasContent() {</span>
<a href="#l23.76"></a><span id="l23.76" class="difflineplus">+    return (this._contentPriority != null);</span>
<a href="#l23.77"></a><span id="l23.77" class="difflineplus">+  },</span>
<a href="#l23.78"></a><span id="l23.78" class="difflineplus">+  </span>
<a href="#l23.79"></a><span id="l23.79" class="difflineplus">+  /**</span>
<a href="#l23.80"></a><span id="l23.80" class="difflineplus">+   * Return content suitable for snippet display.  This means that no quoting</span>
<a href="#l23.81"></a><span id="l23.81" class="difflineplus">+   *  or meta-data should be returned.</span>
<a href="#l23.82"></a><span id="l23.82" class="difflineplus">+   * </span>
<a href="#l23.83"></a><span id="l23.83" class="difflineplus">+   * @param aMaxLength The maximum snippet length desired.</span>
<a href="#l23.84"></a><span id="l23.84" class="difflineplus">+   */</span>
<a href="#l23.85"></a><span id="l23.85" class="difflineplus">+  getContentSnippet: function gloda_content_getContentSnippet(aMaxLength) {</span>
<a href="#l23.86"></a><span id="l23.86" class="difflineplus">+    let content = this.getContentString();</span>
<a href="#l23.87"></a><span id="l23.87" class="difflineplus">+    if (aMaxLength)</span>
<a href="#l23.88"></a><span id="l23.88" class="difflineplus">+      content = content.substring(0, aMaxLength);</span>
<a href="#l23.89"></a><span id="l23.89" class="difflineplus">+    return content;</span>
<a href="#l23.90"></a><span id="l23.90" class="difflineplus">+  },</span>
<a href="#l23.91"></a><span id="l23.91" class="difflineplus">+  </span>
<a href="#l23.92"></a><span id="l23.92" class="difflineplus">+  getContentString: function gloda_content_getContent(aIndexingPurposes) {</span>
<a href="#l23.93"></a><span id="l23.93" class="difflineplus">+    let data = &quot;&quot;;</span>
<a href="#l23.94"></a><span id="l23.94" class="difflineplus">+    for each (let [, hunk] in Iterator(this._hunks)) {</span>
<a href="#l23.95"></a><span id="l23.95" class="difflineplus">+      if (hunk.hunkType == this.kHunkContent) {</span>
<a href="#l23.96"></a><span id="l23.96" class="difflineplus">+        if (data)</span>
<a href="#l23.97"></a><span id="l23.97" class="difflineplus">+          data += &quot;\n&quot; + hunk.data;</span>
<a href="#l23.98"></a><span id="l23.98" class="difflineplus">+        else</span>
<a href="#l23.99"></a><span id="l23.99" class="difflineplus">+          data = hunk.data;</span>
<a href="#l23.100"></a><span id="l23.100" class="difflineplus">+      }</span>
<a href="#l23.101"></a><span id="l23.101" class="difflineplus">+    }</span>
<a href="#l23.102"></a><span id="l23.102" class="difflineplus">+    </span>
<a href="#l23.103"></a><span id="l23.103" class="difflineplus">+    if (aIndexingPurposes) {</span>
<a href="#l23.104"></a><span id="l23.104" class="difflineplus">+      // append the values for indexing.  we assume the keywords are cruft.</span>
<a href="#l23.105"></a><span id="l23.105" class="difflineplus">+      // this may be crazy, but things that aren't a science aren't an exact</span>
<a href="#l23.106"></a><span id="l23.106" class="difflineplus">+      // science.</span>
<a href="#l23.107"></a><span id="l23.107" class="difflineplus">+      for each (let [, kv] in Iterator(this._keysAndValues)) {</span>
<a href="#l23.108"></a><span id="l23.108" class="difflineplus">+        data += &quot;\n&quot; + kv[1];</span>
<a href="#l23.109"></a><span id="l23.109" class="difflineplus">+      }</span>
<a href="#l23.110"></a><span id="l23.110" class="difflineplus">+      for each (let [, kon] in Iterator(this._keysAndValues)) {</span>
<a href="#l23.111"></a><span id="l23.111" class="difflineplus">+        data += &quot;\n&quot; + kon[1] + &quot;\n&quot; + kon[2];</span>
<a href="#l23.112"></a><span id="l23.112" class="difflineplus">+      }</span>
<a href="#l23.113"></a><span id="l23.113" class="difflineplus">+    }</span>
<a href="#l23.114"></a><span id="l23.114" class="difflineplus">+    </span>
<a href="#l23.115"></a><span id="l23.115" class="difflineplus">+    return data;</span>
<a href="#l23.116"></a><span id="l23.116" class="difflineplus">+  },</span>
<a href="#l23.117"></a><span id="l23.117" class="difflineplus">+  </span>
<a href="#l23.118"></a><span id="l23.118" class="difflineplus">+  /* ===== Producer API ===== */</span>
<a href="#l23.119"></a><span id="l23.119" class="difflineplus">+  /**</span>
<a href="#l23.120"></a><span id="l23.120" class="difflineplus">+   * Called by a producer with the priority they believe their interpretation</span>
<a href="#l23.121"></a><span id="l23.121" class="difflineplus">+   *  of the content comes in at.</span>
<a href="#l23.122"></a><span id="l23.122" class="difflineplus">+   * </span>
<a href="#l23.123"></a><span id="l23.123" class="difflineplus">+   * @returns true if we believe the producer's interpretation will be</span>
<a href="#l23.124"></a><span id="l23.124" class="difflineplus">+   *     interesting and they should go ahead and generate events.  We return</span>
<a href="#l23.125"></a><span id="l23.125" class="difflineplus">+   *     false if we don't think they are interesting, in which case they should</span>
<a href="#l23.126"></a><span id="l23.126" class="difflineplus">+   *     probably not issue calls to us, although we don't care.  (We will</span>
<a href="#l23.127"></a><span id="l23.127" class="difflineplus">+   *     ignore their calls if we return false, this allows the simplification</span>
<a href="#l23.128"></a><span id="l23.128" class="difflineplus">+   *     of code that needs to run anyways.)</span>
<a href="#l23.129"></a><span id="l23.129" class="difflineplus">+   */</span>
<a href="#l23.130"></a><span id="l23.130" class="difflineplus">+  volunteerContent: function gloda_content_volunteerContent(aPriority) {</span>
<a href="#l23.131"></a><span id="l23.131" class="difflineplus">+    if (this._contentPriority === null || this._contentPriority &lt; aPriority) {</span>
<a href="#l23.132"></a><span id="l23.132" class="difflineplus">+      this._contentPriority = aPriority;</span>
<a href="#l23.133"></a><span id="l23.133" class="difflineplus">+      this._resetContent();</span>
<a href="#l23.134"></a><span id="l23.134" class="difflineplus">+      this._producing = true;</span>
<a href="#l23.135"></a><span id="l23.135" class="difflineplus">+      return true;</span>
<a href="#l23.136"></a><span id="l23.136" class="difflineplus">+    }</span>
<a href="#l23.137"></a><span id="l23.137" class="difflineplus">+    this._producing = false;</span>
<a href="#l23.138"></a><span id="l23.138" class="difflineplus">+    return false;</span>
<a href="#l23.139"></a><span id="l23.139" class="difflineplus">+  },</span>
<a href="#l23.140"></a><span id="l23.140" class="difflineplus">+  </span>
<a href="#l23.141"></a><span id="l23.141" class="difflineplus">+  keyValue: function gloda_content_keyValue(aKey, aValue) {</span>
<a href="#l23.142"></a><span id="l23.142" class="difflineplus">+    if (!this._producing)</span>
<a href="#l23.143"></a><span id="l23.143" class="difflineplus">+      return;</span>
<a href="#l23.144"></a><span id="l23.144" class="difflineplus">+</span>
<a href="#l23.145"></a><span id="l23.145" class="difflineplus">+    this._keysAndValues.push([aKey, aValue]);</span>
<a href="#l23.146"></a><span id="l23.146" class="difflineplus">+  },</span>
<a href="#l23.147"></a><span id="l23.147" class="difflineplus">+  keyValueDelta: function gloda_content_keyValueDelta (aKey, aOldValue,</span>
<a href="#l23.148"></a><span id="l23.148" class="difflineplus">+      aNewValue) {</span>
<a href="#l23.149"></a><span id="l23.149" class="difflineplus">+    if (!this._producing)</span>
<a href="#l23.150"></a><span id="l23.150" class="difflineplus">+      return;</span>
<a href="#l23.151"></a><span id="l23.151" class="difflineplus">+</span>
<a href="#l23.152"></a><span id="l23.152" class="difflineplus">+    this._keysAndDeltaValues.push([aKey, aOldValue, aNewValue]);</span>
<a href="#l23.153"></a><span id="l23.153" class="difflineplus">+  },</span>
<a href="#l23.154"></a><span id="l23.154" class="difflineplus">+  </span>
<a href="#l23.155"></a><span id="l23.155" class="difflineplus">+  /**</span>
<a href="#l23.156"></a><span id="l23.156" class="difflineplus">+   * Meta lines are lines that have to do with the content but are not the</span>
<a href="#l23.157"></a><span id="l23.157" class="difflineplus">+   *  content and can generally be related to an attribute that has been derived</span>
<a href="#l23.158"></a><span id="l23.158" class="difflineplus">+   *  and stored on the item.</span>
<a href="#l23.159"></a><span id="l23.159" class="difflineplus">+   * For example, a bugzilla bug may note that an attachment was created; this</span>
<a href="#l23.160"></a><span id="l23.160" class="difflineplus">+   *  is not content and wouldn't be desired in a snippet, but is still</span>
<a href="#l23.161"></a><span id="l23.161" class="difflineplus">+   *  potentially interesting meta-data.</span>
<a href="#l23.162"></a><span id="l23.162" class="difflineplus">+   * </span>
<a href="#l23.163"></a><span id="l23.163" class="difflineplus">+   * @param aLineOrLines The line or list of lines that are meta-data.</span>
<a href="#l23.164"></a><span id="l23.164" class="difflineplus">+   * @param aAttr The attribute this meta-data is associated with.</span>
<a href="#l23.165"></a><span id="l23.165" class="difflineplus">+   * @param aIndex If the attribute is non-singular, indicate the specific</span>
<a href="#l23.166"></a><span id="l23.166" class="difflineplus">+   *     index of the item in the attribute's bound list that the meta-data</span>
<a href="#l23.167"></a><span id="l23.167" class="difflineplus">+   *     is associated with.</span>
<a href="#l23.168"></a><span id="l23.168" class="difflineplus">+   */</span>
<a href="#l23.169"></a><span id="l23.169" class="difflineplus">+  meta: function gloda_content_meta(aLineOrLines, aAttr, aIndex) {</span>
<a href="#l23.170"></a><span id="l23.170" class="difflineplus">+    if (!this._producing)</span>
<a href="#l23.171"></a><span id="l23.171" class="difflineplus">+      return;</span>
<a href="#l23.172"></a><span id="l23.172" class="difflineplus">+    </span>
<a href="#l23.173"></a><span id="l23.173" class="difflineplus">+    let data;</span>
<a href="#l23.174"></a><span id="l23.174" class="difflineplus">+    if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l23.175"></a><span id="l23.175" class="difflineplus">+      data = aLineOrLines;</span>
<a href="#l23.176"></a><span id="l23.176" class="difflineplus">+    else</span>
<a href="#l23.177"></a><span id="l23.177" class="difflineplus">+      data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l23.178"></a><span id="l23.178" class="difflineplus">+    </span>
<a href="#l23.179"></a><span id="l23.179" class="difflineplus">+    this._curHunk = {hunkType: this.kHunkMeta, attr: aAttr, index: aIndex,</span>
<a href="#l23.180"></a><span id="l23.180" class="difflineplus">+                     data: data};</span>
<a href="#l23.181"></a><span id="l23.181" class="difflineplus">+    this._hunks.push(this._curHunk);</span>
<a href="#l23.182"></a><span id="l23.182" class="difflineplus">+  },</span>
<a href="#l23.183"></a><span id="l23.183" class="difflineplus">+  /**</span>
<a href="#l23.184"></a><span id="l23.184" class="difflineplus">+   * Quoted lines reference previous messages or what not.</span>
<a href="#l23.185"></a><span id="l23.185" class="difflineplus">+   * </span>
<a href="#l23.186"></a><span id="l23.186" class="difflineplus">+   * @param aLineOrLiens The line or list of lines that are quoted.</span>
<a href="#l23.187"></a><span id="l23.187" class="difflineplus">+   * @param aDepth The depth of the quoting.</span>
<a href="#l23.188"></a><span id="l23.188" class="difflineplus">+   * @param aOrigin The item that originated the original content, if known.</span>
<a href="#l23.189"></a><span id="l23.189" class="difflineplus">+   *     For example, perhaps a GlodaMessage?</span>
<a href="#l23.190"></a><span id="l23.190" class="difflineplus">+   * @param aTarget A reference to the location in the original content, if</span>
<a href="#l23.191"></a><span id="l23.191" class="difflineplus">+   *     known.  For example, the index of a line in a message or something?  </span>
<a href="#l23.192"></a><span id="l23.192" class="difflineplus">+   */</span>
<a href="#l23.193"></a><span id="l23.193" class="difflineplus">+  quoted: function gloda_content_quoted(aLineOrLines, aDepth, aOrigin,</span>
<a href="#l23.194"></a><span id="l23.194" class="difflineplus">+      aTarget) {</span>
<a href="#l23.195"></a><span id="l23.195" class="difflineplus">+    if (!this._producing)</span>
<a href="#l23.196"></a><span id="l23.196" class="difflineplus">+      return;</span>
<a href="#l23.197"></a><span id="l23.197" class="difflineplus">+    </span>
<a href="#l23.198"></a><span id="l23.198" class="difflineplus">+    let data;</span>
<a href="#l23.199"></a><span id="l23.199" class="difflineplus">+    if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l23.200"></a><span id="l23.200" class="difflineplus">+      data = aLineOrLines;</span>
<a href="#l23.201"></a><span id="l23.201" class="difflineplus">+    else</span>
<a href="#l23.202"></a><span id="l23.202" class="difflineplus">+      data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l23.203"></a><span id="l23.203" class="difflineplus">+</span>
<a href="#l23.204"></a><span id="l23.204" class="difflineplus">+    if (!this._curHunk ||</span>
<a href="#l23.205"></a><span id="l23.205" class="difflineplus">+        this._curHunk.hunkType != this.kHunkQuoted ||</span>
<a href="#l23.206"></a><span id="l23.206" class="difflineplus">+        this._curHunk.depth != aDepth ||</span>
<a href="#l23.207"></a><span id="l23.207" class="difflineplus">+        this._curHunk.origin != aOrigin || this._curHunk.target != aTarget) {</span>
<a href="#l23.208"></a><span id="l23.208" class="difflineplus">+      this._curHunk = {hunkType: this.kHunkQuoted, data: data,</span>
<a href="#l23.209"></a><span id="l23.209" class="difflineplus">+                       depth: aDepth, origin: aOrigin, target: aTarget};</span>
<a href="#l23.210"></a><span id="l23.210" class="difflineplus">+      this._hunks.push(this._curHunk);</span>
<a href="#l23.211"></a><span id="l23.211" class="difflineplus">+    }</span>
<a href="#l23.212"></a><span id="l23.212" class="difflineplus">+    else</span>
<a href="#l23.213"></a><span id="l23.213" class="difflineplus">+      this._curHunk.data += &quot;\n&quot; + data; </span>
<a href="#l23.214"></a><span id="l23.214" class="difflineplus">+  },</span>
<a href="#l23.215"></a><span id="l23.215" class="difflineplus">+  </span>
<a href="#l23.216"></a><span id="l23.216" class="difflineplus">+  content: function gloda_content_content(aLineOrLines) {</span>
<a href="#l23.217"></a><span id="l23.217" class="difflineplus">+    if (!this._producing)</span>
<a href="#l23.218"></a><span id="l23.218" class="difflineplus">+      return;</span>
<a href="#l23.219"></a><span id="l23.219" class="difflineplus">+</span>
<a href="#l23.220"></a><span id="l23.220" class="difflineplus">+    let data;</span>
<a href="#l23.221"></a><span id="l23.221" class="difflineplus">+    if (typeof(aLineOrLines) == &quot;string&quot;)</span>
<a href="#l23.222"></a><span id="l23.222" class="difflineplus">+      data = aLineOrLines;</span>
<a href="#l23.223"></a><span id="l23.223" class="difflineplus">+    else</span>
<a href="#l23.224"></a><span id="l23.224" class="difflineplus">+      data = aLineOrLines.join(&quot;\n&quot;);</span>
<a href="#l23.225"></a><span id="l23.225" class="difflineplus">+    </span>
<a href="#l23.226"></a><span id="l23.226" class="difflineplus">+    if (!this._curHunk || this._curHunk.hunkType != this.kHunkContent) {</span>
<a href="#l23.227"></a><span id="l23.227" class="difflineplus">+      this._curHunk = {hunkType: this.kHunkContent, data: data};</span>
<a href="#l23.228"></a><span id="l23.228" class="difflineplus">+      this._hunks.push(this._curHunk);</span>
<a href="#l23.229"></a><span id="l23.229" class="difflineplus">+    }</span>
<a href="#l23.230"></a><span id="l23.230" class="difflineplus">+    else</span>
<a href="#l23.231"></a><span id="l23.231" class="difflineplus">+      this._curHunk.data += &quot;\n&quot; + data;</span>
<a href="#l23.232"></a><span id="l23.232" class="difflineplus">+  },</span>
<a href="#l23.233"></a><span id="l23.233" class="difflineplus">+}</span>
<a href="#l23.234"></a><span id="l23.234">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1">new file mode 100644</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineminus">--- /dev/null</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/databind.js</span>
<a href="#l24.4"></a><span id="l24.4" class="difflineat">@@ -0,0 +1,147 @@</span>
<a href="#l24.5"></a><span id="l24.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l24.6"></a><span id="l24.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l24.7"></a><span id="l24.7" class="difflineplus">+ *</span>
<a href="#l24.8"></a><span id="l24.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l24.9"></a><span id="l24.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l24.10"></a><span id="l24.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l24.11"></a><span id="l24.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineplus">+ * </span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+ * License.</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+ *</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineplus">+ *</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l24.23"></a><span id="l24.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineplus">+ *</span>
<a href="#l24.25"></a><span id="l24.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l24.26"></a><span id="l24.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l24.27"></a><span id="l24.27" class="difflineplus">+ *</span>
<a href="#l24.28"></a><span id="l24.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l24.29"></a><span id="l24.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l24.30"></a><span id="l24.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l24.35"></a><span id="l24.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l24.39"></a><span id="l24.39" class="difflineplus">+ * </span>
<a href="#l24.40"></a><span id="l24.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l24.41"></a><span id="l24.41" class="difflineplus">+</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaDatabind&quot;];</span>
<a href="#l24.43"></a><span id="l24.43" class="difflineplus">+</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+function DatabindCallback(aDatabind, aCallbackThis, aCallback, aOneShot) {</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+  this._databind = aDatabind;</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+  this._callbackThis = aCallbackThis;</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineplus">+  this._callback = aCallback;</span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+  this._oneShot = aOneShot;</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineplus">+  this._databind._datastore._pendingAsyncStatements++;</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+}</span>
<a href="#l24.58"></a><span id="l24.58" class="difflineplus">+DatabindCallback.prototype = {</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineplus">+  handleResult: function (aResultSet) {</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineplus">+    let rows = [];</span>
<a href="#l24.61"></a><span id="l24.61" class="difflineplus">+    let rowResult;</span>
<a href="#l24.62"></a><span id="l24.62" class="difflineplus">+    let getVariant = this._databind._datastore._getVariant;</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineplus">+    while (rowResult = aResultSet.getNextRow()) {</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineplus">+      let row = {};</span>
<a href="#l24.65"></a><span id="l24.65" class="difflineplus">+      for each (let [iCol, colDef] in</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineplus">+                Iterator(this._databind._tableDef.columns)) {</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineplus">+        let colName = colDef[0];</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+        row[colName] = getVariant(rowResult, iCol);</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+      }</span>
<a href="#l24.70"></a><span id="l24.70" class="difflineplus">+      rows.push(row);</span>
<a href="#l24.71"></a><span id="l24.71" class="difflineplus">+    }</span>
<a href="#l24.72"></a><span id="l24.72" class="difflineplus">+    this._callback.call(this._callbackThis, rows, false);</span>
<a href="#l24.73"></a><span id="l24.73" class="difflineplus">+  },</span>
<a href="#l24.74"></a><span id="l24.74" class="difflineplus">+  handleError: function (aError) {</span>
<a href="#l24.75"></a><span id="l24.75" class="difflineplus">+  },</span>
<a href="#l24.76"></a><span id="l24.76" class="difflineplus">+  handleCompletion: function () {</span>
<a href="#l24.77"></a><span id="l24.77" class="difflineplus">+    this._callback.call(this._callbackThis, [], true);</span>
<a href="#l24.78"></a><span id="l24.78" class="difflineplus">+    this._databind._datastore._asyncCompleted();</span>
<a href="#l24.79"></a><span id="l24.79" class="difflineplus">+  },</span>
<a href="#l24.80"></a><span id="l24.80" class="difflineplus">+}</span>
<a href="#l24.81"></a><span id="l24.81" class="difflineplus">+</span>
<a href="#l24.82"></a><span id="l24.82" class="difflineplus">+function GlodaDatabind(aTableDef, aDatastore) {</span>
<a href="#l24.83"></a><span id="l24.83" class="difflineplus">+  this._tableDef = aTableDef;</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineplus">+  this._datastore = aDatastore;</span>
<a href="#l24.85"></a><span id="l24.85" class="difflineplus">+  this._log = Log4Moz.Service.getLogger(&quot;gloda.databind.&quot; + aTableDef.name);</span>
<a href="#l24.86"></a><span id="l24.86" class="difflineplus">+  </span>
<a href="#l24.87"></a><span id="l24.87" class="difflineplus">+  let insertSql = &quot;INSERT INTO &quot; + this._tableDef._realName + &quot; (&quot; +</span>
<a href="#l24.88"></a><span id="l24.88" class="difflineplus">+    [coldef[0] for each</span>
<a href="#l24.89"></a><span id="l24.89" class="difflineplus">+     ([i, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l24.90"></a><span id="l24.90" class="difflineplus">+    &quot;) VALUES (&quot; +</span>
<a href="#l24.91"></a><span id="l24.91" class="difflineplus">+    [(&quot;:&quot; + coldef[0]) for each</span>
<a href="#l24.92"></a><span id="l24.92" class="difflineplus">+     ([i, coldef] in Iterator(this._tableDef.columns))].join(&quot;, &quot;) +</span>
<a href="#l24.93"></a><span id="l24.93" class="difflineplus">+    &quot;)&quot;;</span>
<a href="#l24.94"></a><span id="l24.94" class="difflineplus">+  </span>
<a href="#l24.95"></a><span id="l24.95" class="difflineplus">+  this._insertStmt = aDatastore._createAsyncStatement(insertSql);</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineplus">+  </span>
<a href="#l24.97"></a><span id="l24.97" class="difflineplus">+  this._stmtCache = {};</span>
<a href="#l24.98"></a><span id="l24.98" class="difflineplus">+}</span>
<a href="#l24.99"></a><span id="l24.99" class="difflineplus">+</span>
<a href="#l24.100"></a><span id="l24.100" class="difflineplus">+GlodaDatabind.prototype = {</span>
<a href="#l24.101"></a><span id="l24.101" class="difflineplus">+  /*</span>
<a href="#l24.102"></a><span id="l24.102" class="difflineplus">+  getHighId: function(aLessThan) {</span>
<a href="#l24.103"></a><span id="l24.103" class="difflineplus">+    let sql = &quot;select MAX(id) AS m_id FROM &quot; + this._tableDef._realName;</span>
<a href="#l24.104"></a><span id="l24.104" class="difflineplus">+    if (aLessThan !== undefined)</span>
<a href="#l24.105"></a><span id="l24.105" class="difflineplus">+      sql += &quot; WHERE id &lt; &quot; + aLessThan;</span>
<a href="#l24.106"></a><span id="l24.106" class="difflineplus">+  dump(&quot;SQL: &quot; + sql);</span>
<a href="#l24.107"></a><span id="l24.107" class="difflineplus">+    let stmt = this._datastore._createStatement(sql);</span>
<a href="#l24.108"></a><span id="l24.108" class="difflineplus">+  dump(&quot;created\n&quot;);</span>
<a href="#l24.109"></a><span id="l24.109" class="difflineplus">+    let highId = 0;</span>
<a href="#l24.110"></a><span id="l24.110" class="difflineplus">+    if (stmt.step()) {</span>
<a href="#l24.111"></a><span id="l24.111" class="difflineplus">+      dump(&quot;stepped, retrieving\n&quot;);</span>
<a href="#l24.112"></a><span id="l24.112" class="difflineplus">+      highId = stmt.row[&quot;m_id&quot;];</span>
<a href="#l24.113"></a><span id="l24.113" class="difflineplus">+    }</span>
<a href="#l24.114"></a><span id="l24.114" class="difflineplus">+    stmt.reset();</span>
<a href="#l24.115"></a><span id="l24.115" class="difflineplus">+    </span>
<a href="#l24.116"></a><span id="l24.116" class="difflineplus">+    return highId;</span>
<a href="#l24.117"></a><span id="l24.117" class="difflineplus">+  },</span>
<a href="#l24.118"></a><span id="l24.118" class="difflineplus">+  */</span>
<a href="#l24.119"></a><span id="l24.119" class="difflineplus">+    </span>
<a href="#l24.120"></a><span id="l24.120" class="difflineplus">+  select: function(aColName, aColValue, aCallbackThis, aCallback) {</span>
<a href="#l24.121"></a><span id="l24.121" class="difflineplus">+    let stmt;</span>
<a href="#l24.122"></a><span id="l24.122" class="difflineplus">+    if (!(aColName in this._stmtCache)) {</span>
<a href="#l24.123"></a><span id="l24.123" class="difflineplus">+      let sqlString = &quot;SELECT * FROM &quot; + this._tableDef._realName;</span>
<a href="#l24.124"></a><span id="l24.124" class="difflineplus">+      if (aColName)</span>
<a href="#l24.125"></a><span id="l24.125" class="difflineplus">+        sqlString += &quot; WHERE &quot; + aColName + &quot; = :value&quot;;</span>
<a href="#l24.126"></a><span id="l24.126" class="difflineplus">+      stmt = this._datastore._createAsyncStatement(sqlString);</span>
<a href="#l24.127"></a><span id="l24.127" class="difflineplus">+      this._stmtCache[aColName] = stmt;</span>
<a href="#l24.128"></a><span id="l24.128" class="difflineplus">+    }</span>
<a href="#l24.129"></a><span id="l24.129" class="difflineplus">+    else</span>
<a href="#l24.130"></a><span id="l24.130" class="difflineplus">+      stmt = this._stmtCache[aColName];</span>
<a href="#l24.131"></a><span id="l24.131" class="difflineplus">+    </span>
<a href="#l24.132"></a><span id="l24.132" class="difflineplus">+    if (aColName)</span>
<a href="#l24.133"></a><span id="l24.133" class="difflineplus">+      this._datastore._bindVariant(stmt, 0, aColValue);</span>
<a href="#l24.134"></a><span id="l24.134" class="difflineplus">+    // so, we're tricky-like and lazy and actually return the row, so we don't</span>
<a href="#l24.135"></a><span id="l24.135" class="difflineplus">+    //  want to reset until the user tries to use the statement again, as I</span>
<a href="#l24.136"></a><span id="l24.136" class="difflineplus">+    //  fear we would otherwise lose our awesome row binding (and have to copy</span>
<a href="#l24.137"></a><span id="l24.137" class="difflineplus">+    //  it, etc.)</span>
<a href="#l24.138"></a><span id="l24.138" class="difflineplus">+    stmt.executeAsync(new DatabindCallback(this, aCallbackThis, aCallback));</span>
<a href="#l24.139"></a><span id="l24.139" class="difflineplus">+  },</span>
<a href="#l24.140"></a><span id="l24.140" class="difflineplus">+  </span>
<a href="#l24.141"></a><span id="l24.141" class="difflineplus">+  insert: function(aValueDicts) {</span>
<a href="#l24.142"></a><span id="l24.142" class="difflineplus">+    let stmt = this._insertStmt;</span>
<a href="#l24.143"></a><span id="l24.143" class="difflineplus">+    for each (let [,valueDict] in Iterator(aValueDicts)) {</span>
<a href="#l24.144"></a><span id="l24.144" class="difflineplus">+      for each (let [iColDef, colDef] in Iterator(this._tableDef.columns)) {</span>
<a href="#l24.145"></a><span id="l24.145" class="difflineplus">+        this._log.debug(&quot;insert arg: &quot; + colDef[0] + &quot;=&quot; + valueDict[colDef[0]]);</span>
<a href="#l24.146"></a><span id="l24.146" class="difflineplus">+        stmt.params[colDef[0]] = valueDict[colDef[0]];</span>
<a href="#l24.147"></a><span id="l24.147" class="difflineplus">+      }</span>
<a href="#l24.148"></a><span id="l24.148" class="difflineplus">+      stmt.executeAsync(this._datastore.trackAsync());</span>
<a href="#l24.149"></a><span id="l24.149" class="difflineplus">+    }</span>
<a href="#l24.150"></a><span id="l24.150" class="difflineplus">+  }</span>
<a href="#l24.151"></a><span id="l24.151" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1">new file mode 100644</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineminus">--- /dev/null</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l25.4"></a><span id="l25.4" class="difflineat">@@ -0,0 +1,470 @@</span>
<a href="#l25.5"></a><span id="l25.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l25.6"></a><span id="l25.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l25.7"></a><span id="l25.7" class="difflineplus">+ *</span>
<a href="#l25.8"></a><span id="l25.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l25.9"></a><span id="l25.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l25.10"></a><span id="l25.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l25.11"></a><span id="l25.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineplus">+ *</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l25.14"></a><span id="l25.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l25.15"></a><span id="l25.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l25.16"></a><span id="l25.16" class="difflineplus">+ * License.</span>
<a href="#l25.17"></a><span id="l25.17" class="difflineplus">+ *</span>
<a href="#l25.18"></a><span id="l25.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l25.19"></a><span id="l25.19" class="difflineplus">+ *</span>
<a href="#l25.20"></a><span id="l25.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l25.21"></a><span id="l25.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l25.22"></a><span id="l25.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l25.23"></a><span id="l25.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l25.24"></a><span id="l25.24" class="difflineplus">+ *</span>
<a href="#l25.25"></a><span id="l25.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l25.26"></a><span id="l25.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l25.27"></a><span id="l25.27" class="difflineplus">+ *</span>
<a href="#l25.28"></a><span id="l25.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l25.29"></a><span id="l25.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l25.30"></a><span id="l25.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l25.31"></a><span id="l25.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l25.32"></a><span id="l25.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l25.33"></a><span id="l25.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l25.34"></a><span id="l25.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l25.35"></a><span id="l25.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l25.36"></a><span id="l25.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l25.37"></a><span id="l25.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l25.38"></a><span id="l25.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l25.39"></a><span id="l25.39" class="difflineplus">+ *</span>
<a href="#l25.40"></a><span id="l25.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l25.41"></a><span id="l25.41" class="difflineplus">+</span>
<a href="#l25.42"></a><span id="l25.42" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaAttributeDBDef&quot;,</span>
<a href="#l25.43"></a><span id="l25.43" class="difflineplus">+                    &quot;GlodaConversation&quot;, &quot;GlodaFolder&quot;, &quot;GlodaMessage&quot;,</span>
<a href="#l25.44"></a><span id="l25.44" class="difflineplus">+                    &quot;GlodaContact&quot;, &quot;GlodaIdentity&quot;];</span>
<a href="#l25.45"></a><span id="l25.45" class="difflineplus">+</span>
<a href="#l25.46"></a><span id="l25.46" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l25.47"></a><span id="l25.47" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l25.48"></a><span id="l25.48" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l25.49"></a><span id="l25.49" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l25.50"></a><span id="l25.50" class="difflineplus">+</span>
<a href="#l25.51"></a><span id="l25.51" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l25.52"></a><span id="l25.52" class="difflineplus">+const LOG = Log4Moz.Service.getLogger(&quot;gloda.datamodel&quot;);</span>
<a href="#l25.53"></a><span id="l25.53" class="difflineplus">+</span>
<a href="#l25.54"></a><span id="l25.54" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l25.55"></a><span id="l25.55" class="difflineplus">+</span>
<a href="#l25.56"></a><span id="l25.56" class="difflineplus">+/**</span>
<a href="#l25.57"></a><span id="l25.57" class="difflineplus">+ * @class Represents a gloda attribute definition's DB form.  This class</span>
<a href="#l25.58"></a><span id="l25.58" class="difflineplus">+ *  stores the information in the database relating to this attribute</span>
<a href="#l25.59"></a><span id="l25.59" class="difflineplus">+ *  definition.  Access its attrDef attribute to get at the realy juicy data.</span>
<a href="#l25.60"></a><span id="l25.60" class="difflineplus">+ *  This main interesting thing this class does is serve as the keeper of the</span>
<a href="#l25.61"></a><span id="l25.61" class="difflineplus">+ *  mapping from parameters to attribute ids in the database if this is a </span>
<a href="#l25.62"></a><span id="l25.62" class="difflineplus">+ *  parameterized attribute.</span>
<a href="#l25.63"></a><span id="l25.63" class="difflineplus">+ */</span>
<a href="#l25.64"></a><span id="l25.64" class="difflineplus">+function GlodaAttributeDBDef(aDatastore, aID, aCompoundName, aAttrType,</span>
<a href="#l25.65"></a><span id="l25.65" class="difflineplus">+                           aPluginName, aAttrName) {</span>
<a href="#l25.66"></a><span id="l25.66" class="difflineplus">+  this._datastore = aDatastore;</span>
<a href="#l25.67"></a><span id="l25.67" class="difflineplus">+  this._id = aID;</span>
<a href="#l25.68"></a><span id="l25.68" class="difflineplus">+  this._compoundName = aCompoundName;</span>
<a href="#l25.69"></a><span id="l25.69" class="difflineplus">+  this._attrType = aAttrType;</span>
<a href="#l25.70"></a><span id="l25.70" class="difflineplus">+  this._pluginName = aPluginName;</span>
<a href="#l25.71"></a><span id="l25.71" class="difflineplus">+  this._attrName = aAttrName;</span>
<a href="#l25.72"></a><span id="l25.72" class="difflineplus">+  </span>
<a href="#l25.73"></a><span id="l25.73" class="difflineplus">+  this.attrDef = null;</span>
<a href="#l25.74"></a><span id="l25.74" class="difflineplus">+</span>
<a href="#l25.75"></a><span id="l25.75" class="difflineplus">+  /** Map parameter values to the underlying database id. */</span>
<a href="#l25.76"></a><span id="l25.76" class="difflineplus">+  this._parameterBindings = {};</span>
<a href="#l25.77"></a><span id="l25.77" class="difflineplus">+}</span>
<a href="#l25.78"></a><span id="l25.78" class="difflineplus">+</span>
<a href="#l25.79"></a><span id="l25.79" class="difflineplus">+GlodaAttributeDBDef.prototype = {</span>
<a href="#l25.80"></a><span id="l25.80" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l25.81"></a><span id="l25.81" class="difflineplus">+  get attributeName() { return this._attrName; },</span>
<a href="#l25.82"></a><span id="l25.82" class="difflineplus">+</span>
<a href="#l25.83"></a><span id="l25.83" class="difflineplus">+  get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l25.84"></a><span id="l25.84" class="difflineplus">+  </span>
<a href="#l25.85"></a><span id="l25.85" class="difflineplus">+  /**</span>
<a href="#l25.86"></a><span id="l25.86" class="difflineplus">+   * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l25.87"></a><span id="l25.87" class="difflineplus">+   *  attribute-parameter as an attribute.</span>
<a href="#l25.88"></a><span id="l25.88" class="difflineplus">+   *</span>
<a href="#l25.89"></a><span id="l25.89" class="difflineplus">+   * @return</span>
<a href="#l25.90"></a><span id="l25.90" class="difflineplus">+   */</span>
<a href="#l25.91"></a><span id="l25.91" class="difflineplus">+  bindParameter: function gloda_attr_bindParameter(aValue) {</span>
<a href="#l25.92"></a><span id="l25.92" class="difflineplus">+    // people probably shouldn't call us with null, but handle it</span>
<a href="#l25.93"></a><span id="l25.93" class="difflineplus">+    if (aValue == null) {</span>
<a href="#l25.94"></a><span id="l25.94" class="difflineplus">+      return this._id;</span>
<a href="#l25.95"></a><span id="l25.95" class="difflineplus">+    }</span>
<a href="#l25.96"></a><span id="l25.96" class="difflineplus">+    if (aValue in this._parameterBindings) {</span>
<a href="#l25.97"></a><span id="l25.97" class="difflineplus">+      return this._parameterBindings[aValue];</span>
<a href="#l25.98"></a><span id="l25.98" class="difflineplus">+    }</span>
<a href="#l25.99"></a><span id="l25.99" class="difflineplus">+    // no database entry exists if we are here, so we must create it...</span>
<a href="#l25.100"></a><span id="l25.100" class="difflineplus">+    let id = this._datastore._createAttributeDef(this._attrType,</span>
<a href="#l25.101"></a><span id="l25.101" class="difflineplus">+                 this._pluginName, this._attrName, aValue);</span>
<a href="#l25.102"></a><span id="l25.102" class="difflineplus">+    this._parameterBindings[aValue] = id;</span>
<a href="#l25.103"></a><span id="l25.103" class="difflineplus">+    this._datastore.reportBinding(id, this, aValue);</span>
<a href="#l25.104"></a><span id="l25.104" class="difflineplus">+    return id;</span>
<a href="#l25.105"></a><span id="l25.105" class="difflineplus">+  },</span>
<a href="#l25.106"></a><span id="l25.106" class="difflineplus">+</span>
<a href="#l25.107"></a><span id="l25.107" class="difflineplus">+  /**</span>
<a href="#l25.108"></a><span id="l25.108" class="difflineplus">+   * Given a list of values (if non-singular) or a single value (if singular),</span>
<a href="#l25.109"></a><span id="l25.109" class="difflineplus">+   *  return a list (regardless of plurality) of database-ready [attribute id,</span>
<a href="#l25.110"></a><span id="l25.110" class="difflineplus">+   *  value] tuples.  This is intended to be used to directly convert the value</span>
<a href="#l25.111"></a><span id="l25.111" class="difflineplus">+   *  of a property on an object that corresponds to a bound attribute.</span>
<a href="#l25.112"></a><span id="l25.112" class="difflineplus">+   */</span>
<a href="#l25.113"></a><span id="l25.113" class="difflineplus">+  convertValuesToDBAttributes:</span>
<a href="#l25.114"></a><span id="l25.114" class="difflineplus">+      function gloda_attr_convertValuesToDBAttributes(aInstanceValues) {</span>
<a href="#l25.115"></a><span id="l25.115" class="difflineplus">+    let nounDef = this.attrDef.objectNounDef;</span>
<a href="#l25.116"></a><span id="l25.116" class="difflineplus">+    if (this._singular) {</span>
<a href="#l25.117"></a><span id="l25.117" class="difflineplus">+      if (nounDef.usesParameter) {</span>
<a href="#l25.118"></a><span id="l25.118" class="difflineplus">+        let [param, dbValue] = nounDef.toParamAndValue(aInstanceValues);</span>
<a href="#l25.119"></a><span id="l25.119" class="difflineplus">+        return [[this.bindParameter(param), dbValue]];</span>
<a href="#l25.120"></a><span id="l25.120" class="difflineplus">+      }</span>
<a href="#l25.121"></a><span id="l25.121" class="difflineplus">+      else {</span>
<a href="#l25.122"></a><span id="l25.122" class="difflineplus">+        return [[this._id, nounDef.toParamAndValue(aInstanceValues)[1]]];</span>
<a href="#l25.123"></a><span id="l25.123" class="difflineplus">+      }</span>
<a href="#l25.124"></a><span id="l25.124" class="difflineplus">+    }</span>
<a href="#l25.125"></a><span id="l25.125" class="difflineplus">+    else {</span>
<a href="#l25.126"></a><span id="l25.126" class="difflineplus">+      let dbAttributes = [];</span>
<a href="#l25.127"></a><span id="l25.127" class="difflineplus">+      if (nounDef.usesParameter) {</span>
<a href="#l25.128"></a><span id="l25.128" class="difflineplus">+        for each (let [, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l25.129"></a><span id="l25.129" class="difflineplus">+          let [param, dbValue] = nounDef.toParamAndValue(instanceValue);</span>
<a href="#l25.130"></a><span id="l25.130" class="difflineplus">+          dbAttributes.push([this.bindParameter(param), dbValue]);</span>
<a href="#l25.131"></a><span id="l25.131" class="difflineplus">+        }</span>
<a href="#l25.132"></a><span id="l25.132" class="difflineplus">+      }</span>
<a href="#l25.133"></a><span id="l25.133" class="difflineplus">+      else {</span>
<a href="#l25.134"></a><span id="l25.134" class="difflineplus">+        for each (let [, instanceValue] in Iterator(aInstanceValues)) {</span>
<a href="#l25.135"></a><span id="l25.135" class="difflineplus">+          dbAttributes.push([this._id,</span>
<a href="#l25.136"></a><span id="l25.136" class="difflineplus">+                             nounDef.toParamAndValue(instanceValue)[1]]);</span>
<a href="#l25.137"></a><span id="l25.137" class="difflineplus">+        }</span>
<a href="#l25.138"></a><span id="l25.138" class="difflineplus">+      }</span>
<a href="#l25.139"></a><span id="l25.139" class="difflineplus">+      return dbAttributes;</span>
<a href="#l25.140"></a><span id="l25.140" class="difflineplus">+    }</span>
<a href="#l25.141"></a><span id="l25.141" class="difflineplus">+  },</span>
<a href="#l25.142"></a><span id="l25.142" class="difflineplus">+</span>
<a href="#l25.143"></a><span id="l25.143" class="difflineplus">+  toString: function() {</span>
<a href="#l25.144"></a><span id="l25.144" class="difflineplus">+    return this._compoundName;</span>
<a href="#l25.145"></a><span id="l25.145" class="difflineplus">+  }</span>
<a href="#l25.146"></a><span id="l25.146" class="difflineplus">+};</span>
<a href="#l25.147"></a><span id="l25.147" class="difflineplus">+</span>
<a href="#l25.148"></a><span id="l25.148" class="difflineplus">+let GlodaHasAttributesMixIn = {</span>
<a href="#l25.149"></a><span id="l25.149" class="difflineplus">+  enumerateAttributes: function gloda_attrix_enumerateAttributes() {</span>
<a href="#l25.150"></a><span id="l25.150" class="difflineplus">+    let nounDef = this.NOUN_DEF;</span>
<a href="#l25.151"></a><span id="l25.151" class="difflineplus">+    for each (let [key, value] in Iterator(this)) {</span>
<a href="#l25.152"></a><span id="l25.152" class="difflineplus">+      let attrDef = nounDef.attribsByBoundName[key];</span>
<a href="#l25.153"></a><span id="l25.153" class="difflineplus">+      // we expect to not have attributes for underscore prefixed values (those</span>
<a href="#l25.154"></a><span id="l25.154" class="difflineplus">+      //  are managed by the instance's logic.  we also want to not explode</span>
<a href="#l25.155"></a><span id="l25.155" class="difflineplus">+      //  should someone crap other values in there, we get both birds with this</span>
<a href="#l25.156"></a><span id="l25.156" class="difflineplus">+      //  one stone.</span>
<a href="#l25.157"></a><span id="l25.157" class="difflineplus">+      if (attrDef === undefined)</span>
<a href="#l25.158"></a><span id="l25.158" class="difflineplus">+        continue;</span>
<a href="#l25.159"></a><span id="l25.159" class="difflineplus">+      if (attrDef.singular) {</span>
<a href="#l25.160"></a><span id="l25.160" class="difflineplus">+        // ignore attributes with null values</span>
<a href="#l25.161"></a><span id="l25.161" class="difflineplus">+        if (value != null)</span>
<a href="#l25.162"></a><span id="l25.162" class="difflineplus">+          yield [attrDef, [value]];</span>
<a href="#l25.163"></a><span id="l25.163" class="difflineplus">+      }</span>
<a href="#l25.164"></a><span id="l25.164" class="difflineplus">+      else {</span>
<a href="#l25.165"></a><span id="l25.165" class="difflineplus">+        // ignore attributes with no values</span>
<a href="#l25.166"></a><span id="l25.166" class="difflineplus">+        if (value.length)</span>
<a href="#l25.167"></a><span id="l25.167" class="difflineplus">+          yield [attrDef, value];</span>
<a href="#l25.168"></a><span id="l25.168" class="difflineplus">+      }</span>
<a href="#l25.169"></a><span id="l25.169" class="difflineplus">+    }</span>
<a href="#l25.170"></a><span id="l25.170" class="difflineplus">+  },</span>
<a href="#l25.171"></a><span id="l25.171" class="difflineplus">+  </span>
<a href="#l25.172"></a><span id="l25.172" class="difflineplus">+  domContribute: function gloda_attrix_domContribute(aDomNode) {</span>
<a href="#l25.173"></a><span id="l25.173" class="difflineplus">+    let nounDef = this.NOUN_DEF;</span>
<a href="#l25.174"></a><span id="l25.174" class="difflineplus">+    for each (let [attrName, attr] in</span>
<a href="#l25.175"></a><span id="l25.175" class="difflineplus">+        Iterator(nounDef.domExposeAttribsByBoundName)) {</span>
<a href="#l25.176"></a><span id="l25.176" class="difflineplus">+      if (this[attrName])</span>
<a href="#l25.177"></a><span id="l25.177" class="difflineplus">+        aDomNode.setAttribute(attr.domExpose, this[attrName]);</span>
<a href="#l25.178"></a><span id="l25.178" class="difflineplus">+    }</span>
<a href="#l25.179"></a><span id="l25.179" class="difflineplus">+  },</span>
<a href="#l25.180"></a><span id="l25.180" class="difflineplus">+};</span>
<a href="#l25.181"></a><span id="l25.181" class="difflineplus">+</span>
<a href="#l25.182"></a><span id="l25.182" class="difflineplus">+function MixIn(aConstructor, aMixIn) {</span>
<a href="#l25.183"></a><span id="l25.183" class="difflineplus">+  let proto = aConstructor.prototype;</span>
<a href="#l25.184"></a><span id="l25.184" class="difflineplus">+  for (let [name, func] in Iterator(aMixIn)) {</span>
<a href="#l25.185"></a><span id="l25.185" class="difflineplus">+    if (name.substring(0, 4) == &quot;get_&quot;)</span>
<a href="#l25.186"></a><span id="l25.186" class="difflineplus">+      proto.__defineGetter__(name.substring(4), func);</span>
<a href="#l25.187"></a><span id="l25.187" class="difflineplus">+    else</span>
<a href="#l25.188"></a><span id="l25.188" class="difflineplus">+      proto[name] = func;</span>
<a href="#l25.189"></a><span id="l25.189" class="difflineplus">+  }</span>
<a href="#l25.190"></a><span id="l25.190" class="difflineplus">+}</span>
<a href="#l25.191"></a><span id="l25.191" class="difflineplus">+</span>
<a href="#l25.192"></a><span id="l25.192" class="difflineplus">+/**</span>
<a href="#l25.193"></a><span id="l25.193" class="difflineplus">+ * @class A gloda conversation (thread) exists so that messages can belong.</span>
<a href="#l25.194"></a><span id="l25.194" class="difflineplus">+ */</span>
<a href="#l25.195"></a><span id="l25.195" class="difflineplus">+function GlodaConversation(aDatastore, aID, aSubject, aOldestMessageDate,</span>
<a href="#l25.196"></a><span id="l25.196" class="difflineplus">+                           aNewestMessageDate) {</span>
<a href="#l25.197"></a><span id="l25.197" class="difflineplus">+  this._datastore = aDatastore;</span>
<a href="#l25.198"></a><span id="l25.198" class="difflineplus">+  this._id = aID;</span>
<a href="#l25.199"></a><span id="l25.199" class="difflineplus">+  this._subject = aSubject;</span>
<a href="#l25.200"></a><span id="l25.200" class="difflineplus">+  this._oldestMessageDate = aOldestMessageDate;</span>
<a href="#l25.201"></a><span id="l25.201" class="difflineplus">+  this._newestMessageDate = aNewestMessageDate;</span>
<a href="#l25.202"></a><span id="l25.202" class="difflineplus">+}</span>
<a href="#l25.203"></a><span id="l25.203" class="difflineplus">+</span>
<a href="#l25.204"></a><span id="l25.204" class="difflineplus">+GlodaConversation.prototype = {</span>
<a href="#l25.205"></a><span id="l25.205" class="difflineplus">+  NOUN_ID: 101,</span>
<a href="#l25.206"></a><span id="l25.206" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l25.207"></a><span id="l25.207" class="difflineplus">+  get subject() { return this._subject; },</span>
<a href="#l25.208"></a><span id="l25.208" class="difflineplus">+  get oldestMessageDate() { return this._oldestMessageDate; },</span>
<a href="#l25.209"></a><span id="l25.209" class="difflineplus">+  get newestMessageDate() { return this._newestMessageDate; },</span>
<a href="#l25.210"></a><span id="l25.210" class="difflineplus">+  </span>
<a href="#l25.211"></a><span id="l25.211" class="difflineplus">+  getMessagesCollection: function gloda_conversation_getMessagesCollection(</span>
<a href="#l25.212"></a><span id="l25.212" class="difflineplus">+    aListener, aData) {</span>
<a href="#l25.213"></a><span id="l25.213" class="difflineplus">+    let query = new GlodaMessage.prototype.NOUN_DEF.queryClass();</span>
<a href="#l25.214"></a><span id="l25.214" class="difflineplus">+    query.conversation(this._id).orderBy(&quot;date&quot;);</span>
<a href="#l25.215"></a><span id="l25.215" class="difflineplus">+    return query.getCollection(aListener, aData);</span>
<a href="#l25.216"></a><span id="l25.216" class="difflineplus">+  },</span>
<a href="#l25.217"></a><span id="l25.217" class="difflineplus">+</span>
<a href="#l25.218"></a><span id="l25.218" class="difflineplus">+  toString: function gloda_conversation_toString() {</span>
<a href="#l25.219"></a><span id="l25.219" class="difflineplus">+    return &quot;Conversation:&quot; + this._id;</span>
<a href="#l25.220"></a><span id="l25.220" class="difflineplus">+  },</span>
<a href="#l25.221"></a><span id="l25.221" class="difflineplus">+};</span>
<a href="#l25.222"></a><span id="l25.222" class="difflineplus">+</span>
<a href="#l25.223"></a><span id="l25.223" class="difflineplus">+function GlodaFolder(aDatastore, aID, aURI, aDirtyStatus, aPrettyName) {</span>
<a href="#l25.224"></a><span id="l25.224" class="difflineplus">+  this._datastore = aDatastore;</span>
<a href="#l25.225"></a><span id="l25.225" class="difflineplus">+  this._id = aID;</span>
<a href="#l25.226"></a><span id="l25.226" class="difflineplus">+  this._uri = aURI;</span>
<a href="#l25.227"></a><span id="l25.227" class="difflineplus">+  this._dirtyStatus = aDirtyStatus;</span>
<a href="#l25.228"></a><span id="l25.228" class="difflineplus">+  this._prettyName = aPrettyName;</span>
<a href="#l25.229"></a><span id="l25.229" class="difflineplus">+}</span>
<a href="#l25.230"></a><span id="l25.230" class="difflineplus">+</span>
<a href="#l25.231"></a><span id="l25.231" class="difflineplus">+GlodaFolder.prototype = {</span>
<a href="#l25.232"></a><span id="l25.232" class="difflineplus">+  NOUN_ID: 100,</span>
<a href="#l25.233"></a><span id="l25.233" class="difflineplus">+  /** The folder is believed to be up-to-date */</span>
<a href="#l25.234"></a><span id="l25.234" class="difflineplus">+  kFolderClean: 0,</span>
<a href="#l25.235"></a><span id="l25.235" class="difflineplus">+  /** The folder has some un-indexed or dirty messages */</span>
<a href="#l25.236"></a><span id="l25.236" class="difflineplus">+  kFolderDirty: 1,</span>
<a href="#l25.237"></a><span id="l25.237" class="difflineplus">+  /** The folder needs to be entirely re-indexed, regardless of the flags on</span>
<a href="#l25.238"></a><span id="l25.238" class="difflineplus">+   * the messages in the folder. This state will be downgraded to dirty */</span>
<a href="#l25.239"></a><span id="l25.239" class="difflineplus">+  kFolderFilthy: 2,</span>
<a href="#l25.240"></a><span id="l25.240" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l25.241"></a><span id="l25.241" class="difflineplus">+  get uri() { return this._uri; },</span>
<a href="#l25.242"></a><span id="l25.242" class="difflineplus">+  get dirtyStatus() { return this._dirtyStatus; },</span>
<a href="#l25.243"></a><span id="l25.243" class="difflineplus">+  set dirtyStatus(aNewStatus) {</span>
<a href="#l25.244"></a><span id="l25.244" class="difflineplus">+    if (aNewStatus != this._dirtyStatus) {</span>
<a href="#l25.245"></a><span id="l25.245" class="difflineplus">+      this._dirtyStatus = aNewStatus;</span>
<a href="#l25.246"></a><span id="l25.246" class="difflineplus">+      this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l25.247"></a><span id="l25.247" class="difflineplus">+    }</span>
<a href="#l25.248"></a><span id="l25.248" class="difflineplus">+  },</span>
<a href="#l25.249"></a><span id="l25.249" class="difflineplus">+  get name() { return this._prettyName; },</span>
<a href="#l25.250"></a><span id="l25.250" class="difflineplus">+  toString: function gloda_folder_toString() {</span>
<a href="#l25.251"></a><span id="l25.251" class="difflineplus">+    return &quot;Folder:&quot; + this._id;</span>
<a href="#l25.252"></a><span id="l25.252" class="difflineplus">+  }</span>
<a href="#l25.253"></a><span id="l25.253" class="difflineplus">+}</span>
<a href="#l25.254"></a><span id="l25.254" class="difflineplus">+</span>
<a href="#l25.255"></a><span id="l25.255" class="difflineplus">+/**</span>
<a href="#l25.256"></a><span id="l25.256" class="difflineplus">+ * @class A message representation.</span>
<a href="#l25.257"></a><span id="l25.257" class="difflineplus">+ */</span>
<a href="#l25.258"></a><span id="l25.258" class="difflineplus">+function GlodaMessage(aDatastore, aID, aFolderID, aMessageKey,</span>
<a href="#l25.259"></a><span id="l25.259" class="difflineplus">+                      aConversationID, aConversation, aDate,</span>
<a href="#l25.260"></a><span id="l25.260" class="difflineplus">+                      aHeaderMessageID, aDeleted, aJsonText) {</span>
<a href="#l25.261"></a><span id="l25.261" class="difflineplus">+  this._datastore = aDatastore;</span>
<a href="#l25.262"></a><span id="l25.262" class="difflineplus">+  this._id = aID;</span>
<a href="#l25.263"></a><span id="l25.263" class="difflineplus">+  this._folderID = aFolderID;</span>
<a href="#l25.264"></a><span id="l25.264" class="difflineplus">+  this._messageKey = aMessageKey;</span>
<a href="#l25.265"></a><span id="l25.265" class="difflineplus">+  this._conversationID = aConversationID;</span>
<a href="#l25.266"></a><span id="l25.266" class="difflineplus">+  this._conversation = aConversation;</span>
<a href="#l25.267"></a><span id="l25.267" class="difflineplus">+  this._date = aDate;</span>
<a href="#l25.268"></a><span id="l25.268" class="difflineplus">+  this._headerMessageID = aHeaderMessageID;</span>
<a href="#l25.269"></a><span id="l25.269" class="difflineplus">+  if (aJsonText)</span>
<a href="#l25.270"></a><span id="l25.270" class="difflineplus">+    this._jsonText = aJsonText;</span>
<a href="#l25.271"></a><span id="l25.271" class="difflineplus">+</span>
<a href="#l25.272"></a><span id="l25.272" class="difflineplus">+  // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l25.273"></a><span id="l25.273" class="difflineplus">+  //  speaking for us.</span>
<a href="#l25.274"></a><span id="l25.274" class="difflineplus">+  if (aDeleted)</span>
<a href="#l25.275"></a><span id="l25.275" class="difflineplus">+    this._deleted = aDeleted;</span>
<a href="#l25.276"></a><span id="l25.276" class="difflineplus">+}</span>
<a href="#l25.277"></a><span id="l25.277" class="difflineplus">+</span>
<a href="#l25.278"></a><span id="l25.278" class="difflineplus">+GlodaMessage.prototype = {</span>
<a href="#l25.279"></a><span id="l25.279" class="difflineplus">+  NOUN_ID: 102,</span>
<a href="#l25.280"></a><span id="l25.280" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l25.281"></a><span id="l25.281" class="difflineplus">+  get folderID() { return this._folderID; },</span>
<a href="#l25.282"></a><span id="l25.282" class="difflineplus">+  get messageKey() { return this._messageKey; },</span>
<a href="#l25.283"></a><span id="l25.283" class="difflineplus">+  get conversationID() { return this._conversationID; },</span>
<a href="#l25.284"></a><span id="l25.284" class="difflineplus">+  // conversation is special</span>
<a href="#l25.285"></a><span id="l25.285" class="difflineplus">+  get headerMessageID() { return this._headerMessageID; },</span>
<a href="#l25.286"></a><span id="l25.286" class="difflineplus">+  </span>
<a href="#l25.287"></a><span id="l25.287" class="difflineplus">+  get date() { return this._date; },</span>
<a href="#l25.288"></a><span id="l25.288" class="difflineplus">+  set date(aNewDate) { this._date = aNewDate; },</span>
<a href="#l25.289"></a><span id="l25.289" class="difflineplus">+</span>
<a href="#l25.290"></a><span id="l25.290" class="difflineplus">+  get folderURI() {</span>
<a href="#l25.291"></a><span id="l25.291" class="difflineplus">+    if (this._folderID != null)</span>
<a href="#l25.292"></a><span id="l25.292" class="difflineplus">+      return this._datastore._mapFolderID(this._folderID).uri;</span>
<a href="#l25.293"></a><span id="l25.293" class="difflineplus">+    else</span>
<a href="#l25.294"></a><span id="l25.294" class="difflineplus">+      return null;</span>
<a href="#l25.295"></a><span id="l25.295" class="difflineplus">+  },</span>
<a href="#l25.296"></a><span id="l25.296" class="difflineplus">+  get conversation() {</span>
<a href="#l25.297"></a><span id="l25.297" class="difflineplus">+    return this._conversation;</span>
<a href="#l25.298"></a><span id="l25.298" class="difflineplus">+  },</span>
<a href="#l25.299"></a><span id="l25.299" class="difflineplus">+</span>
<a href="#l25.300"></a><span id="l25.300" class="difflineplus">+  toString: function gloda_message_toString() {</span>
<a href="#l25.301"></a><span id="l25.301" class="difflineplus">+    // uh, this is a tough one...</span>
<a href="#l25.302"></a><span id="l25.302" class="difflineplus">+    return &quot;Message:&quot; + this._id;</span>
<a href="#l25.303"></a><span id="l25.303" class="difflineplus">+  },</span>
<a href="#l25.304"></a><span id="l25.304" class="difflineplus">+</span>
<a href="#l25.305"></a><span id="l25.305" class="difflineplus">+  _clone: function gloda_message_clone() {</span>
<a href="#l25.306"></a><span id="l25.306" class="difflineplus">+    return new GlodaMessage(this._datastore, this._id, this._folderID,</span>
<a href="#l25.307"></a><span id="l25.307" class="difflineplus">+      this._messageKey, this._conversationID, this._conversation, this._date,</span>
<a href="#l25.308"></a><span id="l25.308" class="difflineplus">+      this._headerMessageID, this._deleted);</span>
<a href="#l25.309"></a><span id="l25.309" class="difflineplus">+  },</span>
<a href="#l25.310"></a><span id="l25.310" class="difflineplus">+</span>
<a href="#l25.311"></a><span id="l25.311" class="difflineplus">+  _ghost: function gloda_message_ghost() {</span>
<a href="#l25.312"></a><span id="l25.312" class="difflineplus">+    this._folderID = null;</span>
<a href="#l25.313"></a><span id="l25.313" class="difflineplus">+    this._messageKey = null;</span>
<a href="#l25.314"></a><span id="l25.314" class="difflineplus">+  },</span>
<a href="#l25.315"></a><span id="l25.315" class="difflineplus">+</span>
<a href="#l25.316"></a><span id="l25.316" class="difflineplus">+  _nuke: function gloda_message_nuke() {</span>
<a href="#l25.317"></a><span id="l25.317" class="difflineplus">+    this._id = null;</span>
<a href="#l25.318"></a><span id="l25.318" class="difflineplus">+    this._folderID = null;</span>
<a href="#l25.319"></a><span id="l25.319" class="difflineplus">+    this._messageKey = null;</span>
<a href="#l25.320"></a><span id="l25.320" class="difflineplus">+    this._conversationID = null;</span>
<a href="#l25.321"></a><span id="l25.321" class="difflineplus">+    this._conversation = null;</span>
<a href="#l25.322"></a><span id="l25.322" class="difflineplus">+    this.date = null;</span>
<a href="#l25.323"></a><span id="l25.323" class="difflineplus">+    this._headerMessageID = null;</span>
<a href="#l25.324"></a><span id="l25.324" class="difflineplus">+</span>
<a href="#l25.325"></a><span id="l25.325" class="difflineplus">+    this._datastore = null;</span>
<a href="#l25.326"></a><span id="l25.326" class="difflineplus">+  },</span>
<a href="#l25.327"></a><span id="l25.327" class="difflineplus">+</span>
<a href="#l25.328"></a><span id="l25.328" class="difflineplus">+  /**</span>
<a href="#l25.329"></a><span id="l25.329" class="difflineplus">+   * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l25.330"></a><span id="l25.330" class="difflineplus">+   *  null if the message does not exist for one reason or another.</span>
<a href="#l25.331"></a><span id="l25.331" class="difflineplus">+   * This method no longer caches the result, so it's up to you.</span>
<a href="#l25.332"></a><span id="l25.332" class="difflineplus">+   */</span>
<a href="#l25.333"></a><span id="l25.333" class="difflineplus">+  get folderMessage() {</span>
<a href="#l25.334"></a><span id="l25.334" class="difflineplus">+    if (this._folderID === null || this._messageKey === null)</span>
<a href="#l25.335"></a><span id="l25.335" class="difflineplus">+      return null;</span>
<a href="#l25.336"></a><span id="l25.336" class="difflineplus">+    let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l25.337"></a><span id="l25.337" class="difflineplus">+                     getService(Ci.nsIRDFService);</span>
<a href="#l25.338"></a><span id="l25.338" class="difflineplus">+    let folder = rdfService.GetResource(</span>
<a href="#l25.339"></a><span id="l25.339" class="difflineplus">+                   this._datastore._mapFolderID(this._folderID).uri);</span>
<a href="#l25.340"></a><span id="l25.340" class="difflineplus">+    if (folder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l25.341"></a><span id="l25.341" class="difflineplus">+      let folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l25.342"></a><span id="l25.342" class="difflineplus">+      if (folderMessage !== null) {</span>
<a href="#l25.343"></a><span id="l25.343" class="difflineplus">+        // verify the message-id header matches what we expect...</span>
<a href="#l25.344"></a><span id="l25.344" class="difflineplus">+        if (folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l25.345"></a><span id="l25.345" class="difflineplus">+          LOG.info(&quot;Message with message key does not match expected &quot; +</span>
<a href="#l25.346"></a><span id="l25.346" class="difflineplus">+                   &quot;header! (&quot; + this._headerMessageID + &quot; expected, got &quot; +</span>
<a href="#l25.347"></a><span id="l25.347" class="difflineplus">+                   folderMessage.messageId + &quot;)&quot;);</span>
<a href="#l25.348"></a><span id="l25.348" class="difflineplus">+          folderMessage = null;</span>
<a href="#l25.349"></a><span id="l25.349" class="difflineplus">+        }</span>
<a href="#l25.350"></a><span id="l25.350" class="difflineplus">+      }</span>
<a href="#l25.351"></a><span id="l25.351" class="difflineplus">+      return folderMessage;</span>
<a href="#l25.352"></a><span id="l25.352" class="difflineplus">+    }</span>
<a href="#l25.353"></a><span id="l25.353" class="difflineplus">+</span>
<a href="#l25.354"></a><span id="l25.354" class="difflineplus">+    // this only gets logged if things have gone very wrong.  we used to throw</span>
<a href="#l25.355"></a><span id="l25.355" class="difflineplus">+    //  here, but it's unlikely our caller can do anything more meaningful than</span>
<a href="#l25.356"></a><span id="l25.356" class="difflineplus">+    //  treating this as a disappeared message.</span>
<a href="#l25.357"></a><span id="l25.357" class="difflineplus">+    LOG.info(&quot;Unable to locate folder message for: &quot; + this._folderID + &quot;:&quot; +</span>
<a href="#l25.358"></a><span id="l25.358" class="difflineplus">+             this._messageKey);</span>
<a href="#l25.359"></a><span id="l25.359" class="difflineplus">+    return null;</span>
<a href="#l25.360"></a><span id="l25.360" class="difflineplus">+  },</span>
<a href="#l25.361"></a><span id="l25.361" class="difflineplus">+  get folderMessageURI() {</span>
<a href="#l25.362"></a><span id="l25.362" class="difflineplus">+    let folderMessage = this.folderMessage;</span>
<a href="#l25.363"></a><span id="l25.363" class="difflineplus">+    if (folderMessage)</span>
<a href="#l25.364"></a><span id="l25.364" class="difflineplus">+      return folderMessage.folder.getUriForMsg(folderMessage);</span>
<a href="#l25.365"></a><span id="l25.365" class="difflineplus">+    else</span>
<a href="#l25.366"></a><span id="l25.366" class="difflineplus">+      return null;</span>
<a href="#l25.367"></a><span id="l25.367" class="difflineplus">+  }</span>
<a href="#l25.368"></a><span id="l25.368" class="difflineplus">+};</span>
<a href="#l25.369"></a><span id="l25.369" class="difflineplus">+MixIn(GlodaMessage, GlodaHasAttributesMixIn);</span>
<a href="#l25.370"></a><span id="l25.370" class="difflineplus">+</span>
<a href="#l25.371"></a><span id="l25.371" class="difflineplus">+/**</span>
<a href="#l25.372"></a><span id="l25.372" class="difflineplus">+ * @class Contacts correspond to people (one per person), and may own multiple</span>
<a href="#l25.373"></a><span id="l25.373" class="difflineplus">+ *  identities (e-mail address, IM account, etc.)</span>
<a href="#l25.374"></a><span id="l25.374" class="difflineplus">+ */</span>
<a href="#l25.375"></a><span id="l25.375" class="difflineplus">+function GlodaContact(aDatastore, aID, aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l25.376"></a><span id="l25.376" class="difflineplus">+                      aPopularity, aFrecency, aJsonText) {</span>
<a href="#l25.377"></a><span id="l25.377" class="difflineplus">+  this._datastore = aDatastore;</span>
<a href="#l25.378"></a><span id="l25.378" class="difflineplus">+  this._id = aID;</span>
<a href="#l25.379"></a><span id="l25.379" class="difflineplus">+  this._directoryUUID = aDirectoryUUID;</span>
<a href="#l25.380"></a><span id="l25.380" class="difflineplus">+  this._contactUUID = aContactUUID;</span>
<a href="#l25.381"></a><span id="l25.381" class="difflineplus">+  this._name = aName;</span>
<a href="#l25.382"></a><span id="l25.382" class="difflineplus">+  this._popularity = aPopularity;</span>
<a href="#l25.383"></a><span id="l25.383" class="difflineplus">+  this._frecency = aFrecency;</span>
<a href="#l25.384"></a><span id="l25.384" class="difflineplus">+  if (aJsonText)</span>
<a href="#l25.385"></a><span id="l25.385" class="difflineplus">+    this._jsonText = aJsonText;</span>
<a href="#l25.386"></a><span id="l25.386" class="difflineplus">+</span>
<a href="#l25.387"></a><span id="l25.387" class="difflineplus">+  this._identities = null;</span>
<a href="#l25.388"></a><span id="l25.388" class="difflineplus">+}</span>
<a href="#l25.389"></a><span id="l25.389" class="difflineplus">+</span>
<a href="#l25.390"></a><span id="l25.390" class="difflineplus">+GlodaContact.prototype = {</span>
<a href="#l25.391"></a><span id="l25.391" class="difflineplus">+  NOUN_ID: 103,</span>
<a href="#l25.392"></a><span id="l25.392" class="difflineplus">+</span>
<a href="#l25.393"></a><span id="l25.393" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l25.394"></a><span id="l25.394" class="difflineplus">+  get directoryUUID() { return this._directoryUUID; },</span>
<a href="#l25.395"></a><span id="l25.395" class="difflineplus">+  get contactUUID() { return this._contactUUID; },</span>
<a href="#l25.396"></a><span id="l25.396" class="difflineplus">+  get name() { return this._name; },</span>
<a href="#l25.397"></a><span id="l25.397" class="difflineplus">+  set name(aName) { this._name = aName; },</span>
<a href="#l25.398"></a><span id="l25.398" class="difflineplus">+</span>
<a href="#l25.399"></a><span id="l25.399" class="difflineplus">+  get popularity() { return this._popularity; },</span>
<a href="#l25.400"></a><span id="l25.400" class="difflineplus">+  set popularity(aPopularity) {</span>
<a href="#l25.401"></a><span id="l25.401" class="difflineplus">+    this._popularity = aPopularity;</span>
<a href="#l25.402"></a><span id="l25.402" class="difflineplus">+    this.dirty = true;</span>
<a href="#l25.403"></a><span id="l25.403" class="difflineplus">+  },</span>
<a href="#l25.404"></a><span id="l25.404" class="difflineplus">+</span>
<a href="#l25.405"></a><span id="l25.405" class="difflineplus">+  get frecency() { return this._frecency; },</span>
<a href="#l25.406"></a><span id="l25.406" class="difflineplus">+  set frecency(aFrecency) {</span>
<a href="#l25.407"></a><span id="l25.407" class="difflineplus">+    this._frecency = aFrecency;</span>
<a href="#l25.408"></a><span id="l25.408" class="difflineplus">+    this.dirty = true;</span>
<a href="#l25.409"></a><span id="l25.409" class="difflineplus">+  },</span>
<a href="#l25.410"></a><span id="l25.410" class="difflineplus">+</span>
<a href="#l25.411"></a><span id="l25.411" class="difflineplus">+  get identities() {</span>
<a href="#l25.412"></a><span id="l25.412" class="difflineplus">+    return this._identities;</span>
<a href="#l25.413"></a><span id="l25.413" class="difflineplus">+  },</span>
<a href="#l25.414"></a><span id="l25.414" class="difflineplus">+</span>
<a href="#l25.415"></a><span id="l25.415" class="difflineplus">+  toString: function gloda_contact_toString() {</span>
<a href="#l25.416"></a><span id="l25.416" class="difflineplus">+    return &quot;Contact:&quot; + this._id;</span>
<a href="#l25.417"></a><span id="l25.417" class="difflineplus">+  },</span>
<a href="#l25.418"></a><span id="l25.418" class="difflineplus">+  </span>
<a href="#l25.419"></a><span id="l25.419" class="difflineplus">+  get accessibleLabel() {</span>
<a href="#l25.420"></a><span id="l25.420" class="difflineplus">+    return &quot;Contact: &quot; + this._name;</span>
<a href="#l25.421"></a><span id="l25.421" class="difflineplus">+  },</span>
<a href="#l25.422"></a><span id="l25.422" class="difflineplus">+</span>
<a href="#l25.423"></a><span id="l25.423" class="difflineplus">+  _clone: function gloda_contact_clone() {</span>
<a href="#l25.424"></a><span id="l25.424" class="difflineplus">+    return new GlodaContact(this._datastore, this._id, this._directoryUUID,</span>
<a href="#l25.425"></a><span id="l25.425" class="difflineplus">+      this._contactUUID, this._name, this._popularity, this._frecency);</span>
<a href="#l25.426"></a><span id="l25.426" class="difflineplus">+  },</span>
<a href="#l25.427"></a><span id="l25.427" class="difflineplus">+};</span>
<a href="#l25.428"></a><span id="l25.428" class="difflineplus">+MixIn(GlodaContact, GlodaHasAttributesMixIn);</span>
<a href="#l25.429"></a><span id="l25.429" class="difflineplus">+</span>
<a href="#l25.430"></a><span id="l25.430" class="difflineplus">+</span>
<a href="#l25.431"></a><span id="l25.431" class="difflineplus">+/**</span>
<a href="#l25.432"></a><span id="l25.432" class="difflineplus">+ * @class A specific means of communication for a contact.</span>
<a href="#l25.433"></a><span id="l25.433" class="difflineplus">+ */</span>
<a href="#l25.434"></a><span id="l25.434" class="difflineplus">+function GlodaIdentity(aDatastore, aID, aContactID, aContact, aKind, aValue,</span>
<a href="#l25.435"></a><span id="l25.435" class="difflineplus">+                       aDescription, aIsRelay) {</span>
<a href="#l25.436"></a><span id="l25.436" class="difflineplus">+  this._datastore = aDatastore;</span>
<a href="#l25.437"></a><span id="l25.437" class="difflineplus">+  this._id = aID;</span>
<a href="#l25.438"></a><span id="l25.438" class="difflineplus">+  this._contactID = aContactID;</span>
<a href="#l25.439"></a><span id="l25.439" class="difflineplus">+  this._contact = aContact;</span>
<a href="#l25.440"></a><span id="l25.440" class="difflineplus">+  this._kind = aKind;</span>
<a href="#l25.441"></a><span id="l25.441" class="difflineplus">+  this._value = aValue;</span>
<a href="#l25.442"></a><span id="l25.442" class="difflineplus">+  this._description = aDescription;</span>
<a href="#l25.443"></a><span id="l25.443" class="difflineplus">+  this._isRelay = aIsRelay;</span>
<a href="#l25.444"></a><span id="l25.444" class="difflineplus">+}</span>
<a href="#l25.445"></a><span id="l25.445" class="difflineplus">+</span>
<a href="#l25.446"></a><span id="l25.446" class="difflineplus">+GlodaIdentity.prototype = {</span>
<a href="#l25.447"></a><span id="l25.447" class="difflineplus">+  NOUN_ID: 104,</span>
<a href="#l25.448"></a><span id="l25.448" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l25.449"></a><span id="l25.449" class="difflineplus">+  get contactID() { return this._contactID; },</span>
<a href="#l25.450"></a><span id="l25.450" class="difflineplus">+  get contact() { return this._contact; },</span>
<a href="#l25.451"></a><span id="l25.451" class="difflineplus">+  get kind() { return this._kind; },</span>
<a href="#l25.452"></a><span id="l25.452" class="difflineplus">+  get value() { return this._value; },</span>
<a href="#l25.453"></a><span id="l25.453" class="difflineplus">+  get description() { return this._description; },</span>
<a href="#l25.454"></a><span id="l25.454" class="difflineplus">+  get isRelay() { return this._isRelay; },</span>
<a href="#l25.455"></a><span id="l25.455" class="difflineplus">+</span>
<a href="#l25.456"></a><span id="l25.456" class="difflineplus">+  get uniqueValue() {</span>
<a href="#l25.457"></a><span id="l25.457" class="difflineplus">+    return this._kind + &quot;@&quot; + this._value;</span>
<a href="#l25.458"></a><span id="l25.458" class="difflineplus">+  },</span>
<a href="#l25.459"></a><span id="l25.459" class="difflineplus">+</span>
<a href="#l25.460"></a><span id="l25.460" class="difflineplus">+  toString: function gloda_identity_toString() {</span>
<a href="#l25.461"></a><span id="l25.461" class="difflineplus">+    return &quot;Identity:&quot; + this._kind + &quot;:&quot; + this._value;</span>
<a href="#l25.462"></a><span id="l25.462" class="difflineplus">+  },</span>
<a href="#l25.463"></a><span id="l25.463" class="difflineplus">+</span>
<a href="#l25.464"></a><span id="l25.464" class="difflineplus">+  get abCard() {</span>
<a href="#l25.465"></a><span id="l25.465" class="difflineplus">+    return GlodaUtils.getCardForEmail(this._value);</span>
<a href="#l25.466"></a><span id="l25.466" class="difflineplus">+  },</span>
<a href="#l25.467"></a><span id="l25.467" class="difflineplus">+  </span>
<a href="#l25.468"></a><span id="l25.468" class="difflineplus">+  pictureURL: function(aSize) {</span>
<a href="#l25.469"></a><span id="l25.469" class="difflineplus">+    let md5hash = GlodaUtils.md5HashString(this._value);</span>
<a href="#l25.470"></a><span id="l25.470" class="difflineplus">+    let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash +</span>
<a href="#l25.471"></a><span id="l25.471" class="difflineplus">+                                &quot;?d=identicon&amp;s=&quot; + aSize + &quot;&amp;r=g&quot;;</span>
<a href="#l25.472"></a><span id="l25.472" class="difflineplus">+    return gravURL;</span>
<a href="#l25.473"></a><span id="l25.473" class="difflineplus">+  }</span>
<a href="#l25.474"></a><span id="l25.474" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1">new file mode 100644</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineminus">--- /dev/null</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l26.4"></a><span id="l26.4" class="difflineat">@@ -0,0 +1,3135 @@</span>
<a href="#l26.5"></a><span id="l26.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l26.6"></a><span id="l26.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l26.7"></a><span id="l26.7" class="difflineplus">+ *</span>
<a href="#l26.8"></a><span id="l26.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l26.9"></a><span id="l26.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l26.10"></a><span id="l26.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l26.11"></a><span id="l26.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineplus">+ *</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l26.14"></a><span id="l26.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l26.16"></a><span id="l26.16" class="difflineplus">+ * License.</span>
<a href="#l26.17"></a><span id="l26.17" class="difflineplus">+ *</span>
<a href="#l26.18"></a><span id="l26.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l26.19"></a><span id="l26.19" class="difflineplus">+ *</span>
<a href="#l26.20"></a><span id="l26.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l26.21"></a><span id="l26.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l26.22"></a><span id="l26.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l26.23"></a><span id="l26.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l26.24"></a><span id="l26.24" class="difflineplus">+ *</span>
<a href="#l26.25"></a><span id="l26.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l26.26"></a><span id="l26.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l26.27"></a><span id="l26.27" class="difflineplus">+ *</span>
<a href="#l26.28"></a><span id="l26.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l26.29"></a><span id="l26.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l26.30"></a><span id="l26.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l26.36"></a><span id="l26.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l26.37"></a><span id="l26.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l26.39"></a><span id="l26.39" class="difflineplus">+ *</span>
<a href="#l26.40"></a><span id="l26.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l26.41"></a><span id="l26.41" class="difflineplus">+</span>
<a href="#l26.42"></a><span id="l26.42" class="difflineplus">+/* This file looks to Myk Melez &lt;myk@mozilla.org&gt;'s Mozilla Labs snowl</span>
<a href="#l26.43"></a><span id="l26.43" class="difflineplus">+ * project's (http://hg.mozilla.org/labs/snowl/) modules/datastore.js</span>
<a href="#l26.44"></a><span id="l26.44" class="difflineplus">+ * for inspiration and idioms (and also a name :).</span>
<a href="#l26.45"></a><span id="l26.45" class="difflineplus">+ */</span>
<a href="#l26.46"></a><span id="l26.46" class="difflineplus">+</span>
<a href="#l26.47"></a><span id="l26.47" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaDatastore&quot;];</span>
<a href="#l26.48"></a><span id="l26.48" class="difflineplus">+</span>
<a href="#l26.49"></a><span id="l26.49" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l26.50"></a><span id="l26.50" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l26.51"></a><span id="l26.51" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l26.52"></a><span id="l26.52" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l26.53"></a><span id="l26.53" class="difflineplus">+</span>
<a href="#l26.54"></a><span id="l26.54" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineplus">+</span>
<a href="#l26.56"></a><span id="l26.56" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l26.57"></a><span id="l26.57" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/databind.js&quot;);</span>
<a href="#l26.58"></a><span id="l26.58" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l26.59"></a><span id="l26.59" class="difflineplus">+</span>
<a href="#l26.60"></a><span id="l26.60" class="difflineplus">+let MBM_LOG = Log4Moz.Service.getLogger(&quot;gloda.ds.mbm&quot;);</span>
<a href="#l26.61"></a><span id="l26.61" class="difflineplus">+</span>
<a href="#l26.62"></a><span id="l26.62" class="difflineplus">+/**</span>
<a href="#l26.63"></a><span id="l26.63" class="difflineplus">+ * @class This callback handles processing the asynchronous query results of</span>
<a href="#l26.64"></a><span id="l26.64" class="difflineplus">+ *  GlodaDatastore.getMessagesByMessageID.  Because that method is only</span>
<a href="#l26.65"></a><span id="l26.65" class="difflineplus">+ *  called as part of the indexing process, we are guaranteed that there will</span>
<a href="#l26.66"></a><span id="l26.66" class="difflineplus">+ *  be no real caching ramifications.  Accordingly, we can also defer our cache</span>
<a href="#l26.67"></a><span id="l26.67" class="difflineplus">+ *  processing (via GlodaCollectionManager) until the query completes.</span>
<a href="#l26.68"></a><span id="l26.68" class="difflineplus">+ *</span>
<a href="#l26.69"></a><span id="l26.69" class="difflineplus">+ * @param aMsgIDToIndex Map from message-id to the desired</span>
<a href="#l26.70"></a><span id="l26.70" class="difflineplus">+ *</span>
<a href="#l26.71"></a><span id="l26.71" class="difflineplus">+ * @constructor</span>
<a href="#l26.72"></a><span id="l26.72" class="difflineplus">+ */</span>
<a href="#l26.73"></a><span id="l26.73" class="difflineplus">+function MessagesByMessageIdCallback(aMsgIDToIndex, aResults,</span>
<a href="#l26.74"></a><span id="l26.74" class="difflineplus">+                                     aCallback, aCallbackThis) {</span>
<a href="#l26.75"></a><span id="l26.75" class="difflineplus">+  this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l26.76"></a><span id="l26.76" class="difflineplus">+  this.results = aResults;</span>
<a href="#l26.77"></a><span id="l26.77" class="difflineplus">+  this.callback = aCallback;</span>
<a href="#l26.78"></a><span id="l26.78" class="difflineplus">+  this.callbackThis = aCallbackThis;</span>
<a href="#l26.79"></a><span id="l26.79" class="difflineplus">+}</span>
<a href="#l26.80"></a><span id="l26.80" class="difflineplus">+</span>
<a href="#l26.81"></a><span id="l26.81" class="difflineplus">+MessagesByMessageIdCallback.prototype = {</span>
<a href="#l26.82"></a><span id="l26.82" class="difflineplus">+  onItemsAdded: function gloda_ds_mbmi_onItemsAdded(aItems, aCollection) {</span>
<a href="#l26.83"></a><span id="l26.83" class="difflineplus">+    MBM_LOG.debug(&quot;getting results...&quot;);</span>
<a href="#l26.84"></a><span id="l26.84" class="difflineplus">+    for each (let [, message] in Iterator(aItems)) {</span>
<a href="#l26.85"></a><span id="l26.85" class="difflineplus">+      this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l26.86"></a><span id="l26.86" class="difflineplus">+    }</span>
<a href="#l26.87"></a><span id="l26.87" class="difflineplus">+  },</span>
<a href="#l26.88"></a><span id="l26.88" class="difflineplus">+  onItemsModified: function () {},</span>
<a href="#l26.89"></a><span id="l26.89" class="difflineplus">+  onItemsRemoved: function () {},</span>
<a href="#l26.90"></a><span id="l26.90" class="difflineplus">+  onQueryCompleted: function gloda_ds_mbmi_onQueryCompleted(aCollection) {</span>
<a href="#l26.91"></a><span id="l26.91" class="difflineplus">+    MBM_LOG.debug(&quot;query completed, notifying... &quot; + this.results);</span>
<a href="#l26.92"></a><span id="l26.92" class="difflineplus">+    // we no longer need to unify; it is done for us.</span>
<a href="#l26.93"></a><span id="l26.93" class="difflineplus">+</span>
<a href="#l26.94"></a><span id="l26.94" class="difflineplus">+    this.callback.call(this.callbackThis, this.results);</span>
<a href="#l26.95"></a><span id="l26.95" class="difflineplus">+  }</span>
<a href="#l26.96"></a><span id="l26.96" class="difflineplus">+};</span>
<a href="#l26.97"></a><span id="l26.97" class="difflineplus">+</span>
<a href="#l26.98"></a><span id="l26.98" class="difflineplus">+let PCH_LOG = Log4Moz.Service.getLogger(&quot;gloda.ds.pch&quot;);</span>
<a href="#l26.99"></a><span id="l26.99" class="difflineplus">+</span>
<a href="#l26.100"></a><span id="l26.100" class="difflineplus">+function PostCommitHandler(aCallbacks) {</span>
<a href="#l26.101"></a><span id="l26.101" class="difflineplus">+  this.callbacks = aCallbacks;</span>
<a href="#l26.102"></a><span id="l26.102" class="difflineplus">+  GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l26.103"></a><span id="l26.103" class="difflineplus">+}</span>
<a href="#l26.104"></a><span id="l26.104" class="difflineplus">+</span>
<a href="#l26.105"></a><span id="l26.105" class="difflineplus">+PostCommitHandler.prototype = {</span>
<a href="#l26.106"></a><span id="l26.106" class="difflineplus">+  handleResult: function gloda_ds_pch_handleResult(aResultSet) {</span>
<a href="#l26.107"></a><span id="l26.107" class="difflineplus">+  },</span>
<a href="#l26.108"></a><span id="l26.108" class="difflineplus">+  </span>
<a href="#l26.109"></a><span id="l26.109" class="difflineplus">+  handleError: function gloda_ds_pch_handleError(aError) {</span>
<a href="#l26.110"></a><span id="l26.110" class="difflineplus">+    PCH_LOG.error(&quot;database error:&quot; + aError)</span>
<a href="#l26.111"></a><span id="l26.111" class="difflineplus">+  },</span>
<a href="#l26.112"></a><span id="l26.112" class="difflineplus">+  </span>
<a href="#l26.113"></a><span id="l26.113" class="difflineplus">+  handleCompletion: function gloda_ds_pch_handleCompletion(aReason) {</span>
<a href="#l26.114"></a><span id="l26.114" class="difflineplus">+    if (aReason == Ci.mozIStorageStatementCallback.REASON_FINISHED) {</span>
<a href="#l26.115"></a><span id="l26.115" class="difflineplus">+      for each (let [iCallback, callback] in Iterator(this.callbacks)) {</span>
<a href="#l26.116"></a><span id="l26.116" class="difflineplus">+        try {</span>
<a href="#l26.117"></a><span id="l26.117" class="difflineplus">+          callback();</span>
<a href="#l26.118"></a><span id="l26.118" class="difflineplus">+        }</span>
<a href="#l26.119"></a><span id="l26.119" class="difflineplus">+        catch (ex) {</span>
<a href="#l26.120"></a><span id="l26.120" class="difflineplus">+          dump(&quot;PostCommitHandler callback (&quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l26.121"></a><span id="l26.121" class="difflineplus">+               ex.lineNumber + &quot;) threw: &quot; + ex);</span>
<a href="#l26.122"></a><span id="l26.122" class="difflineplus">+        }</span>
<a href="#l26.123"></a><span id="l26.123" class="difflineplus">+      }</span>
<a href="#l26.124"></a><span id="l26.124" class="difflineplus">+    }</span>
<a href="#l26.125"></a><span id="l26.125" class="difflineplus">+    GlodaDatastore._asyncCompleted();</span>
<a href="#l26.126"></a><span id="l26.126" class="difflineplus">+  }</span>
<a href="#l26.127"></a><span id="l26.127" class="difflineplus">+};</span>
<a href="#l26.128"></a><span id="l26.128" class="difflineplus">+</span>
<a href="#l26.129"></a><span id="l26.129" class="difflineplus">+let QFQ_LOG = Log4Moz.Service.getLogger(&quot;gloda.ds.qfq&quot;);</span>
<a href="#l26.130"></a><span id="l26.130" class="difflineplus">+</span>
<a href="#l26.131"></a><span id="l26.131" class="difflineplus">+let QueryFromQueryResolver = {</span>
<a href="#l26.132"></a><span id="l26.132" class="difflineplus">+  onItemsAdded: function(aIgnoredItems, aCollection, aFake) {</span>
<a href="#l26.133"></a><span id="l26.133" class="difflineplus">+    let originColl = aCollection.dataStack ? aCollection.dataStack.pop()</span>
<a href="#l26.134"></a><span id="l26.134" class="difflineplus">+                                           : aCollection.data;</span>
<a href="#l26.135"></a><span id="l26.135" class="difflineplus">+    if (aCollection.completionShifter)</span>
<a href="#l26.136"></a><span id="l26.136" class="difflineplus">+      aCollection.completionShifter.push(originColl);</span>
<a href="#l26.137"></a><span id="l26.137" class="difflineplus">+    else</span>
<a href="#l26.138"></a><span id="l26.138" class="difflineplus">+      aCollection.completionShifter = [originColl];</span>
<a href="#l26.139"></a><span id="l26.139" class="difflineplus">+</span>
<a href="#l26.140"></a><span id="l26.140" class="difflineplus">+    if (!aFake) {</span>
<a href="#l26.141"></a><span id="l26.141" class="difflineplus">+      originColl.deferredCount--;</span>
<a href="#l26.142"></a><span id="l26.142" class="difflineplus">+      originColl.resolvedCount++;</span>
<a href="#l26.143"></a><span id="l26.143" class="difflineplus">+    }</span>
<a href="#l26.144"></a><span id="l26.144" class="difflineplus">+    </span>
<a href="#l26.145"></a><span id="l26.145" class="difflineplus">+    // bail if we are still pending on some other load completion</span>
<a href="#l26.146"></a><span id="l26.146" class="difflineplus">+    if (originColl.deferredCount &gt; 0) {</span>
<a href="#l26.147"></a><span id="l26.147" class="difflineplus">+      //QFQ_LOG.debug(&quot;QFQR: bailing &quot; + originColl._nounDef.name);</span>
<a href="#l26.148"></a><span id="l26.148" class="difflineplus">+      return;</span>
<a href="#l26.149"></a><span id="l26.149" class="difflineplus">+    }</span>
<a href="#l26.150"></a><span id="l26.150" class="difflineplus">+    </span>
<a href="#l26.151"></a><span id="l26.151" class="difflineplus">+    let referencesByNounID = originColl.masterCollection.referencesByNounID;</span>
<a href="#l26.152"></a><span id="l26.152" class="difflineplus">+    let inverseReferencesByNounID = </span>
<a href="#l26.153"></a><span id="l26.153" class="difflineplus">+      originColl.masterCollection.inverseReferencesByNounID;</span>
<a href="#l26.154"></a><span id="l26.154" class="difflineplus">+</span>
<a href="#l26.155"></a><span id="l26.155" class="difflineplus">+    if (originColl.pendingItems) {</span>
<a href="#l26.156"></a><span id="l26.156" class="difflineplus">+      for (let [, item] in Iterator(originColl.pendingItems)) {</span>
<a href="#l26.157"></a><span id="l26.157" class="difflineplus">+        //QFQ_LOG.debug(&quot;QFQR: loading deferred &quot; + item.NOUN_ID + &quot;:&quot; + item.id);</span>
<a href="#l26.158"></a><span id="l26.158" class="difflineplus">+        GlodaDatastore.loadNounDeferredDeps(item, referencesByNounID,</span>
<a href="#l26.159"></a><span id="l26.159" class="difflineplus">+            inverseReferencesByNounID);</span>
<a href="#l26.160"></a><span id="l26.160" class="difflineplus">+      }</span>
<a href="#l26.161"></a><span id="l26.161" class="difflineplus">+      </span>
<a href="#l26.162"></a><span id="l26.162" class="difflineplus">+      // we need to consider the possibility that we are racing a collection very</span>
<a href="#l26.163"></a><span id="l26.163" class="difflineplus">+      //  much like our own.  as such, this means we need to perform cache</span>
<a href="#l26.164"></a><span id="l26.164" class="difflineplus">+      //  unification as our last step.</span>
<a href="#l26.165"></a><span id="l26.165" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(originColl._nounDef.id,</span>
<a href="#l26.166"></a><span id="l26.166" class="difflineplus">+        originColl.pendingItems, false);</span>
<a href="#l26.167"></a><span id="l26.167" class="difflineplus">+  </span>
<a href="#l26.168"></a><span id="l26.168" class="difflineplus">+      // just directly tell the collection about the items.  we know the query</span>
<a href="#l26.169"></a><span id="l26.169" class="difflineplus">+      //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l26.170"></a><span id="l26.170" class="difflineplus">+      //  in SQL.)</span>
<a href="#l26.171"></a><span id="l26.171" class="difflineplus">+      //QFQ_LOG.debug(&quot; QFQR: about to trigger listener: &quot; + originColl._listener +</span>
<a href="#l26.172"></a><span id="l26.172" class="difflineplus">+      //    &quot;with collection: &quot; + originColl._nounDef.name);</span>
<a href="#l26.173"></a><span id="l26.173" class="difflineplus">+      originColl._onItemsAdded(originColl.pendingItems);</span>
<a href="#l26.174"></a><span id="l26.174" class="difflineplus">+      delete originColl.pendingItems;</span>
<a href="#l26.175"></a><span id="l26.175" class="difflineplus">+      delete originColl._pendingIdMap;</span>
<a href="#l26.176"></a><span id="l26.176" class="difflineplus">+    }</span>
<a href="#l26.177"></a><span id="l26.177" class="difflineplus">+  },</span>
<a href="#l26.178"></a><span id="l26.178" class="difflineplus">+  onItemsModified: function() {</span>
<a href="#l26.179"></a><span id="l26.179" class="difflineplus">+  },</span>
<a href="#l26.180"></a><span id="l26.180" class="difflineplus">+  onItemsRemoved: function() {</span>
<a href="#l26.181"></a><span id="l26.181" class="difflineplus">+  },</span>
<a href="#l26.182"></a><span id="l26.182" class="difflineplus">+  onQueryCompleted: function(aCollection) {</span>
<a href="#l26.183"></a><span id="l26.183" class="difflineplus">+    let originColl = aCollection.completionShifter ?</span>
<a href="#l26.184"></a><span id="l26.184" class="difflineplus">+      aCollection.completionShifter.shift() : aCollection.data;</span>
<a href="#l26.185"></a><span id="l26.185" class="difflineplus">+    //QFQ_LOG.debug(&quot; QFQR about to trigger completion with collection: &quot; +</span>
<a href="#l26.186"></a><span id="l26.186" class="difflineplus">+    //  originColl._nounDef.name);</span>
<a href="#l26.187"></a><span id="l26.187" class="difflineplus">+    if (originColl.deferredCount &lt;= 0) {</span>
<a href="#l26.188"></a><span id="l26.188" class="difflineplus">+      originColl._onQueryCompleted();</span>
<a href="#l26.189"></a><span id="l26.189" class="difflineplus">+    }</span>
<a href="#l26.190"></a><span id="l26.190" class="difflineplus">+  },</span>
<a href="#l26.191"></a><span id="l26.191" class="difflineplus">+};</span>
<a href="#l26.192"></a><span id="l26.192" class="difflineplus">+</span>
<a href="#l26.193"></a><span id="l26.193" class="difflineplus">+/**</span>
<a href="#l26.194"></a><span id="l26.194" class="difflineplus">+ * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l26.195"></a><span id="l26.195" class="difflineplus">+ * @constructor</span>
<a href="#l26.196"></a><span id="l26.196" class="difflineplus">+ */</span>
<a href="#l26.197"></a><span id="l26.197" class="difflineplus">+function QueryFromQueryCallback(aStatement, aNounDef, aCollection) {</span>
<a href="#l26.198"></a><span id="l26.198" class="difflineplus">+  this.statement = aStatement;</span>
<a href="#l26.199"></a><span id="l26.199" class="difflineplus">+  this.nounDef = aNounDef;</span>
<a href="#l26.200"></a><span id="l26.200" class="difflineplus">+  this.collection = aCollection;</span>
<a href="#l26.201"></a><span id="l26.201" class="difflineplus">+  </span>
<a href="#l26.202"></a><span id="l26.202" class="difflineplus">+  //QFQ_LOG.debug(&quot;Creating QFQCallback for noun: &quot; + aNounDef.name);</span>
<a href="#l26.203"></a><span id="l26.203" class="difflineplus">+  </span>
<a href="#l26.204"></a><span id="l26.204" class="difflineplus">+  // the master collection holds the referencesByNounID</span>
<a href="#l26.205"></a><span id="l26.205" class="difflineplus">+  this.referencesByNounID = {};</span>
<a href="#l26.206"></a><span id="l26.206" class="difflineplus">+  this.masterReferencesByNounID =</span>
<a href="#l26.207"></a><span id="l26.207" class="difflineplus">+    this.collection.masterCollection.referencesByNounID;</span>
<a href="#l26.208"></a><span id="l26.208" class="difflineplus">+  this.inverseReferencesByNounID = {};</span>
<a href="#l26.209"></a><span id="l26.209" class="difflineplus">+  this.masterInverseReferencesByNounID =</span>
<a href="#l26.210"></a><span id="l26.210" class="difflineplus">+    this.collection.masterCollection.inverseReferencesByNounID;</span>
<a href="#l26.211"></a><span id="l26.211" class="difflineplus">+  // we need to contribute our references as we load things; we need this </span>
<a href="#l26.212"></a><span id="l26.212" class="difflineplus">+  //  because of the potential for circular dependencies and our inability to</span>
<a href="#l26.213"></a><span id="l26.213" class="difflineplus">+  //  put things into the caching layer (or collection's _idMap) until we have</span>
<a href="#l26.214"></a><span id="l26.214" class="difflineplus">+  //  fully resolved things.</span>
<a href="#l26.215"></a><span id="l26.215" class="difflineplus">+  if (this.nounDef.id in this.masterReferencesByNounID)</span>
<a href="#l26.216"></a><span id="l26.216" class="difflineplus">+    this.selfReferences = this.masterReferencesByNounID[this.nounDef.id];</span>
<a href="#l26.217"></a><span id="l26.217" class="difflineplus">+  else</span>
<a href="#l26.218"></a><span id="l26.218" class="difflineplus">+    this.selfReferences = this.masterReferencesByNounID[this.nounDef.id] = {};</span>
<a href="#l26.219"></a><span id="l26.219" class="difflineplus">+  if (this.nounDef.parentColumnAttr) {</span>
<a href="#l26.220"></a><span id="l26.220" class="difflineplus">+    if (this.nounDef.id in this.masterInverseReferencesByNounID)</span>
<a href="#l26.221"></a><span id="l26.221" class="difflineplus">+      this.selfInverseReferences =</span>
<a href="#l26.222"></a><span id="l26.222" class="difflineplus">+        this.masterInverseReferencesByNounID[this.nounDef.id];</span>
<a href="#l26.223"></a><span id="l26.223" class="difflineplus">+    else</span>
<a href="#l26.224"></a><span id="l26.224" class="difflineplus">+      this.selfInverseReferences =</span>
<a href="#l26.225"></a><span id="l26.225" class="difflineplus">+        this.masterInverseReferencesByNounID[this.nounDef.id] = {};</span>
<a href="#l26.226"></a><span id="l26.226" class="difflineplus">+  }</span>
<a href="#l26.227"></a><span id="l26.227" class="difflineplus">+  </span>
<a href="#l26.228"></a><span id="l26.228" class="difflineplus">+  this.needsLoads = false;</span>
<a href="#l26.229"></a><span id="l26.229" class="difflineplus">+  </span>
<a href="#l26.230"></a><span id="l26.230" class="difflineplus">+  GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l26.231"></a><span id="l26.231" class="difflineplus">+}</span>
<a href="#l26.232"></a><span id="l26.232" class="difflineplus">+</span>
<a href="#l26.233"></a><span id="l26.233" class="difflineplus">+QueryFromQueryCallback.prototype = {</span>
<a href="#l26.234"></a><span id="l26.234" class="difflineplus">+  handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l26.235"></a><span id="l26.235" class="difflineplus">+    let pendingItems = this.collection.pendingItems;</span>
<a href="#l26.236"></a><span id="l26.236" class="difflineplus">+    let pendingIdMap = this.collection._pendingIdMap;</span>
<a href="#l26.237"></a><span id="l26.237" class="difflineplus">+    let row;</span>
<a href="#l26.238"></a><span id="l26.238" class="difflineplus">+    let nounDef = this.nounDef;</span>
<a href="#l26.239"></a><span id="l26.239" class="difflineplus">+    let nounID = nounDef.id;</span>
<a href="#l26.240"></a><span id="l26.240" class="difflineplus">+    while (row = aResultSet.getNextRow()) {</span>
<a href="#l26.241"></a><span id="l26.241" class="difflineplus">+      let item = nounDef.objFromRow.call(nounDef.datastore, row);</span>
<a href="#l26.242"></a><span id="l26.242" class="difflineplus">+      // try and replace the item with one from the cache, if we can</span>
<a href="#l26.243"></a><span id="l26.243" class="difflineplus">+      let cachedItem = GlodaCollectionManager.cacheLookupOne(nounID, item.id,</span>
<a href="#l26.244"></a><span id="l26.244" class="difflineplus">+                                                             false);</span>
<a href="#l26.245"></a><span id="l26.245" class="difflineplus">+      </span>
<a href="#l26.246"></a><span id="l26.246" class="difflineplus">+      // if we already have a copy in the pending id map, skip it</span>
<a href="#l26.247"></a><span id="l26.247" class="difflineplus">+      if (item.id in pendingIdMap)</span>
<a href="#l26.248"></a><span id="l26.248" class="difflineplus">+        continue;</span>
<a href="#l26.249"></a><span id="l26.249" class="difflineplus">+      </span>
<a href="#l26.250"></a><span id="l26.250" class="difflineplus">+      //QFQ_LOG.debug(&quot;loading item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; existing: &quot; +</span>
<a href="#l26.251"></a><span id="l26.251" class="difflineplus">+      //    this.selfReferences[item.id] + &quot; cached: &quot; + cachedItem);</span>
<a href="#l26.252"></a><span id="l26.252" class="difflineplus">+      if (cachedItem)</span>
<a href="#l26.253"></a><span id="l26.253" class="difflineplus">+        item = cachedItem;</span>
<a href="#l26.254"></a><span id="l26.254" class="difflineplus">+      // we may already have been loaded by this process</span>
<a href="#l26.255"></a><span id="l26.255" class="difflineplus">+      else if (this.selfReferences[item.id] != null)</span>
<a href="#l26.256"></a><span id="l26.256" class="difflineplus">+        item = this.selfReferences[item.id];</span>
<a href="#l26.257"></a><span id="l26.257" class="difflineplus">+      // perform loading logic which may produce reference dependencies</span>
<a href="#l26.258"></a><span id="l26.258" class="difflineplus">+      else</span>
<a href="#l26.259"></a><span id="l26.259" class="difflineplus">+        this.needsLoads = </span>
<a href="#l26.260"></a><span id="l26.260" class="difflineplus">+          GlodaDatastore.loadNounItem(item, this.referencesByNounID,</span>
<a href="#l26.261"></a><span id="l26.261" class="difflineplus">+                                      this.inverseReferencesByNounID) ||</span>
<a href="#l26.262"></a><span id="l26.262" class="difflineplus">+          this.needsLoads;</span>
<a href="#l26.263"></a><span id="l26.263" class="difflineplus">+      </span>
<a href="#l26.264"></a><span id="l26.264" class="difflineplus">+      // add ourself to the references by our id</span>
<a href="#l26.265"></a><span id="l26.265" class="difflineplus">+      // QFQ_LOG.debug(&quot;saving item &quot; + nounDef.id + &quot;:&quot; + item.id + &quot; to self-refs&quot;);</span>
<a href="#l26.266"></a><span id="l26.266" class="difflineplus">+      this.selfReferences[item.id] = item;</span>
<a href="#l26.267"></a><span id="l26.267" class="difflineplus">+      </span>
<a href="#l26.268"></a><span id="l26.268" class="difflineplus">+      // if we're tracking it, add ourselves to our parent's list of children</span>
<a href="#l26.269"></a><span id="l26.269" class="difflineplus">+      //  too</span>
<a href="#l26.270"></a><span id="l26.270" class="difflineplus">+      if (this.selfInverseReferences) {</span>
<a href="#l26.271"></a><span id="l26.271" class="difflineplus">+        let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l26.272"></a><span id="l26.272" class="difflineplus">+        let childrenList = this.selfInverseReferences[parentID];</span>
<a href="#l26.273"></a><span id="l26.273" class="difflineplus">+        if (childrenList === undefined)</span>
<a href="#l26.274"></a><span id="l26.274" class="difflineplus">+          childrenList = this.selfInverseReferences[parentID] = [];</span>
<a href="#l26.275"></a><span id="l26.275" class="difflineplus">+        childrenList.push(item);</span>
<a href="#l26.276"></a><span id="l26.276" class="difflineplus">+      }</span>
<a href="#l26.277"></a><span id="l26.277" class="difflineplus">+      </span>
<a href="#l26.278"></a><span id="l26.278" class="difflineplus">+      pendingItems.push(item);</span>
<a href="#l26.279"></a><span id="l26.279" class="difflineplus">+      pendingIdMap[item.id] = item;</span>
<a href="#l26.280"></a><span id="l26.280" class="difflineplus">+    }</span>
<a href="#l26.281"></a><span id="l26.281" class="difflineplus">+  },</span>
<a href="#l26.282"></a><span id="l26.282" class="difflineplus">+</span>
<a href="#l26.283"></a><span id="l26.283" class="difflineplus">+  handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l26.284"></a><span id="l26.284" class="difflineplus">+    GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l26.285"></a><span id="l26.285" class="difflineplus">+      aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l26.286"></a><span id="l26.286" class="difflineplus">+  },</span>
<a href="#l26.287"></a><span id="l26.287" class="difflineplus">+</span>
<a href="#l26.288"></a><span id="l26.288" class="difflineplus">+  handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l26.289"></a><span id="l26.289" class="difflineplus">+    this.statement.finalize();</span>
<a href="#l26.290"></a><span id="l26.290" class="difflineplus">+    this.statement = null;</span>
<a href="#l26.291"></a><span id="l26.291" class="difflineplus">+    </span>
<a href="#l26.292"></a><span id="l26.292" class="difflineplus">+    //QFQ_LOG.debug(&quot;handleCompletion: &quot; + this.collection._nounDef.name);</span>
<a href="#l26.293"></a><span id="l26.293" class="difflineplus">+    </span>
<a href="#l26.294"></a><span id="l26.294" class="difflineplus">+    if (this.needsLoads) {</span>
<a href="#l26.295"></a><span id="l26.295" class="difflineplus">+      for each (let [nounID, references] in Iterator(this.referencesByNounID)) {</span>
<a href="#l26.296"></a><span id="l26.296" class="difflineplus">+        if (nounID == this.nounDef.id)</span>
<a href="#l26.297"></a><span id="l26.297" class="difflineplus">+          continue;</span>
<a href="#l26.298"></a><span id="l26.298" class="difflineplus">+        let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l26.299"></a><span id="l26.299" class="difflineplus">+        //QFQ_LOG.debug(&quot;  have references for noun: &quot; + nounDef.name);</span>
<a href="#l26.300"></a><span id="l26.300" class="difflineplus">+        // try and load them out of the cache/existing collections.  items in the</span>
<a href="#l26.301"></a><span id="l26.301" class="difflineplus">+        //  cache will be fully formed, which is nice for us.</span>
<a href="#l26.302"></a><span id="l26.302" class="difflineplus">+        // XXX this mechanism will get dubious when we have multiple paths to a</span>
<a href="#l26.303"></a><span id="l26.303" class="difflineplus">+        //  single noun-type.  For example, a -&gt; b -&gt; c, a-&gt; c; two paths to c</span>
<a href="#l26.304"></a><span id="l26.304" class="difflineplus">+        //  and we're looking at issuing two requests to c, the latter of which</span>
<a href="#l26.305"></a><span id="l26.305" class="difflineplus">+        //  will be a superset of the first one.  This does not currently pose</span>
<a href="#l26.306"></a><span id="l26.306" class="difflineplus">+        //  a problem because we only have a -&gt; b -&gt; c -&gt; b, and sequential</span>
<a href="#l26.307"></a><span id="l26.307" class="difflineplus">+        //  processing means no alarms and no surprises.</span>
<a href="#l26.308"></a><span id="l26.308" class="difflineplus">+        let masterReferences = this.masterReferencesByNounID[nounID];</span>
<a href="#l26.309"></a><span id="l26.309" class="difflineplus">+        if (masterReferences === undefined)</span>
<a href="#l26.310"></a><span id="l26.310" class="difflineplus">+          masterReferences = this.masterReferencesByNounID[nounID] = {};</span>
<a href="#l26.311"></a><span id="l26.311" class="difflineplus">+        let outReferences;</span>
<a href="#l26.312"></a><span id="l26.312" class="difflineplus">+        if (nounDef.parentColumnAttr)</span>
<a href="#l26.313"></a><span id="l26.313" class="difflineplus">+          outReferences = {};</span>
<a href="#l26.314"></a><span id="l26.314" class="difflineplus">+        else</span>
<a href="#l26.315"></a><span id="l26.315" class="difflineplus">+          outReferences = masterReferences;</span>
<a href="#l26.316"></a><span id="l26.316" class="difflineplus">+        let [foundCount, notFoundCount, notFound] =</span>
<a href="#l26.317"></a><span id="l26.317" class="difflineplus">+          GlodaCollectionManager.cacheLookupMany(nounDef.id, references,</span>
<a href="#l26.318"></a><span id="l26.318" class="difflineplus">+              outReferences);</span>
<a href="#l26.319"></a><span id="l26.319" class="difflineplus">+</span>
<a href="#l26.320"></a><span id="l26.320" class="difflineplus">+        if (nounDef.parentColumnAttr) {</span>
<a href="#l26.321"></a><span id="l26.321" class="difflineplus">+          let inverseReferences;</span>
<a href="#l26.322"></a><span id="l26.322" class="difflineplus">+          if (nounDef.id in this.masterInverseReferencesByNounID)</span>
<a href="#l26.323"></a><span id="l26.323" class="difflineplus">+            inverseReferences =</span>
<a href="#l26.324"></a><span id="l26.324" class="difflineplus">+              this.masterInverseReferencesByNounID[nounDef.id];</span>
<a href="#l26.325"></a><span id="l26.325" class="difflineplus">+          else</span>
<a href="#l26.326"></a><span id="l26.326" class="difflineplus">+            inverseReferences =</span>
<a href="#l26.327"></a><span id="l26.327" class="difflineplus">+              this.masterInverseReferencesByNounID[nounDef.id] = {};</span>
<a href="#l26.328"></a><span id="l26.328" class="difflineplus">+          </span>
<a href="#l26.329"></a><span id="l26.329" class="difflineplus">+          for each (let item in outReferences) {</span>
<a href="#l26.330"></a><span id="l26.330" class="difflineplus">+            masterReferences[item.id] = item;</span>
<a href="#l26.331"></a><span id="l26.331" class="difflineplus">+            let parentID = item[nounDef.parentColumnAttr.idStorageAttributeName];</span>
<a href="#l26.332"></a><span id="l26.332" class="difflineplus">+            let childrenList = inverseReferences[parentID];</span>
<a href="#l26.333"></a><span id="l26.333" class="difflineplus">+            if (childrenList === undefined)</span>
<a href="#l26.334"></a><span id="l26.334" class="difflineplus">+              childrenList = inverseReferences[parentID] = [];</span>
<a href="#l26.335"></a><span id="l26.335" class="difflineplus">+            childrenList.push(item);</span>
<a href="#l26.336"></a><span id="l26.336" class="difflineplus">+          }</span>
<a href="#l26.337"></a><span id="l26.337" class="difflineplus">+        }</span>
<a href="#l26.338"></a><span id="l26.338" class="difflineplus">+        </span>
<a href="#l26.339"></a><span id="l26.339" class="difflineplus">+        //QFQ_LOG.debug(&quot;  found: &quot; + foundCount + &quot; not found: &quot; + notFoundCount);</span>
<a href="#l26.340"></a><span id="l26.340" class="difflineplus">+        if (notFoundCount === 0) {</span>
<a href="#l26.341"></a><span id="l26.341" class="difflineplus">+          this.collection.resolvedCount++;</span>
<a href="#l26.342"></a><span id="l26.342" class="difflineplus">+        }</span>
<a href="#l26.343"></a><span id="l26.343" class="difflineplus">+        else {</span>
<a href="#l26.344"></a><span id="l26.344" class="difflineplus">+          this.collection.deferredCount++;</span>
<a href="#l26.345"></a><span id="l26.345" class="difflineplus">+          let query = new nounDef.queryClass();</span>
<a href="#l26.346"></a><span id="l26.346" class="difflineplus">+          query.id.apply(query, [id for (id in notFound)]);</span>
<a href="#l26.347"></a><span id="l26.347" class="difflineplus">+          </span>
<a href="#l26.348"></a><span id="l26.348" class="difflineplus">+          this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l26.349"></a><span id="l26.349" class="difflineplus">+            GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver, </span>
<a href="#l26.350"></a><span id="l26.350" class="difflineplus">+              this.collection,</span>
<a href="#l26.351"></a><span id="l26.351" class="difflineplus">+              // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l26.352"></a><span id="l26.352" class="difflineplus">+              this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l26.353"></a><span id="l26.353" class="difflineplus">+              this.collection.masterCollection);</span>
<a href="#l26.354"></a><span id="l26.354" class="difflineplus">+        }</span>
<a href="#l26.355"></a><span id="l26.355" class="difflineplus">+      }</span>
<a href="#l26.356"></a><span id="l26.356" class="difflineplus">+      </span>
<a href="#l26.357"></a><span id="l26.357" class="difflineplus">+      for each (let [nounID, inverseReferences] in</span>
<a href="#l26.358"></a><span id="l26.358" class="difflineplus">+          Iterator(this.inverseReferencesByNounID)) {</span>
<a href="#l26.359"></a><span id="l26.359" class="difflineplus">+        this.collection.deferredCount++;</span>
<a href="#l26.360"></a><span id="l26.360" class="difflineplus">+        let nounDef = GlodaDatastore._nounIDToDef[nounID];</span>
<a href="#l26.361"></a><span id="l26.361" class="difflineplus">+        </span>
<a href="#l26.362"></a><span id="l26.362" class="difflineplus">+        //QFQ_LOG.debug(&quot;Want to load inverse via &quot; + nounDef.parentColumnAttr.boundName);</span>
<a href="#l26.363"></a><span id="l26.363" class="difflineplus">+  </span>
<a href="#l26.364"></a><span id="l26.364" class="difflineplus">+        let query = new nounDef.queryClass();</span>
<a href="#l26.365"></a><span id="l26.365" class="difflineplus">+        // we want to constrain using the parent column</span>
<a href="#l26.366"></a><span id="l26.366" class="difflineplus">+        let queryConstrainer = query[nounDef.parentColumnAttr.boundName];</span>
<a href="#l26.367"></a><span id="l26.367" class="difflineplus">+        queryConstrainer.apply(query, [pid for (pid in inverseReferences)]);</span>
<a href="#l26.368"></a><span id="l26.368" class="difflineplus">+        this.collection.masterCollection.subCollections[nounDef.id] = </span>
<a href="#l26.369"></a><span id="l26.369" class="difflineplus">+          GlodaDatastore.queryFromQuery(query, QueryFromQueryResolver,</span>
<a href="#l26.370"></a><span id="l26.370" class="difflineplus">+            this.collection,</span>
<a href="#l26.371"></a><span id="l26.371" class="difflineplus">+            // we fully expect/allow for there being no such subcollection yet.</span>
<a href="#l26.372"></a><span id="l26.372" class="difflineplus">+            this.collection.masterCollection.subCollections[nounDef.id],</span>
<a href="#l26.373"></a><span id="l26.373" class="difflineplus">+            this.collection.masterCollection);</span>
<a href="#l26.374"></a><span id="l26.374" class="difflineplus">+      }</span>
<a href="#l26.375"></a><span id="l26.375" class="difflineplus">+    }</span>
<a href="#l26.376"></a><span id="l26.376" class="difflineplus">+    else {</span>
<a href="#l26.377"></a><span id="l26.377" class="difflineplus">+      this.collection.deferredCount--;</span>
<a href="#l26.378"></a><span id="l26.378" class="difflineplus">+      this.collection.resolvedCount++;</span>
<a href="#l26.379"></a><span id="l26.379" class="difflineplus">+    }</span>
<a href="#l26.380"></a><span id="l26.380" class="difflineplus">+    </span>
<a href="#l26.381"></a><span id="l26.381" class="difflineplus">+    //QFQ_LOG.debug(&quot;  defer: &quot; + this.collection.deferredCount +</span>
<a href="#l26.382"></a><span id="l26.382" class="difflineplus">+    //              &quot; resolved: &quot; + this.collection.resolvedCount);</span>
<a href="#l26.383"></a><span id="l26.383" class="difflineplus">+    </span>
<a href="#l26.384"></a><span id="l26.384" class="difflineplus">+    // process immediately and kick-up to the master collection...</span>
<a href="#l26.385"></a><span id="l26.385" class="difflineplus">+    try {</span>
<a href="#l26.386"></a><span id="l26.386" class="difflineplus">+      if (this.collection.deferredCount &lt;= 0) {</span>
<a href="#l26.387"></a><span id="l26.387" class="difflineplus">+        // this guy will resolve everyone using referencesByNounID and issue the</span>
<a href="#l26.388"></a><span id="l26.388" class="difflineplus">+        //  call to this.collection._onItemsAdded to propagate things to the</span>
<a href="#l26.389"></a><span id="l26.389" class="difflineplus">+        //  next concerned subCollection or the actual listener if this is the</span>
<a href="#l26.390"></a><span id="l26.390" class="difflineplus">+        //  master collection.  (Also, call _onQueryCompleted).</span>
<a href="#l26.391"></a><span id="l26.391" class="difflineplus">+        QueryFromQueryResolver.onItemsAdded(null, {data: this.collection}, true);</span>
<a href="#l26.392"></a><span id="l26.392" class="difflineplus">+        QueryFromQueryResolver.onQueryCompleted({data: this.collection});</span>
<a href="#l26.393"></a><span id="l26.393" class="difflineplus">+      }</span>
<a href="#l26.394"></a><span id="l26.394" class="difflineplus">+    }</span>
<a href="#l26.395"></a><span id="l26.395" class="difflineplus">+    finally {</span>
<a href="#l26.396"></a><span id="l26.396" class="difflineplus">+      GlodaDatastore._asyncCompleted();</span>
<a href="#l26.397"></a><span id="l26.397" class="difflineplus">+    }</span>
<a href="#l26.398"></a><span id="l26.398" class="difflineplus">+  }</span>
<a href="#l26.399"></a><span id="l26.399" class="difflineplus">+};</span>
<a href="#l26.400"></a><span id="l26.400" class="difflineplus">+</span>
<a href="#l26.401"></a><span id="l26.401" class="difflineplus">+</span>
<a href="#l26.402"></a><span id="l26.402" class="difflineplus">+/**</span>
<a href="#l26.403"></a><span id="l26.403" class="difflineplus">+ * Database abstraction layer.  Contains explicit SQL schemas for our</span>
<a href="#l26.404"></a><span id="l26.404" class="difflineplus">+ *  fundamental representations (core 'nouns', if you will) as well as</span>
<a href="#l26.405"></a><span id="l26.405" class="difflineplus">+ *  specialized functions for then dealing with each type of object.  At the</span>
<a href="#l26.406"></a><span id="l26.406" class="difflineplus">+ *  same time, we are beginning to support extension-provided tables, which</span>
<a href="#l26.407"></a><span id="l26.407" class="difflineplus">+ *  call into question whether we really need our hand-rolled code, or could</span>
<a href="#l26.408"></a><span id="l26.408" class="difflineplus">+ *  simply improve the extension-provided table case to work for most of our</span>
<a href="#l26.409"></a><span id="l26.409" class="difflineplus">+ *  hand-rolled cases.</span>
<a href="#l26.410"></a><span id="l26.410" class="difflineplus">+ * For now, the argument can probably be made that our explicit schemas and code</span>
<a href="#l26.411"></a><span id="l26.411" class="difflineplus">+ *  is readable/intuitive (not magic) and efficient (although generic stuff</span>
<a href="#l26.412"></a><span id="l26.412" class="difflineplus">+ *  could also be made efficient, if slightly evil through use of eval or some</span>
<a href="#l26.413"></a><span id="l26.413" class="difflineplus">+ *  other code generation mechanism.)</span>
<a href="#l26.414"></a><span id="l26.414" class="difflineplus">+ *</span>
<a href="#l26.415"></a><span id="l26.415" class="difflineplus">+ * === Data Model Interaction / Dependencies</span>
<a href="#l26.416"></a><span id="l26.416" class="difflineplus">+ *</span>
<a href="#l26.417"></a><span id="l26.417" class="difflineplus">+ * Dependent on and assumes limited knowledge of the datamodel.js</span>
<a href="#l26.418"></a><span id="l26.418" class="difflineplus">+ *  implementations.  datamodel.js actually has an implicit dependency on</span>
<a href="#l26.419"></a><span id="l26.419" class="difflineplus">+ *  our implementation, reaching back into the datastore via the _datastore</span>
<a href="#l26.420"></a><span id="l26.420" class="difflineplus">+ *  attribute which we pass into every instance we create.</span>
<a href="#l26.421"></a><span id="l26.421" class="difflineplus">+ * We pass a reference to ourself as we create the datamodel.js instances (and</span>
<a href="#l26.422"></a><span id="l26.422" class="difflineplus">+ *  they store it as _datastore) because of a half-implemented attempt to make</span>
<a href="#l26.423"></a><span id="l26.423" class="difflineplus">+ *  it possible to live in a world where we have multiple datastores.  This</span>
<a href="#l26.424"></a><span id="l26.424" class="difflineplus">+ *  would be desirable in the cases where we are dealing with multiple SQLite</span>
<a href="#l26.425"></a><span id="l26.425" class="difflineplus">+ *  databases.  This could be because of per-account global databases or</span>
<a href="#l26.426"></a><span id="l26.426" class="difflineplus">+ *  some other segmentation.  This was abandoned when the importance of</span>
<a href="#l26.427"></a><span id="l26.427" class="difflineplus">+ *  per-account databases was diminished following public discussion, at least</span>
<a href="#l26.428"></a><span id="l26.428" class="difflineplus">+ *  for the short-term, but no attempted was made to excise the feature or</span>
<a href="#l26.429"></a><span id="l26.429" class="difflineplus">+ *  preclude it.  (Merely a recognition that it's too much to try and implement</span>
<a href="#l26.430"></a><span id="l26.430" class="difflineplus">+ *  correct right now, especially because our solution might just be another</span>
<a href="#l26.431"></a><span id="l26.431" class="difflineplus">+ *  (aggregating) layer on top of things, rather than complicating the lower</span>
<a href="#l26.432"></a><span id="l26.432" class="difflineplus">+ *  levels.)</span>
<a href="#l26.433"></a><span id="l26.433" class="difflineplus">+ *</span>
<a href="#l26.434"></a><span id="l26.434" class="difflineplus">+ * === Object Identity / Caching</span>
<a href="#l26.435"></a><span id="l26.435" class="difflineplus">+ *</span>
<a href="#l26.436"></a><span id="l26.436" class="difflineplus">+ * The issue of object identity is handled by integration with the collection.js</span>
<a href="#l26.437"></a><span id="l26.437" class="difflineplus">+ *  provided GlodaCollectionManager.  By &quot;Object Identity&quot;, I mean that we only</span>
<a href="#l26.438"></a><span id="l26.438" class="difflineplus">+ *  should ever have one object instance alive at a time that corresponds to</span>
<a href="#l26.439"></a><span id="l26.439" class="difflineplus">+ *  an underlying database row in the database.  Where possible we avoid</span>
<a href="#l26.440"></a><span id="l26.440" class="difflineplus">+ *  performing database look-ups when we can check if the object is already</span>
<a href="#l26.441"></a><span id="l26.441" class="difflineplus">+ *  present in memory; in practice, this means when we are asking for an object</span>
<a href="#l26.442"></a><span id="l26.442" class="difflineplus">+ *  by ID.  When we cannot avoid a database query, we attempt to make sure that</span>
<a href="#l26.443"></a><span id="l26.443" class="difflineplus">+ *  we do not return a duplicate object instance, instead replacing it with the</span>
<a href="#l26.444"></a><span id="l26.444" class="difflineplus">+ *  'live' copy of the object.  (Ideally, we would avoid any redundant</span>
<a href="#l26.445"></a><span id="l26.445" class="difflineplus">+ *  construction costs, but that is not currently the case.)</span>
<a href="#l26.446"></a><span id="l26.446" class="difflineplus">+ * Although you should consult the GlodaCollectionManager for details, the</span>
<a href="#l26.447"></a><span id="l26.447" class="difflineplus">+ *  general idea is that we have 'collections' which represent views of the</span>
<a href="#l26.448"></a><span id="l26.448" class="difflineplus">+ *  database (based on a query) which use a single mechanism for double duty.</span>
<a href="#l26.449"></a><span id="l26.449" class="difflineplus">+ *  The collections are registered with the collection manager via weak</span>
<a href="#l26.450"></a><span id="l26.450" class="difflineplus">+ *  reference.  The first 'duty' is that since the collections may be desired</span>
<a href="#l26.451"></a><span id="l26.451" class="difflineplus">+ *  to be 'live views' of the data, we want them to update as changes occur.</span>
<a href="#l26.452"></a><span id="l26.452" class="difflineplus">+ *  The weak reference allows the collection manager to track the 'live'</span>
<a href="#l26.453"></a><span id="l26.453" class="difflineplus">+ *  collections and update them.  The second 'duty' is the caching/object</span>
<a href="#l26.454"></a><span id="l26.454" class="difflineplus">+ *  identity duty.  In theory, every live item should be referenced by at least</span>
<a href="#l26.455"></a><span id="l26.455" class="difflineplus">+ *  one collection, making it reachable for object identity/caching purposes.</span>
<a href="#l26.456"></a><span id="l26.456" class="difflineplus">+ * There is also an explicit (inclusive) caching layer present to both try and</span>
<a href="#l26.457"></a><span id="l26.457" class="difflineplus">+ *  avoid poor performance from some of the costs of this strategy, as well as</span>
<a href="#l26.458"></a><span id="l26.458" class="difflineplus">+ *  to try and keep track of objects that are being worked with that are not</span>
<a href="#l26.459"></a><span id="l26.459" class="difflineplus">+ *  (yet) tracked by a collection.  Using a size-bounded cache is clearly not</span>
<a href="#l26.460"></a><span id="l26.460" class="difflineplus">+ *  a guarantee of correctness for this, but is suspected will work quite well.</span>
<a href="#l26.461"></a><span id="l26.461" class="difflineplus">+ *  (Well enough to be dangerous because the inevitable failure case will not be</span>
<a href="#l26.462"></a><span id="l26.462" class="difflineplus">+ *  expected.)</span>
<a href="#l26.463"></a><span id="l26.463" class="difflineplus">+ *</span>
<a href="#l26.464"></a><span id="l26.464" class="difflineplus">+ * The current strategy may not be the optimal one, feel free to propose and/or</span>
<a href="#l26.465"></a><span id="l26.465" class="difflineplus">+ *  implement better ones, especially if you have numbers.</span>
<a href="#l26.466"></a><span id="l26.466" class="difflineplus">+ * The current strategy is not fully implemented in this file, but the common</span>
<a href="#l26.467"></a><span id="l26.467" class="difflineplus">+ *  cases are believed to be covered.  (Namely, we fail to purge items from the</span>
<a href="#l26.468"></a><span id="l26.468" class="difflineplus">+ *  cache as they are purged from the database.)</span>
<a href="#l26.469"></a><span id="l26.469" class="difflineplus">+ *</span>
<a href="#l26.470"></a><span id="l26.470" class="difflineplus">+ * === Things That May Not Be Obvious (Gotchas)</span>
<a href="#l26.471"></a><span id="l26.471" class="difflineplus">+ *</span>
<a href="#l26.472"></a><span id="l26.472" class="difflineplus">+ * Although the schema includes &quot;triggers&quot;, they are currently not used</span>
<a href="#l26.473"></a><span id="l26.473" class="difflineplus">+ *  and were added when thinking about implementing the feature.  We will</span>
<a href="#l26.474"></a><span id="l26.474" class="difflineplus">+ *  probably implement this feature at some point, which is why they are still</span>
<a href="#l26.475"></a><span id="l26.475" class="difflineplus">+ *  in there.</span>
<a href="#l26.476"></a><span id="l26.476" class="difflineplus">+ *</span>
<a href="#l26.477"></a><span id="l26.477" class="difflineplus">+ * We, and the layers above us, are not sufficiently thorough at cleaning out</span>
<a href="#l26.478"></a><span id="l26.478" class="difflineplus">+ *  data from the database, and may potentially orphan it _as new functionality</span>
<a href="#l26.479"></a><span id="l26.479" class="difflineplus">+ *  is added in the future at layers above us_.  That is, currently we should</span>
<a href="#l26.480"></a><span id="l26.480" class="difflineplus">+ *  not be leaking database rows, but we may in the future.  This is because</span>
<a href="#l26.481"></a><span id="l26.481" class="difflineplus">+ *  we/the layers above us lack a mechanism to track dependencies based on</span>
<a href="#l26.482"></a><span id="l26.482" class="difflineplus">+ *  attributes.  Say a plugin exists that extracts recipes from messages and</span>
<a href="#l26.483"></a><span id="l26.483" class="difflineplus">+ *  relates them via an attribute.  To do so, it must create new recipe rows</span>
<a href="#l26.484"></a><span id="l26.484" class="difflineplus">+ *  in its own table as new recipes are discovered.  No automatic mechanism</span>
<a href="#l26.485"></a><span id="l26.485" class="difflineplus">+ *  will purge recipes as their source messages are purged, nor does any</span>
<a href="#l26.486"></a><span id="l26.486" class="difflineplus">+ *  event-driven mechanism explicitly inform the plugin.  (It could infer</span>
<a href="#l26.487"></a><span id="l26.487" class="difflineplus">+ *  such an event from the indexing/attribute-providing process, or poll the</span>
<a href="#l26.488"></a><span id="l26.488" class="difflineplus">+ *  states of attributes to accomplish this, but that is not desirable.)  This</span>
<a href="#l26.489"></a><span id="l26.489" class="difflineplus">+ *  needs to be addressed, and may be best addressed at layers above</span>
<a href="#l26.490"></a><span id="l26.490" class="difflineplus">+ *  datastore.js.</span>
<a href="#l26.491"></a><span id="l26.491" class="difflineplus">+ * @namespace</span>
<a href="#l26.492"></a><span id="l26.492" class="difflineplus">+ */</span>
<a href="#l26.493"></a><span id="l26.493" class="difflineplus">+var GlodaDatastore = {</span>
<a href="#l26.494"></a><span id="l26.494" class="difflineplus">+  _log: null,</span>
<a href="#l26.495"></a><span id="l26.495" class="difflineplus">+</span>
<a href="#l26.496"></a><span id="l26.496" class="difflineplus">+  /* see Gloda's documentation for these constants */</span>
<a href="#l26.497"></a><span id="l26.497" class="difflineplus">+  kSpecialNotAtAll: 0,</span>
<a href="#l26.498"></a><span id="l26.498" class="difflineplus">+  kSpecialColumn: 16,</span>
<a href="#l26.499"></a><span id="l26.499" class="difflineplus">+  kSpecialColumnChildren: 16|1,</span>
<a href="#l26.500"></a><span id="l26.500" class="difflineplus">+  kSpecialColumnParent: 16|2,</span>
<a href="#l26.501"></a><span id="l26.501" class="difflineplus">+  kSpecialString: 32,</span>
<a href="#l26.502"></a><span id="l26.502" class="difflineplus">+  kSpecialFulltext: 64,</span>
<a href="#l26.503"></a><span id="l26.503" class="difflineplus">+  </span>
<a href="#l26.504"></a><span id="l26.504" class="difflineplus">+  kConstraintIdIn: 0,</span>
<a href="#l26.505"></a><span id="l26.505" class="difflineplus">+  kConstraintIn: 1,</span>
<a href="#l26.506"></a><span id="l26.506" class="difflineplus">+  kConstraintRanges: 2,</span>
<a href="#l26.507"></a><span id="l26.507" class="difflineplus">+  kConstraintEquals: 3,</span>
<a href="#l26.508"></a><span id="l26.508" class="difflineplus">+  kConstraintStringLike: 4,</span>
<a href="#l26.509"></a><span id="l26.509" class="difflineplus">+  kConstraintFulltext: 5,</span>
<a href="#l26.510"></a><span id="l26.510" class="difflineplus">+</span>
<a href="#l26.511"></a><span id="l26.511" class="difflineplus">+  /* ******************* SCHEMA ******************* */</span>
<a href="#l26.512"></a><span id="l26.512" class="difflineplus">+</span>
<a href="#l26.513"></a><span id="l26.513" class="difflineplus">+  _schemaVersion: 10,</span>
<a href="#l26.514"></a><span id="l26.514" class="difflineplus">+  _schema: {</span>
<a href="#l26.515"></a><span id="l26.515" class="difflineplus">+    tables: {</span>
<a href="#l26.516"></a><span id="l26.516" class="difflineplus">+</span>
<a href="#l26.517"></a><span id="l26.517" class="difflineplus">+      // ----- Messages</span>
<a href="#l26.518"></a><span id="l26.518" class="difflineplus">+      folderLocations: {</span>
<a href="#l26.519"></a><span id="l26.519" class="difflineplus">+        columns: [</span>
<a href="#l26.520"></a><span id="l26.520" class="difflineplus">+          &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l26.521"></a><span id="l26.521" class="difflineplus">+          &quot;folderURI TEXT NOT NULL&quot;,</span>
<a href="#l26.522"></a><span id="l26.522" class="difflineplus">+          &quot;dirtyStatus INTEGER NOT NULL&quot;,</span>
<a href="#l26.523"></a><span id="l26.523" class="difflineplus">+          &quot;name TEXT NOT NULL&quot;,</span>
<a href="#l26.524"></a><span id="l26.524" class="difflineplus">+        ],</span>
<a href="#l26.525"></a><span id="l26.525" class="difflineplus">+</span>
<a href="#l26.526"></a><span id="l26.526" class="difflineplus">+        triggers: {</span>
<a href="#l26.527"></a><span id="l26.527" class="difflineplus">+          delete: &quot;DELETE from messages WHERE folderID = OLD.id&quot;,</span>
<a href="#l26.528"></a><span id="l26.528" class="difflineplus">+        },</span>
<a href="#l26.529"></a><span id="l26.529" class="difflineplus">+      },</span>
<a href="#l26.530"></a><span id="l26.530" class="difflineplus">+</span>
<a href="#l26.531"></a><span id="l26.531" class="difflineplus">+      conversations: {</span>
<a href="#l26.532"></a><span id="l26.532" class="difflineplus">+        columns: [</span>
<a href="#l26.533"></a><span id="l26.533" class="difflineplus">+          &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l26.534"></a><span id="l26.534" class="difflineplus">+          &quot;subject TEXT NOT NULL&quot;,</span>
<a href="#l26.535"></a><span id="l26.535" class="difflineplus">+          &quot;oldestMessageDate INTEGER&quot;,</span>
<a href="#l26.536"></a><span id="l26.536" class="difflineplus">+          &quot;newestMessageDate INTEGER&quot;,</span>
<a href="#l26.537"></a><span id="l26.537" class="difflineplus">+        ],</span>
<a href="#l26.538"></a><span id="l26.538" class="difflineplus">+</span>
<a href="#l26.539"></a><span id="l26.539" class="difflineplus">+        indices: {</span>
<a href="#l26.540"></a><span id="l26.540" class="difflineplus">+          subject: ['subject'],</span>
<a href="#l26.541"></a><span id="l26.541" class="difflineplus">+          oldestMessageDate: ['oldestMessageDate'],</span>
<a href="#l26.542"></a><span id="l26.542" class="difflineplus">+          newestMessageDate: ['newestMessageDate'],</span>
<a href="#l26.543"></a><span id="l26.543" class="difflineplus">+        },</span>
<a href="#l26.544"></a><span id="l26.544" class="difflineplus">+</span>
<a href="#l26.545"></a><span id="l26.545" class="difflineplus">+        fulltextColumns: [</span>
<a href="#l26.546"></a><span id="l26.546" class="difflineplus">+          &quot;subject TEXT&quot;,</span>
<a href="#l26.547"></a><span id="l26.547" class="difflineplus">+        ],</span>
<a href="#l26.548"></a><span id="l26.548" class="difflineplus">+</span>
<a href="#l26.549"></a><span id="l26.549" class="difflineplus">+        triggers: {</span>
<a href="#l26.550"></a><span id="l26.550" class="difflineplus">+          delete: &quot;DELETE from messages WHERE conversationID = OLD.id&quot;,</span>
<a href="#l26.551"></a><span id="l26.551" class="difflineplus">+        },</span>
<a href="#l26.552"></a><span id="l26.552" class="difflineplus">+      },</span>
<a href="#l26.553"></a><span id="l26.553" class="difflineplus">+</span>
<a href="#l26.554"></a><span id="l26.554" class="difflineplus">+      /**</span>
<a href="#l26.555"></a><span id="l26.555" class="difflineplus">+       * A message record correspond to an actual message stored in a folder</span>
<a href="#l26.556"></a><span id="l26.556" class="difflineplus">+       *  somewhere, or is a ghost record indicating a message that we know</span>
<a href="#l26.557"></a><span id="l26.557" class="difflineplus">+       *  should exist, but which we have not seen (and which we may never see).</span>
<a href="#l26.558"></a><span id="l26.558" class="difflineplus">+       *  We represent these ghost messages by storing NULL values in the</span>
<a href="#l26.559"></a><span id="l26.559" class="difflineplus">+       *  folderID and messageKey fields; this may need to change to other</span>
<a href="#l26.560"></a><span id="l26.560" class="difflineplus">+       *  sentinel values if this somehow impacts performance.</span>
<a href="#l26.561"></a><span id="l26.561" class="difflineplus">+       */</span>
<a href="#l26.562"></a><span id="l26.562" class="difflineplus">+      messages: {</span>
<a href="#l26.563"></a><span id="l26.563" class="difflineplus">+        columns: [</span>
<a href="#l26.564"></a><span id="l26.564" class="difflineplus">+          &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l26.565"></a><span id="l26.565" class="difflineplus">+          &quot;folderID INTEGER REFERENCES folderLocations(id)&quot;,</span>
<a href="#l26.566"></a><span id="l26.566" class="difflineplus">+          &quot;messageKey INTEGER&quot;,</span>
<a href="#l26.567"></a><span id="l26.567" class="difflineplus">+          &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l26.568"></a><span id="l26.568" class="difflineplus">+          &quot;date INTEGER&quot;,</span>
<a href="#l26.569"></a><span id="l26.569" class="difflineplus">+          // we used to have the parentID, but because of the very real</span>
<a href="#l26.570"></a><span id="l26.570" class="difflineplus">+          //  possibility of multiple copies of a message with a given</span>
<a href="#l26.571"></a><span id="l26.571" class="difflineplus">+          //  message-id, the parentID concept is unreliable.</span>
<a href="#l26.572"></a><span id="l26.572" class="difflineplus">+          &quot;headerMessageID TEXT&quot;,</span>
<a href="#l26.573"></a><span id="l26.573" class="difflineplus">+          &quot;deleted INTEGER NOT NULL default 0&quot;,</span>
<a href="#l26.574"></a><span id="l26.574" class="difflineplus">+          &quot;jsonAttributes TEXT&quot;,</span>
<a href="#l26.575"></a><span id="l26.575" class="difflineplus">+        ],</span>
<a href="#l26.576"></a><span id="l26.576" class="difflineplus">+</span>
<a href="#l26.577"></a><span id="l26.577" class="difflineplus">+        indices: {</span>
<a href="#l26.578"></a><span id="l26.578" class="difflineplus">+          messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l26.579"></a><span id="l26.579" class="difflineplus">+          headerMessageID: ['headerMessageID'],</span>
<a href="#l26.580"></a><span id="l26.580" class="difflineplus">+          conversationID: ['conversationID'],</span>
<a href="#l26.581"></a><span id="l26.581" class="difflineplus">+          date: ['date'],</span>
<a href="#l26.582"></a><span id="l26.582" class="difflineplus">+          deleted: ['deleted'],</span>
<a href="#l26.583"></a><span id="l26.583" class="difflineplus">+        },</span>
<a href="#l26.584"></a><span id="l26.584" class="difflineplus">+</span>
<a href="#l26.585"></a><span id="l26.585" class="difflineplus">+        fulltextColumns: [</span>
<a href="#l26.586"></a><span id="l26.586" class="difflineplus">+          &quot;subject TEXT&quot;,</span>
<a href="#l26.587"></a><span id="l26.587" class="difflineplus">+          &quot;body TEXT&quot;,</span>
<a href="#l26.588"></a><span id="l26.588" class="difflineplus">+          &quot;attachmentNames TEXT&quot;,</span>
<a href="#l26.589"></a><span id="l26.589" class="difflineplus">+        ],</span>
<a href="#l26.590"></a><span id="l26.590" class="difflineplus">+</span>
<a href="#l26.591"></a><span id="l26.591" class="difflineplus">+        triggers: {</span>
<a href="#l26.592"></a><span id="l26.592" class="difflineplus">+          delete: &quot;DELETE FROM messageAttributes WHERE messageID = OLD.id&quot;,</span>
<a href="#l26.593"></a><span id="l26.593" class="difflineplus">+        },</span>
<a href="#l26.594"></a><span id="l26.594" class="difflineplus">+      },</span>
<a href="#l26.595"></a><span id="l26.595" class="difflineplus">+</span>
<a href="#l26.596"></a><span id="l26.596" class="difflineplus">+      // ----- Attributes</span>
<a href="#l26.597"></a><span id="l26.597" class="difflineplus">+      attributeDefinitions: {</span>
<a href="#l26.598"></a><span id="l26.598" class="difflineplus">+        columns: [</span>
<a href="#l26.599"></a><span id="l26.599" class="difflineplus">+          &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l26.600"></a><span id="l26.600" class="difflineplus">+          &quot;attributeType INTEGER NOT NULL&quot;,</span>
<a href="#l26.601"></a><span id="l26.601" class="difflineplus">+          &quot;extensionName TEXT NOT NULL&quot;,</span>
<a href="#l26.602"></a><span id="l26.602" class="difflineplus">+          &quot;name TEXT NOT NULL&quot;,</span>
<a href="#l26.603"></a><span id="l26.603" class="difflineplus">+          &quot;parameter BLOB&quot;,</span>
<a href="#l26.604"></a><span id="l26.604" class="difflineplus">+        ],</span>
<a href="#l26.605"></a><span id="l26.605" class="difflineplus">+</span>
<a href="#l26.606"></a><span id="l26.606" class="difflineplus">+        triggers: {</span>
<a href="#l26.607"></a><span id="l26.607" class="difflineplus">+          delete: &quot;DELETE FROM messageAttributes WHERE attributeID = OLD.id&quot;,</span>
<a href="#l26.608"></a><span id="l26.608" class="difflineplus">+        },</span>
<a href="#l26.609"></a><span id="l26.609" class="difflineplus">+      },</span>
<a href="#l26.610"></a><span id="l26.610" class="difflineplus">+</span>
<a href="#l26.611"></a><span id="l26.611" class="difflineplus">+      messageAttributes: {</span>
<a href="#l26.612"></a><span id="l26.612" class="difflineplus">+        columns: [</span>
<a href="#l26.613"></a><span id="l26.613" class="difflineplus">+          &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l26.614"></a><span id="l26.614" class="difflineplus">+          &quot;messageID INTEGER NOT NULL REFERENCES messages(id)&quot;,</span>
<a href="#l26.615"></a><span id="l26.615" class="difflineplus">+          &quot;attributeID INTEGER NOT NULL REFERENCES attributeDefinitions(id)&quot;,</span>
<a href="#l26.616"></a><span id="l26.616" class="difflineplus">+          &quot;value NUMERIC&quot;,</span>
<a href="#l26.617"></a><span id="l26.617" class="difflineplus">+        ],</span>
<a href="#l26.618"></a><span id="l26.618" class="difflineplus">+</span>
<a href="#l26.619"></a><span id="l26.619" class="difflineplus">+        indices: {</span>
<a href="#l26.620"></a><span id="l26.620" class="difflineplus">+          attribQuery: [</span>
<a href="#l26.621"></a><span id="l26.621" class="difflineplus">+            &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l26.622"></a><span id="l26.622" class="difflineplus">+            /* covering: */ &quot;conversationID&quot;, &quot;messageID&quot;],</span>
<a href="#l26.623"></a><span id="l26.623" class="difflineplus">+        },</span>
<a href="#l26.624"></a><span id="l26.624" class="difflineplus">+      },</span>
<a href="#l26.625"></a><span id="l26.625" class="difflineplus">+</span>
<a href="#l26.626"></a><span id="l26.626" class="difflineplus">+      // ----- Contacts / Identities</span>
<a href="#l26.627"></a><span id="l26.627" class="difflineplus">+</span>
<a href="#l26.628"></a><span id="l26.628" class="difflineplus">+      /**</span>
<a href="#l26.629"></a><span id="l26.629" class="difflineplus">+       * Corresponds to a human being and roughly to an address book entry.</span>
<a href="#l26.630"></a><span id="l26.630" class="difflineplus">+       *  Constrast with an identity, which is a specific e-mail address, IRC</span>
<a href="#l26.631"></a><span id="l26.631" class="difflineplus">+       *  nick, etc.  Identities belong to contacts, and this relationship is</span>
<a href="#l26.632"></a><span id="l26.632" class="difflineplus">+       *  expressed on the identityAttributes table.</span>
<a href="#l26.633"></a><span id="l26.633" class="difflineplus">+       */</span>
<a href="#l26.634"></a><span id="l26.634" class="difflineplus">+      contacts: {</span>
<a href="#l26.635"></a><span id="l26.635" class="difflineplus">+        columns: [</span>
<a href="#l26.636"></a><span id="l26.636" class="difflineplus">+          &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l26.637"></a><span id="l26.637" class="difflineplus">+          &quot;directoryUUID TEXT&quot;,</span>
<a href="#l26.638"></a><span id="l26.638" class="difflineplus">+          &quot;contactUUID TEXT&quot;,</span>
<a href="#l26.639"></a><span id="l26.639" class="difflineplus">+          &quot;popularity INTEGER&quot;,</span>
<a href="#l26.640"></a><span id="l26.640" class="difflineplus">+          &quot;frecency INTEGER&quot;,</span>
<a href="#l26.641"></a><span id="l26.641" class="difflineplus">+          &quot;name TEXT&quot;,</span>
<a href="#l26.642"></a><span id="l26.642" class="difflineplus">+          &quot;jsonAttributes TEXT&quot;,</span>
<a href="#l26.643"></a><span id="l26.643" class="difflineplus">+        ],</span>
<a href="#l26.644"></a><span id="l26.644" class="difflineplus">+        indices: {</span>
<a href="#l26.645"></a><span id="l26.645" class="difflineplus">+          popularity: [&quot;popularity&quot;],</span>
<a href="#l26.646"></a><span id="l26.646" class="difflineplus">+          frecency: [&quot;frecency&quot;],</span>
<a href="#l26.647"></a><span id="l26.647" class="difflineplus">+        },</span>
<a href="#l26.648"></a><span id="l26.648" class="difflineplus">+      },</span>
<a href="#l26.649"></a><span id="l26.649" class="difflineplus">+</span>
<a href="#l26.650"></a><span id="l26.650" class="difflineplus">+      contactAttributes: {</span>
<a href="#l26.651"></a><span id="l26.651" class="difflineplus">+        columns: [</span>
<a href="#l26.652"></a><span id="l26.652" class="difflineplus">+          &quot;contactID INTEGER NOT NULL REFERENCES contacts(id)&quot;,</span>
<a href="#l26.653"></a><span id="l26.653" class="difflineplus">+          &quot;attributeID INTEGER NOT NULL REFERENCES attributeDefinitions(id)&quot;,</span>
<a href="#l26.654"></a><span id="l26.654" class="difflineplus">+          &quot;value NUMERIC&quot;</span>
<a href="#l26.655"></a><span id="l26.655" class="difflineplus">+        ],</span>
<a href="#l26.656"></a><span id="l26.656" class="difflineplus">+        indices: {</span>
<a href="#l26.657"></a><span id="l26.657" class="difflineplus">+          contactAttribQuery: [</span>
<a href="#l26.658"></a><span id="l26.658" class="difflineplus">+            &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l26.659"></a><span id="l26.659" class="difflineplus">+            /* covering: */ &quot;contactID&quot;],</span>
<a href="#l26.660"></a><span id="l26.660" class="difflineplus">+        }</span>
<a href="#l26.661"></a><span id="l26.661" class="difflineplus">+      },</span>
<a href="#l26.662"></a><span id="l26.662" class="difflineplus">+</span>
<a href="#l26.663"></a><span id="l26.663" class="difflineplus">+      /**</span>
<a href="#l26.664"></a><span id="l26.664" class="difflineplus">+       * Identities correspond to specific e-mail addresses, IRC nicks, etc.</span>
<a href="#l26.665"></a><span id="l26.665" class="difflineplus">+       */</span>
<a href="#l26.666"></a><span id="l26.666" class="difflineplus">+      identities: {</span>
<a href="#l26.667"></a><span id="l26.667" class="difflineplus">+        columns: [</span>
<a href="#l26.668"></a><span id="l26.668" class="difflineplus">+          &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l26.669"></a><span id="l26.669" class="difflineplus">+          &quot;contactID INTEGER NOT NULL REFERENCES contacts(id)&quot;,</span>
<a href="#l26.670"></a><span id="l26.670" class="difflineplus">+          &quot;kind TEXT NOT NULL&quot;, // ex: email, irc, etc.</span>
<a href="#l26.671"></a><span id="l26.671" class="difflineplus">+          &quot;value TEXT NOT NULL&quot;, // ex: e-mail address, irc nick/handle, etc.</span>
<a href="#l26.672"></a><span id="l26.672" class="difflineplus">+          &quot;description NOT NULL&quot;, // what makes this identity different from the</span>
<a href="#l26.673"></a><span id="l26.673" class="difflineplus">+          // others? (ex: home, work, etc.)</span>
<a href="#l26.674"></a><span id="l26.674" class="difflineplus">+          &quot;relay INTEGER NOT NULL&quot;, // is the identity just a relay mechanism?</span>
<a href="#l26.675"></a><span id="l26.675" class="difflineplus">+          // (ex: mailing list, twitter 'bouncer', IRC gateway, etc.)</span>
<a href="#l26.676"></a><span id="l26.676" class="difflineplus">+        ],</span>
<a href="#l26.677"></a><span id="l26.677" class="difflineplus">+</span>
<a href="#l26.678"></a><span id="l26.678" class="difflineplus">+        indices: {</span>
<a href="#l26.679"></a><span id="l26.679" class="difflineplus">+          contactQuery: [&quot;contactID&quot;],</span>
<a href="#l26.680"></a><span id="l26.680" class="difflineplus">+          valueQuery: [&quot;kind&quot;, &quot;value&quot;]</span>
<a href="#l26.681"></a><span id="l26.681" class="difflineplus">+        }</span>
<a href="#l26.682"></a><span id="l26.682" class="difflineplus">+      },</span>
<a href="#l26.683"></a><span id="l26.683" class="difflineplus">+</span>
<a href="#l26.684"></a><span id="l26.684" class="difflineplus">+      //identityAttributes: {</span>
<a href="#l26.685"></a><span id="l26.685" class="difflineplus">+      //},</span>
<a href="#l26.686"></a><span id="l26.686" class="difflineplus">+</span>
<a href="#l26.687"></a><span id="l26.687" class="difflineplus">+    },</span>
<a href="#l26.688"></a><span id="l26.688" class="difflineplus">+  },</span>
<a href="#l26.689"></a><span id="l26.689" class="difflineplus">+</span>
<a href="#l26.690"></a><span id="l26.690" class="difflineplus">+</span>
<a href="#l26.691"></a><span id="l26.691" class="difflineplus">+  /* ******************* LOGIC ******************* */</span>
<a href="#l26.692"></a><span id="l26.692" class="difflineplus">+  /**</span>
<a href="#l26.693"></a><span id="l26.693" class="difflineplus">+   * Our synchronous connection, primarily intended for read-only use, so as to</span>
<a href="#l26.694"></a><span id="l26.694" class="difflineplus">+   *  avoid stepping on the toes of our asynchronous connection that will do</span>
<a href="#l26.695"></a><span id="l26.695" class="difflineplus">+   *  most/all of our updating.</span>
<a href="#l26.696"></a><span id="l26.696" class="difflineplus">+   */</span>
<a href="#l26.697"></a><span id="l26.697" class="difflineplus">+  syncConnection: null,</span>
<a href="#l26.698"></a><span id="l26.698" class="difflineplus">+  /**</span>
<a href="#l26.699"></a><span id="l26.699" class="difflineplus">+   * Our connection reused for asynchronous usage, intended for database write</span>
<a href="#l26.700"></a><span id="l26.700" class="difflineplus">+   *  purposes.</span>
<a href="#l26.701"></a><span id="l26.701" class="difflineplus">+   */</span>
<a href="#l26.702"></a><span id="l26.702" class="difflineplus">+  asyncConnection: null,</span>
<a href="#l26.703"></a><span id="l26.703" class="difflineplus">+</span>
<a href="#l26.704"></a><span id="l26.704" class="difflineplus">+  /**</span>
<a href="#l26.705"></a><span id="l26.705" class="difflineplus">+   * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l26.706"></a><span id="l26.706" class="difflineplus">+   *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l26.707"></a><span id="l26.707" class="difflineplus">+   *  mapping.</span>
<a href="#l26.708"></a><span id="l26.708" class="difflineplus">+   */</span>
<a href="#l26.709"></a><span id="l26.709" class="difflineplus">+  _init: function gloda_ds_init(aNsJSON, aNounIDToDef) {</span>
<a href="#l26.710"></a><span id="l26.710" class="difflineplus">+    this._log = Log4Moz.Service.getLogger(&quot;gloda.datastore&quot;);</span>
<a href="#l26.711"></a><span id="l26.711" class="difflineplus">+    this._log.debug(&quot;Beginning datastore initialization.&quot;);</span>
<a href="#l26.712"></a><span id="l26.712" class="difflineplus">+    </span>
<a href="#l26.713"></a><span id="l26.713" class="difflineplus">+    this._json = aNsJSON;</span>
<a href="#l26.714"></a><span id="l26.714" class="difflineplus">+    this._nounIDToDef = aNounIDToDef;</span>
<a href="#l26.715"></a><span id="l26.715" class="difflineplus">+</span>
<a href="#l26.716"></a><span id="l26.716" class="difflineplus">+    // Get the path to our global database</span>
<a href="#l26.717"></a><span id="l26.717" class="difflineplus">+    var dirService = Cc[&quot;@mozilla.org/file/directory_service;1&quot;].</span>
<a href="#l26.718"></a><span id="l26.718" class="difflineplus">+                     getService(Ci.nsIProperties);</span>
<a href="#l26.719"></a><span id="l26.719" class="difflineplus">+    var dbFile = dirService.get(&quot;ProfD&quot;, Ci.nsIFile);</span>
<a href="#l26.720"></a><span id="l26.720" class="difflineplus">+    dbFile.append(&quot;global-messages-db.sqlite&quot;);</span>
<a href="#l26.721"></a><span id="l26.721" class="difflineplus">+</span>
<a href="#l26.722"></a><span id="l26.722" class="difflineplus">+    // Get the storage (sqlite) service</span>
<a href="#l26.723"></a><span id="l26.723" class="difflineplus">+    var dbService = Cc[&quot;@mozilla.org/storage/service;1&quot;].</span>
<a href="#l26.724"></a><span id="l26.724" class="difflineplus">+                    getService(Ci.mozIStorageService);</span>
<a href="#l26.725"></a><span id="l26.725" class="difflineplus">+</span>
<a href="#l26.726"></a><span id="l26.726" class="difflineplus">+    var dbConnection;</span>
<a href="#l26.727"></a><span id="l26.727" class="difflineplus">+</span>
<a href="#l26.728"></a><span id="l26.728" class="difflineplus">+    // Create the file if it does not exist</span>
<a href="#l26.729"></a><span id="l26.729" class="difflineplus">+    if (!dbFile.exists()) {</span>
<a href="#l26.730"></a><span id="l26.730" class="difflineplus">+      this._log.debug(&quot;Creating database because it does't exist.&quot;);</span>
<a href="#l26.731"></a><span id="l26.731" class="difflineplus">+      dbConnection = this._createDB(dbService, dbFile);</span>
<a href="#l26.732"></a><span id="l26.732" class="difflineplus">+    }</span>
<a href="#l26.733"></a><span id="l26.733" class="difflineplus">+    // It does exist, but we (someday) might need to upgrade the schema</span>
<a href="#l26.734"></a><span id="l26.734" class="difflineplus">+    else {</span>
<a href="#l26.735"></a><span id="l26.735" class="difflineplus">+      // (Exceptions may be thrown if the database is corrupt)</span>
<a href="#l26.736"></a><span id="l26.736" class="difflineplus">+      { // try {</span>
<a href="#l26.737"></a><span id="l26.737" class="difflineplus">+        dbConnection = dbService.openUnsharedDatabase(dbFile);</span>
<a href="#l26.738"></a><span id="l26.738" class="difflineplus">+</span>
<a href="#l26.739"></a><span id="l26.739" class="difflineplus">+        if (dbConnection.schemaVersion != this._schemaVersion) {</span>
<a href="#l26.740"></a><span id="l26.740" class="difflineplus">+          this._log.debug(&quot;Need to migrate database.  (DB version: &quot; +</span>
<a href="#l26.741"></a><span id="l26.741" class="difflineplus">+            dbConnection.schemaVersion + &quot; desired version: &quot; +</span>
<a href="#l26.742"></a><span id="l26.742" class="difflineplus">+            this._schemaVersion);</span>
<a href="#l26.743"></a><span id="l26.743" class="difflineplus">+          dbConnection = this._migrate(dbService, dbFile,</span>
<a href="#l26.744"></a><span id="l26.744" class="difflineplus">+                                       dbConnection,</span>
<a href="#l26.745"></a><span id="l26.745" class="difflineplus">+                                       dbConnection.schemaVersion,</span>
<a href="#l26.746"></a><span id="l26.746" class="difflineplus">+                                       this._schemaVersion);</span>
<a href="#l26.747"></a><span id="l26.747" class="difflineplus">+          this._log.debug(&quot;Migration completed.&quot;);</span>
<a href="#l26.748"></a><span id="l26.748" class="difflineplus">+        }</span>
<a href="#l26.749"></a><span id="l26.749" class="difflineplus">+      }</span>
<a href="#l26.750"></a><span id="l26.750" class="difflineplus">+      // Handle corrupt databases, other oddities</span>
<a href="#l26.751"></a><span id="l26.751" class="difflineplus">+      // ... in the future. for now, let us die</span>
<a href="#l26.752"></a><span id="l26.752" class="difflineplus">+    }</span>
<a href="#l26.753"></a><span id="l26.753" class="difflineplus">+</span>
<a href="#l26.754"></a><span id="l26.754" class="difflineplus">+    this.syncConnection = dbConnection;</span>
<a href="#l26.755"></a><span id="l26.755" class="difflineplus">+    this.asyncConnection = dbConnection;</span>
<a href="#l26.756"></a><span id="l26.756" class="difflineplus">+</span>
<a href="#l26.757"></a><span id="l26.757" class="difflineplus">+    this._log.debug(&quot;Initializing folder mappings.&quot;);</span>
<a href="#l26.758"></a><span id="l26.758" class="difflineplus">+    this._getAllFolderMappings();</span>
<a href="#l26.759"></a><span id="l26.759" class="difflineplus">+    // we need to figure out the next id's for all of the tables where we</span>
<a href="#l26.760"></a><span id="l26.760" class="difflineplus">+    //  manage that.</span>
<a href="#l26.761"></a><span id="l26.761" class="difflineplus">+    this._log.debug(&quot;Populating managed id counters.&quot;);</span>
<a href="#l26.762"></a><span id="l26.762" class="difflineplus">+    this._populateAttributeDefManagedId();</span>
<a href="#l26.763"></a><span id="l26.763" class="difflineplus">+    this._populateConversationManagedId();</span>
<a href="#l26.764"></a><span id="l26.764" class="difflineplus">+    this._populateMessageManagedId();</span>
<a href="#l26.765"></a><span id="l26.765" class="difflineplus">+    this._populateContactManagedId();</span>
<a href="#l26.766"></a><span id="l26.766" class="difflineplus">+    this._populateIdentityManagedId();</span>
<a href="#l26.767"></a><span id="l26.767" class="difflineplus">+    </span>
<a href="#l26.768"></a><span id="l26.768" class="difflineplus">+    this._log.debug(&quot;Completed datastore initialization.&quot;);</span>
<a href="#l26.769"></a><span id="l26.769" class="difflineplus">+  },</span>
<a href="#l26.770"></a><span id="l26.770" class="difflineplus">+</span>
<a href="#l26.771"></a><span id="l26.771" class="difflineplus">+  /**</span>
<a href="#l26.772"></a><span id="l26.772" class="difflineplus">+   * Initiate database shutdown; because this might requiring waiting for</span>
<a href="#l26.773"></a><span id="l26.773" class="difflineplus">+   *  outstanding synchronous events to drain, we allow the caller to pass in</span>
<a href="#l26.774"></a><span id="l26.774" class="difflineplus">+   *  a callback to invoke if we are unable to complete shutdown within this</span>
<a href="#l26.775"></a><span id="l26.775" class="difflineplus">+   *  call.</span>
<a href="#l26.776"></a><span id="l26.776" class="difflineplus">+   * @return true if we were able to shutdown fully, false if we were not.  The</span>
<a href="#l26.777"></a><span id="l26.777" class="difflineplus">+   *   callback, if provided, will be notified if we return false.  It will</span>
<a href="#l26.778"></a><span id="l26.778" class="difflineplus">+   *   not be called if we return true.</span>
<a href="#l26.779"></a><span id="l26.779" class="difflineplus">+   */</span>
<a href="#l26.780"></a><span id="l26.780" class="difflineplus">+  shutdown: function gloda_ds_shutdown(aCallback, aCallbackThis) {</span>
<a href="#l26.781"></a><span id="l26.781" class="difflineplus">+    // clear out any transaction</span>
<a href="#l26.782"></a><span id="l26.782" class="difflineplus">+    while (this._transactionDepth) {</span>
<a href="#l26.783"></a><span id="l26.783" class="difflineplus">+      this._log.info(&quot;Closing pending transaction out for shutdown.&quot;);</span>
<a href="#l26.784"></a><span id="l26.784" class="difflineplus">+      // just schedule this function to be run again once the transaction has</span>
<a href="#l26.785"></a><span id="l26.785" class="difflineplus">+      //  been closed out.</span>
<a href="#l26.786"></a><span id="l26.786" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l26.787"></a><span id="l26.787" class="difflineplus">+    }</span>
<a href="#l26.788"></a><span id="l26.788" class="difflineplus">+</span>
<a href="#l26.789"></a><span id="l26.789" class="difflineplus">+    let datastore = this;</span>
<a href="#l26.790"></a><span id="l26.790" class="difflineplus">+</span>
<a href="#l26.791"></a><span id="l26.791" class="difflineplus">+    function finish_cleanup() {</span>
<a href="#l26.792"></a><span id="l26.792" class="difflineplus">+      datastore._cleanupAsyncStatements();</span>
<a href="#l26.793"></a><span id="l26.793" class="difflineplus">+      datastore._cleanupSyncStatements();</span>
<a href="#l26.794"></a><span id="l26.794" class="difflineplus">+      datastore._log.info(&quot;Closing db connection&quot;);</span>
<a href="#l26.795"></a><span id="l26.795" class="difflineplus">+      datastore.asyncConnection.close();</span>
<a href="#l26.796"></a><span id="l26.796" class="difflineplus">+      datastore.asyncConnection = null;</span>
<a href="#l26.797"></a><span id="l26.797" class="difflineplus">+      datastore.syncConnection = null;</span>
<a href="#l26.798"></a><span id="l26.798" class="difflineplus">+</span>
<a href="#l26.799"></a><span id="l26.799" class="difflineplus">+      if (aCallback) {</span>
<a href="#l26.800"></a><span id="l26.800" class="difflineplus">+        aCallback.call(aCallbackThis);</span>
<a href="#l26.801"></a><span id="l26.801" class="difflineplus">+      }</span>
<a href="#l26.802"></a><span id="l26.802" class="difflineplus">+    }</span>
<a href="#l26.803"></a><span id="l26.803" class="difflineplus">+</span>
<a href="#l26.804"></a><span id="l26.804" class="difflineplus">+    if (this._pendingAsyncStatements) {</span>
<a href="#l26.805"></a><span id="l26.805" class="difflineplus">+      this._pendingAsyncCompletedListener = finish_cleanup;</span>
<a href="#l26.806"></a><span id="l26.806" class="difflineplus">+      return false;</span>
<a href="#l26.807"></a><span id="l26.807" class="difflineplus">+    }</span>
<a href="#l26.808"></a><span id="l26.808" class="difflineplus">+    else {</span>
<a href="#l26.809"></a><span id="l26.809" class="difflineplus">+      this._log.debug(&quot;There are no pending async statements, finishing now.&quot;);</span>
<a href="#l26.810"></a><span id="l26.810" class="difflineplus">+      aCallback = null;</span>
<a href="#l26.811"></a><span id="l26.811" class="difflineplus">+      finish_cleanup();</span>
<a href="#l26.812"></a><span id="l26.812" class="difflineplus">+      return true;</span>
<a href="#l26.813"></a><span id="l26.813" class="difflineplus">+    }</span>
<a href="#l26.814"></a><span id="l26.814" class="difflineplus">+  },</span>
<a href="#l26.815"></a><span id="l26.815" class="difflineplus">+</span>
<a href="#l26.816"></a><span id="l26.816" class="difflineplus">+  /**</span>
<a href="#l26.817"></a><span id="l26.817" class="difflineplus">+   * Create our database; basically a wrapper around _createSchema.</span>
<a href="#l26.818"></a><span id="l26.818" class="difflineplus">+   */</span>
<a href="#l26.819"></a><span id="l26.819" class="difflineplus">+  _createDB: function gloda_ds_createDB(aDBService, aDBFile) {</span>
<a href="#l26.820"></a><span id="l26.820" class="difflineplus">+    var dbConnection = aDBService.openUnsharedDatabase(aDBFile);</span>
<a href="#l26.821"></a><span id="l26.821" class="difflineplus">+</span>
<a href="#l26.822"></a><span id="l26.822" class="difflineplus">+    dbConnection.beginTransaction();</span>
<a href="#l26.823"></a><span id="l26.823" class="difflineplus">+    try {</span>
<a href="#l26.824"></a><span id="l26.824" class="difflineplus">+      this._createSchema(dbConnection);</span>
<a href="#l26.825"></a><span id="l26.825" class="difflineplus">+      dbConnection.commitTransaction();</span>
<a href="#l26.826"></a><span id="l26.826" class="difflineplus">+    }</span>
<a href="#l26.827"></a><span id="l26.827" class="difflineplus">+    catch(ex) {</span>
<a href="#l26.828"></a><span id="l26.828" class="difflineplus">+      dbConnection.rollbackTransaction();</span>
<a href="#l26.829"></a><span id="l26.829" class="difflineplus">+      throw ex;</span>
<a href="#l26.830"></a><span id="l26.830" class="difflineplus">+    }</span>
<a href="#l26.831"></a><span id="l26.831" class="difflineplus">+</span>
<a href="#l26.832"></a><span id="l26.832" class="difflineplus">+    return dbConnection;</span>
<a href="#l26.833"></a><span id="l26.833" class="difflineplus">+  },</span>
<a href="#l26.834"></a><span id="l26.834" class="difflineplus">+</span>
<a href="#l26.835"></a><span id="l26.835" class="difflineplus">+  _createTableSchema: function gloda_ds_createTableSchema(aDBConnection,</span>
<a href="#l26.836"></a><span id="l26.836" class="difflineplus">+      aTableName) {</span>
<a href="#l26.837"></a><span id="l26.837" class="difflineplus">+    let table = this._schema.tables[aTableName];</span>
<a href="#l26.838"></a><span id="l26.838" class="difflineplus">+</span>
<a href="#l26.839"></a><span id="l26.839" class="difflineplus">+    // - Create the table</span>
<a href="#l26.840"></a><span id="l26.840" class="difflineplus">+    aDBConnection.createTable(aTableName, table.columns.join(&quot;, &quot;));</span>
<a href="#l26.841"></a><span id="l26.841" class="difflineplus">+</span>
<a href="#l26.842"></a><span id="l26.842" class="difflineplus">+    // - Create the fulltext table if applicable</span>
<a href="#l26.843"></a><span id="l26.843" class="difflineplus">+    if (&quot;fulltextColumns&quot; in table) {</span>
<a href="#l26.844"></a><span id="l26.844" class="difflineplus">+      let createFulltextSQL = &quot;CREATE VIRTUAL TABLE &quot; + aTableName + &quot;Text&quot; +</span>
<a href="#l26.845"></a><span id="l26.845" class="difflineplus">+        &quot; USING fts3(tokenize porter, &quot; + table.fulltextColumns.join(&quot;, &quot;) +</span>
<a href="#l26.846"></a><span id="l26.846" class="difflineplus">+        &quot;)&quot;;</span>
<a href="#l26.847"></a><span id="l26.847" class="difflineplus">+      this._log.info(&quot;Create fulltext: &quot; + createFulltextSQL);</span>
<a href="#l26.848"></a><span id="l26.848" class="difflineplus">+      aDBConnection.executeSimpleSQL(createFulltextSQL);</span>
<a href="#l26.849"></a><span id="l26.849" class="difflineplus">+    }</span>
<a href="#l26.850"></a><span id="l26.850" class="difflineplus">+</span>
<a href="#l26.851"></a><span id="l26.851" class="difflineplus">+    // - Create its indices</span>
<a href="#l26.852"></a><span id="l26.852" class="difflineplus">+    for (let indexName in table.indices) {</span>
<a href="#l26.853"></a><span id="l26.853" class="difflineplus">+      let indexColumns = table.indices[indexName];</span>
<a href="#l26.854"></a><span id="l26.854" class="difflineplus">+</span>
<a href="#l26.855"></a><span id="l26.855" class="difflineplus">+      aDBConnection.executeSimpleSQL(</span>
<a href="#l26.856"></a><span id="l26.856" class="difflineplus">+        &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; + aTableName +</span>
<a href="#l26.857"></a><span id="l26.857" class="difflineplus">+        &quot;(&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;);</span>
<a href="#l26.858"></a><span id="l26.858" class="difflineplus">+    }</span>
<a href="#l26.859"></a><span id="l26.859" class="difflineplus">+  },</span>
<a href="#l26.860"></a><span id="l26.860" class="difflineplus">+</span>
<a href="#l26.861"></a><span id="l26.861" class="difflineplus">+  /**</span>
<a href="#l26.862"></a><span id="l26.862" class="difflineplus">+   * Create our database schema assuming a newly created database.  This</span>
<a href="#l26.863"></a><span id="l26.863" class="difflineplus">+   *  comes down to creating normal tables, their full-text variants (if</span>
<a href="#l26.864"></a><span id="l26.864" class="difflineplus">+   *  applicable), and their indices.</span>
<a href="#l26.865"></a><span id="l26.865" class="difflineplus">+   */</span>
<a href="#l26.866"></a><span id="l26.866" class="difflineplus">+  _createSchema: function gloda_ds_createSchema(aDBConnection) {</span>
<a href="#l26.867"></a><span id="l26.867" class="difflineplus">+    // -- For each table...</span>
<a href="#l26.868"></a><span id="l26.868" class="difflineplus">+    for (let tableName in this._schema.tables) {</span>
<a href="#l26.869"></a><span id="l26.869" class="difflineplus">+      this._createTableSchema(aDBConnection, tableName);</span>
<a href="#l26.870"></a><span id="l26.870" class="difflineplus">+    }</span>
<a href="#l26.871"></a><span id="l26.871" class="difflineplus">+</span>
<a href="#l26.872"></a><span id="l26.872" class="difflineplus">+    aDBConnection.schemaVersion = this._schemaVersion;</span>
<a href="#l26.873"></a><span id="l26.873" class="difflineplus">+  },</span>
<a href="#l26.874"></a><span id="l26.874" class="difflineplus">+</span>
<a href="#l26.875"></a><span id="l26.875" class="difflineplus">+  /**</span>
<a href="#l26.876"></a><span id="l26.876" class="difflineplus">+   * Our table definition used here is slightly different from that used</span>
<a href="#l26.877"></a><span id="l26.877" class="difflineplus">+   *  internally, because we are potentially creating a sort of crappy ORM and</span>
<a href="#l26.878"></a><span id="l26.878" class="difflineplus">+   *  we don't want to have to parse the column names out.</span>
<a href="#l26.879"></a><span id="l26.879" class="difflineplus">+   */</span>
<a href="#l26.880"></a><span id="l26.880" class="difflineplus">+  createTableIfNotExists: function gloda_ds_createTableIfNotExists(aTableDef) {</span>
<a href="#l26.881"></a><span id="l26.881" class="difflineplus">+    aTableDef._realName = &quot;ext_&quot; + aTableDef.name;</span>
<a href="#l26.882"></a><span id="l26.882" class="difflineplus">+</span>
<a href="#l26.883"></a><span id="l26.883" class="difflineplus">+    // first, check if the table exists</span>
<a href="#l26.884"></a><span id="l26.884" class="difflineplus">+    if (!this.asyncConnection.tableExists(aTableDef._realName)) {</span>
<a href="#l26.885"></a><span id="l26.885" class="difflineplus">+      try {</span>
<a href="#l26.886"></a><span id="l26.886" class="difflineplus">+        this.asyncConnection.createTable(aTableDef._realName,</span>
<a href="#l26.887"></a><span id="l26.887" class="difflineplus">+          [coldef.join(&quot; &quot;) for each</span>
<a href="#l26.888"></a><span id="l26.888" class="difflineplus">+           ([i, coldef] in Iterator(aTableDef.columns))].join(&quot;, &quot;));</span>
<a href="#l26.889"></a><span id="l26.889" class="difflineplus">+      }</span>
<a href="#l26.890"></a><span id="l26.890" class="difflineplus">+      catch (ex) {</span>
<a href="#l26.891"></a><span id="l26.891" class="difflineplus">+         this._log.error(&quot;Problem creating table &quot; + aTableDef.name + &quot; &quot; +</span>
<a href="#l26.892"></a><span id="l26.892" class="difflineplus">+           &quot;because: &quot; + ex + &quot; at &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l26.893"></a><span id="l26.893" class="difflineplus">+         return null;</span>
<a href="#l26.894"></a><span id="l26.894" class="difflineplus">+      }</span>
<a href="#l26.895"></a><span id="l26.895" class="difflineplus">+</span>
<a href="#l26.896"></a><span id="l26.896" class="difflineplus">+      for (let indexName in aTableDef.indices) {</span>
<a href="#l26.897"></a><span id="l26.897" class="difflineplus">+        let indexColumns = aTableDef.indices[indexName];</span>
<a href="#l26.898"></a><span id="l26.898" class="difflineplus">+</span>
<a href="#l26.899"></a><span id="l26.899" class="difflineplus">+        try {</span>
<a href="#l26.900"></a><span id="l26.900" class="difflineplus">+          let indexSql = &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; +</span>
<a href="#l26.901"></a><span id="l26.901" class="difflineplus">+            aTableDef._realName + &quot; (&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l26.902"></a><span id="l26.902" class="difflineplus">+          this.asyncConnection.executeSimpleSQL(indexSql);</span>
<a href="#l26.903"></a><span id="l26.903" class="difflineplus">+        }</span>
<a href="#l26.904"></a><span id="l26.904" class="difflineplus">+        catch (ex) {</span>
<a href="#l26.905"></a><span id="l26.905" class="difflineplus">+          this._log.error(&quot;Problem creating index &quot; + indexName + &quot; for &quot; +</span>
<a href="#l26.906"></a><span id="l26.906" class="difflineplus">+            &quot;table &quot; + aTableDef.name + &quot; because &quot; + ex + &quot; at &quot; +</span>
<a href="#l26.907"></a><span id="l26.907" class="difflineplus">+            ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l26.908"></a><span id="l26.908" class="difflineplus">+        }</span>
<a href="#l26.909"></a><span id="l26.909" class="difflineplus">+      }</span>
<a href="#l26.910"></a><span id="l26.910" class="difflineplus">+    }</span>
<a href="#l26.911"></a><span id="l26.911" class="difflineplus">+</span>
<a href="#l26.912"></a><span id="l26.912" class="difflineplus">+    return new GlodaDatabind(aTableDef, this);</span>
<a href="#l26.913"></a><span id="l26.913" class="difflineplus">+  },</span>
<a href="#l26.914"></a><span id="l26.914" class="difflineplus">+</span>
<a href="#l26.915"></a><span id="l26.915" class="difflineplus">+  _migrate: function gloda_ds_migrate(aDBService, aDBFile, aDBConnection,</span>
<a href="#l26.916"></a><span id="l26.916" class="difflineplus">+                                      aCurVersion, aNewVersion) {</span>
<a href="#l26.917"></a><span id="l26.917" class="difflineplus">+    // we purged our way up to version 8, so we can/must purge prior to 8.</span>
<a href="#l26.918"></a><span id="l26.918" class="difflineplus">+    if (aCurVersion &lt; 8) {</span>
<a href="#l26.919"></a><span id="l26.919" class="difflineplus">+      aDBConnection.close();</span>
<a href="#l26.920"></a><span id="l26.920" class="difflineplus">+      aDBFile.remove(false);</span>
<a href="#l26.921"></a><span id="l26.921" class="difflineplus">+      this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l26.922"></a><span id="l26.922" class="difflineplus">+      return this._createDB(aDBService, aDBFile);</span>
<a href="#l26.923"></a><span id="l26.923" class="difflineplus">+    }</span>
<a href="#l26.924"></a><span id="l26.924" class="difflineplus">+    // version 9 just adds the contactAttributes table</span>
<a href="#l26.925"></a><span id="l26.925" class="difflineplus">+    if (aCurVersion &lt; 9) {</span>
<a href="#l26.926"></a><span id="l26.926" class="difflineplus">+      this._createTableSchema(aDBConnection, &quot;contactAttributes&quot;);</span>
<a href="#l26.927"></a><span id="l26.927" class="difflineplus">+    }</span>
<a href="#l26.928"></a><span id="l26.928" class="difflineplus">+    // version 10:</span>
<a href="#l26.929"></a><span id="l26.929" class="difflineplus">+    // we have so many changes here, not to mention semantic changes, that</span>
<a href="#l26.930"></a><span id="l26.930" class="difflineplus">+    //  purging is the right answer.</span>
<a href="#l26.931"></a><span id="l26.931" class="difflineplus">+    // - adds dirtyStatus, name to folderLocations</span>
<a href="#l26.932"></a><span id="l26.932" class="difflineplus">+    // - removes messageAttribFetch index from messageAttributes</span>
<a href="#l26.933"></a><span id="l26.933" class="difflineplus">+    // - removes conversationAttribFetch index from messageAttributes</span>
<a href="#l26.934"></a><span id="l26.934" class="difflineplus">+    // - removes contactAttribFetch index from contactAttributes</span>
<a href="#l26.935"></a><span id="l26.935" class="difflineplus">+    // - adds jsonAttributes column to messages table</span>
<a href="#l26.936"></a><span id="l26.936" class="difflineplus">+    // - adds jsonAttributes column to contacts table</span>
<a href="#l26.937"></a><span id="l26.937" class="difflineplus">+    if (aCurVersion &lt; 10) {</span>
<a href="#l26.938"></a><span id="l26.938" class="difflineplus">+      aDBConnection.close();</span>
<a href="#l26.939"></a><span id="l26.939" class="difflineplus">+      aDBFile.remove(false);</span>
<a href="#l26.940"></a><span id="l26.940" class="difflineplus">+      this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l26.941"></a><span id="l26.941" class="difflineplus">+      return this._createDB(aDBService, aDBFile);</span>
<a href="#l26.942"></a><span id="l26.942" class="difflineplus">+    }</span>
<a href="#l26.943"></a><span id="l26.943" class="difflineplus">+    </span>
<a href="#l26.944"></a><span id="l26.944" class="difflineplus">+    aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l26.945"></a><span id="l26.945" class="difflineplus">+    </span>
<a href="#l26.946"></a><span id="l26.946" class="difflineplus">+    return aDBConnection;</span>
<a href="#l26.947"></a><span id="l26.947" class="difflineplus">+  },</span>
<a href="#l26.948"></a><span id="l26.948" class="difflineplus">+</span>
<a href="#l26.949"></a><span id="l26.949" class="difflineplus">+  _outstandingAsyncStatements: [],</span>
<a href="#l26.950"></a><span id="l26.950" class="difflineplus">+</span>
<a href="#l26.951"></a><span id="l26.951" class="difflineplus">+  _createAsyncStatement: function gloda_ds_createAsyncStatement(aSQLString,</span>
<a href="#l26.952"></a><span id="l26.952" class="difflineplus">+                                                                aWillFinalize) {</span>
<a href="#l26.953"></a><span id="l26.953" class="difflineplus">+    let statement = null;</span>
<a href="#l26.954"></a><span id="l26.954" class="difflineplus">+    try {</span>
<a href="#l26.955"></a><span id="l26.955" class="difflineplus">+      statement = this.asyncConnection.createStatement(aSQLString);</span>
<a href="#l26.956"></a><span id="l26.956" class="difflineplus">+    }</span>
<a href="#l26.957"></a><span id="l26.957" class="difflineplus">+    catch(ex) {</span>
<a href="#l26.958"></a><span id="l26.958" class="difflineplus">+       throw(&quot;error creating async statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l26.959"></a><span id="l26.959" class="difflineplus">+             this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l26.960"></a><span id="l26.960" class="difflineplus">+             this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l26.961"></a><span id="l26.961" class="difflineplus">+    }</span>
<a href="#l26.962"></a><span id="l26.962" class="difflineplus">+</span>
<a href="#l26.963"></a><span id="l26.963" class="difflineplus">+    if (!aWillFinalize)</span>
<a href="#l26.964"></a><span id="l26.964" class="difflineplus">+      this._outstandingAsyncStatements.push(statement);</span>
<a href="#l26.965"></a><span id="l26.965" class="difflineplus">+</span>
<a href="#l26.966"></a><span id="l26.966" class="difflineplus">+    return statement;</span>
<a href="#l26.967"></a><span id="l26.967" class="difflineplus">+  },</span>
<a href="#l26.968"></a><span id="l26.968" class="difflineplus">+</span>
<a href="#l26.969"></a><span id="l26.969" class="difflineplus">+  _cleanupAsyncStatements: function gloda_ds_cleanupAsyncStatements() {</span>
<a href="#l26.970"></a><span id="l26.970" class="difflineplus">+    [stmt.finalize() for each</span>
<a href="#l26.971"></a><span id="l26.971" class="difflineplus">+     ([i, stmt] in Iterator(this._outstandingAsyncStatements))];</span>
<a href="#l26.972"></a><span id="l26.972" class="difflineplus">+  },</span>
<a href="#l26.973"></a><span id="l26.973" class="difflineplus">+</span>
<a href="#l26.974"></a><span id="l26.974" class="difflineplus">+  _outstandingSyncStatements: [],</span>
<a href="#l26.975"></a><span id="l26.975" class="difflineplus">+</span>
<a href="#l26.976"></a><span id="l26.976" class="difflineplus">+  _createSyncStatement: function gloda_ds_createSyncStatement(aSQLString,</span>
<a href="#l26.977"></a><span id="l26.977" class="difflineplus">+                                                              aWillFinalize) {</span>
<a href="#l26.978"></a><span id="l26.978" class="difflineplus">+    let statement = null;</span>
<a href="#l26.979"></a><span id="l26.979" class="difflineplus">+    try {</span>
<a href="#l26.980"></a><span id="l26.980" class="difflineplus">+      statement = this.syncConnection.createStatement(aSQLString);</span>
<a href="#l26.981"></a><span id="l26.981" class="difflineplus">+    }</span>
<a href="#l26.982"></a><span id="l26.982" class="difflineplus">+    catch(ex) {</span>
<a href="#l26.983"></a><span id="l26.983" class="difflineplus">+       throw(&quot;error creating sync statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l26.984"></a><span id="l26.984" class="difflineplus">+             this.syncConnection.lastError + &quot;: &quot; +</span>
<a href="#l26.985"></a><span id="l26.985" class="difflineplus">+             this.syncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l26.986"></a><span id="l26.986" class="difflineplus">+    }</span>
<a href="#l26.987"></a><span id="l26.987" class="difflineplus">+</span>
<a href="#l26.988"></a><span id="l26.988" class="difflineplus">+    if (!aWillFinalize)</span>
<a href="#l26.989"></a><span id="l26.989" class="difflineplus">+      this._outstandingSyncStatements.push(statement);</span>
<a href="#l26.990"></a><span id="l26.990" class="difflineplus">+</span>
<a href="#l26.991"></a><span id="l26.991" class="difflineplus">+    return statement;</span>
<a href="#l26.992"></a><span id="l26.992" class="difflineplus">+  },</span>
<a href="#l26.993"></a><span id="l26.993" class="difflineplus">+</span>
<a href="#l26.994"></a><span id="l26.994" class="difflineplus">+  _cleanupSyncStatements: function gloda_ds_cleanupSyncStatements() {</span>
<a href="#l26.995"></a><span id="l26.995" class="difflineplus">+    [stmt.finalize() for each</span>
<a href="#l26.996"></a><span id="l26.996" class="difflineplus">+     ([i, stmt] in Iterator(this._outstandingSyncStatements))];</span>
<a href="#l26.997"></a><span id="l26.997" class="difflineplus">+  },</span>
<a href="#l26.998"></a><span id="l26.998" class="difflineplus">+</span>
<a href="#l26.999"></a><span id="l26.999" class="difflineplus">+  /**</span>
<a href="#l26.1000"></a><span id="l26.1000" class="difflineplus">+   * Perform a synchronous executeStep on the statement, handling any</span>
<a href="#l26.1001"></a><span id="l26.1001" class="difflineplus">+   *  SQLITE_BUSY fallout that could conceivably happen from a collision on our</span>
<a href="#l26.1002"></a><span id="l26.1002" class="difflineplus">+   *  read with the async writes.</span>
<a href="#l26.1003"></a><span id="l26.1003" class="difflineplus">+   * Basically we keep trying until we succeed or run out of tries.</span>
<a href="#l26.1004"></a><span id="l26.1004" class="difflineplus">+   * We believe this to be a reasonable course of action because we don't</span>
<a href="#l26.1005"></a><span id="l26.1005" class="difflineplus">+   *  expect this to happen much.</span>
<a href="#l26.1006"></a><span id="l26.1006" class="difflineplus">+   */</span>
<a href="#l26.1007"></a><span id="l26.1007" class="difflineplus">+  _syncStep: function gloda_ds_syncStep(aStatement) {</span>
<a href="#l26.1008"></a><span id="l26.1008" class="difflineplus">+    let tries = 0;</span>
<a href="#l26.1009"></a><span id="l26.1009" class="difflineplus">+    while (tries &lt; 32000) {</span>
<a href="#l26.1010"></a><span id="l26.1010" class="difflineplus">+      try {</span>
<a href="#l26.1011"></a><span id="l26.1011" class="difflineplus">+        return aStatement.executeStep();</span>
<a href="#l26.1012"></a><span id="l26.1012" class="difflineplus">+      }</span>
<a href="#l26.1013"></a><span id="l26.1013" class="difflineplus">+      // SQLITE_BUSY becomes NS_ERROR_FAILURE</span>
<a href="#l26.1014"></a><span id="l26.1014" class="difflineplus">+      catch (e if e.result == 0x80004005) {</span>
<a href="#l26.1015"></a><span id="l26.1015" class="difflineplus">+        tries++;</span>
<a href="#l26.1016"></a><span id="l26.1016" class="difflineplus">+        // we really need to delay here, somehow.  unfortunately, we can't</span>
<a href="#l26.1017"></a><span id="l26.1017" class="difflineplus">+        //  allow event processing to happen, and most of the things we could</span>
<a href="#l26.1018"></a><span id="l26.1018" class="difflineplus">+        //  do to delay ourselves result in event processing happening.  (Use</span>
<a href="#l26.1019"></a><span id="l26.1019" class="difflineplus">+        //  of a timer, a synchronous dispatch, etc.)</span>
<a href="#l26.1020"></a><span id="l26.1020" class="difflineplus">+        // in theory, nsIThreadEventFilter could allow us to stop other events</span>
<a href="#l26.1021"></a><span id="l26.1021" class="difflineplus">+        //  that aren't our timer from happening, but it seems slightly</span>
<a href="#l26.1022"></a><span id="l26.1022" class="difflineplus">+        //  dangerous and 'notxpcom' suggests it ain't happening anyways...</span>
<a href="#l26.1023"></a><span id="l26.1023" class="difflineplus">+        // so, let's just be dumb and hope that the underlying file I/O going</span>
<a href="#l26.1024"></a><span id="l26.1024" class="difflineplus">+        //  on makes us more likely to yield to the other thread so it can</span>
<a href="#l26.1025"></a><span id="l26.1025" class="difflineplus">+        //  finish what it is doing...</span>
<a href="#l26.1026"></a><span id="l26.1026" class="difflineplus">+      }</span>
<a href="#l26.1027"></a><span id="l26.1027" class="difflineplus">+    }</span>
<a href="#l26.1028"></a><span id="l26.1028" class="difflineplus">+    this._log.error(&quot;Synchronous step gave up after &quot; + tries + &quot; tries.&quot;);</span>
<a href="#l26.1029"></a><span id="l26.1029" class="difflineplus">+  },</span>
<a href="#l26.1030"></a><span id="l26.1030" class="difflineplus">+</span>
<a href="#l26.1031"></a><span id="l26.1031" class="difflineplus">+  /**</span>
<a href="#l26.1032"></a><span id="l26.1032" class="difflineplus">+   * Helper to bind based on the actual type of the javascript value.  Note</span>
<a href="#l26.1033"></a><span id="l26.1033" class="difflineplus">+   *  that we always use int64 because under the hood sqlite just promotes the</span>
<a href="#l26.1034"></a><span id="l26.1034" class="difflineplus">+   *  normal 'int' call to 'int64' anyways.</span>
<a href="#l26.1035"></a><span id="l26.1035" class="difflineplus">+   */</span>
<a href="#l26.1036"></a><span id="l26.1036" class="difflineplus">+  _bindVariant: function gloda_ds_bindBlob(aStatement, aIndex, aVariant) {</span>
<a href="#l26.1037"></a><span id="l26.1037" class="difflineplus">+    if (aVariant == null) // catch both null and undefined</span>
<a href="#l26.1038"></a><span id="l26.1038" class="difflineplus">+      aStatement.bindNullParameter(aIndex);</span>
<a href="#l26.1039"></a><span id="l26.1039" class="difflineplus">+    else if (typeof aVariant == &quot;string&quot;)</span>
<a href="#l26.1040"></a><span id="l26.1040" class="difflineplus">+      aStatement.bindStringParameter(aIndex, aVariant);</span>
<a href="#l26.1041"></a><span id="l26.1041" class="difflineplus">+    else if (typeof aVariant == &quot;number&quot;) {</span>
<a href="#l26.1042"></a><span id="l26.1042" class="difflineplus">+      // we differentiate for storage representation reasons only.</span>
<a href="#l26.1043"></a><span id="l26.1043" class="difflineplus">+      if (Math.floor(aVariant) === aVariant)</span>
<a href="#l26.1044"></a><span id="l26.1044" class="difflineplus">+        aStatement.bindInt64Parameter(aIndex, aVariant);</span>
<a href="#l26.1045"></a><span id="l26.1045" class="difflineplus">+      else</span>
<a href="#l26.1046"></a><span id="l26.1046" class="difflineplus">+        aStatement.bindDoubleParameter(aIndex, aVariant);</span>
<a href="#l26.1047"></a><span id="l26.1047" class="difflineplus">+    }</span>
<a href="#l26.1048"></a><span id="l26.1048" class="difflineplus">+    else</span>
<a href="#l26.1049"></a><span id="l26.1049" class="difflineplus">+      throw(&quot;Attempt to bind variant with unsupported type: &quot; +</span>
<a href="#l26.1050"></a><span id="l26.1050" class="difflineplus">+            (typeof aVariant));</span>
<a href="#l26.1051"></a><span id="l26.1051" class="difflineplus">+  },</span>
<a href="#l26.1052"></a><span id="l26.1052" class="difflineplus">+</span>
<a href="#l26.1053"></a><span id="l26.1053" class="difflineplus">+  _getVariant: function gloda_ds_getBlob(aRow, aIndex) {</span>
<a href="#l26.1054"></a><span id="l26.1054" class="difflineplus">+    let typeOfIndex = aRow.getTypeOfIndex(aIndex);</span>
<a href="#l26.1055"></a><span id="l26.1055" class="difflineplus">+    if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.1056"></a><span id="l26.1056" class="difflineplus">+      return null;</span>
<a href="#l26.1057"></a><span id="l26.1057" class="difflineplus">+    // XPConnect would just end up going through an intermediary double stage</span>
<a href="#l26.1058"></a><span id="l26.1058" class="difflineplus">+    //  for the int64 case anyways...</span>
<a href="#l26.1059"></a><span id="l26.1059" class="difflineplus">+    else if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_INTEGER ||</span>
<a href="#l26.1060"></a><span id="l26.1060" class="difflineplus">+             typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_DOUBLE)</span>
<a href="#l26.1061"></a><span id="l26.1061" class="difflineplus">+      return aRow.getDouble(aIndex);</span>
<a href="#l26.1062"></a><span id="l26.1062" class="difflineplus">+    else // typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_TEXT</span>
<a href="#l26.1063"></a><span id="l26.1063" class="difflineplus">+      return aRow.getString(aIndex);</span>
<a href="#l26.1064"></a><span id="l26.1064" class="difflineplus">+  },</span>
<a href="#l26.1065"></a><span id="l26.1065" class="difflineplus">+</span>
<a href="#l26.1066"></a><span id="l26.1066" class="difflineplus">+  /** Simple nested transaction support as a performance optimization. */</span>
<a href="#l26.1067"></a><span id="l26.1067" class="difflineplus">+  _transactionDepth: 0,</span>
<a href="#l26.1068"></a><span id="l26.1068" class="difflineplus">+  _transactionGood: false,</span>
<a href="#l26.1069"></a><span id="l26.1069" class="difflineplus">+</span>
<a href="#l26.1070"></a><span id="l26.1070" class="difflineplus">+  get _beginTransactionStatement() {</span>
<a href="#l26.1071"></a><span id="l26.1071" class="difflineplus">+    let statement = this._createAsyncStatement(&quot;BEGIN TRANSACTION&quot;);</span>
<a href="#l26.1072"></a><span id="l26.1072" class="difflineplus">+    this.__defineGetter__(&quot;_beginTransactionStatement&quot;, function() statement);</span>
<a href="#l26.1073"></a><span id="l26.1073" class="difflineplus">+    return this._beginTransactionStatement;</span>
<a href="#l26.1074"></a><span id="l26.1074" class="difflineplus">+  },</span>
<a href="#l26.1075"></a><span id="l26.1075" class="difflineplus">+</span>
<a href="#l26.1076"></a><span id="l26.1076" class="difflineplus">+  get _commitTransactionStatement() {</span>
<a href="#l26.1077"></a><span id="l26.1077" class="difflineplus">+    let statement = this._createAsyncStatement(&quot;COMMIT&quot;);</span>
<a href="#l26.1078"></a><span id="l26.1078" class="difflineplus">+    this.__defineGetter__(&quot;_commitTransactionStatement&quot;, function() statement);</span>
<a href="#l26.1079"></a><span id="l26.1079" class="difflineplus">+    return this._commitTransactionStatement;</span>
<a href="#l26.1080"></a><span id="l26.1080" class="difflineplus">+  },</span>
<a href="#l26.1081"></a><span id="l26.1081" class="difflineplus">+</span>
<a href="#l26.1082"></a><span id="l26.1082" class="difflineplus">+  get _rollbackTransactionStatement() {</span>
<a href="#l26.1083"></a><span id="l26.1083" class="difflineplus">+    let statement = this._createAsyncStatement(&quot;ROLLBACK&quot;);</span>
<a href="#l26.1084"></a><span id="l26.1084" class="difflineplus">+    this.__defineGetter__(&quot;_rollbackTransactionStatement&quot;, function() statement);</span>
<a href="#l26.1085"></a><span id="l26.1085" class="difflineplus">+    return this._rollbackTransactionStatement;</span>
<a href="#l26.1086"></a><span id="l26.1086" class="difflineplus">+  },</span>
<a href="#l26.1087"></a><span id="l26.1087" class="difflineplus">+</span>
<a href="#l26.1088"></a><span id="l26.1088" class="difflineplus">+  _pendingPostCommitCallbacks: null,</span>
<a href="#l26.1089"></a><span id="l26.1089" class="difflineplus">+  /**</span>
<a href="#l26.1090"></a><span id="l26.1090" class="difflineplus">+   * Register a callback to be invoked when the current transaction's commit</span>
<a href="#l26.1091"></a><span id="l26.1091" class="difflineplus">+   *  completes.</span>
<a href="#l26.1092"></a><span id="l26.1092" class="difflineplus">+   */</span>
<a href="#l26.1093"></a><span id="l26.1093" class="difflineplus">+  runPostCommit: function gloda_ds_runPostCommit(aCallback) {</span>
<a href="#l26.1094"></a><span id="l26.1094" class="difflineplus">+    this._pendingPostCommitCallbacks.push(aCallback);</span>
<a href="#l26.1095"></a><span id="l26.1095" class="difflineplus">+  },</span>
<a href="#l26.1096"></a><span id="l26.1096" class="difflineplus">+</span>
<a href="#l26.1097"></a><span id="l26.1097" class="difflineplus">+  /**</span>
<a href="#l26.1098"></a><span id="l26.1098" class="difflineplus">+   * Begin a potentially nested transaction; only the outermost transaction gets</span>
<a href="#l26.1099"></a><span id="l26.1099" class="difflineplus">+   *  to be an actual transaction, and the failure of any nested transaction</span>
<a href="#l26.1100"></a><span id="l26.1100" class="difflineplus">+   *  results in a rollback of the entire outer transaction.  If you really</span>
<a href="#l26.1101"></a><span id="l26.1101" class="difflineplus">+   *  need an atomic transaction</span>
<a href="#l26.1102"></a><span id="l26.1102" class="difflineplus">+   */</span>
<a href="#l26.1103"></a><span id="l26.1103" class="difflineplus">+  _beginTransaction: function gloda_ds_beginTransaction() {</span>
<a href="#l26.1104"></a><span id="l26.1104" class="difflineplus">+    if (this._transactionDepth == 0) {</span>
<a href="#l26.1105"></a><span id="l26.1105" class="difflineplus">+      this._pendingPostCommitCallbacks = [];</span>
<a href="#l26.1106"></a><span id="l26.1106" class="difflineplus">+      this._beginTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l26.1107"></a><span id="l26.1107" class="difflineplus">+      this._transactionGood = true;</span>
<a href="#l26.1108"></a><span id="l26.1108" class="difflineplus">+    }</span>
<a href="#l26.1109"></a><span id="l26.1109" class="difflineplus">+    this._transactionDepth++;</span>
<a href="#l26.1110"></a><span id="l26.1110" class="difflineplus">+  },</span>
<a href="#l26.1111"></a><span id="l26.1111" class="difflineplus">+  /**</span>
<a href="#l26.1112"></a><span id="l26.1112" class="difflineplus">+   * Commit a potentially nested transaction; if we are the outer-most</span>
<a href="#l26.1113"></a><span id="l26.1113" class="difflineplus">+   *  transaction and no sub-transaction issues a rollback</span>
<a href="#l26.1114"></a><span id="l26.1114" class="difflineplus">+   *  (via _rollbackTransaction) then we commit, otherwise we rollback.</span>
<a href="#l26.1115"></a><span id="l26.1115" class="difflineplus">+   */</span>
<a href="#l26.1116"></a><span id="l26.1116" class="difflineplus">+  _commitTransaction: function gloda_ds_commitTransaction() {</span>
<a href="#l26.1117"></a><span id="l26.1117" class="difflineplus">+    this._transactionDepth--;</span>
<a href="#l26.1118"></a><span id="l26.1118" class="difflineplus">+    if (this._transactionDepth == 0) {</span>
<a href="#l26.1119"></a><span id="l26.1119" class="difflineplus">+      try {</span>
<a href="#l26.1120"></a><span id="l26.1120" class="difflineplus">+        if (this._transactionGood)</span>
<a href="#l26.1121"></a><span id="l26.1121" class="difflineplus">+          this._commitTransactionStatement.executeAsync(</span>
<a href="#l26.1122"></a><span id="l26.1122" class="difflineplus">+            new PostCommitHandler(this._pendingPostCommitCallbacks));</span>
<a href="#l26.1123"></a><span id="l26.1123" class="difflineplus">+        else</span>
<a href="#l26.1124"></a><span id="l26.1124" class="difflineplus">+          this._rollbackTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l26.1125"></a><span id="l26.1125" class="difflineplus">+      }</span>
<a href="#l26.1126"></a><span id="l26.1126" class="difflineplus">+      catch (ex) {</span>
<a href="#l26.1127"></a><span id="l26.1127" class="difflineplus">+        this._log.error(&quot;Commit problem: &quot; + ex);</span>
<a href="#l26.1128"></a><span id="l26.1128" class="difflineplus">+      }</span>
<a href="#l26.1129"></a><span id="l26.1129" class="difflineplus">+      this._pendingPostCommitCallbacks = [];</span>
<a href="#l26.1130"></a><span id="l26.1130" class="difflineplus">+    }</span>
<a href="#l26.1131"></a><span id="l26.1131" class="difflineplus">+  },</span>
<a href="#l26.1132"></a><span id="l26.1132" class="difflineplus">+  /**</span>
<a href="#l26.1133"></a><span id="l26.1133" class="difflineplus">+   * Abort the commit of the potentially nested transaction.  If we are not the</span>
<a href="#l26.1134"></a><span id="l26.1134" class="difflineplus">+   *  outermost transaction, we set a flag that tells the outermost transaction</span>
<a href="#l26.1135"></a><span id="l26.1135" class="difflineplus">+   *  that it must roll back.</span>
<a href="#l26.1136"></a><span id="l26.1136" class="difflineplus">+   */</span>
<a href="#l26.1137"></a><span id="l26.1137" class="difflineplus">+  _rollbackTransaction: function gloda_ds_rollbackTransaction() {</span>
<a href="#l26.1138"></a><span id="l26.1138" class="difflineplus">+    this._transactionDepth--;</span>
<a href="#l26.1139"></a><span id="l26.1139" class="difflineplus">+    this._transactionGood = false;</span>
<a href="#l26.1140"></a><span id="l26.1140" class="difflineplus">+    if (this._transactionDepth == 0) {</span>
<a href="#l26.1141"></a><span id="l26.1141" class="difflineplus">+      try {</span>
<a href="#l26.1142"></a><span id="l26.1142" class="difflineplus">+        this._rollbackTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l26.1143"></a><span id="l26.1143" class="difflineplus">+      }</span>
<a href="#l26.1144"></a><span id="l26.1144" class="difflineplus">+      catch (ex) {</span>
<a href="#l26.1145"></a><span id="l26.1145" class="difflineplus">+        this._log.error(&quot;Rollback problem: &quot; + ex);</span>
<a href="#l26.1146"></a><span id="l26.1146" class="difflineplus">+      }</span>
<a href="#l26.1147"></a><span id="l26.1147" class="difflineplus">+    }</span>
<a href="#l26.1148"></a><span id="l26.1148" class="difflineplus">+  },</span>
<a href="#l26.1149"></a><span id="l26.1149" class="difflineplus">+</span>
<a href="#l26.1150"></a><span id="l26.1150" class="difflineplus">+  _pendingAsyncStatements: 0,</span>
<a href="#l26.1151"></a><span id="l26.1151" class="difflineplus">+  /**</span>
<a href="#l26.1152"></a><span id="l26.1152" class="difflineplus">+   * The function to call, if any, when we hit 0 pending async statements.</span>
<a href="#l26.1153"></a><span id="l26.1153" class="difflineplus">+   */</span>
<a href="#l26.1154"></a><span id="l26.1154" class="difflineplus">+  _pendingAsyncCompletedListener: null,</span>
<a href="#l26.1155"></a><span id="l26.1155" class="difflineplus">+  _asyncCompleted: function () {</span>
<a href="#l26.1156"></a><span id="l26.1156" class="difflineplus">+    if (--this._pendingAsyncStatements == 0) {</span>
<a href="#l26.1157"></a><span id="l26.1157" class="difflineplus">+      if (this._pendingAsyncCompletedListener !== null) {</span>
<a href="#l26.1158"></a><span id="l26.1158" class="difflineplus">+        this._pendingAsyncCompletedListener();</span>
<a href="#l26.1159"></a><span id="l26.1159" class="difflineplus">+        this._pendingAsyncCompletedListener = null;</span>
<a href="#l26.1160"></a><span id="l26.1160" class="difflineplus">+      }</span>
<a href="#l26.1161"></a><span id="l26.1161" class="difflineplus">+    }</span>
<a href="#l26.1162"></a><span id="l26.1162" class="difflineplus">+  },</span>
<a href="#l26.1163"></a><span id="l26.1163" class="difflineplus">+  _asyncTrackerListener: {</span>
<a href="#l26.1164"></a><span id="l26.1164" class="difflineplus">+    handleResult: function () {},</span>
<a href="#l26.1165"></a><span id="l26.1165" class="difflineplus">+    handleError: function() {},</span>
<a href="#l26.1166"></a><span id="l26.1166" class="difflineplus">+    handleCompletion: function () {</span>
<a href="#l26.1167"></a><span id="l26.1167" class="difflineplus">+      // the helper method exists because the other classes need to call it too</span>
<a href="#l26.1168"></a><span id="l26.1168" class="difflineplus">+      GlodaDatastore._asyncCompleted();</span>
<a href="#l26.1169"></a><span id="l26.1169" class="difflineplus">+    }</span>
<a href="#l26.1170"></a><span id="l26.1170" class="difflineplus">+  },</span>
<a href="#l26.1171"></a><span id="l26.1171" class="difflineplus">+  /**</span>
<a href="#l26.1172"></a><span id="l26.1172" class="difflineplus">+   * Increments _pendingAsyncStatements and returns a listener that will</span>
<a href="#l26.1173"></a><span id="l26.1173" class="difflineplus">+   *  decrement the value when the statement completes.</span>
<a href="#l26.1174"></a><span id="l26.1174" class="difflineplus">+   */</span>
<a href="#l26.1175"></a><span id="l26.1175" class="difflineplus">+  trackAsync: function() {</span>
<a href="#l26.1176"></a><span id="l26.1176" class="difflineplus">+    this._pendingAsyncStatements++;</span>
<a href="#l26.1177"></a><span id="l26.1177" class="difflineplus">+    return this._asyncTrackerListener;</span>
<a href="#l26.1178"></a><span id="l26.1178" class="difflineplus">+  },</span>
<a href="#l26.1179"></a><span id="l26.1179" class="difflineplus">+</span>
<a href="#l26.1180"></a><span id="l26.1180" class="difflineplus">+  /* ********** Attribute Definitions ********** */</span>
<a href="#l26.1181"></a><span id="l26.1181" class="difflineplus">+  /** Maps (attribute def) compound names to the GlodaAttributeDBDef objects. */</span>
<a href="#l26.1182"></a><span id="l26.1182" class="difflineplus">+  _attributeDBDefs: {},</span>
<a href="#l26.1183"></a><span id="l26.1183" class="difflineplus">+  /** Map attribute ID to the definition and parameter value that produce it. */</span>
<a href="#l26.1184"></a><span id="l26.1184" class="difflineplus">+  _attributeIDToDBDefAndParam: {},</span>
<a href="#l26.1185"></a><span id="l26.1185" class="difflineplus">+  /**</span>
<a href="#l26.1186"></a><span id="l26.1186" class="difflineplus">+   * We maintain the attributeDefinitions next id counter mainly because we can.</span>
<a href="#l26.1187"></a><span id="l26.1187" class="difflineplus">+   *  Since we mediate the access, there's no real risk to doing so, and it</span>
<a href="#l26.1188"></a><span id="l26.1188" class="difflineplus">+   *  allows us to keep the writes on the async connection without having to</span>
<a href="#l26.1189"></a><span id="l26.1189" class="difflineplus">+   *  wait for a completion notification.</span>
<a href="#l26.1190"></a><span id="l26.1190" class="difflineplus">+   */</span>
<a href="#l26.1191"></a><span id="l26.1191" class="difflineplus">+  _nextAttributeId: 1,</span>
<a href="#l26.1192"></a><span id="l26.1192" class="difflineplus">+</span>
<a href="#l26.1193"></a><span id="l26.1193" class="difflineplus">+  _populateAttributeDefManagedId: function () {</span>
<a href="#l26.1194"></a><span id="l26.1194" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l26.1195"></a><span id="l26.1195" class="difflineplus">+      &quot;SELECT MAX(id) FROM attributeDefinitions&quot;, true);</span>
<a href="#l26.1196"></a><span id="l26.1196" class="difflineplus">+    if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l26.1197"></a><span id="l26.1197" class="difflineplus">+      this._nextAttributeId = stmt.getInt64(0) + 1;</span>
<a href="#l26.1198"></a><span id="l26.1198" class="difflineplus">+    }</span>
<a href="#l26.1199"></a><span id="l26.1199" class="difflineplus">+    stmt.finalize();</span>
<a href="#l26.1200"></a><span id="l26.1200" class="difflineplus">+  },</span>
<a href="#l26.1201"></a><span id="l26.1201" class="difflineplus">+</span>
<a href="#l26.1202"></a><span id="l26.1202" class="difflineplus">+  get _insertAttributeDefStatement() {</span>
<a href="#l26.1203"></a><span id="l26.1203" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1204"></a><span id="l26.1204" class="difflineplus">+      &quot;INSERT INTO attributeDefinitions (id, attributeType, extensionName, \</span>
<a href="#l26.1205"></a><span id="l26.1205" class="difflineplus">+                                  name, parameter) \</span>
<a href="#l26.1206"></a><span id="l26.1206" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5)&quot;);</span>
<a href="#l26.1207"></a><span id="l26.1207" class="difflineplus">+    this.__defineGetter__(&quot;_insertAttributeDefStatement&quot;, function() statement);</span>
<a href="#l26.1208"></a><span id="l26.1208" class="difflineplus">+    return this._insertAttributeDefStatement;</span>
<a href="#l26.1209"></a><span id="l26.1209" class="difflineplus">+  },</span>
<a href="#l26.1210"></a><span id="l26.1210" class="difflineplus">+</span>
<a href="#l26.1211"></a><span id="l26.1211" class="difflineplus">+  /**</span>
<a href="#l26.1212"></a><span id="l26.1212" class="difflineplus">+   * Create an attribute definition and return the row ID.  Special/atypical</span>
<a href="#l26.1213"></a><span id="l26.1213" class="difflineplus">+   *  in that it doesn't directly return a GlodaAttributeDBDef; we leave that up</span>
<a href="#l26.1214"></a><span id="l26.1214" class="difflineplus">+   *  to the caller since they know much more than actually needs to go in the</span>
<a href="#l26.1215"></a><span id="l26.1215" class="difflineplus">+   *  database.</span>
<a href="#l26.1216"></a><span id="l26.1216" class="difflineplus">+   *</span>
<a href="#l26.1217"></a><span id="l26.1217" class="difflineplus">+   * @return The attribute id allocated to this attribute.</span>
<a href="#l26.1218"></a><span id="l26.1218" class="difflineplus">+   */</span>
<a href="#l26.1219"></a><span id="l26.1219" class="difflineplus">+  _createAttributeDef: function gloda_ds_createAttributeDef(aAttrType,</span>
<a href="#l26.1220"></a><span id="l26.1220" class="difflineplus">+                                    aExtensionName, aAttrName, aParameter) {</span>
<a href="#l26.1221"></a><span id="l26.1221" class="difflineplus">+    let attributeId = this._nextAttributeId++;</span>
<a href="#l26.1222"></a><span id="l26.1222" class="difflineplus">+</span>
<a href="#l26.1223"></a><span id="l26.1223" class="difflineplus">+    let iads = this._insertAttributeDefStatement;</span>
<a href="#l26.1224"></a><span id="l26.1224" class="difflineplus">+    iads.bindInt64Parameter(0, attributeId);</span>
<a href="#l26.1225"></a><span id="l26.1225" class="difflineplus">+    iads.bindInt64Parameter(1, aAttrType);</span>
<a href="#l26.1226"></a><span id="l26.1226" class="difflineplus">+    iads.bindStringParameter(2, aExtensionName);</span>
<a href="#l26.1227"></a><span id="l26.1227" class="difflineplus">+    iads.bindStringParameter(3, aAttrName);</span>
<a href="#l26.1228"></a><span id="l26.1228" class="difflineplus">+    this._bindVariant(iads, 4, aParameter);</span>
<a href="#l26.1229"></a><span id="l26.1229" class="difflineplus">+</span>
<a href="#l26.1230"></a><span id="l26.1230" class="difflineplus">+    iads.executeAsync(this.trackAsync());</span>
<a href="#l26.1231"></a><span id="l26.1231" class="difflineplus">+</span>
<a href="#l26.1232"></a><span id="l26.1232" class="difflineplus">+    return attributeId;</span>
<a href="#l26.1233"></a><span id="l26.1233" class="difflineplus">+  },</span>
<a href="#l26.1234"></a><span id="l26.1234" class="difflineplus">+</span>
<a href="#l26.1235"></a><span id="l26.1235" class="difflineplus">+  /**</span>
<a href="#l26.1236"></a><span id="l26.1236" class="difflineplus">+   * Sync-ly look-up all the attribute definitions, populating our authoritative</span>
<a href="#l26.1237"></a><span id="l26.1237" class="difflineplus">+   *  _attributeDBDefss and _attributeIDToDBDefAndParam maps.  (In other words,</span>
<a href="#l26.1238"></a><span id="l26.1238" class="difflineplus">+   *  once this method is called, those maps should always be in sync with the</span>
<a href="#l26.1239"></a><span id="l26.1239" class="difflineplus">+   *  underlying database.)</span>
<a href="#l26.1240"></a><span id="l26.1240" class="difflineplus">+   */</span>
<a href="#l26.1241"></a><span id="l26.1241" class="difflineplus">+  getAllAttributes: function gloda_ds_getAllAttributes() {</span>
<a href="#l26.1242"></a><span id="l26.1242" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l26.1243"></a><span id="l26.1243" class="difflineplus">+      &quot;SELECT id, attributeType, extensionName, name, parameter \</span>
<a href="#l26.1244"></a><span id="l26.1244" class="difflineplus">+         FROM attributeDefinitions&quot;, true);</span>
<a href="#l26.1245"></a><span id="l26.1245" class="difflineplus">+</span>
<a href="#l26.1246"></a><span id="l26.1246" class="difflineplus">+    // map compound name to the attribute</span>
<a href="#l26.1247"></a><span id="l26.1247" class="difflineplus">+    let attribs = {};</span>
<a href="#l26.1248"></a><span id="l26.1248" class="difflineplus">+    // map the attribute id to [attribute, parameter] where parameter is null</span>
<a href="#l26.1249"></a><span id="l26.1249" class="difflineplus">+    //  in cases where parameter is unused.</span>
<a href="#l26.1250"></a><span id="l26.1250" class="difflineplus">+    let idToAttribAndParam = {}</span>
<a href="#l26.1251"></a><span id="l26.1251" class="difflineplus">+</span>
<a href="#l26.1252"></a><span id="l26.1252" class="difflineplus">+    this._log.info(&quot;loading all attribute defs&quot;);</span>
<a href="#l26.1253"></a><span id="l26.1253" class="difflineplus">+</span>
<a href="#l26.1254"></a><span id="l26.1254" class="difflineplus">+    while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l26.1255"></a><span id="l26.1255" class="difflineplus">+      let rowId = stmt.getInt64(0);</span>
<a href="#l26.1256"></a><span id="l26.1256" class="difflineplus">+      let rowAttributeType = stmt.getInt64(1);</span>
<a href="#l26.1257"></a><span id="l26.1257" class="difflineplus">+      let rowExtensionName = stmt.getString(2);</span>
<a href="#l26.1258"></a><span id="l26.1258" class="difflineplus">+      let rowName = stmt.getString(3);</span>
<a href="#l26.1259"></a><span id="l26.1259" class="difflineplus">+      let rowParameter = this._getVariant(stmt, 4);</span>
<a href="#l26.1260"></a><span id="l26.1260" class="difflineplus">+</span>
<a href="#l26.1261"></a><span id="l26.1261" class="difflineplus">+      let compoundName = rowExtensionName + &quot;:&quot; + rowName;</span>
<a href="#l26.1262"></a><span id="l26.1262" class="difflineplus">+</span>
<a href="#l26.1263"></a><span id="l26.1263" class="difflineplus">+      let attrib;</span>
<a href="#l26.1264"></a><span id="l26.1264" class="difflineplus">+      if (compoundName in attribs) {</span>
<a href="#l26.1265"></a><span id="l26.1265" class="difflineplus">+        attrib = attribs[compoundName];</span>
<a href="#l26.1266"></a><span id="l26.1266" class="difflineplus">+      } else {</span>
<a href="#l26.1267"></a><span id="l26.1267" class="difflineplus">+        attrib = new GlodaAttributeDBDef(this, /* aID */ null,</span>
<a href="#l26.1268"></a><span id="l26.1268" class="difflineplus">+          compoundName, rowAttributeType, rowExtensionName, rowName);</span>
<a href="#l26.1269"></a><span id="l26.1269" class="difflineplus">+        attribs[compoundName] = attrib;</span>
<a href="#l26.1270"></a><span id="l26.1270" class="difflineplus">+      }</span>
<a href="#l26.1271"></a><span id="l26.1271" class="difflineplus">+      // if the parameter is null, the id goes on the attribute def, otherwise</span>
<a href="#l26.1272"></a><span id="l26.1272" class="difflineplus">+      //  it is a parameter binding and goes in the binding map.</span>
<a href="#l26.1273"></a><span id="l26.1273" class="difflineplus">+      if (rowParameter == null) {</span>
<a href="#l26.1274"></a><span id="l26.1274" class="difflineplus">+        this._log.debug(compoundName + &quot; primary: &quot; + rowId);</span>
<a href="#l26.1275"></a><span id="l26.1275" class="difflineplus">+        attrib._id = rowId;</span>
<a href="#l26.1276"></a><span id="l26.1276" class="difflineplus">+        idToAttribAndParam[rowId] = [attrib, null];</span>
<a href="#l26.1277"></a><span id="l26.1277" class="difflineplus">+      } else {</span>
<a href="#l26.1278"></a><span id="l26.1278" class="difflineplus">+        this._log.debug(compoundName + &quot; binding: &quot; + rowParameter +</span>
<a href="#l26.1279"></a><span id="l26.1279" class="difflineplus">+            &quot; = &quot; + rowId);</span>
<a href="#l26.1280"></a><span id="l26.1280" class="difflineplus">+        attrib._parameterBindings[rowParameter] = rowId;</span>
<a href="#l26.1281"></a><span id="l26.1281" class="difflineplus">+        idToAttribAndParam[rowId] = [attrib, rowParameter];</span>
<a href="#l26.1282"></a><span id="l26.1282" class="difflineplus">+      }</span>
<a href="#l26.1283"></a><span id="l26.1283" class="difflineplus">+    }</span>
<a href="#l26.1284"></a><span id="l26.1284" class="difflineplus">+    stmt.finalize();</span>
<a href="#l26.1285"></a><span id="l26.1285" class="difflineplus">+</span>
<a href="#l26.1286"></a><span id="l26.1286" class="difflineplus">+    this._log.info(&quot;done loading all attribute defs&quot;);</span>
<a href="#l26.1287"></a><span id="l26.1287" class="difflineplus">+</span>
<a href="#l26.1288"></a><span id="l26.1288" class="difflineplus">+    this._attributeDBDefs = attribs;</span>
<a href="#l26.1289"></a><span id="l26.1289" class="difflineplus">+    this._attributeIDToDBDefAndParam = idToAttribAndParam;</span>
<a href="#l26.1290"></a><span id="l26.1290" class="difflineplus">+  },</span>
<a href="#l26.1291"></a><span id="l26.1291" class="difflineplus">+</span>
<a href="#l26.1292"></a><span id="l26.1292" class="difflineplus">+  /**</span>
<a href="#l26.1293"></a><span id="l26.1293" class="difflineplus">+   * Helper method for GlodaAttributeDBDef to tell us when their bindParameter</span>
<a href="#l26.1294"></a><span id="l26.1294" class="difflineplus">+   *  method is called and they have created a new binding (using</span>
<a href="#l26.1295"></a><span id="l26.1295" class="difflineplus">+   *  GlodaDatastore._createAttributeDef).  In theory, that method could take</span>
<a href="#l26.1296"></a><span id="l26.1296" class="difflineplus">+   *  an additional argument and obviate the need for this method.</span>
<a href="#l26.1297"></a><span id="l26.1297" class="difflineplus">+   */</span>
<a href="#l26.1298"></a><span id="l26.1298" class="difflineplus">+  reportBinding: function gloda_ds_reportBinding(aID, aAttrDef, aParamValue) {</span>
<a href="#l26.1299"></a><span id="l26.1299" class="difflineplus">+    this._attributeIDToDBDefAndParam[aID] = [aAttrDef, aParamValue];</span>
<a href="#l26.1300"></a><span id="l26.1300" class="difflineplus">+  },</span>
<a href="#l26.1301"></a><span id="l26.1301" class="difflineplus">+</span>
<a href="#l26.1302"></a><span id="l26.1302" class="difflineplus">+  /* ********** Folders ********** */</span>
<a href="#l26.1303"></a><span id="l26.1303" class="difflineplus">+  /** next folder (row) id to issue, populated by _getAllFolderMappings. */</span>
<a href="#l26.1304"></a><span id="l26.1304" class="difflineplus">+  _nextFolderId: 1,</span>
<a href="#l26.1305"></a><span id="l26.1305" class="difflineplus">+</span>
<a href="#l26.1306"></a><span id="l26.1306" class="difflineplus">+  get _insertFolderLocationStatement() {</span>
<a href="#l26.1307"></a><span id="l26.1307" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1308"></a><span id="l26.1308" class="difflineplus">+      &quot;INSERT INTO folderLocations (id, folderURI, dirtyStatus, name) VALUES \</span>
<a href="#l26.1309"></a><span id="l26.1309" class="difflineplus">+        (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l26.1310"></a><span id="l26.1310" class="difflineplus">+    this.__defineGetter__(&quot;_insertFolderLocationStatement&quot;,</span>
<a href="#l26.1311"></a><span id="l26.1311" class="difflineplus">+      function() statement);</span>
<a href="#l26.1312"></a><span id="l26.1312" class="difflineplus">+    return this._insertFolderLocationStatement;</span>
<a href="#l26.1313"></a><span id="l26.1313" class="difflineplus">+  },</span>
<a href="#l26.1314"></a><span id="l26.1314" class="difflineplus">+</span>
<a href="#l26.1315"></a><span id="l26.1315" class="difflineplus">+  /**</span>
<a href="#l26.1316"></a><span id="l26.1316" class="difflineplus">+   * Authoritative map from folder URI to folder ID.  (Authoritative in the</span>
<a href="#l26.1317"></a><span id="l26.1317" class="difflineplus">+   *  sense that this map exactly represents the state of the underlying</span>
<a href="#l26.1318"></a><span id="l26.1318" class="difflineplus">+   *  database.  If it does not, it's a bug in updating the database.)</span>
<a href="#l26.1319"></a><span id="l26.1319" class="difflineplus">+   */</span>
<a href="#l26.1320"></a><span id="l26.1320" class="difflineplus">+  _folderByURI: {},</span>
<a href="#l26.1321"></a><span id="l26.1321" class="difflineplus">+  /** Authoritative map from folder ID to folder URI */</span>
<a href="#l26.1322"></a><span id="l26.1322" class="difflineplus">+  _folderByID: {},</span>
<a href="#l26.1323"></a><span id="l26.1323" class="difflineplus">+</span>
<a href="#l26.1324"></a><span id="l26.1324" class="difflineplus">+  /** Intialize our _folderByURI/_folderByID mappings, called by _init(). */</span>
<a href="#l26.1325"></a><span id="l26.1325" class="difflineplus">+  _getAllFolderMappings: function gloda_ds_getAllFolderMappings() {</span>
<a href="#l26.1326"></a><span id="l26.1326" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l26.1327"></a><span id="l26.1327" class="difflineplus">+      &quot;SELECT id, folderURI, dirtyStatus, name FROM folderLocations&quot;, true);</span>
<a href="#l26.1328"></a><span id="l26.1328" class="difflineplus">+</span>
<a href="#l26.1329"></a><span id="l26.1329" class="difflineplus">+    while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l26.1330"></a><span id="l26.1330" class="difflineplus">+      let folderID = stmt.getInt64(0);</span>
<a href="#l26.1331"></a><span id="l26.1331" class="difflineplus">+      let folderURI = stmt.getString(1);</span>
<a href="#l26.1332"></a><span id="l26.1332" class="difflineplus">+      let dirtyStatus = stmt.getInt32(2);</span>
<a href="#l26.1333"></a><span id="l26.1333" class="difflineplus">+      let folderName = stmt.getString(3);</span>
<a href="#l26.1334"></a><span id="l26.1334" class="difflineplus">+      </span>
<a href="#l26.1335"></a><span id="l26.1335" class="difflineplus">+      let folder = new GlodaFolder(this, folderID, folderURI, dirtyStatus,</span>
<a href="#l26.1336"></a><span id="l26.1336" class="difflineplus">+                                   folderName);</span>
<a href="#l26.1337"></a><span id="l26.1337" class="difflineplus">+      </span>
<a href="#l26.1338"></a><span id="l26.1338" class="difflineplus">+      this._folderByURI[folderURI] = folder;</span>
<a href="#l26.1339"></a><span id="l26.1339" class="difflineplus">+      this._folderByID[folderID] = folder;</span>
<a href="#l26.1340"></a><span id="l26.1340" class="difflineplus">+</span>
<a href="#l26.1341"></a><span id="l26.1341" class="difflineplus">+      if (folderID &gt;= this._nextFolderId)</span>
<a href="#l26.1342"></a><span id="l26.1342" class="difflineplus">+        this._nextFolderId = folderID + 1;</span>
<a href="#l26.1343"></a><span id="l26.1343" class="difflineplus">+    }</span>
<a href="#l26.1344"></a><span id="l26.1344" class="difflineplus">+    stmt.finalize();</span>
<a href="#l26.1345"></a><span id="l26.1345" class="difflineplus">+  },</span>
<a href="#l26.1346"></a><span id="l26.1346" class="difflineplus">+</span>
<a href="#l26.1347"></a><span id="l26.1347" class="difflineplus">+  _folderKnown: function gloda_ds_folderKnown(aFolder) {</span>
<a href="#l26.1348"></a><span id="l26.1348" class="difflineplus">+    let folderURI = aFolder.URI;</span>
<a href="#l26.1349"></a><span id="l26.1349" class="difflineplus">+    return folderURI in this._folderByURI;</span>
<a href="#l26.1350"></a><span id="l26.1350" class="difflineplus">+  },</span>
<a href="#l26.1351"></a><span id="l26.1351" class="difflineplus">+</span>
<a href="#l26.1352"></a><span id="l26.1352" class="difflineplus">+  /**</span>
<a href="#l26.1353"></a><span id="l26.1353" class="difflineplus">+   * Map a folder URI to a folder ID, creating the mapping if it does not yet</span>
<a href="#l26.1354"></a><span id="l26.1354" class="difflineplus">+   *  exist.</span>
<a href="#l26.1355"></a><span id="l26.1355" class="difflineplus">+   */</span>
<a href="#l26.1356"></a><span id="l26.1356" class="difflineplus">+  _mapFolder: function gloda_ds_mapFolderURI(aFolder) {</span>
<a href="#l26.1357"></a><span id="l26.1357" class="difflineplus">+    let folderURI = aFolder.URI;</span>
<a href="#l26.1358"></a><span id="l26.1358" class="difflineplus">+    if (folderURI in this._folderByURI) {</span>
<a href="#l26.1359"></a><span id="l26.1359" class="difflineplus">+      return this._folderByURI[folderURI];</span>
<a href="#l26.1360"></a><span id="l26.1360" class="difflineplus">+    }</span>
<a href="#l26.1361"></a><span id="l26.1361" class="difflineplus">+</span>
<a href="#l26.1362"></a><span id="l26.1362" class="difflineplus">+    let folderID = this._nextFolderId++;</span>
<a href="#l26.1363"></a><span id="l26.1363" class="difflineplus">+    </span>
<a href="#l26.1364"></a><span id="l26.1364" class="difflineplus">+    let folder = new GlodaFolder(this, folderID, folderURI,</span>
<a href="#l26.1365"></a><span id="l26.1365" class="difflineplus">+      GlodaFolder.prototype.kFolderFilthy, aFolder.prettiestName);</span>
<a href="#l26.1366"></a><span id="l26.1366" class="difflineplus">+    </span>
<a href="#l26.1367"></a><span id="l26.1367" class="difflineplus">+    this._insertFolderLocationStatement.bindInt64Parameter(0, folder.id)</span>
<a href="#l26.1368"></a><span id="l26.1368" class="difflineplus">+    this._insertFolderLocationStatement.bindStringParameter(1, folder.uri);</span>
<a href="#l26.1369"></a><span id="l26.1369" class="difflineplus">+    this._insertFolderLocationStatement.bindInt64Parameter(2,</span>
<a href="#l26.1370"></a><span id="l26.1370" class="difflineplus">+                                                           folder.dirtyStatus);</span>
<a href="#l26.1371"></a><span id="l26.1371" class="difflineplus">+    this._insertFolderLocationStatement.bindStringParameter(3, folder.name);</span>
<a href="#l26.1372"></a><span id="l26.1372" class="difflineplus">+    this._insertFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l26.1373"></a><span id="l26.1373" class="difflineplus">+</span>
<a href="#l26.1374"></a><span id="l26.1374" class="difflineplus">+    this._folderByURI[folderURI] = folder;</span>
<a href="#l26.1375"></a><span id="l26.1375" class="difflineplus">+    this._folderByID[folderID] = folder;</span>
<a href="#l26.1376"></a><span id="l26.1376" class="difflineplus">+    this._log.debug(&quot;!! mapped &quot; + folder.id + &quot; from &quot; + folderURI);</span>
<a href="#l26.1377"></a><span id="l26.1377" class="difflineplus">+    return folder;</span>
<a href="#l26.1378"></a><span id="l26.1378" class="difflineplus">+  },</span>
<a href="#l26.1379"></a><span id="l26.1379" class="difflineplus">+</span>
<a href="#l26.1380"></a><span id="l26.1380" class="difflineplus">+  _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l26.1381"></a><span id="l26.1381" class="difflineplus">+    if (aFolderID === null)</span>
<a href="#l26.1382"></a><span id="l26.1382" class="difflineplus">+      return null;</span>
<a href="#l26.1383"></a><span id="l26.1383" class="difflineplus">+    if (aFolderID in this._folderByID)</span>
<a href="#l26.1384"></a><span id="l26.1384" class="difflineplus">+      return this._folderByID[aFolderID];</span>
<a href="#l26.1385"></a><span id="l26.1385" class="difflineplus">+    throw &quot;Got impossible folder ID: &quot; + aFolderID;</span>
<a href="#l26.1386"></a><span id="l26.1386" class="difflineplus">+  },</span>
<a href="#l26.1387"></a><span id="l26.1387" class="difflineplus">+</span>
<a href="#l26.1388"></a><span id="l26.1388" class="difflineplus">+  get _updateFolderDirtyStatusStatement() {</span>
<a href="#l26.1389"></a><span id="l26.1389" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1390"></a><span id="l26.1390" class="difflineplus">+      &quot;UPDATE folderLocations SET dirtyStatus = ?1 \</span>
<a href="#l26.1391"></a><span id="l26.1391" class="difflineplus">+              WHERE id = ?2&quot;);</span>
<a href="#l26.1392"></a><span id="l26.1392" class="difflineplus">+    this.__defineGetter__(&quot;_updateFolderDirtyStatusStatement&quot;,</span>
<a href="#l26.1393"></a><span id="l26.1393" class="difflineplus">+      function() statement);</span>
<a href="#l26.1394"></a><span id="l26.1394" class="difflineplus">+    return this._updateFolderDirtyStatusStatement;</span>
<a href="#l26.1395"></a><span id="l26.1395" class="difflineplus">+  },</span>
<a href="#l26.1396"></a><span id="l26.1396" class="difflineplus">+</span>
<a href="#l26.1397"></a><span id="l26.1397" class="difflineplus">+  updateFolderDirtyStatus: function gloda_ds_updateFolderDirtyStatus(aFolder) {</span>
<a href="#l26.1398"></a><span id="l26.1398" class="difflineplus">+    let ufds = this._updateFolderDirtyStatusStatement;</span>
<a href="#l26.1399"></a><span id="l26.1399" class="difflineplus">+    ufds.bindInt64Parameter(1, aFolder.id);</span>
<a href="#l26.1400"></a><span id="l26.1400" class="difflineplus">+    ufds.bindInt64Parameter(0, aFolder.dirtyStatus);</span>
<a href="#l26.1401"></a><span id="l26.1401" class="difflineplus">+    ufds.executeAsync(this.trackAsync());</span>
<a href="#l26.1402"></a><span id="l26.1402" class="difflineplus">+  },</span>
<a href="#l26.1403"></a><span id="l26.1403" class="difflineplus">+</span>
<a href="#l26.1404"></a><span id="l26.1404" class="difflineplus">+  get _updateFolderLocationStatement() {</span>
<a href="#l26.1405"></a><span id="l26.1405" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1406"></a><span id="l26.1406" class="difflineplus">+      &quot;UPDATE folderLocations SET folderURI = ?1 \</span>
<a href="#l26.1407"></a><span id="l26.1407" class="difflineplus">+              WHERE id = ?2&quot;);</span>
<a href="#l26.1408"></a><span id="l26.1408" class="difflineplus">+    this.__defineGetter__(&quot;_updateFolderLocationStatement&quot;,</span>
<a href="#l26.1409"></a><span id="l26.1409" class="difflineplus">+      function() statement);</span>
<a href="#l26.1410"></a><span id="l26.1410" class="difflineplus">+    return this._updateFolderLocationStatement;</span>
<a href="#l26.1411"></a><span id="l26.1411" class="difflineplus">+  },</span>
<a href="#l26.1412"></a><span id="l26.1412" class="difflineplus">+</span>
<a href="#l26.1413"></a><span id="l26.1413" class="difflineplus">+  /**</span>
<a href="#l26.1414"></a><span id="l26.1414" class="difflineplus">+   * Non-recursive asynchronous folder renaming based on the URI.</span>
<a href="#l26.1415"></a><span id="l26.1415" class="difflineplus">+   *</span>
<a href="#l26.1416"></a><span id="l26.1416" class="difflineplus">+   * @TODO provide a mechanism for recursive folder renames or have a higher</span>
<a href="#l26.1417"></a><span id="l26.1417" class="difflineplus">+   *     layer deal with it and remove this note.</span>
<a href="#l26.1418"></a><span id="l26.1418" class="difflineplus">+   */</span>
<a href="#l26.1419"></a><span id="l26.1419" class="difflineplus">+  renameFolder: function gloda_ds_renameFolder(aOldFolder, aNewURI) {</span>
<a href="#l26.1420"></a><span id="l26.1420" class="difflineplus">+    let folder = this._mapFolder(aOldFolder); // ensure the folder is mapped</span>
<a href="#l26.1421"></a><span id="l26.1421" class="difflineplus">+    let oldURI = folder.uri; </span>
<a href="#l26.1422"></a><span id="l26.1422" class="difflineplus">+    this._folderByURI[aNewURI] = folder;</span>
<a href="#l26.1423"></a><span id="l26.1423" class="difflineplus">+    folder._uri = aNewURI;</span>
<a href="#l26.1424"></a><span id="l26.1424" class="difflineplus">+    this._log.info(&quot;renaming folder URI &quot; + oldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l26.1425"></a><span id="l26.1425" class="difflineplus">+    this._updateFolderLocationStatement.bindStringParameter(1, folder.id);</span>
<a href="#l26.1426"></a><span id="l26.1426" class="difflineplus">+    this._updateFolderLocationStatement.bindStringParameter(0, aNewURI);</span>
<a href="#l26.1427"></a><span id="l26.1427" class="difflineplus">+    this._updateFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l26.1428"></a><span id="l26.1428" class="difflineplus">+    </span>
<a href="#l26.1429"></a><span id="l26.1429" class="difflineplus">+    delete this._folderByURI[oldURI];</span>
<a href="#l26.1430"></a><span id="l26.1430" class="difflineplus">+  },</span>
<a href="#l26.1431"></a><span id="l26.1431" class="difflineplus">+</span>
<a href="#l26.1432"></a><span id="l26.1432" class="difflineplus">+  get _deleteFolderByIDStatement() {</span>
<a href="#l26.1433"></a><span id="l26.1433" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1434"></a><span id="l26.1434" class="difflineplus">+      &quot;DELETE FROM folderLocations WHERE id = ?1&quot;);</span>
<a href="#l26.1435"></a><span id="l26.1435" class="difflineplus">+    this.__defineGetter__(&quot;_deleteFolderByIDStatement&quot;,</span>
<a href="#l26.1436"></a><span id="l26.1436" class="difflineplus">+      function() statement);</span>
<a href="#l26.1437"></a><span id="l26.1437" class="difflineplus">+    return this._deleteFolderByIDStatement;</span>
<a href="#l26.1438"></a><span id="l26.1438" class="difflineplus">+  },</span>
<a href="#l26.1439"></a><span id="l26.1439" class="difflineplus">+</span>
<a href="#l26.1440"></a><span id="l26.1440" class="difflineplus">+  deleteFolderByID: function gloda_ds_deleteFolder(aFolderID) {</span>
<a href="#l26.1441"></a><span id="l26.1441" class="difflineplus">+    let dfbis = this._deleteFolderByIDStatement;</span>
<a href="#l26.1442"></a><span id="l26.1442" class="difflineplus">+    dfbis.bindInt64Parameter(0, aFolderID);</span>
<a href="#l26.1443"></a><span id="l26.1443" class="difflineplus">+    dfbis.executeAsync(this.trackAsync());</span>
<a href="#l26.1444"></a><span id="l26.1444" class="difflineplus">+  },</span>
<a href="#l26.1445"></a><span id="l26.1445" class="difflineplus">+</span>
<a href="#l26.1446"></a><span id="l26.1446" class="difflineplus">+  /* ********** Conversation ********** */</span>
<a href="#l26.1447"></a><span id="l26.1447" class="difflineplus">+  /** The next conversation id to allocate.  Initialize at startup. */</span>
<a href="#l26.1448"></a><span id="l26.1448" class="difflineplus">+  _nextConversationId: 1,</span>
<a href="#l26.1449"></a><span id="l26.1449" class="difflineplus">+</span>
<a href="#l26.1450"></a><span id="l26.1450" class="difflineplus">+  _populateConversationManagedId: function () {</span>
<a href="#l26.1451"></a><span id="l26.1451" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l26.1452"></a><span id="l26.1452" class="difflineplus">+      &quot;SELECT MAX(id) FROM conversations&quot;, true);</span>
<a href="#l26.1453"></a><span id="l26.1453" class="difflineplus">+    if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l26.1454"></a><span id="l26.1454" class="difflineplus">+      this._nextConversationId = stmt.getInt64(0) + 1;</span>
<a href="#l26.1455"></a><span id="l26.1455" class="difflineplus">+    }</span>
<a href="#l26.1456"></a><span id="l26.1456" class="difflineplus">+    stmt.finalize();</span>
<a href="#l26.1457"></a><span id="l26.1457" class="difflineplus">+  },</span>
<a href="#l26.1458"></a><span id="l26.1458" class="difflineplus">+</span>
<a href="#l26.1459"></a><span id="l26.1459" class="difflineplus">+  get _insertConversationStatement() {</span>
<a href="#l26.1460"></a><span id="l26.1460" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1461"></a><span id="l26.1461" class="difflineplus">+      &quot;INSERT INTO conversations (id, subject, oldestMessageDate, \</span>
<a href="#l26.1462"></a><span id="l26.1462" class="difflineplus">+                                  newestMessageDate) \</span>
<a href="#l26.1463"></a><span id="l26.1463" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l26.1464"></a><span id="l26.1464" class="difflineplus">+    this.__defineGetter__(&quot;_insertConversationStatement&quot;, function() statement);</span>
<a href="#l26.1465"></a><span id="l26.1465" class="difflineplus">+    return this._insertConversationStatement;</span>
<a href="#l26.1466"></a><span id="l26.1466" class="difflineplus">+  },</span>
<a href="#l26.1467"></a><span id="l26.1467" class="difflineplus">+</span>
<a href="#l26.1468"></a><span id="l26.1468" class="difflineplus">+  get _insertConversationTextStatement() {</span>
<a href="#l26.1469"></a><span id="l26.1469" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1470"></a><span id="l26.1470" class="difflineplus">+      &quot;INSERT INTO conversationsText (docid, subject) \</span>
<a href="#l26.1471"></a><span id="l26.1471" class="difflineplus">+              VALUES (?1, ?2)&quot;);</span>
<a href="#l26.1472"></a><span id="l26.1472" class="difflineplus">+    this.__defineGetter__(&quot;_insertConversationTextStatement&quot;,</span>
<a href="#l26.1473"></a><span id="l26.1473" class="difflineplus">+      function() statement);</span>
<a href="#l26.1474"></a><span id="l26.1474" class="difflineplus">+    return this._insertConversationTextStatement;</span>
<a href="#l26.1475"></a><span id="l26.1475" class="difflineplus">+  },</span>
<a href="#l26.1476"></a><span id="l26.1476" class="difflineplus">+</span>
<a href="#l26.1477"></a><span id="l26.1477" class="difflineplus">+  /**</span>
<a href="#l26.1478"></a><span id="l26.1478" class="difflineplus">+   * Asynchronously create a conversation.</span>
<a href="#l26.1479"></a><span id="l26.1479" class="difflineplus">+   */</span>
<a href="#l26.1480"></a><span id="l26.1480" class="difflineplus">+  createConversation: function gloda_ds_createConversation(aSubject,</span>
<a href="#l26.1481"></a><span id="l26.1481" class="difflineplus">+        aOldestMessageDate, aNewestMessageDate) {</span>
<a href="#l26.1482"></a><span id="l26.1482" class="difflineplus">+</span>
<a href="#l26.1483"></a><span id="l26.1483" class="difflineplus">+    // create the data row</span>
<a href="#l26.1484"></a><span id="l26.1484" class="difflineplus">+    let conversationID = this._nextConversationId++;</span>
<a href="#l26.1485"></a><span id="l26.1485" class="difflineplus">+    let ics = this._insertConversationStatement;</span>
<a href="#l26.1486"></a><span id="l26.1486" class="difflineplus">+    ics.bindInt64Parameter(0, conversationID);</span>
<a href="#l26.1487"></a><span id="l26.1487" class="difflineplus">+    ics.bindStringParameter(1, aSubject);</span>
<a href="#l26.1488"></a><span id="l26.1488" class="difflineplus">+    if (aOldestMessageDate == null)</span>
<a href="#l26.1489"></a><span id="l26.1489" class="difflineplus">+      ics.bindNullParameter(2);</span>
<a href="#l26.1490"></a><span id="l26.1490" class="difflineplus">+    else</span>
<a href="#l26.1491"></a><span id="l26.1491" class="difflineplus">+      ics.bindInt64Parameter(2, aOldestMessageDate);</span>
<a href="#l26.1492"></a><span id="l26.1492" class="difflineplus">+    if (aNewestMessageDate == null)</span>
<a href="#l26.1493"></a><span id="l26.1493" class="difflineplus">+      ics.bindNullParameter(3);</span>
<a href="#l26.1494"></a><span id="l26.1494" class="difflineplus">+    else</span>
<a href="#l26.1495"></a><span id="l26.1495" class="difflineplus">+      ics.bindInt64Parameter(3, aNewestMessageDate);</span>
<a href="#l26.1496"></a><span id="l26.1496" class="difflineplus">+    ics.executeAsync(this.trackAsync());</span>
<a href="#l26.1497"></a><span id="l26.1497" class="difflineplus">+</span>
<a href="#l26.1498"></a><span id="l26.1498" class="difflineplus">+    // create the fulltext row, using the same rowid/docid</span>
<a href="#l26.1499"></a><span id="l26.1499" class="difflineplus">+    let icts = this._insertConversationTextStatement;</span>
<a href="#l26.1500"></a><span id="l26.1500" class="difflineplus">+    icts.bindInt64Parameter(0, conversationID);</span>
<a href="#l26.1501"></a><span id="l26.1501" class="difflineplus">+    icts.bindStringParameter(1, aSubject);</span>
<a href="#l26.1502"></a><span id="l26.1502" class="difflineplus">+    icts.executeAsync(this.trackAsync());</span>
<a href="#l26.1503"></a><span id="l26.1503" class="difflineplus">+</span>
<a href="#l26.1504"></a><span id="l26.1504" class="difflineplus">+    // create it</span>
<a href="#l26.1505"></a><span id="l26.1505" class="difflineplus">+    let conversation = new GlodaConversation(this, conversationID,</span>
<a href="#l26.1506"></a><span id="l26.1506" class="difflineplus">+                                 aSubject, aOldestMessageDate,</span>
<a href="#l26.1507"></a><span id="l26.1507" class="difflineplus">+                                 aNewestMessageDate);</span>
<a href="#l26.1508"></a><span id="l26.1508" class="difflineplus">+    // it's new! let the collection manager know about it.</span>
<a href="#l26.1509"></a><span id="l26.1509" class="difflineplus">+    GlodaCollectionManager.itemsAdded(conversation.NOUN_ID, [conversation]);</span>
<a href="#l26.1510"></a><span id="l26.1510" class="difflineplus">+    // return it</span>
<a href="#l26.1511"></a><span id="l26.1511" class="difflineplus">+    return conversation;</span>
<a href="#l26.1512"></a><span id="l26.1512" class="difflineplus">+  },</span>
<a href="#l26.1513"></a><span id="l26.1513" class="difflineplus">+</span>
<a href="#l26.1514"></a><span id="l26.1514" class="difflineplus">+  get _deleteConversationByIDStatement() {</span>
<a href="#l26.1515"></a><span id="l26.1515" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1516"></a><span id="l26.1516" class="difflineplus">+      &quot;DELETE FROM conversations WHERE id = ?1&quot;);</span>
<a href="#l26.1517"></a><span id="l26.1517" class="difflineplus">+    this.__defineGetter__(&quot;_deleteConversationByIDStatement&quot;,</span>
<a href="#l26.1518"></a><span id="l26.1518" class="difflineplus">+                          function() statement);</span>
<a href="#l26.1519"></a><span id="l26.1519" class="difflineplus">+    return this._deleteConversationByIDStatement;</span>
<a href="#l26.1520"></a><span id="l26.1520" class="difflineplus">+  },</span>
<a href="#l26.1521"></a><span id="l26.1521" class="difflineplus">+</span>
<a href="#l26.1522"></a><span id="l26.1522" class="difflineplus">+  /**</span>
<a href="#l26.1523"></a><span id="l26.1523" class="difflineplus">+   * Asynchronously delete a conversation given its ID.</span>
<a href="#l26.1524"></a><span id="l26.1524" class="difflineplus">+   */</span>
<a href="#l26.1525"></a><span id="l26.1525" class="difflineplus">+  deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l26.1526"></a><span id="l26.1526" class="difflineplus">+                                      aConversationID) {</span>
<a href="#l26.1527"></a><span id="l26.1527" class="difflineplus">+    let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l26.1528"></a><span id="l26.1528" class="difflineplus">+    dcbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l26.1529"></a><span id="l26.1529" class="difflineplus">+    dcbids.executeAsync(this.trackAsync());</span>
<a href="#l26.1530"></a><span id="l26.1530" class="difflineplus">+</span>
<a href="#l26.1531"></a><span id="l26.1531" class="difflineplus">+    // TODO: collection manager implications</span>
<a href="#l26.1532"></a><span id="l26.1532" class="difflineplus">+    //GlodaCollectionManager.removeByID()</span>
<a href="#l26.1533"></a><span id="l26.1533" class="difflineplus">+  },</span>
<a href="#l26.1534"></a><span id="l26.1534" class="difflineplus">+</span>
<a href="#l26.1535"></a><span id="l26.1535" class="difflineplus">+  get _selectConversationByIDStatement() {</span>
<a href="#l26.1536"></a><span id="l26.1536" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.1537"></a><span id="l26.1537" class="difflineplus">+      &quot;SELECT id, subject, oldestMessageDate, newestMessageDate \</span>
<a href="#l26.1538"></a><span id="l26.1538" class="difflineplus">+         FROM conversations WHERE id = ?1&quot;);</span>
<a href="#l26.1539"></a><span id="l26.1539" class="difflineplus">+    this.__defineGetter__(&quot;_selectConversationByIDStatement&quot;,</span>
<a href="#l26.1540"></a><span id="l26.1540" class="difflineplus">+      function() statement);</span>
<a href="#l26.1541"></a><span id="l26.1541" class="difflineplus">+    return this._selectConversationByIDStatement;</span>
<a href="#l26.1542"></a><span id="l26.1542" class="difflineplus">+  },</span>
<a href="#l26.1543"></a><span id="l26.1543" class="difflineplus">+</span>
<a href="#l26.1544"></a><span id="l26.1544" class="difflineplus">+  _conversationFromRow: function gloda_ds_conversationFromRow(aStmt) {</span>
<a href="#l26.1545"></a><span id="l26.1545" class="difflineplus">+      let oldestMessageDate, newestMessageDate;</span>
<a href="#l26.1546"></a><span id="l26.1546" class="difflineplus">+      if (aStmt.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.1547"></a><span id="l26.1547" class="difflineplus">+        oldestMessageDate = null;</span>
<a href="#l26.1548"></a><span id="l26.1548" class="difflineplus">+      else</span>
<a href="#l26.1549"></a><span id="l26.1549" class="difflineplus">+        oldestMessageDate = aStmt.getInt64(2);</span>
<a href="#l26.1550"></a><span id="l26.1550" class="difflineplus">+      if (aStmt.getTypeOfIndex(3) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.1551"></a><span id="l26.1551" class="difflineplus">+        newestMessageDate = null;</span>
<a href="#l26.1552"></a><span id="l26.1552" class="difflineplus">+      else</span>
<a href="#l26.1553"></a><span id="l26.1553" class="difflineplus">+        newestMessageDate = aStmt.getInt64(3);</span>
<a href="#l26.1554"></a><span id="l26.1554" class="difflineplus">+      return new GlodaConversation(this, aStmt.getInt64(0),</span>
<a href="#l26.1555"></a><span id="l26.1555" class="difflineplus">+        aStmt.getString(1), oldestMessageDate, newestMessageDate);</span>
<a href="#l26.1556"></a><span id="l26.1556" class="difflineplus">+  },</span>
<a href="#l26.1557"></a><span id="l26.1557" class="difflineplus">+</span>
<a href="#l26.1558"></a><span id="l26.1558" class="difflineplus">+  /**</span>
<a href="#l26.1559"></a><span id="l26.1559" class="difflineplus">+   * Synchronously look up a conversation given its ID.</span>
<a href="#l26.1560"></a><span id="l26.1560" class="difflineplus">+   */</span>
<a href="#l26.1561"></a><span id="l26.1561" class="difflineplus">+  getConversationByID: function gloda_ds_getConversationByID(aConversationID) {</span>
<a href="#l26.1562"></a><span id="l26.1562" class="difflineplus">+    let conversation = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l26.1563"></a><span id="l26.1563" class="difflineplus">+      GlodaConversation.prototype.NOUN_ID, aConversationID);</span>
<a href="#l26.1564"></a><span id="l26.1564" class="difflineplus">+</span>
<a href="#l26.1565"></a><span id="l26.1565" class="difflineplus">+    if (conversation === null) {</span>
<a href="#l26.1566"></a><span id="l26.1566" class="difflineplus">+      let scbids = this._selectConversationByIDStatement;</span>
<a href="#l26.1567"></a><span id="l26.1567" class="difflineplus">+</span>
<a href="#l26.1568"></a><span id="l26.1568" class="difflineplus">+      scbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l26.1569"></a><span id="l26.1569" class="difflineplus">+      if (this._syncStep(scbids)) {</span>
<a href="#l26.1570"></a><span id="l26.1570" class="difflineplus">+        conversation = this._conversationFromRow(scbids);</span>
<a href="#l26.1571"></a><span id="l26.1571" class="difflineplus">+        GlodaCollectionManager.itemLoaded(conversation);</span>
<a href="#l26.1572"></a><span id="l26.1572" class="difflineplus">+      }</span>
<a href="#l26.1573"></a><span id="l26.1573" class="difflineplus">+      scbids.reset();</span>
<a href="#l26.1574"></a><span id="l26.1574" class="difflineplus">+    }</span>
<a href="#l26.1575"></a><span id="l26.1575" class="difflineplus">+</span>
<a href="#l26.1576"></a><span id="l26.1576" class="difflineplus">+    return conversation;</span>
<a href="#l26.1577"></a><span id="l26.1577" class="difflineplus">+  },</span>
<a href="#l26.1578"></a><span id="l26.1578" class="difflineplus">+</span>
<a href="#l26.1579"></a><span id="l26.1579" class="difflineplus">+  /* ********** Message ********** */</span>
<a href="#l26.1580"></a><span id="l26.1580" class="difflineplus">+  /**</span>
<a href="#l26.1581"></a><span id="l26.1581" class="difflineplus">+   * Next message id, managed because of our use of asynchronous inserts.</span>
<a href="#l26.1582"></a><span id="l26.1582" class="difflineplus">+   * Initialized by _populateMessageManagedId called by _init.</span>
<a href="#l26.1583"></a><span id="l26.1583" class="difflineplus">+   */</span>
<a href="#l26.1584"></a><span id="l26.1584" class="difflineplus">+  _nextMessageId: 1,</span>
<a href="#l26.1585"></a><span id="l26.1585" class="difflineplus">+</span>
<a href="#l26.1586"></a><span id="l26.1586" class="difflineplus">+  _populateMessageManagedId: function () {</span>
<a href="#l26.1587"></a><span id="l26.1587" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l26.1588"></a><span id="l26.1588" class="difflineplus">+      &quot;SELECT MAX(id) FROM messages&quot;, true);</span>
<a href="#l26.1589"></a><span id="l26.1589" class="difflineplus">+    if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l26.1590"></a><span id="l26.1590" class="difflineplus">+      this._nextMessageId = stmt.getInt64(0) + 1;</span>
<a href="#l26.1591"></a><span id="l26.1591" class="difflineplus">+    }</span>
<a href="#l26.1592"></a><span id="l26.1592" class="difflineplus">+    stmt.finalize();</span>
<a href="#l26.1593"></a><span id="l26.1593" class="difflineplus">+  },</span>
<a href="#l26.1594"></a><span id="l26.1594" class="difflineplus">+</span>
<a href="#l26.1595"></a><span id="l26.1595" class="difflineplus">+  get _insertMessageStatement() {</span>
<a href="#l26.1596"></a><span id="l26.1596" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1597"></a><span id="l26.1597" class="difflineplus">+      &quot;INSERT INTO messages (id, folderID, messageKey, conversationID, date, \</span>
<a href="#l26.1598"></a><span id="l26.1598" class="difflineplus">+                             headerMessageID, jsonAttributes) \</span>
<a href="#l26.1599"></a><span id="l26.1599" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)&quot;);</span>
<a href="#l26.1600"></a><span id="l26.1600" class="difflineplus">+    this.__defineGetter__(&quot;_insertMessageStatement&quot;, function() statement);</span>
<a href="#l26.1601"></a><span id="l26.1601" class="difflineplus">+    return this._insertMessageStatement;</span>
<a href="#l26.1602"></a><span id="l26.1602" class="difflineplus">+  },</span>
<a href="#l26.1603"></a><span id="l26.1603" class="difflineplus">+</span>
<a href="#l26.1604"></a><span id="l26.1604" class="difflineplus">+  get _insertMessageTextStatement() {</span>
<a href="#l26.1605"></a><span id="l26.1605" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1606"></a><span id="l26.1606" class="difflineplus">+      &quot;INSERT INTO messagesText (docid, subject, body, attachmentNames) \</span>
<a href="#l26.1607"></a><span id="l26.1607" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l26.1608"></a><span id="l26.1608" class="difflineplus">+    this.__defineGetter__(&quot;_insertMessageTextStatement&quot;, function() statement);</span>
<a href="#l26.1609"></a><span id="l26.1609" class="difflineplus">+    return this._insertMessageTextStatement;</span>
<a href="#l26.1610"></a><span id="l26.1610" class="difflineplus">+  },</span>
<a href="#l26.1611"></a><span id="l26.1611" class="difflineplus">+</span>
<a href="#l26.1612"></a><span id="l26.1612" class="difflineplus">+  /**</span>
<a href="#l26.1613"></a><span id="l26.1613" class="difflineplus">+   * Create a GlodaMessage with the given properties.  Because this is only half</span>
<a href="#l26.1614"></a><span id="l26.1614" class="difflineplus">+   *  of the process of creating a message (the attributes still need to be</span>
<a href="#l26.1615"></a><span id="l26.1615" class="difflineplus">+   *  completed), it's on the caller's head to call GlodaCollectionManager's</span>
<a href="#l26.1616"></a><span id="l26.1616" class="difflineplus">+   *  itemAdded method once the message is fully created.</span>
<a href="#l26.1617"></a><span id="l26.1617" class="difflineplus">+   *</span>
<a href="#l26.1618"></a><span id="l26.1618" class="difflineplus">+   * This method uses the async connection, any downstream logic that depends on</span>
<a href="#l26.1619"></a><span id="l26.1619" class="difflineplus">+   *  this message actually existing in the database must be done using an</span>
<a href="#l26.1620"></a><span id="l26.1620" class="difflineplus">+   *  async query.</span>
<a href="#l26.1621"></a><span id="l26.1621" class="difflineplus">+   */</span>
<a href="#l26.1622"></a><span id="l26.1622" class="difflineplus">+  createMessage: function gloda_ds_createMessage(aFolder, aMessageKey,</span>
<a href="#l26.1623"></a><span id="l26.1623" class="difflineplus">+                              aConversationID, aDatePRTime, aHeaderMessageID) {</span>
<a href="#l26.1624"></a><span id="l26.1624" class="difflineplus">+    let folderID;</span>
<a href="#l26.1625"></a><span id="l26.1625" class="difflineplus">+    if (aFolder != null) {</span>
<a href="#l26.1626"></a><span id="l26.1626" class="difflineplus">+      folderID = this._mapFolder(aFolder).id;</span>
<a href="#l26.1627"></a><span id="l26.1627" class="difflineplus">+    }</span>
<a href="#l26.1628"></a><span id="l26.1628" class="difflineplus">+    else {</span>
<a href="#l26.1629"></a><span id="l26.1629" class="difflineplus">+      folderID = null;</span>
<a href="#l26.1630"></a><span id="l26.1630" class="difflineplus">+    }</span>
<a href="#l26.1631"></a><span id="l26.1631" class="difflineplus">+</span>
<a href="#l26.1632"></a><span id="l26.1632" class="difflineplus">+    let messageID = this._nextMessageId++;</span>
<a href="#l26.1633"></a><span id="l26.1633" class="difflineplus">+</span>
<a href="#l26.1634"></a><span id="l26.1634" class="difflineplus">+    let message = new GlodaMessage(this, messageID, folderID,</span>
<a href="#l26.1635"></a><span id="l26.1635" class="difflineplus">+                            aMessageKey, aConversationID, null,</span>
<a href="#l26.1636"></a><span id="l26.1636" class="difflineplus">+                            aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l26.1637"></a><span id="l26.1637" class="difflineplus">+                            aHeaderMessageID);</span>
<a href="#l26.1638"></a><span id="l26.1638" class="difflineplus">+</span>
<a href="#l26.1639"></a><span id="l26.1639" class="difflineplus">+    this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l26.1640"></a><span id="l26.1640" class="difflineplus">+                    aConversationID + &quot;, &quot; + aDatePRTime + &quot;, &quot; +</span>
<a href="#l26.1641"></a><span id="l26.1641" class="difflineplus">+                    aHeaderMessageID);</span>
<a href="#l26.1642"></a><span id="l26.1642" class="difflineplus">+</span>
<a href="#l26.1643"></a><span id="l26.1643" class="difflineplus">+    // We would love to notify the collection manager about the message at this</span>
<a href="#l26.1644"></a><span id="l26.1644" class="difflineplus">+    //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l26.1645"></a><span id="l26.1645" class="difflineplus">+    //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l26.1646"></a><span id="l26.1646" class="difflineplus">+    //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l26.1647"></a><span id="l26.1647" class="difflineplus">+</span>
<a href="#l26.1648"></a><span id="l26.1648" class="difflineplus">+    return message;</span>
<a href="#l26.1649"></a><span id="l26.1649" class="difflineplus">+  },</span>
<a href="#l26.1650"></a><span id="l26.1650" class="difflineplus">+  </span>
<a href="#l26.1651"></a><span id="l26.1651" class="difflineplus">+  insertMessage: function gloda_ds_insertMessage(aMessage) {</span>
<a href="#l26.1652"></a><span id="l26.1652" class="difflineplus">+    let ims = this._insertMessageStatement;</span>
<a href="#l26.1653"></a><span id="l26.1653" class="difflineplus">+    ims.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l26.1654"></a><span id="l26.1654" class="difflineplus">+    if (aMessage.folderID == null)</span>
<a href="#l26.1655"></a><span id="l26.1655" class="difflineplus">+      ims.bindNullParameter(1);</span>
<a href="#l26.1656"></a><span id="l26.1656" class="difflineplus">+    else</span>
<a href="#l26.1657"></a><span id="l26.1657" class="difflineplus">+      ims.bindInt64Parameter(1, aMessage.folderID);</span>
<a href="#l26.1658"></a><span id="l26.1658" class="difflineplus">+    if (aMessage.messageKey == null)</span>
<a href="#l26.1659"></a><span id="l26.1659" class="difflineplus">+      ims.bindNullParameter(2);</span>
<a href="#l26.1660"></a><span id="l26.1660" class="difflineplus">+    else</span>
<a href="#l26.1661"></a><span id="l26.1661" class="difflineplus">+      ims.bindInt64Parameter(2, aMessage.messageKey);</span>
<a href="#l26.1662"></a><span id="l26.1662" class="difflineplus">+    ims.bindInt64Parameter(3, aMessage.conversationID);</span>
<a href="#l26.1663"></a><span id="l26.1663" class="difflineplus">+    if (aMessage.date == null)</span>
<a href="#l26.1664"></a><span id="l26.1664" class="difflineplus">+      ims.bindNullParameter(4);</span>
<a href="#l26.1665"></a><span id="l26.1665" class="difflineplus">+    else</span>
<a href="#l26.1666"></a><span id="l26.1666" class="difflineplus">+      ims.bindInt64Parameter(4, aMessage.date * 1000);</span>
<a href="#l26.1667"></a><span id="l26.1667" class="difflineplus">+    ims.bindStringParameter(5, aMessage.headerMessageID);</span>
<a href="#l26.1668"></a><span id="l26.1668" class="difflineplus">+    if (aMessage._jsonText)</span>
<a href="#l26.1669"></a><span id="l26.1669" class="difflineplus">+      ims.bindStringParameter(6, aMessage._jsonText);</span>
<a href="#l26.1670"></a><span id="l26.1670" class="difflineplus">+    else</span>
<a href="#l26.1671"></a><span id="l26.1671" class="difflineplus">+      ims.bindNullParameter(6);</span>
<a href="#l26.1672"></a><span id="l26.1672" class="difflineplus">+</span>
<a href="#l26.1673"></a><span id="l26.1673" class="difflineplus">+    try {</span>
<a href="#l26.1674"></a><span id="l26.1674" class="difflineplus">+       ims.executeAsync(this.trackAsync());</span>
<a href="#l26.1675"></a><span id="l26.1675" class="difflineplus">+    }</span>
<a href="#l26.1676"></a><span id="l26.1676" class="difflineplus">+    catch(ex) {</span>
<a href="#l26.1677"></a><span id="l26.1677" class="difflineplus">+       throw(&quot;error executing statement... &quot; +</span>
<a href="#l26.1678"></a><span id="l26.1678" class="difflineplus">+             this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l26.1679"></a><span id="l26.1679" class="difflineplus">+             this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l26.1680"></a><span id="l26.1680" class="difflineplus">+    }</span>
<a href="#l26.1681"></a><span id="l26.1681" class="difflineplus">+</span>
<a href="#l26.1682"></a><span id="l26.1682" class="difflineplus">+    // we only create the full-text row if the body is non-null.</span>
<a href="#l26.1683"></a><span id="l26.1683" class="difflineplus">+    // so, even though body might be null, we still want to create the</span>
<a href="#l26.1684"></a><span id="l26.1684" class="difflineplus">+    //  full-text search row</span>
<a href="#l26.1685"></a><span id="l26.1685" class="difflineplus">+    if (aMessage._bodyLines) {</span>
<a href="#l26.1686"></a><span id="l26.1686" class="difflineplus">+      let bodyText;</span>
<a href="#l26.1687"></a><span id="l26.1687" class="difflineplus">+      if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l26.1688"></a><span id="l26.1688" class="difflineplus">+        bodyText = aMessage._content.getContentString(true);</span>
<a href="#l26.1689"></a><span id="l26.1689" class="difflineplus">+      else</span>
<a href="#l26.1690"></a><span id="l26.1690" class="difflineplus">+        bodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l26.1691"></a><span id="l26.1691" class="difflineplus">+      </span>
<a href="#l26.1692"></a><span id="l26.1692" class="difflineplus">+      let imts = this._insertMessageTextStatement;</span>
<a href="#l26.1693"></a><span id="l26.1693" class="difflineplus">+      imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l26.1694"></a><span id="l26.1694" class="difflineplus">+      imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l26.1695"></a><span id="l26.1695" class="difflineplus">+      imts.bindStringParameter(2, bodyText);</span>
<a href="#l26.1696"></a><span id="l26.1696" class="difflineplus">+      if (aMessage._attachmentNames === null)</span>
<a href="#l26.1697"></a><span id="l26.1697" class="difflineplus">+        imts.bindNullParameter(3);</span>
<a href="#l26.1698"></a><span id="l26.1698" class="difflineplus">+      else</span>
<a href="#l26.1699"></a><span id="l26.1699" class="difflineplus">+        imts.bindStringParameter(3, aMessage._attachmentNames);</span>
<a href="#l26.1700"></a><span id="l26.1700" class="difflineplus">+      </span>
<a href="#l26.1701"></a><span id="l26.1701" class="difflineplus">+      try {</span>
<a href="#l26.1702"></a><span id="l26.1702" class="difflineplus">+         imts.executeAsync(this.trackAsync());</span>
<a href="#l26.1703"></a><span id="l26.1703" class="difflineplus">+      }</span>
<a href="#l26.1704"></a><span id="l26.1704" class="difflineplus">+      catch(ex) {</span>
<a href="#l26.1705"></a><span id="l26.1705" class="difflineplus">+         throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l26.1706"></a><span id="l26.1706" class="difflineplus">+               this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l26.1707"></a><span id="l26.1707" class="difflineplus">+               this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l26.1708"></a><span id="l26.1708" class="difflineplus">+      }</span>
<a href="#l26.1709"></a><span id="l26.1709" class="difflineplus">+    }</span>
<a href="#l26.1710"></a><span id="l26.1710" class="difflineplus">+  },</span>
<a href="#l26.1711"></a><span id="l26.1711" class="difflineplus">+</span>
<a href="#l26.1712"></a><span id="l26.1712" class="difflineplus">+  get _updateMessageStatement() {</span>
<a href="#l26.1713"></a><span id="l26.1713" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1714"></a><span id="l26.1714" class="difflineplus">+      &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l26.1715"></a><span id="l26.1715" class="difflineplus">+                           messageKey = ?2, \</span>
<a href="#l26.1716"></a><span id="l26.1716" class="difflineplus">+                           conversationID = ?3, \</span>
<a href="#l26.1717"></a><span id="l26.1717" class="difflineplus">+                           date = ?4, \</span>
<a href="#l26.1718"></a><span id="l26.1718" class="difflineplus">+                           headerMessageID = ?5, \</span>
<a href="#l26.1719"></a><span id="l26.1719" class="difflineplus">+                           jsonAttributes = ?6 \</span>
<a href="#l26.1720"></a><span id="l26.1720" class="difflineplus">+              WHERE id = ?7&quot;);</span>
<a href="#l26.1721"></a><span id="l26.1721" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l26.1722"></a><span id="l26.1722" class="difflineplus">+    return this._updateMessageStatement;</span>
<a href="#l26.1723"></a><span id="l26.1723" class="difflineplus">+  },</span>
<a href="#l26.1724"></a><span id="l26.1724" class="difflineplus">+</span>
<a href="#l26.1725"></a><span id="l26.1725" class="difflineplus">+  /**</span>
<a href="#l26.1726"></a><span id="l26.1726" class="difflineplus">+   * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l26.1727"></a><span id="l26.1727" class="difflineplus">+   *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l26.1728"></a><span id="l26.1728" class="difflineplus">+   *  previously exist.</span>
<a href="#l26.1729"></a><span id="l26.1729" class="difflineplus">+   */</span>
<a href="#l26.1730"></a><span id="l26.1730" class="difflineplus">+  updateMessage: function gloda_ds_updateMessage(aMessage) {</span>
<a href="#l26.1731"></a><span id="l26.1731" class="difflineplus">+    let ums = this._updateMessageStatement;</span>
<a href="#l26.1732"></a><span id="l26.1732" class="difflineplus">+    ums.bindInt64Parameter(6, aMessage.id);</span>
<a href="#l26.1733"></a><span id="l26.1733" class="difflineplus">+    if (aMessage.folderID === null)</span>
<a href="#l26.1734"></a><span id="l26.1734" class="difflineplus">+      ums.bindNullParameter(0);</span>
<a href="#l26.1735"></a><span id="l26.1735" class="difflineplus">+    else</span>
<a href="#l26.1736"></a><span id="l26.1736" class="difflineplus">+      ums.bindInt64Parameter(0, aMessage.folderID);</span>
<a href="#l26.1737"></a><span id="l26.1737" class="difflineplus">+    if (aMessage.messageKey === null)</span>
<a href="#l26.1738"></a><span id="l26.1738" class="difflineplus">+      ums.bindNullParameter(1);</span>
<a href="#l26.1739"></a><span id="l26.1739" class="difflineplus">+    else</span>
<a href="#l26.1740"></a><span id="l26.1740" class="difflineplus">+      ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l26.1741"></a><span id="l26.1741" class="difflineplus">+    ums.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l26.1742"></a><span id="l26.1742" class="difflineplus">+    if (aMessage.date === null)</span>
<a href="#l26.1743"></a><span id="l26.1743" class="difflineplus">+      ums.bindNullParameter(3);</span>
<a href="#l26.1744"></a><span id="l26.1744" class="difflineplus">+    else</span>
<a href="#l26.1745"></a><span id="l26.1745" class="difflineplus">+      ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l26.1746"></a><span id="l26.1746" class="difflineplus">+    ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l26.1747"></a><span id="l26.1747" class="difflineplus">+    if (aMessage._jsonText)</span>
<a href="#l26.1748"></a><span id="l26.1748" class="difflineplus">+      ums.bindStringParameter(5, aMessage._jsonText);</span>
<a href="#l26.1749"></a><span id="l26.1749" class="difflineplus">+    else</span>
<a href="#l26.1750"></a><span id="l26.1750" class="difflineplus">+      ums.bindNullParameter(5);</span>
<a href="#l26.1751"></a><span id="l26.1751" class="difflineplus">+</span>
<a href="#l26.1752"></a><span id="l26.1752" class="difflineplus">+    ums.executeAsync(this.trackAsync());</span>
<a href="#l26.1753"></a><span id="l26.1753" class="difflineplus">+</span>
<a href="#l26.1754"></a><span id="l26.1754" class="difflineplus">+    if (aMessage._isNew &amp;&amp; aMessage._bodyLines) {</span>
<a href="#l26.1755"></a><span id="l26.1755" class="difflineplus">+      let bodyText;</span>
<a href="#l26.1756"></a><span id="l26.1756" class="difflineplus">+      if (aMessage._content &amp;&amp; aMessage._content.hasContent())</span>
<a href="#l26.1757"></a><span id="l26.1757" class="difflineplus">+        bodyText = aMessage._content.getContentString(true);</span>
<a href="#l26.1758"></a><span id="l26.1758" class="difflineplus">+      else</span>
<a href="#l26.1759"></a><span id="l26.1759" class="difflineplus">+        bodyText = aMessage._bodyLines.join(&quot;\n&quot;);</span>
<a href="#l26.1760"></a><span id="l26.1760" class="difflineplus">+      </span>
<a href="#l26.1761"></a><span id="l26.1761" class="difflineplus">+      let imts = this._insertMessageTextStatement;</span>
<a href="#l26.1762"></a><span id="l26.1762" class="difflineplus">+      imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l26.1763"></a><span id="l26.1763" class="difflineplus">+      imts.bindStringParameter(1, aMessage._subject);</span>
<a href="#l26.1764"></a><span id="l26.1764" class="difflineplus">+      imts.bindStringParameter(2, bodyText);</span>
<a href="#l26.1765"></a><span id="l26.1765" class="difflineplus">+      if (aMessage._attachmentNames === null)</span>
<a href="#l26.1766"></a><span id="l26.1766" class="difflineplus">+        imts.bindNullParameter(3);</span>
<a href="#l26.1767"></a><span id="l26.1767" class="difflineplus">+      else</span>
<a href="#l26.1768"></a><span id="l26.1768" class="difflineplus">+        imts.bindStringParameter(3, aMessage._attachmentNames);</span>
<a href="#l26.1769"></a><span id="l26.1769" class="difflineplus">+      </span>
<a href="#l26.1770"></a><span id="l26.1770" class="difflineplus">+      try {</span>
<a href="#l26.1771"></a><span id="l26.1771" class="difflineplus">+         imts.executeAsync(this.trackAsync());</span>
<a href="#l26.1772"></a><span id="l26.1772" class="difflineplus">+      }</span>
<a href="#l26.1773"></a><span id="l26.1773" class="difflineplus">+      catch(ex) {</span>
<a href="#l26.1774"></a><span id="l26.1774" class="difflineplus">+         throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l26.1775"></a><span id="l26.1775" class="difflineplus">+               this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l26.1776"></a><span id="l26.1776" class="difflineplus">+               this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l26.1777"></a><span id="l26.1777" class="difflineplus">+      }</span>
<a href="#l26.1778"></a><span id="l26.1778" class="difflineplus">+    }</span>
<a href="#l26.1779"></a><span id="l26.1779" class="difflineplus">+</span>
<a href="#l26.1780"></a><span id="l26.1780" class="difflineplus">+    // In completely abstract theory, this is where we would call</span>
<a href="#l26.1781"></a><span id="l26.1781" class="difflineplus">+    //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l26.1782"></a><span id="l26.1782" class="difflineplus">+    //  also have changed, so it's out of our hands.  (Gloda.grokNoun</span>
<a href="#l26.1783"></a><span id="l26.1783" class="difflineplus">+    //  handles it.)</span>
<a href="#l26.1784"></a><span id="l26.1784" class="difflineplus">+  },</span>
<a href="#l26.1785"></a><span id="l26.1785" class="difflineplus">+</span>
<a href="#l26.1786"></a><span id="l26.1786" class="difflineplus">+  get _updateMessageLocationStatement() {</span>
<a href="#l26.1787"></a><span id="l26.1787" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.1788"></a><span id="l26.1788" class="difflineplus">+      &quot;UPDATE messages SET folderID = ?1, messageKey = ?2 WHERE id = ?3&quot;);</span>
<a href="#l26.1789"></a><span id="l26.1789" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessageLocationStatement&quot;,</span>
<a href="#l26.1790"></a><span id="l26.1790" class="difflineplus">+                          function() statement);</span>
<a href="#l26.1791"></a><span id="l26.1791" class="difflineplus">+    return this._updateMessageLocationStatement;</span>
<a href="#l26.1792"></a><span id="l26.1792" class="difflineplus">+  },</span>
<a href="#l26.1793"></a><span id="l26.1793" class="difflineplus">+</span>
<a href="#l26.1794"></a><span id="l26.1794" class="difflineplus">+  /**</span>
<a href="#l26.1795"></a><span id="l26.1795" class="difflineplus">+   * Given a list of gloda message ids, and a list of their new message keys in</span>
<a href="#l26.1796"></a><span id="l26.1796" class="difflineplus">+   *  the given new folder location, asynchronously update the message's</span>
<a href="#l26.1797"></a><span id="l26.1797" class="difflineplus">+   *  database locations.  Also, update the in-memory representations.</span>
<a href="#l26.1798"></a><span id="l26.1798" class="difflineplus">+   */</span>
<a href="#l26.1799"></a><span id="l26.1799" class="difflineplus">+  updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l26.1800"></a><span id="l26.1800" class="difflineplus">+      aNewMessageKeys, aDestFolder) {</span>
<a href="#l26.1801"></a><span id="l26.1801" class="difflineplus">+    let statement = this._updateMessageLocationStatement;</span>
<a href="#l26.1802"></a><span id="l26.1802" class="difflineplus">+    let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l26.1803"></a><span id="l26.1803" class="difflineplus">+</span>
<a href="#l26.1804"></a><span id="l26.1804" class="difflineplus">+    let modifiedItems = [];</span>
<a href="#l26.1805"></a><span id="l26.1805" class="difflineplus">+</span>
<a href="#l26.1806"></a><span id="l26.1806" class="difflineplus">+    for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l26.1807"></a><span id="l26.1807" class="difflineplus">+      let id = aMessageIds[iMsg]</span>
<a href="#l26.1808"></a><span id="l26.1808" class="difflineplus">+      statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l26.1809"></a><span id="l26.1809" class="difflineplus">+      statement.bindInt64Parameter(1, aNewMessageKeys[iMsg]);</span>
<a href="#l26.1810"></a><span id="l26.1810" class="difflineplus">+      statement.bindInt64Parameter(2, id);</span>
<a href="#l26.1811"></a><span id="l26.1811" class="difflineplus">+      statement.executeAsync(this.trackAsync());</span>
<a href="#l26.1812"></a><span id="l26.1812" class="difflineplus">+</span>
<a href="#l26.1813"></a><span id="l26.1813" class="difflineplus">+      // so, if the message is currently loaded, we also need to change it up...</span>
<a href="#l26.1814"></a><span id="l26.1814" class="difflineplus">+      let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l26.1815"></a><span id="l26.1815" class="difflineplus">+        GlodaMessage.prototype.NOUN_ID, id);</span>
<a href="#l26.1816"></a><span id="l26.1816" class="difflineplus">+      if (message) {</span>
<a href="#l26.1817"></a><span id="l26.1817" class="difflineplus">+        message._folderID = destFolderID;</span>
<a href="#l26.1818"></a><span id="l26.1818" class="difflineplus">+        modifiedItems.push(message);</span>
<a href="#l26.1819"></a><span id="l26.1819" class="difflineplus">+      }</span>
<a href="#l26.1820"></a><span id="l26.1820" class="difflineplus">+    }</span>
<a href="#l26.1821"></a><span id="l26.1821" class="difflineplus">+</span>
<a href="#l26.1822"></a><span id="l26.1822" class="difflineplus">+    // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l26.1823"></a><span id="l26.1823" class="difflineplus">+    //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l26.1824"></a><span id="l26.1824" class="difflineplus">+    //  synchronous reads off (this) the main thread.</span>
<a href="#l26.1825"></a><span id="l26.1825" class="difflineplus">+    if ((aMessageIds.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l26.1826"></a><span id="l26.1826" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l26.1827"></a><span id="l26.1827" class="difflineplus">+      this._beginTransaction();</span>
<a href="#l26.1828"></a><span id="l26.1828" class="difflineplus">+    }</span>
<a href="#l26.1829"></a><span id="l26.1829" class="difflineplus">+</span>
<a href="#l26.1830"></a><span id="l26.1830" class="difflineplus">+    // tell the collection manager about the modified messages so it can update</span>
<a href="#l26.1831"></a><span id="l26.1831" class="difflineplus">+    //  any existing views...</span>
<a href="#l26.1832"></a><span id="l26.1832" class="difflineplus">+    if (modifiedItems.length) {</span>
<a href="#l26.1833"></a><span id="l26.1833" class="difflineplus">+      GlodaCollectionManager.itemsModified(GlodaMessage.prototype.NOUN,</span>
<a href="#l26.1834"></a><span id="l26.1834" class="difflineplus">+                                           modifiedItems);</span>
<a href="#l26.1835"></a><span id="l26.1835" class="difflineplus">+    }</span>
<a href="#l26.1836"></a><span id="l26.1836" class="difflineplus">+  },</span>
<a href="#l26.1837"></a><span id="l26.1837" class="difflineplus">+</span>
<a href="#l26.1838"></a><span id="l26.1838" class="difflineplus">+  /**</span>
<a href="#l26.1839"></a><span id="l26.1839" class="difflineplus">+   * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l26.1840"></a><span id="l26.1840" class="difflineplus">+   *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l26.1841"></a><span id="l26.1841" class="difflineplus">+   *  don't yet know their target message keys.</span>
<a href="#l26.1842"></a><span id="l26.1842" class="difflineplus">+   */</span>
<a href="#l26.1843"></a><span id="l26.1843" class="difflineplus">+  updateMessageFoldersByKeyPurging:</span>
<a href="#l26.1844"></a><span id="l26.1844" class="difflineplus">+      function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolder,</span>
<a href="#l26.1845"></a><span id="l26.1845" class="difflineplus">+        aMessageKeys, aDestFolder) {</span>
<a href="#l26.1846"></a><span id="l26.1846" class="difflineplus">+    let srcFolderID = this._mapFolder(aSrcFolder).id;</span>
<a href="#l26.1847"></a><span id="l26.1847" class="difflineplus">+    let destFolderID = this._mapFolder(aDestFolder).id;</span>
<a href="#l26.1848"></a><span id="l26.1848" class="difflineplus">+</span>
<a href="#l26.1849"></a><span id="l26.1849" class="difflineplus">+    let sqlStr = &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l26.1850"></a><span id="l26.1850" class="difflineplus">+                                      messageKey = ?2 \</span>
<a href="#l26.1851"></a><span id="l26.1851" class="difflineplus">+                   WHERE folderID = ?3 \</span>
<a href="#l26.1852"></a><span id="l26.1852" class="difflineplus">+                     AND messageKey IN (&quot; + aMessageKeys.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l26.1853"></a><span id="l26.1853" class="difflineplus">+    let statement = this._createAsyncStatement(sqlStr, true);</span>
<a href="#l26.1854"></a><span id="l26.1854" class="difflineplus">+    statement.bindInt64Parameter(2, srcFolderID);</span>
<a href="#l26.1855"></a><span id="l26.1855" class="difflineplus">+    statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l26.1856"></a><span id="l26.1856" class="difflineplus">+    statement.bindNullParameter(1);</span>
<a href="#l26.1857"></a><span id="l26.1857" class="difflineplus">+    statement.executeAsync(this.trackAsync());</span>
<a href="#l26.1858"></a><span id="l26.1858" class="difflineplus">+    statement.finalize();</span>
<a href="#l26.1859"></a><span id="l26.1859" class="difflineplus">+</span>
<a href="#l26.1860"></a><span id="l26.1860" class="difflineplus">+    // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l26.1861"></a><span id="l26.1861" class="difflineplus">+    //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l26.1862"></a><span id="l26.1862" class="difflineplus">+    //  synchronous reads off (this) the main thread.</span>
<a href="#l26.1863"></a><span id="l26.1863" class="difflineplus">+    if ((aMessageKeys.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l26.1864"></a><span id="l26.1864" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l26.1865"></a><span id="l26.1865" class="difflineplus">+      this._beginTransaction();</span>
<a href="#l26.1866"></a><span id="l26.1866" class="difflineplus">+    }</span>
<a href="#l26.1867"></a><span id="l26.1867" class="difflineplus">+  },</span>
<a href="#l26.1868"></a><span id="l26.1868" class="difflineplus">+</span>
<a href="#l26.1869"></a><span id="l26.1869" class="difflineplus">+  _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l26.1870"></a><span id="l26.1870" class="difflineplus">+    let folderId, messageKey, date, jsonText;</span>
<a href="#l26.1871"></a><span id="l26.1871" class="difflineplus">+    if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.1872"></a><span id="l26.1872" class="difflineplus">+      folderId = null;</span>
<a href="#l26.1873"></a><span id="l26.1873" class="difflineplus">+    else</span>
<a href="#l26.1874"></a><span id="l26.1874" class="difflineplus">+      folderId = aRow.getInt64(1);</span>
<a href="#l26.1875"></a><span id="l26.1875" class="difflineplus">+    if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.1876"></a><span id="l26.1876" class="difflineplus">+      messageKey = null;</span>
<a href="#l26.1877"></a><span id="l26.1877" class="difflineplus">+    else</span>
<a href="#l26.1878"></a><span id="l26.1878" class="difflineplus">+      messageKey = aRow.getInt64(2);</span>
<a href="#l26.1879"></a><span id="l26.1879" class="difflineplus">+    if (aRow.getTypeOfIndex(4) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.1880"></a><span id="l26.1880" class="difflineplus">+      date = null;</span>
<a href="#l26.1881"></a><span id="l26.1881" class="difflineplus">+    else</span>
<a href="#l26.1882"></a><span id="l26.1882" class="difflineplus">+      date = new Date(aRow.getInt64(4) / 1000);</span>
<a href="#l26.1883"></a><span id="l26.1883" class="difflineplus">+    if (aRow.getTypeOfIndex(7) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.1884"></a><span id="l26.1884" class="difflineplus">+      jsonText = undefined;</span>
<a href="#l26.1885"></a><span id="l26.1885" class="difflineplus">+    else</span>
<a href="#l26.1886"></a><span id="l26.1886" class="difflineplus">+      jsonText = aRow.getString(7);</span>
<a href="#l26.1887"></a><span id="l26.1887" class="difflineplus">+    return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l26.1888"></a><span id="l26.1888" class="difflineplus">+                            aRow.getInt64(3), null, date, aRow.getString(5),</span>
<a href="#l26.1889"></a><span id="l26.1889" class="difflineplus">+                            aRow.getInt64(6), jsonText);</span>
<a href="#l26.1890"></a><span id="l26.1890" class="difflineplus">+  },</span>
<a href="#l26.1891"></a><span id="l26.1891" class="difflineplus">+</span>
<a href="#l26.1892"></a><span id="l26.1892" class="difflineplus">+  get _selectMessageByIDStatement() {</span>
<a href="#l26.1893"></a><span id="l26.1893" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.1894"></a><span id="l26.1894" class="difflineplus">+      &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID, \</span>
<a href="#l26.1895"></a><span id="l26.1895" class="difflineplus">+           deleted FROM messages WHERE id = ?1&quot;);</span>
<a href="#l26.1896"></a><span id="l26.1896" class="difflineplus">+    this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l26.1897"></a><span id="l26.1897" class="difflineplus">+      function() statement);</span>
<a href="#l26.1898"></a><span id="l26.1898" class="difflineplus">+    return this._selectMessageByIDStatement;</span>
<a href="#l26.1899"></a><span id="l26.1899" class="difflineplus">+  },</span>
<a href="#l26.1900"></a><span id="l26.1900" class="difflineplus">+</span>
<a href="#l26.1901"></a><span id="l26.1901" class="difflineplus">+  /**</span>
<a href="#l26.1902"></a><span id="l26.1902" class="difflineplus">+   * Synchronously retrieve the given message given its gloda message id.</span>
<a href="#l26.1903"></a><span id="l26.1903" class="difflineplus">+   */</span>
<a href="#l26.1904"></a><span id="l26.1904" class="difflineplus">+  getMessageByID: function gloda_ds_getMessageByID(aID) {</span>
<a href="#l26.1905"></a><span id="l26.1905" class="difflineplus">+    let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l26.1906"></a><span id="l26.1906" class="difflineplus">+      GlodaMessage.prototype.NOUN_ID, aID);</span>
<a href="#l26.1907"></a><span id="l26.1907" class="difflineplus">+</span>
<a href="#l26.1908"></a><span id="l26.1908" class="difflineplus">+    if (message === null) {</span>
<a href="#l26.1909"></a><span id="l26.1909" class="difflineplus">+      let smbis = this._selectMessageByIDStatement;</span>
<a href="#l26.1910"></a><span id="l26.1910" class="difflineplus">+</span>
<a href="#l26.1911"></a><span id="l26.1911" class="difflineplus">+      smbis.bindInt64Parameter(0, aID);</span>
<a href="#l26.1912"></a><span id="l26.1912" class="difflineplus">+      if (this._syncStep(smbis)) {</span>
<a href="#l26.1913"></a><span id="l26.1913" class="difflineplus">+        message = this._messageFromRow(smbis);</span>
<a href="#l26.1914"></a><span id="l26.1914" class="difflineplus">+        GlodaCollectionManager.itemLoaded(message);</span>
<a href="#l26.1915"></a><span id="l26.1915" class="difflineplus">+      }</span>
<a href="#l26.1916"></a><span id="l26.1916" class="difflineplus">+      smbis.reset();</span>
<a href="#l26.1917"></a><span id="l26.1917" class="difflineplus">+    }</span>
<a href="#l26.1918"></a><span id="l26.1918" class="difflineplus">+</span>
<a href="#l26.1919"></a><span id="l26.1919" class="difflineplus">+    return message;</span>
<a href="#l26.1920"></a><span id="l26.1920" class="difflineplus">+  },</span>
<a href="#l26.1921"></a><span id="l26.1921" class="difflineplus">+</span>
<a href="#l26.1922"></a><span id="l26.1922" class="difflineplus">+  get _selectMessageByLocationStatement() {</span>
<a href="#l26.1923"></a><span id="l26.1923" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.1924"></a><span id="l26.1924" class="difflineplus">+      &quot;SELECT * FROM messages WHERE folderID = ?1 AND messageKey = ?2&quot;);</span>
<a href="#l26.1925"></a><span id="l26.1925" class="difflineplus">+    this.__defineGetter__(&quot;_selectMessageByLocationStatement&quot;,</span>
<a href="#l26.1926"></a><span id="l26.1926" class="difflineplus">+      function() statement);</span>
<a href="#l26.1927"></a><span id="l26.1927" class="difflineplus">+    return this._selectMessageByLocationStatement;</span>
<a href="#l26.1928"></a><span id="l26.1928" class="difflineplus">+  },</span>
<a href="#l26.1929"></a><span id="l26.1929" class="difflineplus">+</span>
<a href="#l26.1930"></a><span id="l26.1930" class="difflineplus">+  /**</span>
<a href="#l26.1931"></a><span id="l26.1931" class="difflineplus">+   * Synchronously retrieve the message that we believe to correspond to the</span>
<a href="#l26.1932"></a><span id="l26.1932" class="difflineplus">+   *  given message key in the given folder.</span>
<a href="#l26.1933"></a><span id="l26.1933" class="difflineplus">+   * @return null on failure to locate the message, the message on success.</span>
<a href="#l26.1934"></a><span id="l26.1934" class="difflineplus">+   *</span>
<a href="#l26.1935"></a><span id="l26.1935" class="difflineplus">+   * @XXX on failure, attempt to resolve the problem through re-indexing, etc.</span>
<a href="#l26.1936"></a><span id="l26.1936" class="difflineplus">+   */</span>
<a href="#l26.1937"></a><span id="l26.1937" class="difflineplus">+  getMessageFromLocation: function gloda_ds_getMessageFromLocation(aFolder,</span>
<a href="#l26.1938"></a><span id="l26.1938" class="difflineplus">+                                                                 aMessageKey) {</span>
<a href="#l26.1939"></a><span id="l26.1939" class="difflineplus">+    this._selectMessageByLocationStatement.bindInt64Parameter(0,</span>
<a href="#l26.1940"></a><span id="l26.1940" class="difflineplus">+      this._mapFolder(aFolder).id);</span>
<a href="#l26.1941"></a><span id="l26.1941" class="difflineplus">+    this._selectMessageByLocationStatement.bindInt64Parameter(1, aMessageKey);</span>
<a href="#l26.1942"></a><span id="l26.1942" class="difflineplus">+</span>
<a href="#l26.1943"></a><span id="l26.1943" class="difflineplus">+    let message = null;</span>
<a href="#l26.1944"></a><span id="l26.1944" class="difflineplus">+    if (this._syncStep(this._selectMessageByLocationStatement))</span>
<a href="#l26.1945"></a><span id="l26.1945" class="difflineplus">+      message = this._messageFromRow(this._selectMessageByLocationStatement);</span>
<a href="#l26.1946"></a><span id="l26.1946" class="difflineplus">+    this._selectMessageByLocationStatement.reset();</span>
<a href="#l26.1947"></a><span id="l26.1947" class="difflineplus">+</span>
<a href="#l26.1948"></a><span id="l26.1948" class="difflineplus">+    if (message === null)</span>
<a href="#l26.1949"></a><span id="l26.1949" class="difflineplus">+      this._log.info(&quot;Error locating message with key=&quot; + aMessageKey +</span>
<a href="#l26.1950"></a><span id="l26.1950" class="difflineplus">+                     &quot; and URI &quot; + aFolder.URI);</span>
<a href="#l26.1951"></a><span id="l26.1951" class="difflineplus">+</span>
<a href="#l26.1952"></a><span id="l26.1952" class="difflineplus">+    return message &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(message);</span>
<a href="#l26.1953"></a><span id="l26.1953" class="difflineplus">+  },</span>
<a href="#l26.1954"></a><span id="l26.1954" class="difflineplus">+</span>
<a href="#l26.1955"></a><span id="l26.1955" class="difflineplus">+  get _selectMessageIDsByFolderStatement() {</span>
<a href="#l26.1956"></a><span id="l26.1956" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.1957"></a><span id="l26.1957" class="difflineplus">+      &quot;SELECT id FROM messages WHERE folderID = ?1&quot;);</span>
<a href="#l26.1958"></a><span id="l26.1958" class="difflineplus">+    this.__defineGetter__(&quot;_selectMessageIDsByFolderStatement&quot;,</span>
<a href="#l26.1959"></a><span id="l26.1959" class="difflineplus">+      function() statement);</span>
<a href="#l26.1960"></a><span id="l26.1960" class="difflineplus">+    return this._selectMessageIDsByFolderStatement;</span>
<a href="#l26.1961"></a><span id="l26.1961" class="difflineplus">+  },</span>
<a href="#l26.1962"></a><span id="l26.1962" class="difflineplus">+</span>
<a href="#l26.1963"></a><span id="l26.1963" class="difflineplus">+  getMessageIDsByFolderID:</span>
<a href="#l26.1964"></a><span id="l26.1964" class="difflineplus">+      function gloda_ds_getMessageIDsFromFolderID(aFolderID) {</span>
<a href="#l26.1965"></a><span id="l26.1965" class="difflineplus">+    let messageIDs = [];</span>
<a href="#l26.1966"></a><span id="l26.1966" class="difflineplus">+</span>
<a href="#l26.1967"></a><span id="l26.1967" class="difflineplus">+    let smidbfs = this._selectMessageIDsByFolderStatement;</span>
<a href="#l26.1968"></a><span id="l26.1968" class="difflineplus">+    smidbfs.bindInt64Parameter(0, aFolderID);</span>
<a href="#l26.1969"></a><span id="l26.1969" class="difflineplus">+</span>
<a href="#l26.1970"></a><span id="l26.1970" class="difflineplus">+    while (this._syncStep(smidbfs)) {</span>
<a href="#l26.1971"></a><span id="l26.1971" class="difflineplus">+      messageIDs.push(smidbfs.getInt64(0));</span>
<a href="#l26.1972"></a><span id="l26.1972" class="difflineplus">+    }</span>
<a href="#l26.1973"></a><span id="l26.1973" class="difflineplus">+    smidbfs.reset();</span>
<a href="#l26.1974"></a><span id="l26.1974" class="difflineplus">+</span>
<a href="#l26.1975"></a><span id="l26.1975" class="difflineplus">+    return messageIDs;</span>
<a href="#l26.1976"></a><span id="l26.1976" class="difflineplus">+  },</span>
<a href="#l26.1977"></a><span id="l26.1977" class="difflineplus">+</span>
<a href="#l26.1978"></a><span id="l26.1978" class="difflineplus">+  /**</span>
<a href="#l26.1979"></a><span id="l26.1979" class="difflineplus">+   * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l26.1980"></a><span id="l26.1980" class="difflineplus">+   *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l26.1981"></a><span id="l26.1981" class="difflineplus">+   *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l26.1982"></a><span id="l26.1982" class="difflineplus">+   *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l26.1983"></a><span id="l26.1983" class="difflineplus">+   *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l26.1984"></a><span id="l26.1984" class="difflineplus">+   *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l26.1985"></a><span id="l26.1985" class="difflineplus">+   *  messages with the same ID.</span>
<a href="#l26.1986"></a><span id="l26.1986" class="difflineplus">+   * This call is asynchronous because it depends on previously created messages</span>
<a href="#l26.1987"></a><span id="l26.1987" class="difflineplus">+   *  to be reflected in our results, which requires us to execute on the async</span>
<a href="#l26.1988"></a><span id="l26.1988" class="difflineplus">+   *  thread where all our writes happen.  This also turns out to be a</span>
<a href="#l26.1989"></a><span id="l26.1989" class="difflineplus">+   *  reasonable thing because we could imagine pathological cases where there</span>
<a href="#l26.1990"></a><span id="l26.1990" class="difflineplus">+   *  could be a lot of message-id's and/or a lot of messages with those</span>
<a href="#l26.1991"></a><span id="l26.1991" class="difflineplus">+   *  message-id's.</span>
<a href="#l26.1992"></a><span id="l26.1992" class="difflineplus">+   */</span>
<a href="#l26.1993"></a><span id="l26.1993" class="difflineplus">+  getMessagesByMessageID: function gloda_ds_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l26.1994"></a><span id="l26.1994" class="difflineplus">+      aCallback, aCallbackThis) {</span>
<a href="#l26.1995"></a><span id="l26.1995" class="difflineplus">+    let msgIDToIndex = {};</span>
<a href="#l26.1996"></a><span id="l26.1996" class="difflineplus">+    let results = [];</span>
<a href="#l26.1997"></a><span id="l26.1997" class="difflineplus">+    for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l26.1998"></a><span id="l26.1998" class="difflineplus">+      let msgID = aMessageIDs[iID];</span>
<a href="#l26.1999"></a><span id="l26.1999" class="difflineplus">+      results.push([]);</span>
<a href="#l26.2000"></a><span id="l26.2000" class="difflineplus">+      msgIDToIndex[msgID] = iID;</span>
<a href="#l26.2001"></a><span id="l26.2001" class="difflineplus">+    }</span>
<a href="#l26.2002"></a><span id="l26.2002" class="difflineplus">+</span>
<a href="#l26.2003"></a><span id="l26.2003" class="difflineplus">+    // Unfortunately, IN doesn't work with statement binding mechanisms, and</span>
<a href="#l26.2004"></a><span id="l26.2004" class="difflineplus">+    //  a chain of ORed tests really can't be bound unless we create one per</span>
<a href="#l26.2005"></a><span id="l26.2005" class="difflineplus">+    //  value of N (seems silly).</span>
<a href="#l26.2006"></a><span id="l26.2006" class="difflineplus">+    let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l26.2007"></a><span id="l26.2007" class="difflineplus">+                     ([i, msgID] in Iterator(aMessageIDs))]</span>
<a href="#l26.2008"></a><span id="l26.2008" class="difflineplus">+    let sqlString = &quot;SELECT * FROM messages WHERE headerMessageID IN (&quot; +</span>
<a href="#l26.2009"></a><span id="l26.2009" class="difflineplus">+                    quotedIDs + &quot;)&quot;;</span>
<a href="#l26.2010"></a><span id="l26.2010" class="difflineplus">+    </span>
<a href="#l26.2011"></a><span id="l26.2011" class="difflineplus">+    let nounDef = GlodaMessage.prototype.NOUN_DEF;</span>
<a href="#l26.2012"></a><span id="l26.2012" class="difflineplus">+    let listener = new MessagesByMessageIdCallback(msgIDToIndex, results,</span>
<a href="#l26.2013"></a><span id="l26.2013" class="difflineplus">+        aCallback, aCallbackThis);</span>
<a href="#l26.2014"></a><span id="l26.2014" class="difflineplus">+    let query = new nounDef.explicitQueryClass();</span>
<a href="#l26.2015"></a><span id="l26.2015" class="difflineplus">+    return this._queryFromSQLString(sqlString, [], nounDef,</span>
<a href="#l26.2016"></a><span id="l26.2016" class="difflineplus">+        query, listener);</span>
<a href="#l26.2017"></a><span id="l26.2017" class="difflineplus">+  },</span>
<a href="#l26.2018"></a><span id="l26.2018" class="difflineplus">+</span>
<a href="#l26.2019"></a><span id="l26.2019" class="difflineplus">+  get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l26.2020"></a><span id="l26.2020" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2021"></a><span id="l26.2021" class="difflineplus">+      &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l26.2022"></a><span id="l26.2022" class="difflineplus">+              deleted = 1 WHERE folderID = ?1&quot;);</span>
<a href="#l26.2023"></a><span id="l26.2023" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessagesMarkDeletedByFolderID&quot;,</span>
<a href="#l26.2024"></a><span id="l26.2024" class="difflineplus">+      function() statement);</span>
<a href="#l26.2025"></a><span id="l26.2025" class="difflineplus">+    return this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l26.2026"></a><span id="l26.2026" class="difflineplus">+  },</span>
<a href="#l26.2027"></a><span id="l26.2027" class="difflineplus">+</span>
<a href="#l26.2028"></a><span id="l26.2028" class="difflineplus">+  markMessagesDeletedByFolderID:</span>
<a href="#l26.2029"></a><span id="l26.2029" class="difflineplus">+      function gloda_ds_markMessagesDeletedByFolderID(aFolderID) {</span>
<a href="#l26.2030"></a><span id="l26.2030" class="difflineplus">+    let statement = this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l26.2031"></a><span id="l26.2031" class="difflineplus">+    statement.bindInt64Parameter(0, aFolderID);</span>
<a href="#l26.2032"></a><span id="l26.2032" class="difflineplus">+    statement.executeAsync(this.trackAsync());</span>
<a href="#l26.2033"></a><span id="l26.2033" class="difflineplus">+    statement.finalize();</span>
<a href="#l26.2034"></a><span id="l26.2034" class="difflineplus">+  },</span>
<a href="#l26.2035"></a><span id="l26.2035" class="difflineplus">+</span>
<a href="#l26.2036"></a><span id="l26.2036" class="difflineplus">+  markMessagesDeletedByIDs: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l26.2037"></a><span id="l26.2037" class="difflineplus">+      aMessageIDs) {</span>
<a href="#l26.2038"></a><span id="l26.2038" class="difflineplus">+    let sqlString = &quot;UPDATE messages SET deleted = 1 WHERE id IN (&quot; +</span>
<a href="#l26.2039"></a><span id="l26.2039" class="difflineplus">+      aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l26.2040"></a><span id="l26.2040" class="difflineplus">+</span>
<a href="#l26.2041"></a><span id="l26.2041" class="difflineplus">+    let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l26.2042"></a><span id="l26.2042" class="difflineplus">+    statement.executeAsync(this.trackAsync());</span>
<a href="#l26.2043"></a><span id="l26.2043" class="difflineplus">+    statement.finalize();</span>
<a href="#l26.2044"></a><span id="l26.2044" class="difflineplus">+</span>
<a href="#l26.2045"></a><span id="l26.2045" class="difflineplus">+    // some people are inclined to deleting ridiculous numbers of messages at</span>
<a href="#l26.2046"></a><span id="l26.2046" class="difflineplus">+    //  a time.  if we are in a transaction, this has the potential to cause us</span>
<a href="#l26.2047"></a><span id="l26.2047" class="difflineplus">+    //  to spill the transaction to disk prior to disk, resulting in a lock</span>
<a href="#l26.2048"></a><span id="l26.2048" class="difflineplus">+    //  escalation and making any synchronous reads from the main thread need</span>
<a href="#l26.2049"></a><span id="l26.2049" class="difflineplus">+    //  to become blocking.  We don't want that, so:</span>
<a href="#l26.2050"></a><span id="l26.2050" class="difflineplus">+    // If we are in a transaction and there are a &quot;lot&quot; of messages being</span>
<a href="#l26.2051"></a><span id="l26.2051" class="difflineplus">+    //  marked as deleted, issue a commit and then re-open the transaction.</span>
<a href="#l26.2052"></a><span id="l26.2052" class="difflineplus">+    if ((aMessageIDs.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l26.2053"></a><span id="l26.2053" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l26.2054"></a><span id="l26.2054" class="difflineplus">+      this._beginTransaction();</span>
<a href="#l26.2055"></a><span id="l26.2055" class="difflineplus">+    }</span>
<a href="#l26.2056"></a><span id="l26.2056" class="difflineplus">+  },</span>
<a href="#l26.2057"></a><span id="l26.2057" class="difflineplus">+</span>
<a href="#l26.2058"></a><span id="l26.2058" class="difflineplus">+  get _deleteMessageByIDStatement() {</span>
<a href="#l26.2059"></a><span id="l26.2059" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2060"></a><span id="l26.2060" class="difflineplus">+      &quot;DELETE FROM messages WHERE id = ?1&quot;);</span>
<a href="#l26.2061"></a><span id="l26.2061" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l26.2062"></a><span id="l26.2062" class="difflineplus">+                          function() statement);</span>
<a href="#l26.2063"></a><span id="l26.2063" class="difflineplus">+    return this._deleteMessageByIDStatement;</span>
<a href="#l26.2064"></a><span id="l26.2064" class="difflineplus">+  },</span>
<a href="#l26.2065"></a><span id="l26.2065" class="difflineplus">+</span>
<a href="#l26.2066"></a><span id="l26.2066" class="difflineplus">+  deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l26.2067"></a><span id="l26.2067" class="difflineplus">+    // TODO: collection manager implications</span>
<a href="#l26.2068"></a><span id="l26.2068" class="difflineplus">+    let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l26.2069"></a><span id="l26.2069" class="difflineplus">+    dmbids.bindInt64Parameter(0, aMessageID);</span>
<a href="#l26.2070"></a><span id="l26.2070" class="difflineplus">+    dmbids.executeAsync(this.trackAsync());</span>
<a href="#l26.2071"></a><span id="l26.2071" class="difflineplus">+  },</span>
<a href="#l26.2072"></a><span id="l26.2072" class="difflineplus">+</span>
<a href="#l26.2073"></a><span id="l26.2073" class="difflineplus">+  get _deleteMessagesByConversationIDStatement() {</span>
<a href="#l26.2074"></a><span id="l26.2074" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2075"></a><span id="l26.2075" class="difflineplus">+      &quot;DELETE FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l26.2076"></a><span id="l26.2076" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessagesByConversationIDStatement&quot;,</span>
<a href="#l26.2077"></a><span id="l26.2077" class="difflineplus">+                          function() statement);</span>
<a href="#l26.2078"></a><span id="l26.2078" class="difflineplus">+    return this._deleteMessagesByConversationIDStatement;</span>
<a href="#l26.2079"></a><span id="l26.2079" class="difflineplus">+  },</span>
<a href="#l26.2080"></a><span id="l26.2080" class="difflineplus">+</span>
<a href="#l26.2081"></a><span id="l26.2081" class="difflineplus">+  /**</span>
<a href="#l26.2082"></a><span id="l26.2082" class="difflineplus">+   * Delete messages by conversation ID.  For use by the indexer's deletion</span>
<a href="#l26.2083"></a><span id="l26.2083" class="difflineplus">+   *  logic, NOT you.</span>
<a href="#l26.2084"></a><span id="l26.2084" class="difflineplus">+   */</span>
<a href="#l26.2085"></a><span id="l26.2085" class="difflineplus">+  deleteMessagesByConversationID:</span>
<a href="#l26.2086"></a><span id="l26.2086" class="difflineplus">+    // TODO: collection manager implications</span>
<a href="#l26.2087"></a><span id="l26.2087" class="difflineplus">+      function gloda_ds_deleteMessagesByConversationID(aConversationID) {</span>
<a href="#l26.2088"></a><span id="l26.2088" class="difflineplus">+    let dmbcids = this._deleteMessagesByConversationIDStatement;</span>
<a href="#l26.2089"></a><span id="l26.2089" class="difflineplus">+    dmbcids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l26.2090"></a><span id="l26.2090" class="difflineplus">+    dmbcids.executeAsync(this.trackAsync());</span>
<a href="#l26.2091"></a><span id="l26.2091" class="difflineplus">+  },</span>
<a href="#l26.2092"></a><span id="l26.2092" class="difflineplus">+</span>
<a href="#l26.2093"></a><span id="l26.2093" class="difflineplus">+  get _selectMessagesByConversationIDStatement() {</span>
<a href="#l26.2094"></a><span id="l26.2094" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.2095"></a><span id="l26.2095" class="difflineplus">+      &quot;SELECT * FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l26.2096"></a><span id="l26.2096" class="difflineplus">+    this.__defineGetter__(&quot;_selectMessagesByConversationIDStatement&quot;,</span>
<a href="#l26.2097"></a><span id="l26.2097" class="difflineplus">+      function() statement);</span>
<a href="#l26.2098"></a><span id="l26.2098" class="difflineplus">+    return this._selectMessagesByConversationIDStatement;</span>
<a href="#l26.2099"></a><span id="l26.2099" class="difflineplus">+  },</span>
<a href="#l26.2100"></a><span id="l26.2100" class="difflineplus">+</span>
<a href="#l26.2101"></a><span id="l26.2101" class="difflineplus">+  get _selectMessagesByConversationIDNoGhostsStatement() {</span>
<a href="#l26.2102"></a><span id="l26.2102" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.2103"></a><span id="l26.2103" class="difflineplus">+      &quot;SELECT * FROM messages WHERE conversationID = ?1 AND \</span>
<a href="#l26.2104"></a><span id="l26.2104" class="difflineplus">+                                    folderID IS NOT NULL&quot;);</span>
<a href="#l26.2105"></a><span id="l26.2105" class="difflineplus">+    this.__defineGetter__(&quot;_selectMessagesByConversationIDNoGhostsStatement&quot;,</span>
<a href="#l26.2106"></a><span id="l26.2106" class="difflineplus">+      function() statement);</span>
<a href="#l26.2107"></a><span id="l26.2107" class="difflineplus">+    return this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l26.2108"></a><span id="l26.2108" class="difflineplus">+  },</span>
<a href="#l26.2109"></a><span id="l26.2109" class="difflineplus">+</span>
<a href="#l26.2110"></a><span id="l26.2110" class="difflineplus">+  /**</span>
<a href="#l26.2111"></a><span id="l26.2111" class="difflineplus">+   * Retrieve all the messages belonging to the given conversation.  This</span>
<a href="#l26.2112"></a><span id="l26.2112" class="difflineplus">+   *  method is used by the indexer and the GlodaConversation class and is not</span>
<a href="#l26.2113"></a><span id="l26.2113" class="difflineplus">+   *  intended to be used by any other code.  (Most other code should probably</span>
<a href="#l26.2114"></a><span id="l26.2114" class="difflineplus">+   *  use the GlodaConversation.messages attribute or the general purpose query</span>
<a href="#l26.2115"></a><span id="l26.2115" class="difflineplus">+   *  mechanism.)</span>
<a href="#l26.2116"></a><span id="l26.2116" class="difflineplus">+   *</span>
<a href="#l26.2117"></a><span id="l26.2117" class="difflineplus">+   * @param aConversationID The ID of the conversation for which you want all</span>
<a href="#l26.2118"></a><span id="l26.2118" class="difflineplus">+   *     the messages.</span>
<a href="#l26.2119"></a><span id="l26.2119" class="difflineplus">+   * @param aIncludeGhosts Boolean indicating whether you want 'ghost' messages</span>
<a href="#l26.2120"></a><span id="l26.2120" class="difflineplus">+   *     (true) or not (false).  'Ghost' messages are messages that exist in the</span>
<a href="#l26.2121"></a><span id="l26.2121" class="difflineplus">+   *     database purely for conversation tracking/threading purposes.  They</span>
<a href="#l26.2122"></a><span id="l26.2122" class="difflineplus">+   *     are markers for messages we have not yet seen yet assume must exist</span>
<a href="#l26.2123"></a><span id="l26.2123" class="difflineplus">+   *     based on references/in-reply-to headers from non-ghost messages in our</span>
<a href="#l26.2124"></a><span id="l26.2124" class="difflineplus">+   *     database.</span>
<a href="#l26.2125"></a><span id="l26.2125" class="difflineplus">+   */</span>
<a href="#l26.2126"></a><span id="l26.2126" class="difflineplus">+  getMessagesByConversationID: function gloda_ds_getMessagesByConversationID(</span>
<a href="#l26.2127"></a><span id="l26.2127" class="difflineplus">+        aConversationID, aIncludeGhosts) {</span>
<a href="#l26.2128"></a><span id="l26.2128" class="difflineplus">+    let statement;</span>
<a href="#l26.2129"></a><span id="l26.2129" class="difflineplus">+    if (aIncludeGhosts)</span>
<a href="#l26.2130"></a><span id="l26.2130" class="difflineplus">+      statement = this._selectMessagesByConversationIDStatement;</span>
<a href="#l26.2131"></a><span id="l26.2131" class="difflineplus">+    else</span>
<a href="#l26.2132"></a><span id="l26.2132" class="difflineplus">+      statement = this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l26.2133"></a><span id="l26.2133" class="difflineplus">+    statement.bindInt64Parameter(0, aConversationID);</span>
<a href="#l26.2134"></a><span id="l26.2134" class="difflineplus">+</span>
<a href="#l26.2135"></a><span id="l26.2135" class="difflineplus">+    let messages = [];</span>
<a href="#l26.2136"></a><span id="l26.2136" class="difflineplus">+    while (this._syncStep(statement)) {</span>
<a href="#l26.2137"></a><span id="l26.2137" class="difflineplus">+      messages.push(this._messageFromRow(statement));</span>
<a href="#l26.2138"></a><span id="l26.2138" class="difflineplus">+    }</span>
<a href="#l26.2139"></a><span id="l26.2139" class="difflineplus">+    statement.reset();</span>
<a href="#l26.2140"></a><span id="l26.2140" class="difflineplus">+</span>
<a href="#l26.2141"></a><span id="l26.2141" class="difflineplus">+    if (messages.length)</span>
<a href="#l26.2142"></a><span id="l26.2142" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l26.2143"></a><span id="l26.2143" class="difflineplus">+                                            messages);</span>
<a href="#l26.2144"></a><span id="l26.2144" class="difflineplus">+</span>
<a href="#l26.2145"></a><span id="l26.2145" class="difflineplus">+    return messages;</span>
<a href="#l26.2146"></a><span id="l26.2146" class="difflineplus">+  },</span>
<a href="#l26.2147"></a><span id="l26.2147" class="difflineplus">+</span>
<a href="#l26.2148"></a><span id="l26.2148" class="difflineplus">+  /* ********** Message Attributes ********** */</span>
<a href="#l26.2149"></a><span id="l26.2149" class="difflineplus">+  get _insertMessageAttributeStatement() {</span>
<a href="#l26.2150"></a><span id="l26.2150" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2151"></a><span id="l26.2151" class="difflineplus">+      &quot;INSERT INTO messageAttributes (conversationID, messageID, attributeID, \</span>
<a href="#l26.2152"></a><span id="l26.2152" class="difflineplus">+                             value) \</span>
<a href="#l26.2153"></a><span id="l26.2153" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l26.2154"></a><span id="l26.2154" class="difflineplus">+    this.__defineGetter__(&quot;_insertMessageAttributeStatement&quot;,</span>
<a href="#l26.2155"></a><span id="l26.2155" class="difflineplus">+      function() statement);</span>
<a href="#l26.2156"></a><span id="l26.2156" class="difflineplus">+    return this._insertMessageAttributeStatement;</span>
<a href="#l26.2157"></a><span id="l26.2157" class="difflineplus">+  },</span>
<a href="#l26.2158"></a><span id="l26.2158" class="difflineplus">+</span>
<a href="#l26.2159"></a><span id="l26.2159" class="difflineplus">+  get _deleteMessageAttributeStatement() {</span>
<a href="#l26.2160"></a><span id="l26.2160" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2161"></a><span id="l26.2161" class="difflineplus">+      &quot;DELETE FROM messageAttributes WHERE attributeID = ?1 AND value = ?2 \</span>
<a href="#l26.2162"></a><span id="l26.2162" class="difflineplus">+         AND conversationID = ?3 AND messageID = ?4&quot;);</span>
<a href="#l26.2163"></a><span id="l26.2163" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessageAttributeStatement&quot;,</span>
<a href="#l26.2164"></a><span id="l26.2164" class="difflineplus">+      function() statement);</span>
<a href="#l26.2165"></a><span id="l26.2165" class="difflineplus">+    return this._deleteMessageAttributeStatement;</span>
<a href="#l26.2166"></a><span id="l26.2166" class="difflineplus">+  },</span>
<a href="#l26.2167"></a><span id="l26.2167" class="difflineplus">+</span>
<a href="#l26.2168"></a><span id="l26.2168" class="difflineplus">+  /**</span>
<a href="#l26.2169"></a><span id="l26.2169" class="difflineplus">+   * Insert and remove attributes relating to a GlodaMessage.  This is performed</span>
<a href="#l26.2170"></a><span id="l26.2170" class="difflineplus">+   *  inside a pseudo-transaction (we create one if we aren't in one, using</span>
<a href="#l26.2171"></a><span id="l26.2171" class="difflineplus">+   *  our _beginTransaction wrapper, but if we are in one, no additional</span>
<a href="#l26.2172"></a><span id="l26.2172" class="difflineplus">+   *  meaningful semantics are added).</span>
<a href="#l26.2173"></a><span id="l26.2173" class="difflineplus">+   * No attempt is made to verify uniqueness of inserted attributes, either</span>
<a href="#l26.2174"></a><span id="l26.2174" class="difflineplus">+   *  against the current database or within the provided list of attributes.</span>
<a href="#l26.2175"></a><span id="l26.2175" class="difflineplus">+   *  The caller is responsible for ensuring that unwanted duplicates are</span>
<a href="#l26.2176"></a><span id="l26.2176" class="difflineplus">+   *  avoided.</span>
<a href="#l26.2177"></a><span id="l26.2177" class="difflineplus">+   *</span>
<a href="#l26.2178"></a><span id="l26.2178" class="difflineplus">+   * @param aMessage The GlodaMessage the attributes belong to.  This is used</span>
<a href="#l26.2179"></a><span id="l26.2179" class="difflineplus">+   *     to provide the message id and conversation id.</span>
<a href="#l26.2180"></a><span id="l26.2180" class="difflineplus">+   * @param aAddDBAttributes A list of attribute tuples to add, where each tuple</span>
<a href="#l26.2181"></a><span id="l26.2181" class="difflineplus">+   *     contains an attribute ID and a value.  Lest you forget, an attribute ID</span>
<a href="#l26.2182"></a><span id="l26.2182" class="difflineplus">+   *     corresponds to a row in the attribute definition table.  The attribute</span>
<a href="#l26.2183"></a><span id="l26.2183" class="difflineplus">+   *     definition table stores the 'parameter' for the attribute, if any.</span>
<a href="#l26.2184"></a><span id="l26.2184" class="difflineplus">+   *     (Which is to say, our frequent Attribute-Parameter-Value triple has</span>
<a href="#l26.2185"></a><span id="l26.2185" class="difflineplus">+   *     the Attribute-Parameter part distilled to a single attribute id.)</span>
<a href="#l26.2186"></a><span id="l26.2186" class="difflineplus">+   * @param aRemoveDBAttributes A list of attribute tuples to remove.</span>
<a href="#l26.2187"></a><span id="l26.2187" class="difflineplus">+   */</span>
<a href="#l26.2188"></a><span id="l26.2188" class="difflineplus">+  adjustMessageAttributes: function gloda_ds_adjustMessageAttributes(aMessage,</span>
<a href="#l26.2189"></a><span id="l26.2189" class="difflineplus">+                                        aAddDBAttributes, aRemoveDBAttributes) {</span>
<a href="#l26.2190"></a><span id="l26.2190" class="difflineplus">+    let imas = this._insertMessageAttributeStatement;</span>
<a href="#l26.2191"></a><span id="l26.2191" class="difflineplus">+    let dmas = this._deleteMessageAttributeStatement;</span>
<a href="#l26.2192"></a><span id="l26.2192" class="difflineplus">+    this._beginTransaction();</span>
<a href="#l26.2193"></a><span id="l26.2193" class="difflineplus">+    try {</span>
<a href="#l26.2194"></a><span id="l26.2194" class="difflineplus">+      for (let iAttrib = 0; iAttrib &lt; aAddDBAttributes.length; iAttrib++) {</span>
<a href="#l26.2195"></a><span id="l26.2195" class="difflineplus">+        let attribValueTuple = aAddDBAttributes[iAttrib];</span>
<a href="#l26.2196"></a><span id="l26.2196" class="difflineplus">+</span>
<a href="#l26.2197"></a><span id="l26.2197" class="difflineplus">+        imas.bindInt64Parameter(0, aMessage.conversationID);</span>
<a href="#l26.2198"></a><span id="l26.2198" class="difflineplus">+        imas.bindInt64Parameter(1, aMessage.id);</span>
<a href="#l26.2199"></a><span id="l26.2199" class="difflineplus">+        imas.bindInt64Parameter(2, attribValueTuple[0]);</span>
<a href="#l26.2200"></a><span id="l26.2200" class="difflineplus">+        // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l26.2201"></a><span id="l26.2201" class="difflineplus">+        //  really care anyways.)</span>
<a href="#l26.2202"></a><span id="l26.2202" class="difflineplus">+        if (attribValueTuple[1] == null)</span>
<a href="#l26.2203"></a><span id="l26.2203" class="difflineplus">+          imas.bindInt64Parameter(3, 0);</span>
<a href="#l26.2204"></a><span id="l26.2204" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l26.2205"></a><span id="l26.2205" class="difflineplus">+          imas.bindInt64Parameter(3, attribValueTuple[1]);</span>
<a href="#l26.2206"></a><span id="l26.2206" class="difflineplus">+        else</span>
<a href="#l26.2207"></a><span id="l26.2207" class="difflineplus">+          imas.bindDoubleParameter(3, attribValueTuple[1]);</span>
<a href="#l26.2208"></a><span id="l26.2208" class="difflineplus">+        imas.executeAsync(this.trackAsync());</span>
<a href="#l26.2209"></a><span id="l26.2209" class="difflineplus">+      }</span>
<a href="#l26.2210"></a><span id="l26.2210" class="difflineplus">+</span>
<a href="#l26.2211"></a><span id="l26.2211" class="difflineplus">+      for (let iAttrib = 0; iAttrib &lt; aRemoveDBAttributes.length; iAttrib++) {</span>
<a href="#l26.2212"></a><span id="l26.2212" class="difflineplus">+        let attribValueTuple = aRemoveDBAttributes[iAttrib];</span>
<a href="#l26.2213"></a><span id="l26.2213" class="difflineplus">+</span>
<a href="#l26.2214"></a><span id="l26.2214" class="difflineplus">+        dmas.bindInt64Parameter(0, attribValueTuple[0]);</span>
<a href="#l26.2215"></a><span id="l26.2215" class="difflineplus">+        // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l26.2216"></a><span id="l26.2216" class="difflineplus">+        //  really care anyways.)</span>
<a href="#l26.2217"></a><span id="l26.2217" class="difflineplus">+        if (attribValueTuple[1] == null)</span>
<a href="#l26.2218"></a><span id="l26.2218" class="difflineplus">+          dmas.bindInt64Parameter(1, 0);</span>
<a href="#l26.2219"></a><span id="l26.2219" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l26.2220"></a><span id="l26.2220" class="difflineplus">+          dmas.bindInt64Parameter(1, attribValueTuple[1]);</span>
<a href="#l26.2221"></a><span id="l26.2221" class="difflineplus">+        else</span>
<a href="#l26.2222"></a><span id="l26.2222" class="difflineplus">+          dmas.bindDoubleParameter(1, attribValueTuple[1]);</span>
<a href="#l26.2223"></a><span id="l26.2223" class="difflineplus">+        dmas.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l26.2224"></a><span id="l26.2224" class="difflineplus">+        dmas.bindInt64Parameter(3, aMessage.id);</span>
<a href="#l26.2225"></a><span id="l26.2225" class="difflineplus">+        dmas.executeAsync(this.trackAsync());</span>
<a href="#l26.2226"></a><span id="l26.2226" class="difflineplus">+      }</span>
<a href="#l26.2227"></a><span id="l26.2227" class="difflineplus">+</span>
<a href="#l26.2228"></a><span id="l26.2228" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l26.2229"></a><span id="l26.2229" class="difflineplus">+    }</span>
<a href="#l26.2230"></a><span id="l26.2230" class="difflineplus">+    catch (ex) {</span>
<a href="#l26.2231"></a><span id="l26.2231" class="difflineplus">+      this._log.error(&quot;adjustMessageAttributes:&quot; + ex.lineNumber + &quot;: &quot; + eX);</span>
<a href="#l26.2232"></a><span id="l26.2232" class="difflineplus">+      this._rollbackTransaction();</span>
<a href="#l26.2233"></a><span id="l26.2233" class="difflineplus">+      throw ex;</span>
<a href="#l26.2234"></a><span id="l26.2234" class="difflineplus">+    }</span>
<a href="#l26.2235"></a><span id="l26.2235" class="difflineplus">+  },</span>
<a href="#l26.2236"></a><span id="l26.2236" class="difflineplus">+</span>
<a href="#l26.2237"></a><span id="l26.2237" class="difflineplus">+  get _deleteMessageAttributesByMessageIDStatement() {</span>
<a href="#l26.2238"></a><span id="l26.2238" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2239"></a><span id="l26.2239" class="difflineplus">+      &quot;DELETE FROM messageAttributes WHERE messageID = ?1&quot;);</span>
<a href="#l26.2240"></a><span id="l26.2240" class="difflineplus">+    this.__defineGetter__(&quot;_deleteMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l26.2241"></a><span id="l26.2241" class="difflineplus">+      function() statement);</span>
<a href="#l26.2242"></a><span id="l26.2242" class="difflineplus">+    return this._deleteMessageAttributesByMessageIDStatement;</span>
<a href="#l26.2243"></a><span id="l26.2243" class="difflineplus">+  },</span>
<a href="#l26.2244"></a><span id="l26.2244" class="difflineplus">+</span>
<a href="#l26.2245"></a><span id="l26.2245" class="difflineplus">+  /**</span>
<a href="#l26.2246"></a><span id="l26.2246" class="difflineplus">+   * Clear all the message attributes for a given GlodaMessage.  No changes</span>
<a href="#l26.2247"></a><span id="l26.2247" class="difflineplus">+   *  are made to the in-memory representation of the message; it is up to the</span>
<a href="#l26.2248"></a><span id="l26.2248" class="difflineplus">+   *  caller to ensure that it handles things correctly.</span>
<a href="#l26.2249"></a><span id="l26.2249" class="difflineplus">+   *</span>
<a href="#l26.2250"></a><span id="l26.2250" class="difflineplus">+   * @param aMessage The GlodaMessage whose database attributes should be</span>
<a href="#l26.2251"></a><span id="l26.2251" class="difflineplus">+   *     purged.</span>
<a href="#l26.2252"></a><span id="l26.2252" class="difflineplus">+   */</span>
<a href="#l26.2253"></a><span id="l26.2253" class="difflineplus">+  clearMessageAttributes: function gloda_ds_clearMessageAttributes(aMessage) {</span>
<a href="#l26.2254"></a><span id="l26.2254" class="difflineplus">+    if (aMessage.id != null) {</span>
<a href="#l26.2255"></a><span id="l26.2255" class="difflineplus">+      this._deleteMessageAttributesByMessageIDStatement.bindInt64Parameter(0,</span>
<a href="#l26.2256"></a><span id="l26.2256" class="difflineplus">+        aMessage.id);</span>
<a href="#l26.2257"></a><span id="l26.2257" class="difflineplus">+      this._deleteMessageAttributesByMessageIDStatement.executeAsync(</span>
<a href="#l26.2258"></a><span id="l26.2258" class="difflineplus">+        this.trackAsync());</span>
<a href="#l26.2259"></a><span id="l26.2259" class="difflineplus">+    }</span>
<a href="#l26.2260"></a><span id="l26.2260" class="difflineplus">+  },</span>
<a href="#l26.2261"></a><span id="l26.2261" class="difflineplus">+</span>
<a href="#l26.2262"></a><span id="l26.2262" class="difflineplus">+  get _selectMessageAttributesByMessageIDStatement() {</span>
<a href="#l26.2263"></a><span id="l26.2263" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.2264"></a><span id="l26.2264" class="difflineplus">+      &quot;SELECT attributeID, value FROM messageAttributes \</span>
<a href="#l26.2265"></a><span id="l26.2265" class="difflineplus">+         WHERE messageID = ?1&quot;);</span>
<a href="#l26.2266"></a><span id="l26.2266" class="difflineplus">+    this.__defineGetter__(&quot;_selectMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l26.2267"></a><span id="l26.2267" class="difflineplus">+      function() statement);</span>
<a href="#l26.2268"></a><span id="l26.2268" class="difflineplus">+    return this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l26.2269"></a><span id="l26.2269" class="difflineplus">+  },</span>
<a href="#l26.2270"></a><span id="l26.2270" class="difflineplus">+</span>
<a href="#l26.2271"></a><span id="l26.2271" class="difflineplus">+  /**</span>
<a href="#l26.2272"></a><span id="l26.2272" class="difflineplus">+   * Look-up the attributes associated with the given GlodaMessage instance,</span>
<a href="#l26.2273"></a><span id="l26.2273" class="difflineplus">+   *  returning them in APV form (a tuple of Attribute definition object,</span>
<a href="#l26.2274"></a><span id="l26.2274" class="difflineplus">+   *  attribute Parameter, and attribute Value).</span>
<a href="#l26.2275"></a><span id="l26.2275" class="difflineplus">+   *</span>
<a href="#l26.2276"></a><span id="l26.2276" class="difflineplus">+   * @param aMessage The GlodaMessage whose attributes you want retrieved.</span>
<a href="#l26.2277"></a><span id="l26.2277" class="difflineplus">+   * @return An APV list of the attributes.</span>
<a href="#l26.2278"></a><span id="l26.2278" class="difflineplus">+   */</span>
<a href="#l26.2279"></a><span id="l26.2279" class="difflineplus">+  getMessageAttributes: function gloda_ds_getMessageAttributes(aMessage) {</span>
<a href="#l26.2280"></a><span id="l26.2280" class="difflineplus">+    // A list of [attribute def object, (attr) parameter value, attribute value]</span>
<a href="#l26.2281"></a><span id="l26.2281" class="difflineplus">+    let attribParamVals = []</span>
<a href="#l26.2282"></a><span id="l26.2282" class="difflineplus">+</span>
<a href="#l26.2283"></a><span id="l26.2283" class="difflineplus">+    let smas = this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l26.2284"></a><span id="l26.2284" class="difflineplus">+</span>
<a href="#l26.2285"></a><span id="l26.2285" class="difflineplus">+    smas.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l26.2286"></a><span id="l26.2286" class="difflineplus">+    while (this._syncStep(smas)) {</span>
<a href="#l26.2287"></a><span id="l26.2287" class="difflineplus">+      let attributeID = smas.getInt64(0);</span>
<a href="#l26.2288"></a><span id="l26.2288" class="difflineplus">+      if (!(attributeID in this._attributeIDToDBDefAndParam)) {</span>
<a href="#l26.2289"></a><span id="l26.2289" class="difflineplus">+        this._log.error(&quot;Attribute ID &quot; + attributeID + &quot; not in our map!&quot;);</span>
<a href="#l26.2290"></a><span id="l26.2290" class="difflineplus">+      }</span>
<a href="#l26.2291"></a><span id="l26.2291" class="difflineplus">+      let attribAndParam = this._attributeIDToDBDefAndParam[attributeID];</span>
<a href="#l26.2292"></a><span id="l26.2292" class="difflineplus">+      let val = smas.getDouble(1);</span>
<a href="#l26.2293"></a><span id="l26.2293" class="difflineplus">+      attribParamVals.push([attribAndParam[0], attribAndParam[1], val]);</span>
<a href="#l26.2294"></a><span id="l26.2294" class="difflineplus">+    }</span>
<a href="#l26.2295"></a><span id="l26.2295" class="difflineplus">+    smas.reset();</span>
<a href="#l26.2296"></a><span id="l26.2296" class="difflineplus">+</span>
<a href="#l26.2297"></a><span id="l26.2297" class="difflineplus">+    return attribParamVals;</span>
<a href="#l26.2298"></a><span id="l26.2298" class="difflineplus">+  },</span>
<a href="#l26.2299"></a><span id="l26.2299" class="difflineplus">+</span>
<a href="#l26.2300"></a><span id="l26.2300" class="difflineplus">+  _stringSQLQuoter: function(aString) {</span>
<a href="#l26.2301"></a><span id="l26.2301" class="difflineplus">+    return &quot;'&quot; + aString.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot;;</span>
<a href="#l26.2302"></a><span id="l26.2302" class="difflineplus">+  },</span>
<a href="#l26.2303"></a><span id="l26.2303" class="difflineplus">+  _numberQuoter: function(aNum) {</span>
<a href="#l26.2304"></a><span id="l26.2304" class="difflineplus">+    return aNum;</span>
<a href="#l26.2305"></a><span id="l26.2305" class="difflineplus">+  },</span>
<a href="#l26.2306"></a><span id="l26.2306" class="difflineplus">+</span>
<a href="#l26.2307"></a><span id="l26.2307" class="difflineplus">+  /* ===== Generic Attribute Support ===== */</span>
<a href="#l26.2308"></a><span id="l26.2308" class="difflineplus">+  adjustAttributes: function gloda_ds_adjustAttributes(aItem, aAddDBAttributes,</span>
<a href="#l26.2309"></a><span id="l26.2309" class="difflineplus">+      aRemoveDBAttributes) {</span>
<a href="#l26.2310"></a><span id="l26.2310" class="difflineplus">+    let nounDef = aItem.NOUN_DEF;</span>
<a href="#l26.2311"></a><span id="l26.2311" class="difflineplus">+    let dbMeta = nounDef._dbMeta;</span>
<a href="#l26.2312"></a><span id="l26.2312" class="difflineplus">+    if (dbMeta.insertAttrStatement === undefined) {</span>
<a href="#l26.2313"></a><span id="l26.2313" class="difflineplus">+      dbMeta.insertAttrStatement = this._createAsyncStatement(</span>
<a href="#l26.2314"></a><span id="l26.2314" class="difflineplus">+        &quot;INSERT INTO &quot; + nounDef.attrTableName +</span>
<a href="#l26.2315"></a><span id="l26.2315" class="difflineplus">+        &quot; (&quot; + nounDef.attrIDColumnName + &quot;, attributeID, value) &quot; +</span>
<a href="#l26.2316"></a><span id="l26.2316" class="difflineplus">+        &quot; VALUES (?1, ?2, ?3)&quot;);</span>
<a href="#l26.2317"></a><span id="l26.2317" class="difflineplus">+      // we always create this at the same time (right here), no need to check</span>
<a href="#l26.2318"></a><span id="l26.2318" class="difflineplus">+      dbMeta.deleteAttrStatement = this._createAsyncStatement(</span>
<a href="#l26.2319"></a><span id="l26.2319" class="difflineplus">+        &quot;DELETE FROM &quot; + nounDef.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l26.2320"></a><span id="l26.2320" class="difflineplus">+        &quot; attributeID = ?1 AND value = ?2 AND &quot; +</span>
<a href="#l26.2321"></a><span id="l26.2321" class="difflineplus">+        nounDef.attrIDColumnName + &quot; = ?3&quot;);</span>
<a href="#l26.2322"></a><span id="l26.2322" class="difflineplus">+    }</span>
<a href="#l26.2323"></a><span id="l26.2323" class="difflineplus">+</span>
<a href="#l26.2324"></a><span id="l26.2324" class="difflineplus">+    let ias = dbMeta.insertAttrStatement;</span>
<a href="#l26.2325"></a><span id="l26.2325" class="difflineplus">+    let das = dbMeta.deleteAttrStatement;</span>
<a href="#l26.2326"></a><span id="l26.2326" class="difflineplus">+    this._beginTransaction();</span>
<a href="#l26.2327"></a><span id="l26.2327" class="difflineplus">+    try {</span>
<a href="#l26.2328"></a><span id="l26.2328" class="difflineplus">+      for (let iAttr = 0; iAttr &lt; aAddDBAttributes.length; iAttr++) {</span>
<a href="#l26.2329"></a><span id="l26.2329" class="difflineplus">+        let attribValueTuple = aAddDBAttributes[iAttr];</span>
<a href="#l26.2330"></a><span id="l26.2330" class="difflineplus">+</span>
<a href="#l26.2331"></a><span id="l26.2331" class="difflineplus">+        ias.bindInt64Parameter(0, aItem.id);</span>
<a href="#l26.2332"></a><span id="l26.2332" class="difflineplus">+        ias.bindInt64Parameter(1, attribValueTuple[0]);</span>
<a href="#l26.2333"></a><span id="l26.2333" class="difflineplus">+        // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l26.2334"></a><span id="l26.2334" class="difflineplus">+        //  really care anyways.)</span>
<a href="#l26.2335"></a><span id="l26.2335" class="difflineplus">+        if (attribValueTuple[1] == null)</span>
<a href="#l26.2336"></a><span id="l26.2336" class="difflineplus">+          ias.bindInt64Parameter(2, 0);</span>
<a href="#l26.2337"></a><span id="l26.2337" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l26.2338"></a><span id="l26.2338" class="difflineplus">+          ias.bindInt64Parameter(2, attribValueTuple[1]);</span>
<a href="#l26.2339"></a><span id="l26.2339" class="difflineplus">+        else</span>
<a href="#l26.2340"></a><span id="l26.2340" class="difflineplus">+          ias.bindDoubleParameter(2, attribValueTuple[1]);</span>
<a href="#l26.2341"></a><span id="l26.2341" class="difflineplus">+        ias.executeAsync(this.trackAsync());</span>
<a href="#l26.2342"></a><span id="l26.2342" class="difflineplus">+      }</span>
<a href="#l26.2343"></a><span id="l26.2343" class="difflineplus">+</span>
<a href="#l26.2344"></a><span id="l26.2344" class="difflineplus">+      for (let iAttr = 0; iAttr &lt; aRemoveDBAttributes.length; iAttr++) {</span>
<a href="#l26.2345"></a><span id="l26.2345" class="difflineplus">+        let attribValueTuple = aRemoveDBAttributes[iAttr];</span>
<a href="#l26.2346"></a><span id="l26.2346" class="difflineplus">+</span>
<a href="#l26.2347"></a><span id="l26.2347" class="difflineplus">+        das.bindInt64Parameter(0, attribValueTuple[0]);</span>
<a href="#l26.2348"></a><span id="l26.2348" class="difflineplus">+        // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l26.2349"></a><span id="l26.2349" class="difflineplus">+        //  really care anyways.)</span>
<a href="#l26.2350"></a><span id="l26.2350" class="difflineplus">+        if (attribValueTuple[1] == null)</span>
<a href="#l26.2351"></a><span id="l26.2351" class="difflineplus">+          das.bindInt64Parameter(1, 0);</span>
<a href="#l26.2352"></a><span id="l26.2352" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l26.2353"></a><span id="l26.2353" class="difflineplus">+          das.bindInt64Parameter(1, attribValueTuple[1]);</span>
<a href="#l26.2354"></a><span id="l26.2354" class="difflineplus">+        else</span>
<a href="#l26.2355"></a><span id="l26.2355" class="difflineplus">+          das.bindDoubleParameter(1, attribValueTuple[1]);</span>
<a href="#l26.2356"></a><span id="l26.2356" class="difflineplus">+        das.bindInt64Parameter(2, aItem.id);</span>
<a href="#l26.2357"></a><span id="l26.2357" class="difflineplus">+        das.executeAsync(this.trackAsync());</span>
<a href="#l26.2358"></a><span id="l26.2358" class="difflineplus">+      }</span>
<a href="#l26.2359"></a><span id="l26.2359" class="difflineplus">+</span>
<a href="#l26.2360"></a><span id="l26.2360" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l26.2361"></a><span id="l26.2361" class="difflineplus">+    }</span>
<a href="#l26.2362"></a><span id="l26.2362" class="difflineplus">+    catch (ex) {</span>
<a href="#l26.2363"></a><span id="l26.2363" class="difflineplus">+      this._log.error(&quot;adjustAttributes:&quot; + ex.lineNumber + &quot;: &quot; + eX);</span>
<a href="#l26.2364"></a><span id="l26.2364" class="difflineplus">+      this._rollbackTransaction();</span>
<a href="#l26.2365"></a><span id="l26.2365" class="difflineplus">+      throw ex;</span>
<a href="#l26.2366"></a><span id="l26.2366" class="difflineplus">+    }</span>
<a href="#l26.2367"></a><span id="l26.2367" class="difflineplus">+  },</span>
<a href="#l26.2368"></a><span id="l26.2368" class="difflineplus">+</span>
<a href="#l26.2369"></a><span id="l26.2369" class="difflineplus">+  clearAttributes: function gloda_ds_clearAttributes(aItem) {</span>
<a href="#l26.2370"></a><span id="l26.2370" class="difflineplus">+    let nounDef = aItem.NOUN_DEF;</span>
<a href="#l26.2371"></a><span id="l26.2371" class="difflineplus">+    let dbMeta = nounMeta._dbMeta;</span>
<a href="#l26.2372"></a><span id="l26.2372" class="difflineplus">+    if (dbMeta.clearAttrStatement === undefined) {</span>
<a href="#l26.2373"></a><span id="l26.2373" class="difflineplus">+      dbMeta.clearAttrStatement = this._createAsyncStatement(</span>
<a href="#l26.2374"></a><span id="l26.2374" class="difflineplus">+        &quot;DELETE FROM &quot; + nounDef.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l26.2375"></a><span id="l26.2375" class="difflineplus">+        nounDef.attrIDColumnName + &quot; = ?1&quot;);</span>
<a href="#l26.2376"></a><span id="l26.2376" class="difflineplus">+    }</span>
<a href="#l26.2377"></a><span id="l26.2377" class="difflineplus">+  </span>
<a href="#l26.2378"></a><span id="l26.2378" class="difflineplus">+    if (aItem.id != null) {</span>
<a href="#l26.2379"></a><span id="l26.2379" class="difflineplus">+      dbMeta.clearAttrStatement.bindInt64Parameter(0, aItem.id);</span>
<a href="#l26.2380"></a><span id="l26.2380" class="difflineplus">+      dbMeta.clearAttrStatement.executeAsync(this.trackAsync());</span>
<a href="#l26.2381"></a><span id="l26.2381" class="difflineplus">+    }</span>
<a href="#l26.2382"></a><span id="l26.2382" class="difflineplus">+  },</span>
<a href="#l26.2383"></a><span id="l26.2383" class="difflineplus">+</span>
<a href="#l26.2384"></a><span id="l26.2384" class="difflineplus">+  /**</span>
<a href="#l26.2385"></a><span id="l26.2385" class="difflineplus">+   * escapeStringForLIKE is only available on statements, and sometimes we want</span>
<a href="#l26.2386"></a><span id="l26.2386" class="difflineplus">+   *  to use it before we create our statement, so we create a statement just</span>
<a href="#l26.2387"></a><span id="l26.2387" class="difflineplus">+   *  for this reason.</span>
<a href="#l26.2388"></a><span id="l26.2388" class="difflineplus">+   */</span>
<a href="#l26.2389"></a><span id="l26.2389" class="difflineplus">+  get _escapeLikeStatement() {</span>
<a href="#l26.2390"></a><span id="l26.2390" class="difflineplus">+    let statement = this._createAsyncStatement(&quot;SELECT 0&quot;);</span>
<a href="#l26.2391"></a><span id="l26.2391" class="difflineplus">+    this.__defineGetter__(&quot;_escapeLikeStatement&quot;, function() statement);</span>
<a href="#l26.2392"></a><span id="l26.2392" class="difflineplus">+    return this._escapeLikeStatement;</span>
<a href="#l26.2393"></a><span id="l26.2393" class="difflineplus">+  },</span>
<a href="#l26.2394"></a><span id="l26.2394" class="difflineplus">+</span>
<a href="#l26.2395"></a><span id="l26.2395" class="difflineplus">+  _convertToDBValuesAndGroupByAttributeID:</span>
<a href="#l26.2396"></a><span id="l26.2396" class="difflineplus">+    function gloda_ds__convertToDBValuesAndGroupByAttributeID(aAttrDef,</span>
<a href="#l26.2397"></a><span id="l26.2397" class="difflineplus">+                                                              aValues) {</span>
<a href="#l26.2398"></a><span id="l26.2398" class="difflineplus">+    let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l26.2399"></a><span id="l26.2399" class="difflineplus">+    if (!objectNounDef.usesParameter) {</span>
<a href="#l26.2400"></a><span id="l26.2400" class="difflineplus">+      let dbValues = [];</span>
<a href="#l26.2401"></a><span id="l26.2401" class="difflineplus">+      for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l26.2402"></a><span id="l26.2402" class="difflineplus">+        let dbValue = objectNounDef.toParamAndValue(aValues[iValue])[1];</span>
<a href="#l26.2403"></a><span id="l26.2403" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l26.2404"></a><span id="l26.2404" class="difflineplus">+          dbValues.push(dbValue);</span>
<a href="#l26.2405"></a><span id="l26.2405" class="difflineplus">+      }</span>
<a href="#l26.2406"></a><span id="l26.2406" class="difflineplus">+      yield [aAttrDef.special ? undefined : aAttrDef.id, dbValues];</span>
<a href="#l26.2407"></a><span id="l26.2407" class="difflineplus">+      return;</span>
<a href="#l26.2408"></a><span id="l26.2408" class="difflineplus">+    }</span>
<a href="#l26.2409"></a><span id="l26.2409" class="difflineplus">+    </span>
<a href="#l26.2410"></a><span id="l26.2410" class="difflineplus">+    let curParam, attrID, dbValues;</span>
<a href="#l26.2411"></a><span id="l26.2411" class="difflineplus">+    let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l26.2412"></a><span id="l26.2412" class="difflineplus">+    for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l26.2413"></a><span id="l26.2413" class="difflineplus">+      let [dbParam, dbValue] = objectNounDef.toParamAndValue(aValues[iValue]);</span>
<a href="#l26.2414"></a><span id="l26.2414" class="difflineplus">+      if (curParam === undefined) {</span>
<a href="#l26.2415"></a><span id="l26.2415" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l26.2416"></a><span id="l26.2416" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l26.2417"></a><span id="l26.2417" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l26.2418"></a><span id="l26.2418" class="difflineplus">+          dbValues = [dbValue];</span>
<a href="#l26.2419"></a><span id="l26.2419" class="difflineplus">+        else</span>
<a href="#l26.2420"></a><span id="l26.2420" class="difflineplus">+          dbValues = [];</span>
<a href="#l26.2421"></a><span id="l26.2421" class="difflineplus">+      }</span>
<a href="#l26.2422"></a><span id="l26.2422" class="difflineplus">+      else if (curParam == dbParam) {</span>
<a href="#l26.2423"></a><span id="l26.2423" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l26.2424"></a><span id="l26.2424" class="difflineplus">+          dbValues.push(dbValue);</span>
<a href="#l26.2425"></a><span id="l26.2425" class="difflineplus">+      }</span>
<a href="#l26.2426"></a><span id="l26.2426" class="difflineplus">+      else {</span>
<a href="#l26.2427"></a><span id="l26.2427" class="difflineplus">+        yield [attrID, dbValues];</span>
<a href="#l26.2428"></a><span id="l26.2428" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l26.2429"></a><span id="l26.2429" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l26.2430"></a><span id="l26.2430" class="difflineplus">+        if (dbValue != null)</span>
<a href="#l26.2431"></a><span id="l26.2431" class="difflineplus">+          dbValues = [dbValue];</span>
<a href="#l26.2432"></a><span id="l26.2432" class="difflineplus">+        else</span>
<a href="#l26.2433"></a><span id="l26.2433" class="difflineplus">+          dbValues = [];</span>
<a href="#l26.2434"></a><span id="l26.2434" class="difflineplus">+      }</span>
<a href="#l26.2435"></a><span id="l26.2435" class="difflineplus">+    }</span>
<a href="#l26.2436"></a><span id="l26.2436" class="difflineplus">+    if (dbValues !== undefined)</span>
<a href="#l26.2437"></a><span id="l26.2437" class="difflineplus">+      yield [attrID, dbValues];</span>
<a href="#l26.2438"></a><span id="l26.2438" class="difflineplus">+  },</span>
<a href="#l26.2439"></a><span id="l26.2439" class="difflineplus">+</span>
<a href="#l26.2440"></a><span id="l26.2440" class="difflineplus">+  _convertRangesToDBStringsAndGroupByAttributeID:</span>
<a href="#l26.2441"></a><span id="l26.2441" class="difflineplus">+    function gloda_ds__convertRangesToDBStringsAndGroupByAttributeID(aAttrDef,</span>
<a href="#l26.2442"></a><span id="l26.2442" class="difflineplus">+      aValues, aValueColumnName) {</span>
<a href="#l26.2443"></a><span id="l26.2443" class="difflineplus">+    let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l26.2444"></a><span id="l26.2444" class="difflineplus">+    if (!objectNounDef.usesParameter) {</span>
<a href="#l26.2445"></a><span id="l26.2445" class="difflineplus">+      let dbStrings = [];</span>
<a href="#l26.2446"></a><span id="l26.2446" class="difflineplus">+      for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l26.2447"></a><span id="l26.2447" class="difflineplus">+        let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l26.2448"></a><span id="l26.2448" class="difflineplus">+        // they both can't be null.  that is the law.</span>
<a href="#l26.2449"></a><span id="l26.2449" class="difflineplus">+        if (lowerVal == null)</span>
<a href="#l26.2450"></a><span id="l26.2450" class="difflineplus">+          dbStrings.push(aValueColumnName + &quot; &lt;= &quot; +</span>
<a href="#l26.2451"></a><span id="l26.2451" class="difflineplus">+                         objectNounDef.toParamAndValue(upperVal)[1]);</span>
<a href="#l26.2452"></a><span id="l26.2452" class="difflineplus">+        else if (upperVal == null)</span>
<a href="#l26.2453"></a><span id="l26.2453" class="difflineplus">+          dbStrings.push(aValueColumnName + &quot; &gt;= &quot; +</span>
<a href="#l26.2454"></a><span id="l26.2454" class="difflineplus">+                         objectNounDef.toParamAndValue(lowerVal)[1]);</span>
<a href="#l26.2455"></a><span id="l26.2455" class="difflineplus">+        else // no one is null!</span>
<a href="#l26.2456"></a><span id="l26.2456" class="difflineplus">+          dbStrings.push(aValueColumnName + &quot; BETWEEN &quot; +</span>
<a href="#l26.2457"></a><span id="l26.2457" class="difflineplus">+                         objectNounDef.toParamAndValue(lowerVal)[1] + &quot; AND &quot; +</span>
<a href="#l26.2458"></a><span id="l26.2458" class="difflineplus">+                         objectNounDef.toParamAndValue(upperVal)[1]);</span>
<a href="#l26.2459"></a><span id="l26.2459" class="difflineplus">+      }</span>
<a href="#l26.2460"></a><span id="l26.2460" class="difflineplus">+      yield [aAttrDef.special ? undefined : aAttrDef.id, dbStrings];</span>
<a href="#l26.2461"></a><span id="l26.2461" class="difflineplus">+      return;</span>
<a href="#l26.2462"></a><span id="l26.2462" class="difflineplus">+    }</span>
<a href="#l26.2463"></a><span id="l26.2463" class="difflineplus">+    </span>
<a href="#l26.2464"></a><span id="l26.2464" class="difflineplus">+    let curParam, attrID, dbStrings;</span>
<a href="#l26.2465"></a><span id="l26.2465" class="difflineplus">+    let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l26.2466"></a><span id="l26.2466" class="difflineplus">+    for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l26.2467"></a><span id="l26.2467" class="difflineplus">+      let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l26.2468"></a><span id="l26.2468" class="difflineplus">+</span>
<a href="#l26.2469"></a><span id="l26.2469" class="difflineplus">+      let dbString, dbParam, lowerDBVal, upperDBVal;</span>
<a href="#l26.2470"></a><span id="l26.2470" class="difflineplus">+      // they both can't be null.  that is the law.</span>
<a href="#l26.2471"></a><span id="l26.2471" class="difflineplus">+      if (lowerVal == null) {</span>
<a href="#l26.2472"></a><span id="l26.2472" class="difflineplus">+        [dbParam, upperDBVal] = objectNounDef.toParamAndValue(upperVal);</span>
<a href="#l26.2473"></a><span id="l26.2473" class="difflineplus">+        dbString = aValueColumnName + &quot; &lt;= &quot; + upperDBVal;</span>
<a href="#l26.2474"></a><span id="l26.2474" class="difflineplus">+      }</span>
<a href="#l26.2475"></a><span id="l26.2475" class="difflineplus">+      else if (upperVal == null) {</span>
<a href="#l26.2476"></a><span id="l26.2476" class="difflineplus">+        [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l26.2477"></a><span id="l26.2477" class="difflineplus">+        dbString = aValueColumnName + &quot; &gt;= &quot; + lowerDBVal; </span>
<a href="#l26.2478"></a><span id="l26.2478" class="difflineplus">+      }</span>
<a href="#l26.2479"></a><span id="l26.2479" class="difflineplus">+      else { // no one is null!</span>
<a href="#l26.2480"></a><span id="l26.2480" class="difflineplus">+        [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l26.2481"></a><span id="l26.2481" class="difflineplus">+        dbString = aValueColumnName + &quot; BETWEEN &quot; + lowerDBVal + &quot; AND &quot; +</span>
<a href="#l26.2482"></a><span id="l26.2482" class="difflineplus">+                   objectNounDef.toParamAndValue(upperVal)[1];</span>
<a href="#l26.2483"></a><span id="l26.2483" class="difflineplus">+      }</span>
<a href="#l26.2484"></a><span id="l26.2484" class="difflineplus">+</span>
<a href="#l26.2485"></a><span id="l26.2485" class="difflineplus">+      if (curParam === undefined) {</span>
<a href="#l26.2486"></a><span id="l26.2486" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l26.2487"></a><span id="l26.2487" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l26.2488"></a><span id="l26.2488" class="difflineplus">+        dbStrings = [dbString];</span>
<a href="#l26.2489"></a><span id="l26.2489" class="difflineplus">+      }</span>
<a href="#l26.2490"></a><span id="l26.2490" class="difflineplus">+      else if (curParam === dbParam) {</span>
<a href="#l26.2491"></a><span id="l26.2491" class="difflineplus">+        dbStrings.push(dbString);</span>
<a href="#l26.2492"></a><span id="l26.2492" class="difflineplus">+      }</span>
<a href="#l26.2493"></a><span id="l26.2493" class="difflineplus">+      else {</span>
<a href="#l26.2494"></a><span id="l26.2494" class="difflineplus">+        yield [attrID, dbStrings];</span>
<a href="#l26.2495"></a><span id="l26.2495" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l26.2496"></a><span id="l26.2496" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l26.2497"></a><span id="l26.2497" class="difflineplus">+        dbStrings = [dbString];</span>
<a href="#l26.2498"></a><span id="l26.2498" class="difflineplus">+      }</span>
<a href="#l26.2499"></a><span id="l26.2499" class="difflineplus">+    }</span>
<a href="#l26.2500"></a><span id="l26.2500" class="difflineplus">+    if (dbStrings !== undefined)</span>
<a href="#l26.2501"></a><span id="l26.2501" class="difflineplus">+      yield [attrID, dbStrings];</span>
<a href="#l26.2502"></a><span id="l26.2502" class="difflineplus">+  },</span>
<a href="#l26.2503"></a><span id="l26.2503" class="difflineplus">+</span>
<a href="#l26.2504"></a><span id="l26.2504" class="difflineplus">+  /**</span>
<a href="#l26.2505"></a><span id="l26.2505" class="difflineplus">+   * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l26.2506"></a><span id="l26.2506" class="difflineplus">+   *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l26.2507"></a><span id="l26.2507" class="difflineplus">+   *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l26.2508"></a><span id="l26.2508" class="difflineplus">+   *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l26.2509"></a><span id="l26.2509" class="difflineplus">+   *  its listener) as the state of the database changes.</span>
<a href="#l26.2510"></a><span id="l26.2510" class="difflineplus">+   * This functionality is made user/extension visible by the Query's</span>
<a href="#l26.2511"></a><span id="l26.2511" class="difflineplus">+   *  getCollection (asynchronous).</span>
<a href="#l26.2512"></a><span id="l26.2512" class="difflineplus">+   */</span>
<a href="#l26.2513"></a><span id="l26.2513" class="difflineplus">+  queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener,</span>
<a href="#l26.2514"></a><span id="l26.2514" class="difflineplus">+      aListenerData, aExistingCollection, aMasterCollection) {</span>
<a href="#l26.2515"></a><span id="l26.2515" class="difflineplus">+    // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l26.2516"></a><span id="l26.2516" class="difflineplus">+    //  likewise has its changes made.</span>
<a href="#l26.2517"></a><span id="l26.2517" class="difflineplus">+    let nounDef = aQuery._nounDef;</span>
<a href="#l26.2518"></a><span id="l26.2518" class="difflineplus">+</span>
<a href="#l26.2519"></a><span id="l26.2519" class="difflineplus">+    let whereClauses = [];</span>
<a href="#l26.2520"></a><span id="l26.2520" class="difflineplus">+    let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l26.2521"></a><span id="l26.2521" class="difflineplus">+    let boundArgs = [];</span>
<a href="#l26.2522"></a><span id="l26.2522" class="difflineplus">+</span>
<a href="#l26.2523"></a><span id="l26.2523" class="difflineplus">+    for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l26.2524"></a><span id="l26.2524" class="difflineplus">+      let curQuery = unionQueries[iUnion];</span>
<a href="#l26.2525"></a><span id="l26.2525" class="difflineplus">+      let selects = [];</span>
<a href="#l26.2526"></a><span id="l26.2526" class="difflineplus">+      </span>
<a href="#l26.2527"></a><span id="l26.2527" class="difflineplus">+      let lastConstraintWasSpecial = false;</span>
<a href="#l26.2528"></a><span id="l26.2528" class="difflineplus">+      let curConstraintIsSpecial;</span>
<a href="#l26.2529"></a><span id="l26.2529" class="difflineplus">+</span>
<a href="#l26.2530"></a><span id="l26.2530" class="difflineplus">+      for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length;</span>
<a href="#l26.2531"></a><span id="l26.2531" class="difflineplus">+           iConstraint++) {</span>
<a href="#l26.2532"></a><span id="l26.2532" class="difflineplus">+        let constraint = curQuery._constraints[iConstraint];</span>
<a href="#l26.2533"></a><span id="l26.2533" class="difflineplus">+        let [constraintType, attrDef] = constraint;</span>
<a href="#l26.2534"></a><span id="l26.2534" class="difflineplus">+        let constraintValues = constraint.slice(2);</span>
<a href="#l26.2535"></a><span id="l26.2535" class="difflineplus">+        </span>
<a href="#l26.2536"></a><span id="l26.2536" class="difflineplus">+        let idColumnName, tableColumnName;</span>
<a href="#l26.2537"></a><span id="l26.2537" class="difflineplus">+        if (constraintType == this.kConstraintIdIn) {</span>
<a href="#l26.2538"></a><span id="l26.2538" class="difflineplus">+          // we don't need any of the next cases' setup code, and we especially</span>
<a href="#l26.2539"></a><span id="l26.2539" class="difflineplus">+          //  would prefer that attrDef isn't accessed since it's null for us.</span>
<a href="#l26.2540"></a><span id="l26.2540" class="difflineplus">+        }</span>
<a href="#l26.2541"></a><span id="l26.2541" class="difflineplus">+        else if (attrDef.special) {</span>
<a href="#l26.2542"></a><span id="l26.2542" class="difflineplus">+          tableName = nounDef.tableName;</span>
<a href="#l26.2543"></a><span id="l26.2543" class="difflineplus">+          idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l26.2544"></a><span id="l26.2544" class="difflineplus">+          valueColumnName = attrDef.specialColumnName;</span>
<a href="#l26.2545"></a><span id="l26.2545" class="difflineplus">+          curConstraintIsSpecial = true;</span>
<a href="#l26.2546"></a><span id="l26.2546" class="difflineplus">+        }</span>
<a href="#l26.2547"></a><span id="l26.2547" class="difflineplus">+        else {</span>
<a href="#l26.2548"></a><span id="l26.2548" class="difflineplus">+          tableName = nounDef.attrTableName;</span>
<a href="#l26.2549"></a><span id="l26.2549" class="difflineplus">+          idColumnName = nounDef.attrIDColumnName;</span>
<a href="#l26.2550"></a><span id="l26.2550" class="difflineplus">+          valueColumnName = &quot;value&quot;;</span>
<a href="#l26.2551"></a><span id="l26.2551" class="difflineplus">+          curConstraintIsSpecial = false;</span>
<a href="#l26.2552"></a><span id="l26.2552" class="difflineplus">+        }</span>
<a href="#l26.2553"></a><span id="l26.2553" class="difflineplus">+        </span>
<a href="#l26.2554"></a><span id="l26.2554" class="difflineplus">+        let select = null, test = null, bindArgs = null;</span>
<a href="#l26.2555"></a><span id="l26.2555" class="difflineplus">+        if (constraintType === this.kConstraintIdIn) {</span>
<a href="#l26.2556"></a><span id="l26.2556" class="difflineplus">+          // this is somewhat of a trick.  this does mean that this can be the</span>
<a href="#l26.2557"></a><span id="l26.2557" class="difflineplus">+          //  only constraint.  Namely, our idiom is:</span>
<a href="#l26.2558"></a><span id="l26.2558" class="difflineplus">+          // SELECT * FROM blah WHERE id IN (a INTERSECT b INTERSECT c)</span>
<a href="#l26.2559"></a><span id="l26.2559" class="difflineplus">+          //  but if we only have 'a', then that becomes &quot;...IN (a)&quot;, and if</span>
<a href="#l26.2560"></a><span id="l26.2560" class="difflineplus">+          //  'a' is not a select but a list of id's... tricky, no?  </span>
<a href="#l26.2561"></a><span id="l26.2561" class="difflineplus">+          select = constraintValues.join(&quot;,&quot;);</span>
<a href="#l26.2562"></a><span id="l26.2562" class="difflineplus">+        }</span>
<a href="#l26.2563"></a><span id="l26.2563" class="difflineplus">+        else if (constraintType === this.kConstraintIn) {</span>
<a href="#l26.2564"></a><span id="l26.2564" class="difflineplus">+          let clauses = [];</span>
<a href="#l26.2565"></a><span id="l26.2565" class="difflineplus">+          for each ([attrID, values] in</span>
<a href="#l26.2566"></a><span id="l26.2566" class="difflineplus">+              this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l26.2567"></a><span id="l26.2567" class="difflineplus">+                                                           constraintValues)) {</span>
<a href="#l26.2568"></a><span id="l26.2568" class="difflineplus">+            let clausePart;</span>
<a href="#l26.2569"></a><span id="l26.2569" class="difflineplus">+            if (attrID !== undefined)</span>
<a href="#l26.2570"></a><span id="l26.2570" class="difflineplus">+              clausePart = &quot;(attributeID = &quot; + attrID +</span>
<a href="#l26.2571"></a><span id="l26.2571" class="difflineplus">+                (values.length ? &quot; AND &quot; : &quot;&quot;);</span>
<a href="#l26.2572"></a><span id="l26.2572" class="difflineplus">+            else</span>
<a href="#l26.2573"></a><span id="l26.2573" class="difflineplus">+              clausePart = &quot;(&quot;;</span>
<a href="#l26.2574"></a><span id="l26.2574" class="difflineplus">+            if (values.length)</span>
<a href="#l26.2575"></a><span id="l26.2575" class="difflineplus">+              clausePart += valueColumnName + &quot; IN (&quot; + values.join(&quot;,&quot;) + &quot;))&quot;;</span>
<a href="#l26.2576"></a><span id="l26.2576" class="difflineplus">+            else</span>
<a href="#l26.2577"></a><span id="l26.2577" class="difflineplus">+              clausePart += &quot;)&quot;;</span>
<a href="#l26.2578"></a><span id="l26.2578" class="difflineplus">+            clauses.push(clausePart);</span>
<a href="#l26.2579"></a><span id="l26.2579" class="difflineplus">+          }</span>
<a href="#l26.2580"></a><span id="l26.2580" class="difflineplus">+          test = clauses.join(&quot; OR &quot;);</span>
<a href="#l26.2581"></a><span id="l26.2581" class="difflineplus">+        }</span>
<a href="#l26.2582"></a><span id="l26.2582" class="difflineplus">+        else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l26.2583"></a><span id="l26.2583" class="difflineplus">+          let clauses = [];</span>
<a href="#l26.2584"></a><span id="l26.2584" class="difflineplus">+          for each ([attrID, dbStrings] in</span>
<a href="#l26.2585"></a><span id="l26.2585" class="difflineplus">+              this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l26.2586"></a><span id="l26.2586" class="difflineplus">+                              constraintValues, valueColumnName)) {</span>
<a href="#l26.2587"></a><span id="l26.2587" class="difflineplus">+            if (attrID !== undefined)</span>
<a href="#l26.2588"></a><span id="l26.2588" class="difflineplus">+              clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l26.2589"></a><span id="l26.2589" class="difflineplus">+                           &quot; AND (&quot; + dbStrings.join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l26.2590"></a><span id="l26.2590" class="difflineplus">+            else</span>
<a href="#l26.2591"></a><span id="l26.2591" class="difflineplus">+              clauses.push(&quot;(&quot; + dbStrings.join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l26.2592"></a><span id="l26.2592" class="difflineplus">+          }</span>
<a href="#l26.2593"></a><span id="l26.2593" class="difflineplus">+          test = clauses.join(&quot; OR &quot;);</span>
<a href="#l26.2594"></a><span id="l26.2594" class="difflineplus">+        }</span>
<a href="#l26.2595"></a><span id="l26.2595" class="difflineplus">+        else if (constraintType === this.kConstraintEquals) {</span>
<a href="#l26.2596"></a><span id="l26.2596" class="difflineplus">+          let clauses = [];</span>
<a href="#l26.2597"></a><span id="l26.2597" class="difflineplus">+          for each ([attrID, values] in</span>
<a href="#l26.2598"></a><span id="l26.2598" class="difflineplus">+              this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l26.2599"></a><span id="l26.2599" class="difflineplus">+                                                           constraintValues)) {</span>
<a href="#l26.2600"></a><span id="l26.2600" class="difflineplus">+            if (attrID !== undefined)</span>
<a href="#l26.2601"></a><span id="l26.2601" class="difflineplus">+              clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l26.2602"></a><span id="l26.2602" class="difflineplus">+                  &quot; AND (&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l26.2603"></a><span id="l26.2603" class="difflineplus">+                  (value in values)].join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l26.2604"></a><span id="l26.2604" class="difflineplus">+            else</span>
<a href="#l26.2605"></a><span id="l26.2605" class="difflineplus">+              clauses.push(&quot;(&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l26.2606"></a><span id="l26.2606" class="difflineplus">+                  (value in values)].join(&quot; OR &quot;) + &quot;)&quot;);</span>
<a href="#l26.2607"></a><span id="l26.2607" class="difflineplus">+            boundArgs.push.apply(boundArgs, values);</span>
<a href="#l26.2608"></a><span id="l26.2608" class="difflineplus">+          }</span>
<a href="#l26.2609"></a><span id="l26.2609" class="difflineplus">+          test = clauses.join(&quot; OR &quot;);</span>
<a href="#l26.2610"></a><span id="l26.2610" class="difflineplus">+        }</span>
<a href="#l26.2611"></a><span id="l26.2611" class="difflineplus">+        else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l26.2612"></a><span id="l26.2612" class="difflineplus">+          likePayload = '';</span>
<a href="#l26.2613"></a><span id="l26.2613" class="difflineplus">+          for each (let [iValuePart, valuePart] in Iterator(constraintValues)) {</span>
<a href="#l26.2614"></a><span id="l26.2614" class="difflineplus">+            if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l26.2615"></a><span id="l26.2615" class="difflineplus">+              likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l26.2616"></a><span id="l26.2616" class="difflineplus">+                valuePart, &quot;/&quot;);</span>
<a href="#l26.2617"></a><span id="l26.2617" class="difflineplus">+            else</span>
<a href="#l26.2618"></a><span id="l26.2618" class="difflineplus">+              likePayload += &quot;%&quot;;</span>
<a href="#l26.2619"></a><span id="l26.2619" class="difflineplus">+          }</span>
<a href="#l26.2620"></a><span id="l26.2620" class="difflineplus">+          test = valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;;</span>
<a href="#l26.2621"></a><span id="l26.2621" class="difflineplus">+          boundArgs.push(likePayload);</span>
<a href="#l26.2622"></a><span id="l26.2622" class="difflineplus">+        }</span>
<a href="#l26.2623"></a><span id="l26.2623" class="difflineplus">+        else if (constraintType === this.kConstraintFulltext) {</span>
<a href="#l26.2624"></a><span id="l26.2624" class="difflineplus">+          let matchStr = constraintValues[0];</span>
<a href="#l26.2625"></a><span id="l26.2625" class="difflineplus">+          select = &quot;SELECT docid FROM &quot; + nounDef.tableName + &quot;Text&quot; +</span>
<a href="#l26.2626"></a><span id="l26.2626" class="difflineplus">+            &quot; WHERE &quot; + attrDef.specialColumnName + &quot; MATCH ?&quot;;</span>
<a href="#l26.2627"></a><span id="l26.2627" class="difflineplus">+          boundArgs.push(matchStr);</span>
<a href="#l26.2628"></a><span id="l26.2628" class="difflineplus">+        }</span>
<a href="#l26.2629"></a><span id="l26.2629" class="difflineplus">+        </span>
<a href="#l26.2630"></a><span id="l26.2630" class="difflineplus">+        if (curConstraintIsSpecial &amp;&amp; lastConstraintWasSpecial &amp;&amp; test) {</span>
<a href="#l26.2631"></a><span id="l26.2631" class="difflineplus">+          selects[selects.length-1] += &quot; AND &quot; + test;</span>
<a href="#l26.2632"></a><span id="l26.2632" class="difflineplus">+        }</span>
<a href="#l26.2633"></a><span id="l26.2633" class="difflineplus">+        else if (select)</span>
<a href="#l26.2634"></a><span id="l26.2634" class="difflineplus">+          selects.push(select)</span>
<a href="#l26.2635"></a><span id="l26.2635" class="difflineplus">+        else if (test) {</span>
<a href="#l26.2636"></a><span id="l26.2636" class="difflineplus">+          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName + &quot; WHERE &quot; +</span>
<a href="#l26.2637"></a><span id="l26.2637" class="difflineplus">+              test;</span>
<a href="#l26.2638"></a><span id="l26.2638" class="difflineplus">+          selects.push(select);</span>
<a href="#l26.2639"></a><span id="l26.2639" class="difflineplus">+        }</span>
<a href="#l26.2640"></a><span id="l26.2640" class="difflineplus">+        else</span>
<a href="#l26.2641"></a><span id="l26.2641" class="difflineplus">+          this._log.warning(&quot;Unable to translate constraint of type &quot; + </span>
<a href="#l26.2642"></a><span id="l26.2642" class="difflineplus">+            constraintType + &quot; on attribute bound as &quot; + aAttrDef.boundName);</span>
<a href="#l26.2643"></a><span id="l26.2643" class="difflineplus">+</span>
<a href="#l26.2644"></a><span id="l26.2644" class="difflineplus">+        lastConstraintWasSpecial = curConstraintIsSpecial;</span>
<a href="#l26.2645"></a><span id="l26.2645" class="difflineplus">+      }</span>
<a href="#l26.2646"></a><span id="l26.2646" class="difflineplus">+</span>
<a href="#l26.2647"></a><span id="l26.2647" class="difflineplus">+      if (selects.length)</span>
<a href="#l26.2648"></a><span id="l26.2648" class="difflineplus">+        whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot;)&quot;);</span>
<a href="#l26.2649"></a><span id="l26.2649" class="difflineplus">+    }</span>
<a href="#l26.2650"></a><span id="l26.2650" class="difflineplus">+</span>
<a href="#l26.2651"></a><span id="l26.2651" class="difflineplus">+    let sqlString = &quot;SELECT * FROM &quot; + nounDef.tableName;</span>
<a href="#l26.2652"></a><span id="l26.2652" class="difflineplus">+    if (whereClauses.length)</span>
<a href="#l26.2653"></a><span id="l26.2653" class="difflineplus">+      sqlString += &quot; WHERE &quot; + whereClauses.join(&quot; OR &quot;);</span>
<a href="#l26.2654"></a><span id="l26.2654" class="difflineplus">+    </span>
<a href="#l26.2655"></a><span id="l26.2655" class="difflineplus">+    if (aQuery._order.length) {</span>
<a href="#l26.2656"></a><span id="l26.2656" class="difflineplus">+      let orderClauses = [];</span>
<a href="#l26.2657"></a><span id="l26.2657" class="difflineplus">+      for (let [, colName] in Iterator(aQuery._order)) {</span>
<a href="#l26.2658"></a><span id="l26.2658" class="difflineplus">+         if (colName[0] == &quot;-&quot;)</span>
<a href="#l26.2659"></a><span id="l26.2659" class="difflineplus">+           orderClauses.push(colName.substring(1) + &quot; DESC&quot;);</span>
<a href="#l26.2660"></a><span id="l26.2660" class="difflineplus">+         else</span>
<a href="#l26.2661"></a><span id="l26.2661" class="difflineplus">+           orderClauses.push(colName + &quot; ASC&quot;);</span>
<a href="#l26.2662"></a><span id="l26.2662" class="difflineplus">+      }</span>
<a href="#l26.2663"></a><span id="l26.2663" class="difflineplus">+      sqlString += &quot; ORDER BY &quot; + orderClauses.join(&quot;, &quot;);</span>
<a href="#l26.2664"></a><span id="l26.2664" class="difflineplus">+    }</span>
<a href="#l26.2665"></a><span id="l26.2665" class="difflineplus">+    </span>
<a href="#l26.2666"></a><span id="l26.2666" class="difflineplus">+    if (aQuery._limit) {</span>
<a href="#l26.2667"></a><span id="l26.2667" class="difflineplus">+      sqlString += &quot; LIMIT ?&quot;;</span>
<a href="#l26.2668"></a><span id="l26.2668" class="difflineplus">+      boundArgs.push(aQuery._limit); </span>
<a href="#l26.2669"></a><span id="l26.2669" class="difflineplus">+    }</span>
<a href="#l26.2670"></a><span id="l26.2670" class="difflineplus">+</span>
<a href="#l26.2671"></a><span id="l26.2671" class="difflineplus">+    this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString + &quot; ARGS: &quot; + boundArgs);</span>
<a href="#l26.2672"></a><span id="l26.2672" class="difflineplus">+    </span>
<a href="#l26.2673"></a><span id="l26.2673" class="difflineplus">+    return this._queryFromSQLString(sqlString, boundArgs, nounDef, aQuery,</span>
<a href="#l26.2674"></a><span id="l26.2674" class="difflineplus">+        aListener, aListenerData, aExistingCollection, aMasterCollection);</span>
<a href="#l26.2675"></a><span id="l26.2675" class="difflineplus">+  },</span>
<a href="#l26.2676"></a><span id="l26.2676" class="difflineplus">+  </span>
<a href="#l26.2677"></a><span id="l26.2677" class="difflineplus">+  _queryFromSQLString: function gloda_ds__queryFromSQLString(aSqlString,</span>
<a href="#l26.2678"></a><span id="l26.2678" class="difflineplus">+      aBoundArgs, aNounDef, aQuery, aListener, aListenerData,</span>
<a href="#l26.2679"></a><span id="l26.2679" class="difflineplus">+      aExistingCollection, aMasterCollection) {</span>
<a href="#l26.2680"></a><span id="l26.2680" class="difflineplus">+    let statement = this._createAsyncStatement(aSqlString, true);</span>
<a href="#l26.2681"></a><span id="l26.2681" class="difflineplus">+    for (let [iBinding, bindingValue] in Iterator(aBoundArgs)) {</span>
<a href="#l26.2682"></a><span id="l26.2682" class="difflineplus">+      this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l26.2683"></a><span id="l26.2683" class="difflineplus">+    }</span>
<a href="#l26.2684"></a><span id="l26.2684" class="difflineplus">+</span>
<a href="#l26.2685"></a><span id="l26.2685" class="difflineplus">+    let collection;</span>
<a href="#l26.2686"></a><span id="l26.2686" class="difflineplus">+    if (aExistingCollection)</span>
<a href="#l26.2687"></a><span id="l26.2687" class="difflineplus">+      collection = aExistingCollection;</span>
<a href="#l26.2688"></a><span id="l26.2688" class="difflineplus">+    else {</span>
<a href="#l26.2689"></a><span id="l26.2689" class="difflineplus">+      collection = new GlodaCollection(aNounDef, [], aQuery, aListener,</span>
<a href="#l26.2690"></a><span id="l26.2690" class="difflineplus">+                                       aMasterCollection);</span>
<a href="#l26.2691"></a><span id="l26.2691" class="difflineplus">+      GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l26.2692"></a><span id="l26.2692" class="difflineplus">+      // we don't want to overwrite the existing listener or its data, but this</span>
<a href="#l26.2693"></a><span id="l26.2693" class="difflineplus">+      //  does raise the question about what should happen if we get passed in</span>
<a href="#l26.2694"></a><span id="l26.2694" class="difflineplus">+      //  a different listener and/or data.</span>
<a href="#l26.2695"></a><span id="l26.2695" class="difflineplus">+      if (aListenerData !== undefined)</span>
<a href="#l26.2696"></a><span id="l26.2696" class="difflineplus">+        collection.data = aListenerData;</span>
<a href="#l26.2697"></a><span id="l26.2697" class="difflineplus">+    }</span>
<a href="#l26.2698"></a><span id="l26.2698" class="difflineplus">+    if (aListenerData) {</span>
<a href="#l26.2699"></a><span id="l26.2699" class="difflineplus">+      if (collection.dataStack)</span>
<a href="#l26.2700"></a><span id="l26.2700" class="difflineplus">+        collection.dataStack.push(aListenerData)</span>
<a href="#l26.2701"></a><span id="l26.2701" class="difflineplus">+      else</span>
<a href="#l26.2702"></a><span id="l26.2702" class="difflineplus">+        collection.dataStack = [aListenerData];</span>
<a href="#l26.2703"></a><span id="l26.2703" class="difflineplus">+    }</span>
<a href="#l26.2704"></a><span id="l26.2704" class="difflineplus">+</span>
<a href="#l26.2705"></a><span id="l26.2705" class="difflineplus">+    statement.executeAsync(new QueryFromQueryCallback(statement, aNounDef,</span>
<a href="#l26.2706"></a><span id="l26.2706" class="difflineplus">+      collection));</span>
<a href="#l26.2707"></a><span id="l26.2707" class="difflineplus">+    statement.finalize();</span>
<a href="#l26.2708"></a><span id="l26.2708" class="difflineplus">+    return collection;</span>
<a href="#l26.2709"></a><span id="l26.2709" class="difflineplus">+  },</span>
<a href="#l26.2710"></a><span id="l26.2710" class="difflineplus">+</span>
<a href="#l26.2711"></a><span id="l26.2711" class="difflineplus">+  /**</span>
<a href="#l26.2712"></a><span id="l26.2712" class="difflineplus">+   * </span>
<a href="#l26.2713"></a><span id="l26.2713" class="difflineplus">+   * </span>
<a href="#l26.2714"></a><span id="l26.2714" class="difflineplus">+   */</span>
<a href="#l26.2715"></a><span id="l26.2715" class="difflineplus">+  loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID,</span>
<a href="#l26.2716"></a><span id="l26.2716" class="difflineplus">+      aInverseReferencesByNounID) {</span>
<a href="#l26.2717"></a><span id="l26.2717" class="difflineplus">+    let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l26.2718"></a><span id="l26.2718" class="difflineplus">+    </span>
<a href="#l26.2719"></a><span id="l26.2719" class="difflineplus">+    let hadDeps = aItem._deps != null;</span>
<a href="#l26.2720"></a><span id="l26.2720" class="difflineplus">+    let deps = aItem._deps || {};</span>
<a href="#l26.2721"></a><span id="l26.2721" class="difflineplus">+    let hasDeps = false;</span>
<a href="#l26.2722"></a><span id="l26.2722" class="difflineplus">+    </span>
<a href="#l26.2723"></a><span id="l26.2723" class="difflineplus">+    //this._log.debug(&quot;  hadDeps: &quot; + hadDeps + &quot; deps: &quot; + </span>
<a href="#l26.2724"></a><span id="l26.2724" class="difflineplus">+    //    Log4Moz.enumerateProperties(deps).join(&quot;,&quot;));</span>
<a href="#l26.2725"></a><span id="l26.2725" class="difflineplus">+    </span>
<a href="#l26.2726"></a><span id="l26.2726" class="difflineplus">+    for each (let [, attrib] in Iterator(aItem.NOUN_DEF.specialLoadAttribs)) {</span>
<a href="#l26.2727"></a><span id="l26.2727" class="difflineplus">+      let objectNounDef = attrib.objectNounDef;</span>
<a href="#l26.2728"></a><span id="l26.2728" class="difflineplus">+      </span>
<a href="#l26.2729"></a><span id="l26.2729" class="difflineplus">+      if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l26.2730"></a><span id="l26.2730" class="difflineplus">+        let invReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l26.2731"></a><span id="l26.2731" class="difflineplus">+        if (invReferences === undefined)</span>
<a href="#l26.2732"></a><span id="l26.2732" class="difflineplus">+          invReferences = aInverseReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l26.2733"></a><span id="l26.2733" class="difflineplus">+        // only contribute if it's not already pending or there</span>
<a href="#l26.2734"></a><span id="l26.2734" class="difflineplus">+        if (!(attrib.id in deps) &amp;&amp; aItem[attrib.storageAttributeName] == null){</span>
<a href="#l26.2735"></a><span id="l26.2735" class="difflineplus">+          //this._log.debug(&quot;   Adding inv ref for: &quot; + aItem.id);</span>
<a href="#l26.2736"></a><span id="l26.2736" class="difflineplus">+          if (!(aItem.id in invReferences))</span>
<a href="#l26.2737"></a><span id="l26.2737" class="difflineplus">+            invReferences[aItem.id] = null;</span>
<a href="#l26.2738"></a><span id="l26.2738" class="difflineplus">+          deps[attrib.id] = null;</span>
<a href="#l26.2739"></a><span id="l26.2739" class="difflineplus">+          hasDeps = true;</span>
<a href="#l26.2740"></a><span id="l26.2740" class="difflineplus">+        }</span>
<a href="#l26.2741"></a><span id="l26.2741" class="difflineplus">+      }</span>
<a href="#l26.2742"></a><span id="l26.2742" class="difflineplus">+      else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l26.2743"></a><span id="l26.2743" class="difflineplus">+        let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l26.2744"></a><span id="l26.2744" class="difflineplus">+        if (references === undefined)</span>
<a href="#l26.2745"></a><span id="l26.2745" class="difflineplus">+          references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l26.2746"></a><span id="l26.2746" class="difflineplus">+        // nothing to contribute if it's already there</span>
<a href="#l26.2747"></a><span id="l26.2747" class="difflineplus">+        if (!(attrib.id in deps) &amp;&amp; </span>
<a href="#l26.2748"></a><span id="l26.2748" class="difflineplus">+            aItem[attrib.valueStorageAttributeName] == null) {</span>
<a href="#l26.2749"></a><span id="l26.2749" class="difflineplus">+          let parentID = aItem[attrib.idStorageAttributeName];</span>
<a href="#l26.2750"></a><span id="l26.2750" class="difflineplus">+          if (!(parentID in references))</span>
<a href="#l26.2751"></a><span id="l26.2751" class="difflineplus">+            references[parentID] = null;</span>
<a href="#l26.2752"></a><span id="l26.2752" class="difflineplus">+          //this._log.debug(&quot;   Adding parent ref for: &quot; +</span>
<a href="#l26.2753"></a><span id="l26.2753" class="difflineplus">+          //  aItem[attrib.idStorageAttributeName]);</span>
<a href="#l26.2754"></a><span id="l26.2754" class="difflineplus">+          deps[attrib.id] = null;</span>
<a href="#l26.2755"></a><span id="l26.2755" class="difflineplus">+          hasDeps = true;</span>
<a href="#l26.2756"></a><span id="l26.2756" class="difflineplus">+        }</span>
<a href="#l26.2757"></a><span id="l26.2757" class="difflineplus">+        else {</span>
<a href="#l26.2758"></a><span id="l26.2758" class="difflineplus">+          this._log.debug(&quot;  paranoia value storage: &quot; + aItem[attrib.valueStorageAttributeName]);</span>
<a href="#l26.2759"></a><span id="l26.2759" class="difflineplus">+        }</span>
<a href="#l26.2760"></a><span id="l26.2760" class="difflineplus">+      }</span>
<a href="#l26.2761"></a><span id="l26.2761" class="difflineplus">+    }</span>
<a href="#l26.2762"></a><span id="l26.2762" class="difflineplus">+    </span>
<a href="#l26.2763"></a><span id="l26.2763" class="difflineplus">+    // bail here if arbitrary values are not allowed, there just is no</span>
<a href="#l26.2764"></a><span id="l26.2764" class="difflineplus">+    //  encoded json, or we already had dependencies for this guy, implying</span>
<a href="#l26.2765"></a><span id="l26.2765" class="difflineplus">+    //  the json pass has already been performed</span>
<a href="#l26.2766"></a><span id="l26.2766" class="difflineplus">+    if (!aItem.NOUN_DEF.allowsArbitraryAttrs || !aItem._jsonText || hadDeps) {</span>
<a href="#l26.2767"></a><span id="l26.2767" class="difflineplus">+      if (hasDeps)</span>
<a href="#l26.2768"></a><span id="l26.2768" class="difflineplus">+        aItem._deps = deps;</span>
<a href="#l26.2769"></a><span id="l26.2769" class="difflineplus">+      return hasDeps;</span>
<a href="#l26.2770"></a><span id="l26.2770" class="difflineplus">+    }</span>
<a href="#l26.2771"></a><span id="l26.2771" class="difflineplus">+</span>
<a href="#l26.2772"></a><span id="l26.2772" class="difflineplus">+    //this._log.debug(&quot; load json: &quot; + aItem._jsonText);</span>
<a href="#l26.2773"></a><span id="l26.2773" class="difflineplus">+    let jsonDict = this._json.decode(aItem._jsonText);</span>
<a href="#l26.2774"></a><span id="l26.2774" class="difflineplus">+    delete aItem._jsonText;</span>
<a href="#l26.2775"></a><span id="l26.2775" class="difflineplus">+    </span>
<a href="#l26.2776"></a><span id="l26.2776" class="difflineplus">+    // Iterate over the attributes on the item</span>
<a href="#l26.2777"></a><span id="l26.2777" class="difflineplus">+    for each (let [attribId, jsonValue] in Iterator(jsonDict)) {</span>
<a href="#l26.2778"></a><span id="l26.2778" class="difflineplus">+      // find the attribute definition that corresponds to this key</span>
<a href="#l26.2779"></a><span id="l26.2779" class="difflineplus">+      let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l26.2780"></a><span id="l26.2780" class="difflineplus">+      // the attribute should only fail to exist if an extension was removed</span>
<a href="#l26.2781"></a><span id="l26.2781" class="difflineplus">+      if (dbAttrib === undefined)</span>
<a href="#l26.2782"></a><span id="l26.2782" class="difflineplus">+        continue;</span>
<a href="#l26.2783"></a><span id="l26.2783" class="difflineplus">+      </span>
<a href="#l26.2784"></a><span id="l26.2784" class="difflineplus">+      let attrib = dbAttrib.attrDef;</span>
<a href="#l26.2785"></a><span id="l26.2785" class="difflineplus">+      let objectNounDef = attrib.objectNounDef;</span>
<a href="#l26.2786"></a><span id="l26.2786" class="difflineplus">+      </span>
<a href="#l26.2787"></a><span id="l26.2787" class="difflineplus">+      // if it has a tableName member, then it's a persistent object that needs</span>
<a href="#l26.2788"></a><span id="l26.2788" class="difflineplus">+      //  to be loaded, which also means we need to hold it in a collection</span>
<a href="#l26.2789"></a><span id="l26.2789" class="difflineplus">+      //  owned by our collection.</span>
<a href="#l26.2790"></a><span id="l26.2790" class="difflineplus">+      if (objectNounDef.tableName) {</span>
<a href="#l26.2791"></a><span id="l26.2791" class="difflineplus">+        let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l26.2792"></a><span id="l26.2792" class="difflineplus">+        if (references === undefined)</span>
<a href="#l26.2793"></a><span id="l26.2793" class="difflineplus">+          references = aReferencesByNounID[objectNounDef.id] = {};</span>
<a href="#l26.2794"></a><span id="l26.2794" class="difflineplus">+          </span>
<a href="#l26.2795"></a><span id="l26.2795" class="difflineplus">+        if (attrib.singular) {</span>
<a href="#l26.2796"></a><span id="l26.2796" class="difflineplus">+          if (!(jsonValue in references))</span>
<a href="#l26.2797"></a><span id="l26.2797" class="difflineplus">+            references[jsonValue] = null;</span>
<a href="#l26.2798"></a><span id="l26.2798" class="difflineplus">+        }</span>
<a href="#l26.2799"></a><span id="l26.2799" class="difflineplus">+        else {</span>
<a href="#l26.2800"></a><span id="l26.2800" class="difflineplus">+          for each (let [, anID] in Iterator(jsonValue)) {</span>
<a href="#l26.2801"></a><span id="l26.2801" class="difflineplus">+            if (!(anID in references))</span>
<a href="#l26.2802"></a><span id="l26.2802" class="difflineplus">+            references[anID] = null;</span>
<a href="#l26.2803"></a><span id="l26.2803" class="difflineplus">+          }</span>
<a href="#l26.2804"></a><span id="l26.2804" class="difflineplus">+        }</span>
<a href="#l26.2805"></a><span id="l26.2805" class="difflineplus">+        </span>
<a href="#l26.2806"></a><span id="l26.2806" class="difflineplus">+        deps[attribId] = jsonValue;</span>
<a href="#l26.2807"></a><span id="l26.2807" class="difflineplus">+        hasDeps = true;</span>
<a href="#l26.2808"></a><span id="l26.2808" class="difflineplus">+      }</span>
<a href="#l26.2809"></a><span id="l26.2809" class="difflineplus">+      /* if it has custom contribution logic, use it */</span>
<a href="#l26.2810"></a><span id="l26.2810" class="difflineplus">+      else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l26.2811"></a><span id="l26.2811" class="difflineplus">+        if (objectNounDef.contributeObjDependencies(jsonValue,</span>
<a href="#l26.2812"></a><span id="l26.2812" class="difflineplus">+                             aReferencesByNounID, aInverseReferencesByNounID)) {</span>
<a href="#l26.2813"></a><span id="l26.2813" class="difflineplus">+          deps[attribId] = jsonValue;</span>
<a href="#l26.2814"></a><span id="l26.2814" class="difflineplus">+          hasDeps = true;</span>
<a href="#l26.2815"></a><span id="l26.2815" class="difflineplus">+        }</span>
<a href="#l26.2816"></a><span id="l26.2816" class="difflineplus">+        else // just propagate the value, it's some form of simple sentinel</span>
<a href="#l26.2817"></a><span id="l26.2817" class="difflineplus">+          aItem[attrib.boundName] = jsonValue;</span>
<a href="#l26.2818"></a><span id="l26.2818" class="difflineplus">+      }</span>
<a href="#l26.2819"></a><span id="l26.2819" class="difflineplus">+      // otherwise, the value just needs to be de-persisted, or not</span>
<a href="#l26.2820"></a><span id="l26.2820" class="difflineplus">+      else if (objectNounDef.fromJSON) {</span>
<a href="#l26.2821"></a><span id="l26.2821" class="difflineplus">+        if (attrib.singular)</span>
<a href="#l26.2822"></a><span id="l26.2822" class="difflineplus">+          aItem[attrib.boundName] = objectNounDef.fromJSON(jsonValue);</span>
<a href="#l26.2823"></a><span id="l26.2823" class="difflineplus">+        else</span>
<a href="#l26.2824"></a><span id="l26.2824" class="difflineplus">+          aItem[attrib.boundName] = [objectNounDef.fromJSON(val) for each</span>
<a href="#l26.2825"></a><span id="l26.2825" class="difflineplus">+            ([, val] in Iterator(jsonValue))];</span>
<a href="#l26.2826"></a><span id="l26.2826" class="difflineplus">+      }</span>
<a href="#l26.2827"></a><span id="l26.2827" class="difflineplus">+      // it's fine as is</span>
<a href="#l26.2828"></a><span id="l26.2828" class="difflineplus">+      else</span>
<a href="#l26.2829"></a><span id="l26.2829" class="difflineplus">+        aItem[attrib.boundName] = jsonValue;</span>
<a href="#l26.2830"></a><span id="l26.2830" class="difflineplus">+    }</span>
<a href="#l26.2831"></a><span id="l26.2831" class="difflineplus">+    </span>
<a href="#l26.2832"></a><span id="l26.2832" class="difflineplus">+    if (hasDeps)</span>
<a href="#l26.2833"></a><span id="l26.2833" class="difflineplus">+      aItem._deps = deps;</span>
<a href="#l26.2834"></a><span id="l26.2834" class="difflineplus">+    return hasDeps;</span>
<a href="#l26.2835"></a><span id="l26.2835" class="difflineplus">+  },</span>
<a href="#l26.2836"></a><span id="l26.2836" class="difflineplus">+  </span>
<a href="#l26.2837"></a><span id="l26.2837" class="difflineplus">+  loadNounDeferredDeps: function gloda_ds_loadNounDeferredDeps(aItem,</span>
<a href="#l26.2838"></a><span id="l26.2838" class="difflineplus">+      aReferencesByNounID, aInverseReferencesByNounID) {</span>
<a href="#l26.2839"></a><span id="l26.2839" class="difflineplus">+    if (aItem._deps === undefined)</span>
<a href="#l26.2840"></a><span id="l26.2840" class="difflineplus">+      return;</span>
<a href="#l26.2841"></a><span id="l26.2841" class="difflineplus">+</span>
<a href="#l26.2842"></a><span id="l26.2842" class="difflineplus">+    //this._log.debug(&quot;  loading deferred, deps: &quot; + </span>
<a href="#l26.2843"></a><span id="l26.2843" class="difflineplus">+    //    Log4Moz.enumerateProperties(aItem._deps).join(&quot;,&quot;));</span>
<a href="#l26.2844"></a><span id="l26.2844" class="difflineplus">+</span>
<a href="#l26.2845"></a><span id="l26.2845" class="difflineplus">+    </span>
<a href="#l26.2846"></a><span id="l26.2846" class="difflineplus">+    let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l26.2847"></a><span id="l26.2847" class="difflineplus">+</span>
<a href="#l26.2848"></a><span id="l26.2848" class="difflineplus">+    for (let [attribId, jsonValue] in Iterator(aItem._deps)) {</span>
<a href="#l26.2849"></a><span id="l26.2849" class="difflineplus">+      let dbAttrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l26.2850"></a><span id="l26.2850" class="difflineplus">+      let attrib = dbAttrib.attrDef;</span>
<a href="#l26.2851"></a><span id="l26.2851" class="difflineplus">+      </span>
<a href="#l26.2852"></a><span id="l26.2852" class="difflineplus">+      let objectNounDef = attrib.objectNounDef;</span>
<a href="#l26.2853"></a><span id="l26.2853" class="difflineplus">+      let references = aReferencesByNounID[objectNounDef.id];</span>
<a href="#l26.2854"></a><span id="l26.2854" class="difflineplus">+      if (attrib.special) {</span>
<a href="#l26.2855"></a><span id="l26.2855" class="difflineplus">+        if (attrib.special === this.kSpecialColumnChildren) {</span>
<a href="#l26.2856"></a><span id="l26.2856" class="difflineplus">+          let inverseReferences = aInverseReferencesByNounID[objectNounDef.id];</span>
<a href="#l26.2857"></a><span id="l26.2857" class="difflineplus">+          //this._log.info(&quot;inverse assignment: &quot; + objectNounDef.id +</span>
<a href="#l26.2858"></a><span id="l26.2858" class="difflineplus">+          //    &quot; of &quot; + aItem.id)</span>
<a href="#l26.2859"></a><span id="l26.2859" class="difflineplus">+          aItem[attrib.storageAttributeName] = inverseReferences[aItem.id];</span>
<a href="#l26.2860"></a><span id="l26.2860" class="difflineplus">+        }</span>
<a href="#l26.2861"></a><span id="l26.2861" class="difflineplus">+        else if (attrib.special === this.kSpecialColumnParent) {</span>
<a href="#l26.2862"></a><span id="l26.2862" class="difflineplus">+          //this._log.info(&quot;parent column load: &quot; + objectNounDef.id +</span>
<a href="#l26.2863"></a><span id="l26.2863" class="difflineplus">+          //    &quot; storage value: &quot; + aItem[attrib.idStorageAttributeName]);</span>
<a href="#l26.2864"></a><span id="l26.2864" class="difflineplus">+          aItem[attrib.valueStorageAttributeName] =</span>
<a href="#l26.2865"></a><span id="l26.2865" class="difflineplus">+            references[aItem[attrib.idStorageAttributeName]];</span>
<a href="#l26.2866"></a><span id="l26.2866" class="difflineplus">+        }</span>
<a href="#l26.2867"></a><span id="l26.2867" class="difflineplus">+      }</span>
<a href="#l26.2868"></a><span id="l26.2868" class="difflineplus">+      else if (objectNounDef.tableName) {</span>
<a href="#l26.2869"></a><span id="l26.2869" class="difflineplus">+        //this._log.info(&quot;trying to load: &quot; + objectNounDef.id + &quot; refs: &quot; +</span>
<a href="#l26.2870"></a><span id="l26.2870" class="difflineplus">+        //    jsonValue + &quot;: &quot; + Log4Moz.enumerateProperties(jsonValue).join(&quot;,&quot;));</span>
<a href="#l26.2871"></a><span id="l26.2871" class="difflineplus">+        if (attrib.singular)</span>
<a href="#l26.2872"></a><span id="l26.2872" class="difflineplus">+          aItem[attrib.boundName] = references[jsonValue];</span>
<a href="#l26.2873"></a><span id="l26.2873" class="difflineplus">+        else</span>
<a href="#l26.2874"></a><span id="l26.2874" class="difflineplus">+          aItem[attrib.boundName] = [references[val] for each</span>
<a href="#l26.2875"></a><span id="l26.2875" class="difflineplus">+                                     ([, val] in Iterator(jsonValue))];</span>
<a href="#l26.2876"></a><span id="l26.2876" class="difflineplus">+      }</span>
<a href="#l26.2877"></a><span id="l26.2877" class="difflineplus">+      else if (objectNounDef.contributeObjDependencies) {</span>
<a href="#l26.2878"></a><span id="l26.2878" class="difflineplus">+        aItem[attrib.boundName] =</span>
<a href="#l26.2879"></a><span id="l26.2879" class="difflineplus">+          objectNounDef.resolveObjDependencies(jsonValue, aReferencesByNounID,</span>
<a href="#l26.2880"></a><span id="l26.2880" class="difflineplus">+            aInverseReferencesByNounID);</span>
<a href="#l26.2881"></a><span id="l26.2881" class="difflineplus">+      }</span>
<a href="#l26.2882"></a><span id="l26.2882" class="difflineplus">+      // there is no other case</span>
<a href="#l26.2883"></a><span id="l26.2883" class="difflineplus">+    }</span>
<a href="#l26.2884"></a><span id="l26.2884" class="difflineplus">+    </span>
<a href="#l26.2885"></a><span id="l26.2885" class="difflineplus">+    delete aItem._deps;</span>
<a href="#l26.2886"></a><span id="l26.2886" class="difflineplus">+  },</span>
<a href="#l26.2887"></a><span id="l26.2887" class="difflineplus">+</span>
<a href="#l26.2888"></a><span id="l26.2888" class="difflineplus">+  /* ********** Contact ********** */</span>
<a href="#l26.2889"></a><span id="l26.2889" class="difflineplus">+  _nextContactId: 1,</span>
<a href="#l26.2890"></a><span id="l26.2890" class="difflineplus">+</span>
<a href="#l26.2891"></a><span id="l26.2891" class="difflineplus">+  _populateContactManagedId: function () {</span>
<a href="#l26.2892"></a><span id="l26.2892" class="difflineplus">+    let stmt = this._createSyncStatement(&quot;SELECT MAX(id) FROM contacts&quot;, true);</span>
<a href="#l26.2893"></a><span id="l26.2893" class="difflineplus">+    if (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l26.2894"></a><span id="l26.2894" class="difflineplus">+      this._nextContactId = stmt.getInt64(0) + 1;</span>
<a href="#l26.2895"></a><span id="l26.2895" class="difflineplus">+    }</span>
<a href="#l26.2896"></a><span id="l26.2896" class="difflineplus">+    stmt.finalize();</span>
<a href="#l26.2897"></a><span id="l26.2897" class="difflineplus">+  },</span>
<a href="#l26.2898"></a><span id="l26.2898" class="difflineplus">+</span>
<a href="#l26.2899"></a><span id="l26.2899" class="difflineplus">+  get _insertContactStatement() {</span>
<a href="#l26.2900"></a><span id="l26.2900" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2901"></a><span id="l26.2901" class="difflineplus">+      &quot;INSERT INTO contacts (id, directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l26.2902"></a><span id="l26.2902" class="difflineplus">+                             frecency, jsonAttributes) \</span>
<a href="#l26.2903"></a><span id="l26.2903" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)&quot;);</span>
<a href="#l26.2904"></a><span id="l26.2904" class="difflineplus">+    this.__defineGetter__(&quot;_insertContactStatement&quot;, function() statement);</span>
<a href="#l26.2905"></a><span id="l26.2905" class="difflineplus">+    return this._insertContactStatement;</span>
<a href="#l26.2906"></a><span id="l26.2906" class="difflineplus">+  },</span>
<a href="#l26.2907"></a><span id="l26.2907" class="difflineplus">+</span>
<a href="#l26.2908"></a><span id="l26.2908" class="difflineplus">+  createContact: function gloda_ds_createContact(aDirectoryUUID, aContactUUID,</span>
<a href="#l26.2909"></a><span id="l26.2909" class="difflineplus">+      aName, aPopularity, aFrecency) {</span>
<a href="#l26.2910"></a><span id="l26.2910" class="difflineplus">+    let contactID = this._nextContactId++;</span>
<a href="#l26.2911"></a><span id="l26.2911" class="difflineplus">+    this._log.debug(&quot;createContact: &quot; + contactID + &quot;: &quot; + aName);</span>
<a href="#l26.2912"></a><span id="l26.2912" class="difflineplus">+    let contact = new GlodaContact(this, contactID,</span>
<a href="#l26.2913"></a><span id="l26.2913" class="difflineplus">+                                   aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l26.2914"></a><span id="l26.2914" class="difflineplus">+                                   aPopularity, aFrecency);</span>
<a href="#l26.2915"></a><span id="l26.2915" class="difflineplus">+    return contact;</span>
<a href="#l26.2916"></a><span id="l26.2916" class="difflineplus">+  },</span>
<a href="#l26.2917"></a><span id="l26.2917" class="difflineplus">+  </span>
<a href="#l26.2918"></a><span id="l26.2918" class="difflineplus">+  insertContact: function gloda_ds_insertContact(aContact) {</span>
<a href="#l26.2919"></a><span id="l26.2919" class="difflineplus">+    let ics = this._insertContactStatement;</span>
<a href="#l26.2920"></a><span id="l26.2920" class="difflineplus">+    ics.bindInt64Parameter(0, aContact.id);</span>
<a href="#l26.2921"></a><span id="l26.2921" class="difflineplus">+    if (aContact.directoryUUID == null)</span>
<a href="#l26.2922"></a><span id="l26.2922" class="difflineplus">+      ics.bindNullParameter(1);</span>
<a href="#l26.2923"></a><span id="l26.2923" class="difflineplus">+    else</span>
<a href="#l26.2924"></a><span id="l26.2924" class="difflineplus">+      ics.bindStringParameter(1, aContact.directoryUUID);</span>
<a href="#l26.2925"></a><span id="l26.2925" class="difflineplus">+    if (aContact.contactUUID == null)</span>
<a href="#l26.2926"></a><span id="l26.2926" class="difflineplus">+      ics.bindNullParameter(2);</span>
<a href="#l26.2927"></a><span id="l26.2927" class="difflineplus">+    else</span>
<a href="#l26.2928"></a><span id="l26.2928" class="difflineplus">+      ics.bindStringParameter(2, aContact.contactUUID);</span>
<a href="#l26.2929"></a><span id="l26.2929" class="difflineplus">+    ics.bindStringParameter(3, aContact.name);</span>
<a href="#l26.2930"></a><span id="l26.2930" class="difflineplus">+    ics.bindInt64Parameter(4, aContact.popularity);</span>
<a href="#l26.2931"></a><span id="l26.2931" class="difflineplus">+    ics.bindInt64Parameter(5, aContact.frecency);</span>
<a href="#l26.2932"></a><span id="l26.2932" class="difflineplus">+    if (aContact._jsonText)</span>
<a href="#l26.2933"></a><span id="l26.2933" class="difflineplus">+      ics.bindStringParameter(6, aContact._jsonText);</span>
<a href="#l26.2934"></a><span id="l26.2934" class="difflineplus">+    else</span>
<a href="#l26.2935"></a><span id="l26.2935" class="difflineplus">+      ics.bindNullParameter(6);</span>
<a href="#l26.2936"></a><span id="l26.2936" class="difflineplus">+</span>
<a href="#l26.2937"></a><span id="l26.2937" class="difflineplus">+    ics.executeAsync(this.trackAsync());</span>
<a href="#l26.2938"></a><span id="l26.2938" class="difflineplus">+    this._log.debug(&quot;insertContact: &quot; + aContact.id + &quot;:&quot; + aContact.name);</span>
<a href="#l26.2939"></a><span id="l26.2939" class="difflineplus">+</span>
<a href="#l26.2940"></a><span id="l26.2940" class="difflineplus">+    return aContact;</span>
<a href="#l26.2941"></a><span id="l26.2941" class="difflineplus">+  },</span>
<a href="#l26.2942"></a><span id="l26.2942" class="difflineplus">+</span>
<a href="#l26.2943"></a><span id="l26.2943" class="difflineplus">+  get _updateContactStatement() {</span>
<a href="#l26.2944"></a><span id="l26.2944" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.2945"></a><span id="l26.2945" class="difflineplus">+      &quot;UPDATE contacts SET directoryUUID = ?1, \</span>
<a href="#l26.2946"></a><span id="l26.2946" class="difflineplus">+                           contactUUID = ?2, \</span>
<a href="#l26.2947"></a><span id="l26.2947" class="difflineplus">+                           name = ?3, \</span>
<a href="#l26.2948"></a><span id="l26.2948" class="difflineplus">+                           popularity = ?4, \</span>
<a href="#l26.2949"></a><span id="l26.2949" class="difflineplus">+                           frecency = ?5, \</span>
<a href="#l26.2950"></a><span id="l26.2950" class="difflineplus">+                           jsonAttributes = ?6 \</span>
<a href="#l26.2951"></a><span id="l26.2951" class="difflineplus">+                       WHERE id = ?7&quot;);</span>
<a href="#l26.2952"></a><span id="l26.2952" class="difflineplus">+    this.__defineGetter__(&quot;_updateContactStatement&quot;, function() statement);</span>
<a href="#l26.2953"></a><span id="l26.2953" class="difflineplus">+    return this._updateContactStatement;</span>
<a href="#l26.2954"></a><span id="l26.2954" class="difflineplus">+  },</span>
<a href="#l26.2955"></a><span id="l26.2955" class="difflineplus">+</span>
<a href="#l26.2956"></a><span id="l26.2956" class="difflineplus">+  updateContact: function gloda_ds_updateContact(aContact) {</span>
<a href="#l26.2957"></a><span id="l26.2957" class="difflineplus">+    let ucs = this._updateContactStatement;</span>
<a href="#l26.2958"></a><span id="l26.2958" class="difflineplus">+    ucs.bindInt64Parameter(6, aContact.id);</span>
<a href="#l26.2959"></a><span id="l26.2959" class="difflineplus">+    ucs.bindStringParameter(0, aContact.directoryUUID);</span>
<a href="#l26.2960"></a><span id="l26.2960" class="difflineplus">+    ucs.bindStringParameter(1, aContact.contactUUID);</span>
<a href="#l26.2961"></a><span id="l26.2961" class="difflineplus">+    ucs.bindStringParameter(2, aContact.name);</span>
<a href="#l26.2962"></a><span id="l26.2962" class="difflineplus">+    ucs.bindInt64Parameter(3, aContact.popularity);</span>
<a href="#l26.2963"></a><span id="l26.2963" class="difflineplus">+    ucs.bindInt64Parameter(4, aContact.frecency);</span>
<a href="#l26.2964"></a><span id="l26.2964" class="difflineplus">+    if (aContact._jsonText)</span>
<a href="#l26.2965"></a><span id="l26.2965" class="difflineplus">+      ucs.bindStringParameter(5, aContact._jsonText);</span>
<a href="#l26.2966"></a><span id="l26.2966" class="difflineplus">+    else</span>
<a href="#l26.2967"></a><span id="l26.2967" class="difflineplus">+      ucs.bindNullParameter(5);</span>
<a href="#l26.2968"></a><span id="l26.2968" class="difflineplus">+</span>
<a href="#l26.2969"></a><span id="l26.2969" class="difflineplus">+    ucs.executeAsync(this.trackAsync());</span>
<a href="#l26.2970"></a><span id="l26.2970" class="difflineplus">+  },</span>
<a href="#l26.2971"></a><span id="l26.2971" class="difflineplus">+</span>
<a href="#l26.2972"></a><span id="l26.2972" class="difflineplus">+  _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l26.2973"></a><span id="l26.2973" class="difflineplus">+    let directoryUUID, contactUUID, jsonText;</span>
<a href="#l26.2974"></a><span id="l26.2974" class="difflineplus">+    if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.2975"></a><span id="l26.2975" class="difflineplus">+      directoryUUID = null;</span>
<a href="#l26.2976"></a><span id="l26.2976" class="difflineplus">+    else</span>
<a href="#l26.2977"></a><span id="l26.2977" class="difflineplus">+      directoryUUID = aRow.getString(1);</span>
<a href="#l26.2978"></a><span id="l26.2978" class="difflineplus">+    if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.2979"></a><span id="l26.2979" class="difflineplus">+      contactUUID = null;</span>
<a href="#l26.2980"></a><span id="l26.2980" class="difflineplus">+    else</span>
<a href="#l26.2981"></a><span id="l26.2981" class="difflineplus">+      contactUUID = aRow.getString(2);</span>
<a href="#l26.2982"></a><span id="l26.2982" class="difflineplus">+    if (aRow.getTypeOfIndex(6) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l26.2983"></a><span id="l26.2983" class="difflineplus">+      jsonText = undefined;</span>
<a href="#l26.2984"></a><span id="l26.2984" class="difflineplus">+    else</span>
<a href="#l26.2985"></a><span id="l26.2985" class="difflineplus">+      jsonText = aRow.getString(6);</span>
<a href="#l26.2986"></a><span id="l26.2986" class="difflineplus">+</span>
<a href="#l26.2987"></a><span id="l26.2987" class="difflineplus">+    return new GlodaContact(this, aRow.getInt64(0), directoryUUID,</span>
<a href="#l26.2988"></a><span id="l26.2988" class="difflineplus">+                            contactUUID, aRow.getString(5),</span>
<a href="#l26.2989"></a><span id="l26.2989" class="difflineplus">+                            aRow.getInt64(3), aRow.getInt64(4), jsonText);</span>
<a href="#l26.2990"></a><span id="l26.2990" class="difflineplus">+  },</span>
<a href="#l26.2991"></a><span id="l26.2991" class="difflineplus">+</span>
<a href="#l26.2992"></a><span id="l26.2992" class="difflineplus">+  get _selectContactByIDStatement() {</span>
<a href="#l26.2993"></a><span id="l26.2993" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.2994"></a><span id="l26.2994" class="difflineplus">+      &quot;SELECT * FROM contacts WHERE id = ?1&quot;);</span>
<a href="#l26.2995"></a><span id="l26.2995" class="difflineplus">+    this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l26.2996"></a><span id="l26.2996" class="difflineplus">+      function() statement);</span>
<a href="#l26.2997"></a><span id="l26.2997" class="difflineplus">+    return this._selectContactByIDStatement;</span>
<a href="#l26.2998"></a><span id="l26.2998" class="difflineplus">+  },</span>
<a href="#l26.2999"></a><span id="l26.2999" class="difflineplus">+</span>
<a href="#l26.3000"></a><span id="l26.3000" class="difflineplus">+  getContactByID: function gloda_ds_getContactByID(aContactID) {</span>
<a href="#l26.3001"></a><span id="l26.3001" class="difflineplus">+    let contact = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l26.3002"></a><span id="l26.3002" class="difflineplus">+      GlodaContact.prototype.NOUN_ID, aContactID);</span>
<a href="#l26.3003"></a><span id="l26.3003" class="difflineplus">+</span>
<a href="#l26.3004"></a><span id="l26.3004" class="difflineplus">+    if (contact === null) {</span>
<a href="#l26.3005"></a><span id="l26.3005" class="difflineplus">+      let scbi = this._selectContactByIDStatement;</span>
<a href="#l26.3006"></a><span id="l26.3006" class="difflineplus">+      scbi.bindInt64Parameter(0, aContactID);</span>
<a href="#l26.3007"></a><span id="l26.3007" class="difflineplus">+      if (this._syncStep(scbi)) {</span>
<a href="#l26.3008"></a><span id="l26.3008" class="difflineplus">+        contact = this._contactFromRow(scbi);</span>
<a href="#l26.3009"></a><span id="l26.3009" class="difflineplus">+        GlodaCollectionManager.itemLoaded(contact);</span>
<a href="#l26.3010"></a><span id="l26.3010" class="difflineplus">+      }</span>
<a href="#l26.3011"></a><span id="l26.3011" class="difflineplus">+      scbi.reset();</span>
<a href="#l26.3012"></a><span id="l26.3012" class="difflineplus">+    }</span>
<a href="#l26.3013"></a><span id="l26.3013" class="difflineplus">+</span>
<a href="#l26.3014"></a><span id="l26.3014" class="difflineplus">+    return contact;</span>
<a href="#l26.3015"></a><span id="l26.3015" class="difflineplus">+  },</span>
<a href="#l26.3016"></a><span id="l26.3016" class="difflineplus">+</span>
<a href="#l26.3017"></a><span id="l26.3017" class="difflineplus">+  /* ********** Identity ********** */</span>
<a href="#l26.3018"></a><span id="l26.3018" class="difflineplus">+  /** next identity id, managed for async use reasons. */</span>
<a href="#l26.3019"></a><span id="l26.3019" class="difflineplus">+  _nextIdentityId: 1,</span>
<a href="#l26.3020"></a><span id="l26.3020" class="difflineplus">+  _populateIdentityManagedId: function () {</span>
<a href="#l26.3021"></a><span id="l26.3021" class="difflineplus">+    let stmt = this._createSyncStatement(</span>
<a href="#l26.3022"></a><span id="l26.3022" class="difflineplus">+      &quot;SELECT MAX(id) FROM identities&quot;, true);</span>
<a href="#l26.3023"></a><span id="l26.3023" class="difflineplus">+    if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l26.3024"></a><span id="l26.3024" class="difflineplus">+      this._nextIdentityId = stmt.getInt64(0) + 1;</span>
<a href="#l26.3025"></a><span id="l26.3025" class="difflineplus">+    }</span>
<a href="#l26.3026"></a><span id="l26.3026" class="difflineplus">+    stmt.finalize();</span>
<a href="#l26.3027"></a><span id="l26.3027" class="difflineplus">+  },</span>
<a href="#l26.3028"></a><span id="l26.3028" class="difflineplus">+</span>
<a href="#l26.3029"></a><span id="l26.3029" class="difflineplus">+  get _insertIdentityStatement() {</span>
<a href="#l26.3030"></a><span id="l26.3030" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l26.3031"></a><span id="l26.3031" class="difflineplus">+      &quot;INSERT INTO identities (id, contactID, kind, value, description, relay) \</span>
<a href="#l26.3032"></a><span id="l26.3032" class="difflineplus">+              VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l26.3033"></a><span id="l26.3033" class="difflineplus">+    this.__defineGetter__(&quot;_insertIdentityStatement&quot;, function() statement);</span>
<a href="#l26.3034"></a><span id="l26.3034" class="difflineplus">+    return this._insertIdentityStatement;</span>
<a href="#l26.3035"></a><span id="l26.3035" class="difflineplus">+  },</span>
<a href="#l26.3036"></a><span id="l26.3036" class="difflineplus">+</span>
<a href="#l26.3037"></a><span id="l26.3037" class="difflineplus">+  createIdentity: function gloda_ds_createIdentity(aContactID, aContact, aKind,</span>
<a href="#l26.3038"></a><span id="l26.3038" class="difflineplus">+                                                   aValue, aDescription,</span>
<a href="#l26.3039"></a><span id="l26.3039" class="difflineplus">+                                                   aIsRelay) {</span>
<a href="#l26.3040"></a><span id="l26.3040" class="difflineplus">+    let identityID = this._nextIdentityId++;</span>
<a href="#l26.3041"></a><span id="l26.3041" class="difflineplus">+    let iis = this._insertIdentityStatement;</span>
<a href="#l26.3042"></a><span id="l26.3042" class="difflineplus">+    iis.bindInt64Parameter(0, identityID);</span>
<a href="#l26.3043"></a><span id="l26.3043" class="difflineplus">+    iis.bindInt64Parameter(1, aContactID);</span>
<a href="#l26.3044"></a><span id="l26.3044" class="difflineplus">+    iis.bindStringParameter(2, aKind);</span>
<a href="#l26.3045"></a><span id="l26.3045" class="difflineplus">+    iis.bindStringParameter(3, aValue);</span>
<a href="#l26.3046"></a><span id="l26.3046" class="difflineplus">+    iis.bindStringParameter(4, aDescription);</span>
<a href="#l26.3047"></a><span id="l26.3047" class="difflineplus">+    iis.bindInt64Parameter(5, aIsRelay ? 1 : 0);</span>
<a href="#l26.3048"></a><span id="l26.3048" class="difflineplus">+    iis.executeAsync(this.trackAsync());</span>
<a href="#l26.3049"></a><span id="l26.3049" class="difflineplus">+</span>
<a href="#l26.3050"></a><span id="l26.3050" class="difflineplus">+    let identity = new GlodaIdentity(this, identityID,</span>
<a href="#l26.3051"></a><span id="l26.3051" class="difflineplus">+                                     aContactID, aContact, aKind, aValue,</span>
<a href="#l26.3052"></a><span id="l26.3052" class="difflineplus">+                                     aDescription, aIsRelay);</span>
<a href="#l26.3053"></a><span id="l26.3053" class="difflineplus">+    GlodaCollectionManager.itemsAdded(identity.NOUN_ID, [identity]);</span>
<a href="#l26.3054"></a><span id="l26.3054" class="difflineplus">+    return identity;</span>
<a href="#l26.3055"></a><span id="l26.3055" class="difflineplus">+  },</span>
<a href="#l26.3056"></a><span id="l26.3056" class="difflineplus">+</span>
<a href="#l26.3057"></a><span id="l26.3057" class="difflineplus">+  _identityFromRow: function gloda_ds_identityFromRow(aRow) {</span>
<a href="#l26.3058"></a><span id="l26.3058" class="difflineplus">+    return new GlodaIdentity(this, aRow.getInt64(0), aRow.getInt64(1), null,</span>
<a href="#l26.3059"></a><span id="l26.3059" class="difflineplus">+                             aRow.getString(2), aRow.getString(3),</span>
<a href="#l26.3060"></a><span id="l26.3060" class="difflineplus">+                             aRow.getString(4),</span>
<a href="#l26.3061"></a><span id="l26.3061" class="difflineplus">+                             aRow.getInt32(5) ? true : false);</span>
<a href="#l26.3062"></a><span id="l26.3062" class="difflineplus">+  },</span>
<a href="#l26.3063"></a><span id="l26.3063" class="difflineplus">+</span>
<a href="#l26.3064"></a><span id="l26.3064" class="difflineplus">+  get _selectIdentityByKindValueStatement() {</span>
<a href="#l26.3065"></a><span id="l26.3065" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.3066"></a><span id="l26.3066" class="difflineplus">+      &quot;SELECT * FROM identities WHERE kind = ?1 AND value = ?2&quot;);</span>
<a href="#l26.3067"></a><span id="l26.3067" class="difflineplus">+    this.__defineGetter__(&quot;_selectIdentityByKindValueStatement&quot;,</span>
<a href="#l26.3068"></a><span id="l26.3068" class="difflineplus">+      function() statement);</span>
<a href="#l26.3069"></a><span id="l26.3069" class="difflineplus">+    return this._selectIdentityByKindValueStatement;</span>
<a href="#l26.3070"></a><span id="l26.3070" class="difflineplus">+  },</span>
<a href="#l26.3071"></a><span id="l26.3071" class="difflineplus">+</span>
<a href="#l26.3072"></a><span id="l26.3072" class="difflineplus">+  /** Lookup an identity by kind and value.  Ex: (email, foo@bar.com) */</span>
<a href="#l26.3073"></a><span id="l26.3073" class="difflineplus">+  getIdentity: function gloda_ds_getIdentity(aKind, aValue) {</span>
<a href="#l26.3074"></a><span id="l26.3074" class="difflineplus">+    let identity = GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l26.3075"></a><span id="l26.3075" class="difflineplus">+      GlodaIdentity.prototype.NOUN_ID, aKind + &quot;@&quot; + aValue);</span>
<a href="#l26.3076"></a><span id="l26.3076" class="difflineplus">+</span>
<a href="#l26.3077"></a><span id="l26.3077" class="difflineplus">+    let ibkv = this._selectIdentityByKindValueStatement;</span>
<a href="#l26.3078"></a><span id="l26.3078" class="difflineplus">+    ibkv.bindStringParameter(0, aKind);</span>
<a href="#l26.3079"></a><span id="l26.3079" class="difflineplus">+    ibkv.bindStringParameter(1, aValue);</span>
<a href="#l26.3080"></a><span id="l26.3080" class="difflineplus">+    if (this._syncStep(ibkv)) {</span>
<a href="#l26.3081"></a><span id="l26.3081" class="difflineplus">+      identity = this._identityFromRow(ibkv);</span>
<a href="#l26.3082"></a><span id="l26.3082" class="difflineplus">+      GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l26.3083"></a><span id="l26.3083" class="difflineplus">+    }</span>
<a href="#l26.3084"></a><span id="l26.3084" class="difflineplus">+    ibkv.reset();</span>
<a href="#l26.3085"></a><span id="l26.3085" class="difflineplus">+</span>
<a href="#l26.3086"></a><span id="l26.3086" class="difflineplus">+    return identity;</span>
<a href="#l26.3087"></a><span id="l26.3087" class="difflineplus">+  },</span>
<a href="#l26.3088"></a><span id="l26.3088" class="difflineplus">+</span>
<a href="#l26.3089"></a><span id="l26.3089" class="difflineplus">+  get _selectIdentityByIDStatement() {</span>
<a href="#l26.3090"></a><span id="l26.3090" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.3091"></a><span id="l26.3091" class="difflineplus">+      &quot;SELECT * FROM identities WHERE id = ?1&quot;);</span>
<a href="#l26.3092"></a><span id="l26.3092" class="difflineplus">+    this.__defineGetter__(&quot;_selectIdentityByIDStatement&quot;,</span>
<a href="#l26.3093"></a><span id="l26.3093" class="difflineplus">+      function() statement);</span>
<a href="#l26.3094"></a><span id="l26.3094" class="difflineplus">+    return this._selectIdentityByIDStatement;</span>
<a href="#l26.3095"></a><span id="l26.3095" class="difflineplus">+  },</span>
<a href="#l26.3096"></a><span id="l26.3096" class="difflineplus">+</span>
<a href="#l26.3097"></a><span id="l26.3097" class="difflineplus">+  getIdentityByID: function gloda_ds_getIdentityByID(aID) {</span>
<a href="#l26.3098"></a><span id="l26.3098" class="difflineplus">+    let identity = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l26.3099"></a><span id="l26.3099" class="difflineplus">+      GlodaIdentity.prototype.NOUN_ID, aID);</span>
<a href="#l26.3100"></a><span id="l26.3100" class="difflineplus">+</span>
<a href="#l26.3101"></a><span id="l26.3101" class="difflineplus">+    if (identity === null) {</span>
<a href="#l26.3102"></a><span id="l26.3102" class="difflineplus">+      let sibis = this._selectIdentityByIDStatement;</span>
<a href="#l26.3103"></a><span id="l26.3103" class="difflineplus">+      sibis.bindInt64Parameter(0, aID);</span>
<a href="#l26.3104"></a><span id="l26.3104" class="difflineplus">+      if (this._syncStep(sibis)) {</span>
<a href="#l26.3105"></a><span id="l26.3105" class="difflineplus">+        identity = this._identityFromRow(sibis);</span>
<a href="#l26.3106"></a><span id="l26.3106" class="difflineplus">+        GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l26.3107"></a><span id="l26.3107" class="difflineplus">+      }</span>
<a href="#l26.3108"></a><span id="l26.3108" class="difflineplus">+      sibis.reset();</span>
<a href="#l26.3109"></a><span id="l26.3109" class="difflineplus">+    }</span>
<a href="#l26.3110"></a><span id="l26.3110" class="difflineplus">+</span>
<a href="#l26.3111"></a><span id="l26.3111" class="difflineplus">+    return identity;</span>
<a href="#l26.3112"></a><span id="l26.3112" class="difflineplus">+  },</span>
<a href="#l26.3113"></a><span id="l26.3113" class="difflineplus">+</span>
<a href="#l26.3114"></a><span id="l26.3114" class="difflineplus">+  get _selectIdentityByContactIDStatement() {</span>
<a href="#l26.3115"></a><span id="l26.3115" class="difflineplus">+    let statement = this._createSyncStatement(</span>
<a href="#l26.3116"></a><span id="l26.3116" class="difflineplus">+      &quot;SELECT * FROM identities WHERE contactID = ?1&quot;);</span>
<a href="#l26.3117"></a><span id="l26.3117" class="difflineplus">+    this.__defineGetter__(&quot;_selectIdentityByContactIDStatement&quot;,</span>
<a href="#l26.3118"></a><span id="l26.3118" class="difflineplus">+      function() statement);</span>
<a href="#l26.3119"></a><span id="l26.3119" class="difflineplus">+    return this._selectIdentityByContactIDStatement;</span>
<a href="#l26.3120"></a><span id="l26.3120" class="difflineplus">+  },</span>
<a href="#l26.3121"></a><span id="l26.3121" class="difflineplus">+</span>
<a href="#l26.3122"></a><span id="l26.3122" class="difflineplus">+  getIdentitiesByContactID: function gloda_ds_getIdentitiesByContactID(</span>
<a href="#l26.3123"></a><span id="l26.3123" class="difflineplus">+      aContactID) {</span>
<a href="#l26.3124"></a><span id="l26.3124" class="difflineplus">+    let sibcs = this._selectIdentityByContactIDStatement;</span>
<a href="#l26.3125"></a><span id="l26.3125" class="difflineplus">+</span>
<a href="#l26.3126"></a><span id="l26.3126" class="difflineplus">+    sibcs.bindInt64Parameter(0, aContactID);</span>
<a href="#l26.3127"></a><span id="l26.3127" class="difflineplus">+</span>
<a href="#l26.3128"></a><span id="l26.3128" class="difflineplus">+    let identities = [];</span>
<a href="#l26.3129"></a><span id="l26.3129" class="difflineplus">+    while (this._syncStep(sibcs)) {</span>
<a href="#l26.3130"></a><span id="l26.3130" class="difflineplus">+      identities.push(this._identityFromRow(sibcs));</span>
<a href="#l26.3131"></a><span id="l26.3131" class="difflineplus">+    }</span>
<a href="#l26.3132"></a><span id="l26.3132" class="difflineplus">+    sibcs.reset();</span>
<a href="#l26.3133"></a><span id="l26.3133" class="difflineplus">+</span>
<a href="#l26.3134"></a><span id="l26.3134" class="difflineplus">+    if (identities.length)</span>
<a href="#l26.3135"></a><span id="l26.3135" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(GlodaIdentity.prototype.NOUN_ID,</span>
<a href="#l26.3136"></a><span id="l26.3136" class="difflineplus">+                                            identities);</span>
<a href="#l26.3137"></a><span id="l26.3137" class="difflineplus">+    return identities;</span>
<a href="#l26.3138"></a><span id="l26.3138" class="difflineplus">+  },</span>
<a href="#l26.3139"></a><span id="l26.3139" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1">new file mode 100644</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineminus">--- /dev/null</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/everybody.js</span>
<a href="#l27.4"></a><span id="l27.4" class="difflineat">@@ -0,0 +1,90 @@</span>
<a href="#l27.5"></a><span id="l27.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l27.6"></a><span id="l27.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l27.7"></a><span id="l27.7" class="difflineplus">+ *</span>
<a href="#l27.8"></a><span id="l27.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l27.9"></a><span id="l27.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l27.10"></a><span id="l27.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l27.11"></a><span id="l27.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineplus">+ * </span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l27.15"></a><span id="l27.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l27.16"></a><span id="l27.16" class="difflineplus">+ * License.</span>
<a href="#l27.17"></a><span id="l27.17" class="difflineplus">+ *</span>
<a href="#l27.18"></a><span id="l27.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l27.19"></a><span id="l27.19" class="difflineplus">+ *</span>
<a href="#l27.20"></a><span id="l27.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l27.21"></a><span id="l27.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l27.23"></a><span id="l27.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l27.24"></a><span id="l27.24" class="difflineplus">+ *</span>
<a href="#l27.25"></a><span id="l27.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l27.26"></a><span id="l27.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l27.27"></a><span id="l27.27" class="difflineplus">+ *</span>
<a href="#l27.28"></a><span id="l27.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l27.29"></a><span id="l27.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l27.30"></a><span id="l27.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l27.31"></a><span id="l27.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l27.33"></a><span id="l27.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l27.34"></a><span id="l27.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l27.35"></a><span id="l27.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l27.36"></a><span id="l27.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l27.38"></a><span id="l27.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l27.39"></a><span id="l27.39" class="difflineplus">+ * </span>
<a href="#l27.40"></a><span id="l27.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineplus">+</span>
<a href="#l27.42"></a><span id="l27.42" class="difflineplus">+const EXPORTED_SYMBOLS = [];</span>
<a href="#l27.43"></a><span id="l27.43" class="difflineplus">+</span>
<a href="#l27.44"></a><span id="l27.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l27.45"></a><span id="l27.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l27.48"></a><span id="l27.48" class="difflineplus">+</span>
<a href="#l27.49"></a><span id="l27.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l27.50"></a><span id="l27.50" class="difflineplus">+const LOG = Log4Moz.Service.getLogger(&quot;gloda.everybody&quot;);</span>
<a href="#l27.51"></a><span id="l27.51" class="difflineplus">+</span>
<a href="#l27.52"></a><span id="l27.52" class="difflineplus">+var importNS = {};</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineplus">+var strtab = null;</span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+</span>
<a href="#l27.55"></a><span id="l27.55" class="difflineplus">+function loadModule(aModuleURI, aNSContrib) {</span>
<a href="#l27.56"></a><span id="l27.56" class="difflineplus">+  if (strtab === null) {</span>
<a href="#l27.57"></a><span id="l27.57" class="difflineplus">+    let bundleService = Cc[&quot;@mozilla.org/intl/stringbundle;1&quot;].</span>
<a href="#l27.58"></a><span id="l27.58" class="difflineplus">+                        getService(Ci.nsIStringBundleService);</span>
<a href="#l27.59"></a><span id="l27.59" class="difflineplus">+    strtab = bundleService.createBundle(&quot;chrome://gloda/locale/gloda.properties&quot;);</span>
<a href="#l27.60"></a><span id="l27.60" class="difflineplus">+    LOG.debug(&quot;string bundle: &quot; + strtab);</span>
<a href="#l27.61"></a><span id="l27.61" class="difflineplus">+  }</span>
<a href="#l27.62"></a><span id="l27.62" class="difflineplus">+</span>
<a href="#l27.63"></a><span id="l27.63" class="difflineplus">+  try {</span>
<a href="#l27.64"></a><span id="l27.64" class="difflineplus">+    LOG.info(&quot;... loading &quot; + aModuleURI);</span>
<a href="#l27.65"></a><span id="l27.65" class="difflineplus">+    Cu.import(aModuleURI, importNS);</span>
<a href="#l27.66"></a><span id="l27.66" class="difflineplus">+  }</span>
<a href="#l27.67"></a><span id="l27.67" class="difflineplus">+  catch (ex) {</span>
<a href="#l27.68"></a><span id="l27.68" class="difflineplus">+    LOG.error(&quot;!!! error loading &quot; + aModuleURI);</span>
<a href="#l27.69"></a><span id="l27.69" class="difflineplus">+    LOG.error(&quot;(&quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;) &quot; + ex);</span>
<a href="#l27.70"></a><span id="l27.70" class="difflineplus">+    return false;</span>
<a href="#l27.71"></a><span id="l27.71" class="difflineplus">+  }</span>
<a href="#l27.72"></a><span id="l27.72" class="difflineplus">+  LOG.info(&quot;+++ loaded &quot; + aModuleURI);</span>
<a href="#l27.73"></a><span id="l27.73" class="difflineplus">+</span>
<a href="#l27.74"></a><span id="l27.74" class="difflineplus">+  if (aNSContrib) {</span>
<a href="#l27.75"></a><span id="l27.75" class="difflineplus">+    try {  </span>
<a href="#l27.76"></a><span id="l27.76" class="difflineplus">+      importNS[aNSContrib].init(strtab);</span>
<a href="#l27.77"></a><span id="l27.77" class="difflineplus">+    }</span>
<a href="#l27.78"></a><span id="l27.78" class="difflineplus">+    catch (ex) {</span>
<a href="#l27.79"></a><span id="l27.79" class="difflineplus">+      LOG.error(&quot;!!! error initializing &quot; + aModuleURI);</span>
<a href="#l27.80"></a><span id="l27.80" class="difflineplus">+      LOG.error(&quot;(&quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;) &quot; + ex);</span>
<a href="#l27.81"></a><span id="l27.81" class="difflineplus">+      return false;</span>
<a href="#l27.82"></a><span id="l27.82" class="difflineplus">+    }</span>
<a href="#l27.83"></a><span id="l27.83" class="difflineplus">+    LOG.info(&quot;+++ inited &quot; + aModuleURI);</span>
<a href="#l27.84"></a><span id="l27.84" class="difflineplus">+  }</span>
<a href="#l27.85"></a><span id="l27.85" class="difflineplus">+  return true;</span>
<a href="#l27.86"></a><span id="l27.86" class="difflineplus">+}</span>
<a href="#l27.87"></a><span id="l27.87" class="difflineplus">+</span>
<a href="#l27.88"></a><span id="l27.88" class="difflineplus">+loadModule(&quot;resource://gloda/modules/fundattr.js&quot;, &quot;GlodaFundAttr&quot;);</span>
<a href="#l27.89"></a><span id="l27.89" class="difflineplus">+loadModule(&quot;resource://gloda/modules/explattr.js&quot;, &quot;GlodaExplicitAttr&quot;);</span>
<a href="#l27.90"></a><span id="l27.90" class="difflineplus">+</span>
<a href="#l27.91"></a><span id="l27.91" class="difflineplus">+loadModule(&quot;resource://gloda/modules/noun_tag.js&quot;);</span>
<a href="#l27.92"></a><span id="l27.92" class="difflineplus">+loadModule(&quot;resource://gloda/modules/noun_freetag.js&quot;);</span>
<a href="#l27.93"></a><span id="l27.93" class="difflineplus">+loadModule(&quot;resource://gloda/modules/noun_mimetype.js&quot;);</span>
<a href="#l27.94"></a><span id="l27.94" class="difflineplus">+loadModule(&quot;resource://gloda/modules/index_ab.js&quot;, &quot;GlodaABAttrs&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1">new file mode 100644</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineminus">--- /dev/null</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/explattr.js</span>
<a href="#l28.4"></a><span id="l28.4" class="difflineat">@@ -0,0 +1,165 @@</span>
<a href="#l28.5"></a><span id="l28.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l28.6"></a><span id="l28.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l28.7"></a><span id="l28.7" class="difflineplus">+ *</span>
<a href="#l28.8"></a><span id="l28.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l28.9"></a><span id="l28.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l28.10"></a><span id="l28.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l28.11"></a><span id="l28.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineplus">+ * </span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l28.14"></a><span id="l28.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l28.15"></a><span id="l28.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineplus">+ * License.</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineplus">+ *</span>
<a href="#l28.18"></a><span id="l28.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l28.19"></a><span id="l28.19" class="difflineplus">+ *</span>
<a href="#l28.20"></a><span id="l28.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l28.21"></a><span id="l28.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l28.23"></a><span id="l28.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineplus">+ *</span>
<a href="#l28.25"></a><span id="l28.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l28.26"></a><span id="l28.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l28.27"></a><span id="l28.27" class="difflineplus">+ *</span>
<a href="#l28.28"></a><span id="l28.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l28.29"></a><span id="l28.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l28.30"></a><span id="l28.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l28.33"></a><span id="l28.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l28.35"></a><span id="l28.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l28.36"></a><span id="l28.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l28.37"></a><span id="l28.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l28.38"></a><span id="l28.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l28.39"></a><span id="l28.39" class="difflineplus">+ * </span>
<a href="#l28.40"></a><span id="l28.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l28.41"></a><span id="l28.41" class="difflineplus">+</span>
<a href="#l28.42"></a><span id="l28.42" class="difflineplus">+/*</span>
<a href="#l28.43"></a><span id="l28.43" class="difflineplus">+ * This file provides the &quot;explicit attribute&quot; provider for messages.  It is</span>
<a href="#l28.44"></a><span id="l28.44" class="difflineplus">+ *  concerned with attributes that are the result of user actions.  For example,</span>
<a href="#l28.45"></a><span id="l28.45" class="difflineplus">+ *  whether a message is starred (flagged), message tags, whether it is</span>
<a href="#l28.46"></a><span id="l28.46" class="difflineplus">+ *  read/unread, etc.</span>
<a href="#l28.47"></a><span id="l28.47" class="difflineplus">+ */</span>
<a href="#l28.48"></a><span id="l28.48" class="difflineplus">+</span>
<a href="#l28.49"></a><span id="l28.49" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaExplicitAttr'];</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineplus">+</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l28.53"></a><span id="l28.53" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l28.54"></a><span id="l28.54" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l28.55"></a><span id="l28.55" class="difflineplus">+</span>
<a href="#l28.56"></a><span id="l28.56" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l28.57"></a><span id="l28.57" class="difflineplus">+</span>
<a href="#l28.58"></a><span id="l28.58" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l28.59"></a><span id="l28.59" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l28.60"></a><span id="l28.60" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/noun_tag.js&quot;);</span>
<a href="#l28.61"></a><span id="l28.61" class="difflineplus">+</span>
<a href="#l28.62"></a><span id="l28.62" class="difflineplus">+</span>
<a href="#l28.63"></a><span id="l28.63" class="difflineplus">+const EXT_BUILTIN = &quot;built-in&quot;;</span>
<a href="#l28.64"></a><span id="l28.64" class="difflineplus">+const FA_TAG = &quot;TAG&quot;;</span>
<a href="#l28.65"></a><span id="l28.65" class="difflineplus">+const FA_STAR = &quot;STAR&quot;;</span>
<a href="#l28.66"></a><span id="l28.66" class="difflineplus">+const FA_READ = &quot;READ&quot;;</span>
<a href="#l28.67"></a><span id="l28.67" class="difflineplus">+</span>
<a href="#l28.68"></a><span id="l28.68" class="difflineplus">+/**</span>
<a href="#l28.69"></a><span id="l28.69" class="difflineplus">+ * @namespace Explicit attribute provider.  Indexes/defines attributes that are</span>
<a href="#l28.70"></a><span id="l28.70" class="difflineplus">+ *  explicitly a result of user action.  This dubiously includes marking a</span>
<a href="#l28.71"></a><span id="l28.71" class="difflineplus">+ *  message as read. </span>
<a href="#l28.72"></a><span id="l28.72" class="difflineplus">+ */</span>
<a href="#l28.73"></a><span id="l28.73" class="difflineplus">+var GlodaExplicitAttr = {</span>
<a href="#l28.74"></a><span id="l28.74" class="difflineplus">+  providerName: &quot;gloda.explattr&quot;,</span>
<a href="#l28.75"></a><span id="l28.75" class="difflineplus">+  _log: null,</span>
<a href="#l28.76"></a><span id="l28.76" class="difflineplus">+  _strBundle: null,</span>
<a href="#l28.77"></a><span id="l28.77" class="difflineplus">+  _msgTagService: null,</span>
<a href="#l28.78"></a><span id="l28.78" class="difflineplus">+</span>
<a href="#l28.79"></a><span id="l28.79" class="difflineplus">+  init: function gloda_explattr_init(aStrBundle) {</span>
<a href="#l28.80"></a><span id="l28.80" class="difflineplus">+    this._log =  Log4Moz.Service.getLogger(&quot;gloda.explattr&quot;);</span>
<a href="#l28.81"></a><span id="l28.81" class="difflineplus">+    this._strBundle = aStrBundle;</span>
<a href="#l28.82"></a><span id="l28.82" class="difflineplus">+</span>
<a href="#l28.83"></a><span id="l28.83" class="difflineplus">+    this._msgTagService = Cc[&quot;@mozilla.org/messenger/tagservice;1&quot;].</span>
<a href="#l28.84"></a><span id="l28.84" class="difflineplus">+                          getService(Ci.nsIMsgTagService);</span>
<a href="#l28.85"></a><span id="l28.85" class="difflineplus">+  </span>
<a href="#l28.86"></a><span id="l28.86" class="difflineplus">+    try {</span>
<a href="#l28.87"></a><span id="l28.87" class="difflineplus">+      this.defineAttributes();</span>
<a href="#l28.88"></a><span id="l28.88" class="difflineplus">+    }</span>
<a href="#l28.89"></a><span id="l28.89" class="difflineplus">+    catch (ex) {</span>
<a href="#l28.90"></a><span id="l28.90" class="difflineplus">+      this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l28.91"></a><span id="l28.91" class="difflineplus">+      throw ex;</span>
<a href="#l28.92"></a><span id="l28.92" class="difflineplus">+    }</span>
<a href="#l28.93"></a><span id="l28.93" class="difflineplus">+  },</span>
<a href="#l28.94"></a><span id="l28.94" class="difflineplus">+</span>
<a href="#l28.95"></a><span id="l28.95" class="difflineplus">+  _attrTag: null,</span>
<a href="#l28.96"></a><span id="l28.96" class="difflineplus">+  _attrStar: null,</span>
<a href="#l28.97"></a><span id="l28.97" class="difflineplus">+  _attrRead: null,</span>
<a href="#l28.98"></a><span id="l28.98" class="difflineplus">+  </span>
<a href="#l28.99"></a><span id="l28.99" class="difflineplus">+  defineAttributes: function() {</span>
<a href="#l28.100"></a><span id="l28.100" class="difflineplus">+    // Tag</span>
<a href="#l28.101"></a><span id="l28.101" class="difflineplus">+    this._attrTag = Gloda.defineAttribute({</span>
<a href="#l28.102"></a><span id="l28.102" class="difflineplus">+                        provider: this,</span>
<a href="#l28.103"></a><span id="l28.103" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l28.104"></a><span id="l28.104" class="difflineplus">+                        attributeType: Gloda.kAttrExplicit,</span>
<a href="#l28.105"></a><span id="l28.105" class="difflineplus">+                        attributeName: &quot;tag&quot;,</span>
<a href="#l28.106"></a><span id="l28.106" class="difflineplus">+                        bindName: &quot;tags&quot;,</span>
<a href="#l28.107"></a><span id="l28.107" class="difflineplus">+                        singular: false,</span>
<a href="#l28.108"></a><span id="l28.108" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l28.109"></a><span id="l28.109" class="difflineplus">+                        objectNoun: Gloda.NOUN_TAG,</span>
<a href="#l28.110"></a><span id="l28.110" class="difflineplus">+                        parameterNoun: null,</span>
<a href="#l28.111"></a><span id="l28.111" class="difflineplus">+                        // Property change notifications that we care about:</span>
<a href="#l28.112"></a><span id="l28.112" class="difflineplus">+                        propertyChanges: [&quot;keywords&quot;],</span>
<a href="#l28.113"></a><span id="l28.113" class="difflineplus">+                        }); // not-tested</span>
<a href="#l28.114"></a><span id="l28.114" class="difflineplus">+</span>
<a href="#l28.115"></a><span id="l28.115" class="difflineplus">+    // Star</span>
<a href="#l28.116"></a><span id="l28.116" class="difflineplus">+    this._attrStar = Gloda.defineAttribute({</span>
<a href="#l28.117"></a><span id="l28.117" class="difflineplus">+                        provider: this,</span>
<a href="#l28.118"></a><span id="l28.118" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l28.119"></a><span id="l28.119" class="difflineplus">+                        attributeType: Gloda.kAttrExplicit,</span>
<a href="#l28.120"></a><span id="l28.120" class="difflineplus">+                        attributeName: &quot;star&quot;,</span>
<a href="#l28.121"></a><span id="l28.121" class="difflineplus">+                        bindName: &quot;starred&quot;,</span>
<a href="#l28.122"></a><span id="l28.122" class="difflineplus">+                        singular: true,</span>
<a href="#l28.123"></a><span id="l28.123" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l28.124"></a><span id="l28.124" class="difflineplus">+                        objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l28.125"></a><span id="l28.125" class="difflineplus">+                        parameterNoun: null,</span>
<a href="#l28.126"></a><span id="l28.126" class="difflineplus">+                        }); // tested-by: test_attributes_explicit</span>
<a href="#l28.127"></a><span id="l28.127" class="difflineplus">+    // Read/Unread</span>
<a href="#l28.128"></a><span id="l28.128" class="difflineplus">+    this._attrRead = Gloda.defineAttribute({</span>
<a href="#l28.129"></a><span id="l28.129" class="difflineplus">+                        provider: this,</span>
<a href="#l28.130"></a><span id="l28.130" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l28.131"></a><span id="l28.131" class="difflineplus">+                        attributeType: Gloda.kAttrExplicit,</span>
<a href="#l28.132"></a><span id="l28.132" class="difflineplus">+                        attributeName: &quot;read&quot;,</span>
<a href="#l28.133"></a><span id="l28.133" class="difflineplus">+                        singular: true,</span>
<a href="#l28.134"></a><span id="l28.134" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l28.135"></a><span id="l28.135" class="difflineplus">+                        objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l28.136"></a><span id="l28.136" class="difflineplus">+                        parameterNoun: null,</span>
<a href="#l28.137"></a><span id="l28.137" class="difflineplus">+                        }); // tested-by: test_attributes_explicit</span>
<a href="#l28.138"></a><span id="l28.138" class="difflineplus">+    </span>
<a href="#l28.139"></a><span id="l28.139" class="difflineplus">+  },</span>
<a href="#l28.140"></a><span id="l28.140" class="difflineplus">+  </span>
<a href="#l28.141"></a><span id="l28.141" class="difflineplus">+  process: function Gloda_explattr_process(aGlodaMessage, aRawReps, aIsNew,</span>
<a href="#l28.142"></a><span id="l28.142" class="difflineplus">+                                           aCallbackHandle) {</span>
<a href="#l28.143"></a><span id="l28.143" class="difflineplus">+    let aMsgHdr = aRawReps.header;</span>
<a href="#l28.144"></a><span id="l28.144" class="difflineplus">+    </span>
<a href="#l28.145"></a><span id="l28.145" class="difflineplus">+    aGlodaMessage.starred = aMsgHdr.isFlagged;</span>
<a href="#l28.146"></a><span id="l28.146" class="difflineplus">+    aGlodaMessage.read = aMsgHdr.isRead;</span>
<a href="#l28.147"></a><span id="l28.147" class="difflineplus">+    </span>
<a href="#l28.148"></a><span id="l28.148" class="difflineplus">+    let tags = aGlodaMessage.tags = [];</span>
<a href="#l28.149"></a><span id="l28.149" class="difflineplus">+    </span>
<a href="#l28.150"></a><span id="l28.150" class="difflineplus">+    // -- Tag</span>
<a href="#l28.151"></a><span id="l28.151" class="difflineplus">+    // build a map of the keywords</span>
<a href="#l28.152"></a><span id="l28.152" class="difflineplus">+    let keywords = aMsgHdr.getStringProperty(&quot;keywords&quot;);</span>
<a href="#l28.153"></a><span id="l28.153" class="difflineplus">+    let keywordList = keywords.split(' ');</span>
<a href="#l28.154"></a><span id="l28.154" class="difflineplus">+    let keywordMap = {};</span>
<a href="#l28.155"></a><span id="l28.155" class="difflineplus">+    for (let iKeyword = 0; iKeyword &lt; keywordList.length; iKeyword++) {</span>
<a href="#l28.156"></a><span id="l28.156" class="difflineplus">+      let keyword = keywordList[iKeyword];</span>
<a href="#l28.157"></a><span id="l28.157" class="difflineplus">+      keywordMap[keyword] = true;</span>
<a href="#l28.158"></a><span id="l28.158" class="difflineplus">+    }</span>
<a href="#l28.159"></a><span id="l28.159" class="difflineplus">+</span>
<a href="#l28.160"></a><span id="l28.160" class="difflineplus">+    let tagArray = this._msgTagService.getAllTags({});</span>
<a href="#l28.161"></a><span id="l28.161" class="difflineplus">+    for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l28.162"></a><span id="l28.162" class="difflineplus">+      let tag = tagArray[iTag];</span>
<a href="#l28.163"></a><span id="l28.163" class="difflineplus">+      if (tag.key in keywordMap)</span>
<a href="#l28.164"></a><span id="l28.164" class="difflineplus">+        tags.push(tag);</span>
<a href="#l28.165"></a><span id="l28.165" class="difflineplus">+    }</span>
<a href="#l28.166"></a><span id="l28.166" class="difflineplus">+    </span>
<a href="#l28.167"></a><span id="l28.167" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l28.168"></a><span id="l28.168" class="difflineplus">+  },</span>
<a href="#l28.169"></a><span id="l28.169" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1">new file mode 100644</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineminus">--- /dev/null</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/fundattr.js</span>
<a href="#l29.4"></a><span id="l29.4" class="difflineat">@@ -0,0 +1,544 @@</span>
<a href="#l29.5"></a><span id="l29.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l29.6"></a><span id="l29.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l29.7"></a><span id="l29.7" class="difflineplus">+ *</span>
<a href="#l29.8"></a><span id="l29.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l29.9"></a><span id="l29.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l29.10"></a><span id="l29.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l29.11"></a><span id="l29.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineplus">+ * </span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l29.14"></a><span id="l29.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l29.15"></a><span id="l29.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l29.16"></a><span id="l29.16" class="difflineplus">+ * License.</span>
<a href="#l29.17"></a><span id="l29.17" class="difflineplus">+ *</span>
<a href="#l29.18"></a><span id="l29.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l29.19"></a><span id="l29.19" class="difflineplus">+ *</span>
<a href="#l29.20"></a><span id="l29.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l29.21"></a><span id="l29.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l29.22"></a><span id="l29.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l29.23"></a><span id="l29.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l29.24"></a><span id="l29.24" class="difflineplus">+ *</span>
<a href="#l29.25"></a><span id="l29.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l29.26"></a><span id="l29.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l29.27"></a><span id="l29.27" class="difflineplus">+ *</span>
<a href="#l29.28"></a><span id="l29.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l29.29"></a><span id="l29.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l29.30"></a><span id="l29.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l29.32"></a><span id="l29.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l29.33"></a><span id="l29.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l29.34"></a><span id="l29.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l29.35"></a><span id="l29.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l29.36"></a><span id="l29.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l29.37"></a><span id="l29.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l29.38"></a><span id="l29.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l29.39"></a><span id="l29.39" class="difflineplus">+ * </span>
<a href="#l29.40"></a><span id="l29.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l29.41"></a><span id="l29.41" class="difflineplus">+</span>
<a href="#l29.42"></a><span id="l29.42" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaFundAttr'];</span>
<a href="#l29.43"></a><span id="l29.43" class="difflineplus">+</span>
<a href="#l29.44"></a><span id="l29.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l29.45"></a><span id="l29.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l29.46"></a><span id="l29.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l29.47"></a><span id="l29.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l29.48"></a><span id="l29.48" class="difflineplus">+</span>
<a href="#l29.49"></a><span id="l29.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l29.50"></a><span id="l29.50" class="difflineplus">+</span>
<a href="#l29.51"></a><span id="l29.51" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l29.52"></a><span id="l29.52" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l29.53"></a><span id="l29.53" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l29.54"></a><span id="l29.54" class="difflineplus">+</span>
<a href="#l29.55"></a><span id="l29.55" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/noun_mimetype.js&quot;);</span>
<a href="#l29.56"></a><span id="l29.56" class="difflineplus">+</span>
<a href="#l29.57"></a><span id="l29.57" class="difflineplus">+</span>
<a href="#l29.58"></a><span id="l29.58" class="difflineplus">+/**</span>
<a href="#l29.59"></a><span id="l29.59" class="difflineplus">+ * @namespace The Gloda Fundamental Attribute provider is a special attribute</span>
<a href="#l29.60"></a><span id="l29.60" class="difflineplus">+ *  provider; it provides attributes that the rest of the providers should be</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineplus">+ *  able to assume exist.  Also, it may end up accessing things at a lower level</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineplus">+ *  than most extension providers should do.  In summary, don't mimic this code</span>
<a href="#l29.63"></a><span id="l29.63" class="difflineplus">+ *  unless you won't complain when your code breaks.</span>
<a href="#l29.64"></a><span id="l29.64" class="difflineplus">+ */</span>
<a href="#l29.65"></a><span id="l29.65" class="difflineplus">+var GlodaFundAttr = {</span>
<a href="#l29.66"></a><span id="l29.66" class="difflineplus">+  providerName: &quot;gloda.fundattr&quot;,</span>
<a href="#l29.67"></a><span id="l29.67" class="difflineplus">+  _log: null,</span>
<a href="#l29.68"></a><span id="l29.68" class="difflineplus">+  _strBundle: null,</span>
<a href="#l29.69"></a><span id="l29.69" class="difflineplus">+</span>
<a href="#l29.70"></a><span id="l29.70" class="difflineplus">+  init: function gloda_explattr_init(aStrBundle) {</span>
<a href="#l29.71"></a><span id="l29.71" class="difflineplus">+    this._log =  Log4Moz.Service.getLogger(&quot;gloda.fundattr&quot;);</span>
<a href="#l29.72"></a><span id="l29.72" class="difflineplus">+    this._strBundle = aStrBundle;</span>
<a href="#l29.73"></a><span id="l29.73" class="difflineplus">+  </span>
<a href="#l29.74"></a><span id="l29.74" class="difflineplus">+    try {</span>
<a href="#l29.75"></a><span id="l29.75" class="difflineplus">+      this.defineAttributes();</span>
<a href="#l29.76"></a><span id="l29.76" class="difflineplus">+    }</span>
<a href="#l29.77"></a><span id="l29.77" class="difflineplus">+    catch (ex) {</span>
<a href="#l29.78"></a><span id="l29.78" class="difflineplus">+      this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l29.79"></a><span id="l29.79" class="difflineplus">+      throw ex;</span>
<a href="#l29.80"></a><span id="l29.80" class="difflineplus">+    }</span>
<a href="#l29.81"></a><span id="l29.81" class="difflineplus">+  },</span>
<a href="#l29.82"></a><span id="l29.82" class="difflineplus">+</span>
<a href="#l29.83"></a><span id="l29.83" class="difflineplus">+  POPULARITY_FROM_ME_TO: 10,</span>
<a href="#l29.84"></a><span id="l29.84" class="difflineplus">+  POPULARITY_FROM_ME_CC: 4,</span>
<a href="#l29.85"></a><span id="l29.85" class="difflineplus">+  POPULARITY_TO_ME: 5,</span>
<a href="#l29.86"></a><span id="l29.86" class="difflineplus">+  POPULARITY_CC_ME: 1,</span>
<a href="#l29.87"></a><span id="l29.87" class="difflineplus">+</span>
<a href="#l29.88"></a><span id="l29.88" class="difflineplus">+  _attrConvSubject: null,</span>
<a href="#l29.89"></a><span id="l29.89" class="difflineplus">+  _attrFolder: null,</span>
<a href="#l29.90"></a><span id="l29.90" class="difflineplus">+  _attrBody: null,</span>
<a href="#l29.91"></a><span id="l29.91" class="difflineplus">+  _attrFrom: null,</span>
<a href="#l29.92"></a><span id="l29.92" class="difflineplus">+  _attrFromMe: null,</span>
<a href="#l29.93"></a><span id="l29.93" class="difflineplus">+  _attrTo: null,</span>
<a href="#l29.94"></a><span id="l29.94" class="difflineplus">+  _attrToMe: null,</span>
<a href="#l29.95"></a><span id="l29.95" class="difflineplus">+  _attrCc: null,</span>
<a href="#l29.96"></a><span id="l29.96" class="difflineplus">+  _attrCcMe: null,</span>
<a href="#l29.97"></a><span id="l29.97" class="difflineplus">+  _attrDate: null,</span>
<a href="#l29.98"></a><span id="l29.98" class="difflineplus">+  </span>
<a href="#l29.99"></a><span id="l29.99" class="difflineplus">+  defineAttributes: function() {</span>
<a href="#l29.100"></a><span id="l29.100" class="difflineplus">+    /* ***** Conversations ***** */</span>
<a href="#l29.101"></a><span id="l29.101" class="difflineplus">+    // conversation: subjectMatches</span>
<a href="#l29.102"></a><span id="l29.102" class="difflineplus">+    this._attrConvSubject = Gloda.defineAttribute({</span>
<a href="#l29.103"></a><span id="l29.103" class="difflineplus">+      provider: this,</span>
<a href="#l29.104"></a><span id="l29.104" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.105"></a><span id="l29.105" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l29.106"></a><span id="l29.106" class="difflineplus">+      attributeName: &quot;subjectMatches&quot;,</span>
<a href="#l29.107"></a><span id="l29.107" class="difflineplus">+      singular: true,</span>
<a href="#l29.108"></a><span id="l29.108" class="difflineplus">+      special: Gloda.kSpecialFulltext,</span>
<a href="#l29.109"></a><span id="l29.109" class="difflineplus">+      specialColumnName: &quot;subject&quot;,</span>
<a href="#l29.110"></a><span id="l29.110" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONVERSATION],</span>
<a href="#l29.111"></a><span id="l29.111" class="difflineplus">+      objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l29.112"></a><span id="l29.112" class="difflineplus">+      });</span>
<a href="#l29.113"></a><span id="l29.113" class="difflineplus">+  </span>
<a href="#l29.114"></a><span id="l29.114" class="difflineplus">+    /* ***** Messages ***** */</span>
<a href="#l29.115"></a><span id="l29.115" class="difflineplus">+    // folder</span>
<a href="#l29.116"></a><span id="l29.116" class="difflineplus">+    this._attrFolder = Gloda.defineAttribute({</span>
<a href="#l29.117"></a><span id="l29.117" class="difflineplus">+      provider: this,</span>
<a href="#l29.118"></a><span id="l29.118" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.119"></a><span id="l29.119" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.120"></a><span id="l29.120" class="difflineplus">+      attributeName: &quot;folder&quot;,</span>
<a href="#l29.121"></a><span id="l29.121" class="difflineplus">+      singular: true,</span>
<a href="#l29.122"></a><span id="l29.122" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l29.123"></a><span id="l29.123" class="difflineplus">+      specialColumnName: &quot;folderID&quot;,</span>
<a href="#l29.124"></a><span id="l29.124" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.125"></a><span id="l29.125" class="difflineplus">+      objectNoun: Gloda.NOUN_FOLDER,</span>
<a href="#l29.126"></a><span id="l29.126" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l29.127"></a><span id="l29.127" class="difflineplus">+    this._attrFolder = Gloda.defineAttribute({</span>
<a href="#l29.128"></a><span id="l29.128" class="difflineplus">+      provider: this,</span>
<a href="#l29.129"></a><span id="l29.129" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.130"></a><span id="l29.130" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.131"></a><span id="l29.131" class="difflineplus">+      attributeName: &quot;messageKey&quot;,</span>
<a href="#l29.132"></a><span id="l29.132" class="difflineplus">+      singular: true,</span>
<a href="#l29.133"></a><span id="l29.133" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l29.134"></a><span id="l29.134" class="difflineplus">+      specialColumnName: &quot;messageKey&quot;,</span>
<a href="#l29.135"></a><span id="l29.135" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.136"></a><span id="l29.136" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l29.137"></a><span id="l29.137" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l29.138"></a><span id="l29.138" class="difflineplus">+    </span>
<a href="#l29.139"></a><span id="l29.139" class="difflineplus">+    // bodyMatches. super-synthetic full-text matching...</span>
<a href="#l29.140"></a><span id="l29.140" class="difflineplus">+    this._attrBody = Gloda.defineAttribute({</span>
<a href="#l29.141"></a><span id="l29.141" class="difflineplus">+      provider: this,</span>
<a href="#l29.142"></a><span id="l29.142" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.143"></a><span id="l29.143" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l29.144"></a><span id="l29.144" class="difflineplus">+      attributeName: &quot;bodyMatches&quot;,</span>
<a href="#l29.145"></a><span id="l29.145" class="difflineplus">+      singular: true,</span>
<a href="#l29.146"></a><span id="l29.146" class="difflineplus">+      special: Gloda.kSpecialFulltext,</span>
<a href="#l29.147"></a><span id="l29.147" class="difflineplus">+      specialColumnName: &quot;body&quot;,</span>
<a href="#l29.148"></a><span id="l29.148" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.149"></a><span id="l29.149" class="difflineplus">+      objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l29.150"></a><span id="l29.150" class="difflineplus">+      }); // not-tested</span>
<a href="#l29.151"></a><span id="l29.151" class="difflineplus">+    </span>
<a href="#l29.152"></a><span id="l29.152" class="difflineplus">+    // conversation</span>
<a href="#l29.153"></a><span id="l29.153" class="difflineplus">+    this._attrConversation = Gloda.defineAttribute({</span>
<a href="#l29.154"></a><span id="l29.154" class="difflineplus">+      provider: this,</span>
<a href="#l29.155"></a><span id="l29.155" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.156"></a><span id="l29.156" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.157"></a><span id="l29.157" class="difflineplus">+      attributeName: &quot;conversation&quot;,</span>
<a href="#l29.158"></a><span id="l29.158" class="difflineplus">+      singular: true,</span>
<a href="#l29.159"></a><span id="l29.159" class="difflineplus">+      special: Gloda.kSpecialColumnParent,</span>
<a href="#l29.160"></a><span id="l29.160" class="difflineplus">+      specialColumnName: &quot;conversationID&quot;,</span>
<a href="#l29.161"></a><span id="l29.161" class="difflineplus">+      idStorageAttributeName: &quot;_conversationID&quot;,</span>
<a href="#l29.162"></a><span id="l29.162" class="difflineplus">+      valueStorageAttributeName: &quot;_conversation&quot;, </span>
<a href="#l29.163"></a><span id="l29.163" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.164"></a><span id="l29.164" class="difflineplus">+      objectNoun: Gloda.NOUN_CONVERSATION,</span>
<a href="#l29.165"></a><span id="l29.165" class="difflineplus">+      });</span>
<a href="#l29.166"></a><span id="l29.166" class="difflineplus">+  </span>
<a href="#l29.167"></a><span id="l29.167" class="difflineplus">+    // --- Fundamental</span>
<a href="#l29.168"></a><span id="l29.168" class="difflineplus">+    // From</span>
<a href="#l29.169"></a><span id="l29.169" class="difflineplus">+    this._attrFrom = Gloda.defineAttribute({</span>
<a href="#l29.170"></a><span id="l29.170" class="difflineplus">+                        provider: this,</span>
<a href="#l29.171"></a><span id="l29.171" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.172"></a><span id="l29.172" class="difflineplus">+                        attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.173"></a><span id="l29.173" class="difflineplus">+                        attributeName: &quot;from&quot;,</span>
<a href="#l29.174"></a><span id="l29.174" class="difflineplus">+                        singular: true,</span>
<a href="#l29.175"></a><span id="l29.175" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.176"></a><span id="l29.176" class="difflineplus">+                        objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l29.177"></a><span id="l29.177" class="difflineplus">+                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l29.178"></a><span id="l29.178" class="difflineplus">+    // To</span>
<a href="#l29.179"></a><span id="l29.179" class="difflineplus">+    this._attrTo = Gloda.defineAttribute({</span>
<a href="#l29.180"></a><span id="l29.180" class="difflineplus">+                        provider: this,</span>
<a href="#l29.181"></a><span id="l29.181" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.182"></a><span id="l29.182" class="difflineplus">+                        attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.183"></a><span id="l29.183" class="difflineplus">+                        attributeName: &quot;to&quot;,</span>
<a href="#l29.184"></a><span id="l29.184" class="difflineplus">+                        singular: false,</span>
<a href="#l29.185"></a><span id="l29.185" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.186"></a><span id="l29.186" class="difflineplus">+                        objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l29.187"></a><span id="l29.187" class="difflineplus">+                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l29.188"></a><span id="l29.188" class="difflineplus">+    // Cc</span>
<a href="#l29.189"></a><span id="l29.189" class="difflineplus">+    this._attrCc = Gloda.defineAttribute({</span>
<a href="#l29.190"></a><span id="l29.190" class="difflineplus">+                        provider: this,</span>
<a href="#l29.191"></a><span id="l29.191" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.192"></a><span id="l29.192" class="difflineplus">+                        attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.193"></a><span id="l29.193" class="difflineplus">+                        attributeName: &quot;cc&quot;,</span>
<a href="#l29.194"></a><span id="l29.194" class="difflineplus">+                        singular: false,</span>
<a href="#l29.195"></a><span id="l29.195" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.196"></a><span id="l29.196" class="difflineplus">+                        objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l29.197"></a><span id="l29.197" class="difflineplus">+                        }); // not-tested</span>
<a href="#l29.198"></a><span id="l29.198" class="difflineplus">+</span>
<a href="#l29.199"></a><span id="l29.199" class="difflineplus">+    // Date.  now lives on the row.</span>
<a href="#l29.200"></a><span id="l29.200" class="difflineplus">+    this._attrDate = Gloda.defineAttribute({</span>
<a href="#l29.201"></a><span id="l29.201" class="difflineplus">+                        provider: this,</span>
<a href="#l29.202"></a><span id="l29.202" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.203"></a><span id="l29.203" class="difflineplus">+                        attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.204"></a><span id="l29.204" class="difflineplus">+                        attributeName: &quot;date&quot;,</span>
<a href="#l29.205"></a><span id="l29.205" class="difflineplus">+                        singular: true,</span>
<a href="#l29.206"></a><span id="l29.206" class="difflineplus">+                        special: Gloda.kSpecialColumn,</span>
<a href="#l29.207"></a><span id="l29.207" class="difflineplus">+                        specialColumnName: &quot;date&quot;,</span>
<a href="#l29.208"></a><span id="l29.208" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.209"></a><span id="l29.209" class="difflineplus">+                        objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l29.210"></a><span id="l29.210" class="difflineplus">+                        }); // tested-by: test_attributes_fundamental</span>
<a href="#l29.211"></a><span id="l29.211" class="difflineplus">+    </span>
<a href="#l29.212"></a><span id="l29.212" class="difflineplus">+    // Attachment MIME Types</span>
<a href="#l29.213"></a><span id="l29.213" class="difflineplus">+    this._attrAttachmentTypes = Gloda.defineAttribute({</span>
<a href="#l29.214"></a><span id="l29.214" class="difflineplus">+      provider: this,</span>
<a href="#l29.215"></a><span id="l29.215" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.216"></a><span id="l29.216" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.217"></a><span id="l29.217" class="difflineplus">+      attributeName: &quot;attachmentTypes&quot;,</span>
<a href="#l29.218"></a><span id="l29.218" class="difflineplus">+      singular: false,</span>
<a href="#l29.219"></a><span id="l29.219" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.220"></a><span id="l29.220" class="difflineplus">+      objectNoun: Gloda.NOUN_MIME_TYPE,</span>
<a href="#l29.221"></a><span id="l29.221" class="difflineplus">+      });</span>
<a href="#l29.222"></a><span id="l29.222" class="difflineplus">+</span>
<a href="#l29.223"></a><span id="l29.223" class="difflineplus">+    // --- Optimization</span>
<a href="#l29.224"></a><span id="l29.224" class="difflineplus">+    // Involves.  Means any of from/to/cc.  The queries get ugly enough without</span>
<a href="#l29.225"></a><span id="l29.225" class="difflineplus">+    //   this that it seems to justify the cost, especially given the frequent</span>
<a href="#l29.226"></a><span id="l29.226" class="difflineplus">+    //   use case.  (In fact, post-filtering for the specific from/to/cc is</span>
<a href="#l29.227"></a><span id="l29.227" class="difflineplus">+    //   probably justifiable rather than losing this attribute...)</span>
<a href="#l29.228"></a><span id="l29.228" class="difflineplus">+    this._attrInvolves = Gloda.defineAttribute({</span>
<a href="#l29.229"></a><span id="l29.229" class="difflineplus">+      provider: this,</span>
<a href="#l29.230"></a><span id="l29.230" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.231"></a><span id="l29.231" class="difflineplus">+      attributeType: Gloda.kAttrOptimization,</span>
<a href="#l29.232"></a><span id="l29.232" class="difflineplus">+      attributeName: &quot;involves&quot;,</span>
<a href="#l29.233"></a><span id="l29.233" class="difflineplus">+      singular: false,</span>
<a href="#l29.234"></a><span id="l29.234" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.235"></a><span id="l29.235" class="difflineplus">+      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l29.236"></a><span id="l29.236" class="difflineplus">+      }); // not-tested</span>
<a href="#l29.237"></a><span id="l29.237" class="difflineplus">+</span>
<a href="#l29.238"></a><span id="l29.238" class="difflineplus">+    // From Me To</span>
<a href="#l29.239"></a><span id="l29.239" class="difflineplus">+    this._attrFromMeTo = Gloda.defineAttribute({</span>
<a href="#l29.240"></a><span id="l29.240" class="difflineplus">+      provider: this,</span>
<a href="#l29.241"></a><span id="l29.241" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.242"></a><span id="l29.242" class="difflineplus">+      attributeType: Gloda.kAttrOptimization,</span>
<a href="#l29.243"></a><span id="l29.243" class="difflineplus">+      attributeName: &quot;fromMeTo&quot;,</span>
<a href="#l29.244"></a><span id="l29.244" class="difflineplus">+      singular: false,</span>
<a href="#l29.245"></a><span id="l29.245" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.246"></a><span id="l29.246" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l29.247"></a><span id="l29.247" class="difflineplus">+      }); // not-tested</span>
<a href="#l29.248"></a><span id="l29.248" class="difflineplus">+    // From Me Cc</span>
<a href="#l29.249"></a><span id="l29.249" class="difflineplus">+    this._attrFromMeCc = Gloda.defineAttribute({</span>
<a href="#l29.250"></a><span id="l29.250" class="difflineplus">+      provider: this,</span>
<a href="#l29.251"></a><span id="l29.251" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.252"></a><span id="l29.252" class="difflineplus">+      attributeType: Gloda.kAttrOptimization,</span>
<a href="#l29.253"></a><span id="l29.253" class="difflineplus">+      attributeName: &quot;fromMeCc&quot;,</span>
<a href="#l29.254"></a><span id="l29.254" class="difflineplus">+      singular: false,</span>
<a href="#l29.255"></a><span id="l29.255" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.256"></a><span id="l29.256" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l29.257"></a><span id="l29.257" class="difflineplus">+      }); // not-tested</span>
<a href="#l29.258"></a><span id="l29.258" class="difflineplus">+    // To Me</span>
<a href="#l29.259"></a><span id="l29.259" class="difflineplus">+    this._attrToMe = Gloda.defineAttribute({</span>
<a href="#l29.260"></a><span id="l29.260" class="difflineplus">+      provider: this,</span>
<a href="#l29.261"></a><span id="l29.261" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.262"></a><span id="l29.262" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.263"></a><span id="l29.263" class="difflineplus">+      attributeName: &quot;toMe&quot;,</span>
<a href="#l29.264"></a><span id="l29.264" class="difflineplus">+      singular: false,</span>
<a href="#l29.265"></a><span id="l29.265" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.266"></a><span id="l29.266" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l29.267"></a><span id="l29.267" class="difflineplus">+      }); // not-tested</span>
<a href="#l29.268"></a><span id="l29.268" class="difflineplus">+    // Cc Me</span>
<a href="#l29.269"></a><span id="l29.269" class="difflineplus">+    this._attrCcMe = Gloda.defineAttribute({</span>
<a href="#l29.270"></a><span id="l29.270" class="difflineplus">+      provider: this,</span>
<a href="#l29.271"></a><span id="l29.271" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.272"></a><span id="l29.272" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.273"></a><span id="l29.273" class="difflineplus">+      attributeName: &quot;ccMe&quot;,</span>
<a href="#l29.274"></a><span id="l29.274" class="difflineplus">+      singular: false,</span>
<a href="#l29.275"></a><span id="l29.275" class="difflineplus">+      subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.276"></a><span id="l29.276" class="difflineplus">+      objectNoun: Gloda.NOUN_PARAM_IDENTITY,</span>
<a href="#l29.277"></a><span id="l29.277" class="difflineplus">+      }); // not-tested</span>
<a href="#l29.278"></a><span id="l29.278" class="difflineplus">+</span>
<a href="#l29.279"></a><span id="l29.279" class="difflineplus">+</span>
<a href="#l29.280"></a><span id="l29.280" class="difflineplus">+    // -- Mailing List</span>
<a href="#l29.281"></a><span id="l29.281" class="difflineplus">+    // Non-singular, but a hard call.  Namely, it is obvious that a message can</span>
<a href="#l29.282"></a><span id="l29.282" class="difflineplus">+    //  be addressed to multiple mailing lists.  However, I don't see how you</span>
<a href="#l29.283"></a><span id="l29.283" class="difflineplus">+    //  could receive a message with more than one set of List-* headers,</span>
<a href="#l29.284"></a><span id="l29.284" class="difflineplus">+    //  since each list-serve would each send you a copy.  Based on our current</span>
<a href="#l29.285"></a><span id="l29.285" class="difflineplus">+    //  decision to treat each physical message as separate, it almost seems</span>
<a href="#l29.286"></a><span id="l29.286" class="difflineplus">+    //  right to limit the list attribute to the copy that originated at the</span>
<a href="#l29.287"></a><span id="l29.287" class="difflineplus">+    //  list.  That may sound entirely wrong, but keep in mind that until we</span>
<a href="#l29.288"></a><span id="l29.288" class="difflineplus">+    //  have seen a message from the list with the List headers, we can't</span>
<a href="#l29.289"></a><span id="l29.289" class="difflineplus">+    //  definitely know it's a mailing list (although heuristics could take us</span>
<a href="#l29.290"></a><span id="l29.290" class="difflineplus">+    //  pretty far).  As such, the quasi-singular thing is appealing.</span>
<a href="#l29.291"></a><span id="l29.291" class="difflineplus">+    // Of course, the reality is that we really want to know if a message was</span>
<a href="#l29.292"></a><span id="l29.292" class="difflineplus">+    //  sent to multiple mailing lists and be able to query on that.</span>
<a href="#l29.293"></a><span id="l29.293" class="difflineplus">+    //  Additionally, our implicit-to logic needs to work on messages that</span>
<a href="#l29.294"></a><span id="l29.294" class="difflineplus">+    //  weren't relayed by the list-serve, especially messages sent to the list</span>
<a href="#l29.295"></a><span id="l29.295" class="difflineplus">+    //  by the user.</span>
<a href="#l29.296"></a><span id="l29.296" class="difflineplus">+    this._attrList = Gloda.defineAttribute({</span>
<a href="#l29.297"></a><span id="l29.297" class="difflineplus">+                        provider: this,</span>
<a href="#l29.298"></a><span id="l29.298" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l29.299"></a><span id="l29.299" class="difflineplus">+                        attributeType: Gloda.kAttrFundamental,</span>
<a href="#l29.300"></a><span id="l29.300" class="difflineplus">+                        attributeName: &quot;mailing-list&quot;,</span>
<a href="#l29.301"></a><span id="l29.301" class="difflineplus">+                        bindName: &quot;mailingLists&quot;,</span>
<a href="#l29.302"></a><span id="l29.302" class="difflineplus">+                        singular: false,</span>
<a href="#l29.303"></a><span id="l29.303" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l29.304"></a><span id="l29.304" class="difflineplus">+                        objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l29.305"></a><span id="l29.305" class="difflineplus">+                        }); // not-tested, not-implemented</span>
<a href="#l29.306"></a><span id="l29.306" class="difflineplus">+  },</span>
<a href="#l29.307"></a><span id="l29.307" class="difflineplus">+  </span>
<a href="#l29.308"></a><span id="l29.308" class="difflineplus">+  /**</span>
<a href="#l29.309"></a><span id="l29.309" class="difflineplus">+   *</span>
<a href="#l29.310"></a><span id="l29.310" class="difflineplus">+   * Specializations:</span>
<a href="#l29.311"></a><span id="l29.311" class="difflineplus">+   * - Mailing Lists.  Replies to a message on a mailing list frequently only</span>
<a href="#l29.312"></a><span id="l29.312" class="difflineplus">+   *   have the list-serve as the 'to', so we try to generate a synthetic 'to'</span>
<a href="#l29.313"></a><span id="l29.313" class="difflineplus">+   *   based on the author of the parent message when possible.  (The 'possible'</span>
<a href="#l29.314"></a><span id="l29.314" class="difflineplus">+   *   part is that we may not have a copy of the parent message at the time of</span>
<a href="#l29.315"></a><span id="l29.315" class="difflineplus">+   *   processing.)</span>
<a href="#l29.316"></a><span id="l29.316" class="difflineplus">+   * - Newsgroups.  Same deal as mailing lists.</span>
<a href="#l29.317"></a><span id="l29.317" class="difflineplus">+   */</span>
<a href="#l29.318"></a><span id="l29.318" class="difflineplus">+  process: function gloda_fundattr_process(aGlodaMessage, aRawReps,</span>
<a href="#l29.319"></a><span id="l29.319" class="difflineplus">+                                           aIsNew, aCallbackHandle) {</span>
<a href="#l29.320"></a><span id="l29.320" class="difflineplus">+    let aMsgHdr = aRawReps.header;</span>
<a href="#l29.321"></a><span id="l29.321" class="difflineplus">+    let aMimeMsg = aRawReps.mime;</span>
<a href="#l29.322"></a><span id="l29.322" class="difflineplus">+    </span>
<a href="#l29.323"></a><span id="l29.323" class="difflineplus">+    // -- From</span>
<a href="#l29.324"></a><span id="l29.324" class="difflineplus">+    // Let's use replyTo if available.</span>
<a href="#l29.325"></a><span id="l29.325" class="difflineplus">+    // er, since we are just dealing with mailing lists for now, forget the</span>
<a href="#l29.326"></a><span id="l29.326" class="difflineplus">+    //  reply-to...</span>
<a href="#l29.327"></a><span id="l29.327" class="difflineplus">+    // TODO: deal with default charset issues</span>
<a href="#l29.328"></a><span id="l29.328" class="difflineplus">+    let author = null;</span>
<a href="#l29.329"></a><span id="l29.329" class="difflineplus">+    /*</span>
<a href="#l29.330"></a><span id="l29.330" class="difflineplus">+    try {</span>
<a href="#l29.331"></a><span id="l29.331" class="difflineplus">+      author = aMsgHdr.getStringProperty(&quot;replyTo&quot;);</span>
<a href="#l29.332"></a><span id="l29.332" class="difflineplus">+    }</span>
<a href="#l29.333"></a><span id="l29.333" class="difflineplus">+    catch (ex) {</span>
<a href="#l29.334"></a><span id="l29.334" class="difflineplus">+    }</span>
<a href="#l29.335"></a><span id="l29.335" class="difflineplus">+    */</span>
<a href="#l29.336"></a><span id="l29.336" class="difflineplus">+    if (author == null || author == &quot;&quot;)</span>
<a href="#l29.337"></a><span id="l29.337" class="difflineplus">+      author = aMsgHdr.author;</span>
<a href="#l29.338"></a><span id="l29.338" class="difflineplus">+    </span>
<a href="#l29.339"></a><span id="l29.339" class="difflineplus">+    let [authorIdentities, toIdentities, ccIdentities] =</span>
<a href="#l29.340"></a><span id="l29.340" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l29.341"></a><span id="l29.341" class="difflineplus">+        Gloda.getOrCreateMailIdentities(aCallbackHandle,</span>
<a href="#l29.342"></a><span id="l29.342" class="difflineplus">+                                        author, aMsgHdr.recipients,</span>
<a href="#l29.343"></a><span id="l29.343" class="difflineplus">+                                        aMsgHdr.ccList));</span>
<a href="#l29.344"></a><span id="l29.344" class="difflineplus">+</span>
<a href="#l29.345"></a><span id="l29.345" class="difflineplus">+    if (authorIdentities.length == 0) {</span>
<a href="#l29.346"></a><span id="l29.346" class="difflineplus">+      this._log.error(&quot;Message with subject '&quot; + aMsgHdr.mime2DecodedSubject +</span>
<a href="#l29.347"></a><span id="l29.347" class="difflineplus">+                      &quot;' somehow lacks a valid author.  Bailing.&quot;);</span>
<a href="#l29.348"></a><span id="l29.348" class="difflineplus">+      return; // being a generator, this generates an exception; we like.</span>
<a href="#l29.349"></a><span id="l29.349" class="difflineplus">+    }</span>
<a href="#l29.350"></a><span id="l29.350" class="difflineplus">+    let authorIdentity = authorIdentities[0];</span>
<a href="#l29.351"></a><span id="l29.351" class="difflineplus">+    aGlodaMessage.from = authorIdentity;</span>
<a href="#l29.352"></a><span id="l29.352" class="difflineplus">+</span>
<a href="#l29.353"></a><span id="l29.353" class="difflineplus">+    // -- To, Cc</span>
<a href="#l29.354"></a><span id="l29.354" class="difflineplus">+    aGlodaMessage.to = toIdentities;</span>
<a href="#l29.355"></a><span id="l29.355" class="difflineplus">+    aGlodaMessage.cc = ccIdentities;</span>
<a href="#l29.356"></a><span id="l29.356" class="difflineplus">+    </span>
<a href="#l29.357"></a><span id="l29.357" class="difflineplus">+    // -- Attachments</span>
<a href="#l29.358"></a><span id="l29.358" class="difflineplus">+    let attachmentTypes = [];</span>
<a href="#l29.359"></a><span id="l29.359" class="difflineplus">+    for each (let attachment in aMimeMsg.allAttachments) {</span>
<a href="#l29.360"></a><span id="l29.360" class="difflineplus">+      if (attachment.isRealAttachment) {</span>
<a href="#l29.361"></a><span id="l29.361" class="difflineplus">+        attachmentTypes.push(MimeTypeNoun.getMimeType(attachment.contentType));</span>
<a href="#l29.362"></a><span id="l29.362" class="difflineplus">+      }</span>
<a href="#l29.363"></a><span id="l29.363" class="difflineplus">+    }</span>
<a href="#l29.364"></a><span id="l29.364" class="difflineplus">+    if (attachmentTypes.length) {</span>
<a href="#l29.365"></a><span id="l29.365" class="difflineplus">+      aGlodaMessage.attachmentTypes = attachmentTypes;</span>
<a href="#l29.366"></a><span id="l29.366" class="difflineplus">+    }</span>
<a href="#l29.367"></a><span id="l29.367" class="difflineplus">+    </span>
<a href="#l29.368"></a><span id="l29.368" class="difflineplus">+    // TODO: deal with mailing lists, including implicit-to.  this will require</span>
<a href="#l29.369"></a><span id="l29.369" class="difflineplus">+    //  convincing the indexer to pass us in the previous message if it is</span>
<a href="#l29.370"></a><span id="l29.370" class="difflineplus">+    //  available.  (which we'll simply pass to everyone... it can help body</span>
<a href="#l29.371"></a><span id="l29.371" class="difflineplus">+    //  logic for quoting purposes, etc. too.)</span>
<a href="#l29.372"></a><span id="l29.372" class="difflineplus">+    </span>
<a href="#l29.373"></a><span id="l29.373" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l29.374"></a><span id="l29.374" class="difflineplus">+  },</span>
<a href="#l29.375"></a><span id="l29.375" class="difflineplus">+  </span>
<a href="#l29.376"></a><span id="l29.376" class="difflineplus">+  optimize: function gloda_fundattr_process(aGlodaMessage, aRawReps,</span>
<a href="#l29.377"></a><span id="l29.377" class="difflineplus">+      aIsNew, aCallbackHandle) {</span>
<a href="#l29.378"></a><span id="l29.378" class="difflineplus">+</span>
<a href="#l29.379"></a><span id="l29.379" class="difflineplus">+    let involvesIdentities = {};</span>
<a href="#l29.380"></a><span id="l29.380" class="difflineplus">+    let involves = aGlodaMessage.involves || [];</span>
<a href="#l29.381"></a><span id="l29.381" class="difflineplus">+    </span>
<a href="#l29.382"></a><span id="l29.382" class="difflineplus">+    // me specialization optimizations</span>
<a href="#l29.383"></a><span id="l29.383" class="difflineplus">+    let toMe = aGlodaMessage.toMe || [];</span>
<a href="#l29.384"></a><span id="l29.384" class="difflineplus">+    let fromMeTo = aGlodaMessage.fromMeTo || [];</span>
<a href="#l29.385"></a><span id="l29.385" class="difflineplus">+    let ccMe = aGlodaMessage.ccMe || [];</span>
<a href="#l29.386"></a><span id="l29.386" class="difflineplus">+    let fromMeCc = aGlodaMessage.fromMeCc || [];</span>
<a href="#l29.387"></a><span id="l29.387" class="difflineplus">+</span>
<a href="#l29.388"></a><span id="l29.388" class="difflineplus">+    let myIdentities = Gloda.myIdentities; // needless optimization?</span>
<a href="#l29.389"></a><span id="l29.389" class="difflineplus">+    let authorIdentity = aGlodaMessage.from;</span>
<a href="#l29.390"></a><span id="l29.390" class="difflineplus">+    let isFromMe = authorIdentity.id in myIdentities;</span>
<a href="#l29.391"></a><span id="l29.391" class="difflineplus">+</span>
<a href="#l29.392"></a><span id="l29.392" class="difflineplus">+    involves.push(authorIdentity);</span>
<a href="#l29.393"></a><span id="l29.393" class="difflineplus">+    involvesIdentities[authorIdentity.id] = true;</span>
<a href="#l29.394"></a><span id="l29.394" class="difflineplus">+    </span>
<a href="#l29.395"></a><span id="l29.395" class="difflineplus">+    for each (let [,toIdentity] in Iterator(aGlodaMessage.to)) {</span>
<a href="#l29.396"></a><span id="l29.396" class="difflineplus">+      if (!(toIdentity.id in involvesIdentities)) {</span>
<a href="#l29.397"></a><span id="l29.397" class="difflineplus">+        involves.push(toIdentity);</span>
<a href="#l29.398"></a><span id="l29.398" class="difflineplus">+        involvesIdentities[toIdentity.id] = true;</span>
<a href="#l29.399"></a><span id="l29.399" class="difflineplus">+      }</span>
<a href="#l29.400"></a><span id="l29.400" class="difflineplus">+      </span>
<a href="#l29.401"></a><span id="l29.401" class="difflineplus">+      // optimization attribute to-me ('I' am the parameter)</span>
<a href="#l29.402"></a><span id="l29.402" class="difflineplus">+      if (toIdentity.id in myIdentities) {</span>
<a href="#l29.403"></a><span id="l29.403" class="difflineplus">+        toMe.push([toIdentity, authorIdentity]);</span>
<a href="#l29.404"></a><span id="l29.404" class="difflineplus">+        if (aIsNew)</span>
<a href="#l29.405"></a><span id="l29.405" class="difflineplus">+          authorIdentity.contact.popularity += this.POPULARITY_TO_ME;</span>
<a href="#l29.406"></a><span id="l29.406" class="difflineplus">+      }</span>
<a href="#l29.407"></a><span id="l29.407" class="difflineplus">+      // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l29.408"></a><span id="l29.408" class="difflineplus">+      if (isFromMe) {</span>
<a href="#l29.409"></a><span id="l29.409" class="difflineplus">+        fromMeTo.push([authorIdentity, toIdentity]);</span>
<a href="#l29.410"></a><span id="l29.410" class="difflineplus">+        // also, popularity</span>
<a href="#l29.411"></a><span id="l29.411" class="difflineplus">+        if (aIsNew)</span>
<a href="#l29.412"></a><span id="l29.412" class="difflineplus">+          toIdentity.contact.popularity += this.POPULARITY_FROM_ME_TO;</span>
<a href="#l29.413"></a><span id="l29.413" class="difflineplus">+      }</span>
<a href="#l29.414"></a><span id="l29.414" class="difflineplus">+    }</span>
<a href="#l29.415"></a><span id="l29.415" class="difflineplus">+    for each (let [,ccIdentity] in Iterator(aGlodaMessage.cc)) {</span>
<a href="#l29.416"></a><span id="l29.416" class="difflineplus">+      if (!(ccIdentity.id in involvesIdentities)) {</span>
<a href="#l29.417"></a><span id="l29.417" class="difflineplus">+        involves.push(ccIdentity);</span>
<a href="#l29.418"></a><span id="l29.418" class="difflineplus">+        involvesIdentities[ccIdentity.id] = true;</span>
<a href="#l29.419"></a><span id="l29.419" class="difflineplus">+      }</span>
<a href="#l29.420"></a><span id="l29.420" class="difflineplus">+      // optimization attribute cc-me ('I' am the parameter)</span>
<a href="#l29.421"></a><span id="l29.421" class="difflineplus">+      if (ccIdentity.id in myIdentities) {</span>
<a href="#l29.422"></a><span id="l29.422" class="difflineplus">+        ccMe.push([ccIdentity, authorIdentity]);</span>
<a href="#l29.423"></a><span id="l29.423" class="difflineplus">+        if (aIsNew)</span>
<a href="#l29.424"></a><span id="l29.424" class="difflineplus">+          authorIdentity.contact.popularity += this.POPULARITY_CC_ME;</span>
<a href="#l29.425"></a><span id="l29.425" class="difflineplus">+      }</span>
<a href="#l29.426"></a><span id="l29.426" class="difflineplus">+      // optimization attribute from-me-to ('I' am the parameter)</span>
<a href="#l29.427"></a><span id="l29.427" class="difflineplus">+      if (isFromMe) {</span>
<a href="#l29.428"></a><span id="l29.428" class="difflineplus">+        fromMeCc.push([authorIdentity, ccIdentity]);</span>
<a href="#l29.429"></a><span id="l29.429" class="difflineplus">+        // also, popularity</span>
<a href="#l29.430"></a><span id="l29.430" class="difflineplus">+        if (aIsNew)</span>
<a href="#l29.431"></a><span id="l29.431" class="difflineplus">+          ccIdentity.contact.popularity += this.POPULARITY_FROM_ME_CC;</span>
<a href="#l29.432"></a><span id="l29.432" class="difflineplus">+      }</span>
<a href="#l29.433"></a><span id="l29.433" class="difflineplus">+    }</span>
<a href="#l29.434"></a><span id="l29.434" class="difflineplus">+    </span>
<a href="#l29.435"></a><span id="l29.435" class="difflineplus">+    aGlodaMessage.involves = involves;</span>
<a href="#l29.436"></a><span id="l29.436" class="difflineplus">+    if (toMe.length)</span>
<a href="#l29.437"></a><span id="l29.437" class="difflineplus">+      aGlodaMessage.toMe = toMe;</span>
<a href="#l29.438"></a><span id="l29.438" class="difflineplus">+    if (fromMeTo.length)</span>
<a href="#l29.439"></a><span id="l29.439" class="difflineplus">+      aGlodaMessage.fromMeTo = fromMeTo;</span>
<a href="#l29.440"></a><span id="l29.440" class="difflineplus">+    if (ccMe.length)</span>
<a href="#l29.441"></a><span id="l29.441" class="difflineplus">+      aGlodaMessage.ccMe = ccMe;</span>
<a href="#l29.442"></a><span id="l29.442" class="difflineplus">+    if (fromMeCc.length)</span>
<a href="#l29.443"></a><span id="l29.443" class="difflineplus">+      aGlodaMessage.fromMeCc = fromMeCc;</span>
<a href="#l29.444"></a><span id="l29.444" class="difflineplus">+    </span>
<a href="#l29.445"></a><span id="l29.445" class="difflineplus">+    if (aRawReps.bodyLines &amp;&amp;</span>
<a href="#l29.446"></a><span id="l29.446" class="difflineplus">+        this.contentWhittle(aGlodaMessage, {}, aRawReps.bodyLines,</span>
<a href="#l29.447"></a><span id="l29.447" class="difflineplus">+                            aRawReps.content)) {</span>
<a href="#l29.448"></a><span id="l29.448" class="difflineplus">+      // we were going to do something here?</span>
<a href="#l29.449"></a><span id="l29.449" class="difflineplus">+    }</span>
<a href="#l29.450"></a><span id="l29.450" class="difflineplus">+</span>
<a href="#l29.451"></a><span id="l29.451" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l29.452"></a><span id="l29.452" class="difflineplus">+  },</span>
<a href="#l29.453"></a><span id="l29.453" class="difflineplus">+  </span>
<a href="#l29.454"></a><span id="l29.454" class="difflineplus">+  _countQuoteDepthAndNormalize:</span>
<a href="#l29.455"></a><span id="l29.455" class="difflineplus">+    function gloda_fundattr__countQuoteDepthAndNormalize(aLine) {</span>
<a href="#l29.456"></a><span id="l29.456" class="difflineplus">+    let count = 0;</span>
<a href="#l29.457"></a><span id="l29.457" class="difflineplus">+    let lastStartOffset = 0;</span>
<a href="#l29.458"></a><span id="l29.458" class="difflineplus">+    </span>
<a href="#l29.459"></a><span id="l29.459" class="difflineplus">+    for (let i = 0; i &lt; aLine.length; i++) {</span>
<a href="#l29.460"></a><span id="l29.460" class="difflineplus">+      let c = aLine[i];</span>
<a href="#l29.461"></a><span id="l29.461" class="difflineplus">+      if (c == &quot;&gt;&quot;) {</span>
<a href="#l29.462"></a><span id="l29.462" class="difflineplus">+        count++;</span>
<a href="#l29.463"></a><span id="l29.463" class="difflineplus">+        lastStartOffset = i+1;</span>
<a href="#l29.464"></a><span id="l29.464" class="difflineplus">+      }</span>
<a href="#l29.465"></a><span id="l29.465" class="difflineplus">+      else if (c == &quot; &quot;) {</span>
<a href="#l29.466"></a><span id="l29.466" class="difflineplus">+      }</span>
<a href="#l29.467"></a><span id="l29.467" class="difflineplus">+      else {</span>
<a href="#l29.468"></a><span id="l29.468" class="difflineplus">+        return [count,</span>
<a href="#l29.469"></a><span id="l29.469" class="difflineplus">+                lastStartOffset ? aLine.substring(lastStartOffset) : aLine];</span>
<a href="#l29.470"></a><span id="l29.470" class="difflineplus">+      }</span>
<a href="#l29.471"></a><span id="l29.471" class="difflineplus">+    }</span>
<a href="#l29.472"></a><span id="l29.472" class="difflineplus">+    </span>
<a href="#l29.473"></a><span id="l29.473" class="difflineplus">+    return [count, lastStartOffset ? aLine.substring(lastStartOffset) : aLine];</span>
<a href="#l29.474"></a><span id="l29.474" class="difflineplus">+  },</span>
<a href="#l29.475"></a><span id="l29.475" class="difflineplus">+  </span>
<a href="#l29.476"></a><span id="l29.476" class="difflineplus">+  /**</span>
<a href="#l29.477"></a><span id="l29.477" class="difflineplus">+   * Attempt to understand simple quoting constructs that use &quot;&gt;&quot; with</span>
<a href="#l29.478"></a><span id="l29.478" class="difflineplus">+   * obvious phrases to enter the quoting block.  No support for other types</span>
<a href="#l29.479"></a><span id="l29.479" class="difflineplus">+   * of quoting at this time.  Also no support for piercing the wrapper of</span>
<a href="#l29.480"></a><span id="l29.480" class="difflineplus">+   * forwarded messages to actually be the content of the forwarded message.</span>
<a href="#l29.481"></a><span id="l29.481" class="difflineplus">+   */</span>
<a href="#l29.482"></a><span id="l29.482" class="difflineplus">+  contentWhittle: function gloda_fundattr_contentWhittle(aGlodaMessage,</span>
<a href="#l29.483"></a><span id="l29.483" class="difflineplus">+      aMeta, aBodyLines, aContent) {</span>
<a href="#l29.484"></a><span id="l29.484" class="difflineplus">+    if (!aContent.volunteerContent(aContent.kPriorityBase))</span>
<a href="#l29.485"></a><span id="l29.485" class="difflineplus">+      return false;</span>
<a href="#l29.486"></a><span id="l29.486" class="difflineplus">+    </span>
<a href="#l29.487"></a><span id="l29.487" class="difflineplus">+    // duplicate the list; we mutate somewhat...</span>
<a href="#l29.488"></a><span id="l29.488" class="difflineplus">+    let bodyLines = aBodyLines.concat();</span>
<a href="#l29.489"></a><span id="l29.489" class="difflineplus">+    </span>
<a href="#l29.490"></a><span id="l29.490" class="difflineplus">+    let rangeStart = 0, lastNonBlankLine = null;</span>
<a href="#l29.491"></a><span id="l29.491" class="difflineplus">+    let inQuoteDepth = 0;</span>
<a href="#l29.492"></a><span id="l29.492" class="difflineplus">+    for each (let [iLine, line] in Iterator(bodyLines)) {</span>
<a href="#l29.493"></a><span id="l29.493" class="difflineplus">+      if (!line)</span>
<a href="#l29.494"></a><span id="l29.494" class="difflineplus">+        continue;</span>
<a href="#l29.495"></a><span id="l29.495" class="difflineplus">+      </span>
<a href="#l29.496"></a><span id="l29.496" class="difflineplus">+      if (line[0] == &quot;&gt;&quot;) {</span>
<a href="#l29.497"></a><span id="l29.497" class="difflineplus">+        if (!inQuoteDepth) {</span>
<a href="#l29.498"></a><span id="l29.498" class="difflineplus">+          let rangeEnd = iLine - 1;</span>
<a href="#l29.499"></a><span id="l29.499" class="difflineplus">+          let quoteRangeStart = iLine;</span>
<a href="#l29.500"></a><span id="l29.500" class="difflineplus">+          // see if the last non-blank-line was a lead-in...</span>
<a href="#l29.501"></a><span id="l29.501" class="difflineplus">+          if (lastNonBlankLine != null) {</span>
<a href="#l29.502"></a><span id="l29.502" class="difflineplus">+            if (aBodyLines[lastNonBlankLine].indexOf(&quot;wrote&quot;) &gt;= 0) {</span>
<a href="#l29.503"></a><span id="l29.503" class="difflineplus">+              quoteRangeStart = lastNonBlankLine;</span>
<a href="#l29.504"></a><span id="l29.504" class="difflineplus">+              rangeEnd = lastNonBlankLine - 1;</span>
<a href="#l29.505"></a><span id="l29.505" class="difflineplus">+            }</span>
<a href="#l29.506"></a><span id="l29.506" class="difflineplus">+          }</span>
<a href="#l29.507"></a><span id="l29.507" class="difflineplus">+          if (rangeEnd &gt;= rangeStart)</span>
<a href="#l29.508"></a><span id="l29.508" class="difflineplus">+            aContent.content(aBodyLines.slice(rangeStart, rangeEnd+1));</span>
<a href="#l29.509"></a><span id="l29.509" class="difflineplus">+          </span>
<a href="#l29.510"></a><span id="l29.510" class="difflineplus">+          [inQuoteDepth, line] = this._countQuoteDepthAndNormalize(line);</span>
<a href="#l29.511"></a><span id="l29.511" class="difflineplus">+          bodyLines[iLine] = line;</span>
<a href="#l29.512"></a><span id="l29.512" class="difflineplus">+          rangeStart = quoteRangeStart;</span>
<a href="#l29.513"></a><span id="l29.513" class="difflineplus">+        }</span>
<a href="#l29.514"></a><span id="l29.514" class="difflineplus">+        else {</span>
<a href="#l29.515"></a><span id="l29.515" class="difflineplus">+          let curQuoteDepth;</span>
<a href="#l29.516"></a><span id="l29.516" class="difflineplus">+          [curQuoteDepth, line] = this._countQuoteDepthAndNormalize(line);</span>
<a href="#l29.517"></a><span id="l29.517" class="difflineplus">+          bodyLines[iLine] = line;</span>
<a href="#l29.518"></a><span id="l29.518" class="difflineplus">+          </span>
<a href="#l29.519"></a><span id="l29.519" class="difflineplus">+          if (curQuoteDepth != inQuoteDepth) {</span>
<a href="#l29.520"></a><span id="l29.520" class="difflineplus">+            // we could do some &quot;wrote&quot; compensation here, but it's not really</span>
<a href="#l29.521"></a><span id="l29.521" class="difflineplus">+            //  as important.  let's wait for a more clever algorithm.</span>
<a href="#l29.522"></a><span id="l29.522" class="difflineplus">+            aContent.quoted(aBodyLines.slice(rangeStart, iLine), inQuoteDepth);</span>
<a href="#l29.523"></a><span id="l29.523" class="difflineplus">+            inQuoteDepth = curQuoteDepth;</span>
<a href="#l29.524"></a><span id="l29.524" class="difflineplus">+            rangeStart = iLine;</span>
<a href="#l29.525"></a><span id="l29.525" class="difflineplus">+          }</span>
<a href="#l29.526"></a><span id="l29.526" class="difflineplus">+        }</span>
<a href="#l29.527"></a><span id="l29.527" class="difflineplus">+      }</span>
<a href="#l29.528"></a><span id="l29.528" class="difflineplus">+      else {</span>
<a href="#l29.529"></a><span id="l29.529" class="difflineplus">+        if (inQuoteDepth) {</span>
<a href="#l29.530"></a><span id="l29.530" class="difflineplus">+          aContent.quoted(aBodyLines.slice(rangeStart, iLine), inQuoteDepth);</span>
<a href="#l29.531"></a><span id="l29.531" class="difflineplus">+          inQuoteDepth = 0;</span>
<a href="#l29.532"></a><span id="l29.532" class="difflineplus">+          rangeStart = iLine;</span>
<a href="#l29.533"></a><span id="l29.533" class="difflineplus">+        }</span>
<a href="#l29.534"></a><span id="l29.534" class="difflineplus">+      }</span>
<a href="#l29.535"></a><span id="l29.535" class="difflineplus">+      </span>
<a href="#l29.536"></a><span id="l29.536" class="difflineplus">+      lastNonBlankLine = iLine;</span>
<a href="#l29.537"></a><span id="l29.537" class="difflineplus">+    }</span>
<a href="#l29.538"></a><span id="l29.538" class="difflineplus">+    </span>
<a href="#l29.539"></a><span id="l29.539" class="difflineplus">+    if (inQuoteDepth) {</span>
<a href="#l29.540"></a><span id="l29.540" class="difflineplus">+      aContent.quoted(aBodyLines.slice(rangeStart), inQuoteDepth);</span>
<a href="#l29.541"></a><span id="l29.541" class="difflineplus">+    }</span>
<a href="#l29.542"></a><span id="l29.542" class="difflineplus">+    else {</span>
<a href="#l29.543"></a><span id="l29.543" class="difflineplus">+      aContent.content(aBodyLines.slice(rangeStart));</span>
<a href="#l29.544"></a><span id="l29.544" class="difflineplus">+    }</span>
<a href="#l29.545"></a><span id="l29.545" class="difflineplus">+    </span>
<a href="#l29.546"></a><span id="l29.546" class="difflineplus">+    return true;</span>
<a href="#l29.547"></a><span id="l29.547" class="difflineplus">+  },</span>
<a href="#l29.548"></a><span id="l29.548" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1">new file mode 100644</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineminus">--- /dev/null</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/gloda.js</span>
<a href="#l30.4"></a><span id="l30.4" class="difflineat">@@ -0,0 +1,1643 @@</span>
<a href="#l30.5"></a><span id="l30.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l30.6"></a><span id="l30.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l30.7"></a><span id="l30.7" class="difflineplus">+ *</span>
<a href="#l30.8"></a><span id="l30.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l30.9"></a><span id="l30.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l30.10"></a><span id="l30.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l30.11"></a><span id="l30.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineplus">+ *</span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l30.14"></a><span id="l30.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l30.15"></a><span id="l30.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l30.16"></a><span id="l30.16" class="difflineplus">+ * License.</span>
<a href="#l30.17"></a><span id="l30.17" class="difflineplus">+ *</span>
<a href="#l30.18"></a><span id="l30.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l30.19"></a><span id="l30.19" class="difflineplus">+ *</span>
<a href="#l30.20"></a><span id="l30.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l30.21"></a><span id="l30.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l30.22"></a><span id="l30.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l30.23"></a><span id="l30.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l30.24"></a><span id="l30.24" class="difflineplus">+ *</span>
<a href="#l30.25"></a><span id="l30.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l30.26"></a><span id="l30.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l30.27"></a><span id="l30.27" class="difflineplus">+ *</span>
<a href="#l30.28"></a><span id="l30.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l30.29"></a><span id="l30.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l30.30"></a><span id="l30.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l30.31"></a><span id="l30.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l30.32"></a><span id="l30.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l30.33"></a><span id="l30.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l30.34"></a><span id="l30.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l30.35"></a><span id="l30.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l30.36"></a><span id="l30.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l30.37"></a><span id="l30.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l30.38"></a><span id="l30.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l30.39"></a><span id="l30.39" class="difflineplus">+ *</span>
<a href="#l30.40"></a><span id="l30.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l30.41"></a><span id="l30.41" class="difflineplus">+</span>
<a href="#l30.42"></a><span id="l30.42" class="difflineplus">+EXPORTED_SYMBOLS = ['Gloda'];</span>
<a href="#l30.43"></a><span id="l30.43" class="difflineplus">+</span>
<a href="#l30.44"></a><span id="l30.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l30.47"></a><span id="l30.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l30.48"></a><span id="l30.48" class="difflineplus">+</span>
<a href="#l30.49"></a><span id="l30.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l30.50"></a><span id="l30.50" class="difflineplus">+</span>
<a href="#l30.51"></a><span id="l30.51" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l30.52"></a><span id="l30.52" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l30.53"></a><span id="l30.53" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l30.54"></a><span id="l30.54" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/connotent.js&quot;);</span>
<a href="#l30.55"></a><span id="l30.55" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/query.js&quot;);</span>
<a href="#l30.56"></a><span id="l30.56" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l30.57"></a><span id="l30.57" class="difflineplus">+</span>
<a href="#l30.58"></a><span id="l30.58" class="difflineplus">+/**</span>
<a href="#l30.59"></a><span id="l30.59" class="difflineplus">+ * Provides the user-visible (and extension visible) global database</span>
<a href="#l30.60"></a><span id="l30.60" class="difflineplus">+ *  functionality.  There is currently a dependency/ordering</span>
<a href="#l30.61"></a><span id="l30.61" class="difflineplus">+ *  problem in that the concept of 'gloda' also includes some logic that is</span>
<a href="#l30.62"></a><span id="l30.62" class="difflineplus">+ *  contributed by built-in extensions, if you will.  Those built-in extensions</span>
<a href="#l30.63"></a><span id="l30.63" class="difflineplus">+ *  (fundattr.js, explattr.js) also import this file.  To avoid a circular</span>
<a href="#l30.64"></a><span id="l30.64" class="difflineplus">+ *  dependency, those built-in extensions are loaded by everybody.js.  The</span>
<a href="#l30.65"></a><span id="l30.65" class="difflineplus">+ *  simplest/best solution is probably to move everybody.js to be gloda.js and</span>
<a href="#l30.66"></a><span id="l30.66" class="difflineplus">+ *  have it re-export only 'Gloda'.  gloda.js (this file) can then move to be</span>
<a href="#l30.67"></a><span id="l30.67" class="difflineplus">+ *  gloda_int.js (or whatever our eventual naming scheme is), which built-in</span>
<a href="#l30.68"></a><span id="l30.68" class="difflineplus">+ *  extensions can explicitly rely upon.</span>
<a href="#l30.69"></a><span id="l30.69" class="difflineplus">+ *</span>
<a href="#l30.70"></a><span id="l30.70" class="difflineplus">+ * === Concepts</span>
<a href="#l30.71"></a><span id="l30.71" class="difflineplus">+ *</span>
<a href="#l30.72"></a><span id="l30.72" class="difflineplus">+ * == Nouns</span>
<a href="#l30.73"></a><span id="l30.73" class="difflineplus">+ *</span>
<a href="#l30.74"></a><span id="l30.74" class="difflineplus">+ * Inspired by reasonable uses of triple-stores, I have tried to leverage</span>
<a href="#l30.75"></a><span id="l30.75" class="difflineplus">+ *  existing model and terminology rather than rolling out own for everything.</span>
<a href="#l30.76"></a><span id="l30.76" class="difflineplus">+ *  The idea with triple-stores is that you have a subject, a predicate, and an</span>
<a href="#l30.77"></a><span id="l30.77" class="difflineplus">+ *  object.  For example, if we are talking about a message, that is the</span>
<a href="#l30.78"></a><span id="l30.78" class="difflineplus">+ *  subject, the predicate could roughly be sent-by, and the object a person.</span>
<a href="#l30.79"></a><span id="l30.79" class="difflineplus">+ *  We can generalize this idea to say that the subject and objects are nouns.</span>
<a href="#l30.80"></a><span id="l30.80" class="difflineplus">+ * Since we want to be more flexible than only dealing with messages, we</span>
<a href="#l30.81"></a><span id="l30.81" class="difflineplus">+ *  therefore introduce the concept of nouns as an organizing principle.</span>
<a href="#l30.82"></a><span id="l30.82" class="difflineplus">+ *</span>
<a href="#l30.83"></a><span id="l30.83" class="difflineplus">+ * == Attributes</span>
<a href="#l30.84"></a><span id="l30.84" class="difflineplus">+ *</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineplus">+ * Our attributes definitions are basically our predicates.  When we define</span>
<a href="#l30.86"></a><span id="l30.86" class="difflineplus">+ *  an attribute, it's a label with a bunch of meta-data.  Our attribute</span>
<a href="#l30.87"></a><span id="l30.87" class="difflineplus">+ *  instances are basically a 'triple' in a triple-store.  The attributes</span>
<a href="#l30.88"></a><span id="l30.88" class="difflineplus">+ *  are stored in database rows that imply a specific noun-type (ex: the</span>
<a href="#l30.89"></a><span id="l30.89" class="difflineplus">+ *  messageAttributes table), with an ID identifying the message which is our</span>
<a href="#l30.90"></a><span id="l30.90" class="difflineplus">+ *  subject, an attribute ID which identifies the attribute definition in use</span>
<a href="#l30.91"></a><span id="l30.91" class="difflineplus">+ *  (and therefore the predicate), plus an object ID (given context aka the</span>
<a href="#l30.92"></a><span id="l30.92" class="difflineplus">+ *  noun type by the attribute's meta-data) which identifies the 'object'.</span>
<a href="#l30.93"></a><span id="l30.93" class="difflineplus">+ *</span>
<a href="#l30.94"></a><span id="l30.94" class="difflineplus">+ * == But...</span>
<a href="#l30.95"></a><span id="l30.95" class="difflineplus">+ *</span>
<a href="#l30.96"></a><span id="l30.96" class="difflineplus">+ * Things aren't entirely as clear as they could be right now, terminology/</span>
<a href="#l30.97"></a><span id="l30.97" class="difflineplus">+ *  concept/implementation-wise.  Some work is probably still in order.</span>
<a href="#l30.98"></a><span id="l30.98" class="difflineplus">+ *</span>
<a href="#l30.99"></a><span id="l30.99" class="difflineplus">+ * === Implementation</span>
<a href="#l30.100"></a><span id="l30.100" class="difflineplus">+ *</span>
<a href="#l30.101"></a><span id="l30.101" class="difflineplus">+ * == Nouns</span>
<a href="#l30.102"></a><span id="l30.102" class="difflineplus">+ *</span>
<a href="#l30.103"></a><span id="l30.103" class="difflineplus">+ * So, we go and define the nouns that are roughly the classes in our data</span>
<a href="#l30.104"></a><span id="l30.104" class="difflineplus">+ *  model.  Every 'class' we define in datamodel.js is a noun that gets defined</span>
<a href="#l30.105"></a><span id="l30.105" class="difflineplus">+ *  here in the Gloda core.  We provide sufficient meta-data about the noun to</span>
<a href="#l30.106"></a><span id="l30.106" class="difflineplus">+ *  serialize/deserialize its representation from our database representation.</span>
<a href="#l30.107"></a><span id="l30.107" class="difflineplus">+ *  Nouns do not have to be defined in this class, but can also be contributed</span>
<a href="#l30.108"></a><span id="l30.108" class="difflineplus">+ *  by external code.</span>
<a href="#l30.109"></a><span id="l30.109" class="difflineplus">+ * We have a concept of 'first class' nouns versus non-first class nouns.  The</span>
<a href="#l30.110"></a><span id="l30.110" class="difflineplus">+ *  distinction is meant to be whether we can store meta-information about those</span>
<a href="#l30.111"></a><span id="l30.111" class="difflineplus">+ *  nouns using attributes.  Right now, only message are real first-class nouns,</span>
<a href="#l30.112"></a><span id="l30.112" class="difflineplus">+ *  but we want to expand that to include contacts and eventually events and</span>
<a href="#l30.113"></a><span id="l30.113" class="difflineplus">+ *  tasks as lightning-integration occurs.  In practice, we are stretching the</span>
<a href="#l30.114"></a><span id="l30.114" class="difflineplus">+ *  definition of first-class nouns slightly to include things we can't store</span>
<a href="#l30.115"></a><span id="l30.115" class="difflineplus">+ *  meta-data about, but want to be able to query about.  We do want to resolve</span>
<a href="#l30.116"></a><span id="l30.116" class="difflineplus">+ *  this.</span>
<a href="#l30.117"></a><span id="l30.117" class="difflineplus">+ *</span>
<a href="#l30.118"></a><span id="l30.118" class="difflineplus">+ * == Attributes</span>
<a href="#l30.119"></a><span id="l30.119" class="difflineplus">+ *</span>
<a href="#l30.120"></a><span id="l30.120" class="difflineplus">+ * Attributes are defined by &quot;attribute providers&quot; who are responsible for</span>
<a href="#l30.121"></a><span id="l30.121" class="difflineplus">+ *  taking an instance of a first-class noun (for which they are registered)</span>
<a href="#l30.122"></a><span id="l30.122" class="difflineplus">+ *  plus perhaps some other meta-data, and returning a list of attributes</span>
<a href="#l30.123"></a><span id="l30.123" class="difflineplus">+ *  extracted from that noun.  For now, this means messages.  Attribute</span>
<a href="#l30.124"></a><span id="l30.124" class="difflineplus">+ *  providers may create new data records as a side-effect of the indexing</span>
<a href="#l30.125"></a><span id="l30.125" class="difflineplus">+ *  process, although we have not yet fully dealt with the problem of deleting</span>
<a href="#l30.126"></a><span id="l30.126" class="difflineplus">+ *  these records should they become orphaned in the database due to the</span>
<a href="#l30.127"></a><span id="l30.127" class="difflineplus">+ *  purging of a message and its attributes.</span>
<a href="#l30.128"></a><span id="l30.128" class="difflineplus">+ * All of the 'core' gloda attributes are provided by the fundattr.js and</span>
<a href="#l30.129"></a><span id="l30.129" class="difflineplus">+ *  explattr.js providers.</span>
<a href="#l30.130"></a><span id="l30.130" class="difflineplus">+ *</span>
<a href="#l30.131"></a><span id="l30.131" class="difflineplus">+ * === (Notable) Future Work</span>
<a href="#l30.132"></a><span id="l30.132" class="difflineplus">+ *</span>
<a href="#l30.133"></a><span id="l30.133" class="difflineplus">+ * == Attributes</span>
<a href="#l30.134"></a><span id="l30.134" class="difflineplus">+ *</span>
<a href="#l30.135"></a><span id="l30.135" class="difflineplus">+ * Attribute mechanisms currently lack any support for 'overriding' attributes</span>
<a href="#l30.136"></a><span id="l30.136" class="difflineplus">+ *  provided by other attribute providers.  For example, the fundattr provider</span>
<a href="#l30.137"></a><span id="l30.137" class="difflineplus">+ *  tells us who a message is 'from' based on the e-mail address present.</span>
<a href="#l30.138"></a><span id="l30.138" class="difflineplus">+ *  However, other plugins may actually know better.  For example, the bugzilla</span>
<a href="#l30.139"></a><span id="l30.139" class="difflineplus">+ *  daemon e-mails based on bug activity although the daemon gets the credit</span>
<a href="#l30.140"></a><span id="l30.140" class="difflineplus">+ *  as the official sender.  A bugzilla plugin can easily extract the actual</span>
<a href="#l30.141"></a><span id="l30.141" class="difflineplus">+ *  person/e-mail addressed who did something on the bug to cause the</span>
<a href="#l30.142"></a><span id="l30.142" class="difflineplus">+ *  notification to be sent.  In practice, we would like that person to be</span>
<a href="#l30.143"></a><span id="l30.143" class="difflineplus">+ *  the 'sender' of the bugmail.  But we can't really do that right, yet.</span>
<a href="#l30.144"></a><span id="l30.144" class="difflineplus">+ *</span>
<a href="#l30.145"></a><span id="l30.145" class="difflineplus">+ * @namespace</span>
<a href="#l30.146"></a><span id="l30.146" class="difflineplus">+ */</span>
<a href="#l30.147"></a><span id="l30.147" class="difflineplus">+var Gloda = {</span>
<a href="#l30.148"></a><span id="l30.148" class="difflineplus">+  /**</span>
<a href="#l30.149"></a><span id="l30.149" class="difflineplus">+   * Initialize logging, the datastore (SQLite database), the core nouns and</span>
<a href="#l30.150"></a><span id="l30.150" class="difflineplus">+   *  attributes, and the contact and identities that belong to the presumed</span>
<a href="#l30.151"></a><span id="l30.151" class="difflineplus">+   *  current user (based on accounts).</span>
<a href="#l30.152"></a><span id="l30.152" class="difflineplus">+   *</span>
<a href="#l30.153"></a><span id="l30.153" class="difflineplus">+   * Additional nouns and the core attribute providers are initialized by the</span>
<a href="#l30.154"></a><span id="l30.154" class="difflineplus">+   *  everybody.js module which ensures all of those dependencies are loaded</span>
<a href="#l30.155"></a><span id="l30.155" class="difflineplus">+   *  (and initialized).</span>
<a href="#l30.156"></a><span id="l30.156" class="difflineplus">+   */</span>
<a href="#l30.157"></a><span id="l30.157" class="difflineplus">+  _init: function gloda_ns_init() {</span>
<a href="#l30.158"></a><span id="l30.158" class="difflineplus">+    this._initLogging();</span>
<a href="#l30.159"></a><span id="l30.159" class="difflineplus">+    this._json = Cc[&quot;@mozilla.org/dom/json;1&quot;].createInstance(Ci.nsIJSON);</span>
<a href="#l30.160"></a><span id="l30.160" class="difflineplus">+    GlodaDatastore._init(this._json, this._nounIDToDef);</span>
<a href="#l30.161"></a><span id="l30.161" class="difflineplus">+    this._initAttributes();</span>
<a href="#l30.162"></a><span id="l30.162" class="difflineplus">+    this._initMyIdentities();</span>
<a href="#l30.163"></a><span id="l30.163" class="difflineplus">+  },</span>
<a href="#l30.164"></a><span id="l30.164" class="difflineplus">+</span>
<a href="#l30.165"></a><span id="l30.165" class="difflineplus">+  _log: null,</span>
<a href="#l30.166"></a><span id="l30.166" class="difflineplus">+  /**</span>
<a href="#l30.167"></a><span id="l30.167" class="difflineplus">+   * Initialize logging; the error console window gets Warning/Error, and stdout</span>
<a href="#l30.168"></a><span id="l30.168" class="difflineplus">+   *  (via dump) gets everything.</span>
<a href="#l30.169"></a><span id="l30.169" class="difflineplus">+   */</span>
<a href="#l30.170"></a><span id="l30.170" class="difflineplus">+  _initLogging: function gloda_ns_initLogging() {</span>
<a href="#l30.171"></a><span id="l30.171" class="difflineplus">+    let formatter = new Log4Moz.BasicFormatter();</span>
<a href="#l30.172"></a><span id="l30.172" class="difflineplus">+    let root = Log4Moz.Service.rootLogger;</span>
<a href="#l30.173"></a><span id="l30.173" class="difflineplus">+    root.level = Log4Moz.Level.Debug;</span>
<a href="#l30.174"></a><span id="l30.174" class="difflineplus">+</span>
<a href="#l30.175"></a><span id="l30.175" class="difflineplus">+    let enableConsoleLogging = false;</span>
<a href="#l30.176"></a><span id="l30.176" class="difflineplus">+    let enableDumpLogging = false;</span>
<a href="#l30.177"></a><span id="l30.177" class="difflineplus">+    let considerNetLogging = false;</span>
<a href="#l30.178"></a><span id="l30.178" class="difflineplus">+</span>
<a href="#l30.179"></a><span id="l30.179" class="difflineplus">+    try {</span>
<a href="#l30.180"></a><span id="l30.180" class="difflineplus">+      // figure out if event-driven indexing should be enabled...</span>
<a href="#l30.181"></a><span id="l30.181" class="difflineplus">+      let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l30.182"></a><span id="l30.182" class="difflineplus">+                          getService(Ci.nsIPrefService);</span>
<a href="#l30.183"></a><span id="l30.183" class="difflineplus">+      let branch = prefService.getBranch(&quot;mailnews.database.global.logging.&quot;);</span>
<a href="#l30.184"></a><span id="l30.184" class="difflineplus">+      enableConsoleLogging = branch.getBoolPref(&quot;console&quot;);</span>
<a href="#l30.185"></a><span id="l30.185" class="difflineplus">+      enableDumpLogging = branch.getBoolPref(&quot;dump&quot;);</span>
<a href="#l30.186"></a><span id="l30.186" class="difflineplus">+      enableNetLogging = branch.getBoolPref(&quot;net&quot;);</span>
<a href="#l30.187"></a><span id="l30.187" class="difflineplus">+    } catch (ex) {}</span>
<a href="#l30.188"></a><span id="l30.188" class="difflineplus">+</span>
<a href="#l30.189"></a><span id="l30.189" class="difflineplus">+    if (enableConsoleLogging) {</span>
<a href="#l30.190"></a><span id="l30.190" class="difflineplus">+      let capp = new Log4Moz.ConsoleAppender(formatter);</span>
<a href="#l30.191"></a><span id="l30.191" class="difflineplus">+      capp.level = Log4Moz.Level.Warn;</span>
<a href="#l30.192"></a><span id="l30.192" class="difflineplus">+      root.addAppender(capp);</span>
<a href="#l30.193"></a><span id="l30.193" class="difflineplus">+    }</span>
<a href="#l30.194"></a><span id="l30.194" class="difflineplus">+</span>
<a href="#l30.195"></a><span id="l30.195" class="difflineplus">+    if (enableDumpLogging) {</span>
<a href="#l30.196"></a><span id="l30.196" class="difflineplus">+      let dapp = new Log4Moz.DumpAppender(formatter);</span>
<a href="#l30.197"></a><span id="l30.197" class="difflineplus">+      dapp.level = Log4Moz.Level.All;</span>
<a href="#l30.198"></a><span id="l30.198" class="difflineplus">+      root.addAppender(dapp);</span>
<a href="#l30.199"></a><span id="l30.199" class="difflineplus">+    }</span>
<a href="#l30.200"></a><span id="l30.200" class="difflineplus">+    </span>
<a href="#l30.201"></a><span id="l30.201" class="difflineplus">+    if (considerNetLogging) {</span>
<a href="#l30.202"></a><span id="l30.202" class="difflineplus">+      let file = Cc[&quot;@mozilla.org/file/directory_service;1&quot;]</span>
<a href="#l30.203"></a><span id="l30.203" class="difflineplus">+                    .getService(Ci.nsIProperties)</span>
<a href="#l30.204"></a><span id="l30.204" class="difflineplus">+                    .get(&quot;TmpD&quot;, Ci.nsIFile);</span>
<a href="#l30.205"></a><span id="l30.205" class="difflineplus">+      file.append(&quot;chainsaw.ptr&quot;);</span>
<a href="#l30.206"></a><span id="l30.206" class="difflineplus">+      if (file.exists()) {</span>
<a href="#l30.207"></a><span id="l30.207" class="difflineplus">+        let data = GlodaUtils.loadFileToString(file);</span>
<a href="#l30.208"></a><span id="l30.208" class="difflineplus">+        data = data.trim();</span>
<a href="#l30.209"></a><span id="l30.209" class="difflineplus">+        let [host, port] = data.split(&quot;:&quot;);</span>
<a href="#l30.210"></a><span id="l30.210" class="difflineplus">+        let xf = new Log4Moz.XMLFormatter();</span>
<a href="#l30.211"></a><span id="l30.211" class="difflineplus">+        let sapp = new Log4Moz.SocketAppender(host, Number(port), xf);</span>
<a href="#l30.212"></a><span id="l30.212" class="difflineplus">+        sapp.level = Log4Moz.Level.All;</span>
<a href="#l30.213"></a><span id="l30.213" class="difflineplus">+        root.addAppender(sapp);</span>
<a href="#l30.214"></a><span id="l30.214" class="difflineplus">+      }</span>
<a href="#l30.215"></a><span id="l30.215" class="difflineplus">+    }</span>
<a href="#l30.216"></a><span id="l30.216" class="difflineplus">+</span>
<a href="#l30.217"></a><span id="l30.217" class="difflineplus">+    this._log = Log4Moz.Service.getLogger(&quot;gloda.NS&quot;);</span>
<a href="#l30.218"></a><span id="l30.218" class="difflineplus">+    this._log.info(&quot;Logging Initialized&quot;);</span>
<a href="#l30.219"></a><span id="l30.219" class="difflineplus">+  },</span>
<a href="#l30.220"></a><span id="l30.220" class="difflineplus">+</span>
<a href="#l30.221"></a><span id="l30.221" class="difflineplus">+  kIndexerIdle: 0,</span>
<a href="#l30.222"></a><span id="l30.222" class="difflineplus">+  kIndexerIndexing: 1,</span>
<a href="#l30.223"></a><span id="l30.223" class="difflineplus">+  kIndexerMoving: 2,</span>
<a href="#l30.224"></a><span id="l30.224" class="difflineplus">+  kIndexerRemoving: 3,</span>
<a href="#l30.225"></a><span id="l30.225" class="difflineplus">+</span>
<a href="#l30.226"></a><span id="l30.226" class="difflineplus">+  /** Synchronous activities performed, you can drive us more. */</span>
<a href="#l30.227"></a><span id="l30.227" class="difflineplus">+  kWorkSync: 0,</span>
<a href="#l30.228"></a><span id="l30.228" class="difflineplus">+  /**</span>
<a href="#l30.229"></a><span id="l30.229" class="difflineplus">+   * Asynchronous activity performed, you need to relinquish flow control and</span>
<a href="#l30.230"></a><span id="l30.230" class="difflineplus">+   *  trust us to call callbackDriver later.</span>
<a href="#l30.231"></a><span id="l30.231" class="difflineplus">+   */</span>
<a href="#l30.232"></a><span id="l30.232" class="difflineplus">+  kWorkAsync: 1,</span>
<a href="#l30.233"></a><span id="l30.233" class="difflineplus">+  /**</span>
<a href="#l30.234"></a><span id="l30.234" class="difflineplus">+   * We are all done with our task, close us and figure out something else to do.</span>
<a href="#l30.235"></a><span id="l30.235" class="difflineplus">+   */</span>
<a href="#l30.236"></a><span id="l30.236" class="difflineplus">+  kWorkDone: 2,</span>
<a href="#l30.237"></a><span id="l30.237" class="difflineplus">+  /**</span>
<a href="#l30.238"></a><span id="l30.238" class="difflineplus">+   * We are not done with our task, but we think it's a good idea to take a</span>
<a href="#l30.239"></a><span id="l30.239" class="difflineplus">+   *  breather.</span>
<a href="#l30.240"></a><span id="l30.240" class="difflineplus">+   */</span>
<a href="#l30.241"></a><span id="l30.241" class="difflineplus">+  kWorkPause: 3,</span>
<a href="#l30.242"></a><span id="l30.242" class="difflineplus">+  /**</span>
<a href="#l30.243"></a><span id="l30.243" class="difflineplus">+   * We are done with our task, and have a result that we are returning.  This</span>
<a href="#l30.244"></a><span id="l30.244" class="difflineplus">+   *  should only be used by your callback handler's doneWithResult method.</span>
<a href="#l30.245"></a><span id="l30.245" class="difflineplus">+   *  Ex: you are passed aCallbackHandle, and you do</span>
<a href="#l30.246"></a><span id="l30.246" class="difflineplus">+   *  &quot;yield aCallbackHandle.doneWithResult(myResult);&quot;.</span>
<a href="#l30.247"></a><span id="l30.247" class="difflineplus">+   */</span>
<a href="#l30.248"></a><span id="l30.248" class="difflineplus">+  kWorkDoneWithResult: 4,</span>
<a href="#l30.249"></a><span id="l30.249" class="difflineplus">+</span>
<a href="#l30.250"></a><span id="l30.250" class="difflineplus">+  /**</span>
<a href="#l30.251"></a><span id="l30.251" class="difflineplus">+   * Lookup a gloda message from an nsIMsgDBHdr.</span>
<a href="#l30.252"></a><span id="l30.252" class="difflineplus">+   *</span>
<a href="#l30.253"></a><span id="l30.253" class="difflineplus">+   * @param aMsgHdr The header of the message you want the gloda message for.</span>
<a href="#l30.254"></a><span id="l30.254" class="difflineplus">+   *</span>
<a href="#l30.255"></a><span id="l30.255" class="difflineplus">+   * @return the gloda messages that corresponds to the provided nsIMsgDBHdr</span>
<a href="#l30.256"></a><span id="l30.256" class="difflineplus">+   *    if one exists, null if one cannot be found.</span>
<a href="#l30.257"></a><span id="l30.257" class="difflineplus">+   */</span>
<a href="#l30.258"></a><span id="l30.258" class="difflineplus">+  getMessageCollectionForHeader: function gloda_ns_getMessageForHeader(aMsgHdr,</span>
<a href="#l30.259"></a><span id="l30.259" class="difflineplus">+      aListener, aData) {</span>
<a href="#l30.260"></a><span id="l30.260" class="difflineplus">+    let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l30.261"></a><span id="l30.261" class="difflineplus">+    query.folder(aMsgHdr.folder).messageKey(aMsgHdr.messageKey);</span>
<a href="#l30.262"></a><span id="l30.262" class="difflineplus">+    return query.getCollection(aListener, aData);</span>
<a href="#l30.263"></a><span id="l30.263" class="difflineplus">+  },</span>
<a href="#l30.264"></a><span id="l30.264" class="difflineplus">+  </span>
<a href="#l30.265"></a><span id="l30.265" class="difflineplus">+  getMessageContent: function gloda_ns_getMessageContent(aGlodaMessage,</span>
<a href="#l30.266"></a><span id="l30.266" class="difflineplus">+      aMimeMsg) {</span>
<a href="#l30.267"></a><span id="l30.267" class="difflineplus">+    let content = new GlodaContent();</span>
<a href="#l30.268"></a><span id="l30.268" class="difflineplus">+    </span>
<a href="#l30.269"></a><span id="l30.269" class="difflineplus">+    let meta = {subject: aMimeMsg.get(&quot;subject&quot;)};</span>
<a href="#l30.270"></a><span id="l30.270" class="difflineplus">+    </span>
<a href="#l30.271"></a><span id="l30.271" class="difflineplus">+    let bodyLines = aMimeMsg.bodyPlain.split(/\r?\n/);</span>
<a href="#l30.272"></a><span id="l30.272" class="difflineplus">+    </span>
<a href="#l30.273"></a><span id="l30.273" class="difflineplus">+    // get the provider list in reverse order, mainly because we want more</span>
<a href="#l30.274"></a><span id="l30.274" class="difflineplus">+    //  specific content processors to get a chance before the default one</span>
<a href="#l30.275"></a><span id="l30.275" class="difflineplus">+    let attributeProviders =</span>
<a href="#l30.276"></a><span id="l30.276" class="difflineplus">+      this._attrProviderOrderByNoun[this.NOUN_MESSAGE].concat().reverse();</span>
<a href="#l30.277"></a><span id="l30.277" class="difflineplus">+    for each (let [, attrProvider] in Iterator(attributeProviders)) {</span>
<a href="#l30.278"></a><span id="l30.278" class="difflineplus">+      if (attrProvider.contentWhittle) {</span>
<a href="#l30.279"></a><span id="l30.279" class="difflineplus">+        try {</span>
<a href="#l30.280"></a><span id="l30.280" class="difflineplus">+          attrProvider.contentWhittle(aGlodaMessage, meta, bodyLines, content);</span>
<a href="#l30.281"></a><span id="l30.281" class="difflineplus">+        }</span>
<a href="#l30.282"></a><span id="l30.282" class="difflineplus">+        catch (ex) {</span>
<a href="#l30.283"></a><span id="l30.283" class="difflineplus">+          this._log.warn(&quot;Content whittler exception &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l30.284"></a><span id="l30.284" class="difflineplus">+            ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l30.285"></a><span id="l30.285" class="difflineplus">+        }</span>
<a href="#l30.286"></a><span id="l30.286" class="difflineplus">+      }</span>
<a href="#l30.287"></a><span id="l30.287" class="difflineplus">+    }</span>
<a href="#l30.288"></a><span id="l30.288" class="difflineplus">+    </span>
<a href="#l30.289"></a><span id="l30.289" class="difflineplus">+    return content;</span>
<a href="#l30.290"></a><span id="l30.290" class="difflineplus">+  },</span>
<a href="#l30.291"></a><span id="l30.291" class="difflineplus">+  </span>
<a href="#l30.292"></a><span id="l30.292" class="difflineplus">+  getFolderForFolder: function gloda_ns_getFolderForFolder(aMsgFolder) {</span>
<a href="#l30.293"></a><span id="l30.293" class="difflineplus">+    return GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l30.294"></a><span id="l30.294" class="difflineplus">+  },</span>
<a href="#l30.295"></a><span id="l30.295" class="difflineplus">+  </span>
<a href="#l30.296"></a><span id="l30.296" class="difflineplus">+  /**</span>
<a href="#l30.297"></a><span id="l30.297" class="difflineplus">+   * Given one or more full mail addresses (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;),</span>
<a href="#l30.298"></a><span id="l30.298" class="difflineplus">+   *  return a list of the identities that corresponds to each mail address,</span>
<a href="#l30.299"></a><span id="l30.299" class="difflineplus">+   *  creating them as required.</span>
<a href="#l30.300"></a><span id="l30.300" class="difflineplus">+   */</span>
<a href="#l30.301"></a><span id="l30.301" class="difflineplus">+  getOrCreateMailIdentities:</span>
<a href="#l30.302"></a><span id="l30.302" class="difflineplus">+      function gloda_ns_getOrCreateMailIdentities(aCallbackHandle) {</span>
<a href="#l30.303"></a><span id="l30.303" class="difflineplus">+    let addresses = {};</span>
<a href="#l30.304"></a><span id="l30.304" class="difflineplus">+    let resultLists = [];</span>
<a href="#l30.305"></a><span id="l30.305" class="difflineplus">+    </span>
<a href="#l30.306"></a><span id="l30.306" class="difflineplus">+    for (let iArg = 1; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l30.307"></a><span id="l30.307" class="difflineplus">+      let aMailAddresses = arguments[iArg];</span>
<a href="#l30.308"></a><span id="l30.308" class="difflineplus">+      let parsed = GlodaUtils.parseMailAddresses(aMailAddresses);</span>
<a href="#l30.309"></a><span id="l30.309" class="difflineplus">+      </span>
<a href="#l30.310"></a><span id="l30.310" class="difflineplus">+      let resultList = [];</span>
<a href="#l30.311"></a><span id="l30.311" class="difflineplus">+      resultLists.push(resultList);</span>
<a href="#l30.312"></a><span id="l30.312" class="difflineplus">+      </span>
<a href="#l30.313"></a><span id="l30.313" class="difflineplus">+      let identities = [];</span>
<a href="#l30.314"></a><span id="l30.314" class="difflineplus">+      for (let iAddress = 0; iAddress &lt; parsed.count; iAddress++) {</span>
<a href="#l30.315"></a><span id="l30.315" class="difflineplus">+        let address = parsed.addresses[iAddress];</span>
<a href="#l30.316"></a><span id="l30.316" class="difflineplus">+        if (address in addresses)</span>
<a href="#l30.317"></a><span id="l30.317" class="difflineplus">+          addresses[address].push(resultList);</span>
<a href="#l30.318"></a><span id="l30.318" class="difflineplus">+        else</span>
<a href="#l30.319"></a><span id="l30.319" class="difflineplus">+          addresses[address] = [parsed.names[iAddress], resultList];</span>
<a href="#l30.320"></a><span id="l30.320" class="difflineplus">+      }</span>
<a href="#l30.321"></a><span id="l30.321" class="difflineplus">+    }</span>
<a href="#l30.322"></a><span id="l30.322" class="difflineplus">+</span>
<a href="#l30.323"></a><span id="l30.323" class="difflineplus">+    let query = this.newQuery(this.NOUN_IDENTITY);</span>
<a href="#l30.324"></a><span id="l30.324" class="difflineplus">+    query.kind(&quot;email&quot;);</span>
<a href="#l30.325"></a><span id="l30.325" class="difflineplus">+    query.value.apply(query, [address for (address in addresses)]);</span>
<a href="#l30.326"></a><span id="l30.326" class="difflineplus">+    let collection = query.getCollection(aCallbackHandle);</span>
<a href="#l30.327"></a><span id="l30.327" class="difflineplus">+    yield this.kWorkAsync;</span>
<a href="#l30.328"></a><span id="l30.328" class="difflineplus">+</span>
<a href="#l30.329"></a><span id="l30.329" class="difflineplus">+    // put the identities in the appropriate result lists</span>
<a href="#l30.330"></a><span id="l30.330" class="difflineplus">+    for each (let [, identity] in Iterator(collection.items)) {</span>
<a href="#l30.331"></a><span id="l30.331" class="difflineplus">+      let nameAndResultLists = addresses[identity.value];</span>
<a href="#l30.332"></a><span id="l30.332" class="difflineplus">+      this._log.debug(&quot; found identity for '&quot; + nameAndResultLists[0] + &quot;' (&quot; +</span>
<a href="#l30.333"></a><span id="l30.333" class="difflineplus">+                      identity.value + &quot;)&quot;);</span>
<a href="#l30.334"></a><span id="l30.334" class="difflineplus">+      // index 0 is the name, skip it</span>
<a href="#l30.335"></a><span id="l30.335" class="difflineplus">+      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l30.336"></a><span id="l30.336" class="difflineplus">+        nameAndResultLists[iResList].push(identity);</span>
<a href="#l30.337"></a><span id="l30.337" class="difflineplus">+      }</span>
<a href="#l30.338"></a><span id="l30.338" class="difflineplus">+      delete addresses[identity.value];</span>
<a href="#l30.339"></a><span id="l30.339" class="difflineplus">+    }</span>
<a href="#l30.340"></a><span id="l30.340" class="difflineplus">+    </span>
<a href="#l30.341"></a><span id="l30.341" class="difflineplus">+    // create the identities that did not exist yet</span>
<a href="#l30.342"></a><span id="l30.342" class="difflineplus">+    for each (let [address, nameAndResultLists] in Iterator(addresses)) {</span>
<a href="#l30.343"></a><span id="l30.343" class="difflineplus">+      let name = nameAndResultLists[0];</span>
<a href="#l30.344"></a><span id="l30.344" class="difflineplus">+      </span>
<a href="#l30.345"></a><span id="l30.345" class="difflineplus">+      this._log.debug(&quot; creating contact for '&quot; + name + &quot;' (&quot; + address + &quot;)&quot;);</span>
<a href="#l30.346"></a><span id="l30.346" class="difflineplus">+</span>
<a href="#l30.347"></a><span id="l30.347" class="difflineplus">+      // try and find an existing address book contact.</span>
<a href="#l30.348"></a><span id="l30.348" class="difflineplus">+      let card = GlodaUtils.getCardForEmail(address);</span>
<a href="#l30.349"></a><span id="l30.349" class="difflineplus">+      // XXX when we have the address book GUID stuff, we need to use that to</span>
<a href="#l30.350"></a><span id="l30.350" class="difflineplus">+      //  find existing contacts... (this will introduce a new query phase</span>
<a href="#l30.351"></a><span id="l30.351" class="difflineplus">+      //  where we batch all the GUIDs for an async query)</span>
<a href="#l30.352"></a><span id="l30.352" class="difflineplus">+      // XXX when the address book supports multiple e-mail addresses, we</span>
<a href="#l30.353"></a><span id="l30.353" class="difflineplus">+      //  should also just create identities for any that don't yet exist</span>
<a href="#l30.354"></a><span id="l30.354" class="difflineplus">+      </span>
<a href="#l30.355"></a><span id="l30.355" class="difflineplus">+      // if there is no name, just use the e-mail (the ab indexer actually</span>
<a href="#l30.356"></a><span id="l30.356" class="difflineplus">+      //  processes the card's displayName for synchronization, so we don't</span>
<a href="#l30.357"></a><span id="l30.357" class="difflineplus">+      //  need to do that.)</span>
<a href="#l30.358"></a><span id="l30.358" class="difflineplus">+      if (!name)</span>
<a href="#l30.359"></a><span id="l30.359" class="difflineplus">+        name = address;</span>
<a href="#l30.360"></a><span id="l30.360" class="difflineplus">+</span>
<a href="#l30.361"></a><span id="l30.361" class="difflineplus">+      let contact = GlodaDatastore.createContact(null, null, name, 0, 0);</span>
<a href="#l30.362"></a><span id="l30.362" class="difflineplus">+</span>
<a href="#l30.363"></a><span id="l30.363" class="difflineplus">+      // we must create the identity.  use a blank description because there's</span>
<a href="#l30.364"></a><span id="l30.364" class="difflineplus">+      //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l30.365"></a><span id="l30.365" class="difflineplus">+      //  only has one initially (us).</span>
<a href="#l30.366"></a><span id="l30.366" class="difflineplus">+      // XXX when we have multiple e-mails and there is a meaning associated</span>
<a href="#l30.367"></a><span id="l30.367" class="difflineplus">+      //  with each e-mail, try and use that to populate the description.</span>
<a href="#l30.368"></a><span id="l30.368" class="difflineplus">+      // XXX we are creating the identity here before we insert the contact.</span>
<a href="#l30.369"></a><span id="l30.369" class="difflineplus">+      //  conceptually it is good for us to be creating the identity before</span>
<a href="#l30.370"></a><span id="l30.370" class="difflineplus">+      //  exposing it to the address-book indexer, but we could get our id's</span>
<a href="#l30.371"></a><span id="l30.371" class="difflineplus">+      //  in a bad way from not deferring the identity insertion until after</span>
<a href="#l30.372"></a><span id="l30.372" class="difflineplus">+      //  the contact insertion.</span>
<a href="#l30.373"></a><span id="l30.373" class="difflineplus">+      let identity = GlodaDatastore.createIdentity(contact.id, contact,</span>
<a href="#l30.374"></a><span id="l30.374" class="difflineplus">+        &quot;email&quot;, address, /* description */ &quot;&quot;, /* relay? */ false);</span>
<a href="#l30.375"></a><span id="l30.375" class="difflineplus">+      contact._identities = [identity];</span>
<a href="#l30.376"></a><span id="l30.376" class="difflineplus">+      </span>
<a href="#l30.377"></a><span id="l30.377" class="difflineplus">+      // give the address book indexer a chance if we have a card.</span>
<a href="#l30.378"></a><span id="l30.378" class="difflineplus">+      // (it will fix-up the name based on the card as appropriate)</span>
<a href="#l30.379"></a><span id="l30.379" class="difflineplus">+      if (card)</span>
<a href="#l30.380"></a><span id="l30.380" class="difflineplus">+        yield aCallbackHandle.pushAndGo(</span>
<a href="#l30.381"></a><span id="l30.381" class="difflineplus">+          Gloda.grokNounItem(contact, card, true, aCallbackHandle));</span>
<a href="#l30.382"></a><span id="l30.382" class="difflineplus">+      else // grokNounItem will issue the insert for us...</span>
<a href="#l30.383"></a><span id="l30.383" class="difflineplus">+        GlodaDatastore.insertContact(contact);</span>
<a href="#l30.384"></a><span id="l30.384" class="difflineplus">+</span>
<a href="#l30.385"></a><span id="l30.385" class="difflineplus">+      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l30.386"></a><span id="l30.386" class="difflineplus">+        nameAndResultLists[iResList].push(identity);</span>
<a href="#l30.387"></a><span id="l30.387" class="difflineplus">+      }</span>
<a href="#l30.388"></a><span id="l30.388" class="difflineplus">+    }</span>
<a href="#l30.389"></a><span id="l30.389" class="difflineplus">+</span>
<a href="#l30.390"></a><span id="l30.390" class="difflineplus">+    yield aCallbackHandle.doneWithResult(resultLists);</span>
<a href="#l30.391"></a><span id="l30.391" class="difflineplus">+  },</span>
<a href="#l30.392"></a><span id="l30.392" class="difflineplus">+</span>
<a href="#l30.393"></a><span id="l30.393" class="difflineplus">+  /**</span>
<a href="#l30.394"></a><span id="l30.394" class="difflineplus">+   * Dictionary of the user's known identities; key is the identity id, value</span>
<a href="#l30.395"></a><span id="l30.395" class="difflineplus">+   *  is the actual identity.  This is populated by _initMyIdentities based on</span>
<a href="#l30.396"></a><span id="l30.396" class="difflineplus">+   *  the accounts defined.</span>
<a href="#l30.397"></a><span id="l30.397" class="difflineplus">+   */</span>
<a href="#l30.398"></a><span id="l30.398" class="difflineplus">+  myIdentities: {},</span>
<a href="#l30.399"></a><span id="l30.399" class="difflineplus">+  /**</span>
<a href="#l30.400"></a><span id="l30.400" class="difflineplus">+   * The contact corresponding to the current user.  We are assuming that only</span>
<a href="#l30.401"></a><span id="l30.401" class="difflineplus">+   *  a single user/human being uses the current profile.  This is known to be</span>
<a href="#l30.402"></a><span id="l30.402" class="difflineplus">+   *  a flawed assumption, but is the best first approximation available.</span>
<a href="#l30.403"></a><span id="l30.403" class="difflineplus">+   *</span>
<a href="#l30.404"></a><span id="l30.404" class="difflineplus">+   * @TODO attempt to deal with multile people using the same profile</span>
<a href="#l30.405"></a><span id="l30.405" class="difflineplus">+   */</span>
<a href="#l30.406"></a><span id="l30.406" class="difflineplus">+  myContact: null,</span>
<a href="#l30.407"></a><span id="l30.407" class="difflineplus">+  /**</span>
<a href="#l30.408"></a><span id="l30.408" class="difflineplus">+   * Populate myIdentities with all of our identities.  Currently we do this</span>
<a href="#l30.409"></a><span id="l30.409" class="difflineplus">+   *  by assuming that there is one human/user per profile, and that all of the</span>
<a href="#l30.410"></a><span id="l30.410" class="difflineplus">+   *  accounts defined in the profile belong to them.  The single contact is</span>
<a href="#l30.411"></a><span id="l30.411" class="difflineplus">+   *  stored on myContact.</span>
<a href="#l30.412"></a><span id="l30.412" class="difflineplus">+   *</span>
<a href="#l30.413"></a><span id="l30.413" class="difflineplus">+   * @TODO deal with account addition/modification/removal</span>
<a href="#l30.414"></a><span id="l30.414" class="difflineplus">+   * @TODO attempt to deal with multiple people using the same profile</span>
<a href="#l30.415"></a><span id="l30.415" class="difflineplus">+   */</span>
<a href="#l30.416"></a><span id="l30.416" class="difflineplus">+  _initMyIdentities: function gloda_ns_initMyIdentities() {</span>
<a href="#l30.417"></a><span id="l30.417" class="difflineplus">+    let myContact = null;</span>
<a href="#l30.418"></a><span id="l30.418" class="difflineplus">+    let myIdentities = {};</span>
<a href="#l30.419"></a><span id="l30.419" class="difflineplus">+    let myEmailAddresses = {}; // process each email at most once; stored here</span>
<a href="#l30.420"></a><span id="l30.420" class="difflineplus">+</span>
<a href="#l30.421"></a><span id="l30.421" class="difflineplus">+    let fullName = null;</span>
<a href="#l30.422"></a><span id="l30.422" class="difflineplus">+    let existingIdentities = [];</span>
<a href="#l30.423"></a><span id="l30.423" class="difflineplus">+    let identitiesToCreate = [];</span>
<a href="#l30.424"></a><span id="l30.424" class="difflineplus">+</span>
<a href="#l30.425"></a><span id="l30.425" class="difflineplus">+    let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l30.426"></a><span id="l30.426" class="difflineplus">+                            getService(Ci.nsIMsgAccountManager);</span>
<a href="#l30.427"></a><span id="l30.427" class="difflineplus">+    let numIdentities = msgAccountManager.allIdentities.Count();</span>
<a href="#l30.428"></a><span id="l30.428" class="difflineplus">+</span>
<a href="#l30.429"></a><span id="l30.429" class="difflineplus">+    // nothing to do if there are no accounts/identities.</span>
<a href="#l30.430"></a><span id="l30.430" class="difflineplus">+    if (!numIdentities)</span>
<a href="#l30.431"></a><span id="l30.431" class="difflineplus">+      return;</span>
<a href="#l30.432"></a><span id="l30.432" class="difflineplus">+</span>
<a href="#l30.433"></a><span id="l30.433" class="difflineplus">+    for (let iIdentity = 0; iIdentity &lt; numIdentities; iIdentity++) {</span>
<a href="#l30.434"></a><span id="l30.434" class="difflineplus">+      let msgIdentity = msgAccountManager.allIdentities.GetElementAt(iIdentity)</span>
<a href="#l30.435"></a><span id="l30.435" class="difflineplus">+                                         .QueryInterface(Ci.nsIMsgIdentity);</span>
<a href="#l30.436"></a><span id="l30.436" class="difflineplus">+</span>
<a href="#l30.437"></a><span id="l30.437" class="difflineplus">+      if (fullName === null)</span>
<a href="#l30.438"></a><span id="l30.438" class="difflineplus">+        fullName = msgIdentity.fullName;</span>
<a href="#l30.439"></a><span id="l30.439" class="difflineplus">+</span>
<a href="#l30.440"></a><span id="l30.440" class="difflineplus">+      let emailAddress = msgIdentity.email;</span>
<a href="#l30.441"></a><span id="l30.441" class="difflineplus">+      let replyTo = msgIdentity.replyTo;</span>
<a href="#l30.442"></a><span id="l30.442" class="difflineplus">+</span>
<a href="#l30.443"></a><span id="l30.443" class="difflineplus">+      // find the identities if they exist, flag to create them if they don't</span>
<a href="#l30.444"></a><span id="l30.444" class="difflineplus">+      if (emailAddress) {</span>
<a href="#l30.445"></a><span id="l30.445" class="difflineplus">+        parsed = GlodaUtils.parseMailAddresses(emailAddress);</span>
<a href="#l30.446"></a><span id="l30.446" class="difflineplus">+        if (!(parsed.addresses[0] in myEmailAddresses)) {</span>
<a href="#l30.447"></a><span id="l30.447" class="difflineplus">+          let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l30.448"></a><span id="l30.448" class="difflineplus">+                                                    parsed.addresses[0]);</span>
<a href="#l30.449"></a><span id="l30.449" class="difflineplus">+          if (identity)</span>
<a href="#l30.450"></a><span id="l30.450" class="difflineplus">+            existingIdentities.push(identity);</span>
<a href="#l30.451"></a><span id="l30.451" class="difflineplus">+          else</span>
<a href="#l30.452"></a><span id="l30.452" class="difflineplus">+            identitiesToCreate.push(parsed.addresses[0]);</span>
<a href="#l30.453"></a><span id="l30.453" class="difflineplus">+          myEmailAddresses[parsed.addresses[0]] = true;</span>
<a href="#l30.454"></a><span id="l30.454" class="difflineplus">+        }</span>
<a href="#l30.455"></a><span id="l30.455" class="difflineplus">+      }</span>
<a href="#l30.456"></a><span id="l30.456" class="difflineplus">+      if (replyTo) {</span>
<a href="#l30.457"></a><span id="l30.457" class="difflineplus">+        parsed = GlodaUtils.parseMailAddresses(replyTo);</span>
<a href="#l30.458"></a><span id="l30.458" class="difflineplus">+        if (!(parsed.addresses[0] in myEmailAddresses)) {</span>
<a href="#l30.459"></a><span id="l30.459" class="difflineplus">+          let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l30.460"></a><span id="l30.460" class="difflineplus">+                                                    parsed.addresses[0]);</span>
<a href="#l30.461"></a><span id="l30.461" class="difflineplus">+          if (identity)</span>
<a href="#l30.462"></a><span id="l30.462" class="difflineplus">+            existingIdentities.push(identity);</span>
<a href="#l30.463"></a><span id="l30.463" class="difflineplus">+          else</span>
<a href="#l30.464"></a><span id="l30.464" class="difflineplus">+            identitiesToCreate.push(parsed.addresses[0]);</span>
<a href="#l30.465"></a><span id="l30.465" class="difflineplus">+          myEmailAddresses[parsed.addresses[0]] = true;</span>
<a href="#l30.466"></a><span id="l30.466" class="difflineplus">+        }</span>
<a href="#l30.467"></a><span id="l30.467" class="difflineplus">+      }</span>
<a href="#l30.468"></a><span id="l30.468" class="difflineplus">+    }</span>
<a href="#l30.469"></a><span id="l30.469" class="difflineplus">+</span>
<a href="#l30.470"></a><span id="l30.470" class="difflineplus">+    // we need to establish the identity.contact portions of the relationship</span>
<a href="#l30.471"></a><span id="l30.471" class="difflineplus">+    for each (let [,identity] in Iterator(existingIdentities)) {</span>
<a href="#l30.472"></a><span id="l30.472" class="difflineplus">+      identity._contact = GlodaDatastore.getContactByID(identity.contactID);</span>
<a href="#l30.473"></a><span id="l30.473" class="difflineplus">+    }</span>
<a href="#l30.474"></a><span id="l30.474" class="difflineplus">+    </span>
<a href="#l30.475"></a><span id="l30.475" class="difflineplus">+    if (existingIdentities.length) {</span>
<a href="#l30.476"></a><span id="l30.476" class="difflineplus">+      // just use the first guy's contact</span>
<a href="#l30.477"></a><span id="l30.477" class="difflineplus">+      myContact = existingIdentities[0].contact;</span>
<a href="#l30.478"></a><span id="l30.478" class="difflineplus">+    }</span>
<a href="#l30.479"></a><span id="l30.479" class="difflineplus">+    else {</span>
<a href="#l30.480"></a><span id="l30.480" class="difflineplus">+      // create a new contact</span>
<a href="#l30.481"></a><span id="l30.481" class="difflineplus">+      myContact = GlodaDatastore.createContact(null, null, fullName || &quot;Me&quot;,</span>
<a href="#l30.482"></a><span id="l30.482" class="difflineplus">+                                               0, 0);</span>
<a href="#l30.483"></a><span id="l30.483" class="difflineplus">+      GlodaDatastore.insertContact(myContact);</span>
<a href="#l30.484"></a><span id="l30.484" class="difflineplus">+    }</span>
<a href="#l30.485"></a><span id="l30.485" class="difflineplus">+</span>
<a href="#l30.486"></a><span id="l30.486" class="difflineplus">+    if (identitiesToCreate.length) {</span>
<a href="#l30.487"></a><span id="l30.487" class="difflineplus">+      for (let iIdentity = 0; iIdentity &lt; identitiesToCreate.length;</span>
<a href="#l30.488"></a><span id="l30.488" class="difflineplus">+          iIdentity++) {</span>
<a href="#l30.489"></a><span id="l30.489" class="difflineplus">+        let emailAddress = identitiesToCreate[iIdentity];</span>
<a href="#l30.490"></a><span id="l30.490" class="difflineplus">+        // XXX this won't always be of type &quot;email&quot; as we add new account types</span>
<a href="#l30.491"></a><span id="l30.491" class="difflineplus">+        // XXX the blank string could be trying to differentiate; we do have</span>
<a href="#l30.492"></a><span id="l30.492" class="difflineplus">+        //  enough info to do it.</span>
<a href="#l30.493"></a><span id="l30.493" class="difflineplus">+        let identity = GlodaDatastore.createIdentity(myContact.id, myContact,</span>
<a href="#l30.494"></a><span id="l30.494" class="difflineplus">+                                                     &quot;email&quot;,</span>
<a href="#l30.495"></a><span id="l30.495" class="difflineplus">+                                                     emailAddress,</span>
<a href="#l30.496"></a><span id="l30.496" class="difflineplus">+                                                     &quot;&quot;, false);</span>
<a href="#l30.497"></a><span id="l30.497" class="difflineplus">+        existingIdentities.push(identity);</span>
<a href="#l30.498"></a><span id="l30.498" class="difflineplus">+      }</span>
<a href="#l30.499"></a><span id="l30.499" class="difflineplus">+    }</span>
<a href="#l30.500"></a><span id="l30.500" class="difflineplus">+</span>
<a href="#l30.501"></a><span id="l30.501" class="difflineplus">+    for (let iIdentity = 0; iIdentity &lt; existingIdentities.length;</span>
<a href="#l30.502"></a><span id="l30.502" class="difflineplus">+        iIdentity++) {</span>
<a href="#l30.503"></a><span id="l30.503" class="difflineplus">+      let identity = existingIdentities[iIdentity];</span>
<a href="#l30.504"></a><span id="l30.504" class="difflineplus">+      myIdentities[identity.id] = identity;</span>
<a href="#l30.505"></a><span id="l30.505" class="difflineplus">+    }</span>
<a href="#l30.506"></a><span id="l30.506" class="difflineplus">+</span>
<a href="#l30.507"></a><span id="l30.507" class="difflineplus">+    this.myContact = myContact;</span>
<a href="#l30.508"></a><span id="l30.508" class="difflineplus">+    this.myIdentities = myContact._identities = myIdentities;</span>
<a href="#l30.509"></a><span id="l30.509" class="difflineplus">+  },</span>
<a href="#l30.510"></a><span id="l30.510" class="difflineplus">+</span>
<a href="#l30.511"></a><span id="l30.511" class="difflineplus">+  /**</span>
<a href="#l30.512"></a><span id="l30.512" class="difflineplus">+   * An attribute that is a defining characteristic of the subject.</span>
<a href="#l30.513"></a><span id="l30.513" class="difflineplus">+   */</span>
<a href="#l30.514"></a><span id="l30.514" class="difflineplus">+  kAttrFundamental: 0,</span>
<a href="#l30.515"></a><span id="l30.515" class="difflineplus">+  /**</span>
<a href="#l30.516"></a><span id="l30.516" class="difflineplus">+   * An attribute that is an optimization derived from two or more fundamental</span>
<a href="#l30.517"></a><span id="l30.517" class="difflineplus">+   *  attributes and exists solely to improve database query performance.</span>
<a href="#l30.518"></a><span id="l30.518" class="difflineplus">+   */</span>
<a href="#l30.519"></a><span id="l30.519" class="difflineplus">+  kAttrOptimization: 1,</span>
<a href="#l30.520"></a><span id="l30.520" class="difflineplus">+  /**</span>
<a href="#l30.521"></a><span id="l30.521" class="difflineplus">+   * An attribute that is derived from the content of the subject.  For example,</span>
<a href="#l30.522"></a><span id="l30.522" class="difflineplus">+   *  a message that references a bugzilla bug could have a &quot;derived&quot; attribute</span>
<a href="#l30.523"></a><span id="l30.523" class="difflineplus">+   *  that captures the bugzilla reference.  This is not</span>
<a href="#l30.524"></a><span id="l30.524" class="difflineplus">+   */</span>
<a href="#l30.525"></a><span id="l30.525" class="difflineplus">+  kAttrDerived: 2,</span>
<a href="#l30.526"></a><span id="l30.526" class="difflineplus">+  /**</span>
<a href="#l30.527"></a><span id="l30.527" class="difflineplus">+   * An attribute that is the result of an explicit and intentional user action</span>
<a href="#l30.528"></a><span id="l30.528" class="difflineplus">+   *  upon the subject.  For example, a tag placed on a message by a user (or</span>
<a href="#l30.529"></a><span id="l30.529" class="difflineplus">+   *  at the user's request by a filter) is explicit.</span>
<a href="#l30.530"></a><span id="l30.530" class="difflineplus">+   */</span>
<a href="#l30.531"></a><span id="l30.531" class="difflineplus">+  kAttrExplicit: 3,</span>
<a href="#l30.532"></a><span id="l30.532" class="difflineplus">+  /**</span>
<a href="#l30.533"></a><span id="l30.533" class="difflineplus">+   * An attribute that is indirectly the result of a user's behaviour.  For</span>
<a href="#l30.534"></a><span id="l30.534" class="difflineplus">+   *  example, if a user consults a message multiple times, we may conclude that</span>
<a href="#l30.535"></a><span id="l30.535" class="difflineplus">+   *  the user finds the message interesting.  It is &quot;implied&quot;, if you will,</span>
<a href="#l30.536"></a><span id="l30.536" class="difflineplus">+   *  that the message is interesting.</span>
<a href="#l30.537"></a><span id="l30.537" class="difflineplus">+   */</span>
<a href="#l30.538"></a><span id="l30.538" class="difflineplus">+  kAttrImplicit: 4,</span>
<a href="#l30.539"></a><span id="l30.539" class="difflineplus">+</span>
<a href="#l30.540"></a><span id="l30.540" class="difflineplus">+  /**</span>
<a href="#l30.541"></a><span id="l30.541" class="difflineplus">+   * This attribute is not 'special'; it is stored as a (thing id, attribute id,</span>
<a href="#l30.542"></a><span id="l30.542" class="difflineplus">+   *  attribute id) tuple in the database rather than on thing's row or on</span>
<a href="#l30.543"></a><span id="l30.543" class="difflineplus">+   *  thing's fulltext row.  (Where &quot;thing&quot; could be a message or any other</span>
<a href="#l30.544"></a><span id="l30.544" class="difflineplus">+   *  first class noun.)</span>
<a href="#l30.545"></a><span id="l30.545" class="difflineplus">+   */</span>
<a href="#l30.546"></a><span id="l30.546" class="difflineplus">+  kSpecialNotAtAll: GlodaDatastore.kSpecialNotAtAll,</span>
<a href="#l30.547"></a><span id="l30.547" class="difflineplus">+  /**</span>
<a href="#l30.548"></a><span id="l30.548" class="difflineplus">+   * This attribute is stored as a numeric column on the row for the noun.  The</span>
<a href="#l30.549"></a><span id="l30.549" class="difflineplus">+   *  attribute definition should include this value as 'special' and the</span>
<a href="#l30.550"></a><span id="l30.550" class="difflineplus">+   *  column name that stores the attribute as 'specialColumnName'.</span>
<a href="#l30.551"></a><span id="l30.551" class="difflineplus">+   */</span>
<a href="#l30.552"></a><span id="l30.552" class="difflineplus">+  kSpecialColumn: GlodaDatastore.kSpecialColumn,</span>
<a href="#l30.553"></a><span id="l30.553" class="difflineplus">+  kSpecialColumnChildren: GlodaDatastore.kSpecialColumnChildren,</span>
<a href="#l30.554"></a><span id="l30.554" class="difflineplus">+  kSpecialColumnParent: GlodaDatastore.kSpecialColumnParent,</span>
<a href="#l30.555"></a><span id="l30.555" class="difflineplus">+  /**</span>
<a href="#l30.556"></a><span id="l30.556" class="difflineplus">+   * This attribute is stored as a string column on the row for the noun.  It</span>
<a href="#l30.557"></a><span id="l30.557" class="difflineplus">+   *  differs from kSpecialColumn in that it is a string and thus uses different</span>
<a href="#l30.558"></a><span id="l30.558" class="difflineplus">+   *  query mechanisms.</span>
<a href="#l30.559"></a><span id="l30.559" class="difflineplus">+   */</span>
<a href="#l30.560"></a><span id="l30.560" class="difflineplus">+  kSpecialString: GlodaDatastore.kSpecialString,</span>
<a href="#l30.561"></a><span id="l30.561" class="difflineplus">+  /**</span>
<a href="#l30.562"></a><span id="l30.562" class="difflineplus">+   * This attribute is stored as a fulltext column on the fulltext table for</span>
<a href="#l30.563"></a><span id="l30.563" class="difflineplus">+   *  the noun.  The attribute defintion should include this value as 'special'</span>
<a href="#l30.564"></a><span id="l30.564" class="difflineplus">+   *  and the column name that stores the table as 'specialColumnName'.</span>
<a href="#l30.565"></a><span id="l30.565" class="difflineplus">+   */</span>
<a href="#l30.566"></a><span id="l30.566" class="difflineplus">+  kSpecialFulltext: GlodaDatastore.kSpecialFulltext,</span>
<a href="#l30.567"></a><span id="l30.567" class="difflineplus">+</span>
<a href="#l30.568"></a><span id="l30.568" class="difflineplus">+  /**</span>
<a href="#l30.569"></a><span id="l30.569" class="difflineplus">+   * The extensionName used for the attributes defined by core gloda plugins</span>
<a href="#l30.570"></a><span id="l30.570" class="difflineplus">+   *  such as fundattr.js and explattr.js.</span>
<a href="#l30.571"></a><span id="l30.571" class="difflineplus">+   */</span>
<a href="#l30.572"></a><span id="l30.572" class="difflineplus">+  BUILT_IN: &quot;built-in&quot;,</span>
<a href="#l30.573"></a><span id="l30.573" class="difflineplus">+</span>
<a href="#l30.574"></a><span id="l30.574" class="difflineplus">+</span>
<a href="#l30.575"></a><span id="l30.575" class="difflineplus">+  /*</span>
<a href="#l30.576"></a><span id="l30.576" class="difflineplus">+   * The following are explicit noun IDs.  While most extension-provided nouns</span>
<a href="#l30.577"></a><span id="l30.577" class="difflineplus">+   *  will have dynamically allocated id's that are looked up by name, these</span>
<a href="#l30.578"></a><span id="l30.578" class="difflineplus">+   *  id's can be relied upon to exist and be accessible via these</span>
<a href="#l30.579"></a><span id="l30.579" class="difflineplus">+   *  pseudo-constants.  It's not really clear that we need these, although it</span>
<a href="#l30.580"></a><span id="l30.580" class="difflineplus">+   *  does potentially simplify code to not have to look up all of their nouns</span>
<a href="#l30.581"></a><span id="l30.581" class="difflineplus">+   *  at initialization time.</span>
<a href="#l30.582"></a><span id="l30.582" class="difflineplus">+   */</span>
<a href="#l30.583"></a><span id="l30.583" class="difflineplus">+  /**</span>
<a href="#l30.584"></a><span id="l30.584" class="difflineplus">+   * Boolean values, expressed as 0/1 in the database and non-continuous for</span>
<a href="#l30.585"></a><span id="l30.585" class="difflineplus">+   *  constraint purposes.  Like numbers, such nouns require their attributes</span>
<a href="#l30.586"></a><span id="l30.586" class="difflineplus">+   *  to provide them with context, lacking any of their own.</span>
<a href="#l30.587"></a><span id="l30.587" class="difflineplus">+   * Having this as a noun type may be a bad idea; a change of nomenclature</span>
<a href="#l30.588"></a><span id="l30.588" class="difflineplus">+   *  (so that we are not claiming a boolean value is a noun, but still using</span>
<a href="#l30.589"></a><span id="l30.589" class="difflineplus">+   *  it in the same way) or implementation to require each boolean noun</span>
<a href="#l30.590"></a><span id="l30.590" class="difflineplus">+   *  actually be its own noun may be in order.</span>
<a href="#l30.591"></a><span id="l30.591" class="difflineplus">+   */</span>
<a href="#l30.592"></a><span id="l30.592" class="difflineplus">+  NOUN_BOOLEAN: 1,</span>
<a href="#l30.593"></a><span id="l30.593" class="difflineplus">+  /**</span>
<a href="#l30.594"></a><span id="l30.594" class="difflineplus">+   * A number, which could mean an integer or floating point values.  We treat</span>
<a href="#l30.595"></a><span id="l30.595" class="difflineplus">+   *  these as continuous, meaning that queries on them can have ranged</span>
<a href="#l30.596"></a><span id="l30.596" class="difflineplus">+   *  constraints expressed on them.  Lacking any inherent context, numbers</span>
<a href="#l30.597"></a><span id="l30.597" class="difflineplus">+   *  depend on their attributes to parameterize them as required.</span>
<a href="#l30.598"></a><span id="l30.598" class="difflineplus">+   * Same deal as with NOUN_BOOLEAN, we may need to change this up conceptually.</span>
<a href="#l30.599"></a><span id="l30.599" class="difflineplus">+   */</span>
<a href="#l30.600"></a><span id="l30.600" class="difflineplus">+  NOUN_NUMBER: 2,</span>
<a href="#l30.601"></a><span id="l30.601" class="difflineplus">+  /**</span>
<a href="#l30.602"></a><span id="l30.602" class="difflineplus">+   * A (non-fulltext) string.</span>
<a href="#l30.603"></a><span id="l30.603" class="difflineplus">+   * Same deal as with NOUN_BOOLEAN, we may need to change this up conceptually.</span>
<a href="#l30.604"></a><span id="l30.604" class="difflineplus">+   */</span>
<a href="#l30.605"></a><span id="l30.605" class="difflineplus">+  NOUN_STRING: 3,</span>
<a href="#l30.606"></a><span id="l30.606" class="difflineplus">+  /** A date, encoded as a PRTime, represented as a js Date object. */</span>
<a href="#l30.607"></a><span id="l30.607" class="difflineplus">+  NOUN_DATE: 10,</span>
<a href="#l30.608"></a><span id="l30.608" class="difflineplus">+  /**</span>
<a href="#l30.609"></a><span id="l30.609" class="difflineplus">+   * Fulltext search support, somewhat magical.  This is only intended to be</span>
<a href="#l30.610"></a><span id="l30.610" class="difflineplus">+   *  used for kSpecialFulltext attributes, and exclusively as a constraint</span>
<a href="#l30.611"></a><span id="l30.611" class="difflineplus">+   *  mechanism.  The values are always represented as strings.  It is presumed</span>
<a href="#l30.612"></a><span id="l30.612" class="difflineplus">+   *  that the user of this functionality knows how to generate SQLite FTS3</span>
<a href="#l30.613"></a><span id="l30.613" class="difflineplus">+   *  style MATCH queries, or is okay with us just gluing them together with</span>
<a href="#l30.614"></a><span id="l30.614" class="difflineplus">+   *  &quot; OR &quot; when used in an or-constraint case.  Gloda's query mechanism</span>
<a href="#l30.615"></a><span id="l30.615" class="difflineplus">+   *  currently lacks the ability to to compile Gloda-style and-constraints</span>
<a href="#l30.616"></a><span id="l30.616" class="difflineplus">+   *  into a single MATCH query, but it will turn out okay, just less</span>
<a href="#l30.617"></a><span id="l30.617" class="difflineplus">+   *  efficiently than it could.</span>
<a href="#l30.618"></a><span id="l30.618" class="difflineplus">+   */</span>
<a href="#l30.619"></a><span id="l30.619" class="difflineplus">+  NOUN_FULLTEXT: 20,</span>
<a href="#l30.620"></a><span id="l30.620" class="difflineplus">+  /**</span>
<a href="#l30.621"></a><span id="l30.621" class="difflineplus">+   * Represents a MIME Type.  We currently lack any human-intelligible</span>
<a href="#l30.622"></a><span id="l30.622" class="difflineplus">+   *  descriptions of mime types.</span>
<a href="#l30.623"></a><span id="l30.623" class="difflineplus">+   */</span>
<a href="#l30.624"></a><span id="l30.624" class="difflineplus">+  NOUN_MIME_TYPE: 40, </span>
<a href="#l30.625"></a><span id="l30.625" class="difflineplus">+  /**</span>
<a href="#l30.626"></a><span id="l30.626" class="difflineplus">+   * Captures a message tag as well as when the tag's presence was observed,</span>
<a href="#l30.627"></a><span id="l30.627" class="difflineplus">+   *  hoping to approximate when the tag was applied.  It's a somewhat dubious</span>
<a href="#l30.628"></a><span id="l30.628" class="difflineplus">+   *  attempt to not waste our opporunity to store a value along with the tag.</span>
<a href="#l30.629"></a><span id="l30.629" class="difflineplus">+   *  (The tag is actually stored as an attribute parameter on the attribute</span>
<a href="#l30.630"></a><span id="l30.630" class="difflineplus">+   *  definition, rather than a value in the attribute 'instance' for the</span>
<a href="#l30.631"></a><span id="l30.631" class="difflineplus">+   *  message.)</span>
<a href="#l30.632"></a><span id="l30.632" class="difflineplus">+   */</span>
<a href="#l30.633"></a><span id="l30.633" class="difflineplus">+  NOUN_TAG: 50,</span>
<a href="#l30.634"></a><span id="l30.634" class="difflineplus">+  /**</span>
<a href="#l30.635"></a><span id="l30.635" class="difflineplus">+   * Doesn't actually work owing to a lack of an object to represent a folder.</span>
<a href="#l30.636"></a><span id="l30.636" class="difflineplus">+   *  We do expose the folderURI and folderID of a message, but need to map that</span>
<a href="#l30.637"></a><span id="l30.637" class="difflineplus">+   *  to a good abstraction.  Probably something thin around a SteelFolder or</span>
<a href="#l30.638"></a><span id="l30.638" class="difflineplus">+   *  the like; we would contribute the functionality to easily move from a</span>
<a href="#l30.639"></a><span id="l30.639" class="difflineplus">+   *  folder to the list of gloda messages in that folder, as well as the</span>
<a href="#l30.640"></a><span id="l30.640" class="difflineplus">+   *  indexing preferences for that folder.</span>
<a href="#l30.641"></a><span id="l30.641" class="difflineplus">+   * @TODO folder noun and related abstraction</span>
<a href="#l30.642"></a><span id="l30.642" class="difflineplus">+   */</span>
<a href="#l30.643"></a><span id="l30.643" class="difflineplus">+  NOUN_FOLDER: GlodaFolder.prototype.NOUN_ID, // 100</span>
<a href="#l30.644"></a><span id="l30.644" class="difflineplus">+  /**</span>
<a href="#l30.645"></a><span id="l30.645" class="difflineplus">+   * All messages belong to a conversation.  See datamodel.js for the</span>
<a href="#l30.646"></a><span id="l30.646" class="difflineplus">+   *  definition of the GlodaConversation class.</span>
<a href="#l30.647"></a><span id="l30.647" class="difflineplus">+   */</span>
<a href="#l30.648"></a><span id="l30.648" class="difflineplus">+  NOUN_CONVERSATION: GlodaConversation.prototype.NOUN_ID, // 101</span>
<a href="#l30.649"></a><span id="l30.649" class="difflineplus">+  /**</span>
<a href="#l30.650"></a><span id="l30.650" class="difflineplus">+   * A one-to-one correspondence with underlying (indexed) nsIMsgDBHdr</span>
<a href="#l30.651"></a><span id="l30.651" class="difflineplus">+   *  instances.  See datamodel.js for the definition of the GlodaMessage class.</span>
<a href="#l30.652"></a><span id="l30.652" class="difflineplus">+   */</span>
<a href="#l30.653"></a><span id="l30.653" class="difflineplus">+  NOUN_MESSAGE: GlodaMessage.prototype.NOUN_ID, // 102</span>
<a href="#l30.654"></a><span id="l30.654" class="difflineplus">+  /**</span>
<a href="#l30.655"></a><span id="l30.655" class="difflineplus">+   * Corresponds to a human being, who may have multiple electronic identities</span>
<a href="#l30.656"></a><span id="l30.656" class="difflineplus">+   *  (a la NOUN_IDENTITY).  There is no requirement for association with an</span>
<a href="#l30.657"></a><span id="l30.657" class="difflineplus">+   *  address book contact, although when the address book contact exists,</span>
<a href="#l30.658"></a><span id="l30.658" class="difflineplus">+   *  we want to be associated with it.  See datamodel.js for the definition</span>
<a href="#l30.659"></a><span id="l30.659" class="difflineplus">+   *  of the GlodaContact class.</span>
<a href="#l30.660"></a><span id="l30.660" class="difflineplus">+   */</span>
<a href="#l30.661"></a><span id="l30.661" class="difflineplus">+  NOUN_CONTACT: GlodaContact.prototype.NOUN_ID, // 103</span>
<a href="#l30.662"></a><span id="l30.662" class="difflineplus">+  /**</span>
<a href="#l30.663"></a><span id="l30.663" class="difflineplus">+   * A single identity of a contact, who may have one or more.  E-mail accounts,</span>
<a href="#l30.664"></a><span id="l30.664" class="difflineplus">+   *  instant messaging accounts, social network site accounts, etc. are each</span>
<a href="#l30.665"></a><span id="l30.665" class="difflineplus">+   *  identities.  See datamodel.js for the definition of the GlodaIdentity</span>
<a href="#l30.666"></a><span id="l30.666" class="difflineplus">+   *  class.</span>
<a href="#l30.667"></a><span id="l30.667" class="difflineplus">+   */</span>
<a href="#l30.668"></a><span id="l30.668" class="difflineplus">+  NOUN_IDENTITY: GlodaIdentity.prototype.NOUN_ID, // 104</span>
<a href="#l30.669"></a><span id="l30.669" class="difflineplus">+</span>
<a href="#l30.670"></a><span id="l30.670" class="difflineplus">+  /**</span>
<a href="#l30.671"></a><span id="l30.671" class="difflineplus">+   * Parameterized identities, for use in the from-me, to-me, cc-me optimization</span>
<a href="#l30.672"></a><span id="l30.672" class="difflineplus">+   *  cases.  Not for reuse without some thought.  These nouns use the parameter</span>
<a href="#l30.673"></a><span id="l30.673" class="difflineplus">+   *  to store the 'me' identity that we are talking about, and the value to</span>
<a href="#l30.674"></a><span id="l30.674" class="difflineplus">+   *  store the identity of the other party.  So in both the from-me and to-me</span>
<a href="#l30.675"></a><span id="l30.675" class="difflineplus">+   *  cases involving 'me' and 'foo@bar', the 'me' identity is always stored via</span>
<a href="#l30.676"></a><span id="l30.676" class="difflineplus">+   *  the attribute parameter, and the 'foo@bar' identity is always stored as</span>
<a href="#l30.677"></a><span id="l30.677" class="difflineplus">+   *  the attribute value.  See fundattr.js for more information on this, but</span>
<a href="#l30.678"></a><span id="l30.678" class="difflineplus">+   *  you probably shouldn't be touching this unless you are fundattr.</span>
<a href="#l30.679"></a><span id="l30.679" class="difflineplus">+   */</span>
<a href="#l30.680"></a><span id="l30.680" class="difflineplus">+  NOUN_PARAM_IDENTITY: 200,</span>
<a href="#l30.681"></a><span id="l30.681" class="difflineplus">+</span>
<a href="#l30.682"></a><span id="l30.682" class="difflineplus">+  /** Next Noun ID to hand out, these don't need to be persisted (for now). */</span>
<a href="#l30.683"></a><span id="l30.683" class="difflineplus">+  _nextNounID: 1000,</span>
<a href="#l30.684"></a><span id="l30.684" class="difflineplus">+</span>
<a href="#l30.685"></a><span id="l30.685" class="difflineplus">+  /**</span>
<a href="#l30.686"></a><span id="l30.686" class="difflineplus">+   * Maps noun names to noun IDs.</span>
<a href="#l30.687"></a><span id="l30.687" class="difflineplus">+   */</span>
<a href="#l30.688"></a><span id="l30.688" class="difflineplus">+  _nounNameToNounID: {},</span>
<a href="#l30.689"></a><span id="l30.689" class="difflineplus">+  /**</span>
<a href="#l30.690"></a><span id="l30.690" class="difflineplus">+   * Maps noun IDs to noun definition dictionaries.  (Noun definition</span>
<a href="#l30.691"></a><span id="l30.691" class="difflineplus">+   *  dictionaries provided to us at the time a noun was defined, plus some</span>
<a href="#l30.692"></a><span id="l30.692" class="difflineplus">+   *  additional stuff we put in there.)</span>
<a href="#l30.693"></a><span id="l30.693" class="difflineplus">+   */</span>
<a href="#l30.694"></a><span id="l30.694" class="difflineplus">+  _nounIDToDef: {},</span>
<a href="#l30.695"></a><span id="l30.695" class="difflineplus">+  </span>
<a href="#l30.696"></a><span id="l30.696" class="difflineplus">+  _managedToJSON: function gloda_ns_managedToJSON(aItem) {</span>
<a href="#l30.697"></a><span id="l30.697" class="difflineplus">+    return aItem.id;</span>
<a href="#l30.698"></a><span id="l30.698" class="difflineplus">+  },</span>
<a href="#l30.699"></a><span id="l30.699" class="difflineplus">+</span>
<a href="#l30.700"></a><span id="l30.700" class="difflineplus">+  /**</span>
<a href="#l30.701"></a><span id="l30.701" class="difflineplus">+   * Define a noun.  Takes a dictionary with the following keys/values:</span>
<a href="#l30.702"></a><span id="l30.702" class="difflineplus">+   *</span>
<a href="#l30.703"></a><span id="l30.703" class="difflineplus">+   * @param name The name of the noun.  This is not a display name (anything</span>
<a href="#l30.704"></a><span id="l30.704" class="difflineplus">+   *     being displayed needs to be localized, after all), but simply the</span>
<a href="#l30.705"></a><span id="l30.705" class="difflineplus">+   *     canonical name for debugging purposes and for people to pass to</span>
<a href="#l30.706"></a><span id="l30.706" class="difflineplus">+   *     lookupNoun.  The suggested convention is lower-case-dash-delimited,</span>
<a href="#l30.707"></a><span id="l30.707" class="difflineplus">+   *     with names being singular (since it's a single noun we are referring</span>
<a href="#l30.708"></a><span id="l30.708" class="difflineplus">+   *     to.)</span>
<a href="#l30.709"></a><span id="l30.709" class="difflineplus">+   * @param class The 'class' to which an instance of the noun will belong (aka</span>
<a href="#l30.710"></a><span id="l30.710" class="difflineplus">+   *     will pass an instanceof test).</span>
<a href="#l30.711"></a><span id="l30.711" class="difflineplus">+   * @param allowsArbitraryAttrs Is this a 'first class noun'/can it be a subject, AKA can</span>
<a href="#l30.712"></a><span id="l30.712" class="difflineplus">+   *     this noun have attributes stored on it that relate it to other things?</span>
<a href="#l30.713"></a><span id="l30.713" class="difflineplus">+   *     For example, a message is first-class; we store attributes of</span>
<a href="#l30.714"></a><span id="l30.714" class="difflineplus">+   *     messages.  A date is not first-class now, nor is it likely to be; we</span>
<a href="#l30.715"></a><span id="l30.715" class="difflineplus">+   *     will not store attributes about a date, although dates will be the</span>
<a href="#l30.716"></a><span id="l30.716" class="difflineplus">+   *     objects of other subjects.  (For example: we might associate a date</span>
<a href="#l30.717"></a><span id="l30.717" class="difflineplus">+   *     with a calendar event, but the date is an attribute of the calendar</span>
<a href="#l30.718"></a><span id="l30.718" class="difflineplus">+   *     event and not vice versa.)</span>
<a href="#l30.719"></a><span id="l30.719" class="difflineplus">+   * @param usesParameter A boolean indicating whether this noun requires use</span>
<a href="#l30.720"></a><span id="l30.720" class="difflineplus">+   *     of the 'parameter' BLOB storage field on the attribute bindings in the</span>
<a href="#l30.721"></a><span id="l30.721" class="difflineplus">+   *     database to persist itself.  Use of parameters should be limited</span>
<a href="#l30.722"></a><span id="l30.722" class="difflineplus">+   *     to a reasonable number of values (16-32 is okay, more than that is</span>
<a href="#l30.723"></a><span id="l30.723" class="difflineplus">+   *     pushing it and 256 should be considered an absolute upper bound)</span>
<a href="#l30.724"></a><span id="l30.724" class="difflineplus">+   *     because of the database organization.  When false, your toParamAndValue</span>
<a href="#l30.725"></a><span id="l30.725" class="difflineplus">+   *     function is expected to return null for the parameter and likewise your</span>
<a href="#l30.726"></a><span id="l30.726" class="difflineplus">+   *     fromParamAndValue should expect ignore and generally ignore the</span>
<a href="#l30.727"></a><span id="l30.727" class="difflineplus">+   *     argument.</span>
<a href="#l30.728"></a><span id="l30.728" class="difflineplus">+   * @param toParamAndValue A function that takes an instantiated noun</span>
<a href="#l30.729"></a><span id="l30.729" class="difflineplus">+   *     instance and returns a 2-element list of [parameter, value] where</span>
<a href="#l30.730"></a><span id="l30.730" class="difflineplus">+   *     parameter may only be non-null if you passed a usesParameter of true.</span>
<a href="#l30.731"></a><span id="l30.731" class="difflineplus">+   *     Parameter may be of any type (BLOB), and value must be numeric (pass</span>
<a href="#l30.732"></a><span id="l30.732" class="difflineplus">+   *     0 if you don't need the value).</span>
<a href="#l30.733"></a><span id="l30.733" class="difflineplus">+   */</span>
<a href="#l30.734"></a><span id="l30.734" class="difflineplus">+  defineNoun: function gloda_ns_defineNoun(aNounDef, aNounID) {</span>
<a href="#l30.735"></a><span id="l30.735" class="difflineplus">+    this._log.info(&quot;Defining noun: &quot; + aNounDef.name);</span>
<a href="#l30.736"></a><span id="l30.736" class="difflineplus">+    if (aNounID === undefined)</span>
<a href="#l30.737"></a><span id="l30.737" class="difflineplus">+      aNounID = this._nextNounID++;</span>
<a href="#l30.738"></a><span id="l30.738" class="difflineplus">+    aNounDef.id = aNounID;</span>
<a href="#l30.739"></a><span id="l30.739" class="difflineplus">+    // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l30.740"></a><span id="l30.740" class="difflineplus">+    if (aNounDef.tableName) {</span>
<a href="#l30.741"></a><span id="l30.741" class="difflineplus">+      [aNounDef.queryClass, aNounDef.explicitQueryClass,</span>
<a href="#l30.742"></a><span id="l30.742" class="difflineplus">+       aNounDef.wildcardQueryClass] =</span>
<a href="#l30.743"></a><span id="l30.743" class="difflineplus">+          GlodaQueryClassFactory(aNounDef);</span>
<a href="#l30.744"></a><span id="l30.744" class="difflineplus">+      aNounDef._dbMeta = {};</span>
<a href="#l30.745"></a><span id="l30.745" class="difflineplus">+      aNounDef.class.prototype.NOUN_DEF = aNounDef;</span>
<a href="#l30.746"></a><span id="l30.746" class="difflineplus">+      aNounDef.toJSON = this._managedToJSON;</span>
<a href="#l30.747"></a><span id="l30.747" class="difflineplus">+      </span>
<a href="#l30.748"></a><span id="l30.748" class="difflineplus">+      aNounDef.specialLoadAttribs = [];</span>
<a href="#l30.749"></a><span id="l30.749" class="difflineplus">+</span>
<a href="#l30.750"></a><span id="l30.750" class="difflineplus">+      // - define the 'id' constrainer</span>
<a href="#l30.751"></a><span id="l30.751" class="difflineplus">+      let idConstrainer = function() {</span>
<a href="#l30.752"></a><span id="l30.752" class="difflineplus">+        let constraint = [GlodaDatastore.kConstraintIdIn, null];</span>
<a href="#l30.753"></a><span id="l30.753" class="difflineplus">+        for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l30.754"></a><span id="l30.754" class="difflineplus">+          constraint.push(arguments[iArg]);</span>
<a href="#l30.755"></a><span id="l30.755" class="difflineplus">+        }</span>
<a href="#l30.756"></a><span id="l30.756" class="difflineplus">+        this._constraints.push(constraint);</span>
<a href="#l30.757"></a><span id="l30.757" class="difflineplus">+        return this;</span>
<a href="#l30.758"></a><span id="l30.758" class="difflineplus">+      };</span>
<a href="#l30.759"></a><span id="l30.759" class="difflineplus">+      aNounDef.queryClass.prototype.id = idConstrainer;</span>
<a href="#l30.760"></a><span id="l30.760" class="difflineplus">+    }</span>
<a href="#l30.761"></a><span id="l30.761" class="difflineplus">+    if (aNounDef.cache) {</span>
<a href="#l30.762"></a><span id="l30.762" class="difflineplus">+      let cacheCost = aNounDef.cacheCost || 1024;</span>
<a href="#l30.763"></a><span id="l30.763" class="difflineplus">+      let cacheBudget = aNounDef.cacheBudget || 128 * 1024;</span>
<a href="#l30.764"></a><span id="l30.764" class="difflineplus">+      let cacheSize = Math.floor(cacheBudget / cacheCost);</span>
<a href="#l30.765"></a><span id="l30.765" class="difflineplus">+      if (cacheSize)</span>
<a href="#l30.766"></a><span id="l30.766" class="difflineplus">+        GlodaCollectionManager.defineCache(aNounDef, cacheSize);</span>
<a href="#l30.767"></a><span id="l30.767" class="difflineplus">+    }</span>
<a href="#l30.768"></a><span id="l30.768" class="difflineplus">+    aNounDef.attribsByBoundName = {};</span>
<a href="#l30.769"></a><span id="l30.769" class="difflineplus">+    aNounDef.domExposeAttribsByBoundName = {};</span>
<a href="#l30.770"></a><span id="l30.770" class="difflineplus">+    </span>
<a href="#l30.771"></a><span id="l30.771" class="difflineplus">+    aNounDef.objectNounOfAttributes = [];</span>
<a href="#l30.772"></a><span id="l30.772" class="difflineplus">+</span>
<a href="#l30.773"></a><span id="l30.773" class="difflineplus">+    this._nounNameToNounID[aNounDef.name] = aNounID;</span>
<a href="#l30.774"></a><span id="l30.774" class="difflineplus">+    this._nounIDToDef[aNounID] = aNounDef;</span>
<a href="#l30.775"></a><span id="l30.775" class="difflineplus">+    aNounDef.actions = [];</span>
<a href="#l30.776"></a><span id="l30.776" class="difflineplus">+    </span>
<a href="#l30.777"></a><span id="l30.777" class="difflineplus">+    this._attrProviderOrderByNoun[aNounDef.id] = [];</span>
<a href="#l30.778"></a><span id="l30.778" class="difflineplus">+    this._attrOptimizerOrderByNoun[aNounDef.id] = [];</span>
<a href="#l30.779"></a><span id="l30.779" class="difflineplus">+    this._attrProvidersByNoun[aNounDef.id] = {};</span>
<a href="#l30.780"></a><span id="l30.780" class="difflineplus">+  },</span>
<a href="#l30.781"></a><span id="l30.781" class="difflineplus">+</span>
<a href="#l30.782"></a><span id="l30.782" class="difflineplus">+  /**</span>
<a href="#l30.783"></a><span id="l30.783" class="difflineplus">+   * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l30.784"></a><span id="l30.784" class="difflineplus">+   *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l30.785"></a><span id="l30.785" class="difflineplus">+   *  cannot be found; the assumption is that you can't live without the noun.</span>
<a href="#l30.786"></a><span id="l30.786" class="difflineplus">+   */</span>
<a href="#l30.787"></a><span id="l30.787" class="difflineplus">+  lookupNoun: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l30.788"></a><span id="l30.788" class="difflineplus">+    if (aNounName in this._nounNameToNounID)</span>
<a href="#l30.789"></a><span id="l30.789" class="difflineplus">+      return this._nounNameToNounID[aNounName];</span>
<a href="#l30.790"></a><span id="l30.790" class="difflineplus">+</span>
<a href="#l30.791"></a><span id="l30.791" class="difflineplus">+    throw Error(&quot;Unable to locate noun with name '&quot; + aNounName + &quot;', but I &quot; +</span>
<a href="#l30.792"></a><span id="l30.792" class="difflineplus">+                &quot;do know about: &quot; +</span>
<a href="#l30.793"></a><span id="l30.793" class="difflineplus">+                [propName for</span>
<a href="#l30.794"></a><span id="l30.794" class="difflineplus">+                 (propName in this._nounNameToNounID)].join(&quot;, &quot;));</span>
<a href="#l30.795"></a><span id="l30.795" class="difflineplus">+  },</span>
<a href="#l30.796"></a><span id="l30.796" class="difflineplus">+</span>
<a href="#l30.797"></a><span id="l30.797" class="difflineplus">+  /**</span>
<a href="#l30.798"></a><span id="l30.798" class="difflineplus">+   * Lookup a noun def given a name.</span>
<a href="#l30.799"></a><span id="l30.799" class="difflineplus">+   */</span>
<a href="#l30.800"></a><span id="l30.800" class="difflineplus">+  lookupNounDef: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l30.801"></a><span id="l30.801" class="difflineplus">+    return this._nounIDToDef[this.lookupNoun(aNounName)];</span>
<a href="#l30.802"></a><span id="l30.802" class="difflineplus">+  },</span>
<a href="#l30.803"></a><span id="l30.803" class="difflineplus">+</span>
<a href="#l30.804"></a><span id="l30.804" class="difflineplus">+  </span>
<a href="#l30.805"></a><span id="l30.805" class="difflineplus">+  /**</span>
<a href="#l30.806"></a><span id="l30.806" class="difflineplus">+   * Define an action on a noun.  During the prototype stage, this was conceived</span>
<a href="#l30.807"></a><span id="l30.807" class="difflineplus">+   *  of as a way to expose all the constraints possible given a noun.  For</span>
<a href="#l30.808"></a><span id="l30.808" class="difflineplus">+   *  example, if you have an identity or a contact, you could use this to</span>
<a href="#l30.809"></a><span id="l30.809" class="difflineplus">+   *  see all the messages sent from/to a given contact.  It was likewise</span>
<a href="#l30.810"></a><span id="l30.810" class="difflineplus">+   *  thought potentially usable for future expansion.  For example, you could</span>
<a href="#l30.811"></a><span id="l30.811" class="difflineplus">+   *  also decide to send an e-mail to a contact when you have the contact</span>
<a href="#l30.812"></a><span id="l30.812" class="difflineplus">+   *  instance available.</span>
<a href="#l30.813"></a><span id="l30.813" class="difflineplus">+   * Outside of the 'expmess' checkbox-happy prototype, this functionality is</span>
<a href="#l30.814"></a><span id="l30.814" class="difflineplus">+   *  not used.  As such, this functionality should be considered in flux and</span>
<a href="#l30.815"></a><span id="l30.815" class="difflineplus">+   *  subject to changes.  Also, very open to specific suggestsions motivated</span>
<a href="#l30.816"></a><span id="l30.816" class="difflineplus">+   *  by use cases.</span>
<a href="#l30.817"></a><span id="l30.817" class="difflineplus">+   * One conceptual issue raised by this mechanism is the interaction of actions</span>
<a href="#l30.818"></a><span id="l30.818" class="difflineplus">+   *  with facts like &quot;this message is read&quot;.  We currently implement the 'fact'</span>
<a href="#l30.819"></a><span id="l30.819" class="difflineplus">+   *  by defining an attribute with a 'boolean' noun type.  To deal with this,</span>
<a href="#l30.820"></a><span id="l30.820" class="difflineplus">+   *  in various places we pass-in the attribute as well as the noun value.</span>
<a href="#l30.821"></a><span id="l30.821" class="difflineplus">+   *  Since the relationships for booleans and integers in these cases is</span>
<a href="#l30.822"></a><span id="l30.822" class="difflineplus">+   *  standard and well-defined, this works out pretty well, but suggests we</span>
<a href="#l30.823"></a><span id="l30.823" class="difflineplus">+   *  need to think things through.</span>
<a href="#l30.824"></a><span id="l30.824" class="difflineplus">+   *</span>
<a href="#l30.825"></a><span id="l30.825" class="difflineplus">+   * @param aNounID The ID of the noun you want to define an action on.</span>
<a href="#l30.826"></a><span id="l30.826" class="difflineplus">+   * @param aActionMeta The dictionary describing the noun.  The dictionary</span>
<a href="#l30.827"></a><span id="l30.827" class="difflineplus">+   *     should have the following fields:</span>
<a href="#l30.828"></a><span id="l30.828" class="difflineplus">+   * - actionType: a string indicating the type of action.  Currently, only</span>
<a href="#l30.829"></a><span id="l30.829" class="difflineplus">+   *   &quot;filter&quot; is a legal value.</span>
<a href="#l30.830"></a><span id="l30.830" class="difflineplus">+   * - actionTarget: the noun ID of the noun type on which this action is</span>
<a href="#l30.831"></a><span id="l30.831" class="difflineplus">+   *   applicable.  For example,</span>
<a href="#l30.832"></a><span id="l30.832" class="difflineplus">+   *</span>
<a href="#l30.833"></a><span id="l30.833" class="difflineplus">+   * The following should be present for actionType==&quot;filter&quot;;</span>
<a href="#l30.834"></a><span id="l30.834" class="difflineplus">+   * - shortName: The name that should be used to display this constraint.  For</span>
<a href="#l30.835"></a><span id="l30.835" class="difflineplus">+   *   example, a checkbox-heavy UI might display a checkbox for each constraint</span>
<a href="#l30.836"></a><span id="l30.836" class="difflineplus">+   *   using shortName as the label.</span>
<a href="#l30.837"></a><span id="l30.837" class="difflineplus">+   * - makeConstraint: A function that takes the attribute that is the source</span>
<a href="#l30.838"></a><span id="l30.838" class="difflineplus">+   *   of the noun and the noun instance as arguments, and returns APV-style</span>
<a href="#l30.839"></a><span id="l30.839" class="difflineplus">+   *   constraints.  Since the APV-style query mechanism is now deprecated,</span>
<a href="#l30.840"></a><span id="l30.840" class="difflineplus">+   *   this signature is deprecated.  Probably the way to update this would be</span>
<a href="#l30.841"></a><span id="l30.841" class="difflineplus">+   *   to pass in the query instance that constraints should be contributed to.</span>
<a href="#l30.842"></a><span id="l30.842" class="difflineplus">+   */</span>
<a href="#l30.843"></a><span id="l30.843" class="difflineplus">+  defineNounAction: function gloda_ns_defineNounAction(aNounID, aActionMeta) {</span>
<a href="#l30.844"></a><span id="l30.844" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l30.845"></a><span id="l30.845" class="difflineplus">+    nounDef.actions.push(aActionMeta);</span>
<a href="#l30.846"></a><span id="l30.846" class="difflineplus">+  },</span>
<a href="#l30.847"></a><span id="l30.847" class="difflineplus">+</span>
<a href="#l30.848"></a><span id="l30.848" class="difflineplus">+  /**</span>
<a href="#l30.849"></a><span id="l30.849" class="difflineplus">+   * Retrieve all of the actions (as defined using defineNounAction) for the</span>
<a href="#l30.850"></a><span id="l30.850" class="difflineplus">+   *  given noun type (via noun ID) with the given action type (ex: filter).</span>
<a href="#l30.851"></a><span id="l30.851" class="difflineplus">+   */</span>
<a href="#l30.852"></a><span id="l30.852" class="difflineplus">+  getNounActions: function gloda_ns_getNounActions(aNounID, aActionType) {</span>
<a href="#l30.853"></a><span id="l30.853" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l30.854"></a><span id="l30.854" class="difflineplus">+    if (!nounDef)</span>
<a href="#l30.855"></a><span id="l30.855" class="difflineplus">+      return [];</span>
<a href="#l30.856"></a><span id="l30.856" class="difflineplus">+    return [action for each ([i, action] in Iterator(nounDef.actions))</span>
<a href="#l30.857"></a><span id="l30.857" class="difflineplus">+            if (!aActionType || (action.actionType == aActionType))];</span>
<a href="#l30.858"></a><span id="l30.858" class="difflineplus">+  },</span>
<a href="#l30.859"></a><span id="l30.859" class="difflineplus">+</span>
<a href="#l30.860"></a><span id="l30.860" class="difflineplus">+  /** Attribute providers in the sequence to process them. */</span>
<a href="#l30.861"></a><span id="l30.861" class="difflineplus">+  _attrProviderOrderByNoun: {},</span>
<a href="#l30.862"></a><span id="l30.862" class="difflineplus">+  /** Attribute providers that provide optimizers, in the sequence to proc. */</span>
<a href="#l30.863"></a><span id="l30.863" class="difflineplus">+  _attrOptimizerOrderByNoun: {},</span>
<a href="#l30.864"></a><span id="l30.864" class="difflineplus">+  /** Maps attribute providers to the list of attributes they provide */</span>
<a href="#l30.865"></a><span id="l30.865" class="difflineplus">+  _attrProviders: {},</span>
<a href="#l30.866"></a><span id="l30.866" class="difflineplus">+  /**</span>
<a href="#l30.867"></a><span id="l30.867" class="difflineplus">+   * Maps nouns to their attribute providers to a list of the attributes they</span>
<a href="#l30.868"></a><span id="l30.868" class="difflineplus">+   *  provide for the noun.</span>
<a href="#l30.869"></a><span id="l30.869" class="difflineplus">+   */</span>
<a href="#l30.870"></a><span id="l30.870" class="difflineplus">+  _attrProvidersByNoun: {},</span>
<a href="#l30.871"></a><span id="l30.871" class="difflineplus">+</span>
<a href="#l30.872"></a><span id="l30.872" class="difflineplus">+  /**</span>
<a href="#l30.873"></a><span id="l30.873" class="difflineplus">+   * Define the core nouns (that are not defined elsewhere) and a few noun</span>
<a href="#l30.874"></a><span id="l30.874" class="difflineplus">+   *  actions.  Core nouns could be defined in other files, assuming dependency</span>
<a href="#l30.875"></a><span id="l30.875" class="difflineplus">+   *  issues are resolved via the everybody.js mechanism or something else.</span>
<a href="#l30.876"></a><span id="l30.876" class="difflineplus">+   *  Right now, noun_tag defines the tag noun.  If we broke more of these out,</span>
<a href="#l30.877"></a><span id="l30.877" class="difflineplus">+   *  we would probably want to move the 'class' code from datamodel.js, the</span>
<a href="#l30.878"></a><span id="l30.878" class="difflineplus">+   *  SQL table def and helper code from datastore.js (and this code) to their</span>
<a href="#l30.879"></a><span id="l30.879" class="difflineplus">+   *  own noun_*.js files.  There are some trade-offs to be made, and I think</span>
<a href="#l30.880"></a><span id="l30.880" class="difflineplus">+   *  we can deal with those once we start to integrate lightning/calendar and</span>
<a href="#l30.881"></a><span id="l30.881" class="difflineplus">+   *  our noun space gets large and more heterogeneous.</span>
<a href="#l30.882"></a><span id="l30.882" class="difflineplus">+   */</span>
<a href="#l30.883"></a><span id="l30.883" class="difflineplus">+  _initAttributes: function gloda_ns_initAttributes() {</span>
<a href="#l30.884"></a><span id="l30.884" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.885"></a><span id="l30.885" class="difflineplus">+      name: &quot;bool&quot;,</span>
<a href="#l30.886"></a><span id="l30.886" class="difflineplus">+      class: Boolean, allowsArbitraryAttrs: false,</span>
<a href="#l30.887"></a><span id="l30.887" class="difflineplus">+      toParamAndValue: function(aBool) {</span>
<a href="#l30.888"></a><span id="l30.888" class="difflineplus">+        return [null, aBool ? 1 : 0];</span>
<a href="#l30.889"></a><span id="l30.889" class="difflineplus">+      }}, this.NOUN_BOOLEAN);</span>
<a href="#l30.890"></a><span id="l30.890" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.891"></a><span id="l30.891" class="difflineplus">+      name: &quot;number&quot;,</span>
<a href="#l30.892"></a><span id="l30.892" class="difflineplus">+      class: Number, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l30.893"></a><span id="l30.893" class="difflineplus">+      toParamAndValue: function(aNum) {</span>
<a href="#l30.894"></a><span id="l30.894" class="difflineplus">+        return [null, aNum];</span>
<a href="#l30.895"></a><span id="l30.895" class="difflineplus">+      }}, this.NOUN_NUMBER);</span>
<a href="#l30.896"></a><span id="l30.896" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.897"></a><span id="l30.897" class="difflineplus">+      name: &quot;string&quot;,</span>
<a href="#l30.898"></a><span id="l30.898" class="difflineplus">+      class: String, allowsArbitraryAttrs: false,</span>
<a href="#l30.899"></a><span id="l30.899" class="difflineplus">+      toParamAndValue: function(aString) {</span>
<a href="#l30.900"></a><span id="l30.900" class="difflineplus">+        return [null, aString];</span>
<a href="#l30.901"></a><span id="l30.901" class="difflineplus">+      }}, this.NOUN_STRING);</span>
<a href="#l30.902"></a><span id="l30.902" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.903"></a><span id="l30.903" class="difflineplus">+      name: &quot;date&quot;,</span>
<a href="#l30.904"></a><span id="l30.904" class="difflineplus">+      class: Date, allowsArbitraryAttrs: false, continuous: true,</span>
<a href="#l30.905"></a><span id="l30.905" class="difflineplus">+      toParamAndValue: function(aDate) {</span>
<a href="#l30.906"></a><span id="l30.906" class="difflineplus">+        return [null, aDate.valueOf() * 1000];</span>
<a href="#l30.907"></a><span id="l30.907" class="difflineplus">+      }}, this.NOUN_DATE);</span>
<a href="#l30.908"></a><span id="l30.908" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.909"></a><span id="l30.909" class="difflineplus">+      name: &quot;fulltext&quot;,</span>
<a href="#l30.910"></a><span id="l30.910" class="difflineplus">+      class: String, allowsArbitraryAttrs: false, continuous: false,</span>
<a href="#l30.911"></a><span id="l30.911" class="difflineplus">+      // as noted on NOUN_FULLTEXT, we just pass the string around.  it never</span>
<a href="#l30.912"></a><span id="l30.912" class="difflineplus">+      //  hits the database, so it's okay.</span>
<a href="#l30.913"></a><span id="l30.913" class="difflineplus">+      toParamAndValue: function(aString) {</span>
<a href="#l30.914"></a><span id="l30.914" class="difflineplus">+        return [null, aString];</span>
<a href="#l30.915"></a><span id="l30.915" class="difflineplus">+      }}, this.NOUN_FULLTEXT);</span>
<a href="#l30.916"></a><span id="l30.916" class="difflineplus">+</span>
<a href="#l30.917"></a><span id="l30.917" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.918"></a><span id="l30.918" class="difflineplus">+      name: &quot;folder&quot;,</span>
<a href="#l30.919"></a><span id="l30.919" class="difflineplus">+      class: GlodaFolder,</span>
<a href="#l30.920"></a><span id="l30.920" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l30.921"></a><span id="l30.921" class="difflineplus">+      toParamAndValue: function(aFolderOrGlodaFolder) {</span>
<a href="#l30.922"></a><span id="l30.922" class="difflineplus">+        if (aFolderOrGlodaFolder instanceof GlodaFolder)</span>
<a href="#l30.923"></a><span id="l30.923" class="difflineplus">+          return [null, aFolderOrGlodaFolder.id];</span>
<a href="#l30.924"></a><span id="l30.924" class="difflineplus">+        else</span>
<a href="#l30.925"></a><span id="l30.925" class="difflineplus">+          return [null, GlodaDatastore._mapFolder(aFolderOrGlodaFolder).id];</span>
<a href="#l30.926"></a><span id="l30.926" class="difflineplus">+      }}, this.NOUN_FOLDER);</span>
<a href="#l30.927"></a><span id="l30.927" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.928"></a><span id="l30.928" class="difflineplus">+      name: &quot;conversation&quot;,</span>
<a href="#l30.929"></a><span id="l30.929" class="difflineplus">+      class: GlodaConversation,</span>
<a href="#l30.930"></a><span id="l30.930" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l30.931"></a><span id="l30.931" class="difflineplus">+      cache: true, cacheCost: 512,</span>
<a href="#l30.932"></a><span id="l30.932" class="difflineplus">+      tableName: &quot;conversations&quot;,</span>
<a href="#l30.933"></a><span id="l30.933" class="difflineplus">+      attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;conversationID&quot;,</span>
<a href="#l30.934"></a><span id="l30.934" class="difflineplus">+      datastore: GlodaDatastore,</span>
<a href="#l30.935"></a><span id="l30.935" class="difflineplus">+      objFromRow: GlodaDatastore._conversationFromRow,</span>
<a href="#l30.936"></a><span id="l30.936" class="difflineplus">+      toParamAndValue: function(aConversation) {</span>
<a href="#l30.937"></a><span id="l30.937" class="difflineplus">+        if (aConversation instanceof GlodaConversation)</span>
<a href="#l30.938"></a><span id="l30.938" class="difflineplus">+          return [null, aConversation.id];</span>
<a href="#l30.939"></a><span id="l30.939" class="difflineplus">+        else // assume they're just passing the id directly</span>
<a href="#l30.940"></a><span id="l30.940" class="difflineplus">+          return [null, aConversation];</span>
<a href="#l30.941"></a><span id="l30.941" class="difflineplus">+      }}, this.NOUN_CONVERSATION);</span>
<a href="#l30.942"></a><span id="l30.942" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.943"></a><span id="l30.943" class="difflineplus">+      name: &quot;message&quot;,</span>
<a href="#l30.944"></a><span id="l30.944" class="difflineplus">+      class: GlodaMessage,</span>
<a href="#l30.945"></a><span id="l30.945" class="difflineplus">+      allowsArbitraryAttrs: true,</span>
<a href="#l30.946"></a><span id="l30.946" class="difflineplus">+      cache: true, cacheCost: 2048,</span>
<a href="#l30.947"></a><span id="l30.947" class="difflineplus">+      tableName: &quot;messages&quot;,</span>
<a href="#l30.948"></a><span id="l30.948" class="difflineplus">+      attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;messageID&quot;,</span>
<a href="#l30.949"></a><span id="l30.949" class="difflineplus">+      datastore: GlodaDatastore, objFromRow: GlodaDatastore._messageFromRow,</span>
<a href="#l30.950"></a><span id="l30.950" class="difflineplus">+      dbAttribAdjuster: GlodaDatastore.adjustMessageAttributes,</span>
<a href="#l30.951"></a><span id="l30.951" class="difflineplus">+      objInsert: GlodaDatastore.insertMessage,</span>
<a href="#l30.952"></a><span id="l30.952" class="difflineplus">+      objUpdate: GlodaDatastore.updateMessage,</span>
<a href="#l30.953"></a><span id="l30.953" class="difflineplus">+      toParamAndValue: function(aMessage) {</span>
<a href="#l30.954"></a><span id="l30.954" class="difflineplus">+        if (aMessage instanceof GlodaMessage)</span>
<a href="#l30.955"></a><span id="l30.955" class="difflineplus">+          return [null, aMessage.id];</span>
<a href="#l30.956"></a><span id="l30.956" class="difflineplus">+        else // assume they're just passing the id directly</span>
<a href="#l30.957"></a><span id="l30.957" class="difflineplus">+          return [null, aMessage];</span>
<a href="#l30.958"></a><span id="l30.958" class="difflineplus">+      }}, this.NOUN_MESSAGE);</span>
<a href="#l30.959"></a><span id="l30.959" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.960"></a><span id="l30.960" class="difflineplus">+      name: &quot;contact&quot;,</span>
<a href="#l30.961"></a><span id="l30.961" class="difflineplus">+      class: GlodaContact,</span>
<a href="#l30.962"></a><span id="l30.962" class="difflineplus">+      allowsArbitraryAttrs: true,</span>
<a href="#l30.963"></a><span id="l30.963" class="difflineplus">+      cache: true, cacheCost: 128,</span>
<a href="#l30.964"></a><span id="l30.964" class="difflineplus">+      tableName: &quot;contacts&quot;,</span>
<a href="#l30.965"></a><span id="l30.965" class="difflineplus">+      attrTableName: &quot;contactAttributes&quot;, attrIDColumnName: &quot;contactID&quot;,</span>
<a href="#l30.966"></a><span id="l30.966" class="difflineplus">+      datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l30.967"></a><span id="l30.967" class="difflineplus">+      dbAttribAdjuster: GlodaDatastore.adjustAttributes,</span>
<a href="#l30.968"></a><span id="l30.968" class="difflineplus">+      objInsert: GlodaDatastore.insertContact,</span>
<a href="#l30.969"></a><span id="l30.969" class="difflineplus">+      objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l30.970"></a><span id="l30.970" class="difflineplus">+      toParamAndValue: function(aContact) {</span>
<a href="#l30.971"></a><span id="l30.971" class="difflineplus">+        if (aContact instanceof GlodaContact)</span>
<a href="#l30.972"></a><span id="l30.972" class="difflineplus">+          return [null, aContact.id];</span>
<a href="#l30.973"></a><span id="l30.973" class="difflineplus">+        else // assume they're just passing the id directly</span>
<a href="#l30.974"></a><span id="l30.974" class="difflineplus">+          return [null, aContact];</span>
<a href="#l30.975"></a><span id="l30.975" class="difflineplus">+      }}, this.NOUN_CONTACT);</span>
<a href="#l30.976"></a><span id="l30.976" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.977"></a><span id="l30.977" class="difflineplus">+      name: &quot;identity&quot;,</span>
<a href="#l30.978"></a><span id="l30.978" class="difflineplus">+      class: GlodaIdentity,</span>
<a href="#l30.979"></a><span id="l30.979" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l30.980"></a><span id="l30.980" class="difflineplus">+      cache: true, cacheCost: 128,</span>
<a href="#l30.981"></a><span id="l30.981" class="difflineplus">+      usesUniqueValue: true,</span>
<a href="#l30.982"></a><span id="l30.982" class="difflineplus">+      tableName: &quot;identities&quot;,</span>
<a href="#l30.983"></a><span id="l30.983" class="difflineplus">+      datastore: GlodaDatastore, objFromRow: GlodaDatastore._identityFromRow,</span>
<a href="#l30.984"></a><span id="l30.984" class="difflineplus">+      toParamAndValue: function(aIdentity) {</span>
<a href="#l30.985"></a><span id="l30.985" class="difflineplus">+        if (aIdentity instanceof GlodaIdentity)</span>
<a href="#l30.986"></a><span id="l30.986" class="difflineplus">+          return [null, aIdentity.id];</span>
<a href="#l30.987"></a><span id="l30.987" class="difflineplus">+        else // assume they're just passing the id directly</span>
<a href="#l30.988"></a><span id="l30.988" class="difflineplus">+          return [null, aIdentity];</span>
<a href="#l30.989"></a><span id="l30.989" class="difflineplus">+      }}, this.NOUN_IDENTITY);</span>
<a href="#l30.990"></a><span id="l30.990" class="difflineplus">+</span>
<a href="#l30.991"></a><span id="l30.991" class="difflineplus">+    // parameterized identity is just two identities; we store the first one</span>
<a href="#l30.992"></a><span id="l30.992" class="difflineplus">+    //  (whose value set must be very constrainted, like the 'me' identities)</span>
<a href="#l30.993"></a><span id="l30.993" class="difflineplus">+    //  as the parameter, the second (which does not need to be constrained)</span>
<a href="#l30.994"></a><span id="l30.994" class="difflineplus">+    //  as the value.</span>
<a href="#l30.995"></a><span id="l30.995" class="difflineplus">+    this.defineNoun({</span>
<a href="#l30.996"></a><span id="l30.996" class="difflineplus">+      name: &quot;parameterized-identity&quot;,</span>
<a href="#l30.997"></a><span id="l30.997" class="difflineplus">+      class: null,</span>
<a href="#l30.998"></a><span id="l30.998" class="difflineplus">+      allowsArbitraryAttrs: false,</span>
<a href="#l30.999"></a><span id="l30.999" class="difflineplus">+      computeDelta: function(aCurValues, aOldValues) {</span>
<a href="#l30.1000"></a><span id="l30.1000" class="difflineplus">+        let oldMap = {};</span>
<a href="#l30.1001"></a><span id="l30.1001" class="difflineplus">+        for each (let [, tupe] in Iterator(aOldValues)) {</span>
<a href="#l30.1002"></a><span id="l30.1002" class="difflineplus">+          let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l30.1003"></a><span id="l30.1003" class="difflineplus">+          let targets = oldMap[originIdentity];</span>
<a href="#l30.1004"></a><span id="l30.1004" class="difflineplus">+          if (targets === undefined)</span>
<a href="#l30.1005"></a><span id="l30.1005" class="difflineplus">+            targets = oldMap[originIdentity] = {};</span>
<a href="#l30.1006"></a><span id="l30.1006" class="difflineplus">+          targets[targetIdentity] = true;</span>
<a href="#l30.1007"></a><span id="l30.1007" class="difflineplus">+        }</span>
<a href="#l30.1008"></a><span id="l30.1008" class="difflineplus">+        </span>
<a href="#l30.1009"></a><span id="l30.1009" class="difflineplus">+        let added = [], removed = [];</span>
<a href="#l30.1010"></a><span id="l30.1010" class="difflineplus">+        for each (let [, tupe] in Iterator(aCurValues)) {</span>
<a href="#l30.1011"></a><span id="l30.1011" class="difflineplus">+          let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l30.1012"></a><span id="l30.1012" class="difflineplus">+          let targets = oldMap[originIdentity];</span>
<a href="#l30.1013"></a><span id="l30.1013" class="difflineplus">+          if ((targets === undefined) || !(targetIdentity in targets))</span>
<a href="#l30.1014"></a><span id="l30.1014" class="difflineplus">+            added.push(tupe);</span>
<a href="#l30.1015"></a><span id="l30.1015" class="difflineplus">+          else</span>
<a href="#l30.1016"></a><span id="l30.1016" class="difflineplus">+            delete targets[targetIdentity];</span>
<a href="#l30.1017"></a><span id="l30.1017" class="difflineplus">+        }</span>
<a href="#l30.1018"></a><span id="l30.1018" class="difflineplus">+        </span>
<a href="#l30.1019"></a><span id="l30.1019" class="difflineplus">+        for each (let [originIdentity, targets] in Iterator(oldMap)) {</span>
<a href="#l30.1020"></a><span id="l30.1020" class="difflineplus">+          for (let targetIdentity in targets) {</span>
<a href="#l30.1021"></a><span id="l30.1021" class="difflineplus">+            removed.push([originIdentity, targetIdentity]);</span>
<a href="#l30.1022"></a><span id="l30.1022" class="difflineplus">+          }</span>
<a href="#l30.1023"></a><span id="l30.1023" class="difflineplus">+        }</span>
<a href="#l30.1024"></a><span id="l30.1024" class="difflineplus">+        </span>
<a href="#l30.1025"></a><span id="l30.1025" class="difflineplus">+        return [added, removed];</span>
<a href="#l30.1026"></a><span id="l30.1026" class="difflineplus">+      },</span>
<a href="#l30.1027"></a><span id="l30.1027" class="difflineplus">+      contributeObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l30.1028"></a><span id="l30.1028" class="difflineplus">+          aInverseReferencesByNounID) {</span>
<a href="#l30.1029"></a><span id="l30.1029" class="difflineplus">+        // nothing to do with a zero-length list</span>
<a href="#l30.1030"></a><span id="l30.1030" class="difflineplus">+        if (aJsonValues.length == 0)</span>
<a href="#l30.1031"></a><span id="l30.1031" class="difflineplus">+          return false;</span>
<a href="#l30.1032"></a><span id="l30.1032" class="difflineplus">+      </span>
<a href="#l30.1033"></a><span id="l30.1033" class="difflineplus">+        let nounIdentityDef = Gloda._nounIDToDef[Gloda.NOUN_IDENTITY]</span>
<a href="#l30.1034"></a><span id="l30.1034" class="difflineplus">+        let references = aReferencesByNounID[nounIdentityDef.id];</span>
<a href="#l30.1035"></a><span id="l30.1035" class="difflineplus">+        if (references === undefined)</span>
<a href="#l30.1036"></a><span id="l30.1036" class="difflineplus">+          references = aReferencesByNounID[nounIdentityDef.id] = {};</span>
<a href="#l30.1037"></a><span id="l30.1037" class="difflineplus">+        </span>
<a href="#l30.1038"></a><span id="l30.1038" class="difflineplus">+        for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l30.1039"></a><span id="l30.1039" class="difflineplus">+          let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l30.1040"></a><span id="l30.1040" class="difflineplus">+          if (!(originIdentityID in references))</span>
<a href="#l30.1041"></a><span id="l30.1041" class="difflineplus">+            references[originIdentityID] = null;</span>
<a href="#l30.1042"></a><span id="l30.1042" class="difflineplus">+          if (!(targetIdentityID in references))</span>
<a href="#l30.1043"></a><span id="l30.1043" class="difflineplus">+            references[targetIdentityID] = null;</span>
<a href="#l30.1044"></a><span id="l30.1044" class="difflineplus">+        }</span>
<a href="#l30.1045"></a><span id="l30.1045" class="difflineplus">+        </span>
<a href="#l30.1046"></a><span id="l30.1046" class="difflineplus">+        return true;</span>
<a href="#l30.1047"></a><span id="l30.1047" class="difflineplus">+      },</span>
<a href="#l30.1048"></a><span id="l30.1048" class="difflineplus">+      resolveObjDependencies: function(aJsonValues, aReferencesByNounID,</span>
<a href="#l30.1049"></a><span id="l30.1049" class="difflineplus">+          aInverseReferencesByNounID) {</span>
<a href="#l30.1050"></a><span id="l30.1050" class="difflineplus">+        let references =</span>
<a href="#l30.1051"></a><span id="l30.1051" class="difflineplus">+          aReferencesByNounID[Gloda.NOUN_IDENTITY];</span>
<a href="#l30.1052"></a><span id="l30.1052" class="difflineplus">+        </span>
<a href="#l30.1053"></a><span id="l30.1053" class="difflineplus">+        let results = [];</span>
<a href="#l30.1054"></a><span id="l30.1054" class="difflineplus">+        for each (let [, tupe] in Iterator(aJsonValues)) {</span>
<a href="#l30.1055"></a><span id="l30.1055" class="difflineplus">+          let [originIdentityID, targetIdentityID] = tupe;</span>
<a href="#l30.1056"></a><span id="l30.1056" class="difflineplus">+          results.push([references[originIdentityID],</span>
<a href="#l30.1057"></a><span id="l30.1057" class="difflineplus">+                        references[targetIdentityID]]);</span>
<a href="#l30.1058"></a><span id="l30.1058" class="difflineplus">+        }</span>
<a href="#l30.1059"></a><span id="l30.1059" class="difflineplus">+        </span>
<a href="#l30.1060"></a><span id="l30.1060" class="difflineplus">+        return results;</span>
<a href="#l30.1061"></a><span id="l30.1061" class="difflineplus">+      },</span>
<a href="#l30.1062"></a><span id="l30.1062" class="difflineplus">+      toJSON: function (aIdentityTuple) {</span>
<a href="#l30.1063"></a><span id="l30.1063" class="difflineplus">+        return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l30.1064"></a><span id="l30.1064" class="difflineplus">+      },</span>
<a href="#l30.1065"></a><span id="l30.1065" class="difflineplus">+      toParamAndValue: function(aIdentityTuple) {</span>
<a href="#l30.1066"></a><span id="l30.1066" class="difflineplus">+        return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l30.1067"></a><span id="l30.1067" class="difflineplus">+      }}, this.NOUN_PARAM_IDENTITY);</span>
<a href="#l30.1068"></a><span id="l30.1068" class="difflineplus">+</span>
<a href="#l30.1069"></a><span id="l30.1069" class="difflineplus">+    GlodaDatastore.getAllAttributes();</span>
<a href="#l30.1070"></a><span id="l30.1070" class="difflineplus">+  },</span>
<a href="#l30.1071"></a><span id="l30.1071" class="difflineplus">+</span>
<a href="#l30.1072"></a><span id="l30.1072" class="difflineplus">+  /**</span>
<a href="#l30.1073"></a><span id="l30.1073" class="difflineplus">+   * Create accessor functions to 'bind' an attribute to underlying normalized</span>
<a href="#l30.1074"></a><span id="l30.1074" class="difflineplus">+   *  attribute storage, as well as creating the appropriate query object</span>
<a href="#l30.1075"></a><span id="l30.1075" class="difflineplus">+   *  constraint helper functions.  This name is somewhat of a misnomer because</span>
<a href="#l30.1076"></a><span id="l30.1076" class="difflineplus">+   *  special attributes are not 'bound' (because specific/non-generic per-class</span>
<a href="#l30.1077"></a><span id="l30.1077" class="difflineplus">+   *  code provides the properties) but still depend on this method to</span>
<a href="#l30.1078"></a><span id="l30.1078" class="difflineplus">+   *  establish their constraint helper methods.</span>
<a href="#l30.1079"></a><span id="l30.1079" class="difflineplus">+   *</span>
<a href="#l30.1080"></a><span id="l30.1080" class="difflineplus">+   * @XXX potentially rename to not suggest binding is required.</span>
<a href="#l30.1081"></a><span id="l30.1081" class="difflineplus">+   */</span>
<a href="#l30.1082"></a><span id="l30.1082" class="difflineplus">+  _bindAttribute: function gloda_ns_bindAttr(aAttrDef, aSubjectNounDef) {</span>
<a href="#l30.1083"></a><span id="l30.1083" class="difflineplus">+    let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l30.1084"></a><span id="l30.1084" class="difflineplus">+</span>
<a href="#l30.1085"></a><span id="l30.1085" class="difflineplus">+    // -- the query constraint helpers</span>
<a href="#l30.1086"></a><span id="l30.1086" class="difflineplus">+    if (aSubjectNounDef.queryClass !== undefined) {</span>
<a href="#l30.1087"></a><span id="l30.1087" class="difflineplus">+      let constrainer;</span>
<a href="#l30.1088"></a><span id="l30.1088" class="difflineplus">+      // non-strings can use IN</span>
<a href="#l30.1089"></a><span id="l30.1089" class="difflineplus">+      if (aAttrDef.special == this.kSpecialFulltext) {</span>
<a href="#l30.1090"></a><span id="l30.1090" class="difflineplus">+        constrainer = function() {</span>
<a href="#l30.1091"></a><span id="l30.1091" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintFulltext, aAttrDef];</span>
<a href="#l30.1092"></a><span id="l30.1092" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l30.1093"></a><span id="l30.1093" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l30.1094"></a><span id="l30.1094" class="difflineplus">+          }</span>
<a href="#l30.1095"></a><span id="l30.1095" class="difflineplus">+          this._constraints.push(constraint);</span>
<a href="#l30.1096"></a><span id="l30.1096" class="difflineplus">+          return this;</span>
<a href="#l30.1097"></a><span id="l30.1097" class="difflineplus">+        };</span>
<a href="#l30.1098"></a><span id="l30.1098" class="difflineplus">+      }</span>
<a href="#l30.1099"></a><span id="l30.1099" class="difflineplus">+      else if (aAttrDef.special != this.kSpecialString) {</span>
<a href="#l30.1100"></a><span id="l30.1100" class="difflineplus">+        constrainer = function() {</span>
<a href="#l30.1101"></a><span id="l30.1101" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintIn, aAttrDef];</span>
<a href="#l30.1102"></a><span id="l30.1102" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l30.1103"></a><span id="l30.1103" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l30.1104"></a><span id="l30.1104" class="difflineplus">+          }</span>
<a href="#l30.1105"></a><span id="l30.1105" class="difflineplus">+          this._constraints.push(constraint);</span>
<a href="#l30.1106"></a><span id="l30.1106" class="difflineplus">+          return this;</span>
<a href="#l30.1107"></a><span id="l30.1107" class="difflineplus">+        };</span>
<a href="#l30.1108"></a><span id="l30.1108" class="difflineplus">+      }</span>
<a href="#l30.1109"></a><span id="l30.1109" class="difflineplus">+      else { // strings need to use equals for escaping reasons</span>
<a href="#l30.1110"></a><span id="l30.1110" class="difflineplus">+        // (we could introduce an 'escaped' in that we manually escape though)</span>
<a href="#l30.1111"></a><span id="l30.1111" class="difflineplus">+        constrainer = function() {</span>
<a href="#l30.1112"></a><span id="l30.1112" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintEquals, aAttrDef];</span>
<a href="#l30.1113"></a><span id="l30.1113" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l30.1114"></a><span id="l30.1114" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l30.1115"></a><span id="l30.1115" class="difflineplus">+          }</span>
<a href="#l30.1116"></a><span id="l30.1116" class="difflineplus">+          this._constraints.push(constraint);</span>
<a href="#l30.1117"></a><span id="l30.1117" class="difflineplus">+          return this;</span>
<a href="#l30.1118"></a><span id="l30.1118" class="difflineplus">+        };</span>
<a href="#l30.1119"></a><span id="l30.1119" class="difflineplus">+      }</span>
<a href="#l30.1120"></a><span id="l30.1120" class="difflineplus">+</span>
<a href="#l30.1121"></a><span id="l30.1121" class="difflineplus">+      aSubjectNounDef.queryClass.prototype[aAttrDef.boundName] = constrainer;</span>
<a href="#l30.1122"></a><span id="l30.1122" class="difflineplus">+</span>
<a href="#l30.1123"></a><span id="l30.1123" class="difflineplus">+      // - ranged value helper: fooRange</span>
<a href="#l30.1124"></a><span id="l30.1124" class="difflineplus">+      if (objectNounDef.continuous) {</span>
<a href="#l30.1125"></a><span id="l30.1125" class="difflineplus">+        // takes one or more tuples of [lower bound, upper bound]</span>
<a href="#l30.1126"></a><span id="l30.1126" class="difflineplus">+        let rangedConstrainer = function() {</span>
<a href="#l30.1127"></a><span id="l30.1127" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintRanges, aAttrDef];</span>
<a href="#l30.1128"></a><span id="l30.1128" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++ ) {</span>
<a href="#l30.1129"></a><span id="l30.1129" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l30.1130"></a><span id="l30.1130" class="difflineplus">+          }</span>
<a href="#l30.1131"></a><span id="l30.1131" class="difflineplus">+          this._constraints.push(constraints);</span>
<a href="#l30.1132"></a><span id="l30.1132" class="difflineplus">+          return this;</span>
<a href="#l30.1133"></a><span id="l30.1133" class="difflineplus">+        }</span>
<a href="#l30.1134"></a><span id="l30.1134" class="difflineplus">+</span>
<a href="#l30.1135"></a><span id="l30.1135" class="difflineplus">+        aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Range&quot;] =</span>
<a href="#l30.1136"></a><span id="l30.1136" class="difflineplus">+          rangedConstrainer;</span>
<a href="#l30.1137"></a><span id="l30.1137" class="difflineplus">+      }</span>
<a href="#l30.1138"></a><span id="l30.1138" class="difflineplus">+</span>
<a href="#l30.1139"></a><span id="l30.1139" class="difflineplus">+      // - string LIKE helper for special on-row attributes: fooLike</span>
<a href="#l30.1140"></a><span id="l30.1140" class="difflineplus">+      // (it is impossible to store a string as an indexed attribute, which is</span>
<a href="#l30.1141"></a><span id="l30.1141" class="difflineplus">+      //  why we do this for on-row only.)</span>
<a href="#l30.1142"></a><span id="l30.1142" class="difflineplus">+      if (aAttrDef.special == this.kSpecialString) {</span>
<a href="#l30.1143"></a><span id="l30.1143" class="difflineplus">+        let likeConstrainer = function() {</span>
<a href="#l30.1144"></a><span id="l30.1144" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintStringLike, aAttrDef];</span>
<a href="#l30.1145"></a><span id="l30.1145" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l30.1146"></a><span id="l30.1146" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l30.1147"></a><span id="l30.1147" class="difflineplus">+          }</span>
<a href="#l30.1148"></a><span id="l30.1148" class="difflineplus">+          this._constraints.push(constraint);</span>
<a href="#l30.1149"></a><span id="l30.1149" class="difflineplus">+          return this;</span>
<a href="#l30.1150"></a><span id="l30.1150" class="difflineplus">+        }</span>
<a href="#l30.1151"></a><span id="l30.1151" class="difflineplus">+</span>
<a href="#l30.1152"></a><span id="l30.1152" class="difflineplus">+        aSubjectNounDef.queryClass.prototype[aAttrDef.boundName + &quot;Like&quot;] =</span>
<a href="#l30.1153"></a><span id="l30.1153" class="difflineplus">+          likeConstrainer;</span>
<a href="#l30.1154"></a><span id="l30.1154" class="difflineplus">+      }</span>
<a href="#l30.1155"></a><span id="l30.1155" class="difflineplus">+    }</span>
<a href="#l30.1156"></a><span id="l30.1156" class="difflineplus">+  },</span>
<a href="#l30.1157"></a><span id="l30.1157" class="difflineplus">+</span>
<a href="#l30.1158"></a><span id="l30.1158" class="difflineplus">+  /**</span>
<a href="#l30.1159"></a><span id="l30.1159" class="difflineplus">+   * Define an attribute and all its meta-data.  Takes a single dictionary as</span>
<a href="#l30.1160"></a><span id="l30.1160" class="difflineplus">+   *  its argument, with the following required properties:</span>
<a href="#l30.1161"></a><span id="l30.1161" class="difflineplus">+   *</span>
<a href="#l30.1162"></a><span id="l30.1162" class="difflineplus">+   * @param provider The object instance providing a 'process' method.</span>
<a href="#l30.1163"></a><span id="l30.1163" class="difflineplus">+   * @param extensionName The name of the extension providing these attributes.</span>
<a href="#l30.1164"></a><span id="l30.1164" class="difflineplus">+   * @param attributeType The type of attribute, one of the values from the</span>
<a href="#l30.1165"></a><span id="l30.1165" class="difflineplus">+   *     kAttr* enumeration.</span>
<a href="#l30.1166"></a><span id="l30.1166" class="difflineplus">+   * @param attributeName The name of the attribute, which also doubles as the</span>
<a href="#l30.1167"></a><span id="l30.1167" class="difflineplus">+   *     bound property name if you pass 'bind' a value of true.  You are</span>
<a href="#l30.1168"></a><span id="l30.1168" class="difflineplus">+   *     responsible for avoiding collisions, which presumably will mean</span>
<a href="#l30.1169"></a><span id="l30.1169" class="difflineplus">+   *     checking/updating a wiki page in the future, or just prefixing your</span>
<a href="#l30.1170"></a><span id="l30.1170" class="difflineplus">+   *     attribute name with your extension name or something like that.</span>
<a href="#l30.1171"></a><span id="l30.1171" class="difflineplus">+   * @param bind Should this attribute be 'bound' as a convenience attribute</span>
<a href="#l30.1172"></a><span id="l30.1172" class="difflineplus">+   *     on the subject's object (true/false)?  For example, with an</span>
<a href="#l30.1173"></a><span id="l30.1173" class="difflineplus">+   *     attributeName of &quot;foo&quot; and passing true for 'bind' with a subject noun</span>
<a href="#l30.1174"></a><span id="l30.1174" class="difflineplus">+   *     of NOUN_MESSAGE, GlodaMessage instances will expose a &quot;foo&quot; getter</span>
<a href="#l30.1175"></a><span id="l30.1175" class="difflineplus">+   *     that returns the value of the attribute.  If 'singular' is true, this</span>
<a href="#l30.1176"></a><span id="l30.1176" class="difflineplus">+   *     means an instance of the object class corresponding to the noun type or</span>
<a href="#l30.1177"></a><span id="l30.1177" class="difflineplus">+   *     null if the attribute does not exist.  If 'singular' is false, this</span>
<a href="#l30.1178"></a><span id="l30.1178" class="difflineplus">+   *     means a list of instances of the object class corresponding to the noun</span>
<a href="#l30.1179"></a><span id="l30.1179" class="difflineplus">+   *     type, where the list may be empty if no instances of the attribute are</span>
<a href="#l30.1180"></a><span id="l30.1180" class="difflineplus">+   *     present.</span>
<a href="#l30.1181"></a><span id="l30.1181" class="difflineplus">+   * @param bindName Optional override of attributeName for purposes of the</span>
<a href="#l30.1182"></a><span id="l30.1182" class="difflineplus">+   *     binding property's name.</span>
<a href="#l30.1183"></a><span id="l30.1183" class="difflineplus">+   * @param singular Is the attribute going to happen at most once (true),</span>
<a href="#l30.1184"></a><span id="l30.1184" class="difflineplus">+   *     or potentially multiple times (false).  This affects whether</span>
<a href="#l30.1185"></a><span id="l30.1185" class="difflineplus">+   *     the binding  returns a list or just a single item (which is null when</span>
<a href="#l30.1186"></a><span id="l30.1186" class="difflineplus">+   *     the attribute is not present).</span>
<a href="#l30.1187"></a><span id="l30.1187" class="difflineplus">+   * @param subjectNouns A list of object types (NOUNs) that this attribute can</span>
<a href="#l30.1188"></a><span id="l30.1188" class="difflineplus">+   *     be set on.  Each element in the list should be one of the NOUN_*</span>
<a href="#l30.1189"></a><span id="l30.1189" class="difflineplus">+   *     constants or a dynamically registered noun type.</span>
<a href="#l30.1190"></a><span id="l30.1190" class="difflineplus">+   * @param objectNoun The object type (one of the NOUN_* constants or a</span>
<a href="#l30.1191"></a><span id="l30.1191" class="difflineplus">+   *     dynamically registered noun types) that is the 'object' in the</span>
<a href="#l30.1192"></a><span id="l30.1192" class="difflineplus">+   *     traditional RDF triple.  More pragmatically, in the database row used</span>
<a href="#l30.1193"></a><span id="l30.1193" class="difflineplus">+   *     to represent an attribute, we store the subject (ex: message ID),</span>
<a href="#l30.1194"></a><span id="l30.1194" class="difflineplus">+   *     attribute ID, and an integer which is the integer representation of the</span>
<a href="#l30.1195"></a><span id="l30.1195" class="difflineplus">+   *     'object' whose type you are defining right here.</span>
<a href="#l30.1196"></a><span id="l30.1196" class="difflineplus">+   */</span>
<a href="#l30.1197"></a><span id="l30.1197" class="difflineplus">+  defineAttribute: function gloda_ns_defineAttribute(aAttrDef) {</span>
<a href="#l30.1198"></a><span id="l30.1198" class="difflineplus">+    // ensure required properties exist on aAttrDef</span>
<a href="#l30.1199"></a><span id="l30.1199" class="difflineplus">+    if (!(&quot;provider&quot; in aAttrDef) ||</span>
<a href="#l30.1200"></a><span id="l30.1200" class="difflineplus">+        !(&quot;extensionName&quot; in aAttrDef) ||</span>
<a href="#l30.1201"></a><span id="l30.1201" class="difflineplus">+        !(&quot;attributeType&quot; in aAttrDef) ||</span>
<a href="#l30.1202"></a><span id="l30.1202" class="difflineplus">+        !(&quot;attributeName&quot; in aAttrDef) ||</span>
<a href="#l30.1203"></a><span id="l30.1203" class="difflineplus">+        !(&quot;singular&quot; in aAttrDef) ||</span>
<a href="#l30.1204"></a><span id="l30.1204" class="difflineplus">+        !(&quot;subjectNouns&quot; in aAttrDef) ||</span>
<a href="#l30.1205"></a><span id="l30.1205" class="difflineplus">+        !(&quot;objectNoun&quot; in aAttrDef))</span>
<a href="#l30.1206"></a><span id="l30.1206" class="difflineplus">+      // perhaps we should have a list of required attributes, perchance with</span>
<a href="#l30.1207"></a><span id="l30.1207" class="difflineplus">+      //  and explanation of what it holds, and use that to be friendlier?</span>
<a href="#l30.1208"></a><span id="l30.1208" class="difflineplus">+      throw Error(&quot;You omitted a required attribute defining property, please&quot; +</span>
<a href="#l30.1209"></a><span id="l30.1209" class="difflineplus">+                  &quot; consult the documentation as penance.&quot;)</span>
<a href="#l30.1210"></a><span id="l30.1210" class="difflineplus">+</span>
<a href="#l30.1211"></a><span id="l30.1211" class="difflineplus">+    // return if the attribute has already been defined</span>
<a href="#l30.1212"></a><span id="l30.1212" class="difflineplus">+    if (aAttrDef.dbDef) {</span>
<a href="#l30.1213"></a><span id="l30.1213" class="difflineplus">+      return aAttrDef;</span>
<a href="#l30.1214"></a><span id="l30.1214" class="difflineplus">+    }</span>
<a href="#l30.1215"></a><span id="l30.1215" class="difflineplus">+</span>
<a href="#l30.1216"></a><span id="l30.1216" class="difflineplus">+    // provider tracking</span>
<a href="#l30.1217"></a><span id="l30.1217" class="difflineplus">+    if (!(aAttrDef.provider.providerName in this._attrProviders)) {</span>
<a href="#l30.1218"></a><span id="l30.1218" class="difflineplus">+      this._attrProviders[aAttrDef.provider.providerName] = [];</span>
<a href="#l30.1219"></a><span id="l30.1219" class="difflineplus">+    }</span>
<a href="#l30.1220"></a><span id="l30.1220" class="difflineplus">+</span>
<a href="#l30.1221"></a><span id="l30.1221" class="difflineplus">+    let compoundName = aAttrDef.extensionName + &quot;:&quot; + aAttrDef.attributeName;</span>
<a href="#l30.1222"></a><span id="l30.1222" class="difflineplus">+    let attrDBDef;</span>
<a href="#l30.1223"></a><span id="l30.1223" class="difflineplus">+    if (compoundName in GlodaDatastore._attributeDBDefs) {</span>
<a href="#l30.1224"></a><span id="l30.1224" class="difflineplus">+      // the existence of the GlodaAttributeDBDef means that either it has</span>
<a href="#l30.1225"></a><span id="l30.1225" class="difflineplus">+      //  already been fully defined, or has been loaded from the database but</span>
<a href="#l30.1226"></a><span id="l30.1226" class="difflineplus">+      //  not yet 'bound' to a provider (and had important meta-info that</span>
<a href="#l30.1227"></a><span id="l30.1227" class="difflineplus">+      //  doesn't go in the db copied over)</span>
<a href="#l30.1228"></a><span id="l30.1228" class="difflineplus">+      attrDBDef = GlodaDatastore._attributeDBDefs[compoundName];</span>
<a href="#l30.1229"></a><span id="l30.1229" class="difflineplus">+    }</span>
<a href="#l30.1230"></a><span id="l30.1230" class="difflineplus">+    // we need to create the attribute definition in the database</span>
<a href="#l30.1231"></a><span id="l30.1231" class="difflineplus">+    else {</span>
<a href="#l30.1232"></a><span id="l30.1232" class="difflineplus">+      let attrID = null;</span>
<a href="#l30.1233"></a><span id="l30.1233" class="difflineplus">+      attrID = GlodaDatastore._createAttributeDef(aAttrDef.attributeType,</span>
<a href="#l30.1234"></a><span id="l30.1234" class="difflineplus">+                                                  aAttrDef.extensionName,</span>
<a href="#l30.1235"></a><span id="l30.1235" class="difflineplus">+                                                  aAttrDef.attributeName,</span>
<a href="#l30.1236"></a><span id="l30.1236" class="difflineplus">+                                                  null);</span>
<a href="#l30.1237"></a><span id="l30.1237" class="difflineplus">+    </span>
<a href="#l30.1238"></a><span id="l30.1238" class="difflineplus">+      attrDBDef = new GlodaAttributeDBDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l30.1239"></a><span id="l30.1239" class="difflineplus">+        aAttrDef.attributeType, aAttrDef.extensionName, aAttrDef.attributeName);</span>
<a href="#l30.1240"></a><span id="l30.1240" class="difflineplus">+      GlodaDatastore._attributeDBDefs[compoundName] = attrDBDef;</span>
<a href="#l30.1241"></a><span id="l30.1241" class="difflineplus">+      GlodaDatastore._attributeIDToDBDefAndParam[attrID] = [attrDBDef, null];</span>
<a href="#l30.1242"></a><span id="l30.1242" class="difflineplus">+    }</span>
<a href="#l30.1243"></a><span id="l30.1243" class="difflineplus">+    </span>
<a href="#l30.1244"></a><span id="l30.1244" class="difflineplus">+    aAttrDef.dbDef = attrDBDef;</span>
<a href="#l30.1245"></a><span id="l30.1245" class="difflineplus">+    attrDBDef.attrDef = aAttrDef;</span>
<a href="#l30.1246"></a><span id="l30.1246" class="difflineplus">+    </span>
<a href="#l30.1247"></a><span id="l30.1247" class="difflineplus">+    aAttrDef.id = aAttrDef.dbDef.id;</span>
<a href="#l30.1248"></a><span id="l30.1248" class="difflineplus">+</span>
<a href="#l30.1249"></a><span id="l30.1249" class="difflineplus">+    if (&quot;bindName&quot; in aAttrDef)</span>
<a href="#l30.1250"></a><span id="l30.1250" class="difflineplus">+      aAttrDef.boundName = aAttrDef.bindName;</span>
<a href="#l30.1251"></a><span id="l30.1251" class="difflineplus">+    else</span>
<a href="#l30.1252"></a><span id="l30.1252" class="difflineplus">+      aAttrDef.boundName = aAttrDef.attributeName;</span>
<a href="#l30.1253"></a><span id="l30.1253" class="difflineplus">+    </span>
<a href="#l30.1254"></a><span id="l30.1254" class="difflineplus">+    aAttrDef.objectNounDef = this._nounIDToDef[aAttrDef.objectNoun];</span>
<a href="#l30.1255"></a><span id="l30.1255" class="difflineplus">+    aAttrDef.objectNounDef.objectNounOfAttributes.push(aAttrDef);</span>
<a href="#l30.1256"></a><span id="l30.1256" class="difflineplus">+</span>
<a href="#l30.1257"></a><span id="l30.1257" class="difflineplus">+    for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l30.1258"></a><span id="l30.1258" class="difflineplus">+           iSubject++) {</span>
<a href="#l30.1259"></a><span id="l30.1259" class="difflineplus">+      let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l30.1260"></a><span id="l30.1260" class="difflineplus">+      let subjectNounDef = this._nounIDToDef[subjectType];</span>
<a href="#l30.1261"></a><span id="l30.1261" class="difflineplus">+      this._bindAttribute(aAttrDef, subjectNounDef);</span>
<a href="#l30.1262"></a><span id="l30.1262" class="difflineplus">+</span>
<a href="#l30.1263"></a><span id="l30.1263" class="difflineplus">+      // update the provider maps...</span>
<a href="#l30.1264"></a><span id="l30.1264" class="difflineplus">+      if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l30.1265"></a><span id="l30.1265" class="difflineplus">+              .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l30.1266"></a><span id="l30.1266" class="difflineplus">+        this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l30.1267"></a><span id="l30.1267" class="difflineplus">+        if (aAttrDef.provider.optimize)</span>
<a href="#l30.1268"></a><span id="l30.1268" class="difflineplus">+          this._attrOptimizerOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l30.1269"></a><span id="l30.1269" class="difflineplus">+        this._attrProvidersByNoun[subjectType][aAttrDef.provider] = [];</span>
<a href="#l30.1270"></a><span id="l30.1270" class="difflineplus">+      }</span>
<a href="#l30.1271"></a><span id="l30.1271" class="difflineplus">+      this._attrProvidersByNoun[subjectType][aAttrDef.provider].push(aAttrDef);</span>
<a href="#l30.1272"></a><span id="l30.1272" class="difflineplus">+      </span>
<a href="#l30.1273"></a><span id="l30.1273" class="difflineplus">+      subjectNounDef.attribsByBoundName[aAttrDef.boundName] = aAttrDef;</span>
<a href="#l30.1274"></a><span id="l30.1274" class="difflineplus">+      if (aAttrDef.domExpose)</span>
<a href="#l30.1275"></a><span id="l30.1275" class="difflineplus">+        subjectNounDef.domExposeAttribsByBoundName[aAttrDef.boundName] =</span>
<a href="#l30.1276"></a><span id="l30.1276" class="difflineplus">+          aAttrDef;</span>
<a href="#l30.1277"></a><span id="l30.1277" class="difflineplus">+      </span>
<a href="#l30.1278"></a><span id="l30.1278" class="difflineplus">+      if (aAttrDef.special &amp; this.kSpecialColumn)</span>
<a href="#l30.1279"></a><span id="l30.1279" class="difflineplus">+        subjectNounDef.specialLoadAttribs.push(aAttrDef);</span>
<a href="#l30.1280"></a><span id="l30.1280" class="difflineplus">+      </span>
<a href="#l30.1281"></a><span id="l30.1281" class="difflineplus">+      // if this is a parent column attribute, make note of it so that if we</span>
<a href="#l30.1282"></a><span id="l30.1282" class="difflineplus">+      //  need to do an inverse references lookup, we know what column we are</span>
<a href="#l30.1283"></a><span id="l30.1283" class="difflineplus">+      //  issuing against.</span>
<a href="#l30.1284"></a><span id="l30.1284" class="difflineplus">+      if (aAttrDef.special === this.kSpecialColumnParent) {</span>
<a href="#l30.1285"></a><span id="l30.1285" class="difflineplus">+        subjectNounDef.parentColumnAttr = aAttrDef;</span>
<a href="#l30.1286"></a><span id="l30.1286" class="difflineplus">+      }</span>
<a href="#l30.1287"></a><span id="l30.1287" class="difflineplus">+      </span>
<a href="#l30.1288"></a><span id="l30.1288" class="difflineplus">+      if (aAttrDef.objectNounDef.tableName ||</span>
<a href="#l30.1289"></a><span id="l30.1289" class="difflineplus">+          aAttrDef.objectNounDef.contributeObjDependencies) {</span>
<a href="#l30.1290"></a><span id="l30.1290" class="difflineplus">+        subjectNounDef.hasObjDependencies = true;</span>
<a href="#l30.1291"></a><span id="l30.1291" class="difflineplus">+      }</span>
<a href="#l30.1292"></a><span id="l30.1292" class="difflineplus">+    }</span>
<a href="#l30.1293"></a><span id="l30.1293" class="difflineplus">+    </span>
<a href="#l30.1294"></a><span id="l30.1294" class="difflineplus">+    this._attrProviders[aAttrDef.provider.providerName].push(aAttrDef);</span>
<a href="#l30.1295"></a><span id="l30.1295" class="difflineplus">+    return aAttrDef;</span>
<a href="#l30.1296"></a><span id="l30.1296" class="difflineplus">+  },</span>
<a href="#l30.1297"></a><span id="l30.1297" class="difflineplus">+</span>
<a href="#l30.1298"></a><span id="l30.1298" class="difflineplus">+  /**</span>
<a href="#l30.1299"></a><span id="l30.1299" class="difflineplus">+   * Retrieve the attribute provided by the given extension with the given</span>
<a href="#l30.1300"></a><span id="l30.1300" class="difflineplus">+   *  attribute name.  The original idea was that plugins would effectively</span>
<a href="#l30.1301"></a><span id="l30.1301" class="difflineplus">+   *  name-space attributes, helping avoid collisions.  Since we are leaning</span>
<a href="#l30.1302"></a><span id="l30.1302" class="difflineplus">+   *  towards using binding heavily, this doesn't really help, as the collisions</span>
<a href="#l30.1303"></a><span id="l30.1303" class="difflineplus">+   *  will just occur on the attribute name instead.  Also, this can turn</span>
<a href="#l30.1304"></a><span id="l30.1304" class="difflineplus">+   *  extensions into liars as name changes/moves to core/etc. happen.</span>
<a href="#l30.1305"></a><span id="l30.1305" class="difflineplus">+   * @TODO consider removing the extension name argument parameter requirement</span>
<a href="#l30.1306"></a><span id="l30.1306" class="difflineplus">+   */</span>
<a href="#l30.1307"></a><span id="l30.1307" class="difflineplus">+  getAttrDef: function gloda_ns_getAttrDef(aPluginName, aAttrName) {</span>
<a href="#l30.1308"></a><span id="l30.1308" class="difflineplus">+    let compoundName = aPluginName + &quot;:&quot; + aAttrName;</span>
<a href="#l30.1309"></a><span id="l30.1309" class="difflineplus">+    return GlodaDatastore._attributeDBDefs[compoundName];</span>
<a href="#l30.1310"></a><span id="l30.1310" class="difflineplus">+  },</span>
<a href="#l30.1311"></a><span id="l30.1311" class="difflineplus">+</span>
<a href="#l30.1312"></a><span id="l30.1312" class="difflineplus">+  /**</span>
<a href="#l30.1313"></a><span id="l30.1313" class="difflineplus">+   * Define a SQL table for plug-ins.  This is intended to be used by</span>
<a href="#l30.1314"></a><span id="l30.1314" class="difflineplus">+   *  extensions/plug-ins whose storage needs exceed those provided by the</span>
<a href="#l30.1315"></a><span id="l30.1315" class="difflineplus">+   *  attribute parameter (on the attribute definition)/attribute value (on the</span>
<a href="#l30.1316"></a><span id="l30.1316" class="difflineplus">+   *  attribute instance) idiom.  (This includes extensions whose parameter</span>
<a href="#l30.1317"></a><span id="l30.1317" class="difflineplus">+   *  usage would exceed acceptable cardinality.)  They can create a table</span>
<a href="#l30.1318"></a><span id="l30.1318" class="difflineplus">+   *  to store information on their nouns, using their row id (commonly &quot;id&quot;)</span>
<a href="#l30.1319"></a><span id="l30.1319" class="difflineplus">+   *  as the attribute value.</span>
<a href="#l30.1320"></a><span id="l30.1320" class="difflineplus">+   * The current implementation was for a prototype and this should not be</span>
<a href="#l30.1321"></a><span id="l30.1321" class="difflineplus">+   *  interpreted as our final approach.  Our goal is just to make it easy to</span>
<a href="#l30.1322"></a><span id="l30.1322" class="difflineplus">+   *  add your own data-type and have it interact with the rest of the gloda</span>
<a href="#l30.1323"></a><span id="l30.1323" class="difflineplus">+   *  schema.  We don't really want to be a be-all, end-all JS ORM (object</span>
<a href="#l30.1324"></a><span id="l30.1324" class="difflineplus">+   *  relational mapper), though we started down that road.</span>
<a href="#l30.1325"></a><span id="l30.1325" class="difflineplus">+   *</span>
<a href="#l30.1326"></a><span id="l30.1326" class="difflineplus">+   * The argument should be a dictionary with the following keys:</span>
<a href="#l30.1327"></a><span id="l30.1327" class="difflineplus">+   * @param name The table name; don't conflict with other things!</span>
<a href="#l30.1328"></a><span id="l30.1328" class="difflineplus">+   * @param columns A list of [column name, sqlite type] tuples.  You should</span>
<a href="#l30.1329"></a><span id="l30.1329" class="difflineplus">+   *     always include a definition like [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;] for</span>
<a href="#l30.1330"></a><span id="l30.1330" class="difflineplus">+   *     now.</span>
<a href="#l30.1331"></a><span id="l30.1331" class="difflineplus">+   * @param indices A dictionary of lists of column names, where the key name</span>
<a href="#l30.1332"></a><span id="l30.1332" class="difflineplus">+   *     becomes the index name.  Ex: {foo: [&quot;bar&quot;]} results in an index on</span>
<a href="#l30.1333"></a><span id="l30.1333" class="difflineplus">+   *     the column &quot;bar&quot; where the index is named &quot;foo&quot;.</span>
<a href="#l30.1334"></a><span id="l30.1334" class="difflineplus">+   */</span>
<a href="#l30.1335"></a><span id="l30.1335" class="difflineplus">+  defineTable: function gloda_ns_defineTable(aTableDef) {</span>
<a href="#l30.1336"></a><span id="l30.1336" class="difflineplus">+    return GlodaDatastore.createTableIfNotExists(aTableDef);</span>
<a href="#l30.1337"></a><span id="l30.1337" class="difflineplus">+  },</span>
<a href="#l30.1338"></a><span id="l30.1338" class="difflineplus">+</span>
<a href="#l30.1339"></a><span id="l30.1339" class="difflineplus">+  /**</span>
<a href="#l30.1340"></a><span id="l30.1340" class="difflineplus">+   * Create a new query instance for the given noun-type.  This provides</span>
<a href="#l30.1341"></a><span id="l30.1341" class="difflineplus">+   *  a generic way to provide constraint-based queries of any first-class</span>
<a href="#l30.1342"></a><span id="l30.1342" class="difflineplus">+   *  nouns supported by the system.</span>
<a href="#l30.1343"></a><span id="l30.1343" class="difflineplus">+   *</span>
<a href="#l30.1344"></a><span id="l30.1344" class="difflineplus">+   * The idea is that every attribute on an object can be used to express</span>
<a href="#l30.1345"></a><span id="l30.1345" class="difflineplus">+   *  a constraint on the query object.  Constraints implicitly 'AND' together,</span>
<a href="#l30.1346"></a><span id="l30.1346" class="difflineplus">+   *  but providing multiple arguments to a constraint function results in an</span>
<a href="#l30.1347"></a><span id="l30.1347" class="difflineplus">+   *  'OR'ing of those values.  Additionally, you can call or() on the returned</span>
<a href="#l30.1348"></a><span id="l30.1348" class="difflineplus">+   *  query to create an alternate query that is effectively a giant OR against</span>
<a href="#l30.1349"></a><span id="l30.1349" class="difflineplus">+   *  all the constraints you create on the main query object (or any other</span>
<a href="#l30.1350"></a><span id="l30.1350" class="difflineplus">+   *  alternate queries returned by or()).  (Note: there is no nesting of these</span>
<a href="#l30.1351"></a><span id="l30.1351" class="difflineplus">+   *  alternate queries. query.or().or() is equivalent to query.or())</span>
<a href="#l30.1352"></a><span id="l30.1352" class="difflineplus">+   * For each attribute, there is a constraint with the same name that takes</span>
<a href="#l30.1353"></a><span id="l30.1353" class="difflineplus">+   *  one or more arguments.  The arguments represent a set of OR values that</span>
<a href="#l30.1354"></a><span id="l30.1354" class="difflineplus">+   *  objects matching the query can have.  (If you want the constraint</span>
<a href="#l30.1355"></a><span id="l30.1355" class="difflineplus">+   *  effectively ANDed together, just invoke the constraint function</span>
<a href="#l30.1356"></a><span id="l30.1356" class="difflineplus">+   *  multiple times.)  For example, newQuery(NOUN_PERSON).age(25) would</span>
<a href="#l30.1357"></a><span id="l30.1357" class="difflineplus">+   *  constraint to all the people aged 25, while age(25, 26) would constrain</span>
<a href="#l30.1358"></a><span id="l30.1358" class="difflineplus">+   *  to all the people age 25 or 26.</span>
<a href="#l30.1359"></a><span id="l30.1359" class="difflineplus">+   * For each attribute with a 'continuous' noun, there is a constraint with the</span>
<a href="#l30.1360"></a><span id="l30.1360" class="difflineplus">+   *  attribute name with &quot;Range&quot; appended.  It takes two arguments which are an</span>
<a href="#l30.1361"></a><span id="l30.1361" class="difflineplus">+   *  inclusive lower bound and an inclusive lower bound for values in the</span>
<a href="#l30.1362"></a><span id="l30.1362" class="difflineplus">+   *  range.  If you would like an open-ended range on either side, pass null</span>
<a href="#l30.1363"></a><span id="l30.1363" class="difflineplus">+   *  for that argument.  If you would like to specify multiple ranges that</span>
<a href="#l30.1364"></a><span id="l30.1364" class="difflineplus">+   *  should be ORed together, simply pass additional (pairs of) arguments.</span>
<a href="#l30.1365"></a><span id="l30.1365" class="difflineplus">+   *  For example, newQuery(NOUN_PERSON).age(25,100) would constraint to all</span>
<a href="#l30.1366"></a><span id="l30.1366" class="difflineplus">+   *  the people who are &gt;= 25 and &lt;= 100.  Likewise age(25, null) would just</span>
<a href="#l30.1367"></a><span id="l30.1367" class="difflineplus">+   *  return all the people who are 25 or older.  And age(25,30,35,40) would</span>
<a href="#l30.1368"></a><span id="l30.1368" class="difflineplus">+   *  return people who are either 25-30 or 35-30.</span>
<a href="#l30.1369"></a><span id="l30.1369" class="difflineplus">+   * There are also full-text constraint columns.  In a nutshell, their</span>
<a href="#l30.1370"></a><span id="l30.1370" class="difflineplus">+   *  arguments are the strings that should be passed to the SQLite FTS3</span>
<a href="#l30.1371"></a><span id="l30.1371" class="difflineplus">+   *  MATCH clause.</span>
<a href="#l30.1372"></a><span id="l30.1372" class="difflineplus">+   */</span>
<a href="#l30.1373"></a><span id="l30.1373" class="difflineplus">+  newQuery: function gloda_ns_newQuery(aNounID) {</span>
<a href="#l30.1374"></a><span id="l30.1374" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l30.1375"></a><span id="l30.1375" class="difflineplus">+    return new nounDef.queryClass();</span>
<a href="#l30.1376"></a><span id="l30.1376" class="difflineplus">+  },</span>
<a href="#l30.1377"></a><span id="l30.1377" class="difflineplus">+</span>
<a href="#l30.1378"></a><span id="l30.1378" class="difflineplus">+  /**</span>
<a href="#l30.1379"></a><span id="l30.1379" class="difflineplus">+   * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l30.1380"></a><span id="l30.1380" class="difflineplus">+   *  provided items.  This is to be used when you have an explicit set of items</span>
<a href="#l30.1381"></a><span id="l30.1381" class="difflineplus">+   *  that you would still like to receive updates for.</span>
<a href="#l30.1382"></a><span id="l30.1382" class="difflineplus">+   */</span>
<a href="#l30.1383"></a><span id="l30.1383" class="difflineplus">+  explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l30.1384"></a><span id="l30.1384" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l30.1385"></a><span id="l30.1385" class="difflineplus">+    let collection = new GlodaCollection(nounDef, aItems, null, null)</span>
<a href="#l30.1386"></a><span id="l30.1386" class="difflineplus">+    let query = new nounDef.explicitQueryClass(collection);</span>
<a href="#l30.1387"></a><span id="l30.1387" class="difflineplus">+    collection.query = query;</span>
<a href="#l30.1388"></a><span id="l30.1388" class="difflineplus">+    GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l30.1389"></a><span id="l30.1389" class="difflineplus">+    return collection;</span>
<a href="#l30.1390"></a><span id="l30.1390" class="difflineplus">+  },</span>
<a href="#l30.1391"></a><span id="l30.1391" class="difflineplus">+</span>
<a href="#l30.1392"></a><span id="l30.1392" class="difflineplus">+  /**</span>
<a href="#l30.1393"></a><span id="l30.1393" class="difflineplus">+   * Debugging 'wildcard' collection creation support.  A wildcard collection</span>
<a href="#l30.1394"></a><span id="l30.1394" class="difflineplus">+   *  will 'accept' any new item instances presented to the collection manager</span>
<a href="#l30.1395"></a><span id="l30.1395" class="difflineplus">+   *  as new.  The result is that it allows you to be notified as new items</span>
<a href="#l30.1396"></a><span id="l30.1396" class="difflineplus">+   *  as they are indexed, existing items as they are loaded from the database,</span>
<a href="#l30.1397"></a><span id="l30.1397" class="difflineplus">+   *  etc.</span>
<a href="#l30.1398"></a><span id="l30.1398" class="difflineplus">+   * Because the items are added to the collection without limit, this will</span>
<a href="#l30.1399"></a><span id="l30.1399" class="difflineplus">+   *  result in a leak if you don't do something to clean up after the</span>
<a href="#l30.1400"></a><span id="l30.1400" class="difflineplus">+   *  collection.  (Forgetting about the collection will suffice, as it is still</span>
<a href="#l30.1401"></a><span id="l30.1401" class="difflineplus">+   *  weakly held.)</span>
<a href="#l30.1402"></a><span id="l30.1402" class="difflineplus">+   */</span>
<a href="#l30.1403"></a><span id="l30.1403" class="difflineplus">+  _wildcardCollection: function gloda_ns_wildcardCollection(aNounID, aItems) {</span>
<a href="#l30.1404"></a><span id="l30.1404" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l30.1405"></a><span id="l30.1405" class="difflineplus">+    let collection = new GlodaCollection(nounDef, aItems, null, null)</span>
<a href="#l30.1406"></a><span id="l30.1406" class="difflineplus">+    let query = new nounDef.wildcardQueryClass(collection);</span>
<a href="#l30.1407"></a><span id="l30.1407" class="difflineplus">+    collection.query = query;</span>
<a href="#l30.1408"></a><span id="l30.1408" class="difflineplus">+    GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l30.1409"></a><span id="l30.1409" class="difflineplus">+    return collection;</span>
<a href="#l30.1410"></a><span id="l30.1410" class="difflineplus">+  },</span>
<a href="#l30.1411"></a><span id="l30.1411" class="difflineplus">+</span>
<a href="#l30.1412"></a><span id="l30.1412" class="difflineplus">+  /**</span>
<a href="#l30.1413"></a><span id="l30.1413" class="difflineplus">+   * Populate a gloda representation of an item given the thus-far built</span>
<a href="#l30.1414"></a><span id="l30.1414" class="difflineplus">+   *  representation, the previous representation, and one or more raw</span>
<a href="#l30.1415"></a><span id="l30.1415" class="difflineplus">+   *  representations.</span>
<a href="#l30.1416"></a><span id="l30.1416" class="difflineplus">+   *</span>
<a href="#l30.1417"></a><span id="l30.1417" class="difflineplus">+   * The result of the processing ends up with attributes in 3 different forms:</span>
<a href="#l30.1418"></a><span id="l30.1418" class="difflineplus">+   * - Database attribute rows (to be added and removed).</span>
<a href="#l30.1419"></a><span id="l30.1419" class="difflineplus">+   * - In-memory representation.</span>
<a href="#l30.1420"></a><span id="l30.1420" class="difflineplus">+   * - JSON-able representation.</span>
<a href="#l30.1421"></a><span id="l30.1421" class="difflineplus">+   */</span>
<a href="#l30.1422"></a><span id="l30.1422" class="difflineplus">+  grokNounItem: function gloda_ns_grokNounItem(aItem, aRawReps, aIsNew,</span>
<a href="#l30.1423"></a><span id="l30.1423" class="difflineplus">+      aCallbackHandle, aDoCache) {</span>
<a href="#l30.1424"></a><span id="l30.1424" class="difflineplus">+    let itemNounDef = this._nounIDToDef[aItem.NOUN_ID];</span>
<a href="#l30.1425"></a><span id="l30.1425" class="difflineplus">+    let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l30.1426"></a><span id="l30.1426" class="difflineplus">+    </span>
<a href="#l30.1427"></a><span id="l30.1427" class="difflineplus">+    this._log.info(&quot; ** grokNounItem: &quot; + itemNounDef.name);</span>
<a href="#l30.1428"></a><span id="l30.1428" class="difflineplus">+    </span>
<a href="#l30.1429"></a><span id="l30.1429" class="difflineplus">+    let addDBAttribs = [];</span>
<a href="#l30.1430"></a><span id="l30.1430" class="difflineplus">+    let removeDBAttribs = [];</span>
<a href="#l30.1431"></a><span id="l30.1431" class="difflineplus">+    </span>
<a href="#l30.1432"></a><span id="l30.1432" class="difflineplus">+    let jsonDict = {};</span>
<a href="#l30.1433"></a><span id="l30.1433" class="difflineplus">+    </span>
<a href="#l30.1434"></a><span id="l30.1434" class="difflineplus">+    let aOldItem;</span>
<a href="#l30.1435"></a><span id="l30.1435" class="difflineplus">+    if (aIsNew) // there is no old item if we are new.</span>
<a href="#l30.1436"></a><span id="l30.1436" class="difflineplus">+      aOldItem = {};</span>
<a href="#l30.1437"></a><span id="l30.1437" class="difflineplus">+    else {</span>
<a href="#l30.1438"></a><span id="l30.1438" class="difflineplus">+      aOldItem = aItem;</span>
<a href="#l30.1439"></a><span id="l30.1439" class="difflineplus">+      // we want to create a clone of the existing item so that we can know the</span>
<a href="#l30.1440"></a><span id="l30.1440" class="difflineplus">+      //  deltas that happened for indexing purposes</span>
<a href="#l30.1441"></a><span id="l30.1441" class="difflineplus">+      aItem = aItem._clone();</span>
<a href="#l30.1442"></a><span id="l30.1442" class="difflineplus">+    }</span>
<a href="#l30.1443"></a><span id="l30.1443" class="difflineplus">+  </span>
<a href="#l30.1444"></a><span id="l30.1444" class="difflineplus">+    // Have the attribute providers directly set properties on the aItem</span>
<a href="#l30.1445"></a><span id="l30.1445" class="difflineplus">+    let attrProviders = this._attrProviderOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l30.1446"></a><span id="l30.1446" class="difflineplus">+    for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l30.1447"></a><span id="l30.1447" class="difflineplus">+      this._log.info(&quot;  * provider: &quot; + attrProviders[iProvider].providerName);</span>
<a href="#l30.1448"></a><span id="l30.1448" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l30.1449"></a><span id="l30.1449" class="difflineplus">+        attrProviders[iProvider].process(aItem, aRawReps, aIsNew,</span>
<a href="#l30.1450"></a><span id="l30.1450" class="difflineplus">+                                         aCallbackHandle));</span>
<a href="#l30.1451"></a><span id="l30.1451" class="difflineplus">+    }</span>
<a href="#l30.1452"></a><span id="l30.1452" class="difflineplus">+    </span>
<a href="#l30.1453"></a><span id="l30.1453" class="difflineplus">+    let attrOptimizers = this._attrOptimizerOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l30.1454"></a><span id="l30.1454" class="difflineplus">+    for (let iProvider = 0; iProvider &lt; attrOptimizers.length; iProvider++) {</span>
<a href="#l30.1455"></a><span id="l30.1455" class="difflineplus">+      this._log.info(&quot;  * optimizer: &quot; + attrOptimizers[iProvider].providerName);</span>
<a href="#l30.1456"></a><span id="l30.1456" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l30.1457"></a><span id="l30.1457" class="difflineplus">+        attrOptimizers[iProvider].optimize(aItem, aRawReps, aIsNew,</span>
<a href="#l30.1458"></a><span id="l30.1458" class="difflineplus">+                                           aCallbackHandle));</span>
<a href="#l30.1459"></a><span id="l30.1459" class="difflineplus">+    }</span>
<a href="#l30.1460"></a><span id="l30.1460" class="difflineplus">+    </span>
<a href="#l30.1461"></a><span id="l30.1461" class="difflineplus">+    this._log.info(&quot; ** done with providers.&quot;);</span>
<a href="#l30.1462"></a><span id="l30.1462" class="difflineplus">+  </span>
<a href="#l30.1463"></a><span id="l30.1463" class="difflineplus">+    // Iterate over the attributes on the item</span>
<a href="#l30.1464"></a><span id="l30.1464" class="difflineplus">+    for each (let [key, value] in Iterator(aItem)) {</span>
<a href="#l30.1465"></a><span id="l30.1465" class="difflineplus">+      // ignore keys that start with underscores, they are private and not</span>
<a href="#l30.1466"></a><span id="l30.1466" class="difflineplus">+      //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l30.1467"></a><span id="l30.1467" class="difflineplus">+      //  the object implementation.)</span>
<a href="#l30.1468"></a><span id="l30.1468" class="difflineplus">+      if (key[0] == &quot;_&quot;)</span>
<a href="#l30.1469"></a><span id="l30.1469" class="difflineplus">+        continue;</span>
<a href="#l30.1470"></a><span id="l30.1470" class="difflineplus">+      // find the attribute definition that corresponds to this key</span>
<a href="#l30.1471"></a><span id="l30.1471" class="difflineplus">+      let attrib = attribsByBoundName[key];</span>
<a href="#l30.1472"></a><span id="l30.1472" class="difflineplus">+      // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l30.1473"></a><span id="l30.1473" class="difflineplus">+      if (attrib === undefined) {</span>
<a href="#l30.1474"></a><span id="l30.1474" class="difflineplus">+        this._log.warn(&quot;new proc ignoring attrib: &quot; + key);</span>
<a href="#l30.1475"></a><span id="l30.1475" class="difflineplus">+        continue;</span>
<a href="#l30.1476"></a><span id="l30.1476" class="difflineplus">+      }</span>
<a href="#l30.1477"></a><span id="l30.1477" class="difflineplus">+</span>
<a href="#l30.1478"></a><span id="l30.1478" class="difflineplus">+      let attribDB = attrib.dbDef;</span>
<a href="#l30.1479"></a><span id="l30.1479" class="difflineplus">+      let objectNounDef = attrib.objectNounDef;</span>
<a href="#l30.1480"></a><span id="l30.1480" class="difflineplus">+      </span>
<a href="#l30.1481"></a><span id="l30.1481" class="difflineplus">+      // - translate for our JSON rep</span>
<a href="#l30.1482"></a><span id="l30.1482" class="difflineplus">+      if (attrib.singular) {</span>
<a href="#l30.1483"></a><span id="l30.1483" class="difflineplus">+        if (objectNounDef.toJSON)</span>
<a href="#l30.1484"></a><span id="l30.1484" class="difflineplus">+          jsonDict[attrib.id] = objectNounDef.toJSON(value);</span>
<a href="#l30.1485"></a><span id="l30.1485" class="difflineplus">+        else</span>
<a href="#l30.1486"></a><span id="l30.1486" class="difflineplus">+          jsonDict[attrib.id] = value; </span>
<a href="#l30.1487"></a><span id="l30.1487" class="difflineplus">+      }</span>
<a href="#l30.1488"></a><span id="l30.1488" class="difflineplus">+      else {</span>
<a href="#l30.1489"></a><span id="l30.1489" class="difflineplus">+        if (objectNounDef.toJSON) {</span>
<a href="#l30.1490"></a><span id="l30.1490" class="difflineplus">+          toJSON = objectNounDef.toJSON;</span>
<a href="#l30.1491"></a><span id="l30.1491" class="difflineplus">+          jsonDict[attrib.id] = [toJSON(subValue) for each</span>
<a href="#l30.1492"></a><span id="l30.1492" class="difflineplus">+                           ([, subValue] in Iterator(value))] ;</span>
<a href="#l30.1493"></a><span id="l30.1493" class="difflineplus">+        }</span>
<a href="#l30.1494"></a><span id="l30.1494" class="difflineplus">+        else</span>
<a href="#l30.1495"></a><span id="l30.1495" class="difflineplus">+          jsonDict[attrib.id] = value;</span>
<a href="#l30.1496"></a><span id="l30.1496" class="difflineplus">+      }</span>
<a href="#l30.1497"></a><span id="l30.1497" class="difflineplus">+      </span>
<a href="#l30.1498"></a><span id="l30.1498" class="difflineplus">+      // perform a delta analysis against the old value, if we have one</span>
<a href="#l30.1499"></a><span id="l30.1499" class="difflineplus">+      let oldValue = aOldItem[key];</span>
<a href="#l30.1500"></a><span id="l30.1500" class="difflineplus">+      if (oldValue !== undefined) {</span>
<a href="#l30.1501"></a><span id="l30.1501" class="difflineplus">+        // in the singular case if they don't match, it's one add and one remove</span>
<a href="#l30.1502"></a><span id="l30.1502" class="difflineplus">+        if (attrib.singular) {</span>
<a href="#l30.1503"></a><span id="l30.1503" class="difflineplus">+          // test for identicality, failing that, see if they have explicit</span>
<a href="#l30.1504"></a><span id="l30.1504" class="difflineplus">+          //  equals support.</span>
<a href="#l30.1505"></a><span id="l30.1505" class="difflineplus">+          if ((value !== oldValue) &amp;&amp;</span>
<a href="#l30.1506"></a><span id="l30.1506" class="difflineplus">+              (!value.equals || !value.equals(oldValue))) {</span>
<a href="#l30.1507"></a><span id="l30.1507" class="difflineplus">+            this._log.debug(&quot;%% want to add1 &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes([value]));</span>
<a href="#l30.1508"></a><span id="l30.1508" class="difflineplus">+            this._log.debug(&quot;%% want to rem1 &quot; + oldValue + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes([oldValue]));</span>
<a href="#l30.1509"></a><span id="l30.1509" class="difflineplus">+            addDBAttribs.push(attribDB.convertValuesToDBAttributes([value])[0]);</span>
<a href="#l30.1510"></a><span id="l30.1510" class="difflineplus">+            removeDBAttribs.push(</span>
<a href="#l30.1511"></a><span id="l30.1511" class="difflineplus">+              attribDB.convertValuesToDBAttributes([oldValue])[0]);</span>
<a href="#l30.1512"></a><span id="l30.1512" class="difflineplus">+          }</span>
<a href="#l30.1513"></a><span id="l30.1513" class="difflineplus">+        }</span>
<a href="#l30.1514"></a><span id="l30.1514" class="difflineplus">+        // in the plural case, we have to figure the deltas accounting for</span>
<a href="#l30.1515"></a><span id="l30.1515" class="difflineplus">+        //  possible changes in ordering (which is insignificant from an</span>
<a href="#l30.1516"></a><span id="l30.1516" class="difflineplus">+        //  indexing perspective)</span>
<a href="#l30.1517"></a><span id="l30.1517" class="difflineplus">+        // some nouns may not meet === equivalence needs, so must provide a</span>
<a href="#l30.1518"></a><span id="l30.1518" class="difflineplus">+        //  custom computeDelta method to help us out</span>
<a href="#l30.1519"></a><span id="l30.1519" class="difflineplus">+        else if (objectNounDef.computeDelta) {</span>
<a href="#l30.1520"></a><span id="l30.1520" class="difflineplus">+          let [valuesAdded, valuesRemoved] = </span>
<a href="#l30.1521"></a><span id="l30.1521" class="difflineplus">+            objectNounDef.computeDelta(value, oldValue);</span>
<a href="#l30.1522"></a><span id="l30.1522" class="difflineplus">+          // convert the values to database-style attribute rows</span>
<a href="#l30.1523"></a><span id="l30.1523" class="difflineplus">+          this._log.debug(&quot;%% cdelta want to add &quot; + valuesAdded + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l30.1524"></a><span id="l30.1524" class="difflineplus">+          this._log.debug(&quot;%% cdelta want to rem &quot; + valuesRemoved + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l30.1525"></a><span id="l30.1525" class="difflineplus">+          addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l30.1526"></a><span id="l30.1526" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l30.1527"></a><span id="l30.1527" class="difflineplus">+          removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l30.1528"></a><span id="l30.1528" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l30.1529"></a><span id="l30.1529" class="difflineplus">+        }</span>
<a href="#l30.1530"></a><span id="l30.1530" class="difflineplus">+        else {</span>
<a href="#l30.1531"></a><span id="l30.1531" class="difflineplus">+          // build a map of the previous values; we will delete the values as</span>
<a href="#l30.1532"></a><span id="l30.1532" class="difflineplus">+          //  we see them so that we will know what old values are no longer</span>
<a href="#l30.1533"></a><span id="l30.1533" class="difflineplus">+          //  present in the current set of values.</span>
<a href="#l30.1534"></a><span id="l30.1534" class="difflineplus">+          let oldValueMap = {};</span>
<a href="#l30.1535"></a><span id="l30.1535" class="difflineplus">+          for each (let [, anOldValue] in Iterator(oldValue)) {</span>
<a href="#l30.1536"></a><span id="l30.1536" class="difflineplus">+this._log.debug(&quot;  old traverse: &quot; + anOldValue);</span>
<a href="#l30.1537"></a><span id="l30.1537" class="difflineplus">+            // remember, the key is just the toString'ed value, so we need to</span>
<a href="#l30.1538"></a><span id="l30.1538" class="difflineplus">+            //  store and use the actual value as the value!</span>
<a href="#l30.1539"></a><span id="l30.1539" class="difflineplus">+            oldValueMap[anOldValue] = anOldValue;</span>
<a href="#l30.1540"></a><span id="l30.1540" class="difflineplus">+          }</span>
<a href="#l30.1541"></a><span id="l30.1541" class="difflineplus">+          // traverse the current values...</span>
<a href="#l30.1542"></a><span id="l30.1542" class="difflineplus">+          let valuesAdded = [];</span>
<a href="#l30.1543"></a><span id="l30.1543" class="difflineplus">+          for each (let [, curValue] in Iterator(value)) {</span>
<a href="#l30.1544"></a><span id="l30.1544" class="difflineplus">+this._log.debug(&quot;  new traverse: &quot; + curValue);</span>
<a href="#l30.1545"></a><span id="l30.1545" class="difflineplus">+            if (curValue in oldValueMap)</span>
<a href="#l30.1546"></a><span id="l30.1546" class="difflineplus">+              delete oldValueMap[curValue];</span>
<a href="#l30.1547"></a><span id="l30.1547" class="difflineplus">+            else</span>
<a href="#l30.1548"></a><span id="l30.1548" class="difflineplus">+              valuesAdded.push(curValue);</span>
<a href="#l30.1549"></a><span id="l30.1549" class="difflineplus">+          }</span>
<a href="#l30.1550"></a><span id="l30.1550" class="difflineplus">+          // anything still on oldValueMap was removed.</span>
<a href="#l30.1551"></a><span id="l30.1551" class="difflineplus">+          let valuesRemoved = [val for each (val in oldValueMap)];</span>
<a href="#l30.1552"></a><span id="l30.1552" class="difflineplus">+          // convert the values to database-style attribute rows</span>
<a href="#l30.1553"></a><span id="l30.1553" class="difflineplus">+          this._log.debug(&quot;%% want to add &quot; + valuesAdded + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l30.1554"></a><span id="l30.1554" class="difflineplus">+          this._log.debug(&quot;%% want to rem &quot; + valuesRemoved + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l30.1555"></a><span id="l30.1555" class="difflineplus">+          addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l30.1556"></a><span id="l30.1556" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l30.1557"></a><span id="l30.1557" class="difflineplus">+          removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l30.1558"></a><span id="l30.1558" class="difflineplus">+            attribDB.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l30.1559"></a><span id="l30.1559" class="difflineplus">+        }</span>
<a href="#l30.1560"></a><span id="l30.1560" class="difflineplus">+      </span>
<a href="#l30.1561"></a><span id="l30.1561" class="difflineplus">+        // replace the old value with the new values... (the 'old' item is</span>
<a href="#l30.1562"></a><span id="l30.1562" class="difflineplus">+        //  canonical)</span>
<a href="#l30.1563"></a><span id="l30.1563" class="difflineplus">+        aOldItem[key] = value; </span>
<a href="#l30.1564"></a><span id="l30.1564" class="difflineplus">+      }</span>
<a href="#l30.1565"></a><span id="l30.1565" class="difflineplus">+      // no old value, all values are new</span>
<a href="#l30.1566"></a><span id="l30.1566" class="difflineplus">+      else {</span>
<a href="#l30.1567"></a><span id="l30.1567" class="difflineplus">+        // the 'old' item is still the canonical one; update it</span>
<a href="#l30.1568"></a><span id="l30.1568" class="difflineplus">+        if (!aIsNew)</span>
<a href="#l30.1569"></a><span id="l30.1569" class="difflineplus">+          aOldItem[key] = value;</span>
<a href="#l30.1570"></a><span id="l30.1570" class="difflineplus">+        // add the db reps on the new values</span>
<a href="#l30.1571"></a><span id="l30.1571" class="difflineplus">+        if (attrib.singular)</span>
<a href="#l30.1572"></a><span id="l30.1572" class="difflineplus">+          value = [value];</span>
<a href="#l30.1573"></a><span id="l30.1573" class="difflineplus">+        this._log.debug(&quot;%% no old, want to add &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l30.1574"></a><span id="l30.1574" class="difflineplus">+        addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l30.1575"></a><span id="l30.1575" class="difflineplus">+                                attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l30.1576"></a><span id="l30.1576" class="difflineplus">+      }</span>
<a href="#l30.1577"></a><span id="l30.1577" class="difflineplus">+    }</span>
<a href="#l30.1578"></a><span id="l30.1578" class="difflineplus">+    </span>
<a href="#l30.1579"></a><span id="l30.1579" class="difflineplus">+    // Iterate over any remaining values in old items for purge purposes.</span>
<a href="#l30.1580"></a><span id="l30.1580" class="difflineplus">+    for each (let [key, value] in Iterator(aOldItem)) {</span>
<a href="#l30.1581"></a><span id="l30.1581" class="difflineplus">+      // ignore keys that start with underscores, they are private and not</span>
<a href="#l30.1582"></a><span id="l30.1582" class="difflineplus">+      //  persisted by our attribute mechanism.  (they are directly handled by</span>
<a href="#l30.1583"></a><span id="l30.1583" class="difflineplus">+      //  the object implementation.)</span>
<a href="#l30.1584"></a><span id="l30.1584" class="difflineplus">+      if (key[0] == &quot;_&quot;)</span>
<a href="#l30.1585"></a><span id="l30.1585" class="difflineplus">+        continue;</span>
<a href="#l30.1586"></a><span id="l30.1586" class="difflineplus">+      // ignore things we saw in the new guy</span>
<a href="#l30.1587"></a><span id="l30.1587" class="difflineplus">+      if (key in aItem)</span>
<a href="#l30.1588"></a><span id="l30.1588" class="difflineplus">+        continue;</span>
<a href="#l30.1589"></a><span id="l30.1589" class="difflineplus">+      </span>
<a href="#l30.1590"></a><span id="l30.1590" class="difflineplus">+      // find the attribute definition that corresponds to this key</span>
<a href="#l30.1591"></a><span id="l30.1591" class="difflineplus">+      let attrib = attribsByBoundName[key];</span>
<a href="#l30.1592"></a><span id="l30.1592" class="difflineplus">+      // if there's no attribute, that's not good, but not horrible.</span>
<a href="#l30.1593"></a><span id="l30.1593" class="difflineplus">+      if (attrib === undefined) {</span>
<a href="#l30.1594"></a><span id="l30.1594" class="difflineplus">+        this._log.warn(&quot;old proc ignoring attrib: &quot; + key);</span>
<a href="#l30.1595"></a><span id="l30.1595" class="difflineplus">+        continue;</span>
<a href="#l30.1596"></a><span id="l30.1596" class="difflineplus">+      }</span>
<a href="#l30.1597"></a><span id="l30.1597" class="difflineplus">+      let attribDB = attrib.dbDef;</span>
<a href="#l30.1598"></a><span id="l30.1598" class="difflineplus">+      this._log.debug(&quot;%% want to remove &quot; + value + &quot; which map to &quot; + attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l30.1599"></a><span id="l30.1599" class="difflineplus">+      removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l30.1600"></a><span id="l30.1600" class="difflineplus">+                                 attribDB.convertValuesToDBAttributes(value));</span>
<a href="#l30.1601"></a><span id="l30.1601" class="difflineplus">+      // delete these from the old item, as the old item is canonical, and</span>
<a href="#l30.1602"></a><span id="l30.1602" class="difflineplus">+      //  should no longer have these values</span>
<a href="#l30.1603"></a><span id="l30.1603" class="difflineplus">+      delete aOldItem[key];</span>
<a href="#l30.1604"></a><span id="l30.1604" class="difflineplus">+    }</span>
<a href="#l30.1605"></a><span id="l30.1605" class="difflineplus">+    </span>
<a href="#l30.1606"></a><span id="l30.1606" class="difflineplus">+    aItem._jsonText = this._json.encode(jsonDict);</span>
<a href="#l30.1607"></a><span id="l30.1607" class="difflineplus">+    this._log.debug(&quot;  json text: &quot; + aItem._jsonText);</span>
<a href="#l30.1608"></a><span id="l30.1608" class="difflineplus">+    </span>
<a href="#l30.1609"></a><span id="l30.1609" class="difflineplus">+    if (aIsNew) {</span>
<a href="#l30.1610"></a><span id="l30.1610" class="difflineplus">+      this._log.debug(&quot; inserting item&quot;);</span>
<a href="#l30.1611"></a><span id="l30.1611" class="difflineplus">+      itemNounDef.objInsert.call(itemNounDef.datastore, aItem);</span>
<a href="#l30.1612"></a><span id="l30.1612" class="difflineplus">+    }</span>
<a href="#l30.1613"></a><span id="l30.1613" class="difflineplus">+    else {</span>
<a href="#l30.1614"></a><span id="l30.1614" class="difflineplus">+      this._log.debug(&quot; updating item&quot;);</span>
<a href="#l30.1615"></a><span id="l30.1615" class="difflineplus">+      itemNounDef.objUpdate.call(itemNounDef.datastore, aItem);</span>
<a href="#l30.1616"></a><span id="l30.1616" class="difflineplus">+    }</span>
<a href="#l30.1617"></a><span id="l30.1617" class="difflineplus">+    </span>
<a href="#l30.1618"></a><span id="l30.1618" class="difflineplus">+    this._log.debug(&quot; adjusting attributes, add: &quot; + addDBAttribs + &quot; rem: &quot; +</span>
<a href="#l30.1619"></a><span id="l30.1619" class="difflineplus">+        removeDBAttribs);</span>
<a href="#l30.1620"></a><span id="l30.1620" class="difflineplus">+    itemNounDef.dbAttribAdjuster.call(itemNounDef.datastore, aItem,</span>
<a href="#l30.1621"></a><span id="l30.1621" class="difflineplus">+      addDBAttribs, removeDBAttribs);</span>
<a href="#l30.1622"></a><span id="l30.1622" class="difflineplus">+    </span>
<a href="#l30.1623"></a><span id="l30.1623" class="difflineplus">+    // Cache ramifications...</span>
<a href="#l30.1624"></a><span id="l30.1624" class="difflineplus">+    if (aDoCache === undefined || aDoCache) {</span>
<a href="#l30.1625"></a><span id="l30.1625" class="difflineplus">+      if (aIsNew)</span>
<a href="#l30.1626"></a><span id="l30.1626" class="difflineplus">+        GlodaCollectionManager.itemsAdded(aItem.NOUN_ID, [aItem]);</span>
<a href="#l30.1627"></a><span id="l30.1627" class="difflineplus">+      else</span>
<a href="#l30.1628"></a><span id="l30.1628" class="difflineplus">+        GlodaCollectionManager.itemsModified(aOldItem.NOUN_ID, [aOldItem]);</span>
<a href="#l30.1629"></a><span id="l30.1629" class="difflineplus">+    }</span>
<a href="#l30.1630"></a><span id="l30.1630" class="difflineplus">+    </span>
<a href="#l30.1631"></a><span id="l30.1631" class="difflineplus">+    this._log.debug(&quot; done grokking.&quot;);</span>
<a href="#l30.1632"></a><span id="l30.1632" class="difflineplus">+    </span>
<a href="#l30.1633"></a><span id="l30.1633" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l30.1634"></a><span id="l30.1634" class="difflineplus">+  },</span>
<a href="#l30.1635"></a><span id="l30.1635" class="difflineplus">+};</span>
<a href="#l30.1636"></a><span id="l30.1636" class="difflineplus">+</span>
<a href="#l30.1637"></a><span id="l30.1637" class="difflineplus">+/* and initialize the Gloda object/NS before we return... */</span>
<a href="#l30.1638"></a><span id="l30.1638" class="difflineplus">+try {</span>
<a href="#l30.1639"></a><span id="l30.1639" class="difflineplus">+  Gloda._init();</span>
<a href="#l30.1640"></a><span id="l30.1640" class="difflineplus">+}</span>
<a href="#l30.1641"></a><span id="l30.1641" class="difflineplus">+catch (ex) {</span>
<a href="#l30.1642"></a><span id="l30.1642" class="difflineplus">+  Gloda._log.debug(&quot;Exception during Gloda init (&quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l30.1643"></a><span id="l30.1643" class="difflineplus">+                   ex.lineNumber + &quot;): &quot; + ex);</span>
<a href="#l30.1644"></a><span id="l30.1644" class="difflineplus">+};</span>
<a href="#l30.1645"></a><span id="l30.1645" class="difflineplus">+/* but don't forget that we effectively depend on everybody.js too, and</span>
<a href="#l30.1646"></a><span id="l30.1646" class="difflineplus">+   currently on our importer to be importing that if they need us fully armed</span>
<a href="#l30.1647"></a><span id="l30.1647" class="difflineplus">+   and operational. */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1">new file mode 100644</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineminus">--- /dev/null</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_ab.js</span>
<a href="#l31.4"></a><span id="l31.4" class="difflineat">@@ -0,0 +1,276 @@</span>
<a href="#l31.5"></a><span id="l31.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l31.6"></a><span id="l31.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l31.7"></a><span id="l31.7" class="difflineplus">+ *</span>
<a href="#l31.8"></a><span id="l31.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l31.9"></a><span id="l31.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l31.10"></a><span id="l31.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l31.11"></a><span id="l31.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l31.12"></a><span id="l31.12" class="difflineplus">+ * </span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l31.14"></a><span id="l31.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l31.15"></a><span id="l31.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l31.16"></a><span id="l31.16" class="difflineplus">+ * License.</span>
<a href="#l31.17"></a><span id="l31.17" class="difflineplus">+ *</span>
<a href="#l31.18"></a><span id="l31.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l31.19"></a><span id="l31.19" class="difflineplus">+ *</span>
<a href="#l31.20"></a><span id="l31.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l31.21"></a><span id="l31.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l31.22"></a><span id="l31.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l31.23"></a><span id="l31.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l31.24"></a><span id="l31.24" class="difflineplus">+ *</span>
<a href="#l31.25"></a><span id="l31.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l31.26"></a><span id="l31.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l31.27"></a><span id="l31.27" class="difflineplus">+ *</span>
<a href="#l31.28"></a><span id="l31.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l31.29"></a><span id="l31.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l31.30"></a><span id="l31.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l31.31"></a><span id="l31.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l31.32"></a><span id="l31.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l31.33"></a><span id="l31.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l31.34"></a><span id="l31.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l31.35"></a><span id="l31.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l31.36"></a><span id="l31.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l31.37"></a><span id="l31.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l31.38"></a><span id="l31.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l31.39"></a><span id="l31.39" class="difflineplus">+ * </span>
<a href="#l31.40"></a><span id="l31.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l31.41"></a><span id="l31.41" class="difflineplus">+</span>
<a href="#l31.42"></a><span id="l31.42" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaABIndexer', 'GlodaABAttrs'];</span>
<a href="#l31.43"></a><span id="l31.43" class="difflineplus">+</span>
<a href="#l31.44"></a><span id="l31.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l31.45"></a><span id="l31.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l31.46"></a><span id="l31.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l31.47"></a><span id="l31.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l31.48"></a><span id="l31.48" class="difflineplus">+</span>
<a href="#l31.49"></a><span id="l31.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l31.50"></a><span id="l31.50" class="difflineplus">+</span>
<a href="#l31.51"></a><span id="l31.51" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l31.52"></a><span id="l31.52" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l31.53"></a><span id="l31.53" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l31.54"></a><span id="l31.54" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l31.55"></a><span id="l31.55" class="difflineplus">+</span>
<a href="#l31.56"></a><span id="l31.56" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/indexer.js&quot;);</span>
<a href="#l31.57"></a><span id="l31.57" class="difflineplus">+</span>
<a href="#l31.58"></a><span id="l31.58" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/noun_freetag.js&quot;);</span>
<a href="#l31.59"></a><span id="l31.59" class="difflineplus">+</span>
<a href="#l31.60"></a><span id="l31.60" class="difflineplus">+</span>
<a href="#l31.61"></a><span id="l31.61" class="difflineplus">+var GlodaABIndexer = {</span>
<a href="#l31.62"></a><span id="l31.62" class="difflineplus">+  _log: null,</span>
<a href="#l31.63"></a><span id="l31.63" class="difflineplus">+</span>
<a href="#l31.64"></a><span id="l31.64" class="difflineplus">+  name: &quot;ab_indexer&quot;,</span>
<a href="#l31.65"></a><span id="l31.65" class="difflineplus">+  enable: function() {</span>
<a href="#l31.66"></a><span id="l31.66" class="difflineplus">+    if (this._log == null)</span>
<a href="#l31.67"></a><span id="l31.67" class="difflineplus">+      this._log =  Log4Moz.Service.getLogger(&quot;gloda.ab_indexer&quot;);</span>
<a href="#l31.68"></a><span id="l31.68" class="difflineplus">+  </span>
<a href="#l31.69"></a><span id="l31.69" class="difflineplus">+    let abManager = Cc[&quot;@mozilla.org/abmanager;1&quot;].getService(Ci.nsIAbManager);</span>
<a href="#l31.70"></a><span id="l31.70" class="difflineplus">+    abManager.addAddressBookListener(this, Ci.nsIAbListener.itemChanged);</span>
<a href="#l31.71"></a><span id="l31.71" class="difflineplus">+  },</span>
<a href="#l31.72"></a><span id="l31.72" class="difflineplus">+  </span>
<a href="#l31.73"></a><span id="l31.73" class="difflineplus">+  disable: function() {</span>
<a href="#l31.74"></a><span id="l31.74" class="difflineplus">+    let abManager = Cc[&quot;@mozilla.org/abmanager;1&quot;].getService(Ci.nsIAbManager);</span>
<a href="#l31.75"></a><span id="l31.75" class="difflineplus">+    abManager.removeAddressBookListener(this);</span>
<a href="#l31.76"></a><span id="l31.76" class="difflineplus">+  },</span>
<a href="#l31.77"></a><span id="l31.77" class="difflineplus">+</span>
<a href="#l31.78"></a><span id="l31.78" class="difflineplus">+  get workers() {</span>
<a href="#l31.79"></a><span id="l31.79" class="difflineplus">+    return [[&quot;ab-card&quot;, this._worker_index_card]];</span>
<a href="#l31.80"></a><span id="l31.80" class="difflineplus">+  },</span>
<a href="#l31.81"></a><span id="l31.81" class="difflineplus">+  </span>
<a href="#l31.82"></a><span id="l31.82" class="difflineplus">+  _worker_index_card: function(aJob, aCallbackHandle) {</span>
<a href="#l31.83"></a><span id="l31.83" class="difflineplus">+    let card = aJob.id;</span>
<a href="#l31.84"></a><span id="l31.84" class="difflineplus">+    // load the identity</span>
<a href="#l31.85"></a><span id="l31.85" class="difflineplus">+    let query = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l31.86"></a><span id="l31.86" class="difflineplus">+    query.kind(&quot;email&quot;);</span>
<a href="#l31.87"></a><span id="l31.87" class="difflineplus">+    query.value(card.primaryEmail);</span>
<a href="#l31.88"></a><span id="l31.88" class="difflineplus">+    let identityCollection = query.getCollection(aCallbackHandle);</span>
<a href="#l31.89"></a><span id="l31.89" class="difflineplus">+    yield Gloda.kWorkAsync;</span>
<a href="#l31.90"></a><span id="l31.90" class="difflineplus">+    </span>
<a href="#l31.91"></a><span id="l31.91" class="difflineplus">+    if (identityCollection.items.length) {</span>
<a href="#l31.92"></a><span id="l31.92" class="difflineplus">+      let identity = identityCollection.items[0];</span>
<a href="#l31.93"></a><span id="l31.93" class="difflineplus">+</span>
<a href="#l31.94"></a><span id="l31.94" class="difflineplus">+      this._log.debug(&quot;Found identity, processing card.&quot;);</span>
<a href="#l31.95"></a><span id="l31.95" class="difflineplus">+      yield aCallbackHandle.pushAndGo(</span>
<a href="#l31.96"></a><span id="l31.96" class="difflineplus">+          Gloda.grokNounItem(identity.contact, card, false, aCallbackHandle));</span>
<a href="#l31.97"></a><span id="l31.97" class="difflineplus">+      this._log.debug(&quot;Done processing card.&quot;);</span>
<a href="#l31.98"></a><span id="l31.98" class="difflineplus">+    }</span>
<a href="#l31.99"></a><span id="l31.99" class="difflineplus">+    </span>
<a href="#l31.100"></a><span id="l31.100" class="difflineplus">+    yield GlodaIndexer.kWorkDone;</span>
<a href="#l31.101"></a><span id="l31.101" class="difflineplus">+  },</span>
<a href="#l31.102"></a><span id="l31.102" class="difflineplus">+  </span>
<a href="#l31.103"></a><span id="l31.103" class="difflineplus">+  initialSweep: function() {</span>
<a href="#l31.104"></a><span id="l31.104" class="difflineplus">+  },</span>
<a href="#l31.105"></a><span id="l31.105" class="difflineplus">+  </span>
<a href="#l31.106"></a><span id="l31.106" class="difflineplus">+  /* ------ nsIAbListener ------ */</span>
<a href="#l31.107"></a><span id="l31.107" class="difflineplus">+  onItemAdded: function ab_indexer_onItemAdded(aParentDir, aItem) {</span>
<a href="#l31.108"></a><span id="l31.108" class="difflineplus">+  },</span>
<a href="#l31.109"></a><span id="l31.109" class="difflineplus">+  onItemRemoved: function ab_indexer_onItemRemoved(aParentDir, aItem) {</span>
<a href="#l31.110"></a><span id="l31.110" class="difflineplus">+  },</span>
<a href="#l31.111"></a><span id="l31.111" class="difflineplus">+  onItemPropertyChanged: function ab_indexer_onItemPropertyChanged(aItem,</span>
<a href="#l31.112"></a><span id="l31.112" class="difflineplus">+      aProperty, aOldValue, aNewValue) {</span>
<a href="#l31.113"></a><span id="l31.113" class="difflineplus">+    if (aProperty == null &amp;&amp; aItem instanceof Ci.nsIAbCard) {</span>
<a href="#l31.114"></a><span id="l31.114" class="difflineplus">+      this._log.debug(&quot;Received Card Change Notification&quot;);</span>
<a href="#l31.115"></a><span id="l31.115" class="difflineplus">+</span>
<a href="#l31.116"></a><span id="l31.116" class="difflineplus">+      let card = aItem; // instanceof already QueryInterface'd for us.</span>
<a href="#l31.117"></a><span id="l31.117" class="difflineplus">+      let job = new IndexingJob(&quot;ab-card&quot;, 1, card);</span>
<a href="#l31.118"></a><span id="l31.118" class="difflineplus">+      GlodaIndexer.indexJob(job);</span>
<a href="#l31.119"></a><span id="l31.119" class="difflineplus">+    }</span>
<a href="#l31.120"></a><span id="l31.120" class="difflineplus">+  }</span>
<a href="#l31.121"></a><span id="l31.121" class="difflineplus">+};</span>
<a href="#l31.122"></a><span id="l31.122" class="difflineplus">+GlodaIndexer.registerIndexer(GlodaABIndexer);</span>
<a href="#l31.123"></a><span id="l31.123" class="difflineplus">+</span>
<a href="#l31.124"></a><span id="l31.124" class="difflineplus">+var GlodaABAttrs = {</span>
<a href="#l31.125"></a><span id="l31.125" class="difflineplus">+  providerName: &quot;gloda.ab_attr&quot;,</span>
<a href="#l31.126"></a><span id="l31.126" class="difflineplus">+  _log: null,</span>
<a href="#l31.127"></a><span id="l31.127" class="difflineplus">+  _strBundle: null,</span>
<a href="#l31.128"></a><span id="l31.128" class="difflineplus">+</span>
<a href="#l31.129"></a><span id="l31.129" class="difflineplus">+  init: function(aStrBundle) {</span>
<a href="#l31.130"></a><span id="l31.130" class="difflineplus">+    this._log =  Log4Moz.Service.getLogger(&quot;gloda.abattrs&quot;);</span>
<a href="#l31.131"></a><span id="l31.131" class="difflineplus">+    this._strBundle = aStrBundle;</span>
<a href="#l31.132"></a><span id="l31.132" class="difflineplus">+    </span>
<a href="#l31.133"></a><span id="l31.133" class="difflineplus">+    try {</span>
<a href="#l31.134"></a><span id="l31.134" class="difflineplus">+      this.defineAttributes();</span>
<a href="#l31.135"></a><span id="l31.135" class="difflineplus">+    }</span>
<a href="#l31.136"></a><span id="l31.136" class="difflineplus">+    catch (ex) {</span>
<a href="#l31.137"></a><span id="l31.137" class="difflineplus">+      this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l31.138"></a><span id="l31.138" class="difflineplus">+      throw ex;</span>
<a href="#l31.139"></a><span id="l31.139" class="difflineplus">+    }</span>
<a href="#l31.140"></a><span id="l31.140" class="difflineplus">+  },</span>
<a href="#l31.141"></a><span id="l31.141" class="difflineplus">+  </span>
<a href="#l31.142"></a><span id="l31.142" class="difflineplus">+  defineAttributes: function() {</span>
<a href="#l31.143"></a><span id="l31.143" class="difflineplus">+    /* ***** Contacts ***** */</span>
<a href="#l31.144"></a><span id="l31.144" class="difflineplus">+    this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l31.145"></a><span id="l31.145" class="difflineplus">+      provider: this,</span>
<a href="#l31.146"></a><span id="l31.146" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.147"></a><span id="l31.147" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l31.148"></a><span id="l31.148" class="difflineplus">+      attributeName: &quot;identities&quot;,</span>
<a href="#l31.149"></a><span id="l31.149" class="difflineplus">+      singular: false,</span>
<a href="#l31.150"></a><span id="l31.150" class="difflineplus">+      special: Gloda.kSpecialColumnChildren,</span>
<a href="#l31.151"></a><span id="l31.151" class="difflineplus">+      //specialColumnName: &quot;contactID&quot;,</span>
<a href="#l31.152"></a><span id="l31.152" class="difflineplus">+      storageAttributeName: &quot;_identities&quot;,</span>
<a href="#l31.153"></a><span id="l31.153" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l31.154"></a><span id="l31.154" class="difflineplus">+      objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l31.155"></a><span id="l31.155" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l31.156"></a><span id="l31.156" class="difflineplus">+    this._attrContactName = Gloda.defineAttribute({</span>
<a href="#l31.157"></a><span id="l31.157" class="difflineplus">+      provider: this,</span>
<a href="#l31.158"></a><span id="l31.158" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.159"></a><span id="l31.159" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l31.160"></a><span id="l31.160" class="difflineplus">+      attributeName: &quot;name&quot;,</span>
<a href="#l31.161"></a><span id="l31.161" class="difflineplus">+      singular: true,</span>
<a href="#l31.162"></a><span id="l31.162" class="difflineplus">+      special: Gloda.kSpecialString,</span>
<a href="#l31.163"></a><span id="l31.163" class="difflineplus">+      specialColumnName: &quot;name&quot;,</span>
<a href="#l31.164"></a><span id="l31.164" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l31.165"></a><span id="l31.165" class="difflineplus">+      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l31.166"></a><span id="l31.166" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l31.167"></a><span id="l31.167" class="difflineplus">+    this._attrContactPopularity = Gloda.defineAttribute({</span>
<a href="#l31.168"></a><span id="l31.168" class="difflineplus">+      provider: this,</span>
<a href="#l31.169"></a><span id="l31.169" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.170"></a><span id="l31.170" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l31.171"></a><span id="l31.171" class="difflineplus">+      attributeName: &quot;popularity&quot;,</span>
<a href="#l31.172"></a><span id="l31.172" class="difflineplus">+      singular: true,</span>
<a href="#l31.173"></a><span id="l31.173" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l31.174"></a><span id="l31.174" class="difflineplus">+      specialColumnName: &quot;popularity&quot;,</span>
<a href="#l31.175"></a><span id="l31.175" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l31.176"></a><span id="l31.176" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l31.177"></a><span id="l31.177" class="difflineplus">+      }); // not-tested</span>
<a href="#l31.178"></a><span id="l31.178" class="difflineplus">+    this._attrContactFrecency = Gloda.defineAttribute({</span>
<a href="#l31.179"></a><span id="l31.179" class="difflineplus">+      provider: this,</span>
<a href="#l31.180"></a><span id="l31.180" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.181"></a><span id="l31.181" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l31.182"></a><span id="l31.182" class="difflineplus">+      attributeName: &quot;frecency&quot;,</span>
<a href="#l31.183"></a><span id="l31.183" class="difflineplus">+      singular: true,</span>
<a href="#l31.184"></a><span id="l31.184" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l31.185"></a><span id="l31.185" class="difflineplus">+      specialColumnName: &quot;frecency&quot;,</span>
<a href="#l31.186"></a><span id="l31.186" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l31.187"></a><span id="l31.187" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l31.188"></a><span id="l31.188" class="difflineplus">+      }); // not-tested</span>
<a href="#l31.189"></a><span id="l31.189" class="difflineplus">+</span>
<a href="#l31.190"></a><span id="l31.190" class="difflineplus">+    /* ***** Identities ***** */</span>
<a href="#l31.191"></a><span id="l31.191" class="difflineplus">+    this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l31.192"></a><span id="l31.192" class="difflineplus">+      provider: this,</span>
<a href="#l31.193"></a><span id="l31.193" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.194"></a><span id="l31.194" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l31.195"></a><span id="l31.195" class="difflineplus">+      attributeName: &quot;contact&quot;,</span>
<a href="#l31.196"></a><span id="l31.196" class="difflineplus">+      singular: true,</span>
<a href="#l31.197"></a><span id="l31.197" class="difflineplus">+      special: Gloda.kSpecialColumnParent,</span>
<a href="#l31.198"></a><span id="l31.198" class="difflineplus">+      specialColumnName: &quot;contactID&quot;, // the column in the db</span>
<a href="#l31.199"></a><span id="l31.199" class="difflineplus">+      idStorageAttributeName: &quot;_contactID&quot;,</span>
<a href="#l31.200"></a><span id="l31.200" class="difflineplus">+      valueStorageAttributeName: &quot;_contact&quot;, </span>
<a href="#l31.201"></a><span id="l31.201" class="difflineplus">+      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l31.202"></a><span id="l31.202" class="difflineplus">+      objectNoun: Gloda.NOUN_CONTACT,</span>
<a href="#l31.203"></a><span id="l31.203" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l31.204"></a><span id="l31.204" class="difflineplus">+    this._attrIdentityKind = Gloda.defineAttribute({</span>
<a href="#l31.205"></a><span id="l31.205" class="difflineplus">+      provider: this,</span>
<a href="#l31.206"></a><span id="l31.206" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.207"></a><span id="l31.207" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l31.208"></a><span id="l31.208" class="difflineplus">+      attributeName: &quot;kind&quot;,</span>
<a href="#l31.209"></a><span id="l31.209" class="difflineplus">+      singular: true,</span>
<a href="#l31.210"></a><span id="l31.210" class="difflineplus">+      special: Gloda.kSpecialString,</span>
<a href="#l31.211"></a><span id="l31.211" class="difflineplus">+      specialColumnName: &quot;kind&quot;,</span>
<a href="#l31.212"></a><span id="l31.212" class="difflineplus">+      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l31.213"></a><span id="l31.213" class="difflineplus">+      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l31.214"></a><span id="l31.214" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l31.215"></a><span id="l31.215" class="difflineplus">+    this._attrIdentityValue = Gloda.defineAttribute({</span>
<a href="#l31.216"></a><span id="l31.216" class="difflineplus">+      provider: this,</span>
<a href="#l31.217"></a><span id="l31.217" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.218"></a><span id="l31.218" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l31.219"></a><span id="l31.219" class="difflineplus">+      attributeName: &quot;value&quot;,</span>
<a href="#l31.220"></a><span id="l31.220" class="difflineplus">+      singular: true,</span>
<a href="#l31.221"></a><span id="l31.221" class="difflineplus">+      special: Gloda.kSpecialString,</span>
<a href="#l31.222"></a><span id="l31.222" class="difflineplus">+      specialColumnName: &quot;value&quot;,</span>
<a href="#l31.223"></a><span id="l31.223" class="difflineplus">+      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l31.224"></a><span id="l31.224" class="difflineplus">+      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l31.225"></a><span id="l31.225" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l31.226"></a><span id="l31.226" class="difflineplus">+</span>
<a href="#l31.227"></a><span id="l31.227" class="difflineplus">+    /* ***** Contact Meta ***** */</span>
<a href="#l31.228"></a><span id="l31.228" class="difflineplus">+    // Freeform tags; not explicit like thunderbird's fundamental tags.</span>
<a href="#l31.229"></a><span id="l31.229" class="difflineplus">+    //  we differentiate for now because of fundamental implementation</span>
<a href="#l31.230"></a><span id="l31.230" class="difflineplus">+    //  differences.</span>
<a href="#l31.231"></a><span id="l31.231" class="difflineplus">+    this._attrFreeTag = Gloda.defineAttribute({</span>
<a href="#l31.232"></a><span id="l31.232" class="difflineplus">+                        provider: this,</span>
<a href="#l31.233"></a><span id="l31.233" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l31.234"></a><span id="l31.234" class="difflineplus">+                        attributeType: Gloda.kAttrExplicit,</span>
<a href="#l31.235"></a><span id="l31.235" class="difflineplus">+                        attributeName: &quot;freetag&quot;,</span>
<a href="#l31.236"></a><span id="l31.236" class="difflineplus">+                        bind: true,</span>
<a href="#l31.237"></a><span id="l31.237" class="difflineplus">+                        bindName: &quot;freeTags&quot;,</span>
<a href="#l31.238"></a><span id="l31.238" class="difflineplus">+                        singular: false,</span>
<a href="#l31.239"></a><span id="l31.239" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l31.240"></a><span id="l31.240" class="difflineplus">+                        objectNoun: Gloda.lookupNoun(&quot;freetag&quot;),</span>
<a href="#l31.241"></a><span id="l31.241" class="difflineplus">+                        parameterNoun: null,</span>
<a href="#l31.242"></a><span id="l31.242" class="difflineplus">+                        }); // not-tested</span>
<a href="#l31.243"></a><span id="l31.243" class="difflineplus">+    // we need to find any existing bound freetag attributes, and use them to</span>
<a href="#l31.244"></a><span id="l31.244" class="difflineplus">+    //  populate to FreeTagNoun's understanding</span>
<a href="#l31.245"></a><span id="l31.245" class="difflineplus">+    for (let freeTagName in this._attrFreeTag.parameterBindings) {</span>
<a href="#l31.246"></a><span id="l31.246" class="difflineplus">+      this._log.debug(&quot;Telling FreeTagNoun about: &quot; + freeTagName);</span>
<a href="#l31.247"></a><span id="l31.247" class="difflineplus">+      FreeTagNoun.getFreeTag(freeTagName);</span>
<a href="#l31.248"></a><span id="l31.248" class="difflineplus">+    }</span>
<a href="#l31.249"></a><span id="l31.249" class="difflineplus">+  },</span>
<a href="#l31.250"></a><span id="l31.250" class="difflineplus">+  </span>
<a href="#l31.251"></a><span id="l31.251" class="difflineplus">+  process: function(aContact, aCard, aIsNew, aCallbackHandle) {</span>
<a href="#l31.252"></a><span id="l31.252" class="difflineplus">+    if (aContact.NOUN_ID != Gloda.NOUN_CONTACT) {</span>
<a href="#l31.253"></a><span id="l31.253" class="difflineplus">+      this._log.warning(&quot;Somehow got a non-contact: &quot; + aContact);</span>
<a href="#l31.254"></a><span id="l31.254" class="difflineplus">+      return; // this will produce an exception; we like.</span>
<a href="#l31.255"></a><span id="l31.255" class="difflineplus">+    }</span>
<a href="#l31.256"></a><span id="l31.256" class="difflineplus">+    </span>
<a href="#l31.257"></a><span id="l31.257" class="difflineplus">+    // update the name</span>
<a href="#l31.258"></a><span id="l31.258" class="difflineplus">+    if (aCard.displayName &amp;&amp; aCard.displayName != aContact.name)</span>
<a href="#l31.259"></a><span id="l31.259" class="difflineplus">+      aContact.name = aCard.displayName;</span>
<a href="#l31.260"></a><span id="l31.260" class="difflineplus">+  </span>
<a href="#l31.261"></a><span id="l31.261" class="difflineplus">+    aContact.freeTags = [];</span>
<a href="#l31.262"></a><span id="l31.262" class="difflineplus">+    </span>
<a href="#l31.263"></a><span id="l31.263" class="difflineplus">+    let tags = null;</span>
<a href="#l31.264"></a><span id="l31.264" class="difflineplus">+    try {</span>
<a href="#l31.265"></a><span id="l31.265" class="difflineplus">+      tags = aCard.getProperty(&quot;Categories&quot;, null);</span>
<a href="#l31.266"></a><span id="l31.266" class="difflineplus">+    } catch (ex) {</span>
<a href="#l31.267"></a><span id="l31.267" class="difflineplus">+      this._log.error(&quot;Problem accessing property: &quot; + ex);</span>
<a href="#l31.268"></a><span id="l31.268" class="difflineplus">+    }</span>
<a href="#l31.269"></a><span id="l31.269" class="difflineplus">+    if (tags) {</span>
<a href="#l31.270"></a><span id="l31.270" class="difflineplus">+      for each (let [iTagName, tagName] in Iterator(tags.split(&quot;,&quot;))) {</span>
<a href="#l31.271"></a><span id="l31.271" class="difflineplus">+        tagName = tagName.trim();</span>
<a href="#l31.272"></a><span id="l31.272" class="difflineplus">+        if (tagName) {</span>
<a href="#l31.273"></a><span id="l31.273" class="difflineplus">+          aContact.freeTags.push(FreeTagNoun.getFreeTag(tagName));</span>
<a href="#l31.274"></a><span id="l31.274" class="difflineplus">+        }</span>
<a href="#l31.275"></a><span id="l31.275" class="difflineplus">+      }</span>
<a href="#l31.276"></a><span id="l31.276" class="difflineplus">+    }</span>
<a href="#l31.277"></a><span id="l31.277" class="difflineplus">+    </span>
<a href="#l31.278"></a><span id="l31.278" class="difflineplus">+    yield Gloda.kWorkDone;</span>
<a href="#l31.279"></a><span id="l31.279" class="difflineplus">+  }</span>
<a href="#l31.280"></a><span id="l31.280" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1">new file mode 100644</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineminus">--- /dev/null</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/indexer.js</span>
<a href="#l32.4"></a><span id="l32.4" class="difflineat">@@ -0,0 +1,2323 @@</span>
<a href="#l32.5"></a><span id="l32.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l32.6"></a><span id="l32.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l32.7"></a><span id="l32.7" class="difflineplus">+ *</span>
<a href="#l32.8"></a><span id="l32.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l32.9"></a><span id="l32.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l32.10"></a><span id="l32.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l32.11"></a><span id="l32.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineplus">+ * </span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l32.14"></a><span id="l32.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l32.15"></a><span id="l32.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l32.16"></a><span id="l32.16" class="difflineplus">+ * License.</span>
<a href="#l32.17"></a><span id="l32.17" class="difflineplus">+ *</span>
<a href="#l32.18"></a><span id="l32.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l32.19"></a><span id="l32.19" class="difflineplus">+ *</span>
<a href="#l32.20"></a><span id="l32.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l32.21"></a><span id="l32.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l32.22"></a><span id="l32.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l32.23"></a><span id="l32.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l32.24"></a><span id="l32.24" class="difflineplus">+ *</span>
<a href="#l32.25"></a><span id="l32.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l32.26"></a><span id="l32.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l32.27"></a><span id="l32.27" class="difflineplus">+ *</span>
<a href="#l32.28"></a><span id="l32.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l32.29"></a><span id="l32.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l32.30"></a><span id="l32.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l32.31"></a><span id="l32.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l32.32"></a><span id="l32.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l32.33"></a><span id="l32.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l32.34"></a><span id="l32.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l32.35"></a><span id="l32.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l32.36"></a><span id="l32.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l32.37"></a><span id="l32.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l32.38"></a><span id="l32.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l32.39"></a><span id="l32.39" class="difflineplus">+ * </span>
<a href="#l32.40"></a><span id="l32.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l32.41"></a><span id="l32.41" class="difflineplus">+</span>
<a href="#l32.42"></a><span id="l32.42" class="difflineplus">+/*</span>
<a href="#l32.43"></a><span id="l32.43" class="difflineplus">+ * This file currently contains a fairly general implementation of asynchronous</span>
<a href="#l32.44"></a><span id="l32.44" class="difflineplus">+ *  indexing with a very explicit message indexing implementation.  As gloda</span>
<a href="#l32.45"></a><span id="l32.45" class="difflineplus">+ *  will eventually want to index more than just messages, the message-specific</span>
<a href="#l32.46"></a><span id="l32.46" class="difflineplus">+ *  things should ideally lose their special hold on this file.  This will</span>
<a href="#l32.47"></a><span id="l32.47" class="difflineplus">+ *  benefit readability/size as well.</span>
<a href="#l32.48"></a><span id="l32.48" class="difflineplus">+ */</span>
<a href="#l32.49"></a><span id="l32.49" class="difflineplus">+</span>
<a href="#l32.50"></a><span id="l32.50" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaIndexer', 'IndexingJob'];</span>
<a href="#l32.51"></a><span id="l32.51" class="difflineplus">+</span>
<a href="#l32.52"></a><span id="l32.52" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l32.53"></a><span id="l32.53" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l32.54"></a><span id="l32.54" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l32.55"></a><span id="l32.55" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l32.56"></a><span id="l32.56" class="difflineplus">+</span>
<a href="#l32.57"></a><span id="l32.57" class="difflineplus">+Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l32.58"></a><span id="l32.58" class="difflineplus">+</span>
<a href="#l32.59"></a><span id="l32.59" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l32.60"></a><span id="l32.60" class="difflineplus">+</span>
<a href="#l32.61"></a><span id="l32.61" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l32.62"></a><span id="l32.62" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l32.63"></a><span id="l32.63" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l32.64"></a><span id="l32.64" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l32.65"></a><span id="l32.65" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/connotent.js&quot;);</span>
<a href="#l32.66"></a><span id="l32.66" class="difflineplus">+</span>
<a href="#l32.67"></a><span id="l32.67" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/mimemsg.js&quot;);</span>
<a href="#l32.68"></a><span id="l32.68" class="difflineplus">+</span>
<a href="#l32.69"></a><span id="l32.69" class="difflineplus">+// for list comprehension fun</span>
<a href="#l32.70"></a><span id="l32.70" class="difflineplus">+function range(begin, end) {</span>
<a href="#l32.71"></a><span id="l32.71" class="difflineplus">+  for (let i = begin; i &lt; end; ++i) {</span>
<a href="#l32.72"></a><span id="l32.72" class="difflineplus">+    yield i;</span>
<a href="#l32.73"></a><span id="l32.73" class="difflineplus">+  }</span>
<a href="#l32.74"></a><span id="l32.74" class="difflineplus">+}</span>
<a href="#l32.75"></a><span id="l32.75" class="difflineplus">+</span>
<a href="#l32.76"></a><span id="l32.76" class="difflineplus">+const GFI = Log4Moz.Service.getLogger(&quot;gloda.fixiterator&quot;);</span>
<a href="#l32.77"></a><span id="l32.77" class="difflineplus">+</span>
<a href="#l32.78"></a><span id="l32.78" class="difflineplus">+</span>
<a href="#l32.79"></a><span id="l32.79" class="difflineplus">+// FROM STEEL (a la Joey Minta/jminta)</span>
<a href="#l32.80"></a><span id="l32.80" class="difflineplus">+// (and to go away when STEEL is checked in, although we may also want to</span>
<a href="#l32.81"></a><span id="l32.81" class="difflineplus">+//  consider just specializing the code in the few places this method is used.)</span>
<a href="#l32.82"></a><span id="l32.82" class="difflineplus">+/**</span>
<a href="#l32.83"></a><span id="l32.83" class="difflineplus">+ * This function will take a variety of xpcom iterators designed for c++ and turn</span>
<a href="#l32.84"></a><span id="l32.84" class="difflineplus">+ * them into a nice JavaScript style object that can be iterated using for...in</span>
<a href="#l32.85"></a><span id="l32.85" class="difflineplus">+ *</span>
<a href="#l32.86"></a><span id="l32.86" class="difflineplus">+ * Currently, we support the following types of xpcom iterators:</span>
<a href="#l32.87"></a><span id="l32.87" class="difflineplus">+ *   nsISupportsArray</span>
<a href="#l32.88"></a><span id="l32.88" class="difflineplus">+ *   nsIEnumerator</span>
<a href="#l32.89"></a><span id="l32.89" class="difflineplus">+ *   nsISimpleEnumerator</span>
<a href="#l32.90"></a><span id="l32.90" class="difflineplus">+ *</span>
<a href="#l32.91"></a><span id="l32.91" class="difflineplus">+ *   @param aEnum  the enumerator to convert</span>
<a href="#l32.92"></a><span id="l32.92" class="difflineplus">+ *   @param aIface (optional) an interface to QI each object to prior to returning</span>
<a href="#l32.93"></a><span id="l32.93" class="difflineplus">+ *</span>
<a href="#l32.94"></a><span id="l32.94" class="difflineplus">+ *   @note This does *not* return an Array object.  It returns an object that can</span>
<a href="#l32.95"></a><span id="l32.95" class="difflineplus">+ *         be use in for...in contexts only.  To create such an array, use</span>
<a href="#l32.96"></a><span id="l32.96" class="difflineplus">+ *         var array = [a for (a in fixIterator(xpcomEnumerator))];</span>
<a href="#l32.97"></a><span id="l32.97" class="difflineplus">+ */</span>
<a href="#l32.98"></a><span id="l32.98" class="difflineplus">+function fixIterator(aEnum, aIface) {</span>
<a href="#l32.99"></a><span id="l32.99" class="difflineplus">+  let face = aIface || Ci.nsISupports;</span>
<a href="#l32.100"></a><span id="l32.100" class="difflineplus">+  // Try to QI our object to each of the known iterator types.  If the QI does</span>
<a href="#l32.101"></a><span id="l32.101" class="difflineplus">+  // not throw, assign our iteration function</span>
<a href="#l32.102"></a><span id="l32.102" class="difflineplus">+  try {</span>
<a href="#l32.103"></a><span id="l32.103" class="difflineplus">+    aEnum.QueryInterface(Ci.nsISupportsArray);</span>
<a href="#l32.104"></a><span id="l32.104" class="difflineplus">+    let iter = function() {</span>
<a href="#l32.105"></a><span id="l32.105" class="difflineplus">+      let count = aEnum.Count();</span>
<a href="#l32.106"></a><span id="l32.106" class="difflineplus">+      for (let i = 0; i &lt; count; i++)</span>
<a href="#l32.107"></a><span id="l32.107" class="difflineplus">+        yield aEnum.GetElementAt(i).QueryInterface(face);</span>
<a href="#l32.108"></a><span id="l32.108" class="difflineplus">+    }</span>
<a href="#l32.109"></a><span id="l32.109" class="difflineplus">+    return { __iterator__: iter };</span>
<a href="#l32.110"></a><span id="l32.110" class="difflineplus">+  } catch(ex) {}</span>
<a href="#l32.111"></a><span id="l32.111" class="difflineplus">+  </span>
<a href="#l32.112"></a><span id="l32.112" class="difflineplus">+  // Now try nsIEnumerator</span>
<a href="#l32.113"></a><span id="l32.113" class="difflineplus">+  try {</span>
<a href="#l32.114"></a><span id="l32.114" class="difflineplus">+    aEnum.QueryInterface(Ci.nsIEnumerator);</span>
<a href="#l32.115"></a><span id="l32.115" class="difflineplus">+    let done = false;</span>
<a href="#l32.116"></a><span id="l32.116" class="difflineplus">+    let iter = function() {</span>
<a href="#l32.117"></a><span id="l32.117" class="difflineplus">+      while (!done) {</span>
<a href="#l32.118"></a><span id="l32.118" class="difflineplus">+        try {</span>
<a href="#l32.119"></a><span id="l32.119" class="difflineplus">+          //rets.push(aEnum.currentItem().QueryInterface(face));</span>
<a href="#l32.120"></a><span id="l32.120" class="difflineplus">+          yield aEnum.currentItem().QueryInterface(face);</span>
<a href="#l32.121"></a><span id="l32.121" class="difflineplus">+          aEnum.next();</span>
<a href="#l32.122"></a><span id="l32.122" class="difflineplus">+        } catch(ex) {</span>
<a href="#l32.123"></a><span id="l32.123" class="difflineplus">+          done = true;</span>
<a href="#l32.124"></a><span id="l32.124" class="difflineplus">+          GFI.error(face + &quot; =&gt; &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex)</span>
<a href="#l32.125"></a><span id="l32.125" class="difflineplus">+        }</span>
<a href="#l32.126"></a><span id="l32.126" class="difflineplus">+      }</span>
<a href="#l32.127"></a><span id="l32.127" class="difflineplus">+    };</span>
<a href="#l32.128"></a><span id="l32.128" class="difflineplus">+</span>
<a href="#l32.129"></a><span id="l32.129" class="difflineplus">+    return { __iterator__: iter };</span>
<a href="#l32.130"></a><span id="l32.130" class="difflineplus">+  } catch(ex) {}</span>
<a href="#l32.131"></a><span id="l32.131" class="difflineplus">+  </span>
<a href="#l32.132"></a><span id="l32.132" class="difflineplus">+  // how about nsISimpleEnumerator? this one is nice and simple</span>
<a href="#l32.133"></a><span id="l32.133" class="difflineplus">+  try {</span>
<a href="#l32.134"></a><span id="l32.134" class="difflineplus">+    aEnum.QueryInterface(Ci.nsISimpleEnumerator);</span>
<a href="#l32.135"></a><span id="l32.135" class="difflineplus">+    let iter = function () {</span>
<a href="#l32.136"></a><span id="l32.136" class="difflineplus">+      while (aEnum.hasMoreElements())</span>
<a href="#l32.137"></a><span id="l32.137" class="difflineplus">+        yield aEnum.getNext().QueryInterface(face);</span>
<a href="#l32.138"></a><span id="l32.138" class="difflineplus">+    }</span>
<a href="#l32.139"></a><span id="l32.139" class="difflineplus">+    return { __iterator__: iter };</span>
<a href="#l32.140"></a><span id="l32.140" class="difflineplus">+  } catch(ex) {}</span>
<a href="#l32.141"></a><span id="l32.141" class="difflineplus">+}</span>
<a href="#l32.142"></a><span id="l32.142" class="difflineplus">+</span>
<a href="#l32.143"></a><span id="l32.143" class="difflineplus">+function MakeCleanMsgHdrCallback(aMsgHdr, aGlodaMessageID) {</span>
<a href="#l32.144"></a><span id="l32.144" class="difflineplus">+  return function() {</span>
<a href="#l32.145"></a><span id="l32.145" class="difflineplus">+    // Mark this message as indexed</span>
<a href="#l32.146"></a><span id="l32.146" class="difflineplus">+    aMsgHdr.setUint32Property(GlodaIndexer.GLODA_MESSAGE_ID_PROPERTY,</span>
<a href="#l32.147"></a><span id="l32.147" class="difflineplus">+                              aGlodaMessageID);</span>
<a href="#l32.148"></a><span id="l32.148" class="difflineplus">+    // If there is a gloda-dirty flag on there, clear it by writing a 0.  (But</span>
<a href="#l32.149"></a><span id="l32.149" class="difflineplus">+    //  don't do this if we didn't have a dirty flag on there in the first</span>
<a href="#l32.150"></a><span id="l32.150" class="difflineplus">+    //  case.)  It sounds like we would actually prefer to &quot;cut&quot; the &quot;cell&quot;,</span>
<a href="#l32.151"></a><span id="l32.151" class="difflineplus">+    //  but I don't see any in-domain means of doing that.</span>
<a href="#l32.152"></a><span id="l32.152" class="difflineplus">+    try {</span>
<a href="#l32.153"></a><span id="l32.153" class="difflineplus">+      let isDirty = aMsgHdr.getUint32Property(</span>
<a href="#l32.154"></a><span id="l32.154" class="difflineplus">+        GlodaIndexer.GLODA_DIRTY_PROPERTY);</span>
<a href="#l32.155"></a><span id="l32.155" class="difflineplus">+      if (isDirty)</span>
<a href="#l32.156"></a><span id="l32.156" class="difflineplus">+        aMsgHdr.setUint32Property(GlodaIndexer.GLODA_DIRTY_PROPERTY, 0);</span>
<a href="#l32.157"></a><span id="l32.157" class="difflineplus">+    }</span>
<a href="#l32.158"></a><span id="l32.158" class="difflineplus">+    catch (ex) {}</span>
<a href="#l32.159"></a><span id="l32.159" class="difflineplus">+  };</span>
<a href="#l32.160"></a><span id="l32.160" class="difflineplus">+}</span>
<a href="#l32.161"></a><span id="l32.161" class="difflineplus">+</span>
<a href="#l32.162"></a><span id="l32.162" class="difflineplus">+const MSG_FLAG_OFFLINE = 0x80;</span>
<a href="#l32.163"></a><span id="l32.163" class="difflineplus">+const MSG_FLAG_EXPUNGED = 0x08;</span>
<a href="#l32.164"></a><span id="l32.164" class="difflineplus">+</span>
<a href="#l32.165"></a><span id="l32.165" class="difflineplus">+/**</span>
<a href="#l32.166"></a><span id="l32.166" class="difflineplus">+ * @class Capture the indexing batch concept explicitly.</span>
<a href="#l32.167"></a><span id="l32.167" class="difflineplus">+ *</span>
<a href="#l32.168"></a><span id="l32.168" class="difflineplus">+ * @param aJobType The type of thing we are indexing.  Current choices are:</span>
<a href="#l32.169"></a><span id="l32.169" class="difflineplus">+ *   &quot;folder&quot; and &quot;message&quot;.  Previous choices included &quot;account&quot;.  The indexer</span>
<a href="#l32.170"></a><span id="l32.170" class="difflineplus">+ *   currently knows too much about these; they should be de-coupled.</span>
<a href="#l32.171"></a><span id="l32.171" class="difflineplus">+ * @param aDeltaType -1 for deletion, 0 for move, 1 for addition/new.</span>
<a href="#l32.172"></a><span id="l32.172" class="difflineplus">+ * @param aID Specific to the job type, but for now only used to hold folder</span>
<a href="#l32.173"></a><span id="l32.173" class="difflineplus">+ *     IDs.</span>
<a href="#l32.174"></a><span id="l32.174" class="difflineplus">+ *</span>
<a href="#l32.175"></a><span id="l32.175" class="difflineplus">+ * @ivar items The list of items to process during this job/batch.  (For</span>
<a href="#l32.176"></a><span id="l32.176" class="difflineplus">+ *     example, if this is a &quot;messages&quot; job, this would be the list of messages</span>
<a href="#l32.177"></a><span id="l32.177" class="difflineplus">+ *     to process, although the specific representation is determined by the</span>
<a href="#l32.178"></a><span id="l32.178" class="difflineplus">+ *     job.)  The list will only be mutated through the addition of extra items.</span>
<a href="#l32.179"></a><span id="l32.179" class="difflineplus">+ * @ivar offset The current offset into the 'items' list (if used), updated as</span>
<a href="#l32.180"></a><span id="l32.180" class="difflineplus">+ *     processing occurs.  If 'items' is not used, the processing code can also</span>
<a href="#l32.181"></a><span id="l32.181" class="difflineplus">+ *     update this in a similar fashion.  This is used by the status</span>
<a href="#l32.182"></a><span id="l32.182" class="difflineplus">+ *     notification code in conjunction with goal.</span>
<a href="#l32.183"></a><span id="l32.183" class="difflineplus">+ * @ivar goal The total number of items to index/actions to perform in this job.</span>
<a href="#l32.184"></a><span id="l32.184" class="difflineplus">+ *     This number may increase during the life of the job, but should not</span>
<a href="#l32.185"></a><span id="l32.185" class="difflineplus">+ *     decrease.  This is used by the status notification code in conjunction</span>
<a href="#l32.186"></a><span id="l32.186" class="difflineplus">+ *     with the goal.</span>
<a href="#l32.187"></a><span id="l32.187" class="difflineplus">+ *</span>
<a href="#l32.188"></a><span id="l32.188" class="difflineplus">+ * @constructor</span>
<a href="#l32.189"></a><span id="l32.189" class="difflineplus">+ */</span>
<a href="#l32.190"></a><span id="l32.190" class="difflineplus">+function IndexingJob(aJobType, aDeltaType, aID) {</span>
<a href="#l32.191"></a><span id="l32.191" class="difflineplus">+  this.jobType = aJobType;</span>
<a href="#l32.192"></a><span id="l32.192" class="difflineplus">+  this.deltaType = aDeltaType;</span>
<a href="#l32.193"></a><span id="l32.193" class="difflineplus">+  this.id = aID;</span>
<a href="#l32.194"></a><span id="l32.194" class="difflineplus">+  this.items = [];</span>
<a href="#l32.195"></a><span id="l32.195" class="difflineplus">+  this.offset = 0;</span>
<a href="#l32.196"></a><span id="l32.196" class="difflineplus">+  this.goal = null;</span>
<a href="#l32.197"></a><span id="l32.197" class="difflineplus">+}</span>
<a href="#l32.198"></a><span id="l32.198" class="difflineplus">+</span>
<a href="#l32.199"></a><span id="l32.199" class="difflineplus">+/**</span>
<a href="#l32.200"></a><span id="l32.200" class="difflineplus">+ * @namespace Core indexing logic, plus message-specific indexing logic.</span>
<a href="#l32.201"></a><span id="l32.201" class="difflineplus">+ *</span>
<a href="#l32.202"></a><span id="l32.202" class="difflineplus">+ * === Indexing Goals</span>
<a href="#l32.203"></a><span id="l32.203" class="difflineplus">+ * We have the following goals:</span>
<a href="#l32.204"></a><span id="l32.204" class="difflineplus">+ *</span>
<a href="#l32.205"></a><span id="l32.205" class="difflineplus">+ * Responsiveness</span>
<a href="#l32.206"></a><span id="l32.206" class="difflineplus">+ * - When the user wants to quit, we should be able to stop and quit in a timely</span>
<a href="#l32.207"></a><span id="l32.207" class="difflineplus">+ *   fasion.</span>
<a href="#l32.208"></a><span id="l32.208" class="difflineplus">+ * - We should not interfere with the user's thunderbird usage.</span>
<a href="#l32.209"></a><span id="l32.209" class="difflineplus">+ *</span>
<a href="#l32.210"></a><span id="l32.210" class="difflineplus">+ * Correctness</span>
<a href="#l32.211"></a><span id="l32.211" class="difflineplus">+ * - Quitting should not result in any information loss; we should (eventually)</span>
<a href="#l32.212"></a><span id="l32.212" class="difflineplus">+ *   end up at the same indexed state regardless of whether a user lets</span>
<a href="#l32.213"></a><span id="l32.213" class="difflineplus">+ *   indexing run to completion or restarts thunderbird in the middle of the</span>
<a href="#l32.214"></a><span id="l32.214" class="difflineplus">+ *   process.  (It is okay to take slightly longer in the latter case.)</span>
<a href="#l32.215"></a><span id="l32.215" class="difflineplus">+ * </span>
<a href="#l32.216"></a><span id="l32.216" class="difflineplus">+ * Worst Case Scenario Avoidance</span>
<a href="#l32.217"></a><span id="l32.217" class="difflineplus">+ * - We should try to be O(1) memory-wise regardless of what notifications</span>
<a href="#l32.218"></a><span id="l32.218" class="difflineplus">+ *   are thrown at us.</span>
<a href="#l32.219"></a><span id="l32.219" class="difflineplus">+ *</span>
<a href="#l32.220"></a><span id="l32.220" class="difflineplus">+ * === Indexing Strategy</span>
<a href="#l32.221"></a><span id="l32.221" class="difflineplus">+ * To these ends, we implement things like so:</span>
<a href="#l32.222"></a><span id="l32.222" class="difflineplus">+ *</span>
<a href="#l32.223"></a><span id="l32.223" class="difflineplus">+ * Mesage State Tracking</span>
<a href="#l32.224"></a><span id="l32.224" class="difflineplus">+ * - We store a property on all indexed headers indicating their gloda message</span>
<a href="#l32.225"></a><span id="l32.225" class="difflineplus">+ *   id.  This allows us to tell whether a message is indexed from the header,</span>
<a href="#l32.226"></a><span id="l32.226" class="difflineplus">+ *   without having to consult the SQL database.</span>
<a href="#l32.227"></a><span id="l32.227" class="difflineplus">+ * - When we receive an event that indicates that a message's meta-data has</span>
<a href="#l32.228"></a><span id="l32.228" class="difflineplus">+ *   changed and gloda needs to re-index the message, we set a property on the</span>
<a href="#l32.229"></a><span id="l32.229" class="difflineplus">+ *   header that indicates the message is dirty.</span>
<a href="#l32.230"></a><span id="l32.230" class="difflineplus">+ * - We store a property on folders that indicate that the folder's index is</span>
<a href="#l32.231"></a><span id="l32.231" class="difflineplus">+ *   up-to-date.  Absence of this property is akin to a 0=folder not up to date.</span>
<a href="#l32.232"></a><span id="l32.232" class="difflineplus">+ *   There is no particular reason for the choice of using the folder's</span>
<a href="#l32.233"></a><span id="l32.233" class="difflineplus">+ *   properties (via the folder cache implementation) over gloda's own folder</span>
<a href="#l32.234"></a><span id="l32.234" class="difflineplus">+ *   meta-data.</span>
<a href="#l32.235"></a><span id="l32.235" class="difflineplus">+ *</span>
<a href="#l32.236"></a><span id="l32.236" class="difflineplus">+ * Indexing Message Control</span>
<a href="#l32.237"></a><span id="l32.237" class="difflineplus">+ * - We index IMAP messages that are offline.  We index all local messages.</span>
<a href="#l32.238"></a><span id="l32.238" class="difflineplus">+ *   We plan to avoid indexing news messages.</span>
<a href="#l32.239"></a><span id="l32.239" class="difflineplus">+ * - We would like a way to express desires about indexing that either don't</span>
<a href="#l32.240"></a><span id="l32.240" class="difflineplus">+ *   confound offline storage with indexing, or actually allow some choice.</span>
<a href="#l32.241"></a><span id="l32.241" class="difflineplus">+ *</span>
<a href="#l32.242"></a><span id="l32.242" class="difflineplus">+ * Indexing</span>
<a href="#l32.243"></a><span id="l32.243" class="difflineplus">+ * - We process one folder at a time, walking the headers in the folder,</span>
<a href="#l32.244"></a><span id="l32.244" class="difflineplus">+ *   indexing those which should be indexed, but which have never been indexed</span>
<a href="#l32.245"></a><span id="l32.245" class="difflineplus">+ *   or are dirty.</span>
<a href="#l32.246"></a><span id="l32.246" class="difflineplus">+ * - For local folders, we use GetDatabaseWithReparse to ensure that the .msf</span>
<a href="#l32.247"></a><span id="l32.247" class="difflineplus">+ *   file exists.  For IMAP folders, we simply use GetDatabase because we know</span>
<a href="#l32.248"></a><span id="l32.248" class="difflineplus">+ *   the auto-sync logic will make sure that the folder is up-to-date and we</span>
<a href="#l32.249"></a><span id="l32.249" class="difflineplus">+ *   want to avoid creating problems through use of updateFolder.</span>
<a href="#l32.250"></a><span id="l32.250" class="difflineplus">+ *</span>
<a href="#l32.251"></a><span id="l32.251" class="difflineplus">+ * Indexing Throttling</span>
<a href="#l32.252"></a><span id="l32.252" class="difflineplus">+ * - Unless we believe everything is up-to-date, then we are always indexing.</span>
<a href="#l32.253"></a><span id="l32.253" class="difflineplus">+ *   We must be able to process messages </span>
<a href="#l32.254"></a><span id="l32.254" class="difflineplus">+ *</span>
<a href="#l32.255"></a><span id="l32.255" class="difflineplus">+ *</span>
<a href="#l32.256"></a><span id="l32.256" class="difflineplus">+ * === Message Indexing</span>
<a href="#l32.257"></a><span id="l32.257" class="difflineplus">+ * </span>
<a href="#l32.258"></a><span id="l32.258" class="difflineplus">+ * We are good at listening to nsIMsgFolderListener events.  Unfortunately,</span>
<a href="#l32.259"></a><span id="l32.259" class="difflineplus">+ *  MailNews isn't pervasively thorough at generating these yet (newsgroups</span>
<a href="#l32.260"></a><span id="l32.260" class="difflineplus">+ *  don't produce them, probably not RSS either.)  This provides us with</span>
<a href="#l32.261"></a><span id="l32.261" class="difflineplus">+ *  message addition, moves/copies, and deletion.</span>
<a href="#l32.262"></a><span id="l32.262" class="difflineplus">+ * We are not good at listening to nsIFolderListener events.  This means we fail</span>
<a href="#l32.263"></a><span id="l32.263" class="difflineplus">+ *  to update ourselves when a message is changed because of a change in tags,</span>
<a href="#l32.264"></a><span id="l32.264" class="difflineplus">+ *  read status/starred status/etc.  (Well, in fairness, events aren't actually</span>
<a href="#l32.265"></a><span id="l32.265" class="difflineplus">+ *  generated in all of those cases either, yet, but we should try.)  We need</span>
<a href="#l32.266"></a><span id="l32.266" class="difflineplus">+ *  to handle this.</span>
<a href="#l32.267"></a><span id="l32.267" class="difflineplus">+ *</span>
<a href="#l32.268"></a><span id="l32.268" class="difflineplus">+ * Currently, when we index a message, when it comes to attributes, we ignore</span>
<a href="#l32.269"></a><span id="l32.269" class="difflineplus">+ *  all that has come before us and simply blow away the attributes and apply</span>
<a href="#l32.270"></a><span id="l32.270" class="difflineplus">+ *  those provided by the attribute providers anew.  This is not particularly</span>
<a href="#l32.271"></a><span id="l32.271" class="difflineplus">+ *  efficient for anyone.  Also, I think we probably screw this up now that we</span>
<a href="#l32.272"></a><span id="l32.272" class="difflineplus">+ *  have object identity support.  Uh, so, this should be improved, but</span>
<a href="#l32.273"></a><span id="l32.273" class="difflineplus">+ *  certainly works.</span>
<a href="#l32.274"></a><span id="l32.274" class="difflineplus">+ *  </span>
<a href="#l32.275"></a><span id="l32.275" class="difflineplus">+ * We are not sufficiently good at detaching our listeners so as to avoid</span>
<a href="#l32.276"></a><span id="l32.276" class="difflineplus">+ *  crashes.  We want to hook the shutdown notification, but we don't.  We do</span>
<a href="#l32.277"></a><span id="l32.277" class="difflineplus">+ *  try to hook database-is-going-away notifications, but it's really not</span>
<a href="#l32.278"></a><span id="l32.278" class="difflineplus">+ *  tested.  We definitely do crash sometimes when you're shutting down.</span>
<a href="#l32.279"></a><span id="l32.279" class="difflineplus">+ * </span>
<a href="#l32.280"></a><span id="l32.280" class="difflineplus">+ */</span>
<a href="#l32.281"></a><span id="l32.281" class="difflineplus">+var GlodaIndexer = {</span>
<a href="#l32.282"></a><span id="l32.282" class="difflineplus">+  /**</span>
<a href="#l32.283"></a><span id="l32.283" class="difflineplus">+   * A partial attempt to generalize to support multiple databases.  Each</span>
<a href="#l32.284"></a><span id="l32.284" class="difflineplus">+   *  database would have its own datastore would have its own indexer.  But</span>
<a href="#l32.285"></a><span id="l32.285" class="difflineplus">+   *  we rather inter-mingle our use of this field with the singleton global</span>
<a href="#l32.286"></a><span id="l32.286" class="difflineplus">+   *  GlodaDatastore.</span>
<a href="#l32.287"></a><span id="l32.287" class="difflineplus">+   */</span>
<a href="#l32.288"></a><span id="l32.288" class="difflineplus">+  _datastore: GlodaDatastore,</span>
<a href="#l32.289"></a><span id="l32.289" class="difflineplus">+  _log: Log4Moz.Service.getLogger(&quot;gloda.indexer&quot;),</span>
<a href="#l32.290"></a><span id="l32.290" class="difflineplus">+  /**</span>
<a href="#l32.291"></a><span id="l32.291" class="difflineplus">+   * Our nsITimer that we use to schedule ourselves on the main thread</span>
<a href="#l32.292"></a><span id="l32.292" class="difflineplus">+   *  intermittently.  The timer always exists but may not always be active.</span>
<a href="#l32.293"></a><span id="l32.293" class="difflineplus">+   */</span>
<a href="#l32.294"></a><span id="l32.294" class="difflineplus">+  _timer: null,</span>
<a href="#l32.295"></a><span id="l32.295" class="difflineplus">+</span>
<a href="#l32.296"></a><span id="l32.296" class="difflineplus">+  _inited: false,</span>
<a href="#l32.297"></a><span id="l32.297" class="difflineplus">+  /**</span>
<a href="#l32.298"></a><span id="l32.298" class="difflineplus">+   * Initialize the indexer.</span>
<a href="#l32.299"></a><span id="l32.299" class="difflineplus">+   */</span>
<a href="#l32.300"></a><span id="l32.300" class="difflineplus">+  _init: function gloda_index_init() {</span>
<a href="#l32.301"></a><span id="l32.301" class="difflineplus">+    if (this._inited)</span>
<a href="#l32.302"></a><span id="l32.302" class="difflineplus">+      return;</span>
<a href="#l32.303"></a><span id="l32.303" class="difflineplus">+    </span>
<a href="#l32.304"></a><span id="l32.304" class="difflineplus">+    this._inited = true;</span>
<a href="#l32.305"></a><span id="l32.305" class="difflineplus">+    </span>
<a href="#l32.306"></a><span id="l32.306" class="difflineplus">+    // initialize our listeners' this pointers</span>
<a href="#l32.307"></a><span id="l32.307" class="difflineplus">+    this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l32.308"></a><span id="l32.308" class="difflineplus">+    this._msgFolderListener.indexer = this;</span>
<a href="#l32.309"></a><span id="l32.309" class="difflineplus">+    this._shutdownTask.indexer = this;</span>
<a href="#l32.310"></a><span id="l32.310" class="difflineplus">+    </span>
<a href="#l32.311"></a><span id="l32.311" class="difflineplus">+    this._callbackHandle.init();</span>
<a href="#l32.312"></a><span id="l32.312" class="difflineplus">+    </span>
<a href="#l32.313"></a><span id="l32.313" class="difflineplus">+    // create the timer that drives our intermittent indexing</span>
<a href="#l32.314"></a><span id="l32.314" class="difflineplus">+    this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l32.315"></a><span id="l32.315" class="difflineplus">+</span>
<a href="#l32.316"></a><span id="l32.316" class="difflineplus">+</span>
<a href="#l32.317"></a><span id="l32.317" class="difflineplus">+    // figure out if event-driven indexing should be enabled...</span>
<a href="#l32.318"></a><span id="l32.318" class="difflineplus">+    let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l32.319"></a><span id="l32.319" class="difflineplus">+                        getService(Ci.nsIPrefService);</span>
<a href="#l32.320"></a><span id="l32.320" class="difflineplus">+    let branch = prefService.getBranch(&quot;mailnews.database.global.indexer.&quot;);</span>
<a href="#l32.321"></a><span id="l32.321" class="difflineplus">+    let eventDrivenEnabled = false; // default</span>
<a href="#l32.322"></a><span id="l32.322" class="difflineplus">+    try {</span>
<a href="#l32.323"></a><span id="l32.323" class="difflineplus">+      eventDrivenEnabled = branch.getBoolPref(&quot;enabled&quot;);</span>
<a href="#l32.324"></a><span id="l32.324" class="difflineplus">+    } catch (ex) {</span>
<a href="#l32.325"></a><span id="l32.325" class="difflineplus">+      dump(&quot;%%% annoying exception on pref access: &quot; + ex);</span>
<a href="#l32.326"></a><span id="l32.326" class="difflineplus">+    }</span>
<a href="#l32.327"></a><span id="l32.327" class="difflineplus">+    this.enabled = eventDrivenEnabled;</span>
<a href="#l32.328"></a><span id="l32.328" class="difflineplus">+  },</span>
<a href="#l32.329"></a><span id="l32.329" class="difflineplus">+  </span>
<a href="#l32.330"></a><span id="l32.330" class="difflineplus">+  /**</span>
<a href="#l32.331"></a><span id="l32.331" class="difflineplus">+   * @returns true on full and immediate shutdown, false if we need to pend on</span>
<a href="#l32.332"></a><span id="l32.332" class="difflineplus">+   *     something asynchronous.</span>
<a href="#l32.333"></a><span id="l32.333" class="difflineplus">+   */</span>
<a href="#l32.334"></a><span id="l32.334" class="difflineplus">+  _shutdown: function gloda_index_shutdown(aUrlListener) {</span>
<a href="#l32.335"></a><span id="l32.335" class="difflineplus">+    if (!this.enabled)</span>
<a href="#l32.336"></a><span id="l32.336" class="difflineplus">+      return true;</span>
<a href="#l32.337"></a><span id="l32.337" class="difflineplus">+    </span>
<a href="#l32.338"></a><span id="l32.338" class="difflineplus">+    this._log.info(&quot;Shutting Down&quot;);</span>
<a href="#l32.339"></a><span id="l32.339" class="difflineplus">+</span>
<a href="#l32.340"></a><span id="l32.340" class="difflineplus">+    this.suppressIndexing = true;</span>
<a href="#l32.341"></a><span id="l32.341" class="difflineplus">+    this._indexerLeaveFolder(); // nop if we aren't &quot;in&quot; a folder</span>
<a href="#l32.342"></a><span id="l32.342" class="difflineplus">+    this.enabled = false;</span>
<a href="#l32.343"></a><span id="l32.343" class="difflineplus">+</span>
<a href="#l32.344"></a><span id="l32.344" class="difflineplus">+    // if the datastore can't stop immediately, it will call the provided</span>
<a href="#l32.345"></a><span id="l32.345" class="difflineplus">+    //  callback.</span>
<a href="#l32.346"></a><span id="l32.346" class="difflineplus">+    return GlodaDatastore.shutdown(function () {</span>
<a href="#l32.347"></a><span id="l32.347" class="difflineplus">+      if (aUrlListener)</span>
<a href="#l32.348"></a><span id="l32.348" class="difflineplus">+        aUrlListener.OnStopRunningUrl(null, Cr.NS_OK);</span>
<a href="#l32.349"></a><span id="l32.349" class="difflineplus">+    });</span>
<a href="#l32.350"></a><span id="l32.350" class="difflineplus">+  },</span>
<a href="#l32.351"></a><span id="l32.351" class="difflineplus">+  </span>
<a href="#l32.352"></a><span id="l32.352" class="difflineplus">+  _otherIndexers: [],</span>
<a href="#l32.353"></a><span id="l32.353" class="difflineplus">+  registerIndexer: function gloda_index_registerIndexer(aIndexer) {</span>
<a href="#l32.354"></a><span id="l32.354" class="difflineplus">+    this._log.info(&quot;Registering indexer: &quot; + aIndexer.name);</span>
<a href="#l32.355"></a><span id="l32.355" class="difflineplus">+    this._otherIndexers.push(aIndexer);</span>
<a href="#l32.356"></a><span id="l32.356" class="difflineplus">+    </span>
<a href="#l32.357"></a><span id="l32.357" class="difflineplus">+    try {</span>
<a href="#l32.358"></a><span id="l32.358" class="difflineplus">+      for each (let [iWorker, workerInfo] in Iterator(aIndexer.workers)) {</span>
<a href="#l32.359"></a><span id="l32.359" class="difflineplus">+        let [workerCode, workerFunc] = workerInfo;</span>
<a href="#l32.360"></a><span id="l32.360" class="difflineplus">+        this._otherIndexerWorkers[workerCode] = [aIndexer, workerFunc];</span>
<a href="#l32.361"></a><span id="l32.361" class="difflineplus">+      }</span>
<a href="#l32.362"></a><span id="l32.362" class="difflineplus">+    }</span>
<a href="#l32.363"></a><span id="l32.363" class="difflineplus">+    catch (ex) {</span>
<a href="#l32.364"></a><span id="l32.364" class="difflineplus">+      this._log.warning(&quot;Helper indexer threw exception on worker enum.&quot;);</span>
<a href="#l32.365"></a><span id="l32.365" class="difflineplus">+    }</span>
<a href="#l32.366"></a><span id="l32.366" class="difflineplus">+    </span>
<a href="#l32.367"></a><span id="l32.367" class="difflineplus">+    if (this._enabled) {</span>
<a href="#l32.368"></a><span id="l32.368" class="difflineplus">+      try {</span>
<a href="#l32.369"></a><span id="l32.369" class="difflineplus">+        aIndexer.enable();</span>
<a href="#l32.370"></a><span id="l32.370" class="difflineplus">+      } catch (ex) {</span>
<a href="#l32.371"></a><span id="l32.371" class="difflineplus">+        this._log.warning(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l32.372"></a><span id="l32.372" class="difflineplus">+      }</span>
<a href="#l32.373"></a><span id="l32.373" class="difflineplus">+    }</span>
<a href="#l32.374"></a><span id="l32.374" class="difflineplus">+  },</span>
<a href="#l32.375"></a><span id="l32.375" class="difflineplus">+  </span>
<a href="#l32.376"></a><span id="l32.376" class="difflineplus">+  /**</span>
<a href="#l32.377"></a><span id="l32.377" class="difflineplus">+   * Are we enabled, read: are we processing change events?</span>
<a href="#l32.378"></a><span id="l32.378" class="difflineplus">+   */</span>
<a href="#l32.379"></a><span id="l32.379" class="difflineplus">+  _enabled: false,</span>
<a href="#l32.380"></a><span id="l32.380" class="difflineplus">+  get enabled() { return this._enabled; },</span>
<a href="#l32.381"></a><span id="l32.381" class="difflineplus">+  set enabled(aEnable) {</span>
<a href="#l32.382"></a><span id="l32.382" class="difflineplus">+    if (!this._enabled &amp;&amp; aEnable) {</span>
<a href="#l32.383"></a><span id="l32.383" class="difflineplus">+      // register for:</span>
<a href="#l32.384"></a><span id="l32.384" class="difflineplus">+      // - folder loaded events, so we know when getDatabaseWithReparse has finished</span>
<a href="#l32.385"></a><span id="l32.385" class="difflineplus">+      //   updating the index/what not (if it was't immediately available)</span>
<a href="#l32.386"></a><span id="l32.386" class="difflineplus">+      // - property changes (so we know when a message's read/starred state have</span>
<a href="#l32.387"></a><span id="l32.387" class="difflineplus">+      //   changed.)</span>
<a href="#l32.388"></a><span id="l32.388" class="difflineplus">+      let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l32.389"></a><span id="l32.389" class="difflineplus">+                          getService(Ci.nsIMsgMailSession);</span>
<a href="#l32.390"></a><span id="l32.390" class="difflineplus">+      this._folderListener._init(this);</span>
<a href="#l32.391"></a><span id="l32.391" class="difflineplus">+      mailSession.AddFolderListener(this._folderListener,</span>
<a href="#l32.392"></a><span id="l32.392" class="difflineplus">+                                    Ci.nsIFolderListener.propertyFlagChanged |</span>
<a href="#l32.393"></a><span id="l32.393" class="difflineplus">+                                    Ci.nsIFolderListener.event);</span>
<a href="#l32.394"></a><span id="l32.394" class="difflineplus">+  </span>
<a href="#l32.395"></a><span id="l32.395" class="difflineplus">+      // register for shutdown, offline notifications</span>
<a href="#l32.396"></a><span id="l32.396" class="difflineplus">+      let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l32.397"></a><span id="l32.397" class="difflineplus">+                              getService(Ci.nsIObserverService);</span>
<a href="#l32.398"></a><span id="l32.398" class="difflineplus">+      observerService.addObserver(this, &quot;network:offline-status-changed&quot;, false);</span>
<a href="#l32.399"></a><span id="l32.399" class="difflineplus">+      // sign up for the nsIMsgShutdownService's scheme...</span>
<a href="#l32.400"></a><span id="l32.400" class="difflineplus">+      observerService.addObserver(this._shutdownTask, &quot;msg-shutdown&quot;, false);</span>
<a href="#l32.401"></a><span id="l32.401" class="difflineplus">+      // ...which isn't fool-proof, so sign up for quit-application too</span>
<a href="#l32.402"></a><span id="l32.402" class="difflineplus">+      // (msg-shutdown depends on quit-application-request which is optional)</span>
<a href="#l32.403"></a><span id="l32.403" class="difflineplus">+      observerService.addObserver(this, &quot;quit-application&quot;, false);</span>
<a href="#l32.404"></a><span id="l32.404" class="difflineplus">+  </span>
<a href="#l32.405"></a><span id="l32.405" class="difflineplus">+      // register for idle notification</span>
<a href="#l32.406"></a><span id="l32.406" class="difflineplus">+      let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;].</span>
<a href="#l32.407"></a><span id="l32.407" class="difflineplus">+                          getService(Ci.nsIIdleService);</span>
<a href="#l32.408"></a><span id="l32.408" class="difflineplus">+      idleService.addIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l32.409"></a><span id="l32.409" class="difflineplus">+</span>
<a href="#l32.410"></a><span id="l32.410" class="difflineplus">+      let notificationService =</span>
<a href="#l32.411"></a><span id="l32.411" class="difflineplus">+        Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l32.412"></a><span id="l32.412" class="difflineplus">+        getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l32.413"></a><span id="l32.413" class="difflineplus">+      notificationService.addListener(this._msgFolderListener,</span>
<a href="#l32.414"></a><span id="l32.414" class="difflineplus">+                                      Ci.nsIMsgFolderNotificationService.all);</span>
<a href="#l32.415"></a><span id="l32.415" class="difflineplus">+      </span>
<a href="#l32.416"></a><span id="l32.416" class="difflineplus">+      this._enabled = true;</span>
<a href="#l32.417"></a><span id="l32.417" class="difflineplus">+      </span>
<a href="#l32.418"></a><span id="l32.418" class="difflineplus">+      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l32.419"></a><span id="l32.419" class="difflineplus">+        try {</span>
<a href="#l32.420"></a><span id="l32.420" class="difflineplus">+          indexer.enable();</span>
<a href="#l32.421"></a><span id="l32.421" class="difflineplus">+        } catch (ex) {</span>
<a href="#l32.422"></a><span id="l32.422" class="difflineplus">+          this._log.warning(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l32.423"></a><span id="l32.423" class="difflineplus">+        }</span>
<a href="#l32.424"></a><span id="l32.424" class="difflineplus">+      }</span>
<a href="#l32.425"></a><span id="l32.425" class="difflineplus">+      </span>
<a href="#l32.426"></a><span id="l32.426" class="difflineplus">+      // if we have an accumulated desire to index things, kick it off again.</span>
<a href="#l32.427"></a><span id="l32.427" class="difflineplus">+      if (this._indexingDesired) {</span>
<a href="#l32.428"></a><span id="l32.428" class="difflineplus">+        this._indexingDesired = false; // it's edge-triggered for now</span>
<a href="#l32.429"></a><span id="l32.429" class="difflineplus">+        this.indexing = true;</span>
<a href="#l32.430"></a><span id="l32.430" class="difflineplus">+      }</span>
<a href="#l32.431"></a><span id="l32.431" class="difflineplus">+    }</span>
<a href="#l32.432"></a><span id="l32.432" class="difflineplus">+    else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l32.433"></a><span id="l32.433" class="difflineplus">+      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l32.434"></a><span id="l32.434" class="difflineplus">+        try {</span>
<a href="#l32.435"></a><span id="l32.435" class="difflineplus">+          indexer.disable();</span>
<a href="#l32.436"></a><span id="l32.436" class="difflineplus">+        } catch (ex) {</span>
<a href="#l32.437"></a><span id="l32.437" class="difflineplus">+          this._log.warning(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l32.438"></a><span id="l32.438" class="difflineplus">+        }</span>
<a href="#l32.439"></a><span id="l32.439" class="difflineplus">+      }</span>
<a href="#l32.440"></a><span id="l32.440" class="difflineplus">+</span>
<a href="#l32.441"></a><span id="l32.441" class="difflineplus">+      // remove observer; no more events to observe!</span>
<a href="#l32.442"></a><span id="l32.442" class="difflineplus">+      let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l32.443"></a><span id="l32.443" class="difflineplus">+                              getService(Ci.nsIObserverService);</span>
<a href="#l32.444"></a><span id="l32.444" class="difflineplus">+      observerService.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l32.445"></a><span id="l32.445" class="difflineplus">+      observerService.removeObserver(this._shutdownTask, &quot;msg-shutdown&quot;);</span>
<a href="#l32.446"></a><span id="l32.446" class="difflineplus">+      observerService.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l32.447"></a><span id="l32.447" class="difflineplus">+  </span>
<a href="#l32.448"></a><span id="l32.448" class="difflineplus">+      // remove idle</span>
<a href="#l32.449"></a><span id="l32.449" class="difflineplus">+      let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;].</span>
<a href="#l32.450"></a><span id="l32.450" class="difflineplus">+                          getService(Ci.nsIIdleService);</span>
<a href="#l32.451"></a><span id="l32.451" class="difflineplus">+      idleService.removeIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l32.452"></a><span id="l32.452" class="difflineplus">+  </span>
<a href="#l32.453"></a><span id="l32.453" class="difflineplus">+      // remove FolderLoaded notification listener</span>
<a href="#l32.454"></a><span id="l32.454" class="difflineplus">+      let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l32.455"></a><span id="l32.455" class="difflineplus">+                          getService(Ci.nsIMsgMailSession);</span>
<a href="#l32.456"></a><span id="l32.456" class="difflineplus">+      mailSession.RemoveFolderListener(this._folderListener);</span>
<a href="#l32.457"></a><span id="l32.457" class="difflineplus">+</span>
<a href="#l32.458"></a><span id="l32.458" class="difflineplus">+      let notificationService =</span>
<a href="#l32.459"></a><span id="l32.459" class="difflineplus">+        Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l32.460"></a><span id="l32.460" class="difflineplus">+        getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l32.461"></a><span id="l32.461" class="difflineplus">+      notificationService.removeListener(this._msgFolderListener);</span>
<a href="#l32.462"></a><span id="l32.462" class="difflineplus">+      </span>
<a href="#l32.463"></a><span id="l32.463" class="difflineplus">+      this._enabled = false;</span>
<a href="#l32.464"></a><span id="l32.464" class="difflineplus">+    }</span>
<a href="#l32.465"></a><span id="l32.465" class="difflineplus">+    </span>
<a href="#l32.466"></a><span id="l32.466" class="difflineplus">+    this._log.info(&quot;Event-Driven Indexing is now &quot; + this._enabled);</span>
<a href="#l32.467"></a><span id="l32.467" class="difflineplus">+  },</span>
<a href="#l32.468"></a><span id="l32.468" class="difflineplus">+</span>
<a href="#l32.469"></a><span id="l32.469" class="difflineplus">+  /** Track whether indexing is desired (we have jobs to prosecute). */</span>
<a href="#l32.470"></a><span id="l32.470" class="difflineplus">+  _indexingDesired: false,</span>
<a href="#l32.471"></a><span id="l32.471" class="difflineplus">+  /**</span>
<a href="#l32.472"></a><span id="l32.472" class="difflineplus">+   * Track whether we have an actively pending callback or timer event.  We do</span>
<a href="#l32.473"></a><span id="l32.473" class="difflineplus">+   *  this so we don't experience a transient suppression and accidentally</span>
<a href="#l32.474"></a><span id="l32.474" class="difflineplus">+   *  get multiple event-chains driving indexing at the same time (which the</span>
<a href="#l32.475"></a><span id="l32.475" class="difflineplus">+   *  code will not handle correctly).</span>
<a href="#l32.476"></a><span id="l32.476" class="difflineplus">+   */</span>
<a href="#l32.477"></a><span id="l32.477" class="difflineplus">+  _indexingActive: false,</span>
<a href="#l32.478"></a><span id="l32.478" class="difflineplus">+  /**</span>
<a href="#l32.479"></a><span id="l32.479" class="difflineplus">+   * Indicates whether indexing is currently ongoing.  This may return false</span>
<a href="#l32.480"></a><span id="l32.480" class="difflineplus">+   *  while indexing activities are still active, but they will quiesce shortly.</span>
<a href="#l32.481"></a><span id="l32.481" class="difflineplus">+   */</span>
<a href="#l32.482"></a><span id="l32.482" class="difflineplus">+  get indexing() {</span>
<a href="#l32.483"></a><span id="l32.483" class="difflineplus">+    return this._indexingDesired &amp;&amp; !this._suppressIndexing;</span>
<a href="#l32.484"></a><span id="l32.484" class="difflineplus">+  },</span>
<a href="#l32.485"></a><span id="l32.485" class="difflineplus">+  /** Indicates whether indexing is desired. */</span>
<a href="#l32.486"></a><span id="l32.486" class="difflineplus">+  get indexingDesired() {</span>
<a href="#l32.487"></a><span id="l32.487" class="difflineplus">+    return this._indexingDesired;</span>
<a href="#l32.488"></a><span id="l32.488" class="difflineplus">+  },</span>
<a href="#l32.489"></a><span id="l32.489" class="difflineplus">+  /**</span>
<a href="#l32.490"></a><span id="l32.490" class="difflineplus">+   * Set this to true to indicate there is indexing work to perform.  This does</span>
<a href="#l32.491"></a><span id="l32.491" class="difflineplus">+   *  not mean indexing will begin immediately (if it wasn't active), however.</span>
<a href="#l32.492"></a><span id="l32.492" class="difflineplus">+   *  If suppressIndexing has been set, we won't do anything until indexing is</span>
<a href="#l32.493"></a><span id="l32.493" class="difflineplus">+   *  no longer suppressed.</span>
<a href="#l32.494"></a><span id="l32.494" class="difflineplus">+   */</span>
<a href="#l32.495"></a><span id="l32.495" class="difflineplus">+  set indexing(aShouldIndex) {</span>
<a href="#l32.496"></a><span id="l32.496" class="difflineplus">+    if (!this._indexingDesired &amp;&amp; aShouldIndex) {</span>
<a href="#l32.497"></a><span id="l32.497" class="difflineplus">+      this._indexingDesired = true;</span>
<a href="#l32.498"></a><span id="l32.498" class="difflineplus">+      if (this.enabled &amp;&amp; !this._indexingActive &amp;&amp; !this._suppressIndexing) {</span>
<a href="#l32.499"></a><span id="l32.499" class="difflineplus">+        this._log.info(&quot;+++ Indexing Queue Processing Commencing&quot;);</span>
<a href="#l32.500"></a><span id="l32.500" class="difflineplus">+        this._indexingActive = true;</span>
<a href="#l32.501"></a><span id="l32.501" class="difflineplus">+        this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l32.502"></a><span id="l32.502" class="difflineplus">+                                     this._indexInterval,</span>
<a href="#l32.503"></a><span id="l32.503" class="difflineplus">+                                     Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l32.504"></a><span id="l32.504" class="difflineplus">+      }</span>
<a href="#l32.505"></a><span id="l32.505" class="difflineplus">+    }</span>
<a href="#l32.506"></a><span id="l32.506" class="difflineplus">+  },</span>
<a href="#l32.507"></a><span id="l32.507" class="difflineplus">+  </span>
<a href="#l32.508"></a><span id="l32.508" class="difflineplus">+  _suppressIndexing: false,</span>
<a href="#l32.509"></a><span id="l32.509" class="difflineplus">+  /**</span>
<a href="#l32.510"></a><span id="l32.510" class="difflineplus">+   * Set whether or not indexing should be suppressed.  This is to allow us to</span>
<a href="#l32.511"></a><span id="l32.511" class="difflineplus">+   *  avoid running down a laptop's battery when it is not on AC.  Only code</span>
<a href="#l32.512"></a><span id="l32.512" class="difflineplus">+   *  in charge of regulating that tracking should be setting this variable; if</span>
<a href="#l32.513"></a><span id="l32.513" class="difflineplus">+   *  other factors want to contribute to such a decision, this logic needs to</span>
<a href="#l32.514"></a><span id="l32.514" class="difflineplus">+   *  be changed to track that, since last-write currently wins.</span>
<a href="#l32.515"></a><span id="l32.515" class="difflineplus">+   */</span>
<a href="#l32.516"></a><span id="l32.516" class="difflineplus">+  set suppressIndexing(aShouldSuppress) {</span>
<a href="#l32.517"></a><span id="l32.517" class="difflineplus">+    this._suppressIndexing = aShouldSuppress;</span>
<a href="#l32.518"></a><span id="l32.518" class="difflineplus">+    </span>
<a href="#l32.519"></a><span id="l32.519" class="difflineplus">+    // re-start processing if we are no longer suppressing, there is work yet</span>
<a href="#l32.520"></a><span id="l32.520" class="difflineplus">+    //  to do, and the indexing process had actually stopped.</span>
<a href="#l32.521"></a><span id="l32.521" class="difflineplus">+    if (!this._suppressIndexing &amp;&amp; this._indexingDesired &amp;&amp;</span>
<a href="#l32.522"></a><span id="l32.522" class="difflineplus">+        !this._indexingActive) {</span>
<a href="#l32.523"></a><span id="l32.523" class="difflineplus">+        this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l32.524"></a><span id="l32.524" class="difflineplus">+        this._indexingActive = true;</span>
<a href="#l32.525"></a><span id="l32.525" class="difflineplus">+        this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l32.526"></a><span id="l32.526" class="difflineplus">+                                     this._indexInterval,</span>
<a href="#l32.527"></a><span id="l32.527" class="difflineplus">+                                     Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l32.528"></a><span id="l32.528" class="difflineplus">+    }</span>
<a href="#l32.529"></a><span id="l32.529" class="difflineplus">+  },</span>
<a href="#l32.530"></a><span id="l32.530" class="difflineplus">+</span>
<a href="#l32.531"></a><span id="l32.531" class="difflineplus">+  _initialSweepPerformed: false,</span>
<a href="#l32.532"></a><span id="l32.532" class="difflineplus">+  _indexingSweepActive: false,</span>
<a href="#l32.533"></a><span id="l32.533" class="difflineplus">+  /**</span>
<a href="#l32.534"></a><span id="l32.534" class="difflineplus">+   * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l32.535"></a><span id="l32.535" class="difflineplus">+   *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l32.536"></a><span id="l32.536" class="difflineplus">+   *  that we either can't process as an event or that we normally handle</span>
<a href="#l32.537"></a><span id="l32.537" class="difflineplus">+   *  during the sweep pass anyways.</span>
<a href="#l32.538"></a><span id="l32.538" class="difflineplus">+   */</span>
<a href="#l32.539"></a><span id="l32.539" class="difflineplus">+  set indexingSweepNeeded(aNeeded) {</span>
<a href="#l32.540"></a><span id="l32.540" class="difflineplus">+    if (!this._indexingSweepActive &amp;&amp; aNeeded) {</span>
<a href="#l32.541"></a><span id="l32.541" class="difflineplus">+      this._indexQueue.push(new IndexingJob(&quot;sweep&quot;, 0, null));</span>
<a href="#l32.542"></a><span id="l32.542" class="difflineplus">+      this._indexingJobGoal++;</span>
<a href="#l32.543"></a><span id="l32.543" class="difflineplus">+      this._indexingSweepActive = true;</span>
<a href="#l32.544"></a><span id="l32.544" class="difflineplus">+      this.indexing = true;</span>
<a href="#l32.545"></a><span id="l32.545" class="difflineplus">+    }</span>
<a href="#l32.546"></a><span id="l32.546" class="difflineplus">+  },</span>
<a href="#l32.547"></a><span id="l32.547" class="difflineplus">+</span>
<a href="#l32.548"></a><span id="l32.548" class="difflineplus">+  /**</span>
<a href="#l32.549"></a><span id="l32.549" class="difflineplus">+   * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l32.550"></a><span id="l32.550" class="difflineplus">+   *  are gloda message rows flagged for deletion.  If this value is a boolean,</span>
<a href="#l32.551"></a><span id="l32.551" class="difflineplus">+   *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l32.552"></a><span id="l32.552" class="difflineplus">+   *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l32.553"></a><span id="l32.553" class="difflineplus">+   *  the database.</span>
<a href="#l32.554"></a><span id="l32.554" class="difflineplus">+   */</span>
<a href="#l32.555"></a><span id="l32.555" class="difflineplus">+  pendingDeletions: null,</span>
<a href="#l32.556"></a><span id="l32.556" class="difflineplus">+  </span>
<a href="#l32.557"></a><span id="l32.557" class="difflineplus">+  GLODA_MESSAGE_ID_PROPERTY: &quot;gloda-id&quot;,</span>
<a href="#l32.558"></a><span id="l32.558" class="difflineplus">+  GLODA_DIRTY_PROPERTY: &quot;gloda-dirty&quot;,</span>
<a href="#l32.559"></a><span id="l32.559" class="difflineplus">+  /**</span>
<a href="#l32.560"></a><span id="l32.560" class="difflineplus">+   * The message (or folder state) is believed up-to-date.</span>
<a href="#l32.561"></a><span id="l32.561" class="difflineplus">+   */</span>
<a href="#l32.562"></a><span id="l32.562" class="difflineplus">+  kMessageClean: 0,</span>
<a href="#l32.563"></a><span id="l32.563" class="difflineplus">+  /**</span>
<a href="#l32.564"></a><span id="l32.564" class="difflineplus">+   * The message (or folder) is known to not be up-to-date. In the case of</span>
<a href="#l32.565"></a><span id="l32.565" class="difflineplus">+   *  folders, this means that some of the messages in the folder may be dirty.</span>
<a href="#l32.566"></a><span id="l32.566" class="difflineplus">+   *  However, because of the way our indexing works, it is possible there may</span>
<a href="#l32.567"></a><span id="l32.567" class="difflineplus">+   *  actually be no dirty messages in a folder.  (We attempt to process</span>
<a href="#l32.568"></a><span id="l32.568" class="difflineplus">+   *  messages in an event-driven fashion for a finite number of messages, but</span>
<a href="#l32.569"></a><span id="l32.569" class="difflineplus">+   *  because we can quit without completing processing of the queue, we need to</span>
<a href="#l32.570"></a><span id="l32.570" class="difflineplus">+   *  mark the folder dirty, just-in-case.)  (We could do some extra leg-work</span>
<a href="#l32.571"></a><span id="l32.571" class="difflineplus">+   *  and do a better job of marking the folder clean again.)   </span>
<a href="#l32.572"></a><span id="l32.572" class="difflineplus">+   */</span>
<a href="#l32.573"></a><span id="l32.573" class="difflineplus">+  kMessageDirty: 1,</span>
<a href="#l32.574"></a><span id="l32.574" class="difflineplus">+  /**</span>
<a href="#l32.575"></a><span id="l32.575" class="difflineplus">+   * We have not indexed the folder at all, but messages in the folder think</span>
<a href="#l32.576"></a><span id="l32.576" class="difflineplus">+   *  they are indexed.  Once we mark all the messages in the folder as being</span>
<a href="#l32.577"></a><span id="l32.577" class="difflineplus">+   *  dirty so that they don't confuse us, we downgrade the folder's dirty</span>
<a href="#l32.578"></a><span id="l32.578" class="difflineplus">+   *  status to just kMessageDirty.</span>
<a href="#l32.579"></a><span id="l32.579" class="difflineplus">+   */</span>
<a href="#l32.580"></a><span id="l32.580" class="difflineplus">+  kMessageFilthy: 2,</span>
<a href="#l32.581"></a><span id="l32.581" class="difflineplus">+</span>
<a href="#l32.582"></a><span id="l32.582" class="difflineplus">+  kWorkSync: Gloda.kWorkSync,</span>
<a href="#l32.583"></a><span id="l32.583" class="difflineplus">+  kWorkAsync: Gloda.kWorkAsync,</span>
<a href="#l32.584"></a><span id="l32.584" class="difflineplus">+  kWorkDone: Gloda.kWorkDone,</span>
<a href="#l32.585"></a><span id="l32.585" class="difflineplus">+  kWorkPause: Gloda.kWorkPause,</span>
<a href="#l32.586"></a><span id="l32.586" class="difflineplus">+  kWorkDoneWithResult: Gloda.kWorkDoneWithResult,</span>
<a href="#l32.587"></a><span id="l32.587" class="difflineplus">+  </span>
<a href="#l32.588"></a><span id="l32.588" class="difflineplus">+  /**</span>
<a href="#l32.589"></a><span id="l32.589" class="difflineplus">+   * Our current job number, out of _indexingJobGoal.  Although our jobs comes</span>
<a href="#l32.590"></a><span id="l32.590" class="difflineplus">+   *  from _indexQueue, this is not an offset into that list because we forget</span>
<a href="#l32.591"></a><span id="l32.591" class="difflineplus">+   *  jobs once we complete them.  As such, this value is strictly for progress</span>
<a href="#l32.592"></a><span id="l32.592" class="difflineplus">+   *  tracking.</span>
<a href="#l32.593"></a><span id="l32.593" class="difflineplus">+   */ </span>
<a href="#l32.594"></a><span id="l32.594" class="difflineplus">+  _indexingJobCount: 0,</span>
<a href="#l32.595"></a><span id="l32.595" class="difflineplus">+  /**</span>
<a href="#l32.596"></a><span id="l32.596" class="difflineplus">+   * Total number of jobs to process in this current indexing session; may</span>
<a href="#l32.597"></a><span id="l32.597" class="difflineplus">+   *  increase as new jobs are added to the _indexQueue.  This value won't</span>
<a href="#l32.598"></a><span id="l32.598" class="difflineplus">+   *  decrease until the indexing session is completed (and we become idle),</span>
<a href="#l32.599"></a><span id="l32.599" class="difflineplus">+   *  and then it will go to zero.</span>
<a href="#l32.600"></a><span id="l32.600" class="difflineplus">+   */</span>
<a href="#l32.601"></a><span id="l32.601" class="difflineplus">+  _indexingJobGoal: 0,</span>
<a href="#l32.602"></a><span id="l32.602" class="difflineplus">+  </span>
<a href="#l32.603"></a><span id="l32.603" class="difflineplus">+  /**</span>
<a href="#l32.604"></a><span id="l32.604" class="difflineplus">+   * A list of IndexingJob instances to process.</span>
<a href="#l32.605"></a><span id="l32.605" class="difflineplus">+   * - ['account', account object]</span>
<a href="#l32.606"></a><span id="l32.606" class="difflineplus">+   * - ['folder', folder URI]</span>
<a href="#l32.607"></a><span id="l32.607" class="difflineplus">+   * - ['message', delta type, message header, folder ID, message key,</span>
<a href="#l32.608"></a><span id="l32.608" class="difflineplus">+   *      message ID]</span>
<a href="#l32.609"></a><span id="l32.609" class="difflineplus">+   *   (we use folder ID instead of URI so that renames can't trick us)</span>
<a href="#l32.610"></a><span id="l32.610" class="difflineplus">+   */</span>
<a href="#l32.611"></a><span id="l32.611" class="difflineplus">+  _indexQueue: [],</span>
<a href="#l32.612"></a><span id="l32.612" class="difflineplus">+  </span>
<a href="#l32.613"></a><span id="l32.613" class="difflineplus">+  /**</span>
<a href="#l32.614"></a><span id="l32.614" class="difflineplus">+   * The current indexing job.</span>
<a href="#l32.615"></a><span id="l32.615" class="difflineplus">+   */</span>
<a href="#l32.616"></a><span id="l32.616" class="difflineplus">+  _curIndexingJob: null,</span>
<a href="#l32.617"></a><span id="l32.617" class="difflineplus">+  </span>
<a href="#l32.618"></a><span id="l32.618" class="difflineplus">+  /**</span>
<a href="#l32.619"></a><span id="l32.619" class="difflineplus">+   * A message addition job yet to be (completely) processed.  Since message</span>
<a href="#l32.620"></a><span id="l32.620" class="difflineplus">+   *  addition events come to us one-by-one, in order to aggregate them into a</span>
<a href="#l32.621"></a><span id="l32.621" class="difflineplus">+   *  job, we need something like this.  It's up to the indexing loop to</span>
<a href="#l32.622"></a><span id="l32.622" class="difflineplus">+   *  decide when to null this out; it can either do it when it first starts</span>
<a href="#l32.623"></a><span id="l32.623" class="difflineplus">+   *  processing it, or when it has processed the last thing.  It's really a</span>
<a href="#l32.624"></a><span id="l32.624" class="difflineplus">+   *  question of whether we want retrograde motion in the folder progress bar</span>
<a href="#l32.625"></a><span id="l32.625" class="difflineplus">+   *  or the message progress bar.</span>
<a href="#l32.626"></a><span id="l32.626" class="difflineplus">+   */</span>
<a href="#l32.627"></a><span id="l32.627" class="difflineplus">+  _pendingAddJob: null,</span>
<a href="#l32.628"></a><span id="l32.628" class="difflineplus">+  </span>
<a href="#l32.629"></a><span id="l32.629" class="difflineplus">+  /**</span>
<a href="#l32.630"></a><span id="l32.630" class="difflineplus">+   * The number of seconds before we declare the user idle and step up our</span>
<a href="#l32.631"></a><span id="l32.631" class="difflineplus">+   *  indexing.</span>
<a href="#l32.632"></a><span id="l32.632" class="difflineplus">+   */</span>
<a href="#l32.633"></a><span id="l32.633" class="difflineplus">+  _indexIdleThresholdSecs: 15,</span>
<a href="#l32.634"></a><span id="l32.634" class="difflineplus">+  </span>
<a href="#l32.635"></a><span id="l32.635" class="difflineplus">+  /**</span>
<a href="#l32.636"></a><span id="l32.636" class="difflineplus">+   * The time interval, in milliseconds between performing indexing work.</span>
<a href="#l32.637"></a><span id="l32.637" class="difflineplus">+   *  This may be altered by user session (in)activity.</span>
<a href="#l32.638"></a><span id="l32.638" class="difflineplus">+   */ </span>
<a href="#l32.639"></a><span id="l32.639" class="difflineplus">+  _indexInterval: 100,</span>
<a href="#l32.640"></a><span id="l32.640" class="difflineplus">+  _indexInterval_whenActive: 100,</span>
<a href="#l32.641"></a><span id="l32.641" class="difflineplus">+  _indexInterval_whenIdle: 20,</span>
<a href="#l32.642"></a><span id="l32.642" class="difflineplus">+  /**</span>
<a href="#l32.643"></a><span id="l32.643" class="difflineplus">+   * Number of indexing 'tokens' we are allowed to consume before yielding for</span>
<a href="#l32.644"></a><span id="l32.644" class="difflineplus">+   *  each incremental pass.  Consider a single token equal to indexing a single</span>
<a href="#l32.645"></a><span id="l32.645" class="difflineplus">+   *  medium-sized message.  This may be altered by user session (in)activity.</span>
<a href="#l32.646"></a><span id="l32.646" class="difflineplus">+   * Because we fetch message bodies, which is potentially asynchronous, this</span>
<a href="#l32.647"></a><span id="l32.647" class="difflineplus">+   *  is not a precise knob to twiddle.</span>
<a href="#l32.648"></a><span id="l32.648" class="difflineplus">+   */</span>
<a href="#l32.649"></a><span id="l32.649" class="difflineplus">+  _indexTokens: 2,</span>
<a href="#l32.650"></a><span id="l32.650" class="difflineplus">+  _indexTokens_whenActive: 2,</span>
<a href="#l32.651"></a><span id="l32.651" class="difflineplus">+  _indexTokens_whenIdle: 10,</span>
<a href="#l32.652"></a><span id="l32.652" class="difflineplus">+  </span>
<a href="#l32.653"></a><span id="l32.653" class="difflineplus">+  /**</span>
<a href="#l32.654"></a><span id="l32.654" class="difflineplus">+   * Number of indexing 'tokens' we consume before we issue a commit.  The</span>
<a href="#l32.655"></a><span id="l32.655" class="difflineplus">+   *  goal is to de-couple our time scheduling from our commit schedule.  It's</span>
<a href="#l32.656"></a><span id="l32.656" class="difflineplus">+   *  far better for user responsiveness to take lots of little bites instead</span>
<a href="#l32.657"></a><span id="l32.657" class="difflineplus">+   *  of a few big ones, but bites that result in commits cannot be little... </span>
<a href="#l32.658"></a><span id="l32.658" class="difflineplus">+   */</span>
<a href="#l32.659"></a><span id="l32.659" class="difflineplus">+  _indexCommitTokens: 10,</span>
<a href="#l32.660"></a><span id="l32.660" class="difflineplus">+  </span>
<a href="#l32.661"></a><span id="l32.661" class="difflineplus">+  /**</span>
<a href="#l32.662"></a><span id="l32.662" class="difflineplus">+   * The number of messages that we should queue for processing before letting</span>
<a href="#l32.663"></a><span id="l32.663" class="difflineplus">+   *  them fall on the floor and relying on our folder-walking logic to ensure</span>
<a href="#l32.664"></a><span id="l32.664" class="difflineplus">+   *  that the messages are indexed.</span>
<a href="#l32.665"></a><span id="l32.665" class="difflineplus">+   * The reason we allow for queueing messages in an event-driven fashion is</span>
<a href="#l32.666"></a><span id="l32.666" class="difflineplus">+   *  that once we have reached a steady-state, it is preferable to be able to</span>
<a href="#l32.667"></a><span id="l32.667" class="difflineplus">+   *  deal with new messages and modified meta-data in a prompt fasion rather</span>
<a href="#l32.668"></a><span id="l32.668" class="difflineplus">+   *  than having to (potentially) walk every folder in the system just to find</span>
<a href="#l32.669"></a><span id="l32.669" class="difflineplus">+   *  the message that the user changed the tag on.</span>
<a href="#l32.670"></a><span id="l32.670" class="difflineplus">+   */</span>
<a href="#l32.671"></a><span id="l32.671" class="difflineplus">+  _indexMaxEventQueueMessages: 20,</span>
<a href="#l32.672"></a><span id="l32.672" class="difflineplus">+  </span>
<a href="#l32.673"></a><span id="l32.673" class="difflineplus">+  _indexListeners: [],</span>
<a href="#l32.674"></a><span id="l32.674" class="difflineplus">+  /**</span>
<a href="#l32.675"></a><span id="l32.675" class="difflineplus">+   * Add an indexing progress listener.  The listener will be notified of at</span>
<a href="#l32.676"></a><span id="l32.676" class="difflineplus">+   *  least all major status changes (idle -&gt; indexing, indexing -&gt; idle), plus</span>
<a href="#l32.677"></a><span id="l32.677" class="difflineplus">+   *  arbitrary progress updates during the indexing process.</span>
<a href="#l32.678"></a><span id="l32.678" class="difflineplus">+   * If indexing is not active when the listener is added, a synthetic idle</span>
<a href="#l32.679"></a><span id="l32.679" class="difflineplus">+   *  notification will be generated.</span>
<a href="#l32.680"></a><span id="l32.680" class="difflineplus">+   *</span>
<a href="#l32.681"></a><span id="l32.681" class="difflineplus">+   * @param aListener A listener function, taking arguments: status (Gloda.</span>
<a href="#l32.682"></a><span id="l32.682" class="difflineplus">+   *     kIndexer*), the folder name if a folder is involved (string or null),</span>
<a href="#l32.683"></a><span id="l32.683" class="difflineplus">+   *     current zero-based job number (int), total number of jobs (int),</span>
<a href="#l32.684"></a><span id="l32.684" class="difflineplus">+   *     current item number being indexed in this job (int), total number</span>
<a href="#l32.685"></a><span id="l32.685" class="difflineplus">+   *     of items in this job to be indexed (int).</span>
<a href="#l32.686"></a><span id="l32.686" class="difflineplus">+   *</span>
<a href="#l32.687"></a><span id="l32.687" class="difflineplus">+   * @TODO should probably allow for a 'this' value to be provided</span>
<a href="#l32.688"></a><span id="l32.688" class="difflineplus">+   * @TODO generalize to not be folder/message specific.  use nouns!</span>
<a href="#l32.689"></a><span id="l32.689" class="difflineplus">+   */</span>
<a href="#l32.690"></a><span id="l32.690" class="difflineplus">+  addListener: function gloda_index_addListener(aListener) {</span>
<a href="#l32.691"></a><span id="l32.691" class="difflineplus">+    // should we weakify?</span>
<a href="#l32.692"></a><span id="l32.692" class="difflineplus">+    if (this._indexListeners.indexOf(aListener) == -1)</span>
<a href="#l32.693"></a><span id="l32.693" class="difflineplus">+      this._indexListeners.push(aListener);</span>
<a href="#l32.694"></a><span id="l32.694" class="difflineplus">+    // if we aren't indexing, give them an idle indicator, otherwise they can</span>
<a href="#l32.695"></a><span id="l32.695" class="difflineplus">+    //  just be happy when we hit the next actual status point.</span>
<a href="#l32.696"></a><span id="l32.696" class="difflineplus">+    if (!this.indexing)</span>
<a href="#l32.697"></a><span id="l32.697" class="difflineplus">+      aListener(Gloda.kIndexerIdle, null, 0, 1, 0, 1);</span>
<a href="#l32.698"></a><span id="l32.698" class="difflineplus">+    return aListener;</span>
<a href="#l32.699"></a><span id="l32.699" class="difflineplus">+  },</span>
<a href="#l32.700"></a><span id="l32.700" class="difflineplus">+  /**</span>
<a href="#l32.701"></a><span id="l32.701" class="difflineplus">+   * Remove the given listener so that it no longer receives indexing progress</span>
<a href="#l32.702"></a><span id="l32.702" class="difflineplus">+   *  updates.</span>
<a href="#l32.703"></a><span id="l32.703" class="difflineplus">+   */</span>
<a href="#l32.704"></a><span id="l32.704" class="difflineplus">+  removeListener: function gloda_index_removeListener(aListener) {</span>
<a href="#l32.705"></a><span id="l32.705" class="difflineplus">+    let index = this._indexListeners.indexOf(aListener);</span>
<a href="#l32.706"></a><span id="l32.706" class="difflineplus">+    if (index != -1)</span>
<a href="#l32.707"></a><span id="l32.707" class="difflineplus">+      this._indexListeners.splice(index, 1);</span>
<a href="#l32.708"></a><span id="l32.708" class="difflineplus">+  },</span>
<a href="#l32.709"></a><span id="l32.709" class="difflineplus">+  /**</span>
<a href="#l32.710"></a><span id="l32.710" class="difflineplus">+   * Helper method to tell listeners what we're up to.  For code simplicity,</span>
<a href="#l32.711"></a><span id="l32.711" class="difflineplus">+   *  the caller is just deciding when to send this update (preferably at</span>
<a href="#l32.712"></a><span id="l32.712" class="difflineplus">+   *  reasonable intervals), and doesn't need to provide any indication of</span>
<a href="#l32.713"></a><span id="l32.713" class="difflineplus">+   *  state... we figure that out ourselves.</span>
<a href="#l32.714"></a><span id="l32.714" class="difflineplus">+   */</span>
<a href="#l32.715"></a><span id="l32.715" class="difflineplus">+  _notifyListeners: function gloda_index_notifyListeners() {</span>
<a href="#l32.716"></a><span id="l32.716" class="difflineplus">+    let status, prettyName, jobIndex, jobTotal, jobItemIndex, jobItemGoal;</span>
<a href="#l32.717"></a><span id="l32.717" class="difflineplus">+    </span>
<a href="#l32.718"></a><span id="l32.718" class="difflineplus">+    if (this.indexing &amp;&amp; this._curIndexingJob) {</span>
<a href="#l32.719"></a><span id="l32.719" class="difflineplus">+      let job = this._curIndexingJob;</span>
<a href="#l32.720"></a><span id="l32.720" class="difflineplus">+      if (job.deltaType &gt; 0)</span>
<a href="#l32.721"></a><span id="l32.721" class="difflineplus">+        status = Gloda.kIndexerIndexing;</span>
<a href="#l32.722"></a><span id="l32.722" class="difflineplus">+      else if (job.deltaType == 0)</span>
<a href="#l32.723"></a><span id="l32.723" class="difflineplus">+        status = Gloda.kIndexerMoving;</span>
<a href="#l32.724"></a><span id="l32.724" class="difflineplus">+      else</span>
<a href="#l32.725"></a><span id="l32.725" class="difflineplus">+        status = Gloda.kIndexerRemoving;</span>
<a href="#l32.726"></a><span id="l32.726" class="difflineplus">+        </span>
<a href="#l32.727"></a><span id="l32.727" class="difflineplus">+      let prettyName = (this._indexingFolder !== null) ?</span>
<a href="#l32.728"></a><span id="l32.728" class="difflineplus">+                       this._indexingFolder.prettiestName : null;</span>
<a href="#l32.729"></a><span id="l32.729" class="difflineplus">+</span>
<a href="#l32.730"></a><span id="l32.730" class="difflineplus">+      jobIndex = this._indexingJobCount-1;</span>
<a href="#l32.731"></a><span id="l32.731" class="difflineplus">+      jobTotal = this._indexingJobGoal;</span>
<a href="#l32.732"></a><span id="l32.732" class="difflineplus">+      jobItemIndex = job.offset;</span>
<a href="#l32.733"></a><span id="l32.733" class="difflineplus">+      jobItemGoal  = job.goal;</span>
<a href="#l32.734"></a><span id="l32.734" class="difflineplus">+    }</span>
<a href="#l32.735"></a><span id="l32.735" class="difflineplus">+    else {</span>
<a href="#l32.736"></a><span id="l32.736" class="difflineplus">+      status = Gloda.kIndexerIdle;</span>
<a href="#l32.737"></a><span id="l32.737" class="difflineplus">+      prettyName = null;</span>
<a href="#l32.738"></a><span id="l32.738" class="difflineplus">+      jobIndex = 0;</span>
<a href="#l32.739"></a><span id="l32.739" class="difflineplus">+      jobTotal = 1;</span>
<a href="#l32.740"></a><span id="l32.740" class="difflineplus">+      jobItemIndex = 0;</span>
<a href="#l32.741"></a><span id="l32.741" class="difflineplus">+      jobItemGoal = 1;</span>
<a href="#l32.742"></a><span id="l32.742" class="difflineplus">+    }</span>
<a href="#l32.743"></a><span id="l32.743" class="difflineplus">+      </span>
<a href="#l32.744"></a><span id="l32.744" class="difflineplus">+    for (let iListener = this._indexListeners.length-1; iListener &gt;= 0; </span>
<a href="#l32.745"></a><span id="l32.745" class="difflineplus">+         iListener--) {</span>
<a href="#l32.746"></a><span id="l32.746" class="difflineplus">+      let listener = this._indexListeners[iListener];</span>
<a href="#l32.747"></a><span id="l32.747" class="difflineplus">+      listener(status, prettyName, jobIndex, jobTotal, jobItemIndex,</span>
<a href="#l32.748"></a><span id="l32.748" class="difflineplus">+               jobItemGoal);</span>
<a href="#l32.749"></a><span id="l32.749" class="difflineplus">+    }</span>
<a href="#l32.750"></a><span id="l32.750" class="difflineplus">+  },</span>
<a href="#l32.751"></a><span id="l32.751" class="difflineplus">+  </span>
<a href="#l32.752"></a><span id="l32.752" class="difflineplus">+  _indexingFolderID: null,</span>
<a href="#l32.753"></a><span id="l32.753" class="difflineplus">+  _indexingFolder: null,</span>
<a href="#l32.754"></a><span id="l32.754" class="difflineplus">+  _indexingDatabase: null,</span>
<a href="#l32.755"></a><span id="l32.755" class="difflineplus">+  _indexingIterator: null,</span>
<a href="#l32.756"></a><span id="l32.756" class="difflineplus">+  </span>
<a href="#l32.757"></a><span id="l32.757" class="difflineplus">+  /** folder whose entry we are pending on */</span>
<a href="#l32.758"></a><span id="l32.758" class="difflineplus">+  _pendingFolderEntry: null,</span>
<a href="#l32.759"></a><span id="l32.759" class="difflineplus">+  </span>
<a href="#l32.760"></a><span id="l32.760" class="difflineplus">+  /**</span>
<a href="#l32.761"></a><span id="l32.761" class="difflineplus">+   * Common logic that we want to deal with the given folder ID.  Besides</span>
<a href="#l32.762"></a><span id="l32.762" class="difflineplus">+   *  cutting down on duplicate code, this ensures that we are listening on</span>
<a href="#l32.763"></a><span id="l32.763" class="difflineplus">+   *  the folder in case it tries to go away when we are using it.</span>
<a href="#l32.764"></a><span id="l32.764" class="difflineplus">+   *</span>
<a href="#l32.765"></a><span id="l32.765" class="difflineplus">+   * @return true when the folder was successfully entered, false when we need</span>
<a href="#l32.766"></a><span id="l32.766" class="difflineplus">+   *     to pend on notification of updating of the folder (due to re-parsing</span>
<a href="#l32.767"></a><span id="l32.767" class="difflineplus">+   *     or what have you).  In the event of an actual problem, an exception</span>
<a href="#l32.768"></a><span id="l32.768" class="difflineplus">+   *     will escape.</span>
<a href="#l32.769"></a><span id="l32.769" class="difflineplus">+   */</span>
<a href="#l32.770"></a><span id="l32.770" class="difflineplus">+  _indexerEnterFolder: function gloda_index_indexerEnterFolder(aFolderID,</span>
<a href="#l32.771"></a><span id="l32.771" class="difflineplus">+                                                               aNeedIterator) {</span>
<a href="#l32.772"></a><span id="l32.772" class="difflineplus">+    // if leave folder was't cleared first, remove the listener; everyone else</span>
<a href="#l32.773"></a><span id="l32.773" class="difflineplus">+    //  will be nulled out in the exception handler below if things go south</span>
<a href="#l32.774"></a><span id="l32.774" class="difflineplus">+    //  on this folder.</span>
<a href="#l32.775"></a><span id="l32.775" class="difflineplus">+    if (this._indexingFolder !== null) {</span>
<a href="#l32.776"></a><span id="l32.776" class="difflineplus">+      this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l32.777"></a><span id="l32.777" class="difflineplus">+    }</span>
<a href="#l32.778"></a><span id="l32.778" class="difflineplus">+    </span>
<a href="#l32.779"></a><span id="l32.779" class="difflineplus">+    let glodaFolder = GlodaDatastore._mapFolderID(aFolderID);</span>
<a href="#l32.780"></a><span id="l32.780" class="difflineplus">+  </span>
<a href="#l32.781"></a><span id="l32.781" class="difflineplus">+    let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l32.782"></a><span id="l32.782" class="difflineplus">+                     getService(Ci.nsIRDFService);</span>
<a href="#l32.783"></a><span id="l32.783" class="difflineplus">+    let folder = rdfService.GetResource(glodaFolder.uri);</span>
<a href="#l32.784"></a><span id="l32.784" class="difflineplus">+    folder.QueryInterface(Ci.nsIMsgFolder); // (we want to explode in the try</span>
<a href="#l32.785"></a><span id="l32.785" class="difflineplus">+    // if this guy wasn't what we wanted)</span>
<a href="#l32.786"></a><span id="l32.786" class="difflineplus">+    this._indexingFolder = folder;</span>
<a href="#l32.787"></a><span id="l32.787" class="difflineplus">+    this._indexingFolderID = aFolderID;</span>
<a href="#l32.788"></a><span id="l32.788" class="difflineplus">+</span>
<a href="#l32.789"></a><span id="l32.789" class="difflineplus">+    try {</span>
<a href="#l32.790"></a><span id="l32.790" class="difflineplus">+      // The msf may need to be created or otherwise updated for local folders.</span>
<a href="#l32.791"></a><span id="l32.791" class="difflineplus">+      // This may require yielding until such time as the msf has been created.</span>
<a href="#l32.792"></a><span id="l32.792" class="difflineplus">+      try {</span>
<a href="#l32.793"></a><span id="l32.793" class="difflineplus">+        if (this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l32.794"></a><span id="l32.794" class="difflineplus">+          this._indexingDatabase =</span>
<a href="#l32.795"></a><span id="l32.795" class="difflineplus">+            this._indexingFolder.getDatabaseWithReparse(this._indexingFolder,</span>
<a href="#l32.796"></a><span id="l32.796" class="difflineplus">+                                                        null);</span>
<a href="#l32.797"></a><span id="l32.797" class="difflineplus">+        }</span>
<a href="#l32.798"></a><span id="l32.798" class="difflineplus">+        // we need do nothing special for IMAP, news, or other</span>
<a href="#l32.799"></a><span id="l32.799" class="difflineplus">+      }</span>
<a href="#l32.800"></a><span id="l32.800" class="difflineplus">+      catch ( e if e.result == Cr.NS_ERROR_NOT_INITIALIZED) {</span>
<a href="#l32.801"></a><span id="l32.801" class="difflineplus">+        // this means that we need to pend on the update.</span>
<a href="#l32.802"></a><span id="l32.802" class="difflineplus">+        this._log.debug(&quot;Pending on folder load...&quot;);</span>
<a href="#l32.803"></a><span id="l32.803" class="difflineplus">+        this._pendingFolderEntry = this._indexingFolder;</span>
<a href="#l32.804"></a><span id="l32.804" class="difflineplus">+        this._indexingFolder = null;</span>
<a href="#l32.805"></a><span id="l32.805" class="difflineplus">+        this._indexingFolderID = null;</span>
<a href="#l32.806"></a><span id="l32.806" class="difflineplus">+        this._indexingDatabase = null;</span>
<a href="#l32.807"></a><span id="l32.807" class="difflineplus">+        this._indexingIterator = null;</span>
<a href="#l32.808"></a><span id="l32.808" class="difflineplus">+        return this.kWorkAsync;</span>
<a href="#l32.809"></a><span id="l32.809" class="difflineplus">+      }</span>
<a href="#l32.810"></a><span id="l32.810" class="difflineplus">+      // we get an nsIMsgDatabase out of this (unsurprisingly) which</span>
<a href="#l32.811"></a><span id="l32.811" class="difflineplus">+      //  explicitly inherits from nsIDBChangeAnnouncer, which has the</span>
<a href="#l32.812"></a><span id="l32.812" class="difflineplus">+      //  AddListener call we want.</span>
<a href="#l32.813"></a><span id="l32.813" class="difflineplus">+      if (this._indexingDatabase == null)</span>
<a href="#l32.814"></a><span id="l32.814" class="difflineplus">+        this._indexingDatabase = folder.getMsgDatabase(null);</span>
<a href="#l32.815"></a><span id="l32.815" class="difflineplus">+      if (aNeedIterator)</span>
<a href="#l32.816"></a><span id="l32.816" class="difflineplus">+        this._indexerGetIterator();</span>
<a href="#l32.817"></a><span id="l32.817" class="difflineplus">+      this._indexingDatabase.AddListener(this._databaseAnnouncerListener);</span>
<a href="#l32.818"></a><span id="l32.818" class="difflineplus">+    }</span>
<a href="#l32.819"></a><span id="l32.819" class="difflineplus">+    catch (ex) {</span>
<a href="#l32.820"></a><span id="l32.820" class="difflineplus">+      this._log.error(&quot;Problem entering folder: &quot; +</span>
<a href="#l32.821"></a><span id="l32.821" class="difflineplus">+                      folder.prettiestName + &quot;, skipping.&quot;);</span>
<a href="#l32.822"></a><span id="l32.822" class="difflineplus">+      this._log.error(&quot;Error was: &quot; + ex);</span>
<a href="#l32.823"></a><span id="l32.823" class="difflineplus">+      this._indexingFolder = null;</span>
<a href="#l32.824"></a><span id="l32.824" class="difflineplus">+      this._indexingFolderID = null;</span>
<a href="#l32.825"></a><span id="l32.825" class="difflineplus">+      this._indexingDatabase = null;</span>
<a href="#l32.826"></a><span id="l32.826" class="difflineplus">+      this._indexingIterator = null;</span>
<a href="#l32.827"></a><span id="l32.827" class="difflineplus">+      </span>
<a href="#l32.828"></a><span id="l32.828" class="difflineplus">+      // re-throw, we just wanted to make sure this junk is cleaned up and</span>
<a href="#l32.829"></a><span id="l32.829" class="difflineplus">+      //  get localized error logging...</span>
<a href="#l32.830"></a><span id="l32.830" class="difflineplus">+      throw ex;</span>
<a href="#l32.831"></a><span id="l32.831" class="difflineplus">+    }</span>
<a href="#l32.832"></a><span id="l32.832" class="difflineplus">+    </span>
<a href="#l32.833"></a><span id="l32.833" class="difflineplus">+    return this.kWorkSync;</span>
<a href="#l32.834"></a><span id="l32.834" class="difflineplus">+  },</span>
<a href="#l32.835"></a><span id="l32.835" class="difflineplus">+  </span>
<a href="#l32.836"></a><span id="l32.836" class="difflineplus">+  _indexerGetIterator: function gloda_indexer_indexerGetIterator() {</span>
<a href="#l32.837"></a><span id="l32.837" class="difflineplus">+    this._indexingIterator = fixIterator(</span>
<a href="#l32.838"></a><span id="l32.838" class="difflineplus">+                               this._indexingDatabase.EnumerateMessages(),</span>
<a href="#l32.839"></a><span id="l32.839" class="difflineplus">+                               Ci.nsIMsgDBHdr);</span>
<a href="#l32.840"></a><span id="l32.840" class="difflineplus">+  },</span>
<a href="#l32.841"></a><span id="l32.841" class="difflineplus">+  </span>
<a href="#l32.842"></a><span id="l32.842" class="difflineplus">+  _indexerLeaveFolder: function gloda_index_indexerLeaveFolder(aExpected) {</span>
<a href="#l32.843"></a><span id="l32.843" class="difflineplus">+    if (this._indexingFolder !== null) {</span>
<a href="#l32.844"></a><span id="l32.844" class="difflineplus">+      // remove our listener!</span>
<a href="#l32.845"></a><span id="l32.845" class="difflineplus">+      this._indexingDatabase.RemoveListener(this._databaseAnnouncerListener);</span>
<a href="#l32.846"></a><span id="l32.846" class="difflineplus">+      // null everyone out</span>
<a href="#l32.847"></a><span id="l32.847" class="difflineplus">+      this._indexingFolder = null;</span>
<a href="#l32.848"></a><span id="l32.848" class="difflineplus">+      this._indexingFolderID = null;</span>
<a href="#l32.849"></a><span id="l32.849" class="difflineplus">+      this._indexingDatabase = null;</span>
<a href="#l32.850"></a><span id="l32.850" class="difflineplus">+      this._indexingIterator = null;</span>
<a href="#l32.851"></a><span id="l32.851" class="difflineplus">+      // ...including the active job:</span>
<a href="#l32.852"></a><span id="l32.852" class="difflineplus">+      this._curIndexingJob = null;</span>
<a href="#l32.853"></a><span id="l32.853" class="difflineplus">+    }</span>
<a href="#l32.854"></a><span id="l32.854" class="difflineplus">+  },</span>
<a href="#l32.855"></a><span id="l32.855" class="difflineplus">+  </span>
<a href="#l32.856"></a><span id="l32.856" class="difflineplus">+  /**</span>
<a href="#l32.857"></a><span id="l32.857" class="difflineplus">+   * Event fed to us by our nsIFolderListener when a folder is loaded.  We use</span>
<a href="#l32.858"></a><span id="l32.858" class="difflineplus">+   *  this event to two ends:</span>
<a href="#l32.859"></a><span id="l32.859" class="difflineplus">+   *</span>
<a href="#l32.860"></a><span id="l32.860" class="difflineplus">+   * - Know when a folder we were trying to open to index is actually ready to</span>
<a href="#l32.861"></a><span id="l32.861" class="difflineplus">+   *   be indexed.  (The summary may have not existed, may have been out of</span>
<a href="#l32.862"></a><span id="l32.862" class="difflineplus">+   *   date, or otherwise.)</span>
<a href="#l32.863"></a><span id="l32.863" class="difflineplus">+   * - Know when </span>
<a href="#l32.864"></a><span id="l32.864" class="difflineplus">+   *</span>
<a href="#l32.865"></a><span id="l32.865" class="difflineplus">+   * @param aFolder An nsIMsgFolder, already QI'd.</span>
<a href="#l32.866"></a><span id="l32.866" class="difflineplus">+   */</span>
<a href="#l32.867"></a><span id="l32.867" class="difflineplus">+  _onFolderLoaded: function gloda_index_onFolderLoaded(aFolder) {</span>
<a href="#l32.868"></a><span id="l32.868" class="difflineplus">+    if ((this._pendingFolderEntry !== null) &amp;&amp;</span>
<a href="#l32.869"></a><span id="l32.869" class="difflineplus">+        (aFolder.URI == this._pendingFolderEntry.URI)) {</span>
<a href="#l32.870"></a><span id="l32.870" class="difflineplus">+      this._log.debug(&quot;...Folder Loaded!&quot;);</span>
<a href="#l32.871"></a><span id="l32.871" class="difflineplus">+      this._pendingFolderEntry = null;</span>
<a href="#l32.872"></a><span id="l32.872" class="difflineplus">+      this.callbackDriver();</span>
<a href="#l32.873"></a><span id="l32.873" class="difflineplus">+    }</span>
<a href="#l32.874"></a><span id="l32.874" class="difflineplus">+  },</span>
<a href="#l32.875"></a><span id="l32.875" class="difflineplus">+  </span>
<a href="#l32.876"></a><span id="l32.876" class="difflineplus">+  /**</span>
<a href="#l32.877"></a><span id="l32.877" class="difflineplus">+   * A simple wrapper to make 'this' be right for incrementalIndex.</span>
<a href="#l32.878"></a><span id="l32.878" class="difflineplus">+   */</span>
<a href="#l32.879"></a><span id="l32.879" class="difflineplus">+  _wrapCallbackDriver: function gloda_index_wrapCallbackDriver() {</span>
<a href="#l32.880"></a><span id="l32.880" class="difflineplus">+    GlodaIndexer.callbackDriver();</span>
<a href="#l32.881"></a><span id="l32.881" class="difflineplus">+  },</span>
<a href="#l32.882"></a><span id="l32.882" class="difflineplus">+</span>
<a href="#l32.883"></a><span id="l32.883" class="difflineplus">+  /**</span>
<a href="#l32.884"></a><span id="l32.884" class="difflineplus">+   * The current processing 'batch' generator, produced by a call to workBatch()</span>
<a href="#l32.885"></a><span id="l32.885" class="difflineplus">+   *  and used by callbackDriver to drive execution.</span>
<a href="#l32.886"></a><span id="l32.886" class="difflineplus">+   */</span>
<a href="#l32.887"></a><span id="l32.887" class="difflineplus">+  _batch: null,</span>
<a href="#l32.888"></a><span id="l32.888" class="difflineplus">+  _inCallback: false,</span>
<a href="#l32.889"></a><span id="l32.889" class="difflineplus">+  _savedCallbackArgs: null,</span>
<a href="#l32.890"></a><span id="l32.890" class="difflineplus">+  /**</span>
<a href="#l32.891"></a><span id="l32.891" class="difflineplus">+   * The root work-driver.  callbackDriver creates workBatch generator instances</span>
<a href="#l32.892"></a><span id="l32.892" class="difflineplus">+   *  (stored in _batch) which run until they are done (kWorkDone) or they</span>
<a href="#l32.893"></a><span id="l32.893" class="difflineplus">+   *  (really the embedded _actualWorker) encounter something asynchronous.</span>
<a href="#l32.894"></a><span id="l32.894" class="difflineplus">+   *  The convention is that all the callback handlers end up calling us,</span>
<a href="#l32.895"></a><span id="l32.895" class="difflineplus">+   *  ensuring that control-flow properly resumes.  If the batch completes,</span>
<a href="#l32.896"></a><span id="l32.896" class="difflineplus">+   *  we re-schedule ourselves after a time delay (controlled by _indexInterval)</span>
<a href="#l32.897"></a><span id="l32.897" class="difflineplus">+   *  and return.  (We use one-shot timers because repeating-slack does not</span>
<a href="#l32.898"></a><span id="l32.898" class="difflineplus">+   *  know enough to deal with our (current) asynchronous nature.)</span>
<a href="#l32.899"></a><span id="l32.899" class="difflineplus">+   */</span>
<a href="#l32.900"></a><span id="l32.900" class="difflineplus">+  callbackDriver: function gloda_index_callbackDriver() {</span>
<a href="#l32.901"></a><span id="l32.901" class="difflineplus">+    // it is conceivable that someone we call will call something that in some</span>
<a href="#l32.902"></a><span id="l32.902" class="difflineplus">+    //  cases might be asynchronous, and in other cases immediately generate</span>
<a href="#l32.903"></a><span id="l32.903" class="difflineplus">+    //  events without returning.  In the interest of (stack-depth) sanity,</span>
<a href="#l32.904"></a><span id="l32.904" class="difflineplus">+    //  let's handle this by performing a minimal time-delay callback.</span>
<a href="#l32.905"></a><span id="l32.905" class="difflineplus">+    // this is also now a good thing sequencing-wise.  if we get our callback</span>
<a href="#l32.906"></a><span id="l32.906" class="difflineplus">+    //  with data before the underlying function has yielded, we obviously can't</span>
<a href="#l32.907"></a><span id="l32.907" class="difflineplus">+    //  cram the data in yet.  Our options in this case are to either mark the</span>
<a href="#l32.908"></a><span id="l32.908" class="difflineplus">+    //  fact that the callback has already happened and immediately return to</span>
<a href="#l32.909"></a><span id="l32.909" class="difflineplus">+    //  the iterator when it does bubble up the kWorkAsync, or we can do as we</span>
<a href="#l32.910"></a><span id="l32.910" class="difflineplus">+    //  have been doing, but save the </span>
<a href="#l32.911"></a><span id="l32.911" class="difflineplus">+    if (this._inCallback) {</span>
<a href="#l32.912"></a><span id="l32.912" class="difflineplus">+      this._savedCallbackArgs = arguments;</span>
<a href="#l32.913"></a><span id="l32.913" class="difflineplus">+      this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l32.914"></a><span id="l32.914" class="difflineplus">+                                   0,</span>
<a href="#l32.915"></a><span id="l32.915" class="difflineplus">+                                   Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l32.916"></a><span id="l32.916" class="difflineplus">+      return;</span>
<a href="#l32.917"></a><span id="l32.917" class="difflineplus">+    }</span>
<a href="#l32.918"></a><span id="l32.918" class="difflineplus">+    this._inCallback = true;</span>
<a href="#l32.919"></a><span id="l32.919" class="difflineplus">+</span>
<a href="#l32.920"></a><span id="l32.920" class="difflineplus">+    try {</span>
<a href="#l32.921"></a><span id="l32.921" class="difflineplus">+      if (this._batch === null)</span>
<a href="#l32.922"></a><span id="l32.922" class="difflineplus">+        this._batch = this.workBatch();</span>
<a href="#l32.923"></a><span id="l32.923" class="difflineplus">+      </span>
<a href="#l32.924"></a><span id="l32.924" class="difflineplus">+      // kWorkAsync, kWorkDone, kWorkPause are allowed out; kWorkSync is not</span>
<a href="#l32.925"></a><span id="l32.925" class="difflineplus">+      // On kWorkDone, we want to schedule another timer to fire on us if we are</span>
<a href="#l32.926"></a><span id="l32.926" class="difflineplus">+      //  not done indexing.  (On kWorkAsync, we don't care what happens, because</span>
<a href="#l32.927"></a><span id="l32.927" class="difflineplus">+      //  someone else will be receiving the callback, and they will call us when</span>
<a href="#l32.928"></a><span id="l32.928" class="difflineplus">+      //  they are done doing their thing.</span>
<a href="#l32.929"></a><span id="l32.929" class="difflineplus">+      let args;</span>
<a href="#l32.930"></a><span id="l32.930" class="difflineplus">+      if (this._savedCallbackArgs != null) {</span>
<a href="#l32.931"></a><span id="l32.931" class="difflineplus">+        args = this._savedCallbackArgs;</span>
<a href="#l32.932"></a><span id="l32.932" class="difflineplus">+        this._savedCallbackArgs = null;</span>
<a href="#l32.933"></a><span id="l32.933" class="difflineplus">+      }</span>
<a href="#l32.934"></a><span id="l32.934" class="difflineplus">+      else</span>
<a href="#l32.935"></a><span id="l32.935" class="difflineplus">+        args = arguments; //Array.slice.call(arguments);</span>
<a href="#l32.936"></a><span id="l32.936" class="difflineplus">+      </span>
<a href="#l32.937"></a><span id="l32.937" class="difflineplus">+      let result;</span>
<a href="#l32.938"></a><span id="l32.938" class="difflineplus">+      if (args.length == 0)</span>
<a href="#l32.939"></a><span id="l32.939" class="difflineplus">+        result = this._batch.next();</span>
<a href="#l32.940"></a><span id="l32.940" class="difflineplus">+      else if (args.length == 1)</span>
<a href="#l32.941"></a><span id="l32.941" class="difflineplus">+        result = this._batch.send(args[0]);</span>
<a href="#l32.942"></a><span id="l32.942" class="difflineplus">+      else // arguments works with destructuring assignment</span>
<a href="#l32.943"></a><span id="l32.943" class="difflineplus">+        result = this._batch.send(args);</span>
<a href="#l32.944"></a><span id="l32.944" class="difflineplus">+      switch (result) {</span>
<a href="#l32.945"></a><span id="l32.945" class="difflineplus">+        // job's done, close the batch and re-schedule ourselves if there's more</span>
<a href="#l32.946"></a><span id="l32.946" class="difflineplus">+        //  to do.</span>
<a href="#l32.947"></a><span id="l32.947" class="difflineplus">+        case this.kWorkDone:</span>
<a href="#l32.948"></a><span id="l32.948" class="difflineplus">+          this._batch.close();</span>
<a href="#l32.949"></a><span id="l32.949" class="difflineplus">+          this._batch = null;</span>
<a href="#l32.950"></a><span id="l32.950" class="difflineplus">+          // (intentional fall-through to re-scheduling logic) </span>
<a href="#l32.951"></a><span id="l32.951" class="difflineplus">+        // the batch wants to get re-scheduled, do so.</span>
<a href="#l32.952"></a><span id="l32.952" class="difflineplus">+        case this.kWorkPause:</span>
<a href="#l32.953"></a><span id="l32.953" class="difflineplus">+          if (this.indexing)</span>
<a href="#l32.954"></a><span id="l32.954" class="difflineplus">+            this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l32.955"></a><span id="l32.955" class="difflineplus">+                                         this._indexInterval,</span>
<a href="#l32.956"></a><span id="l32.956" class="difflineplus">+                                         Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l32.957"></a><span id="l32.957" class="difflineplus">+          else // it's important to indicate no more callbacks are in flight</span>
<a href="#l32.958"></a><span id="l32.958" class="difflineplus">+            this._indexingActive = false;</span>
<a href="#l32.959"></a><span id="l32.959" class="difflineplus">+          break;</span>
<a href="#l32.960"></a><span id="l32.960" class="difflineplus">+        case this.kWorkAsync:</span>
<a href="#l32.961"></a><span id="l32.961" class="difflineplus">+          // there is nothing to do.  some other code is now responsible for</span>
<a href="#l32.962"></a><span id="l32.962" class="difflineplus">+          //  calling us.</span>
<a href="#l32.963"></a><span id="l32.963" class="difflineplus">+          break;</span>
<a href="#l32.964"></a><span id="l32.964" class="difflineplus">+      }</span>
<a href="#l32.965"></a><span id="l32.965" class="difflineplus">+    }</span>
<a href="#l32.966"></a><span id="l32.966" class="difflineplus">+    finally {    </span>
<a href="#l32.967"></a><span id="l32.967" class="difflineplus">+      this._inCallback = false;</span>
<a href="#l32.968"></a><span id="l32.968" class="difflineplus">+    }</span>
<a href="#l32.969"></a><span id="l32.969" class="difflineplus">+  },</span>
<a href="#l32.970"></a><span id="l32.970" class="difflineplus">+</span>
<a href="#l32.971"></a><span id="l32.971" class="difflineplus">+  _callbackHandle: {</span>
<a href="#l32.972"></a><span id="l32.972" class="difflineplus">+    init: function gloda_index_callbackhandle_init() {</span>
<a href="#l32.973"></a><span id="l32.973" class="difflineplus">+      this.wrappedCallback = GlodaIndexer._wrapCallbackDriver;</span>
<a href="#l32.974"></a><span id="l32.974" class="difflineplus">+      this.callbackThis = GlodaIndexer;</span>
<a href="#l32.975"></a><span id="l32.975" class="difflineplus">+      this.callback = GlodaIndexer.callbackDriver;</span>
<a href="#l32.976"></a><span id="l32.976" class="difflineplus">+    },</span>
<a href="#l32.977"></a><span id="l32.977" class="difflineplus">+    activeStack: [],</span>
<a href="#l32.978"></a><span id="l32.978" class="difflineplus">+    activeIterator: null,</span>
<a href="#l32.979"></a><span id="l32.979" class="difflineplus">+    push: function gloda_index_callbackhandle_push(aIterator) {</span>
<a href="#l32.980"></a><span id="l32.980" class="difflineplus">+      this.activeStack.push(aIterator);</span>
<a href="#l32.981"></a><span id="l32.981" class="difflineplus">+      this.activeIterator = aIterator;</span>
<a href="#l32.982"></a><span id="l32.982" class="difflineplus">+    },</span>
<a href="#l32.983"></a><span id="l32.983" class="difflineplus">+    pushAndGo: function gloda_index_callbackhandle_pushAndGo(aIterator) {</span>
<a href="#l32.984"></a><span id="l32.984" class="difflineplus">+      this.push(aIterator);</span>
<a href="#l32.985"></a><span id="l32.985" class="difflineplus">+      return this.activeIterator.next();</span>
<a href="#l32.986"></a><span id="l32.986" class="difflineplus">+    },</span>
<a href="#l32.987"></a><span id="l32.987" class="difflineplus">+    pop: function gloda_index_callbackhandle_pop() {</span>
<a href="#l32.988"></a><span id="l32.988" class="difflineplus">+      this.activeIterator.close();</span>
<a href="#l32.989"></a><span id="l32.989" class="difflineplus">+      this.activeStack.pop();</span>
<a href="#l32.990"></a><span id="l32.990" class="difflineplus">+      if (this.activeStack.length)</span>
<a href="#l32.991"></a><span id="l32.991" class="difflineplus">+        this.activeIterator = this.activeStack[this.activeStack.length - 1];</span>
<a href="#l32.992"></a><span id="l32.992" class="difflineplus">+      else</span>
<a href="#l32.993"></a><span id="l32.993" class="difflineplus">+        this.activeIterator = null;</span>
<a href="#l32.994"></a><span id="l32.994" class="difflineplus">+    },</span>
<a href="#l32.995"></a><span id="l32.995" class="difflineplus">+    /**</span>
<a href="#l32.996"></a><span id="l32.996" class="difflineplus">+     * Someone propagated an exception and we need to clean-up all the active</span>
<a href="#l32.997"></a><span id="l32.997" class="difflineplus">+     *  logic as best we can.  Which is not really all that well.</span>
<a href="#l32.998"></a><span id="l32.998" class="difflineplus">+     */</span>
<a href="#l32.999"></a><span id="l32.999" class="difflineplus">+    cleanup: function gloda_index_callbackhandle_cleanup() {</span>
<a href="#l32.1000"></a><span id="l32.1000" class="difflineplus">+      while (this.activeIterator !== null) {</span>
<a href="#l32.1001"></a><span id="l32.1001" class="difflineplus">+        this.pop();</span>
<a href="#l32.1002"></a><span id="l32.1002" class="difflineplus">+      }</span>
<a href="#l32.1003"></a><span id="l32.1003" class="difflineplus">+    },</span>
<a href="#l32.1004"></a><span id="l32.1004" class="difflineplus">+    popWithResult: function gloda_index_callbackhandle_popWithResult() {</span>
<a href="#l32.1005"></a><span id="l32.1005" class="difflineplus">+      this.pop();</span>
<a href="#l32.1006"></a><span id="l32.1006" class="difflineplus">+      let result = this._result;</span>
<a href="#l32.1007"></a><span id="l32.1007" class="difflineplus">+      this._result = null;</span>
<a href="#l32.1008"></a><span id="l32.1008" class="difflineplus">+      return result;</span>
<a href="#l32.1009"></a><span id="l32.1009" class="difflineplus">+    },</span>
<a href="#l32.1010"></a><span id="l32.1010" class="difflineplus">+    _result: null,</span>
<a href="#l32.1011"></a><span id="l32.1011" class="difflineplus">+    doneWithResult: function gloda_index_callbackhandle_doneWithResult(aResult){</span>
<a href="#l32.1012"></a><span id="l32.1012" class="difflineplus">+      this._result = aResult;</span>
<a href="#l32.1013"></a><span id="l32.1013" class="difflineplus">+      return Gloda.kWorkDoneWithResult;</span>
<a href="#l32.1014"></a><span id="l32.1014" class="difflineplus">+    },</span>
<a href="#l32.1015"></a><span id="l32.1015" class="difflineplus">+    </span>
<a href="#l32.1016"></a><span id="l32.1016" class="difflineplus">+    /* be able to serve as a collection listener, resuming the active iterator's</span>
<a href="#l32.1017"></a><span id="l32.1017" class="difflineplus">+       last yield kWorkAsync */</span>
<a href="#l32.1018"></a><span id="l32.1018" class="difflineplus">+    onItemsAdded: function() {},</span>
<a href="#l32.1019"></a><span id="l32.1019" class="difflineplus">+    onItemsModified: function() {},</span>
<a href="#l32.1020"></a><span id="l32.1020" class="difflineplus">+    onItemsRemoved: function() {},</span>
<a href="#l32.1021"></a><span id="l32.1021" class="difflineplus">+    onQueryCompleted: function(aCollection) {</span>
<a href="#l32.1022"></a><span id="l32.1022" class="difflineplus">+      GlodaIndexer.callbackDriver();</span>
<a href="#l32.1023"></a><span id="l32.1023" class="difflineplus">+    }</span>
<a href="#l32.1024"></a><span id="l32.1024" class="difflineplus">+  },</span>
<a href="#l32.1025"></a><span id="l32.1025" class="difflineplus">+  _forceGCCounter: 0,</span>
<a href="#l32.1026"></a><span id="l32.1026" class="difflineplus">+  FORCE_GC_THRESHOLD: 256,</span>
<a href="#l32.1027"></a><span id="l32.1027" class="difflineplus">+  _workBatchData: undefined,</span>
<a href="#l32.1028"></a><span id="l32.1028" class="difflineplus">+  /**</span>
<a href="#l32.1029"></a><span id="l32.1029" class="difflineplus">+   * The workBatch generator handles a single 'batch' of processing, managing</span>
<a href="#l32.1030"></a><span id="l32.1030" class="difflineplus">+   *  the database transaction and keeping track of &quot;tokens&quot;.  It drives the</span>
<a href="#l32.1031"></a><span id="l32.1031" class="difflineplus">+   *  _actualWorker generator which is doing the work.</span>
<a href="#l32.1032"></a><span id="l32.1032" class="difflineplus">+   * workBatch will only produce kWorkAsync and kWorkDone notifications.</span>
<a href="#l32.1033"></a><span id="l32.1033" class="difflineplus">+   *  If _actualWorker returns kWorkSync and there are still tokens available,</span>
<a href="#l32.1034"></a><span id="l32.1034" class="difflineplus">+   *  workBatch will keep driving _actualWorker until it encounters a</span>
<a href="#l32.1035"></a><span id="l32.1035" class="difflineplus">+   *  kWorkAsync (which workBatch will yield to callbackDriver), or it runs</span>
<a href="#l32.1036"></a><span id="l32.1036" class="difflineplus">+   *  out of tokens and yields a kWorkDone. </span>
<a href="#l32.1037"></a><span id="l32.1037" class="difflineplus">+   */</span>
<a href="#l32.1038"></a><span id="l32.1038" class="difflineplus">+  workBatch: function gloda_index_workBatch() {</span>
<a href="#l32.1039"></a><span id="l32.1039" class="difflineplus">+    let commitTokens = this._indexCommitTokens;</span>
<a href="#l32.1040"></a><span id="l32.1040" class="difflineplus">+    GlodaDatastore._beginTransaction();</span>
<a href="#l32.1041"></a><span id="l32.1041" class="difflineplus">+</span>
<a href="#l32.1042"></a><span id="l32.1042" class="difflineplus">+    while (commitTokens &gt; 0) {</span>
<a href="#l32.1043"></a><span id="l32.1043" class="difflineplus">+      for (let tokensLeft = this._indexTokens; tokensLeft &gt; 0;</span>
<a href="#l32.1044"></a><span id="l32.1044" class="difflineplus">+          tokensLeft--, commitTokens--) {</span>
<a href="#l32.1045"></a><span id="l32.1045" class="difflineplus">+        // we need to periodically force a GC to avoid excessive process size</span>
<a href="#l32.1046"></a><span id="l32.1046" class="difflineplus">+        //  and because nsAutoLock is a jerk on debug builds</span>
<a href="#l32.1047"></a><span id="l32.1047" class="difflineplus">+        if (++this._forceGCCounter &gt;= this.FORCE_GC_THRESHOLD) {</span>
<a href="#l32.1048"></a><span id="l32.1048" class="difflineplus">+          Cu.forceGC();</span>
<a href="#l32.1049"></a><span id="l32.1049" class="difflineplus">+          this._forceGCCounter = 0;</span>
<a href="#l32.1050"></a><span id="l32.1050" class="difflineplus">+        }</span>
<a href="#l32.1051"></a><span id="l32.1051" class="difflineplus">+        </span>
<a href="#l32.1052"></a><span id="l32.1052" class="difflineplus">+        if ((this._callbackHandle.activeIterator === null) &amp;&amp;</span>
<a href="#l32.1053"></a><span id="l32.1053" class="difflineplus">+            !this._hireJobWorker()) {</span>
<a href="#l32.1054"></a><span id="l32.1054" class="difflineplus">+          commitTokens = 0;</span>
<a href="#l32.1055"></a><span id="l32.1055" class="difflineplus">+          break;</span>
<a href="#l32.1056"></a><span id="l32.1056" class="difflineplus">+        }</span>
<a href="#l32.1057"></a><span id="l32.1057" class="difflineplus">+      </span>
<a href="#l32.1058"></a><span id="l32.1058" class="difflineplus">+        // XXX for performance, we may want to move the try outside the for loop</span>
<a href="#l32.1059"></a><span id="l32.1059" class="difflineplus">+        //  with a quasi-redundant outer loop that shunts control back inside</span>
<a href="#l32.1060"></a><span id="l32.1060" class="difflineplus">+        //  if we left the loop due to an exception (without consuming all the</span>
<a href="#l32.1061"></a><span id="l32.1061" class="difflineplus">+        //  tokens.)</span>
<a href="#l32.1062"></a><span id="l32.1062" class="difflineplus">+        try {</span>
<a href="#l32.1063"></a><span id="l32.1063" class="difflineplus">+          switch (this._callbackHandle.activeIterator.send(this._workBatchData)) {</span>
<a href="#l32.1064"></a><span id="l32.1064" class="difflineplus">+            case this.kWorkSync:</span>
<a href="#l32.1065"></a><span id="l32.1065" class="difflineplus">+              this._workBatchData = undefined;</span>
<a href="#l32.1066"></a><span id="l32.1066" class="difflineplus">+              break;</span>
<a href="#l32.1067"></a><span id="l32.1067" class="difflineplus">+            case this.kWorkAsync:</span>
<a href="#l32.1068"></a><span id="l32.1068" class="difflineplus">+              this._workBatchData = yield this.kWorkAsync;</span>
<a href="#l32.1069"></a><span id="l32.1069" class="difflineplus">+              break;</span>
<a href="#l32.1070"></a><span id="l32.1070" class="difflineplus">+            case this.kWorkDone:</span>
<a href="#l32.1071"></a><span id="l32.1071" class="difflineplus">+              this._callbackHandle.pop();</span>
<a href="#l32.1072"></a><span id="l32.1072" class="difflineplus">+              this._workBatchData = undefined;</span>
<a href="#l32.1073"></a><span id="l32.1073" class="difflineplus">+              tokensLeft++; // don't eat a token for this pass</span>
<a href="#l32.1074"></a><span id="l32.1074" class="difflineplus">+              break;</span>
<a href="#l32.1075"></a><span id="l32.1075" class="difflineplus">+            case this.kWorkDoneWithResult:</span>
<a href="#l32.1076"></a><span id="l32.1076" class="difflineplus">+              this._workBatchData = this._callbackHandle.popWithResult();</span>
<a href="#l32.1077"></a><span id="l32.1077" class="difflineplus">+              tokensLeft++; // don't eat a token for this pass</span>
<a href="#l32.1078"></a><span id="l32.1078" class="difflineplus">+              continue;</span>
<a href="#l32.1079"></a><span id="l32.1079" class="difflineplus">+          }</span>
<a href="#l32.1080"></a><span id="l32.1080" class="difflineplus">+        }</span>
<a href="#l32.1081"></a><span id="l32.1081" class="difflineplus">+        catch (ex) {</span>
<a href="#l32.1082"></a><span id="l32.1082" class="difflineplus">+          this._log.warn(&quot;Bailing on job (at &quot; + ex.fileName + &quot;:&quot; +</span>
<a href="#l32.1083"></a><span id="l32.1083" class="difflineplus">+              ex.lineNumber + &quot;) because: &quot; + ex);</span>
<a href="#l32.1084"></a><span id="l32.1084" class="difflineplus">+          // make sure we no longer have a current folder</span>
<a href="#l32.1085"></a><span id="l32.1085" class="difflineplus">+          this._indexerLeaveFolder(true);</span>
<a href="#l32.1086"></a><span id="l32.1086" class="difflineplus">+          this._curIndexingJob = null;</span>
<a href="#l32.1087"></a><span id="l32.1087" class="difflineplus">+          // clear out our current generators and our related data</span>
<a href="#l32.1088"></a><span id="l32.1088" class="difflineplus">+          this._callbackHandle.cleanup();</span>
<a href="#l32.1089"></a><span id="l32.1089" class="difflineplus">+          this._workBatchData = undefined;</span>
<a href="#l32.1090"></a><span id="l32.1090" class="difflineplus">+        }</span>
<a href="#l32.1091"></a><span id="l32.1091" class="difflineplus">+      }</span>
<a href="#l32.1092"></a><span id="l32.1092" class="difflineplus">+      </span>
<a href="#l32.1093"></a><span id="l32.1093" class="difflineplus">+      // take a breather by having the caller re-schedule us sometime in the</span>
<a href="#l32.1094"></a><span id="l32.1094" class="difflineplus">+      //  future, but only if we're going to perform another loop iteration.</span>
<a href="#l32.1095"></a><span id="l32.1095" class="difflineplus">+      if (commitTokens &gt; 0)</span>
<a href="#l32.1096"></a><span id="l32.1096" class="difflineplus">+        yield this.kWorkPause;</span>
<a href="#l32.1097"></a><span id="l32.1097" class="difflineplus">+    }</span>
<a href="#l32.1098"></a><span id="l32.1098" class="difflineplus">+    // XXX doing the dirty commit/check every time could be pretty expensive...</span>
<a href="#l32.1099"></a><span id="l32.1099" class="difflineplus">+    GlodaCollectionManager.cacheCommitDirty();</span>
<a href="#l32.1100"></a><span id="l32.1100" class="difflineplus">+    GlodaDatastore._commitTransaction();</span>
<a href="#l32.1101"></a><span id="l32.1101" class="difflineplus">+    </span>
<a href="#l32.1102"></a><span id="l32.1102" class="difflineplus">+    // try and get a job if we don't have one for the sake of the notification</span>
<a href="#l32.1103"></a><span id="l32.1103" class="difflineplus">+    if (this.indexing &amp;&amp; (this._actualWorker === null))</span>
<a href="#l32.1104"></a><span id="l32.1104" class="difflineplus">+      this._hireJobWorker();</span>
<a href="#l32.1105"></a><span id="l32.1105" class="difflineplus">+    this._notifyListeners();</span>
<a href="#l32.1106"></a><span id="l32.1106" class="difflineplus">+    </span>
<a href="#l32.1107"></a><span id="l32.1107" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l32.1108"></a><span id="l32.1108" class="difflineplus">+  },</span>
<a href="#l32.1109"></a><span id="l32.1109" class="difflineplus">+</span>
<a href="#l32.1110"></a><span id="l32.1110" class="difflineplus">+  _otherIndexerWorkers: {},</span>
<a href="#l32.1111"></a><span id="l32.1111" class="difflineplus">+  /**</span>
<a href="#l32.1112"></a><span id="l32.1112" class="difflineplus">+   * Perform the initialization step and return a generator if there is any</span>
<a href="#l32.1113"></a><span id="l32.1113" class="difflineplus">+   *  steady-state processing to be had.</span>
<a href="#l32.1114"></a><span id="l32.1114" class="difflineplus">+   */</span>
<a href="#l32.1115"></a><span id="l32.1115" class="difflineplus">+  _hireJobWorker: function gloda_index_hireJobWorker() {</span>
<a href="#l32.1116"></a><span id="l32.1116" class="difflineplus">+    if (this._indexQueue.length == 0) {</span>
<a href="#l32.1117"></a><span id="l32.1117" class="difflineplus">+      this._log.info(&quot;--- Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l32.1118"></a><span id="l32.1118" class="difflineplus">+      </span>
<a href="#l32.1119"></a><span id="l32.1119" class="difflineplus">+      if (this._indexingFolder !== null) {</span>
<a href="#l32.1120"></a><span id="l32.1120" class="difflineplus">+        this._indexerLeaveFolder(true);</span>
<a href="#l32.1121"></a><span id="l32.1121" class="difflineplus">+      }</span>
<a href="#l32.1122"></a><span id="l32.1122" class="difflineplus">+      </span>
<a href="#l32.1123"></a><span id="l32.1123" class="difflineplus">+      this._curIndexingJob = null;</span>
<a href="#l32.1124"></a><span id="l32.1124" class="difflineplus">+      this._indexingDesired = false;</span>
<a href="#l32.1125"></a><span id="l32.1125" class="difflineplus">+      this._indexingJobCount = 0;</span>
<a href="#l32.1126"></a><span id="l32.1126" class="difflineplus">+      this._indexingJobGoal = 0;</span>
<a href="#l32.1127"></a><span id="l32.1127" class="difflineplus">+      return false;</span>
<a href="#l32.1128"></a><span id="l32.1128" class="difflineplus">+    }</span>
<a href="#l32.1129"></a><span id="l32.1129" class="difflineplus">+</span>
<a href="#l32.1130"></a><span id="l32.1130" class="difflineplus">+    //this._log.debug(&quot;++ Pulling job from queue of size &quot; +</span>
<a href="#l32.1131"></a><span id="l32.1131" class="difflineplus">+    //                this._indexQueue.length);</span>
<a href="#l32.1132"></a><span id="l32.1132" class="difflineplus">+    let job = this._curIndexingJob = this._indexQueue.shift();</span>
<a href="#l32.1133"></a><span id="l32.1133" class="difflineplus">+    this._indexingJobCount++;</span>
<a href="#l32.1134"></a><span id="l32.1134" class="difflineplus">+    //this._log.debug(&quot;++ Pulled job: &quot; + job.jobType + &quot;, &quot; +</span>
<a href="#l32.1135"></a><span id="l32.1135" class="difflineplus">+    //                job.deltaType + &quot;, &quot; + job.id);</span>
<a href="#l32.1136"></a><span id="l32.1136" class="difflineplus">+    let generator = null;</span>
<a href="#l32.1137"></a><span id="l32.1137" class="difflineplus">+    </span>
<a href="#l32.1138"></a><span id="l32.1138" class="difflineplus">+    if (job.jobType == &quot;sweep&quot;) {</span>
<a href="#l32.1139"></a><span id="l32.1139" class="difflineplus">+      generator = this._worker_indexingSweep(job);</span>
<a href="#l32.1140"></a><span id="l32.1140" class="difflineplus">+    }</span>
<a href="#l32.1141"></a><span id="l32.1141" class="difflineplus">+    else if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l32.1142"></a><span id="l32.1142" class="difflineplus">+      generator = this._worker_folderIndex(job);</span>
<a href="#l32.1143"></a><span id="l32.1143" class="difflineplus">+    }</span>
<a href="#l32.1144"></a><span id="l32.1144" class="difflineplus">+    else if(job.jobType == &quot;message&quot;) {</span>
<a href="#l32.1145"></a><span id="l32.1145" class="difflineplus">+      if (job === this._pendingAddJob)</span>
<a href="#l32.1146"></a><span id="l32.1146" class="difflineplus">+        this._pendingAddJob = null;</span>
<a href="#l32.1147"></a><span id="l32.1147" class="difflineplus">+      // update our goal from the items length</span>
<a href="#l32.1148"></a><span id="l32.1148" class="difflineplus">+      job.goal = job.items.length;</span>
<a href="#l32.1149"></a><span id="l32.1149" class="difflineplus">+                  </span>
<a href="#l32.1150"></a><span id="l32.1150" class="difflineplus">+      generator = this._worker_messageIndex(job);</span>
<a href="#l32.1151"></a><span id="l32.1151" class="difflineplus">+    }</span>
<a href="#l32.1152"></a><span id="l32.1152" class="difflineplus">+    else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l32.1153"></a><span id="l32.1153" class="difflineplus">+      // we'll count the block processing as a cost of 1...</span>
<a href="#l32.1154"></a><span id="l32.1154" class="difflineplus">+      job.goal = 1;</span>
<a href="#l32.1155"></a><span id="l32.1155" class="difflineplus">+      generator = this._worker_processDeletes(job);</span>
<a href="#l32.1156"></a><span id="l32.1156" class="difflineplus">+    }</span>
<a href="#l32.1157"></a><span id="l32.1157" class="difflineplus">+    else if (job.jobType in this._otherIndexerWorkers) {</span>
<a href="#l32.1158"></a><span id="l32.1158" class="difflineplus">+      let [indexer, workerFunc] = this._otherIndexerWorkers[job.jobType];</span>
<a href="#l32.1159"></a><span id="l32.1159" class="difflineplus">+      generator = workerFunc.call(indexer, job, this._callbackHandle);</span>
<a href="#l32.1160"></a><span id="l32.1160" class="difflineplus">+    }</span>
<a href="#l32.1161"></a><span id="l32.1161" class="difflineplus">+    else {</span>
<a href="#l32.1162"></a><span id="l32.1162" class="difflineplus">+      this._log.warning(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l32.1163"></a><span id="l32.1163" class="difflineplus">+    }</span>
<a href="#l32.1164"></a><span id="l32.1164" class="difflineplus">+    </span>
<a href="#l32.1165"></a><span id="l32.1165" class="difflineplus">+    if (generator) {</span>
<a href="#l32.1166"></a><span id="l32.1166" class="difflineplus">+      this._callbackHandle.push(generator);</span>
<a href="#l32.1167"></a><span id="l32.1167" class="difflineplus">+      return true;</span>
<a href="#l32.1168"></a><span id="l32.1168" class="difflineplus">+    }</span>
<a href="#l32.1169"></a><span id="l32.1169" class="difflineplus">+    else</span>
<a href="#l32.1170"></a><span id="l32.1170" class="difflineplus">+      return false;</span>
<a href="#l32.1171"></a><span id="l32.1171" class="difflineplus">+  },</span>
<a href="#l32.1172"></a><span id="l32.1172" class="difflineplus">+</span>
<a href="#l32.1173"></a><span id="l32.1173" class="difflineplus">+  /**</span>
<a href="#l32.1174"></a><span id="l32.1174" class="difflineplus">+   * Performs the folder sweep, locating folders that should be indexed, and</span>
<a href="#l32.1175"></a><span id="l32.1175" class="difflineplus">+   *  creating a folder indexing job for them, and rescheduling itself for</span>
<a href="#l32.1176"></a><span id="l32.1176" class="difflineplus">+   *  execution after that job is completed.  Once it indexes all the folders,</span>
<a href="#l32.1177"></a><span id="l32.1177" class="difflineplus">+   *  if we believe we have deletions to process (or just don't know), it kicks</span>
<a href="#l32.1178"></a><span id="l32.1178" class="difflineplus">+   *  off a deletion processing job.</span>
<a href="#l32.1179"></a><span id="l32.1179" class="difflineplus">+   *</span>
<a href="#l32.1180"></a><span id="l32.1180" class="difflineplus">+   * Folder traversal logic is based off the spotlight/vista indexer code; we</span>
<a href="#l32.1181"></a><span id="l32.1181" class="difflineplus">+   *  retrieve the list of servers and folders each time want to find a new</span>
<a href="#l32.1182"></a><span id="l32.1182" class="difflineplus">+   *  folder to index.  This avoids needing to maintain a perfect model of the</span>
<a href="#l32.1183"></a><span id="l32.1183" class="difflineplus">+   *  folder hierarchy at all times.  (We may eventually want to do that, but</span>
<a href="#l32.1184"></a><span id="l32.1184" class="difflineplus">+   *  this is sufficient and safe for now.)  Although our use of dirty flags on</span>
<a href="#l32.1185"></a><span id="l32.1185" class="difflineplus">+   *  the folders allows us to avoid tracking the 'last folder' we processed,</span>
<a href="#l32.1186"></a><span id="l32.1186" class="difflineplus">+   *  we do so to avoid getting 'trapped' in a folder with a high rate of</span>
<a href="#l32.1187"></a><span id="l32.1187" class="difflineplus">+   *  changes.</span>
<a href="#l32.1188"></a><span id="l32.1188" class="difflineplus">+   */</span>
<a href="#l32.1189"></a><span id="l32.1189" class="difflineplus">+  _worker_indexingSweep: function gloda_worker_indexingSweep(aJob) {</span>
<a href="#l32.1190"></a><span id="l32.1190" class="difflineplus">+    // walk the folders</span>
<a href="#l32.1191"></a><span id="l32.1191" class="difflineplus">+    let accountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l32.1192"></a><span id="l32.1192" class="difflineplus">+                           getService(Ci.nsIMsgAccountManager);</span>
<a href="#l32.1193"></a><span id="l32.1193" class="difflineplus">+    let servers = accountManager.allServers;</span>
<a href="#l32.1194"></a><span id="l32.1194" class="difflineplus">+    let useNextFolder = false;</span>
<a href="#l32.1195"></a><span id="l32.1195" class="difflineplus">+    </span>
<a href="#l32.1196"></a><span id="l32.1196" class="difflineplus">+    if (aJob.lastFolderIndexedUri === undefined)</span>
<a href="#l32.1197"></a><span id="l32.1197" class="difflineplus">+      aJob.lastFolderIndexedUri = '';</span>
<a href="#l32.1198"></a><span id="l32.1198" class="difflineplus">+  </span>
<a href="#l32.1199"></a><span id="l32.1199" class="difflineplus">+    for (let i = 0; i &lt; servers.Count(); i++)</span>
<a href="#l32.1200"></a><span id="l32.1200" class="difflineplus">+    {</span>
<a href="#l32.1201"></a><span id="l32.1201" class="difflineplus">+      let server = servers.QueryElementAt(i, Ci.nsIMsgIncomingServer);</span>
<a href="#l32.1202"></a><span id="l32.1202" class="difflineplus">+      let rootFolder = server.rootFolder;</span>
<a href="#l32.1203"></a><span id="l32.1203" class="difflineplus">+</span>
<a href="#l32.1204"></a><span id="l32.1204" class="difflineplus">+      // ignore news accounts for now.</span>
<a href="#l32.1205"></a><span id="l32.1205" class="difflineplus">+      if (rootFolder.URI.indexOf('news://') == 0)</span>
<a href="#l32.1206"></a><span id="l32.1206" class="difflineplus">+        continue;</span>
<a href="#l32.1207"></a><span id="l32.1207" class="difflineplus">+      </span>
<a href="#l32.1208"></a><span id="l32.1208" class="difflineplus">+      let allFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l32.1209"></a><span id="l32.1209" class="difflineplus">+                         createInstance(Ci.nsISupportsArray);</span>
<a href="#l32.1210"></a><span id="l32.1210" class="difflineplus">+      rootFolder.ListDescendents(allFolders);</span>
<a href="#l32.1211"></a><span id="l32.1211" class="difflineplus">+      let numFolders = allFolders.Count();</span>
<a href="#l32.1212"></a><span id="l32.1212" class="difflineplus">+      for (let folderIndex = 0; folderIndex &lt; numFolders; folderIndex++)</span>
<a href="#l32.1213"></a><span id="l32.1213" class="difflineplus">+      {</span>
<a href="#l32.1214"></a><span id="l32.1214" class="difflineplus">+        let folder = allFolders.GetElementAt(folderIndex).QueryInterface(</span>
<a href="#l32.1215"></a><span id="l32.1215" class="difflineplus">+                                                            Ci.nsIMsgFolder);</span>
<a href="#l32.1216"></a><span id="l32.1216" class="difflineplus">+        // we could also check nsMsgFolderFlags.Mail conceivably...</span>
<a href="#l32.1217"></a><span id="l32.1217" class="difflineplus">+        let isLocal = folder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l32.1218"></a><span id="l32.1218" class="difflineplus">+        // we only index local folders or IMAP folders that are marked offline.</span>
<a href="#l32.1219"></a><span id="l32.1219" class="difflineplus">+        if (!isLocal &amp;&amp; !(folder.flags &amp; Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l32.1220"></a><span id="l32.1220" class="difflineplus">+          continue;</span>
<a href="#l32.1221"></a><span id="l32.1221" class="difflineplus">+</span>
<a href="#l32.1222"></a><span id="l32.1222" class="difflineplus">+        // if no folder was indexed (or the pref's not set), just use the first folder</span>
<a href="#l32.1223"></a><span id="l32.1223" class="difflineplus">+        if (!aJob.lastFolderIndexedUri || useNextFolder)</span>
<a href="#l32.1224"></a><span id="l32.1224" class="difflineplus">+        {</span>
<a href="#l32.1225"></a><span id="l32.1225" class="difflineplus">+          // make sure the folder is dirty before accepting this job...</span>
<a href="#l32.1226"></a><span id="l32.1226" class="difflineplus">+          let glodaFolder = GlodaDatastore._mapFolder(folder);</span>
<a href="#l32.1227"></a><span id="l32.1227" class="difflineplus">+          if (!glodaFolder.dirtyStatus)</span>
<a href="#l32.1228"></a><span id="l32.1228" class="difflineplus">+            continue;</span>
<a href="#l32.1229"></a><span id="l32.1229" class="difflineplus">+        </span>
<a href="#l32.1230"></a><span id="l32.1230" class="difflineplus">+          aJob.lastFolderIndexedUri = folder.URI;</span>
<a href="#l32.1231"></a><span id="l32.1231" class="difflineplus">+          this._indexingJobGoal += 2;</span>
<a href="#l32.1232"></a><span id="l32.1232" class="difflineplus">+          // add a job for the folder indexing</span>
<a href="#l32.1233"></a><span id="l32.1233" class="difflineplus">+          this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 0,</span>
<a href="#l32.1234"></a><span id="l32.1234" class="difflineplus">+              this._datastore._mapFolder(folder).id));</span>
<a href="#l32.1235"></a><span id="l32.1235" class="difflineplus">+          // re-schedule this job (although this worker will die)</span>
<a href="#l32.1236"></a><span id="l32.1236" class="difflineplus">+          this._indexQueue.push(aJob);</span>
<a href="#l32.1237"></a><span id="l32.1237" class="difflineplus">+          yield this.kWorkDone;</span>
<a href="#l32.1238"></a><span id="l32.1238" class="difflineplus">+        }</span>
<a href="#l32.1239"></a><span id="l32.1239" class="difflineplus">+        else</span>
<a href="#l32.1240"></a><span id="l32.1240" class="difflineplus">+        {</span>
<a href="#l32.1241"></a><span id="l32.1241" class="difflineplus">+          if (aJob.lastFolderIndexedUri == folder.URI)</span>
<a href="#l32.1242"></a><span id="l32.1242" class="difflineplus">+            useNextFolder = true;</span>
<a href="#l32.1243"></a><span id="l32.1243" class="difflineplus">+        }</span>
<a href="#l32.1244"></a><span id="l32.1244" class="difflineplus">+      }</span>
<a href="#l32.1245"></a><span id="l32.1245" class="difflineplus">+    }</span>
<a href="#l32.1246"></a><span id="l32.1246" class="difflineplus">+    </span>
<a href="#l32.1247"></a><span id="l32.1247" class="difflineplus">+    // consider deletion</span>
<a href="#l32.1248"></a><span id="l32.1248" class="difflineplus">+    if (this.pendingDeletion || this.pendingDeletion === null) {</span>
<a href="#l32.1249"></a><span id="l32.1249" class="difflineplus">+      this._indexingJobGoal++;</span>
<a href="#l32.1250"></a><span id="l32.1250" class="difflineplus">+      this._indexQueue.push(new IndexingJob(&quot;delete&quot;, 0, null));</span>
<a href="#l32.1251"></a><span id="l32.1251" class="difflineplus">+      // no need to set this.indexing to true, it must be true if we are here.</span>
<a href="#l32.1252"></a><span id="l32.1252" class="difflineplus">+    }</span>
<a href="#l32.1253"></a><span id="l32.1253" class="difflineplus">+    </span>
<a href="#l32.1254"></a><span id="l32.1254" class="difflineplus">+    // if this is our first sweep, give the other indexers a chance to do their</span>
<a href="#l32.1255"></a><span id="l32.1255" class="difflineplus">+    //  own initial sweep.  it's on them to schedule their own job if they have</span>
<a href="#l32.1256"></a><span id="l32.1256" class="difflineplus">+    //  a lot to do, but if they only have a little to do, they can get away</span>
<a href="#l32.1257"></a><span id="l32.1257" class="difflineplus">+    //  with it, as we yield a sync after each one.</span>
<a href="#l32.1258"></a><span id="l32.1258" class="difflineplus">+    if (!this._initialSweepPerformed) {</span>
<a href="#l32.1259"></a><span id="l32.1259" class="difflineplus">+      for each (let [iIndexer, indexer] in Iterator(this._otherIndexers)) {</span>
<a href="#l32.1260"></a><span id="l32.1260" class="difflineplus">+        try {</span>
<a href="#l32.1261"></a><span id="l32.1261" class="difflineplus">+          indexer.initialSweep();</span>
<a href="#l32.1262"></a><span id="l32.1262" class="difflineplus">+        }</span>
<a href="#l32.1263"></a><span id="l32.1263" class="difflineplus">+        catch (ex) {</span>
<a href="#l32.1264"></a><span id="l32.1264" class="difflineplus">+          this._log.warning(&quot;Helper indexer threw exception on initial sweep:&quot; +</span>
<a href="#l32.1265"></a><span id="l32.1265" class="difflineplus">+                            ex);</span>
<a href="#l32.1266"></a><span id="l32.1266" class="difflineplus">+        }</span>
<a href="#l32.1267"></a><span id="l32.1267" class="difflineplus">+        yield this.kWorkSync;</span>
<a href="#l32.1268"></a><span id="l32.1268" class="difflineplus">+      }</span>
<a href="#l32.1269"></a><span id="l32.1269" class="difflineplus">+      this._initialSweepPerformed = true;</span>
<a href="#l32.1270"></a><span id="l32.1270" class="difflineplus">+    }</span>
<a href="#l32.1271"></a><span id="l32.1271" class="difflineplus">+    </span>
<a href="#l32.1272"></a><span id="l32.1272" class="difflineplus">+    // we don't have any more work to do...</span>
<a href="#l32.1273"></a><span id="l32.1273" class="difflineplus">+    this._indexingSweepActive = false;</span>
<a href="#l32.1274"></a><span id="l32.1274" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l32.1275"></a><span id="l32.1275" class="difflineplus">+  },</span>
<a href="#l32.1276"></a><span id="l32.1276" class="difflineplus">+</span>
<a href="#l32.1277"></a><span id="l32.1277" class="difflineplus">+  /**</span>
<a href="#l32.1278"></a><span id="l32.1278" class="difflineplus">+   * Index the contents of a folder.</span>
<a href="#l32.1279"></a><span id="l32.1279" class="difflineplus">+   */</span>
<a href="#l32.1280"></a><span id="l32.1280" class="difflineplus">+  _worker_folderIndex: function gloda_worker_folderIndex(aJob) {</span>
<a href="#l32.1281"></a><span id="l32.1281" class="difflineplus">+    yield this._indexerEnterFolder(aJob.id, true);</span>
<a href="#l32.1282"></a><span id="l32.1282" class="difflineplus">+    aJob.goal = this._indexingFolder.getTotalMessages(false);</span>
<a href="#l32.1283"></a><span id="l32.1283" class="difflineplus">+    </span>
<a href="#l32.1284"></a><span id="l32.1284" class="difflineplus">+    // there is of course a cost to all this header investigation even if we</span>
<a href="#l32.1285"></a><span id="l32.1285" class="difflineplus">+    //  don't do something.  so we will yield with kWorkSync for every block. </span>
<a href="#l32.1286"></a><span id="l32.1286" class="difflineplus">+    const HEADER_CHECK_BLOCK_SIZE = 100;</span>
<a href="#l32.1287"></a><span id="l32.1287" class="difflineplus">+    </span>
<a href="#l32.1288"></a><span id="l32.1288" class="difflineplus">+    let isLocal = this._indexingFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l32.1289"></a><span id="l32.1289" class="difflineplus">+    // we can safely presume if we are here that this folder has been selected</span>
<a href="#l32.1290"></a><span id="l32.1290" class="difflineplus">+    //  for offline processing...</span>
<a href="#l32.1291"></a><span id="l32.1291" class="difflineplus">+</span>
<a href="#l32.1292"></a><span id="l32.1292" class="difflineplus">+    // Handle the filthy case.  A filthy folder may have misleading properties</span>
<a href="#l32.1293"></a><span id="l32.1293" class="difflineplus">+    //  on the message that claim the message is indexed.  They are misleading</span>
<a href="#l32.1294"></a><span id="l32.1294" class="difflineplus">+    //  because the database, for whatever reason, does not have the messages</span>
<a href="#l32.1295"></a><span id="l32.1295" class="difflineplus">+    //  (accurately) indexed.</span>
<a href="#l32.1296"></a><span id="l32.1296" class="difflineplus">+    // We need to walk all the messages and mark them filthy if they have a</span>
<a href="#l32.1297"></a><span id="l32.1297" class="difflineplus">+    //  dirty property.  Once we have done this, we can downgrade the folder's</span>
<a href="#l32.1298"></a><span id="l32.1298" class="difflineplus">+    //  dirty status to plain dirty.  We do this rather than trying to process</span>
<a href="#l32.1299"></a><span id="l32.1299" class="difflineplus">+    //  everyone in one go in a filthy context because if we have to terminate</span>
<a href="#l32.1300"></a><span id="l32.1300" class="difflineplus">+    //  indexing before we quit, we don't want to have to re-index messages next</span>
<a href="#l32.1301"></a><span id="l32.1301" class="difflineplus">+    //  time.  (This could even lead to never completing indexing in a</span>
<a href="#l32.1302"></a><span id="l32.1302" class="difflineplus">+    //  pathological situation.)</span>
<a href="#l32.1303"></a><span id="l32.1303" class="difflineplus">+    let glodaFolder = GlodaDatastore._mapFolder(this._indexingFolder);</span>
<a href="#l32.1304"></a><span id="l32.1304" class="difflineplus">+    if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy) {</span>
<a href="#l32.1305"></a><span id="l32.1305" class="difflineplus">+      let count = 0;</span>
<a href="#l32.1306"></a><span id="l32.1306" class="difflineplus">+      for (let msgHdr in this._indexingIterator) {</span>
<a href="#l32.1307"></a><span id="l32.1307" class="difflineplus">+        // we still need to avoid locking up the UI, pause periodically...</span>
<a href="#l32.1308"></a><span id="l32.1308" class="difflineplus">+        if (++count % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l32.1309"></a><span id="l32.1309" class="difflineplus">+          yield this.kWorkSync;</span>
<a href="#l32.1310"></a><span id="l32.1310" class="difflineplus">+        </span>
<a href="#l32.1311"></a><span id="l32.1311" class="difflineplus">+        let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l32.1312"></a><span id="l32.1312" class="difflineplus">+                             this.GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l32.1313"></a><span id="l32.1313" class="difflineplus">+        // if it has a gloda message id, we need to mark it filthy</span>
<a href="#l32.1314"></a><span id="l32.1314" class="difflineplus">+        if (glodaMessageId != 0)</span>
<a href="#l32.1315"></a><span id="l32.1315" class="difflineplus">+          msgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY,</span>
<a href="#l32.1316"></a><span id="l32.1316" class="difflineplus">+                                   this.kMessageFilthy);</span>
<a href="#l32.1317"></a><span id="l32.1317" class="difflineplus">+        // if it doesn't have a gloda message id, we will definitely index it,</span>
<a href="#l32.1318"></a><span id="l32.1318" class="difflineplus">+        //  so no action is required.</span>
<a href="#l32.1319"></a><span id="l32.1319" class="difflineplus">+      }</span>
<a href="#l32.1320"></a><span id="l32.1320" class="difflineplus">+      // this will automatically persist to the database</span>
<a href="#l32.1321"></a><span id="l32.1321" class="difflineplus">+      glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l32.1322"></a><span id="l32.1322" class="difflineplus">+      </span>
<a href="#l32.1323"></a><span id="l32.1323" class="difflineplus">+      // We used up the iterator, get a new one.</span>
<a href="#l32.1324"></a><span id="l32.1324" class="difflineplus">+      this._indexerGetIterator();</span>
<a href="#l32.1325"></a><span id="l32.1325" class="difflineplus">+    }</span>
<a href="#l32.1326"></a><span id="l32.1326" class="difflineplus">+    </span>
<a href="#l32.1327"></a><span id="l32.1327" class="difflineplus">+    for (let msgHdr in this._indexingIterator) {</span>
<a href="#l32.1328"></a><span id="l32.1328" class="difflineplus">+      // per above, we want to periodically release control while doing all</span>
<a href="#l32.1329"></a><span id="l32.1329" class="difflineplus">+      //  this header traversal/investigation.</span>
<a href="#l32.1330"></a><span id="l32.1330" class="difflineplus">+      if (++aJob.offset % HEADER_CHECK_BLOCK_SIZE == 0)</span>
<a href="#l32.1331"></a><span id="l32.1331" class="difflineplus">+        yield this.kWorkSync;</span>
<a href="#l32.1332"></a><span id="l32.1332" class="difflineplus">+      </span>
<a href="#l32.1333"></a><span id="l32.1333" class="difflineplus">+      if ((isLocal || (msgHdr.flags &amp; MSG_FLAG_OFFLINE)) &amp;&amp;</span>
<a href="#l32.1334"></a><span id="l32.1334" class="difflineplus">+          !(msgHdr.flags &amp; MSG_FLAG_EXPUNGED)) {</span>
<a href="#l32.1335"></a><span id="l32.1335" class="difflineplus">+        // this returns 0 when missing</span>
<a href="#l32.1336"></a><span id="l32.1336" class="difflineplus">+        let glodaMessageId = msgHdr.getUint32Property(</span>
<a href="#l32.1337"></a><span id="l32.1337" class="difflineplus">+                             this.GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l32.1338"></a><span id="l32.1338" class="difflineplus">+        </span>
<a href="#l32.1339"></a><span id="l32.1339" class="difflineplus">+        // if it has a gloda message id, it has been indexed, but it still</span>
<a href="#l32.1340"></a><span id="l32.1340" class="difflineplus">+        //  could be dirty.</span>
<a href="#l32.1341"></a><span id="l32.1341" class="difflineplus">+        if (glodaMessageId != 0) {</span>
<a href="#l32.1342"></a><span id="l32.1342" class="difflineplus">+          // (returns 0 when missing)</span>
<a href="#l32.1343"></a><span id="l32.1343" class="difflineplus">+          let isDirty = msgHdr.getUint32Property(this.GLODA_DIRTY_PROPERTY)!= 0;</span>
<a href="#l32.1344"></a><span id="l32.1344" class="difflineplus">+</span>
<a href="#l32.1345"></a><span id="l32.1345" class="difflineplus">+          // it's up to date if it's not dirty </span>
<a href="#l32.1346"></a><span id="l32.1346" class="difflineplus">+          if (!isDirty)</span>
<a href="#l32.1347"></a><span id="l32.1347" class="difflineplus">+            continue;</span>
<a href="#l32.1348"></a><span id="l32.1348" class="difflineplus">+        }</span>
<a href="#l32.1349"></a><span id="l32.1349" class="difflineplus">+        </span>
<a href="#l32.1350"></a><span id="l32.1350" class="difflineplus">+        this._log.debug(&quot;&gt;&gt;&gt;  _indexMessage&quot;);</span>
<a href="#l32.1351"></a><span id="l32.1351" class="difflineplus">+        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l32.1352"></a><span id="l32.1352" class="difflineplus">+            this._callbackHandle));</span>
<a href="#l32.1353"></a><span id="l32.1353" class="difflineplus">+        this._log.debug(&quot;&lt;&lt;&lt;  _indexMessage&quot;);</span>
<a href="#l32.1354"></a><span id="l32.1354" class="difflineplus">+      }</span>
<a href="#l32.1355"></a><span id="l32.1355" class="difflineplus">+    }</span>
<a href="#l32.1356"></a><span id="l32.1356" class="difflineplus">+    </span>
<a href="#l32.1357"></a><span id="l32.1357" class="difflineplus">+    glodaFolder.dirtyStatus = glodaFolder.kFolderClean;</span>
<a href="#l32.1358"></a><span id="l32.1358" class="difflineplus">+    </span>
<a href="#l32.1359"></a><span id="l32.1359" class="difflineplus">+    // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l32.1360"></a><span id="l32.1360" class="difflineplus">+    this._indexerLeaveFolder();</span>
<a href="#l32.1361"></a><span id="l32.1361" class="difflineplus">+    </span>
<a href="#l32.1362"></a><span id="l32.1362" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l32.1363"></a><span id="l32.1363" class="difflineplus">+  },</span>
<a href="#l32.1364"></a><span id="l32.1364" class="difflineplus">+  </span>
<a href="#l32.1365"></a><span id="l32.1365" class="difflineplus">+  /**</span>
<a href="#l32.1366"></a><span id="l32.1366" class="difflineplus">+   * Index a specific list of messages that we know to index from</span>
<a href="#l32.1367"></a><span id="l32.1367" class="difflineplus">+   *  event-notification hints.</span>
<a href="#l32.1368"></a><span id="l32.1368" class="difflineplus">+   */</span>
<a href="#l32.1369"></a><span id="l32.1369" class="difflineplus">+  _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l32.1370"></a><span id="l32.1370" class="difflineplus">+    for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l32.1371"></a><span id="l32.1371" class="difflineplus">+      let item = aJob.items[aJob.offset];</span>
<a href="#l32.1372"></a><span id="l32.1372" class="difflineplus">+      // item is either [folder ID, message key] or</span>
<a href="#l32.1373"></a><span id="l32.1373" class="difflineplus">+      //                [folder ID, message ID]</span>
<a href="#l32.1374"></a><span id="l32.1374" class="difflineplus">+</span>
<a href="#l32.1375"></a><span id="l32.1375" class="difflineplus">+      // get in the folder</span>
<a href="#l32.1376"></a><span id="l32.1376" class="difflineplus">+      if (this._indexingFolderID != item[0])</span>
<a href="#l32.1377"></a><span id="l32.1377" class="difflineplus">+        yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l32.1378"></a><span id="l32.1378" class="difflineplus">+</span>
<a href="#l32.1379"></a><span id="l32.1379" class="difflineplus">+      let msgHdr;</span>
<a href="#l32.1380"></a><span id="l32.1380" class="difflineplus">+      if (typeof item[1] == &quot;number&quot;)</span>
<a href="#l32.1381"></a><span id="l32.1381" class="difflineplus">+        msgHdr = this._indexingFolder.GetMessageHeader(item[1]);</span>
<a href="#l32.1382"></a><span id="l32.1382" class="difflineplus">+      else</span>
<a href="#l32.1383"></a><span id="l32.1383" class="difflineplus">+        // same deal as in move processing.</span>
<a href="#l32.1384"></a><span id="l32.1384" class="difflineplus">+        // TODO fixme to not assume singular message-id's.</span>
<a href="#l32.1385"></a><span id="l32.1385" class="difflineplus">+        msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l32.1386"></a><span id="l32.1386" class="difflineplus">+      </span>
<a href="#l32.1387"></a><span id="l32.1387" class="difflineplus">+      if (msgHdr &amp;&amp; !(msgHdr.flags&amp;MSG_FLAG_EXPUNGED))</span>
<a href="#l32.1388"></a><span id="l32.1388" class="difflineplus">+        yield this._callbackHandle.pushAndGo(this._indexMessage(msgHdr,</span>
<a href="#l32.1389"></a><span id="l32.1389" class="difflineplus">+            this._callbackHandle));</span>
<a href="#l32.1390"></a><span id="l32.1390" class="difflineplus">+      else</span>
<a href="#l32.1391"></a><span id="l32.1391" class="difflineplus">+        yield this.kWorkSync;</span>
<a href="#l32.1392"></a><span id="l32.1392" class="difflineplus">+    }</span>
<a href="#l32.1393"></a><span id="l32.1393" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l32.1394"></a><span id="l32.1394" class="difflineplus">+  },</span>
<a href="#l32.1395"></a><span id="l32.1395" class="difflineplus">+  </span>
<a href="#l32.1396"></a><span id="l32.1396" class="difflineplus">+  /**</span>
<a href="#l32.1397"></a><span id="l32.1397" class="difflineplus">+   * Process pending deletes...</span>
<a href="#l32.1398"></a><span id="l32.1398" class="difflineplus">+   */</span>
<a href="#l32.1399"></a><span id="l32.1399" class="difflineplus">+  _worker_processDeletes: function gloda_worker_processDeletes(aJob,</span>
<a href="#l32.1400"></a><span id="l32.1400" class="difflineplus">+      aCallbackHandle) {</span>
<a href="#l32.1401"></a><span id="l32.1401" class="difflineplus">+    // get a block of messages to delete.  for now, let's just do this</span>
<a href="#l32.1402"></a><span id="l32.1402" class="difflineplus">+    //  synchronously.  we don't care if there are un-landed delete changes</span>
<a href="#l32.1403"></a><span id="l32.1403" class="difflineplus">+    //  on the asynchronous thread.  (well, there is a potential race that</span>
<a href="#l32.1404"></a><span id="l32.1404" class="difflineplus">+    //  would result in us clearing pendingDeletions erroneously, but the</span>
<a href="#l32.1405"></a><span id="l32.1405" class="difflineplus">+    //  processedAny flag and our use of a while loop here make this</span>
<a href="#l32.1406"></a><span id="l32.1406" class="difflineplus">+    //  sufficiently close to zero until we move to being async.)</span>
<a href="#l32.1407"></a><span id="l32.1407" class="difflineplus">+    let messagesToDelete = this._datastore.getDeletedMessageBlock();</span>
<a href="#l32.1408"></a><span id="l32.1408" class="difflineplus">+    let processedAny = false;</span>
<a href="#l32.1409"></a><span id="l32.1409" class="difflineplus">+    while (messagesToDelete.length) {</span>
<a href="#l32.1410"></a><span id="l32.1410" class="difflineplus">+      aJob.goal += messagesToDelete.length;</span>
<a href="#l32.1411"></a><span id="l32.1411" class="difflineplus">+      for each (let [iMessage, message] in Iterator(messagesToDelete)) {</span>
<a href="#l32.1412"></a><span id="l32.1412" class="difflineplus">+        yield aCallbackHandle.pushAndGo(this._deleteMessage(message));</span>
<a href="#l32.1413"></a><span id="l32.1413" class="difflineplus">+        aJob.offset++;</span>
<a href="#l32.1414"></a><span id="l32.1414" class="difflineplus">+        yield this.kWorkSync;</span>
<a href="#l32.1415"></a><span id="l32.1415" class="difflineplus">+      }</span>
<a href="#l32.1416"></a><span id="l32.1416" class="difflineplus">+      </span>
<a href="#l32.1417"></a><span id="l32.1417" class="difflineplus">+      processedAny = true;</span>
<a href="#l32.1418"></a><span id="l32.1418" class="difflineplus">+      messagesToDelete = this._datastore.getDeletedMessageBlock(); </span>
<a href="#l32.1419"></a><span id="l32.1419" class="difflineplus">+    }</span>
<a href="#l32.1420"></a><span id="l32.1420" class="difflineplus">+    if (processedAny)</span>
<a href="#l32.1421"></a><span id="l32.1421" class="difflineplus">+      this.pendingDeletions = false;</span>
<a href="#l32.1422"></a><span id="l32.1422" class="difflineplus">+    </span>
<a href="#l32.1423"></a><span id="l32.1423" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l32.1424"></a><span id="l32.1424" class="difflineplus">+  },</span>
<a href="#l32.1425"></a><span id="l32.1425" class="difflineplus">+</span>
<a href="#l32.1426"></a><span id="l32.1426" class="difflineplus">+  /**</span>
<a href="#l32.1427"></a><span id="l32.1427" class="difflineplus">+   * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l32.1428"></a><span id="l32.1428" class="difflineplus">+   *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l32.1429"></a><span id="l32.1429" class="difflineplus">+   *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l32.1430"></a><span id="l32.1430" class="difflineplus">+   *  indexed.  (We previously queued accounts rather than immediately</span>
<a href="#l32.1431"></a><span id="l32.1431" class="difflineplus">+   *  walking their list of folders.)</span>
<a href="#l32.1432"></a><span id="l32.1432" class="difflineplus">+   */</span>
<a href="#l32.1433"></a><span id="l32.1433" class="difflineplus">+  indexEverything: function glodaIndexEverything() {</span>
<a href="#l32.1434"></a><span id="l32.1434" class="difflineplus">+    this._log.info(&quot;Queueing all accounts for indexing.&quot;);</span>
<a href="#l32.1435"></a><span id="l32.1435" class="difflineplus">+    let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l32.1436"></a><span id="l32.1436" class="difflineplus">+                            getService(Ci.nsIMsgAccountManager);</span>
<a href="#l32.1437"></a><span id="l32.1437" class="difflineplus">+    </span>
<a href="#l32.1438"></a><span id="l32.1438" class="difflineplus">+    GlodaDatastore._beginTransaction();</span>
<a href="#l32.1439"></a><span id="l32.1439" class="difflineplus">+    let sideEffects = [this.indexAccount(account) for each</span>
<a href="#l32.1440"></a><span id="l32.1440" class="difflineplus">+                       (account in fixIterator(msgAccountManager.accounts,</span>
<a href="#l32.1441"></a><span id="l32.1441" class="difflineplus">+                                               Ci.nsIMsgAccount))];</span>
<a href="#l32.1442"></a><span id="l32.1442" class="difflineplus">+    GlodaDatastore._commitTransaction();</span>
<a href="#l32.1443"></a><span id="l32.1443" class="difflineplus">+  },</span>
<a href="#l32.1444"></a><span id="l32.1444" class="difflineplus">+</span>
<a href="#l32.1445"></a><span id="l32.1445" class="difflineplus">+  /**</span>
<a href="#l32.1446"></a><span id="l32.1446" class="difflineplus">+   * Queue all of the folders belonging to an account for indexing.</span>
<a href="#l32.1447"></a><span id="l32.1447" class="difflineplus">+   */</span>
<a href="#l32.1448"></a><span id="l32.1448" class="difflineplus">+  indexAccount: function glodaIndexAccount(aAccount) {</span>
<a href="#l32.1449"></a><span id="l32.1449" class="difflineplus">+    let rootFolder = aAccount.incomingServer.rootFolder;</span>
<a href="#l32.1450"></a><span id="l32.1450" class="difflineplus">+    if (rootFolder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l32.1451"></a><span id="l32.1451" class="difflineplus">+      this._log.info(&quot;Queueing account folders for indexing: &quot; + aAccount.key);</span>
<a href="#l32.1452"></a><span id="l32.1452" class="difflineplus">+</span>
<a href="#l32.1453"></a><span id="l32.1453" class="difflineplus">+      GlodaDatastore._beginTransaction();</span>
<a href="#l32.1454"></a><span id="l32.1454" class="difflineplus">+      let folderJobs =</span>
<a href="#l32.1455"></a><span id="l32.1455" class="difflineplus">+              [new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l32.1456"></a><span id="l32.1456" class="difflineplus">+                               GlodaDatastore._mapFolder(folder).id) for each</span>
<a href="#l32.1457"></a><span id="l32.1457" class="difflineplus">+              (folder in fixIterator(rootFolder.subFolders, Ci.nsIMsgFolder))];</span>
<a href="#l32.1458"></a><span id="l32.1458" class="difflineplus">+      GlodaDatastore._commitTransaction();</span>
<a href="#l32.1459"></a><span id="l32.1459" class="difflineplus">+      </span>
<a href="#l32.1460"></a><span id="l32.1460" class="difflineplus">+      this._indexingJobGoal += folderJobs.length;</span>
<a href="#l32.1461"></a><span id="l32.1461" class="difflineplus">+      this._indexQueue = this._indexQueue.concat(folderJobs);</span>
<a href="#l32.1462"></a><span id="l32.1462" class="difflineplus">+      this.indexing = true;</span>
<a href="#l32.1463"></a><span id="l32.1463" class="difflineplus">+    }</span>
<a href="#l32.1464"></a><span id="l32.1464" class="difflineplus">+    else {</span>
<a href="#l32.1465"></a><span id="l32.1465" class="difflineplus">+      this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l32.1466"></a><span id="l32.1466" class="difflineplus">+    }</span>
<a href="#l32.1467"></a><span id="l32.1467" class="difflineplus">+  },</span>
<a href="#l32.1468"></a><span id="l32.1468" class="difflineplus">+</span>
<a href="#l32.1469"></a><span id="l32.1469" class="difflineplus">+  indexJob: function glodaIndexJob(aJob) {</span>
<a href="#l32.1470"></a><span id="l32.1470" class="difflineplus">+    this._log.info(&quot;Queue-ing job for indexing: &quot; + aJob.jobType);</span>
<a href="#l32.1471"></a><span id="l32.1471" class="difflineplus">+    </span>
<a href="#l32.1472"></a><span id="l32.1472" class="difflineplus">+    this._indexQueue.push(aJob);</span>
<a href="#l32.1473"></a><span id="l32.1473" class="difflineplus">+    this._indexingJobGoal++;</span>
<a href="#l32.1474"></a><span id="l32.1474" class="difflineplus">+    this.indexing = true;</span>
<a href="#l32.1475"></a><span id="l32.1475" class="difflineplus">+  },</span>
<a href="#l32.1476"></a><span id="l32.1476" class="difflineplus">+  </span>
<a href="#l32.1477"></a><span id="l32.1477" class="difflineplus">+  /**</span>
<a href="#l32.1478"></a><span id="l32.1478" class="difflineplus">+   * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l32.1479"></a><span id="l32.1479" class="difflineplus">+   */</span>
<a href="#l32.1480"></a><span id="l32.1480" class="difflineplus">+  indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l32.1481"></a><span id="l32.1481" class="difflineplus">+    this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l32.1482"></a><span id="l32.1482" class="difflineplus">+    </span>
<a href="#l32.1483"></a><span id="l32.1483" class="difflineplus">+    this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l32.1484"></a><span id="l32.1484" class="difflineplus">+                          GlodaDatastore._mapFolder(aFolder).id));</span>
<a href="#l32.1485"></a><span id="l32.1485" class="difflineplus">+    this._indexingJobGoal++;</span>
<a href="#l32.1486"></a><span id="l32.1486" class="difflineplus">+    this.indexing = true;</span>
<a href="#l32.1487"></a><span id="l32.1487" class="difflineplus">+  },</span>
<a href="#l32.1488"></a><span id="l32.1488" class="difflineplus">+  </span>
<a href="#l32.1489"></a><span id="l32.1489" class="difflineplus">+  /**</span>
<a href="#l32.1490"></a><span id="l32.1490" class="difflineplus">+   * Queue a list of messages for indexing.</span>
<a href="#l32.1491"></a><span id="l32.1491" class="difflineplus">+   *</span>
<a href="#l32.1492"></a><span id="l32.1492" class="difflineplus">+   * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l32.1493"></a><span id="l32.1493" class="difflineplus">+   */</span>
<a href="#l32.1494"></a><span id="l32.1494" class="difflineplus">+  indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l32.1495"></a><span id="l32.1495" class="difflineplus">+    let job = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l32.1496"></a><span id="l32.1496" class="difflineplus">+    job.items = [[GlodaDatastore._mapFolder(fm[0]).id, fm[1]] for each</span>
<a href="#l32.1497"></a><span id="l32.1497" class="difflineplus">+                 ([i, fm] in Iterator(aFoldersAndMessages))];</span>
<a href="#l32.1498"></a><span id="l32.1498" class="difflineplus">+    this._indexQueue.push(job);</span>
<a href="#l32.1499"></a><span id="l32.1499" class="difflineplus">+    this._indexingJobGoal++;</span>
<a href="#l32.1500"></a><span id="l32.1500" class="difflineplus">+    this.indexing = true;</span>
<a href="#l32.1501"></a><span id="l32.1501" class="difflineplus">+  },</span>
<a href="#l32.1502"></a><span id="l32.1502" class="difflineplus">+  </span>
<a href="#l32.1503"></a><span id="l32.1503" class="difflineplus">+  /* *********** Event Processing *********** */</span>
<a href="#l32.1504"></a><span id="l32.1504" class="difflineplus">+  observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l32.1505"></a><span id="l32.1505" class="difflineplus">+    // idle</span>
<a href="#l32.1506"></a><span id="l32.1506" class="difflineplus">+    if (aTopic == &quot;idle&quot;) {</span>
<a href="#l32.1507"></a><span id="l32.1507" class="difflineplus">+      if (this.indexing)</span>
<a href="#l32.1508"></a><span id="l32.1508" class="difflineplus">+        this._log.debug(&quot;Detected idle, throttling up.&quot;);</span>
<a href="#l32.1509"></a><span id="l32.1509" class="difflineplus">+      this._indexInterval = this._indexInterval_whenIdle;</span>
<a href="#l32.1510"></a><span id="l32.1510" class="difflineplus">+      this._indexTokens = this._indexTokens_whenIdle;</span>
<a href="#l32.1511"></a><span id="l32.1511" class="difflineplus">+    }</span>
<a href="#l32.1512"></a><span id="l32.1512" class="difflineplus">+    else if (aTopic == &quot;back&quot;) {</span>
<a href="#l32.1513"></a><span id="l32.1513" class="difflineplus">+      if (this.indexing)</span>
<a href="#l32.1514"></a><span id="l32.1514" class="difflineplus">+        this._log.debug(&quot;Detected un-idle, throttling down.&quot;);</span>
<a href="#l32.1515"></a><span id="l32.1515" class="difflineplus">+      this._indexInterval = this._indexInterval_whenActive;</span>
<a href="#l32.1516"></a><span id="l32.1516" class="difflineplus">+      this._indexTokens = this._indexTokens_whenActive;</span>
<a href="#l32.1517"></a><span id="l32.1517" class="difflineplus">+    }</span>
<a href="#l32.1518"></a><span id="l32.1518" class="difflineplus">+    // offline status</span>
<a href="#l32.1519"></a><span id="l32.1519" class="difflineplus">+    else if (aTopic == &quot;network:offline-status-changed&quot;) {</span>
<a href="#l32.1520"></a><span id="l32.1520" class="difflineplus">+      if (aData == &quot;offline&quot;) {</span>
<a href="#l32.1521"></a><span id="l32.1521" class="difflineplus">+        this.suppressIndexing = true;</span>
<a href="#l32.1522"></a><span id="l32.1522" class="difflineplus">+      }</span>
<a href="#l32.1523"></a><span id="l32.1523" class="difflineplus">+      else { // online</span>
<a href="#l32.1524"></a><span id="l32.1524" class="difflineplus">+        this.suppressIndexing = false;</span>
<a href="#l32.1525"></a><span id="l32.1525" class="difflineplus">+      }</span>
<a href="#l32.1526"></a><span id="l32.1526" class="difflineplus">+    }</span>
<a href="#l32.1527"></a><span id="l32.1527" class="difflineplus">+    // shutdown fallback</span>
<a href="#l32.1528"></a><span id="l32.1528" class="difflineplus">+    else if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l32.1529"></a><span id="l32.1529" class="difflineplus">+      this._shutdown();</span>
<a href="#l32.1530"></a><span id="l32.1530" class="difflineplus">+    }</span>
<a href="#l32.1531"></a><span id="l32.1531" class="difflineplus">+  },</span>
<a href="#l32.1532"></a><span id="l32.1532" class="difflineplus">+</span>
<a href="#l32.1533"></a><span id="l32.1533" class="difflineplus">+  /* ***** Folder Changes ***** */  </span>
<a href="#l32.1534"></a><span id="l32.1534" class="difflineplus">+  /**</span>
<a href="#l32.1535"></a><span id="l32.1535" class="difflineplus">+   * All additions and removals are queued for processing.  Indexing messages</span>
<a href="#l32.1536"></a><span id="l32.1536" class="difflineplus">+   *  is potentially phenomenally expensive, and deletion can still be</span>
<a href="#l32.1537"></a><span id="l32.1537" class="difflineplus">+   *  relatively expensive due to our need to delete the message, its</span>
<a href="#l32.1538"></a><span id="l32.1538" class="difflineplus">+   *  attributes, and all attributes that reference it.  Additionally,</span>
<a href="#l32.1539"></a><span id="l32.1539" class="difflineplus">+   *  attribute deletion costs are higher than attribute look-up because</span>
<a href="#l32.1540"></a><span id="l32.1540" class="difflineplus">+   *  there is the actual row plus its 3 indices, and our covering indices are</span>
<a href="#l32.1541"></a><span id="l32.1541" class="difflineplus">+   *  no help there.</span>
<a href="#l32.1542"></a><span id="l32.1542" class="difflineplus">+   *  </span>
<a href="#l32.1543"></a><span id="l32.1543" class="difflineplus">+   */</span>
<a href="#l32.1544"></a><span id="l32.1544" class="difflineplus">+  _msgFolderListener: {</span>
<a href="#l32.1545"></a><span id="l32.1545" class="difflineplus">+    indexer: null,</span>
<a href="#l32.1546"></a><span id="l32.1546" class="difflineplus">+    </span>
<a href="#l32.1547"></a><span id="l32.1547" class="difflineplus">+    /**</span>
<a href="#l32.1548"></a><span id="l32.1548" class="difflineplus">+     * Handle a new-to-thunderbird message, meaning a newly fetched message</span>
<a href="#l32.1549"></a><span id="l32.1549" class="difflineplus">+     *  (local folder) one revealed by synching with the server (IMAP).  Because</span>
<a href="#l32.1550"></a><span id="l32.1550" class="difflineplus">+     *  the new-to-IMAP case requires Thunderbird to have opened the folder,</span>
<a href="#l32.1551"></a><span id="l32.1551" class="difflineplus">+     *  we either need to depend on MailNews to be aggressive about looking</span>
<a href="#l32.1552"></a><span id="l32.1552" class="difflineplus">+     *  for new messages in folders or try and do it ourselves.  For now, we</span>
<a href="#l32.1553"></a><span id="l32.1553" class="difflineplus">+     *  leave it up to MailNews proper.</span>
<a href="#l32.1554"></a><span id="l32.1554" class="difflineplus">+     *</span>
<a href="#l32.1555"></a><span id="l32.1555" class="difflineplus">+     * For the time being, we post the message header as received to our</span>
<a href="#l32.1556"></a><span id="l32.1556" class="difflineplus">+     *  indexing queue.  Depending on experience, it may be more suitable to</span>
<a href="#l32.1557"></a><span id="l32.1557" class="difflineplus">+     *  try and index the message immediately, or hold onto a less specific</span>
<a href="#l32.1558"></a><span id="l32.1558" class="difflineplus">+     *  form of message information than the nsIMsgDBHdr.  (If we were to</span>
<a href="#l32.1559"></a><span id="l32.1559" class="difflineplus">+     *  process immediately, it might appropriate to consider having a</span>
<a href="#l32.1560"></a><span id="l32.1560" class="difflineplus">+     *  transaction open that is commited by timer/sufficient activity, since it</span>
<a href="#l32.1561"></a><span id="l32.1561" class="difflineplus">+     *  is conceivable we will see a number of these events in fairly rapid</span>
<a href="#l32.1562"></a><span id="l32.1562" class="difflineplus">+     *  succession.)</span>
<a href="#l32.1563"></a><span id="l32.1563" class="difflineplus">+     */</span>
<a href="#l32.1564"></a><span id="l32.1564" class="difflineplus">+    msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l32.1565"></a><span id="l32.1565" class="difflineplus">+      // make sure the message is eligible for indexing...</span>
<a href="#l32.1566"></a><span id="l32.1566" class="difflineplus">+      let msgFolder = aMsgHdr.folder;</span>
<a href="#l32.1567"></a><span id="l32.1567" class="difflineplus">+      if (msgFolder.URI.indexOf(&quot;news://&quot;) == 0)</span>
<a href="#l32.1568"></a><span id="l32.1568" class="difflineplus">+        return;</span>
<a href="#l32.1569"></a><span id="l32.1569" class="difflineplus">+      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l32.1570"></a><span id="l32.1570" class="difflineplus">+      if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l32.1571"></a><span id="l32.1571" class="difflineplus">+        return;</span>
<a href="#l32.1572"></a><span id="l32.1572" class="difflineplus">+      </span>
<a href="#l32.1573"></a><span id="l32.1573" class="difflineplus">+      // mark the folder dirty so we know to look in it, but there is no need</span>
<a href="#l32.1574"></a><span id="l32.1574" class="difflineplus">+      //  to mark the message because it will lack a gloda-id anyways.</span>
<a href="#l32.1575"></a><span id="l32.1575" class="difflineplus">+      // (but don't mark it if it's already marked, as it could result in </span>
<a href="#l32.1576"></a><span id="l32.1576" class="difflineplus">+      //  useless commits.)</span>
<a href="#l32.1577"></a><span id="l32.1577" class="difflineplus">+      // XXX if we used our own folder rep here, this would be much cheaper...</span>
<a href="#l32.1578"></a><span id="l32.1578" class="difflineplus">+      let folderAlreadyDirty = true;</span>
<a href="#l32.1579"></a><span id="l32.1579" class="difflineplus">+      try {</span>
<a href="#l32.1580"></a><span id="l32.1580" class="difflineplus">+        folderAlreadyDirty = msgFolder.getStringProperty(</span>
<a href="#l32.1581"></a><span id="l32.1581" class="difflineplus">+          this.indexer.GLODA_DIRTY_PROPERTY) != &quot;0&quot;;</span>
<a href="#l32.1582"></a><span id="l32.1582" class="difflineplus">+      } catch (ex) {}</span>
<a href="#l32.1583"></a><span id="l32.1583" class="difflineplus">+      if (!folderAlreadyDirty)</span>
<a href="#l32.1584"></a><span id="l32.1584" class="difflineplus">+        msgFolder.setStringProperty(this.indexer.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l32.1585"></a><span id="l32.1585" class="difflineplus">+</span>
<a href="#l32.1586"></a><span id="l32.1586" class="difflineplus">+      if (this.indexer._pendingAddJob === null) {</span>
<a href="#l32.1587"></a><span id="l32.1587" class="difflineplus">+        this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l32.1588"></a><span id="l32.1588" class="difflineplus">+        this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l32.1589"></a><span id="l32.1589" class="difflineplus">+        this.indexer._indexingJobGoal++;</span>
<a href="#l32.1590"></a><span id="l32.1590" class="difflineplus">+      }</span>
<a href="#l32.1591"></a><span id="l32.1591" class="difflineplus">+      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l32.1592"></a><span id="l32.1592" class="difflineplus">+      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l32.1593"></a><span id="l32.1593" class="difflineplus">+          this.indexer._indexMaxEventQueueMessages) {</span>
<a href="#l32.1594"></a><span id="l32.1594" class="difflineplus">+        this.indexer._pendingAddJob.items.push(</span>
<a href="#l32.1595"></a><span id="l32.1595" class="difflineplus">+          [GlodaDatastore._mapFolder(aMsgHdr.folder).id,</span>
<a href="#l32.1596"></a><span id="l32.1596" class="difflineplus">+           aMsgHdr.messageKey]);</span>
<a href="#l32.1597"></a><span id="l32.1597" class="difflineplus">+        this.indexer.indexing = true;</span>
<a href="#l32.1598"></a><span id="l32.1598" class="difflineplus">+        this.indexer._log.debug(&quot;msgAdded notification, event indexing&quot;);</span>
<a href="#l32.1599"></a><span id="l32.1599" class="difflineplus">+      }</span>
<a href="#l32.1600"></a><span id="l32.1600" class="difflineplus">+      else {</span>
<a href="#l32.1601"></a><span id="l32.1601" class="difflineplus">+        this.indexer.indexingSweepNeeded = true;</span>
<a href="#l32.1602"></a><span id="l32.1602" class="difflineplus">+        this.indexer._log.debug(&quot;msgAdded notification, sweep indexing&quot;);</span>
<a href="#l32.1603"></a><span id="l32.1603" class="difflineplus">+      }</span>
<a href="#l32.1604"></a><span id="l32.1604" class="difflineplus">+    },</span>
<a href="#l32.1605"></a><span id="l32.1605" class="difflineplus">+    </span>
<a href="#l32.1606"></a><span id="l32.1606" class="difflineplus">+    /**</span>
<a href="#l32.1607"></a><span id="l32.1607" class="difflineplus">+     * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l32.1608"></a><span id="l32.1608" class="difflineplus">+     *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l32.1609"></a><span id="l32.1609" class="difflineplus">+     *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l32.1610"></a><span id="l32.1610" class="difflineplus">+     *  going away, we need to either process things immediately or extract the</span>
<a href="#l32.1611"></a><span id="l32.1611" class="difflineplus">+     *  information required to purge it later without the header.</span>
<a href="#l32.1612"></a><span id="l32.1612" class="difflineplus">+     * To this end, we mark all messages that were indexed in the gloda message</span>
<a href="#l32.1613"></a><span id="l32.1613" class="difflineplus">+     *  database as deleted.  We set our pending deletions flag to let our</span>
<a href="#l32.1614"></a><span id="l32.1614" class="difflineplus">+     *  indexing logic know that after its next wave of folder traversal, it</span>
<a href="#l32.1615"></a><span id="l32.1615" class="difflineplus">+     *  should perform a deletion pass.  If it turns out the messages are coming</span>
<a href="#l32.1616"></a><span id="l32.1616" class="difflineplus">+     *  back, the fact that deletion is thus deferred can be handy, as we can</span>
<a href="#l32.1617"></a><span id="l32.1617" class="difflineplus">+     *  reuse the existing gloda message. </span>
<a href="#l32.1618"></a><span id="l32.1618" class="difflineplus">+     */</span>
<a href="#l32.1619"></a><span id="l32.1619" class="difflineplus">+    msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l32.1620"></a><span id="l32.1620" class="difflineplus">+      this.indexer._log.debug(&quot;msgsDeleted notification&quot;);</span>
<a href="#l32.1621"></a><span id="l32.1621" class="difflineplus">+      </span>
<a href="#l32.1622"></a><span id="l32.1622" class="difflineplus">+      let glodaMessageIds = [];</span>
<a href="#l32.1623"></a><span id="l32.1623" class="difflineplus">+      </span>
<a href="#l32.1624"></a><span id="l32.1624" class="difflineplus">+      let deleteJob = new IndexingJob(&quot;message&quot;, -1, null);</span>
<a href="#l32.1625"></a><span id="l32.1625" class="difflineplus">+      for (let iMsgHdr = 0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l32.1626"></a><span id="l32.1626" class="difflineplus">+        let msgHdr = aMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l32.1627"></a><span id="l32.1627" class="difflineplus">+        try {</span>
<a href="#l32.1628"></a><span id="l32.1628" class="difflineplus">+          glodaMessageIds.push(msgHdr.getUint32Property(</span>
<a href="#l32.1629"></a><span id="l32.1629" class="difflineplus">+            this.indexer.GLODA_MESSAGE_ID_PROPERTY));</span>
<a href="#l32.1630"></a><span id="l32.1630" class="difflineplus">+        }</span>
<a href="#l32.1631"></a><span id="l32.1631" class="difflineplus">+        catch (ex) {}</span>
<a href="#l32.1632"></a><span id="l32.1632" class="difflineplus">+      }</span>
<a href="#l32.1633"></a><span id="l32.1633" class="difflineplus">+      </span>
<a href="#l32.1634"></a><span id="l32.1634" class="difflineplus">+      if (glodaMessageIds.length) {</span>
<a href="#l32.1635"></a><span id="l32.1635" class="difflineplus">+        this.indexer._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l32.1636"></a><span id="l32.1636" class="difflineplus">+        this.indexer.pendingDeletions = true;</span>
<a href="#l32.1637"></a><span id="l32.1637" class="difflineplus">+      }</span>
<a href="#l32.1638"></a><span id="l32.1638" class="difflineplus">+    },</span>
<a href="#l32.1639"></a><span id="l32.1639" class="difflineplus">+    </span>
<a href="#l32.1640"></a><span id="l32.1640" class="difflineplus">+    /**</span>
<a href="#l32.1641"></a><span id="l32.1641" class="difflineplus">+     * Process a move or copy.</span>
<a href="#l32.1642"></a><span id="l32.1642" class="difflineplus">+     * Moves to a local folder can be dealt with (relatively) efficiently; the</span>
<a href="#l32.1643"></a><span id="l32.1643" class="difflineplus">+     *  target message headers exist at the time of the notification.  The trick</span>
<a href="#l32.1644"></a><span id="l32.1644" class="difflineplus">+     *  is that we aren't provided with them.</span>
<a href="#l32.1645"></a><span id="l32.1645" class="difflineplus">+     * Moves to an IMAP folder are troublesome because mailnews may not actually</span>
<a href="#l32.1646"></a><span id="l32.1646" class="difflineplus">+     *  know anything about the messages in their new location.  If there isn't</span>
<a href="#l32.1647"></a><span id="l32.1647" class="difflineplus">+     *  a currently open connection to the destination folder, we will only hear</span>
<a href="#l32.1648"></a><span id="l32.1648" class="difflineplus">+     *  about the headers when the user browses there or IMAP auto-sync gets to</span>
<a href="#l32.1649"></a><span id="l32.1649" class="difflineplus">+     *  the folder.  Either way, we will actually receive a msgAdded event for</span>
<a href="#l32.1650"></a><span id="l32.1650" class="difflineplus">+     *  each message, so the main thing we need to do is provide a hint to the</span>
<a href="#l32.1651"></a><span id="l32.1651" class="difflineplus">+     *  indexing logic that the gloda message in question should be reused and</span>
<a href="#l32.1652"></a><span id="l32.1652" class="difflineplus">+     *  is not a duplicate.</span>
<a href="#l32.1653"></a><span id="l32.1653" class="difflineplus">+     * Because copied messages are, by their nature, duplicate messages, we</span>
<a href="#l32.1654"></a><span id="l32.1654" class="difflineplus">+     *  do not particularly care about them.  As such, we defer their processing</span>
<a href="#l32.1655"></a><span id="l32.1655" class="difflineplus">+     *  to the automatic sync logic that will happen much later on.  This is</span>
<a href="#l32.1656"></a><span id="l32.1656" class="difflineplus">+     *  potentially desirable in case the user deletes some of the original</span>
<a href="#l32.1657"></a><span id="l32.1657" class="difflineplus">+     *  messages, allowing us to reuse the gloda message representations when</span>
<a href="#l32.1658"></a><span id="l32.1658" class="difflineplus">+     *  we finally get around to indexing the messages.  We do need to mark the</span>
<a href="#l32.1659"></a><span id="l32.1659" class="difflineplus">+     *  folder as dirty, though, to clue in the sync logic.</span>
<a href="#l32.1660"></a><span id="l32.1660" class="difflineplus">+     */</span>
<a href="#l32.1661"></a><span id="l32.1661" class="difflineplus">+    msgsMoveCopyCompleted: function gloda_indexer_msgsMoveCopyCompleted(aMove,</span>
<a href="#l32.1662"></a><span id="l32.1662" class="difflineplus">+                             aSrcMsgHdrs, aDestFolder) {</span>
<a href="#l32.1663"></a><span id="l32.1663" class="difflineplus">+      this.indexer._log.debug(&quot;MoveCopy notification.  Move: &quot; + aMove);</span>
<a href="#l32.1664"></a><span id="l32.1664" class="difflineplus">+      try {</span>
<a href="#l32.1665"></a><span id="l32.1665" class="difflineplus">+        if (aMove) {</span>
<a href="#l32.1666"></a><span id="l32.1666" class="difflineplus">+          // target is a local folder, we can find the destination messages</span>
<a href="#l32.1667"></a><span id="l32.1667" class="difflineplus">+          if (aDestFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l32.1668"></a><span id="l32.1668" class="difflineplus">+            // ...of course, finding the destination messages is not going to</span>
<a href="#l32.1669"></a><span id="l32.1669" class="difflineplus">+            //  be cheap.  we're O(n) for the messages in the target folder</span>
<a href="#l32.1670"></a><span id="l32.1670" class="difflineplus">+            //  (which is &gt;= the number of moved messages).</span>
<a href="#l32.1671"></a><span id="l32.1671" class="difflineplus">+            // XXX for now, we assume the gloda-id is not propagated at the</span>
<a href="#l32.1672"></a><span id="l32.1672" class="difflineplus">+            //  cost of getting confused if multiple messages have the same</span>
<a href="#l32.1673"></a><span id="l32.1673" class="difflineplus">+            //  message-id header; we would do better to get the gloda-id</span>
<a href="#l32.1674"></a><span id="l32.1674" class="difflineplus">+            //  propagated and use that.  (needs C++ code changes.)</span>
<a href="#l32.1675"></a><span id="l32.1675" class="difflineplus">+            // (we would still need to do the traversal because we still need</span>
<a href="#l32.1676"></a><span id="l32.1676" class="difflineplus">+            //  to know the messageKey in the target folder...)</span>
<a href="#l32.1677"></a><span id="l32.1677" class="difflineplus">+            let srcMsgIdToHdr = {};</span>
<a href="#l32.1678"></a><span id="l32.1678" class="difflineplus">+</span>
<a href="#l32.1679"></a><span id="l32.1679" class="difflineplus">+            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l32.1680"></a><span id="l32.1680" class="difflineplus">+              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l32.1681"></a><span id="l32.1681" class="difflineplus">+              // (note: collissions on message-id headers are possible and sad)</span>
<a href="#l32.1682"></a><span id="l32.1682" class="difflineplus">+              srcMsgIdToHdr[msgHdr.messageId] = msgHdr;</span>
<a href="#l32.1683"></a><span id="l32.1683" class="difflineplus">+            }</span>
<a href="#l32.1684"></a><span id="l32.1684" class="difflineplus">+            let glodaIds = [];</span>
<a href="#l32.1685"></a><span id="l32.1685" class="difflineplus">+            let newMessageKeys = [];</span>
<a href="#l32.1686"></a><span id="l32.1686" class="difflineplus">+            for each (let destMsgHdr in fixIterator(aDest.getMessages(null),</span>
<a href="#l32.1687"></a><span id="l32.1687" class="difflineplus">+                                                    Ci.nsIMsgDBHdr)) {</span>
<a href="#l32.1688"></a><span id="l32.1688" class="difflineplus">+              let destMsgId = destMsgHdr.messageId;</span>
<a href="#l32.1689"></a><span id="l32.1689" class="difflineplus">+              let matchingSrcHdr = srcMsgIdToHdr[destMsgId];</span>
<a href="#l32.1690"></a><span id="l32.1690" class="difflineplus">+              if (matchingSrcHdr) {</span>
<a href="#l32.1691"></a><span id="l32.1691" class="difflineplus">+                try {</span>
<a href="#l32.1692"></a><span id="l32.1692" class="difflineplus">+                  let glodaId = matchingSrcHdr.getUint32Property(</span>
<a href="#l32.1693"></a><span id="l32.1693" class="difflineplus">+                    this.indexer.GLODA_MESSAGE_ID_PROPERTY); </span>
<a href="#l32.1694"></a><span id="l32.1694" class="difflineplus">+                  glodaIds.push(glodaId);</span>
<a href="#l32.1695"></a><span id="l32.1695" class="difflineplus">+                  newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l32.1696"></a><span id="l32.1696" class="difflineplus">+                }</span>
<a href="#l32.1697"></a><span id="l32.1697" class="difflineplus">+                // no gloda id means it hasn't been indexed, so the move isn't</span>
<a href="#l32.1698"></a><span id="l32.1698" class="difflineplus">+                //  required.</span>
<a href="#l32.1699"></a><span id="l32.1699" class="difflineplus">+                catch (ex) {}</span>
<a href="#l32.1700"></a><span id="l32.1700" class="difflineplus">+              }</span>
<a href="#l32.1701"></a><span id="l32.1701" class="difflineplus">+            }</span>
<a href="#l32.1702"></a><span id="l32.1702" class="difflineplus">+            </span>
<a href="#l32.1703"></a><span id="l32.1703" class="difflineplus">+            // this method takes care to update the in-memory representations</span>
<a href="#l32.1704"></a><span id="l32.1704" class="difflineplus">+            //  too; we don't need to do anything</span>
<a href="#l32.1705"></a><span id="l32.1705" class="difflineplus">+            this.indexer._datastore.updateMessageLocations(glodaIds,</span>
<a href="#l32.1706"></a><span id="l32.1706" class="difflineplus">+              newMessageKeys, aDestFolder);</span>
<a href="#l32.1707"></a><span id="l32.1707" class="difflineplus">+          }</span>
<a href="#l32.1708"></a><span id="l32.1708" class="difflineplus">+          // target is IMAP or something we equally don't understand</span>
<a href="#l32.1709"></a><span id="l32.1709" class="difflineplus">+          else {</span>
<a href="#l32.1710"></a><span id="l32.1710" class="difflineplus">+            // XXX the srcFolder will always be the same for now, but we</span>
<a href="#l32.1711"></a><span id="l32.1711" class="difflineplus">+            //  probably don't want to depend on it, or at least want a unit</span>
<a href="#l32.1712"></a><span id="l32.1712" class="difflineplus">+            //  test that will break if it changes...</span>
<a href="#l32.1713"></a><span id="l32.1713" class="difflineplus">+            let srcFolder = aSrcMsgHdrs.queryElementAt(0,Ci.nsIMsgDBHdr).folder;</span>
<a href="#l32.1714"></a><span id="l32.1714" class="difflineplus">+    </span>
<a href="#l32.1715"></a><span id="l32.1715" class="difflineplus">+            // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l32.1716"></a><span id="l32.1716" class="difflineplus">+            //  job list too.</span>
<a href="#l32.1717"></a><span id="l32.1717" class="difflineplus">+            let messageKeys = [];</span>
<a href="#l32.1718"></a><span id="l32.1718" class="difflineplus">+            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l32.1719"></a><span id="l32.1719" class="difflineplus">+              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l32.1720"></a><span id="l32.1720" class="difflineplus">+              messageKeys.push(msgHdr.messageKey);</span>
<a href="#l32.1721"></a><span id="l32.1721" class="difflineplus">+            }</span>
<a href="#l32.1722"></a><span id="l32.1722" class="difflineplus">+            // XXX we could extract the gloda message id's instead.</span>
<a href="#l32.1723"></a><span id="l32.1723" class="difflineplus">+            // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l32.1724"></a><span id="l32.1724" class="difflineplus">+            this.indexer._datastore.updateMessageFoldersByKeyPurging(</span>
<a href="#l32.1725"></a><span id="l32.1725" class="difflineplus">+              srcFolder, messageKeys, aDestFolder);</span>
<a href="#l32.1726"></a><span id="l32.1726" class="difflineplus">+            // we _do not_ need to mark the folder as dirty, because the</span>
<a href="#l32.1727"></a><span id="l32.1727" class="difflineplus">+            //  message added events will cause that to happen.</span>
<a href="#l32.1728"></a><span id="l32.1728" class="difflineplus">+          }</span>
<a href="#l32.1729"></a><span id="l32.1729" class="difflineplus">+        }</span>
<a href="#l32.1730"></a><span id="l32.1730" class="difflineplus">+       // copy case</span>
<a href="#l32.1731"></a><span id="l32.1731" class="difflineplus">+        else {</span>
<a href="#l32.1732"></a><span id="l32.1732" class="difflineplus">+          // mark the folder as dirty; we'll get to it later.</span>
<a href="#l32.1733"></a><span id="l32.1733" class="difflineplus">+          aDestFolder.setStringProperty(this.indexer.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l32.1734"></a><span id="l32.1734" class="difflineplus">+          this.indexer.indexingSweepNeeded = true;</span>
<a href="#l32.1735"></a><span id="l32.1735" class="difflineplus">+        }</span>
<a href="#l32.1736"></a><span id="l32.1736" class="difflineplus">+      } catch (ex) {</span>
<a href="#l32.1737"></a><span id="l32.1737" class="difflineplus">+        this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l32.1738"></a><span id="l32.1738" class="difflineplus">+          &quot;: &quot; + ex);</span>
<a href="#l32.1739"></a><span id="l32.1739" class="difflineplus">+      }</span>
<a href="#l32.1740"></a><span id="l32.1740" class="difflineplus">+    },</span>
<a href="#l32.1741"></a><span id="l32.1741" class="difflineplus">+    </span>
<a href="#l32.1742"></a><span id="l32.1742" class="difflineplus">+    /**</span>
<a href="#l32.1743"></a><span id="l32.1743" class="difflineplus">+     * Handles folder no-longer-exists-ence.  We mark all messages as deleted</span>
<a href="#l32.1744"></a><span id="l32.1744" class="difflineplus">+     *  and remove the folder from our URI table.  Currently, if a folder that</span>
<a href="#l32.1745"></a><span id="l32.1745" class="difflineplus">+     *  contains other folders is deleted, we may either receive one</span>
<a href="#l32.1746"></a><span id="l32.1746" class="difflineplus">+     *  notification for the folder that is deleted, or a notification for the</span>
<a href="#l32.1747"></a><span id="l32.1747" class="difflineplus">+     *  folder and one for each of its descendents.  This depends upon the</span>
<a href="#l32.1748"></a><span id="l32.1748" class="difflineplus">+     *  underlying account implementation, so we explicitly handle each case.</span>
<a href="#l32.1749"></a><span id="l32.1749" class="difflineplus">+     *  Namely, we treat it as if we're only planning on getting one, but we</span>
<a href="#l32.1750"></a><span id="l32.1750" class="difflineplus">+     *  handle if the children are already gone for some reason.</span>
<a href="#l32.1751"></a><span id="l32.1751" class="difflineplus">+     */</span>
<a href="#l32.1752"></a><span id="l32.1752" class="difflineplus">+    folderDeleted: function gloda_indexer_folderDeleted(aFolder) {</span>
<a href="#l32.1753"></a><span id="l32.1753" class="difflineplus">+      this.indexer._log.debug(&quot;folderDeleted notification&quot;);</span>
<a href="#l32.1754"></a><span id="l32.1754" class="difflineplus">+      </span>
<a href="#l32.1755"></a><span id="l32.1755" class="difflineplus">+      delFunc = function(folder) {</span>
<a href="#l32.1756"></a><span id="l32.1756" class="difflineplus">+        if (this._datastore._folderKnown(aFolder)) {</span>
<a href="#l32.1757"></a><span id="l32.1757" class="difflineplus">+          let folder = GlodaDatastore._mapFolder(aFolder);</span>
<a href="#l32.1758"></a><span id="l32.1758" class="difflineplus">+          this._datastore.markMessagesDeletedByID(folder.id);</span>
<a href="#l32.1759"></a><span id="l32.1759" class="difflineplus">+          this._datastore.deleteFolderByID(folder.id);</span>
<a href="#l32.1760"></a><span id="l32.1760" class="difflineplus">+        }</span>
<a href="#l32.1761"></a><span id="l32.1761" class="difflineplus">+      };</span>
<a href="#l32.1762"></a><span id="l32.1762" class="difflineplus">+</span>
<a href="#l32.1763"></a><span id="l32.1763" class="difflineplus">+      let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l32.1764"></a><span id="l32.1764" class="difflineplus">+                                createInstance(Ci.nsISupportsArray);</span>
<a href="#l32.1765"></a><span id="l32.1765" class="difflineplus">+      aFolder.ListDescendents(descendentFolders);</span>
<a href="#l32.1766"></a><span id="l32.1766" class="difflineplus">+      </span>
<a href="#l32.1767"></a><span id="l32.1767" class="difflineplus">+      // (the order of operations does not matter; child, non-child, whatever.)</span>
<a href="#l32.1768"></a><span id="l32.1768" class="difflineplus">+      // delete the parent</span>
<a href="#l32.1769"></a><span id="l32.1769" class="difflineplus">+      delFunc(aFolder);</span>
<a href="#l32.1770"></a><span id="l32.1770" class="difflineplus">+      // delete all its descendents</span>
<a href="#l32.1771"></a><span id="l32.1771" class="difflineplus">+      for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l32.1772"></a><span id="l32.1772" class="difflineplus">+        delFunc(folder);</span>
<a href="#l32.1773"></a><span id="l32.1773" class="difflineplus">+      }</span>
<a href="#l32.1774"></a><span id="l32.1774" class="difflineplus">+        </span>
<a href="#l32.1775"></a><span id="l32.1775" class="difflineplus">+      this.indexer.pendingDeletions = true;</span>
<a href="#l32.1776"></a><span id="l32.1776" class="difflineplus">+    },</span>
<a href="#l32.1777"></a><span id="l32.1777" class="difflineplus">+    </span>
<a href="#l32.1778"></a><span id="l32.1778" class="difflineplus">+    /**</span>
<a href="#l32.1779"></a><span id="l32.1779" class="difflineplus">+     * Handle a folder being copied or moved.</span>
<a href="#l32.1780"></a><span id="l32.1780" class="difflineplus">+     * Moves are handled by a helper function shared with _folderRenameHelper</span>
<a href="#l32.1781"></a><span id="l32.1781" class="difflineplus">+     *  (which takes care of any nesting involved).</span>
<a href="#l32.1782"></a><span id="l32.1782" class="difflineplus">+     * Copies are actually ignored, because our periodic indexing traversal</span>
<a href="#l32.1783"></a><span id="l32.1783" class="difflineplus">+     *  should discover these automatically.  We could hint ourselves into</span>
<a href="#l32.1784"></a><span id="l32.1784" class="difflineplus">+     *  action, but arguably a set of completely duplicate messages is not</span>
<a href="#l32.1785"></a><span id="l32.1785" class="difflineplus">+     *  a high priority for indexing.</span>
<a href="#l32.1786"></a><span id="l32.1786" class="difflineplus">+     */</span>
<a href="#l32.1787"></a><span id="l32.1787" class="difflineplus">+    folderMoveCopyCompleted: function gloda_indexer_folderMoveCopyCompleted(</span>
<a href="#l32.1788"></a><span id="l32.1788" class="difflineplus">+                               aMove, aSrcFolder, aDestFolder) {</span>
<a href="#l32.1789"></a><span id="l32.1789" class="difflineplus">+      this.indexer._log.debug(&quot;folderMoveCopy notification (Move: &quot; + aMove</span>
<a href="#l32.1790"></a><span id="l32.1790" class="difflineplus">+                              + &quot;)&quot;);</span>
<a href="#l32.1791"></a><span id="l32.1791" class="difflineplus">+      if (aMove) {</span>
<a href="#l32.1792"></a><span id="l32.1792" class="difflineplus">+        let targetURI = aDestFolder.URI +</span>
<a href="#l32.1793"></a><span id="l32.1793" class="difflineplus">+                        srcURI.substring(srcURI.lastIndexOf(&quot;/&quot;));</span>
<a href="#l32.1794"></a><span id="l32.1794" class="difflineplus">+        return this._folderRenameHelper(aSrcFolder, targetURI);</span>
<a href="#l32.1795"></a><span id="l32.1795" class="difflineplus">+      }</span>
<a href="#l32.1796"></a><span id="l32.1796" class="difflineplus">+      this.indexer.indexingSweepNeeded = true;</span>
<a href="#l32.1797"></a><span id="l32.1797" class="difflineplus">+    },</span>
<a href="#l32.1798"></a><span id="l32.1798" class="difflineplus">+    </span>
<a href="#l32.1799"></a><span id="l32.1799" class="difflineplus">+    /**</span>
<a href="#l32.1800"></a><span id="l32.1800" class="difflineplus">+     * We just need to update the URI &lt;-&gt; ID maps and the row in the database,</span>
<a href="#l32.1801"></a><span id="l32.1801" class="difflineplus">+     *  all of which is actually done by the datastore for us.</span>
<a href="#l32.1802"></a><span id="l32.1802" class="difflineplus">+     * This method needs to deal with the complexity where local folders will</span>
<a href="#l32.1803"></a><span id="l32.1803" class="difflineplus">+     *  generate a rename notification for each sub-folder, but IMAP folders</span>
<a href="#l32.1804"></a><span id="l32.1804" class="difflineplus">+     *  will generate only a single notification.  Our logic primarily handles</span>
<a href="#l32.1805"></a><span id="l32.1805" class="difflineplus">+     *  this by not exploding if the original folder no longer exists.</span>
<a href="#l32.1806"></a><span id="l32.1806" class="difflineplus">+     */</span>
<a href="#l32.1807"></a><span id="l32.1807" class="difflineplus">+    _folderRenameHelper: function gloda_indexer_folderRenameHelper(aOrigFolder,</span>
<a href="#l32.1808"></a><span id="l32.1808" class="difflineplus">+                                                                   aNewURI) {</span>
<a href="#l32.1809"></a><span id="l32.1809" class="difflineplus">+      let descendentFolders = Cc[&quot;@mozilla.org/supports-array;1&quot;].</span>
<a href="#l32.1810"></a><span id="l32.1810" class="difflineplus">+                                createInstance(Ci.nsISupportsArray);</span>
<a href="#l32.1811"></a><span id="l32.1811" class="difflineplus">+      aOrigFolder.ListDescendents(descendentFolders);</span>
<a href="#l32.1812"></a><span id="l32.1812" class="difflineplus">+      </span>
<a href="#l32.1813"></a><span id="l32.1813" class="difflineplus">+      let origURI = aOrigFolder.URI;</span>
<a href="#l32.1814"></a><span id="l32.1814" class="difflineplus">+      // this rename is straightforward.</span>
<a href="#l32.1815"></a><span id="l32.1815" class="difflineplus">+      GlodaDatastore.renameFolder(aOrigFolder, aNewURI);</span>
<a href="#l32.1816"></a><span id="l32.1816" class="difflineplus">+      </span>
<a href="#l32.1817"></a><span id="l32.1817" class="difflineplus">+      for (let folder in fixIterator(descendentFolders, Ci.nsIMsgFolder)) {</span>
<a href="#l32.1818"></a><span id="l32.1818" class="difflineplus">+        let oldSubURI = folder.URI;</span>
<a href="#l32.1819"></a><span id="l32.1819" class="difflineplus">+        // mangle a new URI from the old URI.  we could also try and do a</span>
<a href="#l32.1820"></a><span id="l32.1820" class="difflineplus">+        //  parallel traversal of the new folder hierarchy, but that seems like</span>
<a href="#l32.1821"></a><span id="l32.1821" class="difflineplus">+        //  more work.</span>
<a href="#l32.1822"></a><span id="l32.1822" class="difflineplus">+        let newSubURI = aNewURI + oldSubURI.substring(origURI.length)</span>
<a href="#l32.1823"></a><span id="l32.1823" class="difflineplus">+        this.indexer._datastore.renameFolder(oldSubURI, newSubURI);</span>
<a href="#l32.1824"></a><span id="l32.1824" class="difflineplus">+      }</span>
<a href="#l32.1825"></a><span id="l32.1825" class="difflineplus">+</span>
<a href="#l32.1826"></a><span id="l32.1826" class="difflineplus">+      this.indexer._log.debug(&quot;folder renamed: &quot; + origURI + &quot; to &quot; + aNewURI);</span>
<a href="#l32.1827"></a><span id="l32.1827" class="difflineplus">+    },</span>
<a href="#l32.1828"></a><span id="l32.1828" class="difflineplus">+    </span>
<a href="#l32.1829"></a><span id="l32.1829" class="difflineplus">+    /**</span>
<a href="#l32.1830"></a><span id="l32.1830" class="difflineplus">+     * Handle folder renames, dispatching to our rename helper (which also</span>
<a href="#l32.1831"></a><span id="l32.1831" class="difflineplus">+     *  takes care of any nested folder issues.)</span>
<a href="#l32.1832"></a><span id="l32.1832" class="difflineplus">+     */</span>
<a href="#l32.1833"></a><span id="l32.1833" class="difflineplus">+    folderRenamed: function gloda_indexer_folderRenamed(aOrigFolder,</span>
<a href="#l32.1834"></a><span id="l32.1834" class="difflineplus">+                                                        aNewFolder) {</span>
<a href="#l32.1835"></a><span id="l32.1835" class="difflineplus">+      this._folderRenameHelper(aOrigFolder, aNewFolder.URI);</span>
<a href="#l32.1836"></a><span id="l32.1836" class="difflineplus">+    },</span>
<a href="#l32.1837"></a><span id="l32.1837" class="difflineplus">+    </span>
<a href="#l32.1838"></a><span id="l32.1838" class="difflineplus">+    itemEvent: function gloda_indexer_itemEvent(aItem, aEvent, aData) {</span>
<a href="#l32.1839"></a><span id="l32.1839" class="difflineplus">+      // nop.  this is an expansion method on the part of the interface and has</span>
<a href="#l32.1840"></a><span id="l32.1840" class="difflineplus">+      //  no known events that we need to handle.</span>
<a href="#l32.1841"></a><span id="l32.1841" class="difflineplus">+    },</span>
<a href="#l32.1842"></a><span id="l32.1842" class="difflineplus">+  },</span>
<a href="#l32.1843"></a><span id="l32.1843" class="difflineplus">+  </span>
<a href="#l32.1844"></a><span id="l32.1844" class="difflineplus">+  /**</span>
<a href="#l32.1845"></a><span id="l32.1845" class="difflineplus">+   * A nsIFolderListener (listening on nsIMsgMailSession so we get all of</span>
<a href="#l32.1846"></a><span id="l32.1846" class="difflineplus">+   *  these events) PRIMARILY to get folder loaded notifications.  Because of</span>
<a href="#l32.1847"></a><span id="l32.1847" class="difflineplus">+   *  deficiencies in the nsIMsgFolderListener's events at this time, we also</span>
<a href="#l32.1848"></a><span id="l32.1848" class="difflineplus">+   *  get our folder-added and newsgroup notifications from here for now.  (This</span>
<a href="#l32.1849"></a><span id="l32.1849" class="difflineplus">+   *  will be rectified.)  </span>
<a href="#l32.1850"></a><span id="l32.1850" class="difflineplus">+   */</span>
<a href="#l32.1851"></a><span id="l32.1851" class="difflineplus">+  _folderListener: {</span>
<a href="#l32.1852"></a><span id="l32.1852" class="difflineplus">+    indexer: null,</span>
<a href="#l32.1853"></a><span id="l32.1853" class="difflineplus">+    _kFolderLoadedAtom: null,</span>
<a href="#l32.1854"></a><span id="l32.1854" class="difflineplus">+    _kKeywordsAtom: null,</span>
<a href="#l32.1855"></a><span id="l32.1855" class="difflineplus">+    _kStatusAtom: null,</span>
<a href="#l32.1856"></a><span id="l32.1856" class="difflineplus">+    _kFlaggedAtom: null,</span>
<a href="#l32.1857"></a><span id="l32.1857" class="difflineplus">+    _kJunkStatusChangedAtom: null,</span>
<a href="#l32.1858"></a><span id="l32.1858" class="difflineplus">+    </span>
<a href="#l32.1859"></a><span id="l32.1859" class="difflineplus">+    _init: function gloda_indexer_fl_init(aIndexer) {</span>
<a href="#l32.1860"></a><span id="l32.1860" class="difflineplus">+      this.indexer = aIndexer;</span>
<a href="#l32.1861"></a><span id="l32.1861" class="difflineplus">+      let atomService = Cc[&quot;@mozilla.org/atom-service;1&quot;].</span>
<a href="#l32.1862"></a><span id="l32.1862" class="difflineplus">+                        getService(Ci.nsIAtomService);</span>
<a href="#l32.1863"></a><span id="l32.1863" class="difflineplus">+      this._kFolderLoadedAtom = atomService.getAtom(&quot;FolderLoaded&quot;);</span>
<a href="#l32.1864"></a><span id="l32.1864" class="difflineplus">+      // we explicitly know about these things rather than bothering with some</span>
<a href="#l32.1865"></a><span id="l32.1865" class="difflineplus">+      //  form of registration scheme because these aren't going to change much.</span>
<a href="#l32.1866"></a><span id="l32.1866" class="difflineplus">+      this._kKeywordsAtom = atomService.getAtom(&quot;Keywords&quot;);</span>
<a href="#l32.1867"></a><span id="l32.1867" class="difflineplus">+      this._kStatusAtom = atomService.getAtom(&quot;Status&quot;);</span>
<a href="#l32.1868"></a><span id="l32.1868" class="difflineplus">+      this._kFlaggedAtom = atomService.getAtom(&quot;Flagged&quot;);</span>
<a href="#l32.1869"></a><span id="l32.1869" class="difflineplus">+      this._kJunkStatusChangedAtom = atomService.getAtom(&quot;JunkStatusChanged&quot;);</span>
<a href="#l32.1870"></a><span id="l32.1870" class="difflineplus">+    },</span>
<a href="#l32.1871"></a><span id="l32.1871" class="difflineplus">+    </span>
<a href="#l32.1872"></a><span id="l32.1872" class="difflineplus">+    /**</span>
<a href="#l32.1873"></a><span id="l32.1873" class="difflineplus">+     * Helper method to do the leg-work associated with flagging a message</span>
<a href="#l32.1874"></a><span id="l32.1874" class="difflineplus">+     *  for re-indexing because of some change in meta-state that happened to</span>
<a href="#l32.1875"></a><span id="l32.1875" class="difflineplus">+     *  it.  Job-wise, we treat this as a message addition; we are uniquely</span>
<a href="#l32.1876"></a><span id="l32.1876" class="difflineplus">+     *  identifying the message by providing its folder ID and message key, and</span>
<a href="#l32.1877"></a><span id="l32.1877" class="difflineplus">+     *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l32.1878"></a><span id="l32.1878" class="difflineplus">+     */</span>
<a href="#l32.1879"></a><span id="l32.1879" class="difflineplus">+    _reindexChangedMessage: function gloda_indexer_reindexChangedMessage(</span>
<a href="#l32.1880"></a><span id="l32.1880" class="difflineplus">+        aMsgHdr) {</span>
<a href="#l32.1881"></a><span id="l32.1881" class="difflineplus">+      // make sure the message is eligible for indexing...</span>
<a href="#l32.1882"></a><span id="l32.1882" class="difflineplus">+      let msgFolder = aMsgHdr.folder;</span>
<a href="#l32.1883"></a><span id="l32.1883" class="difflineplus">+      if (msgFolder.URI.indexOf(&quot;news://&quot;) == 0)</span>
<a href="#l32.1884"></a><span id="l32.1884" class="difflineplus">+        return;</span>
<a href="#l32.1885"></a><span id="l32.1885" class="difflineplus">+      let isFolderLocal = msgFolder instanceof Ci.nsIMsgLocalMailFolder;</span>
<a href="#l32.1886"></a><span id="l32.1886" class="difflineplus">+      if (!isFolderLocal &amp;&amp; !(msgFolder.flags&amp;Ci.nsMsgFolderFlags.Offline))</span>
<a href="#l32.1887"></a><span id="l32.1887" class="difflineplus">+        return;</span>
<a href="#l32.1888"></a><span id="l32.1888" class="difflineplus">+    </span>
<a href="#l32.1889"></a><span id="l32.1889" class="difflineplus">+      // mark the message as dirty</span>
<a href="#l32.1890"></a><span id="l32.1890" class="difflineplus">+      // (We could check for the presence of the gloda message id property</span>
<a href="#l32.1891"></a><span id="l32.1891" class="difflineplus">+      //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l32.1892"></a><span id="l32.1892" class="difflineplus">+      //  not sure whether it is worth the high-probability exception cost.) </span>
<a href="#l32.1893"></a><span id="l32.1893" class="difflineplus">+      aMsgHdr.setUint32Property(this.indexer.GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l32.1894"></a><span id="l32.1894" class="difflineplus">+      // mark the folder dirty too, so we know to look inside</span>
<a href="#l32.1895"></a><span id="l32.1895" class="difflineplus">+      msgFolder.setStringProperty(this.indexer.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l32.1896"></a><span id="l32.1896" class="difflineplus">+      </span>
<a href="#l32.1897"></a><span id="l32.1897" class="difflineplus">+      if (this.indexer._pendingAddJob === null) {</span>
<a href="#l32.1898"></a><span id="l32.1898" class="difflineplus">+        this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l32.1899"></a><span id="l32.1899" class="difflineplus">+        this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l32.1900"></a><span id="l32.1900" class="difflineplus">+        this.indexer._indexingJobGoal++;</span>
<a href="#l32.1901"></a><span id="l32.1901" class="difflineplus">+      }</span>
<a href="#l32.1902"></a><span id="l32.1902" class="difflineplus">+      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l32.1903"></a><span id="l32.1903" class="difflineplus">+      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l32.1904"></a><span id="l32.1904" class="difflineplus">+          this.indexer._indexMaxEventQueueMessages)</span>
<a href="#l32.1905"></a><span id="l32.1905" class="difflineplus">+        this.indexer._pendingAddJob.items.push(</span>
<a href="#l32.1906"></a><span id="l32.1906" class="difflineplus">+          [GlodaDatastore._mapFolder(msgFolder).id,</span>
<a href="#l32.1907"></a><span id="l32.1907" class="difflineplus">+           aMsgHdr.messageKey]);</span>
<a href="#l32.1908"></a><span id="l32.1908" class="difflineplus">+      this.indexer.indexing = true;</span>
<a href="#l32.1909"></a><span id="l32.1909" class="difflineplus">+    },</span>
<a href="#l32.1910"></a><span id="l32.1910" class="difflineplus">+  </span>
<a href="#l32.1911"></a><span id="l32.1911" class="difflineplus">+    OnItemAdded: function gloda_indexer_OnItemAdded(aParentItem, aItem) {</span>
<a href="#l32.1912"></a><span id="l32.1912" class="difflineplus">+    },</span>
<a href="#l32.1913"></a><span id="l32.1913" class="difflineplus">+    OnItemRemoved: function gloda_indexer_OnItemRemoved(aParentItem, aItem) {</span>
<a href="#l32.1914"></a><span id="l32.1914" class="difflineplus">+    },</span>
<a href="#l32.1915"></a><span id="l32.1915" class="difflineplus">+    OnItemPropertyChanged: function gloda_indexer_OnItemPropertyChanged(</span>
<a href="#l32.1916"></a><span id="l32.1916" class="difflineplus">+                             aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l32.1917"></a><span id="l32.1917" class="difflineplus">+    },</span>
<a href="#l32.1918"></a><span id="l32.1918" class="difflineplus">+    OnItemIntPropertyChanged: function gloda_indexer_OnItemIntPropertyChanged(</span>
<a href="#l32.1919"></a><span id="l32.1919" class="difflineplus">+                                aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l32.1920"></a><span id="l32.1920" class="difflineplus">+    },</span>
<a href="#l32.1921"></a><span id="l32.1921" class="difflineplus">+    OnItemBoolPropertyChanged: function gloda_indexer_OnItemBoolPropertyChanged(</span>
<a href="#l32.1922"></a><span id="l32.1922" class="difflineplus">+                                aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l32.1923"></a><span id="l32.1923" class="difflineplus">+    },</span>
<a href="#l32.1924"></a><span id="l32.1924" class="difflineplus">+    OnItemUnicharPropertyChanged:</span>
<a href="#l32.1925"></a><span id="l32.1925" class="difflineplus">+        function gloda_indexer_OnItemUnicharPropertyChanged(</span>
<a href="#l32.1926"></a><span id="l32.1926" class="difflineplus">+          aItem, aProperty, aOldValue, aNewValue) {</span>
<a href="#l32.1927"></a><span id="l32.1927" class="difflineplus">+      </span>
<a href="#l32.1928"></a><span id="l32.1928" class="difflineplus">+    },</span>
<a href="#l32.1929"></a><span id="l32.1929" class="difflineplus">+    /**</span>
<a href="#l32.1930"></a><span id="l32.1930" class="difflineplus">+     * Notice when user activity changes a message's status, or automated</span>
<a href="#l32.1931"></a><span id="l32.1931" class="difflineplus">+     *  junk processing flags a message as junk.</span>
<a href="#l32.1932"></a><span id="l32.1932" class="difflineplus">+     */</span>
<a href="#l32.1933"></a><span id="l32.1933" class="difflineplus">+    OnItemPropertyFlagChanged: function gloda_indexer_OnItemPropertyFlagChanged(</span>
<a href="#l32.1934"></a><span id="l32.1934" class="difflineplus">+                                aMsgHdr, aProperty, aOldValue, aNewValue) {</span>
<a href="#l32.1935"></a><span id="l32.1935" class="difflineplus">+      if (aProperty == this._kKeywordsAtom ||</span>
<a href="#l32.1936"></a><span id="l32.1936" class="difflineplus">+          aProperty == this._kStatusAtom ||</span>
<a href="#l32.1937"></a><span id="l32.1937" class="difflineplus">+          aProperty == this._kFlaggedAtom ||</span>
<a href="#l32.1938"></a><span id="l32.1938" class="difflineplus">+          aProperty == this._kJunkStatusChangedAtom) {</span>
<a href="#l32.1939"></a><span id="l32.1939" class="difflineplus">+        if (this.indexer.enabled) {</span>
<a href="#l32.1940"></a><span id="l32.1940" class="difflineplus">+          this.indexer._log.debug(&quot;ItemPropertyFlagChanged notification&quot;);</span>
<a href="#l32.1941"></a><span id="l32.1941" class="difflineplus">+          this._reindexChangedMessage(aMsgHdr);</span>
<a href="#l32.1942"></a><span id="l32.1942" class="difflineplus">+        }</span>
<a href="#l32.1943"></a><span id="l32.1943" class="difflineplus">+      }</span>
<a href="#l32.1944"></a><span id="l32.1944" class="difflineplus">+    },</span>
<a href="#l32.1945"></a><span id="l32.1945" class="difflineplus">+    </span>
<a href="#l32.1946"></a><span id="l32.1946" class="difflineplus">+    /**</span>
<a href="#l32.1947"></a><span id="l32.1947" class="difflineplus">+     * Get folder loaded notifications for folders that had to do some</span>
<a href="#l32.1948"></a><span id="l32.1948" class="difflineplus">+     *  (asynchronous) processing before they could be opened.</span>
<a href="#l32.1949"></a><span id="l32.1949" class="difflineplus">+     */</span>
<a href="#l32.1950"></a><span id="l32.1950" class="difflineplus">+    OnItemEvent: function gloda_indexer_OnItemEvent(aFolder, aEvent) {</span>
<a href="#l32.1951"></a><span id="l32.1951" class="difflineplus">+      if (aEvent == this._kFolderLoadedAtom)</span>
<a href="#l32.1952"></a><span id="l32.1952" class="difflineplus">+        this.indexer._onFolderLoaded(aFolder);</span>
<a href="#l32.1953"></a><span id="l32.1953" class="difflineplus">+    },</span>
<a href="#l32.1954"></a><span id="l32.1954" class="difflineplus">+  },</span>
<a href="#l32.1955"></a><span id="l32.1955" class="difflineplus">+  </span>
<a href="#l32.1956"></a><span id="l32.1956" class="difflineplus">+  /* ***** Rebuilding / Reindexing ***** */</span>
<a href="#l32.1957"></a><span id="l32.1957" class="difflineplus">+  // TODO: implement a folder observer doodad to handle rebuilding / reindexing</span>
<a href="#l32.1958"></a><span id="l32.1958" class="difflineplus">+  /**</span>
<a href="#l32.1959"></a><span id="l32.1959" class="difflineplus">+   * Allow us to invalidate an outstanding folder traversal because the</span>
<a href="#l32.1960"></a><span id="l32.1960" class="difflineplus">+   *  underlying database is going away.  We use other means for detecting </span>
<a href="#l32.1961"></a><span id="l32.1961" class="difflineplus">+   *  modifications of the message (labeling, marked (un)read, starred, etc.)</span>
<a href="#l32.1962"></a><span id="l32.1962" class="difflineplus">+   *</span>
<a href="#l32.1963"></a><span id="l32.1963" class="difflineplus">+   * This is an nsIDBChangeListener listening to an nsIDBChangeAnnouncer.  To</span>
<a href="#l32.1964"></a><span id="l32.1964" class="difflineplus">+   *  add ourselves, we get us a nice nsMsgDatabase, query it to the announcer,</span>
<a href="#l32.1965"></a><span id="l32.1965" class="difflineplus">+   *  then call AddListener.</span>
<a href="#l32.1966"></a><span id="l32.1966" class="difflineplus">+   */</span>
<a href="#l32.1967"></a><span id="l32.1967" class="difflineplus">+  _databaseAnnouncerListener: {</span>
<a href="#l32.1968"></a><span id="l32.1968" class="difflineplus">+    indexer: null,</span>
<a href="#l32.1969"></a><span id="l32.1969" class="difflineplus">+    onAnnouncerGoingAway: function gloda_indexer_dbGoingAway(</span>
<a href="#l32.1970"></a><span id="l32.1970" class="difflineplus">+                                         aDBChangeAnnouncer) {</span>
<a href="#l32.1971"></a><span id="l32.1971" class="difflineplus">+      this.indexer._indexerLeaveFolder(false);</span>
<a href="#l32.1972"></a><span id="l32.1972" class="difflineplus">+    },</span>
<a href="#l32.1973"></a><span id="l32.1973" class="difflineplus">+    </span>
<a href="#l32.1974"></a><span id="l32.1974" class="difflineplus">+    onHdrFlagsChanged: function(aHdrChanged, aOldFlags, aNewFlags, aInstigator) {},</span>
<a href="#l32.1975"></a><span id="l32.1975" class="difflineplus">+    onHdrDeleted: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l32.1976"></a><span id="l32.1976" class="difflineplus">+    onHdrAdded: function(aHdrChanged, aParentKey, aFlags, aInstigator) {},</span>
<a href="#l32.1977"></a><span id="l32.1977" class="difflineplus">+    onParentChanged: function(aKeyChanged, aOldParent, aNewParent, </span>
<a href="#l32.1978"></a><span id="l32.1978" class="difflineplus">+                              aInstigator) {},</span>
<a href="#l32.1979"></a><span id="l32.1979" class="difflineplus">+    onReadChanged: function(aInstigator) {},</span>
<a href="#l32.1980"></a><span id="l32.1980" class="difflineplus">+    onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l32.1981"></a><span id="l32.1981" class="difflineplus">+    onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l32.1982"></a><span id="l32.1982" class="difflineplus">+                                    aInstigator) {},</span>
<a href="#l32.1983"></a><span id="l32.1983" class="difflineplus">+  },</span>
<a href="#l32.1984"></a><span id="l32.1984" class="difflineplus">+  </span>
<a href="#l32.1985"></a><span id="l32.1985" class="difflineplus">+  /* ***** MailNews Shutdown ***** */</span>
<a href="#l32.1986"></a><span id="l32.1986" class="difflineplus">+  /**</span>
<a href="#l32.1987"></a><span id="l32.1987" class="difflineplus">+   * The shutdown task exists because shutdown may entail waiting for the</span>
<a href="#l32.1988"></a><span id="l32.1988" class="difflineplus">+   *  datastore to ensure that all async statements have completed execution.</span>
<a href="#l32.1989"></a><span id="l32.1989" class="difflineplus">+   *  Merely observing on 'quit-application' is insufficient because that would</span>
<a href="#l32.1990"></a><span id="l32.1990" class="difflineplus">+   *  not allow us to ensure that Thunderbird doesn't quit/teardown XPCOM before</span>
<a href="#l32.1991"></a><span id="l32.1991" class="difflineplus">+   *  we finish shutting down.</span>
<a href="#l32.1992"></a><span id="l32.1992" class="difflineplus">+   *</span>
<a href="#l32.1993"></a><span id="l32.1993" class="difflineplus">+   * We implement nsIMsgShutdownTask, served up by nsIMsgShutdownService.  We</span>
<a href="#l32.1994"></a><span id="l32.1994" class="difflineplus">+   *  offer our services by registering ourselves as a &quot;msg-shutdown&quot; observer</span>
<a href="#l32.1995"></a><span id="l32.1995" class="difflineplus">+   *  with the observer service.</span>
<a href="#l32.1996"></a><span id="l32.1996" class="difflineplus">+   */</span>
<a href="#l32.1997"></a><span id="l32.1997" class="difflineplus">+  _shutdownTask: {</span>
<a href="#l32.1998"></a><span id="l32.1998" class="difflineplus">+    QueryInterface: XPCOMUtils.generateQI([Ci.nsIMsgShutdownTask]),</span>
<a href="#l32.1999"></a><span id="l32.1999" class="difflineplus">+  </span>
<a href="#l32.2000"></a><span id="l32.2000" class="difflineplus">+    indexer: null,</span>
<a href="#l32.2001"></a><span id="l32.2001" class="difflineplus">+    </span>
<a href="#l32.2002"></a><span id="l32.2002" class="difflineplus">+    /**</span>
<a href="#l32.2003"></a><span id="l32.2003" class="difflineplus">+     * Indicate that we need to run, because if anyone knows about us, we</span>
<a href="#l32.2004"></a><span id="l32.2004" class="difflineplus">+     *  clearly are active and need to perform a shutdown.</span>
<a href="#l32.2005"></a><span id="l32.2005" class="difflineplus">+     */</span>
<a href="#l32.2006"></a><span id="l32.2006" class="difflineplus">+    get needsToRunTask() {</span>
<a href="#l32.2007"></a><span id="l32.2007" class="difflineplus">+      return true;</span>
<a href="#l32.2008"></a><span id="l32.2008" class="difflineplus">+    },</span>
<a href="#l32.2009"></a><span id="l32.2009" class="difflineplus">+    </span>
<a href="#l32.2010"></a><span id="l32.2010" class="difflineplus">+    /**</span>
<a href="#l32.2011"></a><span id="l32.2011" class="difflineplus">+     * Tell the indexer shutdown logic to happen.  The indexer's shutdown</span>
<a href="#l32.2012"></a><span id="l32.2012" class="difflineplus">+     *  returns true on complete shutdown, or false on async pending.  This</span>
<a href="#l32.2013"></a><span id="l32.2013" class="difflineplus">+     *  is the opposite of our nsIMsgShutdownTask behaviour, so we invert it.</span>
<a href="#l32.2014"></a><span id="l32.2014" class="difflineplus">+     */</span>
<a href="#l32.2015"></a><span id="l32.2015" class="difflineplus">+    doShutdownTask: function gloda_indexer_doShutdownTask(aUrlListener,</span>
<a href="#l32.2016"></a><span id="l32.2016" class="difflineplus">+                                                          aMsgWingow) {</span>
<a href="#l32.2017"></a><span id="l32.2017" class="difflineplus">+      return !this.indexer._shutdown(aUrlListener);</span>
<a href="#l32.2018"></a><span id="l32.2018" class="difflineplus">+    },</span>
<a href="#l32.2019"></a><span id="l32.2019" class="difflineplus">+    </span>
<a href="#l32.2020"></a><span id="l32.2020" class="difflineplus">+    getCurrentTaskName: function gloda_indexer_getCurrentTaskName() {</span>
<a href="#l32.2021"></a><span id="l32.2021" class="difflineplus">+      return &quot;Global Database Indexer&quot;; // L10n-me</span>
<a href="#l32.2022"></a><span id="l32.2022" class="difflineplus">+    },</span>
<a href="#l32.2023"></a><span id="l32.2023" class="difflineplus">+  }, </span>
<a href="#l32.2024"></a><span id="l32.2024" class="difflineplus">+  </span>
<a href="#l32.2025"></a><span id="l32.2025" class="difflineplus">+  _indexMessage: function gloda_indexMessage(aMsgHdr, aCallbackHandle) {</span>
<a href="#l32.2026"></a><span id="l32.2026" class="difflineplus">+    this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l32.2027"></a><span id="l32.2027" class="difflineplus">+                    aMsgHdr.subject);</span>
<a href="#l32.2028"></a><span id="l32.2028" class="difflineplus">+    MsgHdrToMimeMessage(aMsgHdr, aCallbackHandle.callbackThis,</span>
<a href="#l32.2029"></a><span id="l32.2029" class="difflineplus">+        aCallbackHandle.callback);</span>
<a href="#l32.2030"></a><span id="l32.2030" class="difflineplus">+    let [,aMimeMsg] = yield this.kWorkAsync;</span>
<a href="#l32.2031"></a><span id="l32.2031" class="difflineplus">+</span>
<a href="#l32.2032"></a><span id="l32.2032" class="difflineplus">+    if (aMimeMsg)</span>
<a href="#l32.2033"></a><span id="l32.2033" class="difflineplus">+      this._log.debug(&quot;  * Got Mime Message!&quot;);</span>
<a href="#l32.2034"></a><span id="l32.2034" class="difflineplus">+    else</span>
<a href="#l32.2035"></a><span id="l32.2035" class="difflineplus">+      this._log.debug(&quot;  * Did not get body!&quot;);</span>
<a href="#l32.2036"></a><span id="l32.2036" class="difflineplus">+</span>
<a href="#l32.2037"></a><span id="l32.2037" class="difflineplus">+    // -- Find/create the conversation the message belongs to.</span>
<a href="#l32.2038"></a><span id="l32.2038" class="difflineplus">+    // Our invariant is that all messages that exist in the database belong to</span>
<a href="#l32.2039"></a><span id="l32.2039" class="difflineplus">+    //  a conversation.</span>
<a href="#l32.2040"></a><span id="l32.2040" class="difflineplus">+    </span>
<a href="#l32.2041"></a><span id="l32.2041" class="difflineplus">+    // - See if any of the ancestors exist and have a conversationID...</span>
<a href="#l32.2042"></a><span id="l32.2042" class="difflineplus">+    // (references are ordered from old [0] to new [n-1])</span>
<a href="#l32.2043"></a><span id="l32.2043" class="difflineplus">+    let references = [aMsgHdr.getStringReference(i) for each</span>
<a href="#l32.2044"></a><span id="l32.2044" class="difflineplus">+                      (i in range(0, aMsgHdr.numReferences))];</span>
<a href="#l32.2045"></a><span id="l32.2045" class="difflineplus">+    // also see if we already know about the message...</span>
<a href="#l32.2046"></a><span id="l32.2046" class="difflineplus">+    references.push(aMsgHdr.messageId);</span>
<a href="#l32.2047"></a><span id="l32.2047" class="difflineplus">+    </span>
<a href="#l32.2048"></a><span id="l32.2048" class="difflineplus">+    this._datastore.getMessagesByMessageID(references, aCallbackHandle.callback,</span>
<a href="#l32.2049"></a><span id="l32.2049" class="difflineplus">+      aCallbackHandle.callbackThis);</span>
<a href="#l32.2050"></a><span id="l32.2050" class="difflineplus">+    // (ancestorLists has a direct correspondence to the message ids)</span>
<a href="#l32.2051"></a><span id="l32.2051" class="difflineplus">+    let ancestorLists = yield this.kWorkAsync; </span>
<a href="#l32.2052"></a><span id="l32.2052" class="difflineplus">+    </span>
<a href="#l32.2053"></a><span id="l32.2053" class="difflineplus">+    this._log.debug(&quot;ancestors raw: &quot; + ancestorLists);</span>
<a href="#l32.2054"></a><span id="l32.2054" class="difflineplus">+    this._log.debug(&quot;ref len: &quot; + references.length + &quot; anc len: &quot; + ancestorLists.length);</span>
<a href="#l32.2055"></a><span id="l32.2055" class="difflineplus">+    this._log.debug(&quot;references: &quot; + Log4Moz.enumerateProperties(references).join(&quot;,&quot;));</span>
<a href="#l32.2056"></a><span id="l32.2056" class="difflineplus">+    this._log.debug(&quot;ancestors: &quot; + Log4Moz.enumerateProperties(ancestorLists).join(&quot;,&quot;));</span>
<a href="#l32.2057"></a><span id="l32.2057" class="difflineplus">+    </span>
<a href="#l32.2058"></a><span id="l32.2058" class="difflineplus">+    // pull our current message lookup results off</span>
<a href="#l32.2059"></a><span id="l32.2059" class="difflineplus">+    references.pop();</span>
<a href="#l32.2060"></a><span id="l32.2060" class="difflineplus">+    let candidateCurMsgs = ancestorLists.pop();</span>
<a href="#l32.2061"></a><span id="l32.2061" class="difflineplus">+    </span>
<a href="#l32.2062"></a><span id="l32.2062" class="difflineplus">+    let conversationID = null;</span>
<a href="#l32.2063"></a><span id="l32.2063" class="difflineplus">+    // -- figure out the conversation ID</span>
<a href="#l32.2064"></a><span id="l32.2064" class="difflineplus">+    // if we have a clone/already exist, just use his conversation ID</span>
<a href="#l32.2065"></a><span id="l32.2065" class="difflineplus">+    if (candidateCurMsgs.length &gt; 0) {</span>
<a href="#l32.2066"></a><span id="l32.2066" class="difflineplus">+      conversationID = candidateCurMsgs[0].conversationID;</span>
<a href="#l32.2067"></a><span id="l32.2067" class="difflineplus">+    }</span>
<a href="#l32.2068"></a><span id="l32.2068" class="difflineplus">+    // otherwise check out our ancestors</span>
<a href="#l32.2069"></a><span id="l32.2069" class="difflineplus">+    else {</span>
<a href="#l32.2070"></a><span id="l32.2070" class="difflineplus">+      // (walk from closest to furthest ancestor)</span>
<a href="#l32.2071"></a><span id="l32.2071" class="difflineplus">+      for (let iAncestor = ancestorLists.length-1; iAncestor &gt;= 0;</span>
<a href="#l32.2072"></a><span id="l32.2072" class="difflineplus">+          --iAncestor) {</span>
<a href="#l32.2073"></a><span id="l32.2073" class="difflineplus">+        let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l32.2074"></a><span id="l32.2074" class="difflineplus">+        </span>
<a href="#l32.2075"></a><span id="l32.2075" class="difflineplus">+        if (ancestorList.length &gt; 0) {</span>
<a href="#l32.2076"></a><span id="l32.2076" class="difflineplus">+          // we only care about the first instance of the message because we are</span>
<a href="#l32.2077"></a><span id="l32.2077" class="difflineplus">+          //  able to guarantee the invariant that all messages with the same</span>
<a href="#l32.2078"></a><span id="l32.2078" class="difflineplus">+          //  message id belong to the same conversation. </span>
<a href="#l32.2079"></a><span id="l32.2079" class="difflineplus">+          let ancestor = ancestorList[0];</span>
<a href="#l32.2080"></a><span id="l32.2080" class="difflineplus">+          if (conversationID === null)</span>
<a href="#l32.2081"></a><span id="l32.2081" class="difflineplus">+            conversationID = ancestor.conversationID;</span>
<a href="#l32.2082"></a><span id="l32.2082" class="difflineplus">+          else if (conversationID != ancestor.conversationID)</span>
<a href="#l32.2083"></a><span id="l32.2083" class="difflineplus">+            this._log.error(&quot;Inconsistency in conversations invariant on &quot; +</span>
<a href="#l32.2084"></a><span id="l32.2084" class="difflineplus">+                            ancestor.headerMessageID + &quot;.  It has conv id &quot; +</span>
<a href="#l32.2085"></a><span id="l32.2085" class="difflineplus">+                            ancestor.conversationID + &quot; but expected &quot; + </span>
<a href="#l32.2086"></a><span id="l32.2086" class="difflineplus">+                            conversationID + &quot;. ID: &quot; + ancestor.id);</span>
<a href="#l32.2087"></a><span id="l32.2087" class="difflineplus">+        }</span>
<a href="#l32.2088"></a><span id="l32.2088" class="difflineplus">+      }</span>
<a href="#l32.2089"></a><span id="l32.2089" class="difflineplus">+    }</span>
<a href="#l32.2090"></a><span id="l32.2090" class="difflineplus">+    </span>
<a href="#l32.2091"></a><span id="l32.2091" class="difflineplus">+    let conversation = null;</span>
<a href="#l32.2092"></a><span id="l32.2092" class="difflineplus">+    // nobody had one?  create a new conversation</span>
<a href="#l32.2093"></a><span id="l32.2093" class="difflineplus">+    if (conversationID === null) {</span>
<a href="#l32.2094"></a><span id="l32.2094" class="difflineplus">+      // (the create method could issue the id, making the call return</span>
<a href="#l32.2095"></a><span id="l32.2095" class="difflineplus">+      //  without waiting for the database...)</span>
<a href="#l32.2096"></a><span id="l32.2096" class="difflineplus">+      conversation = this._datastore.createConversation(</span>
<a href="#l32.2097"></a><span id="l32.2097" class="difflineplus">+          aMsgHdr.mime2DecodedSubject, null, null);</span>
<a href="#l32.2098"></a><span id="l32.2098" class="difflineplus">+      conversationID = conversation.id;</span>
<a href="#l32.2099"></a><span id="l32.2099" class="difflineplus">+    }</span>
<a href="#l32.2100"></a><span id="l32.2100" class="difflineplus">+    </span>
<a href="#l32.2101"></a><span id="l32.2101" class="difflineplus">+    // Walk from furthest to closest ancestor, creating the ancestors that don't</span>
<a href="#l32.2102"></a><span id="l32.2102" class="difflineplus">+    //  exist. (This is possible if previous messages that were consumed in this</span>
<a href="#l32.2103"></a><span id="l32.2103" class="difflineplus">+    //  thread only had an in-reply-to or for some reason did not otherwise</span>
<a href="#l32.2104"></a><span id="l32.2104" class="difflineplus">+    //  provide the full references chain.)</span>
<a href="#l32.2105"></a><span id="l32.2105" class="difflineplus">+    for (let iAncestor = 0; iAncestor &lt; ancestorLists.length; ++iAncestor) {</span>
<a href="#l32.2106"></a><span id="l32.2106" class="difflineplus">+      let ancestorList = ancestorLists[iAncestor];</span>
<a href="#l32.2107"></a><span id="l32.2107" class="difflineplus">+      </span>
<a href="#l32.2108"></a><span id="l32.2108" class="difflineplus">+      if (ancestorList.length == 0) {</span>
<a href="#l32.2109"></a><span id="l32.2109" class="difflineplus">+        this._log.debug(&quot;creating message with: null, &quot; + conversationID +</span>
<a href="#l32.2110"></a><span id="l32.2110" class="difflineplus">+                        &quot;, &quot; + references[iAncestor] +</span>
<a href="#l32.2111"></a><span id="l32.2111" class="difflineplus">+                        &quot;, null.&quot;);</span>
<a href="#l32.2112"></a><span id="l32.2112" class="difflineplus">+        let ancestor = this._datastore.createMessage(null, null, // ghost</span>
<a href="#l32.2113"></a><span id="l32.2113" class="difflineplus">+                                                     conversationID, null,</span>
<a href="#l32.2114"></a><span id="l32.2114" class="difflineplus">+                                                     references[iAncestor],</span>
<a href="#l32.2115"></a><span id="l32.2115" class="difflineplus">+                                                     null, // no subject</span>
<a href="#l32.2116"></a><span id="l32.2116" class="difflineplus">+                                                     null, // no body</span>
<a href="#l32.2117"></a><span id="l32.2117" class="difflineplus">+                                                     null); // no attachments</span>
<a href="#l32.2118"></a><span id="l32.2118" class="difflineplus">+        ancestorLists[iAncestor].push(ancestor);</span>
<a href="#l32.2119"></a><span id="l32.2119" class="difflineplus">+      }</span>
<a href="#l32.2120"></a><span id="l32.2120" class="difflineplus">+    }</span>
<a href="#l32.2121"></a><span id="l32.2121" class="difflineplus">+    // now all our ancestors exist, though they may be ghost-like...</span>
<a href="#l32.2122"></a><span id="l32.2122" class="difflineplus">+    </span>
<a href="#l32.2123"></a><span id="l32.2123" class="difflineplus">+    // find if there's a ghost version of our message or we already have indexed</span>
<a href="#l32.2124"></a><span id="l32.2124" class="difflineplus">+    //  this message.</span>
<a href="#l32.2125"></a><span id="l32.2125" class="difflineplus">+    let curMsg = null;</span>
<a href="#l32.2126"></a><span id="l32.2126" class="difflineplus">+    this._log.debug(candidateCurMsgs.length + &quot; candidate messages&quot;);</span>
<a href="#l32.2127"></a><span id="l32.2127" class="difflineplus">+    for (let iCurCand = 0; iCurCand &lt; candidateCurMsgs.length; iCurCand++) {</span>
<a href="#l32.2128"></a><span id="l32.2128" class="difflineplus">+      let candMsg = candidateCurMsgs[iCurCand];</span>
<a href="#l32.2129"></a><span id="l32.2129" class="difflineplus">+</span>
<a href="#l32.2130"></a><span id="l32.2130" class="difflineplus">+      this._log.debug(&quot;candidate folderID: &quot; + candMsg.folderID +</span>
<a href="#l32.2131"></a><span id="l32.2131" class="difflineplus">+                      &quot; messageKey: &quot; + candMsg.messageKey);</span>
<a href="#l32.2132"></a><span id="l32.2132" class="difflineplus">+      </span>
<a href="#l32.2133"></a><span id="l32.2133" class="difflineplus">+      if (candMsg.folderURI == aMsgHdr.folder.URI) {</span>
<a href="#l32.2134"></a><span id="l32.2134" class="difflineplus">+        // if we are in the same folder and we have the same message key, we</span>
<a href="#l32.2135"></a><span id="l32.2135" class="difflineplus">+        //  are definitely the same, stop looking.</span>
<a href="#l32.2136"></a><span id="l32.2136" class="difflineplus">+        if (candMsg.messageKey == aMsgHdr.messageKey) {</span>
<a href="#l32.2137"></a><span id="l32.2137" class="difflineplus">+          curMsg = candMsg;</span>
<a href="#l32.2138"></a><span id="l32.2138" class="difflineplus">+          break;</span>
<a href="#l32.2139"></a><span id="l32.2139" class="difflineplus">+        }</span>
<a href="#l32.2140"></a><span id="l32.2140" class="difflineplus">+        // if we are in the same folder and the candidate message has a null</span>
<a href="#l32.2141"></a><span id="l32.2141" class="difflineplus">+        //  message key, we treat it as our best option unless we find an exact</span>
<a href="#l32.2142"></a><span id="l32.2142" class="difflineplus">+        //  key match. (this would happen because the 'move' notification case</span>
<a href="#l32.2143"></a><span id="l32.2143" class="difflineplus">+        //  has to deal with not knowing the target message key.  this case</span>
<a href="#l32.2144"></a><span id="l32.2144" class="difflineplus">+        //  will hopefully be somewhat improved in the future to not go through</span>
<a href="#l32.2145"></a><span id="l32.2145" class="difflineplus">+        //  this path which mandates re-indexing of the message in its entirety)</span>
<a href="#l32.2146"></a><span id="l32.2146" class="difflineplus">+        if (candMsg.messageKey === null)</span>
<a href="#l32.2147"></a><span id="l32.2147" class="difflineplus">+          curMsg = candMsg;</span>
<a href="#l32.2148"></a><span id="l32.2148" class="difflineplus">+        // if we are in the same folder and the candidate message's underlying</span>
<a href="#l32.2149"></a><span id="l32.2149" class="difflineplus">+        //  message no longer exists/matches, we'll assume we are the same but</span>
<a href="#l32.2150"></a><span id="l32.2150" class="difflineplus">+        //  were betrayed by a re-indexing or something, but we have to make</span>
<a href="#l32.2151"></a><span id="l32.2151" class="difflineplus">+        //  sure a perfect match doesn't turn up.</span>
<a href="#l32.2152"></a><span id="l32.2152" class="difflineplus">+        else if ((curMsg === null) &amp;&amp; (candMsg.folderMessage === null))</span>
<a href="#l32.2153"></a><span id="l32.2153" class="difflineplus">+          curMsg = candMsg;</span>
<a href="#l32.2154"></a><span id="l32.2154" class="difflineplus">+      }</span>
<a href="#l32.2155"></a><span id="l32.2155" class="difflineplus">+      // our choice of last resort, but still okay, is a ghost message</span>
<a href="#l32.2156"></a><span id="l32.2156" class="difflineplus">+      else if ((curMsg === null) &amp;&amp; (candMsg.folderID === null)) {</span>
<a href="#l32.2157"></a><span id="l32.2157" class="difflineplus">+        curMsg = candMsg;</span>
<a href="#l32.2158"></a><span id="l32.2158" class="difflineplus">+      }</span>
<a href="#l32.2159"></a><span id="l32.2159" class="difflineplus">+    }</span>
<a href="#l32.2160"></a><span id="l32.2160" class="difflineplus">+    </span>
<a href="#l32.2161"></a><span id="l32.2161" class="difflineplus">+    let attachmentNames = null;</span>
<a href="#l32.2162"></a><span id="l32.2162" class="difflineplus">+    if (aMimeMsg) {</span>
<a href="#l32.2163"></a><span id="l32.2163" class="difflineplus">+      let allAttachmentNames = [att.name for each</span>
<a href="#l32.2164"></a><span id="l32.2164" class="difflineplus">+                                ([i, att] in Iterator(aMimeMsg.allAttachments))</span>
<a href="#l32.2165"></a><span id="l32.2165" class="difflineplus">+                                if (att.isRealAttachment)];</span>
<a href="#l32.2166"></a><span id="l32.2166" class="difflineplus">+      // we need some kind of delimeter for the names.  we use a newline.</span>
<a href="#l32.2167"></a><span id="l32.2167" class="difflineplus">+      if (allAttachmentNames)</span>
<a href="#l32.2168"></a><span id="l32.2168" class="difflineplus">+        attachmentNames = allAttachmentNames.join(&quot;\n&quot;);</span>
<a href="#l32.2169"></a><span id="l32.2169" class="difflineplus">+    } </span>
<a href="#l32.2170"></a><span id="l32.2170" class="difflineplus">+    </span>
<a href="#l32.2171"></a><span id="l32.2171" class="difflineplus">+    let isNew;</span>
<a href="#l32.2172"></a><span id="l32.2172" class="difflineplus">+    if (curMsg === null) {</span>
<a href="#l32.2173"></a><span id="l32.2173" class="difflineplus">+      curMsg = this._datastore.createMessage(aMsgHdr.folder,</span>
<a href="#l32.2174"></a><span id="l32.2174" class="difflineplus">+                                             aMsgHdr.messageKey,                </span>
<a href="#l32.2175"></a><span id="l32.2175" class="difflineplus">+                                             conversationID,</span>
<a href="#l32.2176"></a><span id="l32.2176" class="difflineplus">+                                             aMsgHdr.date,</span>
<a href="#l32.2177"></a><span id="l32.2177" class="difflineplus">+                                             aMsgHdr.messageId);</span>
<a href="#l32.2178"></a><span id="l32.2178" class="difflineplus">+      curMsg._conversation = conversation;</span>
<a href="#l32.2179"></a><span id="l32.2179" class="difflineplus">+      isNew = true;</span>
<a href="#l32.2180"></a><span id="l32.2180" class="difflineplus">+    }</span>
<a href="#l32.2181"></a><span id="l32.2181" class="difflineplus">+    else {</span>
<a href="#l32.2182"></a><span id="l32.2182" class="difflineplus">+      isNew = (curMsg._folderID === null); // aka was-a-ghost</span>
<a href="#l32.2183"></a><span id="l32.2183" class="difflineplus">+      // (messageKey can be null if it's not new in the move-case)</span>
<a href="#l32.2184"></a><span id="l32.2184" class="difflineplus">+      curMsg._folderID = this._datastore._mapFolder(aMsgHdr.folder).id;</span>
<a href="#l32.2185"></a><span id="l32.2185" class="difflineplus">+      curMsg._messageKey = aMsgHdr.messageKey;</span>
<a href="#l32.2186"></a><span id="l32.2186" class="difflineplus">+      curMsg.date = new Date(aMsgHdr.date / 1000); </span>
<a href="#l32.2187"></a><span id="l32.2187" class="difflineplus">+      // note: we are assuming that our matching logic is flawless in that</span>
<a href="#l32.2188"></a><span id="l32.2188" class="difflineplus">+      //  if this message was not a ghost, we are assuming the 'body'</span>
<a href="#l32.2189"></a><span id="l32.2189" class="difflineplus">+      //  associated with the id is still exactly the same.  It is conceivable</span>
<a href="#l32.2190"></a><span id="l32.2190" class="difflineplus">+      //  that there are cases where this is not true.</span>
<a href="#l32.2191"></a><span id="l32.2191" class="difflineplus">+    }</span>
<a href="#l32.2192"></a><span id="l32.2192" class="difflineplus">+</span>
<a href="#l32.2193"></a><span id="l32.2193" class="difflineplus">+    if (aMimeMsg) {</span>
<a href="#l32.2194"></a><span id="l32.2194" class="difflineplus">+      let bodyPlain = aMimeMsg.bodyPlain;</span>
<a href="#l32.2195"></a><span id="l32.2195" class="difflineplus">+      if (bodyPlain) {</span>
<a href="#l32.2196"></a><span id="l32.2196" class="difflineplus">+        curMsg._bodyLines = bodyPlain.split(/\r?\n/);</span>
<a href="#l32.2197"></a><span id="l32.2197" class="difflineplus">+        curMsg._content = new GlodaContent();</span>
<a href="#l32.2198"></a><span id="l32.2198" class="difflineplus">+      }</span>
<a href="#l32.2199"></a><span id="l32.2199" class="difflineplus">+      else {</span>
<a href="#l32.2200"></a><span id="l32.2200" class="difflineplus">+        this._log.warn(&quot;Have aMimeMsg but not bodyPlain?&quot;);</span>
<a href="#l32.2201"></a><span id="l32.2201" class="difflineplus">+      }</span>
<a href="#l32.2202"></a><span id="l32.2202" class="difflineplus">+    }</span>
<a href="#l32.2203"></a><span id="l32.2203" class="difflineplus">+    else {</span>
<a href="#l32.2204"></a><span id="l32.2204" class="difflineplus">+      this._log.warn(&quot;aMimeMsg went away?&quot;);</span>
<a href="#l32.2205"></a><span id="l32.2205" class="difflineplus">+    }</span>
<a href="#l32.2206"></a><span id="l32.2206" class="difflineplus">+    </span>
<a href="#l32.2207"></a><span id="l32.2207" class="difflineplus">+    if (isNew) {</span>
<a href="#l32.2208"></a><span id="l32.2208" class="difflineplus">+      curMsg._isNew = true;</span>
<a href="#l32.2209"></a><span id="l32.2209" class="difflineplus">+      curMsg._subject = aMsgHdr.mime2DecodedSubject;</span>
<a href="#l32.2210"></a><span id="l32.2210" class="difflineplus">+      curMsg._attachmentNames = attachmentNames;</span>
<a href="#l32.2211"></a><span id="l32.2211" class="difflineplus">+    }</span>
<a href="#l32.2212"></a><span id="l32.2212" class="difflineplus">+    </span>
<a href="#l32.2213"></a><span id="l32.2213" class="difflineplus">+    yield aCallbackHandle.pushAndGo(</span>
<a href="#l32.2214"></a><span id="l32.2214" class="difflineplus">+        Gloda.grokNounItem(curMsg,</span>
<a href="#l32.2215"></a><span id="l32.2215" class="difflineplus">+            {header: aMsgHdr, mime: aMimeMsg,</span>
<a href="#l32.2216"></a><span id="l32.2216" class="difflineplus">+             bodyLines: curMsg._bodyLines, content: curMsg._content},</span>
<a href="#l32.2217"></a><span id="l32.2217" class="difflineplus">+            isNew,</span>
<a href="#l32.2218"></a><span id="l32.2218" class="difflineplus">+            aCallbackHandle));</span>
<a href="#l32.2219"></a><span id="l32.2219" class="difflineplus">+    </span>
<a href="#l32.2220"></a><span id="l32.2220" class="difflineplus">+    delete curMsg._bodyLines;</span>
<a href="#l32.2221"></a><span id="l32.2221" class="difflineplus">+    delete curMsg._content;</span>
<a href="#l32.2222"></a><span id="l32.2222" class="difflineplus">+    delete curMsg._isNew;</span>
<a href="#l32.2223"></a><span id="l32.2223" class="difflineplus">+    delete curMsg._subject;</span>
<a href="#l32.2224"></a><span id="l32.2224" class="difflineplus">+    delete curMsg._attachmentNames;</span>
<a href="#l32.2225"></a><span id="l32.2225" class="difflineplus">+    </span>
<a href="#l32.2226"></a><span id="l32.2226" class="difflineplus">+    // we want to update the header for messages only after the transaction</span>
<a href="#l32.2227"></a><span id="l32.2227" class="difflineplus">+    //  irrevocably hits the disk.  otherwise we could get confused if the</span>
<a href="#l32.2228"></a><span id="l32.2228" class="difflineplus">+    //  transaction rolls back or what not.</span>
<a href="#l32.2229"></a><span id="l32.2229" class="difflineplus">+    GlodaDatastore.runPostCommit(MakeCleanMsgHdrCallback(aMsgHdr, curMsg.id));</span>
<a href="#l32.2230"></a><span id="l32.2230" class="difflineplus">+    </span>
<a href="#l32.2231"></a><span id="l32.2231" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l32.2232"></a><span id="l32.2232" class="difflineplus">+  },</span>
<a href="#l32.2233"></a><span id="l32.2233" class="difflineplus">+  </span>
<a href="#l32.2234"></a><span id="l32.2234" class="difflineplus">+  /**</span>
<a href="#l32.2235"></a><span id="l32.2235" class="difflineplus">+   * Wipe a message out of existence from our index.  This is slightly more</span>
<a href="#l32.2236"></a><span id="l32.2236" class="difflineplus">+   *  tricky than one would first expect because there are potentially</span>
<a href="#l32.2237"></a><span id="l32.2237" class="difflineplus">+   *  attributes not immediately associated with this message that reference</span>
<a href="#l32.2238"></a><span id="l32.2238" class="difflineplus">+   *  the message.  Not only that, but deletion of messages may leave a</span>
<a href="#l32.2239"></a><span id="l32.2239" class="difflineplus">+   *  conversation posessing only ghost messages, which we don't want, so we</span>
<a href="#l32.2240"></a><span id="l32.2240" class="difflineplus">+   *  need to nuke the moot conversation and its moot ghost messages.</span>
<a href="#l32.2241"></a><span id="l32.2241" class="difflineplus">+   * For now, we are actually punting on that trickiness, and the exact</span>
<a href="#l32.2242"></a><span id="l32.2242" class="difflineplus">+   *  nuances aren't defined yet because we have not decided whether to store</span>
<a href="#l32.2243"></a><span id="l32.2243" class="difflineplus">+   *  such attributes redundantly.  For example, if we have subject-pred-object,</span>
<a href="#l32.2244"></a><span id="l32.2244" class="difflineplus">+   *  we could actually store this as attributes (subject, id, object) and</span>
<a href="#l32.2245"></a><span id="l32.2245" class="difflineplus">+   *  (object, id, subject).  In such a case, we could query on (subject, *)</span>
<a href="#l32.2246"></a><span id="l32.2246" class="difflineplus">+   *  and use the results to delete the (object, id, subject) case.  If we</span>
<a href="#l32.2247"></a><span id="l32.2247" class="difflineplus">+   *  don't redundantly store attributes, we can deal with the problem by</span>
<a href="#l32.2248"></a><span id="l32.2248" class="difflineplus">+   *  collecting up all the attributes that accept a message as their object</span>
<a href="#l32.2249"></a><span id="l32.2249" class="difflineplus">+   *  type and issuing a delete against that.  For example, delete (*, [1,2,3],</span>
<a href="#l32.2250"></a><span id="l32.2250" class="difflineplus">+   *  message id).</span>
<a href="#l32.2251"></a><span id="l32.2251" class="difflineplus">+   * (We are punting because we haven't implemented support for generating</span>
<a href="#l32.2252"></a><span id="l32.2252" class="difflineplus">+   *  attributes like that yet.)</span>
<a href="#l32.2253"></a><span id="l32.2253" class="difflineplus">+   *</span>
<a href="#l32.2254"></a><span id="l32.2254" class="difflineplus">+   * @TODO: implement deletion of attributes that reference (deleted) messages</span>
<a href="#l32.2255"></a><span id="l32.2255" class="difflineplus">+   */</span>
<a href="#l32.2256"></a><span id="l32.2256" class="difflineplus">+  _deleteMessage: function gloda_index_deleteMessage(aMessage) {</span>
<a href="#l32.2257"></a><span id="l32.2257" class="difflineplus">+    // -- delete our attributes</span>
<a href="#l32.2258"></a><span id="l32.2258" class="difflineplus">+    // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l32.2259"></a><span id="l32.2259" class="difflineplus">+    //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l32.2260"></a><span id="l32.2260" class="difflineplus">+    //  schema but the back-end ignores it)</span>
<a href="#l32.2261"></a><span id="l32.2261" class="difflineplus">+    aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l32.2262"></a><span id="l32.2262" class="difflineplus">+    </span>
<a href="#l32.2263"></a><span id="l32.2263" class="difflineplus">+    // -- delete our message or ghost us, and maybe nuke the whole conversation</span>
<a href="#l32.2264"></a><span id="l32.2264" class="difflineplus">+    // look at the other messages in the conversation.</span>
<a href="#l32.2265"></a><span id="l32.2265" class="difflineplus">+    let conversationCollection = aMessage.conversation.getMessagesCollection(</span>
<a href="#l32.2266"></a><span id="l32.2266" class="difflineplus">+        aCallbackHandle);</span>
<a href="#l32.2267"></a><span id="l32.2267" class="difflineplus">+    yield this.kWorkAsync;</span>
<a href="#l32.2268"></a><span id="l32.2268" class="difflineplus">+    let conversationMsgs = conversationCollection.items;</span>
<a href="#l32.2269"></a><span id="l32.2269" class="difflineplus">+    </span>
<a href="#l32.2270"></a><span id="l32.2270" class="difflineplus">+    let ghosts = [];</span>
<a href="#l32.2271"></a><span id="l32.2271" class="difflineplus">+    let twinMessage = null;</span>
<a href="#l32.2272"></a><span id="l32.2272" class="difflineplus">+    for (let iMsg = 0; iMsg &lt; conversationMsgs.length; iMsg++) {</span>
<a href="#l32.2273"></a><span id="l32.2273" class="difflineplus">+      let convMsg = conversationMsgs[iMsg];</span>
<a href="#l32.2274"></a><span id="l32.2274" class="difflineplus">+      </span>
<a href="#l32.2275"></a><span id="l32.2275" class="difflineplus">+      // ignore our message</span>
<a href="#l32.2276"></a><span id="l32.2276" class="difflineplus">+      if (convMsg.id == aMessage.id)</span>
<a href="#l32.2277"></a><span id="l32.2277" class="difflineplus">+        continue;</span>
<a href="#l32.2278"></a><span id="l32.2278" class="difflineplus">+      </span>
<a href="#l32.2279"></a><span id="l32.2279" class="difflineplus">+      if (convMsg.folderID !== null) {</span>
<a href="#l32.2280"></a><span id="l32.2280" class="difflineplus">+        if (convMsg.headerMessageID == aMessage.headerMessageID) {</span>
<a href="#l32.2281"></a><span id="l32.2281" class="difflineplus">+          twinMessage = convMsg;</span>
<a href="#l32.2282"></a><span id="l32.2282" class="difflineplus">+        }</span>
<a href="#l32.2283"></a><span id="l32.2283" class="difflineplus">+      }</span>
<a href="#l32.2284"></a><span id="l32.2284" class="difflineplus">+      else {</span>
<a href="#l32.2285"></a><span id="l32.2285" class="difflineplus">+        ghosts.push(convMsg);</span>
<a href="#l32.2286"></a><span id="l32.2286" class="difflineplus">+      }</span>
<a href="#l32.2287"></a><span id="l32.2287" class="difflineplus">+    }</span>
<a href="#l32.2288"></a><span id="l32.2288" class="difflineplus">+    </span>
<a href="#l32.2289"></a><span id="l32.2289" class="difflineplus">+    // is everyone else a ghost? (note that conversationMsgs includes us, but</span>
<a href="#l32.2290"></a><span id="l32.2290" class="difflineplus">+    //  ghosts cannot)</span>
<a href="#l32.2291"></a><span id="l32.2291" class="difflineplus">+    if ((conversationMsgs.length - 1) == ghosts.length) {</span>
<a href="#l32.2292"></a><span id="l32.2292" class="difflineplus">+      // obliterate the conversation including aMessage.</span>
<a href="#l32.2293"></a><span id="l32.2293" class="difflineplus">+      // since everyone else is a ghost they have no attributes.  however, the</span>
<a href="#l32.2294"></a><span id="l32.2294" class="difflineplus">+      //  conversation may some day have attributes targeted against it, so it</span>
<a href="#l32.2295"></a><span id="l32.2295" class="difflineplus">+      //  gets a helper.</span>
<a href="#l32.2296"></a><span id="l32.2296" class="difflineplus">+      this._deleteConversationOfMessage(aMessage);</span>
<a href="#l32.2297"></a><span id="l32.2297" class="difflineplus">+      aMessage._nuke();</span>
<a href="#l32.2298"></a><span id="l32.2298" class="difflineplus">+    }</span>
<a href="#l32.2299"></a><span id="l32.2299" class="difflineplus">+    else { // there is at least one real message out there, so the only q is...</span>
<a href="#l32.2300"></a><span id="l32.2300" class="difflineplus">+      // do we have a twin (so it's okay to delete us) or do we become a ghost?</span>
<a href="#l32.2301"></a><span id="l32.2301" class="difflineplus">+      if (twinMessage !== null) { // just delete us</span>
<a href="#l32.2302"></a><span id="l32.2302" class="difflineplus">+        aMessage._datastore.deleteMessageByID(aMessage.id);</span>
<a href="#l32.2303"></a><span id="l32.2303" class="difflineplus">+        aMessage._nuke();</span>
<a href="#l32.2304"></a><span id="l32.2304" class="difflineplus">+      }</span>
<a href="#l32.2305"></a><span id="l32.2305" class="difflineplus">+      else { // ghost us</span>
<a href="#l32.2306"></a><span id="l32.2306" class="difflineplus">+        aMessage._ghost();</span>
<a href="#l32.2307"></a><span id="l32.2307" class="difflineplus">+        aMessage._datastore.updateMessage(aMessage);</span>
<a href="#l32.2308"></a><span id="l32.2308" class="difflineplus">+      }</span>
<a href="#l32.2309"></a><span id="l32.2309" class="difflineplus">+    }</span>
<a href="#l32.2310"></a><span id="l32.2310" class="difflineplus">+    </span>
<a href="#l32.2311"></a><span id="l32.2311" class="difflineplus">+    yield this.kWorkDone;</span>
<a href="#l32.2312"></a><span id="l32.2312" class="difflineplus">+  },</span>
<a href="#l32.2313"></a><span id="l32.2313" class="difflineplus">+  </span>
<a href="#l32.2314"></a><span id="l32.2314" class="difflineplus">+  /**</span>
<a href="#l32.2315"></a><span id="l32.2315" class="difflineplus">+   * Delete an entire conversation, using the passed-in message which must be</span>
<a href="#l32.2316"></a><span id="l32.2316" class="difflineplus">+   *  the last non-ghost in the conversation and have its attributes all</span>
<a href="#l32.2317"></a><span id="l32.2317" class="difflineplus">+   *  deleted.  This function issues the batch delete of all the ghosts (and the</span>
<a href="#l32.2318"></a><span id="l32.2318" class="difflineplus">+   *  message), and in the future will take care to nuke any attributes</span>
<a href="#l32.2319"></a><span id="l32.2319" class="difflineplus">+   *  referencing the conversation.</span>
<a href="#l32.2320"></a><span id="l32.2320" class="difflineplus">+   */</span>
<a href="#l32.2321"></a><span id="l32.2321" class="difflineplus">+  _deleteConversationOfMessage:</span>
<a href="#l32.2322"></a><span id="l32.2322" class="difflineplus">+      function gloda_index_deleteConversationOfMessage(aMessage) {</span>
<a href="#l32.2323"></a><span id="l32.2323" class="difflineplus">+    aMessage._datastore.deleteMessagesByConversationID(aMessage.conversationID);</span>
<a href="#l32.2324"></a><span id="l32.2324" class="difflineplus">+    aMessage._datastore.deleteConversationByID(aMessage.conversationID);</span>
<a href="#l32.2325"></a><span id="l32.2325" class="difflineplus">+  },</span>
<a href="#l32.2326"></a><span id="l32.2326" class="difflineplus">+};</span>
<a href="#l32.2327"></a><span id="l32.2327" class="difflineplus">+GlodaIndexer._init();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1">new file mode 100644</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineminus">--- /dev/null</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/log4moz.js</span>
<a href="#l33.4"></a><span id="l33.4" class="difflineat">@@ -0,0 +1,661 @@</span>
<a href="#l33.5"></a><span id="l33.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l33.6"></a><span id="l33.6" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l33.7"></a><span id="l33.7" class="difflineplus">+ *</span>
<a href="#l33.8"></a><span id="l33.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l33.9"></a><span id="l33.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l33.10"></a><span id="l33.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l33.11"></a><span id="l33.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l33.12"></a><span id="l33.12" class="difflineplus">+ *</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l33.14"></a><span id="l33.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l33.15"></a><span id="l33.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l33.16"></a><span id="l33.16" class="difflineplus">+ * License.</span>
<a href="#l33.17"></a><span id="l33.17" class="difflineplus">+ *</span>
<a href="#l33.18"></a><span id="l33.18" class="difflineplus">+ * The Original Code is log4moz</span>
<a href="#l33.19"></a><span id="l33.19" class="difflineplus">+ *</span>
<a href="#l33.20"></a><span id="l33.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l33.21"></a><span id="l33.21" class="difflineplus">+ * Michael Johnston</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2006</span>
<a href="#l33.23"></a><span id="l33.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l33.24"></a><span id="l33.24" class="difflineplus">+ *</span>
<a href="#l33.25"></a><span id="l33.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l33.26"></a><span id="l33.26" class="difflineplus">+ * Michael Johnston &lt;special.michael@gmail.com&gt;</span>
<a href="#l33.27"></a><span id="l33.27" class="difflineplus">+ * Dan Mills &lt;thunder@mozilla.com&gt;</span>
<a href="#l33.28"></a><span id="l33.28" class="difflineplus">+ * Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l33.29"></a><span id="l33.29" class="difflineplus">+ *</span>
<a href="#l33.30"></a><span id="l33.30" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l33.31"></a><span id="l33.31" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l33.32"></a><span id="l33.32" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l33.33"></a><span id="l33.33" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l33.34"></a><span id="l33.34" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l33.35"></a><span id="l33.35" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l33.36"></a><span id="l33.36" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l33.37"></a><span id="l33.37" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l33.38"></a><span id="l33.38" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l33.39"></a><span id="l33.39" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l33.40"></a><span id="l33.40" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l33.41"></a><span id="l33.41" class="difflineplus">+ *</span>
<a href="#l33.42"></a><span id="l33.42" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l33.43"></a><span id="l33.43" class="difflineplus">+</span>
<a href="#l33.44"></a><span id="l33.44" class="difflineplus">+const EXPORTED_SYMBOLS = ['Log4Moz'];</span>
<a href="#l33.45"></a><span id="l33.45" class="difflineplus">+</span>
<a href="#l33.46"></a><span id="l33.46" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l33.47"></a><span id="l33.47" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l33.48"></a><span id="l33.48" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l33.49"></a><span id="l33.49" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l33.50"></a><span id="l33.50" class="difflineplus">+</span>
<a href="#l33.51"></a><span id="l33.51" class="difflineplus">+Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l33.52"></a><span id="l33.52" class="difflineplus">+</span>
<a href="#l33.53"></a><span id="l33.53" class="difflineplus">+const MODE_RDONLY   = 0x01;</span>
<a href="#l33.54"></a><span id="l33.54" class="difflineplus">+const MODE_WRONLY   = 0x02;</span>
<a href="#l33.55"></a><span id="l33.55" class="difflineplus">+const MODE_CREATE   = 0x08;</span>
<a href="#l33.56"></a><span id="l33.56" class="difflineplus">+const MODE_APPEND   = 0x10;</span>
<a href="#l33.57"></a><span id="l33.57" class="difflineplus">+const MODE_TRUNCATE = 0x20;</span>
<a href="#l33.58"></a><span id="l33.58" class="difflineplus">+</span>
<a href="#l33.59"></a><span id="l33.59" class="difflineplus">+const PERMS_FILE      = 0644;</span>
<a href="#l33.60"></a><span id="l33.60" class="difflineplus">+const PERMS_DIRECTORY = 0755;</span>
<a href="#l33.61"></a><span id="l33.61" class="difflineplus">+</span>
<a href="#l33.62"></a><span id="l33.62" class="difflineplus">+const ONE_BYTE = 1;</span>
<a href="#l33.63"></a><span id="l33.63" class="difflineplus">+const ONE_KILOBYTE = 1024 * ONE_BYTE;</span>
<a href="#l33.64"></a><span id="l33.64" class="difflineplus">+const ONE_MEGABYTE = 1024 * ONE_KILOBYTE;</span>
<a href="#l33.65"></a><span id="l33.65" class="difflineplus">+</span>
<a href="#l33.66"></a><span id="l33.66" class="difflineplus">+const DEFAULT_NETWORK_TIMEOUT_DELAY = 5;</span>
<a href="#l33.67"></a><span id="l33.67" class="difflineplus">+</span>
<a href="#l33.68"></a><span id="l33.68" class="difflineplus">+const CDATA_START = &quot;&lt;![CDATA[&quot;;</span>
<a href="#l33.69"></a><span id="l33.69" class="difflineplus">+const CDATA_END = &quot;]]&gt;&quot;;</span>
<a href="#l33.70"></a><span id="l33.70" class="difflineplus">+const CDATA_ESCAPED_END = CDATA_END + &quot;]]&amp;gt;&quot; + CDATA_START;</span>
<a href="#l33.71"></a><span id="l33.71" class="difflineplus">+</span>
<a href="#l33.72"></a><span id="l33.72" class="difflineplus">+let Log4Moz = {</span>
<a href="#l33.73"></a><span id="l33.73" class="difflineplus">+  Level: {</span>
<a href="#l33.74"></a><span id="l33.74" class="difflineplus">+    Fatal:  70,</span>
<a href="#l33.75"></a><span id="l33.75" class="difflineplus">+    Error:  60,</span>
<a href="#l33.76"></a><span id="l33.76" class="difflineplus">+    Warn:   50,</span>
<a href="#l33.77"></a><span id="l33.77" class="difflineplus">+    Info:   40,</span>
<a href="#l33.78"></a><span id="l33.78" class="difflineplus">+    Config: 30,</span>
<a href="#l33.79"></a><span id="l33.79" class="difflineplus">+    Debug:  20,</span>
<a href="#l33.80"></a><span id="l33.80" class="difflineplus">+    Trace:  10,</span>
<a href="#l33.81"></a><span id="l33.81" class="difflineplus">+    All:    0,</span>
<a href="#l33.82"></a><span id="l33.82" class="difflineplus">+    Desc: {</span>
<a href="#l33.83"></a><span id="l33.83" class="difflineplus">+      70: &quot;FATAL&quot;,</span>
<a href="#l33.84"></a><span id="l33.84" class="difflineplus">+      60: &quot;ERROR&quot;,</span>
<a href="#l33.85"></a><span id="l33.85" class="difflineplus">+      50: &quot;WARN&quot;,</span>
<a href="#l33.86"></a><span id="l33.86" class="difflineplus">+      40: &quot;INFO&quot;,</span>
<a href="#l33.87"></a><span id="l33.87" class="difflineplus">+      30: &quot;CONFIG&quot;,</span>
<a href="#l33.88"></a><span id="l33.88" class="difflineplus">+      20: &quot;DEBUG&quot;,</span>
<a href="#l33.89"></a><span id="l33.89" class="difflineplus">+      10: &quot;TRACE&quot;,</span>
<a href="#l33.90"></a><span id="l33.90" class="difflineplus">+      0:  &quot;ALL&quot;</span>
<a href="#l33.91"></a><span id="l33.91" class="difflineplus">+    }</span>
<a href="#l33.92"></a><span id="l33.92" class="difflineplus">+  },</span>
<a href="#l33.93"></a><span id="l33.93" class="difflineplus">+</span>
<a href="#l33.94"></a><span id="l33.94" class="difflineplus">+  get Service() {</span>
<a href="#l33.95"></a><span id="l33.95" class="difflineplus">+    delete Log4Moz.Service;</span>
<a href="#l33.96"></a><span id="l33.96" class="difflineplus">+    Log4Moz.Service = new Log4MozService();</span>
<a href="#l33.97"></a><span id="l33.97" class="difflineplus">+    return Log4Moz.Service;</span>
<a href="#l33.98"></a><span id="l33.98" class="difflineplus">+  },</span>
<a href="#l33.99"></a><span id="l33.99" class="difflineplus">+</span>
<a href="#l33.100"></a><span id="l33.100" class="difflineplus">+  get Formatter() { return Formatter; },</span>
<a href="#l33.101"></a><span id="l33.101" class="difflineplus">+  get BasicFormatter() { return BasicFormatter; },</span>
<a href="#l33.102"></a><span id="l33.102" class="difflineplus">+  get XMLFormatter() { return XMLFormatter; },</span>
<a href="#l33.103"></a><span id="l33.103" class="difflineplus">+  get Appender() { return Appender; },</span>
<a href="#l33.104"></a><span id="l33.104" class="difflineplus">+  get DumpAppender() { return DumpAppender; },</span>
<a href="#l33.105"></a><span id="l33.105" class="difflineplus">+  get ConsoleAppender() { return ConsoleAppender; },</span>
<a href="#l33.106"></a><span id="l33.106" class="difflineplus">+  get FileAppender() { return FileAppender; },</span>
<a href="#l33.107"></a><span id="l33.107" class="difflineplus">+  get SocketAppender() { return SocketAppender; },</span>
<a href="#l33.108"></a><span id="l33.108" class="difflineplus">+  get RotatingFileAppender() { return RotatingFileAppender; },</span>
<a href="#l33.109"></a><span id="l33.109" class="difflineplus">+</span>
<a href="#l33.110"></a><span id="l33.110" class="difflineplus">+  // Logging helper:</span>
<a href="#l33.111"></a><span id="l33.111" class="difflineplus">+  // let logger = Log4Moz.Service.getLogger(&quot;foo&quot;);</span>
<a href="#l33.112"></a><span id="l33.112" class="difflineplus">+  // logger.info(Log4Moz.enumerateInterfaces(someObject).join(&quot;,&quot;));</span>
<a href="#l33.113"></a><span id="l33.113" class="difflineplus">+  enumerateInterfaces: function(aObject) {</span>
<a href="#l33.114"></a><span id="l33.114" class="difflineplus">+    let interfaces = [];</span>
<a href="#l33.115"></a><span id="l33.115" class="difflineplus">+</span>
<a href="#l33.116"></a><span id="l33.116" class="difflineplus">+    for (i in Ci) {</span>
<a href="#l33.117"></a><span id="l33.117" class="difflineplus">+      try {</span>
<a href="#l33.118"></a><span id="l33.118" class="difflineplus">+        aObject.QueryInterface(Ci[i]);</span>
<a href="#l33.119"></a><span id="l33.119" class="difflineplus">+        interfaces.push(i);</span>
<a href="#l33.120"></a><span id="l33.120" class="difflineplus">+      }</span>
<a href="#l33.121"></a><span id="l33.121" class="difflineplus">+      catch(ex) {}</span>
<a href="#l33.122"></a><span id="l33.122" class="difflineplus">+    }</span>
<a href="#l33.123"></a><span id="l33.123" class="difflineplus">+</span>
<a href="#l33.124"></a><span id="l33.124" class="difflineplus">+    return interfaces;</span>
<a href="#l33.125"></a><span id="l33.125" class="difflineplus">+  },</span>
<a href="#l33.126"></a><span id="l33.126" class="difflineplus">+</span>
<a href="#l33.127"></a><span id="l33.127" class="difflineplus">+  // Logging helper:</span>
<a href="#l33.128"></a><span id="l33.128" class="difflineplus">+  // let logger = Log4Moz.Service.getLogger(&quot;foo&quot;);</span>
<a href="#l33.129"></a><span id="l33.129" class="difflineplus">+  // logger.info(Log4Moz.enumerateProperties(someObject).join(&quot;,&quot;));</span>
<a href="#l33.130"></a><span id="l33.130" class="difflineplus">+  enumerateProperties: function(aObject, aExcludeComplexTypes) {</span>
<a href="#l33.131"></a><span id="l33.131" class="difflineplus">+    let properties = [];</span>
<a href="#l33.132"></a><span id="l33.132" class="difflineplus">+</span>
<a href="#l33.133"></a><span id="l33.133" class="difflineplus">+    for (p in aObject) {</span>
<a href="#l33.134"></a><span id="l33.134" class="difflineplus">+      try {</span>
<a href="#l33.135"></a><span id="l33.135" class="difflineplus">+        if (aExcludeComplexTypes &amp;&amp;</span>
<a href="#l33.136"></a><span id="l33.136" class="difflineplus">+            (typeof aObject[p] == &quot;object&quot; || typeof aObject[p] == &quot;function&quot;))</span>
<a href="#l33.137"></a><span id="l33.137" class="difflineplus">+          continue;</span>
<a href="#l33.138"></a><span id="l33.138" class="difflineplus">+        properties.push(p + &quot; = &quot; + aObject[p]);</span>
<a href="#l33.139"></a><span id="l33.139" class="difflineplus">+      }</span>
<a href="#l33.140"></a><span id="l33.140" class="difflineplus">+      catch(ex) {</span>
<a href="#l33.141"></a><span id="l33.141" class="difflineplus">+        properties.push(p + &quot; = &quot; + ex);</span>
<a href="#l33.142"></a><span id="l33.142" class="difflineplus">+      }</span>
<a href="#l33.143"></a><span id="l33.143" class="difflineplus">+    }</span>
<a href="#l33.144"></a><span id="l33.144" class="difflineplus">+</span>
<a href="#l33.145"></a><span id="l33.145" class="difflineplus">+    return properties;</span>
<a href="#l33.146"></a><span id="l33.146" class="difflineplus">+  }</span>
<a href="#l33.147"></a><span id="l33.147" class="difflineplus">+};</span>
<a href="#l33.148"></a><span id="l33.148" class="difflineplus">+</span>
<a href="#l33.149"></a><span id="l33.149" class="difflineplus">+</span>
<a href="#l33.150"></a><span id="l33.150" class="difflineplus">+/*</span>
<a href="#l33.151"></a><span id="l33.151" class="difflineplus">+ * LogMessage</span>
<a href="#l33.152"></a><span id="l33.152" class="difflineplus">+ * Encapsulates a single log event's data</span>
<a href="#l33.153"></a><span id="l33.153" class="difflineplus">+ */</span>
<a href="#l33.154"></a><span id="l33.154" class="difflineplus">+function LogMessage(loggerName, level, message){</span>
<a href="#l33.155"></a><span id="l33.155" class="difflineplus">+  this.loggerName = loggerName;</span>
<a href="#l33.156"></a><span id="l33.156" class="difflineplus">+  this.message = message;</span>
<a href="#l33.157"></a><span id="l33.157" class="difflineplus">+  this.level = level;</span>
<a href="#l33.158"></a><span id="l33.158" class="difflineplus">+  this.time = Date.now();</span>
<a href="#l33.159"></a><span id="l33.159" class="difflineplus">+}</span>
<a href="#l33.160"></a><span id="l33.160" class="difflineplus">+LogMessage.prototype = {</span>
<a href="#l33.161"></a><span id="l33.161" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),</span>
<a href="#l33.162"></a><span id="l33.162" class="difflineplus">+</span>
<a href="#l33.163"></a><span id="l33.163" class="difflineplus">+  get levelDesc() {</span>
<a href="#l33.164"></a><span id="l33.164" class="difflineplus">+    if (this.level in Log4Moz.Level.Desc)</span>
<a href="#l33.165"></a><span id="l33.165" class="difflineplus">+      return Log4Moz.Level.Desc[this.level];</span>
<a href="#l33.166"></a><span id="l33.166" class="difflineplus">+    return &quot;UNKNOWN&quot;;</span>
<a href="#l33.167"></a><span id="l33.167" class="difflineplus">+  },</span>
<a href="#l33.168"></a><span id="l33.168" class="difflineplus">+</span>
<a href="#l33.169"></a><span id="l33.169" class="difflineplus">+  toString: function LogMsg_toString(){</span>
<a href="#l33.170"></a><span id="l33.170" class="difflineplus">+    return &quot;LogMessage [&quot; + this.time + &quot; &quot; + this.level + &quot; &quot; +</span>
<a href="#l33.171"></a><span id="l33.171" class="difflineplus">+      this.message + &quot;]&quot;;</span>
<a href="#l33.172"></a><span id="l33.172" class="difflineplus">+  }</span>
<a href="#l33.173"></a><span id="l33.173" class="difflineplus">+};</span>
<a href="#l33.174"></a><span id="l33.174" class="difflineplus">+</span>
<a href="#l33.175"></a><span id="l33.175" class="difflineplus">+/*</span>
<a href="#l33.176"></a><span id="l33.176" class="difflineplus">+ * Logger</span>
<a href="#l33.177"></a><span id="l33.177" class="difflineplus">+ * Hierarchical version.  Logs to all appenders, assigned or inherited</span>
<a href="#l33.178"></a><span id="l33.178" class="difflineplus">+ */</span>
<a href="#l33.179"></a><span id="l33.179" class="difflineplus">+</span>
<a href="#l33.180"></a><span id="l33.180" class="difflineplus">+function Logger(name, repository) {</span>
<a href="#l33.181"></a><span id="l33.181" class="difflineplus">+  this._name = name;</span>
<a href="#l33.182"></a><span id="l33.182" class="difflineplus">+  this._repository = repository;</span>
<a href="#l33.183"></a><span id="l33.183" class="difflineplus">+  this._appenders = [];</span>
<a href="#l33.184"></a><span id="l33.184" class="difflineplus">+}</span>
<a href="#l33.185"></a><span id="l33.185" class="difflineplus">+Logger.prototype = {</span>
<a href="#l33.186"></a><span id="l33.186" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),</span>
<a href="#l33.187"></a><span id="l33.187" class="difflineplus">+</span>
<a href="#l33.188"></a><span id="l33.188" class="difflineplus">+  parent: null,</span>
<a href="#l33.189"></a><span id="l33.189" class="difflineplus">+</span>
<a href="#l33.190"></a><span id="l33.190" class="difflineplus">+  _level: null,</span>
<a href="#l33.191"></a><span id="l33.191" class="difflineplus">+  get level() {</span>
<a href="#l33.192"></a><span id="l33.192" class="difflineplus">+    if (this._level != null)</span>
<a href="#l33.193"></a><span id="l33.193" class="difflineplus">+      return this._level;</span>
<a href="#l33.194"></a><span id="l33.194" class="difflineplus">+    if (this.parent)</span>
<a href="#l33.195"></a><span id="l33.195" class="difflineplus">+      return this.parent.level;</span>
<a href="#l33.196"></a><span id="l33.196" class="difflineplus">+    dump(&quot;log4moz warning: root logger configuration error: no level defined\n&quot;);</span>
<a href="#l33.197"></a><span id="l33.197" class="difflineplus">+    return Log4Moz.Level.All;</span>
<a href="#l33.198"></a><span id="l33.198" class="difflineplus">+  },</span>
<a href="#l33.199"></a><span id="l33.199" class="difflineplus">+  set level(level) {</span>
<a href="#l33.200"></a><span id="l33.200" class="difflineplus">+    this._level = level;</span>
<a href="#l33.201"></a><span id="l33.201" class="difflineplus">+  },</span>
<a href="#l33.202"></a><span id="l33.202" class="difflineplus">+</span>
<a href="#l33.203"></a><span id="l33.203" class="difflineplus">+  _appenders: null,</span>
<a href="#l33.204"></a><span id="l33.204" class="difflineplus">+  get appenders() {</span>
<a href="#l33.205"></a><span id="l33.205" class="difflineplus">+    if (!this.parent)</span>
<a href="#l33.206"></a><span id="l33.206" class="difflineplus">+      return this._appenders;</span>
<a href="#l33.207"></a><span id="l33.207" class="difflineplus">+    return this._appenders.concat(this.parent.appenders);</span>
<a href="#l33.208"></a><span id="l33.208" class="difflineplus">+  },</span>
<a href="#l33.209"></a><span id="l33.209" class="difflineplus">+</span>
<a href="#l33.210"></a><span id="l33.210" class="difflineplus">+  addAppender: function Logger_addAppender(appender) {</span>
<a href="#l33.211"></a><span id="l33.211" class="difflineplus">+    for (let i = 0; i &lt; this._appenders.length; i++) {</span>
<a href="#l33.212"></a><span id="l33.212" class="difflineplus">+      if (this._appenders[i] == appender)</span>
<a href="#l33.213"></a><span id="l33.213" class="difflineplus">+        return;</span>
<a href="#l33.214"></a><span id="l33.214" class="difflineplus">+    }</span>
<a href="#l33.215"></a><span id="l33.215" class="difflineplus">+    this._appenders.push(appender);</span>
<a href="#l33.216"></a><span id="l33.216" class="difflineplus">+  },</span>
<a href="#l33.217"></a><span id="l33.217" class="difflineplus">+</span>
<a href="#l33.218"></a><span id="l33.218" class="difflineplus">+  log: function Logger_log(message) {</span>
<a href="#l33.219"></a><span id="l33.219" class="difflineplus">+    if (this.level &gt; message.level)</span>
<a href="#l33.220"></a><span id="l33.220" class="difflineplus">+      return;</span>
<a href="#l33.221"></a><span id="l33.221" class="difflineplus">+    let appenders = this.appenders;</span>
<a href="#l33.222"></a><span id="l33.222" class="difflineplus">+    for (let i = 0; i &lt; appenders.length; i++){</span>
<a href="#l33.223"></a><span id="l33.223" class="difflineplus">+      appenders[i].append(message);</span>
<a href="#l33.224"></a><span id="l33.224" class="difflineplus">+    }</span>
<a href="#l33.225"></a><span id="l33.225" class="difflineplus">+  },</span>
<a href="#l33.226"></a><span id="l33.226" class="difflineplus">+</span>
<a href="#l33.227"></a><span id="l33.227" class="difflineplus">+  fatal: function Logger_fatal(string) {</span>
<a href="#l33.228"></a><span id="l33.228" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Fatal, string));</span>
<a href="#l33.229"></a><span id="l33.229" class="difflineplus">+  },</span>
<a href="#l33.230"></a><span id="l33.230" class="difflineplus">+  error: function Logger_error(string) {</span>
<a href="#l33.231"></a><span id="l33.231" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Error, string));</span>
<a href="#l33.232"></a><span id="l33.232" class="difflineplus">+  },</span>
<a href="#l33.233"></a><span id="l33.233" class="difflineplus">+  warn: function Logger_warn(string) {</span>
<a href="#l33.234"></a><span id="l33.234" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Warn, string));</span>
<a href="#l33.235"></a><span id="l33.235" class="difflineplus">+  },</span>
<a href="#l33.236"></a><span id="l33.236" class="difflineplus">+  info: function Logger_info(string) {</span>
<a href="#l33.237"></a><span id="l33.237" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Info, string));</span>
<a href="#l33.238"></a><span id="l33.238" class="difflineplus">+  },</span>
<a href="#l33.239"></a><span id="l33.239" class="difflineplus">+  config: function Logger_config(string) {</span>
<a href="#l33.240"></a><span id="l33.240" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Config, string));</span>
<a href="#l33.241"></a><span id="l33.241" class="difflineplus">+  },</span>
<a href="#l33.242"></a><span id="l33.242" class="difflineplus">+  debug: function Logger_debug(string) {</span>
<a href="#l33.243"></a><span id="l33.243" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Debug, string));</span>
<a href="#l33.244"></a><span id="l33.244" class="difflineplus">+  },</span>
<a href="#l33.245"></a><span id="l33.245" class="difflineplus">+  trace: function Logger_trace(string) {</span>
<a href="#l33.246"></a><span id="l33.246" class="difflineplus">+    this.log(new LogMessage(this._name, Log4Moz.Level.Trace, string));</span>
<a href="#l33.247"></a><span id="l33.247" class="difflineplus">+  }</span>
<a href="#l33.248"></a><span id="l33.248" class="difflineplus">+};</span>
<a href="#l33.249"></a><span id="l33.249" class="difflineplus">+</span>
<a href="#l33.250"></a><span id="l33.250" class="difflineplus">+/*</span>
<a href="#l33.251"></a><span id="l33.251" class="difflineplus">+ * LoggerRepository</span>
<a href="#l33.252"></a><span id="l33.252" class="difflineplus">+ * Implements a hierarchy of Loggers</span>
<a href="#l33.253"></a><span id="l33.253" class="difflineplus">+ */</span>
<a href="#l33.254"></a><span id="l33.254" class="difflineplus">+</span>
<a href="#l33.255"></a><span id="l33.255" class="difflineplus">+function LoggerRepository() {}</span>
<a href="#l33.256"></a><span id="l33.256" class="difflineplus">+LoggerRepository.prototype = {</span>
<a href="#l33.257"></a><span id="l33.257" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),</span>
<a href="#l33.258"></a><span id="l33.258" class="difflineplus">+</span>
<a href="#l33.259"></a><span id="l33.259" class="difflineplus">+  _loggers: {},</span>
<a href="#l33.260"></a><span id="l33.260" class="difflineplus">+</span>
<a href="#l33.261"></a><span id="l33.261" class="difflineplus">+  _rootLogger: null,</span>
<a href="#l33.262"></a><span id="l33.262" class="difflineplus">+  get rootLogger() {</span>
<a href="#l33.263"></a><span id="l33.263" class="difflineplus">+    if (!this._rootLogger) {</span>
<a href="#l33.264"></a><span id="l33.264" class="difflineplus">+      this._rootLogger = new Logger(&quot;root&quot;, this);</span>
<a href="#l33.265"></a><span id="l33.265" class="difflineplus">+      this._rootLogger.level = Log4Moz.Level.All;</span>
<a href="#l33.266"></a><span id="l33.266" class="difflineplus">+    }</span>
<a href="#l33.267"></a><span id="l33.267" class="difflineplus">+    return this._rootLogger;</span>
<a href="#l33.268"></a><span id="l33.268" class="difflineplus">+  },</span>
<a href="#l33.269"></a><span id="l33.269" class="difflineplus">+  // FIXME: need to update all parent values if we do this</span>
<a href="#l33.270"></a><span id="l33.270" class="difflineplus">+  //set rootLogger(logger) {</span>
<a href="#l33.271"></a><span id="l33.271" class="difflineplus">+  //  this._rootLogger = logger;</span>
<a href="#l33.272"></a><span id="l33.272" class="difflineplus">+  //},</span>
<a href="#l33.273"></a><span id="l33.273" class="difflineplus">+</span>
<a href="#l33.274"></a><span id="l33.274" class="difflineplus">+  _updateParents: function LogRep__updateParents(name) {</span>
<a href="#l33.275"></a><span id="l33.275" class="difflineplus">+    let pieces = name.split('.');</span>
<a href="#l33.276"></a><span id="l33.276" class="difflineplus">+    let cur, parent;</span>
<a href="#l33.277"></a><span id="l33.277" class="difflineplus">+</span>
<a href="#l33.278"></a><span id="l33.278" class="difflineplus">+    // find the closest parent</span>
<a href="#l33.279"></a><span id="l33.279" class="difflineplus">+    for (let i = 0; i &lt; pieces.length; i++) {</span>
<a href="#l33.280"></a><span id="l33.280" class="difflineplus">+      if (cur)</span>
<a href="#l33.281"></a><span id="l33.281" class="difflineplus">+        cur += '.' + pieces[i];</span>
<a href="#l33.282"></a><span id="l33.282" class="difflineplus">+      else</span>
<a href="#l33.283"></a><span id="l33.283" class="difflineplus">+        cur = pieces[i];</span>
<a href="#l33.284"></a><span id="l33.284" class="difflineplus">+      if (cur in this._loggers)</span>
<a href="#l33.285"></a><span id="l33.285" class="difflineplus">+        parent = cur;</span>
<a href="#l33.286"></a><span id="l33.286" class="difflineplus">+    }</span>
<a href="#l33.287"></a><span id="l33.287" class="difflineplus">+</span>
<a href="#l33.288"></a><span id="l33.288" class="difflineplus">+    // if they are the same it has no parent</span>
<a href="#l33.289"></a><span id="l33.289" class="difflineplus">+    if (parent == name)</span>
<a href="#l33.290"></a><span id="l33.290" class="difflineplus">+      this._loggers[name].parent = this.rootLogger;</span>
<a href="#l33.291"></a><span id="l33.291" class="difflineplus">+    else</span>
<a href="#l33.292"></a><span id="l33.292" class="difflineplus">+      this._loggers[name].parent = this._loggers[parent];</span>
<a href="#l33.293"></a><span id="l33.293" class="difflineplus">+</span>
<a href="#l33.294"></a><span id="l33.294" class="difflineplus">+    // trigger updates for any possible descendants of this logger</span>
<a href="#l33.295"></a><span id="l33.295" class="difflineplus">+    for (let logger in this._loggers) {</span>
<a href="#l33.296"></a><span id="l33.296" class="difflineplus">+      if (logger != name &amp;&amp; name.indexOf(logger) == 0)</span>
<a href="#l33.297"></a><span id="l33.297" class="difflineplus">+        this._updateParents(logger);</span>
<a href="#l33.298"></a><span id="l33.298" class="difflineplus">+    }</span>
<a href="#l33.299"></a><span id="l33.299" class="difflineplus">+  },</span>
<a href="#l33.300"></a><span id="l33.300" class="difflineplus">+</span>
<a href="#l33.301"></a><span id="l33.301" class="difflineplus">+  getLogger: function LogRep_getLogger(name) {</span>
<a href="#l33.302"></a><span id="l33.302" class="difflineplus">+    if (!(name in this._loggers)) {</span>
<a href="#l33.303"></a><span id="l33.303" class="difflineplus">+      this._loggers[name] = new Logger(name, this);</span>
<a href="#l33.304"></a><span id="l33.304" class="difflineplus">+      this._updateParents(name);</span>
<a href="#l33.305"></a><span id="l33.305" class="difflineplus">+    }</span>
<a href="#l33.306"></a><span id="l33.306" class="difflineplus">+    return this._loggers[name];</span>
<a href="#l33.307"></a><span id="l33.307" class="difflineplus">+  }</span>
<a href="#l33.308"></a><span id="l33.308" class="difflineplus">+};</span>
<a href="#l33.309"></a><span id="l33.309" class="difflineplus">+</span>
<a href="#l33.310"></a><span id="l33.310" class="difflineplus">+/*</span>
<a href="#l33.311"></a><span id="l33.311" class="difflineplus">+ * Formatters</span>
<a href="#l33.312"></a><span id="l33.312" class="difflineplus">+ * These massage a LogMessage into whatever output is desired</span>
<a href="#l33.313"></a><span id="l33.313" class="difflineplus">+ * Only the BasicFormatter is currently implemented</span>
<a href="#l33.314"></a><span id="l33.314" class="difflineplus">+ */</span>
<a href="#l33.315"></a><span id="l33.315" class="difflineplus">+</span>
<a href="#l33.316"></a><span id="l33.316" class="difflineplus">+// Abstract formatter</span>
<a href="#l33.317"></a><span id="l33.317" class="difflineplus">+function Formatter() {}</span>
<a href="#l33.318"></a><span id="l33.318" class="difflineplus">+Formatter.prototype = {</span>
<a href="#l33.319"></a><span id="l33.319" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),</span>
<a href="#l33.320"></a><span id="l33.320" class="difflineplus">+  format: function Formatter_format(message) {}</span>
<a href="#l33.321"></a><span id="l33.321" class="difflineplus">+};</span>
<a href="#l33.322"></a><span id="l33.322" class="difflineplus">+</span>
<a href="#l33.323"></a><span id="l33.323" class="difflineplus">+// FIXME: should allow for formatting the whole string, not just the date</span>
<a href="#l33.324"></a><span id="l33.324" class="difflineplus">+function BasicFormatter(dateFormat) {</span>
<a href="#l33.325"></a><span id="l33.325" class="difflineplus">+  if (dateFormat)</span>
<a href="#l33.326"></a><span id="l33.326" class="difflineplus">+    this.dateFormat = dateFormat;</span>
<a href="#l33.327"></a><span id="l33.327" class="difflineplus">+}</span>
<a href="#l33.328"></a><span id="l33.328" class="difflineplus">+BasicFormatter.prototype = {</span>
<a href="#l33.329"></a><span id="l33.329" class="difflineplus">+  _dateFormat: null,</span>
<a href="#l33.330"></a><span id="l33.330" class="difflineplus">+</span>
<a href="#l33.331"></a><span id="l33.331" class="difflineplus">+  get dateFormat() {</span>
<a href="#l33.332"></a><span id="l33.332" class="difflineplus">+    if (!this._dateFormat)</span>
<a href="#l33.333"></a><span id="l33.333" class="difflineplus">+      this._dateFormat = &quot;%Y-%m-%d %H:%M:%S&quot;;</span>
<a href="#l33.334"></a><span id="l33.334" class="difflineplus">+    return this._dateFormat;</span>
<a href="#l33.335"></a><span id="l33.335" class="difflineplus">+  },</span>
<a href="#l33.336"></a><span id="l33.336" class="difflineplus">+</span>
<a href="#l33.337"></a><span id="l33.337" class="difflineplus">+  set dateFormat(format) {</span>
<a href="#l33.338"></a><span id="l33.338" class="difflineplus">+    this._dateFormat = format;</span>
<a href="#l33.339"></a><span id="l33.339" class="difflineplus">+  },</span>
<a href="#l33.340"></a><span id="l33.340" class="difflineplus">+</span>
<a href="#l33.341"></a><span id="l33.341" class="difflineplus">+  format: function BF_format(message) {</span>
<a href="#l33.342"></a><span id="l33.342" class="difflineplus">+    let date = new Date(message.time);</span>
<a href="#l33.343"></a><span id="l33.343" class="difflineplus">+    return date.toLocaleFormat(this.dateFormat) + &quot;\t&quot; +</span>
<a href="#l33.344"></a><span id="l33.344" class="difflineplus">+      message.loggerName + &quot;\t&quot; + message.levelDesc + &quot;\t&quot; +</span>
<a href="#l33.345"></a><span id="l33.345" class="difflineplus">+      message.message + &quot;\n&quot;;</span>
<a href="#l33.346"></a><span id="l33.346" class="difflineplus">+  }</span>
<a href="#l33.347"></a><span id="l33.347" class="difflineplus">+};</span>
<a href="#l33.348"></a><span id="l33.348" class="difflineplus">+BasicFormatter.prototype.__proto__ = new Formatter();</span>
<a href="#l33.349"></a><span id="l33.349" class="difflineplus">+</span>
<a href="#l33.350"></a><span id="l33.350" class="difflineplus">+/*</span>
<a href="#l33.351"></a><span id="l33.351" class="difflineplus">+ * XMLFormatter</span>
<a href="#l33.352"></a><span id="l33.352" class="difflineplus">+ * Format like log4j's XMLLayout.  The intent is that you can hook this up to</span>
<a href="#l33.353"></a><span id="l33.353" class="difflineplus">+ * a SocketAppender and point them at a Chainsaw GUI running with an</span>
<a href="#l33.354"></a><span id="l33.354" class="difflineplus">+ * XMLSocketReceiver running.  Then your output comes out in Chainsaw.</span>
<a href="#l33.355"></a><span id="l33.355" class="difflineplus">+ * (Chainsaw is log4j's GUI that displays log output with niceties such as</span>
<a href="#l33.356"></a><span id="l33.356" class="difflineplus">+ * filtering and conditional coloring.)</span>
<a href="#l33.357"></a><span id="l33.357" class="difflineplus">+ */</span>
<a href="#l33.358"></a><span id="l33.358" class="difflineplus">+</span>
<a href="#l33.359"></a><span id="l33.359" class="difflineplus">+function XMLFormatter() {}</span>
<a href="#l33.360"></a><span id="l33.360" class="difflineplus">+XMLFormatter.prototype = {</span>
<a href="#l33.361"></a><span id="l33.361" class="difflineplus">+  format: function XF_format(message) {</span>
<a href="#l33.362"></a><span id="l33.362" class="difflineplus">+    let cdataEscapedMessage = message.message.replace(CDATA_END,</span>
<a href="#l33.363"></a><span id="l33.363" class="difflineplus">+                                                      CDATA_ESCAPED_END, &quot;g&quot;);</span>
<a href="#l33.364"></a><span id="l33.364" class="difflineplus">+    return &quot;&lt;log4j:event logger='&quot; + message.loggerName + &quot;' &quot; +</span>
<a href="#l33.365"></a><span id="l33.365" class="difflineplus">+                        &quot;level='&quot; + message.levelDesc + &quot;' thread='unknown' &quot; +</span>
<a href="#l33.366"></a><span id="l33.366" class="difflineplus">+                        &quot;timestamp='&quot; + message.time + &quot;'&gt;&quot; +</span>
<a href="#l33.367"></a><span id="l33.367" class="difflineplus">+      &quot;&lt;log4j:message&gt;&lt;![CDATA[&quot; + cdataEscapedMessage + &quot;]]&gt;&lt;/log4j:message&gt;&quot; +</span>
<a href="#l33.368"></a><span id="l33.368" class="difflineplus">+      &quot;&lt;/log4j:event&gt;&quot;;</span>
<a href="#l33.369"></a><span id="l33.369" class="difflineplus">+  }</span>
<a href="#l33.370"></a><span id="l33.370" class="difflineplus">+}</span>
<a href="#l33.371"></a><span id="l33.371" class="difflineplus">+XMLFormatter.prototype.__proto__ = new Formatter();</span>
<a href="#l33.372"></a><span id="l33.372" class="difflineplus">+</span>
<a href="#l33.373"></a><span id="l33.373" class="difflineplus">+/*</span>
<a href="#l33.374"></a><span id="l33.374" class="difflineplus">+ * Appenders</span>
<a href="#l33.375"></a><span id="l33.375" class="difflineplus">+ * These can be attached to Loggers to log to different places</span>
<a href="#l33.376"></a><span id="l33.376" class="difflineplus">+ * Simply subclass and override doAppend to implement a new one</span>
<a href="#l33.377"></a><span id="l33.377" class="difflineplus">+ */</span>
<a href="#l33.378"></a><span id="l33.378" class="difflineplus">+</span>
<a href="#l33.379"></a><span id="l33.379" class="difflineplus">+function Appender(formatter) {</span>
<a href="#l33.380"></a><span id="l33.380" class="difflineplus">+  this._name = &quot;Appender&quot;;</span>
<a href="#l33.381"></a><span id="l33.381" class="difflineplus">+  this._formatter = formatter? formatter : new BasicFormatter();</span>
<a href="#l33.382"></a><span id="l33.382" class="difflineplus">+}</span>
<a href="#l33.383"></a><span id="l33.383" class="difflineplus">+Appender.prototype = {</span>
<a href="#l33.384"></a><span id="l33.384" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),</span>
<a href="#l33.385"></a><span id="l33.385" class="difflineplus">+</span>
<a href="#l33.386"></a><span id="l33.386" class="difflineplus">+  _level: Log4Moz.Level.All,</span>
<a href="#l33.387"></a><span id="l33.387" class="difflineplus">+  get level() { return this._level; },</span>
<a href="#l33.388"></a><span id="l33.388" class="difflineplus">+  set level(level) { this._level = level; },</span>
<a href="#l33.389"></a><span id="l33.389" class="difflineplus">+</span>
<a href="#l33.390"></a><span id="l33.390" class="difflineplus">+  append: function App_append(message) {</span>
<a href="#l33.391"></a><span id="l33.391" class="difflineplus">+    if(this._level &lt;= message.level)</span>
<a href="#l33.392"></a><span id="l33.392" class="difflineplus">+      this.doAppend(this._formatter.format(message));</span>
<a href="#l33.393"></a><span id="l33.393" class="difflineplus">+  },</span>
<a href="#l33.394"></a><span id="l33.394" class="difflineplus">+  toString: function App_toString() {</span>
<a href="#l33.395"></a><span id="l33.395" class="difflineplus">+    return this._name + &quot; [level=&quot; + this._level +</span>
<a href="#l33.396"></a><span id="l33.396" class="difflineplus">+      &quot;, formatter=&quot; + this._formatter + &quot;]&quot;;</span>
<a href="#l33.397"></a><span id="l33.397" class="difflineplus">+  },</span>
<a href="#l33.398"></a><span id="l33.398" class="difflineplus">+  doAppend: function App_doAppend(message) {}</span>
<a href="#l33.399"></a><span id="l33.399" class="difflineplus">+};</span>
<a href="#l33.400"></a><span id="l33.400" class="difflineplus">+</span>
<a href="#l33.401"></a><span id="l33.401" class="difflineplus">+/*</span>
<a href="#l33.402"></a><span id="l33.402" class="difflineplus">+ * DumpAppender</span>
<a href="#l33.403"></a><span id="l33.403" class="difflineplus">+ * Logs to standard out</span>
<a href="#l33.404"></a><span id="l33.404" class="difflineplus">+ */</span>
<a href="#l33.405"></a><span id="l33.405" class="difflineplus">+</span>
<a href="#l33.406"></a><span id="l33.406" class="difflineplus">+function DumpAppender(formatter) {</span>
<a href="#l33.407"></a><span id="l33.407" class="difflineplus">+  this._name = &quot;DumpAppender&quot;;</span>
<a href="#l33.408"></a><span id="l33.408" class="difflineplus">+  this._formatter = formatter;</span>
<a href="#l33.409"></a><span id="l33.409" class="difflineplus">+}</span>
<a href="#l33.410"></a><span id="l33.410" class="difflineplus">+DumpAppender.prototype = {</span>
<a href="#l33.411"></a><span id="l33.411" class="difflineplus">+  doAppend: function DApp_doAppend(message) {</span>
<a href="#l33.412"></a><span id="l33.412" class="difflineplus">+    dump(message);</span>
<a href="#l33.413"></a><span id="l33.413" class="difflineplus">+  }</span>
<a href="#l33.414"></a><span id="l33.414" class="difflineplus">+};</span>
<a href="#l33.415"></a><span id="l33.415" class="difflineplus">+DumpAppender.prototype.__proto__ = new Appender();</span>
<a href="#l33.416"></a><span id="l33.416" class="difflineplus">+</span>
<a href="#l33.417"></a><span id="l33.417" class="difflineplus">+/*</span>
<a href="#l33.418"></a><span id="l33.418" class="difflineplus">+ * ConsoleAppender</span>
<a href="#l33.419"></a><span id="l33.419" class="difflineplus">+ * Logs to the javascript console</span>
<a href="#l33.420"></a><span id="l33.420" class="difflineplus">+ */</span>
<a href="#l33.421"></a><span id="l33.421" class="difflineplus">+</span>
<a href="#l33.422"></a><span id="l33.422" class="difflineplus">+function ConsoleAppender(formatter) {</span>
<a href="#l33.423"></a><span id="l33.423" class="difflineplus">+  this._name = &quot;ConsoleAppender&quot;;</span>
<a href="#l33.424"></a><span id="l33.424" class="difflineplus">+  this._formatter = formatter;</span>
<a href="#l33.425"></a><span id="l33.425" class="difflineplus">+}</span>
<a href="#l33.426"></a><span id="l33.426" class="difflineplus">+ConsoleAppender.prototype = {</span>
<a href="#l33.427"></a><span id="l33.427" class="difflineplus">+  doAppend: function CApp_doAppend(message) {</span>
<a href="#l33.428"></a><span id="l33.428" class="difflineplus">+    if (message.level &gt; Log4Moz.Level.Warn) {</span>
<a href="#l33.429"></a><span id="l33.429" class="difflineplus">+      Cu.reportError(message);</span>
<a href="#l33.430"></a><span id="l33.430" class="difflineplus">+      return;</span>
<a href="#l33.431"></a><span id="l33.431" class="difflineplus">+    }</span>
<a href="#l33.432"></a><span id="l33.432" class="difflineplus">+    Cc[&quot;@mozilla.org/consoleservice;1&quot;].</span>
<a href="#l33.433"></a><span id="l33.433" class="difflineplus">+      getService(Ci.nsIConsoleService).logStringMessage(message);</span>
<a href="#l33.434"></a><span id="l33.434" class="difflineplus">+  }</span>
<a href="#l33.435"></a><span id="l33.435" class="difflineplus">+};</span>
<a href="#l33.436"></a><span id="l33.436" class="difflineplus">+ConsoleAppender.prototype.__proto__ = new Appender();</span>
<a href="#l33.437"></a><span id="l33.437" class="difflineplus">+</span>
<a href="#l33.438"></a><span id="l33.438" class="difflineplus">+/*</span>
<a href="#l33.439"></a><span id="l33.439" class="difflineplus">+ * FileAppender</span>
<a href="#l33.440"></a><span id="l33.440" class="difflineplus">+ * Logs to a file</span>
<a href="#l33.441"></a><span id="l33.441" class="difflineplus">+ */</span>
<a href="#l33.442"></a><span id="l33.442" class="difflineplus">+</span>
<a href="#l33.443"></a><span id="l33.443" class="difflineplus">+function FileAppender(file, formatter) {</span>
<a href="#l33.444"></a><span id="l33.444" class="difflineplus">+  this._name = &quot;FileAppender&quot;;</span>
<a href="#l33.445"></a><span id="l33.445" class="difflineplus">+  this._file = file; // nsIFile</span>
<a href="#l33.446"></a><span id="l33.446" class="difflineplus">+  this._formatter = formatter;</span>
<a href="#l33.447"></a><span id="l33.447" class="difflineplus">+}</span>
<a href="#l33.448"></a><span id="l33.448" class="difflineplus">+FileAppender.prototype = {</span>
<a href="#l33.449"></a><span id="l33.449" class="difflineplus">+  __fos: null,</span>
<a href="#l33.450"></a><span id="l33.450" class="difflineplus">+  get _fos() {</span>
<a href="#l33.451"></a><span id="l33.451" class="difflineplus">+    if (!this.__fos)</span>
<a href="#l33.452"></a><span id="l33.452" class="difflineplus">+      this.openStream();</span>
<a href="#l33.453"></a><span id="l33.453" class="difflineplus">+    return this.__fos;</span>
<a href="#l33.454"></a><span id="l33.454" class="difflineplus">+  },</span>
<a href="#l33.455"></a><span id="l33.455" class="difflineplus">+</span>
<a href="#l33.456"></a><span id="l33.456" class="difflineplus">+  openStream: function FApp_openStream() {</span>
<a href="#l33.457"></a><span id="l33.457" class="difflineplus">+    this.__fos = Cc[&quot;@mozilla.org/network/file-output-stream;1&quot;].</span>
<a href="#l33.458"></a><span id="l33.458" class="difflineplus">+      createInstance(Ci.nsIFileOutputStream);</span>
<a href="#l33.459"></a><span id="l33.459" class="difflineplus">+    let flags = MODE_WRONLY | MODE_CREATE | MODE_APPEND;</span>
<a href="#l33.460"></a><span id="l33.460" class="difflineplus">+    this.__fos.init(this._file, flags, PERMS_FILE, 0);</span>
<a href="#l33.461"></a><span id="l33.461" class="difflineplus">+  },</span>
<a href="#l33.462"></a><span id="l33.462" class="difflineplus">+</span>
<a href="#l33.463"></a><span id="l33.463" class="difflineplus">+  closeStream: function FApp_closeStream() {</span>
<a href="#l33.464"></a><span id="l33.464" class="difflineplus">+    if (!this.__fos)</span>
<a href="#l33.465"></a><span id="l33.465" class="difflineplus">+      return;</span>
<a href="#l33.466"></a><span id="l33.466" class="difflineplus">+    try {</span>
<a href="#l33.467"></a><span id="l33.467" class="difflineplus">+      this.__fos.close();</span>
<a href="#l33.468"></a><span id="l33.468" class="difflineplus">+      this.__fos = null;</span>
<a href="#l33.469"></a><span id="l33.469" class="difflineplus">+    } catch(e) {</span>
<a href="#l33.470"></a><span id="l33.470" class="difflineplus">+      dump(&quot;Failed to close file output stream\n&quot; + e);</span>
<a href="#l33.471"></a><span id="l33.471" class="difflineplus">+    }</span>
<a href="#l33.472"></a><span id="l33.472" class="difflineplus">+  },</span>
<a href="#l33.473"></a><span id="l33.473" class="difflineplus">+</span>
<a href="#l33.474"></a><span id="l33.474" class="difflineplus">+  doAppend: function FApp_doAppend(message) {</span>
<a href="#l33.475"></a><span id="l33.475" class="difflineplus">+    if (message === null || message.length &lt;= 0)</span>
<a href="#l33.476"></a><span id="l33.476" class="difflineplus">+      return;</span>
<a href="#l33.477"></a><span id="l33.477" class="difflineplus">+    try {</span>
<a href="#l33.478"></a><span id="l33.478" class="difflineplus">+      this._fos().write(message, message.length);</span>
<a href="#l33.479"></a><span id="l33.479" class="difflineplus">+    } catch(e) {</span>
<a href="#l33.480"></a><span id="l33.480" class="difflineplus">+      dump(&quot;Error writing file:\n&quot; + e);</span>
<a href="#l33.481"></a><span id="l33.481" class="difflineplus">+    }</span>
<a href="#l33.482"></a><span id="l33.482" class="difflineplus">+  },</span>
<a href="#l33.483"></a><span id="l33.483" class="difflineplus">+</span>
<a href="#l33.484"></a><span id="l33.484" class="difflineplus">+  clear: function FApp_clear() {</span>
<a href="#l33.485"></a><span id="l33.485" class="difflineplus">+    this.closeStream();</span>
<a href="#l33.486"></a><span id="l33.486" class="difflineplus">+    this._file.remove(false);</span>
<a href="#l33.487"></a><span id="l33.487" class="difflineplus">+  }</span>
<a href="#l33.488"></a><span id="l33.488" class="difflineplus">+};</span>
<a href="#l33.489"></a><span id="l33.489" class="difflineplus">+FileAppender.prototype.__proto__ = new Appender();</span>
<a href="#l33.490"></a><span id="l33.490" class="difflineplus">+</span>
<a href="#l33.491"></a><span id="l33.491" class="difflineplus">+/*</span>
<a href="#l33.492"></a><span id="l33.492" class="difflineplus">+ * RotatingFileAppender</span>
<a href="#l33.493"></a><span id="l33.493" class="difflineplus">+ * Similar to FileAppender, but rotates logs when they become too large</span>
<a href="#l33.494"></a><span id="l33.494" class="difflineplus">+ */</span>
<a href="#l33.495"></a><span id="l33.495" class="difflineplus">+</span>
<a href="#l33.496"></a><span id="l33.496" class="difflineplus">+function RotatingFileAppender(file, formatter, maxSize, maxBackups) {</span>
<a href="#l33.497"></a><span id="l33.497" class="difflineplus">+  if (maxSize === undefined)</span>
<a href="#l33.498"></a><span id="l33.498" class="difflineplus">+    maxSize = ONE_MEGABYTE * 2;</span>
<a href="#l33.499"></a><span id="l33.499" class="difflineplus">+</span>
<a href="#l33.500"></a><span id="l33.500" class="difflineplus">+  if (maxBackups === undefined)</span>
<a href="#l33.501"></a><span id="l33.501" class="difflineplus">+    maxBackups = 0;</span>
<a href="#l33.502"></a><span id="l33.502" class="difflineplus">+</span>
<a href="#l33.503"></a><span id="l33.503" class="difflineplus">+  this._name = &quot;RotatingFileAppender&quot;;</span>
<a href="#l33.504"></a><span id="l33.504" class="difflineplus">+  this._file = file; // nsIFile</span>
<a href="#l33.505"></a><span id="l33.505" class="difflineplus">+  this._formatter = formatter;</span>
<a href="#l33.506"></a><span id="l33.506" class="difflineplus">+  this._maxSize = maxSize;</span>
<a href="#l33.507"></a><span id="l33.507" class="difflineplus">+  this._maxBackups = maxBackups;</span>
<a href="#l33.508"></a><span id="l33.508" class="difflineplus">+}</span>
<a href="#l33.509"></a><span id="l33.509" class="difflineplus">+RotatingFileAppender.prototype = {</span>
<a href="#l33.510"></a><span id="l33.510" class="difflineplus">+  doAppend: function RFApp_doAppend(message) {</span>
<a href="#l33.511"></a><span id="l33.511" class="difflineplus">+    if (message === null || message.length &lt;= 0)</span>
<a href="#l33.512"></a><span id="l33.512" class="difflineplus">+      return;</span>
<a href="#l33.513"></a><span id="l33.513" class="difflineplus">+    try {</span>
<a href="#l33.514"></a><span id="l33.514" class="difflineplus">+      this.rotateLogs();</span>
<a href="#l33.515"></a><span id="l33.515" class="difflineplus">+      this._fos.write(message, message.length);</span>
<a href="#l33.516"></a><span id="l33.516" class="difflineplus">+    } catch(e) {</span>
<a href="#l33.517"></a><span id="l33.517" class="difflineplus">+      dump(&quot;Error writing file:\n&quot; + e);</span>
<a href="#l33.518"></a><span id="l33.518" class="difflineplus">+    }</span>
<a href="#l33.519"></a><span id="l33.519" class="difflineplus">+  },</span>
<a href="#l33.520"></a><span id="l33.520" class="difflineplus">+  rotateLogs: function RFApp_rotateLogs() {</span>
<a href="#l33.521"></a><span id="l33.521" class="difflineplus">+    if(this._file.exists() &amp;&amp;</span>
<a href="#l33.522"></a><span id="l33.522" class="difflineplus">+       this._file.fileSize &lt; this._maxSize)</span>
<a href="#l33.523"></a><span id="l33.523" class="difflineplus">+      return;</span>
<a href="#l33.524"></a><span id="l33.524" class="difflineplus">+</span>
<a href="#l33.525"></a><span id="l33.525" class="difflineplus">+    this.closeStream();</span>
<a href="#l33.526"></a><span id="l33.526" class="difflineplus">+</span>
<a href="#l33.527"></a><span id="l33.527" class="difflineplus">+    for (let i = this.maxBackups - 1; i &gt; 0; i--){</span>
<a href="#l33.528"></a><span id="l33.528" class="difflineplus">+      let backup = this._file.parent.clone();</span>
<a href="#l33.529"></a><span id="l33.529" class="difflineplus">+      backup.append(this._file.leafName + &quot;.&quot; + i);</span>
<a href="#l33.530"></a><span id="l33.530" class="difflineplus">+      if (backup.exists())</span>
<a href="#l33.531"></a><span id="l33.531" class="difflineplus">+        backup.moveTo(this._file.parent, this._file.leafName + &quot;.&quot; + (i + 1));</span>
<a href="#l33.532"></a><span id="l33.532" class="difflineplus">+    }</span>
<a href="#l33.533"></a><span id="l33.533" class="difflineplus">+</span>
<a href="#l33.534"></a><span id="l33.534" class="difflineplus">+    let cur = this._file.clone();</span>
<a href="#l33.535"></a><span id="l33.535" class="difflineplus">+    if (cur.exists())</span>
<a href="#l33.536"></a><span id="l33.536" class="difflineplus">+      cur.moveTo(cur.parent, cur.leafName + &quot;.1&quot;);</span>
<a href="#l33.537"></a><span id="l33.537" class="difflineplus">+</span>
<a href="#l33.538"></a><span id="l33.538" class="difflineplus">+    // Note: this._file still points to the same file</span>
<a href="#l33.539"></a><span id="l33.539" class="difflineplus">+  }</span>
<a href="#l33.540"></a><span id="l33.540" class="difflineplus">+};</span>
<a href="#l33.541"></a><span id="l33.541" class="difflineplus">+RotatingFileAppender.prototype.__proto__ = new FileAppender();</span>
<a href="#l33.542"></a><span id="l33.542" class="difflineplus">+</span>
<a href="#l33.543"></a><span id="l33.543" class="difflineplus">+/*</span>
<a href="#l33.544"></a><span id="l33.544" class="difflineplus">+ * SocketAppender</span>
<a href="#l33.545"></a><span id="l33.545" class="difflineplus">+ * Logs via TCP to a given host and port.  Attempts to automatically reconnect</span>
<a href="#l33.546"></a><span id="l33.546" class="difflineplus">+ * when the connection drops or cannot be initially re-established.  Connection</span>
<a href="#l33.547"></a><span id="l33.547" class="difflineplus">+ * attempts will happen at most every timeoutDelay seconds (has a sane default</span>
<a href="#l33.548"></a><span id="l33.548" class="difflineplus">+ * if left blank).  Messages are dropped when there is no connection.  </span>
<a href="#l33.549"></a><span id="l33.549" class="difflineplus">+ */</span>
<a href="#l33.550"></a><span id="l33.550" class="difflineplus">+</span>
<a href="#l33.551"></a><span id="l33.551" class="difflineplus">+function SocketAppender(host, port, formatter, timeoutDelay) {</span>
<a href="#l33.552"></a><span id="l33.552" class="difflineplus">+  this._name = &quot;SocketAppender&quot;;</span>
<a href="#l33.553"></a><span id="l33.553" class="difflineplus">+  this._host = host;</span>
<a href="#l33.554"></a><span id="l33.554" class="difflineplus">+  this._port = port;</span>
<a href="#l33.555"></a><span id="l33.555" class="difflineplus">+  this._formatter = formatter;</span>
<a href="#l33.556"></a><span id="l33.556" class="difflineplus">+  this._timeout_delay = timeoutDelay || DEFAULT_NETWORK_TIMEOUT_DELAY;</span>
<a href="#l33.557"></a><span id="l33.557" class="difflineplus">+</span>
<a href="#l33.558"></a><span id="l33.558" class="difflineplus">+  this._socketService = Cc[&quot;@mozilla.org/network/socket-transport-service;1&quot;]</span>
<a href="#l33.559"></a><span id="l33.559" class="difflineplus">+                          .getService(Ci.nsISocketTransportService);</span>
<a href="#l33.560"></a><span id="l33.560" class="difflineplus">+  this._mainThread =</span>
<a href="#l33.561"></a><span id="l33.561" class="difflineplus">+    Cc[&quot;@mozilla.org/thread-manager;1&quot;].getService().mainThread;</span>
<a href="#l33.562"></a><span id="l33.562" class="difflineplus">+}</span>
<a href="#l33.563"></a><span id="l33.563" class="difflineplus">+SocketAppender.prototype = {</span>
<a href="#l33.564"></a><span id="l33.564" class="difflineplus">+  __nos: null,</span>
<a href="#l33.565"></a><span id="l33.565" class="difflineplus">+  get _nos() {</span>
<a href="#l33.566"></a><span id="l33.566" class="difflineplus">+    if (!this.__nos)</span>
<a href="#l33.567"></a><span id="l33.567" class="difflineplus">+      this.openStream();</span>
<a href="#l33.568"></a><span id="l33.568" class="difflineplus">+    return this.__nos;</span>
<a href="#l33.569"></a><span id="l33.569" class="difflineplus">+  },</span>
<a href="#l33.570"></a><span id="l33.570" class="difflineplus">+  _nextCheck: 0,</span>
<a href="#l33.571"></a><span id="l33.571" class="difflineplus">+  openStream: function SApp_openStream() {</span>
<a href="#l33.572"></a><span id="l33.572" class="difflineplus">+    let now = Date.now();</span>
<a href="#l33.573"></a><span id="l33.573" class="difflineplus">+    if (now &lt;= this._nextCheck) {</span>
<a href="#l33.574"></a><span id="l33.574" class="difflineplus">+      return null;</span>
<a href="#l33.575"></a><span id="l33.575" class="difflineplus">+    }</span>
<a href="#l33.576"></a><span id="l33.576" class="difflineplus">+    this._nextCheck = now + this._timeout_delay * 1000;</span>
<a href="#l33.577"></a><span id="l33.577" class="difflineplus">+    try {</span>
<a href="#l33.578"></a><span id="l33.578" class="difflineplus">+      this._transport = this._socketService.createTransport(</span>
<a href="#l33.579"></a><span id="l33.579" class="difflineplus">+        null, 0, // default socket type</span>
<a href="#l33.580"></a><span id="l33.580" class="difflineplus">+        this._host, this._port,</span>
<a href="#l33.581"></a><span id="l33.581" class="difflineplus">+        null); // no proxy</span>
<a href="#l33.582"></a><span id="l33.582" class="difflineplus">+      this._transport.setTimeout(Ci.nsISocketTransport.TIMEOUT_CONNECT,</span>
<a href="#l33.583"></a><span id="l33.583" class="difflineplus">+                                 this._timeout_delay);</span>
<a href="#l33.584"></a><span id="l33.584" class="difflineplus">+      // do not set a timeout for TIMEOUT_READ_WRITE. The timeout is not</span>
<a href="#l33.585"></a><span id="l33.585" class="difflineplus">+      //  entirely intuitive; your socket will time out if no one reads or</span>
<a href="#l33.586"></a><span id="l33.586" class="difflineplus">+      //  writes to the socket within the timeout.  That, as you can imagine,</span>
<a href="#l33.587"></a><span id="l33.587" class="difflineplus">+      //  is not what we want.</span>
<a href="#l33.588"></a><span id="l33.588" class="difflineplus">+      this._transport.setEventSink(this, this._mainThread);</span>
<a href="#l33.589"></a><span id="l33.589" class="difflineplus">+  </span>
<a href="#l33.590"></a><span id="l33.590" class="difflineplus">+      this.__nos = this._transport.openOutputStream(</span>
<a href="#l33.591"></a><span id="l33.591" class="difflineplus">+        0, // neither blocking nor unbuffered operation is desired</span>
<a href="#l33.592"></a><span id="l33.592" class="difflineplus">+        0, // default buffer size is fine</span>
<a href="#l33.593"></a><span id="l33.593" class="difflineplus">+        0 // default buffer count is fine</span>
<a href="#l33.594"></a><span id="l33.594" class="difflineplus">+        );</span>
<a href="#l33.595"></a><span id="l33.595" class="difflineplus">+    } catch (ex) {</span>
<a href="#l33.596"></a><span id="l33.596" class="difflineplus">+      dump(&quot;Unexpected SocketAppender connection problem: &quot; +</span>
<a href="#l33.597"></a><span id="l33.597" class="difflineplus">+           ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex + &quot;\n&quot;);</span>
<a href="#l33.598"></a><span id="l33.598" class="difflineplus">+    }</span>
<a href="#l33.599"></a><span id="l33.599" class="difflineplus">+  },</span>
<a href="#l33.600"></a><span id="l33.600" class="difflineplus">+</span>
<a href="#l33.601"></a><span id="l33.601" class="difflineplus">+  closeStream: function SApp_closeStream() {</span>
<a href="#l33.602"></a><span id="l33.602" class="difflineplus">+    if (!this._transport)</span>
<a href="#l33.603"></a><span id="l33.603" class="difflineplus">+      return;</span>
<a href="#l33.604"></a><span id="l33.604" class="difflineplus">+    try {</span>
<a href="#l33.605"></a><span id="l33.605" class="difflineplus">+      this._connected = false;</span>
<a href="#l33.606"></a><span id="l33.606" class="difflineplus">+      this._transport = null;</span>
<a href="#l33.607"></a><span id="l33.607" class="difflineplus">+      let nos = this.__nos;</span>
<a href="#l33.608"></a><span id="l33.608" class="difflineplus">+      this.__nos = null;</span>
<a href="#l33.609"></a><span id="l33.609" class="difflineplus">+      nos.close();</span>
<a href="#l33.610"></a><span id="l33.610" class="difflineplus">+    } catch(e) {</span>
<a href="#l33.611"></a><span id="l33.611" class="difflineplus">+      // this shouldn't happen, but no one cares</span>
<a href="#l33.612"></a><span id="l33.612" class="difflineplus">+    }</span>
<a href="#l33.613"></a><span id="l33.613" class="difflineplus">+  },</span>
<a href="#l33.614"></a><span id="l33.614" class="difflineplus">+</span>
<a href="#l33.615"></a><span id="l33.615" class="difflineplus">+  doAppend: function SApp_doAppend(message) {</span>
<a href="#l33.616"></a><span id="l33.616" class="difflineplus">+    if (message === null || message.length &lt;= 0)</span>
<a href="#l33.617"></a><span id="l33.617" class="difflineplus">+      return;</span>
<a href="#l33.618"></a><span id="l33.618" class="difflineplus">+    try {</span>
<a href="#l33.619"></a><span id="l33.619" class="difflineplus">+      let nos = this._nos;</span>
<a href="#l33.620"></a><span id="l33.620" class="difflineplus">+      if (nos)</span>
<a href="#l33.621"></a><span id="l33.621" class="difflineplus">+        nos.write(message, message.length);</span>
<a href="#l33.622"></a><span id="l33.622" class="difflineplus">+    } catch(e) {</span>
<a href="#l33.623"></a><span id="l33.623" class="difflineplus">+      if (this._transport &amp;&amp; !this._transport.isAlive()) {</span>
<a href="#l33.624"></a><span id="l33.624" class="difflineplus">+        this.closeStream();</span>
<a href="#l33.625"></a><span id="l33.625" class="difflineplus">+      }</span>
<a href="#l33.626"></a><span id="l33.626" class="difflineplus">+    }</span>
<a href="#l33.627"></a><span id="l33.627" class="difflineplus">+  },</span>
<a href="#l33.628"></a><span id="l33.628" class="difflineplus">+</span>
<a href="#l33.629"></a><span id="l33.629" class="difflineplus">+  clear: function SApp_clear() {</span>
<a href="#l33.630"></a><span id="l33.630" class="difflineplus">+    this.closeStream();</span>
<a href="#l33.631"></a><span id="l33.631" class="difflineplus">+    this._file.remove(false);</span>
<a href="#l33.632"></a><span id="l33.632" class="difflineplus">+  },</span>
<a href="#l33.633"></a><span id="l33.633" class="difflineplus">+  </span>
<a href="#l33.634"></a><span id="l33.634" class="difflineplus">+  /* nsITransportEventSink */</span>
<a href="#l33.635"></a><span id="l33.635" class="difflineplus">+  onTransportStatus: function SApp_onTransportStatus(aTransport, aStatus,</span>
<a href="#l33.636"></a><span id="l33.636" class="difflineplus">+      aProgress, aProgressMax) {</span>
<a href="#l33.637"></a><span id="l33.637" class="difflineplus">+    if (aStatus == 0x804b0004) // STATUS_CONNECTED_TO is not a constant.</span>
<a href="#l33.638"></a><span id="l33.638" class="difflineplus">+      this._connected = true;</span>
<a href="#l33.639"></a><span id="l33.639" class="difflineplus">+  },</span>
<a href="#l33.640"></a><span id="l33.640" class="difflineplus">+  </span>
<a href="#l33.641"></a><span id="l33.641" class="difflineplus">+};</span>
<a href="#l33.642"></a><span id="l33.642" class="difflineplus">+SocketAppender.prototype.__proto__ = new Appender();</span>
<a href="#l33.643"></a><span id="l33.643" class="difflineplus">+</span>
<a href="#l33.644"></a><span id="l33.644" class="difflineplus">+</span>
<a href="#l33.645"></a><span id="l33.645" class="difflineplus">+/*</span>
<a href="#l33.646"></a><span id="l33.646" class="difflineplus">+ * LoggingService</span>
<a href="#l33.647"></a><span id="l33.647" class="difflineplus">+ */</span>
<a href="#l33.648"></a><span id="l33.648" class="difflineplus">+</span>
<a href="#l33.649"></a><span id="l33.649" class="difflineplus">+function Log4MozService() {</span>
<a href="#l33.650"></a><span id="l33.650" class="difflineplus">+  this._repository = new LoggerRepository();</span>
<a href="#l33.651"></a><span id="l33.651" class="difflineplus">+}</span>
<a href="#l33.652"></a><span id="l33.652" class="difflineplus">+Log4MozService.prototype = {</span>
<a href="#l33.653"></a><span id="l33.653" class="difflineplus">+  //classDescription: &quot;Log4moz Logging Service&quot;,</span>
<a href="#l33.654"></a><span id="l33.654" class="difflineplus">+  //contractID: &quot;@mozilla.org/log4moz/service;1&quot;,</span>
<a href="#l33.655"></a><span id="l33.655" class="difflineplus">+  //classID: Components.ID(&quot;{a60e50d7-90b8-4a12-ad0c-79e6a1896978}&quot;),</span>
<a href="#l33.656"></a><span id="l33.656" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISupports]),</span>
<a href="#l33.657"></a><span id="l33.657" class="difflineplus">+</span>
<a href="#l33.658"></a><span id="l33.658" class="difflineplus">+  get rootLogger() {</span>
<a href="#l33.659"></a><span id="l33.659" class="difflineplus">+    return this._repository.rootLogger;</span>
<a href="#l33.660"></a><span id="l33.660" class="difflineplus">+  },</span>
<a href="#l33.661"></a><span id="l33.661" class="difflineplus">+</span>
<a href="#l33.662"></a><span id="l33.662" class="difflineplus">+  getLogger: function LogSvc_getLogger(name) {</span>
<a href="#l33.663"></a><span id="l33.663" class="difflineplus">+    return this._repository.getLogger(name);</span>
<a href="#l33.664"></a><span id="l33.664" class="difflineplus">+  }</span>
<a href="#l33.665"></a><span id="l33.665" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1">new file mode 100644</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineminus">--- /dev/null</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/mimemsg.js</span>
<a href="#l34.4"></a><span id="l34.4" class="difflineat">@@ -0,0 +1,454 @@</span>
<a href="#l34.5"></a><span id="l34.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l34.6"></a><span id="l34.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l34.7"></a><span id="l34.7" class="difflineplus">+ *</span>
<a href="#l34.8"></a><span id="l34.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l34.9"></a><span id="l34.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l34.10"></a><span id="l34.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l34.11"></a><span id="l34.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineplus">+ * </span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l34.14"></a><span id="l34.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l34.15"></a><span id="l34.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l34.16"></a><span id="l34.16" class="difflineplus">+ * License.</span>
<a href="#l34.17"></a><span id="l34.17" class="difflineplus">+ *</span>
<a href="#l34.18"></a><span id="l34.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l34.19"></a><span id="l34.19" class="difflineplus">+ *</span>
<a href="#l34.20"></a><span id="l34.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l34.21"></a><span id="l34.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l34.22"></a><span id="l34.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l34.23"></a><span id="l34.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l34.24"></a><span id="l34.24" class="difflineplus">+ *</span>
<a href="#l34.25"></a><span id="l34.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l34.26"></a><span id="l34.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l34.27"></a><span id="l34.27" class="difflineplus">+ *</span>
<a href="#l34.28"></a><span id="l34.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l34.29"></a><span id="l34.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l34.30"></a><span id="l34.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l34.31"></a><span id="l34.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l34.32"></a><span id="l34.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l34.33"></a><span id="l34.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l34.34"></a><span id="l34.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l34.35"></a><span id="l34.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l34.36"></a><span id="l34.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l34.37"></a><span id="l34.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l34.38"></a><span id="l34.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l34.39"></a><span id="l34.39" class="difflineplus">+ * </span>
<a href="#l34.40"></a><span id="l34.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l34.41"></a><span id="l34.41" class="difflineplus">+</span>
<a href="#l34.42"></a><span id="l34.42" class="difflineplus">+EXPORTED_SYMBOLS = ['MsgHdrToMimeMessage',</span>
<a href="#l34.43"></a><span id="l34.43" class="difflineplus">+                    'MimeMessage', 'MimeContainer', 'MimeBody', 'MimeUnknown',</span>
<a href="#l34.44"></a><span id="l34.44" class="difflineplus">+                    'MimeMessageAttachment'];</span>
<a href="#l34.45"></a><span id="l34.45" class="difflineplus">+</span>
<a href="#l34.46"></a><span id="l34.46" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l34.47"></a><span id="l34.47" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l34.48"></a><span id="l34.48" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l34.49"></a><span id="l34.49" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l34.50"></a><span id="l34.50" class="difflineplus">+</span>
<a href="#l34.51"></a><span id="l34.51" class="difflineplus">+Components.utils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l34.52"></a><span id="l34.52" class="difflineplus">+</span>
<a href="#l34.53"></a><span id="l34.53" class="difflineplus">+const EMITTER_MIME_CODE = &quot;application/x-js-mime-message&quot;;</span>
<a href="#l34.54"></a><span id="l34.54" class="difflineplus">+</span>
<a href="#l34.55"></a><span id="l34.55" class="difflineplus">+/**</span>
<a href="#l34.56"></a><span id="l34.56" class="difflineplus">+ * The URL listener is surplus because the CallbackStreamListener ends up</span>
<a href="#l34.57"></a><span id="l34.57" class="difflineplus">+ *  getting the same set of events, effectively.</span>
<a href="#l34.58"></a><span id="l34.58" class="difflineplus">+ */</span>
<a href="#l34.59"></a><span id="l34.59" class="difflineplus">+let dumbUrlListener = {</span>
<a href="#l34.60"></a><span id="l34.60" class="difflineplus">+  OnStartRunningUrl: function (aUrl) {</span>
<a href="#l34.61"></a><span id="l34.61" class="difflineplus">+  },</span>
<a href="#l34.62"></a><span id="l34.62" class="difflineplus">+  OnStopRunningUrl: function (aUrl, aExitCode) {</span>
<a href="#l34.63"></a><span id="l34.63" class="difflineplus">+  },</span>
<a href="#l34.64"></a><span id="l34.64" class="difflineplus">+};</span>
<a href="#l34.65"></a><span id="l34.65" class="difflineplus">+</span>
<a href="#l34.66"></a><span id="l34.66" class="difflineplus">+let gCallbacks = {};</span>
<a href="#l34.67"></a><span id="l34.67" class="difflineplus">+</span>
<a href="#l34.68"></a><span id="l34.68" class="difflineplus">+function CallbackStreamListener(aMsgHdr, aCallbackThis, aCallback) {</span>
<a href="#l34.69"></a><span id="l34.69" class="difflineplus">+  this._msgHdr = aMsgHdr;</span>
<a href="#l34.70"></a><span id="l34.70" class="difflineplus">+  this._stream = null;</span>
<a href="#l34.71"></a><span id="l34.71" class="difflineplus">+  if (aCallback === undefined) {</span>
<a href="#l34.72"></a><span id="l34.72" class="difflineplus">+    this._callbackThis = null;</span>
<a href="#l34.73"></a><span id="l34.73" class="difflineplus">+    this._callback = aCallbackThis;</span>
<a href="#l34.74"></a><span id="l34.74" class="difflineplus">+  }</span>
<a href="#l34.75"></a><span id="l34.75" class="difflineplus">+  else {</span>
<a href="#l34.76"></a><span id="l34.76" class="difflineplus">+    this._callbackThis = aCallbackThis;</span>
<a href="#l34.77"></a><span id="l34.77" class="difflineplus">+    this._callback = aCallback;</span>
<a href="#l34.78"></a><span id="l34.78" class="difflineplus">+  }</span>
<a href="#l34.79"></a><span id="l34.79" class="difflineplus">+}</span>
<a href="#l34.80"></a><span id="l34.80" class="difflineplus">+</span>
<a href="#l34.81"></a><span id="l34.81" class="difflineplus">+CallbackStreamListener.prototype = {</span>
<a href="#l34.82"></a><span id="l34.82" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIStreamListener]),</span>
<a href="#l34.83"></a><span id="l34.83" class="difflineplus">+</span>
<a href="#l34.84"></a><span id="l34.84" class="difflineplus">+  // nsIRequestObserver part</span>
<a href="#l34.85"></a><span id="l34.85" class="difflineplus">+  onStartRequest: function (aRequest, aContext) {</span>
<a href="#l34.86"></a><span id="l34.86" class="difflineplus">+  },</span>
<a href="#l34.87"></a><span id="l34.87" class="difflineplus">+  onStopRequest: function (aRequest, aContext, aStatusCode) {</span>
<a href="#l34.88"></a><span id="l34.88" class="difflineplus">+    aContext.QueryInterface(Ci.nsIURI);</span>
<a href="#l34.89"></a><span id="l34.89" class="difflineplus">+    let message = MsgHdrToMimeMessage.RESULT_RENDEVOUZ[aContext.spec];</span>
<a href="#l34.90"></a><span id="l34.90" class="difflineplus">+    if (message === undefined)</span>
<a href="#l34.91"></a><span id="l34.91" class="difflineplus">+      message = null;</span>
<a href="#l34.92"></a><span id="l34.92" class="difflineplus">+</span>
<a href="#l34.93"></a><span id="l34.93" class="difflineplus">+    delete MsgHdrToMimeMessage.RESULT_RENDEVOUZ[aContext.spec];</span>
<a href="#l34.94"></a><span id="l34.94" class="difflineplus">+    </span>
<a href="#l34.95"></a><span id="l34.95" class="difflineplus">+    if (this._callbackThis)</span>
<a href="#l34.96"></a><span id="l34.96" class="difflineplus">+      this._callback.call(this._callbackThis, this._msgHdr, message);</span>
<a href="#l34.97"></a><span id="l34.97" class="difflineplus">+    else</span>
<a href="#l34.98"></a><span id="l34.98" class="difflineplus">+      this._callback.call(null, this._msgHdr, message);</span>
<a href="#l34.99"></a><span id="l34.99" class="difflineplus">+    </span>
<a href="#l34.100"></a><span id="l34.100" class="difflineplus">+    // null everyone out, we are getting hosed by some secretive horrible cycles</span>
<a href="#l34.101"></a><span id="l34.101" class="difflineplus">+    this._msgHdr = null;</span>
<a href="#l34.102"></a><span id="l34.102" class="difflineplus">+    this._stream = null;</span>
<a href="#l34.103"></a><span id="l34.103" class="difflineplus">+    this._callbackThis = null;</span>
<a href="#l34.104"></a><span id="l34.104" class="difflineplus">+    this._callback = null;</span>
<a href="#l34.105"></a><span id="l34.105" class="difflineplus">+  },</span>
<a href="#l34.106"></a><span id="l34.106" class="difflineplus">+</span>
<a href="#l34.107"></a><span id="l34.107" class="difflineplus">+  /* okay, our onDataAvailable should actually never be called.  the stream</span>
<a href="#l34.108"></a><span id="l34.108" class="difflineplus">+     converter is actually eating everything except the start and stop</span>
<a href="#l34.109"></a><span id="l34.109" class="difflineplus">+     notification. */</span>
<a href="#l34.110"></a><span id="l34.110" class="difflineplus">+  // nsIStreamListener part</span>
<a href="#l34.111"></a><span id="l34.111" class="difflineplus">+  onDataAvailable: function (aRequest,aContext,aInputStream,aOffset,aCount) {</span>
<a href="#l34.112"></a><span id="l34.112" class="difflineplus">+    dump(&quot;this should not be happening! arrgggggh!\n&quot;)</span>
<a href="#l34.113"></a><span id="l34.113" class="difflineplus">+    if (this._stream === null) {</span>
<a href="#l34.114"></a><span id="l34.114" class="difflineplus">+      this._stream = Cc[&quot;@mozilla.org/scriptableinputstream;1&quot;].</span>
<a href="#l34.115"></a><span id="l34.115" class="difflineplus">+                    createInstance(Ci.nsIScriptableInputStream);</span>
<a href="#l34.116"></a><span id="l34.116" class="difflineplus">+      this._stream.init(aInputStream);</span>
<a href="#l34.117"></a><span id="l34.117" class="difflineplus">+    }</span>
<a href="#l34.118"></a><span id="l34.118" class="difflineplus">+    this._stream.read(aCount);</span>
<a href="#l34.119"></a><span id="l34.119" class="difflineplus">+    </span>
<a href="#l34.120"></a><span id="l34.120" class="difflineplus">+  },</span>
<a href="#l34.121"></a><span id="l34.121" class="difflineplus">+};</span>
<a href="#l34.122"></a><span id="l34.122" class="difflineplus">+</span>
<a href="#l34.123"></a><span id="l34.123" class="difflineplus">+let gMessenger = Cc[&quot;@mozilla.org/messenger;1&quot;].</span>
<a href="#l34.124"></a><span id="l34.124" class="difflineplus">+                   createInstance(Ci.nsIMessenger);</span>
<a href="#l34.125"></a><span id="l34.125" class="difflineplus">+</span>
<a href="#l34.126"></a><span id="l34.126" class="difflineplus">+/**</span>
<a href="#l34.127"></a><span id="l34.127" class="difflineplus">+ * Starts retrieval of a MimeMessage instance for the given message header.</span>
<a href="#l34.128"></a><span id="l34.128" class="difflineplus">+ *  Your callback will be called with the message header you provide and the</span>
<a href="#l34.129"></a><span id="l34.129" class="difflineplus">+ *  </span>
<a href="#l34.130"></a><span id="l34.130" class="difflineplus">+ * @param aMsgHdr The message header to retrieve the body for and build a MIME</span>
<a href="#l34.131"></a><span id="l34.131" class="difflineplus">+ *     representation of the message.</span>
<a href="#l34.132"></a><span id="l34.132" class="difflineplus">+ * @param aCallbackThis The (optional) 'this' to use for your callback function.</span>
<a href="#l34.133"></a><span id="l34.133" class="difflineplus">+ * @param aCallback The callback function to invoke on completion of message</span>
<a href="#l34.134"></a><span id="l34.134" class="difflineplus">+ *     parsing or failure.  The first argument passed will be the nsIMsgDBHdr</span>
<a href="#l34.135"></a><span id="l34.135" class="difflineplus">+ *     you passed to this function.  The second argument will be the MimeMessage</span>
<a href="#l34.136"></a><span id="l34.136" class="difflineplus">+ *     instance resulting from the processing on success, and null on failure. </span>
<a href="#l34.137"></a><span id="l34.137" class="difflineplus">+ */</span>
<a href="#l34.138"></a><span id="l34.138" class="difflineplus">+function MsgHdrToMimeMessage(aMsgHdr, aCallbackThis, aCallback) {</span>
<a href="#l34.139"></a><span id="l34.139" class="difflineplus">+  let msgURI = aMsgHdr.folder.getUriForMsg(aMsgHdr);</span>
<a href="#l34.140"></a><span id="l34.140" class="difflineplus">+  let msgService = gMessenger.messageServiceFromURI(msgURI);</span>
<a href="#l34.141"></a><span id="l34.141" class="difflineplus">+  </span>
<a href="#l34.142"></a><span id="l34.142" class="difflineplus">+  let streamListener = new CallbackStreamListener(aMsgHdr,</span>
<a href="#l34.143"></a><span id="l34.143" class="difflineplus">+                                                  aCallbackThis, aCallback);</span>
<a href="#l34.144"></a><span id="l34.144" class="difflineplus">+  </span>
<a href="#l34.145"></a><span id="l34.145" class="difflineplus">+  let streamURI = msgService.streamMessage(msgURI,</span>
<a href="#l34.146"></a><span id="l34.146" class="difflineplus">+                                           streamListener, // consumer</span>
<a href="#l34.147"></a><span id="l34.147" class="difflineplus">+                                           null, // nsIMsgWindow</span>
<a href="#l34.148"></a><span id="l34.148" class="difflineplus">+                                           dumbUrlListener, // nsIUrlListener</span>
<a href="#l34.149"></a><span id="l34.149" class="difflineplus">+                                           true, // have them create the converter</span>
<a href="#l34.150"></a><span id="l34.150" class="difflineplus">+      // additional uri payload, note that &quot;header=&quot; is prepended automatically </span>
<a href="#l34.151"></a><span id="l34.151" class="difflineplus">+                                           &quot;filter&amp;emitter=js&quot;,</span>
<a href="#l34.152"></a><span id="l34.152" class="difflineplus">+                                           true);</span>
<a href="#l34.153"></a><span id="l34.153" class="difflineplus">+}</span>
<a href="#l34.154"></a><span id="l34.154" class="difflineplus">+</span>
<a href="#l34.155"></a><span id="l34.155" class="difflineplus">+/**</span>
<a href="#l34.156"></a><span id="l34.156" class="difflineplus">+ * Let the jsmimeemitter provide us with results.  The poor emitter (if I am</span>
<a href="#l34.157"></a><span id="l34.157" class="difflineplus">+ *  understanding things correctly) is evaluated outside of the C.u.import</span>
<a href="#l34.158"></a><span id="l34.158" class="difflineplus">+ *  world, so if we were to import him, we would not see him, but rather a new</span>
<a href="#l34.159"></a><span id="l34.159" class="difflineplus">+ *  copy of him.  This goes for his globals, etc.  (and is why we live in this</span>
<a href="#l34.160"></a><span id="l34.160" class="difflineplus">+ *  file right here).  Also, it appears that the XPCOM JS wrappers aren't</span>
<a href="#l34.161"></a><span id="l34.161" class="difflineplus">+ *  magically unified so that we can try and pass data as expando properties</span>
<a href="#l34.162"></a><span id="l34.162" class="difflineplus">+ *  on things like the nsIUri instances either.  So we have the jsmimeemitter</span>
<a href="#l34.163"></a><span id="l34.163" class="difflineplus">+ *  import us and poke things into RESULT_RENDEVOUZ.  We put it here on this</span>
<a href="#l34.164"></a><span id="l34.164" class="difflineplus">+ *  function to try and be stealthy and avoid polluting the namespaces (or</span>
<a href="#l34.165"></a><span id="l34.165" class="difflineplus">+ *  encouraging bad behaviour) of our importers.</span>
<a href="#l34.166"></a><span id="l34.166" class="difflineplus">+ *</span>
<a href="#l34.167"></a><span id="l34.167" class="difflineplus">+ * If you can come up with a prettier way to shuttle this data, please do.</span>
<a href="#l34.168"></a><span id="l34.168" class="difflineplus">+ */</span>
<a href="#l34.169"></a><span id="l34.169" class="difflineplus">+MsgHdrToMimeMessage.RESULT_RENDEVOUZ = {};</span>
<a href="#l34.170"></a><span id="l34.170" class="difflineplus">+</span>
<a href="#l34.171"></a><span id="l34.171" class="difflineplus">+/**</span>
<a href="#l34.172"></a><span id="l34.172" class="difflineplus">+ * @ivar partName The MIME part, ex &quot;1.2.2.1&quot;.  The partName of a (top-level)</span>
<a href="#l34.173"></a><span id="l34.173" class="difflineplus">+ *     message is &quot;1&quot;, its first child is &quot;1.1&quot;, its second child is &quot;1.2&quot;,</span>
<a href="#l34.174"></a><span id="l34.174" class="difflineplus">+ *     its first child's first child is &quot;1.1.1&quot;, etc.</span>
<a href="#l34.175"></a><span id="l34.175" class="difflineplus">+ * @ivar headers Maps lower-cased header field names to a list of the values</span>
<a href="#l34.176"></a><span id="l34.176" class="difflineplus">+ *     seen for the given header.  Use get or getAll as convenience helpers.</span>
<a href="#l34.177"></a><span id="l34.177" class="difflineplus">+ * @ivar bodyParts A list of the MimeBody instances that belong to this message.</span>
<a href="#l34.178"></a><span id="l34.178" class="difflineplus">+ *     If there are nested messages, any bodies under the nested messages will</span>
<a href="#l34.179"></a><span id="l34.179" class="difflineplus">+ *     belong to those messages.</span>
<a href="#l34.180"></a><span id="l34.180" class="difflineplus">+ * @ivar bodyPartsPlain A list of the MimeBody instances with a content type of</span>
<a href="#l34.181"></a><span id="l34.181" class="difflineplus">+ *     text/plain.</span>
<a href="#l34.182"></a><span id="l34.182" class="difflineplus">+ * @ivar bodyPlain The concatenation of all of the bodyPartsPlain bodies into a</span>
<a href="#l34.183"></a><span id="l34.183" class="difflineplus">+ *     single string.</span>
<a href="#l34.184"></a><span id="l34.184" class="difflineplus">+ * @ivar bodyPartsHTML A list of the MimeBody instances with a content type of</span>
<a href="#l34.185"></a><span id="l34.185" class="difflineplus">+ *     text/html.</span>
<a href="#l34.186"></a><span id="l34.186" class="difflineplus">+ * @ivar bodyHTML The concatentation of all of the bodyPartsHTML bodies into a</span>
<a href="#l34.187"></a><span id="l34.187" class="difflineplus">+ *     single string. </span>
<a href="#l34.188"></a><span id="l34.188" class="difflineplus">+ * @ivar messages A list of the sub-message children of this message.  Strict</span>
<a href="#l34.189"></a><span id="l34.189" class="difflineplus">+ *     MIME part hierarchy is not maintained; a sub-message's parent is the</span>
<a href="#l34.190"></a><span id="l34.190" class="difflineplus">+ *     closest sub-message above it.  Sub-messages can also be found in the</span>
<a href="#l34.191"></a><span id="l34.191" class="difflineplus">+ *     parts list, if you want a more strict traversal.</span>
<a href="#l34.192"></a><span id="l34.192" class="difflineplus">+ * @ivar parts The list of the MIME part children of this message.  Children</span>
<a href="#l34.193"></a><span id="l34.193" class="difflineplus">+ *     will be either MimeMessage instances, MimeMessageAttachment instances,</span>
<a href="#l34.194"></a><span id="l34.194" class="difflineplus">+ *     MimeContainer instances, or MimeUnknown instances.  The latter two are</span>
<a href="#l34.195"></a><span id="l34.195" class="difflineplus">+ *     the result of limitations in the Javascript representation generation  </span>
<a href="#l34.196"></a><span id="l34.196" class="difflineplus">+ *     at this time, combined with the need to most accurately represent the</span>
<a href="#l34.197"></a><span id="l34.197" class="difflineplus">+ *     MIME structure.</span>
<a href="#l34.198"></a><span id="l34.198" class="difflineplus">+ */</span>
<a href="#l34.199"></a><span id="l34.199" class="difflineplus">+function MimeMessage() {</span>
<a href="#l34.200"></a><span id="l34.200" class="difflineplus">+  this.partName = null;</span>
<a href="#l34.201"></a><span id="l34.201" class="difflineplus">+  this.headers = {};</span>
<a href="#l34.202"></a><span id="l34.202" class="difflineplus">+  </span>
<a href="#l34.203"></a><span id="l34.203" class="difflineplus">+  this.bodyParts = [];</span>
<a href="#l34.204"></a><span id="l34.204" class="difflineplus">+</span>
<a href="#l34.205"></a><span id="l34.205" class="difflineplus">+  this.messages = [];</span>
<a href="#l34.206"></a><span id="l34.206" class="difflineplus">+  this.attachments = [];</span>
<a href="#l34.207"></a><span id="l34.207" class="difflineplus">+</span>
<a href="#l34.208"></a><span id="l34.208" class="difflineplus">+  this.parts = [];</span>
<a href="#l34.209"></a><span id="l34.209" class="difflineplus">+}</span>
<a href="#l34.210"></a><span id="l34.210" class="difflineplus">+</span>
<a href="#l34.211"></a><span id="l34.211" class="difflineplus">+MimeMessage.prototype = {</span>
<a href="#l34.212"></a><span id="l34.212" class="difflineplus">+  /**</span>
<a href="#l34.213"></a><span id="l34.213" class="difflineplus">+   * Look-up a header that should be present at most once.</span>
<a href="#l34.214"></a><span id="l34.214" class="difflineplus">+   *</span>
<a href="#l34.215"></a><span id="l34.215" class="difflineplus">+   * @param aHeaderName The header name to retrieve, case does not matter.</span>
<a href="#l34.216"></a><span id="l34.216" class="difflineplus">+   * @param aDefaultValue The value to return if the header was not found, null</span>
<a href="#l34.217"></a><span id="l34.217" class="difflineplus">+   *     if left unspecified.</span>
<a href="#l34.218"></a><span id="l34.218" class="difflineplus">+   * @return the value of the header if present, and the default value if not</span>
<a href="#l34.219"></a><span id="l34.219" class="difflineplus">+   *  (defaults to null).  If the header was present multiple times, the first</span>
<a href="#l34.220"></a><span id="l34.220" class="difflineplus">+   *  instance of the header is returned.  Use getAll if you want all of the</span>
<a href="#l34.221"></a><span id="l34.221" class="difflineplus">+   *  values for the multiply-defined header.</span>
<a href="#l34.222"></a><span id="l34.222" class="difflineplus">+   */</span>
<a href="#l34.223"></a><span id="l34.223" class="difflineplus">+  get: function MimeMessage_get(aHeaderName, aDefaultValue) {</span>
<a href="#l34.224"></a><span id="l34.224" class="difflineplus">+    if (aDefaultValue === undefined) {</span>
<a href="#l34.225"></a><span id="l34.225" class="difflineplus">+      aDefaultValue = null;</span>
<a href="#l34.226"></a><span id="l34.226" class="difflineplus">+    }</span>
<a href="#l34.227"></a><span id="l34.227" class="difflineplus">+    let lowerHeader = aHeaderName.toLowerCase();</span>
<a href="#l34.228"></a><span id="l34.228" class="difflineplus">+    if (lowerHeader in this.headers)</span>
<a href="#l34.229"></a><span id="l34.229" class="difflineplus">+      // we require that the list cannot be empty if present</span>
<a href="#l34.230"></a><span id="l34.230" class="difflineplus">+      return this.headers[lowerHeader][0];</span>
<a href="#l34.231"></a><span id="l34.231" class="difflineplus">+    else</span>
<a href="#l34.232"></a><span id="l34.232" class="difflineplus">+      return aDefaultValue;</span>
<a href="#l34.233"></a><span id="l34.233" class="difflineplus">+  },</span>
<a href="#l34.234"></a><span id="l34.234" class="difflineplus">+  /**</span>
<a href="#l34.235"></a><span id="l34.235" class="difflineplus">+   * Look-up a header that can be present multiple times.  Use get for headers</span>
<a href="#l34.236"></a><span id="l34.236" class="difflineplus">+   *  that you only expect to be present at most once.</span>
<a href="#l34.237"></a><span id="l34.237" class="difflineplus">+   *</span>
<a href="#l34.238"></a><span id="l34.238" class="difflineplus">+   * @param aHeaderName The header name to retrieve, case does not matter.</span>
<a href="#l34.239"></a><span id="l34.239" class="difflineplus">+   * @return An array containing the values observed, which may mean a zero</span>
<a href="#l34.240"></a><span id="l34.240" class="difflineplus">+   *     length array.</span>
<a href="#l34.241"></a><span id="l34.241" class="difflineplus">+   */</span>
<a href="#l34.242"></a><span id="l34.242" class="difflineplus">+  getAll: function MimeMessage_getAll(aHeaderName) {</span>
<a href="#l34.243"></a><span id="l34.243" class="difflineplus">+    let lowerHeader = aHeaderName.toLowerCase();</span>
<a href="#l34.244"></a><span id="l34.244" class="difflineplus">+    if (lowerHeader in this.headers)</span>
<a href="#l34.245"></a><span id="l34.245" class="difflineplus">+      return this.headers[lowerHeader];</span>
<a href="#l34.246"></a><span id="l34.246" class="difflineplus">+    else</span>
<a href="#l34.247"></a><span id="l34.247" class="difflineplus">+      return [];</span>
<a href="#l34.248"></a><span id="l34.248" class="difflineplus">+  },</span>
<a href="#l34.249"></a><span id="l34.249" class="difflineplus">+  /**</span>
<a href="#l34.250"></a><span id="l34.250" class="difflineplus">+   * @param aHeaderName Header name to test for its presence.</span>
<a href="#l34.251"></a><span id="l34.251" class="difflineplus">+   * @return true if the message has (at least one value for) the given header</span>
<a href="#l34.252"></a><span id="l34.252" class="difflineplus">+   *     name.</span>
<a href="#l34.253"></a><span id="l34.253" class="difflineplus">+   */</span>
<a href="#l34.254"></a><span id="l34.254" class="difflineplus">+  has: function MimeMessage_has(aHeaderName) {</span>
<a href="#l34.255"></a><span id="l34.255" class="difflineplus">+    let lowerHeader = aHeaderName.toLowerCase();</span>
<a href="#l34.256"></a><span id="l34.256" class="difflineplus">+    return lowerHeader in this.headers;</span>
<a href="#l34.257"></a><span id="l34.257" class="difflineplus">+  },</span>
<a href="#l34.258"></a><span id="l34.258" class="difflineplus">+  /**</span>
<a href="#l34.259"></a><span id="l34.259" class="difflineplus">+   * @return a list of all attachments contained in this message and all its</span>
<a href="#l34.260"></a><span id="l34.260" class="difflineplus">+   *     sub-messages.  Only MimeMessageAttachment instances will be present in</span>
<a href="#l34.261"></a><span id="l34.261" class="difflineplus">+   *     the list (no sub-messages).</span>
<a href="#l34.262"></a><span id="l34.262" class="difflineplus">+   */</span>
<a href="#l34.263"></a><span id="l34.263" class="difflineplus">+  get allAttachments() {</span>
<a href="#l34.264"></a><span id="l34.264" class="difflineplus">+    let results = []; // messages are not attachments, don't include self</span>
<a href="#l34.265"></a><span id="l34.265" class="difflineplus">+    for (let iChild = 0; iChild &lt; this.parts.length; iChild++) {</span>
<a href="#l34.266"></a><span id="l34.266" class="difflineplus">+      let child = this.parts[iChild];</span>
<a href="#l34.267"></a><span id="l34.267" class="difflineplus">+      results = results.concat(child.allAttachments);</span>
<a href="#l34.268"></a><span id="l34.268" class="difflineplus">+    }</span>
<a href="#l34.269"></a><span id="l34.269" class="difflineplus">+    return results;</span>
<a href="#l34.270"></a><span id="l34.270" class="difflineplus">+  },</span>
<a href="#l34.271"></a><span id="l34.271" class="difflineplus">+  </span>
<a href="#l34.272"></a><span id="l34.272" class="difflineplus">+  /**</span>
<a href="#l34.273"></a><span id="l34.273" class="difflineplus">+   * @return a list of all of the plaintext body parts of this message.</span>
<a href="#l34.274"></a><span id="l34.274" class="difflineplus">+   */</span>
<a href="#l34.275"></a><span id="l34.275" class="difflineplus">+  get bodyPartsPlain() {</span>
<a href="#l34.276"></a><span id="l34.276" class="difflineplus">+    return [part for each ([, part] in Iterator(this.bodyParts)) if</span>
<a href="#l34.277"></a><span id="l34.277" class="difflineplus">+            (part.contentType == &quot;text/plain&quot;)];</span>
<a href="#l34.278"></a><span id="l34.278" class="difflineplus">+  },</span>
<a href="#l34.279"></a><span id="l34.279" class="difflineplus">+  /**</span>
<a href="#l34.280"></a><span id="l34.280" class="difflineplus">+   * @return all of the plaintext body parts of this message, concatenated</span>
<a href="#l34.281"></a><span id="l34.281" class="difflineplus">+   *  together into a single string.</span>
<a href="#l34.282"></a><span id="l34.282" class="difflineplus">+   */</span>
<a href="#l34.283"></a><span id="l34.283" class="difflineplus">+  get bodyPlain() {</span>
<a href="#l34.284"></a><span id="l34.284" class="difflineplus">+    return [bodyPart.body for each</span>
<a href="#l34.285"></a><span id="l34.285" class="difflineplus">+            ([, bodyPart] in Iterator(this.bodyPartsPlain))].join(&quot;&quot;);</span>
<a href="#l34.286"></a><span id="l34.286" class="difflineplus">+  },</span>
<a href="#l34.287"></a><span id="l34.287" class="difflineplus">+  /**</span>
<a href="#l34.288"></a><span id="l34.288" class="difflineplus">+   * @return a list of all of the HTML body parts of this message.</span>
<a href="#l34.289"></a><span id="l34.289" class="difflineplus">+   */</span>
<a href="#l34.290"></a><span id="l34.290" class="difflineplus">+  get bodyPartsHTML() {</span>
<a href="#l34.291"></a><span id="l34.291" class="difflineplus">+    return [part for each ([, part] in Iterator(this.bodyParts)) if</span>
<a href="#l34.292"></a><span id="l34.292" class="difflineplus">+        (part.contentType == &quot;text/html&quot;)];</span>
<a href="#l34.293"></a><span id="l34.293" class="difflineplus">+  },</span>
<a href="#l34.294"></a><span id="l34.294" class="difflineplus">+  /**</span>
<a href="#l34.295"></a><span id="l34.295" class="difflineplus">+   * @return all of the HTML body parts of this message, concatenated together</span>
<a href="#l34.296"></a><span id="l34.296" class="difflineplus">+   *  into a single string.</span>
<a href="#l34.297"></a><span id="l34.297" class="difflineplus">+   */</span>
<a href="#l34.298"></a><span id="l34.298" class="difflineplus">+  get bodyHTML() {</span>
<a href="#l34.299"></a><span id="l34.299" class="difflineplus">+    return [bodyPart.body for each</span>
<a href="#l34.300"></a><span id="l34.300" class="difflineplus">+            ([, bodyPart] in Iterator(this.bodyPartsHTML))].join(&quot;&quot;);</span>
<a href="#l34.301"></a><span id="l34.301" class="difflineplus">+  },</span>
<a href="#l34.302"></a><span id="l34.302" class="difflineplus">+  </span>
<a href="#l34.303"></a><span id="l34.303" class="difflineplus">+  /**</span>
<a href="#l34.304"></a><span id="l34.304" class="difflineplus">+   * Convert the message and its hierarchy into a &quot;pretty string&quot;.  The message</span>
<a href="#l34.305"></a><span id="l34.305" class="difflineplus">+   *  and each MIME part get their own line.  The string never ends with a</span>
<a href="#l34.306"></a><span id="l34.306" class="difflineplus">+   *  newline.  For a non-multi-part message, only a single line will be</span>
<a href="#l34.307"></a><span id="l34.307" class="difflineplus">+   *  returned.</span>
<a href="#l34.308"></a><span id="l34.308" class="difflineplus">+   * Messages have their subject displayed, attachments have their filename and</span>
<a href="#l34.309"></a><span id="l34.309" class="difflineplus">+   *  content-type (ex: image/jpeg) displayed.  &quot;Filler&quot; classes simply have</span>
<a href="#l34.310"></a><span id="l34.310" class="difflineplus">+   *  their class displayed.</span>
<a href="#l34.311"></a><span id="l34.311" class="difflineplus">+   */</span>
<a href="#l34.312"></a><span id="l34.312" class="difflineplus">+  prettyString: function MimeMessage_prettyString(aIndent) {</span>
<a href="#l34.313"></a><span id="l34.313" class="difflineplus">+    if (aIndent === undefined)</span>
<a href="#l34.314"></a><span id="l34.314" class="difflineplus">+      aIndent = &quot;&quot;; </span>
<a href="#l34.315"></a><span id="l34.315" class="difflineplus">+    let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l34.316"></a><span id="l34.316" class="difflineplus">+  </span>
<a href="#l34.317"></a><span id="l34.317" class="difflineplus">+    let s = &quot;Message: &quot; + this.headers.subject;</span>
<a href="#l34.318"></a><span id="l34.318" class="difflineplus">+    </span>
<a href="#l34.319"></a><span id="l34.319" class="difflineplus">+    for (let iPart = 0; iPart &lt; this.parts.length; iPart++) {</span>
<a href="#l34.320"></a><span id="l34.320" class="difflineplus">+      let part = this.parts[iPart];</span>
<a href="#l34.321"></a><span id="l34.321" class="difflineplus">+      s += &quot;\n&quot; + nextIndent + (iPart+1) + &quot; &quot; + part.prettyString(nextIndent);</span>
<a href="#l34.322"></a><span id="l34.322" class="difflineplus">+    }</span>
<a href="#l34.323"></a><span id="l34.323" class="difflineplus">+    </span>
<a href="#l34.324"></a><span id="l34.324" class="difflineplus">+    return s;</span>
<a href="#l34.325"></a><span id="l34.325" class="difflineplus">+  },</span>
<a href="#l34.326"></a><span id="l34.326" class="difflineplus">+};</span>
<a href="#l34.327"></a><span id="l34.327" class="difflineplus">+</span>
<a href="#l34.328"></a><span id="l34.328" class="difflineplus">+/**</span>
<a href="#l34.329"></a><span id="l34.329" class="difflineplus">+ * @ivar contentType The content-type of this container.</span>
<a href="#l34.330"></a><span id="l34.330" class="difflineplus">+ * @ivar parts The parts held by this container.  These can be instances of any</span>
<a href="#l34.331"></a><span id="l34.331" class="difflineplus">+ *      of the classes found in this file.</span>
<a href="#l34.332"></a><span id="l34.332" class="difflineplus">+ */</span>
<a href="#l34.333"></a><span id="l34.333" class="difflineplus">+function MimeContainer(aContentType) {</span>
<a href="#l34.334"></a><span id="l34.334" class="difflineplus">+  this.partName = null;</span>
<a href="#l34.335"></a><span id="l34.335" class="difflineplus">+  this.contentType = aContentType;</span>
<a href="#l34.336"></a><span id="l34.336" class="difflineplus">+  this.parts = [];</span>
<a href="#l34.337"></a><span id="l34.337" class="difflineplus">+}</span>
<a href="#l34.338"></a><span id="l34.338" class="difflineplus">+</span>
<a href="#l34.339"></a><span id="l34.339" class="difflineplus">+MimeContainer.prototype = {</span>
<a href="#l34.340"></a><span id="l34.340" class="difflineplus">+  get allAttachments() {</span>
<a href="#l34.341"></a><span id="l34.341" class="difflineplus">+    let results = [];</span>
<a href="#l34.342"></a><span id="l34.342" class="difflineplus">+    for (let iChild = 0; iChild &lt; this.parts.length; iChild++) {</span>
<a href="#l34.343"></a><span id="l34.343" class="difflineplus">+      let child = this.parts[iChild];</span>
<a href="#l34.344"></a><span id="l34.344" class="difflineplus">+      results = results.concat(child.allAttachments);</span>
<a href="#l34.345"></a><span id="l34.345" class="difflineplus">+    }</span>
<a href="#l34.346"></a><span id="l34.346" class="difflineplus">+    return results;</span>
<a href="#l34.347"></a><span id="l34.347" class="difflineplus">+  },</span>
<a href="#l34.348"></a><span id="l34.348" class="difflineplus">+  prettyString: function MimeContainer_prettyString(aIndent) {</span>
<a href="#l34.349"></a><span id="l34.349" class="difflineplus">+    let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l34.350"></a><span id="l34.350" class="difflineplus">+  </span>
<a href="#l34.351"></a><span id="l34.351" class="difflineplus">+    let s = &quot;Container: &quot; + this.contentType;</span>
<a href="#l34.352"></a><span id="l34.352" class="difflineplus">+    </span>
<a href="#l34.353"></a><span id="l34.353" class="difflineplus">+    for (let iPart = 0; iPart &lt; this.parts.length; iPart++) {</span>
<a href="#l34.354"></a><span id="l34.354" class="difflineplus">+      let part = this.parts[iPart];</span>
<a href="#l34.355"></a><span id="l34.355" class="difflineplus">+      s += &quot;\n&quot; + nextIndent + (iPart+1) + &quot; &quot; + part.prettyString(nextIndent);</span>
<a href="#l34.356"></a><span id="l34.356" class="difflineplus">+    }</span>
<a href="#l34.357"></a><span id="l34.357" class="difflineplus">+    </span>
<a href="#l34.358"></a><span id="l34.358" class="difflineplus">+    return s;</span>
<a href="#l34.359"></a><span id="l34.359" class="difflineplus">+  },</span>
<a href="#l34.360"></a><span id="l34.360" class="difflineplus">+  toString: function MimeContainer_toString() {</span>
<a href="#l34.361"></a><span id="l34.361" class="difflineplus">+    return &quot;Container: &quot; + this.contentType;</span>
<a href="#l34.362"></a><span id="l34.362" class="difflineplus">+  }</span>
<a href="#l34.363"></a><span id="l34.363" class="difflineplus">+}</span>
<a href="#l34.364"></a><span id="l34.364" class="difflineplus">+</span>
<a href="#l34.365"></a><span id="l34.365" class="difflineplus">+/**</span>
<a href="#l34.366"></a><span id="l34.366" class="difflineplus">+ * @class Represents a body portion that we understand and do not believe to be</span>
<a href="#l34.367"></a><span id="l34.367" class="difflineplus">+ *  a proper attachment.  This means text/plain or text/html and it has no</span>
<a href="#l34.368"></a><span id="l34.368" class="difflineplus">+ *  filename.  (A filename suggests an attachment.)</span>
<a href="#l34.369"></a><span id="l34.369" class="difflineplus">+ *  </span>
<a href="#l34.370"></a><span id="l34.370" class="difflineplus">+ * @ivar contentType The content type of this body materal; text/plain or</span>
<a href="#l34.371"></a><span id="l34.371" class="difflineplus">+ *     text/html.</span>
<a href="#l34.372"></a><span id="l34.372" class="difflineplus">+ * @ivar body The actual body content.</span>
<a href="#l34.373"></a><span id="l34.373" class="difflineplus">+ */</span>
<a href="#l34.374"></a><span id="l34.374" class="difflineplus">+function MimeBody(aContentType, aIsPart) {</span>
<a href="#l34.375"></a><span id="l34.375" class="difflineplus">+  this.partName = null;</span>
<a href="#l34.376"></a><span id="l34.376" class="difflineplus">+  this.contentType = aContentType;</span>
<a href="#l34.377"></a><span id="l34.377" class="difflineplus">+  this.isPart = aIsPart;</span>
<a href="#l34.378"></a><span id="l34.378" class="difflineplus">+  this.body = &quot;&quot;;</span>
<a href="#l34.379"></a><span id="l34.379" class="difflineplus">+}</span>
<a href="#l34.380"></a><span id="l34.380" class="difflineplus">+</span>
<a href="#l34.381"></a><span id="l34.381" class="difflineplus">+MimeBody.prototype = {</span>
<a href="#l34.382"></a><span id="l34.382" class="difflineplus">+  get allAttachments() {</span>
<a href="#l34.383"></a><span id="l34.383" class="difflineplus">+    return []; // we are a leaf</span>
<a href="#l34.384"></a><span id="l34.384" class="difflineplus">+  },</span>
<a href="#l34.385"></a><span id="l34.385" class="difflineplus">+  prettyString: function MimeBody_prettyString(aIndent) {</span>
<a href="#l34.386"></a><span id="l34.386" class="difflineplus">+    return &quot;Body: &quot; + this.contentType + &quot; (&quot; + this.body.length + &quot; bytes)&quot;;</span>
<a href="#l34.387"></a><span id="l34.387" class="difflineplus">+  },</span>
<a href="#l34.388"></a><span id="l34.388" class="difflineplus">+  toString: function MimeBody_toString() {</span>
<a href="#l34.389"></a><span id="l34.389" class="difflineplus">+    return &quot;Body: &quot; + this.contentType + &quot; (&quot; + this.body.length + &quot; bytes)&quot;;</span>
<a href="#l34.390"></a><span id="l34.390" class="difflineplus">+  }</span>
<a href="#l34.391"></a><span id="l34.391" class="difflineplus">+}</span>
<a href="#l34.392"></a><span id="l34.392" class="difflineplus">+</span>
<a href="#l34.393"></a><span id="l34.393" class="difflineplus">+/**</span>
<a href="#l34.394"></a><span id="l34.394" class="difflineplus">+ * @class A MIME Leaf node that doesn't have a filename so we assume it's not</span>
<a href="#l34.395"></a><span id="l34.395" class="difflineplus">+ *  intended to be an attachment proper.  This is probably meant for inline</span>
<a href="#l34.396"></a><span id="l34.396" class="difflineplus">+ *  display or is the result of someone amusing themselves by composing messages</span>
<a href="#l34.397"></a><span id="l34.397" class="difflineplus">+ *  by hand or a bad client.  This class should probably be renamed or we should</span>
<a href="#l34.398"></a><span id="l34.398" class="difflineplus">+ *  introduce a better named class that we try and use in preference to this</span>
<a href="#l34.399"></a><span id="l34.399" class="difflineplus">+ *  class.</span>
<a href="#l34.400"></a><span id="l34.400" class="difflineplus">+ * </span>
<a href="#l34.401"></a><span id="l34.401" class="difflineplus">+ * @ivar contentType The content type of this part.</span>
<a href="#l34.402"></a><span id="l34.402" class="difflineplus">+ */</span>
<a href="#l34.403"></a><span id="l34.403" class="difflineplus">+function MimeUnknown(aContentType, aIsPart) {</span>
<a href="#l34.404"></a><span id="l34.404" class="difflineplus">+  this.partName = null;</span>
<a href="#l34.405"></a><span id="l34.405" class="difflineplus">+  this.contentType = aContentType;</span>
<a href="#l34.406"></a><span id="l34.406" class="difflineplus">+  this.isPart = aIsPart;</span>
<a href="#l34.407"></a><span id="l34.407" class="difflineplus">+}</span>
<a href="#l34.408"></a><span id="l34.408" class="difflineplus">+</span>
<a href="#l34.409"></a><span id="l34.409" class="difflineplus">+MimeUnknown.prototype = {</span>
<a href="#l34.410"></a><span id="l34.410" class="difflineplus">+  get allAttachments() {</span>
<a href="#l34.411"></a><span id="l34.411" class="difflineplus">+    return []; // we are a leaf</span>
<a href="#l34.412"></a><span id="l34.412" class="difflineplus">+  },</span>
<a href="#l34.413"></a><span id="l34.413" class="difflineplus">+  prettyString: function MimeUnknown_prettyString(aIndent) {</span>
<a href="#l34.414"></a><span id="l34.414" class="difflineplus">+    return &quot;Unknown: &quot; + this.contentType;</span>
<a href="#l34.415"></a><span id="l34.415" class="difflineplus">+  },</span>
<a href="#l34.416"></a><span id="l34.416" class="difflineplus">+  toString: function MimeUnknown_toString() {</span>
<a href="#l34.417"></a><span id="l34.417" class="difflineplus">+    return &quot;Unknown: &quot; + this.contentType;</span>
<a href="#l34.418"></a><span id="l34.418" class="difflineplus">+  }</span>
<a href="#l34.419"></a><span id="l34.419" class="difflineplus">+}</span>
<a href="#l34.420"></a><span id="l34.420" class="difflineplus">+</span>
<a href="#l34.421"></a><span id="l34.421" class="difflineplus">+/**</span>
<a href="#l34.422"></a><span id="l34.422" class="difflineplus">+ * @class An attachment proper.  We think it's an attachment because it has a</span>
<a href="#l34.423"></a><span id="l34.423" class="difflineplus">+ *  filename that libmime was able to figure out.</span>
<a href="#l34.424"></a><span id="l34.424" class="difflineplus">+ * </span>
<a href="#l34.425"></a><span id="l34.425" class="difflineplus">+ * @ivar contentType The MIME content type of this part.</span>
<a href="#l34.426"></a><span id="l34.426" class="difflineplus">+ * @ivar The filename of this attachment.</span>
<a href="#l34.427"></a><span id="l34.427" class="difflineplus">+ * @ivar The URL to stream if you want the contents of this part.</span>
<a href="#l34.428"></a><span id="l34.428" class="difflineplus">+ */</span>
<a href="#l34.429"></a><span id="l34.429" class="difflineplus">+function MimeMessageAttachment(aPartName, aName, aContentType, aUrl,</span>
<a href="#l34.430"></a><span id="l34.430" class="difflineplus">+                               aIsExternal) {</span>
<a href="#l34.431"></a><span id="l34.431" class="difflineplus">+  this.partName = aPartName;</span>
<a href="#l34.432"></a><span id="l34.432" class="difflineplus">+  this.name = aName;</span>
<a href="#l34.433"></a><span id="l34.433" class="difflineplus">+  this.contentType = aContentType;</span>
<a href="#l34.434"></a><span id="l34.434" class="difflineplus">+  this.url = aUrl;</span>
<a href="#l34.435"></a><span id="l34.435" class="difflineplus">+  this.isExternal = aIsExternal;</span>
<a href="#l34.436"></a><span id="l34.436" class="difflineplus">+  </span>
<a href="#l34.437"></a><span id="l34.437" class="difflineplus">+  this.fields = {};</span>
<a href="#l34.438"></a><span id="l34.438" class="difflineplus">+}</span>
<a href="#l34.439"></a><span id="l34.439" class="difflineplus">+</span>
<a href="#l34.440"></a><span id="l34.440" class="difflineplus">+MimeMessageAttachment.prototype = {</span>
<a href="#l34.441"></a><span id="l34.441" class="difflineplus">+  /**</span>
<a href="#l34.442"></a><span id="l34.442" class="difflineplus">+   * Is this an actual attachment, as far as we can tell?  An example of</span>
<a href="#l34.443"></a><span id="l34.443" class="difflineplus">+   *  something that's not a real attachment is a mailing list footer that</span>
<a href="#l34.444"></a><span id="l34.444" class="difflineplus">+   *  gets its own MIME part because the original message had both HTML and text</span>
<a href="#l34.445"></a><span id="l34.445" class="difflineplus">+   *  as alternatives.</span>
<a href="#l34.446"></a><span id="l34.446" class="difflineplus">+   * Our super-advanced heuristic is to check whether the attachment name is</span>
<a href="#l34.447"></a><span id="l34.447" class="difflineplus">+   *  the same as the part name.</span>
<a href="#l34.448"></a><span id="l34.448" class="difflineplus">+   */</span>
<a href="#l34.449"></a><span id="l34.449" class="difflineplus">+  get isRealAttachment() {</span>
<a href="#l34.450"></a><span id="l34.450" class="difflineplus">+    return this.name != &quot;Part &quot; + this.partName;</span>
<a href="#l34.451"></a><span id="l34.451" class="difflineplus">+  },</span>
<a href="#l34.452"></a><span id="l34.452" class="difflineplus">+  get allAttachments() {</span>
<a href="#l34.453"></a><span id="l34.453" class="difflineplus">+    return [this]; // we are a leaf, so just us.</span>
<a href="#l34.454"></a><span id="l34.454" class="difflineplus">+  },</span>
<a href="#l34.455"></a><span id="l34.455" class="difflineplus">+  prettyString: function MimeMessageAttachment_prettyString(aIndent) {</span>
<a href="#l34.456"></a><span id="l34.456" class="difflineplus">+    return &quot;Attachment: &quot; + this.name + &quot;, &quot; + this.contentType;</span>
<a href="#l34.457"></a><span id="l34.457" class="difflineplus">+  },</span>
<a href="#l34.458"></a><span id="l34.458" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1">new file mode 100644</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineminus">--- /dev/null</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_freetag.js</span>
<a href="#l35.4"></a><span id="l35.4" class="difflineat">@@ -0,0 +1,113 @@</span>
<a href="#l35.5"></a><span id="l35.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l35.6"></a><span id="l35.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l35.7"></a><span id="l35.7" class="difflineplus">+ *</span>
<a href="#l35.8"></a><span id="l35.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l35.9"></a><span id="l35.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l35.10"></a><span id="l35.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l35.11"></a><span id="l35.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineplus">+ * </span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l35.14"></a><span id="l35.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l35.15"></a><span id="l35.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l35.16"></a><span id="l35.16" class="difflineplus">+ * License.</span>
<a href="#l35.17"></a><span id="l35.17" class="difflineplus">+ *</span>
<a href="#l35.18"></a><span id="l35.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l35.19"></a><span id="l35.19" class="difflineplus">+ *</span>
<a href="#l35.20"></a><span id="l35.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l35.21"></a><span id="l35.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l35.22"></a><span id="l35.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l35.23"></a><span id="l35.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l35.24"></a><span id="l35.24" class="difflineplus">+ *</span>
<a href="#l35.25"></a><span id="l35.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l35.26"></a><span id="l35.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l35.27"></a><span id="l35.27" class="difflineplus">+ *</span>
<a href="#l35.28"></a><span id="l35.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l35.29"></a><span id="l35.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l35.30"></a><span id="l35.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l35.31"></a><span id="l35.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l35.32"></a><span id="l35.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l35.33"></a><span id="l35.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l35.34"></a><span id="l35.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l35.35"></a><span id="l35.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l35.36"></a><span id="l35.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l35.37"></a><span id="l35.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l35.38"></a><span id="l35.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l35.39"></a><span id="l35.39" class="difflineplus">+ * </span>
<a href="#l35.40"></a><span id="l35.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l35.41"></a><span id="l35.41" class="difflineplus">+</span>
<a href="#l35.42"></a><span id="l35.42" class="difflineplus">+EXPORTED_SYMBOLS = ['FreeTag', 'FreeTagNoun'];</span>
<a href="#l35.43"></a><span id="l35.43" class="difflineplus">+</span>
<a href="#l35.44"></a><span id="l35.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l35.45"></a><span id="l35.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l35.46"></a><span id="l35.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l35.47"></a><span id="l35.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l35.48"></a><span id="l35.48" class="difflineplus">+</span>
<a href="#l35.49"></a><span id="l35.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l35.50"></a><span id="l35.50" class="difflineplus">+</span>
<a href="#l35.51"></a><span id="l35.51" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l35.52"></a><span id="l35.52" class="difflineplus">+</span>
<a href="#l35.53"></a><span id="l35.53" class="difflineplus">+function FreeTag(aTagName) {</span>
<a href="#l35.54"></a><span id="l35.54" class="difflineplus">+  this.name = aTagName;</span>
<a href="#l35.55"></a><span id="l35.55" class="difflineplus">+}</span>
<a href="#l35.56"></a><span id="l35.56" class="difflineplus">+</span>
<a href="#l35.57"></a><span id="l35.57" class="difflineplus">+FreeTag.prototype = {</span>
<a href="#l35.58"></a><span id="l35.58" class="difflineplus">+  toString: function () {</span>
<a href="#l35.59"></a><span id="l35.59" class="difflineplus">+    return this.name;</span>
<a href="#l35.60"></a><span id="l35.60" class="difflineplus">+  }</span>
<a href="#l35.61"></a><span id="l35.61" class="difflineplus">+};</span>
<a href="#l35.62"></a><span id="l35.62" class="difflineplus">+</span>
<a href="#l35.63"></a><span id="l35.63" class="difflineplus">+/**</span>
<a href="#l35.64"></a><span id="l35.64" class="difflineplus">+ * @namespace Tag noun provider.  Since the tag unique value is stored as a</span>
<a href="#l35.65"></a><span id="l35.65" class="difflineplus">+ *  parameter, we are an odd case and semantically confused.</span>
<a href="#l35.66"></a><span id="l35.66" class="difflineplus">+ */</span>
<a href="#l35.67"></a><span id="l35.67" class="difflineplus">+var FreeTagNoun = {</span>
<a href="#l35.68"></a><span id="l35.68" class="difflineplus">+  _log: Log4Moz.Service.getLogger(&quot;gloda.noun.freetag&quot;),</span>
<a href="#l35.69"></a><span id="l35.69" class="difflineplus">+</span>
<a href="#l35.70"></a><span id="l35.70" class="difflineplus">+  name: &quot;freetag&quot;,</span>
<a href="#l35.71"></a><span id="l35.71" class="difflineplus">+  class: FreeTag,</span>
<a href="#l35.72"></a><span id="l35.72" class="difflineplus">+  allowsArbitraryAttrs: false,</span>
<a href="#l35.73"></a><span id="l35.73" class="difflineplus">+  usesParameter: true,</span>
<a href="#l35.74"></a><span id="l35.74" class="difflineplus">+  </span>
<a href="#l35.75"></a><span id="l35.75" class="difflineplus">+  _listeners: [],</span>
<a href="#l35.76"></a><span id="l35.76" class="difflineplus">+  addListener: function(aListener) {</span>
<a href="#l35.77"></a><span id="l35.77" class="difflineplus">+    this._listeners.push(aListener);</span>
<a href="#l35.78"></a><span id="l35.78" class="difflineplus">+  },</span>
<a href="#l35.79"></a><span id="l35.79" class="difflineplus">+  removeListener: function(aListener) {</span>
<a href="#l35.80"></a><span id="l35.80" class="difflineplus">+    let index = this._listeners.indexOf(aListener);</span>
<a href="#l35.81"></a><span id="l35.81" class="difflineplus">+    if (index &gt;=0)</span>
<a href="#l35.82"></a><span id="l35.82" class="difflineplus">+      this._listeners.splice(index, 1);</span>
<a href="#l35.83"></a><span id="l35.83" class="difflineplus">+  },</span>
<a href="#l35.84"></a><span id="l35.84" class="difflineplus">+  </span>
<a href="#l35.85"></a><span id="l35.85" class="difflineplus">+  populateKnownFreeTags: function() {</span>
<a href="#l35.86"></a><span id="l35.86" class="difflineplus">+    for each (let [,attr] in Iterator(this.objectNounOfAttributes)) {</span>
<a href="#l35.87"></a><span id="l35.87" class="difflineplus">+      let attrDB = attr.dbDef;</span>
<a href="#l35.88"></a><span id="l35.88" class="difflineplus">+      for (let param in attrDB.parameterBindings) {</span>
<a href="#l35.89"></a><span id="l35.89" class="difflineplus">+        this.getFreeTag(param);</span>
<a href="#l35.90"></a><span id="l35.90" class="difflineplus">+      }</span>
<a href="#l35.91"></a><span id="l35.91" class="difflineplus">+    }</span>
<a href="#l35.92"></a><span id="l35.92" class="difflineplus">+  },</span>
<a href="#l35.93"></a><span id="l35.93" class="difflineplus">+  </span>
<a href="#l35.94"></a><span id="l35.94" class="difflineplus">+  knownFreeTags: {},</span>
<a href="#l35.95"></a><span id="l35.95" class="difflineplus">+  getFreeTag: function(aTagName) {</span>
<a href="#l35.96"></a><span id="l35.96" class="difflineplus">+    let tag = this.knownFreeTags[aTagName];</span>
<a href="#l35.97"></a><span id="l35.97" class="difflineplus">+    if (!tag) {</span>
<a href="#l35.98"></a><span id="l35.98" class="difflineplus">+      tag = this.knownFreeTags[aTagName] = new FreeTag(aTagName);</span>
<a href="#l35.99"></a><span id="l35.99" class="difflineplus">+      for each (let [iListener, listener] in Iterator(this._listeners))</span>
<a href="#l35.100"></a><span id="l35.100" class="difflineplus">+        listener.onFreeTagAdded(tag);</span>
<a href="#l35.101"></a><span id="l35.101" class="difflineplus">+    }</span>
<a href="#l35.102"></a><span id="l35.102" class="difflineplus">+    return tag;</span>
<a href="#l35.103"></a><span id="l35.103" class="difflineplus">+  },</span>
<a href="#l35.104"></a><span id="l35.104" class="difflineplus">+</span>
<a href="#l35.105"></a><span id="l35.105" class="difflineplus">+  toParamAndValue: function gloda_noun_freetag_toParamAndValue(aTag) {</span>
<a href="#l35.106"></a><span id="l35.106" class="difflineplus">+    return [aTag.name, null];</span>
<a href="#l35.107"></a><span id="l35.107" class="difflineplus">+  },</span>
<a href="#l35.108"></a><span id="l35.108" class="difflineplus">+  </span>
<a href="#l35.109"></a><span id="l35.109" class="difflineplus">+  toJSON: function gloda_noun_freetag_toJSON(aTag) {</span>
<a href="#l35.110"></a><span id="l35.110" class="difflineplus">+    return aTag.name;</span>
<a href="#l35.111"></a><span id="l35.111" class="difflineplus">+  },</span>
<a href="#l35.112"></a><span id="l35.112" class="difflineplus">+  fromJSON: function gloda_noun_freetag_fromJSON(aTagName) {</span>
<a href="#l35.113"></a><span id="l35.113" class="difflineplus">+    return this.getFreeTag(aTagName);</span>
<a href="#l35.114"></a><span id="l35.114" class="difflineplus">+  },</span>
<a href="#l35.115"></a><span id="l35.115" class="difflineplus">+};</span>
<a href="#l35.116"></a><span id="l35.116" class="difflineplus">+</span>
<a href="#l35.117"></a><span id="l35.117" class="difflineplus">+Gloda.defineNoun(FreeTagNoun);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1">new file mode 100644</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineminus">--- /dev/null</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_mimetype.js</span>
<a href="#l36.4"></a><span id="l36.4" class="difflineat">@@ -0,0 +1,175 @@</span>
<a href="#l36.5"></a><span id="l36.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l36.6"></a><span id="l36.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l36.7"></a><span id="l36.7" class="difflineplus">+ *</span>
<a href="#l36.8"></a><span id="l36.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l36.9"></a><span id="l36.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l36.10"></a><span id="l36.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l36.11"></a><span id="l36.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineplus">+ * </span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l36.14"></a><span id="l36.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l36.15"></a><span id="l36.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l36.16"></a><span id="l36.16" class="difflineplus">+ * License.</span>
<a href="#l36.17"></a><span id="l36.17" class="difflineplus">+ *</span>
<a href="#l36.18"></a><span id="l36.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l36.19"></a><span id="l36.19" class="difflineplus">+ *</span>
<a href="#l36.20"></a><span id="l36.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l36.21"></a><span id="l36.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l36.22"></a><span id="l36.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l36.23"></a><span id="l36.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l36.24"></a><span id="l36.24" class="difflineplus">+ *</span>
<a href="#l36.25"></a><span id="l36.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l36.26"></a><span id="l36.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l36.27"></a><span id="l36.27" class="difflineplus">+ *</span>
<a href="#l36.28"></a><span id="l36.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l36.29"></a><span id="l36.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l36.30"></a><span id="l36.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l36.31"></a><span id="l36.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l36.32"></a><span id="l36.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l36.33"></a><span id="l36.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l36.34"></a><span id="l36.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l36.35"></a><span id="l36.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l36.36"></a><span id="l36.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l36.37"></a><span id="l36.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l36.38"></a><span id="l36.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l36.39"></a><span id="l36.39" class="difflineplus">+ * </span>
<a href="#l36.40"></a><span id="l36.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l36.41"></a><span id="l36.41" class="difflineplus">+</span>
<a href="#l36.42"></a><span id="l36.42" class="difflineplus">+EXPORTED_SYMBOLS = ['MimeType', 'MimeTypeNoun'];</span>
<a href="#l36.43"></a><span id="l36.43" class="difflineplus">+</span>
<a href="#l36.44"></a><span id="l36.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l36.45"></a><span id="l36.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l36.46"></a><span id="l36.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l36.47"></a><span id="l36.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l36.48"></a><span id="l36.48" class="difflineplus">+</span>
<a href="#l36.49"></a><span id="l36.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l36.50"></a><span id="l36.50" class="difflineplus">+</span>
<a href="#l36.51"></a><span id="l36.51" class="difflineplus">+const LOG = Log4Moz.Service.getLogger(&quot;gloda.noun.mimetype&quot;);</span>
<a href="#l36.52"></a><span id="l36.52" class="difflineplus">+</span>
<a href="#l36.53"></a><span id="l36.53" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l36.54"></a><span id="l36.54" class="difflineplus">+</span>
<a href="#l36.55"></a><span id="l36.55" class="difflineplus">+function MimeType(aID, aType, aSubType, aFullType) {</span>
<a href="#l36.56"></a><span id="l36.56" class="difflineplus">+  this._id = aID;</span>
<a href="#l36.57"></a><span id="l36.57" class="difflineplus">+  this._type = aType;</span>
<a href="#l36.58"></a><span id="l36.58" class="difflineplus">+  this._subType = aSubType;</span>
<a href="#l36.59"></a><span id="l36.59" class="difflineplus">+  this._fullType = aFullType;</span>
<a href="#l36.60"></a><span id="l36.60" class="difflineplus">+}</span>
<a href="#l36.61"></a><span id="l36.61" class="difflineplus">+</span>
<a href="#l36.62"></a><span id="l36.62" class="difflineplus">+MimeType.prototype = {</span>
<a href="#l36.63"></a><span id="l36.63" class="difflineplus">+  get id() { return this._id; },</span>
<a href="#l36.64"></a><span id="l36.64" class="difflineplus">+  get type() { return this._type; },</span>
<a href="#l36.65"></a><span id="l36.65" class="difflineplus">+  get subType() { return this._subType; },</span>
<a href="#l36.66"></a><span id="l36.66" class="difflineplus">+  get fullType() { return this._fullType; },</span>
<a href="#l36.67"></a><span id="l36.67" class="difflineplus">+  toString: function () {</span>
<a href="#l36.68"></a><span id="l36.68" class="difflineplus">+    return this.fullType;</span>
<a href="#l36.69"></a><span id="l36.69" class="difflineplus">+  }</span>
<a href="#l36.70"></a><span id="l36.70" class="difflineplus">+};</span>
<a href="#l36.71"></a><span id="l36.71" class="difflineplus">+</span>
<a href="#l36.72"></a><span id="l36.72" class="difflineplus">+/**</span>
<a href="#l36.73"></a><span id="l36.73" class="difflineplus">+ * @namespace Mime type noun provider.  Uses datastore mechanisms to define its</span>
<a href="#l36.74"></a><span id="l36.74" class="difflineplus">+ *  table.</span>
<a href="#l36.75"></a><span id="l36.75" class="difflineplus">+ * </span>
<a href="#l36.76"></a><span id="l36.76" class="difflineplus">+ * The set of MIME Types is sufficiently limited that we can keep them all in</span>
<a href="#l36.77"></a><span id="l36.77" class="difflineplus">+ *  memory.  In theory it is also sufficiently limited that we could use the</span>
<a href="#l36.78"></a><span id="l36.78" class="difflineplus">+ *  parameter mechanism in the database.  However, it is more efficient, for</span>
<a href="#l36.79"></a><span id="l36.79" class="difflineplus">+ *  both space and performance reasons, to store the specific mime type as a</span>
<a href="#l36.80"></a><span id="l36.80" class="difflineplus">+ *  value.  For future-proofing reasons, we opt use a database table to</span>
<a href="#l36.81"></a><span id="l36.81" class="difflineplus">+ *  persist the mapping rather than a hard-coded list.  A preferences file or</span>
<a href="#l36.82"></a><span id="l36.82" class="difflineplus">+ *  other text file would arguably suffice, but for consistency reasons, the</span>
<a href="#l36.83"></a><span id="l36.83" class="difflineplus">+ *  database is not a bad thing.</span>
<a href="#l36.84"></a><span id="l36.84" class="difflineplus">+ */</span>
<a href="#l36.85"></a><span id="l36.85" class="difflineplus">+var MimeTypeNoun = {</span>
<a href="#l36.86"></a><span id="l36.86" class="difflineplus">+  name: &quot;mime-type&quot;,</span>
<a href="#l36.87"></a><span id="l36.87" class="difflineplus">+  class: MimeType,</span>
<a href="#l36.88"></a><span id="l36.88" class="difflineplus">+  allowsArbitraryAttrs: false,</span>
<a href="#l36.89"></a><span id="l36.89" class="difflineplus">+  </span>
<a href="#l36.90"></a><span id="l36.90" class="difflineplus">+  _mimeTypes: {},</span>
<a href="#l36.91"></a><span id="l36.91" class="difflineplus">+  _mimeTypesByID: {},</span>
<a href="#l36.92"></a><span id="l36.92" class="difflineplus">+  TYPE_BLOCK_SIZE: 8096,</span>
<a href="#l36.93"></a><span id="l36.93" class="difflineplus">+  _mimeTypeHighID: {},</span>
<a href="#l36.94"></a><span id="l36.94" class="difflineplus">+  _highID: 0,</span>
<a href="#l36.95"></a><span id="l36.95" class="difflineplus">+  </span>
<a href="#l36.96"></a><span id="l36.96" class="difflineplus">+  _init: function() {</span>
<a href="#l36.97"></a><span id="l36.97" class="difflineplus">+    LOG.debug(&quot;initializing table definition&quot;);</span>
<a href="#l36.98"></a><span id="l36.98" class="difflineplus">+    this._tableMimeTypes = Gloda.defineTable({</span>
<a href="#l36.99"></a><span id="l36.99" class="difflineplus">+      name: 'mimeTypes',</span>
<a href="#l36.100"></a><span id="l36.100" class="difflineplus">+      columns: [['id', 'INTEGER PRIMARY KEY'],</span>
<a href="#l36.101"></a><span id="l36.101" class="difflineplus">+                ['mimeType', 'TEXT']],</span>
<a href="#l36.102"></a><span id="l36.102" class="difflineplus">+    });</span>
<a href="#l36.103"></a><span id="l36.103" class="difflineplus">+    LOG.debug(&quot;loading MIME types&quot;);</span>
<a href="#l36.104"></a><span id="l36.104" class="difflineplus">+    this._loadMimeTypes();</span>
<a href="#l36.105"></a><span id="l36.105" class="difflineplus">+  },</span>
<a href="#l36.106"></a><span id="l36.106" class="difflineplus">+  </span>
<a href="#l36.107"></a><span id="l36.107" class="difflineplus">+  _loadMimeTypes: function() {</span>
<a href="#l36.108"></a><span id="l36.108" class="difflineplus">+    this._tableMimeTypes.select(null, null, this, this._processMimeTypes);</span>
<a href="#l36.109"></a><span id="l36.109" class="difflineplus">+  },</span>
<a href="#l36.110"></a><span id="l36.110" class="difflineplus">+  </span>
<a href="#l36.111"></a><span id="l36.111" class="difflineplus">+  _processMimeTypes: function(aRows, aDone) {</span>
<a href="#l36.112"></a><span id="l36.112" class="difflineplus">+    for each (let [, row] in Iterator(aRows)) {</span>
<a href="#l36.113"></a><span id="l36.113" class="difflineplus">+      if (row.id &gt; this._highID)</span>
<a href="#l36.114"></a><span id="l36.114" class="difflineplus">+        this._highID = row.id;</span>
<a href="#l36.115"></a><span id="l36.115" class="difflineplus">+      let [typeName, subTypeName] = row.mimeType.split(&quot;/&quot;);</span>
<a href="#l36.116"></a><span id="l36.116" class="difflineplus">+      let mimeType = new MimeType(row.id, typeName, subTypeName, row.mimeType);</span>
<a href="#l36.117"></a><span id="l36.117" class="difflineplus">+      this._mimeTypes[mimeType] = mimeType;</span>
<a href="#l36.118"></a><span id="l36.118" class="difflineplus">+      this._mimeTypesByID[mimeType.id] = mimeType;</span>
<a href="#l36.119"></a><span id="l36.119" class="difflineplus">+      </span>
<a href="#l36.120"></a><span id="l36.120" class="difflineplus">+      let typeBlock = mimeType.id - (mimeType.id % this.TYPE_BLOCK_SIZE);</span>
<a href="#l36.121"></a><span id="l36.121" class="difflineplus">+      let blockHighID = this._mimeTypeHighID[typeName];</span>
<a href="#l36.122"></a><span id="l36.122" class="difflineplus">+      if ((blockHighID === undefined) || mimeType.id &gt; blockHighID)</span>
<a href="#l36.123"></a><span id="l36.123" class="difflineplus">+        this._mimeTypeHighID[typeName] = mimeType.id;</span>
<a href="#l36.124"></a><span id="l36.124" class="difflineplus">+    }</span>
<a href="#l36.125"></a><span id="l36.125" class="difflineplus">+  },</span>
<a href="#l36.126"></a><span id="l36.126" class="difflineplus">+  </span>
<a href="#l36.127"></a><span id="l36.127" class="difflineplus">+  _addNewMimeType: function(aMimeTypeName) {</span>
<a href="#l36.128"></a><span id="l36.128" class="difflineplus">+    let [typeName, subTypeName] = aMimeTypeName.split(&quot;/&quot;);</span>
<a href="#l36.129"></a><span id="l36.129" class="difflineplus">+    </span>
<a href="#l36.130"></a><span id="l36.130" class="difflineplus">+    if (!(typeName in this._mimeTypeHighID)) {</span>
<a href="#l36.131"></a><span id="l36.131" class="difflineplus">+      let nextID = this._highID - (this._highID % this.TYPE_BLOCK_SIZE) +</span>
<a href="#l36.132"></a><span id="l36.132" class="difflineplus">+        this.TYPE_BLOCK_SIZE;</span>
<a href="#l36.133"></a><span id="l36.133" class="difflineplus">+      this._mimeTypeHighID[typeName] = nextID;</span>
<a href="#l36.134"></a><span id="l36.134" class="difflineplus">+    }</span>
<a href="#l36.135"></a><span id="l36.135" class="difflineplus">+    </span>
<a href="#l36.136"></a><span id="l36.136" class="difflineplus">+    let nextID = ++this._mimeTypeHighID[typeName];</span>
<a href="#l36.137"></a><span id="l36.137" class="difflineplus">+    </span>
<a href="#l36.138"></a><span id="l36.138" class="difflineplus">+    let mimeType = new MimeType(nextID, typeName, subTypeName, aMimeTypeName);</span>
<a href="#l36.139"></a><span id="l36.139" class="difflineplus">+    if (mimeType.id &gt; this._highID)</span>
<a href="#l36.140"></a><span id="l36.140" class="difflineplus">+      this._highID = mimeType.id;</span>
<a href="#l36.141"></a><span id="l36.141" class="difflineplus">+    </span>
<a href="#l36.142"></a><span id="l36.142" class="difflineplus">+    this._mimeTypes[aMimeTypeName] = mimeType;</span>
<a href="#l36.143"></a><span id="l36.143" class="difflineplus">+    this._mimeTypesByID[nextID] = mimeType;</span>
<a href="#l36.144"></a><span id="l36.144" class="difflineplus">+    </span>
<a href="#l36.145"></a><span id="l36.145" class="difflineplus">+    this._tableMimeTypes.insert([{id: nextID, mimeType: aMimeTypeName}]);</span>
<a href="#l36.146"></a><span id="l36.146" class="difflineplus">+    </span>
<a href="#l36.147"></a><span id="l36.147" class="difflineplus">+    return mimeType;</span>
<a href="#l36.148"></a><span id="l36.148" class="difflineplus">+  },</span>
<a href="#l36.149"></a><span id="l36.149" class="difflineplus">+  </span>
<a href="#l36.150"></a><span id="l36.150" class="difflineplus">+  getMimeType: function(aMimeTypeName) {</span>
<a href="#l36.151"></a><span id="l36.151" class="difflineplus">+    // first, lose any parameters</span>
<a href="#l36.152"></a><span id="l36.152" class="difflineplus">+    let semiIndex = aMimeTypeName.indexOf(&quot;;&quot;);</span>
<a href="#l36.153"></a><span id="l36.153" class="difflineplus">+    if (semiIndex &gt;= 0)</span>
<a href="#l36.154"></a><span id="l36.154" class="difflineplus">+      aMimeTypeName = aMimeTypeName.substring(semiIndex);</span>
<a href="#l36.155"></a><span id="l36.155" class="difflineplus">+    aMimeTypeName = aMimeTypeName.trim().toLowerCase();</span>
<a href="#l36.156"></a><span id="l36.156" class="difflineplus">+    </span>
<a href="#l36.157"></a><span id="l36.157" class="difflineplus">+    let mimeType = this._mimeTypes[aMimeTypeName];</span>
<a href="#l36.158"></a><span id="l36.158" class="difflineplus">+    if (mimeType)</span>
<a href="#l36.159"></a><span id="l36.159" class="difflineplus">+      return mimeType;</span>
<a href="#l36.160"></a><span id="l36.160" class="difflineplus">+    else</span>
<a href="#l36.161"></a><span id="l36.161" class="difflineplus">+      return this._addNewMimeType(aMimeTypeName);</span>
<a href="#l36.162"></a><span id="l36.162" class="difflineplus">+  },</span>
<a href="#l36.163"></a><span id="l36.163" class="difflineplus">+</span>
<a href="#l36.164"></a><span id="l36.164" class="difflineplus">+  toParamAndValue: function gloda_noun_freetag_toParamAndValue(aMimeType) {</span>
<a href="#l36.165"></a><span id="l36.165" class="difflineplus">+    return [null, aMimeType.id];</span>
<a href="#l36.166"></a><span id="l36.166" class="difflineplus">+  },</span>
<a href="#l36.167"></a><span id="l36.167" class="difflineplus">+  toJSON: function gloda_noun_freetag_toJSON(aMimeType) {</span>
<a href="#l36.168"></a><span id="l36.168" class="difflineplus">+    return aMimeType.id;</span>
<a href="#l36.169"></a><span id="l36.169" class="difflineplus">+  },</span>
<a href="#l36.170"></a><span id="l36.170" class="difflineplus">+  fromJSON: function gloda_noun_freetag_fromJSON(aMimeTypeID) {</span>
<a href="#l36.171"></a><span id="l36.171" class="difflineplus">+    return this._mimeTypesByID[aMimeTypeID];</span>
<a href="#l36.172"></a><span id="l36.172" class="difflineplus">+  },</span>
<a href="#l36.173"></a><span id="l36.173" class="difflineplus">+};</span>
<a href="#l36.174"></a><span id="l36.174" class="difflineplus">+try {</span>
<a href="#l36.175"></a><span id="l36.175" class="difflineplus">+MimeTypeNoun._init();</span>
<a href="#l36.176"></a><span id="l36.176" class="difflineplus">+} catch (ex) {</span>
<a href="#l36.177"></a><span id="l36.177" class="difflineplus">+  LOG.error(&quot;problem init-ing: &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;: &quot; + ex);</span>
<a href="#l36.178"></a><span id="l36.178" class="difflineplus">+}</span>
<a href="#l36.179"></a><span id="l36.179" class="difflineplus">+Gloda.defineNoun(MimeTypeNoun, Gloda.NOUN_MIME_TYPE);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1">new file mode 100644</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineminus">--- /dev/null</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/noun_tag.js</span>
<a href="#l37.4"></a><span id="l37.4" class="difflineat">@@ -0,0 +1,100 @@</span>
<a href="#l37.5"></a><span id="l37.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l37.6"></a><span id="l37.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l37.7"></a><span id="l37.7" class="difflineplus">+ *</span>
<a href="#l37.8"></a><span id="l37.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l37.9"></a><span id="l37.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l37.10"></a><span id="l37.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l37.11"></a><span id="l37.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l37.12"></a><span id="l37.12" class="difflineplus">+ * </span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l37.14"></a><span id="l37.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l37.15"></a><span id="l37.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l37.16"></a><span id="l37.16" class="difflineplus">+ * License.</span>
<a href="#l37.17"></a><span id="l37.17" class="difflineplus">+ *</span>
<a href="#l37.18"></a><span id="l37.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l37.19"></a><span id="l37.19" class="difflineplus">+ *</span>
<a href="#l37.20"></a><span id="l37.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l37.21"></a><span id="l37.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l37.22"></a><span id="l37.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l37.23"></a><span id="l37.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l37.24"></a><span id="l37.24" class="difflineplus">+ *</span>
<a href="#l37.25"></a><span id="l37.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l37.26"></a><span id="l37.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l37.27"></a><span id="l37.27" class="difflineplus">+ *</span>
<a href="#l37.28"></a><span id="l37.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l37.29"></a><span id="l37.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l37.30"></a><span id="l37.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l37.31"></a><span id="l37.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l37.32"></a><span id="l37.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l37.33"></a><span id="l37.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l37.34"></a><span id="l37.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l37.35"></a><span id="l37.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l37.36"></a><span id="l37.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l37.37"></a><span id="l37.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l37.38"></a><span id="l37.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l37.39"></a><span id="l37.39" class="difflineplus">+ * </span>
<a href="#l37.40"></a><span id="l37.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l37.41"></a><span id="l37.41" class="difflineplus">+</span>
<a href="#l37.42"></a><span id="l37.42" class="difflineplus">+EXPORTED_SYMBOLS = ['TagNoun'];</span>
<a href="#l37.43"></a><span id="l37.43" class="difflineplus">+</span>
<a href="#l37.44"></a><span id="l37.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l37.45"></a><span id="l37.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l37.46"></a><span id="l37.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l37.47"></a><span id="l37.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l37.48"></a><span id="l37.48" class="difflineplus">+</span>
<a href="#l37.49"></a><span id="l37.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l37.50"></a><span id="l37.50" class="difflineplus">+</span>
<a href="#l37.51"></a><span id="l37.51" class="difflineplus">+/**</span>
<a href="#l37.52"></a><span id="l37.52" class="difflineplus">+ * @namespace Tag noun provider.</span>
<a href="#l37.53"></a><span id="l37.53" class="difflineplus">+ */</span>
<a href="#l37.54"></a><span id="l37.54" class="difflineplus">+var TagNoun = {</span>
<a href="#l37.55"></a><span id="l37.55" class="difflineplus">+  name: &quot;tag&quot;,</span>
<a href="#l37.56"></a><span id="l37.56" class="difflineplus">+  class: Ci.nsIMsgTag,</span>
<a href="#l37.57"></a><span id="l37.57" class="difflineplus">+  usesParameter: true,</span>
<a href="#l37.58"></a><span id="l37.58" class="difflineplus">+  allowsArbitraryAttrs: false,</span>
<a href="#l37.59"></a><span id="l37.59" class="difflineplus">+  _msgTagService: null,</span>
<a href="#l37.60"></a><span id="l37.60" class="difflineplus">+  _tagMap: null,</span>
<a href="#l37.61"></a><span id="l37.61" class="difflineplus">+  </span>
<a href="#l37.62"></a><span id="l37.62" class="difflineplus">+  _init: function () {</span>
<a href="#l37.63"></a><span id="l37.63" class="difflineplus">+    this._msgTagService = Cc[&quot;@mozilla.org/messenger/tagservice;1&quot;].</span>
<a href="#l37.64"></a><span id="l37.64" class="difflineplus">+                          getService(Ci.nsIMsgTagService);</span>
<a href="#l37.65"></a><span id="l37.65" class="difflineplus">+    this._updateTagMap();</span>
<a href="#l37.66"></a><span id="l37.66" class="difflineplus">+  },</span>
<a href="#l37.67"></a><span id="l37.67" class="difflineplus">+  </span>
<a href="#l37.68"></a><span id="l37.68" class="difflineplus">+  getAllTags: function gloda_noun_tag_getAllTags() {</span>
<a href="#l37.69"></a><span id="l37.69" class="difflineplus">+    return this._msgTagService.getAllTags({});</span>
<a href="#l37.70"></a><span id="l37.70" class="difflineplus">+  },</span>
<a href="#l37.71"></a><span id="l37.71" class="difflineplus">+  </span>
<a href="#l37.72"></a><span id="l37.72" class="difflineplus">+  _updateTagMap: function gloda_noun_tag_updateTagMap() {</span>
<a href="#l37.73"></a><span id="l37.73" class="difflineplus">+    this._tagMap = {};</span>
<a href="#l37.74"></a><span id="l37.74" class="difflineplus">+    let tagArray = this._msgTagService.getAllTags({});</span>
<a href="#l37.75"></a><span id="l37.75" class="difflineplus">+    for (let iTag = 0; iTag &lt; tagArray.length; iTag++) {</span>
<a href="#l37.76"></a><span id="l37.76" class="difflineplus">+      let tag = tagArray[iTag];</span>
<a href="#l37.77"></a><span id="l37.77" class="difflineplus">+      this._tagMap[tag.key] = tag;</span>
<a href="#l37.78"></a><span id="l37.78" class="difflineplus">+    }</span>
<a href="#l37.79"></a><span id="l37.79" class="difflineplus">+  },</span>
<a href="#l37.80"></a><span id="l37.80" class="difflineplus">+  </span>
<a href="#l37.81"></a><span id="l37.81" class="difflineplus">+  // we cannot be an attribute value</span>
<a href="#l37.82"></a><span id="l37.82" class="difflineplus">+  </span>
<a href="#l37.83"></a><span id="l37.83" class="difflineplus">+  toParamAndValue: function gloda_noun_tag_toParamAndValue(aTag) {</span>
<a href="#l37.84"></a><span id="l37.84" class="difflineplus">+    return [aTag.key, null];</span>
<a href="#l37.85"></a><span id="l37.85" class="difflineplus">+  },</span>
<a href="#l37.86"></a><span id="l37.86" class="difflineplus">+  toJSON: function gloda_noun_tag_toJSON(aTag) {</span>
<a href="#l37.87"></a><span id="l37.87" class="difflineplus">+    return aTag.key;</span>
<a href="#l37.88"></a><span id="l37.88" class="difflineplus">+  },</span>
<a href="#l37.89"></a><span id="l37.89" class="difflineplus">+  fromJSON: function gloda_noun_tag_fromJSON(aTagKey, aIgnored) {</span>
<a href="#l37.90"></a><span id="l37.90" class="difflineplus">+    let tag = this._tagMap[aTagKey];</span>
<a href="#l37.91"></a><span id="l37.91" class="difflineplus">+    // you will note that if a tag is removed, we are unable to aggressively</span>
<a href="#l37.92"></a><span id="l37.92" class="difflineplus">+    //  deal with this.  we are okay with this, but it would be nice to be able</span>
<a href="#l37.93"></a><span id="l37.93" class="difflineplus">+    //  to listen to the message tag service to know when we should rebuild.</span>
<a href="#l37.94"></a><span id="l37.94" class="difflineplus">+    if ((tag === undefined) &amp;&amp; this._msgTagService.isValidKey(aTagKey)) {</span>
<a href="#l37.95"></a><span id="l37.95" class="difflineplus">+      this._updateTagMap();</span>
<a href="#l37.96"></a><span id="l37.96" class="difflineplus">+      tag = this._tagMap[aTagKey];</span>
<a href="#l37.97"></a><span id="l37.97" class="difflineplus">+    }</span>
<a href="#l37.98"></a><span id="l37.98" class="difflineplus">+    // we intentionally are returning undefined if the tag doesn't exist</span>
<a href="#l37.99"></a><span id="l37.99" class="difflineplus">+    return tag;</span>
<a href="#l37.100"></a><span id="l37.100" class="difflineplus">+  },</span>
<a href="#l37.101"></a><span id="l37.101" class="difflineplus">+};</span>
<a href="#l37.102"></a><span id="l37.102" class="difflineplus">+</span>
<a href="#l37.103"></a><span id="l37.103" class="difflineplus">+TagNoun._init();</span>
<a href="#l37.104"></a><span id="l37.104" class="difflineplus">+Gloda.defineNoun(TagNoun, Gloda.NOUN_TAG);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1">new file mode 100644</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineminus">--- /dev/null</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/public.js</span>
<a href="#l38.4"></a><span id="l38.4" class="difflineat">@@ -0,0 +1,36 @@</span>
<a href="#l38.5"></a><span id="l38.5" class="difflineplus">+</span>
<a href="#l38.6"></a><span id="l38.6" class="difflineplus">+</span>
<a href="#l38.7"></a><span id="l38.7" class="difflineplus">+EXPORTED_SYMBOLS = ['Gloda'];</span>
<a href="#l38.8"></a><span id="l38.8" class="difflineplus">+</span>
<a href="#l38.9"></a><span id="l38.9" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l38.10"></a><span id="l38.10" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l38.11"></a><span id="l38.11" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineplus">+</span>
<a href="#l38.14"></a><span id="l38.14" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l38.15"></a><span id="l38.15" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/everybody.js&quot;);</span>
<a href="#l38.16"></a><span id="l38.16" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/indexer.js&quot;);</span>
<a href="#l38.17"></a><span id="l38.17" class="difflineplus">+</span>
<a href="#l38.18"></a><span id="l38.18" class="difflineplus">+// an initial sweep is required.  this will not actually trigger anything if</span>
<a href="#l38.19"></a><span id="l38.19" class="difflineplus">+//  things are disabled, of course.</span>
<a href="#l38.20"></a><span id="l38.20" class="difflineplus">+// delay the initial sweep until after thunderbird has had a chance to start-up</span>
<a href="#l38.21"></a><span id="l38.21" class="difflineplus">+//  fully.</span>
<a href="#l38.22"></a><span id="l38.22" class="difflineplus">+let timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l38.23"></a><span id="l38.23" class="difflineplus">+timer.initWithCallback(function() {</span>
<a href="#l38.24"></a><span id="l38.24" class="difflineplus">+    GlodaIndexer.indexingSweepNeeded = true;</span>
<a href="#l38.25"></a><span id="l38.25" class="difflineplus">+    timer = null;</span>
<a href="#l38.26"></a><span id="l38.26" class="difflineplus">+  },</span>
<a href="#l38.27"></a><span id="l38.27" class="difflineplus">+  5000,</span>
<a href="#l38.28"></a><span id="l38.28" class="difflineplus">+  Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l38.29"></a><span id="l38.29" class="difflineplus">+</span>
<a href="#l38.30"></a><span id="l38.30" class="difflineplus">+/**</span>
<a href="#l38.31"></a><span id="l38.31" class="difflineplus">+ * Expose some junk </span>
<a href="#l38.32"></a><span id="l38.32" class="difflineplus">+ */</span>
<a href="#l38.33"></a><span id="l38.33" class="difflineplus">+function proxy(aSourceObj, aSourceAttr, aDestObj, aDestAttr) {</span>
<a href="#l38.34"></a><span id="l38.34" class="difflineplus">+  aDestObj[aDestAttr] = function() {</span>
<a href="#l38.35"></a><span id="l38.35" class="difflineplus">+    return aSourceObj[aSourceAttr].apply(aSourceObj, arguments);</span>
<a href="#l38.36"></a><span id="l38.36" class="difflineplus">+  };</span>
<a href="#l38.37"></a><span id="l38.37" class="difflineplus">+}</span>
<a href="#l38.38"></a><span id="l38.38" class="difflineplus">+</span>
<a href="#l38.39"></a><span id="l38.39" class="difflineplus">+proxy(GlodaIndexer, &quot;addListener&quot;, Gloda, &quot;addIndexerListener&quot;);</span>
<a href="#l38.40"></a><span id="l38.40" class="difflineplus">+proxy(GlodaIndexer, &quot;removeListener&quot;, Gloda, &quot;removeIndexerListener&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1">new file mode 100644</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineminus">--- /dev/null</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/query.js</span>
<a href="#l39.4"></a><span id="l39.4" class="difflineat">@@ -0,0 +1,370 @@</span>
<a href="#l39.5"></a><span id="l39.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l39.6"></a><span id="l39.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l39.7"></a><span id="l39.7" class="difflineplus">+ *</span>
<a href="#l39.8"></a><span id="l39.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l39.9"></a><span id="l39.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l39.10"></a><span id="l39.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l39.11"></a><span id="l39.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineplus">+ * </span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l39.14"></a><span id="l39.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l39.15"></a><span id="l39.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l39.16"></a><span id="l39.16" class="difflineplus">+ * License.</span>
<a href="#l39.17"></a><span id="l39.17" class="difflineplus">+ *</span>
<a href="#l39.18"></a><span id="l39.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l39.19"></a><span id="l39.19" class="difflineplus">+ *</span>
<a href="#l39.20"></a><span id="l39.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l39.21"></a><span id="l39.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l39.22"></a><span id="l39.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l39.23"></a><span id="l39.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l39.24"></a><span id="l39.24" class="difflineplus">+ *</span>
<a href="#l39.25"></a><span id="l39.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l39.26"></a><span id="l39.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l39.27"></a><span id="l39.27" class="difflineplus">+ *</span>
<a href="#l39.28"></a><span id="l39.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l39.29"></a><span id="l39.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l39.30"></a><span id="l39.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l39.31"></a><span id="l39.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l39.32"></a><span id="l39.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l39.33"></a><span id="l39.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l39.34"></a><span id="l39.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l39.35"></a><span id="l39.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l39.36"></a><span id="l39.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l39.37"></a><span id="l39.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l39.38"></a><span id="l39.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l39.39"></a><span id="l39.39" class="difflineplus">+ * </span>
<a href="#l39.40"></a><span id="l39.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l39.41"></a><span id="l39.41" class="difflineplus">+</span>
<a href="#l39.42"></a><span id="l39.42" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;GlodaQueryClassFactory&quot;];</span>
<a href="#l39.43"></a><span id="l39.43" class="difflineplus">+</span>
<a href="#l39.44"></a><span id="l39.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l39.45"></a><span id="l39.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l39.46"></a><span id="l39.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l39.47"></a><span id="l39.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l39.48"></a><span id="l39.48" class="difflineplus">+</span>
<a href="#l39.49"></a><span id="l39.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l39.50"></a><span id="l39.50" class="difflineplus">+</span>
<a href="#l39.51"></a><span id="l39.51" class="difflineplus">+/**</span>
<a href="#l39.52"></a><span id="l39.52" class="difflineplus">+ * @class Query class core; each noun gets its own sub-class where attributes</span>
<a href="#l39.53"></a><span id="l39.53" class="difflineplus">+ *  have helper methods bound.</span>
<a href="#l39.54"></a><span id="l39.54" class="difflineplus">+ * </span>
<a href="#l39.55"></a><span id="l39.55" class="difflineplus">+ * @property _owner The query instance that holds the list of unions...</span>
<a href="#l39.56"></a><span id="l39.56" class="difflineplus">+ * @property _constraints A list of (lists of OR constraints) that are ANDed</span>
<a href="#l39.57"></a><span id="l39.57" class="difflineplus">+ *     together.  For example [[FROM bob, FROM jim], [DATE last week]] would</span>
<a href="#l39.58"></a><span id="l39.58" class="difflineplus">+ *     be requesting us to find all the messages from either bob or jim, and</span>
<a href="#l39.59"></a><span id="l39.59" class="difflineplus">+ *     sent in the last week.</span>
<a href="#l39.60"></a><span id="l39.60" class="difflineplus">+ * @property _unions A list of other queries whose results are unioned with our</span>
<a href="#l39.61"></a><span id="l39.61" class="difflineplus">+ *     own.  There is no concept of nesting or sub-queries apart from this</span>
<a href="#l39.62"></a><span id="l39.62" class="difflineplus">+ *     mechanism.</span>
<a href="#l39.63"></a><span id="l39.63" class="difflineplus">+ */</span>
<a href="#l39.64"></a><span id="l39.64" class="difflineplus">+function GlodaQueryClass() {</span>
<a href="#l39.65"></a><span id="l39.65" class="difflineplus">+  // if we are an 'or' clause, who is our parent whom other 'or' clauses should</span>
<a href="#l39.66"></a><span id="l39.66" class="difflineplus">+  //  spawn from...</span>
<a href="#l39.67"></a><span id="l39.67" class="difflineplus">+  this._owner = null;</span>
<a href="#l39.68"></a><span id="l39.68" class="difflineplus">+  // our personal chain of and-ing.</span>
<a href="#l39.69"></a><span id="l39.69" class="difflineplus">+  this._constraints = [];</span>
<a href="#l39.70"></a><span id="l39.70" class="difflineplus">+  // the other instances we union with</span>
<a href="#l39.71"></a><span id="l39.71" class="difflineplus">+  this._unions = [];</span>
<a href="#l39.72"></a><span id="l39.72" class="difflineplus">+  </span>
<a href="#l39.73"></a><span id="l39.73" class="difflineplus">+  this._order = [];</span>
<a href="#l39.74"></a><span id="l39.74" class="difflineplus">+  this._limit = 0;</span>
<a href="#l39.75"></a><span id="l39.75" class="difflineplus">+}</span>
<a href="#l39.76"></a><span id="l39.76" class="difflineplus">+</span>
<a href="#l39.77"></a><span id="l39.77" class="difflineplus">+GlodaQueryClass.prototype = {</span>
<a href="#l39.78"></a><span id="l39.78" class="difflineplus">+  WILDCARD: {},</span>
<a href="#l39.79"></a><span id="l39.79" class="difflineplus">+  </span>
<a href="#l39.80"></a><span id="l39.80" class="difflineplus">+  get constraintCount() {</span>
<a href="#l39.81"></a><span id="l39.81" class="difflineplus">+    return this._constraints.length;</span>
<a href="#l39.82"></a><span id="l39.82" class="difflineplus">+  },</span>
<a href="#l39.83"></a><span id="l39.83" class="difflineplus">+  </span>
<a href="#l39.84"></a><span id="l39.84" class="difflineplus">+  or: function gloda_query_or() {</span>
<a href="#l39.85"></a><span id="l39.85" class="difflineplus">+    let owner = this._owner || this;</span>
<a href="#l39.86"></a><span id="l39.86" class="difflineplus">+    let orQuery = new this._queryClass();</span>
<a href="#l39.87"></a><span id="l39.87" class="difflineplus">+    orQuery._owner = owner;</span>
<a href="#l39.88"></a><span id="l39.88" class="difflineplus">+    owner._unions.push(orQuery);</span>
<a href="#l39.89"></a><span id="l39.89" class="difflineplus">+    return orQuery;</span>
<a href="#l39.90"></a><span id="l39.90" class="difflineplus">+  },</span>
<a href="#l39.91"></a><span id="l39.91" class="difflineplus">+  </span>
<a href="#l39.92"></a><span id="l39.92" class="difflineplus">+  orderBy: function gloda_query_orderBy() {</span>
<a href="#l39.93"></a><span id="l39.93" class="difflineplus">+    for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l39.94"></a><span id="l39.94" class="difflineplus">+      let arg = arguments[iArg];</span>
<a href="#l39.95"></a><span id="l39.95" class="difflineplus">+      this._order.push(arg);</span>
<a href="#l39.96"></a><span id="l39.96" class="difflineplus">+    }</span>
<a href="#l39.97"></a><span id="l39.97" class="difflineplus">+    return this;</span>
<a href="#l39.98"></a><span id="l39.98" class="difflineplus">+  },</span>
<a href="#l39.99"></a><span id="l39.99" class="difflineplus">+  </span>
<a href="#l39.100"></a><span id="l39.100" class="difflineplus">+  limit: function gloda_query_limit(aLimit) {</span>
<a href="#l39.101"></a><span id="l39.101" class="difflineplus">+    this._limit = aLimit;</span>
<a href="#l39.102"></a><span id="l39.102" class="difflineplus">+    return this;</span>
<a href="#l39.103"></a><span id="l39.103" class="difflineplus">+  },</span>
<a href="#l39.104"></a><span id="l39.104" class="difflineplus">+  </span>
<a href="#l39.105"></a><span id="l39.105" class="difflineplus">+  /**</span>
<a href="#l39.106"></a><span id="l39.106" class="difflineplus">+   * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l39.107"></a><span id="l39.107" class="difflineplus">+   *  provide a listener to receive notifications from the collection as it</span>
<a href="#l39.108"></a><span id="l39.108" class="difflineplus">+   *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l39.109"></a><span id="l39.109" class="difflineplus">+   *  onItemsModified, and onItemsRemoved methods, all of which take a single</span>
<a href="#l39.110"></a><span id="l39.110" class="difflineplus">+   *  argument which is the list of items which have been added, modified, or</span>
<a href="#l39.111"></a><span id="l39.111" class="difflineplus">+   *  removed respectively.</span>
<a href="#l39.112"></a><span id="l39.112" class="difflineplus">+   */</span>
<a href="#l39.113"></a><span id="l39.113" class="difflineplus">+  getCollection: function gloda_query_getCollection(aListener, aData) {</span>
<a href="#l39.114"></a><span id="l39.114" class="difflineplus">+    return this._nounDef.datastore.queryFromQuery(this, aListener, aData);</span>
<a href="#l39.115"></a><span id="l39.115" class="difflineplus">+  },</span>
<a href="#l39.116"></a><span id="l39.116" class="difflineplus">+  </span>
<a href="#l39.117"></a><span id="l39.117" class="difflineplus">+  /**</span>
<a href="#l39.118"></a><span id="l39.118" class="difflineplus">+   * Test whether the given first-class noun instance satisfies this query.</span>
<a href="#l39.119"></a><span id="l39.119" class="difflineplus">+   * </span>
<a href="#l39.120"></a><span id="l39.120" class="difflineplus">+   */</span>
<a href="#l39.121"></a><span id="l39.121" class="difflineplus">+  test: function gloda_query_test(aObj) {</span>
<a href="#l39.122"></a><span id="l39.122" class="difflineplus">+    // when changing this method, be sure that GlodaDatastore's queryFromQuery</span>
<a href="#l39.123"></a><span id="l39.123" class="difflineplus">+    //  method likewise has any required changes made. </span>
<a href="#l39.124"></a><span id="l39.124" class="difflineplus">+    let unionQueries = [this].concat(this._unions);</span>
<a href="#l39.125"></a><span id="l39.125" class="difflineplus">+    </span>
<a href="#l39.126"></a><span id="l39.126" class="difflineplus">+    for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l39.127"></a><span id="l39.127" class="difflineplus">+      let curQuery = unionQueries[iUnion];</span>
<a href="#l39.128"></a><span id="l39.128" class="difflineplus">+</span>
<a href="#l39.129"></a><span id="l39.129" class="difflineplus">+      // assume success until a specific (or) constraint proves us wrong</span>
<a href="#l39.130"></a><span id="l39.130" class="difflineplus">+      let querySatisfied = true;</span>
<a href="#l39.131"></a><span id="l39.131" class="difflineplus">+      for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length; </span>
<a href="#l39.132"></a><span id="l39.132" class="difflineplus">+           iConstraint++) {</span>
<a href="#l39.133"></a><span id="l39.133" class="difflineplus">+        let constraint = curQuery._constraints[iConstraint];</span>
<a href="#l39.134"></a><span id="l39.134" class="difflineplus">+        let [constraintType, attrDef] = constraint;</span>
<a href="#l39.135"></a><span id="l39.135" class="difflineplus">+        let constraintValues = constraint.slice(2);</span>
<a href="#l39.136"></a><span id="l39.136" class="difflineplus">+        </span>
<a href="#l39.137"></a><span id="l39.137" class="difflineplus">+        if (constraintType === this.kConstraintIdIn) {</span>
<a href="#l39.138"></a><span id="l39.138" class="difflineplus">+          if (constraintValues.indexOf(aObj.id) == -1) {</span>
<a href="#l39.139"></a><span id="l39.139" class="difflineplus">+            querySatisfied = false;</span>
<a href="#l39.140"></a><span id="l39.140" class="difflineplus">+            break;</span>
<a href="#l39.141"></a><span id="l39.141" class="difflineplus">+          }</span>
<a href="#l39.142"></a><span id="l39.142" class="difflineplus">+        }</span>
<a href="#l39.143"></a><span id="l39.143" class="difflineplus">+        else if ((constraintType === this.kConstraintIn) ||</span>
<a href="#l39.144"></a><span id="l39.144" class="difflineplus">+                 (constraintType === this.kConstraintEquals)) {</span>
<a href="#l39.145"></a><span id="l39.145" class="difflineplus">+          let objectNounDef = attrDef.objectNounDef;</span>
<a href="#l39.146"></a><span id="l39.146" class="difflineplus">+          </span>
<a href="#l39.147"></a><span id="l39.147" class="difflineplus">+          // if they provide an equals comparator, use that.</span>
<a href="#l39.148"></a><span id="l39.148" class="difflineplus">+          // (note: the next case has better optimization possibilities than</span>
<a href="#l39.149"></a><span id="l39.149" class="difflineplus">+          //  this mechanism, but of course has higher initialization costs or</span>
<a href="#l39.150"></a><span id="l39.150" class="difflineplus">+          //  code complexity costs...)</span>
<a href="#l39.151"></a><span id="l39.151" class="difflineplus">+          if (objectNounDef.equals) {</span>
<a href="#l39.152"></a><span id="l39.152" class="difflineplus">+            let testValues;</span>
<a href="#l39.153"></a><span id="l39.153" class="difflineplus">+            if (attrDef.singular)</span>
<a href="#l39.154"></a><span id="l39.154" class="difflineplus">+              testValues = [aObj[attrDef.boundName]];</span>
<a href="#l39.155"></a><span id="l39.155" class="difflineplus">+            else</span>
<a href="#l39.156"></a><span id="l39.156" class="difflineplus">+              testValues = aObj[attrDef.boundName];</span>
<a href="#l39.157"></a><span id="l39.157" class="difflineplus">+</span>
<a href="#l39.158"></a><span id="l39.158" class="difflineplus">+            let foundMatch = false;</span>
<a href="#l39.159"></a><span id="l39.159" class="difflineplus">+            for each (let [,testValue] in Iterator(testValues)) {</span>
<a href="#l39.160"></a><span id="l39.160" class="difflineplus">+              for each (let [,value] in Iterator(constraintValues)) {</span>
<a href="#l39.161"></a><span id="l39.161" class="difflineplus">+                if (objectNounDef.equals(testValue, value)) {</span>
<a href="#l39.162"></a><span id="l39.162" class="difflineplus">+                  foundMatch = true;</span>
<a href="#l39.163"></a><span id="l39.163" class="difflineplus">+                  break;</span>
<a href="#l39.164"></a><span id="l39.164" class="difflineplus">+                }</span>
<a href="#l39.165"></a><span id="l39.165" class="difflineplus">+              }</span>
<a href="#l39.166"></a><span id="l39.166" class="difflineplus">+              if (foundMatch)</span>
<a href="#l39.167"></a><span id="l39.167" class="difflineplus">+                break;</span>
<a href="#l39.168"></a><span id="l39.168" class="difflineplus">+            }</span>
<a href="#l39.169"></a><span id="l39.169" class="difflineplus">+            if (!foundMatch) {</span>
<a href="#l39.170"></a><span id="l39.170" class="difflineplus">+              querySatisfied = false;</span>
<a href="#l39.171"></a><span id="l39.171" class="difflineplus">+              break;</span>
<a href="#l39.172"></a><span id="l39.172" class="difflineplus">+            }</span>
<a href="#l39.173"></a><span id="l39.173" class="difflineplus">+          }</span>
<a href="#l39.174"></a><span id="l39.174" class="difflineplus">+          // otherwise, we need to convert everyone to their param/value form</span>
<a href="#l39.175"></a><span id="l39.175" class="difflineplus">+          //  in order to test for equality</span>
<a href="#l39.176"></a><span id="l39.176" class="difflineplus">+          else {</span>
<a href="#l39.177"></a><span id="l39.177" class="difflineplus">+            // let's just do the simple, obvious thing for now.  which is</span>
<a href="#l39.178"></a><span id="l39.178" class="difflineplus">+            //  what we did in the prior case but exploding values using</span>
<a href="#l39.179"></a><span id="l39.179" class="difflineplus">+            //  toParamAndValue, and then comparing.</span>
<a href="#l39.180"></a><span id="l39.180" class="difflineplus">+            let testValues;</span>
<a href="#l39.181"></a><span id="l39.181" class="difflineplus">+            if (attrDef.singular)</span>
<a href="#l39.182"></a><span id="l39.182" class="difflineplus">+              testValues = [aObj[attrDef.boundName]];</span>
<a href="#l39.183"></a><span id="l39.183" class="difflineplus">+            else</span>
<a href="#l39.184"></a><span id="l39.184" class="difflineplus">+              testValues = aObj[attrDef.boundName];</span>
<a href="#l39.185"></a><span id="l39.185" class="difflineplus">+</span>
<a href="#l39.186"></a><span id="l39.186" class="difflineplus">+            let foundMatch = false;</span>
<a href="#l39.187"></a><span id="l39.187" class="difflineplus">+            for each (let [,testValue] in Iterator(testValues)) {</span>
<a href="#l39.188"></a><span id="l39.188" class="difflineplus">+              let [aParam, aValue] = objectNounDef.toParamAndValue(testValue);</span>
<a href="#l39.189"></a><span id="l39.189" class="difflineplus">+              for each (let [,value] in Iterator(constraintValues)) {</span>
<a href="#l39.190"></a><span id="l39.190" class="difflineplus">+                let [bParam, bValue] = objectNounDef.toParamAndValue(value);</span>
<a href="#l39.191"></a><span id="l39.191" class="difflineplus">+                if (aParam == bParam &amp;&amp; aVAlue == bValue) {</span>
<a href="#l39.192"></a><span id="l39.192" class="difflineplus">+                  foundMatch = true;</span>
<a href="#l39.193"></a><span id="l39.193" class="difflineplus">+                  break;</span>
<a href="#l39.194"></a><span id="l39.194" class="difflineplus">+                }</span>
<a href="#l39.195"></a><span id="l39.195" class="difflineplus">+              }</span>
<a href="#l39.196"></a><span id="l39.196" class="difflineplus">+              if (foundMatch)</span>
<a href="#l39.197"></a><span id="l39.197" class="difflineplus">+                break;</span>
<a href="#l39.198"></a><span id="l39.198" class="difflineplus">+            }</span>
<a href="#l39.199"></a><span id="l39.199" class="difflineplus">+            if (!foundMatch) {</span>
<a href="#l39.200"></a><span id="l39.200" class="difflineplus">+              querySatisfied = false;</span>
<a href="#l39.201"></a><span id="l39.201" class="difflineplus">+              break;</span>
<a href="#l39.202"></a><span id="l39.202" class="difflineplus">+            }</span>
<a href="#l39.203"></a><span id="l39.203" class="difflineplus">+          }</span>
<a href="#l39.204"></a><span id="l39.204" class="difflineplus">+        }</span>
<a href="#l39.205"></a><span id="l39.205" class="difflineplus">+        else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l39.206"></a><span id="l39.206" class="difflineplus">+          let testValues;</span>
<a href="#l39.207"></a><span id="l39.207" class="difflineplus">+          if (attrDef.singular)</span>
<a href="#l39.208"></a><span id="l39.208" class="difflineplus">+            testValues = [aObj[attrDef.boundName]];</span>
<a href="#l39.209"></a><span id="l39.209" class="difflineplus">+          else</span>
<a href="#l39.210"></a><span id="l39.210" class="difflineplus">+            testValues = aObj[attrDef.boundName];</span>
<a href="#l39.211"></a><span id="l39.211" class="difflineplus">+</span>
<a href="#l39.212"></a><span id="l39.212" class="difflineplus">+          let foundMatch = false;</span>
<a href="#l39.213"></a><span id="l39.213" class="difflineplus">+          for each (let [,testValue] in Iterator(testValues)) {</span>
<a href="#l39.214"></a><span id="l39.214" class="difflineplus">+            let [tParam, tValue] = objectNounDef.toParamAndValue(testValue);</span>
<a href="#l39.215"></a><span id="l39.215" class="difflineplus">+            for each (let [,rangeTuple] in Iterator(constraintValues)) {</span>
<a href="#l39.216"></a><span id="l39.216" class="difflineplus">+              let [lowRValue, upperRValue] = rangeTuple;</span>
<a href="#l39.217"></a><span id="l39.217" class="difflineplus">+              if (lowRValue == null) {</span>
<a href="#l39.218"></a><span id="l39.218" class="difflineplus">+                let [upperParam, upperValue] =</span>
<a href="#l39.219"></a><span id="l39.219" class="difflineplus">+                  objectNounDef.toParamAndValue(upperRValue);</span>
<a href="#l39.220"></a><span id="l39.220" class="difflineplus">+                if (tParam == upperParam &amp;&amp; tValue &lt;= upperValue) {</span>
<a href="#l39.221"></a><span id="l39.221" class="difflineplus">+                  foundMatch = true;</span>
<a href="#l39.222"></a><span id="l39.222" class="difflineplus">+                  break;</span>
<a href="#l39.223"></a><span id="l39.223" class="difflineplus">+                }</span>
<a href="#l39.224"></a><span id="l39.224" class="difflineplus">+              }</span>
<a href="#l39.225"></a><span id="l39.225" class="difflineplus">+              else if (upperRValue == null) {</span>
<a href="#l39.226"></a><span id="l39.226" class="difflineplus">+                let [lowerParam, lowerValue] =</span>
<a href="#l39.227"></a><span id="l39.227" class="difflineplus">+                  objectNounDef.toParamAndValue(lowerRValue);</span>
<a href="#l39.228"></a><span id="l39.228" class="difflineplus">+                if (tParam == lowerParam &amp;&amp; tValue &gt;= lowerValue) {</span>
<a href="#l39.229"></a><span id="l39.229" class="difflineplus">+                  foundMatch = true;</span>
<a href="#l39.230"></a><span id="l39.230" class="difflineplus">+                  break;</span>
<a href="#l39.231"></a><span id="l39.231" class="difflineplus">+                }</span>
<a href="#l39.232"></a><span id="l39.232" class="difflineplus">+              }</span>
<a href="#l39.233"></a><span id="l39.233" class="difflineplus">+              else { // no one is null</span>
<a href="#l39.234"></a><span id="l39.234" class="difflineplus">+                let [upperParam, upperValue] =</span>
<a href="#l39.235"></a><span id="l39.235" class="difflineplus">+                  objectNounDef.toParamAndValue(upperRValue);</span>
<a href="#l39.236"></a><span id="l39.236" class="difflineplus">+                let [lowerParam, lowerValue] =</span>
<a href="#l39.237"></a><span id="l39.237" class="difflineplus">+                  objectNounDef.toParamAndValue(lowerRValue);</span>
<a href="#l39.238"></a><span id="l39.238" class="difflineplus">+                if ((tParam == lowerParam) &amp;&amp; (tValue &gt;= lowerValue) &amp;&amp;</span>
<a href="#l39.239"></a><span id="l39.239" class="difflineplus">+                    (tParam == upperParam) &amp;&amp; (tValue &lt;= upperValue)) {</span>
<a href="#l39.240"></a><span id="l39.240" class="difflineplus">+                  foundMatch = true;</span>
<a href="#l39.241"></a><span id="l39.241" class="difflineplus">+                  break;</span>
<a href="#l39.242"></a><span id="l39.242" class="difflineplus">+                }</span>
<a href="#l39.243"></a><span id="l39.243" class="difflineplus">+              }</span>
<a href="#l39.244"></a><span id="l39.244" class="difflineplus">+            }</span>
<a href="#l39.245"></a><span id="l39.245" class="difflineplus">+            if (foundMatch)</span>
<a href="#l39.246"></a><span id="l39.246" class="difflineplus">+              break;</span>
<a href="#l39.247"></a><span id="l39.247" class="difflineplus">+          }</span>
<a href="#l39.248"></a><span id="l39.248" class="difflineplus">+          if (!foundMatch) {</span>
<a href="#l39.249"></a><span id="l39.249" class="difflineplus">+            querySatisfied = false;</span>
<a href="#l39.250"></a><span id="l39.250" class="difflineplus">+            break;</span>
<a href="#l39.251"></a><span id="l39.251" class="difflineplus">+          }</span>
<a href="#l39.252"></a><span id="l39.252" class="difflineplus">+        }</span>
<a href="#l39.253"></a><span id="l39.253" class="difflineplus">+        else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l39.254"></a><span id="l39.254" class="difflineplus">+          let curIndex = 0;</span>
<a href="#l39.255"></a><span id="l39.255" class="difflineplus">+          let value = aObj[attrDef.boundName];</span>
<a href="#l39.256"></a><span id="l39.256" class="difflineplus">+          // the attribute must be singular, we don't support arrays of strings.</span>
<a href="#l39.257"></a><span id="l39.257" class="difflineplus">+          for each (let [iValuePart, valuePart] in Iterator(constraintValues)) {</span>
<a href="#l39.258"></a><span id="l39.258" class="difflineplus">+            if (typeof valuePart == &quot;string&quot;) {</span>
<a href="#l39.259"></a><span id="l39.259" class="difflineplus">+              let index = value.indexOf(valuePart);</span>
<a href="#l39.260"></a><span id="l39.260" class="difflineplus">+              // if curIndex is null, we just need any match</span>
<a href="#l39.261"></a><span id="l39.261" class="difflineplus">+              // if it's not null, it must match the offset of our found match</span>
<a href="#l39.262"></a><span id="l39.262" class="difflineplus">+              if (curIndex === null) {</span>
<a href="#l39.263"></a><span id="l39.263" class="difflineplus">+                if (index == -1)</span>
<a href="#l39.264"></a><span id="l39.264" class="difflineplus">+                  querySatisfied = false;</span>
<a href="#l39.265"></a><span id="l39.265" class="difflineplus">+                else</span>
<a href="#l39.266"></a><span id="l39.266" class="difflineplus">+                  curIndex = index + valuePart.length;</span>
<a href="#l39.267"></a><span id="l39.267" class="difflineplus">+              }</span>
<a href="#l39.268"></a><span id="l39.268" class="difflineplus">+              else {</span>
<a href="#l39.269"></a><span id="l39.269" class="difflineplus">+                if (index != curIndex)</span>
<a href="#l39.270"></a><span id="l39.270" class="difflineplus">+                  querySatisfied = false;</span>
<a href="#l39.271"></a><span id="l39.271" class="difflineplus">+                else</span>
<a href="#l39.272"></a><span id="l39.272" class="difflineplus">+                  curIndex = index + valuePart.length;</span>
<a href="#l39.273"></a><span id="l39.273" class="difflineplus">+              }</span>
<a href="#l39.274"></a><span id="l39.274" class="difflineplus">+              if (!querySatisfied)</span>
<a href="#l39.275"></a><span id="l39.275" class="difflineplus">+                break;</span>
<a href="#l39.276"></a><span id="l39.276" class="difflineplus">+            }</span>
<a href="#l39.277"></a><span id="l39.277" class="difflineplus">+            else // wild!</span>
<a href="#l39.278"></a><span id="l39.278" class="difflineplus">+              curIndex = null;</span>
<a href="#l39.279"></a><span id="l39.279" class="difflineplus">+          }</span>
<a href="#l39.280"></a><span id="l39.280" class="difflineplus">+          // curIndex must be null or equal to the length of the string</span>
<a href="#l39.281"></a><span id="l39.281" class="difflineplus">+          if (querySatisfied &amp;&amp; curIndex !== null &amp;&amp; curIndex != value.length)</span>
<a href="#l39.282"></a><span id="l39.282" class="difflineplus">+            querySatisfied = false;</span>
<a href="#l39.283"></a><span id="l39.283" class="difflineplus">+        }</span>
<a href="#l39.284"></a><span id="l39.284" class="difflineplus">+        else if (constraintType === this.kConstraintFulltext) {</span>
<a href="#l39.285"></a><span id="l39.285" class="difflineplus">+          // this is beyond our powers.  don't match.</span>
<a href="#l39.286"></a><span id="l39.286" class="difflineplus">+          querySatisfied = false;</span>
<a href="#l39.287"></a><span id="l39.287" class="difflineplus">+        }</span>
<a href="#l39.288"></a><span id="l39.288" class="difflineplus">+        </span>
<a href="#l39.289"></a><span id="l39.289" class="difflineplus">+        if (!querySatisfied)</span>
<a href="#l39.290"></a><span id="l39.290" class="difflineplus">+          break;</span>
<a href="#l39.291"></a><span id="l39.291" class="difflineplus">+      }</span>
<a href="#l39.292"></a><span id="l39.292" class="difflineplus">+      </span>
<a href="#l39.293"></a><span id="l39.293" class="difflineplus">+      if (querySatisfied)</span>
<a href="#l39.294"></a><span id="l39.294" class="difflineplus">+        return true;</span>
<a href="#l39.295"></a><span id="l39.295" class="difflineplus">+    }</span>
<a href="#l39.296"></a><span id="l39.296" class="difflineplus">+    </span>
<a href="#l39.297"></a><span id="l39.297" class="difflineplus">+    return false;</span>
<a href="#l39.298"></a><span id="l39.298" class="difflineplus">+  },</span>
<a href="#l39.299"></a><span id="l39.299" class="difflineplus">+};</span>
<a href="#l39.300"></a><span id="l39.300" class="difflineplus">+</span>
<a href="#l39.301"></a><span id="l39.301" class="difflineplus">+/**</span>
<a href="#l39.302"></a><span id="l39.302" class="difflineplus">+ * @class A query that only 'tests' for already belonging to the collection.</span>
<a href="#l39.303"></a><span id="l39.303" class="difflineplus">+ */</span>
<a href="#l39.304"></a><span id="l39.304" class="difflineplus">+function GlodaExplicitQueryClass() {</span>
<a href="#l39.305"></a><span id="l39.305" class="difflineplus">+}</span>
<a href="#l39.306"></a><span id="l39.306" class="difflineplus">+</span>
<a href="#l39.307"></a><span id="l39.307" class="difflineplus">+GlodaExplicitQueryClass.prototype = {</span>
<a href="#l39.308"></a><span id="l39.308" class="difflineplus">+  // don't let people try and mess with us</span>
<a href="#l39.309"></a><span id="l39.309" class="difflineplus">+  or: function() { return null; },</span>
<a href="#l39.310"></a><span id="l39.310" class="difflineplus">+  // don't let people try and query on us (until we have a real use case for</span>
<a href="#l39.311"></a><span id="l39.311" class="difflineplus">+  //  that...)</span>
<a href="#l39.312"></a><span id="l39.312" class="difflineplus">+  getCollection: function() { return null; },</span>
<a href="#l39.313"></a><span id="l39.313" class="difflineplus">+  /**</span>
<a href="#l39.314"></a><span id="l39.314" class="difflineplus">+   * Matches only items that are already in the collection (by id).</span>
<a href="#l39.315"></a><span id="l39.315" class="difflineplus">+   */</span>
<a href="#l39.316"></a><span id="l39.316" class="difflineplus">+  test: function gloda_query_explicit_test(aObj) {</span>
<a href="#l39.317"></a><span id="l39.317" class="difflineplus">+    return (aObj.id in this.collection._idMap);</span>
<a href="#l39.318"></a><span id="l39.318" class="difflineplus">+  }</span>
<a href="#l39.319"></a><span id="l39.319" class="difflineplus">+};</span>
<a href="#l39.320"></a><span id="l39.320" class="difflineplus">+</span>
<a href="#l39.321"></a><span id="l39.321" class="difflineplus">+/**</span>
<a href="#l39.322"></a><span id="l39.322" class="difflineplus">+ * @class A query that 'tests' true for everything.  Intended for debugging purposes</span>
<a href="#l39.323"></a><span id="l39.323" class="difflineplus">+ *  only.</span>
<a href="#l39.324"></a><span id="l39.324" class="difflineplus">+ */</span>
<a href="#l39.325"></a><span id="l39.325" class="difflineplus">+function GlodaWildcardQueryClass() {</span>
<a href="#l39.326"></a><span id="l39.326" class="difflineplus">+}</span>
<a href="#l39.327"></a><span id="l39.327" class="difflineplus">+</span>
<a href="#l39.328"></a><span id="l39.328" class="difflineplus">+GlodaWildcardQueryClass.prototype = {</span>
<a href="#l39.329"></a><span id="l39.329" class="difflineplus">+  // don't let people try and mess with us</span>
<a href="#l39.330"></a><span id="l39.330" class="difflineplus">+  or: function() { return null; },</span>
<a href="#l39.331"></a><span id="l39.331" class="difflineplus">+  // don't let people try and query on us (until we have a real use case for</span>
<a href="#l39.332"></a><span id="l39.332" class="difflineplus">+  //  that...)</span>
<a href="#l39.333"></a><span id="l39.333" class="difflineplus">+  getCollection: function() { return null; },</span>
<a href="#l39.334"></a><span id="l39.334" class="difflineplus">+  /**</span>
<a href="#l39.335"></a><span id="l39.335" class="difflineplus">+   * Everybody wins!</span>
<a href="#l39.336"></a><span id="l39.336" class="difflineplus">+   */</span>
<a href="#l39.337"></a><span id="l39.337" class="difflineplus">+  test: function gloda_query_explicit_test(aObj) {</span>
<a href="#l39.338"></a><span id="l39.338" class="difflineplus">+    return true;</span>
<a href="#l39.339"></a><span id="l39.339" class="difflineplus">+  }</span>
<a href="#l39.340"></a><span id="l39.340" class="difflineplus">+};</span>
<a href="#l39.341"></a><span id="l39.341" class="difflineplus">+</span>
<a href="#l39.342"></a><span id="l39.342" class="difflineplus">+/**</span>
<a href="#l39.343"></a><span id="l39.343" class="difflineplus">+ * Factory method to effectively create per-noun subclasses of GlodaQueryClass,</span>
<a href="#l39.344"></a><span id="l39.344" class="difflineplus">+ *  GlodaExplicitQueryClas, and GlodaWildcardQueryClass.  For GlodaQueryClass</span>
<a href="#l39.345"></a><span id="l39.345" class="difflineplus">+ *  this allows us to add per-noun helpers.  For the others, this is merely a</span>
<a href="#l39.346"></a><span id="l39.346" class="difflineplus">+ *  means of allowing us to attach the (per-noun) nounDef to the 'class'.</span>
<a href="#l39.347"></a><span id="l39.347" class="difflineplus">+ */</span>
<a href="#l39.348"></a><span id="l39.348" class="difflineplus">+function GlodaQueryClassFactory(aNounDef) {</span>
<a href="#l39.349"></a><span id="l39.349" class="difflineplus">+  let newQueryClass = function() {</span>
<a href="#l39.350"></a><span id="l39.350" class="difflineplus">+    GlodaQueryClass.call(this);</span>
<a href="#l39.351"></a><span id="l39.351" class="difflineplus">+  }; </span>
<a href="#l39.352"></a><span id="l39.352" class="difflineplus">+  </span>
<a href="#l39.353"></a><span id="l39.353" class="difflineplus">+  newQueryClass.prototype = new GlodaQueryClass();</span>
<a href="#l39.354"></a><span id="l39.354" class="difflineplus">+  newQueryClass.prototype._queryClass = newQueryClass;</span>
<a href="#l39.355"></a><span id="l39.355" class="difflineplus">+  newQueryClass.prototype._nounDef = aNounDef;</span>
<a href="#l39.356"></a><span id="l39.356" class="difflineplus">+  </span>
<a href="#l39.357"></a><span id="l39.357" class="difflineplus">+  let newExplicitClass = function(aCollection) {</span>
<a href="#l39.358"></a><span id="l39.358" class="difflineplus">+    GlodaExplicitQueryClass.call(this);</span>
<a href="#l39.359"></a><span id="l39.359" class="difflineplus">+    this.collection = aCollection;</span>
<a href="#l39.360"></a><span id="l39.360" class="difflineplus">+  };</span>
<a href="#l39.361"></a><span id="l39.361" class="difflineplus">+  newExplicitClass.prototype = new GlodaExplicitQueryClass();</span>
<a href="#l39.362"></a><span id="l39.362" class="difflineplus">+  newExplicitClass.prototype._queryClass = newExplicitClass;</span>
<a href="#l39.363"></a><span id="l39.363" class="difflineplus">+  newExplicitClass.prototype._nounDef = aNounDef;</span>
<a href="#l39.364"></a><span id="l39.364" class="difflineplus">+</span>
<a href="#l39.365"></a><span id="l39.365" class="difflineplus">+  let newWildcardClass = function(aCollection) {</span>
<a href="#l39.366"></a><span id="l39.366" class="difflineplus">+    GlodaWildcardQueryClass.call(this);</span>
<a href="#l39.367"></a><span id="l39.367" class="difflineplus">+    this.collection = aCollection;</span>
<a href="#l39.368"></a><span id="l39.368" class="difflineplus">+  };</span>
<a href="#l39.369"></a><span id="l39.369" class="difflineplus">+  newWildcardClass.prototype = new GlodaWildcardQueryClass();</span>
<a href="#l39.370"></a><span id="l39.370" class="difflineplus">+  newWildcardClass.prototype._queryClass = newWildcardClass;</span>
<a href="#l39.371"></a><span id="l39.371" class="difflineplus">+  newWildcardClass.prototype._nounDef = aNounDef;</span>
<a href="#l39.372"></a><span id="l39.372" class="difflineplus">+  </span>
<a href="#l39.373"></a><span id="l39.373" class="difflineplus">+  return [newQueryClass, newExplicitClass, newWildcardClass];</span>
<a href="#l39.374"></a><span id="l39.374" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1">new file mode 100644</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineminus">--- /dev/null</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/suffixtree.js</span>
<a href="#l40.4"></a><span id="l40.4" class="difflineat">@@ -0,0 +1,373 @@</span>
<a href="#l40.5"></a><span id="l40.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l40.6"></a><span id="l40.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l40.7"></a><span id="l40.7" class="difflineplus">+ *</span>
<a href="#l40.8"></a><span id="l40.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l40.9"></a><span id="l40.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l40.10"></a><span id="l40.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l40.11"></a><span id="l40.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineplus">+ * </span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l40.14"></a><span id="l40.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l40.15"></a><span id="l40.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l40.16"></a><span id="l40.16" class="difflineplus">+ * License.</span>
<a href="#l40.17"></a><span id="l40.17" class="difflineplus">+ *</span>
<a href="#l40.18"></a><span id="l40.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l40.19"></a><span id="l40.19" class="difflineplus">+ *</span>
<a href="#l40.20"></a><span id="l40.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l40.21"></a><span id="l40.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l40.23"></a><span id="l40.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l40.24"></a><span id="l40.24" class="difflineplus">+ *</span>
<a href="#l40.25"></a><span id="l40.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l40.26"></a><span id="l40.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l40.27"></a><span id="l40.27" class="difflineplus">+ *</span>
<a href="#l40.28"></a><span id="l40.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l40.29"></a><span id="l40.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l40.30"></a><span id="l40.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l40.31"></a><span id="l40.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l40.32"></a><span id="l40.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l40.33"></a><span id="l40.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l40.34"></a><span id="l40.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l40.35"></a><span id="l40.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l40.36"></a><span id="l40.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l40.37"></a><span id="l40.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l40.38"></a><span id="l40.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l40.39"></a><span id="l40.39" class="difflineplus">+ * </span>
<a href="#l40.40"></a><span id="l40.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l40.41"></a><span id="l40.41" class="difflineplus">+</span>
<a href="#l40.42"></a><span id="l40.42" class="difflineplus">+EXPORTED_SYMBOLS = [&quot;SuffixTree&quot;, &quot;MultiSuffixTree&quot;];</span>
<a href="#l40.43"></a><span id="l40.43" class="difflineplus">+</span>
<a href="#l40.44"></a><span id="l40.44" class="difflineplus">+/**</span>
<a href="#l40.45"></a><span id="l40.45" class="difflineplus">+ * Given a list of strings and a corresponding map of items that those strings</span>
<a href="#l40.46"></a><span id="l40.46" class="difflineplus">+ *  correspond to, build a suffix tree.</span>
<a href="#l40.47"></a><span id="l40.47" class="difflineplus">+ */</span>
<a href="#l40.48"></a><span id="l40.48" class="difflineplus">+function MultiSuffixTree(aStrings, aItems) {</span>
<a href="#l40.49"></a><span id="l40.49" class="difflineplus">+  if (aStrings.length != aItems.length)</span>
<a href="#l40.50"></a><span id="l40.50" class="difflineplus">+    throw Error(&quot;Array lengths need to be the same.&quot;);</span>
<a href="#l40.51"></a><span id="l40.51" class="difflineplus">+</span>
<a href="#l40.52"></a><span id="l40.52" class="difflineplus">+  let s = '';</span>
<a href="#l40.53"></a><span id="l40.53" class="difflineplus">+  let offsetsToItems = [];</span>
<a href="#l40.54"></a><span id="l40.54" class="difflineplus">+  let lastLength = 0;</span>
<a href="#l40.55"></a><span id="l40.55" class="difflineplus">+  for (let i = 0; i &lt; aStrings.length; i++) {</span>
<a href="#l40.56"></a><span id="l40.56" class="difflineplus">+    s += aStrings[i];</span>
<a href="#l40.57"></a><span id="l40.57" class="difflineplus">+    offsetsToItems.push(lastLength, s.length, aItems[i]);</span>
<a href="#l40.58"></a><span id="l40.58" class="difflineplus">+    lastLength = s.length;</span>
<a href="#l40.59"></a><span id="l40.59" class="difflineplus">+  }</span>
<a href="#l40.60"></a><span id="l40.60" class="difflineplus">+  </span>
<a href="#l40.61"></a><span id="l40.61" class="difflineplus">+  this._construct(s);</span>
<a href="#l40.62"></a><span id="l40.62" class="difflineplus">+  this._offsetsToItems = offsetsToItems;</span>
<a href="#l40.63"></a><span id="l40.63" class="difflineplus">+  this._numItems = aItems.length;</span>
<a href="#l40.64"></a><span id="l40.64" class="difflineplus">+}</span>
<a href="#l40.65"></a><span id="l40.65" class="difflineplus">+</span>
<a href="#l40.66"></a><span id="l40.66" class="difflineplus">+/**</span>
<a href="#l40.67"></a><span id="l40.67" class="difflineplus">+ * @constructor</span>
<a href="#l40.68"></a><span id="l40.68" class="difflineplus">+ */</span>
<a href="#l40.69"></a><span id="l40.69" class="difflineplus">+function State(aStartIndex, aEndIndex, aSuffix) {</span>
<a href="#l40.70"></a><span id="l40.70" class="difflineplus">+  this.start = aStartIndex;</span>
<a href="#l40.71"></a><span id="l40.71" class="difflineplus">+  this.end = aEndIndex;</span>
<a href="#l40.72"></a><span id="l40.72" class="difflineplus">+  this.suffix = aSuffix;</span>
<a href="#l40.73"></a><span id="l40.73" class="difflineplus">+}</span>
<a href="#l40.74"></a><span id="l40.74" class="difflineplus">+</span>
<a href="#l40.75"></a><span id="l40.75" class="difflineplus">+var dump;</span>
<a href="#l40.76"></a><span id="l40.76" class="difflineplus">+if (dump === undefined) {</span>
<a href="#l40.77"></a><span id="l40.77" class="difflineplus">+  dump = function(a) {</span>
<a href="#l40.78"></a><span id="l40.78" class="difflineplus">+    print(a.slice(0, -1));</span>
<a href="#l40.79"></a><span id="l40.79" class="difflineplus">+  };</span>
<a href="#l40.80"></a><span id="l40.80" class="difflineplus">+}</span>
<a href="#l40.81"></a><span id="l40.81" class="difflineplus">+</span>
<a href="#l40.82"></a><span id="l40.82" class="difflineplus">+/**</span>
<a href="#l40.83"></a><span id="l40.83" class="difflineplus">+ * Since objects are basically hash-tables anyways, we simply create an</span>
<a href="#l40.84"></a><span id="l40.84" class="difflineplus">+ *  attribute whose name is the first letter of the edge string.  (So, the</span>
<a href="#l40.85"></a><span id="l40.85" class="difflineplus">+ *  edge string can conceptually be a multi-letter string, but since we would</span>
<a href="#l40.86"></a><span id="l40.86" class="difflineplus">+ *  split it were there any ambiguity, it's okay to just use the single letter.)</span>
<a href="#l40.87"></a><span id="l40.87" class="difflineplus">+ *  This avoids having to update the attribute name or worry about tripping our</span>
<a href="#l40.88"></a><span id="l40.88" class="difflineplus">+ *  implementation up.</span>
<a href="#l40.89"></a><span id="l40.89" class="difflineplus">+ */</span>
<a href="#l40.90"></a><span id="l40.90" class="difflineplus">+State.prototype = {</span>
<a href="#l40.91"></a><span id="l40.91" class="difflineplus">+  get isExplicit() {</span>
<a href="#l40.92"></a><span id="l40.92" class="difflineplus">+    // our end is not inclusive...</span>
<a href="#l40.93"></a><span id="l40.93" class="difflineplus">+    return (this.end &lt;= this.start);</span>
<a href="#l40.94"></a><span id="l40.94" class="difflineplus">+  },</span>
<a href="#l40.95"></a><span id="l40.95" class="difflineplus">+  get isImplicit() {</span>
<a href="#l40.96"></a><span id="l40.96" class="difflineplus">+    // our end is not inclusive...</span>
<a href="#l40.97"></a><span id="l40.97" class="difflineplus">+    return (this.end &gt; this.start);</span>
<a href="#l40.98"></a><span id="l40.98" class="difflineplus">+  },</span>
<a href="#l40.99"></a><span id="l40.99" class="difflineplus">+  </span>
<a href="#l40.100"></a><span id="l40.100" class="difflineplus">+  get length() {</span>
<a href="#l40.101"></a><span id="l40.101" class="difflineplus">+    return this.end - this.start;</span>
<a href="#l40.102"></a><span id="l40.102" class="difflineplus">+  },</span>
<a href="#l40.103"></a><span id="l40.103" class="difflineplus">+  </span>
<a href="#l40.104"></a><span id="l40.104" class="difflineplus">+  toString: function State_toString() {</span>
<a href="#l40.105"></a><span id="l40.105" class="difflineplus">+    return &quot;[Start: &quot; + this.start + &quot; End: &quot; + this.end +</span>
<a href="#l40.106"></a><span id="l40.106" class="difflineplus">+           (this.suffix ? &quot; non-null suffix]&quot; : &quot; null suffix]&quot;); </span>
<a href="#l40.107"></a><span id="l40.107" class="difflineplus">+  }</span>
<a href="#l40.108"></a><span id="l40.108" class="difflineplus">+};</span>
<a href="#l40.109"></a><span id="l40.109" class="difflineplus">+</span>
<a href="#l40.110"></a><span id="l40.110" class="difflineplus">+/**</span>
<a href="#l40.111"></a><span id="l40.111" class="difflineplus">+ * Suffix tree implemented using Ukkonen's algorithm.</span>
<a href="#l40.112"></a><span id="l40.112" class="difflineplus">+ * @constructor</span>
<a href="#l40.113"></a><span id="l40.113" class="difflineplus">+ */</span>
<a href="#l40.114"></a><span id="l40.114" class="difflineplus">+function SuffixTree(aStr) {</span>
<a href="#l40.115"></a><span id="l40.115" class="difflineplus">+  this._construct(aStr);</span>
<a href="#l40.116"></a><span id="l40.116" class="difflineplus">+}</span>
<a href="#l40.117"></a><span id="l40.117" class="difflineplus">+</span>
<a href="#l40.118"></a><span id="l40.118" class="difflineplus">+/**</span>
<a href="#l40.119"></a><span id="l40.119" class="difflineplus">+ * States are </span>
<a href="#l40.120"></a><span id="l40.120" class="difflineplus">+ */</span>
<a href="#l40.121"></a><span id="l40.121" class="difflineplus">+SuffixTree.prototype = {</span>
<a href="#l40.122"></a><span id="l40.122" class="difflineplus">+  /**</span>
<a href="#l40.123"></a><span id="l40.123" class="difflineplus">+   * Find all items matching the provided substring.</span>
<a href="#l40.124"></a><span id="l40.124" class="difflineplus">+   */</span>
<a href="#l40.125"></a><span id="l40.125" class="difflineplus">+  findMatches: function findMatches(aSubstring) {</span>
<a href="#l40.126"></a><span id="l40.126" class="difflineplus">+    let results = [];</span>
<a href="#l40.127"></a><span id="l40.127" class="difflineplus">+    let state = this._root;</span>
<a href="#l40.128"></a><span id="l40.128" class="difflineplus">+    let index=0;</span>
<a href="#l40.129"></a><span id="l40.129" class="difflineplus">+    let end = aSubstring.length;</span>
<a href="#l40.130"></a><span id="l40.130" class="difflineplus">+    while(index &lt; end) {</span>
<a href="#l40.131"></a><span id="l40.131" class="difflineplus">+      state = state[aSubstring[index]];</span>
<a href="#l40.132"></a><span id="l40.132" class="difflineplus">+      // bail if there was no edge</span>
<a href="#l40.133"></a><span id="l40.133" class="difflineplus">+      if (state === undefined)</span>
<a href="#l40.134"></a><span id="l40.134" class="difflineplus">+        return results;</span>
<a href="#l40.135"></a><span id="l40.135" class="difflineplus">+      // bail if the portion of the edge we traversed is not equal to that</span>
<a href="#l40.136"></a><span id="l40.136" class="difflineplus">+      //  portion of our pattern</span>
<a href="#l40.137"></a><span id="l40.137" class="difflineplus">+      let actualTraverseLength = Math.min(state.length,</span>
<a href="#l40.138"></a><span id="l40.138" class="difflineplus">+                                          end - index);</span>
<a href="#l40.139"></a><span id="l40.139" class="difflineplus">+      if (this._str.substring(state.start,</span>
<a href="#l40.140"></a><span id="l40.140" class="difflineplus">+                              state.start + actualTraverseLength) !=</span>
<a href="#l40.141"></a><span id="l40.141" class="difflineplus">+          aSubstring.substring(index, index + actualTraverseLength))</span>
<a href="#l40.142"></a><span id="l40.142" class="difflineplus">+        return results;</span>
<a href="#l40.143"></a><span id="l40.143" class="difflineplus">+      index += state.length;</span>
<a href="#l40.144"></a><span id="l40.144" class="difflineplus">+    }</span>
<a href="#l40.145"></a><span id="l40.145" class="difflineplus">+    </span>
<a href="#l40.146"></a><span id="l40.146" class="difflineplus">+    // state should now be the node which itself and all its children match...</span>
<a href="#l40.147"></a><span id="l40.147" class="difflineplus">+    // The delta is to adjust us to the offset of the last letter of our match;</span>
<a href="#l40.148"></a><span id="l40.148" class="difflineplus">+    //  the edge we traversed to get here may have found us traversing more</span>
<a href="#l40.149"></a><span id="l40.149" class="difflineplus">+    //  than we wanted.</span>
<a href="#l40.150"></a><span id="l40.150" class="difflineplus">+    // index - end captures the over-shoot of the edge traversal,</span>
<a href="#l40.151"></a><span id="l40.151" class="difflineplus">+    // index - end + 1 captures the fact that we want to find the last letter</span>
<a href="#l40.152"></a><span id="l40.152" class="difflineplus">+    //  that matched, not just the first letter beyond it</span>
<a href="#l40.153"></a><span id="l40.153" class="difflineplus">+    // However, if this state is a leaf node (end == 'infinity'), then 'end'</span>
<a href="#l40.154"></a><span id="l40.154" class="difflineplus">+    //  isn't describing an edge at all and we want to avoid accounting for it.</span>
<a href="#l40.155"></a><span id="l40.155" class="difflineplus">+    let delta;</span>
<a href="#l40.156"></a><span id="l40.156" class="difflineplus">+    /*</span>
<a href="#l40.157"></a><span id="l40.157" class="difflineplus">+    if (state.end != this._infinity)</span>
<a href="#l40.158"></a><span id="l40.158" class="difflineplus">+      //delta = index - end + 1;</span>
<a href="#l40.159"></a><span id="l40.159" class="difflineplus">+      delta = end - (index - state.length); </span>
<a href="#l40.160"></a><span id="l40.160" class="difflineplus">+    else */</span>
<a href="#l40.161"></a><span id="l40.161" class="difflineplus">+    delta = index - state.length - end + 1;</span>
<a href="#l40.162"></a><span id="l40.162" class="difflineplus">+ </span>
<a href="#l40.163"></a><span id="l40.163" class="difflineplus">+    this._resultGather(state, results, {}, end, delta, true);</span>
<a href="#l40.164"></a><span id="l40.164" class="difflineplus">+    return results;</span>
<a href="#l40.165"></a><span id="l40.165" class="difflineplus">+  },</span>
<a href="#l40.166"></a><span id="l40.166" class="difflineplus">+  </span>
<a href="#l40.167"></a><span id="l40.167" class="difflineplus">+  _resultGather: function resultGather(aState, aResults, aPresence,</span>
<a href="#l40.168"></a><span id="l40.168" class="difflineplus">+                                       aPatLength, aDelta, alreadyAdjusted) {</span>
<a href="#l40.169"></a><span id="l40.169" class="difflineplus">+    // find the item that this state originated from based on the state's</span>
<a href="#l40.170"></a><span id="l40.170" class="difflineplus">+    //  start character.  offsetToItem holds [string start index, string end</span>
<a href="#l40.171"></a><span id="l40.171" class="difflineplus">+    //  index (exclusive), item reference].  So we want to binary search to</span>
<a href="#l40.172"></a><span id="l40.172" class="difflineplus">+    //  find the string whose start/end index contains the state's start index.</span>
<a href="#l40.173"></a><span id="l40.173" class="difflineplus">+    let low = 0;</span>
<a href="#l40.174"></a><span id="l40.174" class="difflineplus">+    let high = this._numItems-1;</span>
<a href="#l40.175"></a><span id="l40.175" class="difflineplus">+    let mid, stringStart, stringEnd;</span>
<a href="#l40.176"></a><span id="l40.176" class="difflineplus">+    </span>
<a href="#l40.177"></a><span id="l40.177" class="difflineplus">+    let patternLast = aState.start - aDelta;</span>
<a href="#l40.178"></a><span id="l40.178" class="difflineplus">+    while (low &lt;= high) {</span>
<a href="#l40.179"></a><span id="l40.179" class="difflineplus">+      mid = low + Math.floor((high - low) / 2); // excessive, especially with js nums</span>
<a href="#l40.180"></a><span id="l40.180" class="difflineplus">+      stringStart = this._offsetsToItems[mid*3];</span>
<a href="#l40.181"></a><span id="l40.181" class="difflineplus">+      let startDelta = stringStart - patternLast;</span>
<a href="#l40.182"></a><span id="l40.182" class="difflineplus">+      stringEnd = this._offsetsToItems[mid*3+1];</span>
<a href="#l40.183"></a><span id="l40.183" class="difflineplus">+      let endDelta = stringEnd - patternLast;</span>
<a href="#l40.184"></a><span id="l40.184" class="difflineplus">+      if (startDelta &gt; 0)</span>
<a href="#l40.185"></a><span id="l40.185" class="difflineplus">+        high = mid - 1;</span>
<a href="#l40.186"></a><span id="l40.186" class="difflineplus">+      else if (endDelta &lt;= 0)</span>
<a href="#l40.187"></a><span id="l40.187" class="difflineplus">+        low = mid + 1;</span>
<a href="#l40.188"></a><span id="l40.188" class="difflineplus">+      else {</span>
<a href="#l40.189"></a><span id="l40.189" class="difflineplus">+        break;</span>
<a href="#l40.190"></a><span id="l40.190" class="difflineplus">+      }</span>
<a href="#l40.191"></a><span id="l40.191" class="difflineplus">+    }</span>
<a href="#l40.192"></a><span id="l40.192" class="difflineplus">+    </span>
<a href="#l40.193"></a><span id="l40.193" class="difflineplus">+    // - The match occurred completely inside a source string.  Success.</span>
<a href="#l40.194"></a><span id="l40.194" class="difflineplus">+    // - The match spans more than one source strings, and is therefore not</span>
<a href="#l40.195"></a><span id="l40.195" class="difflineplus">+    //   a match.</span>
<a href="#l40.196"></a><span id="l40.196" class="difflineplus">+    </span>
<a href="#l40.197"></a><span id="l40.197" class="difflineplus">+    // at this point, we have located the origin string that corresponds to the</span>
<a href="#l40.198"></a><span id="l40.198" class="difflineplus">+    //  start index of this state.</span>
<a href="#l40.199"></a><span id="l40.199" class="difflineplus">+    // - The match terminated with the end of the preceding string, and does</span>
<a href="#l40.200"></a><span id="l40.200" class="difflineplus">+    //   not match us at all.  We, and potentially our children, are merely</span>
<a href="#l40.201"></a><span id="l40.201" class="difflineplus">+    //   serving as a unique terminal.</span>
<a href="#l40.202"></a><span id="l40.202" class="difflineplus">+    // - The </span>
<a href="#l40.203"></a><span id="l40.203" class="difflineplus">+</span>
<a href="#l40.204"></a><span id="l40.204" class="difflineplus">+  let patternFirst = patternLast - (aPatLength - 1);</span>
<a href="#l40.205"></a><span id="l40.205" class="difflineplus">+</span>
<a href="#l40.206"></a><span id="l40.206" class="difflineplus">+  if (patternFirst &gt;= stringStart) {</span>
<a href="#l40.207"></a><span id="l40.207" class="difflineplus">+    if (!(stringStart in aPresence)) {</span>
<a href="#l40.208"></a><span id="l40.208" class="difflineplus">+      aPresence[stringStart] = true;</span>
<a href="#l40.209"></a><span id="l40.209" class="difflineplus">+      aResults.push(this._offsetsToItems[mid*3+2]);</span>
<a href="#l40.210"></a><span id="l40.210" class="difflineplus">+    }</span>
<a href="#l40.211"></a><span id="l40.211" class="difflineplus">+  }</span>
<a href="#l40.212"></a><span id="l40.212" class="difflineplus">+    </span>
<a href="#l40.213"></a><span id="l40.213" class="difflineplus">+    // bail if we had it coming OR</span>
<a href="#l40.214"></a><span id="l40.214" class="difflineplus">+    // if the result terminates at/part-way through this state, meaning any</span>
<a href="#l40.215"></a><span id="l40.215" class="difflineplus">+    //  of its children are not going to be actual results, just hangers</span>
<a href="#l40.216"></a><span id="l40.216" class="difflineplus">+    //  on.</span>
<a href="#l40.217"></a><span id="l40.217" class="difflineplus">+/*</span>
<a href="#l40.218"></a><span id="l40.218" class="difflineplus">+    if (bail || (end &lt;= aState.end)) {</span>
<a href="#l40.219"></a><span id="l40.219" class="difflineplus">+dump(&quot;  bailing! (bail was: &quot; + bail + &quot;)\n&quot;);</span>
<a href="#l40.220"></a><span id="l40.220" class="difflineplus">+      return;</span>
<a href="#l40.221"></a><span id="l40.221" class="difflineplus">+    }</span>
<a href="#l40.222"></a><span id="l40.222" class="difflineplus">+*/    </span>
<a href="#l40.223"></a><span id="l40.223" class="difflineplus">+    // process our children...</span>
<a href="#l40.224"></a><span id="l40.224" class="difflineplus">+    for (let key in aState) {</span>
<a href="#l40.225"></a><span id="l40.225" class="difflineplus">+      // edges have attributes of length 1...</span>
<a href="#l40.226"></a><span id="l40.226" class="difflineplus">+      if (key.length == 1) {</span>
<a href="#l40.227"></a><span id="l40.227" class="difflineplus">+        let statePrime = aState[key];</span>
<a href="#l40.228"></a><span id="l40.228" class="difflineplus">+        this._resultGather(statePrime, aResults, aPresence, aPatLength,</span>
<a href="#l40.229"></a><span id="l40.229" class="difflineplus">+                           aDelta + aState.length, //(alreadyAdjusted ? 0 : aState.length),</span>
<a href="#l40.230"></a><span id="l40.230" class="difflineplus">+                           false);</span>
<a href="#l40.231"></a><span id="l40.231" class="difflineplus">+      }</span>
<a href="#l40.232"></a><span id="l40.232" class="difflineplus">+    }</span>
<a href="#l40.233"></a><span id="l40.233" class="difflineplus">+  },</span>
<a href="#l40.234"></a><span id="l40.234" class="difflineplus">+</span>
<a href="#l40.235"></a><span id="l40.235" class="difflineplus">+  /**</span>
<a href="#l40.236"></a><span id="l40.236" class="difflineplus">+   * Given a reference 'pair' of a state and a string (may be 'empty'=explicit,</span>
<a href="#l40.237"></a><span id="l40.237" class="difflineplus">+   *  which means no work to do and we return immediately) follow that state</span>
<a href="#l40.238"></a><span id="l40.238" class="difflineplus">+   *  (and then the successive states)'s transitions until we run out of</span>
<a href="#l40.239"></a><span id="l40.239" class="difflineplus">+   *  transitions.  This happens either when we find an explicit state, or </span>
<a href="#l40.240"></a><span id="l40.240" class="difflineplus">+   *  find ourselves partially along an edge (conceptually speaking).  In</span>
<a href="#l40.241"></a><span id="l40.241" class="difflineplus">+   *  the partial case, we return the state prior to the edge traversal.</span>
<a href="#l40.242"></a><span id="l40.242" class="difflineplus">+   * (The information about the 'edge' is contained on its target State;</span>
<a href="#l40.243"></a><span id="l40.243" class="difflineplus">+   *  we can do this because a state is only referenced by one other state.) </span>
<a href="#l40.244"></a><span id="l40.244" class="difflineplus">+   */</span>
<a href="#l40.245"></a><span id="l40.245" class="difflineplus">+  _canonize: function canonize(aState, aStart, aEnd) {</span>
<a href="#l40.246"></a><span id="l40.246" class="difflineplus">+    if (aEnd &lt;= aStart) {</span>
<a href="#l40.247"></a><span id="l40.247" class="difflineplus">+      return [aState, aStart];</span>
<a href="#l40.248"></a><span id="l40.248" class="difflineplus">+    }</span>
<a href="#l40.249"></a><span id="l40.249" class="difflineplus">+  </span>
<a href="#l40.250"></a><span id="l40.250" class="difflineplus">+    let statePrime;</span>
<a href="#l40.251"></a><span id="l40.251" class="difflineplus">+    // we treat an aState of null as 'bottom', which has transitions for every</span>
<a href="#l40.252"></a><span id="l40.252" class="difflineplus">+    //  letter in the alphabet to 'root'.  rather than create all those</span>
<a href="#l40.253"></a><span id="l40.253" class="difflineplus">+    //  transitions, we special-case here.</span>
<a href="#l40.254"></a><span id="l40.254" class="difflineplus">+    if (aState === null)</span>
<a href="#l40.255"></a><span id="l40.255" class="difflineplus">+      statePrime = this._root;</span>
<a href="#l40.256"></a><span id="l40.256" class="difflineplus">+    else</span>
<a href="#l40.257"></a><span id="l40.257" class="difflineplus">+      statePrime = aState[this._str[aStart]];</span>
<a href="#l40.258"></a><span id="l40.258" class="difflineplus">+    while (statePrime.length &lt;= aEnd - aStart) { // (no 1 adjustment required)</span>
<a href="#l40.259"></a><span id="l40.259" class="difflineplus">+      aStart += statePrime.length;</span>
<a href="#l40.260"></a><span id="l40.260" class="difflineplus">+      aState = statePrime;</span>
<a href="#l40.261"></a><span id="l40.261" class="difflineplus">+      if (aStart &lt; aEnd) {</span>
<a href="#l40.262"></a><span id="l40.262" class="difflineplus">+        statePrime = aState[this._str[aStart]];</span>
<a href="#l40.263"></a><span id="l40.263" class="difflineplus">+      }</span>
<a href="#l40.264"></a><span id="l40.264" class="difflineplus">+    }</span>
<a href="#l40.265"></a><span id="l40.265" class="difflineplus">+    return [aState, aStart]; </span>
<a href="#l40.266"></a><span id="l40.266" class="difflineplus">+  },</span>
<a href="#l40.267"></a><span id="l40.267" class="difflineplus">+</span>
<a href="#l40.268"></a><span id="l40.268" class="difflineplus">+  /**</span>
<a href="#l40.269"></a><span id="l40.269" class="difflineplus">+   * Given a reference 'pair' whose state may or may not be explicit (and for</span>
<a href="#l40.270"></a><span id="l40.270" class="difflineplus">+   *  which we will perform the required splitting to make it explicit), test</span>
<a href="#l40.271"></a><span id="l40.271" class="difflineplus">+   *  whether it already possesses a transition corresponding to the provided</span>
<a href="#l40.272"></a><span id="l40.272" class="difflineplus">+   *  character.</span>
<a href="#l40.273"></a><span id="l40.273" class="difflineplus">+   * @return A list of: whether we had to make it explicit, the (potentially)</span>
<a href="#l40.274"></a><span id="l40.274" class="difflineplus">+   *    new explicit state.</span>
<a href="#l40.275"></a><span id="l40.275" class="difflineplus">+   */</span>
<a href="#l40.276"></a><span id="l40.276" class="difflineplus">+  _testAndSplit: function testAndSplit(aState, aStart, aEnd, aChar) {</span>
<a href="#l40.277"></a><span id="l40.277" class="difflineplus">+    if (aStart &lt; aEnd) { // it's not explicit</span>
<a href="#l40.278"></a><span id="l40.278" class="difflineplus">+      let statePrime = aState[this._str[aStart]];</span>
<a href="#l40.279"></a><span id="l40.279" class="difflineplus">+      let length = aEnd - aStart;</span>
<a href="#l40.280"></a><span id="l40.280" class="difflineplus">+      if (aChar == this._str[statePrime.start + length]) {</span>
<a href="#l40.281"></a><span id="l40.281" class="difflineplus">+        return [true, aState];</span>
<a href="#l40.282"></a><span id="l40.282" class="difflineplus">+      }</span>
<a href="#l40.283"></a><span id="l40.283" class="difflineplus">+      else {</span>
<a href="#l40.284"></a><span id="l40.284" class="difflineplus">+        // do splitting... aState -&gt; rState -&gt; statePrime</span>
<a href="#l40.285"></a><span id="l40.285" class="difflineplus">+        let rState = new State(statePrime.start, statePrime.start + length);</span>
<a href="#l40.286"></a><span id="l40.286" class="difflineplus">+        aState[this._str[statePrime.start]] = rState;</span>
<a href="#l40.287"></a><span id="l40.287" class="difflineplus">+        statePrime.start += length;</span>
<a href="#l40.288"></a><span id="l40.288" class="difflineplus">+        rState[this._str[statePrime.start]] = statePrime;</span>
<a href="#l40.289"></a><span id="l40.289" class="difflineplus">+        return [false, rState];</span>
<a href="#l40.290"></a><span id="l40.290" class="difflineplus">+      }</span>
<a href="#l40.291"></a><span id="l40.291" class="difflineplus">+    }</span>
<a href="#l40.292"></a><span id="l40.292" class="difflineplus">+    else { // it's already explicit</span>
<a href="#l40.293"></a><span id="l40.293" class="difflineplus">+      if (aState === null) { // bottom case... shouldn't happen, but hey. </span>
<a href="#l40.294"></a><span id="l40.294" class="difflineplus">+        return [true, aState];</span>
<a href="#l40.295"></a><span id="l40.295" class="difflineplus">+      }</span>
<a href="#l40.296"></a><span id="l40.296" class="difflineplus">+      return [(aChar in aState), aState];</span>
<a href="#l40.297"></a><span id="l40.297" class="difflineplus">+    }</span>
<a href="#l40.298"></a><span id="l40.298" class="difflineplus">+      </span>
<a href="#l40.299"></a><span id="l40.299" class="difflineplus">+  },</span>
<a href="#l40.300"></a><span id="l40.300" class="difflineplus">+</span>
<a href="#l40.301"></a><span id="l40.301" class="difflineplus">+  _update: function update(aState, aStart, aIndex) {</span>
<a href="#l40.302"></a><span id="l40.302" class="difflineplus">+    let oldR = this._root;</span>
<a href="#l40.303"></a><span id="l40.303" class="difflineplus">+    let textAtIndex = this._str[aIndex]; // T sub i (0-based corrected...)</span>
<a href="#l40.304"></a><span id="l40.304" class="difflineplus">+    // because of the way we store the 'end' value as a one-past form, we do</span>
<a href="#l40.305"></a><span id="l40.305" class="difflineplus">+    //  not need to subtract 1 off of aIndex.</span>
<a href="#l40.306"></a><span id="l40.306" class="difflineplus">+    let [endPoint, rState] = this._testAndSplit(aState, aStart, aIndex, //no -1</span>
<a href="#l40.307"></a><span id="l40.307" class="difflineplus">+                                                textAtIndex);</span>
<a href="#l40.308"></a><span id="l40.308" class="difflineplus">+    while (!endPoint) {</span>
<a href="#l40.309"></a><span id="l40.309" class="difflineplus">+      let rPrime = new State(aIndex, this._infinity);</span>
<a href="#l40.310"></a><span id="l40.310" class="difflineplus">+      rState[textAtIndex] = rPrime;</span>
<a href="#l40.311"></a><span id="l40.311" class="difflineplus">+      if (oldR !== this._root)</span>
<a href="#l40.312"></a><span id="l40.312" class="difflineplus">+        oldR.suffix = rState;</span>
<a href="#l40.313"></a><span id="l40.313" class="difflineplus">+      oldR = rState;</span>
<a href="#l40.314"></a><span id="l40.314" class="difflineplus">+      [aState, aStart] = this._canonize(aState.suffix, aStart, aIndex); // no -1</span>
<a href="#l40.315"></a><span id="l40.315" class="difflineplus">+      [endPoint, rState] = this._testAndSplit(aState, aStart, aIndex, // no -1</span>
<a href="#l40.316"></a><span id="l40.316" class="difflineplus">+                                              textAtIndex);</span>
<a href="#l40.317"></a><span id="l40.317" class="difflineplus">+    }</span>
<a href="#l40.318"></a><span id="l40.318" class="difflineplus">+    if (oldR !== this._root)</span>
<a href="#l40.319"></a><span id="l40.319" class="difflineplus">+      oldR.suffix = aState;</span>
<a href="#l40.320"></a><span id="l40.320" class="difflineplus">+    </span>
<a href="#l40.321"></a><span id="l40.321" class="difflineplus">+    return [aState, aStart];</span>
<a href="#l40.322"></a><span id="l40.322" class="difflineplus">+  },</span>
<a href="#l40.323"></a><span id="l40.323" class="difflineplus">+  </span>
<a href="#l40.324"></a><span id="l40.324" class="difflineplus">+  _construct: function construct(aStr) {</span>
<a href="#l40.325"></a><span id="l40.325" class="difflineplus">+    this._str = aStr;</span>
<a href="#l40.326"></a><span id="l40.326" class="difflineplus">+    // just needs to be longer than the string.</span>
<a href="#l40.327"></a><span id="l40.327" class="difflineplus">+    this._infinity = aStr.length + 1;</span>
<a href="#l40.328"></a><span id="l40.328" class="difflineplus">+    </span>
<a href="#l40.329"></a><span id="l40.329" class="difflineplus">+    //this._bottom = new State(0, -1, null);</span>
<a href="#l40.330"></a><span id="l40.330" class="difflineplus">+    this._root = new State(-1, 0, null); // null === bottom</span>
<a href="#l40.331"></a><span id="l40.331" class="difflineplus">+    let state = this._root;</span>
<a href="#l40.332"></a><span id="l40.332" class="difflineplus">+    let start = 0;</span>
<a href="#l40.333"></a><span id="l40.333" class="difflineplus">+  </span>
<a href="#l40.334"></a><span id="l40.334" class="difflineplus">+    for (let i = 0; i &lt; aStr.length; i++) {</span>
<a href="#l40.335"></a><span id="l40.335" class="difflineplus">+      [state, start] = this._update(state, start, i); // treat as flowing -1...</span>
<a href="#l40.336"></a><span id="l40.336" class="difflineplus">+      [state, start] = this._canonize(state, start, i+1); // 1-length string</span>
<a href="#l40.337"></a><span id="l40.337" class="difflineplus">+    }</span>
<a href="#l40.338"></a><span id="l40.338" class="difflineplus">+  },</span>
<a href="#l40.339"></a><span id="l40.339" class="difflineplus">+  </span>
<a href="#l40.340"></a><span id="l40.340" class="difflineplus">+  dump: function SuffixTree_show(aState, aIndent, aKey) {</span>
<a href="#l40.341"></a><span id="l40.341" class="difflineplus">+    if (aState === undefined)</span>
<a href="#l40.342"></a><span id="l40.342" class="difflineplus">+      aState = this._root;</span>
<a href="#l40.343"></a><span id="l40.343" class="difflineplus">+    if (aIndent === undefined) {</span>
<a href="#l40.344"></a><span id="l40.344" class="difflineplus">+      aIndent = &quot;&quot;;</span>
<a href="#l40.345"></a><span id="l40.345" class="difflineplus">+      aKey = &quot;.&quot;;</span>
<a href="#l40.346"></a><span id="l40.346" class="difflineplus">+    }</span>
<a href="#l40.347"></a><span id="l40.347" class="difflineplus">+    </span>
<a href="#l40.348"></a><span id="l40.348" class="difflineplus">+    if (aState.isImplicit) {</span>
<a href="#l40.349"></a><span id="l40.349" class="difflineplus">+      let snip;</span>
<a href="#l40.350"></a><span id="l40.350" class="difflineplus">+      if (aState.length &gt; 10)</span>
<a href="#l40.351"></a><span id="l40.351" class="difflineplus">+        snip = this._str.slice(aState.start,</span>
<a href="#l40.352"></a><span id="l40.352" class="difflineplus">+                           Math.min(aState.start+10, this._str.length)) + &quot;...&quot;;</span>
<a href="#l40.353"></a><span id="l40.353" class="difflineplus">+      else</span>
<a href="#l40.354"></a><span id="l40.354" class="difflineplus">+        snip =  this._str.slice(aState.start,</span>
<a href="#l40.355"></a><span id="l40.355" class="difflineplus">+                                Math.min(aState.end, this._str.length)); </span>
<a href="#l40.356"></a><span id="l40.356" class="difflineplus">+      dump(aIndent + aKey + &quot;:&quot; + snip + &quot;(&quot; +</span>
<a href="#l40.357"></a><span id="l40.357" class="difflineplus">+           aState.start + &quot;:&quot; + aState.end + &quot;)\n&quot;);</span>
<a href="#l40.358"></a><span id="l40.358" class="difflineplus">+    }</span>
<a href="#l40.359"></a><span id="l40.359" class="difflineplus">+    else</span>
<a href="#l40.360"></a><span id="l40.360" class="difflineplus">+      dump(aIndent + aKey + &quot;: (explicit:&quot; + aState.start + &quot;:&quot; + aState.end +&quot;)\n&quot;);</span>
<a href="#l40.361"></a><span id="l40.361" class="difflineplus">+    let nextIndent = aIndent + &quot;  &quot;;</span>
<a href="#l40.362"></a><span id="l40.362" class="difflineplus">+    let keys = [c for (c in aState) if (c.length == 1)];</span>
<a href="#l40.363"></a><span id="l40.363" class="difflineplus">+    for each (let [iKey, key] in Iterator(keys)) {</span>
<a href="#l40.364"></a><span id="l40.364" class="difflineplus">+      this.dump(aState[key], nextIndent, key);</span>
<a href="#l40.365"></a><span id="l40.365" class="difflineplus">+    }</span>
<a href="#l40.366"></a><span id="l40.366" class="difflineplus">+  }</span>
<a href="#l40.367"></a><span id="l40.367" class="difflineplus">+};</span>
<a href="#l40.368"></a><span id="l40.368" class="difflineplus">+MultiSuffixTree.prototype = SuffixTree.prototype;</span>
<a href="#l40.369"></a><span id="l40.369" class="difflineplus">+</span>
<a href="#l40.370"></a><span id="l40.370" class="difflineplus">+function examplar() {</span>
<a href="#l40.371"></a><span id="l40.371" class="difflineplus">+  let names = [&quot;AndrewSmith&quot;, &quot;AndrewJones&quot;, &quot;MarkSmith&quot;, &quot;BryanClark&quot;,</span>
<a href="#l40.372"></a><span id="l40.372" class="difflineplus">+               &quot;MarthaJones&quot;, &quot;DavidAscher&quot;, &quot;DanMosedale&quot;, &quot;DavidBienvenu&quot;,</span>
<a href="#l40.373"></a><span id="l40.373" class="difflineplus">+               &quot;JanetDavis&quot;, &quot;JosephBryant&quot;];</span>
<a href="#l40.374"></a><span id="l40.374" class="difflineplus">+  let b = new MultiSuffixTree(names, names);</span>
<a href="#l40.375"></a><span id="l40.375" class="difflineplus">+  b.dump();</span>
<a href="#l40.376"></a><span id="l40.376" class="difflineplus">+  dump(b.findMatches(&quot;rya&quot;) + &quot;\n&quot;);</span>
<a href="#l40.377"></a><span id="l40.377" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1">new file mode 100644</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineminus">--- /dev/null</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineplus">+++ b/mailnews/db/gloda/modules/utils.js</span>
<a href="#l41.4"></a><span id="l41.4" class="difflineat">@@ -0,0 +1,157 @@</span>
<a href="#l41.5"></a><span id="l41.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l41.6"></a><span id="l41.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l41.7"></a><span id="l41.7" class="difflineplus">+ *</span>
<a href="#l41.8"></a><span id="l41.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l41.9"></a><span id="l41.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l41.10"></a><span id="l41.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l41.11"></a><span id="l41.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l41.12"></a><span id="l41.12" class="difflineplus">+ * </span>
<a href="#l41.13"></a><span id="l41.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l41.14"></a><span id="l41.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l41.15"></a><span id="l41.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l41.16"></a><span id="l41.16" class="difflineplus">+ * License.</span>
<a href="#l41.17"></a><span id="l41.17" class="difflineplus">+ *</span>
<a href="#l41.18"></a><span id="l41.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l41.19"></a><span id="l41.19" class="difflineplus">+ *</span>
<a href="#l41.20"></a><span id="l41.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l41.21"></a><span id="l41.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l41.22"></a><span id="l41.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l41.23"></a><span id="l41.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l41.24"></a><span id="l41.24" class="difflineplus">+ *</span>
<a href="#l41.25"></a><span id="l41.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l41.26"></a><span id="l41.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l41.27"></a><span id="l41.27" class="difflineplus">+ *</span>
<a href="#l41.28"></a><span id="l41.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l41.29"></a><span id="l41.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l41.30"></a><span id="l41.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l41.31"></a><span id="l41.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l41.32"></a><span id="l41.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l41.33"></a><span id="l41.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l41.34"></a><span id="l41.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l41.35"></a><span id="l41.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l41.36"></a><span id="l41.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l41.37"></a><span id="l41.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l41.38"></a><span id="l41.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l41.39"></a><span id="l41.39" class="difflineplus">+ * </span>
<a href="#l41.40"></a><span id="l41.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l41.41"></a><span id="l41.41" class="difflineplus">+</span>
<a href="#l41.42"></a><span id="l41.42" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaUtils'];</span>
<a href="#l41.43"></a><span id="l41.43" class="difflineplus">+</span>
<a href="#l41.44"></a><span id="l41.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l41.45"></a><span id="l41.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l41.46"></a><span id="l41.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l41.47"></a><span id="l41.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l41.48"></a><span id="l41.48" class="difflineplus">+</span>
<a href="#l41.49"></a><span id="l41.49" class="difflineplus">+/**</span>
<a href="#l41.50"></a><span id="l41.50" class="difflineplus">+ * @namespace A holding place for logic that is not gloda-specific and should</span>
<a href="#l41.51"></a><span id="l41.51" class="difflineplus">+ *  reside elsewhere.</span>
<a href="#l41.52"></a><span id="l41.52" class="difflineplus">+ */</span>
<a href="#l41.53"></a><span id="l41.53" class="difflineplus">+var GlodaUtils = {</span>
<a href="#l41.54"></a><span id="l41.54" class="difflineplus">+  _mimeConverter: null,</span>
<a href="#l41.55"></a><span id="l41.55" class="difflineplus">+  deMime: function gloda_utils_deMime(aString) {</span>
<a href="#l41.56"></a><span id="l41.56" class="difflineplus">+    if (this._mimeConverter == null) {</span>
<a href="#l41.57"></a><span id="l41.57" class="difflineplus">+      this._mimeConverter = Cc[&quot;@mozilla.org/messenger/mimeconverter;1&quot;].</span>
<a href="#l41.58"></a><span id="l41.58" class="difflineplus">+                            getService(Ci.nsIMimeConverter);</span>
<a href="#l41.59"></a><span id="l41.59" class="difflineplus">+    }</span>
<a href="#l41.60"></a><span id="l41.60" class="difflineplus">+    </span>
<a href="#l41.61"></a><span id="l41.61" class="difflineplus">+    return this._mimeConverter.decodeMimeHeader(aString, null, false, true);</span>
<a href="#l41.62"></a><span id="l41.62" class="difflineplus">+  },</span>
<a href="#l41.63"></a><span id="l41.63" class="difflineplus">+  </span>
<a href="#l41.64"></a><span id="l41.64" class="difflineplus">+  _headerParser: null,</span>
<a href="#l41.65"></a><span id="l41.65" class="difflineplus">+  </span>
<a href="#l41.66"></a><span id="l41.66" class="difflineplus">+  /**</span>
<a href="#l41.67"></a><span id="l41.67" class="difflineplus">+   * Parses an RFC 2822 list of e-mail addresses and returns an object with</span>
<a href="#l41.68"></a><span id="l41.68" class="difflineplus">+   *  4 attributes, as described below.  We will use the example of the user</span>
<a href="#l41.69"></a><span id="l41.69" class="difflineplus">+   *  passing an argument of '&quot;Bob Smith&quot; &lt;bob@company.com&gt;'.</span>
<a href="#l41.70"></a><span id="l41.70" class="difflineplus">+   *  </span>
<a href="#l41.71"></a><span id="l41.71" class="difflineplus">+   * count: the number of addresses parsed. (ex: 1)</span>
<a href="#l41.72"></a><span id="l41.72" class="difflineplus">+   * addresses: a list of e-mail addresses (ex: [&quot;bob@company.com&quot;])</span>
<a href="#l41.73"></a><span id="l41.73" class="difflineplus">+   * names: a list of names (ex: [&quot;Bob Smith&quot;])</span>
<a href="#l41.74"></a><span id="l41.74" class="difflineplus">+   * fullAddresses: aka the list of name and e-mail together (ex: ['&quot;Bob Smith&quot;</span>
<a href="#l41.75"></a><span id="l41.75" class="difflineplus">+   *  &lt;bob@company.com&gt;']).</span>
<a href="#l41.76"></a><span id="l41.76" class="difflineplus">+   *</span>
<a href="#l41.77"></a><span id="l41.77" class="difflineplus">+   * This method is a convenience wrapper around nsIMsgHeaderParser. </span>
<a href="#l41.78"></a><span id="l41.78" class="difflineplus">+   */</span>
<a href="#l41.79"></a><span id="l41.79" class="difflineplus">+  parseMailAddresses: function gloda_utils_parseMailAddresses(aMailAddresses) {</span>
<a href="#l41.80"></a><span id="l41.80" class="difflineplus">+    if (this._headerParser == null) {</span>
<a href="#l41.81"></a><span id="l41.81" class="difflineplus">+      this._headerParser = Cc[&quot;@mozilla.org/messenger/headerparser;1&quot;].</span>
<a href="#l41.82"></a><span id="l41.82" class="difflineplus">+                           getService(Ci.nsIMsgHeaderParser);</span>
<a href="#l41.83"></a><span id="l41.83" class="difflineplus">+    }</span>
<a href="#l41.84"></a><span id="l41.84" class="difflineplus">+    let addresses = {}, names = {}, fullAddresses = {};</span>
<a href="#l41.85"></a><span id="l41.85" class="difflineplus">+    this._headerParser.parseHeadersWithArray(aMailAddresses, addresses,</span>
<a href="#l41.86"></a><span id="l41.86" class="difflineplus">+                                             names, fullAddresses);</span>
<a href="#l41.87"></a><span id="l41.87" class="difflineplus">+    return {names: names.value, addresses: addresses.value,</span>
<a href="#l41.88"></a><span id="l41.88" class="difflineplus">+            fullAddresses: fullAddresses.value,</span>
<a href="#l41.89"></a><span id="l41.89" class="difflineplus">+            count: names.value.length}; </span>
<a href="#l41.90"></a><span id="l41.90" class="difflineplus">+  },</span>
<a href="#l41.91"></a><span id="l41.91" class="difflineplus">+  </span>
<a href="#l41.92"></a><span id="l41.92" class="difflineplus">+  /**</span>
<a href="#l41.93"></a><span id="l41.93" class="difflineplus">+   * MD5 hash a string and return the hex-string result. Impl from nsICryptoHash</span>
<a href="#l41.94"></a><span id="l41.94" class="difflineplus">+   *  docs.</span>
<a href="#l41.95"></a><span id="l41.95" class="difflineplus">+   */</span>
<a href="#l41.96"></a><span id="l41.96" class="difflineplus">+  md5HashString: function gloda_utils_md5hash(aString) {</span>
<a href="#l41.97"></a><span id="l41.97" class="difflineplus">+    let converter = Cc[&quot;@mozilla.org/intl/scriptableunicodeconverter&quot;].</span>
<a href="#l41.98"></a><span id="l41.98" class="difflineplus">+                    createInstance(Ci.nsIScriptableUnicodeConverter);</span>
<a href="#l41.99"></a><span id="l41.99" class="difflineplus">+    let trash = {};</span>
<a href="#l41.100"></a><span id="l41.100" class="difflineplus">+    converter.charset = &quot;UTF-8&quot;;</span>
<a href="#l41.101"></a><span id="l41.101" class="difflineplus">+    let data = converter.convertToByteArray(aString, trash);</span>
<a href="#l41.102"></a><span id="l41.102" class="difflineplus">+</span>
<a href="#l41.103"></a><span id="l41.103" class="difflineplus">+    let hasher = Cc['@mozilla.org/security/hash;1'].</span>
<a href="#l41.104"></a><span id="l41.104" class="difflineplus">+                 createInstance(Ci.nsICryptoHash);</span>
<a href="#l41.105"></a><span id="l41.105" class="difflineplus">+    hasher.init(Ci.nsICryptoHash.MD5);</span>
<a href="#l41.106"></a><span id="l41.106" class="difflineplus">+    hasher.update(data, data.length);</span>
<a href="#l41.107"></a><span id="l41.107" class="difflineplus">+    let hash = hasher.finish(false);</span>
<a href="#l41.108"></a><span id="l41.108" class="difflineplus">+    </span>
<a href="#l41.109"></a><span id="l41.109" class="difflineplus">+     // return the two-digit hexadecimal code for a byte</span>
<a href="#l41.110"></a><span id="l41.110" class="difflineplus">+    function toHexString(charCode) {</span>
<a href="#l41.111"></a><span id="l41.111" class="difflineplus">+      return (&quot;0&quot; + charCode.toString(16)).slice(-2);</span>
<a href="#l41.112"></a><span id="l41.112" class="difflineplus">+    }</span>
<a href="#l41.113"></a><span id="l41.113" class="difflineplus">+</span>
<a href="#l41.114"></a><span id="l41.114" class="difflineplus">+    // convert the binary hash data to a hex string.</span>
<a href="#l41.115"></a><span id="l41.115" class="difflineplus">+    return [toHexString(hash.charCodeAt(i)) for (i in hash)].join(&quot;&quot;);</span>
<a href="#l41.116"></a><span id="l41.116" class="difflineplus">+  },</span>
<a href="#l41.117"></a><span id="l41.117" class="difflineplus">+  </span>
<a href="#l41.118"></a><span id="l41.118" class="difflineplus">+  getCardForEmail: function gloda_utils_getCardForEmail(aAddress) {</span>
<a href="#l41.119"></a><span id="l41.119" class="difflineplus">+    // search through all of our local address books looking for a match.</span>
<a href="#l41.120"></a><span id="l41.120" class="difflineplus">+    let enumerator = Components.classes[&quot;@mozilla.org/abmanager;1&quot;]</span>
<a href="#l41.121"></a><span id="l41.121" class="difflineplus">+                               .getService(Ci.nsIAbManager)</span>
<a href="#l41.122"></a><span id="l41.122" class="difflineplus">+                               .directories;</span>
<a href="#l41.123"></a><span id="l41.123" class="difflineplus">+    let cardForEmailAddress;</span>
<a href="#l41.124"></a><span id="l41.124" class="difflineplus">+    let addrbook;</span>
<a href="#l41.125"></a><span id="l41.125" class="difflineplus">+    while (!cardForEmailAddress &amp;&amp; enumerator.hasMoreElements())</span>
<a href="#l41.126"></a><span id="l41.126" class="difflineplus">+    {</span>
<a href="#l41.127"></a><span id="l41.127" class="difflineplus">+      addrbook = enumerator.getNext().QueryInterface(Ci.nsIAbDirectory);</span>
<a href="#l41.128"></a><span id="l41.128" class="difflineplus">+      try</span>
<a href="#l41.129"></a><span id="l41.129" class="difflineplus">+      {</span>
<a href="#l41.130"></a><span id="l41.130" class="difflineplus">+        cardForEmailAddress = addrbook.cardForEmailAddress(aAddress);</span>
<a href="#l41.131"></a><span id="l41.131" class="difflineplus">+        if (cardForEmailAddress)</span>
<a href="#l41.132"></a><span id="l41.132" class="difflineplus">+          return cardForEmailAddress;</span>
<a href="#l41.133"></a><span id="l41.133" class="difflineplus">+      } catch (ex) {}</span>
<a href="#l41.134"></a><span id="l41.134" class="difflineplus">+    }</span>
<a href="#l41.135"></a><span id="l41.135" class="difflineplus">+</span>
<a href="#l41.136"></a><span id="l41.136" class="difflineplus">+    return null;</span>
<a href="#l41.137"></a><span id="l41.137" class="difflineplus">+  },</span>
<a href="#l41.138"></a><span id="l41.138" class="difflineplus">+  </span>
<a href="#l41.139"></a><span id="l41.139" class="difflineplus">+  /* from mailTestUtils.js, but whittled for our purposes... */</span>
<a href="#l41.140"></a><span id="l41.140" class="difflineplus">+  loadFileToString: function(aFile) {</span>
<a href="#l41.141"></a><span id="l41.141" class="difflineplus">+    let fstream = Cc[&quot;@mozilla.org/network/file-input-stream;1&quot;]</span>
<a href="#l41.142"></a><span id="l41.142" class="difflineplus">+                    .createInstance(Ci.nsIFileInputStream);</span>
<a href="#l41.143"></a><span id="l41.143" class="difflineplus">+    fstream.init(aFile, -1, 0, 0);</span>
<a href="#l41.144"></a><span id="l41.144" class="difflineplus">+    </span>
<a href="#l41.145"></a><span id="l41.145" class="difflineplus">+    let sstream = Cc[&quot;@mozilla.org/scriptableinputstream;1&quot;]</span>
<a href="#l41.146"></a><span id="l41.146" class="difflineplus">+                    .createInstance(Ci.nsIScriptableInputStream);</span>
<a href="#l41.147"></a><span id="l41.147" class="difflineplus">+    sstream.init(fstream);</span>
<a href="#l41.148"></a><span id="l41.148" class="difflineplus">+</span>
<a href="#l41.149"></a><span id="l41.149" class="difflineplus">+    let data = &quot;&quot;;</span>
<a href="#l41.150"></a><span id="l41.150" class="difflineplus">+    let str = sstream.read(4096);</span>
<a href="#l41.151"></a><span id="l41.151" class="difflineplus">+    while (str.length &gt; 0) {</span>
<a href="#l41.152"></a><span id="l41.152" class="difflineplus">+      data += str;</span>
<a href="#l41.153"></a><span id="l41.153" class="difflineplus">+      str = sstream.read(4096);</span>
<a href="#l41.154"></a><span id="l41.154" class="difflineplus">+    }</span>
<a href="#l41.155"></a><span id="l41.155" class="difflineplus">+</span>
<a href="#l41.156"></a><span id="l41.156" class="difflineplus">+    sstream.close();</span>
<a href="#l41.157"></a><span id="l41.157" class="difflineplus">+    fstream.close();</span>
<a href="#l41.158"></a><span id="l41.158" class="difflineplus">+</span>
<a href="#l41.159"></a><span id="l41.159" class="difflineplus">+    return data;</span>
<a href="#l41.160"></a><span id="l41.160" class="difflineplus">+  },</span>
<a href="#l41.161"></a><span id="l41.161" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1">new file mode 100644</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineminus">--- /dev/null</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineplus">+++ b/mailnews/db/gloda/readme.txt</span>
<a href="#l42.4"></a><span id="l42.4" class="difflineat">@@ -0,0 +1,21 @@</span>
<a href="#l42.5"></a><span id="l42.5" class="difflineplus">+This extension was generated by the Extension Wizard at</span>
<a href="#l42.6"></a><span id="l42.6" class="difflineplus">+http://ted.mielczarek.org/code/mozilla/extensionwiz/ .</span>
<a href="#l42.7"></a><span id="l42.7" class="difflineplus">+This extension is compatible only with Firefox 1.5 and</span>
<a href="#l42.8"></a><span id="l42.8" class="difflineplus">+above.  Most of the files in this package are based on</span>
<a href="#l42.9"></a><span id="l42.9" class="difflineplus">+the 'helloworld' extension from the Mozillazine Knowledge Base.</span>
<a href="#l42.10"></a><span id="l42.10" class="difflineplus">+</span>
<a href="#l42.11"></a><span id="l42.11" class="difflineplus">+You can build an XPI for installation by running the</span>
<a href="#l42.12"></a><span id="l42.12" class="difflineplus">+build.sh script located in this folder.  For development</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+you should do the following:</span>
<a href="#l42.14"></a><span id="l42.14" class="difflineplus">+  1. Unzip the entire contents of this package to somewhere,</span>
<a href="#l42.15"></a><span id="l42.15" class="difflineplus">+	       e.g, c:\dev or /home/user/dev</span>
<a href="#l42.16"></a><span id="l42.16" class="difflineplus">+  2. Put the full path to the folder (e.g. c:\dev\gloda on</span>
<a href="#l42.17"></a><span id="l42.17" class="difflineplus">+     Windows, /home/user/dev/gloda on Linux) in a file named</span>
<a href="#l42.18"></a><span id="l42.18" class="difflineplus">+     gloda@mozillamessaging.com and copy that file to</span>
<a href="#l42.19"></a><span id="l42.19" class="difflineplus">+     [your profile folder]\extensions\</span>
<a href="#l42.20"></a><span id="l42.20" class="difflineplus">+  3. Restart Firefox.</span>
<a href="#l42.21"></a><span id="l42.21" class="difflineplus">+</span>
<a href="#l42.22"></a><span id="l42.22" class="difflineplus">+For more information, see the Mozillazine Knowledge Base:</span>
<a href="#l42.23"></a><span id="l42.23" class="difflineplus">+http://kb.mozillazine.org/Getting_started_with_extension_development</span>
<a href="#l42.24"></a><span id="l42.24" class="difflineplus">+</span>
<a href="#l42.25"></a><span id="l42.25" class="difflineplus">+-Ted Mielczarek &lt;ted.mielczarek@gmail.com&gt;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1">new file mode 100644</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineminus">--- /dev/null</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineplus">+++ b/mailnews/db/gloda/skin/overlay.css</span>
<a href="#l43.4"></a><span id="l43.4" class="difflineat">@@ -0,0 +1,5 @@</span>
<a href="#l43.5"></a><span id="l43.5" class="difflineplus">+/* This is just an example.  You shouldn't do this. */</span>
<a href="#l43.6"></a><span id="l43.6" class="difflineplus">+#gloda-hello</span>
<a href="#l43.7"></a><span id="l43.7" class="difflineplus">+{</span>
<a href="#l43.8"></a><span id="l43.8" class="difflineplus">+  color: red ! important;</span>
<a href="#l43.9"></a><span id="l43.9" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1">new file mode 100644</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineminus">--- /dev/null</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineplus">+++ b/mailnews/db/gloda/test/Makefile.in</span>
<a href="#l44.4"></a><span id="l44.4" class="difflineat">@@ -0,0 +1,51 @@</span>
<a href="#l44.5"></a><span id="l44.5" class="difflineplus">+#</span>
<a href="#l44.6"></a><span id="l44.6" class="difflineplus">+# ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l44.7"></a><span id="l44.7" class="difflineplus">+# Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l44.8"></a><span id="l44.8" class="difflineplus">+#</span>
<a href="#l44.9"></a><span id="l44.9" class="difflineplus">+# The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l44.10"></a><span id="l44.10" class="difflineplus">+# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l44.11"></a><span id="l44.11" class="difflineplus">+# the License. You may obtain a copy of the License at</span>
<a href="#l44.12"></a><span id="l44.12" class="difflineplus">+# http://www.mozilla.org/MPL/</span>
<a href="#l44.13"></a><span id="l44.13" class="difflineplus">+#</span>
<a href="#l44.14"></a><span id="l44.14" class="difflineplus">+# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l44.15"></a><span id="l44.15" class="difflineplus">+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l44.16"></a><span id="l44.16" class="difflineplus">+# for the specific language governing rights and limitations under the</span>
<a href="#l44.17"></a><span id="l44.17" class="difflineplus">+# License.</span>
<a href="#l44.18"></a><span id="l44.18" class="difflineplus">+#</span>
<a href="#l44.19"></a><span id="l44.19" class="difflineplus">+# The Original Code is mozilla.org code.</span>
<a href="#l44.20"></a><span id="l44.20" class="difflineplus">+#</span>
<a href="#l44.21"></a><span id="l44.21" class="difflineplus">+# The Initial Developer of the Original Code is</span>
<a href="#l44.22"></a><span id="l44.22" class="difflineplus">+# Mozilla Messaging, Inc.</span>
<a href="#l44.23"></a><span id="l44.23" class="difflineplus">+#</span>
<a href="#l44.24"></a><span id="l44.24" class="difflineplus">+# Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l44.25"></a><span id="l44.25" class="difflineplus">+# the Initial Developer. All Rights Reserved.</span>
<a href="#l44.26"></a><span id="l44.26" class="difflineplus">+#</span>
<a href="#l44.27"></a><span id="l44.27" class="difflineplus">+# Contributor(s):</span>
<a href="#l44.28"></a><span id="l44.28" class="difflineplus">+#</span>
<a href="#l44.29"></a><span id="l44.29" class="difflineplus">+# Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l44.30"></a><span id="l44.30" class="difflineplus">+# either of the GNU General Public License Version 2 or later (the &quot;GPL&quot;),</span>
<a href="#l44.31"></a><span id="l44.31" class="difflineplus">+# or the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l44.32"></a><span id="l44.32" class="difflineplus">+# in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l44.33"></a><span id="l44.33" class="difflineplus">+# of those above. If you wish to allow use of your version of this file only</span>
<a href="#l44.34"></a><span id="l44.34" class="difflineplus">+# under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l44.35"></a><span id="l44.35" class="difflineplus">+# use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l44.36"></a><span id="l44.36" class="difflineplus">+# decision by deleting the provisions above and replace them with the notice</span>
<a href="#l44.37"></a><span id="l44.37" class="difflineplus">+# and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l44.38"></a><span id="l44.38" class="difflineplus">+# the provisions above, a recipient may use your version of this file under</span>
<a href="#l44.39"></a><span id="l44.39" class="difflineplus">+# the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l44.40"></a><span id="l44.40" class="difflineplus">+#</span>
<a href="#l44.41"></a><span id="l44.41" class="difflineplus">+# ***** END LICENSE BLOCK *****</span>
<a href="#l44.42"></a><span id="l44.42" class="difflineplus">+</span>
<a href="#l44.43"></a><span id="l44.43" class="difflineplus">+DEPTH		= ../../../..</span>
<a href="#l44.44"></a><span id="l44.44" class="difflineplus">+topsrcdir	= @top_srcdir@</span>
<a href="#l44.45"></a><span id="l44.45" class="difflineplus">+srcdir		= @srcdir@</span>
<a href="#l44.46"></a><span id="l44.46" class="difflineplus">+VPATH		= @srcdir@</span>
<a href="#l44.47"></a><span id="l44.47" class="difflineplus">+</span>
<a href="#l44.48"></a><span id="l44.48" class="difflineplus">+include $(DEPTH)/config/autoconf.mk</span>
<a href="#l44.49"></a><span id="l44.49" class="difflineplus">+</span>
<a href="#l44.50"></a><span id="l44.50" class="difflineplus">+# Module name for xpcshell tests.</span>
<a href="#l44.51"></a><span id="l44.51" class="difflineplus">+MODULE         = test_mailnewsglobaldb</span>
<a href="#l44.52"></a><span id="l44.52" class="difflineplus">+</span>
<a href="#l44.53"></a><span id="l44.53" class="difflineplus">+XPCSHELL_TESTS = unit</span>
<a href="#l44.54"></a><span id="l44.54" class="difflineplus">+</span>
<a href="#l44.55"></a><span id="l44.55" class="difflineplus">+include $(topsrcdir)/config/rules.mk</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1">new file mode 100644</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineminus">--- /dev/null</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineplus">+++ b/mailnews/db/gloda/test/resources/glodaTestHelper.js</span>
<a href="#l45.4"></a><span id="l45.4" class="difflineat">@@ -0,0 +1,575 @@</span>
<a href="#l45.5"></a><span id="l45.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l45.6"></a><span id="l45.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l45.7"></a><span id="l45.7" class="difflineplus">+ *</span>
<a href="#l45.8"></a><span id="l45.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l45.9"></a><span id="l45.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l45.10"></a><span id="l45.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l45.11"></a><span id="l45.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l45.12"></a><span id="l45.12" class="difflineplus">+ * </span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l45.14"></a><span id="l45.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l45.15"></a><span id="l45.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l45.16"></a><span id="l45.16" class="difflineplus">+ * License.</span>
<a href="#l45.17"></a><span id="l45.17" class="difflineplus">+ *</span>
<a href="#l45.18"></a><span id="l45.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l45.19"></a><span id="l45.19" class="difflineplus">+ *</span>
<a href="#l45.20"></a><span id="l45.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l45.21"></a><span id="l45.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l45.22"></a><span id="l45.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l45.23"></a><span id="l45.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l45.24"></a><span id="l45.24" class="difflineplus">+ *</span>
<a href="#l45.25"></a><span id="l45.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l45.26"></a><span id="l45.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l45.27"></a><span id="l45.27" class="difflineplus">+ *</span>
<a href="#l45.28"></a><span id="l45.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l45.29"></a><span id="l45.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l45.30"></a><span id="l45.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l45.31"></a><span id="l45.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l45.32"></a><span id="l45.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l45.33"></a><span id="l45.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l45.34"></a><span id="l45.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l45.35"></a><span id="l45.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l45.36"></a><span id="l45.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l45.37"></a><span id="l45.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l45.38"></a><span id="l45.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l45.39"></a><span id="l45.39" class="difflineplus">+ * </span>
<a href="#l45.40"></a><span id="l45.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l45.41"></a><span id="l45.41" class="difflineplus">+</span>
<a href="#l45.42"></a><span id="l45.42" class="difflineplus">+// -- Create the &quot;resource&quot; for &quot;gloda&quot; so our imports work.</span>
<a href="#l45.43"></a><span id="l45.43" class="difflineplus">+var ioService = Components.classes[&quot;@mozilla.org/network/io-service;1&quot;]</span>
<a href="#l45.44"></a><span id="l45.44" class="difflineplus">+                          .getService(Components.interfaces.nsIIOService);</span>
<a href="#l45.45"></a><span id="l45.45" class="difflineplus">+var resProt = ioService.getProtocolHandler(&quot;resource&quot;)</span>
<a href="#l45.46"></a><span id="l45.46" class="difflineplus">+                       .QueryInterface(Components.interfaces.nsIResProtocolHandler);</span>
<a href="#l45.47"></a><span id="l45.47" class="difflineplus">+var glodaFile = do_get_file(&quot;../mailnews/db/global&quot;);</span>
<a href="#l45.48"></a><span id="l45.48" class="difflineplus">+</span>
<a href="#l45.49"></a><span id="l45.49" class="difflineplus">+var aliasURI = ioService.newFileURI(glodaFile);</span>
<a href="#l45.50"></a><span id="l45.50" class="difflineplus">+resProt.setSubstitution(&quot;gloda&quot;, aliasURI);</span>
<a href="#l45.51"></a><span id="l45.51" class="difflineplus">+</span>
<a href="#l45.52"></a><span id="l45.52" class="difflineplus">+// -- Pull in the POP3 fake-server / local account helper code</span>
<a href="#l45.53"></a><span id="l45.53" class="difflineplus">+do_import_script(&quot;../mailnews/local/test/unit/head_maillocal.js&quot;);</span>
<a href="#l45.54"></a><span id="l45.54" class="difflineplus">+</span>
<a href="#l45.55"></a><span id="l45.55" class="difflineplus">+// -- Use our newfound imports</span>
<a href="#l45.56"></a><span id="l45.56" class="difflineplus">+Components.utils.import(&quot;resource://gloda/modules/public.js&quot;);</span>
<a href="#l45.57"></a><span id="l45.57" class="difflineplus">+Components.utils.import(&quot;resource://gloda/modules/indexer.js&quot;);</span>
<a href="#l45.58"></a><span id="l45.58" class="difflineplus">+</span>
<a href="#l45.59"></a><span id="l45.59" class="difflineplus">+/** Inject messages using a POP3 fake-server. */</span>
<a href="#l45.60"></a><span id="l45.60" class="difflineplus">+const INJECT_FAKE_SERVER = 1;</span>
<a href="#l45.61"></a><span id="l45.61" class="difflineplus">+/** Inject messages using freshly created mboxes. */</span>
<a href="#l45.62"></a><span id="l45.62" class="difflineplus">+const INJECT_MBOX = 2;</span>
<a href="#l45.63"></a><span id="l45.63" class="difflineplus">+</span>
<a href="#l45.64"></a><span id="l45.64" class="difflineplus">+/**</span>
<a href="#l45.65"></a><span id="l45.65" class="difflineplus">+ * Convert a list of synthetic messages to a form appropriate to feed to the</span>
<a href="#l45.66"></a><span id="l45.66" class="difflineplus">+ *  POP3 fakeserver.</span>
<a href="#l45.67"></a><span id="l45.67" class="difflineplus">+ */</span>
<a href="#l45.68"></a><span id="l45.68" class="difflineplus">+function _synthMessagesToFakeRep(aSynthMessages) {</span>
<a href="#l45.69"></a><span id="l45.69" class="difflineplus">+  return [{fileData: msg.toMessageString(), size: -1} for each</span>
<a href="#l45.70"></a><span id="l45.70" class="difflineplus">+          (msg in aSynthMessages)];</span>
<a href="#l45.71"></a><span id="l45.71" class="difflineplus">+}</span>
<a href="#l45.72"></a><span id="l45.72" class="difflineplus">+</span>
<a href="#l45.73"></a><span id="l45.73" class="difflineplus">+function imsInit() {</span>
<a href="#l45.74"></a><span id="l45.74" class="difflineplus">+  let ims = indexMessageState;</span>
<a href="#l45.75"></a><span id="l45.75" class="difflineplus">+</span>
<a href="#l45.76"></a><span id="l45.76" class="difflineplus">+  if (!ims.inited) {</span>
<a href="#l45.77"></a><span id="l45.77" class="difflineplus">+    // Disable new mail notifications</span>
<a href="#l45.78"></a><span id="l45.78" class="difflineplus">+    var prefSvc = Components.classes[&quot;@mozilla.org/preferences-service;1&quot;]</span>
<a href="#l45.79"></a><span id="l45.79" class="difflineplus">+      .getService(Components.interfaces.nsIPrefBranch);</span>
<a href="#l45.80"></a><span id="l45.80" class="difflineplus">+  </span>
<a href="#l45.81"></a><span id="l45.81" class="difflineplus">+    prefSvc.setBoolPref(&quot;mail.biff.play_sound&quot;, false);</span>
<a href="#l45.82"></a><span id="l45.82" class="difflineplus">+    prefSvc.setBoolPref(&quot;mail.biff.show_alert&quot;, false);</span>
<a href="#l45.83"></a><span id="l45.83" class="difflineplus">+    prefSvc.setBoolPref(&quot;mail.biff.show_tray_icon&quot;, false);</span>
<a href="#l45.84"></a><span id="l45.84" class="difflineplus">+    prefSvc.setBoolPref(&quot;mail.biff.animate_dock_icon&quot;, false);</span>
<a href="#l45.85"></a><span id="l45.85" class="difflineplus">+  </span>
<a href="#l45.86"></a><span id="l45.86" class="difflineplus">+    Gloda.addIndexerListener(messageIndexerListener.onIndexNotification);</span>
<a href="#l45.87"></a><span id="l45.87" class="difflineplus">+    ims.catchAllCollection = Gloda._wildcardCollection(Gloda.NOUN_MESSAGE);</span>
<a href="#l45.88"></a><span id="l45.88" class="difflineplus">+    ims.catchAllCollection.listener = messageCollectionListener;</span>
<a href="#l45.89"></a><span id="l45.89" class="difflineplus">+    </span>
<a href="#l45.90"></a><span id="l45.90" class="difflineplus">+    // The indexer doesn't need to worry about load; zero his rescheduling time. </span>
<a href="#l45.91"></a><span id="l45.91" class="difflineplus">+    //GlodaIndexer._indexInterval = 0;</span>
<a href="#l45.92"></a><span id="l45.92" class="difflineplus">+    </span>
<a href="#l45.93"></a><span id="l45.93" class="difflineplus">+    if (ims.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l45.94"></a><span id="l45.94" class="difflineplus">+      // set up POP3 fakeserver to feed things in...</span>
<a href="#l45.95"></a><span id="l45.95" class="difflineplus">+      [ims.daemon, ims.server] = setupServerDaemon();</span>
<a href="#l45.96"></a><span id="l45.96" class="difflineplus">+      // (this will call loadLocalMailAccount())</span>
<a href="#l45.97"></a><span id="l45.97" class="difflineplus">+      ims.incomingServer = createPop3ServerAndLocalFolders();</span>
<a href="#l45.98"></a><span id="l45.98" class="difflineplus">+  </span>
<a href="#l45.99"></a><span id="l45.99" class="difflineplus">+      ims.pop3Service = Cc[&quot;@mozilla.org/messenger/popservice;1&quot;]</span>
<a href="#l45.100"></a><span id="l45.100" class="difflineplus">+                          .getService(Ci.nsIPop3Service);</span>
<a href="#l45.101"></a><span id="l45.101" class="difflineplus">+    }</span>
<a href="#l45.102"></a><span id="l45.102" class="difflineplus">+    else if (ims.injectMechanism == INJECT_MBOX) {</span>
<a href="#l45.103"></a><span id="l45.103" class="difflineplus">+      // we need a local account to stash the mboxes under.</span>
<a href="#l45.104"></a><span id="l45.104" class="difflineplus">+      loadLocalMailAccount();</span>
<a href="#l45.105"></a><span id="l45.105" class="difflineplus">+    }</span>
<a href="#l45.106"></a><span id="l45.106" class="difflineplus">+    </span>
<a href="#l45.107"></a><span id="l45.107" class="difflineplus">+    ims.inited = true;</span>
<a href="#l45.108"></a><span id="l45.108" class="difflineplus">+  }</span>
<a href="#l45.109"></a><span id="l45.109" class="difflineplus">+}</span>
<a href="#l45.110"></a><span id="l45.110" class="difflineplus">+</span>
<a href="#l45.111"></a><span id="l45.111" class="difflineplus">+/**</span>
<a href="#l45.112"></a><span id="l45.112" class="difflineplus">+ * Have gloda index the given synthetic messages, calling the verifier function</span>
<a href="#l45.113"></a><span id="l45.113" class="difflineplus">+ *  (with accumulator field) once the message has been succesfully indexed.</span>
<a href="#l45.114"></a><span id="l45.114" class="difflineplus">+ *</span>
<a href="#l45.115"></a><span id="l45.115" class="difflineplus">+ * We use two mechanisms to do this.  One: we create an open-ended message</span>
<a href="#l45.116"></a><span id="l45.116" class="difflineplus">+ *  collection that gets notified whenever a new message hits the scene.  Two:</span>
<a href="#l45.117"></a><span id="l45.117" class="difflineplus">+ *  we register as a notification listener so that we might know when indexing</span>
<a href="#l45.118"></a><span id="l45.118" class="difflineplus">+ *  has completed.</span>
<a href="#l45.119"></a><span id="l45.119" class="difflineplus">+ *</span>
<a href="#l45.120"></a><span id="l45.120" class="difflineplus">+ * @param aSynthMessages The synthetic messages to introduce to a folder,</span>
<a href="#l45.121"></a><span id="l45.121" class="difflineplus">+ *     resulting in gloda indexing them.</span>
<a href="#l45.122"></a><span id="l45.122" class="difflineplus">+ * @param aVerifier The function to call to verify that the indexing had the</span>
<a href="#l45.123"></a><span id="l45.123" class="difflineplus">+ *     desired result.  Takes arguments aSynthMessage (the synthetic message</span>
<a href="#l45.124"></a><span id="l45.124" class="difflineplus">+ *     just indexed), aGlodaMessage (the gloda message representation of the</span>
<a href="#l45.125"></a><span id="l45.125" class="difflineplus">+ *     indexed message), and aPreviousResult (the value last returned by the</span>
<a href="#l45.126"></a><span id="l45.126" class="difflineplus">+ *     verifier function for this given set of messages, or undefined if it is</span>
<a href="#l45.127"></a><span id="l45.127" class="difflineplus">+ *     the first message.)</span>
<a href="#l45.128"></a><span id="l45.128" class="difflineplus">+ * @param aOnDone The function to call when we complete processing this set of</span>
<a href="#l45.129"></a><span id="l45.129" class="difflineplus">+ *     messages.</span>
<a href="#l45.130"></a><span id="l45.130" class="difflineplus">+ */</span>
<a href="#l45.131"></a><span id="l45.131" class="difflineplus">+function indexMessages(aSynthMessages, aVerifier, aOnDone) {</span>
<a href="#l45.132"></a><span id="l45.132" class="difflineplus">+  let ims = indexMessageState;</span>
<a href="#l45.133"></a><span id="l45.133" class="difflineplus">+  </span>
<a href="#l45.134"></a><span id="l45.134" class="difflineplus">+  ims.inputMessages = aSynthMessages;</span>
<a href="#l45.135"></a><span id="l45.135" class="difflineplus">+  ims.glodaMessages = [];</span>
<a href="#l45.136"></a><span id="l45.136" class="difflineplus">+  ims.verifier = aVerifier;</span>
<a href="#l45.137"></a><span id="l45.137" class="difflineplus">+  ims.previousValue = undefined;</span>
<a href="#l45.138"></a><span id="l45.138" class="difflineplus">+  ims.onDone = aOnDone;</span>
<a href="#l45.139"></a><span id="l45.139" class="difflineplus">+</span>
<a href="#l45.140"></a><span id="l45.140" class="difflineplus">+  if (ims.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l45.141"></a><span id="l45.141" class="difflineplus">+    ims.daemon.setMessages(_synthMessagesToFakeRep(aSynthMessages));</span>
<a href="#l45.142"></a><span id="l45.142" class="difflineplus">+    do_timeout(0, &quot;driveFakeServer();&quot;);</span>
<a href="#l45.143"></a><span id="l45.143" class="difflineplus">+  }</span>
<a href="#l45.144"></a><span id="l45.144" class="difflineplus">+  else if (ims.injectMechanism == INJECT_MBOX) {</span>
<a href="#l45.145"></a><span id="l45.145" class="difflineplus">+    ims.mboxName = &quot;injecty&quot; + ims.nextMboxNumber++;</span>
<a href="#l45.146"></a><span id="l45.146" class="difflineplus">+    writeMessagesToMbox(aSynthMessages, gProfileDir,</span>
<a href="#l45.147"></a><span id="l45.147" class="difflineplus">+                        &quot;Mail/Local Folders/&quot; + ims.mboxName);</span>
<a href="#l45.148"></a><span id="l45.148" class="difflineplus">+</span>
<a href="#l45.149"></a><span id="l45.149" class="difflineplus">+    let rootFolder = gLocalIncomingServer.rootMsgFolder;</span>
<a href="#l45.150"></a><span id="l45.150" class="difflineplus">+    let subFolder = rootFolder.addSubfolder(ims.mboxName);</span>
<a href="#l45.151"></a><span id="l45.151" class="difflineplus">+</span>
<a href="#l45.152"></a><span id="l45.152" class="difflineplus">+    // we need to explicitly kick off indexing...</span>
<a href="#l45.153"></a><span id="l45.153" class="difflineplus">+    updateFolderAndNotify(subFolder, function() {</span>
<a href="#l45.154"></a><span id="l45.154" class="difflineplus">+      GlodaIndexer.indexFolder(subFolder);</span>
<a href="#l45.155"></a><span id="l45.155" class="difflineplus">+    });</span>
<a href="#l45.156"></a><span id="l45.156" class="difflineplus">+  }</span>
<a href="#l45.157"></a><span id="l45.157" class="difflineplus">+</span>
<a href="#l45.158"></a><span id="l45.158" class="difflineplus">+}</span>
<a href="#l45.159"></a><span id="l45.159" class="difflineplus">+</span>
<a href="#l45.160"></a><span id="l45.160" class="difflineplus">+function injectMessagesUsing(aInjectMechanism) {</span>
<a href="#l45.161"></a><span id="l45.161" class="difflineplus">+  indexMessageState.injectMechanism = aInjectMechanism;</span>
<a href="#l45.162"></a><span id="l45.162" class="difflineplus">+}</span>
<a href="#l45.163"></a><span id="l45.163" class="difflineplus">+</span>
<a href="#l45.164"></a><span id="l45.164" class="difflineplus">+var indexMessageState = {</span>
<a href="#l45.165"></a><span id="l45.165" class="difflineplus">+  /** have we been initialized (hooked listeners, etc.) */</span>
<a href="#l45.166"></a><span id="l45.166" class="difflineplus">+  inited: false,</span>
<a href="#l45.167"></a><span id="l45.167" class="difflineplus">+  /** our catch-all message collection that nets us all messages passing by */</span>
<a href="#l45.168"></a><span id="l45.168" class="difflineplus">+  catchAllCollection: null,</span>
<a href="#l45.169"></a><span id="l45.169" class="difflineplus">+  /** the set of synthetic messages passed in to indexMessages */</span>
<a href="#l45.170"></a><span id="l45.170" class="difflineplus">+  inputMessages: null,</span>
<a href="#l45.171"></a><span id="l45.171" class="difflineplus">+  /** the gloda messages resulting from indexing corresponding to input ones */</span>
<a href="#l45.172"></a><span id="l45.172" class="difflineplus">+  glodaMessages: null,</span>
<a href="#l45.173"></a><span id="l45.173" class="difflineplus">+  /** the user-specified accumulate-style verification func */</span>
<a href="#l45.174"></a><span id="l45.174" class="difflineplus">+  verifier: null,</span>
<a href="#l45.175"></a><span id="l45.175" class="difflineplus">+  /** the result of the last call to the verification function */</span>
<a href="#l45.176"></a><span id="l45.176" class="difflineplus">+  previousValue: undefined,</span>
<a href="#l45.177"></a><span id="l45.177" class="difflineplus">+  /** the function to call once we have indexed all the messages */</span>
<a href="#l45.178"></a><span id="l45.178" class="difflineplus">+  onDone: null,</span>
<a href="#l45.179"></a><span id="l45.179" class="difflineplus">+  </span>
<a href="#l45.180"></a><span id="l45.180" class="difflineplus">+  injectMechanism: INJECT_FAKE_SERVER,</span>
<a href="#l45.181"></a><span id="l45.181" class="difflineplus">+  </span>
<a href="#l45.182"></a><span id="l45.182" class="difflineplus">+  /* === Fake Server State === */</span>
<a href="#l45.183"></a><span id="l45.183" class="difflineplus">+  /** nsMailServer instance with POP3_RFC1939 handler */</span>
<a href="#l45.184"></a><span id="l45.184" class="difflineplus">+  server: null,</span>
<a href="#l45.185"></a><span id="l45.185" class="difflineplus">+  serverStarted: false,</span>
<a href="#l45.186"></a><span id="l45.186" class="difflineplus">+  /** pop3Daemon instance */</span>
<a href="#l45.187"></a><span id="l45.187" class="difflineplus">+  daemon: null,</span>
<a href="#l45.188"></a><span id="l45.188" class="difflineplus">+  /** incoming pop3 server */</span>
<a href="#l45.189"></a><span id="l45.189" class="difflineplus">+  incomingServer: null,</span>
<a href="#l45.190"></a><span id="l45.190" class="difflineplus">+  /** pop3 service */</span>
<a href="#l45.191"></a><span id="l45.191" class="difflineplus">+  pop3Service: null,</span>
<a href="#l45.192"></a><span id="l45.192" class="difflineplus">+</span>
<a href="#l45.193"></a><span id="l45.193" class="difflineplus">+  /* === MBox Injection State === */</span>
<a href="#l45.194"></a><span id="l45.194" class="difflineplus">+  nextMboxNumber: 0,</span>
<a href="#l45.195"></a><span id="l45.195" class="difflineplus">+  mboxName: null,</span>
<a href="#l45.196"></a><span id="l45.196" class="difflineplus">+</span>
<a href="#l45.197"></a><span id="l45.197" class="difflineplus">+  /**</span>
<a href="#l45.198"></a><span id="l45.198" class="difflineplus">+   * Listener to handle the completion of the POP3 message retrieval (one way or</span>
<a href="#l45.199"></a><span id="l45.199" class="difflineplus">+   *  the other.)</span>
<a href="#l45.200"></a><span id="l45.200" class="difflineplus">+   */</span>
<a href="#l45.201"></a><span id="l45.201" class="difflineplus">+  urlListener: {</span>
<a href="#l45.202"></a><span id="l45.202" class="difflineplus">+    OnStartRunningUrl: function (url) {</span>
<a href="#l45.203"></a><span id="l45.203" class="difflineplus">+    },</span>
<a href="#l45.204"></a><span id="l45.204" class="difflineplus">+    OnStopRunningUrl: function (url, result) {</span>
<a href="#l45.205"></a><span id="l45.205" class="difflineplus">+      let ims = indexMessageState;</span>
<a href="#l45.206"></a><span id="l45.206" class="difflineplus">+      try {</span>
<a href="#l45.207"></a><span id="l45.207" class="difflineplus">+        // this returns a log of the transaction, but we don't care.  (we</span>
<a href="#l45.208"></a><span id="l45.208" class="difflineplus">+        //  assume that the POP3 stuff works.)</span>
<a href="#l45.209"></a><span id="l45.209" class="difflineplus">+        ims.server.playTransaction();</span>
<a href="#l45.210"></a><span id="l45.210" class="difflineplus">+        // doesn't hurt to break if the POP3 broke though...</span>
<a href="#l45.211"></a><span id="l45.211" class="difflineplus">+        do_check_eq(result, 0);</span>
<a href="#l45.212"></a><span id="l45.212" class="difflineplus">+      }</span>
<a href="#l45.213"></a><span id="l45.213" class="difflineplus">+      catch (e) {</span>
<a href="#l45.214"></a><span id="l45.214" class="difflineplus">+        // If we have an error, clean up nicely before we throw it.</span>
<a href="#l45.215"></a><span id="l45.215" class="difflineplus">+        ims.server.stop();</span>
<a href="#l45.216"></a><span id="l45.216" class="difflineplus">+  </span>
<a href="#l45.217"></a><span id="l45.217" class="difflineplus">+        var thread = gThreadManager.currentThread;</span>
<a href="#l45.218"></a><span id="l45.218" class="difflineplus">+        while (thread.hasPendingEvents())</span>
<a href="#l45.219"></a><span id="l45.219" class="difflineplus">+          thread.processNextEvent(true);</span>
<a href="#l45.220"></a><span id="l45.220" class="difflineplus">+  </span>
<a href="#l45.221"></a><span id="l45.221" class="difflineplus">+        do_throw(e);</span>
<a href="#l45.222"></a><span id="l45.222" class="difflineplus">+      }</span>
<a href="#l45.223"></a><span id="l45.223" class="difflineplus">+      </span>
<a href="#l45.224"></a><span id="l45.224" class="difflineplus">+      // we are expecting the gloda indexer to receive some notification as the</span>
<a href="#l45.225"></a><span id="l45.225" class="difflineplus">+      //  result of the new messages showing up, so we don't actually need to</span>
<a href="#l45.226"></a><span id="l45.226" class="difflineplus">+      //  do anything here.</span>
<a href="#l45.227"></a><span id="l45.227" class="difflineplus">+    }</span>
<a href="#l45.228"></a><span id="l45.228" class="difflineplus">+  }</span>
<a href="#l45.229"></a><span id="l45.229" class="difflineplus">+};</span>
<a href="#l45.230"></a><span id="l45.230" class="difflineplus">+</span>
<a href="#l45.231"></a><span id="l45.231" class="difflineplus">+</span>
<a href="#l45.232"></a><span id="l45.232" class="difflineplus">+/**</span>
<a href="#l45.233"></a><span id="l45.233" class="difflineplus">+ * Indicate that we should expect some modified messages to be indexed.</span>
<a href="#l45.234"></a><span id="l45.234" class="difflineplus">+ * </span>
<a href="#l45.235"></a><span id="l45.235" class="difflineplus">+ * @param aMessages The messages that will be modified and we should expect</span>
<a href="#l45.236"></a><span id="l45.236" class="difflineplus">+ *   notifications about.  We currently don't do anything with these other than</span>
<a href="#l45.237"></a><span id="l45.237" class="difflineplus">+ *   count them, so pass whatever you want and it will be the 'source message'</span>
<a href="#l45.238"></a><span id="l45.238" class="difflineplus">+ *   (1st argument) to your verifier function.</span>
<a href="#l45.239"></a><span id="l45.239" class="difflineplus">+ * @param aVerifier See indexMessage's aVerifier argument.</span>
<a href="#l45.240"></a><span id="l45.240" class="difflineplus">+ * @param aDone The (optional) callback to call on completion.</span>
<a href="#l45.241"></a><span id="l45.241" class="difflineplus">+ */</span>
<a href="#l45.242"></a><span id="l45.242" class="difflineplus">+function expectModifiedMessages(aMessages, aVerifier, aOnDone) {</span>
<a href="#l45.243"></a><span id="l45.243" class="difflineplus">+  let ims = indexMessageState;</span>
<a href="#l45.244"></a><span id="l45.244" class="difflineplus">+  </span>
<a href="#l45.245"></a><span id="l45.245" class="difflineplus">+  ims.inputMessages = aMessages;</span>
<a href="#l45.246"></a><span id="l45.246" class="difflineplus">+  ims.glodaMessages = [];</span>
<a href="#l45.247"></a><span id="l45.247" class="difflineplus">+  ims.verifier = aVerifier;</span>
<a href="#l45.248"></a><span id="l45.248" class="difflineplus">+  ims.previousValue = undefined;</span>
<a href="#l45.249"></a><span id="l45.249" class="difflineplus">+  ims.onDone = aOnDone;</span>
<a href="#l45.250"></a><span id="l45.250" class="difflineplus">+  </span>
<a href="#l45.251"></a><span id="l45.251" class="difflineplus">+  // we don't actually need to do anything.  the caller is going to be</span>
<a href="#l45.252"></a><span id="l45.252" class="difflineplus">+  //  triggering a notification which will spur the indexer into action.  the</span>
<a href="#l45.253"></a><span id="l45.253" class="difflineplus">+  //  indexer uses its own scheduling mechanism to drive itself, so as long</span>
<a href="#l45.254"></a><span id="l45.254" class="difflineplus">+  //  as an event loop is active, we're good.</span>
<a href="#l45.255"></a><span id="l45.255" class="difflineplus">+}</span>
<a href="#l45.256"></a><span id="l45.256" class="difflineplus">+</span>
<a href="#l45.257"></a><span id="l45.257" class="difflineplus">+/**</span>
<a href="#l45.258"></a><span id="l45.258" class="difflineplus">+ * Perform the mail fetching, seeing it through to completion.</span>
<a href="#l45.259"></a><span id="l45.259" class="difflineplus">+ */</span>
<a href="#l45.260"></a><span id="l45.260" class="difflineplus">+function driveFakeServer() {</span>
<a href="#l45.261"></a><span id="l45.261" class="difflineplus">+  let ims = indexMessageState;</span>
<a href="#l45.262"></a><span id="l45.262" class="difflineplus">+dump(&quot;&gt;&gt;&gt; enter driveFakeServer\n&quot;);</span>
<a href="#l45.263"></a><span id="l45.263" class="difflineplus">+  // Handle the server in a try/catch/finally loop so that we always will stop</span>
<a href="#l45.264"></a><span id="l45.264" class="difflineplus">+  // the server if something fails.</span>
<a href="#l45.265"></a><span id="l45.265" class="difflineplus">+  try {</span>
<a href="#l45.266"></a><span id="l45.266" class="difflineplus">+    if (!(ims.serverStarted)) {</span>
<a href="#l45.267"></a><span id="l45.267" class="difflineplus">+      dump(&quot;  starting fake server\n&quot;);</span>
<a href="#l45.268"></a><span id="l45.268" class="difflineplus">+      ims.server.start(POP3_PORT);</span>
<a href="#l45.269"></a><span id="l45.269" class="difflineplus">+      ims.serverStarted = true;</span>
<a href="#l45.270"></a><span id="l45.270" class="difflineplus">+    }</span>
<a href="#l45.271"></a><span id="l45.271" class="difflineplus">+    else {</span>
<a href="#l45.272"></a><span id="l45.272" class="difflineplus">+      dump(&quot;  resetting fake server\n&quot;);</span>
<a href="#l45.273"></a><span id="l45.273" class="difflineplus">+      ims.server.resetTest();</span>
<a href="#l45.274"></a><span id="l45.274" class="difflineplus">+    }</span>
<a href="#l45.275"></a><span id="l45.275" class="difflineplus">+    </span>
<a href="#l45.276"></a><span id="l45.276" class="difflineplus">+    // Now get the mail</span>
<a href="#l45.277"></a><span id="l45.277" class="difflineplus">+    dump(&quot;  issuing GetNewMail\n&quot;);</span>
<a href="#l45.278"></a><span id="l45.278" class="difflineplus">+    ims.pop3Service.GetNewMail(null, ims.urlListener, gLocalInboxFolder,</span>
<a href="#l45.279"></a><span id="l45.279" class="difflineplus">+                               ims.incomingServer);</span>
<a href="#l45.280"></a><span id="l45.280" class="difflineplus">+    dump(&quot;  issuing performTest\n&quot;)</span>
<a href="#l45.281"></a><span id="l45.281" class="difflineplus">+    ims.server.performTest();</span>
<a href="#l45.282"></a><span id="l45.282" class="difflineplus">+  }</span>
<a href="#l45.283"></a><span id="l45.283" class="difflineplus">+  catch (e) {</span>
<a href="#l45.284"></a><span id="l45.284" class="difflineplus">+    ims.server.stop();</span>
<a href="#l45.285"></a><span id="l45.285" class="difflineplus">+    do_throw(e);</span>
<a href="#l45.286"></a><span id="l45.286" class="difflineplus">+  }</span>
<a href="#l45.287"></a><span id="l45.287" class="difflineplus">+  finally {</span>
<a href="#l45.288"></a><span id="l45.288" class="difflineplus">+    dump(&quot;  draining events\n&quot;);</span>
<a href="#l45.289"></a><span id="l45.289" class="difflineplus">+    var thread = gThreadManager.currentThread;</span>
<a href="#l45.290"></a><span id="l45.290" class="difflineplus">+    while (thread.hasPendingEvents())</span>
<a href="#l45.291"></a><span id="l45.291" class="difflineplus">+      thread.processNextEvent(true);</span>
<a href="#l45.292"></a><span id="l45.292" class="difflineplus">+  }</span>
<a href="#l45.293"></a><span id="l45.293" class="difflineplus">+dump(&quot;&lt;&lt;&lt; exit driveFakeServer\n&quot;);</span>
<a href="#l45.294"></a><span id="l45.294" class="difflineplus">+}</span>
<a href="#l45.295"></a><span id="l45.295" class="difflineplus">+</span>
<a href="#l45.296"></a><span id="l45.296" class="difflineplus">+/**</span>
<a href="#l45.297"></a><span id="l45.297" class="difflineplus">+ * Tear down the fake server.  This is very important to avoid things getting</span>
<a href="#l45.298"></a><span id="l45.298" class="difflineplus">+ *  upset during shutdown.  (Namely, XPConnect will get mad about running in</span>
<a href="#l45.299"></a><span id="l45.299" class="difflineplus">+ *  a context without &quot;Components&quot; defined.)</span>
<a href="#l45.300"></a><span id="l45.300" class="difflineplus">+ */</span>
<a href="#l45.301"></a><span id="l45.301" class="difflineplus">+function killFakeServer() {</span>
<a href="#l45.302"></a><span id="l45.302" class="difflineplus">+  let ims = indexMessageState;</span>
<a href="#l45.303"></a><span id="l45.303" class="difflineplus">+</span>
<a href="#l45.304"></a><span id="l45.304" class="difflineplus">+  ims.incomingServer.closeCachedConnections();</span>
<a href="#l45.305"></a><span id="l45.305" class="difflineplus">+  </span>
<a href="#l45.306"></a><span id="l45.306" class="difflineplus">+  // No more tests, let everything finish</span>
<a href="#l45.307"></a><span id="l45.307" class="difflineplus">+  ims.server.stop();</span>
<a href="#l45.308"></a><span id="l45.308" class="difflineplus">+  </span>
<a href="#l45.309"></a><span id="l45.309" class="difflineplus">+  var thread = gThreadManager.currentThread;</span>
<a href="#l45.310"></a><span id="l45.310" class="difflineplus">+  while (thread.hasPendingEvents())</span>
<a href="#l45.311"></a><span id="l45.311" class="difflineplus">+    thread.processNextEvent(true);</span>
<a href="#l45.312"></a><span id="l45.312" class="difflineplus">+}</span>
<a href="#l45.313"></a><span id="l45.313" class="difflineplus">+</span>
<a href="#l45.314"></a><span id="l45.314" class="difflineplus">+/**</span>
<a href="#l45.315"></a><span id="l45.315" class="difflineplus">+ * Our catch-all collection listener.  Any time a new message gets indexed,</span>
<a href="#l45.316"></a><span id="l45.316" class="difflineplus">+ *  we should receive an onItemsAdded call.  Any time an existing message</span>
<a href="#l45.317"></a><span id="l45.317" class="difflineplus">+ *  gets reindexed, we should receive an onItemsModified call.  Any time an</span>
<a href="#l45.318"></a><span id="l45.318" class="difflineplus">+ *  existing message actually gets purged from the system, we should receive</span>
<a href="#l45.319"></a><span id="l45.319" class="difflineplus">+ *  an onItemsRemoved call.</span>
<a href="#l45.320"></a><span id="l45.320" class="difflineplus">+ */</span>
<a href="#l45.321"></a><span id="l45.321" class="difflineplus">+var messageCollectionListener = {</span>
<a href="#l45.322"></a><span id="l45.322" class="difflineplus">+  onItemsAdded: function(aItems) {</span>
<a href="#l45.323"></a><span id="l45.323" class="difflineplus">+    dump(&quot;onItemsAdded\n&quot;);</span>
<a href="#l45.324"></a><span id="l45.324" class="difflineplus">+    let ims = indexMessageState;</span>
<a href="#l45.325"></a><span id="l45.325" class="difflineplus">+    ims.glodaMessages = ims.glodaMessages.concat(aItems);</span>
<a href="#l45.326"></a><span id="l45.326" class="difflineplus">+  },</span>
<a href="#l45.327"></a><span id="l45.327" class="difflineplus">+  </span>
<a href="#l45.328"></a><span id="l45.328" class="difflineplus">+  onItemsModified: function(aItems) {</span>
<a href="#l45.329"></a><span id="l45.329" class="difflineplus">+    dump(&quot;onItemsModified\n&quot;);</span>
<a href="#l45.330"></a><span id="l45.330" class="difflineplus">+    let ims = indexMessageState;</span>
<a href="#l45.331"></a><span id="l45.331" class="difflineplus">+    ims.glodaMessages = ims.glodaMessages.concat(aItems);</span>
<a href="#l45.332"></a><span id="l45.332" class="difflineplus">+  },</span>
<a href="#l45.333"></a><span id="l45.333" class="difflineplus">+  </span>
<a href="#l45.334"></a><span id="l45.334" class="difflineplus">+  onItemsRemoved: function(aItems) {</span>
<a href="#l45.335"></a><span id="l45.335" class="difflineplus">+  }</span>
<a href="#l45.336"></a><span id="l45.336" class="difflineplus">+};</span>
<a href="#l45.337"></a><span id="l45.337" class="difflineplus">+</span>
<a href="#l45.338"></a><span id="l45.338" class="difflineplus">+/**</span>
<a href="#l45.339"></a><span id="l45.339" class="difflineplus">+ * Gloda indexer listener, used to know when all active indexing jobs have</span>
<a href="#l45.340"></a><span id="l45.340" class="difflineplus">+ *  completed so that we can try and process all the things that should have</span>
<a href="#l45.341"></a><span id="l45.341" class="difflineplus">+ *  been processed.</span>
<a href="#l45.342"></a><span id="l45.342" class="difflineplus">+ */</span>
<a href="#l45.343"></a><span id="l45.343" class="difflineplus">+var messageIndexerListener = {</span>
<a href="#l45.344"></a><span id="l45.344" class="difflineplus">+  onIndexNotification: function(aStatus, aPrettyName, aJobIndex, aJobTotal,</span>
<a href="#l45.345"></a><span id="l45.345" class="difflineplus">+                                aJobItemIndex, aJobItemGoal) {</span>
<a href="#l45.346"></a><span id="l45.346" class="difflineplus">+    // we only care if indexing has just completed...</span>
<a href="#l45.347"></a><span id="l45.347" class="difflineplus">+    if (!GlodaIndexer.indexing) {</span>
<a href="#l45.348"></a><span id="l45.348" class="difflineplus">+      let ims = indexMessageState;</span>
<a href="#l45.349"></a><span id="l45.349" class="difflineplus">+      </span>
<a href="#l45.350"></a><span id="l45.350" class="difflineplus">+      // this is just the synthetic notification if inputMessages is null</span>
<a href="#l45.351"></a><span id="l45.351" class="difflineplus">+      if (ims.inputMessages === null)</span>
<a href="#l45.352"></a><span id="l45.352" class="difflineplus">+       return;</span>
<a href="#l45.353"></a><span id="l45.353" class="difflineplus">+</span>
<a href="#l45.354"></a><span id="l45.354" class="difflineplus">+      // if we haven't seen all the messages we should see, assume that the</span>
<a href="#l45.355"></a><span id="l45.355" class="difflineplus">+      //  rest are on their way, and are just coming in a subsequent job...</span>
<a href="#l45.356"></a><span id="l45.356" class="difflineplus">+      // (Also, the first time we register our listener, we will get a synthetic</span>
<a href="#l45.357"></a><span id="l45.357" class="difflineplus">+      //  idle status; at least if the indexer is idle.)</span>
<a href="#l45.358"></a><span id="l45.358" class="difflineplus">+      if (ims.glodaMessages.length &lt; ims.inputMessages.length) {</span>
<a href="#l45.359"></a><span id="l45.359" class="difflineplus">+        return;</span>
<a href="#l45.360"></a><span id="l45.360" class="difflineplus">+      }</span>
<a href="#l45.361"></a><span id="l45.361" class="difflineplus">+    </span>
<a href="#l45.362"></a><span id="l45.362" class="difflineplus">+      // call the verifier.  (we expect them to generate an exception if the</span>
<a href="#l45.363"></a><span id="l45.363" class="difflineplus">+      //  verification fails, using do_check_*/do_throw; we don't care about</span>
<a href="#l45.364"></a><span id="l45.364" class="difflineplus">+      //  the return value except to propagate forward to subsequent calls.)</span>
<a href="#l45.365"></a><span id="l45.365" class="difflineplus">+      for (let iMessage=0; iMessage &lt; ims.inputMessages.length; iMessage++) {</span>
<a href="#l45.366"></a><span id="l45.366" class="difflineplus">+        if (ims.verifier)</span>
<a href="#l45.367"></a><span id="l45.367" class="difflineplus">+          ims.previousValue = ims.verifier(ims.inputMessages[iMessage],</span>
<a href="#l45.368"></a><span id="l45.368" class="difflineplus">+                                           ims.glodaMessages[iMessage],</span>
<a href="#l45.369"></a><span id="l45.369" class="difflineplus">+                                           ims.previousValue);</span>
<a href="#l45.370"></a><span id="l45.370" class="difflineplus">+      }</span>
<a href="#l45.371"></a><span id="l45.371" class="difflineplus">+</span>
<a href="#l45.372"></a><span id="l45.372" class="difflineplus">+      if (ims.onDone)</span>
<a href="#l45.373"></a><span id="l45.373" class="difflineplus">+        ims.onDone();</span>
<a href="#l45.374"></a><span id="l45.374" class="difflineplus">+    }</span>
<a href="#l45.375"></a><span id="l45.375" class="difflineplus">+  }</span>
<a href="#l45.376"></a><span id="l45.376" class="difflineplus">+};</span>
<a href="#l45.377"></a><span id="l45.377" class="difflineplus">+</span>
<a href="#l45.378"></a><span id="l45.378" class="difflineplus">+/**</span>
<a href="#l45.379"></a><span id="l45.379" class="difflineplus">+ * Given a function that generates a set of synthetic messages, feed those</span>
<a href="#l45.380"></a><span id="l45.380" class="difflineplus">+ *  messages to gloda to be indexed, verifying the resulting indexed messages</span>
<a href="#l45.381"></a><span id="l45.381" class="difflineplus">+ *  have the desired properties by calling the provided verification function.</span>
<a href="#l45.382"></a><span id="l45.382" class="difflineplus">+ * This process is executed once for each possible permutation of observation</span>
<a href="#l45.383"></a><span id="l45.383" class="difflineplus">+ *  of the synthetic messages.  (Well, we cap it; brute-force test your logic</span>
<a href="#l45.384"></a><span id="l45.384" class="difflineplus">+ *  on your own time; you should really only be feeding us minimal scenarios.)</span>
<a href="#l45.385"></a><span id="l45.385" class="difflineplus">+ *</span>
<a href="#l45.386"></a><span id="l45.386" class="difflineplus">+ * @param aScenarioMaker A function that, when called, will generate a series</span>
<a href="#l45.387"></a><span id="l45.387" class="difflineplus">+ *   of SyntheticMessage instances.  Each call to this method should generate</span>
<a href="#l45.388"></a><span id="l45.388" class="difflineplus">+ *   a new set of conceptually equivalent, but not identical, messages.  This</span>
<a href="#l45.389"></a><span id="l45.389" class="difflineplus">+ *   allows us to process without having to reset our state back to nothing each</span>
<a href="#l45.390"></a><span id="l45.390" class="difflineplus">+ *   time.  (This is more to try and make sure we run the system with a 'dirty'</span>
<a href="#l45.391"></a><span id="l45.391" class="difflineplus">+ *   state than a bid for efficiency.)</span>
<a href="#l45.392"></a><span id="l45.392" class="difflineplus">+ * @param aVerifier Verifier function, same signature/intent as the same</span>
<a href="#l45.393"></a><span id="l45.393" class="difflineplus">+ *   argument for indexMessages (who we internally end up calling).</span>
<a href="#l45.394"></a><span id="l45.394" class="difflineplus">+ * @param aOnDone The (optional) function to call when we have finished</span>
<a href="#l45.395"></a><span id="l45.395" class="difflineplus">+ *   processing.  Note that this handler is only called when there are no</span>
<a href="#l45.396"></a><span id="l45.396" class="difflineplus">+ *   additional jobs to be queued.  So if you queue up 5 jobs, you can pass in</span>
<a href="#l45.397"></a><span id="l45.397" class="difflineplus">+ *   the same aOnDone handler for all of them, confident in the knowledge that</span>
<a href="#l45.398"></a><span id="l45.398" class="difflineplus">+ *   only the last job will result in the done handler being called.  </span>
<a href="#l45.399"></a><span id="l45.399" class="difflineplus">+ */</span>
<a href="#l45.400"></a><span id="l45.400" class="difflineplus">+function indexAndPermuteMessages(aScenarioMaker, aVerifier, aOnDone) {</span>
<a href="#l45.401"></a><span id="l45.401" class="difflineplus">+  let mis = multiIndexState;</span>
<a href="#l45.402"></a><span id="l45.402" class="difflineplus">+  </span>
<a href="#l45.403"></a><span id="l45.403" class="difflineplus">+  mis.queue.push([aScenarioMaker, aVerifier, aOnDone]);</span>
<a href="#l45.404"></a><span id="l45.404" class="difflineplus">+</span>
<a href="#l45.405"></a><span id="l45.405" class="difflineplus">+  // start processing it immediately if we're not doing anything...</span>
<a href="#l45.406"></a><span id="l45.406" class="difflineplus">+  if (!mis.active)</span>
<a href="#l45.407"></a><span id="l45.407" class="difflineplus">+    _multiIndexNext();</span>
<a href="#l45.408"></a><span id="l45.408" class="difflineplus">+}</span>
<a href="#l45.409"></a><span id="l45.409" class="difflineplus">+</span>
<a href="#l45.410"></a><span id="l45.410" class="difflineplus">+/**</span>
<a href="#l45.411"></a><span id="l45.411" class="difflineplus">+ * Helper function that does the actual multi-indexing work for each call</span>
<a href="#l45.412"></a><span id="l45.412" class="difflineplus">+ *  made to indexAndPermuteMessages.  Since those calls can stack, the arguments</span>
<a href="#l45.413"></a><span id="l45.413" class="difflineplus">+ *  are queued, and we process them when there is no (longer) a current job.</span>
<a href="#l45.414"></a><span id="l45.414" class="difflineplus">+ *  _permutationIndexed handles the work of trying the subsequent permutations</span>
<a href="#l45.415"></a><span id="l45.415" class="difflineplus">+ *  for each job we de-queue and initiate.</span>
<a href="#l45.416"></a><span id="l45.416" class="difflineplus">+ */</span>
<a href="#l45.417"></a><span id="l45.417" class="difflineplus">+function _multiIndexNext() {</span>
<a href="#l45.418"></a><span id="l45.418" class="difflineplus">+  let mis = multiIndexState;</span>
<a href="#l45.419"></a><span id="l45.419" class="difflineplus">+  </span>
<a href="#l45.420"></a><span id="l45.420" class="difflineplus">+  if (mis.queue.length) {</span>
<a href="#l45.421"></a><span id="l45.421" class="difflineplus">+    mis.active = true;</span>
<a href="#l45.422"></a><span id="l45.422" class="difflineplus">+    </span>
<a href="#l45.423"></a><span id="l45.423" class="difflineplus">+    let [aScenarioMaker, aVerifier, aOnDone] = mis.queue.shift();</span>
<a href="#l45.424"></a><span id="l45.424" class="difflineplus">+  </span>
<a href="#l45.425"></a><span id="l45.425" class="difflineplus">+    let firstSet = aScenarioMaker();</span>
<a href="#l45.426"></a><span id="l45.426" class="difflineplus">+    </span>
<a href="#l45.427"></a><span id="l45.427" class="difflineplus">+    mis.scenarioMaker = aScenarioMaker;</span>
<a href="#l45.428"></a><span id="l45.428" class="difflineplus">+    mis.verifier = aVerifier;</span>
<a href="#l45.429"></a><span id="l45.429" class="difflineplus">+    // 32 permutations is probably too generous, not to mention an odd choice.</span>
<a href="#l45.430"></a><span id="l45.430" class="difflineplus">+    mis.numPermutations = Math.min(factorial(firstSet.length), 32);</span>
<a href="#l45.431"></a><span id="l45.431" class="difflineplus">+    mis.nextPermutationId = 1;</span>
<a href="#l45.432"></a><span id="l45.432" class="difflineplus">+    </span>
<a href="#l45.433"></a><span id="l45.433" class="difflineplus">+    mis.onDone = aOnDone;</span>
<a href="#l45.434"></a><span id="l45.434" class="difflineplus">+    </span>
<a href="#l45.435"></a><span id="l45.435" class="difflineplus">+    indexMessages(firstSet, mis.verifier, _permutationIndexed);</span>
<a href="#l45.436"></a><span id="l45.436" class="difflineplus">+  }</span>
<a href="#l45.437"></a><span id="l45.437" class="difflineplus">+  else {</span>
<a href="#l45.438"></a><span id="l45.438" class="difflineplus">+    mis.active = false;</span>
<a href="#l45.439"></a><span id="l45.439" class="difflineplus">+    if (mis.onDone)</span>
<a href="#l45.440"></a><span id="l45.440" class="difflineplus">+      mis.onDone();</span>
<a href="#l45.441"></a><span id="l45.441" class="difflineplus">+  }</span>
<a href="#l45.442"></a><span id="l45.442" class="difflineplus">+}</span>
<a href="#l45.443"></a><span id="l45.443" class="difflineplus">+</span>
<a href="#l45.444"></a><span id="l45.444" class="difflineplus">+/**</span>
<a href="#l45.445"></a><span id="l45.445" class="difflineplus">+ * The onDone handler for indexAndPermuteMessages/_multiIndexNext's use of</span>
<a href="#l45.446"></a><span id="l45.446" class="difflineplus">+ *  indexMessages under the hood.  Generates and initiates processing of then</span>
<a href="#l45.447"></a><span id="l45.447" class="difflineplus">+ *  next permutation if any remain, otherwise deferring to _multiIndexNext to</span>
<a href="#l45.448"></a><span id="l45.448" class="difflineplus">+ *  de-queue the next call/job or close up shop. </span>
<a href="#l45.449"></a><span id="l45.449" class="difflineplus">+ */</span>
<a href="#l45.450"></a><span id="l45.450" class="difflineplus">+function _permutationIndexed() {</span>
<a href="#l45.451"></a><span id="l45.451" class="difflineplus">+  let mis = multiIndexState;</span>
<a href="#l45.452"></a><span id="l45.452" class="difflineplus">+  if (mis.nextPermutationId &lt; mis.numPermutations)</span>
<a href="#l45.453"></a><span id="l45.453" class="difflineplus">+    indexMessages(permute(mis.scenarioMaker(), mis.nextPermutationId++),</span>
<a href="#l45.454"></a><span id="l45.454" class="difflineplus">+                  mis.verifier, _permutationIndexed);</span>
<a href="#l45.455"></a><span id="l45.455" class="difflineplus">+  else</span>
<a href="#l45.456"></a><span id="l45.456" class="difflineplus">+    _multiIndexNext();</span>
<a href="#l45.457"></a><span id="l45.457" class="difflineplus">+}</span>
<a href="#l45.458"></a><span id="l45.458" class="difflineplus">+</span>
<a href="#l45.459"></a><span id="l45.459" class="difflineplus">+/**</span>
<a href="#l45.460"></a><span id="l45.460" class="difflineplus">+ * The state global for indexAndPermuteMessages / _multiIndexNext / </span>
<a href="#l45.461"></a><span id="l45.461" class="difflineplus">+ *  _permutationIndexed.</span>
<a href="#l45.462"></a><span id="l45.462" class="difflineplus">+ */</span>
<a href="#l45.463"></a><span id="l45.463" class="difflineplus">+var multiIndexState = {</span>
<a href="#l45.464"></a><span id="l45.464" class="difflineplus">+  scenarioMaker: null,</span>
<a href="#l45.465"></a><span id="l45.465" class="difflineplus">+  verifier: null,</span>
<a href="#l45.466"></a><span id="l45.466" class="difflineplus">+  onDone: null,</span>
<a href="#l45.467"></a><span id="l45.467" class="difflineplus">+  numPermutations: undefined,</span>
<a href="#l45.468"></a><span id="l45.468" class="difflineplus">+  nextPermutationId: undefined,</span>
<a href="#l45.469"></a><span id="l45.469" class="difflineplus">+  active: false,</span>
<a href="#l45.470"></a><span id="l45.470" class="difflineplus">+  queue: []</span>
<a href="#l45.471"></a><span id="l45.471" class="difflineplus">+};</span>
<a href="#l45.472"></a><span id="l45.472" class="difflineplus">+</span>
<a href="#l45.473"></a><span id="l45.473" class="difflineplus">+/**</span>
<a href="#l45.474"></a><span id="l45.474" class="difflineplus">+ * A simple factorial function used to calculate the number of permutations</span>
<a href="#l45.475"></a><span id="l45.475" class="difflineplus">+ *  possible for a given set of messages.</span>
<a href="#l45.476"></a><span id="l45.476" class="difflineplus">+ */</span>
<a href="#l45.477"></a><span id="l45.477" class="difflineplus">+function factorial(i, rv) {</span>
<a href="#l45.478"></a><span id="l45.478" class="difflineplus">+  if (i &lt;= 1)</span>
<a href="#l45.479"></a><span id="l45.479" class="difflineplus">+    return rv || 1;</span>
<a href="#l45.480"></a><span id="l45.480" class="difflineplus">+  return factorial(i-1, (rv || 1) * i); // tail-call capable</span>
<a href="#l45.481"></a><span id="l45.481" class="difflineplus">+}</span>
<a href="#l45.482"></a><span id="l45.482" class="difflineplus">+</span>
<a href="#l45.483"></a><span id="l45.483" class="difflineplus">+/**</span>
<a href="#l45.484"></a><span id="l45.484" class="difflineplus">+ * Permute an array given a 'permutation id' that is an integer that fully</span>
<a href="#l45.485"></a><span id="l45.485" class="difflineplus">+ *  characterizes the permutation through the decisions that need to be made</span>
<a href="#l45.486"></a><span id="l45.486" class="difflineplus">+ *  at each step.</span>
<a href="#l45.487"></a><span id="l45.487" class="difflineplus">+ *</span>
<a href="#l45.488"></a><span id="l45.488" class="difflineplus">+ * @param aArray Source array that is destructively processed.</span>
<a href="#l45.489"></a><span id="l45.489" class="difflineplus">+ * @param aPermutationId The permutation id.  A permutation id of 0 results in</span>
<a href="#l45.490"></a><span id="l45.490" class="difflineplus">+ *     the original array's sequence being maintained.</span>
<a href="#l45.491"></a><span id="l45.491" class="difflineplus">+ */</span>
<a href="#l45.492"></a><span id="l45.492" class="difflineplus">+function permute(aArray, aPermutationId) {</span>
<a href="#l45.493"></a><span id="l45.493" class="difflineplus">+  let out = [];</span>
<a href="#l45.494"></a><span id="l45.494" class="difflineplus">+  for (let l=aArray.length; l &gt; 0; l--) {</span>
<a href="#l45.495"></a><span id="l45.495" class="difflineplus">+    let offset = aPermutationId % l;  </span>
<a href="#l45.496"></a><span id="l45.496" class="difflineplus">+    out.push(aArray[offset]);</span>
<a href="#l45.497"></a><span id="l45.497" class="difflineplus">+    aArray.splice(offset, 1);</span>
<a href="#l45.498"></a><span id="l45.498" class="difflineplus">+    aPermutationId = Math.floor(aPermutationId / l);</span>
<a href="#l45.499"></a><span id="l45.499" class="difflineplus">+  }</span>
<a href="#l45.500"></a><span id="l45.500" class="difflineplus">+  return out;</span>
<a href="#l45.501"></a><span id="l45.501" class="difflineplus">+}</span>
<a href="#l45.502"></a><span id="l45.502" class="difflineplus">+</span>
<a href="#l45.503"></a><span id="l45.503" class="difflineplus">+// TODO: FIXME: XXX: this should go away, I put it in mailTestUtils.js, but</span>
<a href="#l45.504"></a><span id="l45.504" class="difflineplus">+//  for the sanity of people trying to use this code who might not have my</span>
<a href="#l45.505"></a><span id="l45.505" class="difflineplus">+//  other patches, I have left it here for now.</span>
<a href="#l45.506"></a><span id="l45.506" class="difflineplus">+function toXPArray(aItems) {</span>
<a href="#l45.507"></a><span id="l45.507" class="difflineplus">+  var array = Cc[&quot;@mozilla.org/array;1&quot;].createInstance(Ci.nsIMutableArray);</span>
<a href="#l45.508"></a><span id="l45.508" class="difflineplus">+  aItems.forEach(function (item) {</span>
<a href="#l45.509"></a><span id="l45.509" class="difflineplus">+    array.appendElement(item, false);</span>
<a href="#l45.510"></a><span id="l45.510" class="difflineplus">+  });</span>
<a href="#l45.511"></a><span id="l45.511" class="difflineplus">+  return array;</span>
<a href="#l45.512"></a><span id="l45.512" class="difflineplus">+}</span>
<a href="#l45.513"></a><span id="l45.513" class="difflineplus">+</span>
<a href="#l45.514"></a><span id="l45.514" class="difflineplus">+/**</span>
<a href="#l45.515"></a><span id="l45.515" class="difflineplus">+ *</span>
<a href="#l45.516"></a><span id="l45.516" class="difflineplus">+ */</span>
<a href="#l45.517"></a><span id="l45.517" class="difflineplus">+function twiddleAndTest(aSynthMsg, aActionsAndTests) {</span>
<a href="#l45.518"></a><span id="l45.518" class="difflineplus">+  let iTwiddling = 0;</span>
<a href="#l45.519"></a><span id="l45.519" class="difflineplus">+  function twiddle_next_attr(smsg, gmsg) {</span>
<a href="#l45.520"></a><span id="l45.520" class="difflineplus">+    let curTwiddling = aActionsAndTests[iTwiddling];</span>
<a href="#l45.521"></a><span id="l45.521" class="difflineplus">+    let twiddleFunc = curTwiddling[0];</span>
<a href="#l45.522"></a><span id="l45.522" class="difflineplus">+    let desiredState = curTwiddling[2];</span>
<a href="#l45.523"></a><span id="l45.523" class="difflineplus">+    </span>
<a href="#l45.524"></a><span id="l45.524" class="difflineplus">+    // the underlying nsIMsgDBHdr should exist at this point...</span>
<a href="#l45.525"></a><span id="l45.525" class="difflineplus">+    do_check_neq(gmsg.folderMessage, null);</span>
<a href="#l45.526"></a><span id="l45.526" class="difflineplus">+    // prepare </span>
<a href="#l45.527"></a><span id="l45.527" class="difflineplus">+    expectModifiedMessages([gmsg.folderMessage], verify_next_attr);</span>
<a href="#l45.528"></a><span id="l45.528" class="difflineplus">+    // tell the function to perform its mutation to the desired state</span>
<a href="#l45.529"></a><span id="l45.529" class="difflineplus">+    twiddleFunc(gmsg.folderMessage, desiredState);</span>
<a href="#l45.530"></a><span id="l45.530" class="difflineplus">+  }</span>
<a href="#l45.531"></a><span id="l45.531" class="difflineplus">+  function verify_next_attr(smsg, gmsg) {</span>
<a href="#l45.532"></a><span id="l45.532" class="difflineplus">+    let curTwiddling = aActionsAndTests[iTwiddling];</span>
<a href="#l45.533"></a><span id="l45.533" class="difflineplus">+    let verifyFunc = curTwiddling[1];</span>
<a href="#l45.534"></a><span id="l45.534" class="difflineplus">+    let expectedVal = curTwiddling[curTwiddling.length == 3 ? 2 : 3];</span>
<a href="#l45.535"></a><span id="l45.535" class="difflineplus">+    verifyFunc(smsg, gmsg, expectedVal);</span>
<a href="#l45.536"></a><span id="l45.536" class="difflineplus">+    </span>
<a href="#l45.537"></a><span id="l45.537" class="difflineplus">+    if (++iTwiddling &lt; aActionsAndTests.length)</span>
<a href="#l45.538"></a><span id="l45.538" class="difflineplus">+      twiddle_next_attr(smsg, gmsg);</span>
<a href="#l45.539"></a><span id="l45.539" class="difflineplus">+    else</span>
<a href="#l45.540"></a><span id="l45.540" class="difflineplus">+      next_test();</span>
<a href="#l45.541"></a><span id="l45.541" class="difflineplus">+  }</span>
<a href="#l45.542"></a><span id="l45.542" class="difflineplus">+  </span>
<a href="#l45.543"></a><span id="l45.543" class="difflineplus">+  indexMessages([aSynthMsg], twiddle_next_attr);</span>
<a href="#l45.544"></a><span id="l45.544" class="difflineplus">+}</span>
<a href="#l45.545"></a><span id="l45.545" class="difflineplus">+</span>
<a href="#l45.546"></a><span id="l45.546" class="difflineplus">+var glodaHelperTests = [];</span>
<a href="#l45.547"></a><span id="l45.547" class="difflineplus">+var glodaHelperIterator = null;</span>
<a href="#l45.548"></a><span id="l45.548" class="difflineplus">+</span>
<a href="#l45.549"></a><span id="l45.549" class="difflineplus">+function _gh_test_iterator() {</span>
<a href="#l45.550"></a><span id="l45.550" class="difflineplus">+  do_test_pending();</span>
<a href="#l45.551"></a><span id="l45.551" class="difflineplus">+</span>
<a href="#l45.552"></a><span id="l45.552" class="difflineplus">+  for (let iTest=0; iTest &lt; glodaHelperTests.length; iTest++) {</span>
<a href="#l45.553"></a><span id="l45.553" class="difflineplus">+    dump(&quot;====== Test function: &quot; + glodaHelperTests[iTest].name + &quot;\n&quot;);</span>
<a href="#l45.554"></a><span id="l45.554" class="difflineplus">+    yield glodaHelperTests[iTest]();</span>
<a href="#l45.555"></a><span id="l45.555" class="difflineplus">+  }</span>
<a href="#l45.556"></a><span id="l45.556" class="difflineplus">+</span>
<a href="#l45.557"></a><span id="l45.557" class="difflineplus">+  if (indexMessageState.injectMechanism == INJECT_FAKE_SERVER) {</span>
<a href="#l45.558"></a><span id="l45.558" class="difflineplus">+    killFakeServer();</span>
<a href="#l45.559"></a><span id="l45.559" class="difflineplus">+  }</span>
<a href="#l45.560"></a><span id="l45.560" class="difflineplus">+</span>
<a href="#l45.561"></a><span id="l45.561" class="difflineplus">+  do_test_finished();</span>
<a href="#l45.562"></a><span id="l45.562" class="difflineplus">+  </span>
<a href="#l45.563"></a><span id="l45.563" class="difflineplus">+  // once the control flow hits the root after do_test_finished, we're done,</span>
<a href="#l45.564"></a><span id="l45.564" class="difflineplus">+  //  so let's just yield something to avoid callers having to deal with an</span>
<a href="#l45.565"></a><span id="l45.565" class="difflineplus">+  //  exception indicating completion.</span>
<a href="#l45.566"></a><span id="l45.566" class="difflineplus">+  glodaHelperIterator = null;</span>
<a href="#l45.567"></a><span id="l45.567" class="difflineplus">+  yield null;</span>
<a href="#l45.568"></a><span id="l45.568" class="difflineplus">+}</span>
<a href="#l45.569"></a><span id="l45.569" class="difflineplus">+</span>
<a href="#l45.570"></a><span id="l45.570" class="difflineplus">+function next_test() {</span>
<a href="#l45.571"></a><span id="l45.571" class="difflineplus">+  glodaHelperIterator.next();</span>
<a href="#l45.572"></a><span id="l45.572" class="difflineplus">+}</span>
<a href="#l45.573"></a><span id="l45.573" class="difflineplus">+</span>
<a href="#l45.574"></a><span id="l45.574" class="difflineplus">+function glodaHelperRunTests(aTests) {</span>
<a href="#l45.575"></a><span id="l45.575" class="difflineplus">+  imsInit();</span>
<a href="#l45.576"></a><span id="l45.576" class="difflineplus">+  glodaHelperTests = aTests;</span>
<a href="#l45.577"></a><span id="l45.577" class="difflineplus">+  glodaHelperIterator = _gh_test_iterator();</span>
<a href="#l45.578"></a><span id="l45.578" class="difflineplus">+  next_test();</span>
<a href="#l45.579"></a><span id="l45.579" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1">new file mode 100644</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineminus">--- /dev/null</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineplus">+++ b/mailnews/db/gloda/test/resources/messageGenerator.js</span>
<a href="#l46.4"></a><span id="l46.4" class="difflineat">@@ -0,0 +1,402 @@</span>
<a href="#l46.5"></a><span id="l46.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l46.6"></a><span id="l46.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l46.7"></a><span id="l46.7" class="difflineplus">+ *</span>
<a href="#l46.8"></a><span id="l46.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l46.9"></a><span id="l46.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l46.10"></a><span id="l46.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l46.11"></a><span id="l46.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineplus">+ * </span>
<a href="#l46.13"></a><span id="l46.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l46.14"></a><span id="l46.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l46.15"></a><span id="l46.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l46.16"></a><span id="l46.16" class="difflineplus">+ * License.</span>
<a href="#l46.17"></a><span id="l46.17" class="difflineplus">+ *</span>
<a href="#l46.18"></a><span id="l46.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l46.19"></a><span id="l46.19" class="difflineplus">+ *</span>
<a href="#l46.20"></a><span id="l46.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l46.21"></a><span id="l46.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l46.22"></a><span id="l46.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l46.23"></a><span id="l46.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l46.24"></a><span id="l46.24" class="difflineplus">+ *</span>
<a href="#l46.25"></a><span id="l46.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l46.26"></a><span id="l46.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l46.27"></a><span id="l46.27" class="difflineplus">+ *</span>
<a href="#l46.28"></a><span id="l46.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l46.29"></a><span id="l46.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l46.30"></a><span id="l46.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l46.31"></a><span id="l46.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l46.32"></a><span id="l46.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l46.33"></a><span id="l46.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l46.34"></a><span id="l46.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l46.35"></a><span id="l46.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l46.36"></a><span id="l46.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l46.37"></a><span id="l46.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l46.38"></a><span id="l46.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l46.39"></a><span id="l46.39" class="difflineplus">+ * </span>
<a href="#l46.40"></a><span id="l46.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l46.41"></a><span id="l46.41" class="difflineplus">+</span>
<a href="#l46.42"></a><span id="l46.42" class="difflineplus">+const FIRST_NAMES = [</span>
<a href="#l46.43"></a><span id="l46.43" class="difflineplus">+  &quot;Andy&quot;, &quot;Bob&quot;, &quot;Chris&quot;, &quot;David&quot;, &quot;Emily&quot;, &quot;Felix&quot;,</span>
<a href="#l46.44"></a><span id="l46.44" class="difflineplus">+  &quot;Gillian&quot;, &quot;Helen&quot;, &quot;Idina&quot;, &quot;Johnny&quot;, &quot;Kate&quot;, &quot;Lilia&quot;,</span>
<a href="#l46.45"></a><span id="l46.45" class="difflineplus">+  &quot;Martin&quot;, &quot;Neil&quot;, &quot;Olof&quot;, &quot;Pete&quot;, &quot;Quinn&quot;, &quot;Rasmus&quot;,</span>
<a href="#l46.46"></a><span id="l46.46" class="difflineplus">+  &quot;Sarah&quot;, &quot;Troels&quot;, &quot;Ulf&quot;, &quot;Vince&quot;, &quot;Will&quot;, &quot;Xavier&quot;,</span>
<a href="#l46.47"></a><span id="l46.47" class="difflineplus">+  &quot;Yoko&quot;, &quot;Zig&quot;</span>
<a href="#l46.48"></a><span id="l46.48" class="difflineplus">+  ];</span>
<a href="#l46.49"></a><span id="l46.49" class="difflineplus">+</span>
<a href="#l46.50"></a><span id="l46.50" class="difflineplus">+const LAST_NAMES = [</span>
<a href="#l46.51"></a><span id="l46.51" class="difflineplus">+  &quot;Anway&quot;, &quot;Bell&quot;, &quot;Clarke&quot;, &quot;Davol&quot;, &quot;Ekberg&quot;, &quot;Flowers&quot;,</span>
<a href="#l46.52"></a><span id="l46.52" class="difflineplus">+  &quot;Gilbert&quot;, &quot;Hook&quot;, &quot;Ivarsson&quot;, &quot;Jones&quot;, &quot;Kurtz&quot;, &quot;Lowe&quot;,</span>
<a href="#l46.53"></a><span id="l46.53" class="difflineplus">+  &quot;Morris&quot;, &quot;Nagel&quot;, &quot;Orzabal&quot;, &quot;Price&quot;, &quot;Quinn&quot;, &quot;Rolinski&quot;,</span>
<a href="#l46.54"></a><span id="l46.54" class="difflineplus">+  &quot;Stanley&quot;, &quot;Tennant&quot;, &quot;Ulvaeus&quot;, &quot;Vannucci&quot;, &quot;Wiggs&quot;, &quot;Xavier&quot;,</span>
<a href="#l46.55"></a><span id="l46.55" class="difflineplus">+  &quot;Young&quot;, &quot;Zig&quot;</span>
<a href="#l46.56"></a><span id="l46.56" class="difflineplus">+  ];</span>
<a href="#l46.57"></a><span id="l46.57" class="difflineplus">+</span>
<a href="#l46.58"></a><span id="l46.58" class="difflineplus">+const SUBJECT_ADJECTIVES = [</span>
<a href="#l46.59"></a><span id="l46.59" class="difflineplus">+  &quot;Big&quot;, &quot;Small&quot;, &quot;Huge&quot;, &quot;Tiny&quot;,</span>
<a href="#l46.60"></a><span id="l46.60" class="difflineplus">+  &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;My&quot;,</span>
<a href="#l46.61"></a><span id="l46.61" class="difflineplus">+  &quot;Happy&quot;, &quot;Sad&quot;, &quot;Grumpy&quot;, &quot;Angry&quot;,</span>
<a href="#l46.62"></a><span id="l46.62" class="difflineplus">+  &quot;Awesome&quot;, &quot;Fun&quot;, &quot;Lame&quot;, &quot;Funky&quot;,</span>
<a href="#l46.63"></a><span id="l46.63" class="difflineplus">+  ];</span>
<a href="#l46.64"></a><span id="l46.64" class="difflineplus">+const SUBJECT_NOUNS = [</span>
<a href="#l46.65"></a><span id="l46.65" class="difflineplus">+  &quot;Meeting&quot;, &quot;Party&quot;, &quot;Shindig&quot;, &quot;Wedding&quot;,</span>
<a href="#l46.66"></a><span id="l46.66" class="difflineplus">+  &quot;Document&quot;, &quot;Report&quot;, &quot;Spreadsheet&quot;, &quot;Hovercraft&quot;,</span>
<a href="#l46.67"></a><span id="l46.67" class="difflineplus">+  &quot;Aardvark&quot;, &quot;Giraffe&quot;, &quot;Llama&quot;, &quot;Velociraptor&quot;,</span>
<a href="#l46.68"></a><span id="l46.68" class="difflineplus">+  &quot;Laser&quot;, &quot;Ray-Gun&quot;, &quot;Pen&quot;, &quot;Sword&quot;,</span>
<a href="#l46.69"></a><span id="l46.69" class="difflineplus">+  ];</span>
<a href="#l46.70"></a><span id="l46.70" class="difflineplus">+const SUBJECT_SUFFIXES = [</span>
<a href="#l46.71"></a><span id="l46.71" class="difflineplus">+  &quot;Today&quot;, &quot;Tomorrow&quot;, &quot;Yesterday&quot;, &quot;In a Fortnight&quot;,</span>
<a href="#l46.72"></a><span id="l46.72" class="difflineplus">+  &quot;Needs Attention&quot;, &quot;Very Important&quot;, &quot;Highest Priority&quot;, &quot;Full Of Eels&quot;,</span>
<a href="#l46.73"></a><span id="l46.73" class="difflineplus">+  &quot;In The Lobby&quot;, &quot;On Your Desk&quot;, &quot;In Your Car&quot;, &quot;Hiding Behind The Door&quot;,</span>
<a href="#l46.74"></a><span id="l46.74" class="difflineplus">+  ];</span>
<a href="#l46.75"></a><span id="l46.75" class="difflineplus">+                           </span>
<a href="#l46.76"></a><span id="l46.76" class="difflineplus">+</span>
<a href="#l46.77"></a><span id="l46.77" class="difflineplus">+/**</span>
<a href="#l46.78"></a><span id="l46.78" class="difflineplus">+ * A synthetic message, created by the MessageGenerator.  Captures both the</span>
<a href="#l46.79"></a><span id="l46.79" class="difflineplus">+ *  ingredients that went into the synthetic message as well as the rfc822 form</span>
<a href="#l46.80"></a><span id="l46.80" class="difflineplus">+ *  of the message.</span>
<a href="#l46.81"></a><span id="l46.81" class="difflineplus">+ */</span>
<a href="#l46.82"></a><span id="l46.82" class="difflineplus">+function SyntheticMessage(aHeaders, aBody) {</span>
<a href="#l46.83"></a><span id="l46.83" class="difflineplus">+  this.headers = aHeaders || {};</span>
<a href="#l46.84"></a><span id="l46.84" class="difflineplus">+  this.body = aBody || &quot;&quot;;</span>
<a href="#l46.85"></a><span id="l46.85" class="difflineplus">+}</span>
<a href="#l46.86"></a><span id="l46.86" class="difflineplus">+</span>
<a href="#l46.87"></a><span id="l46.87" class="difflineplus">+SyntheticMessage.prototype = {</span>
<a href="#l46.88"></a><span id="l46.88" class="difflineplus">+  get messageId() { return this._messageId; },</span>
<a href="#l46.89"></a><span id="l46.89" class="difflineplus">+  set messageId(aMessageId) {</span>
<a href="#l46.90"></a><span id="l46.90" class="difflineplus">+    this._messageId = aMessageId;</span>
<a href="#l46.91"></a><span id="l46.91" class="difflineplus">+    this.headers[&quot;Message-Id&quot;] = &quot;&lt;&quot; + aMessageId + &quot;&gt;&quot;;</span>
<a href="#l46.92"></a><span id="l46.92" class="difflineplus">+  },</span>
<a href="#l46.93"></a><span id="l46.93" class="difflineplus">+  </span>
<a href="#l46.94"></a><span id="l46.94" class="difflineplus">+  get date() { return this._date; },</span>
<a href="#l46.95"></a><span id="l46.95" class="difflineplus">+  set date(aDate) {</span>
<a href="#l46.96"></a><span id="l46.96" class="difflineplus">+    this._date = aDate;</span>
<a href="#l46.97"></a><span id="l46.97" class="difflineplus">+    let dateParts = aDate.toString().split(&quot; &quot;);</span>
<a href="#l46.98"></a><span id="l46.98" class="difflineplus">+    this.headers[&quot;Date&quot;] = dateParts[0] + &quot;, &quot; + dateParts[2] + &quot; &quot; +</span>
<a href="#l46.99"></a><span id="l46.99" class="difflineplus">+                           dateParts[1] + &quot; &quot; + dateParts[3] + &quot; &quot; +</span>
<a href="#l46.100"></a><span id="l46.100" class="difflineplus">+                           dateParts[4] + &quot; &quot; + dateParts[5].substring(3);</span>
<a href="#l46.101"></a><span id="l46.101" class="difflineplus">+  },</span>
<a href="#l46.102"></a><span id="l46.102" class="difflineplus">+  </span>
<a href="#l46.103"></a><span id="l46.103" class="difflineplus">+  get subject() { return this._subject; },</span>
<a href="#l46.104"></a><span id="l46.104" class="difflineplus">+  set subject(aSubject) {</span>
<a href="#l46.105"></a><span id="l46.105" class="difflineplus">+    this._subject = aSubject;</span>
<a href="#l46.106"></a><span id="l46.106" class="difflineplus">+    this.headers[&quot;Subject&quot;] = aSubject;</span>
<a href="#l46.107"></a><span id="l46.107" class="difflineplus">+  },</span>
<a href="#l46.108"></a><span id="l46.108" class="difflineplus">+  </span>
<a href="#l46.109"></a><span id="l46.109" class="difflineplus">+  _formatMailFromNameAndAddress: function(aNameAndAddress) {</span>
<a href="#l46.110"></a><span id="l46.110" class="difflineplus">+    return '&quot;' + aNameAndAddress[0] + '&quot; ' + </span>
<a href="#l46.111"></a><span id="l46.111" class="difflineplus">+           '&lt;' + aNameAndAddress[1] + '&gt;';    </span>
<a href="#l46.112"></a><span id="l46.112" class="difflineplus">+  },</span>
<a href="#l46.113"></a><span id="l46.113" class="difflineplus">+  </span>
<a href="#l46.114"></a><span id="l46.114" class="difflineplus">+  get from() { return this._from; },</span>
<a href="#l46.115"></a><span id="l46.115" class="difflineplus">+  set from(aNameAndAddress) {</span>
<a href="#l46.116"></a><span id="l46.116" class="difflineplus">+    this._from = aNameAndAddress;</span>
<a href="#l46.117"></a><span id="l46.117" class="difflineplus">+    this.headers[&quot;From&quot;] = this._formatMailFromNameAndAddress(aNameAndAddress);</span>
<a href="#l46.118"></a><span id="l46.118" class="difflineplus">+  },</span>
<a href="#l46.119"></a><span id="l46.119" class="difflineplus">+</span>
<a href="#l46.120"></a><span id="l46.120" class="difflineplus">+  get fromName() { return this._from[0]; },</span>
<a href="#l46.121"></a><span id="l46.121" class="difflineplus">+  get fromAddress() { return this._from[1]; },</span>
<a href="#l46.122"></a><span id="l46.122" class="difflineplus">+  </span>
<a href="#l46.123"></a><span id="l46.123" class="difflineplus">+  /**</span>
<a href="#l46.124"></a><span id="l46.124" class="difflineplus">+   * For our header storage, we may need to pre-add commas.</span>
<a href="#l46.125"></a><span id="l46.125" class="difflineplus">+   */</span>
<a href="#l46.126"></a><span id="l46.126" class="difflineplus">+  _commaize: function(aList) {</span>
<a href="#l46.127"></a><span id="l46.127" class="difflineplus">+    for (let i=0; i &lt; aList.length - 1; i++)</span>
<a href="#l46.128"></a><span id="l46.128" class="difflineplus">+      aList[i] = aList[i] + &quot;,&quot;;</span>
<a href="#l46.129"></a><span id="l46.129" class="difflineplus">+    return aList;</span>
<a href="#l46.130"></a><span id="l46.130" class="difflineplus">+  },</span>
<a href="#l46.131"></a><span id="l46.131" class="difflineplus">+  </span>
<a href="#l46.132"></a><span id="l46.132" class="difflineplus">+  get to() { return this._to; },</span>
<a href="#l46.133"></a><span id="l46.133" class="difflineplus">+  set to(aNameAndAddresses) {</span>
<a href="#l46.134"></a><span id="l46.134" class="difflineplus">+    this._to = aNameAndAddresses;</span>
<a href="#l46.135"></a><span id="l46.135" class="difflineplus">+    this.headers[&quot;To&quot;] = this._commaize(</span>
<a href="#l46.136"></a><span id="l46.136" class="difflineplus">+                           [this._formatMailFromNameAndAddress(nameAndAddr)</span>
<a href="#l46.137"></a><span id="l46.137" class="difflineplus">+                            for each (nameAndAddr in aNameAndAddresses)]);</span>
<a href="#l46.138"></a><span id="l46.138" class="difflineplus">+  },</span>
<a href="#l46.139"></a><span id="l46.139" class="difflineplus">+  // just the first to...</span>
<a href="#l46.140"></a><span id="l46.140" class="difflineplus">+  get toName() { return this.to[0][0]; },</span>
<a href="#l46.141"></a><span id="l46.141" class="difflineplus">+  get toAddress() { return this._to[0][1]; },</span>
<a href="#l46.142"></a><span id="l46.142" class="difflineplus">+  </span>
<a href="#l46.143"></a><span id="l46.143" class="difflineplus">+  get cc() { return this._cc; },</span>
<a href="#l46.144"></a><span id="l46.144" class="difflineplus">+  set cc(aNameAndAddresses) {</span>
<a href="#l46.145"></a><span id="l46.145" class="difflineplus">+    this._to = aNameAndAddresses;</span>
<a href="#l46.146"></a><span id="l46.146" class="difflineplus">+    this.headers[&quot;Cc&quot;] = this._commaize(</span>
<a href="#l46.147"></a><span id="l46.147" class="difflineplus">+                           [this._formatMailFromNameAndAddress(nameAndAddr)</span>
<a href="#l46.148"></a><span id="l46.148" class="difflineplus">+                            for each (nameAndAddr in aNameAndAddresses)]);</span>
<a href="#l46.149"></a><span id="l46.149" class="difflineplus">+  },</span>
<a href="#l46.150"></a><span id="l46.150" class="difflineplus">+  </span>
<a href="#l46.151"></a><span id="l46.151" class="difflineplus">+  _formatHeaderValues: function(aHeaderValues) {</span>
<a href="#l46.152"></a><span id="l46.152" class="difflineplus">+    // may not be an array</span>
<a href="#l46.153"></a><span id="l46.153" class="difflineplus">+    if (!(aHeaderValues instanceof Array))</span>
<a href="#l46.154"></a><span id="l46.154" class="difflineplus">+      return aHeaderValues;</span>
<a href="#l46.155"></a><span id="l46.155" class="difflineplus">+    // it's an array!</span>
<a href="#l46.156"></a><span id="l46.156" class="difflineplus">+    if (aHeaderValues.length == 1)</span>
<a href="#l46.157"></a><span id="l46.157" class="difflineplus">+      return aHeaderValues[0];</span>
<a href="#l46.158"></a><span id="l46.158" class="difflineplus">+    return aHeaderValues.join(&quot;\n\t&quot;);</span>
<a href="#l46.159"></a><span id="l46.159" class="difflineplus">+  },</span>
<a href="#l46.160"></a><span id="l46.160" class="difflineplus">+  </span>
<a href="#l46.161"></a><span id="l46.161" class="difflineplus">+  toString: function() {</span>
<a href="#l46.162"></a><span id="l46.162" class="difflineplus">+    return &quot;msg:&quot; + this._messageId;</span>
<a href="#l46.163"></a><span id="l46.163" class="difflineplus">+  },</span>
<a href="#l46.164"></a><span id="l46.164" class="difflineplus">+  </span>
<a href="#l46.165"></a><span id="l46.165" class="difflineplus">+  toMessageString: function() {</span>
<a href="#l46.166"></a><span id="l46.166" class="difflineplus">+    let lines = [headerKey + &quot;: &quot; + this._formatHeaderValues(headerValues)</span>
<a href="#l46.167"></a><span id="l46.167" class="difflineplus">+                 for each ([headerKey, headerValues] in Iterator(this.headers))];</span>
<a href="#l46.168"></a><span id="l46.168" class="difflineplus">+    </span>
<a href="#l46.169"></a><span id="l46.169" class="difflineplus">+    return lines.join(&quot;\n&quot;) + &quot;\n\n&quot; + this.body + &quot;\n&quot;;</span>
<a href="#l46.170"></a><span id="l46.170" class="difflineplus">+  },</span>
<a href="#l46.171"></a><span id="l46.171" class="difflineplus">+  </span>
<a href="#l46.172"></a><span id="l46.172" class="difflineplus">+  toStream: function () {</span>
<a href="#l46.173"></a><span id="l46.173" class="difflineplus">+    let stream = Cc[&quot;@mozilla.org/io/string-input-stream;1&quot;]</span>
<a href="#l46.174"></a><span id="l46.174" class="difflineplus">+                   .createInstance(Ci.nsIStringInputStream);</span>
<a href="#l46.175"></a><span id="l46.175" class="difflineplus">+    let str = this.toMessageString();</span>
<a href="#l46.176"></a><span id="l46.176" class="difflineplus">+    stream.setData(str, str.length);</span>
<a href="#l46.177"></a><span id="l46.177" class="difflineplus">+    return stream;</span>
<a href="#l46.178"></a><span id="l46.178" class="difflineplus">+  },</span>
<a href="#l46.179"></a><span id="l46.179" class="difflineplus">+  </span>
<a href="#l46.180"></a><span id="l46.180" class="difflineplus">+  writeToMboxStream: function (aStream) {</span>
<a href="#l46.181"></a><span id="l46.181" class="difflineplus">+    let str = &quot;From &quot; + this._from[1] + &quot;\n&quot; + this.toMessageString() + &quot;\n&quot;;</span>
<a href="#l46.182"></a><span id="l46.182" class="difflineplus">+    aStream.write(str, str.length);</span>
<a href="#l46.183"></a><span id="l46.183" class="difflineplus">+  }</span>
<a href="#l46.184"></a><span id="l46.184" class="difflineplus">+}</span>
<a href="#l46.185"></a><span id="l46.185" class="difflineplus">+</span>
<a href="#l46.186"></a><span id="l46.186" class="difflineplus">+function writeMessagesToMbox (aMessages, aBaseDir, aRelPath) {</span>
<a href="#l46.187"></a><span id="l46.187" class="difflineplus">+  let targetFile = Cc[&quot;@mozilla.org/file/local;1&quot;]</span>
<a href="#l46.188"></a><span id="l46.188" class="difflineplus">+                     .createInstance(Ci.nsILocalFile);</span>
<a href="#l46.189"></a><span id="l46.189" class="difflineplus">+  targetFile.initWithFile(aBaseDir);</span>
<a href="#l46.190"></a><span id="l46.190" class="difflineplus">+  targetFile.appendRelativePath(aRelPath);</span>
<a href="#l46.191"></a><span id="l46.191" class="difflineplus">+</span>
<a href="#l46.192"></a><span id="l46.192" class="difflineplus">+  let ostream = Cc[&quot;@mozilla.org/network/file-output-stream;1&quot;]</span>
<a href="#l46.193"></a><span id="l46.193" class="difflineplus">+                  .createInstance(Ci.nsIFileOutputStream);</span>
<a href="#l46.194"></a><span id="l46.194" class="difflineplus">+  ostream.init(targetFile, -1, -1, 0);</span>
<a href="#l46.195"></a><span id="l46.195" class="difflineplus">+  </span>
<a href="#l46.196"></a><span id="l46.196" class="difflineplus">+  for (let iMessage = 0; iMessage &lt; aMessages.length; iMessage++) {</span>
<a href="#l46.197"></a><span id="l46.197" class="difflineplus">+    aMessages[iMessage].writeToMboxStream(ostream);</span>
<a href="#l46.198"></a><span id="l46.198" class="difflineplus">+  }</span>
<a href="#l46.199"></a><span id="l46.199" class="difflineplus">+  </span>
<a href="#l46.200"></a><span id="l46.200" class="difflineplus">+  ostream.close();</span>
<a href="#l46.201"></a><span id="l46.201" class="difflineplus">+}</span>
<a href="#l46.202"></a><span id="l46.202" class="difflineplus">+</span>
<a href="#l46.203"></a><span id="l46.203" class="difflineplus">+function MessageGenerator() {</span>
<a href="#l46.204"></a><span id="l46.204" class="difflineplus">+  this._clock = new Date(2000, 1, 1);</span>
<a href="#l46.205"></a><span id="l46.205" class="difflineplus">+  this._nextNameNumber = 0;</span>
<a href="#l46.206"></a><span id="l46.206" class="difflineplus">+  this._nextSubjectNumber = 0;</span>
<a href="#l46.207"></a><span id="l46.207" class="difflineplus">+  this._nextMessageIdNum = 0;</span>
<a href="#l46.208"></a><span id="l46.208" class="difflineplus">+}</span>
<a href="#l46.209"></a><span id="l46.209" class="difflineplus">+</span>
<a href="#l46.210"></a><span id="l46.210" class="difflineplus">+MessageGenerator.prototype = {</span>
<a href="#l46.211"></a><span id="l46.211" class="difflineplus">+  /**</span>
<a href="#l46.212"></a><span id="l46.212" class="difflineplus">+   * Generate a consistently determined (and reversible) name from a unique</span>
<a href="#l46.213"></a><span id="l46.213" class="difflineplus">+   *  value.  Currently up to 26*26 unique names can be generated, which</span>
<a href="#l46.214"></a><span id="l46.214" class="difflineplus">+   *  should be sufficient for testing purposes.</span>
<a href="#l46.215"></a><span id="l46.215" class="difflineplus">+   */</span>
<a href="#l46.216"></a><span id="l46.216" class="difflineplus">+  makeName: function(aNameNumber) {</span>
<a href="#l46.217"></a><span id="l46.217" class="difflineplus">+    let iFirst = aNameNumber % FIRST_NAMES.length;</span>
<a href="#l46.218"></a><span id="l46.218" class="difflineplus">+    let iLast = (iFirst + Math.floor(aNameNumber / FIRST_NAMES.length)) %</span>
<a href="#l46.219"></a><span id="l46.219" class="difflineplus">+	            LAST_NAMES.length;</span>
<a href="#l46.220"></a><span id="l46.220" class="difflineplus">+	</span>
<a href="#l46.221"></a><span id="l46.221" class="difflineplus">+    return FIRST_NAMES[iFirst] + &quot; &quot; + LAST_NAMES[iLast];</span>
<a href="#l46.222"></a><span id="l46.222" class="difflineplus">+  },</span>
<a href="#l46.223"></a><span id="l46.223" class="difflineplus">+  </span>
<a href="#l46.224"></a><span id="l46.224" class="difflineplus">+  /**</span>
<a href="#l46.225"></a><span id="l46.225" class="difflineplus">+   * Generate a consistently determined (and reversible) e-mail address from</span>
<a href="#l46.226"></a><span id="l46.226" class="difflineplus">+   *  a unique value; intended to work in parallel with makeName.  Currently</span>
<a href="#l46.227"></a><span id="l46.227" class="difflineplus">+   *  up to 26*26 unique addresses can be generated.</span>
<a href="#l46.228"></a><span id="l46.228" class="difflineplus">+   */</span>
<a href="#l46.229"></a><span id="l46.229" class="difflineplus">+  makeMailAddress: function(aNameNumber) {</span>
<a href="#l46.230"></a><span id="l46.230" class="difflineplus">+    let iFirst = aNameNumber % FIRST_NAMES.length;</span>
<a href="#l46.231"></a><span id="l46.231" class="difflineplus">+    let iLast = (iFirst + Math.floor(aNameNumber / FIRST_NAMES.length)) %</span>
<a href="#l46.232"></a><span id="l46.232" class="difflineplus">+	      LAST_NAMES.length;</span>
<a href="#l46.233"></a><span id="l46.233" class="difflineplus">+		</span>
<a href="#l46.234"></a><span id="l46.234" class="difflineplus">+    return FIRST_NAMES[iFirst].toLowerCase() + &quot;@&quot; +</span>
<a href="#l46.235"></a><span id="l46.235" class="difflineplus">+           LAST_NAMES[iLast].toLowerCase() + &quot;.nul&quot;;</span>
<a href="#l46.236"></a><span id="l46.236" class="difflineplus">+  },</span>
<a href="#l46.237"></a><span id="l46.237" class="difflineplus">+  </span>
<a href="#l46.238"></a><span id="l46.238" class="difflineplus">+  /**</span>
<a href="#l46.239"></a><span id="l46.239" class="difflineplus">+   * Generate a pair of name and e-mail address.</span>
<a href="#l46.240"></a><span id="l46.240" class="difflineplus">+   */</span>
<a href="#l46.241"></a><span id="l46.241" class="difflineplus">+  makeNameAndAddress: function(aNameNumber) {</span>
<a href="#l46.242"></a><span id="l46.242" class="difflineplus">+    if (aNameNumber === undefined)</span>
<a href="#l46.243"></a><span id="l46.243" class="difflineplus">+      aNameNumber = this._nextNameNumber++;</span>
<a href="#l46.244"></a><span id="l46.244" class="difflineplus">+    return [this.makeName(aNameNumber), this.makeMailAddress(aNameNumber)];</span>
<a href="#l46.245"></a><span id="l46.245" class="difflineplus">+  },</span>
<a href="#l46.246"></a><span id="l46.246" class="difflineplus">+</span>
<a href="#l46.247"></a><span id="l46.247" class="difflineplus">+  makeNamesAndAddresses: function(aCount) {</span>
<a href="#l46.248"></a><span id="l46.248" class="difflineplus">+    let namesAndAddresses = [];</span>
<a href="#l46.249"></a><span id="l46.249" class="difflineplus">+    for (let i=0; i &lt; aCount; i++)</span>
<a href="#l46.250"></a><span id="l46.250" class="difflineplus">+      namesAndAddresses.push(this.makeNameAndAddress());</span>
<a href="#l46.251"></a><span id="l46.251" class="difflineplus">+    return namesAndAddresses;</span>
<a href="#l46.252"></a><span id="l46.252" class="difflineplus">+  },</span>
<a href="#l46.253"></a><span id="l46.253" class="difflineplus">+  </span>
<a href="#l46.254"></a><span id="l46.254" class="difflineplus">+  makeSubject: function(aSubjectNumber) {</span>
<a href="#l46.255"></a><span id="l46.255" class="difflineplus">+    if (aSubjectNumber === undefined)</span>
<a href="#l46.256"></a><span id="l46.256" class="difflineplus">+      aSubjectNumber = this._nextSubjectNumber++;</span>
<a href="#l46.257"></a><span id="l46.257" class="difflineplus">+    let iAdjective = aSubjectNumber % SUBJECT_ADJECTIVES.length;</span>
<a href="#l46.258"></a><span id="l46.258" class="difflineplus">+    let iNoun = (iAdjective + Math.floor(aSubjectNumber /</span>
<a href="#l46.259"></a><span id="l46.259" class="difflineplus">+                                         SUBJECT_ADJECTIVES.length)) %</span>
<a href="#l46.260"></a><span id="l46.260" class="difflineplus">+                SUBJECT_NOUNS.length;</span>
<a href="#l46.261"></a><span id="l46.261" class="difflineplus">+    let iSuffix = (iNoun + Math.floor(aSubjectNumber /</span>
<a href="#l46.262"></a><span id="l46.262" class="difflineplus">+                   (SUBJECT_ADJECTIVES.length * SUBJECT_NOUNS.length))) %</span>
<a href="#l46.263"></a><span id="l46.263" class="difflineplus">+                  SUBJECT_SUFFIXES.length;</span>
<a href="#l46.264"></a><span id="l46.264" class="difflineplus">+    return SUBJECT_ADJECTIVES[iAdjective] + &quot; &quot; +</span>
<a href="#l46.265"></a><span id="l46.265" class="difflineplus">+           SUBJECT_NOUNS[iNoun] + &quot; &quot; +</span>
<a href="#l46.266"></a><span id="l46.266" class="difflineplus">+           SUBJECT_SUFFIXES[iSuffix];</span>
<a href="#l46.267"></a><span id="l46.267" class="difflineplus">+  },</span>
<a href="#l46.268"></a><span id="l46.268" class="difflineplus">+  </span>
<a href="#l46.269"></a><span id="l46.269" class="difflineplus">+  /**</span>
<a href="#l46.270"></a><span id="l46.270" class="difflineplus">+   * Fabricate a message-id suitable for the given synthetic message.  Although</span>
<a href="#l46.271"></a><span id="l46.271" class="difflineplus">+   *  we don't use the message yet, in theory it would let us tailor the</span>
<a href="#l46.272"></a><span id="l46.272" class="difflineplus">+   *  message id to the server that theoretically might be sending it.  Or some</span>
<a href="#l46.273"></a><span id="l46.273" class="difflineplus">+   *  such.</span>
<a href="#l46.274"></a><span id="l46.274" class="difflineplus">+   */</span>
<a href="#l46.275"></a><span id="l46.275" class="difflineplus">+  makeMessageId: function(aSynthMessage) {</span>
<a href="#l46.276"></a><span id="l46.276" class="difflineplus">+    let msgId = this._nextMessageIdNum + &quot;@made.up&quot;;</span>
<a href="#l46.277"></a><span id="l46.277" class="difflineplus">+    this._nextMessageIdNum++;</span>
<a href="#l46.278"></a><span id="l46.278" class="difflineplus">+    return msgId;</span>
<a href="#l46.279"></a><span id="l46.279" class="difflineplus">+  },</span>
<a href="#l46.280"></a><span id="l46.280" class="difflineplus">+  </span>
<a href="#l46.281"></a><span id="l46.281" class="difflineplus">+  makeDate: function() {</span>
<a href="#l46.282"></a><span id="l46.282" class="difflineplus">+    let date = this._clock;</span>
<a href="#l46.283"></a><span id="l46.283" class="difflineplus">+    // advance time by an hour</span>
<a href="#l46.284"></a><span id="l46.284" class="difflineplus">+    this._clock = new Date(date.valueOf() + 60 * 60 * 1000);</span>
<a href="#l46.285"></a><span id="l46.285" class="difflineplus">+    return date;</span>
<a href="#l46.286"></a><span id="l46.286" class="difflineplus">+  },</span>
<a href="#l46.287"></a><span id="l46.287" class="difflineplus">+  </span>
<a href="#l46.288"></a><span id="l46.288" class="difflineplus">+  makeMessage: function(aInReplyTo, aArgs) {</span>
<a href="#l46.289"></a><span id="l46.289" class="difflineplus">+    aArgs = aArgs || {};</span>
<a href="#l46.290"></a><span id="l46.290" class="difflineplus">+    let msg = new SyntheticMessage();</span>
<a href="#l46.291"></a><span id="l46.291" class="difflineplus">+    </span>
<a href="#l46.292"></a><span id="l46.292" class="difflineplus">+    if (aInReplyTo) {</span>
<a href="#l46.293"></a><span id="l46.293" class="difflineplus">+      msg.parent = aInReplyTo;</span>
<a href="#l46.294"></a><span id="l46.294" class="difflineplus">+      msg.parent.children.push(msg); </span>
<a href="#l46.295"></a><span id="l46.295" class="difflineplus">+      </span>
<a href="#l46.296"></a><span id="l46.296" class="difflineplus">+      let srcMsg = aInReplyTo;</span>
<a href="#l46.297"></a><span id="l46.297" class="difflineplus">+      </span>
<a href="#l46.298"></a><span id="l46.298" class="difflineplus">+      msg.subject = (srcMsg.subject.substring(0, 4) == &quot;Re: &quot;) ? srcMsg.subject</span>
<a href="#l46.299"></a><span id="l46.299" class="difflineplus">+                    : (&quot;Re: &quot; + srcMsg.subject);</span>
<a href="#l46.300"></a><span id="l46.300" class="difflineplus">+      if (aArgs.replyAll)</span>
<a href="#l46.301"></a><span id="l46.301" class="difflineplus">+        msg.to = [srcMsg.from].concat(srcMsg.to.slice(1));</span>
<a href="#l46.302"></a><span id="l46.302" class="difflineplus">+      else</span>
<a href="#l46.303"></a><span id="l46.303" class="difflineplus">+        msg.to = [srcMsg.from];</span>
<a href="#l46.304"></a><span id="l46.304" class="difflineplus">+      msg.from = srcMsg.to[0];</span>
<a href="#l46.305"></a><span id="l46.305" class="difflineplus">+      </span>
<a href="#l46.306"></a><span id="l46.306" class="difflineplus">+      // we want the &lt;&gt;'s.</span>
<a href="#l46.307"></a><span id="l46.307" class="difflineplus">+      msg.headers[&quot;In-Reply-To&quot;] = srcMsg.headers[&quot;Message-Id&quot;];</span>
<a href="#l46.308"></a><span id="l46.308" class="difflineplus">+      msg.headers[&quot;References&quot;] = (srcMsg.headers[&quot;References&quot;] || []).concat(</span>
<a href="#l46.309"></a><span id="l46.309" class="difflineplus">+                                   [srcMsg.headers[&quot;Message-Id&quot;]]);</span>
<a href="#l46.310"></a><span id="l46.310" class="difflineplus">+    }</span>
<a href="#l46.311"></a><span id="l46.311" class="difflineplus">+    else {</span>
<a href="#l46.312"></a><span id="l46.312" class="difflineplus">+      msg.parent = null;</span>
<a href="#l46.313"></a><span id="l46.313" class="difflineplus">+      </span>
<a href="#l46.314"></a><span id="l46.314" class="difflineplus">+      msg.subject = this.makeSubject();</span>
<a href="#l46.315"></a><span id="l46.315" class="difflineplus">+      msg.from = this.makeNameAndAddress();</span>
<a href="#l46.316"></a><span id="l46.316" class="difflineplus">+      msg.to = this.makeNamesAndAddresses(aArgs.toCount || 1);</span>
<a href="#l46.317"></a><span id="l46.317" class="difflineplus">+    }</span>
<a href="#l46.318"></a><span id="l46.318" class="difflineplus">+    </span>
<a href="#l46.319"></a><span id="l46.319" class="difflineplus">+    msg.children = [];</span>
<a href="#l46.320"></a><span id="l46.320" class="difflineplus">+    msg.messageId = this.makeMessageId(msg);</span>
<a href="#l46.321"></a><span id="l46.321" class="difflineplus">+    msg.date = this.makeDate();</span>
<a href="#l46.322"></a><span id="l46.322" class="difflineplus">+    </span>
<a href="#l46.323"></a><span id="l46.323" class="difflineplus">+    msg.body = &quot;I am an e-mail.&quot;;</span>
<a href="#l46.324"></a><span id="l46.324" class="difflineplus">+    </span>
<a href="#l46.325"></a><span id="l46.325" class="difflineplus">+    return msg;</span>
<a href="#l46.326"></a><span id="l46.326" class="difflineplus">+  }</span>
<a href="#l46.327"></a><span id="l46.327" class="difflineplus">+}</span>
<a href="#l46.328"></a><span id="l46.328" class="difflineplus">+</span>
<a href="#l46.329"></a><span id="l46.329" class="difflineplus">+function MessageScenarioFactory(aMessageGenerator) {</span>
<a href="#l46.330"></a><span id="l46.330" class="difflineplus">+  if(!aMessageGenerator)</span>
<a href="#l46.331"></a><span id="l46.331" class="difflineplus">+    aMessageGenerator = new MessageGenerator();</span>
<a href="#l46.332"></a><span id="l46.332" class="difflineplus">+  this._msgGen = aMessageGenerator;</span>
<a href="#l46.333"></a><span id="l46.333" class="difflineplus">+}</span>
<a href="#l46.334"></a><span id="l46.334" class="difflineplus">+</span>
<a href="#l46.335"></a><span id="l46.335" class="difflineplus">+MessageScenarioFactory.prototype = {</span>
<a href="#l46.336"></a><span id="l46.336" class="difflineplus">+  /** Create a chain of direct-reply messages of the given length. */</span>
<a href="#l46.337"></a><span id="l46.337" class="difflineplus">+  directReply: function(aNumMessages) {</span>
<a href="#l46.338"></a><span id="l46.338" class="difflineplus">+    aNumMessages = aNumMessages || 2;</span>
<a href="#l46.339"></a><span id="l46.339" class="difflineplus">+    let messages = [this._msgGen.makeMessage()];</span>
<a href="#l46.340"></a><span id="l46.340" class="difflineplus">+    for (let i = 1; i &lt; aNumMessages; i++) {</span>
<a href="#l46.341"></a><span id="l46.341" class="difflineplus">+      messages.push(msgGen.makeMessage(messages[i-1]));</span>
<a href="#l46.342"></a><span id="l46.342" class="difflineplus">+    }</span>
<a href="#l46.343"></a><span id="l46.343" class="difflineplus">+    return messages;</span>
<a href="#l46.344"></a><span id="l46.344" class="difflineplus">+  },</span>
<a href="#l46.345"></a><span id="l46.345" class="difflineplus">+  </span>
<a href="#l46.346"></a><span id="l46.346" class="difflineplus">+  /** Two siblings (present), one parent (missing). */</span>
<a href="#l46.347"></a><span id="l46.347" class="difflineplus">+  siblingsMissingParent: function() {</span>
<a href="#l46.348"></a><span id="l46.348" class="difflineplus">+    let missingParent = this._msgGen.makeMessage();</span>
<a href="#l46.349"></a><span id="l46.349" class="difflineplus">+    let msg1 = this._msgGen.makeMessage(missingParent);</span>
<a href="#l46.350"></a><span id="l46.350" class="difflineplus">+    let msg2 = this._msgGen.makeMessage(missingParent);</span>
<a href="#l46.351"></a><span id="l46.351" class="difflineplus">+    return [msg1, msg2];</span>
<a href="#l46.352"></a><span id="l46.352" class="difflineplus">+  },</span>
<a href="#l46.353"></a><span id="l46.353" class="difflineplus">+  </span>
<a href="#l46.354"></a><span id="l46.354" class="difflineplus">+  /** Present parent, missing child, present grand-child. */ </span>
<a href="#l46.355"></a><span id="l46.355" class="difflineplus">+  missingIntermediary: function() {</span>
<a href="#l46.356"></a><span id="l46.356" class="difflineplus">+    let msg1 = this._msgGen.makeMessage();</span>
<a href="#l46.357"></a><span id="l46.357" class="difflineplus">+    let msg2 = this._msgGen.makeMessage(msg1);</span>
<a href="#l46.358"></a><span id="l46.358" class="difflineplus">+    let msg3 = this._msgGen.makeMessage(msg2);</span>
<a href="#l46.359"></a><span id="l46.359" class="difflineplus">+    return [msg1, msg3];</span>
<a href="#l46.360"></a><span id="l46.360" class="difflineplus">+  },</span>
<a href="#l46.361"></a><span id="l46.361" class="difflineplus">+  </span>
<a href="#l46.362"></a><span id="l46.362" class="difflineplus">+  /**</span>
<a href="#l46.363"></a><span id="l46.363" class="difflineplus">+   * The root message and all non-leaf nodes have aChildrenPerParent children,</span>
<a href="#l46.364"></a><span id="l46.364" class="difflineplus">+   *  for a total of aHeight layers.  (If aHeight is 1, we have just the root;</span>
<a href="#l46.365"></a><span id="l46.365" class="difflineplus">+   *  if aHeight is 2, the root and his aChildrePerParent children.)</span>
<a href="#l46.366"></a><span id="l46.366" class="difflineplus">+   */</span>
<a href="#l46.367"></a><span id="l46.367" class="difflineplus">+  fullPyramid: function(aChildrenPerParent, aHeight) {</span>
<a href="#l46.368"></a><span id="l46.368" class="difflineplus">+    let msgGen = this._msgGen;</span>
<a href="#l46.369"></a><span id="l46.369" class="difflineplus">+    let root = msgGen.makeMessage();</span>
<a href="#l46.370"></a><span id="l46.370" class="difflineplus">+    let messages = [root];</span>
<a href="#l46.371"></a><span id="l46.371" class="difflineplus">+    function helper(aParent, aRemDepth) {</span>
<a href="#l46.372"></a><span id="l46.372" class="difflineplus">+      for (let iChild = 0; iChild &lt; aChildrenPerParent; iChild++) {</span>
<a href="#l46.373"></a><span id="l46.373" class="difflineplus">+        let child = msgGen.makeMessage(aParent);</span>
<a href="#l46.374"></a><span id="l46.374" class="difflineplus">+        messages.push(child);</span>
<a href="#l46.375"></a><span id="l46.375" class="difflineplus">+        if (aRemDepth)</span>
<a href="#l46.376"></a><span id="l46.376" class="difflineplus">+          helper(child, aRemDepth - 1);</span>
<a href="#l46.377"></a><span id="l46.377" class="difflineplus">+      }</span>
<a href="#l46.378"></a><span id="l46.378" class="difflineplus">+    }</span>
<a href="#l46.379"></a><span id="l46.379" class="difflineplus">+    if (aHeight &gt; 1)</span>
<a href="#l46.380"></a><span id="l46.380" class="difflineplus">+      helper(root, aHeight - 2);</span>
<a href="#l46.381"></a><span id="l46.381" class="difflineplus">+    return messages;</span>
<a href="#l46.382"></a><span id="l46.382" class="difflineplus">+  }</span>
<a href="#l46.383"></a><span id="l46.383" class="difflineplus">+}</span>
<a href="#l46.384"></a><span id="l46.384" class="difflineplus">+</span>
<a href="#l46.385"></a><span id="l46.385" class="difflineplus">+/**</span>
<a href="#l46.386"></a><span id="l46.386" class="difflineplus">+ * Decorate the given object's methods will python-style method binding.  We</span>
<a href="#l46.387"></a><span id="l46.387" class="difflineplus">+ *  create a getter that returns a method that wraps the call, providing the</span>
<a href="#l46.388"></a><span id="l46.388" class="difflineplus">+ *  actual method with the 'this' of the object that was 'this' when the getter</span>
<a href="#l46.389"></a><span id="l46.389" class="difflineplus">+ *  was called.</span>
<a href="#l46.390"></a><span id="l46.390" class="difflineplus">+ */</span>
<a href="#l46.391"></a><span id="l46.391" class="difflineplus">+function bindMethods(aObj) {</span>
<a href="#l46.392"></a><span id="l46.392" class="difflineplus">+  for (let [name, ubfunc] in Iterator(aObj)) {</span>
<a href="#l46.393"></a><span id="l46.393" class="difflineplus">+    // the variable binding needs to get captured...</span>
<a href="#l46.394"></a><span id="l46.394" class="difflineplus">+    let realFunc = ubfunc;</span>
<a href="#l46.395"></a><span id="l46.395" class="difflineplus">+    let getterFunc = function() {</span>
<a href="#l46.396"></a><span id="l46.396" class="difflineplus">+      // 'this' is magic and not from the enclosing scope.  we are assuming the</span>
<a href="#l46.397"></a><span id="l46.397" class="difflineplus">+      //  getter will receive a valid 'this', and so</span>
<a href="#l46.398"></a><span id="l46.398" class="difflineplus">+      let realThis = this;</span>
<a href="#l46.399"></a><span id="l46.399" class="difflineplus">+      return function() { return realFunc.apply(realThis, arguments); };</span>
<a href="#l46.400"></a><span id="l46.400" class="difflineplus">+    }</span>
<a href="#l46.401"></a><span id="l46.401" class="difflineplus">+    delete aObj[name];</span>
<a href="#l46.402"></a><span id="l46.402" class="difflineplus">+    aObj.__defineGetter__(name, getterFunc);</span>
<a href="#l46.403"></a><span id="l46.403" class="difflineplus">+  }</span>
<a href="#l46.404"></a><span id="l46.404" class="difflineplus">+}</span>
<a href="#l46.405"></a><span id="l46.405" class="difflineplus">+</span>
<a href="#l46.406"></a><span id="l46.406" class="difflineplus">+bindMethods(MessageScenarioFactory.prototype);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1">new file mode 100644</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1">new file mode 100644</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineminus">--- /dev/null</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages.js</span>
<a href="#l48.4"></a><span id="l48.4" class="difflineat">@@ -0,0 +1,177 @@</span>
<a href="#l48.5"></a><span id="l48.5" class="difflineplus">+/* This file tests our indexing prowess.  This includes both our ability to</span>
<a href="#l48.6"></a><span id="l48.6" class="difflineplus">+ *  properly be triggered by events taking place in thunderbird as well as our</span>
<a href="#l48.7"></a><span id="l48.7" class="difflineplus">+ *  ability to correctly extract/index the right data.</span>
<a href="#l48.8"></a><span id="l48.8" class="difflineplus">+ * In general, if these tests pass, things are probably working quite well.</span>
<a href="#l48.9"></a><span id="l48.9" class="difflineplus">+ *</span>
<a href="#l48.10"></a><span id="l48.10" class="difflineplus">+ * Things we don't test that you think we might test:</span>
<a href="#l48.11"></a><span id="l48.11" class="difflineplus">+ * - Full-text search.  Happens in query testing.</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineplus">+ */</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineplus">+</span>
<a href="#l48.14"></a><span id="l48.14" class="difflineplus">+do_import_script(&quot;../mailnews/db/global/test/resources/messageGenerator.js&quot;);</span>
<a href="#l48.15"></a><span id="l48.15" class="difflineplus">+</span>
<a href="#l48.16"></a><span id="l48.16" class="difflineplus">+//these are imported by glodaTestHelper's import of head_maillocal</span>
<a href="#l48.17"></a><span id="l48.17" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailDirService.js&quot;);</span>
<a href="#l48.18"></a><span id="l48.18" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailTestUtils.js&quot;);</span>
<a href="#l48.19"></a><span id="l48.19" class="difflineplus">+do_import_script(&quot;../mailnews/db/global/test/resources/glodaTestHelper.js&quot;);</span>
<a href="#l48.20"></a><span id="l48.20" class="difflineplus">+</span>
<a href="#l48.21"></a><span id="l48.21" class="difflineplus">+// Create a message generator</span>
<a href="#l48.22"></a><span id="l48.22" class="difflineplus">+var msgGen = new MessageGenerator();</span>
<a href="#l48.23"></a><span id="l48.23" class="difflineplus">+// Create a message scenario generator using that message generator</span>
<a href="#l48.24"></a><span id="l48.24" class="difflineplus">+var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l48.25"></a><span id="l48.25" class="difflineplus">+</span>
<a href="#l48.26"></a><span id="l48.26" class="difflineplus">+/* ===== Threading / Conversation Grouping ===== */</span>
<a href="#l48.27"></a><span id="l48.27" class="difflineplus">+</span>
<a href="#l48.28"></a><span id="l48.28" class="difflineplus">+function allMessageInSameConversation(aSynthMessage, aGlodaMessage, aConvID) {</span>
<a href="#l48.29"></a><span id="l48.29" class="difflineplus">+  if (aConvID === undefined)</span>
<a href="#l48.30"></a><span id="l48.30" class="difflineplus">+    return aGlodaMessage.conversationID;</span>
<a href="#l48.31"></a><span id="l48.31" class="difflineplus">+  do_check_eq(aConvID, aGlodaMessage.conversationID);</span>
<a href="#l48.32"></a><span id="l48.32" class="difflineplus">+  return aConvID;</span>
<a href="#l48.33"></a><span id="l48.33" class="difflineplus">+}</span>
<a href="#l48.34"></a><span id="l48.34" class="difflineplus">+</span>
<a href="#l48.35"></a><span id="l48.35" class="difflineplus">+/**</span>
<a href="#l48.36"></a><span id="l48.36" class="difflineplus">+ * Test our conversation/threading logic in the straight-forward direct</span>
<a href="#l48.37"></a><span id="l48.37" class="difflineplus">+ *  reply case, the missing intermediary case, and the siblings with missing</span>
<a href="#l48.38"></a><span id="l48.38" class="difflineplus">+ *  parent case.  We also test all permutations of receipt of those messages.</span>
<a href="#l48.39"></a><span id="l48.39" class="difflineplus">+ * (Also tests that we index new messages.)</span>
<a href="#l48.40"></a><span id="l48.40" class="difflineplus">+ */</span>
<a href="#l48.41"></a><span id="l48.41" class="difflineplus">+function test_threading() {</span>
<a href="#l48.42"></a><span id="l48.42" class="difflineplus">+  indexAndPermuteMessages(scenarios.directReply,</span>
<a href="#l48.43"></a><span id="l48.43" class="difflineplus">+                          allMessageInSameConversation);</span>
<a href="#l48.44"></a><span id="l48.44" class="difflineplus">+  indexAndPermuteMessages(scenarios.missingIntermediary,</span>
<a href="#l48.45"></a><span id="l48.45" class="difflineplus">+                          allMessageInSameConversation);</span>
<a href="#l48.46"></a><span id="l48.46" class="difflineplus">+  indexAndPermuteMessages(scenarios.siblingsMissingParent,</span>
<a href="#l48.47"></a><span id="l48.47" class="difflineplus">+                          allMessageInSameConversation,</span>
<a href="#l48.48"></a><span id="l48.48" class="difflineplus">+                          next_test);</span>
<a href="#l48.49"></a><span id="l48.49" class="difflineplus">+}</span>
<a href="#l48.50"></a><span id="l48.50" class="difflineplus">+</span>
<a href="#l48.51"></a><span id="l48.51" class="difflineplus">+/* ===== Fundamental Attributes (per fundattr.js) ===== */</span>
<a href="#l48.52"></a><span id="l48.52" class="difflineplus">+</span>
<a href="#l48.53"></a><span id="l48.53" class="difflineplus">+/**</span>
<a href="#l48.54"></a><span id="l48.54" class="difflineplus">+ * Test that we extract the 'fundamental attributes' of a message properly</span>
<a href="#l48.55"></a><span id="l48.55" class="difflineplus">+ *  'Fundamental' in this case is talking about the attributes defined/extracted</span>
<a href="#l48.56"></a><span id="l48.56" class="difflineplus">+ *  by gloda's fundattr.js and perhaps the core message indexing logic itself</span>
<a href="#l48.57"></a><span id="l48.57" class="difflineplus">+ *  (which show up as kSpecial* attributes in fundattr.js anyways.)</span>
<a href="#l48.58"></a><span id="l48.58" class="difflineplus">+ */</span>
<a href="#l48.59"></a><span id="l48.59" class="difflineplus">+function test_attributes_fundamental() {</span>
<a href="#l48.60"></a><span id="l48.60" class="difflineplus">+  // create a synthetic message</span>
<a href="#l48.61"></a><span id="l48.61" class="difflineplus">+  let smsg = msgGen.makeMessage();</span>
<a href="#l48.62"></a><span id="l48.62" class="difflineplus">+  </span>
<a href="#l48.63"></a><span id="l48.63" class="difflineplus">+  indexMessages([smsg], verify_attributes_fundamental, next_test);</span>
<a href="#l48.64"></a><span id="l48.64" class="difflineplus">+}</span>
<a href="#l48.65"></a><span id="l48.65" class="difflineplus">+</span>
<a href="#l48.66"></a><span id="l48.66" class="difflineplus">+function verify_attributes_fundamental(smsg, gmsg) {</span>
<a href="#l48.67"></a><span id="l48.67" class="difflineplus">+  do_check_eq(gmsg.folderURI, gLocalInboxFolder.URI);</span>
<a href="#l48.68"></a><span id="l48.68" class="difflineplus">+  </span>
<a href="#l48.69"></a><span id="l48.69" class="difflineplus">+  // -- subject</span>
<a href="#l48.70"></a><span id="l48.70" class="difflineplus">+  do_check_eq(smsg.subject, gmsg.conversation.subject);</span>
<a href="#l48.71"></a><span id="l48.71" class="difflineplus">+  </span>
<a href="#l48.72"></a><span id="l48.72" class="difflineplus">+  // -- contact/identity information</span>
<a href="#l48.73"></a><span id="l48.73" class="difflineplus">+  // - from</span>
<a href="#l48.74"></a><span id="l48.74" class="difflineplus">+  // check the e-mail address</span>
<a href="#l48.75"></a><span id="l48.75" class="difflineplus">+  do_check_eq(gmsg.from.kind, &quot;email&quot;);</span>
<a href="#l48.76"></a><span id="l48.76" class="difflineplus">+  do_check_eq(smsg.fromAddress, gmsg.from.value);</span>
<a href="#l48.77"></a><span id="l48.77" class="difflineplus">+  // check the name</span>
<a href="#l48.78"></a><span id="l48.78" class="difflineplus">+  do_check_eq(smsg.fromName, gmsg.from.contact.name);</span>
<a href="#l48.79"></a><span id="l48.79" class="difflineplus">+  </span>
<a href="#l48.80"></a><span id="l48.80" class="difflineplus">+  // - to</span>
<a href="#l48.81"></a><span id="l48.81" class="difflineplus">+  do_check_eq(smsg.toAddress, gmsg.to[0].value);</span>
<a href="#l48.82"></a><span id="l48.82" class="difflineplus">+  do_check_eq(smsg.toName, gmsg.to[0].contact.name);</span>
<a href="#l48.83"></a><span id="l48.83" class="difflineplus">+  </span>
<a href="#l48.84"></a><span id="l48.84" class="difflineplus">+  // date</span>
<a href="#l48.85"></a><span id="l48.85" class="difflineplus">+  do_check_eq(smsg.date.valueOf(), gmsg.date.valueOf());</span>
<a href="#l48.86"></a><span id="l48.86" class="difflineplus">+}</span>
<a href="#l48.87"></a><span id="l48.87" class="difflineplus">+</span>
<a href="#l48.88"></a><span id="l48.88" class="difflineplus">+/* ===== Explicit Attributes (per explattr.js) ===== */</span>
<a href="#l48.89"></a><span id="l48.89" class="difflineplus">+</span>
<a href="#l48.90"></a><span id="l48.90" class="difflineplus">+function expl_attr_twiddle_star(aMsgHdr, aDesiredState) {</span>
<a href="#l48.91"></a><span id="l48.91" class="difflineplus">+  aMsgHdr.markFlagged(aDesiredState);</span>
<a href="#l48.92"></a><span id="l48.92" class="difflineplus">+}</span>
<a href="#l48.93"></a><span id="l48.93" class="difflineplus">+</span>
<a href="#l48.94"></a><span id="l48.94" class="difflineplus">+function expl_attr_verify_star(smsg, gmsg, aExpectedState) {</span>
<a href="#l48.95"></a><span id="l48.95" class="difflineplus">+  do_check_eq(gmsg.starred, aExpectedState);</span>
<a href="#l48.96"></a><span id="l48.96" class="difflineplus">+}</span>
<a href="#l48.97"></a><span id="l48.97" class="difflineplus">+</span>
<a href="#l48.98"></a><span id="l48.98" class="difflineplus">+function expl_attr_twiddle_read(aMsgHdr, aDesiredState) {</span>
<a href="#l48.99"></a><span id="l48.99" class="difflineplus">+  aMsgHdr.markRead(!aMsgHdr.isRead);</span>
<a href="#l48.100"></a><span id="l48.100" class="difflineplus">+}</span>
<a href="#l48.101"></a><span id="l48.101" class="difflineplus">+</span>
<a href="#l48.102"></a><span id="l48.102" class="difflineplus">+function expl_attr_verify_read(smsg, gmsg, aExpectedState) {</span>
<a href="#l48.103"></a><span id="l48.103" class="difflineplus">+  do_check_eq(gmsg.read, aExpectedState);</span>
<a href="#l48.104"></a><span id="l48.104" class="difflineplus">+}</span>
<a href="#l48.105"></a><span id="l48.105" class="difflineplus">+</span>
<a href="#l48.106"></a><span id="l48.106" class="difflineplus">+function expl_attr_twiddle_tags(aMsgHdr, aTagMods) {</span>
<a href="#l48.107"></a><span id="l48.107" class="difflineplus">+  // TODO: twiddle tags</span>
<a href="#l48.108"></a><span id="l48.108" class="difflineplus">+}</span>
<a href="#l48.109"></a><span id="l48.109" class="difflineplus">+</span>
<a href="#l48.110"></a><span id="l48.110" class="difflineplus">+function expl_attr_verify_tags(smsg, gmsg, aExpectedTags) {</span>
<a href="#l48.111"></a><span id="l48.111" class="difflineplus">+  // TODO: verify tags</span>
<a href="#l48.112"></a><span id="l48.112" class="difflineplus">+}</span>
<a href="#l48.113"></a><span id="l48.113" class="difflineplus">+</span>
<a href="#l48.114"></a><span id="l48.114" class="difflineplus">+var explicitAttributeTwiddlings = [</span>
<a href="#l48.115"></a><span id="l48.115" class="difflineplus">+  // toggle starred</span>
<a href="#l48.116"></a><span id="l48.116" class="difflineplus">+  [expl_attr_twiddle_star, expl_attr_verify_star, true],</span>
<a href="#l48.117"></a><span id="l48.117" class="difflineplus">+  [expl_attr_twiddle_star, expl_attr_verify_star, false],</span>
<a href="#l48.118"></a><span id="l48.118" class="difflineplus">+  // toggle read/unread</span>
<a href="#l48.119"></a><span id="l48.119" class="difflineplus">+  [expl_attr_twiddle_read, expl_attr_verify_read, true],</span>
<a href="#l48.120"></a><span id="l48.120" class="difflineplus">+  [expl_attr_twiddle_read, expl_attr_verify_read, false]/*,</span>
<a href="#l48.121"></a><span id="l48.121" class="difflineplus">+  // twiddle tags</span>
<a href="#l48.122"></a><span id="l48.122" class="difflineplus">+  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l48.123"></a><span id="l48.123" class="difflineplus">+   [1, &quot;funky&quot;], [&quot;funky&quot;]],</span>
<a href="#l48.124"></a><span id="l48.124" class="difflineplus">+  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l48.125"></a><span id="l48.125" class="difflineplus">+   [1, &quot;town&quot;], [&quot;funky&quot;, &quot;town&quot;]],</span>
<a href="#l48.126"></a><span id="l48.126" class="difflineplus">+  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l48.127"></a><span id="l48.127" class="difflineplus">+   [-1, &quot;funky&quot;], [&quot;town&quot;]],</span>
<a href="#l48.128"></a><span id="l48.128" class="difflineplus">+  [expl_attr_twiddle_tags, expl_attr_verify_tags,</span>
<a href="#l48.129"></a><span id="l48.129" class="difflineplus">+   [-1, &quot;town&quot;], []],</span>
<a href="#l48.130"></a><span id="l48.130" class="difflineplus">+*/</span>
<a href="#l48.131"></a><span id="l48.131" class="difflineplus">+];</span>
<a href="#l48.132"></a><span id="l48.132" class="difflineplus">+</span>
<a href="#l48.133"></a><span id="l48.133" class="difflineplus">+</span>
<a href="#l48.134"></a><span id="l48.134" class="difflineplus">+function test_attributes_explicit() {</span>
<a href="#l48.135"></a><span id="l48.135" class="difflineplus">+  let smsg = msgGen.makeMessage();</span>
<a href="#l48.136"></a><span id="l48.136" class="difflineplus">+</span>
<a href="#l48.137"></a><span id="l48.137" class="difflineplus">+  twiddleAndTest(smsg, explicitAttributeTwiddlings);</span>
<a href="#l48.138"></a><span id="l48.138" class="difflineplus">+}</span>
<a href="#l48.139"></a><span id="l48.139" class="difflineplus">+</span>
<a href="#l48.140"></a><span id="l48.140" class="difflineplus">+function do_moveMessage(aMsgHdr, aDestFolder) {</span>
<a href="#l48.141"></a><span id="l48.141" class="difflineplus">+  gCopyService.CopyMessages(aMsgHdr.folder, toXPArray(aMsgHdr),</span>
<a href="#l48.142"></a><span id="l48.142" class="difflineplus">+                            aDestFolder, true, null, null, true);</span>
<a href="#l48.143"></a><span id="l48.143" class="difflineplus">+}</span>
<a href="#l48.144"></a><span id="l48.144" class="difflineplus">+</span>
<a href="#l48.145"></a><span id="l48.145" class="difflineplus">+function verify_messageLocation(aMsgHdr, aMessage, aDestFolder) {</span>
<a href="#l48.146"></a><span id="l48.146" class="difflineplus">+  do_check_eq(aMessage.folderURI, aDestFolder.URI); </span>
<a href="#l48.147"></a><span id="l48.147" class="difflineplus">+}</span>
<a href="#l48.148"></a><span id="l48.148" class="difflineplus">+</span>
<a href="#l48.149"></a><span id="l48.149" class="difflineplus">+/* ===== Message Moving ===== */</span>
<a href="#l48.150"></a><span id="l48.150" class="difflineplus">+const gCopyService = Cc[&quot;@mozilla.org/messenger/messagecopyservice;1&quot;]</span>
<a href="#l48.151"></a><span id="l48.151" class="difflineplus">+                      .getService(Ci.nsIMsgCopyService);</span>
<a href="#l48.152"></a><span id="l48.152" class="difflineplus">+</span>
<a href="#l48.153"></a><span id="l48.153" class="difflineplus">+function test_message_moving() {</span>
<a href="#l48.154"></a><span id="l48.154" class="difflineplus">+  let rootFolder = gLocalIncomingServer.rootMsgFolder;</span>
<a href="#l48.155"></a><span id="l48.155" class="difflineplus">+  let destFolder = rootFolder.addSubfolder(&quot;move1&quot;);</span>
<a href="#l48.156"></a><span id="l48.156" class="difflineplus">+  </span>
<a href="#l48.157"></a><span id="l48.157" class="difflineplus">+  let moveTestActions = [</span>
<a href="#l48.158"></a><span id="l48.158" class="difflineplus">+    [do_moveMessage, verify_messageLocation, destFolder],</span>
<a href="#l48.159"></a><span id="l48.159" class="difflineplus">+    [do_moveMessage, verify_messageLocation, gLocalInboxFolder],</span>
<a href="#l48.160"></a><span id="l48.160" class="difflineplus">+  ];</span>
<a href="#l48.161"></a><span id="l48.161" class="difflineplus">+  </span>
<a href="#l48.162"></a><span id="l48.162" class="difflineplus">+  let smsg = msgGen.makeMessage();</span>
<a href="#l48.163"></a><span id="l48.163" class="difflineplus">+  twiddleAndTest(smsg, moveTestActions);</span>
<a href="#l48.164"></a><span id="l48.164" class="difflineplus">+}</span>
<a href="#l48.165"></a><span id="l48.165" class="difflineplus">+</span>
<a href="#l48.166"></a><span id="l48.166" class="difflineplus">+/* ===== Message Deletion ===== */</span>
<a href="#l48.167"></a><span id="l48.167" class="difflineplus">+function test_message_deletion() {</span>
<a href="#l48.168"></a><span id="l48.168" class="difflineplus">+}</span>
<a href="#l48.169"></a><span id="l48.169" class="difflineplus">+</span>
<a href="#l48.170"></a><span id="l48.170" class="difflineplus">+/* ===== Folder Move/Rename/Copy (Single and Nested) ===== */</span>
<a href="#l48.171"></a><span id="l48.171" class="difflineplus">+</span>
<a href="#l48.172"></a><span id="l48.172" class="difflineplus">+</span>
<a href="#l48.173"></a><span id="l48.173" class="difflineplus">+var tests = [</span>
<a href="#l48.174"></a><span id="l48.174" class="difflineplus">+  test_threading,</span>
<a href="#l48.175"></a><span id="l48.175" class="difflineplus">+  test_attributes_fundamental,</span>
<a href="#l48.176"></a><span id="l48.176" class="difflineplus">+  test_attributes_explicit,</span>
<a href="#l48.177"></a><span id="l48.177" class="difflineplus">+];</span>
<a href="#l48.178"></a><span id="l48.178" class="difflineplus">+</span>
<a href="#l48.179"></a><span id="l48.179" class="difflineplus">+function run_test() {</span>
<a href="#l48.180"></a><span id="l48.180" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l48.181"></a><span id="l48.181" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1">new file mode 100644</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineminus">--- /dev/null</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_messages_in_bulk.js</span>
<a href="#l49.4"></a><span id="l49.4" class="difflineat">@@ -0,0 +1,39 @@</span>
<a href="#l49.5"></a><span id="l49.5" class="difflineplus">+/*</span>
<a href="#l49.6"></a><span id="l49.6" class="difflineplus">+ * This file tests indexing a whole bunch of messages at once.  We</span>
<a href="#l49.7"></a><span id="l49.7" class="difflineplus">+ * are primarily concerned about memory utilization and processor load.</span>
<a href="#l49.8"></a><span id="l49.8" class="difflineplus">+ */</span>
<a href="#l49.9"></a><span id="l49.9" class="difflineplus">+</span>
<a href="#l49.10"></a><span id="l49.10" class="difflineplus">+do_import_script(&quot;../mailnews/db/global/test/resources/messageGenerator.js&quot;);</span>
<a href="#l49.11"></a><span id="l49.11" class="difflineplus">+</span>
<a href="#l49.12"></a><span id="l49.12" class="difflineplus">+//these are imported by glodaTestHelper's import of head_maillocal</span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailDirService.js&quot;);</span>
<a href="#l49.14"></a><span id="l49.14" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailTestUtils.js&quot;);</span>
<a href="#l49.15"></a><span id="l49.15" class="difflineplus">+do_import_script(&quot;../mailnews/db/global/test/resources/glodaTestHelper.js&quot;);</span>
<a href="#l49.16"></a><span id="l49.16" class="difflineplus">+</span>
<a href="#l49.17"></a><span id="l49.17" class="difflineplus">+// Create a message generator</span>
<a href="#l49.18"></a><span id="l49.18" class="difflineplus">+var msgGen = new MessageGenerator();</span>
<a href="#l49.19"></a><span id="l49.19" class="difflineplus">+// Create a message scenario generator using that message generator</span>
<a href="#l49.20"></a><span id="l49.20" class="difflineplus">+var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l49.21"></a><span id="l49.21" class="difflineplus">+</span>
<a href="#l49.22"></a><span id="l49.22" class="difflineplus">+/**</span>
<a href="#l49.23"></a><span id="l49.23" class="difflineplus">+ * Provide a bunch of messages to be indexed.</span>
<a href="#l49.24"></a><span id="l49.24" class="difflineplus">+ */</span>
<a href="#l49.25"></a><span id="l49.25" class="difflineplus">+function test_index_a_bunch() {</span>
<a href="#l49.26"></a><span id="l49.26" class="difflineplus">+  // 4-children-per, 3-deep = 21</span>
<a href="#l49.27"></a><span id="l49.27" class="difflineplus">+  // 4-children-per, 4-deep = 85</span>
<a href="#l49.28"></a><span id="l49.28" class="difflineplus">+  // 4-children-per, 5-deep pyramid = 341</span>
<a href="#l49.29"></a><span id="l49.29" class="difflineplus">+  // 5-children-per, 5-deep pyramid = 781</span>
<a href="#l49.30"></a><span id="l49.30" class="difflineplus">+  // 4-children-per, 6-deep pyramid = 1365 messages</span>
<a href="#l49.31"></a><span id="l49.31" class="difflineplus">+  let messages = scenarios.fullPyramid(4, 3);</span>
<a href="#l49.32"></a><span id="l49.32" class="difflineplus">+  // we have no need to verify.</span>
<a href="#l49.33"></a><span id="l49.33" class="difflineplus">+  indexMessages(messages, null, next_test);</span>
<a href="#l49.34"></a><span id="l49.34" class="difflineplus">+}</span>
<a href="#l49.35"></a><span id="l49.35" class="difflineplus">+</span>
<a href="#l49.36"></a><span id="l49.36" class="difflineplus">+var tests = [</span>
<a href="#l49.37"></a><span id="l49.37" class="difflineplus">+  test_index_a_bunch,</span>
<a href="#l49.38"></a><span id="l49.38" class="difflineplus">+];</span>
<a href="#l49.39"></a><span id="l49.39" class="difflineplus">+</span>
<a href="#l49.40"></a><span id="l49.40" class="difflineplus">+function run_test() {</span>
<a href="#l49.41"></a><span id="l49.41" class="difflineplus">+  injectMessagesUsing(INJECT_MBOX);</span>
<a href="#l49.42"></a><span id="l49.42" class="difflineplus">+  glodaHelperRunTests(tests);</span>
<a href="#l49.43"></a><span id="l49.43" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1">new file mode 100644</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineminus">--- /dev/null</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_query_messages.js</span>
<a href="#l50.4"></a><span id="l50.4" class="difflineat">@@ -0,0 +1,66 @@</span>
<a href="#l50.5"></a><span id="l50.5" class="difflineplus">+/* This file tests our querying support, including full-text search.</span>
<a href="#l50.6"></a><span id="l50.6" class="difflineplus">+ */</span>
<a href="#l50.7"></a><span id="l50.7" class="difflineplus">+</span>
<a href="#l50.8"></a><span id="l50.8" class="difflineplus">+do_import_script(&quot;../mailnews/db/global/test/resources/messageGenerator.js&quot;);</span>
<a href="#l50.9"></a><span id="l50.9" class="difflineplus">+</span>
<a href="#l50.10"></a><span id="l50.10" class="difflineplus">+//these are imported by glodaTestHelper's import of head_maillocal</span>
<a href="#l50.11"></a><span id="l50.11" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailDirService.js&quot;);</span>
<a href="#l50.12"></a><span id="l50.12" class="difflineplus">+// do_import_script(&quot;../mailnews/test/resources/mailTestUtils.js&quot;);</span>
<a href="#l50.13"></a><span id="l50.13" class="difflineplus">+do_import_script(&quot;../mailnews/db/global/test/resources/glodaTestHelper.js&quot;);</span>
<a href="#l50.14"></a><span id="l50.14" class="difflineplus">+</span>
<a href="#l50.15"></a><span id="l50.15" class="difflineplus">+// Create a message generator</span>
<a href="#l50.16"></a><span id="l50.16" class="difflineplus">+var msgGen = new MessageGenerator();</span>
<a href="#l50.17"></a><span id="l50.17" class="difflineplus">+// Create a message scenario generator using that message generator</span>
<a href="#l50.18"></a><span id="l50.18" class="difflineplus">+var scenarios = new MessageScenarioFactory(msgGen);</span>
<a href="#l50.19"></a><span id="l50.19" class="difflineplus">+</span>
<a href="#l50.20"></a><span id="l50.20" class="difflineplus">+/* ===== Non-text queries ===== */</span>
<a href="#l50.21"></a><span id="l50.21" class="difflineplus">+</span>
<a href="#l50.22"></a><span id="l50.22" class="difflineplus">+/* === messages === */</span>
<a href="#l50.23"></a><span id="l50.23" class="difflineplus">+</span>
<a href="#l50.24"></a><span id="l50.24" class="difflineplus">+function test_query_messages_by_conversation() {</span>
<a href="#l50.25"></a><span id="l50.25" class="difflineplus">+}</span>
<a href="#l50.26"></a><span id="l50.26" class="difflineplus">+</span>
<a href="#l50.27"></a><span id="l50.27" class="difflineplus">+function test_query_messages_by_folder() {</span>
<a href="#l50.28"></a><span id="l50.28" class="difflineplus">+}</span>
<a href="#l50.29"></a><span id="l50.29" class="difflineplus">+</span>
<a href="#l50.30"></a><span id="l50.30" class="difflineplus">+function test_query_messages_by_identity() {</span>
<a href="#l50.31"></a><span id="l50.31" class="difflineplus">+}</span>
<a href="#l50.32"></a><span id="l50.32" class="difflineplus">+</span>
<a href="#l50.33"></a><span id="l50.33" class="difflineplus">+function test_query_messages_by_contact() {</span>
<a href="#l50.34"></a><span id="l50.34" class="difflineplus">+}</span>
<a href="#l50.35"></a><span id="l50.35" class="difflineplus">+</span>
<a href="#l50.36"></a><span id="l50.36" class="difflineplus">+function test_query_messages_by_date() {</span>
<a href="#l50.37"></a><span id="l50.37" class="difflineplus">+}</span>
<a href="#l50.38"></a><span id="l50.38" class="difflineplus">+</span>
<a href="#l50.39"></a><span id="l50.39" class="difflineplus">+/* === contacts === */</span>
<a href="#l50.40"></a><span id="l50.40" class="difflineplus">+function test_query_contacts_by_popularity() {</span>
<a href="#l50.41"></a><span id="l50.41" class="difflineplus">+}</span>
<a href="#l50.42"></a><span id="l50.42" class="difflineplus">+</span>
<a href="#l50.43"></a><span id="l50.43" class="difflineplus">+/* === identities === */</span>
<a href="#l50.44"></a><span id="l50.44" class="difflineplus">+</span>
<a href="#l50.45"></a><span id="l50.45" class="difflineplus">+/* ===== Text-based queries ===== */</span>
<a href="#l50.46"></a><span id="l50.46" class="difflineplus">+</span>
<a href="#l50.47"></a><span id="l50.47" class="difflineplus">+/* === conversations === */</span>
<a href="#l50.48"></a><span id="l50.48" class="difflineplus">+</span>
<a href="#l50.49"></a><span id="l50.49" class="difflineplus">+function test_query_conversations_by_subject_text() {</span>
<a href="#l50.50"></a><span id="l50.50" class="difflineplus">+}</span>
<a href="#l50.51"></a><span id="l50.51" class="difflineplus">+</span>
<a href="#l50.52"></a><span id="l50.52" class="difflineplus">+/* === messages === */</span>
<a href="#l50.53"></a><span id="l50.53" class="difflineplus">+</span>
<a href="#l50.54"></a><span id="l50.54" class="difflineplus">+function test_query_messages_by_body_text() {</span>
<a href="#l50.55"></a><span id="l50.55" class="difflineplus">+}</span>
<a href="#l50.56"></a><span id="l50.56" class="difflineplus">+</span>
<a href="#l50.57"></a><span id="l50.57" class="difflineplus">+/* === contacts === */</span>
<a href="#l50.58"></a><span id="l50.58" class="difflineplus">+</span>
<a href="#l50.59"></a><span id="l50.59" class="difflineplus">+function test_query_contacts_by_name() {</span>
<a href="#l50.60"></a><span id="l50.60" class="difflineplus">+}</span>
<a href="#l50.61"></a><span id="l50.61" class="difflineplus">+</span>
<a href="#l50.62"></a><span id="l50.62" class="difflineplus">+/* === identities === */</span>
<a href="#l50.63"></a><span id="l50.63" class="difflineplus">+</span>
<a href="#l50.64"></a><span id="l50.64" class="difflineplus">+function test_query_identities_by_kind_and_value() {</span>
<a href="#l50.65"></a><span id="l50.65" class="difflineplus">+}</span>
<a href="#l50.66"></a><span id="l50.66" class="difflineplus">+</span>
<a href="#l50.67"></a><span id="l50.67" class="difflineplus">+/* ===== Driver ===== */</span>
<a href="#l50.68"></a><span id="l50.68" class="difflineplus">+</span>
<a href="#l50.69"></a><span id="l50.69" class="difflineplus">+function run_test() {</span>
<a href="#l50.70"></a><span id="l50.70" class="difflineplus">+}</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

