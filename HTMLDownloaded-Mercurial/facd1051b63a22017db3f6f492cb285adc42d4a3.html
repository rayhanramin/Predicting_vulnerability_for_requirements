<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 873:facd1051b63a22017db3f6f492cb285adc42d4a3</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ facd1051b63a22017db3f6f492cb285adc42d4a3" />
<meta property="og:url" content="/comm-central/rev/facd1051b63a22017db3f6f492cb285adc42d4a3" />
<meta property="og:description" content="horrible threading glitch resolved, and more!" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / facd1051b63a22017db3f6f492cb285adc42d4a3 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/facd1051b63a22017db3f6f492cb285adc42d4a3">shortlog</a> |
<a href="/comm-central/log/facd1051b63a22017db3f6f492cb285adc42d4a3">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/facd1051b63a22017db3f6f492cb285adc42d4a3">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/facd1051b63a22017db3f6f492cb285adc42d4a3">files</a> |
changeset |
<a href="/comm-central/raw-rev/facd1051b63a22017db3f6f492cb285adc42d4a3">raw</a>  | <a href="/comm-central/archive/facd1051b63a22017db3f6f492cb285adc42d4a3.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
horrible threading glitch resolved, and more!
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Mon, 11 Aug 2008 23:19:14 -0700</td></tr>

<tr>
 <td>changeset 873</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/facd1051b63a22017db3f6f492cb285adc42d4a3">facd1051b63a22017db3f6f492cb285adc42d4a3</a></td>
</tr>



<tr>
<td>parent 872</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/5d88161e7f2d5bedc4948ac9aeb991f4a65e515f">5d88161e7f2d5bedc4948ac9aeb991f4a65e515f</a>
</td>
</tr>

<tr>
<td>child 874</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/ffff2c63236afdda3988a7f01a1217eb76111a29">ffff2c63236afdda3988a7f01a1217eb76111a29</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=facd1051b63a22017db3f6f492cb285adc42d4a3">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">horrible threading glitch resolved, and more!
(I promise, my commit messages will be better once we hit a stable point.)</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/components/glmsgdbview.js">components/glmsgdbview.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/facd1051b63a22017db3f6f492cb285adc42d4a3/components/glmsgdbview.js">file</a> |
<a href="/comm-central/annotate/facd1051b63a22017db3f6f492cb285adc42d4a3/components/glmsgdbview.js">annotate</a> |
<a href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/components/glmsgdbview.js">diff</a> |
<a href="/comm-central/comparison/facd1051b63a22017db3f6f492cb285adc42d4a3/components/glmsgdbview.js">comparison</a> |
<a href="/comm-central/log/facd1051b63a22017db3f6f492cb285adc42d4a3/components/glmsgdbview.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/collection.js">file</a> |
<a href="/comm-central/annotate/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/collection.js">comparison</a> |
<a href="/comm-central/log/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/query.js">file</a> |
<a href="/comm-central/annotate/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/query.js">annotate</a> |
<a href="/comm-central/diff/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/query.js">diff</a> |
<a href="/comm-central/comparison/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/query.js">comparison</a> |
<a href="/comm-central/log/facd1051b63a22017db3f6f492cb285adc42d4a3/modules/query.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/glmsgdbview.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/glmsgdbview.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -51,17 +51,17 @@ var GlodaUtils = null;</span>
<a href="#l1.4"></a><span id="l1.4"> const MSG_FLAG_READ      = 0x0001;</span>
<a href="#l1.5"></a><span id="l1.5"> const MSG_FLAG_REPLIED   = 0x0002;</span>
<a href="#l1.6"></a><span id="l1.6"> const MSG_FLAG_FORWARDED = 0x1000;</span>
<a href="#l1.7"></a><span id="l1.7"> const MSG_FLAG_NEW       = 0x10000;</span>
<a href="#l1.8"></a><span id="l1.8"> // -- general use flags</span>
<a href="#l1.9"></a><span id="l1.9"> const MSG_FLAG_ATTACHMENT = 0x10000000;</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11"> const NO_SUCH_MESSAGE_KEY = 0xFFFFFFFF; // nsMsgKey_none</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-const NO_SUCH_VIEW_INDEX = -1;</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+const NO_SUCH_VIEW_INDEX = 0xFFFFFFFF;</span>
<a href="#l1.14"></a><span id="l1.14"> </span>
<a href="#l1.15"></a><span id="l1.15"> function messageStatusString(aFlags) {</span>
<a href="#l1.16"></a><span id="l1.16">   if (aFlags &amp; MSG_FLAG_REPLIED)</span>
<a href="#l1.17"></a><span id="l1.17">     return &quot;replied&quot;; // L10N-me</span>
<a href="#l1.18"></a><span id="l1.18">   if (aFlags &amp; MSG_FLAG_FORWARDED)</span>
<a href="#l1.19"></a><span id="l1.19">     return &quot;forwarded&quot;; // L10N-me</span>
<a href="#l1.20"></a><span id="l1.20">   if (aFlags &amp; MSG_FLAG_NEW)</span>
<a href="#l1.21"></a><span id="l1.21">     return &quot;new&quot;; // L10N-me</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -98,18 +98,20 @@ function GMTreeNode(aMessage) {</span>
<a href="#l1.23"></a><span id="l1.23">   this.children = null;</span>
<a href="#l1.24"></a><span id="l1.24">   this.open = false;</span>
<a href="#l1.25"></a><span id="l1.25">   this.level = 0;</span>
<a href="#l1.26"></a><span id="l1.26"> }</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28"> GMTreeNode.prototype = {</span>
<a href="#l1.29"></a><span id="l1.29">   setLevel: function(aLevel) {</span>
<a href="#l1.30"></a><span id="l1.30">     this.level = aLevel;</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-    for (let iChild=0; iChild &lt; this.children; iChild++) {</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineminus">-      this.children[iChild].setLevel(aLevel+1);</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+    if (this.children) {</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+      for (let iChild=0; iChild &lt; this.children.length; iChild++) {</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+        this.children[iChild].setLevel(aLevel+1);</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+      }</span>
<a href="#l1.37"></a><span id="l1.37">     }</span>
<a href="#l1.38"></a><span id="l1.38">   },</span>
<a href="#l1.39"></a><span id="l1.39">   </span>
<a href="#l1.40"></a><span id="l1.40">   get nodesInSubTree() {</span>
<a href="#l1.41"></a><span id="l1.41">     let numNodes = 1;</span>
<a href="#l1.42"></a><span id="l1.42">     if (this.children) {</span>
<a href="#l1.43"></a><span id="l1.43">       for (let iChild=0; iChild &lt; this.children.length; iChild++)</span>
<a href="#l1.44"></a><span id="l1.44">         numNodes += this.children[iChild].nodesInSubTree;</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineat">@@ -124,60 +126,58 @@ GMTreeNode.prototype = {</span>
<a href="#l1.46"></a><span id="l1.46">       for (let iChild=0; iChild &lt; this.children.length; iChild++)</span>
<a href="#l1.47"></a><span id="l1.47">         numUnread += this.children[iChild].unreadInSubTree;</span>
<a href="#l1.48"></a><span id="l1.48">     }</span>
<a href="#l1.49"></a><span id="l1.49">     return numUnread;</span>
<a href="#l1.50"></a><span id="l1.50">   },</span>
<a href="#l1.51"></a><span id="l1.51"> };</span>
<a href="#l1.52"></a><span id="l1.52"> </span>
<a href="#l1.53"></a><span id="l1.53"> function GlodaMsgDBView() {</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineminus">-dump(&quot;GlodaMsgDBView constructor entry\n&quot;);</span>
<a href="#l1.55"></a><span id="l1.55">   this._messenger = null;</span>
<a href="#l1.56"></a><span id="l1.56">   this._msgWindow = null;</span>
<a href="#l1.57"></a><span id="l1.57">   this._commandUpdater = null;</span>
<a href="#l1.58"></a><span id="l1.58"> </span>
<a href="#l1.59"></a><span id="l1.59">   this._sortType = Ci.nsMsgViewSortType.byDate;</span>
<a href="#l1.60"></a><span id="l1.60">   this._sortOrder = SORT_DESCENDING;</span>
<a href="#l1.61"></a><span id="l1.61">   this._viewFlags = Ci.nsMsgViewFlagsType.kNone;</span>
<a href="#l1.62"></a><span id="l1.62">   </span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+  this._collection = null;</span>
<a href="#l1.64"></a><span id="l1.64">   this._messages = [];</span>
<a href="#l1.65"></a><span id="l1.65">   this._toplevelNodes = [];</span>
<a href="#l1.66"></a><span id="l1.66">   this._rows = [];</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+  this._idToNode = null;</span>
<a href="#l1.68"></a><span id="l1.68">   </span>
<a href="#l1.69"></a><span id="l1.69">   this._customColumns = {};</span>
<a href="#l1.70"></a><span id="l1.70">   this._customSortColumn = null;</span>
<a href="#l1.71"></a><span id="l1.71">   </span>
<a href="#l1.72"></a><span id="l1.72">   this._treeSelection = null;</span>
<a href="#l1.73"></a><span id="l1.73">   this._selectedNodes = null;</span>
<a href="#l1.74"></a><span id="l1.74">   this._selectedIndices = null;</span>
<a href="#l1.75"></a><span id="l1.75">   </span>
<a href="#l1.76"></a><span id="l1.76">   //: the currently displayed message's node</span>
<a href="#l1.77"></a><span id="l1.77">   this._displayedNode = null;</span>
<a href="#l1.78"></a><span id="l1.78">   </span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+  this._suppressDisplay = false;</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+  </span>
<a href="#l1.81"></a><span id="l1.81">   // set up our awesome globals!</span>
<a href="#l1.82"></a><span id="l1.82">   if (Gloda === null) {</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineminus">-dump(&quot;GlodaMsgDBView loading globals\n&quot;);</span>
<a href="#l1.84"></a><span id="l1.84">     let loadNS = {};</span>
<a href="#l1.85"></a><span id="l1.85">     Cu.import(&quot;resource://gloda/modules/gloda.js&quot;, loadNS);</span>
<a href="#l1.86"></a><span id="l1.86">     Gloda = loadNS.Gloda;</span>
<a href="#l1.87"></a><span id="l1.87">     Cu.import(&quot;resource://gloda/modules/utils.js&quot;, loadNS);</span>
<a href="#l1.88"></a><span id="l1.88">     GlodaUtils = loadNS.GlodaUtils;</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineminus">-dump(&quot;GlodaMsgDBView globals loaded (Gloda: &quot; + Gloda + &quot;, GlodaUtils:&quot; + </span>
<a href="#l1.90"></a><span id="l1.90" class="difflineminus">-     GlodaUtils + &quot;\n&quot;);</span>
<a href="#l1.91"></a><span id="l1.91">   }</span>
<a href="#l1.92"></a><span id="l1.92">   </span>
<a href="#l1.93"></a><span id="l1.93" class="difflineminus">-dump(&quot;GlodaMsgDBView comparison func inits\n&quot;);</span>
<a href="#l1.94"></a><span id="l1.94">   try {</span>
<a href="#l1.95"></a><span id="l1.95">     this._initComparisonFuncs();</span>
<a href="#l1.96"></a><span id="l1.96">   }</span>
<a href="#l1.97"></a><span id="l1.97">   catch (ex) {</span>
<a href="#l1.98"></a><span id="l1.98">     dump(&quot;Exception (source: &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;) &quot; +</span>
<a href="#l1.99"></a><span id="l1.99">          ex + &quot;\n&quot;);</span>
<a href="#l1.100"></a><span id="l1.100">   }</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineminus">-dump(&quot;GlodaMsgDBView constructor completion\n&quot;);</span>
<a href="#l1.102"></a><span id="l1.102"> }</span>
<a href="#l1.103"></a><span id="l1.103"> </span>
<a href="#l1.104"></a><span id="l1.104"> GlodaMsgDBView.prototype = {</span>
<a href="#l1.105"></a><span id="l1.105">   classDescription: &quot;Gloda Message View&quot;,</span>
<a href="#l1.106"></a><span id="l1.106">   classID: Components.ID(&quot;{b7979f43-0188-445a-92e0-492350047254}&quot;),</span>
<a href="#l1.107"></a><span id="l1.107">   contractID: &quot;@mozilla.org/messenger/msgdbview;1?type=gloda&quot;,</span>
<a href="#l1.108"></a><span id="l1.108">   </span>
<a href="#l1.109"></a><span id="l1.109">   QueryInterface: XPCOMUtils.generateQI([Ci.nsIMsgDBView,</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineat">@@ -328,42 +328,59 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.111"></a><span id="l1.111">     };</span>
<a href="#l1.112"></a><span id="l1.112">     // Ci.nsMsgViewSortType.byCustom is handled specially</span>
<a href="#l1.113"></a><span id="l1.113">     this._comparisonFuncs[Ci.nsMsgViewSortType.byReceived] = function(a, b) {</span>
<a href="#l1.114"></a><span id="l1.114">       let aRec = a.message.folderMessage.getUint32Property(&quot;dateReceived&quot;);</span>
<a href="#l1.115"></a><span id="l1.115">       let bRec = b.message.folderMessage.getUint32Property(&quot;dateReceived&quot;);</span>
<a href="#l1.116"></a><span id="l1.116">       return aRec - bRec;</span>
<a href="#l1.117"></a><span id="l1.117">     };</span>
<a href="#l1.118"></a><span id="l1.118">   },</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineplus">+  </span>
<a href="#l1.120"></a><span id="l1.120" class="difflineplus">+  onItemsAdded: function gloda_mdbv_itemsAdded(aItems) {</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineplus">+  },</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineplus">+  onItemsModified: function gloda_mdbv_itemsModified(aItems) {</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineplus">+  },</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineplus">+  onItemsRemoved: function gloda_mdbv_itemsRemoved(aItems) {</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+  },</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineplus">+  </span>
<a href="#l1.127"></a><span id="l1.127">   _sort: function gloda_mdbv_realSort() {</span>
<a href="#l1.128"></a><span id="l1.128">     // TODO: kShowIgnored</span>
<a href="#l1.129"></a><span id="l1.129">     // TODO: kUnreadOnly</span>
<a href="#l1.130"></a><span id="l1.130">     // TODO: kExpandAll</span>
<a href="#l1.131"></a><span id="l1.131">     let allExpanded = false;</span>
<a href="#l1.132"></a><span id="l1.132">     </span>
<a href="#l1.133"></a><span id="l1.133">     let nodes;</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+    let idToNode = {};</span>
<a href="#l1.135"></a><span id="l1.135">   </span>
<a href="#l1.136"></a><span id="l1.136">     if (this._isThreaded) {</span>
<a href="#l1.137"></a><span id="l1.137">       nodes = [];</span>
<a href="#l1.138"></a><span id="l1.138">       // cluster by conversation</span>
<a href="#l1.139"></a><span id="l1.139">       let conversations = {};</span>
<a href="#l1.140"></a><span id="l1.140" class="difflineplus">+      let dupeCheck = {};</span>
<a href="#l1.141"></a><span id="l1.141">       </span>
<a href="#l1.142"></a><span id="l1.142">       for (let iMsg=0; iMsg &lt; this._messages.length; iMsg++) {</span>
<a href="#l1.143"></a><span id="l1.143">         let message = this._messages[iMsg];</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineplus">+        if (message.id in dupeCheck) {</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineplus">+          throw Error(&quot;DUPLICATE!&quot;);</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineplus">+        }</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+        dupeCheck[message.id] = true;</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+        </span>
<a href="#l1.149"></a><span id="l1.149">         if (!(message.conversationID in conversations))</span>
<a href="#l1.150"></a><span id="l1.150">           conversations[message.conversationID] = [message];</span>
<a href="#l1.151"></a><span id="l1.151">         else</span>
<a href="#l1.152"></a><span id="l1.152">           conversations[message.conversationID].push(message);</span>
<a href="#l1.153"></a><span id="l1.153">       }</span>
<a href="#l1.154"></a><span id="l1.154">       </span>
<a href="#l1.155"></a><span id="l1.155">       // build hierarchy within each conversation</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineminus">-      for (let [convID, convMsgs] in Iterator(conversations)) {</span>
<a href="#l1.157"></a><span id="l1.157" class="difflineplus">+      for each (let convMsgs in conversations) {</span>
<a href="#l1.158"></a><span id="l1.158">         // fast-track conversations with only one messages</span>
<a href="#l1.159"></a><span id="l1.159">         if (convMsgs.length == 1) {</span>
<a href="#l1.160"></a><span id="l1.160" class="difflineminus">-          nodes.push(new GMTreeNode(convMsgs[0]));</span>
<a href="#l1.161"></a><span id="l1.161" class="difflineplus">+          let node = new GMTreeNode(convMsgs[0]);</span>
<a href="#l1.162"></a><span id="l1.162" class="difflineplus">+          idToNode[convMsgs[0].id] = node;</span>
<a href="#l1.163"></a><span id="l1.163" class="difflineplus">+          nodes.push(node);</span>
<a href="#l1.164"></a><span id="l1.164">           continue;</span>
<a href="#l1.165"></a><span id="l1.165">         }</span>
<a href="#l1.166"></a><span id="l1.166">       </span>
<a href="#l1.167"></a><span id="l1.167">         // we basically thread from nothing; we pull up the message headers</span>
<a href="#l1.168"></a><span id="l1.168">         //  and do the full references hashmap stuff.  other alternative are:</span>
<a href="#l1.169"></a><span id="l1.169">         // 1) go back to maintaining parentId for each message and pull up all</span>
<a href="#l1.170"></a><span id="l1.170">         //    the messages in the conversation.  (although the conversation may</span>
<a href="#l1.171"></a><span id="l1.171">         //    not have every actual message that ever happened in the thread,</span>
<a href="#l1.172"></a><span id="l1.172" class="difflineat">@@ -375,45 +392,48 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.173"></a><span id="l1.173">         //  backing header later on anyways.</span>
<a href="#l1.174"></a><span id="l1.174">         let messageIdMap = {};</span>
<a href="#l1.175"></a><span id="l1.175"> </span>
<a href="#l1.176"></a><span id="l1.176">         // so, map everyone by their message-id, wrapping them in tree nodes as</span>
<a href="#l1.177"></a><span id="l1.177">         //  we go.  we didn't do this in the conversation-binning pass because</span>
<a href="#l1.178"></a><span id="l1.178">         //  we don't need the mapping object's lifetimes so large.  (perhaps</span>
<a href="#l1.179"></a><span id="l1.179">         //  silly?  worst case is an extra N objects for N messages.)</span>
<a href="#l1.180"></a><span id="l1.180">         for (let iMsg=0; iMsg &lt; convMsgs.length; iMsg++) {</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineminus">-          let message = this._messages[iMsg];</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineminus">-          messageIdMap[message.headerMessageID] = new GMTreeNode(message);</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineplus">+          let message = convMsgs[iMsg];</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineplus">+          let node = new GMTreeNode(message);</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineplus">+          messageIdMap[message.headerMessageID] = node;</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineplus">+          idToNode[message.id] = node;</span>
<a href="#l1.187"></a><span id="l1.187">         }</span>
<a href="#l1.188"></a><span id="l1.188">         // now find their closest parent...</span>
<a href="#l1.189"></a><span id="l1.189">         for each (let treeNode in messageIdMap) {</span>
<a href="#l1.190"></a><span id="l1.190">           let msgHdr = treeNode.message.folderMessage;</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineminus">-           </span>
<a href="#l1.192"></a><span id="l1.192">           // references are ordered from old (0) to new (n-1), so walk backwards</span>
<a href="#l1.193"></a><span id="l1.193">           for (let iRef=msgHdr.numReferences-1; iRef &gt;= 0; iRef--) {</span>
<a href="#l1.194"></a><span id="l1.194">             let ref = msgHdr.getStringReference(iRef);</span>
<a href="#l1.195"></a><span id="l1.195">             if (ref in messageIdMap) {</span>
<a href="#l1.196"></a><span id="l1.196">               // link them to their parent</span>
<a href="#l1.197"></a><span id="l1.197">               let parentNode = messageIdMap[ref];</span>
<a href="#l1.198"></a><span id="l1.198">               if (parentNode.children === null)</span>
<a href="#l1.199"></a><span id="l1.199" class="difflineminus">-                parentNode.children = [treeNode.message];</span>
<a href="#l1.200"></a><span id="l1.200" class="difflineplus">+                parentNode.children = [treeNode];</span>
<a href="#l1.201"></a><span id="l1.201">               else</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineminus">-                parentNode.children.push(treeNode.message);</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineplus">+                parentNode.children.push(treeNode);</span>
<a href="#l1.204"></a><span id="l1.204">               treeNode.parent = parentNode;</span>
<a href="#l1.205"></a><span id="l1.205">               break; </span>
<a href="#l1.206"></a><span id="l1.206">             }</span>
<a href="#l1.207"></a><span id="l1.207">           }</span>
<a href="#l1.208"></a><span id="l1.208">           </span>
<a href="#l1.209"></a><span id="l1.209" class="difflineminus">-          if (treeNode.parent === null)</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+          if (treeNode.parent === null) {</span>
<a href="#l1.211"></a><span id="l1.211">             nodes.push(treeNode);</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+          }</span>
<a href="#l1.213"></a><span id="l1.213">         }</span>
<a href="#l1.214"></a><span id="l1.214">       } // (done building hierarchy)</span>
<a href="#l1.215"></a><span id="l1.215">     } // (done dealing with threading)</span>
<a href="#l1.216"></a><span id="l1.216">     else {</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineminus">-      nodes = [new GMTreeNode(msg) for each (msg in this._messages)];</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineplus">+      nodes = [(idToNode[msg.id] = new GMTreeNode(msg)) for each</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+               (msg in this._messages)];</span>
<a href="#l1.220"></a><span id="l1.220">     }</span>
<a href="#l1.221"></a><span id="l1.221">     </span>
<a href="#l1.222"></a><span id="l1.222">     // SORT!</span>
<a href="#l1.223"></a><span id="l1.223">     switch (this._sortType) {</span>
<a href="#l1.224"></a><span id="l1.224">       case Ci.nsMsgViewSortType.byNone:</span>
<a href="#l1.225"></a><span id="l1.225">         // nothing to do!</span>
<a href="#l1.226"></a><span id="l1.226">       case Ci.nsMsgViewSortType.byThread:</span>
<a href="#l1.227"></a><span id="l1.227">         // also nothing to do!</span>
<a href="#l1.228"></a><span id="l1.228" class="difflineat">@@ -463,27 +483,29 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.229"></a><span id="l1.229">           </span>
<a href="#l1.230"></a><span id="l1.230">           groupedNodes.push(groupNode);</span>
<a href="#l1.231"></a><span id="l1.231">         }</span>
<a href="#l1.232"></a><span id="l1.232">         else {</span>
<a href="#l1.233"></a><span id="l1.233">           curNode.parent = groupNode;</span>
<a href="#l1.234"></a><span id="l1.234">           groupNode.children.push(curNode);</span>
<a href="#l1.235"></a><span id="l1.235">         }</span>
<a href="#l1.236"></a><span id="l1.236">       }</span>
<a href="#l1.237"></a><span id="l1.237" class="difflineminus">-      </span>
<a href="#l1.238"></a><span id="l1.238" class="difflineplus">+dump(&quot;@@@@@@ GROUPING @@@@@@@@@\n&quot;);      </span>
<a href="#l1.239"></a><span id="l1.239">       nodes = groupedNodes;</span>
<a href="#l1.240"></a><span id="l1.240">     }</span>
<a href="#l1.241"></a><span id="l1.241">     </span>
<a href="#l1.242"></a><span id="l1.242">     if (this._rows &amp;&amp; this._treeBox) {</span>
<a href="#l1.243"></a><span id="l1.243">       this._treeBox.rowCountChanged(0, -this._rows.length);</span>
<a href="#l1.244"></a><span id="l1.244">     }</span>
<a href="#l1.245"></a><span id="l1.245">     </span>
<a href="#l1.246"></a><span id="l1.246">     this._toplevelNodes = nodes;</span>
<a href="#l1.247"></a><span id="l1.247" class="difflineplus">+    this._idToNode = idToNode;</span>
<a href="#l1.248"></a><span id="l1.248">     for (let iNode=0; iNode &lt; nodes.length; iNode++)</span>
<a href="#l1.249"></a><span id="l1.249">       nodes[iNode].setLevel(0);</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineplus">+    // by default, just show the top-level nodes...</span>
<a href="#l1.251"></a><span id="l1.251">     this._rows = nodes.concat();</span>
<a href="#l1.252"></a><span id="l1.252">     </span>
<a href="#l1.253"></a><span id="l1.253">     if (this._treeBox) {</span>
<a href="#l1.254"></a><span id="l1.254">       this._treeBox.rowCountChanged(0, this._rows.length); </span>
<a href="#l1.255"></a><span id="l1.255">     }</span>
<a href="#l1.256"></a><span id="l1.256">   },</span>
<a href="#l1.257"></a><span id="l1.257"> </span>
<a href="#l1.258"></a><span id="l1.258">   /* ========== nsIMsgDBView ========== */</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineat">@@ -498,28 +520,33 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.260"></a><span id="l1.260">   open: function gloda_mdbv_open(aFolder, aSortType, aSortOrder, aViewFlags,</span>
<a href="#l1.261"></a><span id="l1.261">                                  aOutCount) {</span>
<a href="#l1.262"></a><span id="l1.262">     this._sortType = aSortType;</span>
<a href="#l1.263"></a><span id="l1.263">     this._sortOrder = aSortOrder;</span>
<a href="#l1.264"></a><span id="l1.264">     this._viewFlags = aViewFlags;</span>
<a href="#l1.265"></a><span id="l1.265">     </span>
<a href="#l1.266"></a><span id="l1.266">     let query = Gloda.newQuery(Gloda.NOUN_MESSAGE);</span>
<a href="#l1.267"></a><span id="l1.267">     query.folderURI(aFolder.URI);</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineminus">-    this._messages = query.getAllSync();</span>
<a href="#l1.269"></a><span id="l1.269" class="difflineplus">+    this._collection = query.getAllSync();</span>
<a href="#l1.270"></a><span id="l1.270" class="difflineplus">+    this._messages = this._collection.items;</span>
<a href="#l1.271"></a><span id="l1.271">     this._sort();</span>
<a href="#l1.272"></a><span id="l1.272">   },</span>
<a href="#l1.273"></a><span id="l1.273">   openWithHdrs: function gloda_mdbv_openWithHdrs(aHeaders, aSortType,</span>
<a href="#l1.274"></a><span id="l1.274">                                                  aSortOrder, aViewFlags,</span>
<a href="#l1.275"></a><span id="l1.275">                                                  aOutCount) {</span>
<a href="#l1.276"></a><span id="l1.276">     this._sortType = aSortType;</span>
<a href="#l1.277"></a><span id="l1.277">     this._sortOrder = aSortOrder;</span>
<a href="#l1.278"></a><span id="l1.278">     this._viewFlags = aViewFlags;</span>
<a href="#l1.279"></a><span id="l1.279">     </span>
<a href="#l1.280"></a><span id="l1.280">     this._messages = [Gloda.getMessageForHeader(hdr) for each</span>
<a href="#l1.281"></a><span id="l1.281">                       (hdr in aHeaders)];</span>
<a href="#l1.282"></a><span id="l1.282" class="difflineplus">+    // we want to create an explicit collection so we at least get notifications</span>
<a href="#l1.283"></a><span id="l1.283" class="difflineplus">+    //  for the ids we already have...</span>
<a href="#l1.284"></a><span id="l1.284" class="difflineplus">+    this._collection = Gloda.explicitCollection(Gloda.NOUN_MESSAGE,</span>
<a href="#l1.285"></a><span id="l1.285" class="difflineplus">+                                                this._messages);</span>
<a href="#l1.286"></a><span id="l1.286">     this._sort();</span>
<a href="#l1.287"></a><span id="l1.287">     </span>
<a href="#l1.288"></a><span id="l1.288">     aOutCount.value = this._messages.length;</span>
<a href="#l1.289"></a><span id="l1.289">   },</span>
<a href="#l1.290"></a><span id="l1.290"> </span>
<a href="#l1.291"></a><span id="l1.291">   cloneDBView: function gloda_mdbv_cloneDBView(aMessengerInstance,</span>
<a href="#l1.292"></a><span id="l1.292">                                                aMsgWindow, aCommandUpdater) {</span>
<a href="#l1.293"></a><span id="l1.293">     let newView = new GlodaMsgDBView();</span>
<a href="#l1.294"></a><span id="l1.294" class="difflineat">@@ -567,16 +594,17 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.295"></a><span id="l1.295">       case Ci.nsMsgViewCommandType.markMessagesRead:</span>
<a href="#l1.296"></a><span id="l1.296">       case Ci.nsMsgViewCommandType.markMessagesUnread:</span>
<a href="#l1.297"></a><span id="l1.297">       case Ci.nsMsgViewCommandType.toggleMessageRead:</span>
<a href="#l1.298"></a><span id="l1.298">       case Ci.nsMsgViewCommandType.flagMessages:</span>
<a href="#l1.299"></a><span id="l1.299">       case Ci.nsMsgViewCommandType.unflagMessages:</span>
<a href="#l1.300"></a><span id="l1.300">       case Ci.nsMsgViewCommandType.deleteMsg:</span>
<a href="#l1.301"></a><span id="l1.301">       case Ci.nsMsgViewCommandType.deleteNoTrash:</span>
<a href="#l1.302"></a><span id="l1.302">       case Ci.nsMsgViewCommandType.markThreadRead:</span>
<a href="#l1.303"></a><span id="l1.303" class="difflineplus">+      </span>
<a href="#l1.304"></a><span id="l1.304">       case Ci.nsMsgViewCommandType.junk:</span>
<a href="#l1.305"></a><span id="l1.305">       case Ci.nsMsgViewCommandType.unjunk:</span>
<a href="#l1.306"></a><span id="l1.306">       case Ci.nsMsgViewCommandType.undeleteMsg:</span>
<a href="#l1.307"></a><span id="l1.307">       </span>
<a href="#l1.308"></a><span id="l1.308">       case Ci.nsMsgViewCommandType.toggleThreadWatched:</span>
<a href="#l1.309"></a><span id="l1.309">       case Ci.nsMsgViewCommandType.expandAll:</span>
<a href="#l1.310"></a><span id="l1.310">       case Ci.nsMsgViewCommandType.collapseAll:</span>
<a href="#l1.311"></a><span id="l1.311">       </span>
<a href="#l1.312"></a><span id="l1.312" class="difflineat">@@ -605,63 +633,112 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.313"></a><span id="l1.313">     switch (aCommand) { // no 5</span>
<a href="#l1.314"></a><span id="l1.314">       case Ci.nsMsgViewCommandType.copyMessages:</span>
<a href="#l1.315"></a><span id="l1.315">       case Ci.nsMsgViewCommandType.moveMessages:</span>
<a href="#l1.316"></a><span id="l1.316">       // error!</span>
<a href="#l1.317"></a><span id="l1.317">       default:</span>
<a href="#l1.318"></a><span id="l1.318">     }</span>
<a href="#l1.319"></a><span id="l1.319">   },</span>
<a href="#l1.320"></a><span id="l1.320">   getCommandStatus: function gloda_mdbv_getCommandStatus(</span>
<a href="#l1.321"></a><span id="l1.321" class="difflineminus">-      aCommand, aOutIsSelectable, aOutIsSelected) {</span>
<a href="#l1.322"></a><span id="l1.322" class="difflineplus">+      aCommand, aOutIsSelectable) { // aOutIsSelected...</span>
<a href="#l1.323"></a><span id="l1.323" class="difflineplus">+    </span>
<a href="#l1.324"></a><span id="l1.324" class="difflineplus">+    let selNodes = this.selectedNodes;</span>
<a href="#l1.325"></a><span id="l1.325" class="difflineplus">+    let haveSelection = (selNodes.length &gt; 0);</span>
<a href="#l1.326"></a><span id="l1.326" class="difflineplus">+    let haveNewsMessages = false; // XXX news message specialization</span>
<a href="#l1.327"></a><span id="l1.327" class="difflineplus">+    </span>
<a href="#l1.328"></a><span id="l1.328" class="difflineplus">+    let canDelete = function() {</span>
<a href="#l1.329"></a><span id="l1.329" class="difflineplus">+      let lastCheckedFolderID = null;</span>
<a href="#l1.330"></a><span id="l1.330" class="difflineplus">+      for (let iNode=0; iNode &lt; selNodes.length; iNode++) {</span>
<a href="#l1.331"></a><span id="l1.331" class="difflineplus">+        let message = selNodes[iNode].message;</span>
<a href="#l1.332"></a><span id="l1.332" class="difflineplus">+        if (lastCheckedFolderID != message.folderID) {</span>
<a href="#l1.333"></a><span id="l1.333" class="difflineplus">+          if (message.folderMessage === null ||</span>
<a href="#l1.334"></a><span id="l1.334" class="difflineplus">+              !message.folderMessage.folder.canDeleteMessages)</span>
<a href="#l1.335"></a><span id="l1.335" class="difflineplus">+            return false;</span>
<a href="#l1.336"></a><span id="l1.336" class="difflineplus">+          lastCheckedFolderID = message.folderID;</span>
<a href="#l1.337"></a><span id="l1.337" class="difflineplus">+        }</span>
<a href="#l1.338"></a><span id="l1.338" class="difflineplus">+      }</span>
<a href="#l1.339"></a><span id="l1.339" class="difflineplus">+      return true;</span>
<a href="#l1.340"></a><span id="l1.340" class="difflineplus">+    };</span>
<a href="#l1.341"></a><span id="l1.341" class="difflineplus">+    </span>
<a href="#l1.342"></a><span id="l1.342" class="difflineplus">+    let commandOkay;</span>
<a href="#l1.343"></a><span id="l1.343" class="difflineplus">+    </span>
<a href="#l1.344"></a><span id="l1.344">     switch (aCommand) { // no 5</span>
<a href="#l1.345"></a><span id="l1.345" class="difflineminus">-      // -- selection related (15,18,19)</span>
<a href="#l1.346"></a><span id="l1.346" class="difflineminus">-      case Ci.nsMsgViewCommandType.selectAll:</span>
<a href="#l1.347"></a><span id="l1.347" class="difflineminus">-      case Ci.nsMsgViewCommandType.selectThread:</span>
<a href="#l1.348"></a><span id="l1.348" class="difflineminus">-      case Ci.nsMsgViewCommandType.selectFlagged:</span>
<a href="#l1.349"></a><span id="l1.349" class="difflineminus">-      // -- re-dispatch (0-4,7-9,27-29)</span>
<a href="#l1.350"></a><span id="l1.350" class="difflineplus">+      case Ci.nsMsgViewCommandType.deleteMsg:</span>
<a href="#l1.351"></a><span id="l1.351" class="difflineplus">+      case Ci.nsMsgViewCommandType.deleteNoTrash:</span>
<a href="#l1.352"></a><span id="l1.352" class="difflineplus">+        // it's okay if all the messages' folders support deletion.  now, news</span>
<a href="#l1.353"></a><span id="l1.353" class="difflineplus">+        //  does't support deletion, but it does support cancelation, and we</span>
<a href="#l1.354"></a><span id="l1.354" class="difflineplus">+        //  use delete to mean cancel right now (even though it's dubious.)</span>
<a href="#l1.355"></a><span id="l1.355" class="difflineplus">+        // XXX this logic is not exhaustively correct in the face of news</span>
<a href="#l1.356"></a><span id="l1.356" class="difflineplus">+        //  inter-mingled with other message types...</span>
<a href="#l1.357"></a><span id="l1.357" class="difflineplus">+        commandOkay = haveSelection &amp;&amp; (haveNewsMessages || canDelete());</span>
<a href="#l1.358"></a><span id="l1.358" class="difflineplus">+        break;</span>
<a href="#l1.359"></a><span id="l1.359" class="difflineplus">+      case Ci.nsMsgViewCommandType.applyFilters:</span>
<a href="#l1.360"></a><span id="l1.360" class="difflineplus">+        // XXX do server-based check required for applyFilters</span>
<a href="#l1.361"></a><span id="l1.361" class="difflineplus">+        commandOkay = false;</span>
<a href="#l1.362"></a><span id="l1.362" class="difflineplus">+        break;</span>
<a href="#l1.363"></a><span id="l1.363" class="difflineplus">+      case Ci.nsMsgViewCommandType.runJunkControls:</span>
<a href="#l1.364"></a><span id="l1.364" class="difflineplus">+        commandOkay = haveSelection &amp;&amp; !haveNewsMessages;</span>
<a href="#l1.365"></a><span id="l1.365" class="difflineplus">+        break;</span>
<a href="#l1.366"></a><span id="l1.366" class="difflineplus">+      case Ci.nsMsgViewCommandType.deleteJunk:</span>
<a href="#l1.367"></a><span id="l1.367" class="difflineplus">+        commandOkay = haveSelection &amp;&amp; canDelete();</span>
<a href="#l1.368"></a><span id="l1.368" class="difflineplus">+        break;</span>
<a href="#l1.369"></a><span id="l1.369" class="difflineplus">+</span>
<a href="#l1.370"></a><span id="l1.370">       case Ci.nsMsgViewCommandType.markMessagesRead:</span>
<a href="#l1.371"></a><span id="l1.371">       case Ci.nsMsgViewCommandType.markMessagesUnread:</span>
<a href="#l1.372"></a><span id="l1.372">       case Ci.nsMsgViewCommandType.toggleMessageRead:</span>
<a href="#l1.373"></a><span id="l1.373">       case Ci.nsMsgViewCommandType.flagMessages:</span>
<a href="#l1.374"></a><span id="l1.374">       case Ci.nsMsgViewCommandType.unflagMessages:</span>
<a href="#l1.375"></a><span id="l1.375" class="difflineminus">-      case Ci.nsMsgViewCommandType.deleteMsg:</span>
<a href="#l1.376"></a><span id="l1.376" class="difflineminus">-      case Ci.nsMsgViewCommandType.deleteNoTrash:</span>
<a href="#l1.377"></a><span id="l1.377" class="difflineplus">+      case Ci.nsMsgViewCommandType.toggleThreadWatched:</span>
<a href="#l1.378"></a><span id="l1.378">       case Ci.nsMsgViewCommandType.markThreadRead:</span>
<a href="#l1.379"></a><span id="l1.379" class="difflineplus">+      case Ci.nsMsgViewCommandType.downloadSelectedForOffline:</span>
<a href="#l1.380"></a><span id="l1.380" class="difflineplus">+        aOutIsSelectable.value = haveSelection;</span>
<a href="#l1.381"></a><span id="l1.381" class="difflineplus">+        break;</span>
<a href="#l1.382"></a><span id="l1.382" class="difflineplus">+      </span>
<a href="#l1.383"></a><span id="l1.383" class="difflineplus">+      </span>
<a href="#l1.384"></a><span id="l1.384">       case Ci.nsMsgViewCommandType.junk:</span>
<a href="#l1.385"></a><span id="l1.385">       case Ci.nsMsgViewCommandType.unjunk:</span>
<a href="#l1.386"></a><span id="l1.386" class="difflineminus">-      case Ci.nsMsgViewCommandType.undeleteMsg:</span>
<a href="#l1.387"></a><span id="l1.387" class="difflineminus">-      </span>
<a href="#l1.388"></a><span id="l1.388" class="difflineminus">-      case Ci.nsMsgViewCommandType.toggleThreadWatched:</span>
<a href="#l1.389"></a><span id="l1.389" class="difflineminus">-      case Ci.nsMsgViewCommandType.expandAll:</span>
<a href="#l1.390"></a><span id="l1.390" class="difflineminus">-      case Ci.nsMsgViewCommandType.collapseAll:</span>
<a href="#l1.391"></a><span id="l1.391" class="difflineminus">-      </span>
<a href="#l1.392"></a><span id="l1.392" class="difflineplus">+        commandOkay = !haveNewsMessages;</span>
<a href="#l1.393"></a><span id="l1.393" class="difflineplus">+        break;</span>
<a href="#l1.394"></a><span id="l1.394" class="difflineplus">+</span>
<a href="#l1.395"></a><span id="l1.395" class="difflineplus">+      case Ci.nsMsgViewCommandType.cmdRequiringMsgBody:</span>
<a href="#l1.396"></a><span id="l1.396" class="difflineplus">+        // XXX support offline detection/offline message detection...</span>
<a href="#l1.397"></a><span id="l1.397" class="difflineplus">+        commandOkay = haveSelection; // &amp;&amp; (!areOffline() || offlineMessages());</span>
<a href="#l1.398"></a><span id="l1.398" class="difflineplus">+        break;</span>
<a href="#l1.399"></a><span id="l1.399" class="difflineplus">+        </span>
<a href="#l1.400"></a><span id="l1.400" class="difflineplus">+      case Ci.nsMsgViewCommandType.downloadFlaggedForOffline:</span>
<a href="#l1.401"></a><span id="l1.401" class="difflineplus">+      case Ci.nsMsgViewCommandType.markAllRead:</span>
<a href="#l1.402"></a><span id="l1.402" class="difflineplus">+        commandOkay = true;</span>
<a href="#l1.403"></a><span id="l1.403" class="difflineplus">+        break;</span>
<a href="#l1.404"></a><span id="l1.404" class="difflineplus">+</span>
<a href="#l1.405"></a><span id="l1.405" class="difflineplus">+      // the C++ code doesn't call anything from here on out.. perhaps the</span>
<a href="#l1.406"></a><span id="l1.406" class="difflineplus">+      //   check does't reach us?</span>
<a href="#l1.407"></a><span id="l1.407">       case Ci.nsMsgViewCommandType.copyMessages:</span>
<a href="#l1.408"></a><span id="l1.408">       case Ci.nsMsgViewCommandType.moveMessages:</span>
<a href="#l1.409"></a><span id="l1.409" class="difflineminus">-      case Ci.nsMsgViewCommandType.downloadSelectedForOffline:</span>
<a href="#l1.410"></a><span id="l1.410" class="difflineminus">-      case Ci.nsMsgViewCommandType.downloadFlaggedForOffline:</span>
<a href="#l1.411"></a><span id="l1.411" class="difflineminus">-      </span>
<a href="#l1.412"></a><span id="l1.412" class="difflineminus">-      case Ci.nsMsgViewCommandType.cmdRequiringMsgBody:</span>
<a href="#l1.413"></a><span id="l1.413" class="difflineplus">+        commandOkay = haveselection;</span>
<a href="#l1.414"></a><span id="l1.414" class="difflineplus">+        break;</span>
<a href="#l1.415"></a><span id="l1.415" class="difflineplus">+</span>
<a href="#l1.416"></a><span id="l1.416" class="difflineplus">+      case Ci.nsMsgViewCommandType.expandAll:</span>
<a href="#l1.417"></a><span id="l1.417" class="difflineplus">+      case Ci.nsMsgViewCommandType.collapseAll:</span>
<a href="#l1.418"></a><span id="l1.418" class="difflineplus">+      case Ci.nsMsgViewCommandType.selectAll:</span>
<a href="#l1.419"></a><span id="l1.419" class="difflineplus">+      case Ci.nsMsgViewCommandType.selectThread:</span>
<a href="#l1.420"></a><span id="l1.420" class="difflineplus">+      case Ci.nsMsgViewCommandType.selectFlagged:</span>
<a href="#l1.421"></a><span id="l1.421" class="difflineplus">+        commandOkay = true;</span>
<a href="#l1.422"></a><span id="l1.422" class="difflineplus">+        break;</span>
<a href="#l1.423"></a><span id="l1.423">       </span>
<a href="#l1.424"></a><span id="l1.424" class="difflineminus">-      case Ci.nsMsgViewCommandType.label0:</span>
<a href="#l1.425"></a><span id="l1.425" class="difflineminus">-      case Ci.nsMsgViewCommandType.label1:</span>
<a href="#l1.426"></a><span id="l1.426" class="difflineminus">-      case Ci.nsMsgViewCommandType.label2:</span>
<a href="#l1.427"></a><span id="l1.427" class="difflineminus">-      case Ci.nsMsgViewCommandType.label3:</span>
<a href="#l1.428"></a><span id="l1.428" class="difflineminus">-      case Ci.nsMsgViewCommandType.label4:</span>
<a href="#l1.429"></a><span id="l1.429" class="difflineminus">-      case Ci.nsMsgViewCommandType.label5:</span>
<a href="#l1.430"></a><span id="l1.430" class="difflineminus">-      </span>
<a href="#l1.431"></a><span id="l1.431" class="difflineminus">-      case Ci.nsMsgViewCommandType.applyFilters:</span>
<a href="#l1.432"></a><span id="l1.432" class="difflineminus">-      case Ci.nsMsgViewCommandType.runJunkControls:</span>
<a href="#l1.433"></a><span id="l1.433" class="difflineminus">-      case Ci.nsMsgViewCommandType.deleteJunk:</span>
<a href="#l1.434"></a><span id="l1.434" class="difflineminus">-        return true;</span>
<a href="#l1.435"></a><span id="l1.435" class="difflineplus">+      default:</span>
<a href="#l1.436"></a><span id="l1.436" class="difflineplus">+        commandOkay = false;</span>
<a href="#l1.437"></a><span id="l1.437" class="difflineplus">+        break;</span>
<a href="#l1.438"></a><span id="l1.438">     }</span>
<a href="#l1.439"></a><span id="l1.439" class="difflineplus">+    </span>
<a href="#l1.440"></a><span id="l1.440" class="difflineplus">+    aOutIsSelectable.value = commandOkay;</span>
<a href="#l1.441"></a><span id="l1.441">   },</span>
<a href="#l1.442"></a><span id="l1.442">   </span>
<a href="#l1.443"></a><span id="l1.443">   get viewType() {</span>
<a href="#l1.444"></a><span id="l1.444">     // XXX TODO: do something about the viewtype enumeration issue</span>
<a href="#l1.445"></a><span id="l1.445" class="difflineminus">-    return 0;</span>
<a href="#l1.446"></a><span id="l1.446" class="difflineplus">+    return 0; // show all threads...</span>
<a href="#l1.447"></a><span id="l1.447">   },</span>
<a href="#l1.448"></a><span id="l1.448">   </span>
<a href="#l1.449"></a><span id="l1.449">   get viewFlags() {</span>
<a href="#l1.450"></a><span id="l1.450">     return this._viewFlags;</span>
<a href="#l1.451"></a><span id="l1.451">   },</span>
<a href="#l1.452"></a><span id="l1.452">   set viewFlags(aViewFlags) {</span>
<a href="#l1.453"></a><span id="l1.453">     this._viewFlags = aViewFlags;</span>
<a href="#l1.454"></a><span id="l1.454">   },</span>
<a href="#l1.455"></a><span id="l1.455" class="difflineat">@@ -745,44 +822,51 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.456"></a><span id="l1.456">       case Ci.nsMsgNavigationType.firstNew:</span>
<a href="#l1.457"></a><span id="l1.457">       case Ci.nsMsgNavigationType.editUndo:</span>
<a href="#l1.458"></a><span id="l1.458">       case Ci.nsMsgNavigationType.editRedo:</span>
<a href="#l1.459"></a><span id="l1.459">       case Ci.nsMsgNavigationType.toggleSubthreadKilled:</span>
<a href="#l1.460"></a><span id="l1.460">     }</span>
<a href="#l1.461"></a><span id="l1.461">   },</span>
<a href="#l1.462"></a><span id="l1.462">   </span>
<a href="#l1.463"></a><span id="l1.463">   get msgFolder() {</span>
<a href="#l1.464"></a><span id="l1.464" class="difflineplus">+dump(&quot;&amp;&amp;&amp; get msgFolder\n&quot;);</span>
<a href="#l1.465"></a><span id="l1.465" class="difflineplus">+    if (this._messages.length)</span>
<a href="#l1.466"></a><span id="l1.466" class="difflineplus">+      return this._messages[0].folderMessage.folder;</span>
<a href="#l1.467"></a><span id="l1.467">     return null;</span>
<a href="#l1.468"></a><span id="l1.468">   },</span>
<a href="#l1.469"></a><span id="l1.469">   get viewFolder() {</span>
<a href="#l1.470"></a><span id="l1.470" class="difflineplus">+dump(&quot;&amp;&amp;&amp; get viewFolder\n&quot;);</span>
<a href="#l1.471"></a><span id="l1.471">     return null;</span>
<a href="#l1.472"></a><span id="l1.472">   },</span>
<a href="#l1.473"></a><span id="l1.473">   </span>
<a href="#l1.474"></a><span id="l1.474">   getKeyAt: function gloda_mdbv_getKeyAt(aViewIndex) {</span>
<a href="#l1.475"></a><span id="l1.475" class="difflineplus">+dump(&quot;&amp;&amp;&amp; getKeyAt\n&quot;);</span>
<a href="#l1.476"></a><span id="l1.476">     return this._rows[aViewIndex].message.folderMessage.messageKey;</span>
<a href="#l1.477"></a><span id="l1.477">   },</span>
<a href="#l1.478"></a><span id="l1.478">   getFolderForViewIndex: function gloda_mdbv_getFolderForViewIndex(aViewIndex) {</span>
<a href="#l1.479"></a><span id="l1.479" class="difflineplus">+dump(&quot;&amp;&amp;&amp; getFolderForViewIndex\n&quot;);</span>
<a href="#l1.480"></a><span id="l1.480">     return this._rows[aViewIndex].message.folderMessage.folder;</span>
<a href="#l1.481"></a><span id="l1.481">   },</span>
<a href="#l1.482"></a><span id="l1.482">   getURIForViewIndex: function gloda_mdbv_getURIForViewIndex(aViewIndex) {</span>
<a href="#l1.483"></a><span id="l1.483" class="difflineplus">+dump(&quot;&amp;&amp;&amp; getURIForViewIndex\n&quot;);</span>
<a href="#l1.484"></a><span id="l1.484">     return this._rows[aViewIndex].message.folderMessageURI;</span>
<a href="#l1.485"></a><span id="l1.485">   },</span>
<a href="#l1.486"></a><span id="l1.486">   </span>
<a href="#l1.487"></a><span id="l1.487">   getURIsForSelection: function gloda_mdbv_getURIsForSelection(</span>
<a href="#l1.488"></a><span id="l1.488" class="difflineminus">-      aOutCount, aOutUris) {</span>
<a href="#l1.489"></a><span id="l1.489" class="difflineplus">+      aOutCount) {</span>
<a href="#l1.490"></a><span id="l1.490">     let selNodes = this.selectedNodes;</span>
<a href="#l1.491"></a><span id="l1.491">     aOutCount.value = selNodes.length;</span>
<a href="#l1.492"></a><span id="l1.492">     return [node.message.folderMessageURI for each</span>
<a href="#l1.493"></a><span id="l1.493">                       (node in selNodes)];</span>
<a href="#l1.494"></a><span id="l1.494">   },</span>
<a href="#l1.495"></a><span id="l1.495">   getIndicesForSelection: function gloda_mdbv_getIndicesForSelection(</span>
<a href="#l1.496"></a><span id="l1.496" class="difflineminus">-      aOutCount, aOutIndices) {</span>
<a href="#l1.497"></a><span id="l1.497" class="difflineplus">+      aOutCount) {</span>
<a href="#l1.498"></a><span id="l1.498">     let selIndices = this.selectedIndices;</span>
<a href="#l1.499"></a><span id="l1.499">     aOutCount.value = selIndices.length;</span>
<a href="#l1.500"></a><span id="l1.500" class="difflineminus">-    aOutIndices.value = selIndices;</span>
<a href="#l1.501"></a><span id="l1.501" class="difflineplus">+    return selIndices;</span>
<a href="#l1.502"></a><span id="l1.502">   },</span>
<a href="#l1.503"></a><span id="l1.503">   </span>
<a href="#l1.504"></a><span id="l1.504">   get URIForFirstSelectedMessage() {</span>
<a href="#l1.505"></a><span id="l1.505">     let selNodes = this.selectedNodes;</span>
<a href="#l1.506"></a><span id="l1.506">     if (selNodes.length)</span>
<a href="#l1.507"></a><span id="l1.507">       return selNodes[0].message.folderMessageURI;</span>
<a href="#l1.508"></a><span id="l1.508">     else</span>
<a href="#l1.509"></a><span id="l1.509">       return null;</span>
<a href="#l1.510"></a><span id="l1.510" class="difflineat">@@ -790,70 +874,95 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.511"></a><span id="l1.511">   get hdrForFirstSelectedMessage() {</span>
<a href="#l1.512"></a><span id="l1.512">     let selNodes = this.selectedNodes;</span>
<a href="#l1.513"></a><span id="l1.513">     if (selNodes.length)</span>
<a href="#l1.514"></a><span id="l1.514">       return selNodes[0].message.folderMessage;</span>
<a href="#l1.515"></a><span id="l1.515">     else</span>
<a href="#l1.516"></a><span id="l1.516">       return null;</span>
<a href="#l1.517"></a><span id="l1.517">   },</span>
<a href="#l1.518"></a><span id="l1.518">   </span>
<a href="#l1.519"></a><span id="l1.519" class="difflineplus">+  _clearDisplay: function() {</span>
<a href="#l1.520"></a><span id="l1.520" class="difflineplus">+    this._msgWindow.windowCommands.clearMsgPane();</span>
<a href="#l1.521"></a><span id="l1.521" class="difflineplus">+    this._commandUpdater.updateCommandStatus();</span>
<a href="#l1.522"></a><span id="l1.522" class="difflineplus">+  },</span>
<a href="#l1.523"></a><span id="l1.523" class="difflineplus">+  </span>
<a href="#l1.524"></a><span id="l1.524" class="difflineplus">+  _displayNode: function(aTreeNode) {</span>
<a href="#l1.525"></a><span id="l1.525" class="difflineplus">+    if (!this._suppressDisplay &amp;&amp;</span>
<a href="#l1.526"></a><span id="l1.526" class="difflineplus">+        this._displayedNode !== aTreeNode) {</span>
<a href="#l1.527"></a><span id="l1.527" class="difflineplus">+      this._displayedNode = aTreeNode;</span>
<a href="#l1.528"></a><span id="l1.528" class="difflineplus">+      this._messenger.openURL(this._displayedNode.message.folderMessageURI);</span>
<a href="#l1.529"></a><span id="l1.529" class="difflineplus">+      this._commandUpdater.updateCommandStatus();</span>
<a href="#l1.530"></a><span id="l1.530" class="difflineplus">+    }</span>
<a href="#l1.531"></a><span id="l1.531" class="difflineplus">+  },</span>
<a href="#l1.532"></a><span id="l1.532" class="difflineplus">+  </span>
<a href="#l1.533"></a><span id="l1.533">   loadMessageByMsgKey: function gloda_mdbv_loadMessageByMsgKey(aMsgKey) {</span>
<a href="#l1.534"></a><span id="l1.534" class="difflineplus">+dump(&quot;&amp;&amp;&amp; loadMessageByMsgKey\n&quot;);</span>
<a href="#l1.535"></a><span id="l1.535">     // ambiguity as to what message key we are dealing with.  let's assume it's</span>
<a href="#l1.536"></a><span id="l1.536">     //  a gloda message id for the sake of this method...</span>
<a href="#l1.537"></a><span id="l1.537" class="difflineminus">-    </span>
<a href="#l1.538"></a><span id="l1.538" class="difflineminus">-    this._messenger.OpenURL()</span>
<a href="#l1.539"></a><span id="l1.539" class="difflineplus">+    this._displayNode(this._idToNode(aMsgKey));</span>
<a href="#l1.540"></a><span id="l1.540">   },</span>
<a href="#l1.541"></a><span id="l1.541">   loadMessageByViewIndex: function gloda_mdbv_loadMessageByViewIndex(</span>
<a href="#l1.542"></a><span id="l1.542">       aViewIndex) {</span>
<a href="#l1.543"></a><span id="l1.543" class="difflineminus">-    this._messenger.OpenURL()</span>
<a href="#l1.544"></a><span id="l1.544" class="difflineplus">+dump(&quot;&amp;&amp;&amp; loadMessageByViewIndex\n&quot;);</span>
<a href="#l1.545"></a><span id="l1.545" class="difflineplus">+    this._displayNode(this._rows[aViewIndex]);</span>
<a href="#l1.546"></a><span id="l1.546">   },</span>
<a href="#l1.547"></a><span id="l1.547" class="difflineplus">+  /*</span>
<a href="#l1.548"></a><span id="l1.548" class="difflineplus">+   * Displays a presumably attached message rather than a message that's</span>
<a href="#l1.549"></a><span id="l1.549" class="difflineplus">+   *  in our list of messages...</span>
<a href="#l1.550"></a><span id="l1.550" class="difflineplus">+   */</span>
<a href="#l1.551"></a><span id="l1.551">   loadMessageByUrl: function gloda_mdbv_loadMessageByUrl(aUrl) {</span>
<a href="#l1.552"></a><span id="l1.552" class="difflineplus">+    this._messenger.LoadURL(null, aUrl);</span>
<a href="#l1.553"></a><span id="l1.553">   },</span>
<a href="#l1.554"></a><span id="l1.554">   </span>
<a href="#l1.555"></a><span id="l1.555">   reloadMessage: function gloda_mdbv_reloadMessage() {</span>
<a href="#l1.556"></a><span id="l1.556">   },</span>
<a href="#l1.557"></a><span id="l1.557">   reloadMessageWithAllParts: function gloda_mdbv_reloadMessageWithAllParts() {</span>
<a href="#l1.558"></a><span id="l1.558">   },</span>
<a href="#l1.559"></a><span id="l1.559">   </span>
<a href="#l1.560"></a><span id="l1.560">   get numSelected() {</span>
<a href="#l1.561"></a><span id="l1.561">     return this.selectedIndices.length;</span>
<a href="#l1.562"></a><span id="l1.562">   },</span>
<a href="#l1.563"></a><span id="l1.563">   get msgToSelectAfterDelete() {</span>
<a href="#l1.564"></a><span id="l1.564">   },</span>
<a href="#l1.565"></a><span id="l1.565">   get currentlyDisplayedMessage() {</span>
<a href="#l1.566"></a><span id="l1.566" class="difflineminus">-    return this._rows.indexOf(this._displayedNode);</span>
<a href="#l1.567"></a><span id="l1.567" class="difflineplus">+dump(&quot;~~~ get currentDisplayedMessage\n&quot;);</span>
<a href="#l1.568"></a><span id="l1.568" class="difflineplus">+    if (this._rows &amp;&amp; this._displayedNode)</span>
<a href="#l1.569"></a><span id="l1.569" class="difflineplus">+      return this._rows.indexOf(this._displayedNode);</span>
<a href="#l1.570"></a><span id="l1.570" class="difflineplus">+    else</span>
<a href="#l1.571"></a><span id="l1.571" class="difflineplus">+      return NO_SUCH_VIEW_INDEX;</span>
<a href="#l1.572"></a><span id="l1.572">   },</span>
<a href="#l1.573"></a><span id="l1.573">   </span>
<a href="#l1.574"></a><span id="l1.574">   selectMsgByKey: function gloda_mdbv_selectMsgByKey(aMsgKey) {</span>
<a href="#l1.575"></a><span id="l1.575">   },</span>
<a href="#l1.576"></a><span id="l1.576">   selectFolderMsgByKey: function gloda_mdbv_selectFolderMsgByKey(</span>
<a href="#l1.577"></a><span id="l1.577">       aMsgFolder, aMsgKey) {</span>
<a href="#l1.578"></a><span id="l1.578">   },</span>
<a href="#l1.579"></a><span id="l1.579">   </span>
<a href="#l1.580"></a><span id="l1.580">   get suppressMsgDisplay() {</span>
<a href="#l1.581"></a><span id="l1.581" class="difflineminus">-    // TODO message display issues</span>
<a href="#l1.582"></a><span id="l1.582" class="difflineminus">-    return null;</span>
<a href="#l1.583"></a><span id="l1.583" class="difflineplus">+    return this._suppressDisplay;</span>
<a href="#l1.584"></a><span id="l1.584">   },</span>
<a href="#l1.585"></a><span id="l1.585">   set suppressMsgDisplay(aSuppress) {</span>
<a href="#l1.586"></a><span id="l1.586" class="difflineminus">-    // TODO message display issues</span>
<a href="#l1.587"></a><span id="l1.587" class="difflineplus">+    this._suppressDisplay = aSuppress;</span>
<a href="#l1.588"></a><span id="l1.588">   },</span>
<a href="#l1.589"></a><span id="l1.589">   </span>
<a href="#l1.590"></a><span id="l1.590">   get suppressCommandUpdating() {</span>
<a href="#l1.591"></a><span id="l1.591">   },</span>
<a href="#l1.592"></a><span id="l1.592">   set suppressCommandUpdating(aSuppress) {</span>
<a href="#l1.593"></a><span id="l1.593">   },</span>
<a href="#l1.594"></a><span id="l1.594">   </span>
<a href="#l1.595"></a><span id="l1.595">   onDeleteCompleted: function gloda_mdbv_onDeleteCompleted(aSucceeded) {</span>
<a href="#l1.596"></a><span id="l1.596">   },</span>
<a href="#l1.597"></a><span id="l1.597">   </span>
<a href="#l1.598"></a><span id="l1.598">   get db() {</span>
<a href="#l1.599"></a><span id="l1.599" class="difflineplus">+dump(&quot;&amp;&amp;&amp; get db\n&quot;);</span>
<a href="#l1.600"></a><span id="l1.600">     return null;</span>
<a href="#l1.601"></a><span id="l1.601">   },</span>
<a href="#l1.602"></a><span id="l1.602">   </span>
<a href="#l1.603"></a><span id="l1.603">   get supportsThreading() {</span>
<a href="#l1.604"></a><span id="l1.604" class="difflineplus">+dump(&quot;&amp;&amp;&amp; get supportsThreading\n&quot;);</span>
<a href="#l1.605"></a><span id="l1.605">     return true;</span>
<a href="#l1.606"></a><span id="l1.606">   },</span>
<a href="#l1.607"></a><span id="l1.607">   </span>
<a href="#l1.608"></a><span id="l1.608">   get searchSession() {</span>
<a href="#l1.609"></a><span id="l1.609">     // TODO: support searches</span>
<a href="#l1.610"></a><span id="l1.610">     return null;</span>
<a href="#l1.611"></a><span id="l1.611">   },</span>
<a href="#l1.612"></a><span id="l1.612">   set searchSession(aMsgSearchSession) {</span>
<a href="#l1.613"></a><span id="l1.613" class="difflineat">@@ -863,24 +972,24 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.614"></a><span id="l1.614">   </span>
<a href="#l1.615"></a><span id="l1.615">   get removeRowOnMoveOrDelete() {</span>
<a href="#l1.616"></a><span id="l1.616">     // this depends on the delete model in the underlying world.</span>
<a href="#l1.617"></a><span id="l1.617">     // for now, we will always get rid of it</span>
<a href="#l1.618"></a><span id="l1.618">     return true;</span>
<a href="#l1.619"></a><span id="l1.619">   },</span>
<a href="#l1.620"></a><span id="l1.620">   </span>
<a href="#l1.621"></a><span id="l1.621">   findIndexFromKey: function gloda_mdbv_findIndexFromKey(aMsgKey, aExpand) {</span>
<a href="#l1.622"></a><span id="l1.622" class="difflineplus">+dump(&quot;&amp;&amp;&amp; findIndexFromKey\n&quot;);</span>
<a href="#l1.623"></a><span id="l1.623">   },</span>
<a href="#l1.624"></a><span id="l1.624">   ExpandAndSelectThreadByIndex:</span>
<a href="#l1.625"></a><span id="l1.625">     function gloda_mdbv_ExpandAndSelectThreadByIndex(aViewIndex, aAugment) {</span>
<a href="#l1.626"></a><span id="l1.626">   },</span>
<a href="#l1.627"></a><span id="l1.627">   </span>
<a href="#l1.628"></a><span id="l1.628">   get usingLines() {</span>
<a href="#l1.629"></a><span id="l1.629" class="difflineminus">-    // XXX I guess we could support lines</span>
<a href="#l1.630"></a><span id="l1.630" class="difflineminus">-    return false;</span>
<a href="#l1.631"></a><span id="l1.631" class="difflineplus">+    return true;</span>
<a href="#l1.632"></a><span id="l1.632">   },</span>
<a href="#l1.633"></a><span id="l1.633">   </span>
<a href="#l1.634"></a><span id="l1.634">   addColumnHandler: function gloda_mdbv_addColumnHandler(aColumn, aHandler) {</span>
<a href="#l1.635"></a><span id="l1.635">     this._customColumns[aColumn] = aHandler;</span>
<a href="#l1.636"></a><span id="l1.636">   },</span>
<a href="#l1.637"></a><span id="l1.637">   removeColumnHandler: function gloda_mdbv_removeColumnHandler(aColumn) {</span>
<a href="#l1.638"></a><span id="l1.638">     if (aColumn in this._customColumns)</span>
<a href="#l1.639"></a><span id="l1.639">       delete this._customColumns[aColumn];</span>
<a href="#l1.640"></a><span id="l1.640" class="difflineat">@@ -893,17 +1002,17 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.641"></a><span id="l1.641">   get selection() {</span>
<a href="#l1.642"></a><span id="l1.642">     return this._treeSelection;</span>
<a href="#l1.643"></a><span id="l1.643">   },</span>
<a href="#l1.644"></a><span id="l1.644">   set selection(aTreeSelection) {</span>
<a href="#l1.645"></a><span id="l1.645">     this._treeSelection = aTreeSelection;</span>
<a href="#l1.646"></a><span id="l1.646">   },</span>
<a href="#l1.647"></a><span id="l1.647">   </span>
<a href="#l1.648"></a><span id="l1.648">   get rowCount() {</span>
<a href="#l1.649"></a><span id="l1.649" class="difflineminus">-    if (this._rows == null)</span>
<a href="#l1.650"></a><span id="l1.650" class="difflineplus">+    if (this._rows === null)</span>
<a href="#l1.651"></a><span id="l1.651">       return 0;</span>
<a href="#l1.652"></a><span id="l1.652">     return this._rows.length;</span>
<a href="#l1.653"></a><span id="l1.653">   },</span>
<a href="#l1.654"></a><span id="l1.654">   </span>
<a href="#l1.655"></a><span id="l1.655">   setTree: function gloda_mdbv_setTree(aTreeBox) {</span>
<a href="#l1.656"></a><span id="l1.656">     this._treeBox = aTreeBox;</span>
<a href="#l1.657"></a><span id="l1.657">   },</span>
<a href="#l1.658"></a><span id="l1.658"> </span>
<a href="#l1.659"></a><span id="l1.659" class="difflineat">@@ -911,79 +1020,81 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.660"></a><span id="l1.660">     let columnId = aTreeCol.id;</span>
<a href="#l1.661"></a><span id="l1.661">     if (columnId in this._customColumns) {</span>
<a href="#l1.662"></a><span id="l1.662">       let customColumn = this._customColumns[columnId];</span>
<a href="#l1.663"></a><span id="l1.663">       customColumn.getCellText(aRow, aTreeCol);</span>
<a href="#l1.664"></a><span id="l1.664">     }</span>
<a href="#l1.665"></a><span id="l1.665"> </span>
<a href="#l1.666"></a><span id="l1.666">     let message = this._rows[aRow].message;</span>
<a href="#l1.667"></a><span id="l1.667">     // if we can't find the underlying message, be sad and return nothing...</span>
<a href="#l1.668"></a><span id="l1.668" class="difflineminus">-    if (message.folderMessage === null)</span>
<a href="#l1.669"></a><span id="l1.669" class="difflineminus">-      return &quot;:(&quot;;</span>
<a href="#l1.670"></a><span id="l1.670" class="difflineplus">+    let folderMessage = message.folderMessage;</span>
<a href="#l1.671"></a><span id="l1.671" class="difflineplus">+    if (folderMessage === null)</span>
<a href="#l1.672"></a><span id="l1.672" class="difflineplus">+      return &quot;&quot;;</span>
<a href="#l1.673"></a><span id="l1.673">     </span>
<a href="#l1.674"></a><span id="l1.674">     switch(columnId[0]) {</span>
<a href="#l1.675"></a><span id="l1.675">       case &quot;s&quot;: // subject, sender, size, status</span>
<a href="#l1.676"></a><span id="l1.676">         switch(columnId[1]) {</span>
<a href="#l1.677"></a><span id="l1.677">           case &quot;u&quot;: // subject</span>
<a href="#l1.678"></a><span id="l1.678" class="difflineminus">-            return message.folderMessage.mime2DecodedSubject;</span>
<a href="#l1.679"></a><span id="l1.679" class="difflineplus">+            return message.conversation.subject; //folderMessage.mime2DecodedSubject;</span>
<a href="#l1.680"></a><span id="l1.680">           case &quot;e&quot;: // sender</span>
<a href="#l1.681"></a><span id="l1.681">             return message.from.contact.name;</span>
<a href="#l1.682"></a><span id="l1.682">           case &quot;i&quot;: // size</span>
<a href="#l1.683"></a><span id="l1.683" class="difflineminus">-            return message.folderMessage.messageSize;</span>
<a href="#l1.684"></a><span id="l1.684" class="difflineplus">+            return folderMessage.messageSize;</span>
<a href="#l1.685"></a><span id="l1.685">           case &quot;t&quot;: // status</span>
<a href="#l1.686"></a><span id="l1.686" class="difflineminus">-            return messageStatusString(message.folderMessage.flags);</span>
<a href="#l1.687"></a><span id="l1.687" class="difflineplus">+            return messageStatusString(folderMessage.flags);</span>
<a href="#l1.688"></a><span id="l1.688">         }</span>
<a href="#l1.689"></a><span id="l1.689">         break;</span>
<a href="#l1.690"></a><span id="l1.690">       case &quot;r&quot;: // recipient, received</span>
<a href="#l1.691"></a><span id="l1.691">         switch(columnId[3]) {</span>
<a href="#l1.692"></a><span id="l1.692">           case &quot;i&quot;: // recipient</span>
<a href="#l1.693"></a><span id="l1.693" class="difflineminus">-            return message.folderMessage.recipients;</span>
<a href="#l1.694"></a><span id="l1.694" class="difflineplus">+            return [recip.contact.name for each</span>
<a href="#l1.695"></a><span id="l1.695" class="difflineplus">+                    (recip in message.to)].join(&quot; &quot;) // folderMessage.recipients;</span>
<a href="#l1.696"></a><span id="l1.696">           case &quot;e&quot;: // received</span>
<a href="#l1.697"></a><span id="l1.697">             let recDate = new Date(1000 *</span>
<a href="#l1.698"></a><span id="l1.698">               folderMessage.getUint32Property(&quot;dateReceived&quot;));</span>
<a href="#l1.699"></a><span id="l1.699">             return GlodaUtils.dateFormat(recDate);</span>
<a href="#l1.700"></a><span id="l1.700">         }</span>
<a href="#l1.701"></a><span id="l1.701">         break;</span>
<a href="#l1.702"></a><span id="l1.702">       case &quot;d&quot;: // date</span>
<a href="#l1.703"></a><span id="l1.703">         return GlodaUtils.dateFormat(message.date);</span>
<a href="#l1.704"></a><span id="l1.704">       case &quot;p&quot;: // priority</span>
<a href="#l1.705"></a><span id="l1.705" class="difflineminus">-        return messagePriorityString(message.folderMessage.priority);</span>
<a href="#l1.706"></a><span id="l1.706" class="difflineplus">+        return messagePriorityString(folderMessage.priority);</span>
<a href="#l1.707"></a><span id="l1.707">       case &quot;a&quot;: // account</span>
<a href="#l1.708"></a><span id="l1.708" class="difflineminus">-        return message.folderMessage.accountKey;</span>
<a href="#l1.709"></a><span id="l1.709" class="difflineplus">+        return folderMessage.accountKey;</span>
<a href="#l1.710"></a><span id="l1.710">       case &quot;t&quot;: // total messages in thread, tags</span>
<a href="#l1.711"></a><span id="l1.711">         switch (columnId[1]) {</span>
<a href="#l1.712"></a><span id="l1.712">           case &quot;h&quot;: // total messages in thread</span>
<a href="#l1.713"></a><span id="l1.713">             // per idiom, only return this for top-level nodes</span>
<a href="#l1.714"></a><span id="l1.714" class="difflineminus">-            let node = this._Rows[aRow];</span>
<a href="#l1.715"></a><span id="l1.715" class="difflineplus">+            let node = this._rows[aRow];</span>
<a href="#l1.716"></a><span id="l1.716">             if (node.parent === null)</span>
<a href="#l1.717"></a><span id="l1.717">               return &quot;&quot; + node.nodesInSubTree;</span>
<a href="#l1.718"></a><span id="l1.718">             else</span>
<a href="#l1.719"></a><span id="l1.719">               return &quot;&quot;;</span>
<a href="#l1.720"></a><span id="l1.720">           case &quot;a&quot;: // tags</span>
<a href="#l1.721"></a><span id="l1.721">             return [tag.tag.tag for each (tag in message.tags)].join(&quot; &quot;);</span>
<a href="#l1.722"></a><span id="l1.722">         }</span>
<a href="#l1.723"></a><span id="l1.723">         break;</span>
<a href="#l1.724"></a><span id="l1.724">       case &quot;u&quot;: // unread messages in thread</span>
<a href="#l1.725"></a><span id="l1.725">         // per idiom, only return this for top-level nodes</span>
<a href="#l1.726"></a><span id="l1.726">         let node = this._Rows[aRow];</span>
<a href="#l1.727"></a><span id="l1.727">         if (node.parent === null)</span>
<a href="#l1.728"></a><span id="l1.728">           return &quot;&quot; + node.unreadInSubTree;</span>
<a href="#l1.729"></a><span id="l1.729">         else</span>
<a href="#l1.730"></a><span id="l1.730">           return &quot;&quot;;        </span>
<a href="#l1.731"></a><span id="l1.731">       case &quot;j&quot;: // junk score</span>
<a href="#l1.732"></a><span id="l1.732" class="difflineminus">-        return message.folderMessage.getStringProperty(&quot;junkscore&quot;);</span>
<a href="#l1.733"></a><span id="l1.733" class="difflineplus">+        return folderMessage.getStringProperty(&quot;junkscore&quot;);</span>
<a href="#l1.734"></a><span id="l1.734">       case &quot;i&quot;: // id</span>
<a href="#l1.735"></a><span id="l1.735">         // I don't think this is exposed anymore; perhaps only ever for</span>
<a href="#l1.736"></a><span id="l1.736">         //  debugging?  (The C++ impl exposes the messageKey, which has no</span>
<a href="#l1.737"></a><span id="l1.737">         //  reason to be user visible.)</span>
<a href="#l1.738"></a><span id="l1.738">         return &quot;&quot; + message.id;</span>
<a href="#l1.739"></a><span id="l1.739">       case &quot;l&quot;: // location, previously label too?</span>
<a href="#l1.740"></a><span id="l1.740">         switch (columnId[1]) {</span>
<a href="#l1.741"></a><span id="l1.741">           case &quot;o&quot;: // location</span>
<a href="#l1.742"></a><span id="l1.742" class="difflineminus">-            return message.folderMessage.folder.prettiestName;</span>
<a href="#l1.743"></a><span id="l1.743" class="difflineplus">+            return folderMessage.folder.prettiestName;</span>
<a href="#l1.744"></a><span id="l1.744">             break;</span>
<a href="#l1.745"></a><span id="l1.745">         }</span>
<a href="#l1.746"></a><span id="l1.746">       default:</span>
<a href="#l1.747"></a><span id="l1.747">         break;</span>
<a href="#l1.748"></a><span id="l1.748">     }</span>
<a href="#l1.749"></a><span id="l1.749">     return &quot;&quot;;</span>
<a href="#l1.750"></a><span id="l1.750">   },</span>
<a href="#l1.751"></a><span id="l1.751">   </span>
<a href="#l1.752"></a><span id="l1.752" class="difflineat">@@ -1012,24 +1123,26 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.753"></a><span id="l1.753">   },</span>
<a href="#l1.754"></a><span id="l1.754">   </span>
<a href="#l1.755"></a><span id="l1.755">   getParentIndex: function gloda_mdbv_getParentIndex(aIndex) {</span>
<a href="#l1.756"></a><span id="l1.756">     let selNode = this._rows[aIndex];</span>
<a href="#l1.757"></a><span id="l1.757">     // a reverse search would be nicer.</span>
<a href="#l1.758"></a><span id="l1.758">     // potentially nicest would be just leveraging our knowledge of the tree to</span>
<a href="#l1.759"></a><span id="l1.759">     //  do our own traversal, although the indexOf has a fair chance of winning</span>
<a href="#l1.760"></a><span id="l1.760">     //  in many cases (assuming it is optimized).</span>
<a href="#l1.761"></a><span id="l1.761" class="difflineplus">+dump(&quot;$$$ getParentIndex\n&quot;);</span>
<a href="#l1.762"></a><span id="l1.762">     return this._rows.indexOf(selNode.parent);</span>
<a href="#l1.763"></a><span id="l1.763">   },</span>
<a href="#l1.764"></a><span id="l1.764">   getLevel: function gloda_mdbv_getLevel(aIndex) {</span>
<a href="#l1.765"></a><span id="l1.765">     return this._rows[aIndex].level;</span>
<a href="#l1.766"></a><span id="l1.766">   },</span>
<a href="#l1.767"></a><span id="l1.767">   </span>
<a href="#l1.768"></a><span id="l1.768">   hasNextSibling: function gloda_mdbv_hasNextSibling(aIndex, aAfterIndex) {</span>
<a href="#l1.769"></a><span id="l1.769">     let selNode = this._rows[aIndex];</span>
<a href="#l1.770"></a><span id="l1.770" class="difflineplus">+dump(&quot;~~~ hasNextSibling\n&quot;);</span>
<a href="#l1.771"></a><span id="l1.771">     // if we have no parent or we are the last child, just rule it out.</span>
<a href="#l1.772"></a><span id="l1.772">     if ((selNode.parent === null) ||</span>
<a href="#l1.773"></a><span id="l1.773">         (selNode.parent.indexOf(selNode) == selNode.parent.children.length - 1))</span>
<a href="#l1.774"></a><span id="l1.774">       return false;</span>
<a href="#l1.775"></a><span id="l1.775">     // walk to the after index looking for our last sibling.  if we find it</span>
<a href="#l1.776"></a><span id="l1.776">     //  before we run out of indices, we have no sibling, otherwise our sibling</span>
<a href="#l1.777"></a><span id="l1.777">     //  must exist there.  we are assuming afterIndex is partitioned in such</span>
<a href="#l1.778"></a><span id="l1.778">     //  a way that this walk is probably shorter than walking potentially the</span>
<a href="#l1.779"></a><span id="l1.779" class="difflineat">@@ -1051,66 +1164,80 @@ GlodaMsgDBView.prototype = {</span>
<a href="#l1.780"></a><span id="l1.780">       //  recursively open such children.</span>
<a href="#l1.781"></a><span id="l1.781">       </span>
<a href="#l1.782"></a><span id="l1.782">       // to avoid pathological insertion to _rows, build a list of what we</span>
<a href="#l1.783"></a><span id="l1.783">       //  are going to insert, and since we plan on using splice via apply,</span>
<a href="#l1.784"></a><span id="l1.784">       //  put the initial args in...</span>
<a href="#l1.785"></a><span id="l1.785">       let spliceArgs = [aIndex+1, 0];</span>
<a href="#l1.786"></a><span id="l1.786">       </span>
<a href="#l1.787"></a><span id="l1.787">       function expandNode(aNode) {</span>
<a href="#l1.788"></a><span id="l1.788" class="difflineminus">-        for (let iChild=0; iChild &lt; aNode.children; iChild++) {</span>
<a href="#l1.789"></a><span id="l1.789" class="difflineplus">+        for (let iChild=0; iChild &lt; aNode.children.length; iChild++) {</span>
<a href="#l1.790"></a><span id="l1.790">           let child = aNode.children[iChild];</span>
<a href="#l1.791"></a><span id="l1.791">           spliceArgs.push(child);</span>
<a href="#l1.792"></a><span id="l1.792">           if (child.open)</span>
<a href="#l1.793"></a><span id="l1.793">             expandNode(child);</span>
<a href="#l1.794"></a><span id="l1.794">         }</span>
<a href="#l1.795"></a><span id="l1.795">       }</span>
<a href="#l1.796"></a><span id="l1.796">       </span>
<a href="#l1.797"></a><span id="l1.797">       expandNode(selNode);</span>
<a href="#l1.798"></a><span id="l1.798">       let rowsInserted = spliceArgs.length - 2;</span>
<a href="#l1.799"></a><span id="l1.799">       this._rows.splice.apply(this._rows, spliceArgs);</span>
<a href="#l1.800"></a><span id="l1.800">       </span>
<a href="#l1.801"></a><span id="l1.801" class="difflineminus">-      if (this._treeBox)</span>
<a href="#l1.802"></a><span id="l1.802" class="difflineplus">+      if (this._treeBox) {</span>
<a href="#l1.803"></a><span id="l1.803" class="difflineplus">+        this._treeBox.invalidateRange(aIndex, aIndex);</span>
<a href="#l1.804"></a><span id="l1.804">         this._treeBox.rowCountChanged(aIndex+1, rowsInserted);</span>
<a href="#l1.805"></a><span id="l1.805" class="difflineplus">+      }</span>
<a href="#l1.806"></a><span id="l1.806">     }</span>
<a href="#l1.807"></a><span id="l1.807">     else {</span>
<a href="#l1.808"></a><span id="l1.808">       // we're closed now, we were previously open</span>
<a href="#l1.809"></a><span id="l1.809">       </span>
<a href="#l1.810"></a><span id="l1.810">       // since we don't have a root node, locating the next sibling/uncle is not</span>
<a href="#l1.811"></a><span id="l1.811">       //  tremendously easy to just scan for that. so we do a level scan</span>
<a href="#l1.812"></a><span id="l1.812">       //  for the first node at or above the given node's level (which must be</span>
<a href="#l1.813"></a><span id="l1.813">       //  a sibling or uncle)</span>
<a href="#l1.814"></a><span id="l1.814">       let curLevel = selNode.level;</span>
<a href="#l1.815"></a><span id="l1.815" class="difflineminus">-      for (let iRow=aIndex+1; iRow &lt; this._rows.length; iRow++) {</span>
<a href="#l1.816"></a><span id="l1.816" class="difflineplus">+      let iRow;</span>
<a href="#l1.817"></a><span id="l1.817" class="difflineplus">+      for (iRow=aIndex+1; iRow &lt; this._rows.length; iRow++) {</span>
<a href="#l1.818"></a><span id="l1.818">         if (this._rows[iRow].level &lt;= curLevel)</span>
<a href="#l1.819"></a><span id="l1.819">           break;</span>
<a href="#l1.820"></a><span id="l1.820">       }</span>
<a href="#l1.821"></a><span id="l1.821" class="difflineminus">-      let rowsToDelete = iRow - aIndex+1;</span>
<a href="#l1.822"></a><span id="l1.822" class="difflineplus">+      let rowsToDelete = iRow - (aIndex+1);</span>
<a href="#l1.823"></a><span id="l1.823">       if (rowsToDelete) {</span>
<a href="#l1.824"></a><span id="l1.824">         this._rows.splice(aIndex+1, rowsToDelete);</span>
<a href="#l1.825"></a><span id="l1.825" class="difflineminus">-        if (this._treeBox)</span>
<a href="#l1.826"></a><span id="l1.826" class="difflineplus">+        if (this._treeBox) {</span>
<a href="#l1.827"></a><span id="l1.827" class="difflineplus">+          this._treeBox.invalidateRange(aIndex, aIndex);</span>
<a href="#l1.828"></a><span id="l1.828">           this._treeBox.rowCountChanged(aIndex+1, -rowsToDelete);</span>
<a href="#l1.829"></a><span id="l1.829" class="difflineplus">+        }</span>
<a href="#l1.830"></a><span id="l1.830">       }</span>
<a href="#l1.831"></a><span id="l1.831">     }</span>
<a href="#l1.832"></a><span id="l1.832">   },</span>
<a href="#l1.833"></a><span id="l1.833">   </span>
<a href="#l1.834"></a><span id="l1.834">   getImageSrc: function(idx, column) {},</span>
<a href="#l1.835"></a><span id="l1.835">   getProgressMode : function(idx,column) {},</span>
<a href="#l1.836"></a><span id="l1.836">   getCellValue: function(idx, column) {},</span>
<a href="#l1.837"></a><span id="l1.837">   cycleHeader: function(col, elem) {},</span>
<a href="#l1.838"></a><span id="l1.838">   selectionChanged: function gloda_mdbv_selectionChanged() {</span>
<a href="#l1.839"></a><span id="l1.839">     this._selectedNodes = null;</span>
<a href="#l1.840"></a><span id="l1.840" class="difflineplus">+    if (this.selectedNodes.length == 1)</span>
<a href="#l1.841"></a><span id="l1.841" class="difflineplus">+      this._displayNode(this.selectedNodes[0]);</span>
<a href="#l1.842"></a><span id="l1.842" class="difflineplus">+    else</span>
<a href="#l1.843"></a><span id="l1.843" class="difflineplus">+      this._clearDisplay();</span>
<a href="#l1.844"></a><span id="l1.844">   },</span>
<a href="#l1.845"></a><span id="l1.845">   cycleCell: function(idx, column) {},</span>
<a href="#l1.846"></a><span id="l1.846">   performAction: function(action) {},</span>
<a href="#l1.847"></a><span id="l1.847">   performActionOnCell: function(action, index, column) {},</span>
<a href="#l1.848"></a><span id="l1.848">   getRowProperties: function(idx, column, prop) {</span>
<a href="#l1.849"></a><span id="l1.849">   },</span>
<a href="#l1.850"></a><span id="l1.850">   getCellProperties: function(idx, column, prop) {</span>
<a href="#l1.851"></a><span id="l1.851">   },</span>
<a href="#l1.852"></a><span id="l1.852">   getColumnProperties: function(column, element, prop) {</span>
<a href="#l1.853"></a><span id="l1.853" class="difflineminus">-  },  </span>
<a href="#l1.854"></a><span id="l1.854" class="difflineplus">+  },</span>
<a href="#l1.855"></a><span id="l1.855" class="difflineplus">+  // no drag and drop!</span>
<a href="#l1.856"></a><span id="l1.856" class="difflineplus">+  canDrop: function(aIndex, aOrient) {</span>
<a href="#l1.857"></a><span id="l1.857" class="difflineplus">+    return false;</span>
<a href="#l1.858"></a><span id="l1.858" class="difflineplus">+  },</span>
<a href="#l1.859"></a><span id="l1.859" class="difflineplus">+  </span>
<a href="#l1.860"></a><span id="l1.860"> };</span>
<a href="#l1.861"></a><span id="l1.861"> </span>
<a href="#l1.862"></a><span id="l1.862"> var components = [GlodaMsgDBView];</span>
<a href="#l1.863"></a><span id="l1.863"> function NSGetModule(compMgr, fileSpec) {</span>
<a href="#l1.864"></a><span id="l1.864">   return XPCOMUtils.generateModule(components);</span>
<a href="#l1.865"></a><span id="l1.865"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -50,17 +50,17 @@ function GlodaCollectionManager() {</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5"> GlodaCollectionManager.prototype = {</span>
<a href="#l2.6"></a><span id="l2.6">   /**</span>
<a href="#l2.7"></a><span id="l2.7">    *</span>
<a href="#l2.8"></a><span id="l2.8">    */</span>
<a href="#l2.9"></a><span id="l2.9">   registerCollection: function gloda_colm_registerCollection(aCollection) {</span>
<a href="#l2.10"></a><span id="l2.10">     let collections;</span>
<a href="#l2.11"></a><span id="l2.11">     let nounID = aCollection.query._nounMeta.id;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-    if (nounID in this._collectionsByNoun)</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+    if (!(nounID in this._collectionsByNoun))</span>
<a href="#l2.14"></a><span id="l2.14">       collections = this._collectionsByNoun[nounID] = [];</span>
<a href="#l2.15"></a><span id="l2.15">     else {</span>
<a href="#l2.16"></a><span id="l2.16">       // purge dead weak references while we're at it</span>
<a href="#l2.17"></a><span id="l2.17">       collections = this._collectionsByNoun[nounID].filter(function (aRef) {</span>
<a href="#l2.18"></a><span id="l2.18">         return aRef.get(); });</span>
<a href="#l2.19"></a><span id="l2.19">       this._collectionsByNoun[nounID] = collections;</span>
<a href="#l2.20"></a><span id="l2.20">     }</span>
<a href="#l2.21"></a><span id="l2.21">     collections.push(Cu.getWeakReference(aCollection));</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -143,16 +143,18 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l2.23"></a><span id="l2.23">     for each (let collection in this.getCollectionsForNounID()) {</span>
<a href="#l2.24"></a><span id="l2.24">       let removeItems = [item for each (item in aItems)</span>
<a href="#l2.25"></a><span id="l2.25">                          if (item.id in collection._idMap)];</span>
<a href="#l2.26"></a><span id="l2.26">       if (removeItems.length)</span>
<a href="#l2.27"></a><span id="l2.27">         collection._onItemsRemoved(removeItems);</span>
<a href="#l2.28"></a><span id="l2.28">     }</span>
<a href="#l2.29"></a><span id="l2.29">   },</span>
<a href="#l2.30"></a><span id="l2.30"> }</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+// singleton</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+GlodaCollectionManager = new GlodaCollectionManager();</span>
<a href="#l2.33"></a><span id="l2.33"> </span>
<a href="#l2.34"></a><span id="l2.34"> /**</span>
<a href="#l2.35"></a><span id="l2.35">  * A GlodaCollection is intended to be a current view of the set of first-class</span>
<a href="#l2.36"></a><span id="l2.36">  *  nouns meeting a given query.  Assuming a listener is present, events are</span>
<a href="#l2.37"></a><span id="l2.37">  *  generated when new objects meet the query, existing objects no longer meet</span>
<a href="#l2.38"></a><span id="l2.38">  *  the query, or existing objects have experienced a change in attributes that</span>
<a href="#l2.39"></a><span id="l2.39">  *  does not affect their ability to be present (but the listener may care about</span>
<a href="#l2.40"></a><span id="l2.40">  *  because it is exposing those attributes). </span>
<a href="#l2.41"></a><span id="l2.41" class="difflineat">@@ -164,16 +166,19 @@ function GlodaCollection(aItems, aQuery,</span>
<a href="#l2.42"></a><span id="l2.42">     this._idMap[item.id] = item;</span>
<a href="#l2.43"></a><span id="l2.43">   }</span>
<a href="#l2.44"></a><span id="l2.44">   </span>
<a href="#l2.45"></a><span id="l2.45">   this.query = aQuery || null;</span>
<a href="#l2.46"></a><span id="l2.46">   this._listener = aListener || null;</span>
<a href="#l2.47"></a><span id="l2.47"> }</span>
<a href="#l2.48"></a><span id="l2.48">  </span>
<a href="#l2.49"></a><span id="l2.49"> GlodaCollection.prototype = {</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+  get listener() { return this._listener; },</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineplus">+  set listener(aListener) { this._listener = aListener; },</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineplus">+</span>
<a href="#l2.53"></a><span id="l2.53">   _onItemsAdded: function(aItems) {</span>
<a href="#l2.54"></a><span id="l2.54">     this.items.push.apply(this.items, aItems);</span>
<a href="#l2.55"></a><span id="l2.55">     for each (item in aItems) {</span>
<a href="#l2.56"></a><span id="l2.56">       this._idMap[item.id] = item;</span>
<a href="#l2.57"></a><span id="l2.57">     }</span>
<a href="#l2.58"></a><span id="l2.58">     if (this._listener)</span>
<a href="#l2.59"></a><span id="l2.59">       this._listener.onItemsAdded(aItems);</span>
<a href="#l2.60"></a><span id="l2.60">   },</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -75,17 +75,17 @@ GlodaAttributeDef.prototype = {</span>
<a href="#l3.4"></a><span id="l3.4">   get id() { return this._id; },</span>
<a href="#l3.5"></a><span id="l3.5">   get provider() { return this._provider; },</span>
<a href="#l3.6"></a><span id="l3.6">   get attributeName() { return this._attrName; },</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8">   get objectNoun() { return this._objectType; },</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10">   get isBound() { return this._boundName !== null; },</span>
<a href="#l3.11"></a><span id="l3.11">   get boundName() { return this._boundName; },</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  get singular() { return this.singular; },</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+  get singular() { return this._singular; },</span>
<a href="#l3.14"></a><span id="l3.14">   </span>
<a href="#l3.15"></a><span id="l3.15">   get isSpecial() { return this._specialColumnName !== null; },</span>
<a href="#l3.16"></a><span id="l3.16">   get specialColumnName() { return this._specialColumnName; },</span>
<a href="#l3.17"></a><span id="l3.17"> </span>
<a href="#l3.18"></a><span id="l3.18">   /**</span>
<a href="#l3.19"></a><span id="l3.19">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l3.20"></a><span id="l3.20">    *  attribute-parameter as an attribute.</span>
<a href="#l3.21"></a><span id="l3.21">    *</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -199,17 +199,17 @@ function GlodaMessage(aDatastore, aID, a</span>
<a href="#l3.23"></a><span id="l3.23">   this._messageKey = aMessageKey;</span>
<a href="#l3.24"></a><span id="l3.24">   this._conversationID = aConversationID;</span>
<a href="#l3.25"></a><span id="l3.25">   this._conversation = aConversation;</span>
<a href="#l3.26"></a><span id="l3.26">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l3.27"></a><span id="l3.27">   this._bodySnippet = aBodySnippet;</span>
<a href="#l3.28"></a><span id="l3.28"> </span>
<a href="#l3.29"></a><span id="l3.29">   // for now, let's always cache this; they should really be forgetting about us</span>
<a href="#l3.30"></a><span id="l3.30">   //  if they want to forget about the underlying storage anyways...</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-  this._folderMessage = null;</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+  this._folderMessage = undefined;</span>
<a href="#l3.33"></a><span id="l3.33">   // the list of attributes, un-processed</span>
<a href="#l3.34"></a><span id="l3.34">   this._attributes = null;</span>
<a href="#l3.35"></a><span id="l3.35"> }</span>
<a href="#l3.36"></a><span id="l3.36"> </span>
<a href="#l3.37"></a><span id="l3.37"> GlodaMessage.prototype = {</span>
<a href="#l3.38"></a><span id="l3.38">   get id() { return this._id; },</span>
<a href="#l3.39"></a><span id="l3.39">   get folderID() { return this._folderID; },</span>
<a href="#l3.40"></a><span id="l3.40">   get messageKey() { return this._messageKey; },</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineat">@@ -259,36 +259,33 @@ GlodaMessage.prototype = {</span>
<a href="#l3.42"></a><span id="l3.42">     this._datastore = null;</span>
<a href="#l3.43"></a><span id="l3.43">   },</span>
<a href="#l3.44"></a><span id="l3.44">   </span>
<a href="#l3.45"></a><span id="l3.45">   /**</span>
<a href="#l3.46"></a><span id="l3.46">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l3.47"></a><span id="l3.47">    *  null if the message does not exist for one reason or another.</span>
<a href="#l3.48"></a><span id="l3.48">    */</span>
<a href="#l3.49"></a><span id="l3.49">   get folderMessage() {</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineminus">-    if (this._folderMessage !== null)</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+    if (this._folderMessage !== undefined)</span>
<a href="#l3.52"></a><span id="l3.52">       return this._folderMessage;</span>
<a href="#l3.53"></a><span id="l3.53">     if (this._folderID === null || this._messageKey === null)</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineminus">-      return null;</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineminus">-</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+      return this._folderMessage = null;</span>
<a href="#l3.57"></a><span id="l3.57">     let rdfService = Cc['@mozilla.org/rdf/rdf-service;1'].</span>
<a href="#l3.58"></a><span id="l3.58">                      getService(Ci.nsIRDFService);</span>
<a href="#l3.59"></a><span id="l3.59">     let folder = rdfService.GetResource(</span>
<a href="#l3.60"></a><span id="l3.60">                    this._datastore._mapFolderID(this._folderID));</span>
<a href="#l3.61"></a><span id="l3.61">     if (folder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l3.62"></a><span id="l3.62">       this._folderMessage = folder.GetMessageHeader(this._messageKey);</span>
<a href="#l3.63"></a><span id="l3.63">       if (this._folderMessage != null) {</span>
<a href="#l3.64"></a><span id="l3.64">         // verify the message-id header matches what we expect...</span>
<a href="#l3.65"></a><span id="l3.65">         if (this._folderMessage.messageId != this._headerMessageID) {</span>
<a href="#l3.66"></a><span id="l3.66">           LOG.info(&quot;Message with message key does not match expected &quot; +</span>
<a href="#l3.67"></a><span id="l3.67">                    &quot;header! (&quot; + this._headerMessageID + &quot; expected, got &quot; +</span>
<a href="#l3.68"></a><span id="l3.68">                    this._folderMessage.messageId + &quot;)&quot;);</span>
<a href="#l3.69"></a><span id="l3.69">           this._folderMessage = null;</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-          // null out our message key to shut us up on future attempts</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-          this._messageKey = null;</span>
<a href="#l3.72"></a><span id="l3.72">         }</span>
<a href="#l3.73"></a><span id="l3.73">       }</span>
<a href="#l3.74"></a><span id="l3.74">       return this._folderMessage;</span>
<a href="#l3.75"></a><span id="l3.75">     }</span>
<a href="#l3.76"></a><span id="l3.76"> </span>
<a href="#l3.77"></a><span id="l3.77">     // this only gets logged if things have gone very wrong.  we used to throw</span>
<a href="#l3.78"></a><span id="l3.78">     //  here, but it's unlikely our caller can do anything more meaningful than</span>
<a href="#l3.79"></a><span id="l3.79">     //  treating this as a disappeared message.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -46,16 +46,17 @@ const Cc = Components.classes;</span>
<a href="#l4.4"></a><span id="l4.4"> const Ci = Components.interfaces;</span>
<a href="#l4.5"></a><span id="l4.5"> const Cr = Components.results;</span>
<a href="#l4.6"></a><span id="l4.6"> const Cu = Components.utils;</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10"> Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l4.11"></a><span id="l4.11"> Cu.import(&quot;resource://gloda/modules/databind.js&quot;);</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l4.13"></a><span id="l4.13"> </span>
<a href="#l4.14"></a><span id="l4.14"> let GlodaDatastore = {</span>
<a href="#l4.15"></a><span id="l4.15">   _log: null,</span>
<a href="#l4.16"></a><span id="l4.16"> </span>
<a href="#l4.17"></a><span id="l4.17">   /* ******************* SCHEMA ******************* */</span>
<a href="#l4.18"></a><span id="l4.18"> </span>
<a href="#l4.19"></a><span id="l4.19">   _schemaVersion: 4,</span>
<a href="#l4.20"></a><span id="l4.20">   _schema: {</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineat">@@ -1119,18 +1120,20 @@ let GlodaDatastore = {</span>
<a href="#l4.22"></a><span id="l4.22">     </span>
<a href="#l4.23"></a><span id="l4.23">     let statement = this._createStatement(sqlString);</span>
<a href="#l4.24"></a><span id="l4.24">     </span>
<a href="#l4.25"></a><span id="l4.25">     let items = [];</span>
<a href="#l4.26"></a><span id="l4.26">     while (statement.step()) {</span>
<a href="#l4.27"></a><span id="l4.27">       items.push(nounMeta.objFromRow.call(nounMeta.datastore, statement.row));</span>
<a href="#l4.28"></a><span id="l4.28">     }</span>
<a href="#l4.29"></a><span id="l4.29">     statement.reset();</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineminus">-     </span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-    return items;</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+    </span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+    let collection = new GlodaCollection(items, aQuery);</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+    GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+    return collection;</span>
<a href="#l4.36"></a><span id="l4.36">   },</span>
<a href="#l4.37"></a><span id="l4.37">   </span>
<a href="#l4.38"></a><span id="l4.38">   queryMessagesAPV: function gloda_ds_queryMessagesAPV(aAPVs) {</span>
<a href="#l4.39"></a><span id="l4.39">     let selects = [];</span>
<a href="#l4.40"></a><span id="l4.40">     </span>
<a href="#l4.41"></a><span id="l4.41">     for (let iAPV=0; iAPV &lt; aAPVs.length; iAPV++) {</span>
<a href="#l4.42"></a><span id="l4.42">       let APV = aAPVs[iAPV];</span>
<a href="#l4.43"></a><span id="l4.43">       </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -41,16 +41,17 @@ const Cc = Components.classes;</span>
<a href="#l5.4"></a><span id="l5.4"> const Ci = Components.interfaces;</span>
<a href="#l5.5"></a><span id="l5.5"> const Cr = Components.results;</span>
<a href="#l5.6"></a><span id="l5.6"> const Cu = Components.utils;</span>
<a href="#l5.7"></a><span id="l5.7"> </span>
<a href="#l5.8"></a><span id="l5.8"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l5.9"></a><span id="l5.9"> </span>
<a href="#l5.10"></a><span id="l5.10"> Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l5.11"></a><span id="l5.11"> Cu.import(&quot;resource://gloda/modules/datamodel.js&quot;);</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l5.13"></a><span id="l5.13"> Cu.import(&quot;resource://gloda/modules/query.js&quot;);</span>
<a href="#l5.14"></a><span id="l5.14"> Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l5.15"></a><span id="l5.15"> </span>
<a href="#l5.16"></a><span id="l5.16"> /**</span>
<a href="#l5.17"></a><span id="l5.17">  * </span>
<a href="#l5.18"></a><span id="l5.18">  */</span>
<a href="#l5.19"></a><span id="l5.19"> let Gloda = {</span>
<a href="#l5.20"></a><span id="l5.20">   _init: function gloda_ns_init() {</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineat">@@ -221,18 +222,20 @@ let Gloda = {</span>
<a href="#l5.22"></a><span id="l5.22">    *     parameter may only be non-null if you passed a usesParameter of true.</span>
<a href="#l5.23"></a><span id="l5.23">    *     Parameter may be of any type (BLOB), and value must be numeric (pass</span>
<a href="#l5.24"></a><span id="l5.24">    *     0 if you don't need the value).</span>
<a href="#l5.25"></a><span id="l5.25">    */</span>
<a href="#l5.26"></a><span id="l5.26">   defineNoun: function gloda_ns_defineNoun(aNounMeta, aNounID) {</span>
<a href="#l5.27"></a><span id="l5.27">     if (aNounID === undefined)</span>
<a href="#l5.28"></a><span id="l5.28">       aNounID = this._nextNounID++;</span>
<a href="#l5.29"></a><span id="l5.29">     aNounMeta.id = aNounID;</span>
<a href="#l5.30"></a><span id="l5.30" class="difflineminus">-    if (aNounMeta.firstClass)</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineminus">-      aNounMeta.queryClass = GlodaQueryClassFactory(aNounMeta);</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineplus">+    if (aNounMeta.firstClass) {</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineplus">+      [aNounMeta.queryClass, aNounMeta.explicitQueryClass] =</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+        GlodaQueryClassFactory(aNounMeta);</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineplus">+    }</span>
<a href="#l5.36"></a><span id="l5.36">     this._nounNameToNounID[aNounMeta.name] = aNounID; </span>
<a href="#l5.37"></a><span id="l5.37">     this._nounIDToMeta[aNounID] = aNounMeta;</span>
<a href="#l5.38"></a><span id="l5.38">     aNounMeta.actions = [];</span>
<a href="#l5.39"></a><span id="l5.39">   },</span>
<a href="#l5.40"></a><span id="l5.40">   </span>
<a href="#l5.41"></a><span id="l5.41">   /**</span>
<a href="#l5.42"></a><span id="l5.42">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l5.43"></a><span id="l5.43">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineat">@@ -375,44 +378,46 @@ let Gloda = {</span>
<a href="#l5.45"></a><span id="l5.45">     </span>
<a href="#l5.46"></a><span id="l5.46">     // -- the on-object bindings</span>
<a href="#l5.47"></a><span id="l5.47">     if (aDoBind) {</span>
<a href="#l5.48"></a><span id="l5.48">       let storageName = &quot;__&quot; + aBindName;</span>
<a href="#l5.49"></a><span id="l5.49">       let getter;</span>
<a href="#l5.50"></a><span id="l5.50">       // should we memoize the value as a getter per-instance?</span>
<a href="#l5.51"></a><span id="l5.51">       if (aSingular) {</span>
<a href="#l5.52"></a><span id="l5.52">         getter = function() {</span>
<a href="#l5.53"></a><span id="l5.53" class="difflineminus">-          if (this[storageName] != undefined)</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineminus">-            return this[storageName];</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineplus">+          let val = this[storageName];</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineplus">+          if (val !== undefined)</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineplus">+            return val;</span>
<a href="#l5.58"></a><span id="l5.58">           let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineminus">-          let val;</span>
<a href="#l5.60"></a><span id="l5.60">           if (instances.length &gt; 0)</span>
<a href="#l5.61"></a><span id="l5.61">             val = nounMeta.fromParamAndValue(instances[0][1], instances[0][2]);</span>
<a href="#l5.62"></a><span id="l5.62">           else</span>
<a href="#l5.63"></a><span id="l5.63">             val = null;</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineminus">-          this[storageName] = val;</span>
<a href="#l5.65"></a><span id="l5.65" class="difflineplus">+          //this[storageName] = val;</span>
<a href="#l5.66"></a><span id="l5.66" class="difflineplus">+          this.__defineGetter__(aBindName, function() val);</span>
<a href="#l5.67"></a><span id="l5.67">           return val;</span>
<a href="#l5.68"></a><span id="l5.68">         }</span>
<a href="#l5.69"></a><span id="l5.69">       } else {</span>
<a href="#l5.70"></a><span id="l5.70">         getter = function() {</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineminus">-          if (this[storageName] != undefined)</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineminus">-            return this[storageName];</span>
<a href="#l5.73"></a><span id="l5.73" class="difflineplus">+          let values = this[storageName];</span>
<a href="#l5.74"></a><span id="l5.74" class="difflineplus">+          if (values !== undefined)</span>
<a href="#l5.75"></a><span id="l5.75" class="difflineplus">+            return values;</span>
<a href="#l5.76"></a><span id="l5.76">           let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l5.77"></a><span id="l5.77" class="difflineminus">-          let values;</span>
<a href="#l5.78"></a><span id="l5.78">           if (instances.length &gt; 0) {</span>
<a href="#l5.79"></a><span id="l5.79">             values = [];</span>
<a href="#l5.80"></a><span id="l5.80">             for (let iInst=0; iInst &lt; instances.length; iInst++) {</span>
<a href="#l5.81"></a><span id="l5.81">               values.push(nounMeta.fromParamAndValue(instances[iInst][1],</span>
<a href="#l5.82"></a><span id="l5.82">                                                      instances[iInst][2]));</span>
<a href="#l5.83"></a><span id="l5.83">             }</span>
<a href="#l5.84"></a><span id="l5.84">           }</span>
<a href="#l5.85"></a><span id="l5.85">           else {</span>
<a href="#l5.86"></a><span id="l5.86">             values = instances; // empty is empty</span>
<a href="#l5.87"></a><span id="l5.87">           }</span>
<a href="#l5.88"></a><span id="l5.88" class="difflineminus">-          this[storageName] = values;</span>
<a href="#l5.89"></a><span id="l5.89" class="difflineplus">+          //this[storageName] = values;</span>
<a href="#l5.90"></a><span id="l5.90" class="difflineplus">+          this.__defineGetter__(aBindName, function() values);</span>
<a href="#l5.91"></a><span id="l5.91">           return values;</span>
<a href="#l5.92"></a><span id="l5.92">         }</span>
<a href="#l5.93"></a><span id="l5.93">       }</span>
<a href="#l5.94"></a><span id="l5.94">   </span>
<a href="#l5.95"></a><span id="l5.95">       let subjectProto = subjectNounMeta.class.prototype;</span>
<a href="#l5.96"></a><span id="l5.96">       subjectProto.__defineGetter__(aBindName, getter);</span>
<a href="#l5.97"></a><span id="l5.97">       // no setters for now; manipulation comes later, and will require the attr</span>
<a href="#l5.98"></a><span id="l5.98">       //  definer to provide the actual logic, since we need to affect reality,</span>
<a href="#l5.99"></a><span id="l5.99" class="difflineat">@@ -431,18 +436,16 @@ let Gloda = {</span>
<a href="#l5.100"></a><span id="l5.100">           let argument = arguments[iArg];</span>
<a href="#l5.101"></a><span id="l5.101">           our_ors.push([aAttr].concat(nounMeta.toParamAndValue(argument)));</span>
<a href="#l5.102"></a><span id="l5.102">         }</span>
<a href="#l5.103"></a><span id="l5.103">         // but the constraints are ANDed together</span>
<a href="#l5.104"></a><span id="l5.104">         this._constraints.push(our_ors);</span>
<a href="#l5.105"></a><span id="l5.105">         return this;</span>
<a href="#l5.106"></a><span id="l5.106">       };</span>
<a href="#l5.107"></a><span id="l5.107"> </span>
<a href="#l5.108"></a><span id="l5.108" class="difflineminus">-dump(&quot;binding constraint &quot; + aBindName + &quot; on &quot; + subjectNounMeta.name + &quot; to &quot;+</span>
<a href="#l5.109"></a><span id="l5.109" class="difflineminus">-  constrainer + &quot;\n&quot;);      </span>
<a href="#l5.110"></a><span id="l5.110">       subjectNounMeta.queryClass.prototype[aBindName] = constrainer;</span>
<a href="#l5.111"></a><span id="l5.111">       </span>
<a href="#l5.112"></a><span id="l5.112">       if (nounMeta.continuous) {</span>
<a href="#l5.113"></a><span id="l5.113">         let rangedConstrainer = function() {</span>
<a href="#l5.114"></a><span id="l5.114">           // all the arguments provided end up being ORed together</span>
<a href="#l5.115"></a><span id="l5.115">           let our_ors = [];</span>
<a href="#l5.116"></a><span id="l5.116">           for(let iArg=0; iArg &lt; arguments.length; iArg +=2 ) {</span>
<a href="#l5.117"></a><span id="l5.117">             let pv1 = nounMeta.toParamAndValue(arguments[iArg]);</span>
<a href="#l5.118"></a><span id="l5.118" class="difflineat">@@ -613,21 +616,38 @@ dump(&quot;binding constraint &quot; + aBindName +</span>
<a href="#l5.119"></a><span id="l5.119">    * @param indices A dictionary of lists of column names, where the key name</span>
<a href="#l5.120"></a><span id="l5.120">    *     becomes the index name.  Ex: {foo: [&quot;bar&quot;]} results in an index on</span>
<a href="#l5.121"></a><span id="l5.121">    *     the column &quot;bar&quot; where the index is named &quot;foo&quot;.</span>
<a href="#l5.122"></a><span id="l5.122">    */</span>
<a href="#l5.123"></a><span id="l5.123">   defineTable: function gloda_ns_defineTable(aTableDef) {</span>
<a href="#l5.124"></a><span id="l5.124">     return GlodaDatastore.createTableIfNotExists(aTableDef);</span>
<a href="#l5.125"></a><span id="l5.125">   },</span>
<a href="#l5.126"></a><span id="l5.126">   </span>
<a href="#l5.127"></a><span id="l5.127" class="difflineplus">+  /**</span>
<a href="#l5.128"></a><span id="l5.128" class="difflineplus">+   * Create a new query for the given noun-type.</span>
<a href="#l5.129"></a><span id="l5.129" class="difflineplus">+   */</span>
<a href="#l5.130"></a><span id="l5.130">   newQuery: function gloda_ns_newQuery(aNounID) {</span>
<a href="#l5.131"></a><span id="l5.131">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l5.132"></a><span id="l5.132">     return new nounMeta.queryClass();</span>
<a href="#l5.133"></a><span id="l5.133">   },</span>
<a href="#l5.134"></a><span id="l5.134">   </span>
<a href="#l5.135"></a><span id="l5.135" class="difflineplus">+  /**</span>
<a href="#l5.136"></a><span id="l5.136" class="difflineplus">+   * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l5.137"></a><span id="l5.137" class="difflineplus">+   *  provided items.  This is to be used when you have an explicit set of items</span>
<a href="#l5.138"></a><span id="l5.138" class="difflineplus">+   *  that you would still like to receive updates for. </span>
<a href="#l5.139"></a><span id="l5.139" class="difflineplus">+   */</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineplus">+  explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l5.141"></a><span id="l5.141" class="difflineplus">+    let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l5.142"></a><span id="l5.142" class="difflineplus">+    let collection = new GlodaCollection(aItems, null, null)</span>
<a href="#l5.143"></a><span id="l5.143" class="difflineplus">+    let query = new nounMeta.explicitQueryClass(collection);</span>
<a href="#l5.144"></a><span id="l5.144" class="difflineplus">+    collection.query = query;</span>
<a href="#l5.145"></a><span id="l5.145" class="difflineplus">+    GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l5.146"></a><span id="l5.146" class="difflineplus">+    return colleciton;</span>
<a href="#l5.147"></a><span id="l5.147" class="difflineplus">+  },</span>
<a href="#l5.148"></a><span id="l5.148" class="difflineplus">+  </span>
<a href="#l5.149"></a><span id="l5.149">   processMessage: function gloda_ns_processMessage(aMessage, aMsgHdr,</span>
<a href="#l5.150"></a><span id="l5.150">                                                    aMimeMsg) {</span>
<a href="#l5.151"></a><span id="l5.151">     // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l5.152"></a><span id="l5.152">     //  before applying the new attributes.</span>
<a href="#l5.153"></a><span id="l5.153">     aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l5.154"></a><span id="l5.154">     </span>
<a href="#l5.155"></a><span id="l5.155">     let allAttribs = [];</span>
<a href="#l5.156"></a><span id="l5.156">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -161,19 +161,44 @@ GlodaQueryClass.prototype = {</span>
<a href="#l6.4"></a><span id="l6.4">       if (querySatisfied)</span>
<a href="#l6.5"></a><span id="l6.5">         return true;</span>
<a href="#l6.6"></a><span id="l6.6">     }</span>
<a href="#l6.7"></a><span id="l6.7">     </span>
<a href="#l6.8"></a><span id="l6.8">     return false;</span>
<a href="#l6.9"></a><span id="l6.9">   },</span>
<a href="#l6.10"></a><span id="l6.10"> };</span>
<a href="#l6.11"></a><span id="l6.11"> </span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+function GlodaExplicitQueryClass() {</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+}</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+GlodaExplicitQueryClass.prototype = {</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+  // don't let people try and mess with us</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+  or: function() { return null; },</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+  // don't let people try and query on us (until we have a real use case for</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+  //  that...)</span>
<a href="#l6.20"></a><span id="l6.20" class="difflineplus">+  getAllSync: function() { return null; },</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineplus">+  /**</span>
<a href="#l6.22"></a><span id="l6.22" class="difflineplus">+   * Matches only items that are already in the collection (by id).</span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+   */</span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+  test: function gloda_query_explicit_test(aObj) {</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineplus">+    return (aObj.id in this.collection._idMap);</span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+  }</span>
<a href="#l6.27"></a><span id="l6.27" class="difflineplus">+};</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineplus">+</span>
<a href="#l6.29"></a><span id="l6.29"> function GlodaQueryClassFactory(aNounMeta) {</span>
<a href="#l6.30"></a><span id="l6.30">   let newQueryClass = function() {</span>
<a href="#l6.31"></a><span id="l6.31">     GlodaQueryClass.call(this);</span>
<a href="#l6.32"></a><span id="l6.32">   }; </span>
<a href="#l6.33"></a><span id="l6.33">   </span>
<a href="#l6.34"></a><span id="l6.34">   newQueryClass.prototype = new GlodaQueryClass;</span>
<a href="#l6.35"></a><span id="l6.35">   newQueryClass.prototype._queryClass = newQueryClass;</span>
<a href="#l6.36"></a><span id="l6.36">   newQueryClass.prototype._nounMeta = aNounMeta;</span>
<a href="#l6.37"></a><span id="l6.37">   </span>
<a href="#l6.38"></a><span id="l6.38" class="difflineminus">-  return newQueryClass;</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+  let newExplicitClass = function(aCollection) {</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+    GlodaExplicitQueryClass.call(this);</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+    this.collection = aCollection;</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+  };</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+  newExplicitClass.prototype = new GlodaExplicitQueryClass();</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  newExplicitClass.prototype._queryClass = newExplicitClass;</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+  newExplicitClass.prototype._nounMeta = aNounMeta;</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+  </span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+  return [newQueryClass, newExplicitClass];</span>
<a href="#l6.48"></a><span id="l6.48"> }</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

