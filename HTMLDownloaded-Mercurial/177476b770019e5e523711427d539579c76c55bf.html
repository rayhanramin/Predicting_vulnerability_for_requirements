<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 892:177476b770019e5e523711427d539579c76c55bf</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 177476b770019e5e523711427d539579c76c55bf" />
<meta property="og:url" content="/comm-central/rev/177476b770019e5e523711427d539579c76c55bf" />
<meta property="og:description" content="more comments/javadoc (favoring pydoc syntax, more accurately.)" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 177476b770019e5e523711427d539579c76c55bf 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/177476b770019e5e523711427d539579c76c55bf">shortlog</a> |
<a href="/comm-central/log/177476b770019e5e523711427d539579c76c55bf">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/177476b770019e5e523711427d539579c76c55bf">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/177476b770019e5e523711427d539579c76c55bf">files</a> |
changeset |
<a href="/comm-central/raw-rev/177476b770019e5e523711427d539579c76c55bf">raw</a>  | <a href="/comm-central/archive/177476b770019e5e523711427d539579c76c55bf.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
more comments/javadoc (favoring pydoc syntax, more accurately.)
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 26 Aug 2008 02:00:58 -0700</td></tr>

<tr>
 <td>changeset 892</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/177476b770019e5e523711427d539579c76c55bf">177476b770019e5e523711427d539579c76c55bf</a></td>
</tr>



<tr>
<td>parent 891</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/8d9b309a3e492c611f31313de64e2025a573d92f">8d9b309a3e492c611f31313de64e2025a573d92f</a>
</td>
</tr>

<tr>
<td>child 893</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d2a13bb0a3d23b21ea92af5938bd5b60022fb90f">d2a13bb0a3d23b21ea92af5938bd5b60022fb90f</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=177476b770019e5e523711427d539579c76c55bf">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">more comments/javadoc (favoring pydoc syntax, more accurately.)</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/177476b770019e5e523711427d539579c76c55bf/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/177476b770019e5e523711427d539579c76c55bf/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/177476b770019e5e523711427d539579c76c55bf/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/177476b770019e5e523711427d539579c76c55bf/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/177476b770019e5e523711427d539579c76c55bf/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/177476b770019e5e523711427d539579c76c55bf/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/177476b770019e5e523711427d539579c76c55bf/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/177476b770019e5e523711427d539579c76c55bf/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/177476b770019e5e523711427d539579c76c55bf/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/177476b770019e5e523711427d539579c76c55bf/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/177476b770019e5e523711427d539579c76c55bf/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/177476b770019e5e523711427d539579c76c55bf/modules/indexer.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -65,16 +65,18 @@ const kSpecialFulltext = 2;</span>
<a href="#l1.4"></a><span id="l1.4">  *  call into question whether we really need our hand-rolled code, or could</span>
<a href="#l1.5"></a><span id="l1.5">  *  simply improve the extension-provided table case to work for most of our</span>
<a href="#l1.6"></a><span id="l1.6">  *  hand-rolled cases.</span>
<a href="#l1.7"></a><span id="l1.7">  * For now, the argument can probably be made that our explicit schemas and code</span>
<a href="#l1.8"></a><span id="l1.8">  *  is readable/intuitive (not magic) and efficient (although generic stuff</span>
<a href="#l1.9"></a><span id="l1.9">  *  could also be made efficient, if slightly evil through use of eval or some</span>
<a href="#l1.10"></a><span id="l1.10">  *  other code generation mechanism.)</span>
<a href="#l1.11"></a><span id="l1.11">  *</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+ * === Data Model Interaction / Dependencies</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+ *</span>
<a href="#l1.14"></a><span id="l1.14">  * Dependent on and assumes limited knowledge of the datamodel.js</span>
<a href="#l1.15"></a><span id="l1.15">  *  implementations.  datamodel.js actually has an implicit dependency on</span>
<a href="#l1.16"></a><span id="l1.16">  *  our implementation, reaching back into the datastore via the _datastore</span>
<a href="#l1.17"></a><span id="l1.17">  *  attribute which we pass into every instance we create.</span>
<a href="#l1.18"></a><span id="l1.18">  * We pass a reference to ourself as we create the datamodel.js instances (and</span>
<a href="#l1.19"></a><span id="l1.19">  *  they store it as _datastore) because of a half-implemented attempt to make</span>
<a href="#l1.20"></a><span id="l1.20">  *  it possible to live in a world where we have multiple datastores.  This</span>
<a href="#l1.21"></a><span id="l1.21">  *  would be desirable in the cases where we are dealing with multiple SQLite</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -82,20 +84,73 @@ const kSpecialFulltext = 2;</span>
<a href="#l1.23"></a><span id="l1.23">  *  some other segmentation.  This was abandoned when the importance of</span>
<a href="#l1.24"></a><span id="l1.24">  *  per-account databases was diminished following public discussion, at least</span>
<a href="#l1.25"></a><span id="l1.25">  *  for the short-term, but no attempted was made to excise the feature or</span>
<a href="#l1.26"></a><span id="l1.26">  *  preclude it.  (Merely a recognition that it's too much to try and implement</span>
<a href="#l1.27"></a><span id="l1.27">  *  correct right now, especially because our solution might just be another</span>
<a href="#l1.28"></a><span id="l1.28">  *  (aggregating) layer on top of things, rather than complicating the lower</span>
<a href="#l1.29"></a><span id="l1.29">  *  levels.)</span>
<a href="#l1.30"></a><span id="l1.30">  *</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">- * Note: Although the schema includes &quot;triggers&quot;, they are currently not used</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+ * === Object Identity / Caching</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+ *</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+ * The issue of object identity is handled by integration with the collection.js</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+ *  provided GlodaCollectionManager.  By &quot;Object Identity&quot;, I mean that we only</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+ *  should ever have one object instance alive at a time that corresponds to</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+ *  an underlying database row in the database.  Where possible we avoid</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+ *  performing database look-ups when we can check if the object is already</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+ *  present in memory; in practice, this means when we are asking for an object</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+ *  by ID.  When we cannot avoid a database query, we attempt to make sure that</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+ *  we do not return a duplicate object instance, instead replacing it with the</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+ *  'live' copy of the object.  (Ideally, we would avoid any redundant</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+ *  construction costs, but that is not currently the case.)</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+ * Although you should consult the GlodaCollectionManager for details, the</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+ *  general idea is that we have 'collections' which represent views of the</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+ *  database (based on a query) which use a single mechanism for double duty.</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+ *  The collections are registered with the collection manager via weak</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+ *  reference.  The first 'duty' is that since the collections may be desired</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+ *  to be 'live views' of the data, we want them to update as changes occur.</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+ *  The weak reference allows the collection manager to track the 'live'</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+ *  collections and update them.  The second 'duty' is the caching/object</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+ *  identity duty.  In theory, every live item should be referenced by at least</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+ *  one collection, making it reachable for object identity/caching purposes.</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+ * There is also an explicit (inclusive) caching layer present to both try and</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+ *  avoid poor performance from some of the costs of this strategy, as well as</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+ *  to try and keep track of objects that are being worked with that are not</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+ *  (yet) tracked by a collection.  Using a size-bounded cache is clearly not</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+ *  a guarantee of correctness for this, but is suspected will work quite well.</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+ *  (Well enough to be dangerous because the inevitable failure case will not be</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+ *  expected.)</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+ *</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+ * The current strategy may not be the optimal one, feel free to propose and/or</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+ *  implement better ones, especially if you have numbers.</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+ * The current strategy is not fully implemented in this file, but the common</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+ *  cases are believed to be covered.  (Namely, we fail to purge items from the</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+ *  cache as they are purged from the database.)</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+ *</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+ * === Things That May Not Be Obvious (Gotchas)</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+ * </span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+ * Although the schema includes &quot;triggers&quot;, they are currently not used</span>
<a href="#l1.71"></a><span id="l1.71">  *  and were added when thinking about implementing the feature.  We will</span>
<a href="#l1.72"></a><span id="l1.72">  *  probably implement this feature at some point, which is why they are still</span>
<a href="#l1.73"></a><span id="l1.73">  *  in there.</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+ *</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+ * We, and the layers above us, are not sufficiently thorough at cleaning out</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+ *  data from the database, and may potentially orphan it _as new functionality</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+ *  is added in the future at layers above us_.  That is, currently we should</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+ *  not be leaking database rows, but we may in the future.  This is because</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+ *  we/the layers above us lack a mechanism to track dependencies based on</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+ *  attributes.  Say a plugin exists that extracts recipes from messages and</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+ *  relates them via an attribute.  To do so, it must create new recipe rows</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+ *  in its own table as new recipes are discovered.  No automatic mechanism</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+ *  will purge recipes as their source messages are purged, nor does any</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+ *  event-driven mechanism explicitly inform the plugin.  (It could infer</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+ *  such an event from the indexing/attribute-providing process, or poll the</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineplus">+ *  states of attributes to accomplish this, but that is not desirable.)  This</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineplus">+ *  needs to be addressed, and may be best addressed at layers above</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+ *  datastore.js.</span>
<a href="#l1.89"></a><span id="l1.89">  */</span>
<a href="#l1.90"></a><span id="l1.90"> let GlodaDatastore = {</span>
<a href="#l1.91"></a><span id="l1.91">   _log: null,</span>
<a href="#l1.92"></a><span id="l1.92"> </span>
<a href="#l1.93"></a><span id="l1.93">   /* ******************* SCHEMA ******************* */</span>
<a href="#l1.94"></a><span id="l1.94"> </span>
<a href="#l1.95"></a><span id="l1.95">   _schemaVersion: 5,</span>
<a href="#l1.96"></a><span id="l1.96">   _schema: {</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineat">@@ -601,17 +656,21 @@ let GlodaDatastore = {</span>
<a href="#l1.98"></a><span id="l1.98">   get _selectAllFolderLocations() {</span>
<a href="#l1.99"></a><span id="l1.99">     let statement = this._createStatement(</span>
<a href="#l1.100"></a><span id="l1.100">       &quot;SELECT id, folderURI FROM folderLocations&quot;);</span>
<a href="#l1.101"></a><span id="l1.101">     this.__defineGetter__(&quot;_selectAllFolderLocations&quot;,</span>
<a href="#l1.102"></a><span id="l1.102">       function() statement);</span>
<a href="#l1.103"></a><span id="l1.103">     return this._selectAllFolderLocations;</span>
<a href="#l1.104"></a><span id="l1.104">   },</span>
<a href="#l1.105"></a><span id="l1.105">   </span>
<a href="#l1.106"></a><span id="l1.106" class="difflineminus">-  /** Authoritative map from folder URI to folder ID */</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineplus">+  /**</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineplus">+   * Authoritative map from folder URI to folder ID.  (Authoritative in the</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+   *  sense that this map exactly represents the state of the underlying</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+   *  database.  If it does not, it's a bug in updating the database.)</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+   */</span>
<a href="#l1.112"></a><span id="l1.112">   _folderURIs: {},</span>
<a href="#l1.113"></a><span id="l1.113">   /** Authoritative map from folder ID to folder URI */</span>
<a href="#l1.114"></a><span id="l1.114">   _folderIDs: {},</span>
<a href="#l1.115"></a><span id="l1.115">   </span>
<a href="#l1.116"></a><span id="l1.116">   /** Intialize our _folderURIs/_folderIDs mappings, called by _init(). */</span>
<a href="#l1.117"></a><span id="l1.117">   _getAllFolderMappings: function gloda_ds_getAllFolderMappings() {</span>
<a href="#l1.118"></a><span id="l1.118">     while (this._selectAllFolderLocations.step()) {</span>
<a href="#l1.119"></a><span id="l1.119">       let folderID = this._selectAllFolderLocations.row[&quot;id&quot;];</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineat">@@ -653,16 +712,22 @@ let GlodaDatastore = {</span>
<a href="#l1.121"></a><span id="l1.121">     let statement = this._createStatement(</span>
<a href="#l1.122"></a><span id="l1.122">       &quot;UPDATE folderLocations SET folderURI = :newFolderURI \</span>
<a href="#l1.123"></a><span id="l1.123">               WHERE folderURI = :oldFolderURI&quot;);</span>
<a href="#l1.124"></a><span id="l1.124">     this.__defineGetter__(&quot;_updateFolderLocationStatement&quot;,</span>
<a href="#l1.125"></a><span id="l1.125">       function() statement);</span>
<a href="#l1.126"></a><span id="l1.126">     return this._updateFolderLocationStatement;</span>
<a href="#l1.127"></a><span id="l1.127">   },</span>
<a href="#l1.128"></a><span id="l1.128">   </span>
<a href="#l1.129"></a><span id="l1.129" class="difflineplus">+  /**</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineplus">+   * Non-recursive folder renaming based on the URI.</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineplus">+   *</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineplus">+   * @TODO provide a mechanism for recursive folder renames or have a higher</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineplus">+   *     layer deal with it and remove this note.</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+   */</span>
<a href="#l1.135"></a><span id="l1.135">   renameFolder: function gloda_ds_renameFolder(aOldURI, aNewURI) {</span>
<a href="#l1.136"></a><span id="l1.136">     let folderID = this._mapFolderURI(aOldURI); // ensure the URI is mapped...</span>
<a href="#l1.137"></a><span id="l1.137">     this._folderURIs[aNewURI] = folderID;</span>
<a href="#l1.138"></a><span id="l1.138">     this._folderIDs[folderID] = aNewURI;</span>
<a href="#l1.139"></a><span id="l1.139">     this._log.info(&quot;renaming folder URI &quot; + aOldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l1.140"></a><span id="l1.140">     this._updateFolderLocationStatement.params.oldFolderURI = aOldURI;</span>
<a href="#l1.141"></a><span id="l1.141">     this._updateFolderLocationStatement.params.newFolderURI = aNewURI;</span>
<a href="#l1.142"></a><span id="l1.142">     this._updateFolderLocationStatement.execute();</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineat">@@ -946,16 +1011,23 @@ let GlodaDatastore = {</span>
<a href="#l1.144"></a><span id="l1.144">     let statement = this._createStatement(</span>
<a href="#l1.145"></a><span id="l1.145">       &quot;SELECT * FROM messages WHERE folderID = :folderID AND \</span>
<a href="#l1.146"></a><span id="l1.146">                                     messageKey = :messageKey&quot;);</span>
<a href="#l1.147"></a><span id="l1.147">     this.__defineGetter__(&quot;_selectMessageByLocationStatement&quot;,</span>
<a href="#l1.148"></a><span id="l1.148">       function() statement);</span>
<a href="#l1.149"></a><span id="l1.149">     return this._selectMessageByLocationStatement;</span>
<a href="#l1.150"></a><span id="l1.150">   },</span>
<a href="#l1.151"></a><span id="l1.151"> </span>
<a href="#l1.152"></a><span id="l1.152" class="difflineplus">+  /**</span>
<a href="#l1.153"></a><span id="l1.153" class="difflineplus">+   * Retrieve the message that we believe to correspond to the given message</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineplus">+   *  key in the given folder.</span>
<a href="#l1.155"></a><span id="l1.155" class="difflineplus">+   * @return null on failure to locate the message, the message on success.</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineplus">+   *</span>
<a href="#l1.157"></a><span id="l1.157" class="difflineplus">+   * @XXX on failure, attempt to resolve the problem through re-indexing, etc.</span>
<a href="#l1.158"></a><span id="l1.158" class="difflineplus">+   */</span>
<a href="#l1.159"></a><span id="l1.159">   getMessageFromLocation: function gloda_ds_getMessageFromLocation(aFolderURI,</span>
<a href="#l1.160"></a><span id="l1.160">                                                                  aMessageKey) {</span>
<a href="#l1.161"></a><span id="l1.161">     this._selectMessageByLocationStatement.params.folderID =</span>
<a href="#l1.162"></a><span id="l1.162">       this._mapFolderURI(aFolderURI);</span>
<a href="#l1.163"></a><span id="l1.163">     this._selectMessageByLocationStatement.params.messageKey = aMessageKey;</span>
<a href="#l1.164"></a><span id="l1.164">     </span>
<a href="#l1.165"></a><span id="l1.165">     let message = null;</span>
<a href="#l1.166"></a><span id="l1.166">     if (this._selectMessageByLocationStatement.step())</span>
<a href="#l1.167"></a><span id="l1.167" class="difflineat">@@ -1099,16 +1171,32 @@ let GlodaDatastore = {</span>
<a href="#l1.168"></a><span id="l1.168">     let statement = this._createStatement(</span>
<a href="#l1.169"></a><span id="l1.169">       &quot;SELECT * FROM messages WHERE conversationID = :conversationID AND \</span>
<a href="#l1.170"></a><span id="l1.170">                                     folderID IS NOT NULL&quot;);</span>
<a href="#l1.171"></a><span id="l1.171">     this.__defineGetter__(&quot;_selectMessagesByConversationIDNoGhostsStatement&quot;,</span>
<a href="#l1.172"></a><span id="l1.172">       function() statement);</span>
<a href="#l1.173"></a><span id="l1.173">     return this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l1.174"></a><span id="l1.174">   },</span>
<a href="#l1.175"></a><span id="l1.175"> </span>
<a href="#l1.176"></a><span id="l1.176" class="difflineplus">+  /**</span>
<a href="#l1.177"></a><span id="l1.177" class="difflineplus">+   * Retrieve all the messages belonging to the given conversation.  This</span>
<a href="#l1.178"></a><span id="l1.178" class="difflineplus">+   *  method is used by the indexer and the GlodaConversation class and is not</span>
<a href="#l1.179"></a><span id="l1.179" class="difflineplus">+   *  intended to be used by any other code.  (Most other code should probably</span>
<a href="#l1.180"></a><span id="l1.180" class="difflineplus">+   *  use the GlodaConversation.messages attribute or the general purpose query</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineplus">+   *  mechanism.)</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineplus">+   *</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineplus">+   * @param aConversationID The ID of the conversation for which you want all</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineplus">+   *     the messages.</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineplus">+   * @param aIncludeGhosts Boolean indicating whether you want 'ghost' messages</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineplus">+   *     (true) or not (false).  'Ghost' messages are messages that exist in the</span>
<a href="#l1.187"></a><span id="l1.187" class="difflineplus">+   *     database purely for conversation tracking/threading purposes.  They</span>
<a href="#l1.188"></a><span id="l1.188" class="difflineplus">+   *     are markers for messages we have not yet seen yet assume must exist</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineplus">+   *     based on references/in-reply-to headers from non-ghost messages in our</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineplus">+   *     database.</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+   */</span>
<a href="#l1.192"></a><span id="l1.192">   getMessagesByConversationID: function gloda_ds_getMessagesByConversationID(</span>
<a href="#l1.193"></a><span id="l1.193">         aConversationID, aIncludeGhosts) {</span>
<a href="#l1.194"></a><span id="l1.194">     let statement;</span>
<a href="#l1.195"></a><span id="l1.195">     if (aIncludeGhosts)</span>
<a href="#l1.196"></a><span id="l1.196">       statement = this._selectMessagesByConversationIDStatement;</span>
<a href="#l1.197"></a><span id="l1.197">     else</span>
<a href="#l1.198"></a><span id="l1.198">       statement = this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l1.199"></a><span id="l1.199">     statement.params.conversationID = aConversationID; </span>
<a href="#l1.200"></a><span id="l1.200" class="difflineat">@@ -1132,16 +1220,39 @@ let GlodaDatastore = {</span>
<a href="#l1.201"></a><span id="l1.201">       &quot;INSERT INTO messageAttributes (conversationID, messageID, attributeID, \</span>
<a href="#l1.202"></a><span id="l1.202">                              value) \</span>
<a href="#l1.203"></a><span id="l1.203">               VALUES (:conversationID, :messageID, :attributeID, :value)&quot;);</span>
<a href="#l1.204"></a><span id="l1.204">     this.__defineGetter__(&quot;_insertMessageAttributeStatement&quot;,</span>
<a href="#l1.205"></a><span id="l1.205">       function() statement);</span>
<a href="#l1.206"></a><span id="l1.206">     return this._insertMessageAttributeStatement;</span>
<a href="#l1.207"></a><span id="l1.207">   },</span>
<a href="#l1.208"></a><span id="l1.208">   </span>
<a href="#l1.209"></a><span id="l1.209" class="difflineplus">+  /**</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+   * Insert a bunch of attributes relating to a GlodaMessage.  This is performed</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineplus">+   *  inside a pseudo-transaction (we create one if we aren't in one, using</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+   *  our _beginTransaction wrapper, but if we are in one, no additional</span>
<a href="#l1.213"></a><span id="l1.213" class="difflineplus">+   *  meaningful semantics are added).</span>
<a href="#l1.214"></a><span id="l1.214" class="difflineplus">+   * No attempt is made to verify uniqueness of inserted attributes, either</span>
<a href="#l1.215"></a><span id="l1.215" class="difflineplus">+   *  against the current database or within the provided list of attributes.</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineplus">+   *  The caller is responsible for ensuring that unwanted duplicates are</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineplus">+   *  avoided.</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineplus">+   * Currently, it is expected that this method will be used following a call to</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+   *  clearMessageAttributes to wipe out the existing attributes in the</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineplus">+   *  database.  We will probably try and move to a delta-mechanism in the</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineplus">+   *  future, avoiding needless database churn for small changes in state.</span>
<a href="#l1.222"></a><span id="l1.222" class="difflineplus">+   *</span>
<a href="#l1.223"></a><span id="l1.223" class="difflineplus">+   * @param aMessage The GlodaMessage the attributes belong to.  This is used</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineplus">+   *     to provide the message id and conversation id.</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineplus">+   * @param aAttributes A list of attribute tuples, where each tuple contains</span>
<a href="#l1.226"></a><span id="l1.226" class="difflineplus">+   *     an attribute ID and a value.  Lest you forget, an attribute ID</span>
<a href="#l1.227"></a><span id="l1.227" class="difflineplus">+   *     corresponds to a row in the attribute definition table.  The attribute</span>
<a href="#l1.228"></a><span id="l1.228" class="difflineplus">+   *     definition table stores the 'parameter' for the attribute, if any.</span>
<a href="#l1.229"></a><span id="l1.229" class="difflineplus">+   *     (Which is to say, our frequent Attribute-Parameter-Value triple has</span>
<a href="#l1.230"></a><span id="l1.230" class="difflineplus">+   *     the Attribute-Parameter part distilled to a single attribute id.)</span>
<a href="#l1.231"></a><span id="l1.231" class="difflineplus">+   */</span>
<a href="#l1.232"></a><span id="l1.232">   insertMessageAttributes: function gloda_ds_insertMessageAttributes(aMessage,</span>
<a href="#l1.233"></a><span id="l1.233">                                         aAttributes) {</span>
<a href="#l1.234"></a><span id="l1.234">     let imas = this._insertMessageAttributeStatement;</span>
<a href="#l1.235"></a><span id="l1.235">     this._beginTransaction();</span>
<a href="#l1.236"></a><span id="l1.236">     try {</span>
<a href="#l1.237"></a><span id="l1.237">       for (let iAttribute=0; iAttribute &lt; aAttributes.length; iAttribute++) {</span>
<a href="#l1.238"></a><span id="l1.238">         let attribValueTuple = aAttributes[iAttribute];</span>
<a href="#l1.239"></a><span id="l1.239"> </span>
<a href="#l1.240"></a><span id="l1.240" class="difflineat">@@ -1173,32 +1284,48 @@ let GlodaDatastore = {</span>
<a href="#l1.241"></a><span id="l1.241">   get _deleteMessageAttributesByMessageIDStatement() {</span>
<a href="#l1.242"></a><span id="l1.242">     let statement = this._createStatement(</span>
<a href="#l1.243"></a><span id="l1.243">       &quot;DELETE FROM messageAttributes WHERE messageID = :messageID&quot;);</span>
<a href="#l1.244"></a><span id="l1.244">     this.__defineGetter__(&quot;_deleteMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l1.245"></a><span id="l1.245">       function() statement);</span>
<a href="#l1.246"></a><span id="l1.246">     return this._deleteMessageAttributesByMessageIDStatement;</span>
<a href="#l1.247"></a><span id="l1.247">   },</span>
<a href="#l1.248"></a><span id="l1.248"> </span>
<a href="#l1.249"></a><span id="l1.249" class="difflineplus">+  /**</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineplus">+   * Clear all the message attributes for a given GlodaMessage.  No changes</span>
<a href="#l1.251"></a><span id="l1.251" class="difflineplus">+   *  are made to the in-memory representation of the message; it is up to the</span>
<a href="#l1.252"></a><span id="l1.252" class="difflineplus">+   *  caller to ensure that it handles things correctly.</span>
<a href="#l1.253"></a><span id="l1.253" class="difflineplus">+   *</span>
<a href="#l1.254"></a><span id="l1.254" class="difflineplus">+   * @param aMessage The GlodaMessage whose database attributes should be</span>
<a href="#l1.255"></a><span id="l1.255" class="difflineplus">+   *     purged.</span>
<a href="#l1.256"></a><span id="l1.256" class="difflineplus">+   */</span>
<a href="#l1.257"></a><span id="l1.257">   clearMessageAttributes: function gloda_ds_clearMessageAttributes(aMessage) {</span>
<a href="#l1.258"></a><span id="l1.258">     if (aMessage.id != null) {</span>
<a href="#l1.259"></a><span id="l1.259">       this._deleteMessageAttributesByMessageIDStatement.params.messageID =</span>
<a href="#l1.260"></a><span id="l1.260">         aMessage.id;</span>
<a href="#l1.261"></a><span id="l1.261">       this._deleteMessageAttributesByMessageIDStatement.execute();</span>
<a href="#l1.262"></a><span id="l1.262">     }</span>
<a href="#l1.263"></a><span id="l1.263">   },</span>
<a href="#l1.264"></a><span id="l1.264">   </span>
<a href="#l1.265"></a><span id="l1.265">   get _selectMessageAttributesByMessageIDStatement() {</span>
<a href="#l1.266"></a><span id="l1.266">     let statement = this._createStatement(</span>
<a href="#l1.267"></a><span id="l1.267">       &quot;SELECT * FROM messageAttributes WHERE messageID = :messageID&quot;);</span>
<a href="#l1.268"></a><span id="l1.268">     this.__defineGetter__(&quot;_selectMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l1.269"></a><span id="l1.269">       function() statement);</span>
<a href="#l1.270"></a><span id="l1.270">     return this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l1.271"></a><span id="l1.271">   },</span>
<a href="#l1.272"></a><span id="l1.272">   </span>
<a href="#l1.273"></a><span id="l1.273" class="difflineplus">+  /**</span>
<a href="#l1.274"></a><span id="l1.274" class="difflineplus">+   * Look-up the attributes associated with the given GlodaMessage instance,</span>
<a href="#l1.275"></a><span id="l1.275" class="difflineplus">+   *  returning them in APV form (a tuple of Attribute definition object,</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineplus">+   *  attribute Parameter, and attribute Value).</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineplus">+   *</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineplus">+   * @param aMessage The GlodaMessage whose attributes you want retrieved.</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineplus">+   * @return An APV list of the attributes.</span>
<a href="#l1.280"></a><span id="l1.280" class="difflineplus">+   */</span>
<a href="#l1.281"></a><span id="l1.281">   getMessageAttributes: function gloda_ds_getMessageAttributes(aMessage) {</span>
<a href="#l1.282"></a><span id="l1.282">     // A list of [attribute def object, (attr) parameter value, attribute value]</span>
<a href="#l1.283"></a><span id="l1.283">     let attribParamVals = []</span>
<a href="#l1.284"></a><span id="l1.284">     </span>
<a href="#l1.285"></a><span id="l1.285">     let smas = this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l1.286"></a><span id="l1.286">     </span>
<a href="#l1.287"></a><span id="l1.287">     smas.params.messageID = aMessage.id;</span>
<a href="#l1.288"></a><span id="l1.288">     while (smas.step()) {</span>
<a href="#l1.289"></a><span id="l1.289" class="difflineat">@@ -1212,16 +1339,29 @@ let GlodaDatastore = {</span>
<a href="#l1.290"></a><span id="l1.290">       //                attribAndParam[1] + &quot; val: &quot; + val);</span>
<a href="#l1.291"></a><span id="l1.291">       attribParamVals.push([attribAndParam[0], attribAndParam[1], val]);</span>
<a href="#l1.292"></a><span id="l1.292">     }</span>
<a href="#l1.293"></a><span id="l1.293">     smas.reset();</span>
<a href="#l1.294"></a><span id="l1.294">     </span>
<a href="#l1.295"></a><span id="l1.295">     return attribParamVals;</span>
<a href="#l1.296"></a><span id="l1.296">   },</span>
<a href="#l1.297"></a><span id="l1.297">   </span>
<a href="#l1.298"></a><span id="l1.298" class="difflineplus">+  /**</span>
<a href="#l1.299"></a><span id="l1.299" class="difflineplus">+   * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l1.300"></a><span id="l1.300" class="difflineplus">+   *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l1.301"></a><span id="l1.301" class="difflineplus">+   *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l1.302"></a><span id="l1.302" class="difflineplus">+   *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l1.303"></a><span id="l1.303" class="difflineplus">+   *  its listener) as the state of the database changes.</span>
<a href="#l1.304"></a><span id="l1.304" class="difflineplus">+   * Currently, this operation is fully synchronous, but needs to also provide</span>
<a href="#l1.305"></a><span id="l1.305" class="difflineplus">+   *  an asynchronous means of operation as well.</span>
<a href="#l1.306"></a><span id="l1.306" class="difflineplus">+   * This functionality is made user/extension visible by the Query's getAllSync</span>
<a href="#l1.307"></a><span id="l1.307" class="difflineplus">+   *  method.</span>
<a href="#l1.308"></a><span id="l1.308" class="difflineplus">+   *</span>
<a href="#l1.309"></a><span id="l1.309" class="difflineplus">+   * @TODO Create an asynchronous query-from-query mechanism</span>
<a href="#l1.310"></a><span id="l1.310" class="difflineplus">+   */</span>
<a href="#l1.311"></a><span id="l1.311">   queryFromQuery: function gloda_ds_queryFromQuery(aQuery) {</span>
<a href="#l1.312"></a><span id="l1.312">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l1.313"></a><span id="l1.313">     //  likewise has its changes made.</span>
<a href="#l1.314"></a><span id="l1.314">     let nounMeta = aQuery._nounMeta;</span>
<a href="#l1.315"></a><span id="l1.315">     </span>
<a href="#l1.316"></a><span id="l1.316">     let whereClauses = [];</span>
<a href="#l1.317"></a><span id="l1.317">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l1.318"></a><span id="l1.318">     </span>
<a href="#l1.319"></a><span id="l1.319" class="difflineat">@@ -1347,17 +1487,20 @@ let GlodaDatastore = {</span>
<a href="#l1.320"></a><span id="l1.320">     GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l1.321"></a><span id="l1.321">     </span>
<a href="#l1.322"></a><span id="l1.322">     let collection = new GlodaCollection(items, aQuery);</span>
<a href="#l1.323"></a><span id="l1.323">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l1.324"></a><span id="l1.324">     return collection;</span>
<a href="#l1.325"></a><span id="l1.325">   },</span>
<a href="#l1.326"></a><span id="l1.326">   </span>
<a href="#l1.327"></a><span id="l1.327">   /**</span>
<a href="#l1.328"></a><span id="l1.328" class="difflineminus">-   * Deprecated.  Use queries (which in turn use queryFromQuery).</span>
<a href="#l1.329"></a><span id="l1.329" class="difflineplus">+   * Deprecated.  Use queries (which in turn use queryFromQuery).  This was a</span>
<a href="#l1.330"></a><span id="l1.330" class="difflineplus">+   *  means of querying for messages based on (normalized) attributes by</span>
<a href="#l1.331"></a><span id="l1.331" class="difflineplus">+   *  specifying an APV style query.  This method does not track changes in the</span>
<a href="#l1.332"></a><span id="l1.332" class="difflineplus">+   *  APV representation idiom for queries and may possess other shortcomings.</span>
<a href="#l1.333"></a><span id="l1.333">    */</span>
<a href="#l1.334"></a><span id="l1.334">   queryMessagesAPV: function gloda_ds_queryMessagesAPV(aAPVs) {</span>
<a href="#l1.335"></a><span id="l1.335">     let selects = [];</span>
<a href="#l1.336"></a><span id="l1.336">     </span>
<a href="#l1.337"></a><span id="l1.337">     for (let iAPV=0; iAPV &lt; aAPVs.length; iAPV++) {</span>
<a href="#l1.338"></a><span id="l1.338">       let APV = aAPVs[iAPV];</span>
<a href="#l1.339"></a><span id="l1.339">       </span>
<a href="#l1.340"></a><span id="l1.340">       let attributeID;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -30,39 +30,50 @@</span>
<a href="#l2.4"></a><span id="l2.4">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l2.5"></a><span id="l2.5">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l2.6"></a><span id="l2.6">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l2.7"></a><span id="l2.7">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l2.8"></a><span id="l2.8">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l2.9"></a><span id="l2.9">  * </span>
<a href="#l2.10"></a><span id="l2.10">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+/*</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+ * This file currently contains a fairly general implementation of asynchronous</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+ *  indexing with a very explicit message indexing implementation.  As gloda</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+ *  will eventually want to index more than just messages, the message-specific</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+ *  things should ideally lose their special hold on this file.  This will</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+ *  benefit readability/size as well.</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+ */</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+</span>
<a href="#l2.20"></a><span id="l2.20"> EXPORTED_SYMBOLS = ['GlodaIndexer'];</span>
<a href="#l2.21"></a><span id="l2.21"> </span>
<a href="#l2.22"></a><span id="l2.22"> const Cc = Components.classes;</span>
<a href="#l2.23"></a><span id="l2.23"> const Ci = Components.interfaces;</span>
<a href="#l2.24"></a><span id="l2.24"> const Cr = Components.results;</span>
<a href="#l2.25"></a><span id="l2.25"> const Cu = Components.utils;</span>
<a href="#l2.26"></a><span id="l2.26"> </span>
<a href="#l2.27"></a><span id="l2.27"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l2.28"></a><span id="l2.28"> </span>
<a href="#l2.29"></a><span id="l2.29"> Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l2.30"></a><span id="l2.30"> Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l2.31"></a><span id="l2.31"> Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l2.32"></a><span id="l2.32"> Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l2.33"></a><span id="l2.33"> </span>
<a href="#l2.34"></a><span id="l2.34"> Cu.import(&quot;resource://gloda/modules/mimemsg.js&quot;);</span>
<a href="#l2.35"></a><span id="l2.35"> </span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+// for list comprehension fun</span>
<a href="#l2.37"></a><span id="l2.37"> function range(begin, end) {</span>
<a href="#l2.38"></a><span id="l2.38">   for (let i = begin; i &lt; end; ++i) {</span>
<a href="#l2.39"></a><span id="l2.39">     yield i;</span>
<a href="#l2.40"></a><span id="l2.40">   }</span>
<a href="#l2.41"></a><span id="l2.41"> }</span>
<a href="#l2.42"></a><span id="l2.42"> </span>
<a href="#l2.43"></a><span id="l2.43" class="difflineminus">-// FROM STEEL</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+// FROM STEEL (a la Joey Minta/jminta)</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+// (and to go away when STEEL is checked in, although we may also want to</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+//  consider just specializing the code in the few places this method is used.)</span>
<a href="#l2.47"></a><span id="l2.47"> /**</span>
<a href="#l2.48"></a><span id="l2.48">  * This function will take a variety of xpcom iterators designed for c++ and turn</span>
<a href="#l2.49"></a><span id="l2.49">  * them into a nice JavaScript style object that can be iterated using for...in</span>
<a href="#l2.50"></a><span id="l2.50">  *</span>
<a href="#l2.51"></a><span id="l2.51">  * Currently, we support the following types of xpcom iterators:</span>
<a href="#l2.52"></a><span id="l2.52">  *   nsISupportsArray</span>
<a href="#l2.53"></a><span id="l2.53">  *   nsIEnumerator</span>
<a href="#l2.54"></a><span id="l2.54">  *   nsISimpleEnumerator</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineat">@@ -116,19 +127,35 @@ function fixIterator(aEnum, aIface) {</span>
<a href="#l2.56"></a><span id="l2.56">     }</span>
<a href="#l2.57"></a><span id="l2.57">     return { __iterator__: iter };</span>
<a href="#l2.58"></a><span id="l2.58">   } catch(ex) {}</span>
<a href="#l2.59"></a><span id="l2.59"> }</span>
<a href="#l2.60"></a><span id="l2.60"> </span>
<a href="#l2.61"></a><span id="l2.61"> /**</span>
<a href="#l2.62"></a><span id="l2.62">  * Capture the indexing batch concept explicitly.</span>
<a href="#l2.63"></a><span id="l2.63">  *</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">- * @param aActionDesc ex: &quot;Indexing&quot;, &quot;De-indexing&quot; (you should pass in the</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineminus">- *     localized string)</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineminus">- * @param aTargetName A folder name, or other.</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+ * @param aJobType The type of thing we are indexing.  Current choices are:</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+ *   &quot;folder&quot; and &quot;message&quot;.  Previous choices included &quot;account&quot;.  The indexer</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+ *   currently knows too much about these; they should be de-coupled.</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+ * @param aDeltaType -1 for deletion, 0 for move, 1 for addition/new.</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+ * @param aID Specific to the job type, but for now only used to hold folder</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+ *     IDs.</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+ *</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+ * @ivar items The list of items to process during this job/batch.  (For</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+ *     example, if this is a &quot;messages&quot; job, this would be the list of messages</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+ *     to process, although the specific representation is determined by the</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineplus">+ *     job.)  The list will only be mutated through the addition of extra items.</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineplus">+ * @ivar offset The current offset into the 'items' list (if used), updated as</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineplus">+ *     processing occurs.  If 'items' is not used, the processing code can also</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineplus">+ *     update this in a similar fashion.  This is used by the status</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineplus">+ *     notification code in conjunction with goal.</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineplus">+ * @ivar goal The total number of items to index/actions to perform in this job.</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineplus">+ *     This number may increase during the life of the job, but should not</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+ *     decrease.  This is used by the status notification code in conjunction</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+ *     with the goal.</span>
<a href="#l2.86"></a><span id="l2.86">  */</span>
<a href="#l2.87"></a><span id="l2.87"> function IndexingJob(aJobType, aDeltaType, aID) {</span>
<a href="#l2.88"></a><span id="l2.88">   this.jobType = aJobType;</span>
<a href="#l2.89"></a><span id="l2.89">   this.deltaType = aDeltaType;</span>
<a href="#l2.90"></a><span id="l2.90">   this.id = aID;</span>
<a href="#l2.91"></a><span id="l2.91">   this.items = [];</span>
<a href="#l2.92"></a><span id="l2.92">   this.offset = 0;</span>
<a href="#l2.93"></a><span id="l2.93">   this.goal = null;</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineat">@@ -141,26 +168,64 @@ const kWorkSync = 0;</span>
<a href="#l2.95"></a><span id="l2.95">  *  trust us to call callbackDriver later.</span>
<a href="#l2.96"></a><span id="l2.96">  */</span>
<a href="#l2.97"></a><span id="l2.97"> const kWorkAsync = 1;</span>
<a href="#l2.98"></a><span id="l2.98"> /**</span>
<a href="#l2.99"></a><span id="l2.99">  * We are all done with our task, close us and figure out something else to do.</span>
<a href="#l2.100"></a><span id="l2.100">  */</span>
<a href="#l2.101"></a><span id="l2.101"> const kWorkDone = 2;</span>
<a href="#l2.102"></a><span id="l2.102"> </span>
<a href="#l2.103"></a><span id="l2.103" class="difflineminus">-</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+/**</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+ * === Message Indexing</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineplus">+ * </span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+ * We are good at listening to nsIMsgFolderListener events.  Unfortunately,</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+ *  MailNews isn't pervasively thorough at generating these yet (newsgroups</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+ *  don't produce them, probably not RSS either.)  This provides us with</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+ *  message addition, moves/copies, and deletion.</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineplus">+ * We are not good at listening to nsIFolderListener events.  This means we fail</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineplus">+ *  to update ourselves when a message is changed because of a change in tags,</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineplus">+ *  read status/starred status/etc.  (Well, in fairness, events aren't actually</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineplus">+ *  generated in all of those cases either, yet, but we should try.)  We need</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineplus">+ *  to handle this.</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+ *</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+ * Currently, when we index a message, when it comes to attributes, we ignore</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+ *  all that has come before us and simply blow away the attributes and apply</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+ *  those provided by the attribute providers anew.  This is not particularly</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+ *  efficient for anyone.  Also, I think we probably screw this up now that we</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+ *  have object identity support.  Uh, so, this should be improved, but</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+ *  certainly works.</span>
<a href="#l2.123"></a><span id="l2.123" class="difflineplus">+ *  </span>
<a href="#l2.124"></a><span id="l2.124" class="difflineplus">+ * We are not sufficiently good at detaching our listeners so as to avoid</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineplus">+ *  crashes.  We want to hook the shutdown notification, but we don't.  We do</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+ *  try to hook database-is-going-away notifications, but it's really not</span>
<a href="#l2.127"></a><span id="l2.127" class="difflineplus">+ *  tested.  We definitely do crash sometimes when you're shutting down.</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineplus">+ * </span>
<a href="#l2.129"></a><span id="l2.129" class="difflineplus">+ */</span>
<a href="#l2.130"></a><span id="l2.130"> let GlodaIndexer = {</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+  /**</span>
<a href="#l2.132"></a><span id="l2.132" class="difflineplus">+   * A partial attempt to generalize to support multiple databases.  Each</span>
<a href="#l2.133"></a><span id="l2.133" class="difflineplus">+   *  database would have its own datastore would have its own indexer.  But</span>
<a href="#l2.134"></a><span id="l2.134" class="difflineplus">+   *  we rather inter-mingle our use of this field with the singleton global</span>
<a href="#l2.135"></a><span id="l2.135" class="difflineplus">+   *  GlodaDatastore.</span>
<a href="#l2.136"></a><span id="l2.136" class="difflineplus">+   */</span>
<a href="#l2.137"></a><span id="l2.137">   _datastore: GlodaDatastore,</span>
<a href="#l2.138"></a><span id="l2.138">   _log: Log4Moz.Service.getLogger(&quot;gloda.indexer&quot;),</span>
<a href="#l2.139"></a><span id="l2.139">   _strBundle: null,</span>
<a href="#l2.140"></a><span id="l2.140">   _messenger: null,</span>
<a href="#l2.141"></a><span id="l2.141">   _msgwindow: null,</span>
<a href="#l2.142"></a><span id="l2.142">   _domWindow: null,</span>
<a href="#l2.143"></a><span id="l2.143"> </span>
<a href="#l2.144"></a><span id="l2.144">   _inited: false,</span>
<a href="#l2.145"></a><span id="l2.145" class="difflineplus">+  /**</span>
<a href="#l2.146"></a><span id="l2.146" class="difflineplus">+   * Initialize the indexer, passing in a number of things that either should</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineplus">+   *  not be needed or should be retrieved by the code directly for XPCOM.</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+   *  This means that some chrome code somewhere (generally gloda) needs to</span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+   *  intitialize us.  In theory this might cause sequencing problems, in</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+   *  practice it doesn't.</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+   */</span>
<a href="#l2.152"></a><span id="l2.152">   init: function gloda_index_init(aDOMWindow, aMsgWindow, aStrBundle,</span>
<a href="#l2.153"></a><span id="l2.153">                                   aMessenger) {</span>
<a href="#l2.154"></a><span id="l2.154">     if (this._inited)</span>
<a href="#l2.155"></a><span id="l2.155">       return;</span>
<a href="#l2.156"></a><span id="l2.156">     </span>
<a href="#l2.157"></a><span id="l2.157">     this._inited = true;</span>
<a href="#l2.158"></a><span id="l2.158">     </span>
<a href="#l2.159"></a><span id="l2.159">     // we need this for setTimeout... what to do about this?</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineat">@@ -749,28 +814,38 @@ let GlodaIndexer = {</span>
<a href="#l2.161"></a><span id="l2.161">       // delete the message!</span>
<a href="#l2.162"></a><span id="l2.162">       if (message !== null)</span>
<a href="#l2.163"></a><span id="l2.163">         this._deleteMessage(message);</span>
<a href="#l2.164"></a><span id="l2.164">       yield kWorkSync;</span>
<a href="#l2.165"></a><span id="l2.165">     }</span>
<a href="#l2.166"></a><span id="l2.166">     yield kWorkDone;</span>
<a href="#l2.167"></a><span id="l2.167">   },</span>
<a href="#l2.168"></a><span id="l2.168"> </span>
<a href="#l2.169"></a><span id="l2.169" class="difflineplus">+  /**</span>
<a href="#l2.170"></a><span id="l2.170" class="difflineplus">+   * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l2.171"></a><span id="l2.171" class="difflineplus">+   *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineplus">+   *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l2.173"></a><span id="l2.173" class="difflineplus">+   *  indexed.  (We previously queued accounts rather than immediately</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+   *  walking their list of folders.)</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineplus">+   */</span>
<a href="#l2.176"></a><span id="l2.176">   indexEverything: function glodaIndexEverything() {</span>
<a href="#l2.177"></a><span id="l2.177">     this._log.info(&quot;Queueing all accounts for indexing.&quot;);</span>
<a href="#l2.178"></a><span id="l2.178">     let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l2.179"></a><span id="l2.179">                             getService(Ci.nsIMsgAccountManager);</span>
<a href="#l2.180"></a><span id="l2.180">     </span>
<a href="#l2.181"></a><span id="l2.181">     GlodaDatastore._beginTransaction();</span>
<a href="#l2.182"></a><span id="l2.182">     let sideEffects = [this.indexAccount(account) for each</span>
<a href="#l2.183"></a><span id="l2.183">                        (account in fixIterator(msgAccountManager.accounts,</span>
<a href="#l2.184"></a><span id="l2.184">                                                Ci.nsIMsgAccount))];</span>
<a href="#l2.185"></a><span id="l2.185">     GlodaDatastore._commitTransaction();</span>
<a href="#l2.186"></a><span id="l2.186">   },</span>
<a href="#l2.187"></a><span id="l2.187"> </span>
<a href="#l2.188"></a><span id="l2.188" class="difflineplus">+  /**</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineplus">+   * Queue all of the folders belonging to an account for indexing.</span>
<a href="#l2.190"></a><span id="l2.190" class="difflineplus">+   */</span>
<a href="#l2.191"></a><span id="l2.191">   indexAccount: function glodaIndexAccount(aAccount) {</span>
<a href="#l2.192"></a><span id="l2.192">     let rootFolder = aAccount.incomingServer.rootFolder;</span>
<a href="#l2.193"></a><span id="l2.193">     if (rootFolder instanceof Ci.nsIMsgFolder) {</span>
<a href="#l2.194"></a><span id="l2.194">       this._log.info(&quot;Queueing account folders for indexing: &quot; + aAccount.key);</span>
<a href="#l2.195"></a><span id="l2.195"> </span>
<a href="#l2.196"></a><span id="l2.196">       GlodaDatastore._beginTransaction();</span>
<a href="#l2.197"></a><span id="l2.197">       let folderJobs =</span>
<a href="#l2.198"></a><span id="l2.198">               [new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l2.199"></a><span id="l2.199" class="difflineat">@@ -782,38 +857,44 @@ let GlodaIndexer = {</span>
<a href="#l2.200"></a><span id="l2.200">       this._indexQueue = this._indexQueue.concat(folderJobs);</span>
<a href="#l2.201"></a><span id="l2.201">       this.indexing = true;</span>
<a href="#l2.202"></a><span id="l2.202">     }</span>
<a href="#l2.203"></a><span id="l2.203">     else {</span>
<a href="#l2.204"></a><span id="l2.204">       this._log.info(&quot;Skipping Account, root folder not nsIMsgFolder&quot;);</span>
<a href="#l2.205"></a><span id="l2.205">     }</span>
<a href="#l2.206"></a><span id="l2.206">   },</span>
<a href="#l2.207"></a><span id="l2.207"> </span>
<a href="#l2.208"></a><span id="l2.208" class="difflineplus">+  /**</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineplus">+   * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l2.210"></a><span id="l2.210" class="difflineplus">+   */</span>
<a href="#l2.211"></a><span id="l2.211">   indexFolder: function glodaIndexFolder(aFolder) {</span>
<a href="#l2.212"></a><span id="l2.212">     this._log.info(&quot;Queue-ing folder for indexing: &quot; + aFolder.prettiestName);</span>
<a href="#l2.213"></a><span id="l2.213">     </span>
<a href="#l2.214"></a><span id="l2.214">     this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l2.215"></a><span id="l2.215">                           GlodaDatastore._mapFolderURI(aFolder.URI)));</span>
<a href="#l2.216"></a><span id="l2.216">     this._indexingJobGoal++;</span>
<a href="#l2.217"></a><span id="l2.217">     this.indexing = true;</span>
<a href="#l2.218"></a><span id="l2.218">   },</span>
<a href="#l2.219"></a><span id="l2.219"> </span>
<a href="#l2.220"></a><span id="l2.220" class="difflineplus">+  /**</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineplus">+   * Queue a single folder for indexing given its URI.</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+   */</span>
<a href="#l2.223"></a><span id="l2.223">   indexFolderByURI: function gloda_index_indexFolderByURI(aURI) {</span>
<a href="#l2.224"></a><span id="l2.224">     if (aURI !== null) {</span>
<a href="#l2.225"></a><span id="l2.225">       this._log.info(&quot;Queue-ing folder URI for indexing: &quot; + aURI);</span>
<a href="#l2.226"></a><span id="l2.226">       </span>
<a href="#l2.227"></a><span id="l2.227">       this._indexQueue.push(new IndexingJob(&quot;folder&quot;, 1,</span>
<a href="#l2.228"></a><span id="l2.228">                             GlodaDatastore._mapFolderURI(aURI)));</span>
<a href="#l2.229"></a><span id="l2.229">       this._indexingJobGoal++;</span>
<a href="#l2.230"></a><span id="l2.230">       this.indexing = true;</span>
<a href="#l2.231"></a><span id="l2.231">     }</span>
<a href="#l2.232"></a><span id="l2.232">   },</span>
<a href="#l2.233"></a><span id="l2.233">   </span>
<a href="#l2.234"></a><span id="l2.234">   /**</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineminus">-   * Index messages.</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineplus">+   * Queue a list of messages for indexing.</span>
<a href="#l2.237"></a><span id="l2.237">    *</span>
<a href="#l2.238"></a><span id="l2.238">    * @param aFoldersAndMessages List of [nsIMsgFolder, message key] tuples.</span>
<a href="#l2.239"></a><span id="l2.239">    */</span>
<a href="#l2.240"></a><span id="l2.240">   indexMessages: function gloda_index_indexMessages(aFoldersAndMessages) {</span>
<a href="#l2.241"></a><span id="l2.241">     let job = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l2.242"></a><span id="l2.242">     job.items = [[GlodaDatastore._mapFolderURI(fm[0].URI), fm[1]] for each</span>
<a href="#l2.243"></a><span id="l2.243">                  (fm in aFoldersAndMessages)];</span>
<a href="#l2.244"></a><span id="l2.244">     this._indexQueue.push(job);</span>
<a href="#l2.245"></a><span id="l2.245" class="difflineat">@@ -1140,18 +1221,16 @@ let GlodaIndexer = {</span>
<a href="#l2.246"></a><span id="l2.246">      * We call aUrlListener's OnStopRunningUrl(null, NS_OK) when we are done,</span>
<a href="#l2.247"></a><span id="l2.247">      *  and can provide status updates by calling the shutdown service</span>
<a href="#l2.248"></a><span id="l2.248">      *  (nsIMsgShutdownService)'s setStatusText method. </span>
<a href="#l2.249"></a><span id="l2.249">      */</span>
<a href="#l2.250"></a><span id="l2.250">     doShutdownTask: function gloda_indexer_doShutdownTask(aUrlListener,</span>
<a href="#l2.251"></a><span id="l2.251">                                                           aMsgWingow) {</span>
<a href="#l2.252"></a><span id="l2.252">       this.indexer._onStopIndexingUrlListener = aUrlListener;</span>
<a href="#l2.253"></a><span id="l2.253">       </span>
<a href="#l2.254"></a><span id="l2.254" class="difflineminus">-      </span>
<a href="#l2.255"></a><span id="l2.255" class="difflineminus">-      </span>
<a href="#l2.256"></a><span id="l2.256">       return true;</span>
<a href="#l2.257"></a><span id="l2.257">     },</span>
<a href="#l2.258"></a><span id="l2.258">     </span>
<a href="#l2.259"></a><span id="l2.259">     getCurrentTaskName: function gloda_indexer_getCurrentTaskName() {</span>
<a href="#l2.260"></a><span id="l2.260">       return this.indexer.strBundle.getString(&quot;shutdownTaskName&quot;);</span>
<a href="#l2.261"></a><span id="l2.261">     },</span>
<a href="#l2.262"></a><span id="l2.262">   }, </span>
<a href="#l2.263"></a><span id="l2.263">   </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

