<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 26488:4983b08e301ad7818c1007ea98e40c6f2a3f2638</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 4983b08e301ad7818c1007ea98e40c6f2a3f2638" />
<meta property="og:url" content="/comm-central/rev/4983b08e301ad7818c1007ea98e40c6f2a3f2638" />
<meta property="og:description" content="Bug 1546364 - Reformat to Google coding style in mailnews/imap (part 2). rs=reformat DONTBUILD" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 4983b08e301ad7818c1007ea98e40c6f2a3f2638 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/4983b08e301ad7818c1007ea98e40c6f2a3f2638">shortlog</a> |
<a href="/comm-central/log/4983b08e301ad7818c1007ea98e40c6f2a3f2638">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/4983b08e301ad7818c1007ea98e40c6f2a3f2638">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/4983b08e301ad7818c1007ea98e40c6f2a3f2638">files</a> |
changeset |
<a href="/comm-central/raw-rev/4983b08e301ad7818c1007ea98e40c6f2a3f2638">raw</a>  | <a href="/comm-central/archive/4983b08e301ad7818c1007ea98e40c6f2a3f2638.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">Bug 1546364</a> - Reformat to Google coding style in mailnews/imap (part 2). rs=reformat DONTBUILD
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 01 May 2019 12:24:06 +0200</td></tr>

<tr>
 <td>changeset 26488</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/4983b08e301ad7818c1007ea98e40c6f2a3f2638">4983b08e301ad7818c1007ea98e40c6f2a3f2638</a></td>
</tr>



<tr>
<td>parent 26487</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/0d3f162fe5bb10329dc93e82cb3792d17d3afe01">0d3f162fe5bb10329dc93e82cb3792d17d3afe01</a>
</td>
</tr>

<tr>
<td>child 26489</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/547dab7a9234941e282c7965b67fa43446bea376">547dab7a9234941e282c7965b67fa43446bea376</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=4983b08e301ad7818c1007ea98e40c6f2a3f2638">15857</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Wed, 01 May 2019 10:24:55 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@4983b08e301a [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4983b08e301ad7818c1007ea98e40c6f2a3f2638">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4983b08e301ad7818c1007ea98e40c6f2a3f2638&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4983b08e301ad7818c1007ea98e40c6f2a3f2638&newProject=comm-central&newRevision=4983b08e301ad7818c1007ea98e40c6f2a3f2638&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4983b08e301ad7818c1007ea98e40c6f2a3f2638&newProject=comm-central&newRevision=4983b08e301ad7818c1007ea98e40c6f2a3f2638&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4983b08e301ad7818c1007ea98e40c6f2a3f2638&newProject=comm-central&newRevision=4983b08e301ad7818c1007ea98e40c6f2a3f2638&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28reformat%29&revcount=50">reformat</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">1546364</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1546364">Bug 1546364</a> - Reformat to Google coding style in mailnews/imap (part 2). rs=reformat DONTBUILD
# ignore-this-changeset</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.cpp">mailnews/imap/src/nsImapOfflineSync.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.cpp">file</a> |
<a href="/comm-central/annotate/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.cpp">annotate</a> |
<a href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.cpp">diff</a> |
<a href="/comm-central/comparison/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.cpp">comparison</a> |
<a href="/comm-central/log/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.h">mailnews/imap/src/nsImapOfflineSync.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.h">file</a> |
<a href="/comm-central/annotate/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.h">annotate</a> |
<a href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.h">diff</a> |
<a href="/comm-central/comparison/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.h">comparison</a> |
<a href="/comm-central/log/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapOfflineSync.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.h">mailnews/imap/src/nsImapProtocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.h">file</a> |
<a href="/comm-central/annotate/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.h">annotate</a> |
<a href="/comm-central/diff/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.h">diff</a> |
<a href="/comm-central/comparison/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.h">comparison</a> |
<a href="/comm-central/log/4983b08e301ad7818c1007ea98e40c6f2a3f2638/mailnews/imap/src/nsImapProtocol.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/imap/src/nsImapOfflineSync.cpp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapOfflineSync.cpp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -18,1280 +18,1156 @@</span>
<a href="#l1.4"></a><span id="l1.4"> #include &quot;nsIMsgCopyService.h&quot;</span>
<a href="#l1.5"></a><span id="l1.5"> #include &quot;nsImapProtocol.h&quot;</span>
<a href="#l1.6"></a><span id="l1.6"> #include &quot;nsMsgUtils.h&quot;</span>
<a href="#l1.7"></a><span id="l1.7"> #include &quot;nsIMutableArray.h&quot;</span>
<a href="#l1.8"></a><span id="l1.8"> #include &quot;nsIAutoSyncManager.h&quot;</span>
<a href="#l1.9"></a><span id="l1.9"> #include &quot;nsArrayUtils.h&quot;</span>
<a href="#l1.10"></a><span id="l1.10"> #include &quot;mozilla/Unused.h&quot;</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-NS_IMPL_ISUPPORTS(nsImapOfflineSync, nsIUrlListener, nsIMsgCopyServiceListener, nsIDBChangeListener)</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+NS_IMPL_ISUPPORTS(nsImapOfflineSync, nsIUrlListener, nsIMsgCopyServiceListener,</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+                  nsIDBChangeListener)</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16" class="difflineminus">-nsImapOfflineSync::nsImapOfflineSync(nsIMsgWindow *window, nsIUrlListener *listener, nsIMsgFolder *singleFolderOnly, bool isPseudoOffline)</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineminus">-{</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+nsImapOfflineSync::nsImapOfflineSync(nsIMsgWindow *window,</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+                                     nsIUrlListener *listener,</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+                                     nsIMsgFolder *singleFolderOnly,</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+                                     bool isPseudoOffline) {</span>
<a href="#l1.22"></a><span id="l1.22">   m_singleFolderToUpdate = singleFolderOnly;</span>
<a href="#l1.23"></a><span id="l1.23">   m_window = window;</span>
<a href="#l1.24"></a><span id="l1.24">   // not the perfect place for this, but I think it will work.</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineminus">-  if (m_window)</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineminus">-    m_window-&gt;SetStopped(false);</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+  if (m_window) m_window-&gt;SetStopped(false);</span>
<a href="#l1.28"></a><span id="l1.28"> </span>
<a href="#l1.29"></a><span id="l1.29">   mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kFlagsChanged;</span>
<a href="#l1.30"></a><span id="l1.30">   m_mailboxupdatesStarted = false;</span>
<a href="#l1.31"></a><span id="l1.31">   m_mailboxupdatesFinished = false;</span>
<a href="#l1.32"></a><span id="l1.32">   m_createdOfflineFolders = false;</span>
<a href="#l1.33"></a><span id="l1.33">   m_pseudoOffline = isPseudoOffline;</span>
<a href="#l1.34"></a><span id="l1.34">   m_KeyIndex = 0;</span>
<a href="#l1.35"></a><span id="l1.35">   mCurrentUIDValidity = nsMsgKey_None;</span>
<a href="#l1.36"></a><span id="l1.36">   m_listener = listener;</span>
<a href="#l1.37"></a><span id="l1.37"> }</span>
<a href="#l1.38"></a><span id="l1.38"> </span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-nsImapOfflineSync::~nsImapOfflineSync()</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-{</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-}</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+nsImapOfflineSync::~nsImapOfflineSync() {}</span>
<a href="#l1.43"></a><span id="l1.43"> </span>
<a href="#l1.44"></a><span id="l1.44" class="difflineminus">-void      nsImapOfflineSync::SetWindow(nsIMsgWindow *window)</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineminus">-{</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineminus">-  m_window = window;</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineminus">-}</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+void nsImapOfflineSync::SetWindow(nsIMsgWindow *window) { m_window = window; }</span>
<a href="#l1.49"></a><span id="l1.49"> </span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-NS_IMETHODIMP nsImapOfflineSync::OnStartRunningUrl(nsIURI* url)</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineminus">-{</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+NS_IMETHODIMP nsImapOfflineSync::OnStartRunningUrl(nsIURI *url) {</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.55"></a><span id="l1.55"> }</span>
<a href="#l1.56"></a><span id="l1.56"> </span>
<a href="#l1.57"></a><span id="l1.57"> NS_IMETHODIMP</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineminus">-nsImapOfflineSync::OnStopRunningUrl(nsIURI* url, nsresult exitCode)</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineminus">-{</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+nsImapOfflineSync::OnStopRunningUrl(nsIURI *url, nsresult exitCode) {</span>
<a href="#l1.61"></a><span id="l1.61">   nsresult rv = exitCode;</span>
<a href="#l1.62"></a><span id="l1.62"> </span>
<a href="#l1.63"></a><span id="l1.63">   // where do we make sure this gets cleared when we start running urls?</span>
<a href="#l1.64"></a><span id="l1.64">   bool stopped = false;</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineminus">-  if (m_window)</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineminus">-    m_window-&gt;GetStopped(&amp;stopped);</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+  if (m_window) m_window-&gt;GetStopped(&amp;stopped);</span>
<a href="#l1.68"></a><span id="l1.68"> </span>
<a href="#l1.69"></a><span id="l1.69" class="difflineminus">-  if (m_curTempFile)</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineminus">-  {</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+  if (m_curTempFile) {</span>
<a href="#l1.72"></a><span id="l1.72">     m_curTempFile-&gt;Remove(false);</span>
<a href="#l1.73"></a><span id="l1.73">     m_curTempFile = nullptr;</span>
<a href="#l1.74"></a><span id="l1.74">   }</span>
<a href="#l1.75"></a><span id="l1.75">   // NS_BINDING_ABORTED is used for the user pressing stop, which</span>
<a href="#l1.76"></a><span id="l1.76">   // should cause us to abort the offline process. Other errors</span>
<a href="#l1.77"></a><span id="l1.77">   // should allow us to continue.</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineminus">-  if (stopped)</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineminus">-  {</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineminus">-    if (m_listener)</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineminus">-      m_listener-&gt;OnStopRunningUrl(url, NS_BINDING_ABORTED);</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+  if (stopped) {</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+    if (m_listener) m_listener-&gt;OnStopRunningUrl(url, NS_BINDING_ABORTED);</span>
<a href="#l1.84"></a><span id="l1.84">     return NS_OK;</span>
<a href="#l1.85"></a><span id="l1.85">   }</span>
<a href="#l1.86"></a><span id="l1.86">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(url);</span>
<a href="#l1.87"></a><span id="l1.87"> </span>
<a href="#l1.88"></a><span id="l1.88">   if (imapUrl)</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineminus">-    nsImapProtocol::LogImapUrl(NS_SUCCEEDED(rv) ?</span>
<a href="#l1.90"></a><span id="l1.90" class="difflineminus">-                               &quot;offline imap url succeeded &quot; :</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineminus">-                               &quot;offline imap url failed &quot;, imapUrl);</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+    nsImapProtocol::LogImapUrl(NS_SUCCEEDED(rv) ? &quot;offline imap url succeeded &quot;</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+                                                : &quot;offline imap url failed &quot;,</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineplus">+                               imapUrl);</span>
<a href="#l1.95"></a><span id="l1.95"> </span>
<a href="#l1.96"></a><span id="l1.96">   // If we succeeded, or it was an imap move/copy that timed out, clear the</span>
<a href="#l1.97"></a><span id="l1.97">   // operation.</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineminus">-  bool moveCopy = mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgCopy ||</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineminus">-    mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgMoved;</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+  bool moveCopy =</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+      mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgCopy ||</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+      mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgMoved;</span>
<a href="#l1.103"></a><span id="l1.103">   if (NS_SUCCEEDED(exitCode) || exitCode == NS_MSG_ERROR_IMAP_COMMAND_FAILED ||</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineminus">-      (moveCopy &amp;&amp; exitCode == NS_ERROR_NET_TIMEOUT))</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineminus">-  {</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineplus">+      (moveCopy &amp;&amp; exitCode == NS_ERROR_NET_TIMEOUT)) {</span>
<a href="#l1.107"></a><span id="l1.107">     ClearCurrentOps();</span>
<a href="#l1.108"></a><span id="l1.108">     rv = ProcessNextOperation();</span>
<a href="#l1.109"></a><span id="l1.109">   }</span>
<a href="#l1.110"></a><span id="l1.110">   // else if it's a non-stop error, and we're doing multiple folders,</span>
<a href="#l1.111"></a><span id="l1.111">   // go to the next folder.</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineminus">-  else if (!m_singleFolderToUpdate)</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineminus">-  {</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineplus">+  else if (!m_singleFolderToUpdate) {</span>
<a href="#l1.115"></a><span id="l1.115">     if (AdvanceToNextFolder())</span>
<a href="#l1.116"></a><span id="l1.116">       rv = ProcessNextOperation();</span>
<a href="#l1.117"></a><span id="l1.117">     else if (m_listener)</span>
<a href="#l1.118"></a><span id="l1.118">       m_listener-&gt;OnStopRunningUrl(url, rv);</span>
<a href="#l1.119"></a><span id="l1.119">   }</span>
<a href="#l1.120"></a><span id="l1.120"> </span>
<a href="#l1.121"></a><span id="l1.121">   return rv;</span>
<a href="#l1.122"></a><span id="l1.122"> }</span>
<a href="#l1.123"></a><span id="l1.123"> </span>
<a href="#l1.124"></a><span id="l1.124"> /**</span>
<a href="#l1.125"></a><span id="l1.125">  * Leaves m_currentServer at the next imap or local mail &quot;server&quot; that</span>
<a href="#l1.126"></a><span id="l1.126">  * might have offline events to playback. If no more servers,</span>
<a href="#l1.127"></a><span id="l1.127">  * m_currentServer will be left at nullptr and the function returns false.</span>
<a href="#l1.128"></a><span id="l1.128">  * Also, sets up m_serverEnumerator to enumerate over the server.</span>
<a href="#l1.129"></a><span id="l1.129">  */</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineminus">-bool nsImapOfflineSync::AdvanceToNextServer()</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineminus">-{</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineplus">+bool nsImapOfflineSync::AdvanceToNextServer() {</span>
<a href="#l1.133"></a><span id="l1.133">   nsresult rv = NS_OK;</span>
<a href="#l1.134"></a><span id="l1.134"> </span>
<a href="#l1.135"></a><span id="l1.135" class="difflineminus">-  if (!m_allServers)</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineminus">-  {</span>
<a href="#l1.137"></a><span id="l1.137" class="difflineplus">+  if (!m_allServers) {</span>
<a href="#l1.138"></a><span id="l1.138">     NS_ASSERTION(!m_currentServer, &quot;this shouldn't be set&quot;);</span>
<a href="#l1.139"></a><span id="l1.139">     m_currentServer = nullptr;</span>
<a href="#l1.140"></a><span id="l1.140">     nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager =</span>
<a href="#l1.141"></a><span id="l1.141" class="difflineminus">-             do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineminus">-    NS_ASSERTION(accountManager &amp;&amp; NS_SUCCEEDED(rv), &quot;couldn't get account mgr&quot;);</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineminus">-    if (!accountManager || NS_FAILED(rv))</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineminus">-      return false;</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineplus">+        do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineplus">+    NS_ASSERTION(accountManager &amp;&amp; NS_SUCCEEDED(rv),</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+                 &quot;couldn't get account mgr&quot;);</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+    if (!accountManager || NS_FAILED(rv)) return false;</span>
<a href="#l1.149"></a><span id="l1.149"> </span>
<a href="#l1.150"></a><span id="l1.150">     rv = accountManager-&gt;GetAllServers(getter_AddRefs(m_allServers));</span>
<a href="#l1.151"></a><span id="l1.151">     NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l1.152"></a><span id="l1.152">   }</span>
<a href="#l1.153"></a><span id="l1.153">   uint32_t serverIndex = 0;</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineminus">-  if (m_currentServer)</span>
<a href="#l1.155"></a><span id="l1.155" class="difflineminus">-  {</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineplus">+  if (m_currentServer) {</span>
<a href="#l1.157"></a><span id="l1.157">     rv = m_allServers-&gt;IndexOf(0, m_currentServer, &amp;serverIndex);</span>
<a href="#l1.158"></a><span id="l1.158" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineminus">-      serverIndex = -1;</span>
<a href="#l1.160"></a><span id="l1.160" class="difflineplus">+    if (NS_FAILED(rv)) serverIndex = -1;</span>
<a href="#l1.161"></a><span id="l1.161"> </span>
<a href="#l1.162"></a><span id="l1.162">     // Move to the next server</span>
<a href="#l1.163"></a><span id="l1.163">     ++serverIndex;</span>
<a href="#l1.164"></a><span id="l1.164">   }</span>
<a href="#l1.165"></a><span id="l1.165">   m_currentServer = nullptr;</span>
<a href="#l1.166"></a><span id="l1.166">   uint32_t numServers;</span>
<a href="#l1.167"></a><span id="l1.167">   m_allServers-&gt;GetLength(&amp;numServers);</span>
<a href="#l1.168"></a><span id="l1.168" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l1.169"></a><span id="l1.169" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; rootFolder;</span>
<a href="#l1.170"></a><span id="l1.170"> </span>
<a href="#l1.171"></a><span id="l1.171" class="difflineminus">-  while (serverIndex &lt; numServers)</span>
<a href="#l1.172"></a><span id="l1.172" class="difflineminus">-  {</span>
<a href="#l1.173"></a><span id="l1.173" class="difflineminus">-    nsCOMPtr&lt;nsIMsgIncomingServer&gt; server(do_QueryElementAt(m_allServers, serverIndex));</span>
<a href="#l1.174"></a><span id="l1.174" class="difflineplus">+  while (serverIndex &lt; numServers) {</span>
<a href="#l1.175"></a><span id="l1.175" class="difflineplus">+    nsCOMPtr&lt;nsIMsgIncomingServer&gt; server(</span>
<a href="#l1.176"></a><span id="l1.176" class="difflineplus">+        do_QueryElementAt(m_allServers, serverIndex));</span>
<a href="#l1.177"></a><span id="l1.177">     serverIndex++;</span>
<a href="#l1.178"></a><span id="l1.178"> </span>
<a href="#l1.179"></a><span id="l1.179">     nsCOMPtr&lt;nsINntpIncomingServer&gt; newsServer = do_QueryInterface(server);</span>
<a href="#l1.180"></a><span id="l1.180" class="difflineminus">-    if (newsServer) // news servers aren't involved in offline imap</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineplus">+    if (newsServer)  // news servers aren't involved in offline imap</span>
<a href="#l1.182"></a><span id="l1.182">       continue;</span>
<a href="#l1.183"></a><span id="l1.183"> </span>
<a href="#l1.184"></a><span id="l1.184" class="difflineminus">-    if (server)</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineminus">-    {</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineplus">+    if (server) {</span>
<a href="#l1.187"></a><span id="l1.187">       m_currentServer = server;</span>
<a href="#l1.188"></a><span id="l1.188">       server-&gt;GetRootFolder(getter_AddRefs(rootFolder));</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineminus">-      if (rootFolder)</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineminus">-      {</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+      if (rootFolder) {</span>
<a href="#l1.192"></a><span id="l1.192">         rv = rootFolder-&gt;GetDescendants(getter_AddRefs(m_allFolders));</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineminus">-        {</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineplus">+        if (NS_SUCCEEDED(rv)) {</span>
<a href="#l1.196"></a><span id="l1.196">           rv = m_allFolders-&gt;Enumerate(getter_AddRefs(m_serverEnumerator));</span>
<a href="#l1.197"></a><span id="l1.197" class="difflineminus">-          if (NS_SUCCEEDED(rv) &amp;&amp; m_serverEnumerator)</span>
<a href="#l1.198"></a><span id="l1.198" class="difflineminus">-          {</span>
<a href="#l1.199"></a><span id="l1.199" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; m_serverEnumerator) {</span>
<a href="#l1.200"></a><span id="l1.200">             bool hasMore = false;</span>
<a href="#l1.201"></a><span id="l1.201">             rv = m_serverEnumerator-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineminus">-            if (NS_SUCCEEDED(rv) &amp;&amp; hasMore)</span>
<a href="#l1.203"></a><span id="l1.203" class="difflineminus">-              return true;</span>
<a href="#l1.204"></a><span id="l1.204" class="difflineplus">+            if (NS_SUCCEEDED(rv) &amp;&amp; hasMore) return true;</span>
<a href="#l1.205"></a><span id="l1.205">           }</span>
<a href="#l1.206"></a><span id="l1.206">         }</span>
<a href="#l1.207"></a><span id="l1.207">       }</span>
<a href="#l1.208"></a><span id="l1.208">     }</span>
<a href="#l1.209"></a><span id="l1.209">   }</span>
<a href="#l1.210"></a><span id="l1.210">   return false;</span>
<a href="#l1.211"></a><span id="l1.211"> }</span>
<a href="#l1.212"></a><span id="l1.212"> </span>
<a href="#l1.213"></a><span id="l1.213"> /**</span>
<a href="#l1.214"></a><span id="l1.214">  * Sets m_currentFolder to the next folder to process.</span>
<a href="#l1.215"></a><span id="l1.215">  *</span>
<a href="#l1.216"></a><span id="l1.216">  * @return  True if next folder to process was found, otherwise false.</span>
<a href="#l1.217"></a><span id="l1.217">  */</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineminus">-bool nsImapOfflineSync::AdvanceToNextFolder()</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineminus">-{</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineplus">+bool nsImapOfflineSync::AdvanceToNextFolder() {</span>
<a href="#l1.221"></a><span id="l1.221">   // we always start by changing flags</span>
<a href="#l1.222"></a><span id="l1.222">   mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kFlagsChanged;</span>
<a href="#l1.223"></a><span id="l1.223"> </span>
<a href="#l1.224"></a><span id="l1.224" class="difflineminus">-  if (m_currentFolder)</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineminus">-  {</span>
<a href="#l1.226"></a><span id="l1.226" class="difflineplus">+  if (m_currentFolder) {</span>
<a href="#l1.227"></a><span id="l1.227">     m_currentFolder-&gt;SetMsgDatabase(nullptr);</span>
<a href="#l1.228"></a><span id="l1.228">     m_currentFolder = nullptr;</span>
<a href="#l1.229"></a><span id="l1.229">   }</span>
<a href="#l1.230"></a><span id="l1.230"> </span>
<a href="#l1.231"></a><span id="l1.231">   bool hasMore = false;</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineminus">-  if (m_currentServer)</span>
<a href="#l1.233"></a><span id="l1.233" class="difflineminus">-    m_serverEnumerator-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l1.234"></a><span id="l1.234" class="difflineminus">-  if (!hasMore)</span>
<a href="#l1.235"></a><span id="l1.235" class="difflineminus">-    hasMore = AdvanceToNextServer();</span>
<a href="#l1.236"></a><span id="l1.236" class="difflineplus">+  if (m_currentServer) m_serverEnumerator-&gt;HasMoreElements(&amp;hasMore);</span>
<a href="#l1.237"></a><span id="l1.237" class="difflineplus">+  if (!hasMore) hasMore = AdvanceToNextServer();</span>
<a href="#l1.238"></a><span id="l1.238"> </span>
<a href="#l1.239"></a><span id="l1.239" class="difflineminus">-  if (hasMore)</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineminus">-  {</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineplus">+  if (hasMore) {</span>
<a href="#l1.242"></a><span id="l1.242">     nsCOMPtr&lt;nsISupports&gt; supports;</span>
<a href="#l1.243"></a><span id="l1.243">     nsresult rv = m_serverEnumerator-&gt;GetNext(getter_AddRefs(supports));</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l1.245"></a><span id="l1.245" class="difflineminus">-      m_currentFolder = do_QueryInterface(supports);</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineplus">+    if (NS_SUCCEEDED(rv)) m_currentFolder = do_QueryInterface(supports);</span>
<a href="#l1.247"></a><span id="l1.247">   }</span>
<a href="#l1.248"></a><span id="l1.248">   ClearDB();</span>
<a href="#l1.249"></a><span id="l1.249">   return m_currentFolder;</span>
<a href="#l1.250"></a><span id="l1.250"> }</span>
<a href="#l1.251"></a><span id="l1.251"> </span>
<a href="#l1.252"></a><span id="l1.252" class="difflineminus">-void nsImapOfflineSync::AdvanceToFirstIMAPFolder()</span>
<a href="#l1.253"></a><span id="l1.253" class="difflineminus">-{</span>
<a href="#l1.254"></a><span id="l1.254" class="difflineplus">+void nsImapOfflineSync::AdvanceToFirstIMAPFolder() {</span>
<a href="#l1.255"></a><span id="l1.255">   m_currentServer = nullptr;</span>
<a href="#l1.256"></a><span id="l1.256">   nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder;</span>
<a href="#l1.257"></a><span id="l1.257" class="difflineminus">-  while (!imapFolder &amp;&amp; AdvanceToNextFolder())</span>
<a href="#l1.258"></a><span id="l1.258" class="difflineminus">-  {</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineplus">+  while (!imapFolder &amp;&amp; AdvanceToNextFolder()) {</span>
<a href="#l1.260"></a><span id="l1.260">     imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.261"></a><span id="l1.261">   }</span>
<a href="#l1.262"></a><span id="l1.262"> }</span>
<a href="#l1.263"></a><span id="l1.263"> </span>
<a href="#l1.264"></a><span id="l1.264" class="difflineminus">-void nsImapOfflineSync::ProcessFlagOperation(nsIMsgOfflineImapOperation *op)</span>
<a href="#l1.265"></a><span id="l1.265" class="difflineminus">-{</span>
<a href="#l1.266"></a><span id="l1.266" class="difflineminus">-  nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; currentOp = op;</span>
<a href="#l1.267"></a><span id="l1.267" class="difflineplus">+void nsImapOfflineSync::ProcessFlagOperation(nsIMsgOfflineImapOperation *op) {</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineplus">+  nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp = op;</span>
<a href="#l1.269"></a><span id="l1.269">   nsTArray&lt;nsMsgKey&gt; matchingFlagKeys;</span>
<a href="#l1.270"></a><span id="l1.270">   uint32_t currentKeyIndex = m_KeyIndex;</span>
<a href="#l1.271"></a><span id="l1.271"> </span>
<a href="#l1.272"></a><span id="l1.272">   imapMessageFlagsType matchingFlags;</span>
<a href="#l1.273"></a><span id="l1.273">   currentOp-&gt;GetNewFlags(&amp;matchingFlags);</span>
<a href="#l1.274"></a><span id="l1.274">   imapMessageFlagsType flagOperation;</span>
<a href="#l1.275"></a><span id="l1.275">   imapMessageFlagsType newFlags;</span>
<a href="#l1.276"></a><span id="l1.276">   bool flagsMatch = true;</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineminus">-  do</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineminus">-  { // loop for all messages with the same flags</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineminus">-    if (flagsMatch)</span>
<a href="#l1.280"></a><span id="l1.280" class="difflineminus">-    {</span>
<a href="#l1.281"></a><span id="l1.281" class="difflineplus">+  do {  // loop for all messages with the same flags</span>
<a href="#l1.282"></a><span id="l1.282" class="difflineplus">+    if (flagsMatch) {</span>
<a href="#l1.283"></a><span id="l1.283">       nsMsgKey curKey;</span>
<a href="#l1.284"></a><span id="l1.284">       currentOp-&gt;GetMessageKey(&amp;curKey);</span>
<a href="#l1.285"></a><span id="l1.285">       matchingFlagKeys.AppendElement(curKey);</span>
<a href="#l1.286"></a><span id="l1.286">       currentOp-&gt;SetPlayingBack(true);</span>
<a href="#l1.287"></a><span id="l1.287">       m_currentOpsToClear.AppendObject(currentOp);</span>
<a href="#l1.288"></a><span id="l1.288">     }</span>
<a href="#l1.289"></a><span id="l1.289">     currentOp = nullptr;</span>
<a href="#l1.290"></a><span id="l1.290">     if (++currentKeyIndex &lt; m_CurrentKeys.Length())</span>
<a href="#l1.291"></a><span id="l1.291">       m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[currentKeyIndex], false,</span>
<a href="#l1.292"></a><span id="l1.292" class="difflineminus">-        getter_AddRefs(currentOp));</span>
<a href="#l1.293"></a><span id="l1.293" class="difflineminus">-    if (currentOp)</span>
<a href="#l1.294"></a><span id="l1.294" class="difflineminus">-    {</span>
<a href="#l1.295"></a><span id="l1.295" class="difflineplus">+                                      getter_AddRefs(currentOp));</span>
<a href="#l1.296"></a><span id="l1.296" class="difflineplus">+    if (currentOp) {</span>
<a href="#l1.297"></a><span id="l1.297">       currentOp-&gt;GetFlagOperation(&amp;flagOperation);</span>
<a href="#l1.298"></a><span id="l1.298">       currentOp-&gt;GetNewFlags(&amp;newFlags);</span>
<a href="#l1.299"></a><span id="l1.299">     }</span>
<a href="#l1.300"></a><span id="l1.300" class="difflineminus">-    flagsMatch = (flagOperation &amp; nsIMsgOfflineImapOperation::kFlagsChanged)</span>
<a href="#l1.301"></a><span id="l1.301" class="difflineminus">-                  &amp;&amp; (newFlags == matchingFlags);</span>
<a href="#l1.302"></a><span id="l1.302" class="difflineplus">+    flagsMatch = (flagOperation &amp; nsIMsgOfflineImapOperation::kFlagsChanged) &amp;&amp;</span>
<a href="#l1.303"></a><span id="l1.303" class="difflineplus">+                 (newFlags == matchingFlags);</span>
<a href="#l1.304"></a><span id="l1.304">   } while (currentOp);</span>
<a href="#l1.305"></a><span id="l1.305"> </span>
<a href="#l1.306"></a><span id="l1.306" class="difflineminus">-  if (!matchingFlagKeys.IsEmpty())</span>
<a href="#l1.307"></a><span id="l1.307" class="difflineminus">-  {</span>
<a href="#l1.308"></a><span id="l1.308" class="difflineplus">+  if (!matchingFlagKeys.IsEmpty()) {</span>
<a href="#l1.309"></a><span id="l1.309">     nsAutoCString uids;</span>
<a href="#l1.310"></a><span id="l1.310" class="difflineminus">-    nsImapMailFolder::AllocateUidStringFromKeys(matchingFlagKeys.Elements(), matchingFlagKeys.Length(), uids);</span>
<a href="#l1.311"></a><span id="l1.311" class="difflineplus">+    nsImapMailFolder::AllocateUidStringFromKeys(</span>
<a href="#l1.312"></a><span id="l1.312" class="difflineplus">+        matchingFlagKeys.Elements(), matchingFlagKeys.Length(), uids);</span>
<a href="#l1.313"></a><span id="l1.313">     uint32_t curFolderFlags;</span>
<a href="#l1.314"></a><span id="l1.314">     m_currentFolder-&gt;GetFlags(&amp;curFolderFlags);</span>
<a href="#l1.315"></a><span id="l1.315"> </span>
<a href="#l1.316"></a><span id="l1.316" class="difflineminus">-    if (uids.get() &amp;&amp; (curFolderFlags &amp; nsMsgFolderFlags::ImapBox))</span>
<a href="#l1.317"></a><span id="l1.317" class="difflineminus">-    {</span>
<a href="#l1.318"></a><span id="l1.318" class="difflineplus">+    if (uids.get() &amp;&amp; (curFolderFlags &amp; nsMsgFolderFlags::ImapBox)) {</span>
<a href="#l1.319"></a><span id="l1.319">       nsresult rv = NS_OK;</span>
<a href="#l1.320"></a><span id="l1.320" class="difflineminus">-      nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.321"></a><span id="l1.321" class="difflineminus">-      nsCOMPtr &lt;nsIURI&gt; uriToSetFlags;</span>
<a href="#l1.322"></a><span id="l1.322" class="difflineminus">-      if (imapFolder)</span>
<a href="#l1.323"></a><span id="l1.323" class="difflineminus">-      {</span>
<a href="#l1.324"></a><span id="l1.324" class="difflineminus">-        rv = imapFolder-&gt;SetImapFlags(uids.get(), matchingFlags, getter_AddRefs(uriToSetFlags));</span>
<a href="#l1.325"></a><span id="l1.325" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; uriToSetFlags)</span>
<a href="#l1.326"></a><span id="l1.326" class="difflineminus">-        {</span>
<a href="#l1.327"></a><span id="l1.327" class="difflineminus">-          nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(uriToSetFlags);</span>
<a href="#l1.328"></a><span id="l1.328" class="difflineminus">-          if (mailnewsUrl)</span>
<a href="#l1.329"></a><span id="l1.329" class="difflineminus">-            mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l1.330"></a><span id="l1.330" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l1.331"></a><span id="l1.331" class="difflineplus">+          do_QueryInterface(m_currentFolder);</span>
<a href="#l1.332"></a><span id="l1.332" class="difflineplus">+      nsCOMPtr&lt;nsIURI&gt; uriToSetFlags;</span>
<a href="#l1.333"></a><span id="l1.333" class="difflineplus">+      if (imapFolder) {</span>
<a href="#l1.334"></a><span id="l1.334" class="difflineplus">+        rv = imapFolder-&gt;SetImapFlags(uids.get(), matchingFlags,</span>
<a href="#l1.335"></a><span id="l1.335" class="difflineplus">+                                      getter_AddRefs(uriToSetFlags));</span>
<a href="#l1.336"></a><span id="l1.336" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; uriToSetFlags) {</span>
<a href="#l1.337"></a><span id="l1.337" class="difflineplus">+          nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl =</span>
<a href="#l1.338"></a><span id="l1.338" class="difflineplus">+              do_QueryInterface(uriToSetFlags);</span>
<a href="#l1.339"></a><span id="l1.339" class="difflineplus">+          if (mailnewsUrl) mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l1.340"></a><span id="l1.340">         }</span>
<a href="#l1.341"></a><span id="l1.341">       }</span>
<a href="#l1.342"></a><span id="l1.342">     }</span>
<a href="#l1.343"></a><span id="l1.343" class="difflineminus">-  }</span>
<a href="#l1.344"></a><span id="l1.344" class="difflineminus">-  else</span>
<a href="#l1.345"></a><span id="l1.345" class="difflineplus">+  } else</span>
<a href="#l1.346"></a><span id="l1.346">     ProcessNextOperation();</span>
<a href="#l1.347"></a><span id="l1.347"> }</span>
<a href="#l1.348"></a><span id="l1.348"> </span>
<a href="#l1.349"></a><span id="l1.349" class="difflineminus">-void nsImapOfflineSync::ProcessKeywordOperation(nsIMsgOfflineImapOperation *op)</span>
<a href="#l1.350"></a><span id="l1.350" class="difflineminus">-{</span>
<a href="#l1.351"></a><span id="l1.351" class="difflineminus">-  nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; currentOp = op;</span>
<a href="#l1.352"></a><span id="l1.352" class="difflineplus">+void nsImapOfflineSync::ProcessKeywordOperation(</span>
<a href="#l1.353"></a><span id="l1.353" class="difflineplus">+    nsIMsgOfflineImapOperation *op) {</span>
<a href="#l1.354"></a><span id="l1.354" class="difflineplus">+  nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp = op;</span>
<a href="#l1.355"></a><span id="l1.355">   nsTArray&lt;nsMsgKey&gt; matchingKeywordKeys;</span>
<a href="#l1.356"></a><span id="l1.356">   uint32_t currentKeyIndex = m_KeyIndex;</span>
<a href="#l1.357"></a><span id="l1.357"> </span>
<a href="#l1.358"></a><span id="l1.358">   nsAutoCString keywords;</span>
<a href="#l1.359"></a><span id="l1.359">   if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAddKeywords)</span>
<a href="#l1.360"></a><span id="l1.360">     currentOp-&gt;GetKeywordsToAdd(getter_Copies(keywords));</span>
<a href="#l1.361"></a><span id="l1.361">   else</span>
<a href="#l1.362"></a><span id="l1.362">     currentOp-&gt;GetKeywordsToRemove(getter_Copies(keywords));</span>
<a href="#l1.363"></a><span id="l1.363">   bool keywordsMatch = true;</span>
<a href="#l1.364"></a><span id="l1.364" class="difflineminus">-  do</span>
<a href="#l1.365"></a><span id="l1.365" class="difflineminus">-  { // loop for all messages with the same keywords</span>
<a href="#l1.366"></a><span id="l1.366" class="difflineminus">-    if (keywordsMatch)</span>
<a href="#l1.367"></a><span id="l1.367" class="difflineminus">-    {</span>
<a href="#l1.368"></a><span id="l1.368" class="difflineplus">+  do {  // loop for all messages with the same keywords</span>
<a href="#l1.369"></a><span id="l1.369" class="difflineplus">+    if (keywordsMatch) {</span>
<a href="#l1.370"></a><span id="l1.370">       nsMsgKey curKey;</span>
<a href="#l1.371"></a><span id="l1.371">       currentOp-&gt;GetMessageKey(&amp;curKey);</span>
<a href="#l1.372"></a><span id="l1.372">       matchingKeywordKeys.AppendElement(curKey);</span>
<a href="#l1.373"></a><span id="l1.373">       currentOp-&gt;SetPlayingBack(true);</span>
<a href="#l1.374"></a><span id="l1.374">       m_currentOpsToClear.AppendObject(currentOp);</span>
<a href="#l1.375"></a><span id="l1.375">     }</span>
<a href="#l1.376"></a><span id="l1.376">     currentOp = nullptr;</span>
<a href="#l1.377"></a><span id="l1.377">     if (++currentKeyIndex &lt; m_CurrentKeys.Length())</span>
<a href="#l1.378"></a><span id="l1.378">       m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[currentKeyIndex], false,</span>
<a href="#l1.379"></a><span id="l1.379" class="difflineminus">-        getter_AddRefs(currentOp));</span>
<a href="#l1.380"></a><span id="l1.380" class="difflineminus">-    if (currentOp)</span>
<a href="#l1.381"></a><span id="l1.381" class="difflineminus">-    {</span>
<a href="#l1.382"></a><span id="l1.382" class="difflineplus">+                                      getter_AddRefs(currentOp));</span>
<a href="#l1.383"></a><span id="l1.383" class="difflineplus">+    if (currentOp) {</span>
<a href="#l1.384"></a><span id="l1.384">       nsAutoCString curOpKeywords;</span>
<a href="#l1.385"></a><span id="l1.385">       nsOfflineImapOperationType operation;</span>
<a href="#l1.386"></a><span id="l1.386">       currentOp-&gt;GetOperation(&amp;operation);</span>
<a href="#l1.387"></a><span id="l1.387">       if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAddKeywords)</span>
<a href="#l1.388"></a><span id="l1.388">         currentOp-&gt;GetKeywordsToAdd(getter_Copies(curOpKeywords));</span>
<a href="#l1.389"></a><span id="l1.389">       else</span>
<a href="#l1.390"></a><span id="l1.390">         currentOp-&gt;GetKeywordsToRemove(getter_Copies(curOpKeywords));</span>
<a href="#l1.391"></a><span id="l1.391" class="difflineminus">-      keywordsMatch = (operation &amp; mCurrentPlaybackOpType)</span>
<a href="#l1.392"></a><span id="l1.392" class="difflineminus">-                  &amp;&amp; (curOpKeywords.Equals(keywords));</span>
<a href="#l1.393"></a><span id="l1.393" class="difflineplus">+      keywordsMatch = (operation &amp; mCurrentPlaybackOpType) &amp;&amp;</span>
<a href="#l1.394"></a><span id="l1.394" class="difflineplus">+                      (curOpKeywords.Equals(keywords));</span>
<a href="#l1.395"></a><span id="l1.395">     }</span>
<a href="#l1.396"></a><span id="l1.396">   } while (currentOp);</span>
<a href="#l1.397"></a><span id="l1.397"> </span>
<a href="#l1.398"></a><span id="l1.398" class="difflineminus">-  if (!matchingKeywordKeys.IsEmpty())</span>
<a href="#l1.399"></a><span id="l1.399" class="difflineminus">-  {</span>
<a href="#l1.400"></a><span id="l1.400" class="difflineplus">+  if (!matchingKeywordKeys.IsEmpty()) {</span>
<a href="#l1.401"></a><span id="l1.401">     uint32_t curFolderFlags;</span>
<a href="#l1.402"></a><span id="l1.402">     m_currentFolder-&gt;GetFlags(&amp;curFolderFlags);</span>
<a href="#l1.403"></a><span id="l1.403"> </span>
<a href="#l1.404"></a><span id="l1.404" class="difflineminus">-    if (curFolderFlags &amp; nsMsgFolderFlags::ImapBox)</span>
<a href="#l1.405"></a><span id="l1.405" class="difflineminus">-    {</span>
<a href="#l1.406"></a><span id="l1.406" class="difflineplus">+    if (curFolderFlags &amp; nsMsgFolderFlags::ImapBox) {</span>
<a href="#l1.407"></a><span id="l1.407">       nsresult rv = NS_OK;</span>
<a href="#l1.408"></a><span id="l1.408" class="difflineminus">-      nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.409"></a><span id="l1.409" class="difflineminus">-      nsCOMPtr &lt;nsIURI&gt; uriToStoreCustomKeywords;</span>
<a href="#l1.410"></a><span id="l1.410" class="difflineminus">-      if (imapFolder)</span>
<a href="#l1.411"></a><span id="l1.411" class="difflineminus">-      {</span>
<a href="#l1.412"></a><span id="l1.412" class="difflineminus">-        rv = imapFolder-&gt;StoreCustomKeywords(m_window,</span>
<a href="#l1.413"></a><span id="l1.413" class="difflineminus">-                    (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAddKeywords) ? keywords : EmptyCString(),</span>
<a href="#l1.414"></a><span id="l1.414" class="difflineminus">-                    (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kRemoveKeywords) ? keywords : EmptyCString(),</span>
<a href="#l1.415"></a><span id="l1.415" class="difflineminus">-                    matchingKeywordKeys.Elements(),</span>
<a href="#l1.416"></a><span id="l1.416" class="difflineminus">-                    matchingKeywordKeys.Length(), getter_AddRefs(uriToStoreCustomKeywords));</span>
<a href="#l1.417"></a><span id="l1.417" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; uriToStoreCustomKeywords)</span>
<a href="#l1.418"></a><span id="l1.418" class="difflineminus">-        {</span>
<a href="#l1.419"></a><span id="l1.419" class="difflineminus">-          nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(uriToStoreCustomKeywords);</span>
<a href="#l1.420"></a><span id="l1.420" class="difflineminus">-          if (mailnewsUrl)</span>
<a href="#l1.421"></a><span id="l1.421" class="difflineminus">-            mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l1.422"></a><span id="l1.422" class="difflineplus">+      nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l1.423"></a><span id="l1.423" class="difflineplus">+          do_QueryInterface(m_currentFolder);</span>
<a href="#l1.424"></a><span id="l1.424" class="difflineplus">+      nsCOMPtr&lt;nsIURI&gt; uriToStoreCustomKeywords;</span>
<a href="#l1.425"></a><span id="l1.425" class="difflineplus">+      if (imapFolder) {</span>
<a href="#l1.426"></a><span id="l1.426" class="difflineplus">+        rv = imapFolder-&gt;StoreCustomKeywords(</span>
<a href="#l1.427"></a><span id="l1.427" class="difflineplus">+            m_window,</span>
<a href="#l1.428"></a><span id="l1.428" class="difflineplus">+            (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAddKeywords)</span>
<a href="#l1.429"></a><span id="l1.429" class="difflineplus">+                ? keywords</span>
<a href="#l1.430"></a><span id="l1.430" class="difflineplus">+                : EmptyCString(),</span>
<a href="#l1.431"></a><span id="l1.431" class="difflineplus">+            (mCurrentPlaybackOpType ==</span>
<a href="#l1.432"></a><span id="l1.432" class="difflineplus">+             nsIMsgOfflineImapOperation::kRemoveKeywords)</span>
<a href="#l1.433"></a><span id="l1.433" class="difflineplus">+                ? keywords</span>
<a href="#l1.434"></a><span id="l1.434" class="difflineplus">+                : EmptyCString(),</span>
<a href="#l1.435"></a><span id="l1.435" class="difflineplus">+            matchingKeywordKeys.Elements(), matchingKeywordKeys.Length(),</span>
<a href="#l1.436"></a><span id="l1.436" class="difflineplus">+            getter_AddRefs(uriToStoreCustomKeywords));</span>
<a href="#l1.437"></a><span id="l1.437" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; uriToStoreCustomKeywords) {</span>
<a href="#l1.438"></a><span id="l1.438" class="difflineplus">+          nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl =</span>
<a href="#l1.439"></a><span id="l1.439" class="difflineplus">+              do_QueryInterface(uriToStoreCustomKeywords);</span>
<a href="#l1.440"></a><span id="l1.440" class="difflineplus">+          if (mailnewsUrl) mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l1.441"></a><span id="l1.441">         }</span>
<a href="#l1.442"></a><span id="l1.442">       }</span>
<a href="#l1.443"></a><span id="l1.443">     }</span>
<a href="#l1.444"></a><span id="l1.444" class="difflineminus">-  }</span>
<a href="#l1.445"></a><span id="l1.445" class="difflineminus">-  else</span>
<a href="#l1.446"></a><span id="l1.446" class="difflineplus">+  } else</span>
<a href="#l1.447"></a><span id="l1.447">     ProcessNextOperation();</span>
<a href="#l1.448"></a><span id="l1.448"> }</span>
<a href="#l1.449"></a><span id="l1.449"> </span>
<a href="#l1.450"></a><span id="l1.450"> // XXX This should not be void but return an error to indicate which low</span>
<a href="#l1.451"></a><span id="l1.451"> // level routine failed.</span>
<a href="#l1.452"></a><span id="l1.452" class="difflineminus">-void</span>
<a href="#l1.453"></a><span id="l1.453" class="difflineminus">-nsImapOfflineSync::ProcessAppendMsgOperation(nsIMsgOfflineImapOperation *currentOp, int32_t opType)</span>
<a href="#l1.454"></a><span id="l1.454" class="difflineminus">-{</span>
<a href="#l1.455"></a><span id="l1.455" class="difflineplus">+void nsImapOfflineSync::ProcessAppendMsgOperation(</span>
<a href="#l1.456"></a><span id="l1.456" class="difflineplus">+    nsIMsgOfflineImapOperation *currentOp, int32_t opType) {</span>
<a href="#l1.457"></a><span id="l1.457">   nsMsgKey msgKey;</span>
<a href="#l1.458"></a><span id="l1.458">   currentOp-&gt;GetMessageKey(&amp;msgKey);</span>
<a href="#l1.459"></a><span id="l1.459" class="difflineminus">-  nsCOMPtr &lt;nsIMsgDBHdr&gt; mailHdr;</span>
<a href="#l1.460"></a><span id="l1.460" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDBHdr&gt; mailHdr;</span>
<a href="#l1.461"></a><span id="l1.461">   nsresult rv = m_currentDB-&gt;GetMsgHdrForKey(msgKey, getter_AddRefs(mailHdr));</span>
<a href="#l1.462"></a><span id="l1.462" class="difflineminus">-  if (NS_FAILED(rv) || !mailHdr)</span>
<a href="#l1.463"></a><span id="l1.463" class="difflineminus">-  {</span>
<a href="#l1.464"></a><span id="l1.464" class="difflineplus">+  if (NS_FAILED(rv) || !mailHdr) {</span>
<a href="#l1.465"></a><span id="l1.465">     m_currentDB-&gt;RemoveOfflineOp(currentOp);</span>
<a href="#l1.466"></a><span id="l1.466">     ProcessNextOperation();</span>
<a href="#l1.467"></a><span id="l1.467">     return;</span>
<a href="#l1.468"></a><span id="l1.468">   }</span>
<a href="#l1.469"></a><span id="l1.469"> </span>
<a href="#l1.470"></a><span id="l1.470">   uint64_t messageOffset;</span>
<a href="#l1.471"></a><span id="l1.471">   uint32_t messageSize;</span>
<a href="#l1.472"></a><span id="l1.472">   mailHdr-&gt;GetMessageOffset(&amp;messageOffset);</span>
<a href="#l1.473"></a><span id="l1.473">   mailHdr-&gt;GetOfflineMessageSize(&amp;messageSize);</span>
<a href="#l1.474"></a><span id="l1.474">   nsCOMPtr&lt;nsIFile&gt; tmpFile;</span>
<a href="#l1.475"></a><span id="l1.475"> </span>
<a href="#l1.476"></a><span id="l1.476" class="difflineminus">-  if (NS_WARN_IF(NS_FAILED(</span>
<a href="#l1.477"></a><span id="l1.477" class="difflineminus">-                 GetSpecialDirectoryWithFileName(NS_OS_TEMP_DIR,</span>
<a href="#l1.478"></a><span id="l1.478" class="difflineminus">-                                                 &quot;nscpmsg.txt&quot;,</span>
<a href="#l1.479"></a><span id="l1.479" class="difflineminus">-                                                 getter_AddRefs(tmpFile)))))</span>
<a href="#l1.480"></a><span id="l1.480" class="difflineplus">+  if (NS_WARN_IF(NS_FAILED(GetSpecialDirectoryWithFileName(</span>
<a href="#l1.481"></a><span id="l1.481" class="difflineplus">+          NS_OS_TEMP_DIR, &quot;nscpmsg.txt&quot;, getter_AddRefs(tmpFile)))))</span>
<a href="#l1.482"></a><span id="l1.482">     return;</span>
<a href="#l1.483"></a><span id="l1.483"> </span>
<a href="#l1.484"></a><span id="l1.484" class="difflineminus">-  if (NS_WARN_IF(NS_FAILED(</span>
<a href="#l1.485"></a><span id="l1.485" class="difflineminus">-                 tmpFile-&gt;CreateUnique(nsIFile::NORMAL_FILE_TYPE, 00600))))</span>
<a href="#l1.486"></a><span id="l1.486" class="difflineplus">+  if (NS_WARN_IF(</span>
<a href="#l1.487"></a><span id="l1.487" class="difflineplus">+          NS_FAILED(tmpFile-&gt;CreateUnique(nsIFile::NORMAL_FILE_TYPE, 00600))))</span>
<a href="#l1.488"></a><span id="l1.488">     return;</span>
<a href="#l1.489"></a><span id="l1.489"> </span>
<a href="#l1.490"></a><span id="l1.490" class="difflineminus">-  nsCOMPtr &lt;nsIOutputStream&gt; outputStream;</span>
<a href="#l1.491"></a><span id="l1.491" class="difflineminus">-  rv = MsgNewBufferedFileOutputStream(getter_AddRefs(outputStream),</span>
<a href="#l1.492"></a><span id="l1.492" class="difflineminus">-                                      tmpFile,</span>
<a href="#l1.493"></a><span id="l1.493" class="difflineminus">-                                      PR_WRONLY | PR_CREATE_FILE,</span>
<a href="#l1.494"></a><span id="l1.494" class="difflineminus">-                                      00600);</span>
<a href="#l1.495"></a><span id="l1.495" class="difflineminus">-  if (NS_WARN_IF(NS_FAILED(rv) || !outputStream))</span>
<a href="#l1.496"></a><span id="l1.496" class="difflineminus">-    return;</span>
<a href="#l1.497"></a><span id="l1.497" class="difflineplus">+  nsCOMPtr&lt;nsIOutputStream&gt; outputStream;</span>
<a href="#l1.498"></a><span id="l1.498" class="difflineplus">+  rv = MsgNewBufferedFileOutputStream(getter_AddRefs(outputStream), tmpFile,</span>
<a href="#l1.499"></a><span id="l1.499" class="difflineplus">+                                      PR_WRONLY | PR_CREATE_FILE, 00600);</span>
<a href="#l1.500"></a><span id="l1.500" class="difflineplus">+  if (NS_WARN_IF(NS_FAILED(rv) || !outputStream)) return;</span>
<a href="#l1.501"></a><span id="l1.501"> </span>
<a href="#l1.502"></a><span id="l1.502">   // We break out of the loop to get to the clean-up code.</span>
<a href="#l1.503"></a><span id="l1.503">   bool setPlayingBack = false;</span>
<a href="#l1.504"></a><span id="l1.504">   do {</span>
<a href="#l1.505"></a><span id="l1.505">     nsCString moveDestination;</span>
<a href="#l1.506"></a><span id="l1.506">     currentOp-&gt;GetDestinationFolderURI(getter_Copies(moveDestination));</span>
<a href="#l1.507"></a><span id="l1.507"> </span>
<a href="#l1.508"></a><span id="l1.508">     nsCOMPtr&lt;nsIMsgFolder&gt; destFolder;</span>
<a href="#l1.509"></a><span id="l1.509">     rv = GetOrCreateFolder(moveDestination, getter_AddRefs(destFolder));</span>
<a href="#l1.510"></a><span id="l1.510" class="difflineminus">-    if (NS_WARN_IF(NS_FAILED(rv)))</span>
<a href="#l1.511"></a><span id="l1.511" class="difflineminus">-      break;</span>
<a href="#l1.512"></a><span id="l1.512" class="difflineplus">+    if (NS_WARN_IF(NS_FAILED(rv))) break;</span>
<a href="#l1.513"></a><span id="l1.513"> </span>
<a href="#l1.514"></a><span id="l1.514" class="difflineminus">-    nsCOMPtr &lt;nsIInputStream&gt; offlineStoreInputStream;</span>
<a href="#l1.515"></a><span id="l1.515" class="difflineplus">+    nsCOMPtr&lt;nsIInputStream&gt; offlineStoreInputStream;</span>
<a href="#l1.516"></a><span id="l1.516">     bool reusable;</span>
<a href="#l1.517"></a><span id="l1.517">     rv = destFolder-&gt;GetMsgInputStream(mailHdr, &amp;reusable,</span>
<a href="#l1.518"></a><span id="l1.518">                                        getter_AddRefs(offlineStoreInputStream));</span>
<a href="#l1.519"></a><span id="l1.519" class="difflineminus">-    if (NS_WARN_IF((NS_FAILED(rv) || !offlineStoreInputStream)))</span>
<a href="#l1.520"></a><span id="l1.520" class="difflineminus">-      break;</span>
<a href="#l1.521"></a><span id="l1.521" class="difflineplus">+    if (NS_WARN_IF((NS_FAILED(rv) || !offlineStoreInputStream))) break;</span>
<a href="#l1.522"></a><span id="l1.522"> </span>
<a href="#l1.523"></a><span id="l1.523" class="difflineminus">-    nsCOMPtr&lt;nsISeekableStream&gt; seekStream = do_QueryInterface(offlineStoreInputStream);</span>
<a href="#l1.524"></a><span id="l1.524" class="difflineplus">+    nsCOMPtr&lt;nsISeekableStream&gt; seekStream =</span>
<a href="#l1.525"></a><span id="l1.525" class="difflineplus">+        do_QueryInterface(offlineStoreInputStream);</span>
<a href="#l1.526"></a><span id="l1.526">     MOZ_ASSERT(seekStream, &quot;non seekable stream - can't read from offline msg&quot;);</span>
<a href="#l1.527"></a><span id="l1.527" class="difflineminus">-    if (!seekStream)</span>
<a href="#l1.528"></a><span id="l1.528" class="difflineminus">-      break;</span>
<a href="#l1.529"></a><span id="l1.529" class="difflineplus">+    if (!seekStream) break;</span>
<a href="#l1.530"></a><span id="l1.530"> </span>
<a href="#l1.531"></a><span id="l1.531">     // From this point onwards, we need to set &quot;playing back&quot;.</span>
<a href="#l1.532"></a><span id="l1.532">     setPlayingBack = true;</span>
<a href="#l1.533"></a><span id="l1.533"> </span>
<a href="#l1.534"></a><span id="l1.534">     rv = seekStream-&gt;Seek(PR_SEEK_SET, messageOffset);</span>
<a href="#l1.535"></a><span id="l1.535" class="difflineminus">-    if (NS_WARN_IF(NS_FAILED(rv)))</span>
<a href="#l1.536"></a><span id="l1.536" class="difflineminus">-      break;</span>
<a href="#l1.537"></a><span id="l1.537" class="difflineplus">+    if (NS_WARN_IF(NS_FAILED(rv))) break;</span>
<a href="#l1.538"></a><span id="l1.538"> </span>
<a href="#l1.539"></a><span id="l1.539">     // Copy the dest folder offline store msg to the temp file.</span>
<a href="#l1.540"></a><span id="l1.540">     int32_t inputBufferSize = FILE_IO_BUFFER_SIZE;</span>
<a href="#l1.541"></a><span id="l1.541" class="difflineminus">-    char *inputBuffer = (char *) PR_Malloc(inputBufferSize);</span>
<a href="#l1.542"></a><span id="l1.542" class="difflineplus">+    char *inputBuffer = (char *)PR_Malloc(inputBufferSize);</span>
<a href="#l1.543"></a><span id="l1.543">     int32_t bytesLeft;</span>
<a href="#l1.544"></a><span id="l1.544">     uint32_t bytesRead, bytesWritten;</span>
<a href="#l1.545"></a><span id="l1.545"> </span>
<a href="#l1.546"></a><span id="l1.546">     bytesLeft = messageSize;</span>
<a href="#l1.547"></a><span id="l1.547">     rv = inputBuffer ? NS_OK : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l1.548"></a><span id="l1.548" class="difflineminus">-    while (bytesLeft &gt; 0 &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l1.549"></a><span id="l1.549" class="difflineminus">-    {</span>
<a href="#l1.550"></a><span id="l1.550" class="difflineplus">+    while (bytesLeft &gt; 0 &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<a href="#l1.551"></a><span id="l1.551">       int32_t bytesToRead = std::min(inputBufferSize, bytesLeft);</span>
<a href="#l1.552"></a><span id="l1.552">       rv = offlineStoreInputStream-&gt;Read(inputBuffer, bytesToRead, &amp;bytesRead);</span>
<a href="#l1.553"></a><span id="l1.553" class="difflineminus">-      if (NS_WARN_IF(NS_FAILED(rv)) || bytesRead == 0)</span>
<a href="#l1.554"></a><span id="l1.554" class="difflineminus">-        break;</span>
<a href="#l1.555"></a><span id="l1.555" class="difflineplus">+      if (NS_WARN_IF(NS_FAILED(rv)) || bytesRead == 0) break;</span>
<a href="#l1.556"></a><span id="l1.556">       rv = outputStream-&gt;Write(inputBuffer, bytesRead, &amp;bytesWritten);</span>
<a href="#l1.557"></a><span id="l1.557" class="difflineminus">-      if (NS_WARN_IF(NS_FAILED(rv)))</span>
<a href="#l1.558"></a><span id="l1.558" class="difflineminus">-        break;</span>
<a href="#l1.559"></a><span id="l1.559" class="difflineminus">-      MOZ_ASSERT(bytesWritten == bytesRead, &quot;wrote out incorrect number of bytes&quot;);</span>
<a href="#l1.560"></a><span id="l1.560" class="difflineplus">+      if (NS_WARN_IF(NS_FAILED(rv))) break;</span>
<a href="#l1.561"></a><span id="l1.561" class="difflineplus">+      MOZ_ASSERT(bytesWritten == bytesRead,</span>
<a href="#l1.562"></a><span id="l1.562" class="difflineplus">+                 &quot;wrote out incorrect number of bytes&quot;);</span>
<a href="#l1.563"></a><span id="l1.563">       bytesLeft -= bytesRead;</span>
<a href="#l1.564"></a><span id="l1.564">     }</span>
<a href="#l1.565"></a><span id="l1.565">     PR_FREEIF(inputBuffer);</span>
<a href="#l1.566"></a><span id="l1.566"> </span>
<a href="#l1.567"></a><span id="l1.567">     // rv could have an error from Read/Write.</span>
<a href="#l1.568"></a><span id="l1.568">     nsresult rv2 = outputStream-&gt;Close();</span>
<a href="#l1.569"></a><span id="l1.569">     if (NS_FAILED(rv2)) {</span>
<a href="#l1.570"></a><span id="l1.570">       NS_WARNING(&quot;ouputStream-&gt;Close() failed&quot;);</span>
<a href="#l1.571"></a><span id="l1.571">     }</span>
<a href="#l1.572"></a><span id="l1.572" class="difflineminus">-    outputStream = nullptr; // Don't try to close it again below.</span>
<a href="#l1.573"></a><span id="l1.573" class="difflineplus">+    outputStream = nullptr;  // Don't try to close it again below.</span>
<a href="#l1.574"></a><span id="l1.574"> </span>
<a href="#l1.575"></a><span id="l1.575">     // rv: Read/Write, rv2: Close</span>
<a href="#l1.576"></a><span id="l1.576">     if (NS_FAILED(rv) || NS_FAILED(rv2)) {</span>
<a href="#l1.577"></a><span id="l1.577">       // This Remove() will fail under Windows if the output stream</span>
<a href="#l1.578"></a><span id="l1.578">       // fails to close above.</span>
<a href="#l1.579"></a><span id="l1.579">       mozilla::Unused &lt;&lt; NS_WARN_IF(NS_FAILED(tmpFile-&gt;Remove(false)));</span>
<a href="#l1.580"></a><span id="l1.580">       break;</span>
<a href="#l1.581"></a><span id="l1.581">     }</span>
<a href="#l1.582"></a><span id="l1.582"> </span>
<a href="#l1.583"></a><span id="l1.583">     nsCOMPtr&lt;nsIFile&gt; cloneTmpFile;</span>
<a href="#l1.584"></a><span id="l1.584">     // clone the tmp file to defeat nsIFile's stat/size caching.</span>
<a href="#l1.585"></a><span id="l1.585">     tmpFile-&gt;Clone(getter_AddRefs(cloneTmpFile));</span>
<a href="#l1.586"></a><span id="l1.586">     m_curTempFile = cloneTmpFile;</span>
<a href="#l1.587"></a><span id="l1.587" class="difflineminus">-    nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID);</span>
<a href="#l1.588"></a><span id="l1.588" class="difflineplus">+    nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l1.589"></a><span id="l1.589" class="difflineplus">+        do_GetService(NS_MSGCOPYSERVICE_CONTRACTID);</span>
<a href="#l1.590"></a><span id="l1.590"> </span>
<a href="#l1.591"></a><span id="l1.591">     // CopyFileMessage returns error async to this-&gt;OnStopCopy</span>
<a href="#l1.592"></a><span id="l1.592">     // if copyService is null, let's crash here and now.</span>
<a href="#l1.593"></a><span id="l1.593">     rv = copyService-&gt;CopyFileMessage(cloneTmpFile, destFolder,</span>
<a href="#l1.594"></a><span id="l1.594" class="difflineminus">-                                      nullptr, // nsIMsgDBHdr* msgToReplace</span>
<a href="#l1.595"></a><span id="l1.595" class="difflineminus">-                                      true,    // isDraftOrTemplate</span>
<a href="#l1.596"></a><span id="l1.596" class="difflineminus">-                                      0,       // new msg flags</span>
<a href="#l1.597"></a><span id="l1.597" class="difflineminus">-                                      EmptyCString(),</span>
<a href="#l1.598"></a><span id="l1.598" class="difflineminus">-                                      this,</span>
<a href="#l1.599"></a><span id="l1.599" class="difflineminus">-                                      m_window);</span>
<a href="#l1.600"></a><span id="l1.600" class="difflineminus">-    MOZ_ASSERT(NS_SUCCEEDED(rv), &quot;CopyFileMessage() failed. Fatal. Error in call setup?&quot;);</span>
<a href="#l1.601"></a><span id="l1.601" class="difflineplus">+                                      nullptr,  // nsIMsgDBHdr* msgToReplace</span>
<a href="#l1.602"></a><span id="l1.602" class="difflineplus">+                                      true,     // isDraftOrTemplate</span>
<a href="#l1.603"></a><span id="l1.603" class="difflineplus">+                                      0,        // new msg flags</span>
<a href="#l1.604"></a><span id="l1.604" class="difflineplus">+                                      EmptyCString(), this, m_window);</span>
<a href="#l1.605"></a><span id="l1.605" class="difflineplus">+    MOZ_ASSERT(NS_SUCCEEDED(rv),</span>
<a href="#l1.606"></a><span id="l1.606" class="difflineplus">+               &quot;CopyFileMessage() failed. Fatal. Error in call setup?&quot;);</span>
<a href="#l1.607"></a><span id="l1.607">   } while (false);</span>
<a href="#l1.608"></a><span id="l1.608"> </span>
<a href="#l1.609"></a><span id="l1.609">   if (setPlayingBack) {</span>
<a href="#l1.610"></a><span id="l1.610">     currentOp-&gt;SetPlayingBack(true);</span>
<a href="#l1.611"></a><span id="l1.611">     m_currentOpsToClear.AppendObject(currentOp);</span>
<a href="#l1.612"></a><span id="l1.612">     m_currentDB-&gt;DeleteHeader(mailHdr, nullptr, true, true);</span>
<a href="#l1.613"></a><span id="l1.613">   }</span>
<a href="#l1.614"></a><span id="l1.614"> </span>
<a href="#l1.615"></a><span id="l1.615">   // Close the output stream if it's not already closed.</span>
<a href="#l1.616"></a><span id="l1.616">   if (outputStream)</span>
<a href="#l1.617"></a><span id="l1.617">     mozilla::Unused &lt;&lt; NS_WARN_IF(NS_FAILED(outputStream-&gt;Close()));</span>
<a href="#l1.618"></a><span id="l1.618"> }</span>
<a href="#l1.619"></a><span id="l1.619"> </span>
<a href="#l1.620"></a><span id="l1.620" class="difflineminus">-void nsImapOfflineSync::ClearCurrentOps()</span>
<a href="#l1.621"></a><span id="l1.621" class="difflineminus">-{</span>
<a href="#l1.622"></a><span id="l1.622" class="difflineplus">+void nsImapOfflineSync::ClearCurrentOps() {</span>
<a href="#l1.623"></a><span id="l1.623">   int32_t opCount = m_currentOpsToClear.Count();</span>
<a href="#l1.624"></a><span id="l1.624" class="difflineminus">-  for (int32_t i = opCount - 1; i &gt;= 0; i--)</span>
<a href="#l1.625"></a><span id="l1.625" class="difflineminus">-  {</span>
<a href="#l1.626"></a><span id="l1.626" class="difflineplus">+  for (int32_t i = opCount - 1; i &gt;= 0; i--) {</span>
<a href="#l1.627"></a><span id="l1.627">     m_currentOpsToClear[i]-&gt;SetPlayingBack(false);</span>
<a href="#l1.628"></a><span id="l1.628">     m_currentOpsToClear[i]-&gt;ClearOperation(mCurrentPlaybackOpType);</span>
<a href="#l1.629"></a><span id="l1.629">     m_currentOpsToClear.RemoveObjectAt(i);</span>
<a href="#l1.630"></a><span id="l1.630">   }</span>
<a href="#l1.631"></a><span id="l1.631"> }</span>
<a href="#l1.632"></a><span id="l1.632"> </span>
<a href="#l1.633"></a><span id="l1.633" class="difflineminus">-void nsImapOfflineSync::ProcessMoveOperation(nsIMsgOfflineImapOperation *op)</span>
<a href="#l1.634"></a><span id="l1.634" class="difflineminus">-{</span>
<a href="#l1.635"></a><span id="l1.635" class="difflineplus">+void nsImapOfflineSync::ProcessMoveOperation(nsIMsgOfflineImapOperation *op) {</span>
<a href="#l1.636"></a><span id="l1.636">   nsTArray&lt;nsMsgKey&gt; matchingFlagKeys;</span>
<a href="#l1.637"></a><span id="l1.637">   uint32_t currentKeyIndex = m_KeyIndex;</span>
<a href="#l1.638"></a><span id="l1.638">   nsCString moveDestination;</span>
<a href="#l1.639"></a><span id="l1.639">   op-&gt;GetDestinationFolderURI(getter_Copies(moveDestination));</span>
<a href="#l1.640"></a><span id="l1.640">   bool moveMatches = true;</span>
<a href="#l1.641"></a><span id="l1.641" class="difflineminus">-  nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; currentOp = op;</span>
<a href="#l1.642"></a><span id="l1.642" class="difflineminus">-  do</span>
<a href="#l1.643"></a><span id="l1.643" class="difflineminus">-  {  // loop for all messages with the same destination</span>
<a href="#l1.644"></a><span id="l1.644" class="difflineminus">-    if (moveMatches)</span>
<a href="#l1.645"></a><span id="l1.645" class="difflineminus">-    {</span>
<a href="#l1.646"></a><span id="l1.646" class="difflineplus">+  nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp = op;</span>
<a href="#l1.647"></a><span id="l1.647" class="difflineplus">+  do {  // loop for all messages with the same destination</span>
<a href="#l1.648"></a><span id="l1.648" class="difflineplus">+    if (moveMatches) {</span>
<a href="#l1.649"></a><span id="l1.649">       nsMsgKey curKey;</span>
<a href="#l1.650"></a><span id="l1.650">       currentOp-&gt;GetMessageKey(&amp;curKey);</span>
<a href="#l1.651"></a><span id="l1.651">       matchingFlagKeys.AppendElement(curKey);</span>
<a href="#l1.652"></a><span id="l1.652">       currentOp-&gt;SetPlayingBack(true);</span>
<a href="#l1.653"></a><span id="l1.653">       m_currentOpsToClear.AppendObject(currentOp);</span>
<a href="#l1.654"></a><span id="l1.654">     }</span>
<a href="#l1.655"></a><span id="l1.655">     currentOp = nullptr;</span>
<a href="#l1.656"></a><span id="l1.656"> </span>
<a href="#l1.657"></a><span id="l1.657" class="difflineminus">-    if (++currentKeyIndex &lt; m_CurrentKeys.Length())</span>
<a href="#l1.658"></a><span id="l1.658" class="difflineminus">-    {</span>
<a href="#l1.659"></a><span id="l1.659" class="difflineplus">+    if (++currentKeyIndex &lt; m_CurrentKeys.Length()) {</span>
<a href="#l1.660"></a><span id="l1.660">       nsCString nextDestination;</span>
<a href="#l1.661"></a><span id="l1.661" class="difflineminus">-      nsresult rv = m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[currentKeyIndex], false, getter_AddRefs(currentOp));</span>
<a href="#l1.662"></a><span id="l1.662" class="difflineplus">+      nsresult rv = m_currentDB-&gt;GetOfflineOpForKey(</span>
<a href="#l1.663"></a><span id="l1.663" class="difflineplus">+          m_CurrentKeys[currentKeyIndex], false, getter_AddRefs(currentOp));</span>
<a href="#l1.664"></a><span id="l1.664">       moveMatches = false;</span>
<a href="#l1.665"></a><span id="l1.665" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; currentOp)</span>
<a href="#l1.666"></a><span id="l1.666" class="difflineminus">-      {</span>
<a href="#l1.667"></a><span id="l1.667" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; currentOp) {</span>
<a href="#l1.668"></a><span id="l1.668">         nsOfflineImapOperationType opType;</span>
<a href="#l1.669"></a><span id="l1.669">         currentOp-&gt;GetOperation(&amp;opType);</span>
<a href="#l1.670"></a><span id="l1.670" class="difflineminus">-        if (opType &amp; nsIMsgOfflineImapOperation::kMsgMoved)</span>
<a href="#l1.671"></a><span id="l1.671" class="difflineminus">-        {</span>
<a href="#l1.672"></a><span id="l1.672" class="difflineplus">+        if (opType &amp; nsIMsgOfflineImapOperation::kMsgMoved) {</span>
<a href="#l1.673"></a><span id="l1.673">           currentOp-&gt;GetDestinationFolderURI(getter_Copies(nextDestination));</span>
<a href="#l1.674"></a><span id="l1.674">           moveMatches = moveDestination.Equals(nextDestination);</span>
<a href="#l1.675"></a><span id="l1.675">         }</span>
<a href="#l1.676"></a><span id="l1.676">       }</span>
<a href="#l1.677"></a><span id="l1.677">     }</span>
<a href="#l1.678"></a><span id="l1.678" class="difflineminus">-  }</span>
<a href="#l1.679"></a><span id="l1.679" class="difflineminus">-  while (currentOp);</span>
<a href="#l1.680"></a><span id="l1.680" class="difflineplus">+  } while (currentOp);</span>
<a href="#l1.681"></a><span id="l1.681"> </span>
<a href="#l1.682"></a><span id="l1.682">   nsCOMPtr&lt;nsIMsgFolder&gt; destFolder;</span>
<a href="#l1.683"></a><span id="l1.683">   FindFolder(moveDestination, getter_AddRefs(destFolder));</span>
<a href="#l1.684"></a><span id="l1.684">   // if the dest folder doesn't really exist, these operations are</span>
<a href="#l1.685"></a><span id="l1.685">   // going to fail, so clear them out and move on.</span>
<a href="#l1.686"></a><span id="l1.686" class="difflineminus">-  if (!destFolder)</span>
<a href="#l1.687"></a><span id="l1.687" class="difflineminus">-  {</span>
<a href="#l1.688"></a><span id="l1.688" class="difflineplus">+  if (!destFolder) {</span>
<a href="#l1.689"></a><span id="l1.689">     NS_WARNING(&quot;trying to playing back move to non-existent folder&quot;);</span>
<a href="#l1.690"></a><span id="l1.690">     ClearCurrentOps();</span>
<a href="#l1.691"></a><span id="l1.691">     ProcessNextOperation();</span>
<a href="#l1.692"></a><span id="l1.692">     return;</span>
<a href="#l1.693"></a><span id="l1.693">   }</span>
<a href="#l1.694"></a><span id="l1.694" class="difflineminus">-  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.695"></a><span id="l1.695" class="difflineminus">-  if (imapFolder &amp;&amp; DestFolderOnSameServer(destFolder))</span>
<a href="#l1.696"></a><span id="l1.696" class="difflineminus">-  {</span>
<a href="#l1.697"></a><span id="l1.697" class="difflineminus">-    imapFolder-&gt;ReplayOfflineMoveCopy(matchingFlagKeys.Elements(), matchingFlagKeys.Length(), true, destFolder,</span>
<a href="#l1.698"></a><span id="l1.698" class="difflineminus">-      this, m_window);</span>
<a href="#l1.699"></a><span id="l1.699" class="difflineminus">-  }</span>
<a href="#l1.700"></a><span id="l1.700" class="difflineminus">-  else</span>
<a href="#l1.701"></a><span id="l1.701" class="difflineminus">-  {</span>
<a href="#l1.702"></a><span id="l1.702" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l1.703"></a><span id="l1.703" class="difflineplus">+      do_QueryInterface(m_currentFolder);</span>
<a href="#l1.704"></a><span id="l1.704" class="difflineplus">+  if (imapFolder &amp;&amp; DestFolderOnSameServer(destFolder)) {</span>
<a href="#l1.705"></a><span id="l1.705" class="difflineplus">+    imapFolder-&gt;ReplayOfflineMoveCopy(matchingFlagKeys.Elements(),</span>
<a href="#l1.706"></a><span id="l1.706" class="difflineplus">+                                      matchingFlagKeys.Length(), true,</span>
<a href="#l1.707"></a><span id="l1.707" class="difflineplus">+                                      destFolder, this, m_window);</span>
<a href="#l1.708"></a><span id="l1.708" class="difflineplus">+  } else {</span>
<a href="#l1.709"></a><span id="l1.709">     nsresult rv;</span>
<a href="#l1.710"></a><span id="l1.710" class="difflineminus">-    nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l1.711"></a><span id="l1.711" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l1.712"></a><span id="l1.712" class="difflineminus">-    {</span>
<a href="#l1.713"></a><span id="l1.713" class="difflineminus">-      for (uint32_t keyIndex = 0; keyIndex &lt; matchingFlagKeys.Length(); keyIndex++)</span>
<a href="#l1.714"></a><span id="l1.714" class="difflineminus">-      {</span>
<a href="#l1.715"></a><span id="l1.715" class="difflineplus">+    nsCOMPtr&lt;nsIMutableArray&gt; messages(</span>
<a href="#l1.716"></a><span id="l1.716" class="difflineplus">+        do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l1.717"></a><span id="l1.717" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l1.718"></a><span id="l1.718" class="difflineplus">+      for (uint32_t keyIndex = 0; keyIndex &lt; matchingFlagKeys.Length();</span>
<a href="#l1.719"></a><span id="l1.719" class="difflineplus">+           keyIndex++) {</span>
<a href="#l1.720"></a><span id="l1.720">         nsCOMPtr&lt;nsIMsgDBHdr&gt; mailHdr = nullptr;</span>
<a href="#l1.721"></a><span id="l1.721" class="difflineminus">-        rv = m_currentFolder-&gt;GetMessageHeader(matchingFlagKeys.ElementAt(keyIndex), getter_AddRefs(mailHdr));</span>
<a href="#l1.722"></a><span id="l1.722" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr)</span>
<a href="#l1.723"></a><span id="l1.723" class="difflineminus">-        {</span>
<a href="#l1.724"></a><span id="l1.724" class="difflineplus">+        rv = m_currentFolder-&gt;GetMessageHeader(</span>
<a href="#l1.725"></a><span id="l1.725" class="difflineplus">+            matchingFlagKeys.ElementAt(keyIndex), getter_AddRefs(mailHdr));</span>
<a href="#l1.726"></a><span id="l1.726" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr) {</span>
<a href="#l1.727"></a><span id="l1.727">           uint32_t msgSize;</span>
<a href="#l1.728"></a><span id="l1.728">           // in case of a move, the header has already been deleted,</span>
<a href="#l1.729"></a><span id="l1.729">           // so we've really got a fake header. We need to get its flags and</span>
<a href="#l1.730"></a><span id="l1.730">           // size from the offline op to have any chance of doing the move.</span>
<a href="#l1.731"></a><span id="l1.731">           mailHdr-&gt;GetMessageSize(&amp;msgSize);</span>
<a href="#l1.732"></a><span id="l1.732" class="difflineminus">-          if (!msgSize)</span>
<a href="#l1.733"></a><span id="l1.733" class="difflineminus">-          {</span>
<a href="#l1.734"></a><span id="l1.734" class="difflineplus">+          if (!msgSize) {</span>
<a href="#l1.735"></a><span id="l1.735">             imapMessageFlagsType newImapFlags;</span>
<a href="#l1.736"></a><span id="l1.736">             uint32_t msgFlags = 0;</span>
<a href="#l1.737"></a><span id="l1.737">             op-&gt;GetMsgSize(&amp;msgSize);</span>
<a href="#l1.738"></a><span id="l1.738">             op-&gt;GetNewFlags(&amp;newImapFlags);</span>
<a href="#l1.739"></a><span id="l1.739">             // first three bits are the same</span>
<a href="#l1.740"></a><span id="l1.740">             msgFlags |= (newImapFlags &amp; 0x07);</span>
<a href="#l1.741"></a><span id="l1.741">             if (newImapFlags &amp; kImapMsgForwardedFlag)</span>
<a href="#l1.742"></a><span id="l1.742">               msgFlags |= nsMsgMessageFlags::Forwarded;</span>
<a href="#l1.743"></a><span id="l1.743">             mailHdr-&gt;SetFlags(msgFlags);</span>
<a href="#l1.744"></a><span id="l1.744">             mailHdr-&gt;SetMessageSize(msgSize);</span>
<a href="#l1.745"></a><span id="l1.745">           }</span>
<a href="#l1.746"></a><span id="l1.746">           messages-&gt;AppendElement(mailHdr);</span>
<a href="#l1.747"></a><span id="l1.747">         }</span>
<a href="#l1.748"></a><span id="l1.748">       }</span>
<a href="#l1.749"></a><span id="l1.749" class="difflineminus">-      nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l1.750"></a><span id="l1.750" class="difflineplus">+      nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l1.751"></a><span id="l1.751" class="difflineplus">+          do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l1.752"></a><span id="l1.752">       if (copyService)</span>
<a href="#l1.753"></a><span id="l1.753" class="difflineminus">-        copyService-&gt;CopyMessages(m_currentFolder, messages, destFolder, true, this, m_window, false);</span>
<a href="#l1.754"></a><span id="l1.754" class="difflineplus">+        copyService-&gt;CopyMessages(m_currentFolder, messages, destFolder, true,</span>
<a href="#l1.755"></a><span id="l1.755" class="difflineplus">+                                  this, m_window, false);</span>
<a href="#l1.756"></a><span id="l1.756">     }</span>
<a href="#l1.757"></a><span id="l1.757">   }</span>
<a href="#l1.758"></a><span id="l1.758"> }</span>
<a href="#l1.759"></a><span id="l1.759"> </span>
<a href="#l1.760"></a><span id="l1.760"> // I'm tempted to make this a method on nsIMsgFolder, but that interface</span>
<a href="#l1.761"></a><span id="l1.761"> // is already so huge, and there are only a few places in the code that do this.</span>
<a href="#l1.762"></a><span id="l1.762"> // If there end up to be more places that need this, then we can reconsider.</span>
<a href="#l1.763"></a><span id="l1.763" class="difflineminus">-bool nsImapOfflineSync::DestFolderOnSameServer(nsIMsgFolder *destFolder)</span>
<a href="#l1.764"></a><span id="l1.764" class="difflineminus">-{</span>
<a href="#l1.765"></a><span id="l1.765" class="difflineplus">+bool nsImapOfflineSync::DestFolderOnSameServer(nsIMsgFolder *destFolder) {</span>
<a href="#l1.766"></a><span id="l1.766">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; srcServer;</span>
<a href="#l1.767"></a><span id="l1.767">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; dstServer;</span>
<a href="#l1.768"></a><span id="l1.768"> </span>
<a href="#l1.769"></a><span id="l1.769">   bool sameServer = false;</span>
<a href="#l1.770"></a><span id="l1.770" class="difflineminus">-  if (NS_SUCCEEDED(m_currentFolder-&gt;GetServer(getter_AddRefs(srcServer)))</span>
<a href="#l1.771"></a><span id="l1.771" class="difflineminus">-    &amp;&amp; NS_SUCCEEDED(destFolder-&gt;GetServer(getter_AddRefs(dstServer))))</span>
<a href="#l1.772"></a><span id="l1.772" class="difflineplus">+  if (NS_SUCCEEDED(m_currentFolder-&gt;GetServer(getter_AddRefs(srcServer))) &amp;&amp;</span>
<a href="#l1.773"></a><span id="l1.773" class="difflineplus">+      NS_SUCCEEDED(destFolder-&gt;GetServer(getter_AddRefs(dstServer))))</span>
<a href="#l1.774"></a><span id="l1.774">     dstServer-&gt;Equals(srcServer, &amp;sameServer);</span>
<a href="#l1.775"></a><span id="l1.775">   return sameServer;</span>
<a href="#l1.776"></a><span id="l1.776"> }</span>
<a href="#l1.777"></a><span id="l1.777"> </span>
<a href="#l1.778"></a><span id="l1.778" class="difflineminus">-void nsImapOfflineSync::ProcessCopyOperation(nsIMsgOfflineImapOperation *aCurrentOp)</span>
<a href="#l1.779"></a><span id="l1.779" class="difflineminus">-{</span>
<a href="#l1.780"></a><span id="l1.780" class="difflineplus">+void nsImapOfflineSync::ProcessCopyOperation(</span>
<a href="#l1.781"></a><span id="l1.781" class="difflineplus">+    nsIMsgOfflineImapOperation *aCurrentOp) {</span>
<a href="#l1.782"></a><span id="l1.782">   nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp = aCurrentOp;</span>
<a href="#l1.783"></a><span id="l1.783"> </span>
<a href="#l1.784"></a><span id="l1.784">   nsTArray&lt;nsMsgKey&gt; matchingFlagKeys;</span>
<a href="#l1.785"></a><span id="l1.785">   uint32_t currentKeyIndex = m_KeyIndex;</span>
<a href="#l1.786"></a><span id="l1.786">   nsCString copyDestination;</span>
<a href="#l1.787"></a><span id="l1.787">   currentOp-&gt;GetCopyDestination(0, getter_Copies(copyDestination));</span>
<a href="#l1.788"></a><span id="l1.788">   bool copyMatches = true;</span>
<a href="#l1.789"></a><span id="l1.789">   nsresult rv;</span>
<a href="#l1.790"></a><span id="l1.790"> </span>
<a href="#l1.791"></a><span id="l1.791" class="difflineminus">-  do { // loop for all messages with the same destination</span>
<a href="#l1.792"></a><span id="l1.792" class="difflineminus">-    if (copyMatches)</span>
<a href="#l1.793"></a><span id="l1.793" class="difflineminus">-    {</span>
<a href="#l1.794"></a><span id="l1.794" class="difflineplus">+  do {  // loop for all messages with the same destination</span>
<a href="#l1.795"></a><span id="l1.795" class="difflineplus">+    if (copyMatches) {</span>
<a href="#l1.796"></a><span id="l1.796">       nsMsgKey curKey;</span>
<a href="#l1.797"></a><span id="l1.797">       currentOp-&gt;GetMessageKey(&amp;curKey);</span>
<a href="#l1.798"></a><span id="l1.798">       matchingFlagKeys.AppendElement(curKey);</span>
<a href="#l1.799"></a><span id="l1.799">       currentOp-&gt;SetPlayingBack(true);</span>
<a href="#l1.800"></a><span id="l1.800">       m_currentOpsToClear.AppendObject(currentOp);</span>
<a href="#l1.801"></a><span id="l1.801">     }</span>
<a href="#l1.802"></a><span id="l1.802">     currentOp = nullptr;</span>
<a href="#l1.803"></a><span id="l1.803"> </span>
<a href="#l1.804"></a><span id="l1.804" class="difflineminus">-    if (++currentKeyIndex &lt; m_CurrentKeys.Length())</span>
<a href="#l1.805"></a><span id="l1.805" class="difflineminus">-    {</span>
<a href="#l1.806"></a><span id="l1.806" class="difflineplus">+    if (++currentKeyIndex &lt; m_CurrentKeys.Length()) {</span>
<a href="#l1.807"></a><span id="l1.807">       nsCString nextDestination;</span>
<a href="#l1.808"></a><span id="l1.808">       rv = m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[currentKeyIndex],</span>
<a href="#l1.809"></a><span id="l1.809">                                            false, getter_AddRefs(currentOp));</span>
<a href="#l1.810"></a><span id="l1.810">       copyMatches = false;</span>
<a href="#l1.811"></a><span id="l1.811" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; currentOp)</span>
<a href="#l1.812"></a><span id="l1.812" class="difflineminus">-      {</span>
<a href="#l1.813"></a><span id="l1.813" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; currentOp) {</span>
<a href="#l1.814"></a><span id="l1.814">         nsOfflineImapOperationType opType;</span>
<a href="#l1.815"></a><span id="l1.815">         currentOp-&gt;GetOperation(&amp;opType);</span>
<a href="#l1.816"></a><span id="l1.816" class="difflineminus">-        if (opType &amp; nsIMsgOfflineImapOperation::kMsgCopy)</span>
<a href="#l1.817"></a><span id="l1.817" class="difflineminus">-        {</span>
<a href="#l1.818"></a><span id="l1.818" class="difflineplus">+        if (opType &amp; nsIMsgOfflineImapOperation::kMsgCopy) {</span>
<a href="#l1.819"></a><span id="l1.819">           currentOp-&gt;GetCopyDestination(0, getter_Copies(nextDestination));</span>
<a href="#l1.820"></a><span id="l1.820">           copyMatches = copyDestination.Equals(nextDestination);</span>
<a href="#l1.821"></a><span id="l1.821">         }</span>
<a href="#l1.822"></a><span id="l1.822">       }</span>
<a href="#l1.823"></a><span id="l1.823">     }</span>
<a href="#l1.824"></a><span id="l1.824" class="difflineminus">-  }</span>
<a href="#l1.825"></a><span id="l1.825" class="difflineminus">-  while (currentOp);</span>
<a href="#l1.826"></a><span id="l1.826" class="difflineplus">+  } while (currentOp);</span>
<a href="#l1.827"></a><span id="l1.827"> </span>
<a href="#l1.828"></a><span id="l1.828">   nsAutoCString uids;</span>
<a href="#l1.829"></a><span id="l1.829">   nsCOMPtr&lt;nsIMsgFolder&gt; destFolder;</span>
<a href="#l1.830"></a><span id="l1.830">   FindFolder(copyDestination, getter_AddRefs(destFolder));</span>
<a href="#l1.831"></a><span id="l1.831">   // if the dest folder doesn't really exist, these operations are</span>
<a href="#l1.832"></a><span id="l1.832">   // going to fail, so clear them out and move on.</span>
<a href="#l1.833"></a><span id="l1.833" class="difflineminus">-  if (!destFolder)</span>
<a href="#l1.834"></a><span id="l1.834" class="difflineminus">-  {</span>
<a href="#l1.835"></a><span id="l1.835" class="difflineplus">+  if (!destFolder) {</span>
<a href="#l1.836"></a><span id="l1.836">     NS_ERROR(&quot;trying to playing back copy to non-existent folder&quot;);</span>
<a href="#l1.837"></a><span id="l1.837">     ClearCurrentOps();</span>
<a href="#l1.838"></a><span id="l1.838">     ProcessNextOperation();</span>
<a href="#l1.839"></a><span id="l1.839">     return;</span>
<a href="#l1.840"></a><span id="l1.840">   }</span>
<a href="#l1.841"></a><span id="l1.841" class="difflineminus">-  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.842"></a><span id="l1.842" class="difflineminus">-  if (imapFolder &amp;&amp; DestFolderOnSameServer(destFolder))</span>
<a href="#l1.843"></a><span id="l1.843" class="difflineminus">-  {</span>
<a href="#l1.844"></a><span id="l1.844" class="difflineminus">-    rv = imapFolder-&gt;ReplayOfflineMoveCopy(matchingFlagKeys.Elements(), matchingFlagKeys.Length(), false, destFolder,</span>
<a href="#l1.845"></a><span id="l1.845" class="difflineminus">-                   this, m_window);</span>
<a href="#l1.846"></a><span id="l1.846" class="difflineminus">-  }</span>
<a href="#l1.847"></a><span id="l1.847" class="difflineminus">-  else</span>
<a href="#l1.848"></a><span id="l1.848" class="difflineminus">-  {</span>
<a href="#l1.849"></a><span id="l1.849" class="difflineminus">-    nsCOMPtr&lt;nsIMutableArray&gt; messages(do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l1.850"></a><span id="l1.850" class="difflineminus">-    if (messages &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l1.851"></a><span id="l1.851" class="difflineminus">-    {</span>
<a href="#l1.852"></a><span id="l1.852" class="difflineminus">-      for (uint32_t keyIndex = 0; keyIndex &lt; matchingFlagKeys.Length(); keyIndex++)</span>
<a href="#l1.853"></a><span id="l1.853" class="difflineminus">-      {</span>
<a href="#l1.854"></a><span id="l1.854" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l1.855"></a><span id="l1.855" class="difflineplus">+      do_QueryInterface(m_currentFolder);</span>
<a href="#l1.856"></a><span id="l1.856" class="difflineplus">+  if (imapFolder &amp;&amp; DestFolderOnSameServer(destFolder)) {</span>
<a href="#l1.857"></a><span id="l1.857" class="difflineplus">+    rv = imapFolder-&gt;ReplayOfflineMoveCopy(matchingFlagKeys.Elements(),</span>
<a href="#l1.858"></a><span id="l1.858" class="difflineplus">+                                           matchingFlagKeys.Length(), false,</span>
<a href="#l1.859"></a><span id="l1.859" class="difflineplus">+                                           destFolder, this, m_window);</span>
<a href="#l1.860"></a><span id="l1.860" class="difflineplus">+  } else {</span>
<a href="#l1.861"></a><span id="l1.861" class="difflineplus">+    nsCOMPtr&lt;nsIMutableArray&gt; messages(</span>
<a href="#l1.862"></a><span id="l1.862" class="difflineplus">+        do_CreateInstance(NS_ARRAY_CONTRACTID, &amp;rv));</span>
<a href="#l1.863"></a><span id="l1.863" class="difflineplus">+    if (messages &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<a href="#l1.864"></a><span id="l1.864" class="difflineplus">+      for (uint32_t keyIndex = 0; keyIndex &lt; matchingFlagKeys.Length();</span>
<a href="#l1.865"></a><span id="l1.865" class="difflineplus">+           keyIndex++) {</span>
<a href="#l1.866"></a><span id="l1.866">         nsCOMPtr&lt;nsIMsgDBHdr&gt; mailHdr = nullptr;</span>
<a href="#l1.867"></a><span id="l1.867" class="difflineminus">-        rv = m_currentFolder-&gt;GetMessageHeader(matchingFlagKeys.ElementAt(keyIndex), getter_AddRefs(mailHdr));</span>
<a href="#l1.868"></a><span id="l1.868" class="difflineminus">-        if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr)</span>
<a href="#l1.869"></a><span id="l1.869" class="difflineminus">-          messages-&gt;AppendElement(mailHdr);</span>
<a href="#l1.870"></a><span id="l1.870" class="difflineplus">+        rv = m_currentFolder-&gt;GetMessageHeader(</span>
<a href="#l1.871"></a><span id="l1.871" class="difflineplus">+            matchingFlagKeys.ElementAt(keyIndex), getter_AddRefs(mailHdr));</span>
<a href="#l1.872"></a><span id="l1.872" class="difflineplus">+        if (NS_SUCCEEDED(rv) &amp;&amp; mailHdr) messages-&gt;AppendElement(mailHdr);</span>
<a href="#l1.873"></a><span id="l1.873">       }</span>
<a href="#l1.874"></a><span id="l1.874" class="difflineminus">-      nsCOMPtr&lt;nsIMsgCopyService&gt; copyService = do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l1.875"></a><span id="l1.875" class="difflineplus">+      nsCOMPtr&lt;nsIMsgCopyService&gt; copyService =</span>
<a href="#l1.876"></a><span id="l1.876" class="difflineplus">+          do_GetService(NS_MSGCOPYSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l1.877"></a><span id="l1.877">       if (copyService)</span>
<a href="#l1.878"></a><span id="l1.878" class="difflineminus">-        copyService-&gt;CopyMessages(m_currentFolder, messages, destFolder, false, this, m_window, false);</span>
<a href="#l1.879"></a><span id="l1.879" class="difflineplus">+        copyService-&gt;CopyMessages(m_currentFolder, messages, destFolder, false,</span>
<a href="#l1.880"></a><span id="l1.880" class="difflineplus">+                                  this, m_window, false);</span>
<a href="#l1.881"></a><span id="l1.881">     }</span>
<a href="#l1.882"></a><span id="l1.882">   }</span>
<a href="#l1.883"></a><span id="l1.883"> }</span>
<a href="#l1.884"></a><span id="l1.884"> </span>
<a href="#l1.885"></a><span id="l1.885" class="difflineminus">-void nsImapOfflineSync::ProcessEmptyTrash()</span>
<a href="#l1.886"></a><span id="l1.886" class="difflineminus">-{</span>
<a href="#l1.887"></a><span id="l1.887" class="difflineplus">+void nsImapOfflineSync::ProcessEmptyTrash() {</span>
<a href="#l1.888"></a><span id="l1.888">   m_currentFolder-&gt;EmptyTrash(m_window, this);</span>
<a href="#l1.889"></a><span id="l1.889" class="difflineminus">-  ClearDB(); // EmptyTrash closes and deletes the trash db.</span>
<a href="#l1.890"></a><span id="l1.890" class="difflineplus">+  ClearDB();  // EmptyTrash closes and deletes the trash db.</span>
<a href="#l1.891"></a><span id="l1.891"> }</span>
<a href="#l1.892"></a><span id="l1.892"> </span>
<a href="#l1.893"></a><span id="l1.893" class="difflineminus">-// returns true if we found a folder to create, false if we're done creating folders.</span>
<a href="#l1.894"></a><span id="l1.894" class="difflineminus">-bool nsImapOfflineSync::CreateOfflineFolders()</span>
<a href="#l1.895"></a><span id="l1.895" class="difflineminus">-{</span>
<a href="#l1.896"></a><span id="l1.896" class="difflineminus">-  while (m_currentFolder)</span>
<a href="#l1.897"></a><span id="l1.897" class="difflineminus">-  {</span>
<a href="#l1.898"></a><span id="l1.898" class="difflineplus">+// returns true if we found a folder to create, false if we're done creating</span>
<a href="#l1.899"></a><span id="l1.899" class="difflineplus">+// folders.</span>
<a href="#l1.900"></a><span id="l1.900" class="difflineplus">+bool nsImapOfflineSync::CreateOfflineFolders() {</span>
<a href="#l1.901"></a><span id="l1.901" class="difflineplus">+  while (m_currentFolder) {</span>
<a href="#l1.902"></a><span id="l1.902">     uint32_t flags;</span>
<a href="#l1.903"></a><span id="l1.903">     m_currentFolder-&gt;GetFlags(&amp;flags);</span>
<a href="#l1.904"></a><span id="l1.904">     bool offlineCreate = (flags &amp; nsMsgFolderFlags::CreatedOffline) != 0;</span>
<a href="#l1.905"></a><span id="l1.905" class="difflineminus">-    if (offlineCreate)</span>
<a href="#l1.906"></a><span id="l1.906" class="difflineminus">-    {</span>
<a href="#l1.907"></a><span id="l1.907" class="difflineminus">-      if (CreateOfflineFolder(m_currentFolder))</span>
<a href="#l1.908"></a><span id="l1.908" class="difflineminus">-        return true;</span>
<a href="#l1.909"></a><span id="l1.909" class="difflineplus">+    if (offlineCreate) {</span>
<a href="#l1.910"></a><span id="l1.910" class="difflineplus">+      if (CreateOfflineFolder(m_currentFolder)) return true;</span>
<a href="#l1.911"></a><span id="l1.911">     }</span>
<a href="#l1.912"></a><span id="l1.912">     AdvanceToNextFolder();</span>
<a href="#l1.913"></a><span id="l1.913">   }</span>
<a href="#l1.914"></a><span id="l1.914">   return false;</span>
<a href="#l1.915"></a><span id="l1.915"> }</span>
<a href="#l1.916"></a><span id="l1.916"> </span>
<a href="#l1.917"></a><span id="l1.917" class="difflineminus">-bool nsImapOfflineSync::CreateOfflineFolder(nsIMsgFolder *folder)</span>
<a href="#l1.918"></a><span id="l1.918" class="difflineminus">-{</span>
<a href="#l1.919"></a><span id="l1.919" class="difflineplus">+bool nsImapOfflineSync::CreateOfflineFolder(nsIMsgFolder *folder) {</span>
<a href="#l1.920"></a><span id="l1.920">   nsCOMPtr&lt;nsIMsgFolder&gt; parent;</span>
<a href="#l1.921"></a><span id="l1.921">   folder-&gt;GetParent(getter_AddRefs(parent));</span>
<a href="#l1.922"></a><span id="l1.922"> </span>
<a href="#l1.923"></a><span id="l1.923" class="difflineminus">-  nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(parent);</span>
<a href="#l1.924"></a><span id="l1.924" class="difflineminus">-  nsCOMPtr &lt;nsIURI&gt; createFolderURI;</span>
<a href="#l1.925"></a><span id="l1.925" class="difflineplus">+  nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(parent);</span>
<a href="#l1.926"></a><span id="l1.926" class="difflineplus">+  nsCOMPtr&lt;nsIURI&gt; createFolderURI;</span>
<a href="#l1.927"></a><span id="l1.927">   nsCString onlineName;</span>
<a href="#l1.928"></a><span id="l1.928">   imapFolder-&gt;GetOnlineName(onlineName);</span>
<a href="#l1.929"></a><span id="l1.929"> </span>
<a href="#l1.930"></a><span id="l1.930">   NS_ConvertASCIItoUTF16 folderName(onlineName);</span>
<a href="#l1.931"></a><span id="l1.931" class="difflineminus">-  nsresult rv = imapFolder-&gt;PlaybackOfflineFolderCreate(folderName, nullptr,  getter_AddRefs(createFolderURI));</span>
<a href="#l1.932"></a><span id="l1.932" class="difflineminus">-  if (createFolderURI &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l1.933"></a><span id="l1.933" class="difflineminus">-  {</span>
<a href="#l1.934"></a><span id="l1.934" class="difflineminus">-    nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(createFolderURI);</span>
<a href="#l1.935"></a><span id="l1.935" class="difflineminus">-    if (mailnewsUrl)</span>
<a href="#l1.936"></a><span id="l1.936" class="difflineminus">-      mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l1.937"></a><span id="l1.937" class="difflineplus">+  nsresult rv = imapFolder-&gt;PlaybackOfflineFolderCreate(</span>
<a href="#l1.938"></a><span id="l1.938" class="difflineplus">+      folderName, nullptr, getter_AddRefs(createFolderURI));</span>
<a href="#l1.939"></a><span id="l1.939" class="difflineplus">+  if (createFolderURI &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<a href="#l1.940"></a><span id="l1.940" class="difflineplus">+    nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl =</span>
<a href="#l1.941"></a><span id="l1.941" class="difflineplus">+        do_QueryInterface(createFolderURI);</span>
<a href="#l1.942"></a><span id="l1.942" class="difflineplus">+    if (mailnewsUrl) mailnewsUrl-&gt;RegisterListener(this);</span>
<a href="#l1.943"></a><span id="l1.943">   }</span>
<a href="#l1.944"></a><span id="l1.944" class="difflineminus">-  return NS_SUCCEEDED(rv) ? true : false;  // this is asynch, we have to return and be called again by the OfflineOpExitFunction</span>
<a href="#l1.945"></a><span id="l1.945" class="difflineplus">+  return NS_SUCCEEDED(rv) ? true</span>
<a href="#l1.946"></a><span id="l1.946" class="difflineplus">+                          : false;  // this is asynch, we have to return and be</span>
<a href="#l1.947"></a><span id="l1.947" class="difflineplus">+                                    // called again by the OfflineOpExitFunction</span>
<a href="#l1.948"></a><span id="l1.948"> }</span>
<a href="#l1.949"></a><span id="l1.949"> </span>
<a href="#l1.950"></a><span id="l1.950" class="difflineminus">-int32_t nsImapOfflineSync::GetCurrentUIDValidity()</span>
<a href="#l1.951"></a><span id="l1.951" class="difflineminus">-{</span>
<a href="#l1.952"></a><span id="l1.952" class="difflineminus">-  if (m_currentFolder)</span>
<a href="#l1.953"></a><span id="l1.953" class="difflineminus">-  {</span>
<a href="#l1.954"></a><span id="l1.954" class="difflineminus">-    nsCOMPtr &lt;nsIImapMailFolderSink&gt; imapFolderSink = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.955"></a><span id="l1.955" class="difflineminus">-    if (imapFolderSink)</span>
<a href="#l1.956"></a><span id="l1.956" class="difflineminus">-      imapFolderSink-&gt;GetUidValidity(&amp;mCurrentUIDValidity);</span>
<a href="#l1.957"></a><span id="l1.957" class="difflineplus">+int32_t nsImapOfflineSync::GetCurrentUIDValidity() {</span>
<a href="#l1.958"></a><span id="l1.958" class="difflineplus">+  if (m_currentFolder) {</span>
<a href="#l1.959"></a><span id="l1.959" class="difflineplus">+    nsCOMPtr&lt;nsIImapMailFolderSink&gt; imapFolderSink =</span>
<a href="#l1.960"></a><span id="l1.960" class="difflineplus">+        do_QueryInterface(m_currentFolder);</span>
<a href="#l1.961"></a><span id="l1.961" class="difflineplus">+    if (imapFolderSink) imapFolderSink-&gt;GetUidValidity(&amp;mCurrentUIDValidity);</span>
<a href="#l1.962"></a><span id="l1.962">   }</span>
<a href="#l1.963"></a><span id="l1.963">   return mCurrentUIDValidity;</span>
<a href="#l1.964"></a><span id="l1.964"> }</span>
<a href="#l1.965"></a><span id="l1.965"> </span>
<a href="#l1.966"></a><span id="l1.966"> /**</span>
<a href="#l1.967"></a><span id="l1.967">  * Playing back offline operations is one giant state machine that runs through</span>
<a href="#l1.968"></a><span id="l1.968">  * ProcessNextOperation.</span>
<a href="#l1.969"></a><span id="l1.969">  * The first state is creating online any folders created offline (we do this</span>
<a href="#l1.970"></a><span id="l1.970">  * first, so we can play back any operations in them in the next pass)</span>
<a href="#l1.971"></a><span id="l1.971">  */</span>
<a href="#l1.972"></a><span id="l1.972" class="difflineminus">-nsresult nsImapOfflineSync::ProcessNextOperation()</span>
<a href="#l1.973"></a><span id="l1.973" class="difflineminus">-{</span>
<a href="#l1.974"></a><span id="l1.974" class="difflineplus">+nsresult nsImapOfflineSync::ProcessNextOperation() {</span>
<a href="#l1.975"></a><span id="l1.975">   nsresult rv = NS_OK;</span>
<a href="#l1.976"></a><span id="l1.976"> </span>
<a href="#l1.977"></a><span id="l1.977">   // if we haven't created offline folders, and we're updating all folders,</span>
<a href="#l1.978"></a><span id="l1.978">   // first, find offline folders to create.</span>
<a href="#l1.979"></a><span id="l1.979" class="difflineminus">-  if (!m_createdOfflineFolders)</span>
<a href="#l1.980"></a><span id="l1.980" class="difflineminus">-  {</span>
<a href="#l1.981"></a><span id="l1.981" class="difflineminus">-    if (m_singleFolderToUpdate)</span>
<a href="#l1.982"></a><span id="l1.982" class="difflineminus">-    {</span>
<a href="#l1.983"></a><span id="l1.983" class="difflineminus">-      if (!m_pseudoOffline)</span>
<a href="#l1.984"></a><span id="l1.984" class="difflineminus">-      {</span>
<a href="#l1.985"></a><span id="l1.985" class="difflineplus">+  if (!m_createdOfflineFolders) {</span>
<a href="#l1.986"></a><span id="l1.986" class="difflineplus">+    if (m_singleFolderToUpdate) {</span>
<a href="#l1.987"></a><span id="l1.987" class="difflineplus">+      if (!m_pseudoOffline) {</span>
<a href="#l1.988"></a><span id="l1.988">         AdvanceToFirstIMAPFolder();</span>
<a href="#l1.989"></a><span id="l1.989" class="difflineminus">-        if (CreateOfflineFolders())</span>
<a href="#l1.990"></a><span id="l1.990" class="difflineminus">-          return NS_OK;</span>
<a href="#l1.991"></a><span id="l1.991" class="difflineplus">+        if (CreateOfflineFolders()) return NS_OK;</span>
<a href="#l1.992"></a><span id="l1.992">       }</span>
<a href="#l1.993"></a><span id="l1.993" class="difflineminus">-    }</span>
<a href="#l1.994"></a><span id="l1.994" class="difflineminus">-    else</span>
<a href="#l1.995"></a><span id="l1.995" class="difflineminus">-    {</span>
<a href="#l1.996"></a><span id="l1.996" class="difflineminus">-      if (CreateOfflineFolders())</span>
<a href="#l1.997"></a><span id="l1.997" class="difflineminus">-        return NS_OK;</span>
<a href="#l1.998"></a><span id="l1.998" class="difflineplus">+    } else {</span>
<a href="#l1.999"></a><span id="l1.999" class="difflineplus">+      if (CreateOfflineFolders()) return NS_OK;</span>
<a href="#l1.1000"></a><span id="l1.1000">       m_currentServer = nullptr;</span>
<a href="#l1.1001"></a><span id="l1.1001">       AdvanceToNextFolder();</span>
<a href="#l1.1002"></a><span id="l1.1002">     }</span>
<a href="#l1.1003"></a><span id="l1.1003">     m_createdOfflineFolders = true;</span>
<a href="#l1.1004"></a><span id="l1.1004">   }</span>
<a href="#l1.1005"></a><span id="l1.1005">   // if updating one folder only, restore m_currentFolder to that folder</span>
<a href="#l1.1006"></a><span id="l1.1006" class="difflineminus">-  if (m_singleFolderToUpdate)</span>
<a href="#l1.1007"></a><span id="l1.1007" class="difflineminus">-    m_currentFolder = m_singleFolderToUpdate;</span>
<a href="#l1.1008"></a><span id="l1.1008" class="difflineplus">+  if (m_singleFolderToUpdate) m_currentFolder = m_singleFolderToUpdate;</span>
<a href="#l1.1009"></a><span id="l1.1009"> </span>
<a href="#l1.1010"></a><span id="l1.1010">   uint32_t folderFlags;</span>
<a href="#l1.1011"></a><span id="l1.1011" class="difflineminus">-  nsCOMPtr &lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l1.1012"></a><span id="l1.1012" class="difflineminus">-  while (m_currentFolder &amp;&amp; !m_currentDB)</span>
<a href="#l1.1013"></a><span id="l1.1013" class="difflineminus">-  {</span>
<a href="#l1.1014"></a><span id="l1.1014" class="difflineplus">+  nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l1.1015"></a><span id="l1.1015" class="difflineplus">+  while (m_currentFolder &amp;&amp; !m_currentDB) {</span>
<a href="#l1.1016"></a><span id="l1.1016">     m_currentFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l1.1017"></a><span id="l1.1017" class="difflineminus">-    // need to check if folder has offline events, /* or is configured for offline */</span>
<a href="#l1.1018"></a><span id="l1.1018" class="difflineminus">-    // shouldn't need to check if configured for offline use, since any folder with</span>
<a href="#l1.1019"></a><span id="l1.1019" class="difflineminus">-    // events should have nsMsgFolderFlags::OfflineEvents set.</span>
<a href="#l1.1020"></a><span id="l1.1020" class="difflineminus">-    if (folderFlags &amp; (nsMsgFolderFlags::OfflineEvents /* | nsMsgFolderFlags::Offline */))</span>
<a href="#l1.1021"></a><span id="l1.1021" class="difflineminus">-    {</span>
<a href="#l1.1022"></a><span id="l1.1022" class="difflineminus">-      m_currentFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(m_currentDB));</span>
<a href="#l1.1023"></a><span id="l1.1023" class="difflineminus">-      if (m_currentDB)</span>
<a href="#l1.1024"></a><span id="l1.1024" class="difflineminus">-        m_currentDB-&gt;AddListener(this);</span>
<a href="#l1.1025"></a><span id="l1.1025" class="difflineplus">+    // need to check if folder has offline events, /* or is configured for</span>
<a href="#l1.1026"></a><span id="l1.1026" class="difflineplus">+    // offline */ shouldn't need to check if configured for offline use, since</span>
<a href="#l1.1027"></a><span id="l1.1027" class="difflineplus">+    // any folder with events should have nsMsgFolderFlags::OfflineEvents set.</span>
<a href="#l1.1028"></a><span id="l1.1028" class="difflineplus">+    if (folderFlags &amp;</span>
<a href="#l1.1029"></a><span id="l1.1029" class="difflineplus">+        (nsMsgFolderFlags::OfflineEvents /* | nsMsgFolderFlags::Offline */)) {</span>
<a href="#l1.1030"></a><span id="l1.1030" class="difflineplus">+      m_currentFolder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo),</span>
<a href="#l1.1031"></a><span id="l1.1031" class="difflineplus">+                                            getter_AddRefs(m_currentDB));</span>
<a href="#l1.1032"></a><span id="l1.1032" class="difflineplus">+      if (m_currentDB) m_currentDB-&gt;AddListener(this);</span>
<a href="#l1.1033"></a><span id="l1.1033">     }</span>
<a href="#l1.1034"></a><span id="l1.1034"> </span>
<a href="#l1.1035"></a><span id="l1.1035" class="difflineminus">-    if (m_currentDB)</span>
<a href="#l1.1036"></a><span id="l1.1036" class="difflineminus">-    {</span>
<a href="#l1.1037"></a><span id="l1.1037" class="difflineplus">+    if (m_currentDB) {</span>
<a href="#l1.1038"></a><span id="l1.1038">       m_CurrentKeys.Clear();</span>
<a href="#l1.1039"></a><span id="l1.1039">       m_KeyIndex = 0;</span>
<a href="#l1.1040"></a><span id="l1.1040" class="difflineminus">-      if (NS_FAILED(m_currentDB-&gt;ListAllOfflineOpIds(&amp;m_CurrentKeys)) || m_CurrentKeys.IsEmpty())</span>
<a href="#l1.1041"></a><span id="l1.1041" class="difflineminus">-      {</span>
<a href="#l1.1042"></a><span id="l1.1042" class="difflineplus">+      if (NS_FAILED(m_currentDB-&gt;ListAllOfflineOpIds(&amp;m_CurrentKeys)) ||</span>
<a href="#l1.1043"></a><span id="l1.1043" class="difflineplus">+          m_CurrentKeys.IsEmpty()) {</span>
<a href="#l1.1044"></a><span id="l1.1044">         ClearDB();</span>
<a href="#l1.1045"></a><span id="l1.1045" class="difflineminus">-        folderInfo = nullptr; // can't hold onto folderInfo longer than db</span>
<a href="#l1.1046"></a><span id="l1.1046" class="difflineplus">+        folderInfo = nullptr;  // can't hold onto folderInfo longer than db</span>
<a href="#l1.1047"></a><span id="l1.1047">         m_currentFolder-&gt;ClearFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l1.1048"></a><span id="l1.1048" class="difflineminus">-      }</span>
<a href="#l1.1049"></a><span id="l1.1049" class="difflineminus">-      else</span>
<a href="#l1.1050"></a><span id="l1.1050" class="difflineminus">-      {</span>
<a href="#l1.1051"></a><span id="l1.1051" class="difflineplus">+      } else {</span>
<a href="#l1.1052"></a><span id="l1.1052">         // trash any ghost msgs</span>
<a href="#l1.1053"></a><span id="l1.1053">         bool deletedGhostMsgs = false;</span>
<a href="#l1.1054"></a><span id="l1.1054" class="difflineminus">-        for (uint32_t fakeIndex=0; fakeIndex &lt; m_CurrentKeys.Length(); fakeIndex++)</span>
<a href="#l1.1055"></a><span id="l1.1055" class="difflineminus">-        {</span>
<a href="#l1.1056"></a><span id="l1.1056" class="difflineminus">-          nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l1.1057"></a><span id="l1.1057" class="difflineminus">-          m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[fakeIndex], false, getter_AddRefs(currentOp));</span>
<a href="#l1.1058"></a><span id="l1.1058" class="difflineminus">-          if (currentOp)</span>
<a href="#l1.1059"></a><span id="l1.1059" class="difflineminus">-          {</span>
<a href="#l1.1060"></a><span id="l1.1060" class="difflineplus">+        for (uint32_t fakeIndex = 0; fakeIndex &lt; m_CurrentKeys.Length();</span>
<a href="#l1.1061"></a><span id="l1.1061" class="difflineplus">+             fakeIndex++) {</span>
<a href="#l1.1062"></a><span id="l1.1062" class="difflineplus">+          nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l1.1063"></a><span id="l1.1063" class="difflineplus">+          m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[fakeIndex], false,</span>
<a href="#l1.1064"></a><span id="l1.1064" class="difflineplus">+                                          getter_AddRefs(currentOp));</span>
<a href="#l1.1065"></a><span id="l1.1065" class="difflineplus">+          if (currentOp) {</span>
<a href="#l1.1066"></a><span id="l1.1066">             nsOfflineImapOperationType opType;</span>
<a href="#l1.1067"></a><span id="l1.1067">             currentOp-&gt;GetOperation(&amp;opType);</span>
<a href="#l1.1068"></a><span id="l1.1068"> </span>
<a href="#l1.1069"></a><span id="l1.1069" class="difflineminus">-            if (opType == nsIMsgOfflineImapOperation::kMoveResult)</span>
<a href="#l1.1070"></a><span id="l1.1070" class="difflineminus">-            {</span>
<a href="#l1.1071"></a><span id="l1.1071" class="difflineplus">+            if (opType == nsIMsgOfflineImapOperation::kMoveResult) {</span>
<a href="#l1.1072"></a><span id="l1.1072">               nsMsgKey curKey;</span>
<a href="#l1.1073"></a><span id="l1.1073">               currentOp-&gt;GetMessageKey(&amp;curKey);</span>
<a href="#l1.1074"></a><span id="l1.1074">               m_currentDB-&gt;RemoveOfflineOp(currentOp);</span>
<a href="#l1.1075"></a><span id="l1.1075">               deletedGhostMsgs = true;</span>
<a href="#l1.1076"></a><span id="l1.1076"> </span>
<a href="#l1.1077"></a><span id="l1.1077">               // Remember the pseudo headers before we delete them,</span>
<a href="#l1.1078"></a><span id="l1.1078">               // and when we download new headers, tell listeners about the</span>
<a href="#l1.1079"></a><span id="l1.1079">               // message key change between the pseudo headers and the real</span>
<a href="#l1.1080"></a><span id="l1.1080">               // downloaded headers. Note that we're not currently sending</span>
<a href="#l1.1081"></a><span id="l1.1081">               // a msgsDeleted notification for these headers, but the</span>
<a href="#l1.1082"></a><span id="l1.1082">               // db listeners are notified about the deletion.</span>
<a href="#l1.1083"></a><span id="l1.1083" class="difflineminus">-              // for imap folders, we should adjust the pending counts, because we</span>
<a href="#l1.1084"></a><span id="l1.1084" class="difflineminus">-              // have a header that we know about, but don't have in the db.</span>
<a href="#l1.1085"></a><span id="l1.1085" class="difflineminus">-              nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.1086"></a><span id="l1.1086" class="difflineminus">-              if (imapFolder)</span>
<a href="#l1.1087"></a><span id="l1.1087" class="difflineminus">-              {</span>
<a href="#l1.1088"></a><span id="l1.1088" class="difflineplus">+              // for imap folders, we should adjust the pending counts, because</span>
<a href="#l1.1089"></a><span id="l1.1089" class="difflineplus">+              // we have a header that we know about, but don't have in the db.</span>
<a href="#l1.1090"></a><span id="l1.1090" class="difflineplus">+              nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l1.1091"></a><span id="l1.1091" class="difflineplus">+                  do_QueryInterface(m_currentFolder);</span>
<a href="#l1.1092"></a><span id="l1.1092" class="difflineplus">+              if (imapFolder) {</span>
<a href="#l1.1093"></a><span id="l1.1093">                 bool hdrIsRead;</span>
<a href="#l1.1094"></a><span id="l1.1094">                 m_currentDB-&gt;IsRead(curKey, &amp;hdrIsRead);</span>
<a href="#l1.1095"></a><span id="l1.1095">                 imapFolder-&gt;ChangePendingTotal(1);</span>
<a href="#l1.1096"></a><span id="l1.1096" class="difflineminus">-                if (!hdrIsRead)</span>
<a href="#l1.1097"></a><span id="l1.1097" class="difflineminus">-                  imapFolder-&gt;ChangePendingUnread(1);</span>
<a href="#l1.1098"></a><span id="l1.1098" class="difflineplus">+                if (!hdrIsRead) imapFolder-&gt;ChangePendingUnread(1);</span>
<a href="#l1.1099"></a><span id="l1.1099">                 imapFolder-&gt;AddMoveResultPseudoKey(curKey);</span>
<a href="#l1.1100"></a><span id="l1.1100">               }</span>
<a href="#l1.1101"></a><span id="l1.1101">               m_currentDB-&gt;DeleteMessage(curKey, nullptr, false);</span>
<a href="#l1.1102"></a><span id="l1.1102">             }</span>
<a href="#l1.1103"></a><span id="l1.1103">           }</span>
<a href="#l1.1104"></a><span id="l1.1104">         }</span>
<a href="#l1.1105"></a><span id="l1.1105"> </span>
<a href="#l1.1106"></a><span id="l1.1106" class="difflineminus">-        if (deletedGhostMsgs)</span>
<a href="#l1.1107"></a><span id="l1.1107" class="difflineminus">-          m_currentFolder-&gt;SummaryChanged();</span>
<a href="#l1.1108"></a><span id="l1.1108" class="difflineplus">+        if (deletedGhostMsgs) m_currentFolder-&gt;SummaryChanged();</span>
<a href="#l1.1109"></a><span id="l1.1109"> </span>
<a href="#l1.1110"></a><span id="l1.1110">         m_CurrentKeys.Clear();</span>
<a href="#l1.1111"></a><span id="l1.1111" class="difflineminus">-        if (NS_FAILED(m_currentDB-&gt;ListAllOfflineOpIds(&amp;m_CurrentKeys)) || m_CurrentKeys.IsEmpty())</span>
<a href="#l1.1112"></a><span id="l1.1112" class="difflineminus">-        {</span>
<a href="#l1.1113"></a><span id="l1.1113" class="difflineplus">+        if (NS_FAILED(m_currentDB-&gt;ListAllOfflineOpIds(&amp;m_CurrentKeys)) ||</span>
<a href="#l1.1114"></a><span id="l1.1114" class="difflineplus">+            m_CurrentKeys.IsEmpty()) {</span>
<a href="#l1.1115"></a><span id="l1.1115">           ClearDB();</span>
<a href="#l1.1116"></a><span id="l1.1116" class="difflineminus">-        }</span>
<a href="#l1.1117"></a><span id="l1.1117" class="difflineminus">-        else if (folderFlags &amp; nsMsgFolderFlags::ImapBox)</span>
<a href="#l1.1118"></a><span id="l1.1118" class="difflineminus">-        {</span>
<a href="#l1.1119"></a><span id="l1.1119" class="difflineplus">+        } else if (folderFlags &amp; nsMsgFolderFlags::ImapBox) {</span>
<a href="#l1.1120"></a><span id="l1.1120">           // if pseudo offline, falls through to playing ops back.</span>
<a href="#l1.1121"></a><span id="l1.1121" class="difflineminus">-          if (!m_pseudoOffline)</span>
<a href="#l1.1122"></a><span id="l1.1122" class="difflineminus">-          {</span>
<a href="#l1.1123"></a><span id="l1.1123" class="difflineplus">+          if (!m_pseudoOffline) {</span>
<a href="#l1.1124"></a><span id="l1.1124">             // there are operations to playback so check uid validity</span>
<a href="#l1.1125"></a><span id="l1.1125" class="difflineminus">-            SetCurrentUIDValidity(0); // force initial invalid state</span>
<a href="#l1.1126"></a><span id="l1.1126" class="difflineplus">+            SetCurrentUIDValidity(0);  // force initial invalid state</span>
<a href="#l1.1127"></a><span id="l1.1127">             // do a lite select here and hook ourselves up as a listener.</span>
<a href="#l1.1128"></a><span id="l1.1128" class="difflineminus">-            nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(m_currentFolder, &amp;rv);</span>
<a href="#l1.1129"></a><span id="l1.1129" class="difflineminus">-            if (imapFolder)</span>
<a href="#l1.1130"></a><span id="l1.1130" class="difflineminus">-              rv = imapFolder-&gt;LiteSelect(this, m_window);</span>
<a href="#l1.1131"></a><span id="l1.1131" class="difflineplus">+            nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder =</span>
<a href="#l1.1132"></a><span id="l1.1132" class="difflineplus">+                do_QueryInterface(m_currentFolder, &amp;rv);</span>
<a href="#l1.1133"></a><span id="l1.1133" class="difflineplus">+            if (imapFolder) rv = imapFolder-&gt;LiteSelect(this, m_window);</span>
<a href="#l1.1134"></a><span id="l1.1134">             // this is async, we will be called again by OnStopRunningUrl.</span>
<a href="#l1.1135"></a><span id="l1.1135">             return rv;</span>
<a href="#l1.1136"></a><span id="l1.1136">           }</span>
<a href="#l1.1137"></a><span id="l1.1137">         }</span>
<a href="#l1.1138"></a><span id="l1.1138">       }</span>
<a href="#l1.1139"></a><span id="l1.1139">     }</span>
<a href="#l1.1140"></a><span id="l1.1140"> </span>
<a href="#l1.1141"></a><span id="l1.1141" class="difflineminus">-    if (!m_currentDB)</span>
<a href="#l1.1142"></a><span id="l1.1142" class="difflineminus">-    {</span>
<a href="#l1.1143"></a><span id="l1.1143" class="difflineplus">+    if (!m_currentDB) {</span>
<a href="#l1.1144"></a><span id="l1.1144">       // only advance if we are doing all folders</span>
<a href="#l1.1145"></a><span id="l1.1145">       if (!m_singleFolderToUpdate)</span>
<a href="#l1.1146"></a><span id="l1.1146">         AdvanceToNextFolder();</span>
<a href="#l1.1147"></a><span id="l1.1147">       else</span>
<a href="#l1.1148"></a><span id="l1.1148">         m_currentFolder = nullptr;  // force update of this folder now.</span>
<a href="#l1.1149"></a><span id="l1.1149">     }</span>
<a href="#l1.1150"></a><span id="l1.1150" class="difflineminus">-</span>
<a href="#l1.1151"></a><span id="l1.1151">   }</span>
<a href="#l1.1152"></a><span id="l1.1152"> </span>
<a href="#l1.1153"></a><span id="l1.1153" class="difflineminus">-  if (m_currentFolder)</span>
<a href="#l1.1154"></a><span id="l1.1154" class="difflineminus">-    m_currentFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l1.1155"></a><span id="l1.1155" class="difflineplus">+  if (m_currentFolder) m_currentFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l1.1156"></a><span id="l1.1156">   // do the current operation</span>
<a href="#l1.1157"></a><span id="l1.1157" class="difflineminus">-  if (m_currentDB)</span>
<a href="#l1.1158"></a><span id="l1.1158" class="difflineminus">-  {</span>
<a href="#l1.1159"></a><span id="l1.1159" class="difflineplus">+  if (m_currentDB) {</span>
<a href="#l1.1160"></a><span id="l1.1160">     bool currentFolderFinished = false;</span>
<a href="#l1.1161"></a><span id="l1.1161" class="difflineminus">-    if (!folderInfo)</span>
<a href="#l1.1162"></a><span id="l1.1162" class="difflineminus">-      m_currentDB-&gt;GetDBFolderInfo(getter_AddRefs(folderInfo));</span>
<a href="#l1.1163"></a><span id="l1.1163" class="difflineplus">+    if (!folderInfo) m_currentDB-&gt;GetDBFolderInfo(getter_AddRefs(folderInfo));</span>
<a href="#l1.1164"></a><span id="l1.1164">     // user canceled the lite select! if GetCurrentUIDValidity() == 0</span>
<a href="#l1.1165"></a><span id="l1.1165">     if (folderInfo &amp;&amp; (m_KeyIndex &lt; m_CurrentKeys.Length()) &amp;&amp;</span>
<a href="#l1.1166"></a><span id="l1.1166">         (m_pseudoOffline || (GetCurrentUIDValidity() != 0) ||</span>
<a href="#l1.1167"></a><span id="l1.1167" class="difflineminus">-        !(folderFlags &amp; nsMsgFolderFlags::ImapBox)))</span>
<a href="#l1.1168"></a><span id="l1.1168" class="difflineminus">-    {</span>
<a href="#l1.1169"></a><span id="l1.1169" class="difflineplus">+         !(folderFlags &amp; nsMsgFolderFlags::ImapBox))) {</span>
<a href="#l1.1170"></a><span id="l1.1170">       int32_t curFolderUidValidity;</span>
<a href="#l1.1171"></a><span id="l1.1171">       folderInfo-&gt;GetImapUidValidity(&amp;curFolderUidValidity);</span>
<a href="#l1.1172"></a><span id="l1.1172" class="difflineminus">-      bool uidvalidityChanged = (!m_pseudoOffline &amp;&amp; folderFlags &amp; nsMsgFolderFlags::ImapBox) &amp;&amp; (GetCurrentUIDValidity() != curFolderUidValidity);</span>
<a href="#l1.1173"></a><span id="l1.1173" class="difflineminus">-      nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l1.1174"></a><span id="l1.1174" class="difflineplus">+      bool uidvalidityChanged =</span>
<a href="#l1.1175"></a><span id="l1.1175" class="difflineplus">+          (!m_pseudoOffline &amp;&amp; folderFlags &amp; nsMsgFolderFlags::ImapBox) &amp;&amp;</span>
<a href="#l1.1176"></a><span id="l1.1176" class="difflineplus">+          (GetCurrentUIDValidity() != curFolderUidValidity);</span>
<a href="#l1.1177"></a><span id="l1.1177" class="difflineplus">+      nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l1.1178"></a><span id="l1.1178">       if (uidvalidityChanged)</span>
<a href="#l1.1179"></a><span id="l1.1179">         DeleteAllOfflineOpsForCurrentDB();</span>
<a href="#l1.1180"></a><span id="l1.1180">       else</span>
<a href="#l1.1181"></a><span id="l1.1181" class="difflineminus">-        m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex], false, getter_AddRefs(currentOp));</span>
<a href="#l1.1182"></a><span id="l1.1182" class="difflineplus">+        m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex], false,</span>
<a href="#l1.1183"></a><span id="l1.1183" class="difflineplus">+                                        getter_AddRefs(currentOp));</span>
<a href="#l1.1184"></a><span id="l1.1184"> </span>
<a href="#l1.1185"></a><span id="l1.1185" class="difflineminus">-      if (currentOp)</span>
<a href="#l1.1186"></a><span id="l1.1186" class="difflineminus">-      {</span>
<a href="#l1.1187"></a><span id="l1.1187" class="difflineplus">+      if (currentOp) {</span>
<a href="#l1.1188"></a><span id="l1.1188">         nsOfflineImapOperationType opType;</span>
<a href="#l1.1189"></a><span id="l1.1189">         currentOp-&gt;GetOperation(&amp;opType);</span>
<a href="#l1.1190"></a><span id="l1.1190" class="difflineminus">-        // loop until we find the next db record that matches the current playback operation</span>
<a href="#l1.1191"></a><span id="l1.1191" class="difflineminus">-        while (currentOp &amp;&amp; !(opType &amp; mCurrentPlaybackOpType))</span>
<a href="#l1.1192"></a><span id="l1.1192" class="difflineminus">-        {</span>
<a href="#l1.1193"></a><span id="l1.1193" class="difflineplus">+        // loop until we find the next db record that matches the current</span>
<a href="#l1.1194"></a><span id="l1.1194" class="difflineplus">+        // playback operation</span>
<a href="#l1.1195"></a><span id="l1.1195" class="difflineplus">+        while (currentOp &amp;&amp; !(opType &amp; mCurrentPlaybackOpType)) {</span>
<a href="#l1.1196"></a><span id="l1.1196">           // remove operations with no type.</span>
<a href="#l1.1197"></a><span id="l1.1197" class="difflineminus">-          if (!opType)</span>
<a href="#l1.1198"></a><span id="l1.1198" class="difflineminus">-            m_currentDB-&gt;RemoveOfflineOp(currentOp);</span>
<a href="#l1.1199"></a><span id="l1.1199" class="difflineplus">+          if (!opType) m_currentDB-&gt;RemoveOfflineOp(currentOp);</span>
<a href="#l1.1200"></a><span id="l1.1200">           currentOp = nullptr;</span>
<a href="#l1.1201"></a><span id="l1.1201">           ++m_KeyIndex;</span>
<a href="#l1.1202"></a><span id="l1.1202">           if (m_KeyIndex &lt; m_CurrentKeys.Length())</span>
<a href="#l1.1203"></a><span id="l1.1203" class="difflineminus">-            m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex],</span>
<a href="#l1.1204"></a><span id="l1.1204" class="difflineminus">-                                            false, getter_AddRefs(currentOp));</span>
<a href="#l1.1205"></a><span id="l1.1205" class="difflineminus">-          if (currentOp)</span>
<a href="#l1.1206"></a><span id="l1.1206" class="difflineminus">-            currentOp-&gt;GetOperation(&amp;opType);</span>
<a href="#l1.1207"></a><span id="l1.1207" class="difflineplus">+            m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex], false,</span>
<a href="#l1.1208"></a><span id="l1.1208" class="difflineplus">+                                            getter_AddRefs(currentOp));</span>
<a href="#l1.1209"></a><span id="l1.1209" class="difflineplus">+          if (currentOp) currentOp-&gt;GetOperation(&amp;opType);</span>
<a href="#l1.1210"></a><span id="l1.1210">         }</span>
<a href="#l1.1211"></a><span id="l1.1211" class="difflineminus">-        // if we did not find a db record that matches the current playback operation,</span>
<a href="#l1.1212"></a><span id="l1.1212" class="difflineminus">-        // then move to the next playback operation and recurse.</span>
<a href="#l1.1213"></a><span id="l1.1213" class="difflineminus">-        if (!currentOp)</span>
<a href="#l1.1214"></a><span id="l1.1214" class="difflineminus">-        {</span>
<a href="#l1.1215"></a><span id="l1.1215" class="difflineplus">+        // if we did not find a db record that matches the current playback</span>
<a href="#l1.1216"></a><span id="l1.1216" class="difflineplus">+        // operation, then move to the next playback operation and recurse.</span>
<a href="#l1.1217"></a><span id="l1.1217" class="difflineplus">+        if (!currentOp) {</span>
<a href="#l1.1218"></a><span id="l1.1218">           // we are done with the current type</span>
<a href="#l1.1219"></a><span id="l1.1219" class="difflineminus">-          if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kFlagsChanged)</span>
<a href="#l1.1220"></a><span id="l1.1220" class="difflineminus">-          {</span>
<a href="#l1.1221"></a><span id="l1.1221" class="difflineplus">+          if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1222"></a><span id="l1.1222" class="difflineplus">+              nsIMsgOfflineImapOperation::kFlagsChanged) {</span>
<a href="#l1.1223"></a><span id="l1.1223">             mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kAddKeywords;</span>
<a href="#l1.1224"></a><span id="l1.1224">             // recurse to deal with next type of operation</span>
<a href="#l1.1225"></a><span id="l1.1225">             m_KeyIndex = 0;</span>
<a href="#l1.1226"></a><span id="l1.1226">             ProcessNextOperation();</span>
<a href="#l1.1227"></a><span id="l1.1227" class="difflineminus">-          }</span>
<a href="#l1.1228"></a><span id="l1.1228" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAddKeywords)</span>
<a href="#l1.1229"></a><span id="l1.1229" class="difflineminus">-          {</span>
<a href="#l1.1230"></a><span id="l1.1230" class="difflineminus">-            mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kRemoveKeywords;</span>
<a href="#l1.1231"></a><span id="l1.1231" class="difflineplus">+          } else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1232"></a><span id="l1.1232" class="difflineplus">+                     nsIMsgOfflineImapOperation::kAddKeywords) {</span>
<a href="#l1.1233"></a><span id="l1.1233" class="difflineplus">+            mCurrentPlaybackOpType =</span>
<a href="#l1.1234"></a><span id="l1.1234" class="difflineplus">+                nsIMsgOfflineImapOperation::kRemoveKeywords;</span>
<a href="#l1.1235"></a><span id="l1.1235">             // recurse to deal with next type of operation</span>
<a href="#l1.1236"></a><span id="l1.1236">             m_KeyIndex = 0;</span>
<a href="#l1.1237"></a><span id="l1.1237">             ProcessNextOperation();</span>
<a href="#l1.1238"></a><span id="l1.1238" class="difflineminus">-          }</span>
<a href="#l1.1239"></a><span id="l1.1239" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kRemoveKeywords)</span>
<a href="#l1.1240"></a><span id="l1.1240" class="difflineminus">-          {</span>
<a href="#l1.1241"></a><span id="l1.1241" class="difflineplus">+          } else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1242"></a><span id="l1.1242" class="difflineplus">+                     nsIMsgOfflineImapOperation::kRemoveKeywords) {</span>
<a href="#l1.1243"></a><span id="l1.1243">             mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kMsgCopy;</span>
<a href="#l1.1244"></a><span id="l1.1244">             // recurse to deal with next type of operation</span>
<a href="#l1.1245"></a><span id="l1.1245">             m_KeyIndex = 0;</span>
<a href="#l1.1246"></a><span id="l1.1246">             ProcessNextOperation();</span>
<a href="#l1.1247"></a><span id="l1.1247" class="difflineminus">-          }</span>
<a href="#l1.1248"></a><span id="l1.1248" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgCopy)</span>
<a href="#l1.1249"></a><span id="l1.1249" class="difflineminus">-          {</span>
<a href="#l1.1250"></a><span id="l1.1250" class="difflineplus">+          } else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1251"></a><span id="l1.1251" class="difflineplus">+                     nsIMsgOfflineImapOperation::kMsgCopy) {</span>
<a href="#l1.1252"></a><span id="l1.1252">             mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kMsgMoved;</span>
<a href="#l1.1253"></a><span id="l1.1253">             // recurse to deal with next type of operation</span>
<a href="#l1.1254"></a><span id="l1.1254">             m_KeyIndex = 0;</span>
<a href="#l1.1255"></a><span id="l1.1255">             ProcessNextOperation();</span>
<a href="#l1.1256"></a><span id="l1.1256" class="difflineminus">-          }</span>
<a href="#l1.1257"></a><span id="l1.1257" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgMoved)</span>
<a href="#l1.1258"></a><span id="l1.1258" class="difflineminus">-          {</span>
<a href="#l1.1259"></a><span id="l1.1259" class="difflineplus">+          } else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1260"></a><span id="l1.1260" class="difflineplus">+                     nsIMsgOfflineImapOperation::kMsgMoved) {</span>
<a href="#l1.1261"></a><span id="l1.1261">             mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kAppendDraft;</span>
<a href="#l1.1262"></a><span id="l1.1262">             // recurse to deal with next type of operation</span>
<a href="#l1.1263"></a><span id="l1.1263">             m_KeyIndex = 0;</span>
<a href="#l1.1264"></a><span id="l1.1264">             ProcessNextOperation();</span>
<a href="#l1.1265"></a><span id="l1.1265" class="difflineminus">-          }</span>
<a href="#l1.1266"></a><span id="l1.1266" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAppendDraft)</span>
<a href="#l1.1267"></a><span id="l1.1267" class="difflineminus">-          {</span>
<a href="#l1.1268"></a><span id="l1.1268" class="difflineminus">-            mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kAppendTemplate;</span>
<a href="#l1.1269"></a><span id="l1.1269" class="difflineplus">+          } else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1270"></a><span id="l1.1270" class="difflineplus">+                     nsIMsgOfflineImapOperation::kAppendDraft) {</span>
<a href="#l1.1271"></a><span id="l1.1271" class="difflineplus">+            mCurrentPlaybackOpType =</span>
<a href="#l1.1272"></a><span id="l1.1272" class="difflineplus">+                nsIMsgOfflineImapOperation::kAppendTemplate;</span>
<a href="#l1.1273"></a><span id="l1.1273">             // recurse to deal with next type of operation</span>
<a href="#l1.1274"></a><span id="l1.1274">             m_KeyIndex = 0;</span>
<a href="#l1.1275"></a><span id="l1.1275">             ProcessNextOperation();</span>
<a href="#l1.1276"></a><span id="l1.1276" class="difflineminus">-          }</span>
<a href="#l1.1277"></a><span id="l1.1277" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAppendTemplate)</span>
<a href="#l1.1278"></a><span id="l1.1278" class="difflineminus">-          {</span>
<a href="#l1.1279"></a><span id="l1.1279" class="difflineplus">+          } else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1280"></a><span id="l1.1280" class="difflineplus">+                     nsIMsgOfflineImapOperation::kAppendTemplate) {</span>
<a href="#l1.1281"></a><span id="l1.1281">             mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kDeleteAllMsgs;</span>
<a href="#l1.1282"></a><span id="l1.1282">             m_KeyIndex = 0;</span>
<a href="#l1.1283"></a><span id="l1.1283">             ProcessNextOperation();</span>
<a href="#l1.1284"></a><span id="l1.1284" class="difflineminus">-          }</span>
<a href="#l1.1285"></a><span id="l1.1285" class="difflineminus">-          else</span>
<a href="#l1.1286"></a><span id="l1.1286" class="difflineminus">-          {</span>
<a href="#l1.1287"></a><span id="l1.1287" class="difflineplus">+          } else {</span>
<a href="#l1.1288"></a><span id="l1.1288">             DeleteAllOfflineOpsForCurrentDB();</span>
<a href="#l1.1289"></a><span id="l1.1289">             currentFolderFinished = true;</span>
<a href="#l1.1290"></a><span id="l1.1290">           }</span>
<a href="#l1.1291"></a><span id="l1.1291"> </span>
<a href="#l1.1292"></a><span id="l1.1292" class="difflineminus">-        }</span>
<a href="#l1.1293"></a><span id="l1.1293" class="difflineminus">-        else</span>
<a href="#l1.1294"></a><span id="l1.1294" class="difflineminus">-        {</span>
<a href="#l1.1295"></a><span id="l1.1295" class="difflineminus">-          if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kFlagsChanged)</span>
<a href="#l1.1296"></a><span id="l1.1296" class="difflineplus">+        } else {</span>
<a href="#l1.1297"></a><span id="l1.1297" class="difflineplus">+          if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1298"></a><span id="l1.1298" class="difflineplus">+              nsIMsgOfflineImapOperation::kFlagsChanged)</span>
<a href="#l1.1299"></a><span id="l1.1299">             ProcessFlagOperation(currentOp);</span>
<a href="#l1.1300"></a><span id="l1.1300" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAddKeywords</span>
<a href="#l1.1301"></a><span id="l1.1301" class="difflineminus">-            ||mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kRemoveKeywords)</span>
<a href="#l1.1302"></a><span id="l1.1302" class="difflineplus">+          else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1303"></a><span id="l1.1303" class="difflineplus">+                       nsIMsgOfflineImapOperation::kAddKeywords ||</span>
<a href="#l1.1304"></a><span id="l1.1304" class="difflineplus">+                   mCurrentPlaybackOpType ==</span>
<a href="#l1.1305"></a><span id="l1.1305" class="difflineplus">+                       nsIMsgOfflineImapOperation::kRemoveKeywords)</span>
<a href="#l1.1306"></a><span id="l1.1306">             ProcessKeywordOperation(currentOp);</span>
<a href="#l1.1307"></a><span id="l1.1307" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgCopy)</span>
<a href="#l1.1308"></a><span id="l1.1308" class="difflineplus">+          else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1309"></a><span id="l1.1309" class="difflineplus">+                   nsIMsgOfflineImapOperation::kMsgCopy)</span>
<a href="#l1.1310"></a><span id="l1.1310">             ProcessCopyOperation(currentOp);</span>
<a href="#l1.1311"></a><span id="l1.1311" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kMsgMoved)</span>
<a href="#l1.1312"></a><span id="l1.1312" class="difflineplus">+          else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1313"></a><span id="l1.1313" class="difflineplus">+                   nsIMsgOfflineImapOperation::kMsgMoved)</span>
<a href="#l1.1314"></a><span id="l1.1314">             ProcessMoveOperation(currentOp);</span>
<a href="#l1.1315"></a><span id="l1.1315" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAppendDraft)</span>
<a href="#l1.1316"></a><span id="l1.1316" class="difflineminus">-            ProcessAppendMsgOperation(currentOp, nsIMsgOfflineImapOperation::kAppendDraft);</span>
<a href="#l1.1317"></a><span id="l1.1317" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kAppendTemplate)</span>
<a href="#l1.1318"></a><span id="l1.1318" class="difflineminus">-            ProcessAppendMsgOperation(currentOp, nsIMsgOfflineImapOperation::kAppendTemplate);</span>
<a href="#l1.1319"></a><span id="l1.1319" class="difflineminus">-          else if (mCurrentPlaybackOpType == nsIMsgOfflineImapOperation::kDeleteAllMsgs)</span>
<a href="#l1.1320"></a><span id="l1.1320" class="difflineminus">-          {</span>
<a href="#l1.1321"></a><span id="l1.1321" class="difflineplus">+          else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1322"></a><span id="l1.1322" class="difflineplus">+                   nsIMsgOfflineImapOperation::kAppendDraft)</span>
<a href="#l1.1323"></a><span id="l1.1323" class="difflineplus">+            ProcessAppendMsgOperation(currentOp,</span>
<a href="#l1.1324"></a><span id="l1.1324" class="difflineplus">+                                      nsIMsgOfflineImapOperation::kAppendDraft);</span>
<a href="#l1.1325"></a><span id="l1.1325" class="difflineplus">+          else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1326"></a><span id="l1.1326" class="difflineplus">+                   nsIMsgOfflineImapOperation::kAppendTemplate)</span>
<a href="#l1.1327"></a><span id="l1.1327" class="difflineplus">+            ProcessAppendMsgOperation(</span>
<a href="#l1.1328"></a><span id="l1.1328" class="difflineplus">+                currentOp, nsIMsgOfflineImapOperation::kAppendTemplate);</span>
<a href="#l1.1329"></a><span id="l1.1329" class="difflineplus">+          else if (mCurrentPlaybackOpType ==</span>
<a href="#l1.1330"></a><span id="l1.1330" class="difflineplus">+                   nsIMsgOfflineImapOperation::kDeleteAllMsgs) {</span>
<a href="#l1.1331"></a><span id="l1.1331">             // empty trash is going to delete the db, so we'd better release the</span>
<a href="#l1.1332"></a><span id="l1.1332">             // reference to the offline operation first.</span>
<a href="#l1.1333"></a><span id="l1.1333">             currentOp = nullptr;</span>
<a href="#l1.1334"></a><span id="l1.1334">             ProcessEmptyTrash();</span>
<a href="#l1.1335"></a><span id="l1.1335" class="difflineminus">-          }</span>
<a href="#l1.1336"></a><span id="l1.1336" class="difflineminus">-          else</span>
<a href="#l1.1337"></a><span id="l1.1337" class="difflineplus">+          } else</span>
<a href="#l1.1338"></a><span id="l1.1338">             NS_WARNING(&quot;invalid playback op type&quot;);</span>
<a href="#l1.1339"></a><span id="l1.1339">         }</span>
<a href="#l1.1340"></a><span id="l1.1340" class="difflineminus">-      }</span>
<a href="#l1.1341"></a><span id="l1.1341" class="difflineminus">-      else</span>
<a href="#l1.1342"></a><span id="l1.1342" class="difflineplus">+      } else</span>
<a href="#l1.1343"></a><span id="l1.1343">         currentFolderFinished = true;</span>
<a href="#l1.1344"></a><span id="l1.1344" class="difflineminus">-    }</span>
<a href="#l1.1345"></a><span id="l1.1345" class="difflineminus">-    else</span>
<a href="#l1.1346"></a><span id="l1.1346" class="difflineplus">+    } else</span>
<a href="#l1.1347"></a><span id="l1.1347">       currentFolderFinished = true;</span>
<a href="#l1.1348"></a><span id="l1.1348"> </span>
<a href="#l1.1349"></a><span id="l1.1349" class="difflineminus">-    if (currentFolderFinished)</span>
<a href="#l1.1350"></a><span id="l1.1350" class="difflineminus">-    {</span>
<a href="#l1.1351"></a><span id="l1.1351" class="difflineplus">+    if (currentFolderFinished) {</span>
<a href="#l1.1352"></a><span id="l1.1352">       ClearDB();</span>
<a href="#l1.1353"></a><span id="l1.1353" class="difflineminus">-      if (!m_singleFolderToUpdate)</span>
<a href="#l1.1354"></a><span id="l1.1354" class="difflineminus">-      {</span>
<a href="#l1.1355"></a><span id="l1.1355" class="difflineplus">+      if (!m_singleFolderToUpdate) {</span>
<a href="#l1.1356"></a><span id="l1.1356">         AdvanceToNextFolder();</span>
<a href="#l1.1357"></a><span id="l1.1357">         ProcessNextOperation();</span>
<a href="#l1.1358"></a><span id="l1.1358">         return NS_OK;</span>
<a href="#l1.1359"></a><span id="l1.1359">       }</span>
<a href="#l1.1360"></a><span id="l1.1360">       m_currentFolder = nullptr;</span>
<a href="#l1.1361"></a><span id="l1.1361">     }</span>
<a href="#l1.1362"></a><span id="l1.1362">   }</span>
<a href="#l1.1363"></a><span id="l1.1363"> </span>
<a href="#l1.1364"></a><span id="l1.1364" class="difflineminus">-  if (!m_currentFolder &amp;&amp; !m_mailboxupdatesStarted)</span>
<a href="#l1.1365"></a><span id="l1.1365" class="difflineminus">-  {</span>
<a href="#l1.1366"></a><span id="l1.1366" class="difflineplus">+  if (!m_currentFolder &amp;&amp; !m_mailboxupdatesStarted) {</span>
<a href="#l1.1367"></a><span id="l1.1367">     m_mailboxupdatesStarted = true;</span>
<a href="#l1.1368"></a><span id="l1.1368"> </span>
<a href="#l1.1369"></a><span id="l1.1369">     // if we are updating more than one folder then we need the iterator</span>
<a href="#l1.1370"></a><span id="l1.1370" class="difflineminus">-    if (!m_singleFolderToUpdate)</span>
<a href="#l1.1371"></a><span id="l1.1371" class="difflineminus">-    {</span>
<a href="#l1.1372"></a><span id="l1.1372" class="difflineplus">+    if (!m_singleFolderToUpdate) {</span>
<a href="#l1.1373"></a><span id="l1.1373">       m_currentServer = nullptr;</span>
<a href="#l1.1374"></a><span id="l1.1374">       AdvanceToNextFolder();</span>
<a href="#l1.1375"></a><span id="l1.1375">     }</span>
<a href="#l1.1376"></a><span id="l1.1376" class="difflineminus">-    if (m_singleFolderToUpdate)</span>
<a href="#l1.1377"></a><span id="l1.1377" class="difflineminus">-    {</span>
<a href="#l1.1378"></a><span id="l1.1378" class="difflineplus">+    if (m_singleFolderToUpdate) {</span>
<a href="#l1.1379"></a><span id="l1.1379">       m_singleFolderToUpdate-&gt;ClearFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l1.1380"></a><span id="l1.1380">       m_singleFolderToUpdate-&gt;UpdateFolder(m_window);</span>
<a href="#l1.1381"></a><span id="l1.1381">     }</span>
<a href="#l1.1382"></a><span id="l1.1382">   }</span>
<a href="#l1.1383"></a><span id="l1.1383">   // if we get here, then I *think* we're done. Not sure, though.</span>
<a href="#l1.1384"></a><span id="l1.1384"> #ifdef DEBUG_bienvenu</span>
<a href="#l1.1385"></a><span id="l1.1385">   printf(&quot;done with offline imap sync\n&quot;);</span>
<a href="#l1.1386"></a><span id="l1.1386"> #endif</span>
<a href="#l1.1387"></a><span id="l1.1387" class="difflineminus">-  nsCOMPtr &lt;nsIUrlListener&gt; saveListener = m_listener;</span>
<a href="#l1.1388"></a><span id="l1.1388" class="difflineplus">+  nsCOMPtr&lt;nsIUrlListener&gt; saveListener = m_listener;</span>
<a href="#l1.1389"></a><span id="l1.1389">   m_listener = nullptr;</span>
<a href="#l1.1390"></a><span id="l1.1390"> </span>
<a href="#l1.1391"></a><span id="l1.1391">   if (saveListener)</span>
<a href="#l1.1392"></a><span id="l1.1392">     saveListener-&gt;OnStopRunningUrl(nullptr /* don't know url */, rv);</span>
<a href="#l1.1393"></a><span id="l1.1393">   return rv;</span>
<a href="#l1.1394"></a><span id="l1.1394"> }</span>
<a href="#l1.1395"></a><span id="l1.1395"> </span>
<a href="#l1.1396"></a><span id="l1.1396" class="difflineminus">-</span>
<a href="#l1.1397"></a><span id="l1.1397" class="difflineminus">-void nsImapOfflineSync::DeleteAllOfflineOpsForCurrentDB()</span>
<a href="#l1.1398"></a><span id="l1.1398" class="difflineminus">-{</span>
<a href="#l1.1399"></a><span id="l1.1399" class="difflineplus">+void nsImapOfflineSync::DeleteAllOfflineOpsForCurrentDB() {</span>
<a href="#l1.1400"></a><span id="l1.1400">   m_KeyIndex = 0;</span>
<a href="#l1.1401"></a><span id="l1.1401" class="difflineminus">-  nsCOMPtr &lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l1.1402"></a><span id="l1.1402" class="difflineminus">-  m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex], false, getter_AddRefs(currentOp));</span>
<a href="#l1.1403"></a><span id="l1.1403" class="difflineminus">-  while (currentOp)</span>
<a href="#l1.1404"></a><span id="l1.1404" class="difflineminus">-  {</span>
<a href="#l1.1405"></a><span id="l1.1405" class="difflineplus">+  nsCOMPtr&lt;nsIMsgOfflineImapOperation&gt; currentOp;</span>
<a href="#l1.1406"></a><span id="l1.1406" class="difflineplus">+  m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex], false,</span>
<a href="#l1.1407"></a><span id="l1.1407" class="difflineplus">+                                  getter_AddRefs(currentOp));</span>
<a href="#l1.1408"></a><span id="l1.1408" class="difflineplus">+  while (currentOp) {</span>
<a href="#l1.1409"></a><span id="l1.1409">     // NS_ASSERTION(currentOp-&gt;GetOperationFlags() == 0);</span>
<a href="#l1.1410"></a><span id="l1.1410">     // delete any ops that have already played back</span>
<a href="#l1.1411"></a><span id="l1.1411">     m_currentDB-&gt;RemoveOfflineOp(currentOp);</span>
<a href="#l1.1412"></a><span id="l1.1412">     currentOp = nullptr;</span>
<a href="#l1.1413"></a><span id="l1.1413"> </span>
<a href="#l1.1414"></a><span id="l1.1414">     if (++m_KeyIndex &lt; m_CurrentKeys.Length())</span>
<a href="#l1.1415"></a><span id="l1.1415" class="difflineminus">-      m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex], false, getter_AddRefs(currentOp));</span>
<a href="#l1.1416"></a><span id="l1.1416" class="difflineplus">+      m_currentDB-&gt;GetOfflineOpForKey(m_CurrentKeys[m_KeyIndex], false,</span>
<a href="#l1.1417"></a><span id="l1.1417" class="difflineplus">+                                      getter_AddRefs(currentOp));</span>
<a href="#l1.1418"></a><span id="l1.1418">   }</span>
<a href="#l1.1419"></a><span id="l1.1419">   m_currentDB-&gt;Commit(nsMsgDBCommitType::kLargeCommit);</span>
<a href="#l1.1420"></a><span id="l1.1420">   // turn off nsMsgFolderFlags::OfflineEvents</span>
<a href="#l1.1421"></a><span id="l1.1421">   if (m_currentFolder)</span>
<a href="#l1.1422"></a><span id="l1.1422">     m_currentFolder-&gt;ClearFlag(nsMsgFolderFlags::OfflineEvents);</span>
<a href="#l1.1423"></a><span id="l1.1423"> }</span>
<a href="#l1.1424"></a><span id="l1.1424"> </span>
<a href="#l1.1425"></a><span id="l1.1425" class="difflineminus">-nsImapOfflineDownloader::nsImapOfflineDownloader(nsIMsgWindow *aMsgWindow, nsIUrlListener *aListener) : nsImapOfflineSync(aMsgWindow, aListener)</span>
<a href="#l1.1426"></a><span id="l1.1426" class="difflineminus">-{</span>
<a href="#l1.1427"></a><span id="l1.1427" class="difflineplus">+nsImapOfflineDownloader::nsImapOfflineDownloader(nsIMsgWindow *aMsgWindow,</span>
<a href="#l1.1428"></a><span id="l1.1428" class="difflineplus">+                                                 nsIUrlListener *aListener)</span>
<a href="#l1.1429"></a><span id="l1.1429" class="difflineplus">+    : nsImapOfflineSync(aMsgWindow, aListener) {</span>
<a href="#l1.1430"></a><span id="l1.1430">   // pause auto-sync service</span>
<a href="#l1.1431"></a><span id="l1.1431">   nsresult rv;</span>
<a href="#l1.1432"></a><span id="l1.1432" class="difflineminus">-  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr = do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l1.1433"></a><span id="l1.1433" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l1.1434"></a><span id="l1.1434" class="difflineminus">-    autoSyncMgr-&gt;Pause();</span>
<a href="#l1.1435"></a><span id="l1.1435" class="difflineplus">+  nsCOMPtr&lt;nsIAutoSyncManager&gt; autoSyncMgr =</span>
<a href="#l1.1436"></a><span id="l1.1436" class="difflineplus">+      do_GetService(NS_AUTOSYNCMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l1.1437"></a><span id="l1.1437" class="difflineplus">+  if (NS_SUCCEEDED(rv)) autoSyncMgr-&gt;Pause();</span>
<a href="#l1.1438"></a><span id="l1.1438"> }</span>
<a href="#l1.1439"></a><span id="l1.1439"> </span>
<a href="#l1.1440"></a><span id="l1.1440" class="difflineminus">-nsImapOfflineDownloader::~nsImapOfflineDownloader()</span>
<a href="#l1.1441"></a><span id="l1.1441" class="difflineminus">-{</span>
<a href="#l1.1442"></a><span id="l1.1442" class="difflineminus">-}</span>
<a href="#l1.1443"></a><span id="l1.1443" class="difflineplus">+nsImapOfflineDownloader::~nsImapOfflineDownloader() {}</span>
<a href="#l1.1444"></a><span id="l1.1444"> </span>
<a href="#l1.1445"></a><span id="l1.1445" class="difflineminus">-nsresult nsImapOfflineDownloader::ProcessNextOperation()</span>
<a href="#l1.1446"></a><span id="l1.1446" class="difflineminus">-{</span>
<a href="#l1.1447"></a><span id="l1.1447" class="difflineplus">+nsresult nsImapOfflineDownloader::ProcessNextOperation() {</span>
<a href="#l1.1448"></a><span id="l1.1448">   nsresult rv = NS_OK;</span>
<a href="#l1.1449"></a><span id="l1.1449" class="difflineminus">-  if (!m_mailboxupdatesStarted)</span>
<a href="#l1.1450"></a><span id="l1.1450" class="difflineminus">-  {</span>
<a href="#l1.1451"></a><span id="l1.1451" class="difflineplus">+  if (!m_mailboxupdatesStarted) {</span>
<a href="#l1.1452"></a><span id="l1.1452">     m_mailboxupdatesStarted = true;</span>
<a href="#l1.1453"></a><span id="l1.1453">     // Update the INBOX first so the updates on the remaining</span>
<a href="#l1.1454"></a><span id="l1.1454">     // folders pickup the results of any filter moves.</span>
<a href="#l1.1455"></a><span id="l1.1455">     nsCOMPtr&lt;nsIMsgAccountManager&gt; accountManager =</span>
<a href="#l1.1456"></a><span id="l1.1456" class="difflineminus">-             do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l1.1457"></a><span id="l1.1457" class="difflineplus">+        do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l1.1458"></a><span id="l1.1458">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l1.1459"></a><span id="l1.1459"> </span>
<a href="#l1.1460"></a><span id="l1.1460">     nsCOMPtr&lt;nsIArray&gt; servers;</span>
<a href="#l1.1461"></a><span id="l1.1461">     rv = accountManager-&gt;GetAllServers(getter_AddRefs(servers));</span>
<a href="#l1.1462"></a><span id="l1.1462">     if (NS_FAILED(rv)) return rv;</span>
<a href="#l1.1463"></a><span id="l1.1463">   }</span>
<a href="#l1.1464"></a><span id="l1.1464" class="difflineminus">-  if (!m_mailboxupdatesFinished)</span>
<a href="#l1.1465"></a><span id="l1.1465" class="difflineminus">-  {</span>
<a href="#l1.1466"></a><span id="l1.1466" class="difflineminus">-    if (AdvanceToNextServer())</span>
<a href="#l1.1467"></a><span id="l1.1467" class="difflineminus">-    {</span>
<a href="#l1.1468"></a><span id="l1.1468" class="difflineminus">-      nsCOMPtr &lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l1.1469"></a><span id="l1.1469" class="difflineplus">+  if (!m_mailboxupdatesFinished) {</span>
<a href="#l1.1470"></a><span id="l1.1470" class="difflineplus">+    if (AdvanceToNextServer()) {</span>
<a href="#l1.1471"></a><span id="l1.1471" class="difflineplus">+      nsCOMPtr&lt;nsIMsgFolder&gt; rootMsgFolder;</span>
<a href="#l1.1472"></a><span id="l1.1472">       m_currentServer-&gt;GetRootFolder(getter_AddRefs(rootMsgFolder));</span>
<a href="#l1.1473"></a><span id="l1.1473">       nsCOMPtr&lt;nsIMsgFolder&gt; inbox;</span>
<a href="#l1.1474"></a><span id="l1.1474" class="difflineminus">-      if (rootMsgFolder)</span>
<a href="#l1.1475"></a><span id="l1.1475" class="difflineminus">-      {</span>
<a href="#l1.1476"></a><span id="l1.1476" class="difflineminus">-          rootMsgFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Inbox,</span>
<a href="#l1.1477"></a><span id="l1.1477" class="difflineminus">-                                            getter_AddRefs(inbox));</span>
<a href="#l1.1478"></a><span id="l1.1478" class="difflineminus">-          if (inbox)</span>
<a href="#l1.1479"></a><span id="l1.1479" class="difflineminus">-          {</span>
<a href="#l1.1480"></a><span id="l1.1480" class="difflineminus">-            nsCOMPtr &lt;nsIMsgFolder&gt; offlineImapFolder;</span>
<a href="#l1.1481"></a><span id="l1.1481" class="difflineminus">-            nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapInbox = do_QueryInterface(inbox);</span>
<a href="#l1.1482"></a><span id="l1.1482" class="difflineminus">-            if (imapInbox)</span>
<a href="#l1.1483"></a><span id="l1.1483" class="difflineminus">-            {</span>
<a href="#l1.1484"></a><span id="l1.1484" class="difflineminus">-              rootMsgFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Offline,</span>
<a href="#l1.1485"></a><span id="l1.1485" class="difflineminus">-                                                getter_AddRefs(offlineImapFolder));</span>
<a href="#l1.1486"></a><span id="l1.1486" class="difflineminus">-              if (!offlineImapFolder)</span>
<a href="#l1.1487"></a><span id="l1.1487" class="difflineminus">-              {</span>
<a href="#l1.1488"></a><span id="l1.1488" class="difflineminus">-                // no imap folders configured for offline use - check if the account is set up</span>
<a href="#l1.1489"></a><span id="l1.1489" class="difflineminus">-                // so that we always download inbox msg bodies for offline use</span>
<a href="#l1.1490"></a><span id="l1.1490" class="difflineminus">-                nsCOMPtr &lt;nsIImapIncomingServer&gt; imapServer = do_QueryInterface(m_currentServer);</span>
<a href="#l1.1491"></a><span id="l1.1491" class="difflineminus">-                if (imapServer)</span>
<a href="#l1.1492"></a><span id="l1.1492" class="difflineminus">-                {</span>
<a href="#l1.1493"></a><span id="l1.1493" class="difflineminus">-                  bool downloadBodiesOnGetNewMail = false;</span>
<a href="#l1.1494"></a><span id="l1.1494" class="difflineminus">-                  imapServer-&gt;GetDownloadBodiesOnGetNewMail(&amp;downloadBodiesOnGetNewMail);</span>
<a href="#l1.1495"></a><span id="l1.1495" class="difflineminus">-                  if (downloadBodiesOnGetNewMail)</span>
<a href="#l1.1496"></a><span id="l1.1496" class="difflineminus">-                    offlineImapFolder = inbox;</span>
<a href="#l1.1497"></a><span id="l1.1497" class="difflineminus">-                }</span>
<a href="#l1.1498"></a><span id="l1.1498" class="difflineplus">+      if (rootMsgFolder) {</span>
<a href="#l1.1499"></a><span id="l1.1499" class="difflineplus">+        rootMsgFolder-&gt;GetFolderWithFlags(nsMsgFolderFlags::Inbox,</span>
<a href="#l1.1500"></a><span id="l1.1500" class="difflineplus">+                                          getter_AddRefs(inbox));</span>
<a href="#l1.1501"></a><span id="l1.1501" class="difflineplus">+        if (inbox) {</span>
<a href="#l1.1502"></a><span id="l1.1502" class="difflineplus">+          nsCOMPtr&lt;nsIMsgFolder&gt; offlineImapFolder;</span>
<a href="#l1.1503"></a><span id="l1.1503" class="difflineplus">+          nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapInbox = do_QueryInterface(inbox);</span>
<a href="#l1.1504"></a><span id="l1.1504" class="difflineplus">+          if (imapInbox) {</span>
<a href="#l1.1505"></a><span id="l1.1505" class="difflineplus">+            rootMsgFolder-&gt;GetFolderWithFlags(</span>
<a href="#l1.1506"></a><span id="l1.1506" class="difflineplus">+                nsMsgFolderFlags::Offline, getter_AddRefs(offlineImapFolder));</span>
<a href="#l1.1507"></a><span id="l1.1507" class="difflineplus">+            if (!offlineImapFolder) {</span>
<a href="#l1.1508"></a><span id="l1.1508" class="difflineplus">+              // no imap folders configured for offline use - check if the</span>
<a href="#l1.1509"></a><span id="l1.1509" class="difflineplus">+              // account is set up so that we always download inbox msg bodies</span>
<a href="#l1.1510"></a><span id="l1.1510" class="difflineplus">+              // for offline use</span>
<a href="#l1.1511"></a><span id="l1.1511" class="difflineplus">+              nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer =</span>
<a href="#l1.1512"></a><span id="l1.1512" class="difflineplus">+                  do_QueryInterface(m_currentServer);</span>
<a href="#l1.1513"></a><span id="l1.1513" class="difflineplus">+              if (imapServer) {</span>
<a href="#l1.1514"></a><span id="l1.1514" class="difflineplus">+                bool downloadBodiesOnGetNewMail = false;</span>
<a href="#l1.1515"></a><span id="l1.1515" class="difflineplus">+                imapServer-&gt;GetDownloadBodiesOnGetNewMail(</span>
<a href="#l1.1516"></a><span id="l1.1516" class="difflineplus">+                    &amp;downloadBodiesOnGetNewMail);</span>
<a href="#l1.1517"></a><span id="l1.1517" class="difflineplus">+                if (downloadBodiesOnGetNewMail) offlineImapFolder = inbox;</span>
<a href="#l1.1518"></a><span id="l1.1518">               }</span>
<a href="#l1.1519"></a><span id="l1.1519">             }</span>
<a href="#l1.1520"></a><span id="l1.1520" class="difflineminus">-            // if this isn't an imap inbox, or we have an offline imap sub-folder, then update the inbox.</span>
<a href="#l1.1521"></a><span id="l1.1521" class="difflineminus">-            // otherwise, it's an imap inbox for an account with no folders configured for offline use,</span>
<a href="#l1.1522"></a><span id="l1.1522" class="difflineminus">-            // so just advance to the next server.</span>
<a href="#l1.1523"></a><span id="l1.1523" class="difflineminus">-            if (!imapInbox || offlineImapFolder)</span>
<a href="#l1.1524"></a><span id="l1.1524" class="difflineminus">-            {</span>
<a href="#l1.1525"></a><span id="l1.1525" class="difflineminus">-              // here we should check if this a pop3 server/inbox, and the user doesn't want</span>
<a href="#l1.1526"></a><span id="l1.1526" class="difflineminus">-              // to download pop3 mail for offline use.</span>
<a href="#l1.1527"></a><span id="l1.1527" class="difflineminus">-              if (!imapInbox)</span>
<a href="#l1.1528"></a><span id="l1.1528" class="difflineminus">-              {</span>
<a href="#l1.1529"></a><span id="l1.1529" class="difflineminus">-              }</span>
<a href="#l1.1530"></a><span id="l1.1530" class="difflineminus">-              rv = inbox-&gt;GetNewMessages(m_window, this);</span>
<a href="#l1.1531"></a><span id="l1.1531" class="difflineminus">-              if (NS_SUCCEEDED(rv))</span>
<a href="#l1.1532"></a><span id="l1.1532" class="difflineminus">-                return rv; // otherwise, fall through.</span>
<a href="#l1.1533"></a><span id="l1.1533" class="difflineplus">+          }</span>
<a href="#l1.1534"></a><span id="l1.1534" class="difflineplus">+          // if this isn't an imap inbox, or we have an offline imap sub-folder,</span>
<a href="#l1.1535"></a><span id="l1.1535" class="difflineplus">+          // then update the inbox. otherwise, it's an imap inbox for an account</span>
<a href="#l1.1536"></a><span id="l1.1536" class="difflineplus">+          // with no folders configured for offline use, so just advance to the</span>
<a href="#l1.1537"></a><span id="l1.1537" class="difflineplus">+          // next server.</span>
<a href="#l1.1538"></a><span id="l1.1538" class="difflineplus">+          if (!imapInbox || offlineImapFolder) {</span>
<a href="#l1.1539"></a><span id="l1.1539" class="difflineplus">+            // here we should check if this a pop3 server/inbox, and the user</span>
<a href="#l1.1540"></a><span id="l1.1540" class="difflineplus">+            // doesn't want to download pop3 mail for offline use.</span>
<a href="#l1.1541"></a><span id="l1.1541" class="difflineplus">+            if (!imapInbox) {</span>
<a href="#l1.1542"></a><span id="l1.1542">             }</span>
<a href="#l1.1543"></a><span id="l1.1543" class="difflineplus">+            rv = inbox-&gt;GetNewMessages(m_window, this);</span>
<a href="#l1.1544"></a><span id="l1.1544" class="difflineplus">+            if (NS_SUCCEEDED(rv)) return rv;  // otherwise, fall through.</span>
<a href="#l1.1545"></a><span id="l1.1545">           }</span>
<a href="#l1.1546"></a><span id="l1.1546" class="difflineplus">+        }</span>
<a href="#l1.1547"></a><span id="l1.1547">       }</span>
<a href="#l1.1548"></a><span id="l1.1548" class="difflineminus">-      return ProcessNextOperation(); // recurse and do next server.</span>
<a href="#l1.1549"></a><span id="l1.1549" class="difflineplus">+      return ProcessNextOperation();  // recurse and do next server.</span>
<a href="#l1.1550"></a><span id="l1.1550">     }</span>
<a href="#l1.1551"></a><span id="l1.1551">     m_allServers = nullptr;</span>
<a href="#l1.1552"></a><span id="l1.1552">     m_mailboxupdatesFinished = true;</span>
<a href="#l1.1553"></a><span id="l1.1553">   }</span>
<a href="#l1.1554"></a><span id="l1.1554"> </span>
<a href="#l1.1555"></a><span id="l1.1555" class="difflineminus">-  while (AdvanceToNextFolder())</span>
<a href="#l1.1556"></a><span id="l1.1556" class="difflineminus">-  {</span>
<a href="#l1.1557"></a><span id="l1.1557" class="difflineplus">+  while (AdvanceToNextFolder()) {</span>
<a href="#l1.1558"></a><span id="l1.1558">     uint32_t folderFlags;</span>
<a href="#l1.1559"></a><span id="l1.1559"> </span>
<a href="#l1.1560"></a><span id="l1.1560">     ClearDB();</span>
<a href="#l1.1561"></a><span id="l1.1561" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder;</span>
<a href="#l1.1562"></a><span id="l1.1562" class="difflineminus">-    if (m_currentFolder)</span>
<a href="#l1.1563"></a><span id="l1.1563" class="difflineminus">-      imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.1564"></a><span id="l1.1564" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder;</span>
<a href="#l1.1565"></a><span id="l1.1565" class="difflineplus">+    if (m_currentFolder) imapFolder = do_QueryInterface(m_currentFolder);</span>
<a href="#l1.1566"></a><span id="l1.1566">     m_currentFolder-&gt;GetFlags(&amp;folderFlags);</span>
<a href="#l1.1567"></a><span id="l1.1567">     // need to check if folder has offline events, or is configured for offline</span>
<a href="#l1.1568"></a><span id="l1.1568">     if (imapFolder &amp;&amp; folderFlags &amp; nsMsgFolderFlags::Offline &amp;&amp;</span>
<a href="#l1.1569"></a><span id="l1.1569" class="difflineminus">-      ! (folderFlags &amp; nsMsgFolderFlags::Virtual))</span>
<a href="#l1.1570"></a><span id="l1.1570" class="difflineminus">-    {</span>
<a href="#l1.1571"></a><span id="l1.1571" class="difflineplus">+        !(folderFlags &amp; nsMsgFolderFlags::Virtual)) {</span>
<a href="#l1.1572"></a><span id="l1.1572">       rv = m_currentFolder-&gt;DownloadAllForOffline(this, m_window);</span>
<a href="#l1.1573"></a><span id="l1.1573" class="difflineminus">-      if (NS_SUCCEEDED(rv) || rv == NS_BINDING_ABORTED)</span>
<a href="#l1.1574"></a><span id="l1.1574" class="difflineminus">-        return rv;</span>
<a href="#l1.1575"></a><span id="l1.1575" class="difflineminus">-      // if this fails and the user didn't cancel/stop, fall through to code that advances to next folder</span>
<a href="#l1.1576"></a><span id="l1.1576" class="difflineplus">+      if (NS_SUCCEEDED(rv) || rv == NS_BINDING_ABORTED) return rv;</span>
<a href="#l1.1577"></a><span id="l1.1577" class="difflineplus">+      // if this fails and the user didn't cancel/stop, fall through to code</span>
<a href="#l1.1578"></a><span id="l1.1578" class="difflineplus">+      // that advances to next folder</span>
<a href="#l1.1579"></a><span id="l1.1579">     }</span>
<a href="#l1.1580"></a><span id="l1.1580">   }</span>
<a href="#l1.1581"></a><span id="l1.1581" class="difflineminus">-  if (m_listener)</span>
<a href="#l1.1582"></a><span id="l1.1582" class="difflineminus">-    m_listener-&gt;OnStopRunningUrl(nullptr, NS_OK);</span>
<a href="#l1.1583"></a><span id="l1.1583" class="difflineplus">+  if (m_listener) m_listener-&gt;OnStopRunningUrl(nullptr, NS_OK);</span>
<a href="#l1.1584"></a><span id="l1.1584">   return rv;</span>
<a href="#l1.1585"></a><span id="l1.1585"> }</span>
<a href="#l1.1586"></a><span id="l1.1586"> </span>
<a href="#l1.1587"></a><span id="l1.1587" class="difflineminus">-</span>
<a href="#l1.1588"></a><span id="l1.1588" class="difflineminus">-NS_IMETHODIMP nsImapOfflineSync::OnStartCopy()</span>
<a href="#l1.1589"></a><span id="l1.1589" class="difflineminus">-{</span>
<a href="#l1.1590"></a><span id="l1.1590" class="difflineminus">-    return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1591"></a><span id="l1.1591" class="difflineplus">+NS_IMETHODIMP nsImapOfflineSync::OnStartCopy() {</span>
<a href="#l1.1592"></a><span id="l1.1592" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1593"></a><span id="l1.1593"> }</span>
<a href="#l1.1594"></a><span id="l1.1594"> </span>
<a href="#l1.1595"></a><span id="l1.1595"> /* void OnProgress (in uint32_t aProgress, in uint32_t aProgressMax); */</span>
<a href="#l1.1596"></a><span id="l1.1596" class="difflineminus">-NS_IMETHODIMP nsImapOfflineSync::OnProgress(uint32_t aProgress, uint32_t aProgressMax)</span>
<a href="#l1.1597"></a><span id="l1.1597" class="difflineminus">-{</span>
<a href="#l1.1598"></a><span id="l1.1598" class="difflineminus">-    return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1599"></a><span id="l1.1599" class="difflineplus">+NS_IMETHODIMP nsImapOfflineSync::OnProgress(uint32_t aProgress,</span>
<a href="#l1.1600"></a><span id="l1.1600" class="difflineplus">+                                            uint32_t aProgressMax) {</span>
<a href="#l1.1601"></a><span id="l1.1601" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1602"></a><span id="l1.1602"> }</span>
<a href="#l1.1603"></a><span id="l1.1603"> </span>
<a href="#l1.1604"></a><span id="l1.1604"> /* void SetMessageKey (in uint32_t aKey); */</span>
<a href="#l1.1605"></a><span id="l1.1605" class="difflineminus">-NS_IMETHODIMP nsImapOfflineSync::SetMessageKey(uint32_t aKey)</span>
<a href="#l1.1606"></a><span id="l1.1606" class="difflineminus">-{</span>
<a href="#l1.1607"></a><span id="l1.1607" class="difflineminus">-    return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1608"></a><span id="l1.1608" class="difflineplus">+NS_IMETHODIMP nsImapOfflineSync::SetMessageKey(uint32_t aKey) {</span>
<a href="#l1.1609"></a><span id="l1.1609" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1610"></a><span id="l1.1610"> }</span>
<a href="#l1.1611"></a><span id="l1.1611"> </span>
<a href="#l1.1612"></a><span id="l1.1612"> /* [noscript] void GetMessageId (in nsCString aMessageId); */</span>
<a href="#l1.1613"></a><span id="l1.1613" class="difflineminus">-NS_IMETHODIMP nsImapOfflineSync::GetMessageId(nsACString&amp; messageId)</span>
<a href="#l1.1614"></a><span id="l1.1614" class="difflineminus">-{</span>
<a href="#l1.1615"></a><span id="l1.1615" class="difflineminus">-    return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1616"></a><span id="l1.1616" class="difflineplus">+NS_IMETHODIMP nsImapOfflineSync::GetMessageId(nsACString &amp;messageId) {</span>
<a href="#l1.1617"></a><span id="l1.1617" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l1.1618"></a><span id="l1.1618"> }</span>
<a href="#l1.1619"></a><span id="l1.1619"> </span>
<a href="#l1.1620"></a><span id="l1.1620"> /* void OnStopCopy (in nsresult aStatus); */</span>
<a href="#l1.1621"></a><span id="l1.1621" class="difflineminus">-NS_IMETHODIMP nsImapOfflineSync::OnStopCopy(nsresult aStatus)</span>
<a href="#l1.1622"></a><span id="l1.1622" class="difflineminus">-{</span>
<a href="#l1.1623"></a><span id="l1.1623" class="difflineplus">+NS_IMETHODIMP nsImapOfflineSync::OnStopCopy(nsresult aStatus) {</span>
<a href="#l1.1624"></a><span id="l1.1624">   return OnStopRunningUrl(nullptr, aStatus);</span>
<a href="#l1.1625"></a><span id="l1.1625"> }</span>
<a href="#l1.1626"></a><span id="l1.1626"> </span>
<a href="#l1.1627"></a><span id="l1.1627" class="difflineminus">-void nsImapOfflineSync::ClearDB()</span>
<a href="#l1.1628"></a><span id="l1.1628" class="difflineminus">-{</span>
<a href="#l1.1629"></a><span id="l1.1629" class="difflineplus">+void nsImapOfflineSync::ClearDB() {</span>
<a href="#l1.1630"></a><span id="l1.1630">   m_currentOpsToClear.Clear();</span>
<a href="#l1.1631"></a><span id="l1.1631" class="difflineminus">-  if (m_currentDB)</span>
<a href="#l1.1632"></a><span id="l1.1632" class="difflineminus">-    m_currentDB-&gt;RemoveListener(this);</span>
<a href="#l1.1633"></a><span id="l1.1633" class="difflineplus">+  if (m_currentDB) m_currentDB-&gt;RemoveListener(this);</span>
<a href="#l1.1634"></a><span id="l1.1634">   m_currentDB = nullptr;</span>
<a href="#l1.1635"></a><span id="l1.1635"> }</span>
<a href="#l1.1636"></a><span id="l1.1636"> </span>
<a href="#l1.1637"></a><span id="l1.1637"> NS_IMETHODIMP</span>
<a href="#l1.1638"></a><span id="l1.1638"> nsImapOfflineSync::OnHdrPropertyChanged(nsIMsgDBHdr *aHdrToChange,</span>
<a href="#l1.1639"></a><span id="l1.1639" class="difflineminus">-    bool aPreChange, uint32_t *aStatus, nsIDBChangeListener * aInstigator)</span>
<a href="#l1.1640"></a><span id="l1.1640" class="difflineminus">-{</span>
<a href="#l1.1641"></a><span id="l1.1641" class="difflineplus">+                                        bool aPreChange, uint32_t *aStatus,</span>
<a href="#l1.1642"></a><span id="l1.1642" class="difflineplus">+                                        nsIDBChangeListener *aInstigator) {</span>
<a href="#l1.1643"></a><span id="l1.1643">   return NS_OK;</span>
<a href="#l1.1644"></a><span id="l1.1644"> }</span>
<a href="#l1.1645"></a><span id="l1.1645"> </span>
<a href="#l1.1646"></a><span id="l1.1646" class="difflineminus">-</span>
<a href="#l1.1647"></a><span id="l1.1647"> NS_IMETHODIMP</span>
<a href="#l1.1648"></a><span id="l1.1648"> nsImapOfflineSync::OnHdrFlagsChanged(nsIMsgDBHdr *aHdrChanged,</span>
<a href="#l1.1649"></a><span id="l1.1649" class="difflineminus">-    uint32_t aOldFlags, uint32_t aNewFlags, nsIDBChangeListener *aInstigator)</span>
<a href="#l1.1650"></a><span id="l1.1650" class="difflineminus">-{</span>
<a href="#l1.1651"></a><span id="l1.1651" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.1652"></a><span id="l1.1652" class="difflineplus">+                                     uint32_t aOldFlags, uint32_t aNewFlags,</span>
<a href="#l1.1653"></a><span id="l1.1653" class="difflineplus">+                                     nsIDBChangeListener *aInstigator) {</span>
<a href="#l1.1654"></a><span id="l1.1654" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.1655"></a><span id="l1.1655"> }</span>
<a href="#l1.1656"></a><span id="l1.1656"> </span>
<a href="#l1.1657"></a><span id="l1.1657"> NS_IMETHODIMP</span>
<a href="#l1.1658"></a><span id="l1.1658" class="difflineminus">-nsImapOfflineSync::OnHdrDeleted(nsIMsgDBHdr *aHdrChanged,</span>
<a href="#l1.1659"></a><span id="l1.1659" class="difflineminus">-    nsMsgKey aParentKey, int32_t aFlags, nsIDBChangeListener *aInstigator)</span>
<a href="#l1.1660"></a><span id="l1.1660" class="difflineminus">-{</span>
<a href="#l1.1661"></a><span id="l1.1661" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.1662"></a><span id="l1.1662" class="difflineplus">+nsImapOfflineSync::OnHdrDeleted(nsIMsgDBHdr *aHdrChanged, nsMsgKey aParentKey,</span>
<a href="#l1.1663"></a><span id="l1.1663" class="difflineplus">+                                int32_t aFlags,</span>
<a href="#l1.1664"></a><span id="l1.1664" class="difflineplus">+                                nsIDBChangeListener *aInstigator) {</span>
<a href="#l1.1665"></a><span id="l1.1665" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.1666"></a><span id="l1.1666"> }</span>
<a href="#l1.1667"></a><span id="l1.1667"> </span>
<a href="#l1.1668"></a><span id="l1.1668"> NS_IMETHODIMP</span>
<a href="#l1.1669"></a><span id="l1.1669" class="difflineminus">-nsImapOfflineSync::OnHdrAdded(nsIMsgDBHdr *aHdrAdded,</span>
<a href="#l1.1670"></a><span id="l1.1670" class="difflineminus">-    nsMsgKey aParentKey, int32_t aFlags, nsIDBChangeListener *aInstigator)</span>
<a href="#l1.1671"></a><span id="l1.1671" class="difflineminus">-{</span>
<a href="#l1.1672"></a><span id="l1.1672" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.1673"></a><span id="l1.1673" class="difflineplus">+nsImapOfflineSync::OnHdrAdded(nsIMsgDBHdr *aHdrAdded, nsMsgKey aParentKey,</span>
<a href="#l1.1674"></a><span id="l1.1674" class="difflineplus">+                              int32_t aFlags,</span>
<a href="#l1.1675"></a><span id="l1.1675" class="difflineplus">+                              nsIDBChangeListener *aInstigator) {</span>
<a href="#l1.1676"></a><span id="l1.1676" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.1677"></a><span id="l1.1677"> }</span>
<a href="#l1.1678"></a><span id="l1.1678"> </span>
<a href="#l1.1679"></a><span id="l1.1679" class="difflineminus">-/* void OnParentChanged (in nsMsgKey aKeyChanged, in nsMsgKey oldParent, in nsMsgKey newParent, in nsIDBChangeListener aInstigator); */</span>
<a href="#l1.1680"></a><span id="l1.1680" class="difflineplus">+/* void OnParentChanged (in nsMsgKey aKeyChanged, in nsMsgKey oldParent, in</span>
<a href="#l1.1681"></a><span id="l1.1681" class="difflineplus">+ * nsMsgKey newParent, in nsIDBChangeListener aInstigator); */</span>
<a href="#l1.1682"></a><span id="l1.1682"> NS_IMETHODIMP</span>
<a href="#l1.1683"></a><span id="l1.1683" class="difflineminus">-nsImapOfflineSync::OnParentChanged(nsMsgKey aKeyChanged,</span>
<a href="#l1.1684"></a><span id="l1.1684" class="difflineminus">-    nsMsgKey oldParent, nsMsgKey newParent, nsIDBChangeListener *aInstigator)</span>
<a href="#l1.1685"></a><span id="l1.1685" class="difflineminus">-{</span>
<a href="#l1.1686"></a><span id="l1.1686" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.1687"></a><span id="l1.1687" class="difflineplus">+nsImapOfflineSync::OnParentChanged(nsMsgKey aKeyChanged, nsMsgKey oldParent,</span>
<a href="#l1.1688"></a><span id="l1.1688" class="difflineplus">+                                   nsMsgKey newParent,</span>
<a href="#l1.1689"></a><span id="l1.1689" class="difflineplus">+                                   nsIDBChangeListener *aInstigator) {</span>
<a href="#l1.1690"></a><span id="l1.1690" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.1691"></a><span id="l1.1691"> }</span>
<a href="#l1.1692"></a><span id="l1.1692"> </span>
<a href="#l1.1693"></a><span id="l1.1693"> /* void OnAnnouncerGoingAway (in nsIDBChangeAnnouncer instigator); */</span>
<a href="#l1.1694"></a><span id="l1.1694"> NS_IMETHODIMP</span>
<a href="#l1.1695"></a><span id="l1.1695" class="difflineminus">-nsImapOfflineSync::OnAnnouncerGoingAway(nsIDBChangeAnnouncer *instigator)</span>
<a href="#l1.1696"></a><span id="l1.1696" class="difflineminus">-{</span>
<a href="#l1.1697"></a><span id="l1.1697" class="difflineplus">+nsImapOfflineSync::OnAnnouncerGoingAway(nsIDBChangeAnnouncer *instigator) {</span>
<a href="#l1.1698"></a><span id="l1.1698">   ClearDB();</span>
<a href="#l1.1699"></a><span id="l1.1699">   return NS_OK;</span>
<a href="#l1.1700"></a><span id="l1.1700"> }</span>
<a href="#l1.1701"></a><span id="l1.1701"> </span>
<a href="#l1.1702"></a><span id="l1.1702" class="difflineminus">-NS_IMETHODIMP nsImapOfflineSync::OnEvent(nsIMsgDatabase *aDB, const char *aEvent)</span>
<a href="#l1.1703"></a><span id="l1.1703" class="difflineminus">-{</span>
<a href="#l1.1704"></a><span id="l1.1704" class="difflineplus">+NS_IMETHODIMP nsImapOfflineSync::OnEvent(nsIMsgDatabase *aDB,</span>
<a href="#l1.1705"></a><span id="l1.1705" class="difflineplus">+                                         const char *aEvent) {</span>
<a href="#l1.1706"></a><span id="l1.1706">   return NS_OK;</span>
<a href="#l1.1707"></a><span id="l1.1707"> }</span>
<a href="#l1.1708"></a><span id="l1.1708"> </span>
<a href="#l1.1709"></a><span id="l1.1709"> /* void OnReadChanged (in nsIDBChangeListener instigator); */</span>
<a href="#l1.1710"></a><span id="l1.1710"> NS_IMETHODIMP</span>
<a href="#l1.1711"></a><span id="l1.1711" class="difflineminus">-nsImapOfflineSync::OnReadChanged(nsIDBChangeListener *instigator)</span>
<a href="#l1.1712"></a><span id="l1.1712" class="difflineminus">-{</span>
<a href="#l1.1713"></a><span id="l1.1713" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.1714"></a><span id="l1.1714" class="difflineplus">+nsImapOfflineSync::OnReadChanged(nsIDBChangeListener *instigator) {</span>
<a href="#l1.1715"></a><span id="l1.1715" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.1716"></a><span id="l1.1716"> }</span>
<a href="#l1.1717"></a><span id="l1.1717"> </span>
<a href="#l1.1718"></a><span id="l1.1718"> /* void OnJunkScoreChanged (in nsIDBChangeListener instigator); */</span>
<a href="#l1.1719"></a><span id="l1.1719"> NS_IMETHODIMP</span>
<a href="#l1.1720"></a><span id="l1.1720" class="difflineminus">-nsImapOfflineSync::OnJunkScoreChanged(nsIDBChangeListener *instigator)</span>
<a href="#l1.1721"></a><span id="l1.1721" class="difflineminus">-{</span>
<a href="#l1.1722"></a><span id="l1.1722" class="difflineminus">-    return NS_OK;</span>
<a href="#l1.1723"></a><span id="l1.1723" class="difflineplus">+nsImapOfflineSync::OnJunkScoreChanged(nsIDBChangeListener *instigator) {</span>
<a href="#l1.1724"></a><span id="l1.1724" class="difflineplus">+  return NS_OK;</span>
<a href="#l1.1725"></a><span id="l1.1725"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/imap/src/nsImapOfflineSync.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapOfflineSync.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -1,92 +1,94 @@</span>
<a href="#l2.4"></a><span id="l2.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l2.5"></a><span id="l2.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l2.6"></a><span id="l2.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l2.7"></a><span id="l2.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> #ifndef _nsImapOfflineSync_H_</span>
<a href="#l2.10"></a><span id="l2.10"> #define _nsImapOfflineSync_H_</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-</span>
<a href="#l2.13"></a><span id="l2.13"> #include &quot;mozilla/Attributes.h&quot;</span>
<a href="#l2.14"></a><span id="l2.14"> #include &quot;nsIMsgDatabase.h&quot;</span>
<a href="#l2.15"></a><span id="l2.15"> #include &quot;nsIUrlListener.h&quot;</span>
<a href="#l2.16"></a><span id="l2.16"> #include &quot;nsIMsgOfflineImapOperation.h&quot;</span>
<a href="#l2.17"></a><span id="l2.17"> #include &quot;nsIMsgWindow.h&quot;</span>
<a href="#l2.18"></a><span id="l2.18"> #include &quot;nsIMsgFolder.h&quot;</span>
<a href="#l2.19"></a><span id="l2.19"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l2.20"></a><span id="l2.20"> #include &quot;nsIDBChangeListener.h&quot;</span>
<a href="#l2.21"></a><span id="l2.21"> </span>
<a href="#l2.22"></a><span id="l2.22"> class nsImapOfflineSync : public nsIUrlListener,</span>
<a href="#l2.23"></a><span id="l2.23">                           public nsIMsgCopyServiceListener,</span>
<a href="#l2.24"></a><span id="l2.24">                           public nsIDBChangeListener {</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineminus">-public: // set to one folder to playback one folder only</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+ public:  // set to one folder to playback one folder only</span>
<a href="#l2.27"></a><span id="l2.27">   nsImapOfflineSync(nsIMsgWindow *window, nsIUrlListener *listener,</span>
<a href="#l2.28"></a><span id="l2.28">                     nsIMsgFolder *singleFolderOnly = nullptr,</span>
<a href="#l2.29"></a><span id="l2.29">                     bool isPseudoOffline = false);</span>
<a href="#l2.30"></a><span id="l2.30"> </span>
<a href="#l2.31"></a><span id="l2.31">   NS_DECL_ISUPPORTS</span>
<a href="#l2.32"></a><span id="l2.32">   NS_DECL_NSIURLLISTENER</span>
<a href="#l2.33"></a><span id="l2.33">   NS_DECL_NSIMSGCOPYSERVICELISTENER</span>
<a href="#l2.34"></a><span id="l2.34">   NS_DECL_NSIDBCHANGELISTENER</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineminus">-  virtual nsresult  ProcessNextOperation(); // this kicks off playback</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+  virtual nsresult ProcessNextOperation();  // this kicks off playback</span>
<a href="#l2.37"></a><span id="l2.37"> </span>
<a href="#l2.38"></a><span id="l2.38" class="difflineminus">-  int32_t   GetCurrentUIDValidity();</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineminus">-  void      SetCurrentUIDValidity(int32_t uidvalidity) { mCurrentUIDValidity = uidvalidity; }</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+  int32_t GetCurrentUIDValidity();</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+  void SetCurrentUIDValidity(int32_t uidvalidity) {</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+    mCurrentUIDValidity = uidvalidity;</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+  }</span>
<a href="#l2.44"></a><span id="l2.44"> </span>
<a href="#l2.45"></a><span id="l2.45" class="difflineminus">-  void      SetPseudoOffline(bool pseudoOffline) {m_pseudoOffline = pseudoOffline;}</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineminus">-  bool      ProcessingStaleFolderUpdate() { return m_singleFolderToUpdate != nullptr; }</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineplus">+  void SetPseudoOffline(bool pseudoOffline) { m_pseudoOffline = pseudoOffline; }</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineplus">+  bool ProcessingStaleFolderUpdate() {</span>
<a href="#l2.49"></a><span id="l2.49" class="difflineplus">+    return m_singleFolderToUpdate != nullptr;</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineplus">+  }</span>
<a href="#l2.51"></a><span id="l2.51"> </span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-  bool      CreateOfflineFolder(nsIMsgFolder *folder);</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineminus">-  void      SetWindow(nsIMsgWindow *window);</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineminus">-protected:</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+  bool CreateOfflineFolder(nsIMsgFolder *folder);</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineplus">+  void SetWindow(nsIMsgWindow *window);</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineplus">+</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+ protected:</span>
<a href="#l2.59"></a><span id="l2.59">   virtual ~nsImapOfflineSync();</span>
<a href="#l2.60"></a><span id="l2.60"> </span>
<a href="#l2.61"></a><span id="l2.61" class="difflineminus">-  bool      CreateOfflineFolders();</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-  bool      DestFolderOnSameServer(nsIMsgFolder *destFolder);</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineminus">-  bool      AdvanceToNextServer();</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">-  bool      AdvanceToNextFolder();</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineminus">-  void      AdvanceToFirstIMAPFolder();</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineminus">-  void      DeleteAllOfflineOpsForCurrentDB();</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineminus">-  void      ClearCurrentOps();</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+  bool CreateOfflineFolders();</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+  bool DestFolderOnSameServer(nsIMsgFolder *destFolder);</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+  bool AdvanceToNextServer();</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+  bool AdvanceToNextFolder();</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+  void AdvanceToFirstIMAPFolder();</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+  void DeleteAllOfflineOpsForCurrentDB();</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+  void ClearCurrentOps();</span>
<a href="#l2.75"></a><span id="l2.75">   // Clears m_currentDB, and unregister listener.</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineminus">-  void      ClearDB();</span>
<a href="#l2.77"></a><span id="l2.77" class="difflineminus">-  void      ProcessFlagOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineminus">-  void      ProcessKeywordOperation(nsIMsgOfflineImapOperation *op);</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineminus">-  void      ProcessMoveOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineminus">-  void      ProcessCopyOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineminus">-  void      ProcessEmptyTrash();</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineminus">-  void      ProcessAppendMsgOperation(nsIMsgOfflineImapOperation *currentOp,</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineminus">-                                      nsOfflineImapOperationType opType);</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineplus">+  void ClearDB();</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+  void ProcessFlagOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+  void ProcessKeywordOperation(nsIMsgOfflineImapOperation *op);</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineplus">+  void ProcessMoveOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineplus">+  void ProcessCopyOperation(nsIMsgOfflineImapOperation *currentOp);</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineplus">+  void ProcessEmptyTrash();</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineplus">+  void ProcessAppendMsgOperation(nsIMsgOfflineImapOperation *currentOp,</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineplus">+                                 nsOfflineImapOperationType opType);</span>
<a href="#l2.92"></a><span id="l2.92"> </span>
<a href="#l2.93"></a><span id="l2.93">   nsCOMPtr&lt;nsIMsgFolder&gt; m_currentFolder;</span>
<a href="#l2.94"></a><span id="l2.94">   nsCOMPtr&lt;nsIMsgFolder&gt; m_singleFolderToUpdate;</span>
<a href="#l2.95"></a><span id="l2.95">   nsCOMPtr&lt;nsIMsgWindow&gt; m_window;</span>
<a href="#l2.96"></a><span id="l2.96">   nsCOMPtr&lt;nsIArray&gt; m_allServers;</span>
<a href="#l2.97"></a><span id="l2.97">   nsCOMPtr&lt;nsIArray&gt; m_allFolders;</span>
<a href="#l2.98"></a><span id="l2.98">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; m_currentServer;</span>
<a href="#l2.99"></a><span id="l2.99">   nsCOMPtr&lt;nsISimpleEnumerator&gt; m_serverEnumerator;</span>
<a href="#l2.100"></a><span id="l2.100">   nsCOMPtr&lt;nsIFile&gt; m_curTempFile;</span>
<a href="#l2.101"></a><span id="l2.101"> </span>
<a href="#l2.102"></a><span id="l2.102">   nsTArray&lt;nsMsgKey&gt; m_CurrentKeys;</span>
<a href="#l2.103"></a><span id="l2.103">   nsCOMArray&lt;nsIMsgOfflineImapOperation&gt; m_currentOpsToClear;</span>
<a href="#l2.104"></a><span id="l2.104">   uint32_t m_KeyIndex;</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineminus">-  nsCOMPtr &lt;nsIMsgDatabase&gt; m_currentDB;</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineminus">-  nsCOMPtr &lt;nsIUrlListener&gt; m_listener;</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+  nsCOMPtr&lt;nsIMsgDatabase&gt; m_currentDB;</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+  nsCOMPtr&lt;nsIUrlListener&gt; m_listener;</span>
<a href="#l2.109"></a><span id="l2.109">   int32_t mCurrentUIDValidity;</span>
<a href="#l2.110"></a><span id="l2.110">   int32_t mCurrentPlaybackOpType;  // kFlagsChanged -&gt; kMsgCopy -&gt; kMsgMoved</span>
<a href="#l2.111"></a><span id="l2.111">   bool m_mailboxupdatesStarted;</span>
<a href="#l2.112"></a><span id="l2.112">   bool m_mailboxupdatesFinished;</span>
<a href="#l2.113"></a><span id="l2.113">   bool m_pseudoOffline;  // for queueing online events in offline db</span>
<a href="#l2.114"></a><span id="l2.114">   bool m_createdOfflineFolders;</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineminus">-</span>
<a href="#l2.116"></a><span id="l2.116"> };</span>
<a href="#l2.117"></a><span id="l2.117"> </span>
<a href="#l2.118"></a><span id="l2.118" class="difflineminus">-class nsImapOfflineDownloader : public nsImapOfflineSync</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineminus">-{</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineminus">-public:</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineplus">+class nsImapOfflineDownloader : public nsImapOfflineSync {</span>
<a href="#l2.122"></a><span id="l2.122" class="difflineplus">+ public:</span>
<a href="#l2.123"></a><span id="l2.123">   nsImapOfflineDownloader(nsIMsgWindow *window, nsIUrlListener *listener);</span>
<a href="#l2.124"></a><span id="l2.124">   virtual ~nsImapOfflineDownloader();</span>
<a href="#l2.125"></a><span id="l2.125" class="difflineminus">-  virtual nsresult  ProcessNextOperation() override; // this kicks off download</span>
<a href="#l2.126"></a><span id="l2.126" class="difflineplus">+  virtual nsresult ProcessNextOperation() override;  // this kicks off download</span>
<a href="#l2.127"></a><span id="l2.127"> };</span>
<a href="#l2.128"></a><span id="l2.128"> </span>
<a href="#l2.129"></a><span id="l2.129"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -81,255 +81,219 @@</span>
<a href="#l3.4"></a><span id="l3.4"> #include &quot;nsIImapMessageSink.h&quot;</span>
<a href="#l3.5"></a><span id="l3.5"> </span>
<a href="#l3.6"></a><span id="l3.6"> using namespace mozilla;</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> LazyLogModule IMAP(&quot;IMAP&quot;);</span>
<a href="#l3.9"></a><span id="l3.9"> LazyLogModule IMAP_CS(&quot;IMAP_CS&quot;);</span>
<a href="#l3.10"></a><span id="l3.10"> LazyLogModule IMAPCache(&quot;IMAPCache&quot;);</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-#define ONE_SECOND ((uint32_t)1000)    // one second</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-#define OUTPUT_BUFFER_SIZE (4096*2) // mscott - i should be able to remove this if I can use nsMsgLineBuffer???</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+#define ONE_SECOND ((uint32_t)1000)  // one second</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+#define OUTPUT_BUFFER_SIZE (4096 * 2)</span>
<a href="#l3.18"></a><span id="l3.18"> </span>
<a href="#l3.19"></a><span id="l3.19"> #define IMAP_ENV_HEADERS &quot;From To Cc Bcc Subject Date Message-ID &quot;</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineminus">-#define IMAP_DB_HEADERS &quot;Priority X-Priority References Newsgroups In-Reply-To Content-Type Reply-To&quot;</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+#define IMAP_DB_HEADERS                                                 \</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+  &quot;Priority X-Priority References Newsgroups In-Reply-To Content-Type &quot; \</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+  &quot;Reply-To&quot;</span>
<a href="#l3.24"></a><span id="l3.24"> #define IMAP_ENV_AND_DB_HEADERS IMAP_ENV_HEADERS IMAP_DB_HEADERS</span>
<a href="#l3.25"></a><span id="l3.25"> static const PRIntervalTime kImapSleepTime = PR_MillisecondsToInterval(60000);</span>
<a href="#l3.26"></a><span id="l3.26"> static int32_t gPromoteNoopToCheckCount = 0;</span>
<a href="#l3.27"></a><span id="l3.27"> static const uint32_t kFlagChangesBeforeCheck = 10;</span>
<a href="#l3.28"></a><span id="l3.28"> static const int32_t kMaxSecondsBeforeCheck = 600;</span>
<a href="#l3.29"></a><span id="l3.29"> </span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-class AutoProxyReleaseMsgWindow</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-{</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineminus">-  public:</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineminus">-    AutoProxyReleaseMsgWindow()</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">-      : mMsgWindow()</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-    {}</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineminus">-    ~AutoProxyReleaseMsgWindow()</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineminus">-    {</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineminus">-      NS_ReleaseOnMainThreadSystemGroup(&quot;AutoProxyReleaseMsgWindow::mMsgWindow&quot;, dont_AddRef(mMsgWindow));</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineminus">-    }</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-    nsIMsgWindow** StartAssignment()</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineminus">-    {</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-      MOZ_ASSERT(!mMsgWindow);</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-      return &amp;mMsgWindow;</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineminus">-    }</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineminus">-    operator nsIMsgWindow*()</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineminus">-    {</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineminus">-      return mMsgWindow;</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineminus">-    }</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineminus">-  private:</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineminus">-    nsIMsgWindow* mMsgWindow;</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+class AutoProxyReleaseMsgWindow {</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+ public:</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+  AutoProxyReleaseMsgWindow() : mMsgWindow() {}</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+  ~AutoProxyReleaseMsgWindow() {</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+    NS_ReleaseOnMainThreadSystemGroup(&quot;AutoProxyReleaseMsgWindow::mMsgWindow&quot;,</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+                                      dont_AddRef(mMsgWindow));</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+  }</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+  nsIMsgWindow **StartAssignment() {</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+    MOZ_ASSERT(!mMsgWindow);</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+    return &amp;mMsgWindow;</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+  }</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+  operator nsIMsgWindow *() { return mMsgWindow; }</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+ private:</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+  nsIMsgWindow *mMsgWindow;</span>
<a href="#l3.66"></a><span id="l3.66"> };</span>
<a href="#l3.67"></a><span id="l3.67"> </span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-nsIMsgWindow**</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineminus">-getter_AddRefs(AutoProxyReleaseMsgWindow&amp; aSmartPtr)</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-{</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+nsIMsgWindow **getter_AddRefs(AutoProxyReleaseMsgWindow &amp;aSmartPtr) {</span>
<a href="#l3.72"></a><span id="l3.72">   return aSmartPtr.StartAssignment();</span>
<a href="#l3.73"></a><span id="l3.73"> }</span>
<a href="#l3.74"></a><span id="l3.74"> </span>
<a href="#l3.75"></a><span id="l3.75"> NS_IMPL_ISUPPORTS(nsMsgImapHdrXferInfo, nsIImapHeaderXferInfo)</span>
<a href="#l3.76"></a><span id="l3.76"> </span>
<a href="#l3.77"></a><span id="l3.77" class="difflineminus">-nsMsgImapHdrXferInfo::nsMsgImapHdrXferInfo()</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineminus">-  : m_hdrInfos(kNumHdrsToXfer)</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineminus">-{</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+nsMsgImapHdrXferInfo::nsMsgImapHdrXferInfo() : m_hdrInfos(kNumHdrsToXfer) {</span>
<a href="#l3.81"></a><span id="l3.81">   m_nextFreeHdrInfo = 0;</span>
<a href="#l3.82"></a><span id="l3.82"> }</span>
<a href="#l3.83"></a><span id="l3.83"> </span>
<a href="#l3.84"></a><span id="l3.84" class="difflineminus">-nsMsgImapHdrXferInfo::~nsMsgImapHdrXferInfo()</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineminus">-{</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineminus">-}</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineminus">-</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineminus">-NS_IMETHODIMP nsMsgImapHdrXferInfo::GetNumHeaders(int32_t *aNumHeaders)</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineminus">-{</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+nsMsgImapHdrXferInfo::~nsMsgImapHdrXferInfo() {}</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+NS_IMETHODIMP nsMsgImapHdrXferInfo::GetNumHeaders(int32_t *aNumHeaders) {</span>
<a href="#l3.93"></a><span id="l3.93">   *aNumHeaders = m_nextFreeHdrInfo;</span>
<a href="#l3.94"></a><span id="l3.94">   return NS_OK;</span>
<a href="#l3.95"></a><span id="l3.95"> }</span>
<a href="#l3.96"></a><span id="l3.96"> </span>
<a href="#l3.97"></a><span id="l3.97" class="difflineminus">-NS_IMETHODIMP nsMsgImapHdrXferInfo::GetHeader(int32_t hdrIndex, nsIImapHeaderInfo **aResult)</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineminus">-{</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+NS_IMETHODIMP nsMsgImapHdrXferInfo::GetHeader(int32_t hdrIndex,</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+                                              nsIImapHeaderInfo **aResult) {</span>
<a href="#l3.101"></a><span id="l3.101">   // If the header index is more than (or equal to) our next free pointer, then</span>
<a href="#l3.102"></a><span id="l3.102">   // its a header we haven't really got and the caller has done something</span>
<a href="#l3.103"></a><span id="l3.103">   // wrong.</span>
<a href="#l3.104"></a><span id="l3.104">   NS_ENSURE_TRUE(hdrIndex &lt; m_nextFreeHdrInfo, NS_ERROR_NULL_POINTER);</span>
<a href="#l3.105"></a><span id="l3.105"> </span>
<a href="#l3.106"></a><span id="l3.106">   NS_IF_ADDREF(*aResult = m_hdrInfos.SafeObjectAt(hdrIndex));</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineminus">-  if (!*aResult)</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+  if (!*aResult) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.110"></a><span id="l3.110">   return NS_OK;</span>
<a href="#l3.111"></a><span id="l3.111"> }</span>
<a href="#l3.112"></a><span id="l3.112"> </span>
<a href="#l3.113"></a><span id="l3.113" class="difflineminus">-static const int32_t kInitLineHdrCacheSize = 512; // should be about right</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineminus">-</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineminus">-nsIImapHeaderInfo* nsMsgImapHdrXferInfo::StartNewHdr()</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineminus">-{</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineminus">-  if (m_nextFreeHdrInfo &gt;= kNumHdrsToXfer)</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineminus">-    return nullptr;</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+static const int32_t kInitLineHdrCacheSize = 512;  // should be about right</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+nsIImapHeaderInfo *nsMsgImapHdrXferInfo::StartNewHdr() {</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+  if (m_nextFreeHdrInfo &gt;= kNumHdrsToXfer) return nullptr;</span>
<a href="#l3.123"></a><span id="l3.123"> </span>
<a href="#l3.124"></a><span id="l3.124">   nsIImapHeaderInfo *result = m_hdrInfos.SafeObjectAt(m_nextFreeHdrInfo++);</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineminus">-  if (result)</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineminus">-    return result;</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+  if (result) return result;</span>
<a href="#l3.128"></a><span id="l3.128"> </span>
<a href="#l3.129"></a><span id="l3.129">   nsMsgImapLineDownloadCache *lineCache = new nsMsgImapLineDownloadCache();</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineminus">-  if (!lineCache)</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineminus">-    return nullptr;</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+  if (!lineCache) return nullptr;</span>
<a href="#l3.133"></a><span id="l3.133"> </span>
<a href="#l3.134"></a><span id="l3.134">   lineCache-&gt;GrowBuffer(kInitLineHdrCacheSize);</span>
<a href="#l3.135"></a><span id="l3.135"> </span>
<a href="#l3.136"></a><span id="l3.136">   m_hdrInfos.AppendObject(lineCache);</span>
<a href="#l3.137"></a><span id="l3.137"> </span>
<a href="#l3.138"></a><span id="l3.138">   return lineCache;</span>
<a href="#l3.139"></a><span id="l3.139"> }</span>
<a href="#l3.140"></a><span id="l3.140"> </span>
<a href="#l3.141"></a><span id="l3.141"> // maybe not needed...</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineminus">-void nsMsgImapHdrXferInfo::FinishCurrentHdr()</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineminus">-{</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+void nsMsgImapHdrXferInfo::FinishCurrentHdr() {</span>
<a href="#l3.145"></a><span id="l3.145">   // nothing to do?</span>
<a href="#l3.146"></a><span id="l3.146"> }</span>
<a href="#l3.147"></a><span id="l3.147"> </span>
<a href="#l3.148"></a><span id="l3.148" class="difflineminus">-void nsMsgImapHdrXferInfo::ResetAll()</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineminus">-{</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+void nsMsgImapHdrXferInfo::ResetAll() {</span>
<a href="#l3.151"></a><span id="l3.151">   int32_t count = m_hdrInfos.Count();</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineminus">-  for (int32_t i = 0; i &lt; count; i++)</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineminus">-  {</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineplus">+  for (int32_t i = 0; i &lt; count; i++) {</span>
<a href="#l3.155"></a><span id="l3.155">     nsIImapHeaderInfo *hdrInfo = m_hdrInfos[i];</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineminus">-    if (hdrInfo)</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineminus">-      hdrInfo-&gt;ResetCache();</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+    if (hdrInfo) hdrInfo-&gt;ResetCache();</span>
<a href="#l3.159"></a><span id="l3.159">   }</span>
<a href="#l3.160"></a><span id="l3.160">   m_nextFreeHdrInfo = 0;</span>
<a href="#l3.161"></a><span id="l3.161"> }</span>
<a href="#l3.162"></a><span id="l3.162"> </span>
<a href="#l3.163"></a><span id="l3.163" class="difflineminus">-void nsMsgImapHdrXferInfo::ReleaseAll()</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineminus">-{</span>
<a href="#l3.165"></a><span id="l3.165" class="difflineplus">+void nsMsgImapHdrXferInfo::ReleaseAll() {</span>
<a href="#l3.166"></a><span id="l3.166">   m_hdrInfos.Clear();</span>
<a href="#l3.167"></a><span id="l3.167">   m_nextFreeHdrInfo = 0;</span>
<a href="#l3.168"></a><span id="l3.168"> }</span>
<a href="#l3.169"></a><span id="l3.169"> </span>
<a href="#l3.170"></a><span id="l3.170"> NS_IMPL_ISUPPORTS(nsMsgImapLineDownloadCache, nsIImapHeaderInfo)</span>
<a href="#l3.171"></a><span id="l3.171"> </span>
<a href="#l3.172"></a><span id="l3.172"> // **** helper class for downloading line ****</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineminus">-nsMsgImapLineDownloadCache::nsMsgImapLineDownloadCache()</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineminus">-{</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineminus">-    fLineInfo = (msg_line_info *) PR_CALLOC(sizeof( msg_line_info));</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">-    fLineInfo-&gt;uidOfMessage = nsMsgKey_None;</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineminus">-    m_msgSize = 0;</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineminus">-}</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineminus">-</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineminus">-nsMsgImapLineDownloadCache::~nsMsgImapLineDownloadCache()</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineminus">-{</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineminus">-    PR_Free( fLineInfo);</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineminus">-}</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineminus">-</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineminus">-uint32_t nsMsgImapLineDownloadCache::CurrentUID()</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineminus">-{</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineminus">-    return fLineInfo-&gt;uidOfMessage;</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineminus">-}</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineminus">-</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineminus">-uint32_t nsMsgImapLineDownloadCache::SpaceAvailable()</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineminus">-{</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+nsMsgImapLineDownloadCache::nsMsgImapLineDownloadCache() {</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+  fLineInfo = (msg_line_info *)PR_CALLOC(sizeof(msg_line_info));</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+  fLineInfo-&gt;uidOfMessage = nsMsgKey_None;</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+  m_msgSize = 0;</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+}</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+nsMsgImapLineDownloadCache::~nsMsgImapLineDownloadCache() {</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+  PR_Free(fLineInfo);</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+}</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+uint32_t nsMsgImapLineDownloadCache::CurrentUID() {</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+  return fLineInfo-&gt;uidOfMessage;</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+}</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+uint32_t nsMsgImapLineDownloadCache::SpaceAvailable() {</span>
<a href="#l3.207"></a><span id="l3.207">   MOZ_ASSERT(kDownLoadCacheSize &gt;= m_bufferPos);</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineminus">-  if (kDownLoadCacheSize &lt;= m_bufferPos)</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineminus">-    return 0;</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+  if (kDownLoadCacheSize &lt;= m_bufferPos) return 0;</span>
<a href="#l3.211"></a><span id="l3.211">   return kDownLoadCacheSize - m_bufferPos;</span>
<a href="#l3.212"></a><span id="l3.212"> }</span>
<a href="#l3.213"></a><span id="l3.213"> </span>
<a href="#l3.214"></a><span id="l3.214" class="difflineminus">-msg_line_info *nsMsgImapLineDownloadCache::GetCurrentLineInfo()</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineminus">-{</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineminus">-  AppendBuffer(&quot;&quot;, 1); // null terminate the buffer</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+msg_line_info *nsMsgImapLineDownloadCache::GetCurrentLineInfo() {</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+  AppendBuffer(&quot;&quot;, 1);  // null terminate the buffer</span>
<a href="#l3.219"></a><span id="l3.219">   fLineInfo-&gt;adoptedMessageLine = GetBuffer();</span>
<a href="#l3.220"></a><span id="l3.220">   return fLineInfo;</span>
<a href="#l3.221"></a><span id="l3.221"> }</span>
<a href="#l3.222"></a><span id="l3.222"> </span>
<a href="#l3.223"></a><span id="l3.223" class="difflineminus">-NS_IMETHODIMP nsMsgImapLineDownloadCache::ResetCache()</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineminus">-{</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineminus">-    ResetWritePos();</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineminus">-}</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineminus">-</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineminus">-bool nsMsgImapLineDownloadCache::CacheEmpty()</span>
<a href="#l3.230"></a><span id="l3.230" class="difflineminus">-{</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineminus">-    return m_bufferPos == 0;</span>
<a href="#l3.232"></a><span id="l3.232" class="difflineminus">-}</span>
<a href="#l3.233"></a><span id="l3.233" class="difflineminus">-</span>
<a href="#l3.234"></a><span id="l3.234" class="difflineminus">-NS_IMETHODIMP nsMsgImapLineDownloadCache::CacheLine(const char *line, uint32_t uid)</span>
<a href="#l3.235"></a><span id="l3.235" class="difflineminus">-{</span>
<a href="#l3.236"></a><span id="l3.236" class="difflineminus">-    NS_ASSERTION((PL_strlen(line) + 1) &lt;= SpaceAvailable(),</span>
<a href="#l3.237"></a><span id="l3.237" class="difflineminus">-                 &quot;Oops... line length greater than space available&quot;);</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineminus">-</span>
<a href="#l3.239"></a><span id="l3.239" class="difflineminus">-    fLineInfo-&gt;uidOfMessage = uid;</span>
<a href="#l3.240"></a><span id="l3.240" class="difflineminus">-</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineminus">-    AppendString(line);</span>
<a href="#l3.242"></a><span id="l3.242" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.243"></a><span id="l3.243" class="difflineplus">+NS_IMETHODIMP nsMsgImapLineDownloadCache::ResetCache() {</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineplus">+  ResetWritePos();</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineplus">+}</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineplus">+</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineplus">+bool nsMsgImapLineDownloadCache::CacheEmpty() { return m_bufferPos == 0; }</span>
<a href="#l3.249"></a><span id="l3.249" class="difflineplus">+</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineplus">+NS_IMETHODIMP nsMsgImapLineDownloadCache::CacheLine(const char *line,</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineplus">+                                                    uint32_t uid) {</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineplus">+  NS_ASSERTION((PL_strlen(line) + 1) &lt;= SpaceAvailable(),</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineplus">+               &quot;Oops... line length greater than space available&quot;);</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineplus">+</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineplus">+  fLineInfo-&gt;uidOfMessage = uid;</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineplus">+</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineplus">+  AppendString(line);</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.259"></a><span id="l3.259"> }</span>
<a href="#l3.260"></a><span id="l3.260"> </span>
<a href="#l3.261"></a><span id="l3.261"> /* attribute nsMsgKey msgUid; */</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineminus">-NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgUid(nsMsgKey *aMsgUid)</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineminus">-{</span>
<a href="#l3.264"></a><span id="l3.264" class="difflineminus">-    *aMsgUid = fLineInfo-&gt;uidOfMessage;</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineminus">-}</span>
<a href="#l3.267"></a><span id="l3.267" class="difflineminus">-NS_IMETHODIMP nsMsgImapLineDownloadCache::SetMsgUid(nsMsgKey aMsgUid)</span>
<a href="#l3.268"></a><span id="l3.268" class="difflineminus">-{</span>
<a href="#l3.269"></a><span id="l3.269" class="difflineminus">-    fLineInfo-&gt;uidOfMessage = aMsgUid;</span>
<a href="#l3.270"></a><span id="l3.270" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.271"></a><span id="l3.271" class="difflineplus">+NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgUid(nsMsgKey *aMsgUid) {</span>
<a href="#l3.272"></a><span id="l3.272" class="difflineplus">+  *aMsgUid = fLineInfo-&gt;uidOfMessage;</span>
<a href="#l3.273"></a><span id="l3.273" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineplus">+}</span>
<a href="#l3.275"></a><span id="l3.275" class="difflineplus">+NS_IMETHODIMP nsMsgImapLineDownloadCache::SetMsgUid(nsMsgKey aMsgUid) {</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineplus">+  fLineInfo-&gt;uidOfMessage = aMsgUid;</span>
<a href="#l3.277"></a><span id="l3.277" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.278"></a><span id="l3.278"> }</span>
<a href="#l3.279"></a><span id="l3.279"> </span>
<a href="#l3.280"></a><span id="l3.280"> /* attribute long msgSize; */</span>
<a href="#l3.281"></a><span id="l3.281" class="difflineminus">-NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgSize(int32_t *aMsgSize)</span>
<a href="#l3.282"></a><span id="l3.282" class="difflineminus">-{</span>
<a href="#l3.283"></a><span id="l3.283" class="difflineminus">-    *aMsgSize = m_msgSize;</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineminus">-}</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineminus">-</span>
<a href="#l3.287"></a><span id="l3.287" class="difflineminus">-NS_IMETHODIMP nsMsgImapLineDownloadCache::SetMsgSize(int32_t aMsgSize)</span>
<a href="#l3.288"></a><span id="l3.288" class="difflineminus">-{</span>
<a href="#l3.289"></a><span id="l3.289" class="difflineminus">-    m_msgSize = aMsgSize;</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.291"></a><span id="l3.291" class="difflineplus">+NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgSize(int32_t *aMsgSize) {</span>
<a href="#l3.292"></a><span id="l3.292" class="difflineplus">+  *aMsgSize = m_msgSize;</span>
<a href="#l3.293"></a><span id="l3.293" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.294"></a><span id="l3.294" class="difflineplus">+}</span>
<a href="#l3.295"></a><span id="l3.295" class="difflineplus">+</span>
<a href="#l3.296"></a><span id="l3.296" class="difflineplus">+NS_IMETHODIMP nsMsgImapLineDownloadCache::SetMsgSize(int32_t aMsgSize) {</span>
<a href="#l3.297"></a><span id="l3.297" class="difflineplus">+  m_msgSize = aMsgSize;</span>
<a href="#l3.298"></a><span id="l3.298" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.299"></a><span id="l3.299"> }</span>
<a href="#l3.300"></a><span id="l3.300"> </span>
<a href="#l3.301"></a><span id="l3.301"> /* attribute string msgHdrs; */</span>
<a href="#l3.302"></a><span id="l3.302" class="difflineminus">-NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgHdrs(const char **aMsgHdrs)</span>
<a href="#l3.303"></a><span id="l3.303" class="difflineminus">-{</span>
<a href="#l3.304"></a><span id="l3.304" class="difflineplus">+NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgHdrs(const char **aMsgHdrs) {</span>
<a href="#l3.305"></a><span id="l3.305">   // this doesn't copy the string</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineminus">-    AppendBuffer(&quot;&quot;, 1); // null terminate the buffer</span>
<a href="#l3.307"></a><span id="l3.307" class="difflineminus">-    *aMsgHdrs = GetBuffer();</span>
<a href="#l3.308"></a><span id="l3.308" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.309"></a><span id="l3.309" class="difflineminus">-}</span>
<a href="#l3.310"></a><span id="l3.310" class="difflineminus">-</span>
<a href="#l3.311"></a><span id="l3.311" class="difflineminus">-/* the following macros actually implement addref, release and query interface for our component. */</span>
<a href="#l3.312"></a><span id="l3.312" class="difflineminus">-</span>
<a href="#l3.313"></a><span id="l3.313" class="difflineplus">+  AppendBuffer(&quot;&quot;, 1);  // null terminate the buffer</span>
<a href="#l3.314"></a><span id="l3.314" class="difflineplus">+  *aMsgHdrs = GetBuffer();</span>
<a href="#l3.315"></a><span id="l3.315" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.316"></a><span id="l3.316" class="difflineplus">+}</span>
<a href="#l3.317"></a><span id="l3.317" class="difflineplus">+</span>
<a href="#l3.318"></a><span id="l3.318" class="difflineplus">+// The following macros actually implement addref, release and query interface</span>
<a href="#l3.319"></a><span id="l3.319" class="difflineplus">+// for our component.</span>
<a href="#l3.320"></a><span id="l3.320"> NS_IMPL_ADDREF_INHERITED(nsImapProtocol, nsMsgProtocol)</span>
<a href="#l3.321"></a><span id="l3.321" class="difflineminus">-NS_IMPL_RELEASE_INHERITED(nsImapProtocol, nsMsgProtocol )</span>
<a href="#l3.322"></a><span id="l3.322" class="difflineplus">+NS_IMPL_RELEASE_INHERITED(nsImapProtocol, nsMsgProtocol)</span>
<a href="#l3.323"></a><span id="l3.323"> </span>
<a href="#l3.324"></a><span id="l3.324"> NS_INTERFACE_MAP_BEGIN(nsImapProtocol)</span>
<a href="#l3.325"></a><span id="l3.325" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIImapProtocol)</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY(nsIRunnable)</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY(nsIImapProtocol)</span>
<a href="#l3.328"></a><span id="l3.328" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY(nsIProtocolProxyCallback)</span>
<a href="#l3.329"></a><span id="l3.329" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY(nsIInputStreamCallback)</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)</span>
<a href="#l3.331"></a><span id="l3.331" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY(nsIImapProtocolSink)</span>
<a href="#l3.332"></a><span id="l3.332" class="difflineminus">-   NS_INTERFACE_MAP_ENTRY(nsIMsgAsyncPromptListener)</span>
<a href="#l3.333"></a><span id="l3.333" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIImapProtocol)</span>
<a href="#l3.334"></a><span id="l3.334" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY(nsIRunnable)</span>
<a href="#l3.335"></a><span id="l3.335" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY(nsIImapProtocol)</span>
<a href="#l3.336"></a><span id="l3.336" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY(nsIProtocolProxyCallback)</span>
<a href="#l3.337"></a><span id="l3.337" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY(nsIInputStreamCallback)</span>
<a href="#l3.338"></a><span id="l3.338" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY(nsIImapProtocolSink)</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineplus">+  NS_INTERFACE_MAP_ENTRY(nsIMsgAsyncPromptListener)</span>
<a href="#l3.341"></a><span id="l3.341"> NS_INTERFACE_MAP_END</span>
<a href="#l3.342"></a><span id="l3.342"> </span>
<a href="#l3.343"></a><span id="l3.343"> static int32_t gTooFastTime = 2;</span>
<a href="#l3.344"></a><span id="l3.344"> static int32_t gIdealTime = 4;</span>
<a href="#l3.345"></a><span id="l3.345"> static int32_t gChunkAddSize = 16384;</span>
<a href="#l3.346"></a><span id="l3.346"> static int32_t gChunkSize = 250000;</span>
<a href="#l3.347"></a><span id="l3.347" class="difflineminus">-static int32_t gChunkThreshold = gChunkSize + gChunkSize/2;</span>
<a href="#l3.348"></a><span id="l3.348" class="difflineplus">+static int32_t gChunkThreshold = gChunkSize + gChunkSize / 2;</span>
<a href="#l3.349"></a><span id="l3.349"> static bool gChunkSizeDirty = false;</span>
<a href="#l3.350"></a><span id="l3.350"> static bool gFetchByChunks = true;</span>
<a href="#l3.351"></a><span id="l3.351"> static bool gInitialized = false;</span>
<a href="#l3.352"></a><span id="l3.352"> static bool gHideUnusedNamespaces = true;</span>
<a href="#l3.353"></a><span id="l3.353"> static bool gHideOtherUsersFromList = false;</span>
<a href="#l3.354"></a><span id="l3.354"> static bool gUseEnvelopeCmd = false;</span>
<a href="#l3.355"></a><span id="l3.355"> static bool gUseLiteralPlus = true;</span>
<a href="#l3.356"></a><span id="l3.356"> static bool gExpungeAfterDelete = false;</span>
<a href="#l3.357"></a><span id="l3.357" class="difflineminus">-static bool gCheckDeletedBeforeExpunge = false; //bug 235004</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineplus">+static bool gCheckDeletedBeforeExpunge = false;  // bug 235004</span>
<a href="#l3.359"></a><span id="l3.359"> static int32_t gResponseTimeout = 60;</span>
<a href="#l3.360"></a><span id="l3.360"> static nsCString gForceSelectDetect;</span>
<a href="#l3.361"></a><span id="l3.361"> static nsTArray&lt;nsCString&gt; gForceSelectServersArray;</span>
<a href="#l3.362"></a><span id="l3.362"> static nsImapProtocol::TCPKeepalive gTCPKeepalive;</span>
<a href="#l3.363"></a><span id="l3.363"> </span>
<a href="#l3.364"></a><span id="l3.364"> // let delete model control expunging, i.e., don't ever expunge when the</span>
<a href="#l3.365"></a><span id="l3.365"> // user chooses the imap delete model, otherwise, expunge when over the</span>
<a href="#l3.366"></a><span id="l3.366"> // threshold. This is the normal TB behavior.</span>
<a href="#l3.367"></a><span id="l3.367" class="difflineat">@@ -341,126 +305,123 @@ static const int32_t kAutoExpungeOnThres</span>
<a href="#l3.368"></a><span id="l3.368"> static int32_t gExpungeOption = kAutoExpungeDeleteModel;</span>
<a href="#l3.369"></a><span id="l3.369"> static int32_t gExpungeThreshold = 20;</span>
<a href="#l3.370"></a><span id="l3.370"> </span>
<a href="#l3.371"></a><span id="l3.371"> const int32_t kAppBufSize = 100;</span>
<a href="#l3.372"></a><span id="l3.372"> // can't use static nsCString because it shows up as a leak.</span>
<a href="#l3.373"></a><span id="l3.373"> static char gAppName[kAppBufSize];</span>
<a href="#l3.374"></a><span id="l3.374"> static char gAppVersion[kAppBufSize];</span>
<a href="#l3.375"></a><span id="l3.375"> </span>
<a href="#l3.376"></a><span id="l3.376" class="difflineminus">-nsresult nsImapProtocol::GlobalInitialization(nsIPrefBranch *aPrefBranch)</span>
<a href="#l3.377"></a><span id="l3.377" class="difflineminus">-{</span>
<a href="#l3.378"></a><span id="l3.378" class="difflineminus">-    gInitialized = true;</span>
<a href="#l3.379"></a><span id="l3.379" class="difflineminus">-</span>
<a href="#l3.380"></a><span id="l3.380" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.chunk_fast&quot;, &amp;gTooFastTime);   // secs we read too little too fast</span>
<a href="#l3.381"></a><span id="l3.381" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.chunk_ideal&quot;, &amp;gIdealTime);    // secs we read enough in good time</span>
<a href="#l3.382"></a><span id="l3.382" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.chunk_add&quot;, &amp;gChunkAddSize);   // buffer size to add when wasting time</span>
<a href="#l3.383"></a><span id="l3.383" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.chunk_size&quot;, &amp;gChunkSize);</span>
<a href="#l3.384"></a><span id="l3.384" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.min_chunk_size_threshold&quot;,</span>
<a href="#l3.385"></a><span id="l3.385" class="difflineminus">-                            &amp;gChunkThreshold);</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineminus">-    aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.hide_other_users&quot;,</span>
<a href="#l3.387"></a><span id="l3.387" class="difflineminus">-                             &amp;gHideOtherUsersFromList);</span>
<a href="#l3.388"></a><span id="l3.388" class="difflineminus">-    aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.hide_unused_namespaces&quot;,</span>
<a href="#l3.389"></a><span id="l3.389" class="difflineminus">-                             &amp;gHideUnusedNamespaces);</span>
<a href="#l3.390"></a><span id="l3.390" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.noop_check_count&quot;,</span>
<a href="#l3.391"></a><span id="l3.391" class="difflineminus">-                            &amp;gPromoteNoopToCheckCount);</span>
<a href="#l3.392"></a><span id="l3.392" class="difflineminus">-    aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.use_envelope_cmd&quot;,</span>
<a href="#l3.393"></a><span id="l3.393" class="difflineminus">-                             &amp;gUseEnvelopeCmd);</span>
<a href="#l3.394"></a><span id="l3.394" class="difflineminus">-    aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.use_literal_plus&quot;, &amp;gUseLiteralPlus);</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineminus">-    aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.expunge_after_delete&quot;,</span>
<a href="#l3.396"></a><span id="l3.396" class="difflineminus">-                             &amp;gExpungeAfterDelete);</span>
<a href="#l3.397"></a><span id="l3.397" class="difflineminus">-    aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.check_deleted_before_expunge&quot;,</span>
<a href="#l3.398"></a><span id="l3.398" class="difflineminus">-                             &amp;gCheckDeletedBeforeExpunge);</span>
<a href="#l3.399"></a><span id="l3.399" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.expunge_option&quot;, &amp;gExpungeOption);</span>
<a href="#l3.400"></a><span id="l3.400" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mail.imap.expunge_threshold_number&quot;,</span>
<a href="#l3.401"></a><span id="l3.401" class="difflineminus">-                            &amp;gExpungeThreshold);</span>
<a href="#l3.402"></a><span id="l3.402" class="difflineminus">-    aPrefBranch-&gt;GetIntPref(&quot;mailnews.tcptimeout&quot;, &amp;gResponseTimeout);</span>
<a href="#l3.403"></a><span id="l3.403" class="difflineminus">-    aPrefBranch-&gt;GetCharPref(&quot;mail.imap.force_select_detect&quot;,</span>
<a href="#l3.404"></a><span id="l3.404" class="difflineminus">-                             gForceSelectDetect);</span>
<a href="#l3.405"></a><span id="l3.405" class="difflineminus">-    ParseString(gForceSelectDetect, ';', gForceSelectServersArray);</span>
<a href="#l3.406"></a><span id="l3.406" class="difflineminus">-</span>
<a href="#l3.407"></a><span id="l3.407" class="difflineminus">-    gTCPKeepalive.enabled.store(false, std::memory_order_relaxed);</span>
<a href="#l3.408"></a><span id="l3.408" class="difflineminus">-    gTCPKeepalive.idleTimeS.store(-1, std::memory_order_relaxed);</span>
<a href="#l3.409"></a><span id="l3.409" class="difflineminus">-    gTCPKeepalive.retryIntervalS.store(-1, std::memory_order_relaxed);</span>
<a href="#l3.410"></a><span id="l3.410" class="difflineminus">-</span>
<a href="#l3.411"></a><span id="l3.411" class="difflineminus">-    nsCOMPtr&lt;nsIXULAppInfo&gt; appInfo(do_GetService(XULAPPINFO_SERVICE_CONTRACTID));</span>
<a href="#l3.412"></a><span id="l3.412" class="difflineminus">-</span>
<a href="#l3.413"></a><span id="l3.413" class="difflineminus">-    if (appInfo)</span>
<a href="#l3.414"></a><span id="l3.414" class="difflineminus">-    {</span>
<a href="#l3.415"></a><span id="l3.415" class="difflineminus">-      nsCString appName, appVersion;</span>
<a href="#l3.416"></a><span id="l3.416" class="difflineminus">-      appInfo-&gt;GetName(appName);</span>
<a href="#l3.417"></a><span id="l3.417" class="difflineminus">-      appInfo-&gt;GetVersion(appVersion);</span>
<a href="#l3.418"></a><span id="l3.418" class="difflineminus">-      PL_strncpyz(gAppName, appName.get(), kAppBufSize);</span>
<a href="#l3.419"></a><span id="l3.419" class="difflineminus">-      PL_strncpyz(gAppVersion, appVersion.get(), kAppBufSize);</span>
<a href="#l3.420"></a><span id="l3.420" class="difflineminus">-    }</span>
<a href="#l3.421"></a><span id="l3.421" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.422"></a><span id="l3.422" class="difflineminus">-}</span>
<a href="#l3.423"></a><span id="l3.423" class="difflineminus">-</span>
<a href="#l3.424"></a><span id="l3.424" class="difflineminus">-class nsImapTransportEventSink final : public nsITransportEventSink</span>
<a href="#l3.425"></a><span id="l3.425" class="difflineminus">-{</span>
<a href="#l3.426"></a><span id="l3.426" class="difflineminus">-public:</span>
<a href="#l3.427"></a><span id="l3.427" class="difflineplus">+nsresult nsImapProtocol::GlobalInitialization(nsIPrefBranch *aPrefBranch) {</span>
<a href="#l3.428"></a><span id="l3.428" class="difflineplus">+  gInitialized = true;</span>
<a href="#l3.429"></a><span id="l3.429" class="difflineplus">+</span>
<a href="#l3.430"></a><span id="l3.430" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mail.imap.chunk_fast&quot;,</span>
<a href="#l3.431"></a><span id="l3.431" class="difflineplus">+                          &amp;gTooFastTime);  // secs we read too little too fast</span>
<a href="#l3.432"></a><span id="l3.432" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mail.imap.chunk_ideal&quot;,</span>
<a href="#l3.433"></a><span id="l3.433" class="difflineplus">+                          &amp;gIdealTime);  // secs we read enough in good time</span>
<a href="#l3.434"></a><span id="l3.434" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(</span>
<a href="#l3.435"></a><span id="l3.435" class="difflineplus">+      &quot;mail.imap.chunk_add&quot;,</span>
<a href="#l3.436"></a><span id="l3.436" class="difflineplus">+      &amp;gChunkAddSize);  // buffer size to add when wasting time</span>
<a href="#l3.437"></a><span id="l3.437" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mail.imap.chunk_size&quot;, &amp;gChunkSize);</span>
<a href="#l3.438"></a><span id="l3.438" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mail.imap.min_chunk_size_threshold&quot;,</span>
<a href="#l3.439"></a><span id="l3.439" class="difflineplus">+                          &amp;gChunkThreshold);</span>
<a href="#l3.440"></a><span id="l3.440" class="difflineplus">+  aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.hide_other_users&quot;,</span>
<a href="#l3.441"></a><span id="l3.441" class="difflineplus">+                           &amp;gHideOtherUsersFromList);</span>
<a href="#l3.442"></a><span id="l3.442" class="difflineplus">+  aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.hide_unused_namespaces&quot;,</span>
<a href="#l3.443"></a><span id="l3.443" class="difflineplus">+                           &amp;gHideUnusedNamespaces);</span>
<a href="#l3.444"></a><span id="l3.444" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mail.imap.noop_check_count&quot;,</span>
<a href="#l3.445"></a><span id="l3.445" class="difflineplus">+                          &amp;gPromoteNoopToCheckCount);</span>
<a href="#l3.446"></a><span id="l3.446" class="difflineplus">+  aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.use_envelope_cmd&quot;, &amp;gUseEnvelopeCmd);</span>
<a href="#l3.447"></a><span id="l3.447" class="difflineplus">+  aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.use_literal_plus&quot;, &amp;gUseLiteralPlus);</span>
<a href="#l3.448"></a><span id="l3.448" class="difflineplus">+  aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.expunge_after_delete&quot;,</span>
<a href="#l3.449"></a><span id="l3.449" class="difflineplus">+                           &amp;gExpungeAfterDelete);</span>
<a href="#l3.450"></a><span id="l3.450" class="difflineplus">+  aPrefBranch-&gt;GetBoolPref(&quot;mail.imap.check_deleted_before_expunge&quot;,</span>
<a href="#l3.451"></a><span id="l3.451" class="difflineplus">+                           &amp;gCheckDeletedBeforeExpunge);</span>
<a href="#l3.452"></a><span id="l3.452" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mail.imap.expunge_option&quot;, &amp;gExpungeOption);</span>
<a href="#l3.453"></a><span id="l3.453" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mail.imap.expunge_threshold_number&quot;,</span>
<a href="#l3.454"></a><span id="l3.454" class="difflineplus">+                          &amp;gExpungeThreshold);</span>
<a href="#l3.455"></a><span id="l3.455" class="difflineplus">+  aPrefBranch-&gt;GetIntPref(&quot;mailnews.tcptimeout&quot;, &amp;gResponseTimeout);</span>
<a href="#l3.456"></a><span id="l3.456" class="difflineplus">+  aPrefBranch-&gt;GetCharPref(&quot;mail.imap.force_select_detect&quot;, gForceSelectDetect);</span>
<a href="#l3.457"></a><span id="l3.457" class="difflineplus">+  ParseString(gForceSelectDetect, ';', gForceSelectServersArray);</span>
<a href="#l3.458"></a><span id="l3.458" class="difflineplus">+</span>
<a href="#l3.459"></a><span id="l3.459" class="difflineplus">+  gTCPKeepalive.enabled.store(false, std::memory_order_relaxed);</span>
<a href="#l3.460"></a><span id="l3.460" class="difflineplus">+  gTCPKeepalive.idleTimeS.store(-1, std::memory_order_relaxed);</span>
<a href="#l3.461"></a><span id="l3.461" class="difflineplus">+  gTCPKeepalive.retryIntervalS.store(-1, std::memory_order_relaxed);</span>
<a href="#l3.462"></a><span id="l3.462" class="difflineplus">+</span>
<a href="#l3.463"></a><span id="l3.463" class="difflineplus">+  nsCOMPtr&lt;nsIXULAppInfo&gt; appInfo(do_GetService(XULAPPINFO_SERVICE_CONTRACTID));</span>
<a href="#l3.464"></a><span id="l3.464" class="difflineplus">+</span>
<a href="#l3.465"></a><span id="l3.465" class="difflineplus">+  if (appInfo) {</span>
<a href="#l3.466"></a><span id="l3.466" class="difflineplus">+    nsCString appName, appVersion;</span>
<a href="#l3.467"></a><span id="l3.467" class="difflineplus">+    appInfo-&gt;GetName(appName);</span>
<a href="#l3.468"></a><span id="l3.468" class="difflineplus">+    appInfo-&gt;GetVersion(appVersion);</span>
<a href="#l3.469"></a><span id="l3.469" class="difflineplus">+    PL_strncpyz(gAppName, appName.get(), kAppBufSize);</span>
<a href="#l3.470"></a><span id="l3.470" class="difflineplus">+    PL_strncpyz(gAppVersion, appVersion.get(), kAppBufSize);</span>
<a href="#l3.471"></a><span id="l3.471" class="difflineplus">+  }</span>
<a href="#l3.472"></a><span id="l3.472" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.473"></a><span id="l3.473" class="difflineplus">+}</span>
<a href="#l3.474"></a><span id="l3.474" class="difflineplus">+</span>
<a href="#l3.475"></a><span id="l3.475" class="difflineplus">+class nsImapTransportEventSink final : public nsITransportEventSink {</span>
<a href="#l3.476"></a><span id="l3.476" class="difflineplus">+ public:</span>
<a href="#l3.477"></a><span id="l3.477">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l3.478"></a><span id="l3.478">   NS_DECL_NSITRANSPORTEVENTSINK</span>
<a href="#l3.479"></a><span id="l3.479"> </span>
<a href="#l3.480"></a><span id="l3.480" class="difflineminus">-private:</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineplus">+ private:</span>
<a href="#l3.482"></a><span id="l3.482">   friend class nsImapProtocol;</span>
<a href="#l3.483"></a><span id="l3.483"> </span>
<a href="#l3.484"></a><span id="l3.484">   virtual ~nsImapTransportEventSink() = default;</span>
<a href="#l3.485"></a><span id="l3.485">   nsresult ApplyTCPKeepalive(nsISocketTransport *aTransport);</span>
<a href="#l3.486"></a><span id="l3.486"> </span>
<a href="#l3.487"></a><span id="l3.487">   nsCOMPtr&lt;nsITransportEventSink&gt; m_proxy;</span>
<a href="#l3.488"></a><span id="l3.488"> };</span>
<a href="#l3.489"></a><span id="l3.489"> </span>
<a href="#l3.490"></a><span id="l3.490"> NS_IMPL_ISUPPORTS(nsImapTransportEventSink, nsITransportEventSink)</span>
<a href="#l3.491"></a><span id="l3.491"> </span>
<a href="#l3.492"></a><span id="l3.492"> NS_IMETHODIMP</span>
<a href="#l3.493"></a><span id="l3.493"> nsImapTransportEventSink::OnTransportStatus(nsITransport *aTransport,</span>
<a href="#l3.494"></a><span id="l3.494" class="difflineminus">-                                            nsresult aStatus,</span>
<a href="#l3.495"></a><span id="l3.495" class="difflineminus">-                                            int64_t aProgress,</span>
<a href="#l3.496"></a><span id="l3.496" class="difflineminus">-                                            int64_t aProgressMax)</span>
<a href="#l3.497"></a><span id="l3.497" class="difflineminus">-{</span>
<a href="#l3.498"></a><span id="l3.498" class="difflineplus">+                                            nsresult aStatus, int64_t aProgress,</span>
<a href="#l3.499"></a><span id="l3.499" class="difflineplus">+                                            int64_t aProgressMax) {</span>
<a href="#l3.500"></a><span id="l3.500">   if (aStatus == NS_NET_STATUS_CONNECTED_TO) {</span>
<a href="#l3.501"></a><span id="l3.501">     nsCOMPtr&lt;nsISocketTransport&gt; sockTrans(do_QueryInterface(aTransport));</span>
<a href="#l3.502"></a><span id="l3.502" class="difflineminus">-    if (!NS_WARN_IF(!sockTrans))</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineminus">-      ApplyTCPKeepalive(sockTrans);</span>
<a href="#l3.504"></a><span id="l3.504" class="difflineminus">-  }</span>
<a href="#l3.505"></a><span id="l3.505" class="difflineminus">-</span>
<a href="#l3.506"></a><span id="l3.506" class="difflineminus">-  if (NS_WARN_IF(!m_proxy))</span>
<a href="#l3.507"></a><span id="l3.507" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.508"></a><span id="l3.508" class="difflineplus">+    if (!NS_WARN_IF(!sockTrans)) ApplyTCPKeepalive(sockTrans);</span>
<a href="#l3.509"></a><span id="l3.509" class="difflineplus">+  }</span>
<a href="#l3.510"></a><span id="l3.510" class="difflineplus">+</span>
<a href="#l3.511"></a><span id="l3.511" class="difflineplus">+  if (NS_WARN_IF(!m_proxy)) return NS_OK;</span>
<a href="#l3.512"></a><span id="l3.512"> </span>
<a href="#l3.513"></a><span id="l3.513">   return m_proxy-&gt;OnTransportStatus(aTransport, aStatus, aProgress,</span>
<a href="#l3.514"></a><span id="l3.514">                                     aProgressMax);</span>
<a href="#l3.515"></a><span id="l3.515"> }</span>
<a href="#l3.516"></a><span id="l3.516"> </span>
<a href="#l3.517"></a><span id="l3.517" class="difflineminus">-nsresult</span>
<a href="#l3.518"></a><span id="l3.518" class="difflineminus">-nsImapTransportEventSink::ApplyTCPKeepalive(nsISocketTransport *aTransport)</span>
<a href="#l3.519"></a><span id="l3.519" class="difflineminus">-{</span>
<a href="#l3.520"></a><span id="l3.520" class="difflineplus">+nsresult nsImapTransportEventSink::ApplyTCPKeepalive(</span>
<a href="#l3.521"></a><span id="l3.521" class="difflineplus">+    nsISocketTransport *aTransport) {</span>
<a href="#l3.522"></a><span id="l3.522">   nsresult rv;</span>
<a href="#l3.523"></a><span id="l3.523"> </span>
<a href="#l3.524"></a><span id="l3.524">   bool kaEnabled = gTCPKeepalive.enabled.load(std::memory_order_relaxed);</span>
<a href="#l3.525"></a><span id="l3.525">   if (kaEnabled) {</span>
<a href="#l3.526"></a><span id="l3.526">     // TCP keepalive idle time, don't mistake with IMAP IDLE.</span>
<a href="#l3.527"></a><span id="l3.527" class="difflineminus">-    int32_t kaIdleTime = gTCPKeepalive.idleTimeS.load(std::memory_order_relaxed);</span>
<a href="#l3.528"></a><span id="l3.528" class="difflineminus">-    int32_t kaRetryInterval = gTCPKeepalive.retryIntervalS.load(std::memory_order_relaxed);</span>
<a href="#l3.529"></a><span id="l3.529" class="difflineplus">+    int32_t kaIdleTime =</span>
<a href="#l3.530"></a><span id="l3.530" class="difflineplus">+        gTCPKeepalive.idleTimeS.load(std::memory_order_relaxed);</span>
<a href="#l3.531"></a><span id="l3.531" class="difflineplus">+    int32_t kaRetryInterval =</span>
<a href="#l3.532"></a><span id="l3.532" class="difflineplus">+        gTCPKeepalive.retryIntervalS.load(std::memory_order_relaxed);</span>
<a href="#l3.533"></a><span id="l3.533"> </span>
<a href="#l3.534"></a><span id="l3.534">     if (kaIdleTime &lt; 0 || kaRetryInterval &lt; 0) {</span>
<a href="#l3.535"></a><span id="l3.535">       if (NS_WARN_IF(!net::gSocketTransportService))</span>
<a href="#l3.536"></a><span id="l3.536">         return NS_ERROR_NOT_INITIALIZED;</span>
<a href="#l3.537"></a><span id="l3.537">     }</span>
<a href="#l3.538"></a><span id="l3.538">     if (kaIdleTime &lt; 0) {</span>
<a href="#l3.539"></a><span id="l3.539">       rv = net::gSocketTransportService-&gt;GetKeepaliveIdleTime(&amp;kaIdleTime);</span>
<a href="#l3.540"></a><span id="l3.540">       if (NS_FAILED(rv)) {</span>
<a href="#l3.541"></a><span id="l3.541">         MOZ_LOG(IMAP, LogLevel::Error,</span>
<a href="#l3.542"></a><span id="l3.542">                 (&quot;GetKeepaliveIdleTime() failed, %&quot; PRIx32,</span>
<a href="#l3.543"></a><span id="l3.543">                  static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.544"></a><span id="l3.544">         return rv;</span>
<a href="#l3.545"></a><span id="l3.545">       }</span>
<a href="#l3.546"></a><span id="l3.546">     }</span>
<a href="#l3.547"></a><span id="l3.547">     if (kaRetryInterval &lt; 0) {</span>
<a href="#l3.548"></a><span id="l3.548" class="difflineminus">-      rv = net::gSocketTransportService-&gt;GetKeepaliveRetryInterval(&amp;kaRetryInterval);</span>
<a href="#l3.549"></a><span id="l3.549" class="difflineplus">+      rv = net::gSocketTransportService-&gt;GetKeepaliveRetryInterval(</span>
<a href="#l3.550"></a><span id="l3.550" class="difflineplus">+          &amp;kaRetryInterval);</span>
<a href="#l3.551"></a><span id="l3.551">       if (NS_FAILED(rv)) {</span>
<a href="#l3.552"></a><span id="l3.552">         MOZ_LOG(IMAP, LogLevel::Error,</span>
<a href="#l3.553"></a><span id="l3.553">                 (&quot;GetKeepaliveRetryInterval() failed, %&quot; PRIx32,</span>
<a href="#l3.554"></a><span id="l3.554">                  static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.555"></a><span id="l3.555">         return rv;</span>
<a href="#l3.556"></a><span id="l3.556">       }</span>
<a href="#l3.557"></a><span id="l3.557">     }</span>
<a href="#l3.558"></a><span id="l3.558"> </span>
<a href="#l3.559"></a><span id="l3.559" class="difflineat">@@ -474,39 +435,38 @@ nsImapTransportEventSink::ApplyTCPKeepal</span>
<a href="#l3.560"></a><span id="l3.560">       return rv;</span>
<a href="#l3.561"></a><span id="l3.561">     }</span>
<a href="#l3.562"></a><span id="l3.562">   }</span>
<a href="#l3.563"></a><span id="l3.563"> </span>
<a href="#l3.564"></a><span id="l3.564">   rv = aTransport-&gt;SetKeepaliveEnabled(kaEnabled);</span>
<a href="#l3.565"></a><span id="l3.565">   if (NS_FAILED(rv)) {</span>
<a href="#l3.566"></a><span id="l3.566">     MOZ_LOG(IMAP, LogLevel::Error,</span>
<a href="#l3.567"></a><span id="l3.567">             (&quot;SetKeepaliveEnabled(%s) failed, %&quot; PRIx32,</span>
<a href="#l3.568"></a><span id="l3.568" class="difflineminus">-             kaEnabled ? &quot;true&quot; : &quot;false&quot;,</span>
<a href="#l3.569"></a><span id="l3.569" class="difflineminus">-             static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.570"></a><span id="l3.570" class="difflineplus">+             kaEnabled ? &quot;true&quot; : &quot;false&quot;, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.571"></a><span id="l3.571">     return rv;</span>
<a href="#l3.572"></a><span id="l3.572">   }</span>
<a href="#l3.573"></a><span id="l3.573">   return NS_OK;</span>
<a href="#l3.574"></a><span id="l3.574"> }</span>
<a href="#l3.575"></a><span id="l3.575"> </span>
<a href="#l3.576"></a><span id="l3.576" class="difflineminus">-nsImapProtocol::nsImapProtocol() : nsMsgProtocol(nullptr),</span>
<a href="#l3.577"></a><span id="l3.577" class="difflineminus">-    m_dataAvailableMonitor(&quot;imapDataAvailable&quot;),</span>
<a href="#l3.578"></a><span id="l3.578" class="difflineminus">-    m_urlReadyToRunMonitor(&quot;imapUrlReadyToRun&quot;),</span>
<a href="#l3.579"></a><span id="l3.579" class="difflineminus">-    m_pseudoInterruptMonitor(&quot;imapPseudoInterrupt&quot;),</span>
<a href="#l3.580"></a><span id="l3.580" class="difflineminus">-    m_dataMemberMonitor(&quot;imapDataMember&quot;),</span>
<a href="#l3.581"></a><span id="l3.581" class="difflineminus">-    m_threadDeathMonitor(&quot;imapThreadDeath&quot;),</span>
<a href="#l3.582"></a><span id="l3.582" class="difflineminus">-    m_waitForBodyIdsMonitor(&quot;imapWaitForBodyIds&quot;),</span>
<a href="#l3.583"></a><span id="l3.583" class="difflineminus">-    m_fetchBodyListMonitor(&quot;imapFetchBodyList&quot;),</span>
<a href="#l3.584"></a><span id="l3.584" class="difflineminus">-    m_passwordReadyMonitor(&quot;imapPasswordReady&quot;),</span>
<a href="#l3.585"></a><span id="l3.585" class="difflineminus">-    mLock(&quot;nsImapProtocol.mLock&quot;),</span>
<a href="#l3.586"></a><span id="l3.586" class="difflineminus">-    m_parser(*this)</span>
<a href="#l3.587"></a><span id="l3.587" class="difflineminus">-{</span>
<a href="#l3.588"></a><span id="l3.588" class="difflineplus">+nsImapProtocol::nsImapProtocol()</span>
<a href="#l3.589"></a><span id="l3.589" class="difflineplus">+    : nsMsgProtocol(nullptr),</span>
<a href="#l3.590"></a><span id="l3.590" class="difflineplus">+      m_dataAvailableMonitor(&quot;imapDataAvailable&quot;),</span>
<a href="#l3.591"></a><span id="l3.591" class="difflineplus">+      m_urlReadyToRunMonitor(&quot;imapUrlReadyToRun&quot;),</span>
<a href="#l3.592"></a><span id="l3.592" class="difflineplus">+      m_pseudoInterruptMonitor(&quot;imapPseudoInterrupt&quot;),</span>
<a href="#l3.593"></a><span id="l3.593" class="difflineplus">+      m_dataMemberMonitor(&quot;imapDataMember&quot;),</span>
<a href="#l3.594"></a><span id="l3.594" class="difflineplus">+      m_threadDeathMonitor(&quot;imapThreadDeath&quot;),</span>
<a href="#l3.595"></a><span id="l3.595" class="difflineplus">+      m_waitForBodyIdsMonitor(&quot;imapWaitForBodyIds&quot;),</span>
<a href="#l3.596"></a><span id="l3.596" class="difflineplus">+      m_fetchBodyListMonitor(&quot;imapFetchBodyList&quot;),</span>
<a href="#l3.597"></a><span id="l3.597" class="difflineplus">+      m_passwordReadyMonitor(&quot;imapPasswordReady&quot;),</span>
<a href="#l3.598"></a><span id="l3.598" class="difflineplus">+      mLock(&quot;nsImapProtocol.mLock&quot;),</span>
<a href="#l3.599"></a><span id="l3.599" class="difflineplus">+      m_parser(*this) {</span>
<a href="#l3.600"></a><span id="l3.600">   m_urlInProgress = false;</span>
<a href="#l3.601"></a><span id="l3.601">   m_idle = false;</span>
<a href="#l3.602"></a><span id="l3.602">   m_retryUrlOnError = false;</span>
<a href="#l3.603"></a><span id="l3.603" class="difflineminus">-  m_useIdle = true; // by default, use it</span>
<a href="#l3.604"></a><span id="l3.604" class="difflineplus">+  m_useIdle = true;  // by default, use it</span>
<a href="#l3.605"></a><span id="l3.605">   m_useCondStore = true;</span>
<a href="#l3.606"></a><span id="l3.606">   m_useCompressDeflate = true;</span>
<a href="#l3.607"></a><span id="l3.607">   m_ignoreExpunges = false;</span>
<a href="#l3.608"></a><span id="l3.608">   m_prefAuthMethods = kCapabilityUndefined;</span>
<a href="#l3.609"></a><span id="l3.609">   m_failedAuthMethods = 0;</span>
<a href="#l3.610"></a><span id="l3.610">   m_currentAuthMethod = kCapabilityUndefined;</span>
<a href="#l3.611"></a><span id="l3.611">   m_socketType = nsMsgSocketType::trySTARTTLS;</span>
<a href="#l3.612"></a><span id="l3.612">   m_connectionStatus = NS_OK;</span>
<a href="#l3.613"></a><span id="l3.613" class="difflineat">@@ -515,33 +475,31 @@ nsImapProtocol::nsImapProtocol() : nsMsg</span>
<a href="#l3.614"></a><span id="l3.614">   m_fetchBodyIdList = nullptr;</span>
<a href="#l3.615"></a><span id="l3.615">   m_isGmailServer = false;</span>
<a href="#l3.616"></a><span id="l3.616">   m_fetchingWholeMessage = false;</span>
<a href="#l3.617"></a><span id="l3.617"> </span>
<a href="#l3.618"></a><span id="l3.618">   nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l3.619"></a><span id="l3.619">   NS_ASSERTION(prefBranch, &quot;FAILED to create the preference service&quot;);</span>
<a href="#l3.620"></a><span id="l3.620"> </span>
<a href="#l3.621"></a><span id="l3.621">   // read in the accept languages preference</span>
<a href="#l3.622"></a><span id="l3.622" class="difflineminus">-  if (prefBranch)</span>
<a href="#l3.623"></a><span id="l3.623" class="difflineminus">-  {</span>
<a href="#l3.624"></a><span id="l3.624" class="difflineminus">-    if (!gInitialized)</span>
<a href="#l3.625"></a><span id="l3.625" class="difflineminus">-      GlobalInitialization(prefBranch);</span>
<a href="#l3.626"></a><span id="l3.626" class="difflineplus">+  if (prefBranch) {</span>
<a href="#l3.627"></a><span id="l3.627" class="difflineplus">+    if (!gInitialized) GlobalInitialization(prefBranch);</span>
<a href="#l3.628"></a><span id="l3.628"> </span>
<a href="#l3.629"></a><span id="l3.629">     nsCOMPtr&lt;nsIPrefLocalizedString&gt; prefString;</span>
<a href="#l3.630"></a><span id="l3.630">     prefBranch-&gt;GetComplexValue(&quot;intl.accept_languages&quot;,</span>
<a href="#l3.631"></a><span id="l3.631">                                 NS_GET_IID(nsIPrefLocalizedString),</span>
<a href="#l3.632"></a><span id="l3.632">                                 getter_AddRefs(prefString));</span>
<a href="#l3.633"></a><span id="l3.633" class="difflineminus">-    if (prefString)</span>
<a href="#l3.634"></a><span id="l3.634" class="difflineminus">-      prefString-&gt;ToString(getter_Copies(mAcceptLanguages));</span>
<a href="#l3.635"></a><span id="l3.635" class="difflineplus">+    if (prefString) prefString-&gt;ToString(getter_Copies(mAcceptLanguages));</span>
<a href="#l3.636"></a><span id="l3.636"> </span>
<a href="#l3.637"></a><span id="l3.637">     nsCString customDBHeaders;</span>
<a href="#l3.638"></a><span id="l3.638">     prefBranch-&gt;GetCharPref(&quot;mailnews.customDBHeaders&quot;, customDBHeaders);</span>
<a href="#l3.639"></a><span id="l3.639"> </span>
<a href="#l3.640"></a><span id="l3.640">     ParseString(customDBHeaders, ' ', mCustomDBHeaders);</span>
<a href="#l3.641"></a><span id="l3.641" class="difflineminus">-    prefBranch-&gt;GetBoolPref(&quot;mailnews.display.prefer_plaintext&quot;, &amp;m_preferPlainText);</span>
<a href="#l3.642"></a><span id="l3.642" class="difflineplus">+    prefBranch-&gt;GetBoolPref(&quot;mailnews.display.prefer_plaintext&quot;,</span>
<a href="#l3.643"></a><span id="l3.643" class="difflineplus">+                            &amp;m_preferPlainText);</span>
<a href="#l3.644"></a><span id="l3.644"> </span>
<a href="#l3.645"></a><span id="l3.645">     nsAutoCString customHeaders;</span>
<a href="#l3.646"></a><span id="l3.646">     prefBranch-&gt;GetCharPref(&quot;mailnews.customHeaders&quot;, customHeaders);</span>
<a href="#l3.647"></a><span id="l3.647">     customHeaders.StripWhitespace();</span>
<a href="#l3.648"></a><span id="l3.648">     ParseString(customHeaders, ':', mCustomHeaders);</span>
<a href="#l3.649"></a><span id="l3.649"> </span>
<a href="#l3.650"></a><span id="l3.650">     nsresult rv;</span>
<a href="#l3.651"></a><span id="l3.651">     bool bVal = false;</span>
<a href="#l3.652"></a><span id="l3.652" class="difflineat">@@ -549,30 +507,30 @@ nsImapProtocol::nsImapProtocol() : nsMsg</span>
<a href="#l3.653"></a><span id="l3.653">     if (NS_SUCCEEDED(rv))</span>
<a href="#l3.654"></a><span id="l3.654">       gTCPKeepalive.enabled.store(bVal, std::memory_order_relaxed);</span>
<a href="#l3.655"></a><span id="l3.655"> </span>
<a href="#l3.656"></a><span id="l3.656">     if (bVal) {</span>
<a href="#l3.657"></a><span id="l3.657">       int32_t val;</span>
<a href="#l3.658"></a><span id="l3.658">       // TCP keepalive idle time, don't mistake with IMAP IDLE.</span>
<a href="#l3.659"></a><span id="l3.659">       rv = prefBranch-&gt;GetIntPref(&quot;mail.imap.tcp_keepalive.idle_time&quot;, &amp;val);</span>
<a href="#l3.660"></a><span id="l3.660">       if (NS_SUCCEEDED(rv) &amp;&amp; val &gt;= 0)</span>
<a href="#l3.661"></a><span id="l3.661" class="difflineminus">-        gTCPKeepalive.idleTimeS.store(std::min(std::max(val, 1),</span>
<a href="#l3.662"></a><span id="l3.662" class="difflineminus">-                                      net::kMaxTCPKeepIdle),</span>
<a href="#l3.663"></a><span id="l3.663" class="difflineminus">-                                      std::memory_order_relaxed);</span>
<a href="#l3.664"></a><span id="l3.664" class="difflineplus">+        gTCPKeepalive.idleTimeS.store(</span>
<a href="#l3.665"></a><span id="l3.665" class="difflineplus">+            std::min(std::max(val, 1), net::kMaxTCPKeepIdle),</span>
<a href="#l3.666"></a><span id="l3.666" class="difflineplus">+            std::memory_order_relaxed);</span>
<a href="#l3.667"></a><span id="l3.667"> </span>
<a href="#l3.668"></a><span id="l3.668">       rv = prefBranch-&gt;GetIntPref(&quot;mail.imap.tcp_keepalive.retry_interval&quot;,</span>
<a href="#l3.669"></a><span id="l3.669">                                   &amp;val);</span>
<a href="#l3.670"></a><span id="l3.670">       if (NS_SUCCEEDED(rv) &amp;&amp; val &gt;= 0)</span>
<a href="#l3.671"></a><span id="l3.671" class="difflineminus">-        gTCPKeepalive.retryIntervalS.store(std::min(std::max(val, 1),</span>
<a href="#l3.672"></a><span id="l3.672" class="difflineminus">-                                           net::kMaxTCPKeepIntvl),</span>
<a href="#l3.673"></a><span id="l3.673" class="difflineminus">-                                           std::memory_order_relaxed);</span>
<a href="#l3.674"></a><span id="l3.674" class="difflineminus">-    }</span>
<a href="#l3.675"></a><span id="l3.675" class="difflineminus">-  }</span>
<a href="#l3.676"></a><span id="l3.676" class="difflineminus">-</span>
<a href="#l3.677"></a><span id="l3.677" class="difflineminus">-    // ***** Thread support *****</span>
<a href="#l3.678"></a><span id="l3.678" class="difflineplus">+        gTCPKeepalive.retryIntervalS.store(</span>
<a href="#l3.679"></a><span id="l3.679" class="difflineplus">+            std::min(std::max(val, 1), net::kMaxTCPKeepIntvl),</span>
<a href="#l3.680"></a><span id="l3.680" class="difflineplus">+            std::memory_order_relaxed);</span>
<a href="#l3.681"></a><span id="l3.681" class="difflineplus">+    }</span>
<a href="#l3.682"></a><span id="l3.682" class="difflineplus">+  }</span>
<a href="#l3.683"></a><span id="l3.683" class="difflineplus">+</span>
<a href="#l3.684"></a><span id="l3.684" class="difflineplus">+  // ***** Thread support *****</span>
<a href="#l3.685"></a><span id="l3.685">   m_thread = nullptr;</span>
<a href="#l3.686"></a><span id="l3.686">   m_imapThreadIsRunning = false;</span>
<a href="#l3.687"></a><span id="l3.687">   m_currentServerCommandTagNumber = 0;</span>
<a href="#l3.688"></a><span id="l3.688">   m_active = false;</span>
<a href="#l3.689"></a><span id="l3.689">   m_folderNeedsSubscribing = false;</span>
<a href="#l3.690"></a><span id="l3.690">   m_folderNeedsACLRefreshed = false;</span>
<a href="#l3.691"></a><span id="l3.691">   m_threadShouldDie = false;</span>
<a href="#l3.692"></a><span id="l3.692">   m_inThreadShouldDie = false;</span>
<a href="#l3.693"></a><span id="l3.693" class="difflineat">@@ -601,21 +559,23 @@ nsImapProtocol::nsImapProtocol() : nsMsg</span>
<a href="#l3.694"></a><span id="l3.694">   m_fetchBodyListIsNew = false;</span>
<a href="#l3.695"></a><span id="l3.695">   m_flagChangeCount = 0;</span>
<a href="#l3.696"></a><span id="l3.696">   m_lastCheckTime = PR_Now();</span>
<a href="#l3.697"></a><span id="l3.697"> </span>
<a href="#l3.698"></a><span id="l3.698">   m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.699"></a><span id="l3.699">   m_discoveryStatus = eContinue;</span>
<a href="#l3.700"></a><span id="l3.700"> </span>
<a href="#l3.701"></a><span id="l3.701">   // m_dataOutputBuf is used by Send Data</span>
<a href="#l3.702"></a><span id="l3.702" class="difflineminus">-  m_dataOutputBuf = (char *) PR_CALLOC(sizeof(char) * OUTPUT_BUFFER_SIZE);</span>
<a href="#l3.703"></a><span id="l3.703" class="difflineplus">+  m_dataOutputBuf = (char *)PR_CALLOC(sizeof(char) * OUTPUT_BUFFER_SIZE);</span>
<a href="#l3.704"></a><span id="l3.704">   m_allocatedSize = OUTPUT_BUFFER_SIZE;</span>
<a href="#l3.705"></a><span id="l3.705"> </span>
<a href="#l3.706"></a><span id="l3.706">   // used to buffer incoming data by ReadNextLine</span>
<a href="#l3.707"></a><span id="l3.707" class="difflineminus">-  m_inputStreamBuffer = new nsMsgLineStreamBuffer(OUTPUT_BUFFER_SIZE, true /* allocate new lines */, false /* leave CRLFs on the returned string */);</span>
<a href="#l3.708"></a><span id="l3.708" class="difflineplus">+  m_inputStreamBuffer = new nsMsgLineStreamBuffer(</span>
<a href="#l3.709"></a><span id="l3.709" class="difflineplus">+      OUTPUT_BUFFER_SIZE, true /* allocate new lines */,</span>
<a href="#l3.710"></a><span id="l3.710" class="difflineplus">+      false /* leave CRLFs on the returned string */);</span>
<a href="#l3.711"></a><span id="l3.711">   m_currentBiffState = nsIMsgFolder::nsMsgBiffState_Unknown;</span>
<a href="#l3.712"></a><span id="l3.712">   m_progressStringName.Truncate();</span>
<a href="#l3.713"></a><span id="l3.713">   m_stringIndex = IMAP_EMPTY_STRING_INDEX;</span>
<a href="#l3.714"></a><span id="l3.714">   m_progressExpectedNumber = 0;</span>
<a href="#l3.715"></a><span id="l3.715">   memset(m_progressCurrentNumber, 0, sizeof m_progressCurrentNumber);</span>
<a href="#l3.716"></a><span id="l3.716"> </span>
<a href="#l3.717"></a><span id="l3.717">   // since these are embedded in the nsImapProtocol object, but passed</span>
<a href="#l3.718"></a><span id="l3.718">   // through proxied xpcom methods, just AddRef them here.</span>
<a href="#l3.719"></a><span id="l3.719" class="difflineat">@@ -626,50 +586,46 @@ nsImapProtocol::nsImapProtocol() : nsMsg</span>
<a href="#l3.720"></a><span id="l3.720">   m_autoSubscribe = true;</span>
<a href="#l3.721"></a><span id="l3.721">   m_autoUnsubscribe = true;</span>
<a href="#l3.722"></a><span id="l3.722">   m_autoSubscribeOnOpen = true;</span>
<a href="#l3.723"></a><span id="l3.723">   m_deletableChildren = nullptr;</span>
<a href="#l3.724"></a><span id="l3.724"> </span>
<a href="#l3.725"></a><span id="l3.725">   mFolderLastModSeq = 0;</span>
<a href="#l3.726"></a><span id="l3.726"> </span>
<a href="#l3.727"></a><span id="l3.727">   Configure(gTooFastTime, gIdealTime, gChunkAddSize, gChunkSize,</span>
<a href="#l3.728"></a><span id="l3.728" class="difflineminus">-                    gChunkThreshold, gFetchByChunks);</span>
<a href="#l3.729"></a><span id="l3.729" class="difflineplus">+            gChunkThreshold, gFetchByChunks);</span>
<a href="#l3.730"></a><span id="l3.730">   m_forceSelect = false;</span>
<a href="#l3.731"></a><span id="l3.731"> }</span>
<a href="#l3.732"></a><span id="l3.732"> </span>
<a href="#l3.733"></a><span id="l3.733"> nsresult nsImapProtocol::Configure(int32_t TooFastTime, int32_t IdealTime,</span>
<a href="#l3.734"></a><span id="l3.734" class="difflineminus">-                  int32_t ChunkAddSize, int32_t ChunkSize, int32_t ChunkThreshold,</span>
<a href="#l3.735"></a><span id="l3.735" class="difflineminus">-                  bool FetchByChunks)</span>
<a href="#l3.736"></a><span id="l3.736" class="difflineminus">-{</span>
<a href="#l3.737"></a><span id="l3.737" class="difflineplus">+                                   int32_t ChunkAddSize, int32_t ChunkSize,</span>
<a href="#l3.738"></a><span id="l3.738" class="difflineplus">+                                   int32_t ChunkThreshold, bool FetchByChunks) {</span>
<a href="#l3.739"></a><span id="l3.739">   m_tooFastTime = TooFastTime;    // secs we read too little too fast</span>
<a href="#l3.740"></a><span id="l3.740" class="difflineminus">-  m_idealTime = IdealTime;    // secs we read enough in good time</span>
<a href="#l3.741"></a><span id="l3.741" class="difflineminus">-  m_chunkAddSize = ChunkAddSize;    // buffer size to add when wasting time</span>
<a href="#l3.742"></a><span id="l3.742" class="difflineplus">+  m_idealTime = IdealTime;        // secs we read enough in good time</span>
<a href="#l3.743"></a><span id="l3.743" class="difflineplus">+  m_chunkAddSize = ChunkAddSize;  // buffer size to add when wasting time</span>
<a href="#l3.744"></a><span id="l3.744">   m_chunkStartSize = m_chunkSize = ChunkSize;</span>
<a href="#l3.745"></a><span id="l3.745">   m_chunkThreshold = ChunkThreshold;</span>
<a href="#l3.746"></a><span id="l3.746">   m_fetchByChunks = FetchByChunks;</span>
<a href="#l3.747"></a><span id="l3.747"> </span>
<a href="#l3.748"></a><span id="l3.748">   return NS_OK;</span>
<a href="#l3.749"></a><span id="l3.749"> }</span>
<a href="#l3.750"></a><span id="l3.750"> </span>
<a href="#l3.751"></a><span id="l3.751" class="difflineminus">-</span>
<a href="#l3.752"></a><span id="l3.752"> NS_IMETHODIMP</span>
<a href="#l3.753"></a><span id="l3.753"> nsImapProtocol::Initialize(nsIImapHostSessionList *aHostSessionList,</span>
<a href="#l3.754"></a><span id="l3.754" class="difflineminus">-                           nsIImapIncomingServer *aServer)</span>
<a href="#l3.755"></a><span id="l3.755" class="difflineminus">-{</span>
<a href="#l3.756"></a><span id="l3.756" class="difflineminus">-  NS_ASSERTION(aHostSessionList &amp;&amp; aServer,</span>
<a href="#l3.757"></a><span id="l3.757" class="difflineminus">-    &quot;oops...trying to initialize with a null host session list or server!&quot;);</span>
<a href="#l3.758"></a><span id="l3.758" class="difflineminus">-  if (!aHostSessionList || !aServer)</span>
<a href="#l3.759"></a><span id="l3.759" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.760"></a><span id="l3.760" class="difflineplus">+                           nsIImapIncomingServer *aServer) {</span>
<a href="#l3.761"></a><span id="l3.761" class="difflineplus">+  NS_ASSERTION(</span>
<a href="#l3.762"></a><span id="l3.762" class="difflineplus">+      aHostSessionList &amp;&amp; aServer,</span>
<a href="#l3.763"></a><span id="l3.763" class="difflineplus">+      &quot;oops...trying to initialize with a null host session list or server!&quot;);</span>
<a href="#l3.764"></a><span id="l3.764" class="difflineplus">+  if (!aHostSessionList || !aServer) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.765"></a><span id="l3.765"> </span>
<a href="#l3.766"></a><span id="l3.766">   nsresult rv = m_downloadLineCache-&gt;GrowBuffer(kDownLoadCacheSize);</span>
<a href="#l3.767"></a><span id="l3.767">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.768"></a><span id="l3.768"> </span>
<a href="#l3.769"></a><span id="l3.769">   m_flagState = new nsImapFlagAndUidState(kImapFlagAndUidStateSize);</span>
<a href="#l3.770"></a><span id="l3.770" class="difflineminus">-  if (!m_flagState)</span>
<a href="#l3.771"></a><span id="l3.771" class="difflineminus">-    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.772"></a><span id="l3.772" class="difflineplus">+  if (!m_flagState) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.773"></a><span id="l3.773"> </span>
<a href="#l3.774"></a><span id="l3.774">   aServer-&gt;GetUseIdle(&amp;m_useIdle);</span>
<a href="#l3.775"></a><span id="l3.775">   aServer-&gt;GetForceSelect(m_forceSelectValue);</span>
<a href="#l3.776"></a><span id="l3.776">   aServer-&gt;GetUseCondStore(&amp;m_useCondStore);</span>
<a href="#l3.777"></a><span id="l3.777">   aServer-&gt;GetUseCompressDeflate(&amp;m_useCompressDeflate);</span>
<a href="#l3.778"></a><span id="l3.778"> </span>
<a href="#l3.779"></a><span id="l3.779">   m_hostSessionList = aHostSessionList;</span>
<a href="#l3.780"></a><span id="l3.780">   m_parser.SetHostSessionList(aHostSessionList);</span>
<a href="#l3.781"></a><span id="l3.781" class="difflineat">@@ -678,733 +634,675 @@ nsImapProtocol::Initialize(nsIImapHostSe</span>
<a href="#l3.782"></a><span id="l3.782">   // Initialize the empty mime part string on the main thread.</span>
<a href="#l3.783"></a><span id="l3.783">   rv = IMAPGetStringBundle(getter_AddRefs(m_bundle));</span>
<a href="#l3.784"></a><span id="l3.784">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.785"></a><span id="l3.785"> </span>
<a href="#l3.786"></a><span id="l3.786">   rv = m_bundle-&gt;GetStringFromName(&quot;imapEmptyMimePart&quot;, m_emptyMimePartString);</span>
<a href="#l3.787"></a><span id="l3.787">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.788"></a><span id="l3.788"> </span>
<a href="#l3.789"></a><span id="l3.789">   // Now initialize the thread for the connection</span>
<a href="#l3.790"></a><span id="l3.790" class="difflineminus">-  if (m_thread == nullptr)</span>
<a href="#l3.791"></a><span id="l3.791" class="difflineminus">-  {</span>
<a href="#l3.792"></a><span id="l3.792" class="difflineplus">+  if (m_thread == nullptr) {</span>
<a href="#l3.793"></a><span id="l3.793">     nsresult rv = NS_NewThread(getter_AddRefs(m_iThread), this);</span>
<a href="#l3.794"></a><span id="l3.794" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.795"></a><span id="l3.795" class="difflineminus">-    {</span>
<a href="#l3.796"></a><span id="l3.796" class="difflineplus">+    if (NS_FAILED(rv)) {</span>
<a href="#l3.797"></a><span id="l3.797">       NS_ASSERTION(m_iThread, &quot;Unable to create imap thread.&quot;);</span>
<a href="#l3.798"></a><span id="l3.798">       return rv;</span>
<a href="#l3.799"></a><span id="l3.799">     }</span>
<a href="#l3.800"></a><span id="l3.800">     m_iThread-&gt;GetPRThread(&amp;m_thread);</span>
<a href="#l3.801"></a><span id="l3.801" class="difflineminus">-</span>
<a href="#l3.802"></a><span id="l3.802">   }</span>
<a href="#l3.803"></a><span id="l3.803">   return NS_OK;</span>
<a href="#l3.804"></a><span id="l3.804"> }</span>
<a href="#l3.805"></a><span id="l3.805"> </span>
<a href="#l3.806"></a><span id="l3.806" class="difflineminus">-nsImapProtocol::~nsImapProtocol()</span>
<a href="#l3.807"></a><span id="l3.807" class="difflineminus">-{</span>
<a href="#l3.808"></a><span id="l3.808" class="difflineplus">+nsImapProtocol::~nsImapProtocol() {</span>
<a href="#l3.809"></a><span id="l3.809">   PR_Free(m_fetchBodyIdList);</span>
<a href="#l3.810"></a><span id="l3.810"> </span>
<a href="#l3.811"></a><span id="l3.811">   PR_Free(m_dataOutputBuf);</span>
<a href="#l3.812"></a><span id="l3.812"> </span>
<a href="#l3.813"></a><span id="l3.813">   // **** We must be out of the thread main loop function</span>
<a href="#l3.814"></a><span id="l3.814">   NS_ASSERTION(!m_imapThreadIsRunning, &quot;Oops, thread is still running.&quot;);</span>
<a href="#l3.815"></a><span id="l3.815"> }</span>
<a href="#l3.816"></a><span id="l3.816"> </span>
<a href="#l3.817"></a><span id="l3.817" class="difflineminus">-const nsCString&amp;</span>
<a href="#l3.818"></a><span id="l3.818" class="difflineminus">-nsImapProtocol::GetImapHostName()</span>
<a href="#l3.819"></a><span id="l3.819" class="difflineminus">-{</span>
<a href="#l3.820"></a><span id="l3.820" class="difflineminus">-  if (m_runningUrl &amp;&amp; m_hostName.IsEmpty())</span>
<a href="#l3.821"></a><span id="l3.821" class="difflineminus">-  {</span>
<a href="#l3.822"></a><span id="l3.822" class="difflineplus">+const nsCString &amp;nsImapProtocol::GetImapHostName() {</span>
<a href="#l3.823"></a><span id="l3.823" class="difflineplus">+  if (m_runningUrl &amp;&amp; m_hostName.IsEmpty()) {</span>
<a href="#l3.824"></a><span id="l3.824">     nsCOMPtr&lt;nsIURI&gt; url = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.825"></a><span id="l3.825">     url-&gt;GetAsciiHost(m_hostName);</span>
<a href="#l3.826"></a><span id="l3.826">   }</span>
<a href="#l3.827"></a><span id="l3.827"> </span>
<a href="#l3.828"></a><span id="l3.828">   return m_hostName;</span>
<a href="#l3.829"></a><span id="l3.829"> }</span>
<a href="#l3.830"></a><span id="l3.830"> </span>
<a href="#l3.831"></a><span id="l3.831" class="difflineminus">-const nsCString&amp;</span>
<a href="#l3.832"></a><span id="l3.832" class="difflineminus">-nsImapProtocol::GetImapUserName()</span>
<a href="#l3.833"></a><span id="l3.833" class="difflineminus">-{</span>
<a href="#l3.834"></a><span id="l3.834" class="difflineminus">-  if (m_userName.IsEmpty() &amp;&amp; m_imapServerSink)</span>
<a href="#l3.835"></a><span id="l3.835" class="difflineminus">-  {</span>
<a href="#l3.836"></a><span id="l3.836" class="difflineplus">+const nsCString &amp;nsImapProtocol::GetImapUserName() {</span>
<a href="#l3.837"></a><span id="l3.837" class="difflineplus">+  if (m_userName.IsEmpty() &amp;&amp; m_imapServerSink) {</span>
<a href="#l3.838"></a><span id="l3.838">     m_imapServerSink-&gt;GetOriginalUsername(m_userName);</span>
<a href="#l3.839"></a><span id="l3.839">   }</span>
<a href="#l3.840"></a><span id="l3.840">   return m_userName;</span>
<a href="#l3.841"></a><span id="l3.841"> }</span>
<a href="#l3.842"></a><span id="l3.842"> </span>
<a href="#l3.843"></a><span id="l3.843" class="difflineminus">-const char*</span>
<a href="#l3.844"></a><span id="l3.844" class="difflineminus">-nsImapProtocol::GetImapServerKey()</span>
<a href="#l3.845"></a><span id="l3.845" class="difflineminus">-{</span>
<a href="#l3.846"></a><span id="l3.846" class="difflineminus">-  if (m_serverKey.IsEmpty() &amp;&amp; m_imapServerSink)</span>
<a href="#l3.847"></a><span id="l3.847" class="difflineminus">-  {</span>
<a href="#l3.848"></a><span id="l3.848" class="difflineplus">+const char *nsImapProtocol::GetImapServerKey() {</span>
<a href="#l3.849"></a><span id="l3.849" class="difflineplus">+  if (m_serverKey.IsEmpty() &amp;&amp; m_imapServerSink) {</span>
<a href="#l3.850"></a><span id="l3.850">     m_imapServerSink-&gt;GetServerKey(m_serverKey);</span>
<a href="#l3.851"></a><span id="l3.851">   }</span>
<a href="#l3.852"></a><span id="l3.852">   return m_serverKey.get();</span>
<a href="#l3.853"></a><span id="l3.853"> }</span>
<a href="#l3.854"></a><span id="l3.854"> </span>
<a href="#l3.855"></a><span id="l3.855" class="difflineminus">-nsresult</span>
<a href="#l3.856"></a><span id="l3.856" class="difflineminus">-nsImapProtocol::SetupSinkProxy()</span>
<a href="#l3.857"></a><span id="l3.857" class="difflineminus">-{</span>
<a href="#l3.858"></a><span id="l3.858" class="difflineplus">+nsresult nsImapProtocol::SetupSinkProxy() {</span>
<a href="#l3.859"></a><span id="l3.859">   nsresult res;</span>
<a href="#l3.860"></a><span id="l3.860" class="difflineminus">-  if (m_runningUrl)</span>
<a href="#l3.861"></a><span id="l3.861" class="difflineminus">-  {</span>
<a href="#l3.862"></a><span id="l3.862" class="difflineminus">-    if (!m_imapMailFolderSink)</span>
<a href="#l3.863"></a><span id="l3.863" class="difflineminus">-    {</span>
<a href="#l3.864"></a><span id="l3.864" class="difflineplus">+  if (m_runningUrl) {</span>
<a href="#l3.865"></a><span id="l3.865" class="difflineplus">+    if (!m_imapMailFolderSink) {</span>
<a href="#l3.866"></a><span id="l3.866">       nsCOMPtr&lt;nsIImapMailFolderSink&gt; aImapMailFolderSink;</span>
<a href="#l3.867"></a><span id="l3.867" class="difflineminus">-      (void) m_runningUrl-&gt;GetImapMailFolderSink(getter_AddRefs(aImapMailFolderSink));</span>
<a href="#l3.868"></a><span id="l3.868" class="difflineminus">-      if (aImapMailFolderSink)</span>
<a href="#l3.869"></a><span id="l3.869" class="difflineminus">-      {</span>
<a href="#l3.870"></a><span id="l3.870" class="difflineplus">+      (void)m_runningUrl-&gt;GetImapMailFolderSink(</span>
<a href="#l3.871"></a><span id="l3.871" class="difflineplus">+          getter_AddRefs(aImapMailFolderSink));</span>
<a href="#l3.872"></a><span id="l3.872" class="difflineplus">+      if (aImapMailFolderSink) {</span>
<a href="#l3.873"></a><span id="l3.873">         m_imapMailFolderSink = new ImapMailFolderSinkProxy(aImapMailFolderSink);</span>
<a href="#l3.874"></a><span id="l3.874">       }</span>
<a href="#l3.875"></a><span id="l3.875">     }</span>
<a href="#l3.876"></a><span id="l3.876"> </span>
<a href="#l3.877"></a><span id="l3.877" class="difflineminus">-    if (!m_imapMessageSink)</span>
<a href="#l3.878"></a><span id="l3.878" class="difflineminus">-    {</span>
<a href="#l3.879"></a><span id="l3.879" class="difflineplus">+    if (!m_imapMessageSink) {</span>
<a href="#l3.880"></a><span id="l3.880">       nsCOMPtr&lt;nsIImapMessageSink&gt; aImapMessageSink;</span>
<a href="#l3.881"></a><span id="l3.881" class="difflineminus">-      (void) m_runningUrl-&gt;GetImapMessageSink(getter_AddRefs(aImapMessageSink));</span>
<a href="#l3.882"></a><span id="l3.882" class="difflineplus">+      (void)m_runningUrl-&gt;GetImapMessageSink(getter_AddRefs(aImapMessageSink));</span>
<a href="#l3.883"></a><span id="l3.883">       if (aImapMessageSink) {</span>
<a href="#l3.884"></a><span id="l3.884">         m_imapMessageSink = new ImapMessageSinkProxy(aImapMessageSink);</span>
<a href="#l3.885"></a><span id="l3.885">       } else {</span>
<a href="#l3.886"></a><span id="l3.886">         return NS_ERROR_ILLEGAL_VALUE;</span>
<a href="#l3.887"></a><span id="l3.887">       }</span>
<a href="#l3.888"></a><span id="l3.888">     }</span>
<a href="#l3.889"></a><span id="l3.889" class="difflineminus">-    if (!m_imapServerSink)</span>
<a href="#l3.890"></a><span id="l3.890" class="difflineminus">-    {</span>
<a href="#l3.891"></a><span id="l3.891" class="difflineplus">+    if (!m_imapServerSink) {</span>
<a href="#l3.892"></a><span id="l3.892">       nsCOMPtr&lt;nsIImapServerSink&gt; aImapServerSink;</span>
<a href="#l3.893"></a><span id="l3.893">       res = m_runningUrl-&gt;GetImapServerSink(getter_AddRefs(aImapServerSink));</span>
<a href="#l3.894"></a><span id="l3.894">       if (aImapServerSink) {</span>
<a href="#l3.895"></a><span id="l3.895">         m_imapServerSink = new ImapServerSinkProxy(aImapServerSink);</span>
<a href="#l3.896"></a><span id="l3.896" class="difflineminus">-        m_imapServerSinkLatest =  m_imapServerSink;</span>
<a href="#l3.897"></a><span id="l3.897" class="difflineplus">+        m_imapServerSinkLatest = m_imapServerSink;</span>
<a href="#l3.898"></a><span id="l3.898">       } else {</span>
<a href="#l3.899"></a><span id="l3.899">         return NS_ERROR_ILLEGAL_VALUE;</span>
<a href="#l3.900"></a><span id="l3.900">       }</span>
<a href="#l3.901"></a><span id="l3.901">     }</span>
<a href="#l3.902"></a><span id="l3.902" class="difflineminus">-    if (!m_imapProtocolSink)</span>
<a href="#l3.903"></a><span id="l3.903" class="difflineminus">-    {</span>
<a href="#l3.904"></a><span id="l3.904" class="difflineminus">-      nsCOMPtr&lt;nsIImapProtocolSink&gt; anImapProxyHelper(do_QueryInterface(NS_ISUPPORTS_CAST(nsIImapProtocolSink*, this), &amp;res));</span>
<a href="#l3.905"></a><span id="l3.905" class="difflineplus">+    if (!m_imapProtocolSink) {</span>
<a href="#l3.906"></a><span id="l3.906" class="difflineplus">+      nsCOMPtr&lt;nsIImapProtocolSink&gt; anImapProxyHelper(do_QueryInterface(</span>
<a href="#l3.907"></a><span id="l3.907" class="difflineplus">+          NS_ISUPPORTS_CAST(nsIImapProtocolSink *, this), &amp;res));</span>
<a href="#l3.908"></a><span id="l3.908">       m_imapProtocolSink = new ImapProtocolSinkProxy(anImapProxyHelper);</span>
<a href="#l3.909"></a><span id="l3.909">     }</span>
<a href="#l3.910"></a><span id="l3.910">   }</span>
<a href="#l3.911"></a><span id="l3.911">   return NS_OK;</span>
<a href="#l3.912"></a><span id="l3.912"> }</span>
<a href="#l3.913"></a><span id="l3.913"> </span>
<a href="#l3.914"></a><span id="l3.914" class="difflineminus">-static void SetSecurityCallbacksFromChannel(nsISocketTransport* aTrans, nsIChannel* aChannel)</span>
<a href="#l3.915"></a><span id="l3.915" class="difflineminus">-{</span>
<a href="#l3.916"></a><span id="l3.916" class="difflineplus">+static void SetSecurityCallbacksFromChannel(nsISocketTransport *aTrans,</span>
<a href="#l3.917"></a><span id="l3.917" class="difflineplus">+                                            nsIChannel *aChannel) {</span>
<a href="#l3.918"></a><span id="l3.918">   nsCOMPtr&lt;nsIInterfaceRequestor&gt; callbacks;</span>
<a href="#l3.919"></a><span id="l3.919">   aChannel-&gt;GetNotificationCallbacks(getter_AddRefs(callbacks));</span>
<a href="#l3.920"></a><span id="l3.920"> </span>
<a href="#l3.921"></a><span id="l3.921">   nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.922"></a><span id="l3.922">   aChannel-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.923"></a><span id="l3.923"> </span>
<a href="#l3.924"></a><span id="l3.924">   nsCOMPtr&lt;nsIInterfaceRequestor&gt; securityCallbacks;</span>
<a href="#l3.925"></a><span id="l3.925">   MsgNewNotificationCallbacksAggregation(callbacks, loadGroup,</span>
<a href="#l3.926"></a><span id="l3.926">                                          getter_AddRefs(securityCallbacks));</span>
<a href="#l3.927"></a><span id="l3.927" class="difflineminus">-  if (securityCallbacks)</span>
<a href="#l3.928"></a><span id="l3.928" class="difflineminus">-    aTrans-&gt;SetSecurityCallbacks(securityCallbacks);</span>
<a href="#l3.929"></a><span id="l3.929" class="difflineminus">-}</span>
<a href="#l3.930"></a><span id="l3.930" class="difflineminus">-</span>
<a href="#l3.931"></a><span id="l3.931" class="difflineminus">-// Setup With Url is intended to set up data which is held on a PER URL basis and not</span>
<a href="#l3.932"></a><span id="l3.932" class="difflineminus">-// a per connection basis. If you have data which is independent of the url we are currently</span>
<a href="#l3.933"></a><span id="l3.933" class="difflineminus">-// running, then you should put it in Initialize().</span>
<a href="#l3.934"></a><span id="l3.934" class="difflineminus">-// This is only ever called from the UI thread. It is called from LoadUrl, right</span>
<a href="#l3.935"></a><span id="l3.935" class="difflineminus">-// before the url gets run - i.e., the url is next in line to run.</span>
<a href="#l3.936"></a><span id="l3.936" class="difflineminus">-nsresult nsImapProtocol::SetupWithUrl(nsIURI * aURL, nsISupports* aConsumer)</span>
<a href="#l3.937"></a><span id="l3.937" class="difflineminus">-{</span>
<a href="#l3.938"></a><span id="l3.938" class="difflineplus">+  if (securityCallbacks) aTrans-&gt;SetSecurityCallbacks(securityCallbacks);</span>
<a href="#l3.939"></a><span id="l3.939" class="difflineplus">+}</span>
<a href="#l3.940"></a><span id="l3.940" class="difflineplus">+</span>
<a href="#l3.941"></a><span id="l3.941" class="difflineplus">+// Setup With Url is intended to set up data which is held on a PER URL basis</span>
<a href="#l3.942"></a><span id="l3.942" class="difflineplus">+// and not a per connection basis. If you have data which is independent of the</span>
<a href="#l3.943"></a><span id="l3.943" class="difflineplus">+// url we are currently running, then you should put it in Initialize(). This is</span>
<a href="#l3.944"></a><span id="l3.944" class="difflineplus">+// only ever called from the UI thread. It is called from LoadUrl, right before</span>
<a href="#l3.945"></a><span id="l3.945" class="difflineplus">+// the url gets run - i.e., the url is next in line to run.</span>
<a href="#l3.946"></a><span id="l3.946" class="difflineplus">+nsresult nsImapProtocol::SetupWithUrl(nsIURI *aURL, nsISupports *aConsumer) {</span>
<a href="#l3.947"></a><span id="l3.947">   nsresult rv = NS_ERROR_FAILURE;</span>
<a href="#l3.948"></a><span id="l3.948">   NS_ASSERTION(aURL, &quot;null URL passed into Imap Protocol&quot;);</span>
<a href="#l3.949"></a><span id="l3.949" class="difflineminus">-  if (aURL)</span>
<a href="#l3.950"></a><span id="l3.950" class="difflineminus">-  {</span>
<a href="#l3.951"></a><span id="l3.951" class="difflineplus">+  if (aURL) {</span>
<a href="#l3.952"></a><span id="l3.952">     m_runningUrl = do_QueryInterface(aURL, &amp;rv);</span>
<a href="#l3.953"></a><span id="l3.953">     m_runningUrlLatest = m_runningUrl;</span>
<a href="#l3.954"></a><span id="l3.954" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.955"></a><span id="l3.955" class="difflineminus">-      return rv;</span>
<a href="#l3.956"></a><span id="l3.956" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l3.957"></a><span id="l3.957"> </span>
<a href="#l3.958"></a><span id="l3.958">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.959"></a><span id="l3.959">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; server = do_QueryReferent(m_server);</span>
<a href="#l3.960"></a><span id="l3.960" class="difflineminus">-    if (!server)</span>
<a href="#l3.961"></a><span id="l3.961" class="difflineminus">-    {</span>
<a href="#l3.962"></a><span id="l3.962" class="difflineplus">+    if (!server) {</span>
<a href="#l3.963"></a><span id="l3.963">       rv = mailnewsUrl-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l3.964"></a><span id="l3.964">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.965"></a><span id="l3.965">       m_server = do_GetWeakReference(server);</span>
<a href="#l3.966"></a><span id="l3.966">     }</span>
<a href="#l3.967"></a><span id="l3.967" class="difflineminus">-    nsCOMPtr &lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.968"></a><span id="l3.968" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.969"></a><span id="l3.969">     mailnewsUrl-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l3.970"></a><span id="l3.970">     mFolderLastModSeq = 0;</span>
<a href="#l3.971"></a><span id="l3.971">     mFolderTotalMsgCount = 0;</span>
<a href="#l3.972"></a><span id="l3.972">     mFolderHighestUID = 0;</span>
<a href="#l3.973"></a><span id="l3.973">     m_uidValidity = kUidUnknown;</span>
<a href="#l3.974"></a><span id="l3.974" class="difflineminus">-    if (folder)</span>
<a href="#l3.975"></a><span id="l3.975" class="difflineminus">-    {</span>
<a href="#l3.976"></a><span id="l3.976" class="difflineplus">+    if (folder) {</span>
<a href="#l3.977"></a><span id="l3.977">       nsCOMPtr&lt;nsIMsgDatabase&gt; folderDB;</span>
<a href="#l3.978"></a><span id="l3.978">       nsCOMPtr&lt;nsIDBFolderInfo&gt; folderInfo;</span>
<a href="#l3.979"></a><span id="l3.979" class="difflineminus">-      folder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo), getter_AddRefs(folderDB));</span>
<a href="#l3.980"></a><span id="l3.980" class="difflineminus">-      if (folderInfo)</span>
<a href="#l3.981"></a><span id="l3.981" class="difflineminus">-      {</span>
<a href="#l3.982"></a><span id="l3.982" class="difflineplus">+      folder-&gt;GetDBFolderInfoAndDB(getter_AddRefs(folderInfo),</span>
<a href="#l3.983"></a><span id="l3.983" class="difflineplus">+                                   getter_AddRefs(folderDB));</span>
<a href="#l3.984"></a><span id="l3.984" class="difflineplus">+      if (folderInfo) {</span>
<a href="#l3.985"></a><span id="l3.985">         nsCString modSeqStr;</span>
<a href="#l3.986"></a><span id="l3.986">         folderInfo-&gt;GetCharProperty(kModSeqPropertyName, modSeqStr);</span>
<a href="#l3.987"></a><span id="l3.987">         mFolderLastModSeq = ParseUint64Str(modSeqStr.get());</span>
<a href="#l3.988"></a><span id="l3.988">         folderInfo-&gt;GetNumMessages(&amp;mFolderTotalMsgCount);</span>
<a href="#l3.989"></a><span id="l3.989" class="difflineminus">-        folderInfo-&gt;GetUint32Property(kHighestRecordedUIDPropertyName, 0, &amp;mFolderHighestUID);</span>
<a href="#l3.990"></a><span id="l3.990" class="difflineplus">+        folderInfo-&gt;GetUint32Property(kHighestRecordedUIDPropertyName, 0,</span>
<a href="#l3.991"></a><span id="l3.991" class="difflineplus">+                                      &amp;mFolderHighestUID);</span>
<a href="#l3.992"></a><span id="l3.992">         folderInfo-&gt;GetImapUidValidity(&amp;m_uidValidity);</span>
<a href="#l3.993"></a><span id="l3.993">       }</span>
<a href="#l3.994"></a><span id="l3.994">     }</span>
<a href="#l3.995"></a><span id="l3.995">     nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer = do_QueryInterface(server);</span>
<a href="#l3.996"></a><span id="l3.996" class="difflineminus">-    nsCOMPtr&lt;nsIStreamListener&gt; aRealStreamListener = do_QueryInterface(aConsumer);</span>
<a href="#l3.997"></a><span id="l3.997" class="difflineplus">+    nsCOMPtr&lt;nsIStreamListener&gt; aRealStreamListener =</span>
<a href="#l3.998"></a><span id="l3.998" class="difflineplus">+        do_QueryInterface(aConsumer);</span>
<a href="#l3.999"></a><span id="l3.999">     m_runningUrl-&gt;GetMockChannel(getter_AddRefs(m_mockChannel));</span>
<a href="#l3.1000"></a><span id="l3.1000">     imapServer-&gt;GetIsGMailServer(&amp;m_isGmailServer);</span>
<a href="#l3.1001"></a><span id="l3.1001" class="difflineminus">-    if (!m_mockChannel)</span>
<a href="#l3.1002"></a><span id="l3.1002" class="difflineminus">-    {</span>
<a href="#l3.1003"></a><span id="l3.1003" class="difflineminus">-</span>
<a href="#l3.1004"></a><span id="l3.1004" class="difflineplus">+    if (!m_mockChannel) {</span>
<a href="#l3.1005"></a><span id="l3.1005">       nsCOMPtr&lt;nsIPrincipal&gt; nullPrincipal =</span>
<a href="#l3.1006"></a><span id="l3.1006" class="difflineminus">-        do_CreateInstance(&quot;@mozilla.org/nullprincipal;1&quot;, &amp;rv);</span>
<a href="#l3.1007"></a><span id="l3.1007" class="difflineplus">+          do_CreateInstance(&quot;@mozilla.org/nullprincipal;1&quot;, &amp;rv);</span>
<a href="#l3.1008"></a><span id="l3.1008">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.1009"></a><span id="l3.1009"> </span>
<a href="#l3.1010"></a><span id="l3.1010" class="difflineminus">-      // there are several imap operations that aren't initiated via a nsIChannel::AsyncOpen call on the mock channel.</span>
<a href="#l3.1011"></a><span id="l3.1011" class="difflineminus">-      // such as selecting a folder. nsImapProtocol now insists on a mock channel when processing a url.</span>
<a href="#l3.1012"></a><span id="l3.1012" class="difflineplus">+      // there are several imap operations that aren't initiated via a</span>
<a href="#l3.1013"></a><span id="l3.1013" class="difflineplus">+      // nsIChannel::AsyncOpen call on the mock channel. such as selecting a</span>
<a href="#l3.1014"></a><span id="l3.1014" class="difflineplus">+      // folder. nsImapProtocol now insists on a mock channel when processing a</span>
<a href="#l3.1015"></a><span id="l3.1015" class="difflineplus">+      // url.</span>
<a href="#l3.1016"></a><span id="l3.1016">       nsCOMPtr&lt;nsIChannel&gt; channel;</span>
<a href="#l3.1017"></a><span id="l3.1017" class="difflineminus">-      rv = NS_NewChannel(getter_AddRefs(channel),</span>
<a href="#l3.1018"></a><span id="l3.1018" class="difflineminus">-                         aURL,</span>
<a href="#l3.1019"></a><span id="l3.1019" class="difflineminus">-                         nullPrincipal,</span>
<a href="#l3.1020"></a><span id="l3.1020" class="difflineplus">+      rv = NS_NewChannel(getter_AddRefs(channel), aURL, nullPrincipal,</span>
<a href="#l3.1021"></a><span id="l3.1021">                          nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL,</span>
<a href="#l3.1022"></a><span id="l3.1022">                          nsIContentPolicy::TYPE_OTHER);</span>
<a href="#l3.1023"></a><span id="l3.1023">       m_mockChannel = do_QueryInterface(channel);</span>
<a href="#l3.1024"></a><span id="l3.1024"> </span>
<a href="#l3.1025"></a><span id="l3.1025" class="difflineminus">-      // Certain imap operations (not initiated by the IO Service via AsyncOpen) can be interrupted by  the stop button on the toolbar.</span>
<a href="#l3.1026"></a><span id="l3.1026" class="difflineminus">-      // We do this by using the loadgroup of the docshell for the message pane. We really shouldn't be doing this..</span>
<a href="#l3.1027"></a><span id="l3.1027" class="difflineminus">-      // See the comment in nsMsgMailNewsUrl::GetLoadGroup.</span>
<a href="#l3.1028"></a><span id="l3.1028" class="difflineplus">+      // Certain imap operations (not initiated by the IO Service via AsyncOpen)</span>
<a href="#l3.1029"></a><span id="l3.1029" class="difflineplus">+      // can be interrupted by  the stop button on the toolbar. We do this by</span>
<a href="#l3.1030"></a><span id="l3.1030" class="difflineplus">+      // using the loadgroup of the docshell for the message pane. We really</span>
<a href="#l3.1031"></a><span id="l3.1031" class="difflineplus">+      // shouldn't be doing this.. See the comment in</span>
<a href="#l3.1032"></a><span id="l3.1032" class="difflineplus">+      // nsMsgMailNewsUrl::GetLoadGroup.</span>
<a href="#l3.1033"></a><span id="l3.1033">       nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.1034"></a><span id="l3.1034" class="difflineminus">-      mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup)); // get the message pane load group</span>
<a href="#l3.1035"></a><span id="l3.1035" class="difflineplus">+      mailnewsUrl-&gt;GetLoadGroup(</span>
<a href="#l3.1036"></a><span id="l3.1036" class="difflineplus">+          getter_AddRefs(loadGroup));  // get the message pane load group</span>
<a href="#l3.1037"></a><span id="l3.1037">       if (loadGroup)</span>
<a href="#l3.1038"></a><span id="l3.1038">         loadGroup-&gt;AddRequest(m_mockChannel, nullptr /* context isupports */);</span>
<a href="#l3.1039"></a><span id="l3.1039">     }</span>
<a href="#l3.1040"></a><span id="l3.1040"> </span>
<a href="#l3.1041"></a><span id="l3.1041" class="difflineminus">-    if (m_mockChannel)</span>
<a href="#l3.1042"></a><span id="l3.1042" class="difflineminus">-    {</span>
<a href="#l3.1043"></a><span id="l3.1043" class="difflineplus">+    if (m_mockChannel) {</span>
<a href="#l3.1044"></a><span id="l3.1044">       m_mockChannel-&gt;SetImapProtocol(this);</span>
<a href="#l3.1045"></a><span id="l3.1045" class="difflineminus">-      // if we have a listener from a mock channel, over-ride the consumer that was passed in</span>
<a href="#l3.1046"></a><span id="l3.1046" class="difflineplus">+      // if we have a listener from a mock channel, over-ride the consumer that</span>
<a href="#l3.1047"></a><span id="l3.1047" class="difflineplus">+      // was passed in</span>
<a href="#l3.1048"></a><span id="l3.1048">       nsCOMPtr&lt;nsIStreamListener&gt; channelListener;</span>
<a href="#l3.1049"></a><span id="l3.1049">       m_mockChannel-&gt;GetChannelListener(getter_AddRefs(channelListener));</span>
<a href="#l3.1050"></a><span id="l3.1050" class="difflineminus">-      if (channelListener) // only over-ride if we have a non null channel listener</span>
<a href="#l3.1051"></a><span id="l3.1051" class="difflineplus">+      if (channelListener)  // only over-ride if we have a non null channel</span>
<a href="#l3.1052"></a><span id="l3.1052" class="difflineplus">+                            // listener</span>
<a href="#l3.1053"></a><span id="l3.1053">         aRealStreamListener = channelListener;</span>
<a href="#l3.1054"></a><span id="l3.1054">       m_mockChannel-&gt;GetChannelContext(getter_AddRefs(m_channelContext));</span>
<a href="#l3.1055"></a><span id="l3.1055">       nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l3.1056"></a><span id="l3.1056">       GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.1057"></a><span id="l3.1057" class="difflineminus">-      if (!msgWindow)</span>
<a href="#l3.1058"></a><span id="l3.1058" class="difflineminus">-        GetTopmostMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.1059"></a><span id="l3.1059" class="difflineminus">-      if (msgWindow)</span>
<a href="#l3.1060"></a><span id="l3.1060" class="difflineminus">-      {</span>
<a href="#l3.1061"></a><span id="l3.1061" class="difflineplus">+      if (!msgWindow) GetTopmostMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.1062"></a><span id="l3.1062" class="difflineplus">+      if (msgWindow) {</span>
<a href="#l3.1063"></a><span id="l3.1063">         nsCOMPtr&lt;nsIDocShell&gt; docShell;</span>
<a href="#l3.1064"></a><span id="l3.1064">         msgWindow-&gt;GetMessageWindowDocShell(getter_AddRefs(docShell));</span>
<a href="#l3.1065"></a><span id="l3.1065">         nsCOMPtr&lt;nsIInterfaceRequestor&gt; ir(do_QueryInterface(docShell));</span>
<a href="#l3.1066"></a><span id="l3.1066">         nsCOMPtr&lt;nsIInterfaceRequestor&gt; interfaceRequestor;</span>
<a href="#l3.1067"></a><span id="l3.1067">         msgWindow-&gt;GetNotificationCallbacks(getter_AddRefs(interfaceRequestor));</span>
<a href="#l3.1068"></a><span id="l3.1068">         nsCOMPtr&lt;nsIInterfaceRequestor&gt; aggregateIR;</span>
<a href="#l3.1069"></a><span id="l3.1069" class="difflineminus">-        MsgNewInterfaceRequestorAggregation(interfaceRequestor, ir, getter_AddRefs(aggregateIR));</span>
<a href="#l3.1070"></a><span id="l3.1070" class="difflineplus">+        MsgNewInterfaceRequestorAggregation(interfaceRequestor, ir,</span>
<a href="#l3.1071"></a><span id="l3.1071" class="difflineplus">+                                            getter_AddRefs(aggregateIR));</span>
<a href="#l3.1072"></a><span id="l3.1072">         m_mockChannel-&gt;SetNotificationCallbacks(aggregateIR);</span>
<a href="#l3.1073"></a><span id="l3.1073">       }</span>
<a href="#l3.1074"></a><span id="l3.1074">     }</span>
<a href="#l3.1075"></a><span id="l3.1075"> </span>
<a href="#l3.1076"></a><span id="l3.1076" class="difflineminus">-    // since we'll be making calls directly from the imap thread to the channel listener,</span>
<a href="#l3.1077"></a><span id="l3.1077" class="difflineminus">-    // we need to turn it into a proxy object....we'll assume that the listener is on the same thread</span>
<a href="#l3.1078"></a><span id="l3.1078" class="difflineminus">-    // as the event sink queue</span>
<a href="#l3.1079"></a><span id="l3.1079" class="difflineminus">-    if (aRealStreamListener)</span>
<a href="#l3.1080"></a><span id="l3.1080" class="difflineminus">-    {</span>
<a href="#l3.1081"></a><span id="l3.1081" class="difflineminus">-      NS_ASSERTION(!m_channelListener, &quot;shouldn't already have a channel listener&quot;);</span>
<a href="#l3.1082"></a><span id="l3.1082" class="difflineplus">+    // since we'll be making calls directly from the imap thread to the channel</span>
<a href="#l3.1083"></a><span id="l3.1083" class="difflineplus">+    // listener, we need to turn it into a proxy object....we'll assume that the</span>
<a href="#l3.1084"></a><span id="l3.1084" class="difflineplus">+    // listener is on the same thread as the event sink queue</span>
<a href="#l3.1085"></a><span id="l3.1085" class="difflineplus">+    if (aRealStreamListener) {</span>
<a href="#l3.1086"></a><span id="l3.1086" class="difflineplus">+      NS_ASSERTION(!m_channelListener,</span>
<a href="#l3.1087"></a><span id="l3.1087" class="difflineplus">+                   &quot;shouldn't already have a channel listener&quot;);</span>
<a href="#l3.1088"></a><span id="l3.1088">       m_channelListener = new StreamListenerProxy(aRealStreamListener);</span>
<a href="#l3.1089"></a><span id="l3.1089">     }</span>
<a href="#l3.1090"></a><span id="l3.1090"> </span>
<a href="#l3.1091"></a><span id="l3.1091">     server-&gt;GetRealHostName(m_realHostName);</span>
<a href="#l3.1092"></a><span id="l3.1092">     int32_t authMethod;</span>
<a href="#l3.1093"></a><span id="l3.1093" class="difflineminus">-    (void) server-&gt;GetAuthMethod(&amp;authMethod);</span>
<a href="#l3.1094"></a><span id="l3.1094" class="difflineplus">+    (void)server-&gt;GetAuthMethod(&amp;authMethod);</span>
<a href="#l3.1095"></a><span id="l3.1095">     InitPrefAuthMethods(authMethod, server);</span>
<a href="#l3.1096"></a><span id="l3.1096" class="difflineminus">-    (void) server-&gt;GetSocketType(&amp;m_socketType);</span>
<a href="#l3.1097"></a><span id="l3.1097" class="difflineplus">+    (void)server-&gt;GetSocketType(&amp;m_socketType);</span>
<a href="#l3.1098"></a><span id="l3.1098">     bool shuttingDown;</span>
<a href="#l3.1099"></a><span id="l3.1099" class="difflineminus">-    (void) imapServer-&gt;GetShuttingDown(&amp;shuttingDown);</span>
<a href="#l3.1100"></a><span id="l3.1100" class="difflineplus">+    (void)imapServer-&gt;GetShuttingDown(&amp;shuttingDown);</span>
<a href="#l3.1101"></a><span id="l3.1101">     if (!shuttingDown)</span>
<a href="#l3.1102"></a><span id="l3.1102" class="difflineminus">-      (void) imapServer-&gt;GetUseIdle(&amp;m_useIdle);</span>
<a href="#l3.1103"></a><span id="l3.1103" class="difflineplus">+      (void)imapServer-&gt;GetUseIdle(&amp;m_useIdle);</span>
<a href="#l3.1104"></a><span id="l3.1104">     else</span>
<a href="#l3.1105"></a><span id="l3.1105">       m_useIdle = false;</span>
<a href="#l3.1106"></a><span id="l3.1106">     imapServer-&gt;GetFetchByChunks(&amp;m_fetchByChunks);</span>
<a href="#l3.1107"></a><span id="l3.1107">     imapServer-&gt;GetSendID(&amp;m_sendID);</span>
<a href="#l3.1108"></a><span id="l3.1108"> </span>
<a href="#l3.1109"></a><span id="l3.1109">     nsAutoString trashFolderPath;</span>
<a href="#l3.1110"></a><span id="l3.1110">     if (NS_SUCCEEDED(imapServer-&gt;GetTrashFolderName(trashFolderPath)))</span>
<a href="#l3.1111"></a><span id="l3.1111">       CopyUTF16toMUTF7(trashFolderPath, m_trashFolderPath);</span>
<a href="#l3.1112"></a><span id="l3.1112"> </span>
<a href="#l3.1113"></a><span id="l3.1113" class="difflineminus">-    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l3.1114"></a><span id="l3.1114" class="difflineminus">-    if (prefBranch)</span>
<a href="#l3.1115"></a><span id="l3.1115" class="difflineminus">-    {</span>
<a href="#l3.1116"></a><span id="l3.1116" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l3.1117"></a><span id="l3.1117" class="difflineplus">+        do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l3.1118"></a><span id="l3.1118" class="difflineplus">+    if (prefBranch) {</span>
<a href="#l3.1119"></a><span id="l3.1119">       bool preferPlainText;</span>
<a href="#l3.1120"></a><span id="l3.1120" class="difflineminus">-      prefBranch-&gt;GetBoolPref(&quot;mailnews.display.prefer_plaintext&quot;, &amp;preferPlainText);</span>
<a href="#l3.1121"></a><span id="l3.1121" class="difflineplus">+      prefBranch-&gt;GetBoolPref(&quot;mailnews.display.prefer_plaintext&quot;,</span>
<a href="#l3.1122"></a><span id="l3.1122" class="difflineplus">+                              &amp;preferPlainText);</span>
<a href="#l3.1123"></a><span id="l3.1123">       // If the pref has changed since the last time we ran a url,</span>
<a href="#l3.1124"></a><span id="l3.1124">       // clear the shell cache for this host.</span>
<a href="#l3.1125"></a><span id="l3.1125" class="difflineminus">-      if (preferPlainText != m_preferPlainText)</span>
<a href="#l3.1126"></a><span id="l3.1126" class="difflineminus">-      {</span>
<a href="#l3.1127"></a><span id="l3.1127" class="difflineplus">+      if (preferPlainText != m_preferPlainText) {</span>
<a href="#l3.1128"></a><span id="l3.1128">         m_hostSessionList-&gt;ClearShellCacheForHost(GetImapServerKey());</span>
<a href="#l3.1129"></a><span id="l3.1129">         m_preferPlainText = preferPlainText;</span>
<a href="#l3.1130"></a><span id="l3.1130">       }</span>
<a href="#l3.1131"></a><span id="l3.1131">     }</span>
<a href="#l3.1132"></a><span id="l3.1132"> </span>
<a href="#l3.1133"></a><span id="l3.1133">     bool proxyCallback = false;</span>
<a href="#l3.1134"></a><span id="l3.1134" class="difflineminus">-    if ( m_runningUrl &amp;&amp; !m_transport /* and we don't have a transport yet */)</span>
<a href="#l3.1135"></a><span id="l3.1135" class="difflineminus">-    {</span>
<a href="#l3.1136"></a><span id="l3.1136" class="difflineplus">+    if (m_runningUrl &amp;&amp; !m_transport /* and we don't have a transport yet */) {</span>
<a href="#l3.1137"></a><span id="l3.1137">       if (m_mockChannel) {</span>
<a href="#l3.1138"></a><span id="l3.1138" class="difflineminus">-        rv = MsgExamineForProxyAsync(m_mockChannel, this, getter_AddRefs(m_proxyRequest));</span>
<a href="#l3.1139"></a><span id="l3.1139" class="difflineminus">-        if (NS_FAILED(rv))</span>
<a href="#l3.1140"></a><span id="l3.1140" class="difflineminus">-        {</span>
<a href="#l3.1141"></a><span id="l3.1141" class="difflineplus">+        rv = MsgExamineForProxyAsync(m_mockChannel, this,</span>
<a href="#l3.1142"></a><span id="l3.1142" class="difflineplus">+                                     getter_AddRefs(m_proxyRequest));</span>
<a href="#l3.1143"></a><span id="l3.1143" class="difflineplus">+        if (NS_FAILED(rv)) {</span>
<a href="#l3.1144"></a><span id="l3.1144">           rv = SetupWithUrlCallback(nullptr);</span>
<a href="#l3.1145"></a><span id="l3.1145" class="difflineminus">-        }</span>
<a href="#l3.1146"></a><span id="l3.1146" class="difflineminus">-        else</span>
<a href="#l3.1147"></a><span id="l3.1147" class="difflineminus">-        {</span>
<a href="#l3.1148"></a><span id="l3.1148" class="difflineplus">+        } else {</span>
<a href="#l3.1149"></a><span id="l3.1149">           proxyCallback = true;</span>
<a href="#l3.1150"></a><span id="l3.1150">         }</span>
<a href="#l3.1151"></a><span id="l3.1151">       }</span>
<a href="#l3.1152"></a><span id="l3.1152">     }</span>
<a href="#l3.1153"></a><span id="l3.1153"> </span>
<a href="#l3.1154"></a><span id="l3.1154" class="difflineminus">-    if (!proxyCallback)</span>
<a href="#l3.1155"></a><span id="l3.1155" class="difflineminus">-      rv = LoadImapUrlInternal();</span>
<a href="#l3.1156"></a><span id="l3.1156" class="difflineplus">+    if (!proxyCallback) rv = LoadImapUrlInternal();</span>
<a href="#l3.1157"></a><span id="l3.1157">   }</span>
<a href="#l3.1158"></a><span id="l3.1158"> </span>
<a href="#l3.1159"></a><span id="l3.1159">   return rv;</span>
<a href="#l3.1160"></a><span id="l3.1160"> }</span>
<a href="#l3.1161"></a><span id="l3.1161"> </span>
<a href="#l3.1162"></a><span id="l3.1162"> // nsIProtocolProxyCallback</span>
<a href="#l3.1163"></a><span id="l3.1163"> NS_IMETHODIMP</span>
<a href="#l3.1164"></a><span id="l3.1164"> nsImapProtocol::OnProxyAvailable(nsICancelable *aRequest, nsIChannel *aChannel,</span>
<a href="#l3.1165"></a><span id="l3.1165" class="difflineminus">-                                 nsIProxyInfo *aProxyInfo, nsresult aStatus)</span>
<a href="#l3.1166"></a><span id="l3.1166" class="difflineminus">-{</span>
<a href="#l3.1167"></a><span id="l3.1167" class="difflineplus">+                                 nsIProxyInfo *aProxyInfo, nsresult aStatus) {</span>
<a href="#l3.1168"></a><span id="l3.1168">   // If we're called with NS_BINDING_ABORTED, the IMAP thread already died,</span>
<a href="#l3.1169"></a><span id="l3.1169">   // so we can't carry on. Otherwise, no checking of 'aStatus' here, see</span>
<a href="#l3.1170"></a><span id="l3.1170">   // nsHttpChannel::OnProxyAvailable(). Status is non-fatal and we just kick on.</span>
<a href="#l3.1171"></a><span id="l3.1171" class="difflineminus">-  if (aStatus == NS_BINDING_ABORTED)</span>
<a href="#l3.1172"></a><span id="l3.1172" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l3.1173"></a><span id="l3.1173" class="difflineplus">+  if (aStatus == NS_BINDING_ABORTED) return NS_ERROR_FAILURE;</span>
<a href="#l3.1174"></a><span id="l3.1174"> </span>
<a href="#l3.1175"></a><span id="l3.1175">   nsresult rv = SetupWithUrlCallback(aProxyInfo);</span>
<a href="#l3.1176"></a><span id="l3.1176">   if (NS_FAILED(rv)) {</span>
<a href="#l3.1177"></a><span id="l3.1177">     // Cancel the protocol and be done.</span>
<a href="#l3.1178"></a><span id="l3.1178" class="difflineminus">-    if (m_mockChannel)</span>
<a href="#l3.1179"></a><span id="l3.1179" class="difflineminus">-      m_mockChannel-&gt;Cancel(rv);</span>
<a href="#l3.1180"></a><span id="l3.1180" class="difflineplus">+    if (m_mockChannel) m_mockChannel-&gt;Cancel(rv);</span>
<a href="#l3.1181"></a><span id="l3.1181">     return rv;</span>
<a href="#l3.1182"></a><span id="l3.1182">   }</span>
<a href="#l3.1183"></a><span id="l3.1183"> </span>
<a href="#l3.1184"></a><span id="l3.1184">   rv = LoadImapUrlInternal();</span>
<a href="#l3.1185"></a><span id="l3.1185">   if (NS_FAILED(rv)) {</span>
<a href="#l3.1186"></a><span id="l3.1186" class="difflineminus">-    if (m_mockChannel)</span>
<a href="#l3.1187"></a><span id="l3.1187" class="difflineminus">-      m_mockChannel-&gt;Cancel(rv);</span>
<a href="#l3.1188"></a><span id="l3.1188" class="difflineplus">+    if (m_mockChannel) m_mockChannel-&gt;Cancel(rv);</span>
<a href="#l3.1189"></a><span id="l3.1189">   }</span>
<a href="#l3.1190"></a><span id="l3.1190"> </span>
<a href="#l3.1191"></a><span id="l3.1191">   return rv;</span>
<a href="#l3.1192"></a><span id="l3.1192"> }</span>
<a href="#l3.1193"></a><span id="l3.1193"> </span>
<a href="#l3.1194"></a><span id="l3.1194" class="difflineminus">-nsresult nsImapProtocol::SetupWithUrlCallback(nsIProxyInfo* aProxyInfo)</span>
<a href="#l3.1195"></a><span id="l3.1195" class="difflineminus">-{</span>
<a href="#l3.1196"></a><span id="l3.1196" class="difflineplus">+nsresult nsImapProtocol::SetupWithUrlCallback(nsIProxyInfo *aProxyInfo) {</span>
<a href="#l3.1197"></a><span id="l3.1197">   m_proxyRequest = nullptr;</span>
<a href="#l3.1198"></a><span id="l3.1198"> </span>
<a href="#l3.1199"></a><span id="l3.1199">   nsresult rv;</span>
<a href="#l3.1200"></a><span id="l3.1200"> </span>
<a href="#l3.1201"></a><span id="l3.1201">   nsCOMPtr&lt;nsISocketTransportService&gt; socketService =</span>
<a href="#l3.1202"></a><span id="l3.1202" class="difflineminus">-    do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l3.1203"></a><span id="l3.1203" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l3.1204"></a><span id="l3.1204" class="difflineminus">-    return rv;</span>
<a href="#l3.1205"></a><span id="l3.1205" class="difflineplus">+      do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l3.1206"></a><span id="l3.1206" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l3.1207"></a><span id="l3.1207"> </span>
<a href="#l3.1208"></a><span id="l3.1208">   Log(&quot;SetupWithUrlCallback&quot;, nullptr, &quot;clearing IMAP_CONNECTION_IS_OPEN&quot;);</span>
<a href="#l3.1209"></a><span id="l3.1209">   ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.1210"></a><span id="l3.1210">   const char *connectionType = nullptr;</span>
<a href="#l3.1211"></a><span id="l3.1211"> </span>
<a href="#l3.1212"></a><span id="l3.1212">   if (m_socketType == nsMsgSocketType::SSL)</span>
<a href="#l3.1213"></a><span id="l3.1213">     connectionType = &quot;ssl&quot;;</span>
<a href="#l3.1214"></a><span id="l3.1214">   else if (m_socketType == nsMsgSocketType::alwaysSTARTTLS)</span>
<a href="#l3.1215"></a><span id="l3.1215">     connectionType = &quot;starttls&quot;;</span>
<a href="#l3.1216"></a><span id="l3.1216">   // This can go away once we think everyone is migrated</span>
<a href="#l3.1217"></a><span id="l3.1217">   // away from the trySTARTTLS socket type.</span>
<a href="#l3.1218"></a><span id="l3.1218">   else if (m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.1219"></a><span id="l3.1219">     connectionType = &quot;starttls&quot;;</span>
<a href="#l3.1220"></a><span id="l3.1220"> </span>
<a href="#l3.1221"></a><span id="l3.1221">   int32_t port = -1;</span>
<a href="#l3.1222"></a><span id="l3.1222">   nsCOMPtr&lt;nsIURI&gt; uri = do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l3.1223"></a><span id="l3.1223" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l3.1224"></a><span id="l3.1224" class="difflineminus">-    return rv;</span>
<a href="#l3.1225"></a><span id="l3.1225" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l3.1226"></a><span id="l3.1226">   uri-&gt;GetPort(&amp;port);</span>
<a href="#l3.1227"></a><span id="l3.1227"> </span>
<a href="#l3.1228"></a><span id="l3.1228" class="difflineminus">-  rv = socketService-&gt;CreateTransport(&amp;connectionType, connectionType != nullptr,</span>
<a href="#l3.1229"></a><span id="l3.1229" class="difflineminus">-                                      m_realHostName, port, aProxyInfo,</span>
<a href="#l3.1230"></a><span id="l3.1230" class="difflineminus">-                                      getter_AddRefs(m_transport));</span>
<a href="#l3.1231"></a><span id="l3.1231" class="difflineminus">-  if (NS_FAILED(rv) &amp;&amp; m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.1232"></a><span id="l3.1232" class="difflineminus">-  {</span>
<a href="#l3.1233"></a><span id="l3.1233" class="difflineplus">+  rv = socketService-&gt;CreateTransport(</span>
<a href="#l3.1234"></a><span id="l3.1234" class="difflineplus">+      &amp;connectionType, connectionType != nullptr, m_realHostName, port,</span>
<a href="#l3.1235"></a><span id="l3.1235" class="difflineplus">+      aProxyInfo, getter_AddRefs(m_transport));</span>
<a href="#l3.1236"></a><span id="l3.1236" class="difflineplus">+  if (NS_FAILED(rv) &amp;&amp; m_socketType == nsMsgSocketType::trySTARTTLS) {</span>
<a href="#l3.1237"></a><span id="l3.1237">     connectionType = nullptr;</span>
<a href="#l3.1238"></a><span id="l3.1238">     m_socketType = nsMsgSocketType::plain;</span>
<a href="#l3.1239"></a><span id="l3.1239" class="difflineminus">-    rv = socketService-&gt;CreateTransport(&amp;connectionType, connectionType != nullptr,</span>
<a href="#l3.1240"></a><span id="l3.1240" class="difflineminus">-                                        m_realHostName, port, aProxyInfo,</span>
<a href="#l3.1241"></a><span id="l3.1241" class="difflineminus">-                                        getter_AddRefs(m_transport));</span>
<a href="#l3.1242"></a><span id="l3.1242" class="difflineplus">+    rv = socketService-&gt;CreateTransport(</span>
<a href="#l3.1243"></a><span id="l3.1243" class="difflineplus">+        &amp;connectionType, connectionType != nullptr, m_realHostName, port,</span>
<a href="#l3.1244"></a><span id="l3.1244" class="difflineplus">+        aProxyInfo, getter_AddRefs(m_transport));</span>
<a href="#l3.1245"></a><span id="l3.1245">   }</span>
<a href="#l3.1246"></a><span id="l3.1246"> </span>
<a href="#l3.1247"></a><span id="l3.1247">   // remember so we can know whether we can issue a start tls or not...</span>
<a href="#l3.1248"></a><span id="l3.1248">   m_connectionType = connectionType;</span>
<a href="#l3.1249"></a><span id="l3.1249" class="difflineminus">-  if (m_transport &amp;&amp; m_mockChannel)</span>
<a href="#l3.1250"></a><span id="l3.1250" class="difflineminus">-  {</span>
<a href="#l3.1251"></a><span id="l3.1251" class="difflineplus">+  if (m_transport &amp;&amp; m_mockChannel) {</span>
<a href="#l3.1252"></a><span id="l3.1252">     uint8_t qos;</span>
<a href="#l3.1253"></a><span id="l3.1253">     rv = GetQoSBits(&amp;qos);</span>
<a href="#l3.1254"></a><span id="l3.1254" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.1255"></a><span id="l3.1255" class="difflineminus">-      m_transport-&gt;SetQoSBits(qos);</span>
<a href="#l3.1256"></a><span id="l3.1256" class="difflineplus">+    if (NS_SUCCEEDED(rv)) m_transport-&gt;SetQoSBits(qos);</span>
<a href="#l3.1257"></a><span id="l3.1257"> </span>
<a href="#l3.1258"></a><span id="l3.1258">     // Ensure that the socket can get the notification callbacks</span>
<a href="#l3.1259"></a><span id="l3.1259">     SetSecurityCallbacksFromChannel(m_transport, m_mockChannel);</span>
<a href="#l3.1260"></a><span id="l3.1260"> </span>
<a href="#l3.1261"></a><span id="l3.1261">     // open buffered, blocking input stream</span>
<a href="#l3.1262"></a><span id="l3.1262" class="difflineminus">-    rv = m_transport-&gt;OpenInputStream(nsITransport::OPEN_BLOCKING, 0, 0, getter_AddRefs(m_inputStream));</span>
<a href="#l3.1263"></a><span id="l3.1263" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.1264"></a><span id="l3.1264" class="difflineminus">-      return rv;</span>
<a href="#l3.1265"></a><span id="l3.1265" class="difflineplus">+    rv = m_transport-&gt;OpenInputStream(nsITransport::OPEN_BLOCKING, 0, 0,</span>
<a href="#l3.1266"></a><span id="l3.1266" class="difflineplus">+                                      getter_AddRefs(m_inputStream));</span>
<a href="#l3.1267"></a><span id="l3.1267" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l3.1268"></a><span id="l3.1268"> </span>
<a href="#l3.1269"></a><span id="l3.1269">     // open buffered, blocking output stream</span>
<a href="#l3.1270"></a><span id="l3.1270" class="difflineminus">-    rv = m_transport-&gt;OpenOutputStream(nsITransport::OPEN_BLOCKING, 0, 0, getter_AddRefs(m_outputStream));</span>
<a href="#l3.1271"></a><span id="l3.1271" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.1272"></a><span id="l3.1272" class="difflineminus">-      return rv;</span>
<a href="#l3.1273"></a><span id="l3.1273" class="difflineplus">+    rv = m_transport-&gt;OpenOutputStream(nsITransport::OPEN_BLOCKING, 0, 0,</span>
<a href="#l3.1274"></a><span id="l3.1274" class="difflineplus">+                                       getter_AddRefs(m_outputStream));</span>
<a href="#l3.1275"></a><span id="l3.1275" class="difflineplus">+    if (NS_FAILED(rv)) return rv;</span>
<a href="#l3.1276"></a><span id="l3.1276">     SetFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.1277"></a><span id="l3.1277">   }</span>
<a href="#l3.1278"></a><span id="l3.1278"> </span>
<a href="#l3.1279"></a><span id="l3.1279">   return rv;</span>
<a href="#l3.1280"></a><span id="l3.1280"> }</span>
<a href="#l3.1281"></a><span id="l3.1281"> </span>
<a href="#l3.1282"></a><span id="l3.1282" class="difflineminus">-</span>
<a href="#l3.1283"></a><span id="l3.1283" class="difflineminus">-// when the connection is done processing the current state, free any per url state data...</span>
<a href="#l3.1284"></a><span id="l3.1284" class="difflineminus">-void nsImapProtocol::ReleaseUrlState(bool rerunning)</span>
<a href="#l3.1285"></a><span id="l3.1285" class="difflineminus">-{</span>
<a href="#l3.1286"></a><span id="l3.1286" class="difflineminus">-  // clear out the socket's reference to the notification callbacks for this transaction</span>
<a href="#l3.1287"></a><span id="l3.1287" class="difflineplus">+// when the connection is done processing the current state, free any per url</span>
<a href="#l3.1288"></a><span id="l3.1288" class="difflineplus">+// state data...</span>
<a href="#l3.1289"></a><span id="l3.1289" class="difflineplus">+void nsImapProtocol::ReleaseUrlState(bool rerunning) {</span>
<a href="#l3.1290"></a><span id="l3.1290" class="difflineplus">+  // clear out the socket's reference to the notification callbacks for this</span>
<a href="#l3.1291"></a><span id="l3.1291" class="difflineplus">+  // transaction</span>
<a href="#l3.1292"></a><span id="l3.1292">   {</span>
<a href="#l3.1293"></a><span id="l3.1293">     MutexAutoLock mon(mLock);</span>
<a href="#l3.1294"></a><span id="l3.1294" class="difflineminus">-    if (m_transport)</span>
<a href="#l3.1295"></a><span id="l3.1295" class="difflineminus">-    {</span>
<a href="#l3.1296"></a><span id="l3.1296" class="difflineplus">+    if (m_transport) {</span>
<a href="#l3.1297"></a><span id="l3.1297">       m_transport-&gt;SetSecurityCallbacks(nullptr);</span>
<a href="#l3.1298"></a><span id="l3.1298">       m_transport-&gt;SetEventSink(nullptr, nullptr);</span>
<a href="#l3.1299"></a><span id="l3.1299">     }</span>
<a href="#l3.1300"></a><span id="l3.1300">   }</span>
<a href="#l3.1301"></a><span id="l3.1301"> </span>
<a href="#l3.1302"></a><span id="l3.1302" class="difflineminus">-  if (m_mockChannel &amp;&amp; !rerunning)</span>
<a href="#l3.1303"></a><span id="l3.1303" class="difflineminus">-  {</span>
<a href="#l3.1304"></a><span id="l3.1304" class="difflineplus">+  if (m_mockChannel &amp;&amp; !rerunning) {</span>
<a href="#l3.1305"></a><span id="l3.1305">     // Proxy the close of the channel to the ui thread.</span>
<a href="#l3.1306"></a><span id="l3.1306">     if (m_imapMailFolderSink)</span>
<a href="#l3.1307"></a><span id="l3.1307">       m_imapMailFolderSink-&gt;CloseMockChannel(m_mockChannel);</span>
<a href="#l3.1308"></a><span id="l3.1308">     else</span>
<a href="#l3.1309"></a><span id="l3.1309">       m_mockChannel-&gt;Close();</span>
<a href="#l3.1310"></a><span id="l3.1310"> </span>
<a href="#l3.1311"></a><span id="l3.1311">     {</span>
<a href="#l3.1312"></a><span id="l3.1312">       // grab a lock so m_mockChannel doesn't get cleared out</span>
<a href="#l3.1313"></a><span id="l3.1313">       // from under us.</span>
<a href="#l3.1314"></a><span id="l3.1314">       MutexAutoLock mon(mLock);</span>
<a href="#l3.1315"></a><span id="l3.1315" class="difflineminus">-      if (m_mockChannel)</span>
<a href="#l3.1316"></a><span id="l3.1316" class="difflineminus">-      {</span>
<a href="#l3.1317"></a><span id="l3.1317" class="difflineminus">-        // Proxy the release of the channel to the main thread.  This is something</span>
<a href="#l3.1318"></a><span id="l3.1318" class="difflineminus">-        // that the xpcom proxy system should do for us!</span>
<a href="#l3.1319"></a><span id="l3.1319" class="difflineminus">-        NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_mockChannel&quot;, m_mockChannel.forget());</span>
<a href="#l3.1320"></a><span id="l3.1320" class="difflineplus">+      if (m_mockChannel) {</span>
<a href="#l3.1321"></a><span id="l3.1321" class="difflineplus">+        // Proxy the release of the channel to the main thread.  This is</span>
<a href="#l3.1322"></a><span id="l3.1322" class="difflineplus">+        // something that the xpcom proxy system should do for us!</span>
<a href="#l3.1323"></a><span id="l3.1323" class="difflineplus">+        NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_mockChannel&quot;,</span>
<a href="#l3.1324"></a><span id="l3.1324" class="difflineplus">+                                          m_mockChannel.forget());</span>
<a href="#l3.1325"></a><span id="l3.1325">       }</span>
<a href="#l3.1326"></a><span id="l3.1326">     }</span>
<a href="#l3.1327"></a><span id="l3.1327">   }</span>
<a href="#l3.1328"></a><span id="l3.1328"> </span>
<a href="#l3.1329"></a><span id="l3.1329" class="difflineminus">-  m_channelContext = nullptr; // this might be the url - null it out before the final release of the url</span>
<a href="#l3.1330"></a><span id="l3.1330" class="difflineplus">+  m_channelContext = nullptr;  // this might be the url - null it out before the</span>
<a href="#l3.1331"></a><span id="l3.1331" class="difflineplus">+                               // final release of the url</span>
<a href="#l3.1332"></a><span id="l3.1332">   m_imapMessageSink = nullptr;</span>
<a href="#l3.1333"></a><span id="l3.1333"> </span>
<a href="#l3.1334"></a><span id="l3.1334">   // Proxy the release of the listener to the main thread.  This is something</span>
<a href="#l3.1335"></a><span id="l3.1335">   // that the xpcom proxy system should do for us!</span>
<a href="#l3.1336"></a><span id="l3.1336">   {</span>
<a href="#l3.1337"></a><span id="l3.1337">     // grab a lock so the m_channelListener doesn't get cleared.</span>
<a href="#l3.1338"></a><span id="l3.1338">     MutexAutoLock mon(mLock);</span>
<a href="#l3.1339"></a><span id="l3.1339" class="difflineminus">-    if (m_channelListener)</span>
<a href="#l3.1340"></a><span id="l3.1340" class="difflineminus">-    {</span>
<a href="#l3.1341"></a><span id="l3.1341" class="difflineminus">-      NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_channelListener&quot;, m_channelListener.forget());</span>
<a href="#l3.1342"></a><span id="l3.1342" class="difflineplus">+    if (m_channelListener) {</span>
<a href="#l3.1343"></a><span id="l3.1343" class="difflineplus">+      NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_channelListener&quot;,</span>
<a href="#l3.1344"></a><span id="l3.1344" class="difflineplus">+                                        m_channelListener.forget());</span>
<a href="#l3.1345"></a><span id="l3.1345">     }</span>
<a href="#l3.1346"></a><span id="l3.1346">   }</span>
<a href="#l3.1347"></a><span id="l3.1347">   m_channelInputStream = nullptr;</span>
<a href="#l3.1348"></a><span id="l3.1348">   m_channelOutputStream = nullptr;</span>
<a href="#l3.1349"></a><span id="l3.1349"> </span>
<a href="#l3.1350"></a><span id="l3.1350">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl;</span>
<a href="#l3.1351"></a><span id="l3.1351">   nsCOMPtr&lt;nsIImapMailFolderSink&gt; saveFolderSink;</span>
<a href="#l3.1352"></a><span id="l3.1352"> </span>
<a href="#l3.1353"></a><span id="l3.1353">   {</span>
<a href="#l3.1354"></a><span id="l3.1354">     MutexAutoLock mon(mLock);</span>
<a href="#l3.1355"></a><span id="l3.1355" class="difflineminus">-    if (m_runningUrl)</span>
<a href="#l3.1356"></a><span id="l3.1356" class="difflineminus">-    {</span>
<a href="#l3.1357"></a><span id="l3.1357" class="difflineplus">+    if (m_runningUrl) {</span>
<a href="#l3.1358"></a><span id="l3.1358">       mailnewsurl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.1359"></a><span id="l3.1359">       // It is unclear what 'saveFolderSink' is used for, most likely to hold</span>
<a href="#l3.1360"></a><span id="l3.1360">       // a reference for a little longer. See bug 1324893 and bug 391259.</span>
<a href="#l3.1361"></a><span id="l3.1361">       saveFolderSink = m_imapMailFolderSink;</span>
<a href="#l3.1362"></a><span id="l3.1362"> </span>
<a href="#l3.1363"></a><span id="l3.1363" class="difflineminus">-      m_runningUrl = nullptr; // force us to release our last reference on the url</span>
<a href="#l3.1364"></a><span id="l3.1364" class="difflineplus">+      m_runningUrl =</span>
<a href="#l3.1365"></a><span id="l3.1365" class="difflineplus">+          nullptr;  // force us to release our last reference on the url</span>
<a href="#l3.1366"></a><span id="l3.1366">       m_urlInProgress = false;</span>
<a href="#l3.1367"></a><span id="l3.1367">     }</span>
<a href="#l3.1368"></a><span id="l3.1368">   }</span>
<a href="#l3.1369"></a><span id="l3.1369">   // Need to null this out whether we have an m_runningUrl or not</span>
<a href="#l3.1370"></a><span id="l3.1370">   m_imapMailFolderSink = nullptr;</span>
<a href="#l3.1371"></a><span id="l3.1371"> </span>
<a href="#l3.1372"></a><span id="l3.1372" class="difflineminus">-  // we want to make sure the imap protocol's last reference to the url gets released</span>
<a href="#l3.1373"></a><span id="l3.1373" class="difflineminus">-  // back on the UI thread. This ensures that the objects the imap url hangs on to</span>
<a href="#l3.1374"></a><span id="l3.1374" class="difflineminus">-  // properly get released back on the UI thread.</span>
<a href="#l3.1375"></a><span id="l3.1375" class="difflineminus">-  if (mailnewsurl)</span>
<a href="#l3.1376"></a><span id="l3.1376" class="difflineminus">-  {</span>
<a href="#l3.1377"></a><span id="l3.1377" class="difflineminus">-    NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_runningUrl&quot;, mailnewsurl.forget());</span>
<a href="#l3.1378"></a><span id="l3.1378" class="difflineplus">+  // we want to make sure the imap protocol's last reference to the url gets</span>
<a href="#l3.1379"></a><span id="l3.1379" class="difflineplus">+  // released back on the UI thread. This ensures that the objects the imap url</span>
<a href="#l3.1380"></a><span id="l3.1380" class="difflineplus">+  // hangs on to properly get released back on the UI thread.</span>
<a href="#l3.1381"></a><span id="l3.1381" class="difflineplus">+  if (mailnewsurl) {</span>
<a href="#l3.1382"></a><span id="l3.1382" class="difflineplus">+    NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_runningUrl&quot;,</span>
<a href="#l3.1383"></a><span id="l3.1383" class="difflineplus">+                                      mailnewsurl.forget());</span>
<a href="#l3.1384"></a><span id="l3.1384">   }</span>
<a href="#l3.1385"></a><span id="l3.1385">   saveFolderSink = nullptr;</span>
<a href="#l3.1386"></a><span id="l3.1386"> }</span>
<a href="#l3.1387"></a><span id="l3.1387"> </span>
<a href="#l3.1388"></a><span id="l3.1388" class="difflineminus">-</span>
<a href="#l3.1389"></a><span id="l3.1389"> class nsImapThreadShutdownEvent : public mozilla::Runnable {</span>
<a href="#l3.1390"></a><span id="l3.1390" class="difflineminus">-public:</span>
<a href="#l3.1391"></a><span id="l3.1391" class="difflineplus">+ public:</span>
<a href="#l3.1392"></a><span id="l3.1392">   explicit nsImapThreadShutdownEvent(nsIThread *thread)</span>
<a href="#l3.1393"></a><span id="l3.1393" class="difflineminus">-    : mozilla::Runnable(&quot;nsImapThreadShutdownEvent&quot;), mThread(thread) {</span>
<a href="#l3.1394"></a><span id="l3.1394" class="difflineminus">-  }</span>
<a href="#l3.1395"></a><span id="l3.1395" class="difflineplus">+      : mozilla::Runnable(&quot;nsImapThreadShutdownEvent&quot;), mThread(thread) {}</span>
<a href="#l3.1396"></a><span id="l3.1396">   NS_IMETHOD Run() {</span>
<a href="#l3.1397"></a><span id="l3.1397">     mThread-&gt;Shutdown();</span>
<a href="#l3.1398"></a><span id="l3.1398">     return NS_OK;</span>
<a href="#l3.1399"></a><span id="l3.1399">   }</span>
<a href="#l3.1400"></a><span id="l3.1400" class="difflineminus">-private:</span>
<a href="#l3.1401"></a><span id="l3.1401" class="difflineplus">+</span>
<a href="#l3.1402"></a><span id="l3.1402" class="difflineplus">+ private:</span>
<a href="#l3.1403"></a><span id="l3.1403">   nsCOMPtr&lt;nsIThread&gt; mThread;</span>
<a href="#l3.1404"></a><span id="l3.1404"> };</span>
<a href="#l3.1405"></a><span id="l3.1405"> </span>
<a href="#l3.1406"></a><span id="l3.1406"> class nsImapCancelProxy : public mozilla::Runnable {</span>
<a href="#l3.1407"></a><span id="l3.1407" class="difflineminus">-public:</span>
<a href="#l3.1408"></a><span id="l3.1408" class="difflineplus">+ public:</span>
<a href="#l3.1409"></a><span id="l3.1409">   explicit nsImapCancelProxy(nsICancelable *aProxyRequest)</span>
<a href="#l3.1410"></a><span id="l3.1410" class="difflineminus">-    : mozilla::Runnable(&quot;nsImapCancelProxy&quot;), mRequest(aProxyRequest) {</span>
<a href="#l3.1411"></a><span id="l3.1411" class="difflineminus">-  }</span>
<a href="#l3.1412"></a><span id="l3.1412" class="difflineplus">+      : mozilla::Runnable(&quot;nsImapCancelProxy&quot;), mRequest(aProxyRequest) {}</span>
<a href="#l3.1413"></a><span id="l3.1413">   NS_IMETHOD Run() {</span>
<a href="#l3.1414"></a><span id="l3.1414" class="difflineminus">-    if (mRequest)</span>
<a href="#l3.1415"></a><span id="l3.1415" class="difflineminus">-      mRequest-&gt;Cancel(NS_BINDING_ABORTED);</span>
<a href="#l3.1416"></a><span id="l3.1416" class="difflineplus">+    if (mRequest) mRequest-&gt;Cancel(NS_BINDING_ABORTED);</span>
<a href="#l3.1417"></a><span id="l3.1417">     return NS_OK;</span>
<a href="#l3.1418"></a><span id="l3.1418">   }</span>
<a href="#l3.1419"></a><span id="l3.1419" class="difflineminus">-private:</span>
<a href="#l3.1420"></a><span id="l3.1420" class="difflineplus">+</span>
<a href="#l3.1421"></a><span id="l3.1421" class="difflineplus">+ private:</span>
<a href="#l3.1422"></a><span id="l3.1422">   nsCOMPtr&lt;nsICancelable&gt; mRequest;</span>
<a href="#l3.1423"></a><span id="l3.1423"> };</span>
<a href="#l3.1424"></a><span id="l3.1424"> </span>
<a href="#l3.1425"></a><span id="l3.1425" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::Run()</span>
<a href="#l3.1426"></a><span id="l3.1426" class="difflineminus">-{</span>
<a href="#l3.1427"></a><span id="l3.1427" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::Run() {</span>
<a href="#l3.1428"></a><span id="l3.1428">   PR_CEnterMonitor(this);</span>
<a href="#l3.1429"></a><span id="l3.1429">   NS_ASSERTION(!m_imapThreadIsRunning,</span>
<a href="#l3.1430"></a><span id="l3.1430" class="difflineminus">-                 &quot;Oh. oh. thread is already running. What's wrong here?&quot;);</span>
<a href="#l3.1431"></a><span id="l3.1431" class="difflineminus">-    if (m_imapThreadIsRunning)</span>
<a href="#l3.1432"></a><span id="l3.1432" class="difflineminus">-    {</span>
<a href="#l3.1433"></a><span id="l3.1433" class="difflineminus">-        PR_CExitMonitor(this);</span>
<a href="#l3.1434"></a><span id="l3.1434" class="difflineminus">-        return NS_OK;</span>
<a href="#l3.1435"></a><span id="l3.1435" class="difflineminus">-    }</span>
<a href="#l3.1436"></a><span id="l3.1436" class="difflineplus">+               &quot;Oh. oh. thread is already running. What's wrong here?&quot;);</span>
<a href="#l3.1437"></a><span id="l3.1437" class="difflineplus">+  if (m_imapThreadIsRunning) {</span>
<a href="#l3.1438"></a><span id="l3.1438" class="difflineplus">+    PR_CExitMonitor(this);</span>
<a href="#l3.1439"></a><span id="l3.1439" class="difflineplus">+    return NS_OK;</span>
<a href="#l3.1440"></a><span id="l3.1440" class="difflineplus">+  }</span>
<a href="#l3.1441"></a><span id="l3.1441"> </span>
<a href="#l3.1442"></a><span id="l3.1442">   m_imapThreadIsRunning = true;</span>
<a href="#l3.1443"></a><span id="l3.1443">   PR_CExitMonitor(this);</span>
<a href="#l3.1444"></a><span id="l3.1444"> </span>
<a href="#l3.1445"></a><span id="l3.1445">   // call the platform specific main loop ....</span>
<a href="#l3.1446"></a><span id="l3.1446">   ImapThreadMainLoop();</span>
<a href="#l3.1447"></a><span id="l3.1447"> </span>
<a href="#l3.1448"></a><span id="l3.1448" class="difflineminus">-  if (m_proxyRequest)</span>
<a href="#l3.1449"></a><span id="l3.1449" class="difflineminus">-  {</span>
<a href="#l3.1450"></a><span id="l3.1450" class="difflineplus">+  if (m_proxyRequest) {</span>
<a href="#l3.1451"></a><span id="l3.1451">     // Cancel proxy on main thread.</span>
<a href="#l3.1452"></a><span id="l3.1452">     RefPtr&lt;nsImapCancelProxy&gt; cancelProxy =</span>
<a href="#l3.1453"></a><span id="l3.1453" class="difflineminus">-      new nsImapCancelProxy(m_proxyRequest);</span>
<a href="#l3.1454"></a><span id="l3.1454" class="difflineplus">+        new nsImapCancelProxy(m_proxyRequest);</span>
<a href="#l3.1455"></a><span id="l3.1455">     NS_DispatchToMainThread(cancelProxy, NS_DISPATCH_SYNC);</span>
<a href="#l3.1456"></a><span id="l3.1456">     m_proxyRequest = nullptr;</span>
<a href="#l3.1457"></a><span id="l3.1457">   }</span>
<a href="#l3.1458"></a><span id="l3.1458"> </span>
<a href="#l3.1459"></a><span id="l3.1459" class="difflineminus">-  if (m_runningUrl)</span>
<a href="#l3.1460"></a><span id="l3.1460" class="difflineminus">-  {</span>
<a href="#l3.1461"></a><span id="l3.1461" class="difflineminus">-    NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_runningUrl&quot;, m_runningUrl.forget());</span>
<a href="#l3.1462"></a><span id="l3.1462" class="difflineplus">+  if (m_runningUrl) {</span>
<a href="#l3.1463"></a><span id="l3.1463" class="difflineplus">+    NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::m_runningUrl&quot;,</span>
<a href="#l3.1464"></a><span id="l3.1464" class="difflineplus">+                                      m_runningUrl.forget());</span>
<a href="#l3.1465"></a><span id="l3.1465">   }</span>
<a href="#l3.1466"></a><span id="l3.1466"> </span>
<a href="#l3.1467"></a><span id="l3.1467">   // close streams via UI thread if it's not already done</span>
<a href="#l3.1468"></a><span id="l3.1468" class="difflineminus">-  if (m_imapProtocolSink)</span>
<a href="#l3.1469"></a><span id="l3.1469" class="difflineminus">-    m_imapProtocolSink-&gt;CloseStreams();</span>
<a href="#l3.1470"></a><span id="l3.1470" class="difflineplus">+  if (m_imapProtocolSink) m_imapProtocolSink-&gt;CloseStreams();</span>
<a href="#l3.1471"></a><span id="l3.1471"> </span>
<a href="#l3.1472"></a><span id="l3.1472">   m_imapMailFolderSink = nullptr;</span>
<a href="#l3.1473"></a><span id="l3.1473">   m_imapMessageSink = nullptr;</span>
<a href="#l3.1474"></a><span id="l3.1474"> </span>
<a href="#l3.1475"></a><span id="l3.1475">   // shutdown this thread, but do it from the main thread</span>
<a href="#l3.1476"></a><span id="l3.1476">   nsCOMPtr&lt;nsIRunnable&gt; ev = new nsImapThreadShutdownEvent(m_iThread);</span>
<a href="#l3.1477"></a><span id="l3.1477">   if (NS_FAILED(NS_DispatchToMainThread(ev)))</span>
<a href="#l3.1478"></a><span id="l3.1478">     NS_WARNING(&quot;Failed to dispatch nsImapThreadShutdownEvent&quot;);</span>
<a href="#l3.1479"></a><span id="l3.1479">   m_iThread = nullptr;</span>
<a href="#l3.1480"></a><span id="l3.1480"> </span>
<a href="#l3.1481"></a><span id="l3.1481">   // Release protocol object on the main thread to avoid destruction of 'this'</span>
<a href="#l3.1482"></a><span id="l3.1482">   // on the IMAP thread, which causes grief for weak references.</span>
<a href="#l3.1483"></a><span id="l3.1483">   nsCOMPtr&lt;nsIImapProtocol&gt; releaseOnMain(this);</span>
<a href="#l3.1484"></a><span id="l3.1484" class="difflineminus">-  NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::this&quot;, releaseOnMain.forget());</span>
<a href="#l3.1485"></a><span id="l3.1485" class="difflineplus">+  NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol::this&quot;,</span>
<a href="#l3.1486"></a><span id="l3.1486" class="difflineplus">+                                    releaseOnMain.forget());</span>
<a href="#l3.1487"></a><span id="l3.1487">   return NS_OK;</span>
<a href="#l3.1488"></a><span id="l3.1488"> }</span>
<a href="#l3.1489"></a><span id="l3.1489"> </span>
<a href="#l3.1490"></a><span id="l3.1490"> //</span>
<a href="#l3.1491"></a><span id="l3.1491"> // Must be called from UI thread only</span>
<a href="#l3.1492"></a><span id="l3.1492"> //</span>
<a href="#l3.1493"></a><span id="l3.1493" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::CloseStreams()</span>
<a href="#l3.1494"></a><span id="l3.1494" class="difflineminus">-{</span>
<a href="#l3.1495"></a><span id="l3.1495" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::CloseStreams() {</span>
<a href="#l3.1496"></a><span id="l3.1496">   // make sure that it is called by the UI thread</span>
<a href="#l3.1497"></a><span id="l3.1497" class="difflineminus">-  MOZ_ASSERT(NS_IsMainThread(), &quot;CloseStreams() should not be called from an off UI thread&quot;);</span>
<a href="#l3.1498"></a><span id="l3.1498" class="difflineplus">+  MOZ_ASSERT(NS_IsMainThread(),</span>
<a href="#l3.1499"></a><span id="l3.1499" class="difflineplus">+             &quot;CloseStreams() should not be called from an off UI thread&quot;);</span>
<a href="#l3.1500"></a><span id="l3.1500"> </span>
<a href="#l3.1501"></a><span id="l3.1501">   {</span>
<a href="#l3.1502"></a><span id="l3.1502">     MutexAutoLock mon(mLock);</span>
<a href="#l3.1503"></a><span id="l3.1503" class="difflineminus">-    if (m_transport)</span>
<a href="#l3.1504"></a><span id="l3.1504" class="difflineminus">-    {</span>
<a href="#l3.1505"></a><span id="l3.1505" class="difflineminus">-        // make sure the transport closes (even if someone is still indirectly</span>
<a href="#l3.1506"></a><span id="l3.1506" class="difflineminus">-        // referencing it).</span>
<a href="#l3.1507"></a><span id="l3.1507" class="difflineminus">-        m_transport-&gt;Close(NS_ERROR_ABORT);</span>
<a href="#l3.1508"></a><span id="l3.1508" class="difflineminus">-        m_transport = nullptr;</span>
<a href="#l3.1509"></a><span id="l3.1509" class="difflineplus">+    if (m_transport) {</span>
<a href="#l3.1510"></a><span id="l3.1510" class="difflineplus">+      // make sure the transport closes (even if someone is still indirectly</span>
<a href="#l3.1511"></a><span id="l3.1511" class="difflineplus">+      // referencing it).</span>
<a href="#l3.1512"></a><span id="l3.1512" class="difflineplus">+      m_transport-&gt;Close(NS_ERROR_ABORT);</span>
<a href="#l3.1513"></a><span id="l3.1513" class="difflineplus">+      m_transport = nullptr;</span>
<a href="#l3.1514"></a><span id="l3.1514">     }</span>
<a href="#l3.1515"></a><span id="l3.1515">     m_inputStream = nullptr;</span>
<a href="#l3.1516"></a><span id="l3.1516">     m_outputStream = nullptr;</span>
<a href="#l3.1517"></a><span id="l3.1517">     m_channelListener = nullptr;</span>
<a href="#l3.1518"></a><span id="l3.1518">     m_channelContext = nullptr;</span>
<a href="#l3.1519"></a><span id="l3.1519" class="difflineminus">-    if (m_mockChannel)</span>
<a href="#l3.1520"></a><span id="l3.1520" class="difflineminus">-    {</span>
<a href="#l3.1521"></a><span id="l3.1521" class="difflineminus">-        m_mockChannel-&gt;Close();</span>
<a href="#l3.1522"></a><span id="l3.1522" class="difflineminus">-        m_mockChannel = nullptr;</span>
<a href="#l3.1523"></a><span id="l3.1523" class="difflineplus">+    if (m_mockChannel) {</span>
<a href="#l3.1524"></a><span id="l3.1524" class="difflineplus">+      m_mockChannel-&gt;Close();</span>
<a href="#l3.1525"></a><span id="l3.1525" class="difflineplus">+      m_mockChannel = nullptr;</span>
<a href="#l3.1526"></a><span id="l3.1526">     }</span>
<a href="#l3.1527"></a><span id="l3.1527">     m_channelInputStream = nullptr;</span>
<a href="#l3.1528"></a><span id="l3.1528">     m_channelOutputStream = nullptr;</span>
<a href="#l3.1529"></a><span id="l3.1529"> </span>
<a href="#l3.1530"></a><span id="l3.1530">     // Close scope because we must let go of the monitor before calling</span>
<a href="#l3.1531"></a><span id="l3.1531">     // RemoveConnection to unblock anyone who tries to get a monitor to the</span>
<a href="#l3.1532"></a><span id="l3.1532">     // protocol object while holding onto a monitor to the server.</span>
<a href="#l3.1533"></a><span id="l3.1533">   }</span>
<a href="#l3.1534"></a><span id="l3.1534">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; me_server = do_QueryReferent(m_server);</span>
<a href="#l3.1535"></a><span id="l3.1535" class="difflineminus">-  if (me_server)</span>
<a href="#l3.1536"></a><span id="l3.1536" class="difflineminus">-  {</span>
<a href="#l3.1537"></a><span id="l3.1537" class="difflineminus">-      nsresult result;</span>
<a href="#l3.1538"></a><span id="l3.1538" class="difflineminus">-      nsCOMPtr&lt;nsIImapIncomingServer&gt;</span>
<a href="#l3.1539"></a><span id="l3.1539" class="difflineminus">-          aImapServer(do_QueryInterface(me_server, &amp;result));</span>
<a href="#l3.1540"></a><span id="l3.1540" class="difflineminus">-      if (NS_SUCCEEDED(result))</span>
<a href="#l3.1541"></a><span id="l3.1541" class="difflineminus">-          aImapServer-&gt;RemoveConnection(this);</span>
<a href="#l3.1542"></a><span id="l3.1542" class="difflineminus">-      me_server = nullptr;</span>
<a href="#l3.1543"></a><span id="l3.1543" class="difflineplus">+  if (me_server) {</span>
<a href="#l3.1544"></a><span id="l3.1544" class="difflineplus">+    nsresult result;</span>
<a href="#l3.1545"></a><span id="l3.1545" class="difflineplus">+    nsCOMPtr&lt;nsIImapIncomingServer&gt; aImapServer(</span>
<a href="#l3.1546"></a><span id="l3.1546" class="difflineplus">+        do_QueryInterface(me_server, &amp;result));</span>
<a href="#l3.1547"></a><span id="l3.1547" class="difflineplus">+    if (NS_SUCCEEDED(result)) aImapServer-&gt;RemoveConnection(this);</span>
<a href="#l3.1548"></a><span id="l3.1548" class="difflineplus">+    me_server = nullptr;</span>
<a href="#l3.1549"></a><span id="l3.1549">   }</span>
<a href="#l3.1550"></a><span id="l3.1550">   m_server = nullptr;</span>
<a href="#l3.1551"></a><span id="l3.1551">   // take this opportunity of being on the UI thread to</span>
<a href="#l3.1552"></a><span id="l3.1552">   // persist chunk prefs if they've changed</span>
<a href="#l3.1553"></a><span id="l3.1553" class="difflineminus">-  if (gChunkSizeDirty)</span>
<a href="#l3.1554"></a><span id="l3.1554" class="difflineminus">-  {</span>
<a href="#l3.1555"></a><span id="l3.1555" class="difflineminus">-    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l3.1556"></a><span id="l3.1556" class="difflineminus">-    if (prefBranch)</span>
<a href="#l3.1557"></a><span id="l3.1557" class="difflineminus">-    {</span>
<a href="#l3.1558"></a><span id="l3.1558" class="difflineplus">+  if (gChunkSizeDirty) {</span>
<a href="#l3.1559"></a><span id="l3.1559" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(</span>
<a href="#l3.1560"></a><span id="l3.1560" class="difflineplus">+        do_GetService(NS_PREFSERVICE_CONTRACTID));</span>
<a href="#l3.1561"></a><span id="l3.1561" class="difflineplus">+    if (prefBranch) {</span>
<a href="#l3.1562"></a><span id="l3.1562">       prefBranch-&gt;SetIntPref(&quot;mail.imap.chunk_size&quot;, gChunkSize);</span>
<a href="#l3.1563"></a><span id="l3.1563" class="difflineminus">-      prefBranch-&gt;SetIntPref(&quot;mail.imap.min_chunk_size_threshold&quot;, gChunkThreshold);</span>
<a href="#l3.1564"></a><span id="l3.1564" class="difflineplus">+      prefBranch-&gt;SetIntPref(&quot;mail.imap.min_chunk_size_threshold&quot;,</span>
<a href="#l3.1565"></a><span id="l3.1565" class="difflineplus">+                             gChunkThreshold);</span>
<a href="#l3.1566"></a><span id="l3.1566">       gChunkSizeDirty = false;</span>
<a href="#l3.1567"></a><span id="l3.1567">     }</span>
<a href="#l3.1568"></a><span id="l3.1568">   }</span>
<a href="#l3.1569"></a><span id="l3.1569">   return NS_OK;</span>
<a href="#l3.1570"></a><span id="l3.1570"> }</span>
<a href="#l3.1571"></a><span id="l3.1571"> </span>
<a href="#l3.1572"></a><span id="l3.1572"> NS_IMETHODIMP nsImapProtocol::GetUrlWindow(nsIMsgMailNewsUrl *aUrl,</span>
<a href="#l3.1573"></a><span id="l3.1573" class="difflineminus">-                                           nsIMsgWindow **aMsgWindow)</span>
<a href="#l3.1574"></a><span id="l3.1574" class="difflineminus">-{</span>
<a href="#l3.1575"></a><span id="l3.1575" class="difflineplus">+                                           nsIMsgWindow **aMsgWindow) {</span>
<a href="#l3.1576"></a><span id="l3.1576">   NS_ENSURE_ARG_POINTER(aUrl);</span>
<a href="#l3.1577"></a><span id="l3.1577">   NS_ENSURE_ARG_POINTER(aMsgWindow);</span>
<a href="#l3.1578"></a><span id="l3.1578">   return aUrl-&gt;GetMsgWindow(aMsgWindow);</span>
<a href="#l3.1579"></a><span id="l3.1579"> }</span>
<a href="#l3.1580"></a><span id="l3.1580"> </span>
<a href="#l3.1581"></a><span id="l3.1581" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::SetupMainThreadProxies()</span>
<a href="#l3.1582"></a><span id="l3.1582" class="difflineminus">-{</span>
<a href="#l3.1583"></a><span id="l3.1583" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::SetupMainThreadProxies() {</span>
<a href="#l3.1584"></a><span id="l3.1584">   return SetupSinkProxy();</span>
<a href="#l3.1585"></a><span id="l3.1585"> }</span>
<a href="#l3.1586"></a><span id="l3.1586"> </span>
<a href="#l3.1587"></a><span id="l3.1587" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::OnInputStreamReady(nsIAsyncInputStream *inStr)</span>
<a href="#l3.1588"></a><span id="l3.1588" class="difflineminus">-{</span>
<a href="#l3.1589"></a><span id="l3.1589" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::OnInputStreamReady(nsIAsyncInputStream *inStr) {</span>
<a href="#l3.1590"></a><span id="l3.1590">   // should we check if it's a close vs. data available?</span>
<a href="#l3.1591"></a><span id="l3.1591" class="difflineminus">-  if (m_idle)</span>
<a href="#l3.1592"></a><span id="l3.1592" class="difflineminus">-  {</span>
<a href="#l3.1593"></a><span id="l3.1593" class="difflineplus">+  if (m_idle) {</span>
<a href="#l3.1594"></a><span id="l3.1594">     uint64_t bytesAvailable = 0;</span>
<a href="#l3.1595"></a><span id="l3.1595" class="difflineminus">-    (void) inStr-&gt;Available(&amp;bytesAvailable);</span>
<a href="#l3.1596"></a><span id="l3.1596" class="difflineplus">+    (void)inStr-&gt;Available(&amp;bytesAvailable);</span>
<a href="#l3.1597"></a><span id="l3.1597">     // check if data available - might be a close</span>
<a href="#l3.1598"></a><span id="l3.1598" class="difflineminus">-    if (bytesAvailable != 0)</span>
<a href="#l3.1599"></a><span id="l3.1599" class="difflineminus">-    {</span>
<a href="#l3.1600"></a><span id="l3.1600" class="difflineplus">+    if (bytesAvailable != 0) {</span>
<a href="#l3.1601"></a><span id="l3.1601">       ReentrantMonitorAutoEnter mon(m_urlReadyToRunMonitor);</span>
<a href="#l3.1602"></a><span id="l3.1602">       m_lastActiveTime = PR_Now();</span>
<a href="#l3.1603"></a><span id="l3.1603">       m_nextUrlReadyToRun = true;</span>
<a href="#l3.1604"></a><span id="l3.1604">       mon.Notify();</span>
<a href="#l3.1605"></a><span id="l3.1605">     }</span>
<a href="#l3.1606"></a><span id="l3.1606">   }</span>
<a href="#l3.1607"></a><span id="l3.1607">   return NS_OK;</span>
<a href="#l3.1608"></a><span id="l3.1608"> }</span>
<a href="#l3.1609"></a><span id="l3.1609"> </span>
<a href="#l3.1610"></a><span id="l3.1610"> // this is to be called from the UI thread. It sets m_threadShouldDie,</span>
<a href="#l3.1611"></a><span id="l3.1611"> // and then signals the imap thread, which, when it wakes up, should exit.</span>
<a href="#l3.1612"></a><span id="l3.1612"> // The imap thread cleanup code will check m_safeToCloseConnection.</span>
<a href="#l3.1613"></a><span id="l3.1613"> NS_IMETHODIMP</span>
<a href="#l3.1614"></a><span id="l3.1614" class="difflineminus">-nsImapProtocol::TellThreadToDie(bool aIsSafeToClose)</span>
<a href="#l3.1615"></a><span id="l3.1615" class="difflineminus">-{</span>
<a href="#l3.1616"></a><span id="l3.1616" class="difflineminus">-  NS_WARNING_ASSERTION(NS_IsMainThread(),</span>
<a href="#l3.1617"></a><span id="l3.1617" class="difflineminus">-                       &quot;TellThreadToDie(aIsSafeToClose) should only be called from UI thread&quot;);</span>
<a href="#l3.1618"></a><span id="l3.1618" class="difflineplus">+nsImapProtocol::TellThreadToDie(bool aIsSafeToClose) {</span>
<a href="#l3.1619"></a><span id="l3.1619" class="difflineplus">+  NS_WARNING_ASSERTION(</span>
<a href="#l3.1620"></a><span id="l3.1620" class="difflineplus">+      NS_IsMainThread(),</span>
<a href="#l3.1621"></a><span id="l3.1621" class="difflineplus">+      &quot;TellThreadToDie(aIsSafeToClose) should only be called from UI thread&quot;);</span>
<a href="#l3.1622"></a><span id="l3.1622">   MutexAutoLock mon(mLock);</span>
<a href="#l3.1623"></a><span id="l3.1623"> </span>
<a href="#l3.1624"></a><span id="l3.1624">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; me_server = do_QueryReferent(m_server);</span>
<a href="#l3.1625"></a><span id="l3.1625" class="difflineminus">-  if (me_server)</span>
<a href="#l3.1626"></a><span id="l3.1626" class="difflineminus">-  {</span>
<a href="#l3.1627"></a><span id="l3.1627" class="difflineplus">+  if (me_server) {</span>
<a href="#l3.1628"></a><span id="l3.1628">     nsresult rv;</span>
<a href="#l3.1629"></a><span id="l3.1629" class="difflineminus">-    nsCOMPtr&lt;nsIImapIncomingServer&gt;</span>
<a href="#l3.1630"></a><span id="l3.1630" class="difflineminus">-      aImapServer(do_QueryInterface(me_server, &amp;rv));</span>
<a href="#l3.1631"></a><span id="l3.1631" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.1632"></a><span id="l3.1632" class="difflineminus">-      aImapServer-&gt;RemoveConnection(this);</span>
<a href="#l3.1633"></a><span id="l3.1633" class="difflineplus">+    nsCOMPtr&lt;nsIImapIncomingServer&gt; aImapServer(</span>
<a href="#l3.1634"></a><span id="l3.1634" class="difflineplus">+        do_QueryInterface(me_server, &amp;rv));</span>
<a href="#l3.1635"></a><span id="l3.1635" class="difflineplus">+    if (NS_SUCCEEDED(rv)) aImapServer-&gt;RemoveConnection(this);</span>
<a href="#l3.1636"></a><span id="l3.1636">     m_server = nullptr;</span>
<a href="#l3.1637"></a><span id="l3.1637">     me_server = nullptr;</span>
<a href="#l3.1638"></a><span id="l3.1638">   }</span>
<a href="#l3.1639"></a><span id="l3.1639">   {</span>
<a href="#l3.1640"></a><span id="l3.1640">     ReentrantMonitorAutoEnter deathMon(m_threadDeathMonitor);</span>
<a href="#l3.1641"></a><span id="l3.1641">     m_safeToCloseConnection = aIsSafeToClose;</span>
<a href="#l3.1642"></a><span id="l3.1642">     m_threadShouldDie = true;</span>
<a href="#l3.1643"></a><span id="l3.1643">   }</span>
<a href="#l3.1644"></a><span id="l3.1644">   ReentrantMonitorAutoEnter readyMon(m_urlReadyToRunMonitor);</span>
<a href="#l3.1645"></a><span id="l3.1645">   m_nextUrlReadyToRun = true;</span>
<a href="#l3.1646"></a><span id="l3.1646">   readyMon.Notify();</span>
<a href="#l3.1647"></a><span id="l3.1647">   return NS_OK;</span>
<a href="#l3.1648"></a><span id="l3.1648"> }</span>
<a href="#l3.1649"></a><span id="l3.1649"> </span>
<a href="#l3.1650"></a><span id="l3.1650" class="difflineminus">-void</span>
<a href="#l3.1651"></a><span id="l3.1651" class="difflineminus">-nsImapProtocol::TellThreadToDie()</span>
<a href="#l3.1652"></a><span id="l3.1652" class="difflineminus">-{</span>
<a href="#l3.1653"></a><span id="l3.1653" class="difflineplus">+void nsImapProtocol::TellThreadToDie() {</span>
<a href="#l3.1654"></a><span id="l3.1654">   nsresult rv = NS_OK;</span>
<a href="#l3.1655"></a><span id="l3.1655">   NS_WARNING_ASSERTION(!NS_IsMainThread(),</span>
<a href="#l3.1656"></a><span id="l3.1656">                        &quot;TellThreadToDie() should not be called from UI thread&quot;);</span>
<a href="#l3.1657"></a><span id="l3.1657"> </span>
<a href="#l3.1658"></a><span id="l3.1658">   // prevent re-entering this method because it may lock the UI.</span>
<a href="#l3.1659"></a><span id="l3.1659" class="difflineminus">-  if (m_inThreadShouldDie)</span>
<a href="#l3.1660"></a><span id="l3.1660" class="difflineminus">-    return;</span>
<a href="#l3.1661"></a><span id="l3.1661" class="difflineplus">+  if (m_inThreadShouldDie) return;</span>
<a href="#l3.1662"></a><span id="l3.1662">   m_inThreadShouldDie = true;</span>
<a href="#l3.1663"></a><span id="l3.1663"> </span>
<a href="#l3.1664"></a><span id="l3.1664">   // This routine is called only from the imap protocol thread.</span>
<a href="#l3.1665"></a><span id="l3.1665">   // The UI thread causes this to be called by calling TellThreadToDie.</span>
<a href="#l3.1666"></a><span id="l3.1666">   // In that case, m_safeToCloseConnection will be FALSE if it's dropping a</span>
<a href="#l3.1667"></a><span id="l3.1667">   // timed out connection, true when closing a cached connection.</span>
<a href="#l3.1668"></a><span id="l3.1668">   // We're using PR_CEnter/ExitMonitor because Monitors don't like having</span>
<a href="#l3.1669"></a><span id="l3.1669">   // us to hold one monitor and call code that gets a different monitor. And</span>
<a href="#l3.1670"></a><span id="l3.1670">   // some of the methods we call here use Monitors.</span>
<a href="#l3.1671"></a><span id="l3.1671">   PR_CEnterMonitor(this);</span>
<a href="#l3.1672"></a><span id="l3.1672"> </span>
<a href="#l3.1673"></a><span id="l3.1673">   m_urlInProgress = true;  // let's say it's busy so no one tries to use</span>
<a href="#l3.1674"></a><span id="l3.1674" class="difflineminus">-                                // this about to die connection.</span>
<a href="#l3.1675"></a><span id="l3.1675" class="difflineplus">+                           // this about to die connection.</span>
<a href="#l3.1676"></a><span id="l3.1676">   bool urlWritingData = false;</span>
<a href="#l3.1677"></a><span id="l3.1677">   bool connectionIdle = !m_runningUrl;</span>
<a href="#l3.1678"></a><span id="l3.1678"> </span>
<a href="#l3.1679"></a><span id="l3.1679">   if (!connectionIdle)</span>
<a href="#l3.1680"></a><span id="l3.1680" class="difflineminus">-    urlWritingData = m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile</span>
<a href="#l3.1681"></a><span id="l3.1681" class="difflineminus">-      || m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile;</span>
<a href="#l3.1682"></a><span id="l3.1682" class="difflineplus">+    urlWritingData = m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile ||</span>
<a href="#l3.1683"></a><span id="l3.1683" class="difflineplus">+                     m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile;</span>
<a href="#l3.1684"></a><span id="l3.1684"> </span>
<a href="#l3.1685"></a><span id="l3.1685">   bool closeNeeded = GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.1686"></a><span id="l3.1686" class="difflineminus">-                nsImapServerResponseParser::kFolderSelected &amp;&amp; m_safeToCloseConnection;</span>
<a href="#l3.1687"></a><span id="l3.1687" class="difflineplus">+                         nsImapServerResponseParser::kFolderSelected &amp;&amp;</span>
<a href="#l3.1688"></a><span id="l3.1688" class="difflineplus">+                     m_safeToCloseConnection;</span>
<a href="#l3.1689"></a><span id="l3.1689">   nsCString command;</span>
<a href="#l3.1690"></a><span id="l3.1690">   // if a url is writing data, we can't even logout, so we're just</span>
<a href="#l3.1691"></a><span id="l3.1691">   // going to close the connection as if the user pressed stop.</span>
<a href="#l3.1692"></a><span id="l3.1692" class="difflineminus">-  if (m_currentServerCommandTagNumber &gt; 0 &amp;&amp; !urlWritingData)</span>
<a href="#l3.1693"></a><span id="l3.1693" class="difflineminus">-  {</span>
<a href="#l3.1694"></a><span id="l3.1694" class="difflineplus">+  if (m_currentServerCommandTagNumber &gt; 0 &amp;&amp; !urlWritingData) {</span>
<a href="#l3.1695"></a><span id="l3.1695">     bool isAlive = false;</span>
<a href="#l3.1696"></a><span id="l3.1696" class="difflineminus">-    if (m_transport)</span>
<a href="#l3.1697"></a><span id="l3.1697" class="difflineminus">-      rv = m_transport-&gt;IsAlive(&amp;isAlive);</span>
<a href="#l3.1698"></a><span id="l3.1698" class="difflineminus">-</span>
<a href="#l3.1699"></a><span id="l3.1699" class="difflineminus">-    if (TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; m_idle &amp;&amp; isAlive)</span>
<a href="#l3.1700"></a><span id="l3.1700" class="difflineminus">-      EndIdle(false);</span>
<a href="#l3.1701"></a><span id="l3.1701" class="difflineminus">-</span>
<a href="#l3.1702"></a><span id="l3.1702" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; isAlive &amp;&amp; closeNeeded &amp;&amp; GetDeleteIsMoveToTrash() &amp;&amp;</span>
<a href="#l3.1703"></a><span id="l3.1703" class="difflineminus">-        TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; m_outputStream)</span>
<a href="#l3.1704"></a><span id="l3.1704" class="difflineplus">+    if (m_transport) rv = m_transport-&gt;IsAlive(&amp;isAlive);</span>
<a href="#l3.1705"></a><span id="l3.1705" class="difflineplus">+</span>
<a href="#l3.1706"></a><span id="l3.1706" class="difflineplus">+    if (TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp; m_idle &amp;&amp; isAlive) EndIdle(false);</span>
<a href="#l3.1707"></a><span id="l3.1707" class="difflineplus">+</span>
<a href="#l3.1708"></a><span id="l3.1708" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; isAlive &amp;&amp; closeNeeded &amp;&amp;</span>
<a href="#l3.1709"></a><span id="l3.1709" class="difflineplus">+        GetDeleteIsMoveToTrash() &amp;&amp; TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp;</span>
<a href="#l3.1710"></a><span id="l3.1710" class="difflineplus">+        m_outputStream)</span>
<a href="#l3.1711"></a><span id="l3.1711">       Close(true, connectionIdle);</span>
<a href="#l3.1712"></a><span id="l3.1712"> </span>
<a href="#l3.1713"></a><span id="l3.1713">     if (NS_SUCCEEDED(rv) &amp;&amp; isAlive &amp;&amp; TestFlag(IMAP_CONNECTION_IS_OPEN) &amp;&amp;</span>
<a href="#l3.1714"></a><span id="l3.1714">         NS_SUCCEEDED(GetConnectionStatus()) &amp;&amp; m_outputStream)</span>
<a href="#l3.1715"></a><span id="l3.1715">       Logout(true, connectionIdle);</span>
<a href="#l3.1716"></a><span id="l3.1716">   }</span>
<a href="#l3.1717"></a><span id="l3.1717">   PR_CExitMonitor(this);</span>
<a href="#l3.1718"></a><span id="l3.1718">   // close streams via UI thread</span>
<a href="#l3.1719"></a><span id="l3.1719" class="difflineminus">-  if (m_imapProtocolSink)</span>
<a href="#l3.1720"></a><span id="l3.1720" class="difflineminus">-  {</span>
<a href="#l3.1721"></a><span id="l3.1721" class="difflineplus">+  if (m_imapProtocolSink) {</span>
<a href="#l3.1722"></a><span id="l3.1722">     m_imapProtocolSink-&gt;CloseStreams();</span>
<a href="#l3.1723"></a><span id="l3.1723">     m_imapProtocolSink = nullptr;</span>
<a href="#l3.1724"></a><span id="l3.1724">   }</span>
<a href="#l3.1725"></a><span id="l3.1725">   Log(&quot;TellThreadToDie&quot;, nullptr, &quot;close socket connection&quot;);</span>
<a href="#l3.1726"></a><span id="l3.1726"> </span>
<a href="#l3.1727"></a><span id="l3.1727">   {</span>
<a href="#l3.1728"></a><span id="l3.1728">     ReentrantMonitorAutoEnter mon(m_threadDeathMonitor);</span>
<a href="#l3.1729"></a><span id="l3.1729">     m_threadShouldDie = true;</span>
<a href="#l3.1730"></a><span id="l3.1730" class="difflineat">@@ -1413,264 +1311,241 @@ nsImapProtocol::TellThreadToDie()</span>
<a href="#l3.1731"></a><span id="l3.1731">     ReentrantMonitorAutoEnter dataMon(m_dataAvailableMonitor);</span>
<a href="#l3.1732"></a><span id="l3.1732">     dataMon.Notify();</span>
<a href="#l3.1733"></a><span id="l3.1733">   }</span>
<a href="#l3.1734"></a><span id="l3.1734">   ReentrantMonitorAutoEnter urlReadyMon(m_urlReadyToRunMonitor);</span>
<a href="#l3.1735"></a><span id="l3.1735">   urlReadyMon.NotifyAll();</span>
<a href="#l3.1736"></a><span id="l3.1736"> }</span>
<a href="#l3.1737"></a><span id="l3.1737"> </span>
<a href="#l3.1738"></a><span id="l3.1738"> NS_IMETHODIMP</span>
<a href="#l3.1739"></a><span id="l3.1739" class="difflineminus">-nsImapProtocol::GetLastActiveTimeStamp(PRTime* aTimeStamp)</span>
<a href="#l3.1740"></a><span id="l3.1740" class="difflineminus">-{</span>
<a href="#l3.1741"></a><span id="l3.1741" class="difflineminus">-  if (aTimeStamp)</span>
<a href="#l3.1742"></a><span id="l3.1742" class="difflineminus">-    *aTimeStamp = m_lastActiveTime;</span>
<a href="#l3.1743"></a><span id="l3.1743" class="difflineplus">+nsImapProtocol::GetLastActiveTimeStamp(PRTime *aTimeStamp) {</span>
<a href="#l3.1744"></a><span id="l3.1744" class="difflineplus">+  if (aTimeStamp) *aTimeStamp = m_lastActiveTime;</span>
<a href="#l3.1745"></a><span id="l3.1745">   return NS_OK;</span>
<a href="#l3.1746"></a><span id="l3.1746"> }</span>
<a href="#l3.1747"></a><span id="l3.1747"> </span>
<a href="#l3.1748"></a><span id="l3.1748"> static void DoomCacheEntry(nsIMsgMailNewsUrl *url);</span>
<a href="#l3.1749"></a><span id="l3.1749"> NS_IMETHODIMP</span>
<a href="#l3.1750"></a><span id="l3.1750" class="difflineminus">-nsImapProtocol::PseudoInterruptMsgLoad(nsIMsgFolder *aImapFolder, nsIMsgWindow *aMsgWindow, bool *interrupted)</span>
<a href="#l3.1751"></a><span id="l3.1751" class="difflineminus">-{</span>
<a href="#l3.1752"></a><span id="l3.1752" class="difflineminus">-  NS_ENSURE_ARG (interrupted);</span>
<a href="#l3.1753"></a><span id="l3.1753" class="difflineplus">+nsImapProtocol::PseudoInterruptMsgLoad(nsIMsgFolder *aImapFolder,</span>
<a href="#l3.1754"></a><span id="l3.1754" class="difflineplus">+                                       nsIMsgWindow *aMsgWindow,</span>
<a href="#l3.1755"></a><span id="l3.1755" class="difflineplus">+                                       bool *interrupted) {</span>
<a href="#l3.1756"></a><span id="l3.1756" class="difflineplus">+  NS_ENSURE_ARG(interrupted);</span>
<a href="#l3.1757"></a><span id="l3.1757"> </span>
<a href="#l3.1758"></a><span id="l3.1758">   *interrupted = false;</span>
<a href="#l3.1759"></a><span id="l3.1759"> </span>
<a href="#l3.1760"></a><span id="l3.1760">   PR_CEnterMonitor(this);</span>
<a href="#l3.1761"></a><span id="l3.1761"> </span>
<a href="#l3.1762"></a><span id="l3.1762" class="difflineminus">-  if (m_runningUrl &amp;&amp; !TestFlag(IMAP_CLEAN_UP_URL_STATE))</span>
<a href="#l3.1763"></a><span id="l3.1763" class="difflineminus">-  {</span>
<a href="#l3.1764"></a><span id="l3.1764" class="difflineplus">+  if (m_runningUrl &amp;&amp; !TestFlag(IMAP_CLEAN_UP_URL_STATE)) {</span>
<a href="#l3.1765"></a><span id="l3.1765">     nsImapAction imapAction;</span>
<a href="#l3.1766"></a><span id="l3.1766">     m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.1767"></a><span id="l3.1767"> </span>
<a href="#l3.1768"></a><span id="l3.1768" class="difflineminus">-    if (imapAction == nsIImapUrl::nsImapMsgFetch)</span>
<a href="#l3.1769"></a><span id="l3.1769" class="difflineminus">-    {</span>
<a href="#l3.1770"></a><span id="l3.1770" class="difflineplus">+    if (imapAction == nsIImapUrl::nsImapMsgFetch) {</span>
<a href="#l3.1771"></a><span id="l3.1771">       nsresult rv = NS_OK;</span>
<a href="#l3.1772"></a><span id="l3.1772">       nsCOMPtr&lt;nsIImapUrl&gt; runningImapURL;</span>
<a href="#l3.1773"></a><span id="l3.1773"> </span>
<a href="#l3.1774"></a><span id="l3.1774">       rv = GetRunningImapURL(getter_AddRefs(runningImapURL));</span>
<a href="#l3.1775"></a><span id="l3.1775" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; runningImapURL)</span>
<a href="#l3.1776"></a><span id="l3.1776" class="difflineminus">-      {</span>
<a href="#l3.1777"></a><span id="l3.1777" class="difflineminus">-        nsCOMPtr &lt;nsIMsgFolder&gt; runningImapFolder;</span>
<a href="#l3.1778"></a><span id="l3.1778" class="difflineminus">-        nsCOMPtr &lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l3.1779"></a><span id="l3.1779" class="difflineminus">-        nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(runningImapURL);</span>
<a href="#l3.1780"></a><span id="l3.1780" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; runningImapURL) {</span>
<a href="#l3.1781"></a><span id="l3.1781" class="difflineplus">+        nsCOMPtr&lt;nsIMsgFolder&gt; runningImapFolder;</span>
<a href="#l3.1782"></a><span id="l3.1782" class="difflineplus">+        nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l3.1783"></a><span id="l3.1783" class="difflineplus">+        nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl =</span>
<a href="#l3.1784"></a><span id="l3.1784" class="difflineplus">+            do_QueryInterface(runningImapURL);</span>
<a href="#l3.1785"></a><span id="l3.1785">         mailnewsUrl-&gt;GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.1786"></a><span id="l3.1786">         mailnewsUrl-&gt;GetFolder(getter_AddRefs(runningImapFolder));</span>
<a href="#l3.1787"></a><span id="l3.1787" class="difflineminus">-        if (aImapFolder == runningImapFolder &amp;&amp; msgWindow == aMsgWindow)</span>
<a href="#l3.1788"></a><span id="l3.1788" class="difflineminus">-        {</span>
<a href="#l3.1789"></a><span id="l3.1789" class="difflineminus">-          MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;PseudoInterruptMsgLoad(): Set PseudoInterrupt&quot;));</span>
<a href="#l3.1790"></a><span id="l3.1790" class="difflineplus">+        if (aImapFolder == runningImapFolder &amp;&amp; msgWindow == aMsgWindow) {</span>
<a href="#l3.1791"></a><span id="l3.1791" class="difflineplus">+          MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.1792"></a><span id="l3.1792" class="difflineplus">+                  (&quot;PseudoInterruptMsgLoad(): Set PseudoInterrupt&quot;));</span>
<a href="#l3.1793"></a><span id="l3.1793">           PseudoInterrupt(true);</span>
<a href="#l3.1794"></a><span id="l3.1794">           *interrupted = true;</span>
<a href="#l3.1795"></a><span id="l3.1795">         }</span>
<a href="#l3.1796"></a><span id="l3.1796">         // If we're interrupted, doom any incomplete cache entry.</span>
<a href="#l3.1797"></a><span id="l3.1797" class="difflineminus">-        MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;PseudoInterruptMsgLoad(): Call DoomCacheEntry()&quot;));</span>
<a href="#l3.1798"></a><span id="l3.1798" class="difflineplus">+        MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.1799"></a><span id="l3.1799" class="difflineplus">+                (&quot;PseudoInterruptMsgLoad(): Call DoomCacheEntry()&quot;));</span>
<a href="#l3.1800"></a><span id="l3.1800">         DoomCacheEntry(mailnewsUrl);</span>
<a href="#l3.1801"></a><span id="l3.1801">       }</span>
<a href="#l3.1802"></a><span id="l3.1802">     }</span>
<a href="#l3.1803"></a><span id="l3.1803">   }</span>
<a href="#l3.1804"></a><span id="l3.1804">   PR_CExitMonitor(this);</span>
<a href="#l3.1805"></a><span id="l3.1805"> #ifdef DEBUG_bienvenu</span>
<a href="#l3.1806"></a><span id="l3.1806">   printf(&quot;interrupt msg load : %s\n&quot;, (*interrupted) ? &quot;TRUE&quot; : &quot;FALSE&quot;);</span>
<a href="#l3.1807"></a><span id="l3.1807"> #endif</span>
<a href="#l3.1808"></a><span id="l3.1808">   return NS_OK;</span>
<a href="#l3.1809"></a><span id="l3.1809"> }</span>
<a href="#l3.1810"></a><span id="l3.1810"> </span>
<a href="#l3.1811"></a><span id="l3.1811" class="difflineminus">-void</span>
<a href="#l3.1812"></a><span id="l3.1812" class="difflineminus">-nsImapProtocol::ImapThreadMainLoop()</span>
<a href="#l3.1813"></a><span id="l3.1813" class="difflineminus">-{</span>
<a href="#l3.1814"></a><span id="l3.1814" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;ImapThreadMainLoop entering [this=%p]&quot;, this));</span>
<a href="#l3.1815"></a><span id="l3.1815" class="difflineplus">+void nsImapProtocol::ImapThreadMainLoop() {</span>
<a href="#l3.1816"></a><span id="l3.1816" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.1817"></a><span id="l3.1817" class="difflineplus">+          (&quot;ImapThreadMainLoop entering [this=%p]&quot;, this));</span>
<a href="#l3.1818"></a><span id="l3.1818"> </span>
<a href="#l3.1819"></a><span id="l3.1819">   PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l3.1820"></a><span id="l3.1820" class="difflineminus">-  while (!DeathSignalReceived())</span>
<a href="#l3.1821"></a><span id="l3.1821" class="difflineminus">-  {</span>
<a href="#l3.1822"></a><span id="l3.1822" class="difflineplus">+  while (!DeathSignalReceived()) {</span>
<a href="#l3.1823"></a><span id="l3.1823">     nsresult rv = NS_OK;</span>
<a href="#l3.1824"></a><span id="l3.1824">     bool readyToRun;</span>
<a href="#l3.1825"></a><span id="l3.1825"> </span>
<a href="#l3.1826"></a><span id="l3.1826">     // wait for an URL to process...</span>
<a href="#l3.1827"></a><span id="l3.1827">     {</span>
<a href="#l3.1828"></a><span id="l3.1828">       ReentrantMonitorAutoEnter mon(m_urlReadyToRunMonitor);</span>
<a href="#l3.1829"></a><span id="l3.1829"> </span>
<a href="#l3.1830"></a><span id="l3.1830">       while (NS_SUCCEEDED(rv) &amp;&amp; !DeathSignalReceived() &amp;&amp;</span>
<a href="#l3.1831"></a><span id="l3.1831">              !m_nextUrlReadyToRun &amp;&amp; !m_threadShouldDie)</span>
<a href="#l3.1832"></a><span id="l3.1832">         rv = mon.Wait(sleepTime);</span>
<a href="#l3.1833"></a><span id="l3.1833"> </span>
<a href="#l3.1834"></a><span id="l3.1834">       readyToRun = m_nextUrlReadyToRun;</span>
<a href="#l3.1835"></a><span id="l3.1835">       m_nextUrlReadyToRun = false;</span>
<a href="#l3.1836"></a><span id="l3.1836">     }</span>
<a href="#l3.1837"></a><span id="l3.1837">     // This will happen if the UI thread signals us to die</span>
<a href="#l3.1838"></a><span id="l3.1838" class="difflineminus">-    if (m_threadShouldDie)</span>
<a href="#l3.1839"></a><span id="l3.1839" class="difflineminus">-    {</span>
<a href="#l3.1840"></a><span id="l3.1840" class="difflineplus">+    if (m_threadShouldDie) {</span>
<a href="#l3.1841"></a><span id="l3.1841">       TellThreadToDie();</span>
<a href="#l3.1842"></a><span id="l3.1842">       break;</span>
<a href="#l3.1843"></a><span id="l3.1843">     }</span>
<a href="#l3.1844"></a><span id="l3.1844"> </span>
<a href="#l3.1845"></a><span id="l3.1845" class="difflineminus">-    if (NS_FAILED(rv) &amp;&amp; PR_PENDING_INTERRUPT_ERROR == PR_GetError())</span>
<a href="#l3.1846"></a><span id="l3.1846" class="difflineminus">-    {</span>
<a href="#l3.1847"></a><span id="l3.1847" class="difflineplus">+    if (NS_FAILED(rv) &amp;&amp; PR_PENDING_INTERRUPT_ERROR == PR_GetError()) {</span>
<a href="#l3.1848"></a><span id="l3.1848">       printf(&quot;error waiting for monitor\n&quot;);</span>
<a href="#l3.1849"></a><span id="l3.1849">       break;</span>
<a href="#l3.1850"></a><span id="l3.1850">     }</span>
<a href="#l3.1851"></a><span id="l3.1851"> </span>
<a href="#l3.1852"></a><span id="l3.1852" class="difflineminus">-    if (readyToRun &amp;&amp; m_runningUrl)</span>
<a href="#l3.1853"></a><span id="l3.1853" class="difflineminus">-    {</span>
<a href="#l3.1854"></a><span id="l3.1854" class="difflineminus">-      if (m_currentServerCommandTagNumber &amp;&amp; m_transport)</span>
<a href="#l3.1855"></a><span id="l3.1855" class="difflineminus">-      {</span>
<a href="#l3.1856"></a><span id="l3.1856" class="difflineplus">+    if (readyToRun &amp;&amp; m_runningUrl) {</span>
<a href="#l3.1857"></a><span id="l3.1857" class="difflineplus">+      if (m_currentServerCommandTagNumber &amp;&amp; m_transport) {</span>
<a href="#l3.1858"></a><span id="l3.1858">         bool isAlive;</span>
<a href="#l3.1859"></a><span id="l3.1859">         rv = m_transport-&gt;IsAlive(&amp;isAlive);</span>
<a href="#l3.1860"></a><span id="l3.1860" class="difflineminus">-        // if the transport is not alive, and we've ever sent a command with this connection, kill it.</span>
<a href="#l3.1861"></a><span id="l3.1861" class="difflineminus">-        // otherwise, we've probably just not finished setting it so don't kill it!</span>
<a href="#l3.1862"></a><span id="l3.1862" class="difflineminus">-        if (NS_FAILED(rv) || !isAlive)</span>
<a href="#l3.1863"></a><span id="l3.1863" class="difflineminus">-        {</span>
<a href="#l3.1864"></a><span id="l3.1864" class="difflineplus">+        // if the transport is not alive, and we've ever sent a command with</span>
<a href="#l3.1865"></a><span id="l3.1865" class="difflineplus">+        // this connection, kill it. otherwise, we've probably just not finished</span>
<a href="#l3.1866"></a><span id="l3.1866" class="difflineplus">+        // setting it so don't kill it!</span>
<a href="#l3.1867"></a><span id="l3.1867" class="difflineplus">+        if (NS_FAILED(rv) || !isAlive) {</span>
<a href="#l3.1868"></a><span id="l3.1868">           // This says we never started running the url, which is the case.</span>
<a href="#l3.1869"></a><span id="l3.1869">           m_runningUrl-&gt;SetRerunningUrl(false);</span>
<a href="#l3.1870"></a><span id="l3.1870">           RetryUrl();</span>
<a href="#l3.1871"></a><span id="l3.1871">           return;</span>
<a href="#l3.1872"></a><span id="l3.1872">         }</span>
<a href="#l3.1873"></a><span id="l3.1873">       }</span>
<a href="#l3.1874"></a><span id="l3.1874">       //</span>
<a href="#l3.1875"></a><span id="l3.1875">       // NOTE: Though we cleared m_nextUrlReadyToRun above, it may have been</span>
<a href="#l3.1876"></a><span id="l3.1876" class="difflineminus">-      //       set by LoadImapUrl, which runs on the main thread.  Because of this,</span>
<a href="#l3.1877"></a><span id="l3.1877" class="difflineminus">-      //       we must not try to clear m_nextUrlReadyToRun here.</span>
<a href="#l3.1878"></a><span id="l3.1878" class="difflineplus">+      //       set by LoadImapUrl, which runs on the main thread.  Because of</span>
<a href="#l3.1879"></a><span id="l3.1879" class="difflineplus">+      //       this, we must not try to clear m_nextUrlReadyToRun here.</span>
<a href="#l3.1880"></a><span id="l3.1880">       //</span>
<a href="#l3.1881"></a><span id="l3.1881" class="difflineminus">-      if (ProcessCurrentURL())</span>
<a href="#l3.1882"></a><span id="l3.1882" class="difflineminus">-      {</span>
<a href="#l3.1883"></a><span id="l3.1883" class="difflineplus">+      if (ProcessCurrentURL()) {</span>
<a href="#l3.1884"></a><span id="l3.1884">         m_nextUrlReadyToRun = true;</span>
<a href="#l3.1885"></a><span id="l3.1885">         m_imapMailFolderSink = nullptr;</span>
<a href="#l3.1886"></a><span id="l3.1886" class="difflineminus">-      }</span>
<a href="#l3.1887"></a><span id="l3.1887" class="difflineminus">-      else</span>
<a href="#l3.1888"></a><span id="l3.1888" class="difflineminus">-      {</span>
<a href="#l3.1889"></a><span id="l3.1889" class="difflineminus">-        // see if we want to go into idle mode. Might want to check a pref here too.</span>
<a href="#l3.1890"></a><span id="l3.1890" class="difflineminus">-        if (m_useIdle &amp;&amp; !m_urlInProgress &amp;&amp; GetServerStateParser().GetCapabilityFlag() &amp; kHasIdleCapability</span>
<a href="#l3.1891"></a><span id="l3.1891" class="difflineminus">-          &amp;&amp; GetServerStateParser().GetIMAPstate()</span>
<a href="#l3.1892"></a><span id="l3.1892" class="difflineminus">-                == nsImapServerResponseParser::kFolderSelected)</span>
<a href="#l3.1893"></a><span id="l3.1893" class="difflineminus">-        {</span>
<a href="#l3.1894"></a><span id="l3.1894" class="difflineminus">-          Idle(); // for now, lets just do it. We'll probably want to use a timer</span>
<a href="#l3.1895"></a><span id="l3.1895" class="difflineminus">-          if (!m_idle)</span>
<a href="#l3.1896"></a><span id="l3.1896" class="difflineminus">-          {</span>
<a href="#l3.1897"></a><span id="l3.1897" class="difflineplus">+      } else {</span>
<a href="#l3.1898"></a><span id="l3.1898" class="difflineplus">+        // see if we want to go into idle mode. Might want to check a pref here</span>
<a href="#l3.1899"></a><span id="l3.1899" class="difflineplus">+        // too.</span>
<a href="#l3.1900"></a><span id="l3.1900" class="difflineplus">+        if (m_useIdle &amp;&amp; !m_urlInProgress &amp;&amp;</span>
<a href="#l3.1901"></a><span id="l3.1901" class="difflineplus">+            GetServerStateParser().GetCapabilityFlag() &amp; kHasIdleCapability &amp;&amp;</span>
<a href="#l3.1902"></a><span id="l3.1902" class="difflineplus">+            GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.1903"></a><span id="l3.1903" class="difflineplus">+                nsImapServerResponseParser::kFolderSelected) {</span>
<a href="#l3.1904"></a><span id="l3.1904" class="difflineplus">+          Idle();  // for now, lets just do it. We'll probably want to use a</span>
<a href="#l3.1905"></a><span id="l3.1905" class="difflineplus">+                   // timer</span>
<a href="#l3.1906"></a><span id="l3.1906" class="difflineplus">+          if (!m_idle) {</span>
<a href="#l3.1907"></a><span id="l3.1907">             // Server rejected IDLE. Treat like IDLE not enabled or available.</span>
<a href="#l3.1908"></a><span id="l3.1908">             m_imapMailFolderSink = nullptr;</span>
<a href="#l3.1909"></a><span id="l3.1909">           }</span>
<a href="#l3.1910"></a><span id="l3.1910" class="difflineminus">-        }</span>
<a href="#l3.1911"></a><span id="l3.1911" class="difflineminus">-        else // if not idle, don't need to remember folder sink</span>
<a href="#l3.1912"></a><span id="l3.1912" class="difflineplus">+        } else  // if not idle, don't need to remember folder sink</span>
<a href="#l3.1913"></a><span id="l3.1913">           m_imapMailFolderSink = nullptr;</span>
<a href="#l3.1914"></a><span id="l3.1914">       }</span>
<a href="#l3.1915"></a><span id="l3.1915" class="difflineminus">-    }</span>
<a href="#l3.1916"></a><span id="l3.1916" class="difflineminus">-    else if (m_idle &amp;&amp; !m_threadShouldDie)</span>
<a href="#l3.1917"></a><span id="l3.1917" class="difflineminus">-    {</span>
<a href="#l3.1918"></a><span id="l3.1918" class="difflineplus">+    } else if (m_idle &amp;&amp; !m_threadShouldDie) {</span>
<a href="#l3.1919"></a><span id="l3.1919">       HandleIdleResponses();</span>
<a href="#l3.1920"></a><span id="l3.1920">     }</span>
<a href="#l3.1921"></a><span id="l3.1921" class="difflineminus">-    if (!GetServerStateParser().Connected())</span>
<a href="#l3.1922"></a><span id="l3.1922" class="difflineminus">-      break;</span>
<a href="#l3.1923"></a><span id="l3.1923" class="difflineplus">+    if (!GetServerStateParser().Connected()) break;</span>
<a href="#l3.1924"></a><span id="l3.1924"> #ifdef DEBUG_bienvenu</span>
<a href="#l3.1925"></a><span id="l3.1925">     else</span>
<a href="#l3.1926"></a><span id="l3.1926">       printf(&quot;ready to run but no url and not idle\n&quot;);</span>
<a href="#l3.1927"></a><span id="l3.1927"> #endif</span>
<a href="#l3.1928"></a><span id="l3.1928">     // This can happen if the UI thread closes cached connections in the</span>
<a href="#l3.1929"></a><span id="l3.1929">     // OnStopRunningUrl notification.</span>
<a href="#l3.1930"></a><span id="l3.1930" class="difflineminus">-    if (m_threadShouldDie)</span>
<a href="#l3.1931"></a><span id="l3.1931" class="difflineminus">-      TellThreadToDie();</span>
<a href="#l3.1932"></a><span id="l3.1932" class="difflineplus">+    if (m_threadShouldDie) TellThreadToDie();</span>
<a href="#l3.1933"></a><span id="l3.1933">   }</span>
<a href="#l3.1934"></a><span id="l3.1934">   m_imapThreadIsRunning = false;</span>
<a href="#l3.1935"></a><span id="l3.1935"> </span>
<a href="#l3.1936"></a><span id="l3.1936" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;ImapThreadMainLoop leaving [this=%p]&quot;, this));</span>
<a href="#l3.1937"></a><span id="l3.1937" class="difflineminus">-}</span>
<a href="#l3.1938"></a><span id="l3.1938" class="difflineminus">-</span>
<a href="#l3.1939"></a><span id="l3.1939" class="difflineminus">-void nsImapProtocol::HandleIdleResponses()</span>
<a href="#l3.1940"></a><span id="l3.1940" class="difflineminus">-{</span>
<a href="#l3.1941"></a><span id="l3.1941" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.1942"></a><span id="l3.1942" class="difflineplus">+          (&quot;ImapThreadMainLoop leaving [this=%p]&quot;, this));</span>
<a href="#l3.1943"></a><span id="l3.1943" class="difflineplus">+}</span>
<a href="#l3.1944"></a><span id="l3.1944" class="difflineplus">+</span>
<a href="#l3.1945"></a><span id="l3.1945" class="difflineplus">+void nsImapProtocol::HandleIdleResponses() {</span>
<a href="#l3.1946"></a><span id="l3.1946">   // int32_t oldRecent = GetServerStateParser().NumberOfRecentMessages();</span>
<a href="#l3.1947"></a><span id="l3.1947">   nsAutoCString commandBuffer(GetServerCommandTag());</span>
<a href="#l3.1948"></a><span id="l3.1948">   commandBuffer.AppendLiteral(&quot; IDLE&quot; CRLF);</span>
<a href="#l3.1949"></a><span id="l3.1949"> </span>
<a href="#l3.1950"></a><span id="l3.1950" class="difflineminus">-  do</span>
<a href="#l3.1951"></a><span id="l3.1951" class="difflineminus">-  {</span>
<a href="#l3.1952"></a><span id="l3.1952" class="difflineplus">+  do {</span>
<a href="#l3.1953"></a><span id="l3.1953">     ParseIMAPandCheckForNewMail(commandBuffer.get());</span>
<a href="#l3.1954"></a><span id="l3.1954" class="difflineminus">-  }</span>
<a href="#l3.1955"></a><span id="l3.1955" class="difflineminus">-  while (m_inputStreamBuffer-&gt;NextLineAvailable() &amp;&amp; GetServerStateParser().Connected());</span>
<a href="#l3.1956"></a><span id="l3.1956" class="difflineplus">+  } while (m_inputStreamBuffer-&gt;NextLineAvailable() &amp;&amp;</span>
<a href="#l3.1957"></a><span id="l3.1957" class="difflineplus">+           GetServerStateParser().Connected());</span>
<a href="#l3.1958"></a><span id="l3.1958"> </span>
<a href="#l3.1959"></a><span id="l3.1959">   //  if (oldRecent != GetServerStateParser().NumberOfRecentMessages())</span>
<a href="#l3.1960"></a><span id="l3.1960">   //  We might check that something actually changed, but for now we can</span>
<a href="#l3.1961"></a><span id="l3.1961">   // just assume it. OnNewIdleMessages must run a url, so that</span>
<a href="#l3.1962"></a><span id="l3.1962">   // we'll go back into asyncwait mode.</span>
<a href="#l3.1963"></a><span id="l3.1963">   if (GetServerStateParser().Connected() &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.1964"></a><span id="l3.1964">     m_imapMailFolderSink-&gt;OnNewIdleMessages();</span>
<a href="#l3.1965"></a><span id="l3.1965"> }</span>
<a href="#l3.1966"></a><span id="l3.1966"> </span>
<a href="#l3.1967"></a><span id="l3.1967" class="difflineminus">-void nsImapProtocol::EstablishServerConnection()</span>
<a href="#l3.1968"></a><span id="l3.1968" class="difflineminus">-{</span>
<a href="#l3.1969"></a><span id="l3.1969" class="difflineplus">+void nsImapProtocol::EstablishServerConnection() {</span>
<a href="#l3.1970"></a><span id="l3.1970"> #define ESC_LENGTH(x) (sizeof(x) - 1)</span>
<a href="#l3.1971"></a><span id="l3.1971" class="difflineminus">-#define ESC_OK                      &quot;* OK&quot;</span>
<a href="#l3.1972"></a><span id="l3.1972" class="difflineminus">-#define ESC_OK_LEN                  ESC_LENGTH(ESC_OK)</span>
<a href="#l3.1973"></a><span id="l3.1973" class="difflineminus">-#define ESC_PREAUTH                 &quot;* PREAUTH&quot;</span>
<a href="#l3.1974"></a><span id="l3.1974" class="difflineminus">-#define ESC_PREAUTH_LEN             ESC_LENGTH(ESC_PREAUTH)</span>
<a href="#l3.1975"></a><span id="l3.1975" class="difflineminus">-#define ESC_CAPABILITY_STAR         &quot;* &quot;</span>
<a href="#l3.1976"></a><span id="l3.1976" class="difflineminus">-#define ESC_CAPABILITY_STAR_LEN     ESC_LENGTH(ESC_CAPABILITY_STAR)</span>
<a href="#l3.1977"></a><span id="l3.1977" class="difflineminus">-#define ESC_CAPABILITY_OK           &quot;* OK [&quot;</span>
<a href="#l3.1978"></a><span id="l3.1978" class="difflineminus">-#define ESC_CAPABILITY_OK_LEN       ESC_LENGTH(ESC_CAPABILITY_OK)</span>
<a href="#l3.1979"></a><span id="l3.1979" class="difflineminus">-#define ESC_CAPABILITY_GREETING     (ESC_CAPABILITY_OK &quot;CAPABILITY&quot;)</span>
<a href="#l3.1980"></a><span id="l3.1980" class="difflineplus">+#define ESC_OK &quot;* OK&quot;</span>
<a href="#l3.1981"></a><span id="l3.1981" class="difflineplus">+#define ESC_OK_LEN ESC_LENGTH(ESC_OK)</span>
<a href="#l3.1982"></a><span id="l3.1982" class="difflineplus">+#define ESC_PREAUTH &quot;* PREAUTH&quot;</span>
<a href="#l3.1983"></a><span id="l3.1983" class="difflineplus">+#define ESC_PREAUTH_LEN ESC_LENGTH(ESC_PREAUTH)</span>
<a href="#l3.1984"></a><span id="l3.1984" class="difflineplus">+#define ESC_CAPABILITY_STAR &quot;* &quot;</span>
<a href="#l3.1985"></a><span id="l3.1985" class="difflineplus">+#define ESC_CAPABILITY_STAR_LEN ESC_LENGTH(ESC_CAPABILITY_STAR)</span>
<a href="#l3.1986"></a><span id="l3.1986" class="difflineplus">+#define ESC_CAPABILITY_OK &quot;* OK [&quot;</span>
<a href="#l3.1987"></a><span id="l3.1987" class="difflineplus">+#define ESC_CAPABILITY_OK_LEN ESC_LENGTH(ESC_CAPABILITY_OK)</span>
<a href="#l3.1988"></a><span id="l3.1988" class="difflineplus">+#define ESC_CAPABILITY_GREETING (ESC_CAPABILITY_OK &quot;CAPABILITY&quot;)</span>
<a href="#l3.1989"></a><span id="l3.1989"> #define ESC_CAPABILITY_GREETING_LEN ESC_LENGTH(ESC_CAPABILITY_GREETING)</span>
<a href="#l3.1990"></a><span id="l3.1990"> </span>
<a href="#l3.1991"></a><span id="l3.1991" class="difflineminus">-  char * serverResponse = CreateNewLineFromSocket(); // read in the greeting</span>
<a href="#l3.1992"></a><span id="l3.1992" class="difflineminus">-</span>
<a href="#l3.1993"></a><span id="l3.1993" class="difflineminus">-  // record the fact that we've received a greeting for this connection so we don't ever</span>
<a href="#l3.1994"></a><span id="l3.1994" class="difflineminus">-  // try to do it again..</span>
<a href="#l3.1995"></a><span id="l3.1995" class="difflineminus">-  if (serverResponse)</span>
<a href="#l3.1996"></a><span id="l3.1996" class="difflineminus">-    SetFlag(IMAP_RECEIVED_GREETING);</span>
<a href="#l3.1997"></a><span id="l3.1997" class="difflineminus">-</span>
<a href="#l3.1998"></a><span id="l3.1998" class="difflineminus">-  if (!PL_strncasecmp(serverResponse, ESC_OK, ESC_OK_LEN))</span>
<a href="#l3.1999"></a><span id="l3.1999" class="difflineminus">-  {</span>
<a href="#l3.2000"></a><span id="l3.2000" class="difflineplus">+  char *serverResponse = CreateNewLineFromSocket();  // read in the greeting</span>
<a href="#l3.2001"></a><span id="l3.2001" class="difflineplus">+</span>
<a href="#l3.2002"></a><span id="l3.2002" class="difflineplus">+  // record the fact that we've received a greeting for this connection so we</span>
<a href="#l3.2003"></a><span id="l3.2003" class="difflineplus">+  // don't ever try to do it again..</span>
<a href="#l3.2004"></a><span id="l3.2004" class="difflineplus">+  if (serverResponse) SetFlag(IMAP_RECEIVED_GREETING);</span>
<a href="#l3.2005"></a><span id="l3.2005" class="difflineplus">+</span>
<a href="#l3.2006"></a><span id="l3.2006" class="difflineplus">+  if (!PL_strncasecmp(serverResponse, ESC_OK, ESC_OK_LEN)) {</span>
<a href="#l3.2007"></a><span id="l3.2007">     SetConnectionStatus(NS_OK);</span>
<a href="#l3.2008"></a><span id="l3.2008"> </span>
<a href="#l3.2009"></a><span id="l3.2009" class="difflineminus">-    if (!PL_strncasecmp(serverResponse, ESC_CAPABILITY_GREETING, ESC_CAPABILITY_GREETING_LEN))</span>
<a href="#l3.2010"></a><span id="l3.2010" class="difflineminus">-    {</span>
<a href="#l3.2011"></a><span id="l3.2011" class="difflineplus">+    if (!PL_strncasecmp(serverResponse, ESC_CAPABILITY_GREETING,</span>
<a href="#l3.2012"></a><span id="l3.2012" class="difflineplus">+                        ESC_CAPABILITY_GREETING_LEN)) {</span>
<a href="#l3.2013"></a><span id="l3.2013">       nsAutoCString tmpstr(serverResponse);</span>
<a href="#l3.2014"></a><span id="l3.2014">       int32_t endIndex = tmpstr.FindChar(']', ESC_CAPABILITY_GREETING_LEN);</span>
<a href="#l3.2015"></a><span id="l3.2015" class="difflineminus">-      if (endIndex &gt;= 0)</span>
<a href="#l3.2016"></a><span id="l3.2016" class="difflineminus">-      {</span>
<a href="#l3.2017"></a><span id="l3.2017" class="difflineplus">+      if (endIndex &gt;= 0) {</span>
<a href="#l3.2018"></a><span id="l3.2018">         // Allocate the new buffer here. This buffer will be passed to</span>
<a href="#l3.2019"></a><span id="l3.2019">         // ParseIMAPServerResponse() where it will be used to fill the</span>
<a href="#l3.2020"></a><span id="l3.2020">         // fCurrentLine field and will be freed by the next call to</span>
<a href="#l3.2021"></a><span id="l3.2021">         // ResetLexAnalyzer().</span>
<a href="#l3.2022"></a><span id="l3.2022" class="difflineminus">-        char *fakeServerResponse = (char*)PR_Malloc(PL_strlen(serverResponse));</span>
<a href="#l3.2023"></a><span id="l3.2023" class="difflineplus">+        char *fakeServerResponse = (char *)PR_Malloc(PL_strlen(serverResponse));</span>
<a href="#l3.2024"></a><span id="l3.2024">         // Munge the greeting into something that would pass for an IMAP</span>
<a href="#l3.2025"></a><span id="l3.2025">         // server's response to a &quot;CAPABILITY&quot; command.</span>
<a href="#l3.2026"></a><span id="l3.2026">         strcpy(fakeServerResponse, ESC_CAPABILITY_STAR);</span>
<a href="#l3.2027"></a><span id="l3.2027">         strcat(fakeServerResponse, serverResponse + ESC_CAPABILITY_OK_LEN);</span>
<a href="#l3.2028"></a><span id="l3.2028" class="difflineminus">-        fakeServerResponse[endIndex - ESC_CAPABILITY_OK_LEN + ESC_CAPABILITY_STAR_LEN] = '\0';</span>
<a href="#l3.2029"></a><span id="l3.2029" class="difflineplus">+        fakeServerResponse[endIndex - ESC_CAPABILITY_OK_LEN +</span>
<a href="#l3.2030"></a><span id="l3.2030" class="difflineplus">+                           ESC_CAPABILITY_STAR_LEN] = '\0';</span>
<a href="#l3.2031"></a><span id="l3.2031">         // Tell the response parser that we just issued a &quot;CAPABILITY&quot; and</span>
<a href="#l3.2032"></a><span id="l3.2032">         // got the following back.</span>
<a href="#l3.2033"></a><span id="l3.2033" class="difflineminus">-        GetServerStateParser().ParseIMAPServerResponse(&quot;1 CAPABILITY&quot;, true, fakeServerResponse);</span>
<a href="#l3.2034"></a><span id="l3.2034" class="difflineplus">+        GetServerStateParser().ParseIMAPServerResponse(&quot;1 CAPABILITY&quot;, true,</span>
<a href="#l3.2035"></a><span id="l3.2035" class="difflineplus">+                                                       fakeServerResponse);</span>
<a href="#l3.2036"></a><span id="l3.2036">       }</span>
<a href="#l3.2037"></a><span id="l3.2037">     }</span>
<a href="#l3.2038"></a><span id="l3.2038" class="difflineminus">-  }</span>
<a href="#l3.2039"></a><span id="l3.2039" class="difflineminus">-  else if (!PL_strncasecmp(serverResponse, ESC_PREAUTH, ESC_PREAUTH_LEN))</span>
<a href="#l3.2040"></a><span id="l3.2040" class="difflineminus">-  {</span>
<a href="#l3.2041"></a><span id="l3.2041" class="difflineplus">+  } else if (!PL_strncasecmp(serverResponse, ESC_PREAUTH, ESC_PREAUTH_LEN)) {</span>
<a href="#l3.2042"></a><span id="l3.2042">     // we've been pre-authenticated.</span>
<a href="#l3.2043"></a><span id="l3.2043">     // we can skip the whole password step, right into the</span>
<a href="#l3.2044"></a><span id="l3.2044">     // kAuthenticated state</span>
<a href="#l3.2045"></a><span id="l3.2045">     GetServerStateParser().PreauthSetAuthenticatedState();</span>
<a href="#l3.2046"></a><span id="l3.2046"> </span>
<a href="#l3.2047"></a><span id="l3.2047">     if (GetServerStateParser().GetCapabilityFlag() == kCapabilityUndefined)</span>
<a href="#l3.2048"></a><span id="l3.2048">       Capability();</span>
<a href="#l3.2049"></a><span id="l3.2049"> </span>
<a href="#l3.2050"></a><span id="l3.2050" class="difflineminus">-    if ( !(GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.2051"></a><span id="l3.2051" class="difflineminus">-          (kIMAP4Capability | kIMAP4rev1Capability | kIMAP4other) ) )</span>
<a href="#l3.2052"></a><span id="l3.2052" class="difflineminus">-    {</span>
<a href="#l3.2053"></a><span id="l3.2053" class="difflineplus">+    if (!(GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.2054"></a><span id="l3.2054" class="difflineplus">+          (kIMAP4Capability | kIMAP4rev1Capability | kIMAP4other))) {</span>
<a href="#l3.2055"></a><span id="l3.2055">       // AlertUserEvent_UsingId(MK_MSG_IMAP_SERVER_NOT_IMAP4);</span>
<a href="#l3.2056"></a><span id="l3.2056" class="difflineminus">-      SetConnectionStatus(NS_ERROR_FAILURE);        // stop netlib</span>
<a href="#l3.2057"></a><span id="l3.2057" class="difflineminus">-    }</span>
<a href="#l3.2058"></a><span id="l3.2058" class="difflineminus">-    else</span>
<a href="#l3.2059"></a><span id="l3.2059" class="difflineminus">-    {</span>
<a href="#l3.2060"></a><span id="l3.2060" class="difflineplus">+      SetConnectionStatus(NS_ERROR_FAILURE);  // stop netlib</span>
<a href="#l3.2061"></a><span id="l3.2061" class="difflineplus">+    } else {</span>
<a href="#l3.2062"></a><span id="l3.2062">       // let's record the user as authenticated.</span>
<a href="#l3.2063"></a><span id="l3.2063">       m_imapServerSink-&gt;SetUserAuthenticated(true);</span>
<a href="#l3.2064"></a><span id="l3.2064"> </span>
<a href="#l3.2065"></a><span id="l3.2065">       ProcessAfterAuthenticated();</span>
<a href="#l3.2066"></a><span id="l3.2066">       // the connection was a success</span>
<a href="#l3.2067"></a><span id="l3.2067">       SetConnectionStatus(NS_OK);</span>
<a href="#l3.2068"></a><span id="l3.2068" class="difflineminus">-     }</span>
<a href="#l3.2069"></a><span id="l3.2069" class="difflineminus">-  }</span>
<a href="#l3.2070"></a><span id="l3.2070" class="difflineminus">-</span>
<a href="#l3.2071"></a><span id="l3.2071" class="difflineminus">-  PR_Free(serverResponse); // we don't care about the greeting yet...</span>
<a href="#l3.2072"></a><span id="l3.2072" class="difflineplus">+    }</span>
<a href="#l3.2073"></a><span id="l3.2073" class="difflineplus">+  }</span>
<a href="#l3.2074"></a><span id="l3.2074" class="difflineplus">+</span>
<a href="#l3.2075"></a><span id="l3.2075" class="difflineplus">+  PR_Free(serverResponse);  // we don't care about the greeting yet...</span>
<a href="#l3.2076"></a><span id="l3.2076"> </span>
<a href="#l3.2077"></a><span id="l3.2077"> #undef ESC_LENGTH</span>
<a href="#l3.2078"></a><span id="l3.2078"> #undef ESC_OK</span>
<a href="#l3.2079"></a><span id="l3.2079"> #undef ESC_OK_LEN</span>
<a href="#l3.2080"></a><span id="l3.2080"> #undef ESC_PREAUTH</span>
<a href="#l3.2081"></a><span id="l3.2081"> #undef ESC_PREAUTH_LEN</span>
<a href="#l3.2082"></a><span id="l3.2082"> #undef ESC_CAPABILITY_STAR</span>
<a href="#l3.2083"></a><span id="l3.2083"> #undef ESC_CAPABILITY_STAR_LEN</span>
<a href="#l3.2084"></a><span id="l3.2084" class="difflineat">@@ -1678,799 +1553,730 @@ void nsImapProtocol::EstablishServerConn</span>
<a href="#l3.2085"></a><span id="l3.2085"> #undef ESC_CAPABILITY_OK_LEN</span>
<a href="#l3.2086"></a><span id="l3.2086"> #undef ESC_CAPABILITY_GREETING</span>
<a href="#l3.2087"></a><span id="l3.2087"> #undef ESC_CAPABILITY_GREETING_LEN</span>
<a href="#l3.2088"></a><span id="l3.2088"> }</span>
<a href="#l3.2089"></a><span id="l3.2089"> </span>
<a href="#l3.2090"></a><span id="l3.2090"> // This can get called from the UI thread or an imap thread.</span>
<a href="#l3.2091"></a><span id="l3.2091"> // It makes sure we don't get left with partial messages in</span>
<a href="#l3.2092"></a><span id="l3.2092"> // the memory cache.</span>
<a href="#l3.2093"></a><span id="l3.2093" class="difflineminus">-static void DoomCacheEntry(nsIMsgMailNewsUrl *url)</span>
<a href="#l3.2094"></a><span id="l3.2094" class="difflineminus">-{</span>
<a href="#l3.2095"></a><span id="l3.2095" class="difflineplus">+static void DoomCacheEntry(nsIMsgMailNewsUrl *url) {</span>
<a href="#l3.2096"></a><span id="l3.2096">   bool readingFromMemCache = false;</span>
<a href="#l3.2097"></a><span id="l3.2097">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(url);</span>
<a href="#l3.2098"></a><span id="l3.2098">   imapUrl-&gt;GetMsgLoadingFromCache(&amp;readingFromMemCache);</span>
<a href="#l3.2099"></a><span id="l3.2099" class="difflineminus">-  if (!readingFromMemCache)</span>
<a href="#l3.2100"></a><span id="l3.2100" class="difflineminus">-  {</span>
<a href="#l3.2101"></a><span id="l3.2101" class="difflineplus">+  if (!readingFromMemCache) {</span>
<a href="#l3.2102"></a><span id="l3.2102">     nsCOMPtr&lt;nsICacheEntry&gt; cacheEntry;</span>
<a href="#l3.2103"></a><span id="l3.2103">     url-&gt;GetMemCacheEntry(getter_AddRefs(cacheEntry));</span>
<a href="#l3.2104"></a><span id="l3.2104" class="difflineminus">-    if (cacheEntry)</span>
<a href="#l3.2105"></a><span id="l3.2105" class="difflineminus">-    {</span>
<a href="#l3.2106"></a><span id="l3.2106" class="difflineminus">-      MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;DoomCacheEntry(): Call AsyncDoom()&quot;));</span>
<a href="#l3.2107"></a><span id="l3.2107" class="difflineplus">+    if (cacheEntry) {</span>
<a href="#l3.2108"></a><span id="l3.2108" class="difflineplus">+      MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.2109"></a><span id="l3.2109" class="difflineplus">+              (&quot;DoomCacheEntry(): Call AsyncDoom()&quot;));</span>
<a href="#l3.2110"></a><span id="l3.2110">       cacheEntry-&gt;AsyncDoom(nullptr);</span>
<a href="#l3.2111"></a><span id="l3.2111">     }</span>
<a href="#l3.2112"></a><span id="l3.2112">   }</span>
<a href="#l3.2113"></a><span id="l3.2113"> }</span>
<a href="#l3.2114"></a><span id="l3.2114"> </span>
<a href="#l3.2115"></a><span id="l3.2115"> // returns true if another url was run, false otherwise.</span>
<a href="#l3.2116"></a><span id="l3.2116" class="difflineminus">-bool nsImapProtocol::ProcessCurrentURL()</span>
<a href="#l3.2117"></a><span id="l3.2117" class="difflineminus">-{</span>
<a href="#l3.2118"></a><span id="l3.2118" class="difflineplus">+bool nsImapProtocol::ProcessCurrentURL() {</span>
<a href="#l3.2119"></a><span id="l3.2119">   nsresult rv = NS_OK;</span>
<a href="#l3.2120"></a><span id="l3.2120" class="difflineminus">-  if (m_idle)</span>
<a href="#l3.2121"></a><span id="l3.2121" class="difflineminus">-    EndIdle();</span>
<a href="#l3.2122"></a><span id="l3.2122" class="difflineminus">-</span>
<a href="#l3.2123"></a><span id="l3.2123" class="difflineminus">-  if (m_retryUrlOnError)</span>
<a href="#l3.2124"></a><span id="l3.2124" class="difflineminus">-  {</span>
<a href="#l3.2125"></a><span id="l3.2125" class="difflineplus">+  if (m_idle) EndIdle();</span>
<a href="#l3.2126"></a><span id="l3.2126" class="difflineplus">+</span>
<a href="#l3.2127"></a><span id="l3.2127" class="difflineplus">+  if (m_retryUrlOnError) {</span>
<a href="#l3.2128"></a><span id="l3.2128">     // we clear this flag if we're re-running immediately, because that</span>
<a href="#l3.2129"></a><span id="l3.2129">     // means we never sent a start running url notification, and later we</span>
<a href="#l3.2130"></a><span id="l3.2130">     // don't send start running notification if we think we're rerunning</span>
<a href="#l3.2131"></a><span id="l3.2131">     // the url (see first call to SetUrlState below). This means we won't</span>
<a href="#l3.2132"></a><span id="l3.2132">     // send a start running notification, which means our stop running</span>
<a href="#l3.2133"></a><span id="l3.2133">     // notification will be ignored because we don't think we were running.</span>
<a href="#l3.2134"></a><span id="l3.2134">     m_runningUrl-&gt;SetRerunningUrl(false);</span>
<a href="#l3.2135"></a><span id="l3.2135">     return RetryUrl();</span>
<a href="#l3.2136"></a><span id="l3.2136">   }</span>
<a href="#l3.2137"></a><span id="l3.2137">   Log(&quot;ProcessCurrentURL&quot;, nullptr, &quot;entering&quot;);</span>
<a href="#l3.2138"></a><span id="l3.2138" class="difflineminus">-  (void) GetImapHostName(); // force m_hostName to get set.</span>
<a href="#l3.2139"></a><span id="l3.2139" class="difflineminus">-</span>
<a href="#l3.2140"></a><span id="l3.2140" class="difflineminus">-</span>
<a href="#l3.2141"></a><span id="l3.2141" class="difflineminus">-  bool    logonFailed = false;</span>
<a href="#l3.2142"></a><span id="l3.2142" class="difflineplus">+  (void)GetImapHostName();  // force m_hostName to get set.</span>
<a href="#l3.2143"></a><span id="l3.2143" class="difflineplus">+</span>
<a href="#l3.2144"></a><span id="l3.2144" class="difflineplus">+  bool logonFailed = false;</span>
<a href="#l3.2145"></a><span id="l3.2145">   bool anotherUrlRun = false;</span>
<a href="#l3.2146"></a><span id="l3.2146">   bool rerunningUrl = false;</span>
<a href="#l3.2147"></a><span id="l3.2147">   bool isExternalUrl;</span>
<a href="#l3.2148"></a><span id="l3.2148">   bool validUrl = true;</span>
<a href="#l3.2149"></a><span id="l3.2149"> </span>
<a href="#l3.2150"></a><span id="l3.2150">   PseudoInterrupt(false);  // clear this if left over from previous url.</span>
<a href="#l3.2151"></a><span id="l3.2151"> </span>
<a href="#l3.2152"></a><span id="l3.2152">   m_runningUrl-&gt;GetRerunningUrl(&amp;rerunningUrl);</span>
<a href="#l3.2153"></a><span id="l3.2153">   m_runningUrl-&gt;GetExternalLinkUrl(&amp;isExternalUrl);</span>
<a href="#l3.2154"></a><span id="l3.2154">   m_runningUrl-&gt;GetValidUrl(&amp;validUrl);</span>
<a href="#l3.2155"></a><span id="l3.2155">   m_runningUrl-&gt;GetImapAction(&amp;m_imapAction);</span>
<a href="#l3.2156"></a><span id="l3.2156"> </span>
<a href="#l3.2157"></a><span id="l3.2157" class="difflineminus">-  if (isExternalUrl)</span>
<a href="#l3.2158"></a><span id="l3.2158" class="difflineminus">-  {</span>
<a href="#l3.2159"></a><span id="l3.2159" class="difflineminus">-    if (m_imapAction == nsIImapUrl::nsImapSelectFolder)</span>
<a href="#l3.2160"></a><span id="l3.2160" class="difflineminus">-    {</span>
<a href="#l3.2161"></a><span id="l3.2161" class="difflineplus">+  if (isExternalUrl) {</span>
<a href="#l3.2162"></a><span id="l3.2162" class="difflineplus">+    if (m_imapAction == nsIImapUrl::nsImapSelectFolder) {</span>
<a href="#l3.2163"></a><span id="l3.2163">       // we need to send a start request so that the doc loader</span>
<a href="#l3.2164"></a><span id="l3.2164">       // will call HandleContent on the imap service so we</span>
<a href="#l3.2165"></a><span id="l3.2165">       // can abort this url, and run a new url in a new msg window</span>
<a href="#l3.2166"></a><span id="l3.2166">       // to run the folder load url and get off this crazy merry-go-round.</span>
<a href="#l3.2167"></a><span id="l3.2167" class="difflineminus">-      if (m_channelListener)</span>
<a href="#l3.2168"></a><span id="l3.2168" class="difflineminus">-      {</span>
<a href="#l3.2169"></a><span id="l3.2169" class="difflineplus">+      if (m_channelListener) {</span>
<a href="#l3.2170"></a><span id="l3.2170">         m_channelListener-&gt;OnStartRequest(m_mockChannel);</span>
<a href="#l3.2171"></a><span id="l3.2171">       }</span>
<a href="#l3.2172"></a><span id="l3.2172">       return false;</span>
<a href="#l3.2173"></a><span id="l3.2173">     }</span>
<a href="#l3.2174"></a><span id="l3.2174">   }</span>
<a href="#l3.2175"></a><span id="l3.2175"> </span>
<a href="#l3.2176"></a><span id="l3.2176" class="difflineminus">-  if (!m_imapMailFolderSink &amp;&amp; m_imapProtocolSink)</span>
<a href="#l3.2177"></a><span id="l3.2177" class="difflineminus">-  {</span>
<a href="#l3.2178"></a><span id="l3.2178" class="difflineplus">+  if (!m_imapMailFolderSink &amp;&amp; m_imapProtocolSink) {</span>
<a href="#l3.2179"></a><span id="l3.2179">     // This occurs when running another URL in the main thread loop</span>
<a href="#l3.2180"></a><span id="l3.2180">     rv = m_imapProtocolSink-&gt;SetupMainThreadProxies();</span>
<a href="#l3.2181"></a><span id="l3.2181">     NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l3.2182"></a><span id="l3.2182">   }</span>
<a href="#l3.2183"></a><span id="l3.2183"> </span>
<a href="#l3.2184"></a><span id="l3.2184">   // Reinitialize the parser</span>
<a href="#l3.2185"></a><span id="l3.2185">   GetServerStateParser().InitializeState();</span>
<a href="#l3.2186"></a><span id="l3.2186">   GetServerStateParser().SetConnected(true);</span>
<a href="#l3.2187"></a><span id="l3.2187"> </span>
<a href="#l3.2188"></a><span id="l3.2188">   // acknowledge that we are running the url now..</span>
<a href="#l3.2189"></a><span id="l3.2189" class="difflineminus">-  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl = do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l3.2190"></a><span id="l3.2190" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl =</span>
<a href="#l3.2191"></a><span id="l3.2191" class="difflineplus">+      do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l3.2192"></a><span id="l3.2192">   nsAutoCString urlSpec;</span>
<a href="#l3.2193"></a><span id="l3.2193">   rv = mailnewsurl-&gt;GetSpec(urlSpec);</span>
<a href="#l3.2194"></a><span id="l3.2194">   NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l3.2195"></a><span id="l3.2195" class="difflineminus">-  Log(&quot;ProcessCurrentURL&quot;, urlSpec.get(), (validUrl) ? &quot; = currentUrl&quot; : &quot; is not valid&quot;);</span>
<a href="#l3.2196"></a><span id="l3.2196" class="difflineminus">-  if (!validUrl)</span>
<a href="#l3.2197"></a><span id="l3.2197" class="difflineminus">-    return false;</span>
<a href="#l3.2198"></a><span id="l3.2198" class="difflineplus">+  Log(&quot;ProcessCurrentURL&quot;, urlSpec.get(),</span>
<a href="#l3.2199"></a><span id="l3.2199" class="difflineplus">+      (validUrl) ? &quot; = currentUrl&quot; : &quot; is not valid&quot;);</span>
<a href="#l3.2200"></a><span id="l3.2200" class="difflineplus">+  if (!validUrl) return false;</span>
<a href="#l3.2201"></a><span id="l3.2201"> </span>
<a href="#l3.2202"></a><span id="l3.2202">   if (NS_SUCCEEDED(rv) &amp;&amp; mailnewsurl &amp;&amp; m_imapMailFolderSink &amp;&amp; !rerunningUrl)</span>
<a href="#l3.2203"></a><span id="l3.2203" class="difflineminus">-    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, true, false,</span>
<a href="#l3.2204"></a><span id="l3.2204" class="difflineminus">-                                      NS_OK);</span>
<a href="#l3.2205"></a><span id="l3.2205" class="difflineminus">-</span>
<a href="#l3.2206"></a><span id="l3.2206" class="difflineminus">-  // if we are set up as a channel, we should notify our channel listener that we are starting...</span>
<a href="#l3.2207"></a><span id="l3.2207" class="difflineminus">-  // so pass in ourself as the channel and not the underlying socket or file channel the protocol</span>
<a href="#l3.2208"></a><span id="l3.2208" class="difflineminus">-  // happens to be using</span>
<a href="#l3.2209"></a><span id="l3.2209" class="difflineminus">-  if (m_channelListener) // ### not sure we want to do this if rerunning url...</span>
<a href="#l3.2210"></a><span id="l3.2210" class="difflineplus">+    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, true, false, NS_OK);</span>
<a href="#l3.2211"></a><span id="l3.2211" class="difflineplus">+</span>
<a href="#l3.2212"></a><span id="l3.2212" class="difflineplus">+  // if we are set up as a channel, we should notify our channel listener that</span>
<a href="#l3.2213"></a><span id="l3.2213" class="difflineplus">+  // we are starting... so pass in ourself as the channel and not the underlying</span>
<a href="#l3.2214"></a><span id="l3.2214" class="difflineplus">+  // socket or file channel the protocol happens to be using</span>
<a href="#l3.2215"></a><span id="l3.2215" class="difflineplus">+  if (m_channelListener)  // ### not sure we want to do this if rerunning url...</span>
<a href="#l3.2216"></a><span id="l3.2216">   {</span>
<a href="#l3.2217"></a><span id="l3.2217">     m_channelListener-&gt;OnStartRequest(m_mockChannel);</span>
<a href="#l3.2218"></a><span id="l3.2218">   }</span>
<a href="#l3.2219"></a><span id="l3.2219">   // If we haven't received the greeting yet, we need to make sure we strip</span>
<a href="#l3.2220"></a><span id="l3.2220">   // it out of the input before we start to do useful things...</span>
<a href="#l3.2221"></a><span id="l3.2221" class="difflineminus">-  if (!TestFlag(IMAP_RECEIVED_GREETING))</span>
<a href="#l3.2222"></a><span id="l3.2222" class="difflineminus">-    EstablishServerConnection();</span>
<a href="#l3.2223"></a><span id="l3.2223" class="difflineplus">+  if (!TestFlag(IMAP_RECEIVED_GREETING)) EstablishServerConnection();</span>
<a href="#l3.2224"></a><span id="l3.2224"> </span>
<a href="#l3.2225"></a><span id="l3.2225">   // Step 1: If we have not moved into the authenticated state yet then do so</span>
<a href="#l3.2226"></a><span id="l3.2226">   // by attempting to logon.</span>
<a href="#l3.2227"></a><span id="l3.2227">   if (!DeathSignalReceived() &amp;&amp; NS_SUCCEEDED(GetConnectionStatus()) &amp;&amp;</span>
<a href="#l3.2228"></a><span id="l3.2228">       (GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.2229"></a><span id="l3.2229" class="difflineminus">-       nsImapServerResponseParser::kNonAuthenticated))</span>
<a href="#l3.2230"></a><span id="l3.2230" class="difflineminus">-  {</span>
<a href="#l3.2231"></a><span id="l3.2231" class="difflineminus">-      /* if we got here, the server's greeting should not have been PREAUTH */</span>
<a href="#l3.2232"></a><span id="l3.2232" class="difflineminus">-      if (GetServerStateParser().GetCapabilityFlag() == kCapabilityUndefined)</span>
<a href="#l3.2233"></a><span id="l3.2233" class="difflineminus">-          Capability();</span>
<a href="#l3.2234"></a><span id="l3.2234" class="difflineminus">-</span>
<a href="#l3.2235"></a><span id="l3.2235" class="difflineminus">-      if ( !(GetServerStateParser().GetCapabilityFlag() &amp; (kIMAP4Capability | kIMAP4rev1Capability |</span>
<a href="#l3.2236"></a><span id="l3.2236" class="difflineminus">-             kIMAP4other) ) )</span>
<a href="#l3.2237"></a><span id="l3.2237" class="difflineminus">-      {</span>
<a href="#l3.2238"></a><span id="l3.2238" class="difflineminus">-        if (!DeathSignalReceived() &amp;&amp; NS_SUCCEEDED(GetConnectionStatus()))</span>
<a href="#l3.2239"></a><span id="l3.2239" class="difflineminus">-          AlertUserEventUsingName(&quot;imapServerNotImap4&quot;);</span>
<a href="#l3.2240"></a><span id="l3.2240" class="difflineminus">-</span>
<a href="#l3.2241"></a><span id="l3.2241" class="difflineminus">-        SetConnectionStatus(NS_ERROR_FAILURE);        // stop netlib</span>
<a href="#l3.2242"></a><span id="l3.2242" class="difflineminus">-      }</span>
<a href="#l3.2243"></a><span id="l3.2243" class="difflineminus">-      else</span>
<a href="#l3.2244"></a><span id="l3.2244" class="difflineminus">-      {</span>
<a href="#l3.2245"></a><span id="l3.2245" class="difflineminus">-        if ((m_connectionType.EqualsLiteral(&quot;starttls&quot;)</span>
<a href="#l3.2246"></a><span id="l3.2246" class="difflineminus">-             &amp;&amp; (m_socketType == nsMsgSocketType::trySTARTTLS</span>
<a href="#l3.2247"></a><span id="l3.2247" class="difflineminus">-             &amp;&amp; (GetServerStateParser().GetCapabilityFlag() &amp; kHasStartTLSCapability)))</span>
<a href="#l3.2248"></a><span id="l3.2248" class="difflineminus">-            || m_socketType == nsMsgSocketType::alwaysSTARTTLS)</span>
<a href="#l3.2249"></a><span id="l3.2249" class="difflineminus">-        {</span>
<a href="#l3.2250"></a><span id="l3.2250" class="difflineminus">-          StartTLS();</span>
<a href="#l3.2251"></a><span id="l3.2251" class="difflineminus">-          if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.2252"></a><span id="l3.2252" class="difflineminus">-          {</span>
<a href="#l3.2253"></a><span id="l3.2253" class="difflineminus">-            nsCOMPtr&lt;nsISupports&gt; secInfo;</span>
<a href="#l3.2254"></a><span id="l3.2254" class="difflineminus">-</span>
<a href="#l3.2255"></a><span id="l3.2255" class="difflineminus">-            NS_ENSURE_TRUE(m_transport, false);</span>
<a href="#l3.2256"></a><span id="l3.2256" class="difflineminus">-            rv = m_transport-&gt;GetSecurityInfo(getter_AddRefs(secInfo));</span>
<a href="#l3.2257"></a><span id="l3.2257" class="difflineminus">-</span>
<a href="#l3.2258"></a><span id="l3.2258" class="difflineminus">-            if (NS_SUCCEEDED(rv) &amp;&amp; secInfo)</span>
<a href="#l3.2259"></a><span id="l3.2259" class="difflineminus">-            {</span>
<a href="#l3.2260"></a><span id="l3.2260" class="difflineminus">-              nsCOMPtr&lt;nsISSLSocketControl&gt; sslControl = do_QueryInterface(secInfo, &amp;rv);</span>
<a href="#l3.2261"></a><span id="l3.2261" class="difflineminus">-</span>
<a href="#l3.2262"></a><span id="l3.2262" class="difflineminus">-              if (NS_SUCCEEDED(rv) &amp;&amp; sslControl)</span>
<a href="#l3.2263"></a><span id="l3.2263" class="difflineminus">-              {</span>
<a href="#l3.2264"></a><span id="l3.2264" class="difflineminus">-                rv = sslControl-&gt;StartTLS();</span>
<a href="#l3.2265"></a><span id="l3.2265" class="difflineminus">-                if (NS_SUCCEEDED(rv))</span>
<a href="#l3.2266"></a><span id="l3.2266" class="difflineminus">-                {</span>
<a href="#l3.2267"></a><span id="l3.2267" class="difflineminus">-                  if (m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.2268"></a><span id="l3.2268" class="difflineminus">-                    m_imapServerSink-&gt;UpdateTrySTARTTLSPref(true);</span>
<a href="#l3.2269"></a><span id="l3.2269" class="difflineminus">-                  // force re-issue of &quot;capability&quot;, because servers may</span>
<a href="#l3.2270"></a><span id="l3.2270" class="difflineminus">-                  // enable other auth features (e.g. remove LOGINDISABLED</span>
<a href="#l3.2271"></a><span id="l3.2271" class="difflineminus">-                  // and add AUTH=PLAIN) after we upgraded to SSL.</span>
<a href="#l3.2272"></a><span id="l3.2272" class="difflineminus">-                  Capability();</span>
<a href="#l3.2273"></a><span id="l3.2273" class="difflineminus">-                  eIMAPCapabilityFlags capabilityFlag = GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.2274"></a><span id="l3.2274" class="difflineminus">-                  // Courier imap doesn't return STARTTLS capability if we've done</span>
<a href="#l3.2275"></a><span id="l3.2275" class="difflineminus">-                  // a STARTTLS! But we need to remember this capability so we'll</span>
<a href="#l3.2276"></a><span id="l3.2276" class="difflineminus">-                  // try to use STARTTLS next time.</span>
<a href="#l3.2277"></a><span id="l3.2277" class="difflineminus">-                  if (!(capabilityFlag &amp; kHasStartTLSCapability))</span>
<a href="#l3.2278"></a><span id="l3.2278" class="difflineminus">-                  {</span>
<a href="#l3.2279"></a><span id="l3.2279" class="difflineminus">-                    capabilityFlag |= kHasStartTLSCapability;</span>
<a href="#l3.2280"></a><span id="l3.2280" class="difflineminus">-                    GetServerStateParser().SetCapabilityFlag(capabilityFlag);</span>
<a href="#l3.2281"></a><span id="l3.2281" class="difflineminus">-                    CommitCapability();</span>
<a href="#l3.2282"></a><span id="l3.2282" class="difflineminus">-                  }</span>
<a href="#l3.2283"></a><span id="l3.2283" class="difflineplus">+       nsImapServerResponseParser::kNonAuthenticated)) {</span>
<a href="#l3.2284"></a><span id="l3.2284" class="difflineplus">+    /* if we got here, the server's greeting should not have been PREAUTH */</span>
<a href="#l3.2285"></a><span id="l3.2285" class="difflineplus">+    if (GetServerStateParser().GetCapabilityFlag() == kCapabilityUndefined)</span>
<a href="#l3.2286"></a><span id="l3.2286" class="difflineplus">+      Capability();</span>
<a href="#l3.2287"></a><span id="l3.2287" class="difflineplus">+</span>
<a href="#l3.2288"></a><span id="l3.2288" class="difflineplus">+    if (!(GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.2289"></a><span id="l3.2289" class="difflineplus">+          (kIMAP4Capability | kIMAP4rev1Capability | kIMAP4other))) {</span>
<a href="#l3.2290"></a><span id="l3.2290" class="difflineplus">+      if (!DeathSignalReceived() &amp;&amp; NS_SUCCEEDED(GetConnectionStatus()))</span>
<a href="#l3.2291"></a><span id="l3.2291" class="difflineplus">+        AlertUserEventUsingName(&quot;imapServerNotImap4&quot;);</span>
<a href="#l3.2292"></a><span id="l3.2292" class="difflineplus">+</span>
<a href="#l3.2293"></a><span id="l3.2293" class="difflineplus">+      SetConnectionStatus(NS_ERROR_FAILURE);  // stop netlib</span>
<a href="#l3.2294"></a><span id="l3.2294" class="difflineplus">+    } else {</span>
<a href="#l3.2295"></a><span id="l3.2295" class="difflineplus">+      if ((m_connectionType.EqualsLiteral(&quot;starttls&quot;) &amp;&amp;</span>
<a href="#l3.2296"></a><span id="l3.2296" class="difflineplus">+           (m_socketType == nsMsgSocketType::trySTARTTLS &amp;&amp;</span>
<a href="#l3.2297"></a><span id="l3.2297" class="difflineplus">+            (GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.2298"></a><span id="l3.2298" class="difflineplus">+             kHasStartTLSCapability))) ||</span>
<a href="#l3.2299"></a><span id="l3.2299" class="difflineplus">+          m_socketType == nsMsgSocketType::alwaysSTARTTLS) {</span>
<a href="#l3.2300"></a><span id="l3.2300" class="difflineplus">+        StartTLS();</span>
<a href="#l3.2301"></a><span id="l3.2301" class="difflineplus">+        if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.2302"></a><span id="l3.2302" class="difflineplus">+          nsCOMPtr&lt;nsISupports&gt; secInfo;</span>
<a href="#l3.2303"></a><span id="l3.2303" class="difflineplus">+</span>
<a href="#l3.2304"></a><span id="l3.2304" class="difflineplus">+          NS_ENSURE_TRUE(m_transport, false);</span>
<a href="#l3.2305"></a><span id="l3.2305" class="difflineplus">+          rv = m_transport-&gt;GetSecurityInfo(getter_AddRefs(secInfo));</span>
<a href="#l3.2306"></a><span id="l3.2306" class="difflineplus">+</span>
<a href="#l3.2307"></a><span id="l3.2307" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; secInfo) {</span>
<a href="#l3.2308"></a><span id="l3.2308" class="difflineplus">+            nsCOMPtr&lt;nsISSLSocketControl&gt; sslControl =</span>
<a href="#l3.2309"></a><span id="l3.2309" class="difflineplus">+                do_QueryInterface(secInfo, &amp;rv);</span>
<a href="#l3.2310"></a><span id="l3.2310" class="difflineplus">+</span>
<a href="#l3.2311"></a><span id="l3.2311" class="difflineplus">+            if (NS_SUCCEEDED(rv) &amp;&amp; sslControl) {</span>
<a href="#l3.2312"></a><span id="l3.2312" class="difflineplus">+              rv = sslControl-&gt;StartTLS();</span>
<a href="#l3.2313"></a><span id="l3.2313" class="difflineplus">+              if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.2314"></a><span id="l3.2314" class="difflineplus">+                if (m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.2315"></a><span id="l3.2315" class="difflineplus">+                  m_imapServerSink-&gt;UpdateTrySTARTTLSPref(true);</span>
<a href="#l3.2316"></a><span id="l3.2316" class="difflineplus">+                // force re-issue of &quot;capability&quot;, because servers may</span>
<a href="#l3.2317"></a><span id="l3.2317" class="difflineplus">+                // enable other auth features (e.g. remove LOGINDISABLED</span>
<a href="#l3.2318"></a><span id="l3.2318" class="difflineplus">+                // and add AUTH=PLAIN) after we upgraded to SSL.</span>
<a href="#l3.2319"></a><span id="l3.2319" class="difflineplus">+                Capability();</span>
<a href="#l3.2320"></a><span id="l3.2320" class="difflineplus">+                eIMAPCapabilityFlags capabilityFlag =</span>
<a href="#l3.2321"></a><span id="l3.2321" class="difflineplus">+                    GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.2322"></a><span id="l3.2322" class="difflineplus">+                // Courier imap doesn't return STARTTLS capability if we've done</span>
<a href="#l3.2323"></a><span id="l3.2323" class="difflineplus">+                // a STARTTLS! But we need to remember this capability so we'll</span>
<a href="#l3.2324"></a><span id="l3.2324" class="difflineplus">+                // try to use STARTTLS next time.</span>
<a href="#l3.2325"></a><span id="l3.2325" class="difflineplus">+                if (!(capabilityFlag &amp; kHasStartTLSCapability)) {</span>
<a href="#l3.2326"></a><span id="l3.2326" class="difflineplus">+                  capabilityFlag |= kHasStartTLSCapability;</span>
<a href="#l3.2327"></a><span id="l3.2327" class="difflineplus">+                  GetServerStateParser().SetCapabilityFlag(capabilityFlag);</span>
<a href="#l3.2328"></a><span id="l3.2328" class="difflineplus">+                  CommitCapability();</span>
<a href="#l3.2329"></a><span id="l3.2329">                 }</span>
<a href="#l3.2330"></a><span id="l3.2330">               }</span>
<a href="#l3.2331"></a><span id="l3.2331">             }</span>
<a href="#l3.2332"></a><span id="l3.2332" class="difflineminus">-            if (NS_FAILED(rv))</span>
<a href="#l3.2333"></a><span id="l3.2333" class="difflineminus">-            {</span>
<a href="#l3.2334"></a><span id="l3.2334" class="difflineminus">-              nsAutoCString logLine(&quot;STARTTLS negotiation failed. Error 0x&quot;);</span>
<a href="#l3.2335"></a><span id="l3.2335" class="difflineminus">-              logLine.AppendInt(static_cast&lt;uint32_t&gt;(rv), 16);</span>
<a href="#l3.2336"></a><span id="l3.2336" class="difflineminus">-              Log(&quot;ProcessCurrentURL&quot;, nullptr, logLine.get());</span>
<a href="#l3.2337"></a><span id="l3.2337" class="difflineminus">-              if (m_socketType == nsMsgSocketType::alwaysSTARTTLS)</span>
<a href="#l3.2338"></a><span id="l3.2338" class="difflineminus">-              {</span>
<a href="#l3.2339"></a><span id="l3.2339" class="difflineminus">-                SetConnectionStatus(rv);        // stop netlib</span>
<a href="#l3.2340"></a><span id="l3.2340" class="difflineminus">-                m_transport-&gt;Close(rv);</span>
<a href="#l3.2341"></a><span id="l3.2341" class="difflineminus">-              }</span>
<a href="#l3.2342"></a><span id="l3.2342" class="difflineminus">-              else if (m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.2343"></a><span id="l3.2343" class="difflineminus">-                m_imapServerSink-&gt;UpdateTrySTARTTLSPref(false);</span>
<a href="#l3.2344"></a><span id="l3.2344" class="difflineminus">-            }</span>
<a href="#l3.2345"></a><span id="l3.2345">           }</span>
<a href="#l3.2346"></a><span id="l3.2346" class="difflineminus">-          else if (m_socketType == nsMsgSocketType::alwaysSTARTTLS)</span>
<a href="#l3.2347"></a><span id="l3.2347" class="difflineminus">-          {</span>
<a href="#l3.2348"></a><span id="l3.2348" class="difflineminus">-            SetConnectionStatus(NS_ERROR_FAILURE);        // stop netlib</span>
<a href="#l3.2349"></a><span id="l3.2349" class="difflineminus">-            if (m_transport)</span>
<a href="#l3.2350"></a><span id="l3.2350" class="difflineplus">+          if (NS_FAILED(rv)) {</span>
<a href="#l3.2351"></a><span id="l3.2351" class="difflineplus">+            nsAutoCString logLine(&quot;STARTTLS negotiation failed. Error 0x&quot;);</span>
<a href="#l3.2352"></a><span id="l3.2352" class="difflineplus">+            logLine.AppendInt(static_cast&lt;uint32_t&gt;(rv), 16);</span>
<a href="#l3.2353"></a><span id="l3.2353" class="difflineplus">+            Log(&quot;ProcessCurrentURL&quot;, nullptr, logLine.get());</span>
<a href="#l3.2354"></a><span id="l3.2354" class="difflineplus">+            if (m_socketType == nsMsgSocketType::alwaysSTARTTLS) {</span>
<a href="#l3.2355"></a><span id="l3.2355" class="difflineplus">+              SetConnectionStatus(rv);  // stop netlib</span>
<a href="#l3.2356"></a><span id="l3.2356">               m_transport-&gt;Close(rv);</span>
<a href="#l3.2357"></a><span id="l3.2357" class="difflineminus">-          }</span>
<a href="#l3.2358"></a><span id="l3.2358" class="difflineminus">-          else if (m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.2359"></a><span id="l3.2359" class="difflineminus">-          {</span>
<a href="#l3.2360"></a><span id="l3.2360" class="difflineminus">-            // STARTTLS failed, so downgrade socket type</span>
<a href="#l3.2361"></a><span id="l3.2361" class="difflineminus">-            m_imapServerSink-&gt;UpdateTrySTARTTLSPref(false);</span>
<a href="#l3.2362"></a><span id="l3.2362" class="difflineplus">+            } else if (m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.2363"></a><span id="l3.2363" class="difflineplus">+              m_imapServerSink-&gt;UpdateTrySTARTTLSPref(false);</span>
<a href="#l3.2364"></a><span id="l3.2364">           }</span>
<a href="#l3.2365"></a><span id="l3.2365" class="difflineplus">+        } else if (m_socketType == nsMsgSocketType::alwaysSTARTTLS) {</span>
<a href="#l3.2366"></a><span id="l3.2366" class="difflineplus">+          SetConnectionStatus(NS_ERROR_FAILURE);  // stop netlib</span>
<a href="#l3.2367"></a><span id="l3.2367" class="difflineplus">+          if (m_transport) m_transport-&gt;Close(rv);</span>
<a href="#l3.2368"></a><span id="l3.2368" class="difflineplus">+        } else if (m_socketType == nsMsgSocketType::trySTARTTLS) {</span>
<a href="#l3.2369"></a><span id="l3.2369" class="difflineplus">+          // STARTTLS failed, so downgrade socket type</span>
<a href="#l3.2370"></a><span id="l3.2370" class="difflineplus">+          m_imapServerSink-&gt;UpdateTrySTARTTLSPref(false);</span>
<a href="#l3.2371"></a><span id="l3.2371">         }</span>
<a href="#l3.2372"></a><span id="l3.2372" class="difflineminus">-        else if (m_socketType == nsMsgSocketType::trySTARTTLS)</span>
<a href="#l3.2373"></a><span id="l3.2373" class="difflineminus">-        {</span>
<a href="#l3.2374"></a><span id="l3.2374" class="difflineminus">-          // we didn't know the server supported TLS when we created</span>
<a href="#l3.2375"></a><span id="l3.2375" class="difflineminus">-          // the socket, so we're going to retry with a STARTTLS socket</span>
<a href="#l3.2376"></a><span id="l3.2376" class="difflineminus">-          if (GetServerStateParser().GetCapabilityFlag() &amp; kHasStartTLSCapability)</span>
<a href="#l3.2377"></a><span id="l3.2377" class="difflineminus">-          {</span>
<a href="#l3.2378"></a><span id="l3.2378" class="difflineminus">-            ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.2379"></a><span id="l3.2379" class="difflineminus">-            TellThreadToDie();</span>
<a href="#l3.2380"></a><span id="l3.2380" class="difflineminus">-            SetConnectionStatus(NS_ERROR_FAILURE);</span>
<a href="#l3.2381"></a><span id="l3.2381" class="difflineminus">-            return RetryUrl();</span>
<a href="#l3.2382"></a><span id="l3.2382" class="difflineminus">-          }</span>
<a href="#l3.2383"></a><span id="l3.2383" class="difflineminus">-          // trySTARTTLS set, but server doesn't have TLS capability,</span>
<a href="#l3.2384"></a><span id="l3.2384" class="difflineminus">-          // so downgrade socket type</span>
<a href="#l3.2385"></a><span id="l3.2385" class="difflineminus">-          m_imapServerSink-&gt;UpdateTrySTARTTLSPref(false);</span>
<a href="#l3.2386"></a><span id="l3.2386" class="difflineminus">-          m_socketType = nsMsgSocketType::plain;</span>
<a href="#l3.2387"></a><span id="l3.2387" class="difflineplus">+      } else if (m_socketType == nsMsgSocketType::trySTARTTLS) {</span>
<a href="#l3.2388"></a><span id="l3.2388" class="difflineplus">+        // we didn't know the server supported TLS when we created</span>
<a href="#l3.2389"></a><span id="l3.2389" class="difflineplus">+        // the socket, so we're going to retry with a STARTTLS socket</span>
<a href="#l3.2390"></a><span id="l3.2390" class="difflineplus">+        if (GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.2391"></a><span id="l3.2391" class="difflineplus">+            kHasStartTLSCapability) {</span>
<a href="#l3.2392"></a><span id="l3.2392" class="difflineplus">+          ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.2393"></a><span id="l3.2393" class="difflineplus">+          TellThreadToDie();</span>
<a href="#l3.2394"></a><span id="l3.2394" class="difflineplus">+          SetConnectionStatus(NS_ERROR_FAILURE);</span>
<a href="#l3.2395"></a><span id="l3.2395" class="difflineplus">+          return RetryUrl();</span>
<a href="#l3.2396"></a><span id="l3.2396">         }</span>
<a href="#l3.2397"></a><span id="l3.2397" class="difflineminus">-        logonFailed = !TryToLogon();</span>
<a href="#l3.2398"></a><span id="l3.2398" class="difflineminus">-        if (m_retryUrlOnError)</span>
<a href="#l3.2399"></a><span id="l3.2399" class="difflineminus">-          return RetryUrl();</span>
<a href="#l3.2400"></a><span id="l3.2400" class="difflineplus">+        // trySTARTTLS set, but server doesn't have TLS capability,</span>
<a href="#l3.2401"></a><span id="l3.2401" class="difflineplus">+        // so downgrade socket type</span>
<a href="#l3.2402"></a><span id="l3.2402" class="difflineplus">+        m_imapServerSink-&gt;UpdateTrySTARTTLSPref(false);</span>
<a href="#l3.2403"></a><span id="l3.2403" class="difflineplus">+        m_socketType = nsMsgSocketType::plain;</span>
<a href="#l3.2404"></a><span id="l3.2404">       }</span>
<a href="#l3.2405"></a><span id="l3.2405" class="difflineminus">-  } // if death signal not received</span>
<a href="#l3.2406"></a><span id="l3.2406" class="difflineminus">-</span>
<a href="#l3.2407"></a><span id="l3.2407" class="difflineminus">-  if (!DeathSignalReceived() &amp;&amp; (NS_SUCCEEDED(GetConnectionStatus())))</span>
<a href="#l3.2408"></a><span id="l3.2408" class="difflineminus">-  {</span>
<a href="#l3.2409"></a><span id="l3.2409" class="difflineplus">+      logonFailed = !TryToLogon();</span>
<a href="#l3.2410"></a><span id="l3.2410" class="difflineplus">+      if (m_retryUrlOnError) return RetryUrl();</span>
<a href="#l3.2411"></a><span id="l3.2411" class="difflineplus">+    }</span>
<a href="#l3.2412"></a><span id="l3.2412" class="difflineplus">+  }  // if death signal not received</span>
<a href="#l3.2413"></a><span id="l3.2413" class="difflineplus">+</span>
<a href="#l3.2414"></a><span id="l3.2414" class="difflineplus">+  if (!DeathSignalReceived() &amp;&amp; (NS_SUCCEEDED(GetConnectionStatus()))) {</span>
<a href="#l3.2415"></a><span id="l3.2415">     // if the server supports a language extension then we should</span>
<a href="#l3.2416"></a><span id="l3.2416">     // attempt to issue the language extension.</span>
<a href="#l3.2417"></a><span id="l3.2417" class="difflineminus">-    if ( GetServerStateParser().GetCapabilityFlag() &amp; kHasLanguageCapability)</span>
<a href="#l3.2418"></a><span id="l3.2418" class="difflineplus">+    if (GetServerStateParser().GetCapabilityFlag() &amp; kHasLanguageCapability)</span>
<a href="#l3.2419"></a><span id="l3.2419">       Language();</span>
<a href="#l3.2420"></a><span id="l3.2420"> </span>
<a href="#l3.2421"></a><span id="l3.2421" class="difflineminus">-    if (m_runningUrl)</span>
<a href="#l3.2422"></a><span id="l3.2422" class="difflineminus">-      FindMailboxesIfNecessary();</span>
<a href="#l3.2423"></a><span id="l3.2423" class="difflineplus">+    if (m_runningUrl) FindMailboxesIfNecessary();</span>
<a href="#l3.2424"></a><span id="l3.2424"> </span>
<a href="#l3.2425"></a><span id="l3.2425">     nsImapState imapState = nsIImapUrl::ImapStatusNone;</span>
<a href="#l3.2426"></a><span id="l3.2426" class="difflineminus">-    if (m_runningUrl)</span>
<a href="#l3.2427"></a><span id="l3.2427" class="difflineminus">-      m_runningUrl-&gt;GetRequiredImapState(&amp;imapState);</span>
<a href="#l3.2428"></a><span id="l3.2428" class="difflineplus">+    if (m_runningUrl) m_runningUrl-&gt;GetRequiredImapState(&amp;imapState);</span>
<a href="#l3.2429"></a><span id="l3.2429"> </span>
<a href="#l3.2430"></a><span id="l3.2430">     if (imapState == nsIImapUrl::nsImapAuthenticatedState)</span>
<a href="#l3.2431"></a><span id="l3.2431">       ProcessAuthenticatedStateURL();</span>
<a href="#l3.2432"></a><span id="l3.2432" class="difflineminus">-    else   // must be a url that requires us to be in the selected state</span>
<a href="#l3.2433"></a><span id="l3.2433" class="difflineplus">+    else  // must be a url that requires us to be in the selected state</span>
<a href="#l3.2434"></a><span id="l3.2434">       ProcessSelectedStateURL();</span>
<a href="#l3.2435"></a><span id="l3.2435"> </span>
<a href="#l3.2436"></a><span id="l3.2436" class="difflineminus">-    if (m_retryUrlOnError)</span>
<a href="#l3.2437"></a><span id="l3.2437" class="difflineminus">-      return RetryUrl();</span>
<a href="#l3.2438"></a><span id="l3.2438" class="difflineminus">-</span>
<a href="#l3.2439"></a><span id="l3.2439" class="difflineminus">-  // The URL has now been processed</span>
<a href="#l3.2440"></a><span id="l3.2440" class="difflineplus">+    if (m_retryUrlOnError) return RetryUrl();</span>
<a href="#l3.2441"></a><span id="l3.2441" class="difflineplus">+</span>
<a href="#l3.2442"></a><span id="l3.2442" class="difflineplus">+    // The URL has now been processed</span>
<a href="#l3.2443"></a><span id="l3.2443">     if ((!logonFailed &amp;&amp; NS_FAILED(GetConnectionStatus())) ||</span>
<a href="#l3.2444"></a><span id="l3.2444" class="difflineminus">-         DeathSignalReceived())</span>
<a href="#l3.2445"></a><span id="l3.2445" class="difflineminus">-         HandleCurrentUrlError();</span>
<a href="#l3.2446"></a><span id="l3.2446" class="difflineminus">-</span>
<a href="#l3.2447"></a><span id="l3.2447" class="difflineminus">-  }</span>
<a href="#l3.2448"></a><span id="l3.2448" class="difflineminus">-  else if (!logonFailed)</span>
<a href="#l3.2449"></a><span id="l3.2449" class="difflineplus">+        DeathSignalReceived())</span>
<a href="#l3.2450"></a><span id="l3.2450">       HandleCurrentUrlError();</span>
<a href="#l3.2451"></a><span id="l3.2451"> </span>
<a href="#l3.2452"></a><span id="l3.2452" class="difflineminus">-// if we are set up as a channel, we should notify our channel listener that we are stopping...</span>
<a href="#l3.2453"></a><span id="l3.2453" class="difflineminus">-// so pass in ourself as the channel and not the underlying socket or file channel the protocol</span>
<a href="#l3.2454"></a><span id="l3.2454" class="difflineminus">-// happens to be using</span>
<a href="#l3.2455"></a><span id="l3.2455" class="difflineminus">-  if (m_channelListener)</span>
<a href="#l3.2456"></a><span id="l3.2456" class="difflineminus">-  {</span>
<a href="#l3.2457"></a><span id="l3.2457" class="difflineminus">-      NS_ASSERTION(m_mockChannel, &quot;no request&quot;);</span>
<a href="#l3.2458"></a><span id="l3.2458" class="difflineminus">-      if (m_mockChannel) {</span>
<a href="#l3.2459"></a><span id="l3.2459" class="difflineminus">-        nsresult status;</span>
<a href="#l3.2460"></a><span id="l3.2460" class="difflineminus">-        m_mockChannel-&gt;GetStatus(&amp;status);</span>
<a href="#l3.2461"></a><span id="l3.2461" class="difflineminus">-        if (!GetServerStateParser().LastCommandSuccessful() &amp;&amp; NS_SUCCEEDED(status))</span>
<a href="#l3.2462"></a><span id="l3.2462" class="difflineminus">-          status = NS_MSG_ERROR_IMAP_COMMAND_FAILED;</span>
<a href="#l3.2463"></a><span id="l3.2463" class="difflineminus">-        rv = m_channelListener-&gt;OnStopRequest(m_mockChannel, status);</span>
<a href="#l3.2464"></a><span id="l3.2464" class="difflineminus">-      }</span>
<a href="#l3.2465"></a><span id="l3.2465" class="difflineplus">+  } else if (!logonFailed)</span>
<a href="#l3.2466"></a><span id="l3.2466" class="difflineplus">+    HandleCurrentUrlError();</span>
<a href="#l3.2467"></a><span id="l3.2467" class="difflineplus">+</span>
<a href="#l3.2468"></a><span id="l3.2468" class="difflineplus">+  // if we are set up as a channel, we should notify our channel listener that</span>
<a href="#l3.2469"></a><span id="l3.2469" class="difflineplus">+  // we are stopping... so pass in ourself as the channel and not the underlying</span>
<a href="#l3.2470"></a><span id="l3.2470" class="difflineplus">+  // socket or file channel the protocol happens to be using</span>
<a href="#l3.2471"></a><span id="l3.2471" class="difflineplus">+  if (m_channelListener) {</span>
<a href="#l3.2472"></a><span id="l3.2472" class="difflineplus">+    NS_ASSERTION(m_mockChannel, &quot;no request&quot;);</span>
<a href="#l3.2473"></a><span id="l3.2473" class="difflineplus">+    if (m_mockChannel) {</span>
<a href="#l3.2474"></a><span id="l3.2474" class="difflineplus">+      nsresult status;</span>
<a href="#l3.2475"></a><span id="l3.2475" class="difflineplus">+      m_mockChannel-&gt;GetStatus(&amp;status);</span>
<a href="#l3.2476"></a><span id="l3.2476" class="difflineplus">+      if (!GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.2477"></a><span id="l3.2477" class="difflineplus">+          NS_SUCCEEDED(status))</span>
<a href="#l3.2478"></a><span id="l3.2478" class="difflineplus">+        status = NS_MSG_ERROR_IMAP_COMMAND_FAILED;</span>
<a href="#l3.2479"></a><span id="l3.2479" class="difflineplus">+      rv = m_channelListener-&gt;OnStopRequest(m_mockChannel, status);</span>
<a href="#l3.2480"></a><span id="l3.2480" class="difflineplus">+    }</span>
<a href="#l3.2481"></a><span id="l3.2481">   }</span>
<a href="#l3.2482"></a><span id="l3.2482">   bool suspendUrl = false;</span>
<a href="#l3.2483"></a><span id="l3.2483">   m_runningUrl-&gt;GetMoreHeadersToDownload(&amp;suspendUrl);</span>
<a href="#l3.2484"></a><span id="l3.2484" class="difflineminus">-  if (mailnewsurl &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.2485"></a><span id="l3.2485" class="difflineminus">-  {</span>
<a href="#l3.2486"></a><span id="l3.2486" class="difflineplus">+  if (mailnewsurl &amp;&amp; m_imapMailFolderSink) {</span>
<a href="#l3.2487"></a><span id="l3.2487">     if (logonFailed)</span>
<a href="#l3.2488"></a><span id="l3.2488">       rv = NS_ERROR_FAILURE;</span>
<a href="#l3.2489"></a><span id="l3.2489">     else if (GetServerStateParser().CommandFailed())</span>
<a href="#l3.2490"></a><span id="l3.2490">       rv = NS_MSG_ERROR_IMAP_COMMAND_FAILED;</span>
<a href="#l3.2491"></a><span id="l3.2491">     else</span>
<a href="#l3.2492"></a><span id="l3.2492">       rv = GetConnectionStatus();</span>
<a href="#l3.2493"></a><span id="l3.2493">     // we are done with this url.</span>
<a href="#l3.2494"></a><span id="l3.2494" class="difflineminus">-    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, false, suspendUrl,</span>
<a href="#l3.2495"></a><span id="l3.2495" class="difflineminus">-                                      rv);</span>
<a href="#l3.2496"></a><span id="l3.2496" class="difflineminus">-     // doom the cache entry</span>
<a href="#l3.2497"></a><span id="l3.2497" class="difflineminus">-    if (NS_FAILED(rv) &amp;&amp; DeathSignalReceived() &amp;&amp; m_mockChannel)</span>
<a href="#l3.2498"></a><span id="l3.2498" class="difflineminus">-    {</span>
<a href="#l3.2499"></a><span id="l3.2499" class="difflineminus">-      MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;ProcessCurrentURL(): Call DoomCacheEntry()&quot;));</span>
<a href="#l3.2500"></a><span id="l3.2500" class="difflineplus">+    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, false, suspendUrl, rv);</span>
<a href="#l3.2501"></a><span id="l3.2501" class="difflineplus">+    // doom the cache entry</span>
<a href="#l3.2502"></a><span id="l3.2502" class="difflineplus">+    if (NS_FAILED(rv) &amp;&amp; DeathSignalReceived() &amp;&amp; m_mockChannel) {</span>
<a href="#l3.2503"></a><span id="l3.2503" class="difflineplus">+      MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.2504"></a><span id="l3.2504" class="difflineplus">+              (&quot;ProcessCurrentURL(): Call DoomCacheEntry()&quot;));</span>
<a href="#l3.2505"></a><span id="l3.2505">       DoomCacheEntry(mailnewsurl);</span>
<a href="#l3.2506"></a><span id="l3.2506">     }</span>
<a href="#l3.2507"></a><span id="l3.2507" class="difflineminus">-  }</span>
<a href="#l3.2508"></a><span id="l3.2508" class="difflineminus">-  else</span>
<a href="#l3.2509"></a><span id="l3.2509" class="difflineminus">-  {</span>
<a href="#l3.2510"></a><span id="l3.2510" class="difflineplus">+  } else {</span>
<a href="#l3.2511"></a><span id="l3.2511">     // That's seen at times in debug sessions.</span>
<a href="#l3.2512"></a><span id="l3.2512">     NS_WARNING(&quot;missing url or sink&quot;);</span>
<a href="#l3.2513"></a><span id="l3.2513">   }</span>
<a href="#l3.2514"></a><span id="l3.2514"> </span>
<a href="#l3.2515"></a><span id="l3.2515">   // disable timeouts before caching connection.</span>
<a href="#l3.2516"></a><span id="l3.2516">   if (m_transport)</span>
<a href="#l3.2517"></a><span id="l3.2517" class="difflineminus">-    m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE, PR_UINT32_MAX);</span>
<a href="#l3.2518"></a><span id="l3.2518" class="difflineplus">+    m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE,</span>
<a href="#l3.2519"></a><span id="l3.2519" class="difflineplus">+                            PR_UINT32_MAX);</span>
<a href="#l3.2520"></a><span id="l3.2520"> </span>
<a href="#l3.2521"></a><span id="l3.2521">   SetFlag(IMAP_CLEAN_UP_URL_STATE);</span>
<a href="#l3.2522"></a><span id="l3.2522"> </span>
<a href="#l3.2523"></a><span id="l3.2523" class="difflineminus">-  nsCOMPtr &lt;nsISupports&gt; copyState;</span>
<a href="#l3.2524"></a><span id="l3.2524" class="difflineminus">-  if (m_runningUrl)</span>
<a href="#l3.2525"></a><span id="l3.2525" class="difflineminus">-    m_runningUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l3.2526"></a><span id="l3.2526" class="difflineplus">+  nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l3.2527"></a><span id="l3.2527" class="difflineplus">+  if (m_runningUrl) m_runningUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l3.2528"></a><span id="l3.2528">   // this is so hokey...we MUST clear any local references to the url</span>
<a href="#l3.2529"></a><span id="l3.2529">   // BEFORE calling ReleaseUrlState</span>
<a href="#l3.2530"></a><span id="l3.2530">   mailnewsurl = nullptr;</span>
<a href="#l3.2531"></a><span id="l3.2531"> </span>
<a href="#l3.2532"></a><span id="l3.2532" class="difflineminus">-  if (suspendUrl)</span>
<a href="#l3.2533"></a><span id="l3.2533" class="difflineminus">-    m_imapServerSink-&gt;SuspendUrl(m_runningUrl);</span>
<a href="#l3.2534"></a><span id="l3.2534" class="difflineplus">+  if (suspendUrl) m_imapServerSink-&gt;SuspendUrl(m_runningUrl);</span>
<a href="#l3.2535"></a><span id="l3.2535">   // save the imap folder sink since we need it to do the CopyNextStreamMessage</span>
<a href="#l3.2536"></a><span id="l3.2536">   RefPtr&lt;ImapMailFolderSinkProxy&gt; imapMailFolderSink = m_imapMailFolderSink;</span>
<a href="#l3.2537"></a><span id="l3.2537">   // release the url as we are done with it...</span>
<a href="#l3.2538"></a><span id="l3.2538">   ReleaseUrlState(false);</span>
<a href="#l3.2539"></a><span id="l3.2539">   ResetProgressInfo();</span>
<a href="#l3.2540"></a><span id="l3.2540"> </span>
<a href="#l3.2541"></a><span id="l3.2541">   ClearFlag(IMAP_CLEAN_UP_URL_STATE);</span>
<a href="#l3.2542"></a><span id="l3.2542"> </span>
<a href="#l3.2543"></a><span id="l3.2543" class="difflineminus">-  if (imapMailFolderSink)</span>
<a href="#l3.2544"></a><span id="l3.2544" class="difflineminus">-  {</span>
<a href="#l3.2545"></a><span id="l3.2545" class="difflineminus">-    if (copyState)</span>
<a href="#l3.2546"></a><span id="l3.2546" class="difflineminus">-    {</span>
<a href="#l3.2547"></a><span id="l3.2547" class="difflineminus">-      rv = imapMailFolderSink-&gt;CopyNextStreamMessage(GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.2548"></a><span id="l3.2548" class="difflineminus">-                                                NS_SUCCEEDED(GetConnectionStatus()),</span>
<a href="#l3.2549"></a><span id="l3.2549" class="difflineminus">-                                                copyState);</span>
<a href="#l3.2550"></a><span id="l3.2550" class="difflineplus">+  if (imapMailFolderSink) {</span>
<a href="#l3.2551"></a><span id="l3.2551" class="difflineplus">+    if (copyState) {</span>
<a href="#l3.2552"></a><span id="l3.2552" class="difflineplus">+      rv = imapMailFolderSink-&gt;CopyNextStreamMessage(</span>
<a href="#l3.2553"></a><span id="l3.2553" class="difflineplus">+          GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.2554"></a><span id="l3.2554" class="difflineplus">+              NS_SUCCEEDED(GetConnectionStatus()),</span>
<a href="#l3.2555"></a><span id="l3.2555" class="difflineplus">+          copyState);</span>
<a href="#l3.2556"></a><span id="l3.2556">       if (NS_FAILED(rv))</span>
<a href="#l3.2557"></a><span id="l3.2557" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Info, (&quot;CopyNextStreamMessage failed: %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.2558"></a><span id="l3.2558" class="difflineminus">-</span>
<a href="#l3.2559"></a><span id="l3.2559" class="difflineminus">-      NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol, copyState&quot;, copyState.forget());</span>
<a href="#l3.2560"></a><span id="l3.2560" class="difflineplus">+        MOZ_LOG(IMAP, LogLevel::Info,</span>
<a href="#l3.2561"></a><span id="l3.2561" class="difflineplus">+                (&quot;CopyNextStreamMessage failed: %&quot; PRIx32,</span>
<a href="#l3.2562"></a><span id="l3.2562" class="difflineplus">+                 static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.2563"></a><span id="l3.2563" class="difflineplus">+</span>
<a href="#l3.2564"></a><span id="l3.2564" class="difflineplus">+      NS_ReleaseOnMainThreadSystemGroup(&quot;nsImapProtocol, copyState&quot;,</span>
<a href="#l3.2565"></a><span id="l3.2565" class="difflineplus">+                                        copyState.forget());</span>
<a href="#l3.2566"></a><span id="l3.2566">     }</span>
<a href="#l3.2567"></a><span id="l3.2567">     // we might need this to stick around for IDLE support</span>
<a href="#l3.2568"></a><span id="l3.2568">     m_imapMailFolderSink = imapMailFolderSink;</span>
<a href="#l3.2569"></a><span id="l3.2569">     imapMailFolderSink = nullptr;</span>
<a href="#l3.2570"></a><span id="l3.2570" class="difflineminus">-  }</span>
<a href="#l3.2571"></a><span id="l3.2571" class="difflineminus">-  else</span>
<a href="#l3.2572"></a><span id="l3.2572" class="difflineplus">+  } else</span>
<a href="#l3.2573"></a><span id="l3.2573">     MOZ_LOG(IMAP, LogLevel::Info, (&quot;null imapMailFolderSink&quot;));</span>
<a href="#l3.2574"></a><span id="l3.2574"> </span>
<a href="#l3.2575"></a><span id="l3.2575">   // now try queued urls, now that we've released this connection.</span>
<a href="#l3.2576"></a><span id="l3.2576" class="difflineminus">-  if (m_imapServerSink)</span>
<a href="#l3.2577"></a><span id="l3.2577" class="difflineminus">-  {</span>
<a href="#l3.2578"></a><span id="l3.2578" class="difflineplus">+  if (m_imapServerSink) {</span>
<a href="#l3.2579"></a><span id="l3.2579">     if (NS_SUCCEEDED(GetConnectionStatus()))</span>
<a href="#l3.2580"></a><span id="l3.2580">       rv = m_imapServerSink-&gt;LoadNextQueuedUrl(this, &amp;anotherUrlRun);</span>
<a href="#l3.2581"></a><span id="l3.2581" class="difflineminus">-    else // if we don't do this, they'll just sit and spin until</span>
<a href="#l3.2582"></a><span id="l3.2582" class="difflineplus">+    else  // if we don't do this, they'll just sit and spin until</span>
<a href="#l3.2583"></a><span id="l3.2583">           // we run some other url on this server.</span>
<a href="#l3.2584"></a><span id="l3.2584">     {</span>
<a href="#l3.2585"></a><span id="l3.2585">       Log(&quot;ProcessCurrentURL&quot;, nullptr, &quot;aborting queued urls&quot;);</span>
<a href="#l3.2586"></a><span id="l3.2586">       rv = m_imapServerSink-&gt;AbortQueuedUrls();</span>
<a href="#l3.2587"></a><span id="l3.2587">     }</span>
<a href="#l3.2588"></a><span id="l3.2588">   }</span>
<a href="#l3.2589"></a><span id="l3.2589"> </span>
<a href="#l3.2590"></a><span id="l3.2590">   // if we didn't run another url, release the server sink to</span>
<a href="#l3.2591"></a><span id="l3.2591">   // cut circular refs.</span>
<a href="#l3.2592"></a><span id="l3.2592" class="difflineminus">-  if (!anotherUrlRun)</span>
<a href="#l3.2593"></a><span id="l3.2593" class="difflineminus">-      m_imapServerSink = nullptr;</span>
<a href="#l3.2594"></a><span id="l3.2594" class="difflineminus">-</span>
<a href="#l3.2595"></a><span id="l3.2595" class="difflineminus">-  if (NS_FAILED(GetConnectionStatus()) || !GetServerStateParser().Connected()</span>
<a href="#l3.2596"></a><span id="l3.2596" class="difflineminus">-    || GetServerStateParser().SyntaxError())</span>
<a href="#l3.2597"></a><span id="l3.2597" class="difflineminus">-  {</span>
<a href="#l3.2598"></a><span id="l3.2598" class="difflineminus">-    if (m_imapServerSink)</span>
<a href="#l3.2599"></a><span id="l3.2599" class="difflineminus">-      m_imapServerSink-&gt;RemoveServerConnection(this);</span>
<a href="#l3.2600"></a><span id="l3.2600" class="difflineminus">-</span>
<a href="#l3.2601"></a><span id="l3.2601" class="difflineminus">-    if (!DeathSignalReceived())</span>
<a href="#l3.2602"></a><span id="l3.2602" class="difflineminus">-    {</span>
<a href="#l3.2603"></a><span id="l3.2603" class="difflineminus">-        TellThreadToDie();</span>
<a href="#l3.2604"></a><span id="l3.2604" class="difflineminus">-    }</span>
<a href="#l3.2605"></a><span id="l3.2605" class="difflineminus">-  }</span>
<a href="#l3.2606"></a><span id="l3.2606" class="difflineminus">-  else</span>
<a href="#l3.2607"></a><span id="l3.2607" class="difflineminus">-  {</span>
<a href="#l3.2608"></a><span id="l3.2608" class="difflineminus">-    if (m_imapServerSink)</span>
<a href="#l3.2609"></a><span id="l3.2609" class="difflineminus">-    {</span>
<a href="#l3.2610"></a><span id="l3.2610" class="difflineplus">+  if (!anotherUrlRun) m_imapServerSink = nullptr;</span>
<a href="#l3.2611"></a><span id="l3.2611" class="difflineplus">+</span>
<a href="#l3.2612"></a><span id="l3.2612" class="difflineplus">+  if (NS_FAILED(GetConnectionStatus()) || !GetServerStateParser().Connected() ||</span>
<a href="#l3.2613"></a><span id="l3.2613" class="difflineplus">+      GetServerStateParser().SyntaxError()) {</span>
<a href="#l3.2614"></a><span id="l3.2614" class="difflineplus">+    if (m_imapServerSink) m_imapServerSink-&gt;RemoveServerConnection(this);</span>
<a href="#l3.2615"></a><span id="l3.2615" class="difflineplus">+</span>
<a href="#l3.2616"></a><span id="l3.2616" class="difflineplus">+    if (!DeathSignalReceived()) {</span>
<a href="#l3.2617"></a><span id="l3.2617" class="difflineplus">+      TellThreadToDie();</span>
<a href="#l3.2618"></a><span id="l3.2618" class="difflineplus">+    }</span>
<a href="#l3.2619"></a><span id="l3.2619" class="difflineplus">+  } else {</span>
<a href="#l3.2620"></a><span id="l3.2620" class="difflineplus">+    if (m_imapServerSink) {</span>
<a href="#l3.2621"></a><span id="l3.2621">       bool shuttingDown;</span>
<a href="#l3.2622"></a><span id="l3.2622">       m_imapServerSink-&gt;GetServerShuttingDown(&amp;shuttingDown);</span>
<a href="#l3.2623"></a><span id="l3.2623" class="difflineminus">-      if (shuttingDown)</span>
<a href="#l3.2624"></a><span id="l3.2624" class="difflineminus">-        m_useIdle = false;</span>
<a href="#l3.2625"></a><span id="l3.2625" class="difflineplus">+      if (shuttingDown) m_useIdle = false;</span>
<a href="#l3.2626"></a><span id="l3.2626">     }</span>
<a href="#l3.2627"></a><span id="l3.2627">   }</span>
<a href="#l3.2628"></a><span id="l3.2628">   return anotherUrlRun;</span>
<a href="#l3.2629"></a><span id="l3.2629"> }</span>
<a href="#l3.2630"></a><span id="l3.2630"> </span>
<a href="#l3.2631"></a><span id="l3.2631" class="difflineminus">-bool nsImapProtocol::RetryUrl()</span>
<a href="#l3.2632"></a><span id="l3.2632" class="difflineminus">-{</span>
<a href="#l3.2633"></a><span id="l3.2633" class="difflineminus">-  nsCOMPtr &lt;nsIImapUrl&gt; kungFuGripImapUrl = m_runningUrl;</span>
<a href="#l3.2634"></a><span id="l3.2634" class="difflineminus">-  nsCOMPtr &lt;nsIImapMockChannel&gt; saveMockChannel;</span>
<a href="#l3.2635"></a><span id="l3.2635" class="difflineplus">+bool nsImapProtocol::RetryUrl() {</span>
<a href="#l3.2636"></a><span id="l3.2636" class="difflineplus">+  nsCOMPtr&lt;nsIImapUrl&gt; kungFuGripImapUrl = m_runningUrl;</span>
<a href="#l3.2637"></a><span id="l3.2637" class="difflineplus">+  nsCOMPtr&lt;nsIImapMockChannel&gt; saveMockChannel;</span>
<a href="#l3.2638"></a><span id="l3.2638"> </span>
<a href="#l3.2639"></a><span id="l3.2639">   // the mock channel might be null - that's OK.</span>
<a href="#l3.2640"></a><span id="l3.2640">   if (m_imapServerSink)</span>
<a href="#l3.2641"></a><span id="l3.2641" class="difflineminus">-    (void) m_imapServerSink-&gt;PrepareToRetryUrl(kungFuGripImapUrl, getter_AddRefs(saveMockChannel));</span>
<a href="#l3.2642"></a><span id="l3.2642" class="difflineplus">+    (void)m_imapServerSink-&gt;PrepareToRetryUrl(kungFuGripImapUrl,</span>
<a href="#l3.2643"></a><span id="l3.2643" class="difflineplus">+                                              getter_AddRefs(saveMockChannel));</span>
<a href="#l3.2644"></a><span id="l3.2644"> </span>
<a href="#l3.2645"></a><span id="l3.2645">   ReleaseUrlState(true);</span>
<a href="#l3.2646"></a><span id="l3.2646" class="difflineminus">-  if (m_imapServerSink)</span>
<a href="#l3.2647"></a><span id="l3.2647" class="difflineminus">-  {</span>
<a href="#l3.2648"></a><span id="l3.2648" class="difflineplus">+  if (m_imapServerSink) {</span>
<a href="#l3.2649"></a><span id="l3.2649">     m_imapServerSink-&gt;RemoveServerConnection(this);</span>
<a href="#l3.2650"></a><span id="l3.2650">     m_imapServerSink-&gt;RetryUrl(kungFuGripImapUrl, saveMockChannel);</span>
<a href="#l3.2651"></a><span id="l3.2651">   }</span>
<a href="#l3.2652"></a><span id="l3.2652" class="difflineminus">-  return (m_imapServerSink != nullptr); // we're running a url (the same url)</span>
<a href="#l3.2653"></a><span id="l3.2653" class="difflineminus">-}</span>
<a href="#l3.2654"></a><span id="l3.2654" class="difflineminus">-</span>
<a href="#l3.2655"></a><span id="l3.2655" class="difflineminus">-// ignoreBadAndNOResponses --&gt; don't throw a error dialog if this command results in a NO or Bad response</span>
<a href="#l3.2656"></a><span id="l3.2656" class="difflineminus">-// from the server..in other words the command is &quot;exploratory&quot; and we don't really care if it succeeds or fails.</span>
<a href="#l3.2657"></a><span id="l3.2657" class="difflineminus">-void nsImapProtocol::ParseIMAPandCheckForNewMail(const char* commandString, bool aIgnoreBadAndNOResponses)</span>
<a href="#l3.2658"></a><span id="l3.2658" class="difflineminus">-{</span>
<a href="#l3.2659"></a><span id="l3.2659" class="difflineminus">-    if (commandString)</span>
<a href="#l3.2660"></a><span id="l3.2660" class="difflineminus">-        GetServerStateParser().ParseIMAPServerResponse(commandString, aIgnoreBadAndNOResponses);</span>
<a href="#l3.2661"></a><span id="l3.2661" class="difflineminus">-    else</span>
<a href="#l3.2662"></a><span id="l3.2662" class="difflineminus">-        GetServerStateParser().ParseIMAPServerResponse(m_currentCommand.get(), aIgnoreBadAndNOResponses);</span>
<a href="#l3.2663"></a><span id="l3.2663" class="difflineminus">-    // **** fix me for new mail biff state *****</span>
<a href="#l3.2664"></a><span id="l3.2664" class="difflineplus">+  return (m_imapServerSink != nullptr);  // we're running a url (the same url)</span>
<a href="#l3.2665"></a><span id="l3.2665" class="difflineplus">+}</span>
<a href="#l3.2666"></a><span id="l3.2666" class="difflineplus">+</span>
<a href="#l3.2667"></a><span id="l3.2667" class="difflineplus">+// ignoreBadAndNOResponses --&gt; don't throw a error dialog if this command</span>
<a href="#l3.2668"></a><span id="l3.2668" class="difflineplus">+// results in a NO or Bad response from the server..in other words the command</span>
<a href="#l3.2669"></a><span id="l3.2669" class="difflineplus">+// is &quot;exploratory&quot; and we don't really care if it succeeds or fails.</span>
<a href="#l3.2670"></a><span id="l3.2670" class="difflineplus">+void nsImapProtocol::ParseIMAPandCheckForNewMail(</span>
<a href="#l3.2671"></a><span id="l3.2671" class="difflineplus">+    const char *commandString, bool aIgnoreBadAndNOResponses) {</span>
<a href="#l3.2672"></a><span id="l3.2672" class="difflineplus">+  if (commandString)</span>
<a href="#l3.2673"></a><span id="l3.2673" class="difflineplus">+    GetServerStateParser().ParseIMAPServerResponse(commandString,</span>
<a href="#l3.2674"></a><span id="l3.2674" class="difflineplus">+                                                   aIgnoreBadAndNOResponses);</span>
<a href="#l3.2675"></a><span id="l3.2675" class="difflineplus">+  else</span>
<a href="#l3.2676"></a><span id="l3.2676" class="difflineplus">+    GetServerStateParser().ParseIMAPServerResponse(m_currentCommand.get(),</span>
<a href="#l3.2677"></a><span id="l3.2677" class="difflineplus">+                                                   aIgnoreBadAndNOResponses);</span>
<a href="#l3.2678"></a><span id="l3.2678" class="difflineplus">+  // **** fix me for new mail biff state *****</span>
<a href="#l3.2679"></a><span id="l3.2679"> }</span>
<a href="#l3.2680"></a><span id="l3.2680"> </span>
<a href="#l3.2681"></a><span id="l3.2681"> /////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.2682"></a><span id="l3.2682"> // End of nsIStreamListenerSupport</span>
<a href="#l3.2683"></a><span id="l3.2683"> //////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.2684"></a><span id="l3.2684"> </span>
<a href="#l3.2685"></a><span id="l3.2685"> NS_IMETHODIMP</span>
<a href="#l3.2686"></a><span id="l3.2686" class="difflineminus">-nsImapProtocol::GetRunningUrl(nsIURI **result)</span>
<a href="#l3.2687"></a><span id="l3.2687" class="difflineminus">-{</span>
<a href="#l3.2688"></a><span id="l3.2688" class="difflineminus">-    if (result &amp;&amp; m_runningUrl)</span>
<a href="#l3.2689"></a><span id="l3.2689" class="difflineminus">-        return m_runningUrl-&gt;QueryInterface(NS_GET_IID(nsIURI), (void**)</span>
<a href="#l3.2690"></a><span id="l3.2690" class="difflineminus">-                                            result);</span>
<a href="#l3.2691"></a><span id="l3.2691" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.2692"></a><span id="l3.2692" class="difflineminus">-}</span>
<a href="#l3.2693"></a><span id="l3.2693" class="difflineminus">-</span>
<a href="#l3.2694"></a><span id="l3.2694" class="difflineminus">-</span>
<a href="#l3.2695"></a><span id="l3.2695" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::GetRunningImapURL(nsIImapUrl **aImapUrl)</span>
<a href="#l3.2696"></a><span id="l3.2696" class="difflineminus">-{</span>
<a href="#l3.2697"></a><span id="l3.2697" class="difflineplus">+nsImapProtocol::GetRunningUrl(nsIURI **result) {</span>
<a href="#l3.2698"></a><span id="l3.2698" class="difflineplus">+  if (result &amp;&amp; m_runningUrl)</span>
<a href="#l3.2699"></a><span id="l3.2699" class="difflineplus">+    return m_runningUrl-&gt;QueryInterface(NS_GET_IID(nsIURI), (void **)result);</span>
<a href="#l3.2700"></a><span id="l3.2700" class="difflineplus">+  return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.2701"></a><span id="l3.2701" class="difflineplus">+}</span>
<a href="#l3.2702"></a><span id="l3.2702" class="difflineplus">+</span>
<a href="#l3.2703"></a><span id="l3.2703" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::GetRunningImapURL(nsIImapUrl **aImapUrl) {</span>
<a href="#l3.2704"></a><span id="l3.2704">   if (aImapUrl &amp;&amp; m_runningUrl)</span>
<a href="#l3.2705"></a><span id="l3.2705" class="difflineminus">-     return m_runningUrl-&gt;QueryInterface(NS_GET_IID(nsIImapUrl), (void**) aImapUrl);</span>
<a href="#l3.2706"></a><span id="l3.2706" class="difflineplus">+    return m_runningUrl-&gt;QueryInterface(NS_GET_IID(nsIImapUrl),</span>
<a href="#l3.2707"></a><span id="l3.2707" class="difflineplus">+                                        (void **)aImapUrl);</span>
<a href="#l3.2708"></a><span id="l3.2708">   return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.2709"></a><span id="l3.2709"> }</span>
<a href="#l3.2710"></a><span id="l3.2710"> </span>
<a href="#l3.2711"></a><span id="l3.2711"> /*</span>
<a href="#l3.2712"></a><span id="l3.2712" class="difflineminus">- * Writes the data contained in dataBuffer into the current output stream. It also informs</span>
<a href="#l3.2713"></a><span id="l3.2713" class="difflineminus">- * the transport layer that this data is now available for transmission.</span>
<a href="#l3.2714"></a><span id="l3.2714" class="difflineminus">- * Returns a positive number for success, 0 for failure (not all the bytes were written to the</span>
<a href="#l3.2715"></a><span id="l3.2715" class="difflineminus">- * stream, etc). We need to make another pass through this file to install an error system (mscott)</span>
<a href="#l3.2716"></a><span id="l3.2716" class="difflineplus">+ * Writes the data contained in dataBuffer into the current output stream. It</span>
<a href="#l3.2717"></a><span id="l3.2717" class="difflineplus">+ * also informs the transport layer that this data is now available for</span>
<a href="#l3.2718"></a><span id="l3.2718" class="difflineplus">+ * transmission. Returns a positive number for success, 0 for failure (not all</span>
<a href="#l3.2719"></a><span id="l3.2719" class="difflineplus">+ * the bytes were written to the stream, etc). We need to make another pass</span>
<a href="#l3.2720"></a><span id="l3.2720" class="difflineplus">+ * through this file to install an error system (mscott)</span>
<a href="#l3.2721"></a><span id="l3.2721">  */</span>
<a href="#l3.2722"></a><span id="l3.2722"> </span>
<a href="#l3.2723"></a><span id="l3.2723" class="difflineminus">-nsresult nsImapProtocol::SendData(const char * dataBuffer, bool aSuppressLogging)</span>
<a href="#l3.2724"></a><span id="l3.2724" class="difflineminus">-{</span>
<a href="#l3.2725"></a><span id="l3.2725" class="difflineplus">+nsresult nsImapProtocol::SendData(const char *dataBuffer,</span>
<a href="#l3.2726"></a><span id="l3.2726" class="difflineplus">+                                  bool aSuppressLogging) {</span>
<a href="#l3.2727"></a><span id="l3.2727">   nsresult rv = NS_ERROR_NULL_POINTER;</span>
<a href="#l3.2728"></a><span id="l3.2728"> </span>
<a href="#l3.2729"></a><span id="l3.2729" class="difflineminus">-  if (!m_transport)</span>
<a href="#l3.2730"></a><span id="l3.2730" class="difflineminus">-  {</span>
<a href="#l3.2731"></a><span id="l3.2731" class="difflineminus">-      Log(&quot;SendData&quot;, nullptr, &quot;clearing IMAP_CONNECTION_IS_OPEN&quot;);</span>
<a href="#l3.2732"></a><span id="l3.2732" class="difflineminus">-      // the connection died unexpectedly! so clear the open connection flag</span>
<a href="#l3.2733"></a><span id="l3.2733" class="difflineminus">-      ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.2734"></a><span id="l3.2734" class="difflineminus">-      TellThreadToDie();</span>
<a href="#l3.2735"></a><span id="l3.2735" class="difflineminus">-      SetConnectionStatus(NS_ERROR_FAILURE);</span>
<a href="#l3.2736"></a><span id="l3.2736" class="difflineminus">-      return NS_ERROR_FAILURE;</span>
<a href="#l3.2737"></a><span id="l3.2737" class="difflineminus">-  }</span>
<a href="#l3.2738"></a><span id="l3.2738" class="difflineminus">-</span>
<a href="#l3.2739"></a><span id="l3.2739" class="difflineminus">-  if (dataBuffer &amp;&amp; m_outputStream)</span>
<a href="#l3.2740"></a><span id="l3.2740" class="difflineminus">-  {</span>
<a href="#l3.2741"></a><span id="l3.2741" class="difflineplus">+  if (!m_transport) {</span>
<a href="#l3.2742"></a><span id="l3.2742" class="difflineplus">+    Log(&quot;SendData&quot;, nullptr, &quot;clearing IMAP_CONNECTION_IS_OPEN&quot;);</span>
<a href="#l3.2743"></a><span id="l3.2743" class="difflineplus">+    // the connection died unexpectedly! so clear the open connection flag</span>
<a href="#l3.2744"></a><span id="l3.2744" class="difflineplus">+    ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.2745"></a><span id="l3.2745" class="difflineplus">+    TellThreadToDie();</span>
<a href="#l3.2746"></a><span id="l3.2746" class="difflineplus">+    SetConnectionStatus(NS_ERROR_FAILURE);</span>
<a href="#l3.2747"></a><span id="l3.2747" class="difflineplus">+    return NS_ERROR_FAILURE;</span>
<a href="#l3.2748"></a><span id="l3.2748" class="difflineplus">+  }</span>
<a href="#l3.2749"></a><span id="l3.2749" class="difflineplus">+</span>
<a href="#l3.2750"></a><span id="l3.2750" class="difflineplus">+  if (dataBuffer &amp;&amp; m_outputStream) {</span>
<a href="#l3.2751"></a><span id="l3.2751">     m_currentCommand = dataBuffer;</span>
<a href="#l3.2752"></a><span id="l3.2752">     if (!aSuppressLogging)</span>
<a href="#l3.2753"></a><span id="l3.2753">       Log(&quot;SendData&quot;, nullptr, dataBuffer);</span>
<a href="#l3.2754"></a><span id="l3.2754">     else</span>
<a href="#l3.2755"></a><span id="l3.2755" class="difflineminus">-      Log(&quot;SendData&quot;, nullptr, &quot;Logging suppressed for this command (it probably contained authentication information)&quot;);</span>
<a href="#l3.2756"></a><span id="l3.2756" class="difflineplus">+      Log(&quot;SendData&quot;, nullptr,</span>
<a href="#l3.2757"></a><span id="l3.2757" class="difflineplus">+          &quot;Logging suppressed for this command (it probably contained &quot;</span>
<a href="#l3.2758"></a><span id="l3.2758" class="difflineplus">+          &quot;authentication information)&quot;);</span>
<a href="#l3.2759"></a><span id="l3.2759"> </span>
<a href="#l3.2760"></a><span id="l3.2760">     {</span>
<a href="#l3.2761"></a><span id="l3.2761">       // don't allow someone to close the stream/transport out from under us</span>
<a href="#l3.2762"></a><span id="l3.2762">       // this can happen when the ui thread calls TellThreadToDie.</span>
<a href="#l3.2763"></a><span id="l3.2763">       PR_CEnterMonitor(this);</span>
<a href="#l3.2764"></a><span id="l3.2764">       uint32_t n;</span>
<a href="#l3.2765"></a><span id="l3.2765">       if (m_outputStream)</span>
<a href="#l3.2766"></a><span id="l3.2766">         rv = m_outputStream-&gt;Write(dataBuffer, PL_strlen(dataBuffer), &amp;n);</span>
<a href="#l3.2767"></a><span id="l3.2767">       PR_CExitMonitor(this);</span>
<a href="#l3.2768"></a><span id="l3.2768">     }</span>
<a href="#l3.2769"></a><span id="l3.2769" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.2770"></a><span id="l3.2770" class="difflineminus">-    {</span>
<a href="#l3.2771"></a><span id="l3.2771" class="difflineplus">+    if (NS_FAILED(rv)) {</span>
<a href="#l3.2772"></a><span id="l3.2772">       Log(&quot;SendData&quot;, nullptr, &quot;clearing IMAP_CONNECTION_IS_OPEN&quot;);</span>
<a href="#l3.2773"></a><span id="l3.2773">       // the connection died unexpectedly! so clear the open connection flag</span>
<a href="#l3.2774"></a><span id="l3.2774">       ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.2775"></a><span id="l3.2775">       TellThreadToDie();</span>
<a href="#l3.2776"></a><span id="l3.2776">       SetConnectionStatus(rv);</span>
<a href="#l3.2777"></a><span id="l3.2777" class="difflineminus">-      if (m_runningUrl &amp;&amp; !m_retryUrlOnError)</span>
<a href="#l3.2778"></a><span id="l3.2778" class="difflineminus">-      {</span>
<a href="#l3.2779"></a><span id="l3.2779" class="difflineplus">+      if (m_runningUrl &amp;&amp; !m_retryUrlOnError) {</span>
<a href="#l3.2780"></a><span id="l3.2780">         bool alreadyRerunningUrl;</span>
<a href="#l3.2781"></a><span id="l3.2781">         m_runningUrl-&gt;GetRerunningUrl(&amp;alreadyRerunningUrl);</span>
<a href="#l3.2782"></a><span id="l3.2782" class="difflineminus">-        if (!alreadyRerunningUrl)</span>
<a href="#l3.2783"></a><span id="l3.2783" class="difflineminus">-        {</span>
<a href="#l3.2784"></a><span id="l3.2784" class="difflineplus">+        if (!alreadyRerunningUrl) {</span>
<a href="#l3.2785"></a><span id="l3.2785">           m_runningUrl-&gt;SetRerunningUrl(true);</span>
<a href="#l3.2786"></a><span id="l3.2786">           m_retryUrlOnError = true;</span>
<a href="#l3.2787"></a><span id="l3.2787">         }</span>
<a href="#l3.2788"></a><span id="l3.2788">       }</span>
<a href="#l3.2789"></a><span id="l3.2789">     }</span>
<a href="#l3.2790"></a><span id="l3.2790">   }</span>
<a href="#l3.2791"></a><span id="l3.2791"> </span>
<a href="#l3.2792"></a><span id="l3.2792">   return rv;</span>
<a href="#l3.2793"></a><span id="l3.2793"> }</span>
<a href="#l3.2794"></a><span id="l3.2794"> </span>
<a href="#l3.2795"></a><span id="l3.2795"> /////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.2796"></a><span id="l3.2796"> // Begin protocol state machine functions...</span>
<a href="#l3.2797"></a><span id="l3.2797"> //////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.2798"></a><span id="l3.2798"> </span>
<a href="#l3.2799"></a><span id="l3.2799" class="difflineminus">-  // ProcessProtocolState - we override this only so we'll link - it should never get called.</span>
<a href="#l3.2800"></a><span id="l3.2800" class="difflineminus">-</span>
<a href="#l3.2801"></a><span id="l3.2801" class="difflineminus">-nsresult nsImapProtocol::ProcessProtocolState(nsIURI * url, nsIInputStream * inputStream,</span>
<a href="#l3.2802"></a><span id="l3.2802" class="difflineminus">-                                              uint64_t sourceOffset, uint32_t length)</span>
<a href="#l3.2803"></a><span id="l3.2803" class="difflineminus">-{</span>
<a href="#l3.2804"></a><span id="l3.2804" class="difflineplus">+// ProcessProtocolState - we override this only so we'll link - it should never</span>
<a href="#l3.2805"></a><span id="l3.2805" class="difflineplus">+// get called.</span>
<a href="#l3.2806"></a><span id="l3.2806" class="difflineplus">+</span>
<a href="#l3.2807"></a><span id="l3.2807" class="difflineplus">+nsresult nsImapProtocol::ProcessProtocolState(nsIURI *url,</span>
<a href="#l3.2808"></a><span id="l3.2808" class="difflineplus">+                                              nsIInputStream *inputStream,</span>
<a href="#l3.2809"></a><span id="l3.2809" class="difflineplus">+                                              uint64_t sourceOffset,</span>
<a href="#l3.2810"></a><span id="l3.2810" class="difflineplus">+                                              uint32_t length) {</span>
<a href="#l3.2811"></a><span id="l3.2811">   return NS_OK;</span>
<a href="#l3.2812"></a><span id="l3.2812"> }</span>
<a href="#l3.2813"></a><span id="l3.2813"> </span>
<a href="#l3.2814"></a><span id="l3.2814" class="difflineminus">-class UrlListenerNotifierEvent : public mozilla::Runnable</span>
<a href="#l3.2815"></a><span id="l3.2815" class="difflineminus">-{</span>
<a href="#l3.2816"></a><span id="l3.2816" class="difflineminus">-public:</span>
<a href="#l3.2817"></a><span id="l3.2817" class="difflineplus">+class UrlListenerNotifierEvent : public mozilla::Runnable {</span>
<a href="#l3.2818"></a><span id="l3.2818" class="difflineplus">+ public:</span>
<a href="#l3.2819"></a><span id="l3.2819">   UrlListenerNotifierEvent(nsIMsgMailNewsUrl *aUrl, nsIImapProtocol *aProtocol)</span>
<a href="#l3.2820"></a><span id="l3.2820" class="difflineminus">-    : mozilla::Runnable(&quot;UrlListenerNotifierEvent&quot;)</span>
<a href="#l3.2821"></a><span id="l3.2821" class="difflineminus">-    , mUrl(aUrl), mProtocol(aProtocol)</span>
<a href="#l3.2822"></a><span id="l3.2822" class="difflineminus">-  {}</span>
<a href="#l3.2823"></a><span id="l3.2823" class="difflineminus">-</span>
<a href="#l3.2824"></a><span id="l3.2824" class="difflineminus">-  NS_IMETHOD Run()</span>
<a href="#l3.2825"></a><span id="l3.2825" class="difflineminus">-  {</span>
<a href="#l3.2826"></a><span id="l3.2826" class="difflineminus">-    if (mUrl)</span>
<a href="#l3.2827"></a><span id="l3.2827" class="difflineminus">-    {</span>
<a href="#l3.2828"></a><span id="l3.2828" class="difflineplus">+      : mozilla::Runnable(&quot;UrlListenerNotifierEvent&quot;),</span>
<a href="#l3.2829"></a><span id="l3.2829" class="difflineplus">+        mUrl(aUrl),</span>
<a href="#l3.2830"></a><span id="l3.2830" class="difflineplus">+        mProtocol(aProtocol) {}</span>
<a href="#l3.2831"></a><span id="l3.2831" class="difflineplus">+</span>
<a href="#l3.2832"></a><span id="l3.2832" class="difflineplus">+  NS_IMETHOD Run() {</span>
<a href="#l3.2833"></a><span id="l3.2833" class="difflineplus">+    if (mUrl) {</span>
<a href="#l3.2834"></a><span id="l3.2834">       nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.2835"></a><span id="l3.2835">       mUrl-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l3.2836"></a><span id="l3.2836">       NS_ENSURE_TRUE(folder, NS_OK);</span>
<a href="#l3.2837"></a><span id="l3.2837">       nsCOMPtr&lt;nsIImapMailFolderSink&gt; folderSink(do_QueryInterface(folder));</span>
<a href="#l3.2838"></a><span id="l3.2838">       // This causes the url listener to get OnStart and Stop notifications.</span>
<a href="#l3.2839"></a><span id="l3.2839">       folderSink-&gt;SetUrlState(mProtocol, mUrl, true, false, NS_OK);</span>
<a href="#l3.2840"></a><span id="l3.2840">       folderSink-&gt;SetUrlState(mProtocol, mUrl, false, false, NS_OK);</span>
<a href="#l3.2841"></a><span id="l3.2841">     }</span>
<a href="#l3.2842"></a><span id="l3.2842">     return NS_OK;</span>
<a href="#l3.2843"></a><span id="l3.2843">   }</span>
<a href="#l3.2844"></a><span id="l3.2844"> </span>
<a href="#l3.2845"></a><span id="l3.2845" class="difflineminus">-private:</span>
<a href="#l3.2846"></a><span id="l3.2846" class="difflineplus">+ private:</span>
<a href="#l3.2847"></a><span id="l3.2847">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mUrl;</span>
<a href="#l3.2848"></a><span id="l3.2848">   nsCOMPtr&lt;nsIImapProtocol&gt; mProtocol;</span>
<a href="#l3.2849"></a><span id="l3.2849"> };</span>
<a href="#l3.2850"></a><span id="l3.2850"> </span>
<a href="#l3.2851"></a><span id="l3.2851" class="difflineminus">-</span>
<a href="#l3.2852"></a><span id="l3.2852" class="difflineminus">-bool nsImapProtocol::TryToRunUrlLocally(nsIURI *aURL, nsISupports *aConsumer)</span>
<a href="#l3.2853"></a><span id="l3.2853" class="difflineminus">-{</span>
<a href="#l3.2854"></a><span id="l3.2854" class="difflineplus">+bool nsImapProtocol::TryToRunUrlLocally(nsIURI *aURL, nsISupports *aConsumer) {</span>
<a href="#l3.2855"></a><span id="l3.2855">   nsresult rv;</span>
<a href="#l3.2856"></a><span id="l3.2856">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl(do_QueryInterface(aURL, &amp;rv));</span>
<a href="#l3.2857"></a><span id="l3.2857">   NS_ENSURE_SUCCESS(rv, false);</span>
<a href="#l3.2858"></a><span id="l3.2858">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(aURL);</span>
<a href="#l3.2859"></a><span id="l3.2859">   nsCString messageIdString;</span>
<a href="#l3.2860"></a><span id="l3.2860">   imapUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.2861"></a><span id="l3.2861">   bool useLocalCache = false;</span>
<a href="#l3.2862"></a><span id="l3.2862" class="difflineminus">-  if (!messageIdString.IsEmpty() &amp;&amp; !HandlingMultipleMessages(messageIdString))</span>
<a href="#l3.2863"></a><span id="l3.2863" class="difflineminus">-  {</span>
<a href="#l3.2864"></a><span id="l3.2864" class="difflineplus">+  if (!messageIdString.IsEmpty() &amp;&amp;</span>
<a href="#l3.2865"></a><span id="l3.2865" class="difflineplus">+      !HandlingMultipleMessages(messageIdString)) {</span>
<a href="#l3.2866"></a><span id="l3.2866">     nsImapAction action;</span>
<a href="#l3.2867"></a><span id="l3.2867">     imapUrl-&gt;GetImapAction(&amp;action);</span>
<a href="#l3.2868"></a><span id="l3.2868" class="difflineminus">-    nsCOMPtr &lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.2869"></a><span id="l3.2869" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.2870"></a><span id="l3.2870">     mailnewsUrl-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l3.2871"></a><span id="l3.2871">     NS_ENSURE_TRUE(folder, false);</span>
<a href="#l3.2872"></a><span id="l3.2872"> </span>
<a href="#l3.2873"></a><span id="l3.2873" class="difflineminus">-    folder-&gt;HasMsgOffline(strtoul(messageIdString.get(), nullptr, 10), &amp;useLocalCache);</span>
<a href="#l3.2874"></a><span id="l3.2874" class="difflineplus">+    folder-&gt;HasMsgOffline(strtoul(messageIdString.get(), nullptr, 10),</span>
<a href="#l3.2875"></a><span id="l3.2875" class="difflineplus">+                          &amp;useLocalCache);</span>
<a href="#l3.2876"></a><span id="l3.2876">     mailnewsUrl-&gt;SetMsgIsInLocalCache(useLocalCache);</span>
<a href="#l3.2877"></a><span id="l3.2877">     // We're downloading a single message for offline use, and it's</span>
<a href="#l3.2878"></a><span id="l3.2878">     // already offline. So we shouldn't do anything, but we do</span>
<a href="#l3.2879"></a><span id="l3.2879">     // need to notify the url listener.</span>
<a href="#l3.2880"></a><span id="l3.2880" class="difflineminus">-    if (useLocalCache &amp;&amp; action == nsIImapUrl::nsImapMsgDownloadForOffline)</span>
<a href="#l3.2881"></a><span id="l3.2881" class="difflineminus">-    {</span>
<a href="#l3.2882"></a><span id="l3.2882" class="difflineminus">-      nsCOMPtr&lt;nsIRunnable&gt; event = new UrlListenerNotifierEvent(mailnewsUrl,</span>
<a href="#l3.2883"></a><span id="l3.2883" class="difflineminus">-                                                                 this);</span>
<a href="#l3.2884"></a><span id="l3.2884" class="difflineplus">+    if (useLocalCache &amp;&amp; action == nsIImapUrl::nsImapMsgDownloadForOffline) {</span>
<a href="#l3.2885"></a><span id="l3.2885" class="difflineplus">+      nsCOMPtr&lt;nsIRunnable&gt; event =</span>
<a href="#l3.2886"></a><span id="l3.2886" class="difflineplus">+          new UrlListenerNotifierEvent(mailnewsUrl, this);</span>
<a href="#l3.2887"></a><span id="l3.2887">       // Post this as an event because it can lead to re-entrant calls to</span>
<a href="#l3.2888"></a><span id="l3.2888">       // LoadNextQueuedUrl if the listener runs a new url.</span>
<a href="#l3.2889"></a><span id="l3.2889" class="difflineminus">-      if (event)</span>
<a href="#l3.2890"></a><span id="l3.2890" class="difflineminus">-        NS_DispatchToCurrentThread(event);</span>
<a href="#l3.2891"></a><span id="l3.2891" class="difflineplus">+      if (event) NS_DispatchToCurrentThread(event);</span>
<a href="#l3.2892"></a><span id="l3.2892">       return true;</span>
<a href="#l3.2893"></a><span id="l3.2893">     }</span>
<a href="#l3.2894"></a><span id="l3.2894">   }</span>
<a href="#l3.2895"></a><span id="l3.2895" class="difflineminus">-  if (!useLocalCache)</span>
<a href="#l3.2896"></a><span id="l3.2896" class="difflineminus">-    return false;</span>
<a href="#l3.2897"></a><span id="l3.2897" class="difflineplus">+  if (!useLocalCache) return false;</span>
<a href="#l3.2898"></a><span id="l3.2898"> </span>
<a href="#l3.2899"></a><span id="l3.2899">   nsCOMPtr&lt;nsIImapMockChannel&gt; mockChannel;</span>
<a href="#l3.2900"></a><span id="l3.2900">   imapUrl-&gt;GetMockChannel(getter_AddRefs(mockChannel));</span>
<a href="#l3.2901"></a><span id="l3.2901" class="difflineminus">-  if (!mockChannel)</span>
<a href="#l3.2902"></a><span id="l3.2902" class="difflineminus">-    return false;</span>
<a href="#l3.2903"></a><span id="l3.2903" class="difflineminus">-</span>
<a href="#l3.2904"></a><span id="l3.2904" class="difflineminus">-  nsImapMockChannel *imapChannel = static_cast&lt;nsImapMockChannel *&gt;(mockChannel.get());</span>
<a href="#l3.2905"></a><span id="l3.2905" class="difflineminus">-  if (!imapChannel)</span>
<a href="#l3.2906"></a><span id="l3.2906" class="difflineminus">-    return false;</span>
<a href="#l3.2907"></a><span id="l3.2907" class="difflineminus">-</span>
<a href="#l3.2908"></a><span id="l3.2908" class="difflineminus">-  nsCOMPtr &lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.2909"></a><span id="l3.2909" class="difflineplus">+  if (!mockChannel) return false;</span>
<a href="#l3.2910"></a><span id="l3.2910" class="difflineplus">+</span>
<a href="#l3.2911"></a><span id="l3.2911" class="difflineplus">+  nsImapMockChannel *imapChannel =</span>
<a href="#l3.2912"></a><span id="l3.2912" class="difflineplus">+      static_cast&lt;nsImapMockChannel *&gt;(mockChannel.get());</span>
<a href="#l3.2913"></a><span id="l3.2913" class="difflineplus">+  if (!imapChannel) return false;</span>
<a href="#l3.2914"></a><span id="l3.2914" class="difflineplus">+</span>
<a href="#l3.2915"></a><span id="l3.2915" class="difflineplus">+  nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.2916"></a><span id="l3.2916">   imapChannel-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.2917"></a><span id="l3.2917" class="difflineminus">-  if (!loadGroup) // if we don't have one, the url will snag one from the msg window...</span>
<a href="#l3.2918"></a><span id="l3.2918" class="difflineplus">+  if (!loadGroup)  // if we don't have one, the url will snag one from the msg</span>
<a href="#l3.2919"></a><span id="l3.2919" class="difflineplus">+                   // window...</span>
<a href="#l3.2920"></a><span id="l3.2920">     mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.2921"></a><span id="l3.2921"> </span>
<a href="#l3.2922"></a><span id="l3.2922">   if (loadGroup)</span>
<a href="#l3.2923"></a><span id="l3.2923" class="difflineminus">-    loadGroup-&gt;RemoveRequest((nsIRequest *) mockChannel, nullptr /* context isupports */, NS_OK);</span>
<a href="#l3.2924"></a><span id="l3.2924" class="difflineminus">-</span>
<a href="#l3.2925"></a><span id="l3.2925" class="difflineminus">-  if (imapChannel-&gt;ReadFromLocalCache())</span>
<a href="#l3.2926"></a><span id="l3.2926" class="difflineminus">-  {</span>
<a href="#l3.2927"></a><span id="l3.2927" class="difflineminus">-    (void) imapChannel-&gt;NotifyStartEndReadFromCache(true);</span>
<a href="#l3.2928"></a><span id="l3.2928" class="difflineplus">+    loadGroup-&gt;RemoveRequest((nsIRequest *)mockChannel,</span>
<a href="#l3.2929"></a><span id="l3.2929" class="difflineplus">+                             nullptr /* context isupports */, NS_OK);</span>
<a href="#l3.2930"></a><span id="l3.2930" class="difflineplus">+</span>
<a href="#l3.2931"></a><span id="l3.2931" class="difflineplus">+  if (imapChannel-&gt;ReadFromLocalCache()) {</span>
<a href="#l3.2932"></a><span id="l3.2932" class="difflineplus">+    (void)imapChannel-&gt;NotifyStartEndReadFromCache(true);</span>
<a href="#l3.2933"></a><span id="l3.2933">     return true;</span>
<a href="#l3.2934"></a><span id="l3.2934">   }</span>
<a href="#l3.2935"></a><span id="l3.2935">   return false;</span>
<a href="#l3.2936"></a><span id="l3.2936"> }</span>
<a href="#l3.2937"></a><span id="l3.2937"> </span>
<a href="#l3.2938"></a><span id="l3.2938" class="difflineminus">-</span>
<a href="#l3.2939"></a><span id="l3.2939" class="difflineminus">-// LoadImapUrl takes a url, initializes all of our url specific data by calling SetupUrl.</span>
<a href="#l3.2940"></a><span id="l3.2940" class="difflineminus">-// If we don't have a connection yet, we open the connection. Finally, we signal the</span>
<a href="#l3.2941"></a><span id="l3.2941" class="difflineminus">-// url to run monitor to let the imap main thread loop process the current url (it is waiting</span>
<a href="#l3.2942"></a><span id="l3.2942" class="difflineminus">-// on this monitor). There is a contract that the imap thread has already been started b4 we</span>
<a href="#l3.2943"></a><span id="l3.2943" class="difflineminus">-// attempt to load a url....</span>
<a href="#l3.2944"></a><span id="l3.2944" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::LoadImapUrl(nsIURI * aURL, nsISupports * aConsumer)</span>
<a href="#l3.2945"></a><span id="l3.2945" class="difflineminus">-{</span>
<a href="#l3.2946"></a><span id="l3.2946" class="difflineplus">+// LoadImapUrl takes a url, initializes all of our url specific data by calling</span>
<a href="#l3.2947"></a><span id="l3.2947" class="difflineplus">+// SetupUrl. If we don't have a connection yet, we open the connection. Finally,</span>
<a href="#l3.2948"></a><span id="l3.2948" class="difflineplus">+// we signal the url to run monitor to let the imap main thread loop process the</span>
<a href="#l3.2949"></a><span id="l3.2949" class="difflineplus">+// current url (it is waiting on this monitor). There is a contract that the</span>
<a href="#l3.2950"></a><span id="l3.2950" class="difflineplus">+// imap thread has already been started b4 we attempt to load a url....</span>
<a href="#l3.2951"></a><span id="l3.2951" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::LoadImapUrl(nsIURI *aURL,</span>
<a href="#l3.2952"></a><span id="l3.2952" class="difflineplus">+                                          nsISupports *aConsumer) {</span>
<a href="#l3.2953"></a><span id="l3.2953">   nsresult rv = NS_ERROR_FAILURE;</span>
<a href="#l3.2954"></a><span id="l3.2954" class="difflineminus">-  if (aURL)</span>
<a href="#l3.2955"></a><span id="l3.2955" class="difflineminus">-  {</span>
<a href="#l3.2956"></a><span id="l3.2956" class="difflineplus">+  if (aURL) {</span>
<a href="#l3.2957"></a><span id="l3.2957"> #ifdef DEBUG_bienvenu</span>
<a href="#l3.2958"></a><span id="l3.2958">     printf(&quot;loading url %s\n&quot;, aURL-&gt;GetSpecOrDefault().get());</span>
<a href="#l3.2959"></a><span id="l3.2959"> #endif</span>
<a href="#l3.2960"></a><span id="l3.2960" class="difflineminus">-    if (TryToRunUrlLocally(aURL, aConsumer))</span>
<a href="#l3.2961"></a><span id="l3.2961" class="difflineminus">-      return NS_OK;</span>
<a href="#l3.2962"></a><span id="l3.2962" class="difflineplus">+    if (TryToRunUrlLocally(aURL, aConsumer)) return NS_OK;</span>
<a href="#l3.2963"></a><span id="l3.2963">     m_urlInProgress = true;</span>
<a href="#l3.2964"></a><span id="l3.2964">     m_imapMailFolderSink = nullptr;</span>
<a href="#l3.2965"></a><span id="l3.2965">     rv = SetupWithUrl(aURL, aConsumer);</span>
<a href="#l3.2966"></a><span id="l3.2966">     NS_ASSERTION(NS_SUCCEEDED(rv), &quot;error setting up imap url&quot;);</span>
<a href="#l3.2967"></a><span id="l3.2967"> </span>
<a href="#l3.2968"></a><span id="l3.2968">     m_lastActiveTime = PR_Now();</span>
<a href="#l3.2969"></a><span id="l3.2969">   }</span>
<a href="#l3.2970"></a><span id="l3.2970">   return rv;</span>
<a href="#l3.2971"></a><span id="l3.2971"> }</span>
<a href="#l3.2972"></a><span id="l3.2972"> </span>
<a href="#l3.2973"></a><span id="l3.2973" class="difflineminus">-nsresult nsImapProtocol::LoadImapUrlInternal()</span>
<a href="#l3.2974"></a><span id="l3.2974" class="difflineminus">-{</span>
<a href="#l3.2975"></a><span id="l3.2975" class="difflineplus">+nsresult nsImapProtocol::LoadImapUrlInternal() {</span>
<a href="#l3.2976"></a><span id="l3.2976">   nsresult rv = NS_ERROR_FAILURE;</span>
<a href="#l3.2977"></a><span id="l3.2977"> </span>
<a href="#l3.2978"></a><span id="l3.2978" class="difflineminus">-  if (m_transport &amp;&amp; m_mockChannel)</span>
<a href="#l3.2979"></a><span id="l3.2979" class="difflineminus">-  {</span>
<a href="#l3.2980"></a><span id="l3.2980" class="difflineminus">-    m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_CONNECT, gResponseTimeout + 60);</span>
<a href="#l3.2981"></a><span id="l3.2981" class="difflineplus">+  if (m_transport &amp;&amp; m_mockChannel) {</span>
<a href="#l3.2982"></a><span id="l3.2982" class="difflineplus">+    m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_CONNECT,</span>
<a href="#l3.2983"></a><span id="l3.2983" class="difflineplus">+                            gResponseTimeout + 60);</span>
<a href="#l3.2984"></a><span id="l3.2984">     int32_t readWriteTimeout = gResponseTimeout;</span>
<a href="#l3.2985"></a><span id="l3.2985" class="difflineminus">-    if (m_runningUrl)</span>
<a href="#l3.2986"></a><span id="l3.2986" class="difflineminus">-    {</span>
<a href="#l3.2987"></a><span id="l3.2987" class="difflineplus">+    if (m_runningUrl) {</span>
<a href="#l3.2988"></a><span id="l3.2988">       m_runningUrl-&gt;GetImapAction(&amp;m_imapAction);</span>
<a href="#l3.2989"></a><span id="l3.2989">       // this is a silly hack, but the default of 100 seconds is way too long</span>
<a href="#l3.2990"></a><span id="l3.2990">       // for things like APPEND, which should come back immediately.</span>
<a href="#l3.2991"></a><span id="l3.2991">       if (m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile ||</span>
<a href="#l3.2992"></a><span id="l3.2992" class="difflineminus">-        m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile)</span>
<a href="#l3.2993"></a><span id="l3.2993" class="difflineminus">-      {</span>
<a href="#l3.2994"></a><span id="l3.2994" class="difflineplus">+          m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile) {</span>
<a href="#l3.2995"></a><span id="l3.2995">         readWriteTimeout = 20;</span>
<a href="#l3.2996"></a><span id="l3.2996" class="difflineminus">-      }</span>
<a href="#l3.2997"></a><span id="l3.2997" class="difflineminus">-      else if (m_imapAction == nsIImapUrl::nsImapOnlineMove ||</span>
<a href="#l3.2998"></a><span id="l3.2998" class="difflineminus">-        m_imapAction == nsIImapUrl::nsImapOnlineCopy)</span>
<a href="#l3.2999"></a><span id="l3.2999" class="difflineminus">-      {</span>
<a href="#l3.3000"></a><span id="l3.3000" class="difflineplus">+      } else if (m_imapAction == nsIImapUrl::nsImapOnlineMove ||</span>
<a href="#l3.3001"></a><span id="l3.3001" class="difflineplus">+                 m_imapAction == nsIImapUrl::nsImapOnlineCopy) {</span>
<a href="#l3.3002"></a><span id="l3.3002">         nsCString messageIdString;</span>
<a href="#l3.3003"></a><span id="l3.3003">         m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.3004"></a><span id="l3.3004">         uint32_t copyCount = CountMessagesInIdString(messageIdString.get());</span>
<a href="#l3.3005"></a><span id="l3.3005">         // If we're move/copying a large number of messages,</span>
<a href="#l3.3006"></a><span id="l3.3006">         // which should be rare, increase the timeout based on number</span>
<a href="#l3.3007"></a><span id="l3.3007">         // of messages. 40 messages per second should be sufficiently slow.</span>
<a href="#l3.3008"></a><span id="l3.3008" class="difflineminus">-        if (copyCount &gt; 2400) // 40 * 60, 60 is default read write timeout</span>
<a href="#l3.3009"></a><span id="l3.3009" class="difflineminus">-          readWriteTimeout = std::max(readWriteTimeout, (int32_t)copyCount / 40);</span>
<a href="#l3.3010"></a><span id="l3.3010" class="difflineplus">+        if (copyCount &gt; 2400)  // 40 * 60, 60 is default read write timeout</span>
<a href="#l3.3011"></a><span id="l3.3011" class="difflineplus">+          readWriteTimeout =</span>
<a href="#l3.3012"></a><span id="l3.3012" class="difflineplus">+              std::max(readWriteTimeout, (int32_t)copyCount / 40);</span>
<a href="#l3.3013"></a><span id="l3.3013">       }</span>
<a href="#l3.3014"></a><span id="l3.3014">     }</span>
<a href="#l3.3015"></a><span id="l3.3015" class="difflineminus">-    m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE, readWriteTimeout);</span>
<a href="#l3.3016"></a><span id="l3.3016" class="difflineminus">-    // set the security info for the mock channel to be the security status for our underlying transport.</span>
<a href="#l3.3017"></a><span id="l3.3017" class="difflineplus">+    m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE,</span>
<a href="#l3.3018"></a><span id="l3.3018" class="difflineplus">+                            readWriteTimeout);</span>
<a href="#l3.3019"></a><span id="l3.3019" class="difflineplus">+    // set the security info for the mock channel to be the security status for</span>
<a href="#l3.3020"></a><span id="l3.3020" class="difflineplus">+    // our underlying transport.</span>
<a href="#l3.3021"></a><span id="l3.3021">     nsCOMPtr&lt;nsISupports&gt; securityInfo;</span>
<a href="#l3.3022"></a><span id="l3.3022">     m_transport-&gt;GetSecurityInfo(getter_AddRefs(securityInfo));</span>
<a href="#l3.3023"></a><span id="l3.3023">     m_mockChannel-&gt;SetSecurityInfo(securityInfo);</span>
<a href="#l3.3024"></a><span id="l3.3024"> </span>
<a href="#l3.3025"></a><span id="l3.3025">     SetSecurityCallbacksFromChannel(m_transport, m_mockChannel);</span>
<a href="#l3.3026"></a><span id="l3.3026"> </span>
<a href="#l3.3027"></a><span id="l3.3027">     nsCOMPtr&lt;nsITransportEventSink&gt; sinkMC = do_QueryInterface(m_mockChannel);</span>
<a href="#l3.3028"></a><span id="l3.3028">     if (sinkMC) {</span>
<a href="#l3.3029"></a><span id="l3.3029">       nsCOMPtr&lt;nsIThread&gt; thread = do_GetMainThread();</span>
<a href="#l3.3030"></a><span id="l3.3030">       RefPtr&lt;nsImapTransportEventSink&gt; sink = new nsImapTransportEventSink;</span>
<a href="#l3.3031"></a><span id="l3.3031">       rv = net_NewTransportEventSinkProxy(getter_AddRefs(sink-&gt;m_proxy), sinkMC,</span>
<a href="#l3.3032"></a><span id="l3.3032">                                           thread);</span>
<a href="#l3.3033"></a><span id="l3.3033">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.3034"></a><span id="l3.3034">       m_transport-&gt;SetEventSink(sink, nullptr);</span>
<a href="#l3.3035"></a><span id="l3.3035">     }</span>
<a href="#l3.3036"></a><span id="l3.3036"> </span>
<a href="#l3.3037"></a><span id="l3.3037" class="difflineminus">-    // and if we have a cache entry that we are saving the message to, set the security info on it too.</span>
<a href="#l3.3038"></a><span id="l3.3038" class="difflineminus">-    // since imap only uses the memory cache, passing this on is the right thing to do.</span>
<a href="#l3.3039"></a><span id="l3.3039" class="difflineplus">+    // and if we have a cache entry that we are saving the message to, set the</span>
<a href="#l3.3040"></a><span id="l3.3040" class="difflineplus">+    // security info on it too. since imap only uses the memory cache, passing</span>
<a href="#l3.3041"></a><span id="l3.3041" class="difflineplus">+    // this on is the right thing to do.</span>
<a href="#l3.3042"></a><span id="l3.3042">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.3043"></a><span id="l3.3043" class="difflineminus">-    if (mailnewsUrl)</span>
<a href="#l3.3044"></a><span id="l3.3044" class="difflineminus">-    {</span>
<a href="#l3.3045"></a><span id="l3.3045" class="difflineplus">+    if (mailnewsUrl) {</span>
<a href="#l3.3046"></a><span id="l3.3046">       nsCOMPtr&lt;nsICacheEntry&gt; cacheEntry;</span>
<a href="#l3.3047"></a><span id="l3.3047">       mailnewsUrl-&gt;GetMemCacheEntry(getter_AddRefs(cacheEntry));</span>
<a href="#l3.3048"></a><span id="l3.3048" class="difflineminus">-      if (cacheEntry)</span>
<a href="#l3.3049"></a><span id="l3.3049" class="difflineminus">-        cacheEntry-&gt;SetSecurityInfo(securityInfo);</span>
<a href="#l3.3050"></a><span id="l3.3050" class="difflineminus">-    }</span>
<a href="#l3.3051"></a><span id="l3.3051" class="difflineminus">-  }</span>
<a href="#l3.3052"></a><span id="l3.3052" class="difflineminus">-</span>
<a href="#l3.3053"></a><span id="l3.3053" class="difflineminus">-  rv = SetupSinkProxy(); // generate proxies for all of the event sinks in the url</span>
<a href="#l3.3054"></a><span id="l3.3054" class="difflineminus">-  if (NS_FAILED(rv)) // URL can be invalid.</span>
<a href="#l3.3055"></a><span id="l3.3055" class="difflineplus">+      if (cacheEntry) cacheEntry-&gt;SetSecurityInfo(securityInfo);</span>
<a href="#l3.3056"></a><span id="l3.3056" class="difflineplus">+    }</span>
<a href="#l3.3057"></a><span id="l3.3057" class="difflineplus">+  }</span>
<a href="#l3.3058"></a><span id="l3.3058" class="difflineplus">+</span>
<a href="#l3.3059"></a><span id="l3.3059" class="difflineplus">+  rv = SetupSinkProxy();  // generate proxies for all of the event sinks in the</span>
<a href="#l3.3060"></a><span id="l3.3060" class="difflineplus">+                          // url</span>
<a href="#l3.3061"></a><span id="l3.3061" class="difflineplus">+  if (NS_FAILED(rv))      // URL can be invalid.</span>
<a href="#l3.3062"></a><span id="l3.3062">     return rv;</span>
<a href="#l3.3063"></a><span id="l3.3063"> </span>
<a href="#l3.3064"></a><span id="l3.3064" class="difflineminus">-  if (m_transport &amp;&amp; m_runningUrl)</span>
<a href="#l3.3065"></a><span id="l3.3065" class="difflineminus">-  {</span>
<a href="#l3.3066"></a><span id="l3.3066" class="difflineplus">+  if (m_transport &amp;&amp; m_runningUrl) {</span>
<a href="#l3.3067"></a><span id="l3.3067">     nsImapAction imapAction;</span>
<a href="#l3.3068"></a><span id="l3.3068">     m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.3069"></a><span id="l3.3069">     // if we're shutting down, and not running the kinds of urls we run at</span>
<a href="#l3.3070"></a><span id="l3.3070">     // shutdown, then this should fail because running urls during</span>
<a href="#l3.3071"></a><span id="l3.3071">     // shutdown will very likely fail and potentially hang.</span>
<a href="#l3.3072"></a><span id="l3.3072" class="difflineminus">-    nsCOMPtr&lt;nsIMsgAccountManager&gt; accountMgr = do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l3.3073"></a><span id="l3.3073" class="difflineplus">+    nsCOMPtr&lt;nsIMsgAccountManager&gt; accountMgr =</span>
<a href="#l3.3074"></a><span id="l3.3074" class="difflineplus">+        do_GetService(NS_MSGACCOUNTMANAGER_CONTRACTID, &amp;rv);</span>
<a href="#l3.3075"></a><span id="l3.3075">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.3076"></a><span id="l3.3076">     bool shuttingDown = false;</span>
<a href="#l3.3077"></a><span id="l3.3077" class="difflineminus">-    (void) accountMgr-&gt;GetShutdownInProgress(&amp;shuttingDown);</span>
<a href="#l3.3078"></a><span id="l3.3078" class="difflineplus">+    (void)accountMgr-&gt;GetShutdownInProgress(&amp;shuttingDown);</span>
<a href="#l3.3079"></a><span id="l3.3079">     if (shuttingDown &amp;&amp; imapAction != nsIImapUrl::nsImapExpungeFolder &amp;&amp;</span>
<a href="#l3.3080"></a><span id="l3.3080">         imapAction != nsIImapUrl::nsImapDeleteAllMsgs &amp;&amp;</span>
<a href="#l3.3081"></a><span id="l3.3081">         imapAction != nsIImapUrl::nsImapDeleteFolder)</span>
<a href="#l3.3082"></a><span id="l3.3082">       return NS_ERROR_FAILURE;</span>
<a href="#l3.3083"></a><span id="l3.3083"> </span>
<a href="#l3.3084"></a><span id="l3.3084">     // if we're running a select or delete all, do a noop first.</span>
<a href="#l3.3085"></a><span id="l3.3085">     // this should really be in the connection cache code when we know</span>
<a href="#l3.3086"></a><span id="l3.3086">     // we're pulling out a selected state connection, but maybe we</span>
<a href="#l3.3087"></a><span id="l3.3087">     // can get away with this.</span>
<a href="#l3.3088"></a><span id="l3.3088" class="difflineminus">-    m_needNoop = (imapAction == nsIImapUrl::nsImapSelectFolder || imapAction == nsIImapUrl::nsImapDeleteAllMsgs);</span>
<a href="#l3.3089"></a><span id="l3.3089" class="difflineminus">-</span>
<a href="#l3.3090"></a><span id="l3.3090" class="difflineminus">-    // We now have a url to run so signal the monitor for url ready to be processed...</span>
<a href="#l3.3091"></a><span id="l3.3091" class="difflineplus">+    m_needNoop = (imapAction == nsIImapUrl::nsImapSelectFolder ||</span>
<a href="#l3.3092"></a><span id="l3.3092" class="difflineplus">+                  imapAction == nsIImapUrl::nsImapDeleteAllMsgs);</span>
<a href="#l3.3093"></a><span id="l3.3093" class="difflineplus">+</span>
<a href="#l3.3094"></a><span id="l3.3094" class="difflineplus">+    // We now have a url to run so signal the monitor for url ready to be</span>
<a href="#l3.3095"></a><span id="l3.3095" class="difflineplus">+    // processed...</span>
<a href="#l3.3096"></a><span id="l3.3096">     ReentrantMonitorAutoEnter urlReadyMon(m_urlReadyToRunMonitor);</span>
<a href="#l3.3097"></a><span id="l3.3097">     m_nextUrlReadyToRun = true;</span>
<a href="#l3.3098"></a><span id="l3.3098">     urlReadyMon.Notify();</span>
<a href="#l3.3099"></a><span id="l3.3099"> </span>
<a href="#l3.3100"></a><span id="l3.3100" class="difflineminus">-  } // if we have an imap url and a transport</span>
<a href="#l3.3101"></a><span id="l3.3101" class="difflineplus">+  }  // if we have an imap url and a transport</span>
<a href="#l3.3102"></a><span id="l3.3102">   else {</span>
<a href="#l3.3103"></a><span id="l3.3103">     NS_ASSERTION(false, &quot;missing channel or running url&quot;);</span>
<a href="#l3.3104"></a><span id="l3.3104">   }</span>
<a href="#l3.3105"></a><span id="l3.3105"> </span>
<a href="#l3.3106"></a><span id="l3.3106">   return rv;</span>
<a href="#l3.3107"></a><span id="l3.3107"> }</span>
<a href="#l3.3108"></a><span id="l3.3108"> </span>
<a href="#l3.3109"></a><span id="l3.3109"> NS_IMETHODIMP nsImapProtocol::IsBusy(bool *aIsConnectionBusy,</span>
<a href="#l3.3110"></a><span id="l3.3110" class="difflineminus">-                                     bool *isInboxConnection)</span>
<a href="#l3.3111"></a><span id="l3.3111" class="difflineminus">-{</span>
<a href="#l3.3112"></a><span id="l3.3112" class="difflineminus">-  if (!aIsConnectionBusy || !isInboxConnection)</span>
<a href="#l3.3113"></a><span id="l3.3113" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.3114"></a><span id="l3.3114" class="difflineplus">+                                     bool *isInboxConnection) {</span>
<a href="#l3.3115"></a><span id="l3.3115" class="difflineplus">+  if (!aIsConnectionBusy || !isInboxConnection) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.3116"></a><span id="l3.3116">   nsresult rv = NS_OK;</span>
<a href="#l3.3117"></a><span id="l3.3117">   *aIsConnectionBusy = false;</span>
<a href="#l3.3118"></a><span id="l3.3118">   *isInboxConnection = false;</span>
<a href="#l3.3119"></a><span id="l3.3119" class="difflineminus">-  if (!m_transport)</span>
<a href="#l3.3120"></a><span id="l3.3120" class="difflineminus">-  {</span>
<a href="#l3.3121"></a><span id="l3.3121" class="difflineplus">+  if (!m_transport) {</span>
<a href="#l3.3122"></a><span id="l3.3122">     // this connection might not be fully set up yet.</span>
<a href="#l3.3123"></a><span id="l3.3123">     rv = NS_ERROR_FAILURE;</span>
<a href="#l3.3124"></a><span id="l3.3124" class="difflineminus">-  }</span>
<a href="#l3.3125"></a><span id="l3.3125" class="difflineminus">-  else</span>
<a href="#l3.3126"></a><span id="l3.3126" class="difflineminus">-  {</span>
<a href="#l3.3127"></a><span id="l3.3127" class="difflineminus">-    if (m_urlInProgress) // do we have a url? That means we're working on it...</span>
<a href="#l3.3128"></a><span id="l3.3128" class="difflineplus">+  } else {</span>
<a href="#l3.3129"></a><span id="l3.3129" class="difflineplus">+    if (m_urlInProgress)  // do we have a url? That means we're working on it...</span>
<a href="#l3.3130"></a><span id="l3.3130">       *aIsConnectionBusy = true;</span>
<a href="#l3.3131"></a><span id="l3.3131"> </span>
<a href="#l3.3132"></a><span id="l3.3132">     if (GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.3133"></a><span id="l3.3133" class="difflineminus">-        nsImapServerResponseParser::kFolderSelected &amp;&amp; GetServerStateParser().GetSelectedMailboxName() &amp;&amp;</span>
<a href="#l3.3134"></a><span id="l3.3134" class="difflineplus">+            nsImapServerResponseParser::kFolderSelected &amp;&amp;</span>
<a href="#l3.3135"></a><span id="l3.3135" class="difflineplus">+        GetServerStateParser().GetSelectedMailboxName() &amp;&amp;</span>
<a href="#l3.3136"></a><span id="l3.3136">         PL_strcasecmp(GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.3137"></a><span id="l3.3137">                       &quot;Inbox&quot;) == 0)</span>
<a href="#l3.3138"></a><span id="l3.3138">       *isInboxConnection = true;</span>
<a href="#l3.3139"></a><span id="l3.3139" class="difflineminus">-</span>
<a href="#l3.3140"></a><span id="l3.3140">   }</span>
<a href="#l3.3141"></a><span id="l3.3141">   return rv;</span>
<a href="#l3.3142"></a><span id="l3.3142"> }</span>
<a href="#l3.3143"></a><span id="l3.3143"> </span>
<a href="#l3.3144"></a><span id="l3.3144" class="difflineminus">-#define IS_SUBSCRIPTION_RELATED_ACTION(action) (action == nsIImapUrl::nsImapSubscribe\</span>
<a href="#l3.3145"></a><span id="l3.3145" class="difflineminus">-|| action == nsIImapUrl::nsImapUnsubscribe || action == nsIImapUrl::nsImapDiscoverAllBoxesUrl || action == nsIImapUrl::nsImapListFolder)</span>
<a href="#l3.3146"></a><span id="l3.3146" class="difflineminus">-</span>
<a href="#l3.3147"></a><span id="l3.3147" class="difflineplus">+#define IS_SUBSCRIPTION_RELATED_ACTION(action)        \</span>
<a href="#l3.3148"></a><span id="l3.3148" class="difflineplus">+  (action == nsIImapUrl::nsImapSubscribe ||           \</span>
<a href="#l3.3149"></a><span id="l3.3149" class="difflineplus">+   action == nsIImapUrl::nsImapUnsubscribe ||         \</span>
<a href="#l3.3150"></a><span id="l3.3150" class="difflineplus">+   action == nsIImapUrl::nsImapDiscoverAllBoxesUrl || \</span>
<a href="#l3.3151"></a><span id="l3.3151" class="difflineplus">+   action == nsIImapUrl::nsImapListFolder)</span>
<a href="#l3.3152"></a><span id="l3.3152"> </span>
<a href="#l3.3153"></a><span id="l3.3153"> // canRunUrl means the connection is not busy, and is in the selected state</span>
<a href="#l3.3154"></a><span id="l3.3154"> // for the desired folder (or authenticated).</span>
<a href="#l3.3155"></a><span id="l3.3155"> // has to wait means it's in the right selected state, but busy.</span>
<a href="#l3.3156"></a><span id="l3.3156" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::CanHandleUrl(nsIImapUrl * aImapUrl,</span>
<a href="#l3.3157"></a><span id="l3.3157" class="difflineminus">-                                           bool * aCanRunUrl,</span>
<a href="#l3.3158"></a><span id="l3.3158" class="difflineminus">-                                           bool * hasToWait)</span>
<a href="#l3.3159"></a><span id="l3.3159" class="difflineminus">-{</span>
<a href="#l3.3160"></a><span id="l3.3160" class="difflineminus">-  if (!aCanRunUrl || !hasToWait || !aImapUrl)</span>
<a href="#l3.3161"></a><span id="l3.3161" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.3162"></a><span id="l3.3162" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::CanHandleUrl(nsIImapUrl *aImapUrl,</span>
<a href="#l3.3163"></a><span id="l3.3163" class="difflineplus">+                                           bool *aCanRunUrl, bool *hasToWait) {</span>
<a href="#l3.3164"></a><span id="l3.3164" class="difflineplus">+  if (!aCanRunUrl || !hasToWait || !aImapUrl) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.3165"></a><span id="l3.3165">   nsresult rv = NS_OK;</span>
<a href="#l3.3166"></a><span id="l3.3166">   MutexAutoLock mon(mLock);</span>
<a href="#l3.3167"></a><span id="l3.3167"> </span>
<a href="#l3.3168"></a><span id="l3.3168" class="difflineminus">-  *aCanRunUrl = false; // assume guilty until proven otherwise...</span>
<a href="#l3.3169"></a><span id="l3.3169" class="difflineplus">+  *aCanRunUrl = false;  // assume guilty until proven otherwise...</span>
<a href="#l3.3170"></a><span id="l3.3170">   *hasToWait = false;</span>
<a href="#l3.3171"></a><span id="l3.3171"> </span>
<a href="#l3.3172"></a><span id="l3.3172" class="difflineminus">-  if (DeathSignalReceived())</span>
<a href="#l3.3173"></a><span id="l3.3173" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l3.3174"></a><span id="l3.3174" class="difflineplus">+  if (DeathSignalReceived()) return NS_ERROR_FAILURE;</span>
<a href="#l3.3175"></a><span id="l3.3175"> </span>
<a href="#l3.3176"></a><span id="l3.3176">   bool isBusy = false;</span>
<a href="#l3.3177"></a><span id="l3.3177">   bool isInboxConnection = false;</span>
<a href="#l3.3178"></a><span id="l3.3178"> </span>
<a href="#l3.3179"></a><span id="l3.3179" class="difflineminus">-  if (!m_transport)</span>
<a href="#l3.3180"></a><span id="l3.3180" class="difflineminus">-  {</span>
<a href="#l3.3181"></a><span id="l3.3181" class="difflineplus">+  if (!m_transport) {</span>
<a href="#l3.3182"></a><span id="l3.3182">     // this connection might not be fully set up yet.</span>
<a href="#l3.3183"></a><span id="l3.3183">     return NS_ERROR_FAILURE;</span>
<a href="#l3.3184"></a><span id="l3.3184">   }</span>
<a href="#l3.3185"></a><span id="l3.3185">   IsBusy(&amp;isBusy, &amp;isInboxConnection);</span>
<a href="#l3.3186"></a><span id="l3.3186">   bool inSelectedState = GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.3187"></a><span id="l3.3187" class="difflineminus">-    nsImapServerResponseParser::kFolderSelected;</span>
<a href="#l3.3188"></a><span id="l3.3188" class="difflineplus">+                         nsImapServerResponseParser::kFolderSelected;</span>
<a href="#l3.3189"></a><span id="l3.3189"> </span>
<a href="#l3.3190"></a><span id="l3.3190">   nsAutoCString curSelectedUrlFolderName;</span>
<a href="#l3.3191"></a><span id="l3.3191">   nsAutoCString pendingUrlFolderName;</span>
<a href="#l3.3192"></a><span id="l3.3192">   if (inSelectedState)</span>
<a href="#l3.3193"></a><span id="l3.3193">     curSelectedUrlFolderName = GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.3194"></a><span id="l3.3194"> </span>
<a href="#l3.3195"></a><span id="l3.3195" class="difflineminus">-  if (isBusy)</span>
<a href="#l3.3196"></a><span id="l3.3196" class="difflineminus">-  {</span>
<a href="#l3.3197"></a><span id="l3.3197" class="difflineplus">+  if (isBusy) {</span>
<a href="#l3.3198"></a><span id="l3.3198">     nsImapState curUrlImapState;</span>
<a href="#l3.3199"></a><span id="l3.3199" class="difflineminus">-    NS_ASSERTION(m_runningUrl,&quot;isBusy, but no running url.&quot;);</span>
<a href="#l3.3200"></a><span id="l3.3200" class="difflineminus">-    if (m_runningUrl)</span>
<a href="#l3.3201"></a><span id="l3.3201" class="difflineminus">-    {</span>
<a href="#l3.3202"></a><span id="l3.3202" class="difflineplus">+    NS_ASSERTION(m_runningUrl, &quot;isBusy, but no running url.&quot;);</span>
<a href="#l3.3203"></a><span id="l3.3203" class="difflineplus">+    if (m_runningUrl) {</span>
<a href="#l3.3204"></a><span id="l3.3204">       m_runningUrl-&gt;GetRequiredImapState(&amp;curUrlImapState);</span>
<a href="#l3.3205"></a><span id="l3.3205" class="difflineminus">-      if (curUrlImapState == nsIImapUrl::nsImapSelectedState)</span>
<a href="#l3.3206"></a><span id="l3.3206" class="difflineminus">-      {</span>
<a href="#l3.3207"></a><span id="l3.3207" class="difflineplus">+      if (curUrlImapState == nsIImapUrl::nsImapSelectedState) {</span>
<a href="#l3.3208"></a><span id="l3.3208">         char *folderName = GetFolderPathString();</span>
<a href="#l3.3209"></a><span id="l3.3209">         if (!curSelectedUrlFolderName.Equals(folderName))</span>
<a href="#l3.3210"></a><span id="l3.3210">           pendingUrlFolderName.Assign(folderName);</span>
<a href="#l3.3211"></a><span id="l3.3211">         inSelectedState = true;</span>
<a href="#l3.3212"></a><span id="l3.3212">         PR_Free(folderName);</span>
<a href="#l3.3213"></a><span id="l3.3213">       }</span>
<a href="#l3.3214"></a><span id="l3.3214">     }</span>
<a href="#l3.3215"></a><span id="l3.3215">   }</span>
<a href="#l3.3216"></a><span id="l3.3216" class="difflineat">@@ -2484,544 +2290,531 @@ NS_IMETHODIMP nsImapProtocol::CanHandleU</span>
<a href="#l3.3217"></a><span id="l3.3217">   // these types of urls requires a selected state connection on</span>
<a href="#l3.3218"></a><span id="l3.3218">   // the folder in question. This isn't technically true,</span>
<a href="#l3.3219"></a><span id="l3.3219">   // but we would much rather use that connection for several reasons,</span>
<a href="#l3.3220"></a><span id="l3.3220">   // one is that some UW servers require us to use that connection</span>
<a href="#l3.3221"></a><span id="l3.3221">   // the other is that we don't want to leave a connection dangling in</span>
<a href="#l3.3222"></a><span id="l3.3222">   // the selected state for the deleted folder.</span>
<a href="#l3.3223"></a><span id="l3.3223">   // If we don't find a connection in that selected state,</span>
<a href="#l3.3224"></a><span id="l3.3224">   // we'll fall back to the first free connection.</span>
<a href="#l3.3225"></a><span id="l3.3225" class="difflineminus">-  bool isSelectedStateUrl = imapState == nsIImapUrl::nsImapSelectedState</span>
<a href="#l3.3226"></a><span id="l3.3226" class="difflineminus">-    || actionForProposedUrl == nsIImapUrl::nsImapDeleteFolder || actionForProposedUrl == nsIImapUrl::nsImapRenameFolder</span>
<a href="#l3.3227"></a><span id="l3.3227" class="difflineminus">-    || actionForProposedUrl == nsIImapUrl::nsImapMoveFolderHierarchy</span>
<a href="#l3.3228"></a><span id="l3.3228" class="difflineminus">-    || actionForProposedUrl == nsIImapUrl::nsImapAppendDraftFromFile</span>
<a href="#l3.3229"></a><span id="l3.3229" class="difflineminus">-    || actionForProposedUrl == nsIImapUrl::nsImapAppendMsgFromFile</span>
<a href="#l3.3230"></a><span id="l3.3230" class="difflineminus">-    || actionForProposedUrl == nsIImapUrl::nsImapFolderStatus;</span>
<a href="#l3.3231"></a><span id="l3.3231" class="difflineplus">+  bool isSelectedStateUrl =</span>
<a href="#l3.3232"></a><span id="l3.3232" class="difflineplus">+      imapState == nsIImapUrl::nsImapSelectedState ||</span>
<a href="#l3.3233"></a><span id="l3.3233" class="difflineplus">+      actionForProposedUrl == nsIImapUrl::nsImapDeleteFolder ||</span>
<a href="#l3.3234"></a><span id="l3.3234" class="difflineplus">+      actionForProposedUrl == nsIImapUrl::nsImapRenameFolder ||</span>
<a href="#l3.3235"></a><span id="l3.3235" class="difflineplus">+      actionForProposedUrl == nsIImapUrl::nsImapMoveFolderHierarchy ||</span>
<a href="#l3.3236"></a><span id="l3.3236" class="difflineplus">+      actionForProposedUrl == nsIImapUrl::nsImapAppendDraftFromFile ||</span>
<a href="#l3.3237"></a><span id="l3.3237" class="difflineplus">+      actionForProposedUrl == nsIImapUrl::nsImapAppendMsgFromFile ||</span>
<a href="#l3.3238"></a><span id="l3.3238" class="difflineplus">+      actionForProposedUrl == nsIImapUrl::nsImapFolderStatus;</span>
<a href="#l3.3239"></a><span id="l3.3239"> </span>
<a href="#l3.3240"></a><span id="l3.3240">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; msgUrl = do_QueryInterface(aImapUrl);</span>
<a href="#l3.3241"></a><span id="l3.3241">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l3.3242"></a><span id="l3.3242">   rv = msgUrl-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l3.3243"></a><span id="l3.3243" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.3244"></a><span id="l3.3244" class="difflineminus">-  {</span>
<a href="#l3.3245"></a><span id="l3.3245" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.3246"></a><span id="l3.3246">     // compare host/user between url and connection.</span>
<a href="#l3.3247"></a><span id="l3.3247">     nsCString urlHostName;</span>
<a href="#l3.3248"></a><span id="l3.3248">     nsCString urlUserName;</span>
<a href="#l3.3249"></a><span id="l3.3249">     rv = server-&gt;GetHostName(urlHostName);</span>
<a href="#l3.3250"></a><span id="l3.3250">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.3251"></a><span id="l3.3251">     rv = server-&gt;GetUsername(urlUserName);</span>
<a href="#l3.3252"></a><span id="l3.3252">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.3253"></a><span id="l3.3253"> </span>
<a href="#l3.3254"></a><span id="l3.3254">     if ((GetImapHostName().IsEmpty() ||</span>
<a href="#l3.3255"></a><span id="l3.3255" class="difflineminus">-      urlHostName.Equals(GetImapHostName(), nsCaseInsensitiveCStringComparator())) &amp;&amp;</span>
<a href="#l3.3256"></a><span id="l3.3256" class="difflineminus">-      (GetImapUserName().IsEmpty() ||</span>
<a href="#l3.3257"></a><span id="l3.3257" class="difflineminus">-      urlUserName.Equals(GetImapUserName(), nsCaseInsensitiveCStringComparator())))</span>
<a href="#l3.3258"></a><span id="l3.3258" class="difflineminus">-    {</span>
<a href="#l3.3259"></a><span id="l3.3259" class="difflineminus">-      if (isSelectedStateUrl)</span>
<a href="#l3.3260"></a><span id="l3.3260" class="difflineminus">-      {</span>
<a href="#l3.3261"></a><span id="l3.3261" class="difflineminus">-        if (inSelectedState)</span>
<a href="#l3.3262"></a><span id="l3.3262" class="difflineminus">-        {</span>
<a href="#l3.3263"></a><span id="l3.3263" class="difflineplus">+         urlHostName.Equals(GetImapHostName(),</span>
<a href="#l3.3264"></a><span id="l3.3264" class="difflineplus">+                            nsCaseInsensitiveCStringComparator())) &amp;&amp;</span>
<a href="#l3.3265"></a><span id="l3.3265" class="difflineplus">+        (GetImapUserName().IsEmpty() ||</span>
<a href="#l3.3266"></a><span id="l3.3266" class="difflineplus">+         urlUserName.Equals(GetImapUserName(),</span>
<a href="#l3.3267"></a><span id="l3.3267" class="difflineplus">+                            nsCaseInsensitiveCStringComparator()))) {</span>
<a href="#l3.3268"></a><span id="l3.3268" class="difflineplus">+      if (isSelectedStateUrl) {</span>
<a href="#l3.3269"></a><span id="l3.3269" class="difflineplus">+        if (inSelectedState) {</span>
<a href="#l3.3270"></a><span id="l3.3270">           // *** jt - in selected state can only run url with</span>
<a href="#l3.3271"></a><span id="l3.3271">           // matching foldername</span>
<a href="#l3.3272"></a><span id="l3.3272">           char *folderNameForProposedUrl = nullptr;</span>
<a href="#l3.3273"></a><span id="l3.3273">           rv = aImapUrl-&gt;CreateServerSourceFolderPathString(</span>
<a href="#l3.3274"></a><span id="l3.3274" class="difflineminus">-            &amp;folderNameForProposedUrl);</span>
<a href="#l3.3275"></a><span id="l3.3275" class="difflineminus">-          if (NS_SUCCEEDED(rv) &amp;&amp; folderNameForProposedUrl)</span>
<a href="#l3.3276"></a><span id="l3.3276" class="difflineminus">-          {</span>
<a href="#l3.3277"></a><span id="l3.3277" class="difflineplus">+              &amp;folderNameForProposedUrl);</span>
<a href="#l3.3278"></a><span id="l3.3278" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; folderNameForProposedUrl) {</span>
<a href="#l3.3279"></a><span id="l3.3279">             bool isInbox =</span>
<a href="#l3.3280"></a><span id="l3.3280" class="difflineminus">-              PL_strcasecmp(&quot;Inbox&quot;, folderNameForProposedUrl) == 0;</span>
<a href="#l3.3281"></a><span id="l3.3281" class="difflineminus">-            if (!curSelectedUrlFolderName.IsEmpty() || !pendingUrlFolderName.IsEmpty())</span>
<a href="#l3.3282"></a><span id="l3.3282" class="difflineminus">-            {</span>
<a href="#l3.3283"></a><span id="l3.3283" class="difflineminus">-              bool matched = isInbox ?</span>
<a href="#l3.3284"></a><span id="l3.3284" class="difflineminus">-                PL_strcasecmp(curSelectedUrlFolderName.get(),</span>
<a href="#l3.3285"></a><span id="l3.3285" class="difflineminus">-                folderNameForProposedUrl) == 0 :</span>
<a href="#l3.3286"></a><span id="l3.3286" class="difflineminus">-              PL_strcmp(curSelectedUrlFolderName.get(),</span>
<a href="#l3.3287"></a><span id="l3.3287" class="difflineminus">-                folderNameForProposedUrl) == 0;</span>
<a href="#l3.3288"></a><span id="l3.3288" class="difflineminus">-              if (!matched &amp;&amp; !pendingUrlFolderName.IsEmpty())</span>
<a href="#l3.3289"></a><span id="l3.3289" class="difflineminus">-              {</span>
<a href="#l3.3290"></a><span id="l3.3290" class="difflineminus">-                matched = isInbox ?</span>
<a href="#l3.3291"></a><span id="l3.3291" class="difflineminus">-                  PL_strcasecmp(pendingUrlFolderName.get(),</span>
<a href="#l3.3292"></a><span id="l3.3292" class="difflineminus">-                  folderNameForProposedUrl) == 0 :</span>
<a href="#l3.3293"></a><span id="l3.3293" class="difflineminus">-                PL_strcmp(pendingUrlFolderName.get(),</span>
<a href="#l3.3294"></a><span id="l3.3294" class="difflineminus">-                  folderNameForProposedUrl) == 0;</span>
<a href="#l3.3295"></a><span id="l3.3295" class="difflineplus">+                PL_strcasecmp(&quot;Inbox&quot;, folderNameForProposedUrl) == 0;</span>
<a href="#l3.3296"></a><span id="l3.3296" class="difflineplus">+            if (!curSelectedUrlFolderName.IsEmpty() ||</span>
<a href="#l3.3297"></a><span id="l3.3297" class="difflineplus">+                !pendingUrlFolderName.IsEmpty()) {</span>
<a href="#l3.3298"></a><span id="l3.3298" class="difflineplus">+              bool matched = isInbox</span>
<a href="#l3.3299"></a><span id="l3.3299" class="difflineplus">+                                 ? PL_strcasecmp(curSelectedUrlFolderName.get(),</span>
<a href="#l3.3300"></a><span id="l3.3300" class="difflineplus">+                                                 folderNameForProposedUrl) == 0</span>
<a href="#l3.3301"></a><span id="l3.3301" class="difflineplus">+                                 : PL_strcmp(curSelectedUrlFolderName.get(),</span>
<a href="#l3.3302"></a><span id="l3.3302" class="difflineplus">+                                             folderNameForProposedUrl) == 0;</span>
<a href="#l3.3303"></a><span id="l3.3303" class="difflineplus">+              if (!matched &amp;&amp; !pendingUrlFolderName.IsEmpty()) {</span>
<a href="#l3.3304"></a><span id="l3.3304" class="difflineplus">+                matched = isInbox ? PL_strcasecmp(pendingUrlFolderName.get(),</span>
<a href="#l3.3305"></a><span id="l3.3305" class="difflineplus">+                                                  folderNameForProposedUrl) == 0</span>
<a href="#l3.3306"></a><span id="l3.3306" class="difflineplus">+                                  : PL_strcmp(pendingUrlFolderName.get(),</span>
<a href="#l3.3307"></a><span id="l3.3307" class="difflineplus">+                                              folderNameForProposedUrl) == 0;</span>
<a href="#l3.3308"></a><span id="l3.3308">               }</span>
<a href="#l3.3309"></a><span id="l3.3309" class="difflineminus">-              if (matched)</span>
<a href="#l3.3310"></a><span id="l3.3310" class="difflineminus">-              {</span>
<a href="#l3.3311"></a><span id="l3.3311" class="difflineplus">+              if (matched) {</span>
<a href="#l3.3312"></a><span id="l3.3312">                 if (isBusy)</span>
<a href="#l3.3313"></a><span id="l3.3313">                   *hasToWait = true;</span>
<a href="#l3.3314"></a><span id="l3.3314">                 else</span>
<a href="#l3.3315"></a><span id="l3.3315">                   *aCanRunUrl = true;</span>
<a href="#l3.3316"></a><span id="l3.3316">               }</span>
<a href="#l3.3317"></a><span id="l3.3317">             }</span>
<a href="#l3.3318"></a><span id="l3.3318">           }</span>
<a href="#l3.3319"></a><span id="l3.3319">           MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.3320"></a><span id="l3.3320" class="difflineminus">-                 (&quot;proposed url = %s folder for connection %s has To Wait = %s can run = %s&quot;,</span>
<a href="#l3.3321"></a><span id="l3.3321" class="difflineminus">-                  folderNameForProposedUrl, curSelectedUrlFolderName.get(),</span>
<a href="#l3.3322"></a><span id="l3.3322" class="difflineminus">-                  (*hasToWait) ? &quot;true&quot; : &quot;false&quot;, (*aCanRunUrl) ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.3323"></a><span id="l3.3323" class="difflineplus">+                  (&quot;proposed url = %s folder for connection %s has To Wait = &quot;</span>
<a href="#l3.3324"></a><span id="l3.3324" class="difflineplus">+                   &quot;%s can run = %s&quot;,</span>
<a href="#l3.3325"></a><span id="l3.3325" class="difflineplus">+                   folderNameForProposedUrl, curSelectedUrlFolderName.get(),</span>
<a href="#l3.3326"></a><span id="l3.3326" class="difflineplus">+                   (*hasToWait) ? &quot;true&quot; : &quot;false&quot;,</span>
<a href="#l3.3327"></a><span id="l3.3327" class="difflineplus">+                   (*aCanRunUrl) ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.3328"></a><span id="l3.3328">           PR_FREEIF(folderNameForProposedUrl);</span>
<a href="#l3.3329"></a><span id="l3.3329">         }</span>
<a href="#l3.3330"></a><span id="l3.3330" class="difflineminus">-      }</span>
<a href="#l3.3331"></a><span id="l3.3331" class="difflineminus">-      else // *** jt - an authenticated state url can be run in either</span>
<a href="#l3.3332"></a><span id="l3.3332" class="difflineminus">-        // authenticated or selected state</span>
<a href="#l3.3333"></a><span id="l3.3333" class="difflineplus">+      } else  // *** jt - an authenticated state url can be run in either</span>
<a href="#l3.3334"></a><span id="l3.3334" class="difflineplus">+              // authenticated or selected state</span>
<a href="#l3.3335"></a><span id="l3.3335">       {</span>
<a href="#l3.3336"></a><span id="l3.3336">         nsImapAction actionForRunningUrl;</span>
<a href="#l3.3337"></a><span id="l3.3337"> </span>
<a href="#l3.3338"></a><span id="l3.3338">         // If proposed url is subscription related, and we are currently running</span>
<a href="#l3.3339"></a><span id="l3.3339" class="difflineminus">-        // a subscription url, then we want to queue the proposed url after the current url.</span>
<a href="#l3.3340"></a><span id="l3.3340" class="difflineminus">-        // Otherwise, we can run this url if we're not busy.</span>
<a href="#l3.3341"></a><span id="l3.3341" class="difflineminus">-        // If we never find a running subscription-related url, the caller will</span>
<a href="#l3.3342"></a><span id="l3.3342" class="difflineminus">-        // just use whatever free connection it can find, which is what we want.</span>
<a href="#l3.3343"></a><span id="l3.3343" class="difflineminus">-        if (IS_SUBSCRIPTION_RELATED_ACTION(actionForProposedUrl))</span>
<a href="#l3.3344"></a><span id="l3.3344" class="difflineminus">-        {</span>
<a href="#l3.3345"></a><span id="l3.3345" class="difflineminus">-          if (isBusy &amp;&amp; m_runningUrl)</span>
<a href="#l3.3346"></a><span id="l3.3346" class="difflineminus">-          {</span>
<a href="#l3.3347"></a><span id="l3.3347" class="difflineplus">+        // a subscription url, then we want to queue the proposed url after the</span>
<a href="#l3.3348"></a><span id="l3.3348" class="difflineplus">+        // current url. Otherwise, we can run this url if we're not busy. If we</span>
<a href="#l3.3349"></a><span id="l3.3349" class="difflineplus">+        // never find a running subscription-related url, the caller will just</span>
<a href="#l3.3350"></a><span id="l3.3350" class="difflineplus">+        // use whatever free connection it can find, which is what we want.</span>
<a href="#l3.3351"></a><span id="l3.3351" class="difflineplus">+        if (IS_SUBSCRIPTION_RELATED_ACTION(actionForProposedUrl)) {</span>
<a href="#l3.3352"></a><span id="l3.3352" class="difflineplus">+          if (isBusy &amp;&amp; m_runningUrl) {</span>
<a href="#l3.3353"></a><span id="l3.3353">             m_runningUrl-&gt;GetImapAction(&amp;actionForRunningUrl);</span>
<a href="#l3.3354"></a><span id="l3.3354" class="difflineminus">-            if (IS_SUBSCRIPTION_RELATED_ACTION(actionForRunningUrl))</span>
<a href="#l3.3355"></a><span id="l3.3355" class="difflineminus">-            {</span>
<a href="#l3.3356"></a><span id="l3.3356" class="difflineplus">+            if (IS_SUBSCRIPTION_RELATED_ACTION(actionForRunningUrl)) {</span>
<a href="#l3.3357"></a><span id="l3.3357">               *aCanRunUrl = false;</span>
<a href="#l3.3358"></a><span id="l3.3358">               *hasToWait = true;</span>
<a href="#l3.3359"></a><span id="l3.3359">             }</span>
<a href="#l3.3360"></a><span id="l3.3360">           }</span>
<a href="#l3.3361"></a><span id="l3.3361" class="difflineminus">-        }</span>
<a href="#l3.3362"></a><span id="l3.3362" class="difflineminus">-        else</span>
<a href="#l3.3363"></a><span id="l3.3363" class="difflineminus">-        {</span>
<a href="#l3.3364"></a><span id="l3.3364" class="difflineminus">-          if (!isBusy)</span>
<a href="#l3.3365"></a><span id="l3.3365" class="difflineminus">-            *aCanRunUrl = true;</span>
<a href="#l3.3366"></a><span id="l3.3366" class="difflineplus">+        } else {</span>
<a href="#l3.3367"></a><span id="l3.3367" class="difflineplus">+          if (!isBusy) *aCanRunUrl = true;</span>
<a href="#l3.3368"></a><span id="l3.3368">         }</span>
<a href="#l3.3369"></a><span id="l3.3369">       }</span>
<a href="#l3.3370"></a><span id="l3.3370">     }</span>
<a href="#l3.3371"></a><span id="l3.3371">   }</span>
<a href="#l3.3372"></a><span id="l3.3372">   return rv;</span>
<a href="#l3.3373"></a><span id="l3.3373"> }</span>
<a href="#l3.3374"></a><span id="l3.3374"> </span>
<a href="#l3.3375"></a><span id="l3.3375" class="difflineminus">-</span>
<a href="#l3.3376"></a><span id="l3.3376"> // Command tag handling stuff</span>
<a href="#l3.3377"></a><span id="l3.3377" class="difflineminus">-void nsImapProtocol::IncrementCommandTagNumber()</span>
<a href="#l3.3378"></a><span id="l3.3378" class="difflineminus">-{</span>
<a href="#l3.3379"></a><span id="l3.3379" class="difflineplus">+void nsImapProtocol::IncrementCommandTagNumber() {</span>
<a href="#l3.3380"></a><span id="l3.3380">   sprintf(m_currentServerCommandTag, &quot;%u&quot;, ++m_currentServerCommandTagNumber);</span>
<a href="#l3.3381"></a><span id="l3.3381"> }</span>
<a href="#l3.3382"></a><span id="l3.3382"> </span>
<a href="#l3.3383"></a><span id="l3.3383" class="difflineminus">-const char *nsImapProtocol::GetServerCommandTag()</span>
<a href="#l3.3384"></a><span id="l3.3384" class="difflineminus">-{</span>
<a href="#l3.3385"></a><span id="l3.3385" class="difflineminus">-    return m_currentServerCommandTag;</span>
<a href="#l3.3386"></a><span id="l3.3386" class="difflineminus">-}</span>
<a href="#l3.3387"></a><span id="l3.3387" class="difflineminus">-</span>
<a href="#l3.3388"></a><span id="l3.3388" class="difflineminus">-void nsImapProtocol::ProcessSelectedStateURL()</span>
<a href="#l3.3389"></a><span id="l3.3389" class="difflineminus">-{</span>
<a href="#l3.3390"></a><span id="l3.3390" class="difflineplus">+const char *nsImapProtocol::GetServerCommandTag() {</span>
<a href="#l3.3391"></a><span id="l3.3391" class="difflineplus">+  return m_currentServerCommandTag;</span>
<a href="#l3.3392"></a><span id="l3.3392" class="difflineplus">+}</span>
<a href="#l3.3393"></a><span id="l3.3393" class="difflineplus">+</span>
<a href="#l3.3394"></a><span id="l3.3394" class="difflineplus">+void nsImapProtocol::ProcessSelectedStateURL() {</span>
<a href="#l3.3395"></a><span id="l3.3395">   nsCString mailboxName;</span>
<a href="#l3.3396"></a><span id="l3.3396">   bool bMessageIdsAreUids = true;</span>
<a href="#l3.3397"></a><span id="l3.3397">   bool moreHeadersToDownload;</span>
<a href="#l3.3398"></a><span id="l3.3398" class="difflineminus">-  imapMessageFlagsType  msgFlags = 0;</span>
<a href="#l3.3399"></a><span id="l3.3399" class="difflineminus">-  nsCString       urlHost;</span>
<a href="#l3.3400"></a><span id="l3.3400" class="difflineplus">+  imapMessageFlagsType msgFlags = 0;</span>
<a href="#l3.3401"></a><span id="l3.3401" class="difflineplus">+  nsCString urlHost;</span>
<a href="#l3.3402"></a><span id="l3.3402"> </span>
<a href="#l3.3403"></a><span id="l3.3403">   // this can't fail, can it?</span>
<a href="#l3.3404"></a><span id="l3.3404">   nsresult res;</span>
<a href="#l3.3405"></a><span id="l3.3405">   res = m_runningUrl-&gt;GetImapAction(&amp;m_imapAction);</span>
<a href="#l3.3406"></a><span id="l3.3406">   m_runningUrl-&gt;MessageIdsAreUids(&amp;bMessageIdsAreUids);</span>
<a href="#l3.3407"></a><span id="l3.3407">   m_runningUrl-&gt;GetMsgFlags(&amp;msgFlags);</span>
<a href="#l3.3408"></a><span id="l3.3408">   m_runningUrl-&gt;GetMoreHeadersToDownload(&amp;moreHeadersToDownload);</span>
<a href="#l3.3409"></a><span id="l3.3409"> </span>
<a href="#l3.3410"></a><span id="l3.3410">   res = CreateServerSourceFolderPathString(getter_Copies(mailboxName));</span>
<a href="#l3.3411"></a><span id="l3.3411">   if (NS_FAILED(res))</span>
<a href="#l3.3412"></a><span id="l3.3412" class="difflineminus">-    Log(&quot;ProcessSelectedStateURL&quot;, nullptr, &quot;error getting source folder path string&quot;);</span>
<a href="#l3.3413"></a><span id="l3.3413" class="difflineminus">-</span>
<a href="#l3.3414"></a><span id="l3.3414" class="difflineminus">-  if (NS_SUCCEEDED(res) &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.3415"></a><span id="l3.3415" class="difflineminus">-  {</span>
<a href="#l3.3416"></a><span id="l3.3416" class="difflineplus">+    Log(&quot;ProcessSelectedStateURL&quot;, nullptr,</span>
<a href="#l3.3417"></a><span id="l3.3417" class="difflineplus">+        &quot;error getting source folder path string&quot;);</span>
<a href="#l3.3418"></a><span id="l3.3418" class="difflineplus">+</span>
<a href="#l3.3419"></a><span id="l3.3419" class="difflineplus">+  if (NS_SUCCEEDED(res) &amp;&amp; !DeathSignalReceived()) {</span>
<a href="#l3.3420"></a><span id="l3.3420">     bool selectIssued = false;</span>
<a href="#l3.3421"></a><span id="l3.3421" class="difflineminus">-    if (GetServerStateParser().GetIMAPstate() == nsImapServerResponseParser::kFolderSelected)</span>
<a href="#l3.3422"></a><span id="l3.3422" class="difflineminus">-    {</span>
<a href="#l3.3423"></a><span id="l3.3423" class="difflineplus">+    if (GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.3424"></a><span id="l3.3424" class="difflineplus">+        nsImapServerResponseParser::kFolderSelected) {</span>
<a href="#l3.3425"></a><span id="l3.3425">       if (GetServerStateParser().GetSelectedMailboxName() &amp;&amp;</span>
<a href="#l3.3426"></a><span id="l3.3426" class="difflineminus">-        PL_strcmp(GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.3427"></a><span id="l3.3427" class="difflineminus">-        mailboxName.get()))</span>
<a href="#l3.3428"></a><span id="l3.3428" class="difflineminus">-      {       // we are selected in another folder</span>
<a href="#l3.3429"></a><span id="l3.3429" class="difflineminus">-        if (m_closeNeededBeforeSelect)</span>
<a href="#l3.3430"></a><span id="l3.3430" class="difflineminus">-          Close();</span>
<a href="#l3.3431"></a><span id="l3.3431" class="difflineminus">-        if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.3432"></a><span id="l3.3432" class="difflineminus">-        {</span>
<a href="#l3.3433"></a><span id="l3.3433" class="difflineplus">+          PL_strcmp(GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.3434"></a><span id="l3.3434" class="difflineplus">+                    mailboxName.get())) {  // we are selected in another folder</span>
<a href="#l3.3435"></a><span id="l3.3435" class="difflineplus">+        if (m_closeNeededBeforeSelect) Close();</span>
<a href="#l3.3436"></a><span id="l3.3436" class="difflineplus">+        if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.3437"></a><span id="l3.3437">           selectIssued = true;</span>
<a href="#l3.3438"></a><span id="l3.3438">           SelectMailbox(mailboxName.get());</span>
<a href="#l3.3439"></a><span id="l3.3439">         }</span>
<a href="#l3.3440"></a><span id="l3.3440" class="difflineminus">-      }</span>
<a href="#l3.3441"></a><span id="l3.3441" class="difflineminus">-      else if (!GetServerStateParser().GetSelectedMailboxName())</span>
<a href="#l3.3442"></a><span id="l3.3442" class="difflineminus">-      {       // why are we in the selected state with no box name?</span>
<a href="#l3.3443"></a><span id="l3.3443" class="difflineplus">+      } else if (!GetServerStateParser()</span>
<a href="#l3.3444"></a><span id="l3.3444" class="difflineplus">+                      .GetSelectedMailboxName()) {  // why are we in the</span>
<a href="#l3.3445"></a><span id="l3.3445" class="difflineplus">+                                                    // selected state with no</span>
<a href="#l3.3446"></a><span id="l3.3446" class="difflineplus">+                                                    // box name?</span>
<a href="#l3.3447"></a><span id="l3.3447">         SelectMailbox(mailboxName.get());</span>
<a href="#l3.3448"></a><span id="l3.3448">         selectIssued = true;</span>
<a href="#l3.3449"></a><span id="l3.3449" class="difflineminus">-      }</span>
<a href="#l3.3450"></a><span id="l3.3450" class="difflineminus">-      else if (moreHeadersToDownload &amp;&amp; m_imapMailFolderSink) // we need to fetch older headers</span>
<a href="#l3.3451"></a><span id="l3.3451" class="difflineplus">+      } else if (moreHeadersToDownload &amp;&amp;</span>
<a href="#l3.3452"></a><span id="l3.3452" class="difflineplus">+                 m_imapMailFolderSink)  // we need to fetch older headers</span>
<a href="#l3.3453"></a><span id="l3.3453">       {</span>
<a href="#l3.3454"></a><span id="l3.3454">         nsMsgKey *msgIdList = nullptr;</span>
<a href="#l3.3455"></a><span id="l3.3455">         uint32_t msgCount = 0;</span>
<a href="#l3.3456"></a><span id="l3.3456">         bool more;</span>
<a href="#l3.3457"></a><span id="l3.3457" class="difflineminus">-        m_imapMailFolderSink-&gt;GetMsgHdrsToDownload(&amp;more,</span>
<a href="#l3.3458"></a><span id="l3.3458" class="difflineminus">-                                                   &amp;m_progressExpectedNumber,</span>
<a href="#l3.3459"></a><span id="l3.3459" class="difflineminus">-                                                   &amp;msgCount,</span>
<a href="#l3.3460"></a><span id="l3.3460" class="difflineminus">-                                                   &amp;msgIdList);</span>
<a href="#l3.3461"></a><span id="l3.3461" class="difflineminus">-        if (msgIdList)</span>
<a href="#l3.3462"></a><span id="l3.3462" class="difflineminus">-        {</span>
<a href="#l3.3463"></a><span id="l3.3463" class="difflineplus">+        m_imapMailFolderSink-&gt;GetMsgHdrsToDownload(</span>
<a href="#l3.3464"></a><span id="l3.3464" class="difflineplus">+            &amp;more, &amp;m_progressExpectedNumber, &amp;msgCount, &amp;msgIdList);</span>
<a href="#l3.3465"></a><span id="l3.3465" class="difflineplus">+        if (msgIdList) {</span>
<a href="#l3.3466"></a><span id="l3.3466">           FolderHeaderDump(msgIdList, msgCount);</span>
<a href="#l3.3467"></a><span id="l3.3467">           free(msgIdList);</span>
<a href="#l3.3468"></a><span id="l3.3468">           m_runningUrl-&gt;SetMoreHeadersToDownload(more);</span>
<a href="#l3.3469"></a><span id="l3.3469">           // We're going to be re-running this url.</span>
<a href="#l3.3470"></a><span id="l3.3470" class="difflineminus">-          if (more)</span>
<a href="#l3.3471"></a><span id="l3.3471" class="difflineminus">-            m_runningUrl-&gt;SetRerunningUrl(true);</span>
<a href="#l3.3472"></a><span id="l3.3472" class="difflineplus">+          if (more) m_runningUrl-&gt;SetRerunningUrl(true);</span>
<a href="#l3.3473"></a><span id="l3.3473">         }</span>
<a href="#l3.3474"></a><span id="l3.3474">         HeaderFetchCompleted();</span>
<a href="#l3.3475"></a><span id="l3.3475" class="difflineminus">-      }</span>
<a href="#l3.3476"></a><span id="l3.3476" class="difflineminus">-      else</span>
<a href="#l3.3477"></a><span id="l3.3477" class="difflineminus">-      {</span>
<a href="#l3.3478"></a><span id="l3.3478" class="difflineplus">+      } else {</span>
<a href="#l3.3479"></a><span id="l3.3479">         // get new message counts, if any, from server</span>
<a href="#l3.3480"></a><span id="l3.3480" class="difflineminus">-        if (m_needNoop)</span>
<a href="#l3.3481"></a><span id="l3.3481" class="difflineminus">-        {</span>
<a href="#l3.3482"></a><span id="l3.3482" class="difflineplus">+        if (m_needNoop) {</span>
<a href="#l3.3483"></a><span id="l3.3483">           // For some IMAP servers, to detect new email we must send imap</span>
<a href="#l3.3484"></a><span id="l3.3484">           // SELECT even if already SELECTed on the same mailbox. For other</span>
<a href="#l3.3485"></a><span id="l3.3485">           // servers that simply don't support IDLE, doing select here will</span>
<a href="#l3.3486"></a><span id="l3.3486">           // cause emails to be properly marked &quot;read&quot; after they have been</span>
<a href="#l3.3487"></a><span id="l3.3487">           // read in another email client.</span>
<a href="#l3.3488"></a><span id="l3.3488" class="difflineminus">-          if (m_forceSelect)</span>
<a href="#l3.3489"></a><span id="l3.3489" class="difflineminus">-          {</span>
<a href="#l3.3490"></a><span id="l3.3490" class="difflineplus">+          if (m_forceSelect) {</span>
<a href="#l3.3491"></a><span id="l3.3491">             SelectMailbox(mailboxName.get());</span>
<a href="#l3.3492"></a><span id="l3.3492">             selectIssued = true;</span>
<a href="#l3.3493"></a><span id="l3.3493">           }</span>
<a href="#l3.3494"></a><span id="l3.3494"> </span>
<a href="#l3.3495"></a><span id="l3.3495">           m_noopCount++;</span>
<a href="#l3.3496"></a><span id="l3.3496" class="difflineminus">-          if ((gPromoteNoopToCheckCount &gt; 0 &amp;&amp; (m_noopCount % gPromoteNoopToCheckCount) == 0) ||</span>
<a href="#l3.3497"></a><span id="l3.3497" class="difflineminus">-            CheckNeeded())</span>
<a href="#l3.3498"></a><span id="l3.3498" class="difflineplus">+          if ((gPromoteNoopToCheckCount &gt; 0 &amp;&amp;</span>
<a href="#l3.3499"></a><span id="l3.3499" class="difflineplus">+               (m_noopCount % gPromoteNoopToCheckCount) == 0) ||</span>
<a href="#l3.3500"></a><span id="l3.3500" class="difflineplus">+              CheckNeeded())</span>
<a href="#l3.3501"></a><span id="l3.3501">             Check();</span>
<a href="#l3.3502"></a><span id="l3.3502">           else</span>
<a href="#l3.3503"></a><span id="l3.3503" class="difflineminus">-            Noop(); // I think this is needed when we're using a cached connection</span>
<a href="#l3.3504"></a><span id="l3.3504" class="difflineplus">+            Noop();  // I think this is needed when we're using a cached</span>
<a href="#l3.3505"></a><span id="l3.3505" class="difflineplus">+                     // connection</span>
<a href="#l3.3506"></a><span id="l3.3506">           m_needNoop = false;</span>
<a href="#l3.3507"></a><span id="l3.3507">         }</span>
<a href="#l3.3508"></a><span id="l3.3508">       }</span>
<a href="#l3.3509"></a><span id="l3.3509" class="difflineminus">-    }</span>
<a href="#l3.3510"></a><span id="l3.3510" class="difflineminus">-    else</span>
<a href="#l3.3511"></a><span id="l3.3511" class="difflineminus">-    {</span>
<a href="#l3.3512"></a><span id="l3.3512" class="difflineplus">+    } else {</span>
<a href="#l3.3513"></a><span id="l3.3513">       // go to selected state</span>
<a href="#l3.3514"></a><span id="l3.3514">       SelectMailbox(mailboxName.get());</span>
<a href="#l3.3515"></a><span id="l3.3515">       selectIssued = GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l3.3516"></a><span id="l3.3516">     }</span>
<a href="#l3.3517"></a><span id="l3.3517"> </span>
<a href="#l3.3518"></a><span id="l3.3518" class="difflineminus">-    if (selectIssued)</span>
<a href="#l3.3519"></a><span id="l3.3519" class="difflineminus">-      RefreshACLForFolderIfNecessary(mailboxName.get());</span>
<a href="#l3.3520"></a><span id="l3.3520" class="difflineplus">+    if (selectIssued) RefreshACLForFolderIfNecessary(mailboxName.get());</span>
<a href="#l3.3521"></a><span id="l3.3521"> </span>
<a href="#l3.3522"></a><span id="l3.3522">     bool uidValidityOk = true;</span>
<a href="#l3.3523"></a><span id="l3.3523">     if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; selectIssued &amp;&amp;</span>
<a href="#l3.3524"></a><span id="l3.3524" class="difflineminus">-      (m_imapAction != nsIImapUrl::nsImapSelectFolder) &amp;&amp; (m_imapAction != nsIImapUrl::nsImapLiteSelectFolder))</span>
<a href="#l3.3525"></a><span id="l3.3525" class="difflineminus">-    {</span>
<a href="#l3.3526"></a><span id="l3.3526" class="difflineminus">-</span>
<a href="#l3.3527"></a><span id="l3.3527" class="difflineminus">-      // error on the side of caution, if the fe event fails to set uidStruct-&gt;returnValidity, then assume that UIDVALIDITY</span>
<a href="#l3.3528"></a><span id="l3.3528" class="difflineminus">-      // did not roll.  This is a common case event for attachments that are fetched within a browser context.</span>
<a href="#l3.3529"></a><span id="l3.3529" class="difflineplus">+        (m_imapAction != nsIImapUrl::nsImapSelectFolder) &amp;&amp;</span>
<a href="#l3.3530"></a><span id="l3.3530" class="difflineplus">+        (m_imapAction != nsIImapUrl::nsImapLiteSelectFolder)) {</span>
<a href="#l3.3531"></a><span id="l3.3531" class="difflineplus">+      // error on the side of caution, if the fe event fails to set</span>
<a href="#l3.3532"></a><span id="l3.3532" class="difflineplus">+      // uidStruct-&gt;returnValidity, then assume that UIDVALIDITY did not roll.</span>
<a href="#l3.3533"></a><span id="l3.3533" class="difflineplus">+      // This is a common case event for attachments that are fetched within a</span>
<a href="#l3.3534"></a><span id="l3.3534" class="difflineplus">+      // browser context.</span>
<a href="#l3.3535"></a><span id="l3.3535">       if (!DeathSignalReceived())</span>
<a href="#l3.3536"></a><span id="l3.3536">         uidValidityOk = m_uidValidity == kUidUnknown ||</span>
<a href="#l3.3537"></a><span id="l3.3537">                         m_uidValidity == GetServerStateParser().FolderUID();</span>
<a href="#l3.3538"></a><span id="l3.3538">     }</span>
<a href="#l3.3539"></a><span id="l3.3539"> </span>
<a href="#l3.3540"></a><span id="l3.3540">     if (!uidValidityOk)</span>
<a href="#l3.3541"></a><span id="l3.3541">       Log(&quot;ProcessSelectedStateURL&quot;, nullptr, &quot;uid validity not ok&quot;);</span>
<a href="#l3.3542"></a><span id="l3.3542" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; !DeathSignalReceived() &amp;&amp; (uidValidityOk || m_imapAction == nsIImapUrl::nsImapDeleteAllMsgs))</span>
<a href="#l3.3543"></a><span id="l3.3543" class="difflineminus">-    {</span>
<a href="#l3.3544"></a><span id="l3.3544" class="difflineminus">-      if (GetServerStateParser().CurrentFolderReadOnly())</span>
<a href="#l3.3545"></a><span id="l3.3545" class="difflineminus">-      {</span>
<a href="#l3.3546"></a><span id="l3.3546" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.3547"></a><span id="l3.3547" class="difflineplus">+        !DeathSignalReceived() &amp;&amp;</span>
<a href="#l3.3548"></a><span id="l3.3548" class="difflineplus">+        (uidValidityOk || m_imapAction == nsIImapUrl::nsImapDeleteAllMsgs)) {</span>
<a href="#l3.3549"></a><span id="l3.3549" class="difflineplus">+      if (GetServerStateParser().CurrentFolderReadOnly()) {</span>
<a href="#l3.3550"></a><span id="l3.3550">         Log(&quot;ProcessSelectedStateURL&quot;, nullptr, &quot;current folder read only&quot;);</span>
<a href="#l3.3551"></a><span id="l3.3551">         if (m_imapAction == nsIImapUrl::nsImapAddMsgFlags ||</span>
<a href="#l3.3552"></a><span id="l3.3552" class="difflineminus">-          m_imapAction == nsIImapUrl::nsImapSubtractMsgFlags)</span>
<a href="#l3.3553"></a><span id="l3.3553" class="difflineminus">-        {</span>
<a href="#l3.3554"></a><span id="l3.3554" class="difflineplus">+            m_imapAction == nsIImapUrl::nsImapSubtractMsgFlags) {</span>
<a href="#l3.3555"></a><span id="l3.3555">           bool canChangeFlag = false;</span>
<a href="#l3.3556"></a><span id="l3.3556" class="difflineminus">-          if (GetServerStateParser().ServerHasACLCapability() &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.3557"></a><span id="l3.3557" class="difflineminus">-          {</span>
<a href="#l3.3558"></a><span id="l3.3558" class="difflineplus">+          if (GetServerStateParser().ServerHasACLCapability() &amp;&amp;</span>
<a href="#l3.3559"></a><span id="l3.3559" class="difflineplus">+              m_imapMailFolderSink) {</span>
<a href="#l3.3560"></a><span id="l3.3560">             uint32_t aclFlags = 0;</span>
<a href="#l3.3561"></a><span id="l3.3561"> </span>
<a href="#l3.3562"></a><span id="l3.3562" class="difflineminus">-            if (NS_SUCCEEDED(m_imapMailFolderSink-&gt;GetAclFlags(&amp;aclFlags))</span>
<a href="#l3.3563"></a><span id="l3.3563" class="difflineminus">-                  &amp;&amp; aclFlags != 0) // make sure we have some acl flags</span>
<a href="#l3.3564"></a><span id="l3.3564" class="difflineminus">-              canChangeFlag = ((msgFlags &amp; kImapMsgSeenFlag) &amp;&amp; (aclFlags &amp; IMAP_ACL_STORE_SEEN_FLAG));</span>
<a href="#l3.3565"></a><span id="l3.3565" class="difflineminus">-          }</span>
<a href="#l3.3566"></a><span id="l3.3566" class="difflineminus">-          else</span>
<a href="#l3.3567"></a><span id="l3.3567" class="difflineminus">-            canChangeFlag = (GetServerStateParser().SettablePermanentFlags() &amp; msgFlags) == msgFlags;</span>
<a href="#l3.3568"></a><span id="l3.3568" class="difflineminus">-          if (!canChangeFlag)</span>
<a href="#l3.3569"></a><span id="l3.3569" class="difflineminus">-            return;</span>
<a href="#l3.3570"></a><span id="l3.3570" class="difflineplus">+            if (NS_SUCCEEDED(m_imapMailFolderSink-&gt;GetAclFlags(&amp;aclFlags)) &amp;&amp;</span>
<a href="#l3.3571"></a><span id="l3.3571" class="difflineplus">+                aclFlags != 0)  // make sure we have some acl flags</span>
<a href="#l3.3572"></a><span id="l3.3572" class="difflineplus">+              canChangeFlag = ((msgFlags &amp; kImapMsgSeenFlag) &amp;&amp;</span>
<a href="#l3.3573"></a><span id="l3.3573" class="difflineplus">+                               (aclFlags &amp; IMAP_ACL_STORE_SEEN_FLAG));</span>
<a href="#l3.3574"></a><span id="l3.3574" class="difflineplus">+          } else</span>
<a href="#l3.3575"></a><span id="l3.3575" class="difflineplus">+            canChangeFlag = (GetServerStateParser().SettablePermanentFlags() &amp;</span>
<a href="#l3.3576"></a><span id="l3.3576" class="difflineplus">+                             msgFlags) == msgFlags;</span>
<a href="#l3.3577"></a><span id="l3.3577" class="difflineplus">+          if (!canChangeFlag) return;</span>
<a href="#l3.3578"></a><span id="l3.3578">         }</span>
<a href="#l3.3579"></a><span id="l3.3579" class="difflineminus">-        if (m_imapAction == nsIImapUrl::nsImapExpungeFolder || m_imapAction == nsIImapUrl::nsImapDeleteMsg ||</span>
<a href="#l3.3580"></a><span id="l3.3580" class="difflineminus">-          m_imapAction == nsIImapUrl::nsImapDeleteAllMsgs)</span>
<a href="#l3.3581"></a><span id="l3.3581" class="difflineplus">+        if (m_imapAction == nsIImapUrl::nsImapExpungeFolder ||</span>
<a href="#l3.3582"></a><span id="l3.3582" class="difflineplus">+            m_imapAction == nsIImapUrl::nsImapDeleteMsg ||</span>
<a href="#l3.3583"></a><span id="l3.3583" class="difflineplus">+            m_imapAction == nsIImapUrl::nsImapDeleteAllMsgs)</span>
<a href="#l3.3584"></a><span id="l3.3584">           return;</span>
<a href="#l3.3585"></a><span id="l3.3585">       }</span>
<a href="#l3.3586"></a><span id="l3.3586" class="difflineminus">-      switch (m_imapAction)</span>
<a href="#l3.3587"></a><span id="l3.3587" class="difflineminus">-      {</span>
<a href="#l3.3588"></a><span id="l3.3588" class="difflineminus">-      case nsIImapUrl::nsImapLiteSelectFolder:</span>
<a href="#l3.3589"></a><span id="l3.3589" class="difflineminus">-        if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.3590"></a><span id="l3.3590" class="difflineminus">-            m_imapMailFolderSink &amp;&amp; !moreHeadersToDownload)</span>
<a href="#l3.3591"></a><span id="l3.3591" class="difflineminus">-        {</span>
<a href="#l3.3592"></a><span id="l3.3592" class="difflineminus">-          m_imapMailFolderSink-&gt;SetUidValidity(GetServerStateParser().FolderUID());</span>
<a href="#l3.3593"></a><span id="l3.3593" class="difflineminus">-          ProcessMailboxUpdate(false); // handle uidvalidity change</span>
<a href="#l3.3594"></a><span id="l3.3594" class="difflineminus">-        }</span>
<a href="#l3.3595"></a><span id="l3.3595" class="difflineminus">-        break;</span>
<a href="#l3.3596"></a><span id="l3.3596" class="difflineminus">-      case nsIImapUrl::nsImapSaveMessageToDisk:</span>
<a href="#l3.3597"></a><span id="l3.3597" class="difflineminus">-      case nsIImapUrl::nsImapMsgFetch:</span>
<a href="#l3.3598"></a><span id="l3.3598" class="difflineminus">-      case nsIImapUrl::nsImapMsgFetchPeek:</span>
<a href="#l3.3599"></a><span id="l3.3599" class="difflineminus">-      case nsIImapUrl::nsImapMsgDownloadForOffline:</span>
<a href="#l3.3600"></a><span id="l3.3600" class="difflineminus">-      case nsIImapUrl::nsImapMsgPreview:</span>
<a href="#l3.3601"></a><span id="l3.3601" class="difflineminus">-        {</span>
<a href="#l3.3602"></a><span id="l3.3602" class="difflineplus">+      switch (m_imapAction) {</span>
<a href="#l3.3603"></a><span id="l3.3603" class="difflineplus">+        case nsIImapUrl::nsImapLiteSelectFolder:</span>
<a href="#l3.3604"></a><span id="l3.3604" class="difflineplus">+          if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.3605"></a><span id="l3.3605" class="difflineplus">+              m_imapMailFolderSink &amp;&amp; !moreHeadersToDownload) {</span>
<a href="#l3.3606"></a><span id="l3.3606" class="difflineplus">+            m_imapMailFolderSink-&gt;SetUidValidity(</span>
<a href="#l3.3607"></a><span id="l3.3607" class="difflineplus">+                GetServerStateParser().FolderUID());</span>
<a href="#l3.3608"></a><span id="l3.3608" class="difflineplus">+            ProcessMailboxUpdate(false);  // handle uidvalidity change</span>
<a href="#l3.3609"></a><span id="l3.3609" class="difflineplus">+          }</span>
<a href="#l3.3610"></a><span id="l3.3610" class="difflineplus">+          break;</span>
<a href="#l3.3611"></a><span id="l3.3611" class="difflineplus">+        case nsIImapUrl::nsImapSaveMessageToDisk:</span>
<a href="#l3.3612"></a><span id="l3.3612" class="difflineplus">+        case nsIImapUrl::nsImapMsgFetch:</span>
<a href="#l3.3613"></a><span id="l3.3613" class="difflineplus">+        case nsIImapUrl::nsImapMsgFetchPeek:</span>
<a href="#l3.3614"></a><span id="l3.3614" class="difflineplus">+        case nsIImapUrl::nsImapMsgDownloadForOffline:</span>
<a href="#l3.3615"></a><span id="l3.3615" class="difflineplus">+        case nsIImapUrl::nsImapMsgPreview: {</span>
<a href="#l3.3616"></a><span id="l3.3616">           nsCString messageIdString;</span>
<a href="#l3.3617"></a><span id="l3.3617">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.3618"></a><span id="l3.3618">           // we don't want to send the flags back in a group</span>
<a href="#l3.3619"></a><span id="l3.3619" class="difflineminus">-          if (HandlingMultipleMessages(messageIdString) || m_imapAction == nsIImapUrl::nsImapMsgDownloadForOffline</span>
<a href="#l3.3620"></a><span id="l3.3620" class="difflineminus">-             || m_imapAction == nsIImapUrl::nsImapMsgPreview)</span>
<a href="#l3.3621"></a><span id="l3.3621" class="difflineminus">-          {</span>
<a href="#l3.3622"></a><span id="l3.3622" class="difflineplus">+          if (HandlingMultipleMessages(messageIdString) ||</span>
<a href="#l3.3623"></a><span id="l3.3623" class="difflineplus">+              m_imapAction == nsIImapUrl::nsImapMsgDownloadForOffline ||</span>
<a href="#l3.3624"></a><span id="l3.3624" class="difflineplus">+              m_imapAction == nsIImapUrl::nsImapMsgPreview) {</span>
<a href="#l3.3625"></a><span id="l3.3625">             // multiple messages, fetch them all</span>
<a href="#l3.3626"></a><span id="l3.3626">             SetProgressString(IMAP_MESSAGES_STRING_INDEX);</span>
<a href="#l3.3627"></a><span id="l3.3627"> </span>
<a href="#l3.3628"></a><span id="l3.3628">             m_progressCurrentNumber[m_stringIndex] = 0;</span>
<a href="#l3.3629"></a><span id="l3.3629" class="difflineminus">-            m_progressExpectedNumber = CountMessagesInIdString(messageIdString.get());</span>
<a href="#l3.3630"></a><span id="l3.3630" class="difflineplus">+            m_progressExpectedNumber =</span>
<a href="#l3.3631"></a><span id="l3.3631" class="difflineplus">+                CountMessagesInIdString(messageIdString.get());</span>
<a href="#l3.3632"></a><span id="l3.3632"> </span>
<a href="#l3.3633"></a><span id="l3.3633">             // we need to set this so we'll get the msg from the memory cache.</span>
<a href="#l3.3634"></a><span id="l3.3634" class="difflineminus">-            if (m_imapAction == nsIImapUrl::nsImapMsgFetchPeek)</span>
<a href="#l3.3635"></a><span id="l3.3635" class="difflineminus">-            {</span>
<a href="#l3.3636"></a><span id="l3.3636" class="difflineplus">+            if (m_imapAction == nsIImapUrl::nsImapMsgFetchPeek) {</span>
<a href="#l3.3637"></a><span id="l3.3637">               MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3638"></a><span id="l3.3638" class="difflineminus">-                (&quot;ProcessSelectedStateURL(): Set IMAP_CONTENT_NOT_MODIFIED; action nsImapMsgFetchPeek&quot;));</span>
<a href="#l3.3639"></a><span id="l3.3639" class="difflineplus">+                      (&quot;ProcessSelectedStateURL(): Set &quot;</span>
<a href="#l3.3640"></a><span id="l3.3640" class="difflineplus">+                       &quot;IMAP_CONTENT_NOT_MODIFIED; action nsImapMsgFetchPeek&quot;));</span>
<a href="#l3.3641"></a><span id="l3.3641">               SetContentModified(IMAP_CONTENT_NOT_MODIFIED);</span>
<a href="#l3.3642"></a><span id="l3.3642">             }</span>
<a href="#l3.3643"></a><span id="l3.3643"> </span>
<a href="#l3.3644"></a><span id="l3.3644">             FetchMessage(messageIdString,</span>
<a href="#l3.3645"></a><span id="l3.3645" class="difflineminus">-              (m_imapAction == nsIImapUrl::nsImapMsgPreview)</span>
<a href="#l3.3646"></a><span id="l3.3646" class="difflineminus">-              ? kBodyStart : kEveryThingRFC822Peek);</span>
<a href="#l3.3647"></a><span id="l3.3647" class="difflineplus">+                         (m_imapAction == nsIImapUrl::nsImapMsgPreview)</span>
<a href="#l3.3648"></a><span id="l3.3648" class="difflineplus">+                             ? kBodyStart</span>
<a href="#l3.3649"></a><span id="l3.3649" class="difflineplus">+                             : kEveryThingRFC822Peek);</span>
<a href="#l3.3650"></a><span id="l3.3650">             if (m_imapAction == nsIImapUrl::nsImapMsgPreview)</span>
<a href="#l3.3651"></a><span id="l3.3651">               HeaderFetchCompleted();</span>
<a href="#l3.3652"></a><span id="l3.3652">             SetProgressString(IMAP_EMPTY_STRING_INDEX);</span>
<a href="#l3.3653"></a><span id="l3.3653" class="difflineminus">-          }</span>
<a href="#l3.3654"></a><span id="l3.3654" class="difflineminus">-          else</span>
<a href="#l3.3655"></a><span id="l3.3655" class="difflineminus">-          {</span>
<a href="#l3.3656"></a><span id="l3.3656" class="difflineplus">+          } else {</span>
<a href="#l3.3657"></a><span id="l3.3657">             // A single message ID</span>
<a href="#l3.3658"></a><span id="l3.3658">             nsIMAPeFetchFields whatToFetch = kEveryThingRFC822;</span>
<a href="#l3.3659"></a><span id="l3.3659" class="difflineminus">-            if(m_imapAction == nsIImapUrl::nsImapMsgFetchPeek)</span>
<a href="#l3.3660"></a><span id="l3.3660" class="difflineplus">+            if (m_imapAction == nsIImapUrl::nsImapMsgFetchPeek)</span>
<a href="#l3.3661"></a><span id="l3.3661">               whatToFetch = kEveryThingRFC822Peek;</span>
<a href="#l3.3662"></a><span id="l3.3662"> </span>
<a href="#l3.3663"></a><span id="l3.3663">             // First, let's see if we're requesting a specific MIME part</span>
<a href="#l3.3664"></a><span id="l3.3664">             char *imappart = nullptr;</span>
<a href="#l3.3665"></a><span id="l3.3665">             m_runningUrl-&gt;GetImapPartToFetch(&amp;imappart);</span>
<a href="#l3.3666"></a><span id="l3.3666" class="difflineminus">-            if (imappart)</span>
<a href="#l3.3667"></a><span id="l3.3667" class="difflineminus">-            {</span>
<a href="#l3.3668"></a><span id="l3.3668" class="difflineminus">-              if (bMessageIdsAreUids)</span>
<a href="#l3.3669"></a><span id="l3.3669" class="difflineminus">-              {</span>
<a href="#l3.3670"></a><span id="l3.3670" class="difflineplus">+            if (imappart) {</span>
<a href="#l3.3671"></a><span id="l3.3671" class="difflineplus">+              if (bMessageIdsAreUids) {</span>
<a href="#l3.3672"></a><span id="l3.3672">                 // We actually want a specific MIME part of the message.</span>
<a href="#l3.3673"></a><span id="l3.3673" class="difflineminus">-                // The Body Shell will generate it, even though we haven't downloaded it yet.</span>
<a href="#l3.3674"></a><span id="l3.3674" class="difflineminus">-</span>
<a href="#l3.3675"></a><span id="l3.3675" class="difflineminus">-                IMAP_ContentModifiedType modType = GetShowAttachmentsInline() ?</span>
<a href="#l3.3676"></a><span id="l3.3676" class="difflineminus">-                  IMAP_CONTENT_MODIFIED_VIEW_INLINE :</span>
<a href="#l3.3677"></a><span id="l3.3677" class="difflineminus">-                  IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS ;</span>
<a href="#l3.3678"></a><span id="l3.3678" class="difflineplus">+                // The Body Shell will generate it, even though we haven't</span>
<a href="#l3.3679"></a><span id="l3.3679" class="difflineplus">+                // downloaded it yet.</span>
<a href="#l3.3680"></a><span id="l3.3680" class="difflineplus">+</span>
<a href="#l3.3681"></a><span id="l3.3681" class="difflineplus">+                IMAP_ContentModifiedType modType =</span>
<a href="#l3.3682"></a><span id="l3.3682" class="difflineplus">+                    GetShowAttachmentsInline()</span>
<a href="#l3.3683"></a><span id="l3.3683" class="difflineplus">+                        ? IMAP_CONTENT_MODIFIED_VIEW_INLINE</span>
<a href="#l3.3684"></a><span id="l3.3684" class="difflineplus">+                        : IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS;</span>
<a href="#l3.3685"></a><span id="l3.3685"> </span>
<a href="#l3.3686"></a><span id="l3.3686">                 nsCString messageIdValString(messageIdString);</span>
<a href="#l3.3687"></a><span id="l3.3687">                 messageIdValString.AppendInt(m_uidValidity);</span>
<a href="#l3.3688"></a><span id="l3.3688">                 RefPtr&lt;nsIMAPBodyShell&gt; foundShell;</span>
<a href="#l3.3689"></a><span id="l3.3689" class="difflineminus">-                res = m_hostSessionList-&gt;FindShellInCacheForHost(GetImapServerKey(),</span>
<a href="#l3.3690"></a><span id="l3.3690" class="difflineminus">-                  GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.3691"></a><span id="l3.3691" class="difflineminus">-                  messageIdValString.get(), modType, getter_AddRefs(foundShell));</span>
<a href="#l3.3692"></a><span id="l3.3692" class="difflineminus">-                if (!foundShell)</span>
<a href="#l3.3693"></a><span id="l3.3693" class="difflineminus">-                {</span>
<a href="#l3.3694"></a><span id="l3.3694" class="difflineplus">+                res = m_hostSessionList-&gt;FindShellInCacheForHost(</span>
<a href="#l3.3695"></a><span id="l3.3695" class="difflineplus">+                    GetImapServerKey(),</span>
<a href="#l3.3696"></a><span id="l3.3696" class="difflineplus">+                    GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.3697"></a><span id="l3.3697" class="difflineplus">+                    messageIdValString.get(), modType,</span>
<a href="#l3.3698"></a><span id="l3.3698" class="difflineplus">+                    getter_AddRefs(foundShell));</span>
<a href="#l3.3699"></a><span id="l3.3699" class="difflineplus">+                if (!foundShell) {</span>
<a href="#l3.3700"></a><span id="l3.3700">                   // The shell wasn't in the cache.  Deal with this case later.</span>
<a href="#l3.3701"></a><span id="l3.3701">                   Log(&quot;SHELL&quot;, NULL, &quot;Loading part, shell not found in cache!&quot;);</span>
<a href="#l3.3702"></a><span id="l3.3702" class="difflineminus">-                  //MOZ_LOG(IMAP, out, (&quot;BODYSHELL: Loading part, shell not found in cache!&quot;));</span>
<a href="#l3.3703"></a><span id="l3.3703" class="difflineminus">-                  // The parser will extract the part number from the current URL.</span>
<a href="#l3.3704"></a><span id="l3.3704" class="difflineplus">+                  // MOZ_LOG(IMAP, out, (&quot;BODYSHELL: Loading part, shell not</span>
<a href="#l3.3705"></a><span id="l3.3705" class="difflineplus">+                  // found in cache!&quot;));</span>
<a href="#l3.3706"></a><span id="l3.3706" class="difflineplus">+                  // The parser will extract the part number from the current</span>
<a href="#l3.3707"></a><span id="l3.3707" class="difflineplus">+                  // URL.</span>
<a href="#l3.3708"></a><span id="l3.3708">                   MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3709"></a><span id="l3.3709" class="difflineminus">-                    (&quot;ProcessSelectedStateURL(): Set IMAP_CONTENT_MODIFIED_*; fetch bodystructure, one mime part&quot;));</span>
<a href="#l3.3710"></a><span id="l3.3710" class="difflineplus">+                          (&quot;ProcessSelectedStateURL(): Set &quot;</span>
<a href="#l3.3711"></a><span id="l3.3711" class="difflineplus">+                           &quot;IMAP_CONTENT_MODIFIED_*; fetch bodystructure, one &quot;</span>
<a href="#l3.3712"></a><span id="l3.3712" class="difflineplus">+                           &quot;mime part&quot;));</span>
<a href="#l3.3713"></a><span id="l3.3713">                   SetContentModified(modType);</span>
<a href="#l3.3714"></a><span id="l3.3714">                   Bodystructure(messageIdString, bMessageIdsAreUids);</span>
<a href="#l3.3715"></a><span id="l3.3715" class="difflineminus">-                }</span>
<a href="#l3.3716"></a><span id="l3.3716" class="difflineminus">-                else</span>
<a href="#l3.3717"></a><span id="l3.3717" class="difflineminus">-                {</span>
<a href="#l3.3718"></a><span id="l3.3718" class="difflineplus">+                } else {</span>
<a href="#l3.3719"></a><span id="l3.3719">                   Log(&quot;SHELL&quot;, NULL, &quot;Loading Part, using cached shell.&quot;);</span>
<a href="#l3.3720"></a><span id="l3.3720" class="difflineminus">-                  //MOZ_LOG(IMAP, out, (&quot;BODYSHELL: Loading part, using cached shell.&quot;));</span>
<a href="#l3.3721"></a><span id="l3.3721" class="difflineplus">+                  // MOZ_LOG(IMAP, out, (&quot;BODYSHELL: Loading part, using cached</span>
<a href="#l3.3722"></a><span id="l3.3722" class="difflineplus">+                  // shell.&quot;));</span>
<a href="#l3.3723"></a><span id="l3.3723">                   SetContentModified(modType);</span>
<a href="#l3.3724"></a><span id="l3.3724">                   MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3725"></a><span id="l3.3725" class="difflineminus">-                    (&quot;ProcessSelectedStateURL(): Set IMAP_CONTENT_MODIFIED_*: fetch one mime part&quot;));</span>
<a href="#l3.3726"></a><span id="l3.3726" class="difflineplus">+                          (&quot;ProcessSelectedStateURL(): Set &quot;</span>
<a href="#l3.3727"></a><span id="l3.3727" class="difflineplus">+                           &quot;IMAP_CONTENT_MODIFIED_*: fetch one mime part&quot;));</span>
<a href="#l3.3728"></a><span id="l3.3728">                   foundShell-&gt;SetConnection(this);</span>
<a href="#l3.3729"></a><span id="l3.3729">                   GetServerStateParser().UseCachedShell(foundShell);</span>
<a href="#l3.3730"></a><span id="l3.3730" class="difflineminus">-                  //Set the current uid in server state parser (in case it was used for new mail msgs earlier).</span>
<a href="#l3.3731"></a><span id="l3.3731" class="difflineminus">-                  GetServerStateParser().SetCurrentResponseUID(strtoul(messageIdString.get(), nullptr, 10));</span>
<a href="#l3.3732"></a><span id="l3.3732" class="difflineplus">+                  // Set the current uid in server state parser (in case it was</span>
<a href="#l3.3733"></a><span id="l3.3733" class="difflineplus">+                  // used for new mail msgs earlier).</span>
<a href="#l3.3734"></a><span id="l3.3734" class="difflineplus">+                  GetServerStateParser().SetCurrentResponseUID(</span>
<a href="#l3.3735"></a><span id="l3.3735" class="difflineplus">+                      strtoul(messageIdString.get(), nullptr, 10));</span>
<a href="#l3.3736"></a><span id="l3.3736">                   foundShell-&gt;Generate(imappart);</span>
<a href="#l3.3737"></a><span id="l3.3737">                   GetServerStateParser().UseCachedShell(NULL);</span>
<a href="#l3.3738"></a><span id="l3.3738">                 }</span>
<a href="#l3.3739"></a><span id="l3.3739" class="difflineminus">-              }</span>
<a href="#l3.3740"></a><span id="l3.3740" class="difflineminus">-              else</span>
<a href="#l3.3741"></a><span id="l3.3741" class="difflineminus">-              {</span>
<a href="#l3.3742"></a><span id="l3.3742" class="difflineplus">+              } else {</span>
<a href="#l3.3743"></a><span id="l3.3743">                 // Message IDs are not UIDs.</span>
<a href="#l3.3744"></a><span id="l3.3744">                 NS_ASSERTION(false, &quot;message ids aren't uids&quot;);</span>
<a href="#l3.3745"></a><span id="l3.3745">               }</span>
<a href="#l3.3746"></a><span id="l3.3746">               PR_Free(imappart);</span>
<a href="#l3.3747"></a><span id="l3.3747" class="difflineminus">-            }</span>
<a href="#l3.3748"></a><span id="l3.3748" class="difflineminus">-            else</span>
<a href="#l3.3749"></a><span id="l3.3749" class="difflineminus">-            {</span>
<a href="#l3.3750"></a><span id="l3.3750" class="difflineminus">-              // downloading a single message: try to do it by bodystructure, and/or do it by chunks</span>
<a href="#l3.3751"></a><span id="l3.3751" class="difflineminus">-              uint32_t messageSize = GetMessageSize(messageIdString.get(), bMessageIdsAreUids);</span>
<a href="#l3.3752"></a><span id="l3.3752" class="difflineminus">-              // We need to check the format_out bits to see if we are allowed to leave out parts,</span>
<a href="#l3.3753"></a><span id="l3.3753" class="difflineminus">-              // or if we are required to get the whole thing.  Some instances where we are allowed</span>
<a href="#l3.3754"></a><span id="l3.3754" class="difflineminus">-              // to do it by parts:  when viewing a message, replying to a message, or viewing its source</span>
<a href="#l3.3755"></a><span id="l3.3755" class="difflineminus">-              // Some times when we're NOT allowed:  when forwarding a message, saving it, moving it, etc.</span>
<a href="#l3.3756"></a><span id="l3.3756" class="difflineminus">-              // need to set a flag in the url, I guess, equiv to allow_content_changed.</span>
<a href="#l3.3757"></a><span id="l3.3757" class="difflineminus">-              bool allowedToBreakApart = true; // (ce  &amp;&amp; !DeathSignalReceived()) ? ce-&gt;URL_s-&gt;allow_content_change : false;</span>
<a href="#l3.3758"></a><span id="l3.3758" class="difflineplus">+            } else {</span>
<a href="#l3.3759"></a><span id="l3.3759" class="difflineplus">+              // downloading a single message: try to do it by bodystructure,</span>
<a href="#l3.3760"></a><span id="l3.3760" class="difflineplus">+              // and/or do it by chunks</span>
<a href="#l3.3761"></a><span id="l3.3761" class="difflineplus">+              uint32_t messageSize =</span>
<a href="#l3.3762"></a><span id="l3.3762" class="difflineplus">+                  GetMessageSize(messageIdString.get(), bMessageIdsAreUids);</span>
<a href="#l3.3763"></a><span id="l3.3763" class="difflineplus">+              // We need to check the format_out bits to see if we are allowed</span>
<a href="#l3.3764"></a><span id="l3.3764" class="difflineplus">+              // to leave out parts, or if we are required to get the whole</span>
<a href="#l3.3765"></a><span id="l3.3765" class="difflineplus">+              // thing.  Some instances where we are allowed to do it by parts:</span>
<a href="#l3.3766"></a><span id="l3.3766" class="difflineplus">+              // when viewing a message, replying to a message, or viewing its</span>
<a href="#l3.3767"></a><span id="l3.3767" class="difflineplus">+              // source Some times when we're NOT allowed:  when forwarding a</span>
<a href="#l3.3768"></a><span id="l3.3768" class="difflineplus">+              // message, saving it, moving it, etc. need to set a flag in the</span>
<a href="#l3.3769"></a><span id="l3.3769" class="difflineplus">+              // url, I guess, equiv to allow_content_changed.</span>
<a href="#l3.3770"></a><span id="l3.3770" class="difflineplus">+              bool allowedToBreakApart =</span>
<a href="#l3.3771"></a><span id="l3.3771" class="difflineplus">+                  true;  // (ce  &amp;&amp; !DeathSignalReceived()) ?</span>
<a href="#l3.3772"></a><span id="l3.3772" class="difflineplus">+                         // ce-&gt;URL_s-&gt;allow_content_change : false;</span>
<a href="#l3.3773"></a><span id="l3.3773">               bool mimePartSelectorDetected;</span>
<a href="#l3.3774"></a><span id="l3.3774">               bool urlOKToFetchByParts = false;</span>
<a href="#l3.3775"></a><span id="l3.3775" class="difflineminus">-              m_runningUrl-&gt;GetMimePartSelectorDetected(&amp;mimePartSelectorDetected);</span>
<a href="#l3.3776"></a><span id="l3.3776" class="difflineplus">+              m_runningUrl-&gt;GetMimePartSelectorDetected(</span>
<a href="#l3.3777"></a><span id="l3.3777" class="difflineplus">+                  &amp;mimePartSelectorDetected);</span>
<a href="#l3.3778"></a><span id="l3.3778">               m_runningUrl-&gt;GetFetchPartsOnDemand(&amp;urlOKToFetchByParts);</span>
<a href="#l3.3779"></a><span id="l3.3779"> </span>
<a href="#l3.3780"></a><span id="l3.3780">               {</span>
<a href="#l3.3781"></a><span id="l3.3781" class="difflineminus">-                nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.3782"></a><span id="l3.3782" class="difflineplus">+                nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl =</span>
<a href="#l3.3783"></a><span id="l3.3783" class="difflineplus">+                    do_QueryInterface(m_runningUrl);</span>
<a href="#l3.3784"></a><span id="l3.3784">                 if (mailnewsurl) {</span>
<a href="#l3.3785"></a><span id="l3.3785">                   MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.3786"></a><span id="l3.3786" class="difflineminus">-                         (&quot;SHELL: URL %s, OKToFetchByParts %d, allowedToBreakApart %d, ShouldFetchAllParts %d&quot;,</span>
<a href="#l3.3787"></a><span id="l3.3787" class="difflineminus">-                          mailnewsurl-&gt;GetSpecOrDefault().get(), urlOKToFetchByParts, allowedToBreakApart,</span>
<a href="#l3.3788"></a><span id="l3.3788" class="difflineminus">-                          GetShouldFetchAllParts()));</span>
<a href="#l3.3789"></a><span id="l3.3789" class="difflineplus">+                          (&quot;SHELL: URL %s, OKToFetchByParts %d, &quot;</span>
<a href="#l3.3790"></a><span id="l3.3790" class="difflineplus">+                           &quot;allowedToBreakApart %d, ShouldFetchAllParts %d&quot;,</span>
<a href="#l3.3791"></a><span id="l3.3791" class="difflineplus">+                           mailnewsurl-&gt;GetSpecOrDefault().get(),</span>
<a href="#l3.3792"></a><span id="l3.3792" class="difflineplus">+                           urlOKToFetchByParts, allowedToBreakApart,</span>
<a href="#l3.3793"></a><span id="l3.3793" class="difflineplus">+                           GetShouldFetchAllParts()));</span>
<a href="#l3.3794"></a><span id="l3.3794">                 }</span>
<a href="#l3.3795"></a><span id="l3.3795">               }</span>
<a href="#l3.3796"></a><span id="l3.3796"> </span>
<a href="#l3.3797"></a><span id="l3.3797">               if (urlOKToFetchByParts &amp;&amp;</span>
<a href="#l3.3798"></a><span id="l3.3798">                   allowedToBreakApart &amp;&amp;</span>
<a href="#l3.3799"></a><span id="l3.3799">                   !GetShouldFetchAllParts() &amp;&amp;</span>
<a href="#l3.3800"></a><span id="l3.3800">                   GetServerStateParser().ServerHasIMAP4Rev1Capability() /* &amp;&amp;</span>
<a href="#l3.3801"></a><span id="l3.3801">                 !mimePartSelectorDetected */)  // if a ?part=, don't do BS.</span>
<a href="#l3.3802"></a><span id="l3.3802">               {</span>
<a href="#l3.3803"></a><span id="l3.3803">                 // OK, we're doing bodystructure</span>
<a href="#l3.3804"></a><span id="l3.3804"> </span>
<a href="#l3.3805"></a><span id="l3.3805" class="difflineminus">-                // Before fetching the bodystructure, let's check our body shell cache to see if</span>
<a href="#l3.3806"></a><span id="l3.3806" class="difflineminus">-                // we already have it around.</span>
<a href="#l3.3807"></a><span id="l3.3807" class="difflineplus">+                // Before fetching the bodystructure, let's check our body shell</span>
<a href="#l3.3808"></a><span id="l3.3808" class="difflineplus">+                // cache to see if we already have it around.</span>
<a href="#l3.3809"></a><span id="l3.3809">                 RefPtr&lt;nsIMAPBodyShell&gt; foundShell;</span>
<a href="#l3.3810"></a><span id="l3.3810" class="difflineminus">-                IMAP_ContentModifiedType modType = GetShowAttachmentsInline() ?</span>
<a href="#l3.3811"></a><span id="l3.3811" class="difflineminus">-                  IMAP_CONTENT_MODIFIED_VIEW_INLINE :</span>
<a href="#l3.3812"></a><span id="l3.3812" class="difflineminus">-                  IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS ;</span>
<a href="#l3.3813"></a><span id="l3.3813" class="difflineplus">+                IMAP_ContentModifiedType modType =</span>
<a href="#l3.3814"></a><span id="l3.3814" class="difflineplus">+                    GetShowAttachmentsInline()</span>
<a href="#l3.3815"></a><span id="l3.3815" class="difflineplus">+                        ? IMAP_CONTENT_MODIFIED_VIEW_INLINE</span>
<a href="#l3.3816"></a><span id="l3.3816" class="difflineplus">+                        : IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS;</span>
<a href="#l3.3817"></a><span id="l3.3817"> </span>
<a href="#l3.3818"></a><span id="l3.3818">                 bool wasStoringMsgOffline;</span>
<a href="#l3.3819"></a><span id="l3.3819">                 m_runningUrl-&gt;GetStoreResultsOffline(&amp;wasStoringMsgOffline);</span>
<a href="#l3.3820"></a><span id="l3.3820">                 m_runningUrl-&gt;SetStoreOfflineOnFallback(wasStoringMsgOffline);</span>
<a href="#l3.3821"></a><span id="l3.3821">                 m_runningUrl-&gt;SetStoreResultsOffline(false);</span>
<a href="#l3.3822"></a><span id="l3.3822" class="difflineminus">-                if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug))</span>
<a href="#l3.3823"></a><span id="l3.3823" class="difflineminus">-                {</span>
<a href="#l3.3824"></a><span id="l3.3824" class="difflineplus">+                if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug)) {</span>
<a href="#l3.3825"></a><span id="l3.3825">                   // For logging the running URL.</span>
<a href="#l3.3826"></a><span id="l3.3826" class="difflineminus">-                  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.3827"></a><span id="l3.3827" class="difflineplus">+                  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl =</span>
<a href="#l3.3828"></a><span id="l3.3828" class="difflineplus">+                      do_QueryInterface(m_runningUrl);</span>
<a href="#l3.3829"></a><span id="l3.3829">                   if (mailnewsurl) {</span>
<a href="#l3.3830"></a><span id="l3.3830" class="difflineplus">+                    // clang-format off</span>
<a href="#l3.3831"></a><span id="l3.3831">                     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3832"></a><span id="l3.3832" class="difflineminus">-                      (&quot;ProcessSelectedStateURL(): Fetch parts; URL = |%s|&quot;, mailnewsurl-&gt;GetSpecOrDefault().get()));</span>
<a href="#l3.3833"></a><span id="l3.3833" class="difflineplus">+                            (&quot;ProcessSelectedStateURL(): Fetch parts; URL = |%s|&quot;,</span>
<a href="#l3.3834"></a><span id="l3.3834" class="difflineplus">+                              mailnewsurl-&gt;GetSpecOrDefault().get()));</span>
<a href="#l3.3835"></a><span id="l3.3835" class="difflineplus">+                    // clang-format on</span>
<a href="#l3.3836"></a><span id="l3.3836">                   }</span>
<a href="#l3.3837"></a><span id="l3.3837">                 }</span>
<a href="#l3.3838"></a><span id="l3.3838">                 MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3839"></a><span id="l3.3839" class="difflineminus">-                  (&quot;ProcessSelectedStateURL(): Set IMAP_CONTENT_MODIFIED_*; fetch message by parts&quot;));</span>
<a href="#l3.3840"></a><span id="l3.3840" class="difflineminus">-                SetContentModified(modType);  // This will be looked at by the cache</span>
<a href="#l3.3841"></a><span id="l3.3841" class="difflineminus">-                if (bMessageIdsAreUids)</span>
<a href="#l3.3842"></a><span id="l3.3842" class="difflineminus">-                {</span>
<a href="#l3.3843"></a><span id="l3.3843" class="difflineplus">+                        (&quot;ProcessSelectedStateURL(): Set &quot;</span>
<a href="#l3.3844"></a><span id="l3.3844" class="difflineplus">+                         &quot;IMAP_CONTENT_MODIFIED_*; fetch message by parts&quot;));</span>
<a href="#l3.3845"></a><span id="l3.3845" class="difflineplus">+                SetContentModified(</span>
<a href="#l3.3846"></a><span id="l3.3846" class="difflineplus">+                    modType);  // This will be looked at by the cache</span>
<a href="#l3.3847"></a><span id="l3.3847" class="difflineplus">+                if (bMessageIdsAreUids) {</span>
<a href="#l3.3848"></a><span id="l3.3848">                   nsCString messageIdValString(messageIdString);</span>
<a href="#l3.3849"></a><span id="l3.3849">                   messageIdValString.AppendInt(m_uidValidity);</span>
<a href="#l3.3850"></a><span id="l3.3850" class="difflineminus">-                  res = m_hostSessionList-&gt;FindShellInCacheForHost(GetImapServerKey(),</span>
<a href="#l3.3851"></a><span id="l3.3851" class="difflineminus">-                    GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.3852"></a><span id="l3.3852" class="difflineminus">-                    messageIdValString.get(), modType, getter_AddRefs(foundShell));</span>
<a href="#l3.3853"></a><span id="l3.3853" class="difflineminus">-                  if (foundShell)</span>
<a href="#l3.3854"></a><span id="l3.3854" class="difflineminus">-                  {</span>
<a href="#l3.3855"></a><span id="l3.3855" class="difflineplus">+                  res = m_hostSessionList-&gt;FindShellInCacheForHost(</span>
<a href="#l3.3856"></a><span id="l3.3856" class="difflineplus">+                      GetImapServerKey(),</span>
<a href="#l3.3857"></a><span id="l3.3857" class="difflineplus">+                      GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.3858"></a><span id="l3.3858" class="difflineplus">+                      messageIdValString.get(), modType,</span>
<a href="#l3.3859"></a><span id="l3.3859" class="difflineplus">+                      getter_AddRefs(foundShell));</span>
<a href="#l3.3860"></a><span id="l3.3860" class="difflineplus">+                  if (foundShell) {</span>
<a href="#l3.3861"></a><span id="l3.3861">                     Log(&quot;SHELL&quot;, NULL, &quot;Loading message, using cached shell.&quot;);</span>
<a href="#l3.3862"></a><span id="l3.3862">                     foundShell-&gt;SetConnection(this);</span>
<a href="#l3.3863"></a><span id="l3.3863">                     GetServerStateParser().UseCachedShell(foundShell);</span>
<a href="#l3.3864"></a><span id="l3.3864" class="difflineminus">-                    //Set the current uid in server state parser (in case it was used for new mail msgs earlier).</span>
<a href="#l3.3865"></a><span id="l3.3865" class="difflineminus">-                    GetServerStateParser().SetCurrentResponseUID(strtoul(messageIdString.get(), nullptr, 10));</span>
<a href="#l3.3866"></a><span id="l3.3866" class="difflineplus">+                    // Set the current uid in server state parser (in case it</span>
<a href="#l3.3867"></a><span id="l3.3867" class="difflineplus">+                    // was used for new mail msgs earlier).</span>
<a href="#l3.3868"></a><span id="l3.3868" class="difflineplus">+                    GetServerStateParser().SetCurrentResponseUID(</span>
<a href="#l3.3869"></a><span id="l3.3869" class="difflineplus">+                        strtoul(messageIdString.get(), nullptr, 10));</span>
<a href="#l3.3870"></a><span id="l3.3870">                     foundShell-&gt;Generate(NULL);</span>
<a href="#l3.3871"></a><span id="l3.3871">                     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3872"></a><span id="l3.3872" class="difflineminus">-                      (&quot;ProcessSelectedStateURL(): Generated parts fetch from cached shell)&quot;));</span>
<a href="#l3.3873"></a><span id="l3.3873" class="difflineplus">+                            (&quot;ProcessSelectedStateURL(): Generated parts fetch &quot;</span>
<a href="#l3.3874"></a><span id="l3.3874" class="difflineplus">+                             &quot;from cached shell)&quot;));</span>
<a href="#l3.3875"></a><span id="l3.3875">                     GetServerStateParser().UseCachedShell(NULL);</span>
<a href="#l3.3876"></a><span id="l3.3876">                   }</span>
<a href="#l3.3877"></a><span id="l3.3877">                 }</span>
<a href="#l3.3878"></a><span id="l3.3878"> </span>
<a href="#l3.3879"></a><span id="l3.3879" class="difflineminus">-                if (!foundShell)</span>
<a href="#l3.3880"></a><span id="l3.3880" class="difflineminus">-                {</span>
<a href="#l3.3881"></a><span id="l3.3881" class="difflineplus">+                if (!foundShell) {</span>
<a href="#l3.3882"></a><span id="l3.3882">                   MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3883"></a><span id="l3.3883" class="difflineminus">-                    (&quot;ProcessSelectedStateURL(): Fetch bodystructure and generated parts fetch&quot;));</span>
<a href="#l3.3884"></a><span id="l3.3884" class="difflineplus">+                          (&quot;ProcessSelectedStateURL(): Fetch bodystructure and &quot;</span>
<a href="#l3.3885"></a><span id="l3.3885" class="difflineplus">+                           &quot;generated parts fetch&quot;));</span>
<a href="#l3.3886"></a><span id="l3.3886">                   Bodystructure(messageIdString, bMessageIdsAreUids);</span>
<a href="#l3.3887"></a><span id="l3.3887">                 }</span>
<a href="#l3.3888"></a><span id="l3.3888" class="difflineminus">-              }</span>
<a href="#l3.3889"></a><span id="l3.3889" class="difflineminus">-              else</span>
<a href="#l3.3890"></a><span id="l3.3890" class="difflineminus">-              {</span>
<a href="#l3.3891"></a><span id="l3.3891" class="difflineminus">-                // Not doing bodystructure.  Fetch the whole thing, and try to do</span>
<a href="#l3.3892"></a><span id="l3.3892" class="difflineminus">-                // it in chunks.</span>
<a href="#l3.3893"></a><span id="l3.3893" class="difflineminus">-                if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug))</span>
<a href="#l3.3894"></a><span id="l3.3894" class="difflineminus">-                {</span>
<a href="#l3.3895"></a><span id="l3.3895" class="difflineplus">+              } else {</span>
<a href="#l3.3896"></a><span id="l3.3896" class="difflineplus">+                // Not doing bodystructure.  Fetch the whole thing, and try to</span>
<a href="#l3.3897"></a><span id="l3.3897" class="difflineplus">+                // do it in chunks.</span>
<a href="#l3.3898"></a><span id="l3.3898" class="difflineplus">+                if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug)) {</span>
<a href="#l3.3899"></a><span id="l3.3899">                   // For logging the running URL.</span>
<a href="#l3.3900"></a><span id="l3.3900" class="difflineminus">-                  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.3901"></a><span id="l3.3901" class="difflineminus">-                  if (mailnewsurl)</span>
<a href="#l3.3902"></a><span id="l3.3902" class="difflineminus">-                  {</span>
<a href="#l3.3903"></a><span id="l3.3903" class="difflineplus">+                  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl =</span>
<a href="#l3.3904"></a><span id="l3.3904" class="difflineplus">+                      do_QueryInterface(m_runningUrl);</span>
<a href="#l3.3905"></a><span id="l3.3905" class="difflineplus">+                  if (mailnewsurl) {</span>
<a href="#l3.3906"></a><span id="l3.3906">                     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3907"></a><span id="l3.3907" class="difflineminus">-                      (&quot;ProcessSelectedStateURL(): Fetch entire message; URL = |%s|&quot;, mailnewsurl-&gt;GetSpecOrDefault().get()));</span>
<a href="#l3.3908"></a><span id="l3.3908" class="difflineplus">+                            (&quot;ProcessSelectedStateURL(): Fetch entire message; &quot;</span>
<a href="#l3.3909"></a><span id="l3.3909" class="difflineplus">+                             &quot;URL = |%s|&quot;,</span>
<a href="#l3.3910"></a><span id="l3.3910" class="difflineplus">+                             mailnewsurl-&gt;GetSpecOrDefault().get()));</span>
<a href="#l3.3911"></a><span id="l3.3911">                   }</span>
<a href="#l3.3912"></a><span id="l3.3912">                 }</span>
<a href="#l3.3913"></a><span id="l3.3913" class="difflineplus">+                // clang-format off</span>
<a href="#l3.3914"></a><span id="l3.3914">                 MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.3915"></a><span id="l3.3915" class="difflineminus">-                  (&quot;ProcessSelectedStateURL(): Set IMAP_CONTENT_NOT MODIFIED; fetch entire message with FetchTryChunking()&quot;));</span>
<a href="#l3.3916"></a><span id="l3.3916" class="difflineplus">+                        (&quot;ProcessSelectedStateURL(): Set IMAP_CONTENT_NOT &quot;</span>
<a href="#l3.3917"></a><span id="l3.3917" class="difflineplus">+                         &quot;MODIFIED; fetch entire message with FetchTryChunking()&quot;));</span>
<a href="#l3.3918"></a><span id="l3.3918" class="difflineplus">+                // clang-format on</span>
<a href="#l3.3919"></a><span id="l3.3919">                 SetContentModified(IMAP_CONTENT_NOT_MODIFIED);</span>
<a href="#l3.3920"></a><span id="l3.3920">                 FetchTryChunking(messageIdString, whatToFetch,</span>
<a href="#l3.3921"></a><span id="l3.3921" class="difflineminus">-                  bMessageIdsAreUids, NULL, messageSize, true);</span>
<a href="#l3.3922"></a><span id="l3.3922" class="difflineplus">+                                 bMessageIdsAreUids, NULL, messageSize, true);</span>
<a href="#l3.3923"></a><span id="l3.3923">               }</span>
<a href="#l3.3924"></a><span id="l3.3924">             }</span>
<a href="#l3.3925"></a><span id="l3.3925" class="difflineminus">-            if (GetServerStateParser().LastCommandSuccessful()</span>
<a href="#l3.3926"></a><span id="l3.3926" class="difflineminus">-                &amp;&amp; m_imapAction != nsIImapUrl::nsImapMsgPreview</span>
<a href="#l3.3927"></a><span id="l3.3927" class="difflineminus">-                &amp;&amp; m_imapAction != nsIImapUrl::nsImapMsgFetchPeek)</span>
<a href="#l3.3928"></a><span id="l3.3928" class="difflineminus">-            {</span>
<a href="#l3.3929"></a><span id="l3.3929" class="difflineplus">+            if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.3930"></a><span id="l3.3930" class="difflineplus">+                m_imapAction != nsIImapUrl::nsImapMsgPreview &amp;&amp;</span>
<a href="#l3.3931"></a><span id="l3.3931" class="difflineplus">+                m_imapAction != nsIImapUrl::nsImapMsgFetchPeek) {</span>
<a href="#l3.3932"></a><span id="l3.3932">               uint32_t uid = strtoul(messageIdString.get(), nullptr, 10);</span>
<a href="#l3.3933"></a><span id="l3.3933">               int32_t index;</span>
<a href="#l3.3934"></a><span id="l3.3934">               bool foundIt;</span>
<a href="#l3.3935"></a><span id="l3.3935" class="difflineminus">-              imapMessageFlagsType flags = m_flagState-&gt;GetMessageFlagsFromUID(uid, &amp;foundIt, &amp;index);</span>
<a href="#l3.3936"></a><span id="l3.3936" class="difflineminus">-              if (foundIt)</span>
<a href="#l3.3937"></a><span id="l3.3937" class="difflineminus">-              {</span>
<a href="#l3.3938"></a><span id="l3.3938" class="difflineplus">+              imapMessageFlagsType flags =</span>
<a href="#l3.3939"></a><span id="l3.3939" class="difflineplus">+                  m_flagState-&gt;GetMessageFlagsFromUID(uid, &amp;foundIt, &amp;index);</span>
<a href="#l3.3940"></a><span id="l3.3940" class="difflineplus">+              if (foundIt) {</span>
<a href="#l3.3941"></a><span id="l3.3941">                 flags |= kImapMsgSeenFlag;</span>
<a href="#l3.3942"></a><span id="l3.3942">                 m_flagState-&gt;SetMessageFlags(index, flags);</span>
<a href="#l3.3943"></a><span id="l3.3943">               }</span>
<a href="#l3.3944"></a><span id="l3.3944">             }</span>
<a href="#l3.3945"></a><span id="l3.3945">           }</span>
<a href="#l3.3946"></a><span id="l3.3946" class="difflineminus">-        }</span>
<a href="#l3.3947"></a><span id="l3.3947" class="difflineminus">-        break;</span>
<a href="#l3.3948"></a><span id="l3.3948" class="difflineminus">-      case nsIImapUrl::nsImapExpungeFolder:</span>
<a href="#l3.3949"></a><span id="l3.3949" class="difflineminus">-        Expunge();</span>
<a href="#l3.3950"></a><span id="l3.3950" class="difflineminus">-        // note fall through to next cases.</span>
<a href="#l3.3951"></a><span id="l3.3951" class="difflineminus">-        MOZ_FALLTHROUGH;</span>
<a href="#l3.3952"></a><span id="l3.3952" class="difflineminus">-      case nsIImapUrl::nsImapSelectFolder:</span>
<a href="#l3.3953"></a><span id="l3.3953" class="difflineminus">-      case nsIImapUrl::nsImapSelectNoopFolder:</span>
<a href="#l3.3954"></a><span id="l3.3954" class="difflineminus">-        if (!moreHeadersToDownload)</span>
<a href="#l3.3955"></a><span id="l3.3955" class="difflineminus">-          ProcessMailboxUpdate(true);</span>
<a href="#l3.3956"></a><span id="l3.3956" class="difflineminus">-        break;</span>
<a href="#l3.3957"></a><span id="l3.3957" class="difflineminus">-      case nsIImapUrl::nsImapMsgHeader:</span>
<a href="#l3.3958"></a><span id="l3.3958" class="difflineminus">-        {</span>
<a href="#l3.3959"></a><span id="l3.3959" class="difflineplus">+        } break;</span>
<a href="#l3.3960"></a><span id="l3.3960" class="difflineplus">+        case nsIImapUrl::nsImapExpungeFolder:</span>
<a href="#l3.3961"></a><span id="l3.3961" class="difflineplus">+          Expunge();</span>
<a href="#l3.3962"></a><span id="l3.3962" class="difflineplus">+          // note fall through to next cases.</span>
<a href="#l3.3963"></a><span id="l3.3963" class="difflineplus">+          MOZ_FALLTHROUGH;</span>
<a href="#l3.3964"></a><span id="l3.3964" class="difflineplus">+        case nsIImapUrl::nsImapSelectFolder:</span>
<a href="#l3.3965"></a><span id="l3.3965" class="difflineplus">+        case nsIImapUrl::nsImapSelectNoopFolder:</span>
<a href="#l3.3966"></a><span id="l3.3966" class="difflineplus">+          if (!moreHeadersToDownload) ProcessMailboxUpdate(true);</span>
<a href="#l3.3967"></a><span id="l3.3967" class="difflineplus">+          break;</span>
<a href="#l3.3968"></a><span id="l3.3968" class="difflineplus">+        case nsIImapUrl::nsImapMsgHeader: {</span>
<a href="#l3.3969"></a><span id="l3.3969">           nsCString messageIds;</span>
<a href="#l3.3970"></a><span id="l3.3970">           m_runningUrl-&gt;GetListOfMessageIds(messageIds);</span>
<a href="#l3.3971"></a><span id="l3.3971"> </span>
<a href="#l3.3972"></a><span id="l3.3972" class="difflineminus">-          FetchMessage(messageIds,</span>
<a href="#l3.3973"></a><span id="l3.3973" class="difflineminus">-            kHeadersRFC822andUid);</span>
<a href="#l3.3974"></a><span id="l3.3974" class="difflineminus">-          // if we explicitly ask for headers, as opposed to getting them as a result</span>
<a href="#l3.3975"></a><span id="l3.3975" class="difflineminus">-          // of selecting the folder, or biff, send the headerFetchCompleted notification</span>
<a href="#l3.3976"></a><span id="l3.3976" class="difflineminus">-          // to flush out the header cache.</span>
<a href="#l3.3977"></a><span id="l3.3977" class="difflineplus">+          FetchMessage(messageIds, kHeadersRFC822andUid);</span>
<a href="#l3.3978"></a><span id="l3.3978" class="difflineplus">+          // if we explicitly ask for headers, as opposed to getting them as a</span>
<a href="#l3.3979"></a><span id="l3.3979" class="difflineplus">+          // result of selecting the folder, or biff, send the</span>
<a href="#l3.3980"></a><span id="l3.3980" class="difflineplus">+          // headerFetchCompleted notification to flush out the header cache.</span>
<a href="#l3.3981"></a><span id="l3.3981">           HeaderFetchCompleted();</span>
<a href="#l3.3982"></a><span id="l3.3982" class="difflineminus">-        }</span>
<a href="#l3.3983"></a><span id="l3.3983" class="difflineminus">-        break;</span>
<a href="#l3.3984"></a><span id="l3.3984" class="difflineminus">-      case nsIImapUrl::nsImapSearch:</span>
<a href="#l3.3985"></a><span id="l3.3985" class="difflineminus">-        {</span>
<a href="#l3.3986"></a><span id="l3.3986" class="difflineplus">+        } break;</span>
<a href="#l3.3987"></a><span id="l3.3987" class="difflineplus">+        case nsIImapUrl::nsImapSearch: {</span>
<a href="#l3.3988"></a><span id="l3.3988">           nsAutoCString searchCriteriaString;</span>
<a href="#l3.3989"></a><span id="l3.3989" class="difflineminus">-          m_runningUrl-&gt;CreateSearchCriteriaString(getter_Copies(searchCriteriaString));</span>
<a href="#l3.3990"></a><span id="l3.3990" class="difflineplus">+          m_runningUrl-&gt;CreateSearchCriteriaString(</span>
<a href="#l3.3991"></a><span id="l3.3991" class="difflineplus">+              getter_Copies(searchCriteriaString));</span>
<a href="#l3.3992"></a><span id="l3.3992">           Search(searchCriteriaString.get(), bMessageIdsAreUids);</span>
<a href="#l3.3993"></a><span id="l3.3993">           // drop the results on the floor for now</span>
<a href="#l3.3994"></a><span id="l3.3994" class="difflineminus">-        }</span>
<a href="#l3.3995"></a><span id="l3.3995" class="difflineminus">-        break;</span>
<a href="#l3.3996"></a><span id="l3.3996" class="difflineminus">-      case nsIImapUrl::nsImapUserDefinedMsgCommand:</span>
<a href="#l3.3997"></a><span id="l3.3997" class="difflineminus">-        {</span>
<a href="#l3.3998"></a><span id="l3.3998" class="difflineplus">+        } break;</span>
<a href="#l3.3999"></a><span id="l3.3999" class="difflineplus">+        case nsIImapUrl::nsImapUserDefinedMsgCommand: {</span>
<a href="#l3.4000"></a><span id="l3.4000">           nsCString messageIdString;</span>
<a href="#l3.4001"></a><span id="l3.4001">           nsCString command;</span>
<a href="#l3.4002"></a><span id="l3.4002"> </span>
<a href="#l3.4003"></a><span id="l3.4003">           m_runningUrl-&gt;GetCommand(command);</span>
<a href="#l3.4004"></a><span id="l3.4004">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4005"></a><span id="l3.4005">           IssueUserDefinedMsgCommand(command.get(), messageIdString.get());</span>
<a href="#l3.4006"></a><span id="l3.4006" class="difflineminus">-        }</span>
<a href="#l3.4007"></a><span id="l3.4007" class="difflineminus">-        break;</span>
<a href="#l3.4008"></a><span id="l3.4008" class="difflineminus">-      case nsIImapUrl::nsImapUserDefinedFetchAttribute:</span>
<a href="#l3.4009"></a><span id="l3.4009" class="difflineminus">-        {</span>
<a href="#l3.4010"></a><span id="l3.4010" class="difflineplus">+        } break;</span>
<a href="#l3.4011"></a><span id="l3.4011" class="difflineplus">+        case nsIImapUrl::nsImapUserDefinedFetchAttribute: {</span>
<a href="#l3.4012"></a><span id="l3.4012">           nsCString messageIdString;</span>
<a href="#l3.4013"></a><span id="l3.4013">           nsCString attribute;</span>
<a href="#l3.4014"></a><span id="l3.4014"> </span>
<a href="#l3.4015"></a><span id="l3.4015">           m_runningUrl-&gt;GetCustomAttributeToFetch(attribute);</span>
<a href="#l3.4016"></a><span id="l3.4016">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4017"></a><span id="l3.4017">           FetchMsgAttribute(messageIdString, attribute);</span>
<a href="#l3.4018"></a><span id="l3.4018" class="difflineminus">-        }</span>
<a href="#l3.4019"></a><span id="l3.4019" class="difflineminus">-        break;</span>
<a href="#l3.4020"></a><span id="l3.4020" class="difflineminus">-      case nsIImapUrl::nsImapMsgStoreCustomKeywords:</span>
<a href="#l3.4021"></a><span id="l3.4021" class="difflineminus">-        {</span>
<a href="#l3.4022"></a><span id="l3.4022" class="difflineplus">+        } break;</span>
<a href="#l3.4023"></a><span id="l3.4023" class="difflineplus">+        case nsIImapUrl::nsImapMsgStoreCustomKeywords: {</span>
<a href="#l3.4024"></a><span id="l3.4024">           // If the server doesn't support user defined flags, don't try to</span>
<a href="#l3.4025"></a><span id="l3.4025">           // define/set new ones. But if this is an attempt by TB to set or</span>
<a href="#l3.4026"></a><span id="l3.4026">           // reset flags &quot;Junk&quot; or &quot;NonJunk&quot;, change &quot;Junk&quot; or &quot;NonJunk&quot; to</span>
<a href="#l3.4027"></a><span id="l3.4027">           // &quot;$Junk&quot; or &quot;$NotJunk&quot; respectively and store the modified flag</span>
<a href="#l3.4028"></a><span id="l3.4028">           // name if the server doesn't support storing user defined flags</span>
<a href="#l3.4029"></a><span id="l3.4029">           // and the server does allow storing the almost-standard flag names</span>
<a href="#l3.4030"></a><span id="l3.4030">           // &quot;$Junk&quot; and &quot;$NotJunk&quot;. Yahoo imap server is an example of this.</span>
<a href="#l3.4031"></a><span id="l3.4031">           uint16_t userFlags = 0;</span>
<a href="#l3.4032"></a><span id="l3.4032" class="difflineat">@@ -3031,1313 +2824,1182 @@ void nsImapProtocol::ProcessSelectedStat</span>
<a href="#l3.4033"></a><span id="l3.4033"> </span>
<a href="#l3.4034"></a><span id="l3.4034">           nsCString messageIdString;</span>
<a href="#l3.4035"></a><span id="l3.4035">           nsCString addFlags;</span>
<a href="#l3.4036"></a><span id="l3.4036">           nsCString subtractFlags;</span>
<a href="#l3.4037"></a><span id="l3.4037"> </span>
<a href="#l3.4038"></a><span id="l3.4038">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4039"></a><span id="l3.4039">           m_runningUrl-&gt;GetCustomAddFlags(addFlags);</span>
<a href="#l3.4040"></a><span id="l3.4040">           m_runningUrl-&gt;GetCustomSubtractFlags(subtractFlags);</span>
<a href="#l3.4041"></a><span id="l3.4041" class="difflineminus">-          if (!addFlags.IsEmpty())</span>
<a href="#l3.4042"></a><span id="l3.4042" class="difflineminus">-          {</span>
<a href="#l3.4043"></a><span id="l3.4043" class="difflineminus">-            if (!userDefinedSettable)</span>
<a href="#l3.4044"></a><span id="l3.4044" class="difflineminus">-            {</span>
<a href="#l3.4045"></a><span id="l3.4045" class="difflineminus">-              if (stdJunkOk)</span>
<a href="#l3.4046"></a><span id="l3.4046" class="difflineminus">-              {</span>
<a href="#l3.4047"></a><span id="l3.4047" class="difflineplus">+          if (!addFlags.IsEmpty()) {</span>
<a href="#l3.4048"></a><span id="l3.4048" class="difflineplus">+            if (!userDefinedSettable) {</span>
<a href="#l3.4049"></a><span id="l3.4049" class="difflineplus">+              if (stdJunkOk) {</span>
<a href="#l3.4050"></a><span id="l3.4050">                 if (addFlags.EqualsIgnoreCase(&quot;junk&quot;))</span>
<a href="#l3.4051"></a><span id="l3.4051">                   addFlags = &quot;$Junk&quot;;</span>
<a href="#l3.4052"></a><span id="l3.4052">                 else if (addFlags.EqualsIgnoreCase(&quot;nonjunk&quot;))</span>
<a href="#l3.4053"></a><span id="l3.4053">                   addFlags = &quot;$NotJunk&quot;;</span>
<a href="#l3.4054"></a><span id="l3.4054">                 else</span>
<a href="#l3.4055"></a><span id="l3.4055">                   break;</span>
<a href="#l3.4056"></a><span id="l3.4056" class="difflineminus">-              }</span>
<a href="#l3.4057"></a><span id="l3.4057" class="difflineminus">-              else</span>
<a href="#l3.4058"></a><span id="l3.4058" class="difflineplus">+              } else</span>
<a href="#l3.4059"></a><span id="l3.4059">                 break;</span>
<a href="#l3.4060"></a><span id="l3.4060">             }</span>
<a href="#l3.4061"></a><span id="l3.4061">             nsAutoCString storeString(&quot;+FLAGS (&quot;);</span>
<a href="#l3.4062"></a><span id="l3.4062">             storeString.Append(addFlags);</span>
<a href="#l3.4063"></a><span id="l3.4063">             storeString.Append(')');</span>
<a href="#l3.4064"></a><span id="l3.4064">             Store(messageIdString, storeString.get(), true);</span>
<a href="#l3.4065"></a><span id="l3.4065">           }</span>
<a href="#l3.4066"></a><span id="l3.4066" class="difflineminus">-          if (!subtractFlags.IsEmpty())</span>
<a href="#l3.4067"></a><span id="l3.4067" class="difflineminus">-          {</span>
<a href="#l3.4068"></a><span id="l3.4068" class="difflineminus">-            if (!userDefinedSettable)</span>
<a href="#l3.4069"></a><span id="l3.4069" class="difflineminus">-            {</span>
<a href="#l3.4070"></a><span id="l3.4070" class="difflineminus">-              if (stdJunkOk)</span>
<a href="#l3.4071"></a><span id="l3.4071" class="difflineminus">-              {</span>
<a href="#l3.4072"></a><span id="l3.4072" class="difflineplus">+          if (!subtractFlags.IsEmpty()) {</span>
<a href="#l3.4073"></a><span id="l3.4073" class="difflineplus">+            if (!userDefinedSettable) {</span>
<a href="#l3.4074"></a><span id="l3.4074" class="difflineplus">+              if (stdJunkOk) {</span>
<a href="#l3.4075"></a><span id="l3.4075">                 if (subtractFlags.EqualsIgnoreCase(&quot;junk&quot;))</span>
<a href="#l3.4076"></a><span id="l3.4076">                   subtractFlags = &quot;$Junk&quot;;</span>
<a href="#l3.4077"></a><span id="l3.4077">                 else if (subtractFlags.EqualsIgnoreCase(&quot;nonjunk&quot;))</span>
<a href="#l3.4078"></a><span id="l3.4078">                   subtractFlags = &quot;$NotJunk&quot;;</span>
<a href="#l3.4079"></a><span id="l3.4079">                 else</span>
<a href="#l3.4080"></a><span id="l3.4080">                   break;</span>
<a href="#l3.4081"></a><span id="l3.4081" class="difflineminus">-              }</span>
<a href="#l3.4082"></a><span id="l3.4082" class="difflineminus">-              else</span>
<a href="#l3.4083"></a><span id="l3.4083" class="difflineplus">+              } else</span>
<a href="#l3.4084"></a><span id="l3.4084">                 break;</span>
<a href="#l3.4085"></a><span id="l3.4085">             }</span>
<a href="#l3.4086"></a><span id="l3.4086">             nsAutoCString storeString(&quot;-FLAGS (&quot;);</span>
<a href="#l3.4087"></a><span id="l3.4087">             storeString.Append(subtractFlags);</span>
<a href="#l3.4088"></a><span id="l3.4088">             storeString.Append(')');</span>
<a href="#l3.4089"></a><span id="l3.4089">             Store(messageIdString, storeString.get(), true);</span>
<a href="#l3.4090"></a><span id="l3.4090">           }</span>
<a href="#l3.4091"></a><span id="l3.4091" class="difflineminus">-        }</span>
<a href="#l3.4092"></a><span id="l3.4092" class="difflineminus">-        break;</span>
<a href="#l3.4093"></a><span id="l3.4093" class="difflineminus">-      case nsIImapUrl::nsImapDeleteMsg:</span>
<a href="#l3.4094"></a><span id="l3.4094" class="difflineminus">-        {</span>
<a href="#l3.4095"></a><span id="l3.4095" class="difflineplus">+        } break;</span>
<a href="#l3.4096"></a><span id="l3.4096" class="difflineplus">+        case nsIImapUrl::nsImapDeleteMsg: {</span>
<a href="#l3.4097"></a><span id="l3.4097">           nsCString messageIdString;</span>
<a href="#l3.4098"></a><span id="l3.4098">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4099"></a><span id="l3.4099"> </span>
<a href="#l3.4100"></a><span id="l3.4100" class="difflineminus">-          ProgressEventFunctionUsingName(HandlingMultipleMessages(messageIdString) ?</span>
<a href="#l3.4101"></a><span id="l3.4101" class="difflineminus">-                                         &quot;imapDeletingMessages&quot; :</span>
<a href="#l3.4102"></a><span id="l3.4102" class="difflineminus">-                                         &quot;imapDeletingMessage&quot;);</span>
<a href="#l3.4103"></a><span id="l3.4103" class="difflineminus">-</span>
<a href="#l3.4104"></a><span id="l3.4104" class="difflineminus">-          Store(messageIdString, &quot;+FLAGS (\\Deleted)&quot;,  bMessageIdsAreUids);</span>
<a href="#l3.4105"></a><span id="l3.4105" class="difflineminus">-</span>
<a href="#l3.4106"></a><span id="l3.4106" class="difflineminus">-          if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.4107"></a><span id="l3.4107" class="difflineminus">-          {</span>
<a href="#l3.4108"></a><span id="l3.4108" class="difflineminus">-            //delete_message_struct *deleteMsg = (delete_message_struct *) PR_Malloc (sizeof(delete_message_struct));</span>
<a href="#l3.4109"></a><span id="l3.4109" class="difflineplus">+          ProgressEventFunctionUsingName(</span>
<a href="#l3.4110"></a><span id="l3.4110" class="difflineplus">+              HandlingMultipleMessages(messageIdString)</span>
<a href="#l3.4111"></a><span id="l3.4111" class="difflineplus">+                  ? &quot;imapDeletingMessages&quot;</span>
<a href="#l3.4112"></a><span id="l3.4112" class="difflineplus">+                  : &quot;imapDeletingMessage&quot;);</span>
<a href="#l3.4113"></a><span id="l3.4113" class="difflineplus">+</span>
<a href="#l3.4114"></a><span id="l3.4114" class="difflineplus">+          Store(messageIdString, &quot;+FLAGS (\\Deleted)&quot;, bMessageIdsAreUids);</span>
<a href="#l3.4115"></a><span id="l3.4115" class="difflineplus">+</span>
<a href="#l3.4116"></a><span id="l3.4116" class="difflineplus">+          if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.4117"></a><span id="l3.4117" class="difflineplus">+            // delete_message_struct *deleteMsg = (delete_message_struct *)</span>
<a href="#l3.4118"></a><span id="l3.4118" class="difflineplus">+            // PR_Malloc (sizeof(delete_message_struct));</span>
<a href="#l3.4119"></a><span id="l3.4119">             // convert name back from utf7</span>
<a href="#l3.4120"></a><span id="l3.4120">             nsCString canonicalName;</span>
<a href="#l3.4121"></a><span id="l3.4121" class="difflineminus">-            const char *selectedMailboxName = GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.4122"></a><span id="l3.4122" class="difflineminus">-            if (selectedMailboxName)</span>
<a href="#l3.4123"></a><span id="l3.4123" class="difflineminus">-            {</span>
<a href="#l3.4124"></a><span id="l3.4124" class="difflineminus">-              m_runningUrl-&gt;AllocateCanonicalPath(selectedMailboxName,</span>
<a href="#l3.4125"></a><span id="l3.4125" class="difflineminus">-                kOnlineHierarchySeparatorUnknown, getter_Copies(canonicalName));</span>
<a href="#l3.4126"></a><span id="l3.4126" class="difflineplus">+            const char *selectedMailboxName =</span>
<a href="#l3.4127"></a><span id="l3.4127" class="difflineplus">+                GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.4128"></a><span id="l3.4128" class="difflineplus">+            if (selectedMailboxName) {</span>
<a href="#l3.4129"></a><span id="l3.4129" class="difflineplus">+              m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.4130"></a><span id="l3.4130" class="difflineplus">+                  selectedMailboxName, kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.4131"></a><span id="l3.4131" class="difflineplus">+                  getter_Copies(canonicalName));</span>
<a href="#l3.4132"></a><span id="l3.4132">             }</span>
<a href="#l3.4133"></a><span id="l3.4133"> </span>
<a href="#l3.4134"></a><span id="l3.4134">             if (m_imapMessageSink)</span>
<a href="#l3.4135"></a><span id="l3.4135" class="difflineminus">-              m_imapMessageSink-&gt;NotifyMessageDeleted(canonicalName.get(), false, messageIdString.get());</span>
<a href="#l3.4136"></a><span id="l3.4136" class="difflineplus">+              m_imapMessageSink-&gt;NotifyMessageDeleted(</span>
<a href="#l3.4137"></a><span id="l3.4137" class="difflineplus">+                  canonicalName.get(), false, messageIdString.get());</span>
<a href="#l3.4138"></a><span id="l3.4138">             // notice we don't wait for this to finish...</span>
<a href="#l3.4139"></a><span id="l3.4139" class="difflineminus">-          }</span>
<a href="#l3.4140"></a><span id="l3.4140" class="difflineminus">-          else</span>
<a href="#l3.4141"></a><span id="l3.4141" class="difflineplus">+          } else</span>
<a href="#l3.4142"></a><span id="l3.4142">             HandleMemoryFailure();</span>
<a href="#l3.4143"></a><span id="l3.4143" class="difflineminus">-        }</span>
<a href="#l3.4144"></a><span id="l3.4144" class="difflineminus">-        break;</span>
<a href="#l3.4145"></a><span id="l3.4145" class="difflineminus">-      case nsIImapUrl::nsImapDeleteFolderAndMsgs:</span>
<a href="#l3.4146"></a><span id="l3.4146" class="difflineminus">-        DeleteFolderAndMsgs(mailboxName.get());</span>
<a href="#l3.4147"></a><span id="l3.4147" class="difflineminus">-        break;</span>
<a href="#l3.4148"></a><span id="l3.4148" class="difflineminus">-      case nsIImapUrl::nsImapDeleteAllMsgs:</span>
<a href="#l3.4149"></a><span id="l3.4149" class="difflineminus">-        {</span>
<a href="#l3.4150"></a><span id="l3.4150" class="difflineplus">+        } break;</span>
<a href="#l3.4151"></a><span id="l3.4151" class="difflineplus">+        case nsIImapUrl::nsImapDeleteFolderAndMsgs:</span>
<a href="#l3.4152"></a><span id="l3.4152" class="difflineplus">+          DeleteFolderAndMsgs(mailboxName.get());</span>
<a href="#l3.4153"></a><span id="l3.4153" class="difflineplus">+          break;</span>
<a href="#l3.4154"></a><span id="l3.4154" class="difflineplus">+        case nsIImapUrl::nsImapDeleteAllMsgs: {</span>
<a href="#l3.4155"></a><span id="l3.4155">           uint32_t numberOfMessages = GetServerStateParser().NumberOfMessages();</span>
<a href="#l3.4156"></a><span id="l3.4156" class="difflineminus">-          if (numberOfMessages)</span>
<a href="#l3.4157"></a><span id="l3.4157" class="difflineminus">-          {</span>
<a href="#l3.4158"></a><span id="l3.4158" class="difflineplus">+          if (numberOfMessages) {</span>
<a href="#l3.4159"></a><span id="l3.4159">             Store(NS_LITERAL_CSTRING(&quot;1:*&quot;), &quot;+FLAGS.SILENT (\\Deleted)&quot;,</span>
<a href="#l3.4160"></a><span id="l3.4160" class="difflineminus">-              false);  // use sequence #'s</span>
<a href="#l3.4161"></a><span id="l3.4161" class="difflineplus">+                  false);  // use sequence #'s</span>
<a href="#l3.4162"></a><span id="l3.4162"> </span>
<a href="#l3.4163"></a><span id="l3.4163">             if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.4164"></a><span id="l3.4164" class="difflineminus">-              Expunge();      // expunge messages with deleted flag</span>
<a href="#l3.4165"></a><span id="l3.4165" class="difflineminus">-            if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.4166"></a><span id="l3.4166" class="difflineminus">-            {</span>
<a href="#l3.4167"></a><span id="l3.4167" class="difflineplus">+              Expunge();  // expunge messages with deleted flag</span>
<a href="#l3.4168"></a><span id="l3.4168" class="difflineplus">+            if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.4169"></a><span id="l3.4169">               // convert name back from utf7</span>
<a href="#l3.4170"></a><span id="l3.4170">               nsCString canonicalName;</span>
<a href="#l3.4171"></a><span id="l3.4171" class="difflineminus">-              const char *selectedMailboxName = GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.4172"></a><span id="l3.4172" class="difflineminus">-              if (selectedMailboxName )</span>
<a href="#l3.4173"></a><span id="l3.4173" class="difflineminus">-              {</span>
<a href="#l3.4174"></a><span id="l3.4174" class="difflineminus">-                m_runningUrl-&gt;AllocateCanonicalPath(selectedMailboxName,</span>
<a href="#l3.4175"></a><span id="l3.4175" class="difflineminus">-                  kOnlineHierarchySeparatorUnknown, getter_Copies(canonicalName));</span>
<a href="#l3.4176"></a><span id="l3.4176" class="difflineplus">+              const char *selectedMailboxName =</span>
<a href="#l3.4177"></a><span id="l3.4177" class="difflineplus">+                  GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.4178"></a><span id="l3.4178" class="difflineplus">+              if (selectedMailboxName) {</span>
<a href="#l3.4179"></a><span id="l3.4179" class="difflineplus">+                m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.4180"></a><span id="l3.4180" class="difflineplus">+                    selectedMailboxName, kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.4181"></a><span id="l3.4181" class="difflineplus">+                    getter_Copies(canonicalName));</span>
<a href="#l3.4182"></a><span id="l3.4182">               }</span>
<a href="#l3.4183"></a><span id="l3.4183"> </span>
<a href="#l3.4184"></a><span id="l3.4184">               if (m_imapMessageSink)</span>
<a href="#l3.4185"></a><span id="l3.4185" class="difflineminus">-                m_imapMessageSink-&gt;NotifyMessageDeleted(canonicalName.get(), true, nullptr);</span>
<a href="#l3.4186"></a><span id="l3.4186" class="difflineplus">+                m_imapMessageSink-&gt;NotifyMessageDeleted(canonicalName.get(),</span>
<a href="#l3.4187"></a><span id="l3.4187" class="difflineplus">+                                                        true, nullptr);</span>
<a href="#l3.4188"></a><span id="l3.4188">             }</span>
<a href="#l3.4189"></a><span id="l3.4189" class="difflineminus">-</span>
<a href="#l3.4190"></a><span id="l3.4190">           }</span>
<a href="#l3.4191"></a><span id="l3.4191">           bool deleteSelf = false;</span>
<a href="#l3.4192"></a><span id="l3.4192">           DeleteSubFolders(mailboxName.get(), deleteSelf);  // don't delete self</span>
<a href="#l3.4193"></a><span id="l3.4193" class="difflineminus">-        }</span>
<a href="#l3.4194"></a><span id="l3.4194" class="difflineminus">-        break;</span>
<a href="#l3.4195"></a><span id="l3.4195" class="difflineminus">-      case nsIImapUrl::nsImapAppendDraftFromFile:</span>
<a href="#l3.4196"></a><span id="l3.4196" class="difflineminus">-        {</span>
<a href="#l3.4197"></a><span id="l3.4197" class="difflineplus">+        } break;</span>
<a href="#l3.4198"></a><span id="l3.4198" class="difflineplus">+        case nsIImapUrl::nsImapAppendDraftFromFile: {</span>
<a href="#l3.4199"></a><span id="l3.4199">           OnAppendMsgFromFile();</span>
<a href="#l3.4200"></a><span id="l3.4200" class="difflineminus">-        }</span>
<a href="#l3.4201"></a><span id="l3.4201" class="difflineminus">-        break;</span>
<a href="#l3.4202"></a><span id="l3.4202" class="difflineminus">-      case nsIImapUrl::nsImapAddMsgFlags:</span>
<a href="#l3.4203"></a><span id="l3.4203" class="difflineminus">-        {</span>
<a href="#l3.4204"></a><span id="l3.4204" class="difflineplus">+        } break;</span>
<a href="#l3.4205"></a><span id="l3.4205" class="difflineplus">+        case nsIImapUrl::nsImapAddMsgFlags: {</span>
<a href="#l3.4206"></a><span id="l3.4206">           nsCString messageIdString;</span>
<a href="#l3.4207"></a><span id="l3.4207">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4208"></a><span id="l3.4208"> </span>
<a href="#l3.4209"></a><span id="l3.4209" class="difflineminus">-          ProcessStoreFlags(messageIdString, bMessageIdsAreUids,</span>
<a href="#l3.4210"></a><span id="l3.4210" class="difflineminus">-            msgFlags, true);</span>
<a href="#l3.4211"></a><span id="l3.4211" class="difflineminus">-        }</span>
<a href="#l3.4212"></a><span id="l3.4212" class="difflineminus">-        break;</span>
<a href="#l3.4213"></a><span id="l3.4213" class="difflineminus">-      case nsIImapUrl::nsImapSubtractMsgFlags:</span>
<a href="#l3.4214"></a><span id="l3.4214" class="difflineminus">-        {</span>
<a href="#l3.4215"></a><span id="l3.4215" class="difflineplus">+          ProcessStoreFlags(messageIdString, bMessageIdsAreUids, msgFlags,</span>
<a href="#l3.4216"></a><span id="l3.4216" class="difflineplus">+                            true);</span>
<a href="#l3.4217"></a><span id="l3.4217" class="difflineplus">+        } break;</span>
<a href="#l3.4218"></a><span id="l3.4218" class="difflineplus">+        case nsIImapUrl::nsImapSubtractMsgFlags: {</span>
<a href="#l3.4219"></a><span id="l3.4219">           nsCString messageIdString;</span>
<a href="#l3.4220"></a><span id="l3.4220">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4221"></a><span id="l3.4221"> </span>
<a href="#l3.4222"></a><span id="l3.4222" class="difflineminus">-          ProcessStoreFlags(messageIdString, bMessageIdsAreUids,</span>
<a href="#l3.4223"></a><span id="l3.4223" class="difflineminus">-            msgFlags, false);</span>
<a href="#l3.4224"></a><span id="l3.4224" class="difflineminus">-        }</span>
<a href="#l3.4225"></a><span id="l3.4225" class="difflineminus">-        break;</span>
<a href="#l3.4226"></a><span id="l3.4226" class="difflineminus">-      case nsIImapUrl::nsImapSetMsgFlags:</span>
<a href="#l3.4227"></a><span id="l3.4227" class="difflineminus">-        {</span>
<a href="#l3.4228"></a><span id="l3.4228" class="difflineplus">+          ProcessStoreFlags(messageIdString, bMessageIdsAreUids, msgFlags,</span>
<a href="#l3.4229"></a><span id="l3.4229" class="difflineplus">+                            false);</span>
<a href="#l3.4230"></a><span id="l3.4230" class="difflineplus">+        } break;</span>
<a href="#l3.4231"></a><span id="l3.4231" class="difflineplus">+        case nsIImapUrl::nsImapSetMsgFlags: {</span>
<a href="#l3.4232"></a><span id="l3.4232">           nsCString messageIdString;</span>
<a href="#l3.4233"></a><span id="l3.4233">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4234"></a><span id="l3.4234"> </span>
<a href="#l3.4235"></a><span id="l3.4235" class="difflineminus">-          ProcessStoreFlags(messageIdString, bMessageIdsAreUids,</span>
<a href="#l3.4236"></a><span id="l3.4236" class="difflineminus">-            msgFlags, true);</span>
<a href="#l3.4237"></a><span id="l3.4237" class="difflineminus">-          ProcessStoreFlags(messageIdString, bMessageIdsAreUids,</span>
<a href="#l3.4238"></a><span id="l3.4238" class="difflineminus">-            ~msgFlags, false);</span>
<a href="#l3.4239"></a><span id="l3.4239" class="difflineminus">-        }</span>
<a href="#l3.4240"></a><span id="l3.4240" class="difflineminus">-        break;</span>
<a href="#l3.4241"></a><span id="l3.4241" class="difflineminus">-      case nsIImapUrl::nsImapBiff:</span>
<a href="#l3.4242"></a><span id="l3.4242" class="difflineminus">-        PeriodicBiff();</span>
<a href="#l3.4243"></a><span id="l3.4243" class="difflineminus">-        break;</span>
<a href="#l3.4244"></a><span id="l3.4244" class="difflineminus">-      case nsIImapUrl::nsImapOnlineCopy:</span>
<a href="#l3.4245"></a><span id="l3.4245" class="difflineminus">-      case nsIImapUrl::nsImapOnlineMove:</span>
<a href="#l3.4246"></a><span id="l3.4246" class="difflineminus">-        {</span>
<a href="#l3.4247"></a><span id="l3.4247" class="difflineplus">+          ProcessStoreFlags(messageIdString, bMessageIdsAreUids, msgFlags,</span>
<a href="#l3.4248"></a><span id="l3.4248" class="difflineplus">+                            true);</span>
<a href="#l3.4249"></a><span id="l3.4249" class="difflineplus">+          ProcessStoreFlags(messageIdString, bMessageIdsAreUids, ~msgFlags,</span>
<a href="#l3.4250"></a><span id="l3.4250" class="difflineplus">+                            false);</span>
<a href="#l3.4251"></a><span id="l3.4251" class="difflineplus">+        } break;</span>
<a href="#l3.4252"></a><span id="l3.4252" class="difflineplus">+        case nsIImapUrl::nsImapBiff:</span>
<a href="#l3.4253"></a><span id="l3.4253" class="difflineplus">+          PeriodicBiff();</span>
<a href="#l3.4254"></a><span id="l3.4254" class="difflineplus">+          break;</span>
<a href="#l3.4255"></a><span id="l3.4255" class="difflineplus">+        case nsIImapUrl::nsImapOnlineCopy:</span>
<a href="#l3.4256"></a><span id="l3.4256" class="difflineplus">+        case nsIImapUrl::nsImapOnlineMove: {</span>
<a href="#l3.4257"></a><span id="l3.4257">           nsCString messageIdString;</span>
<a href="#l3.4258"></a><span id="l3.4258">           m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4259"></a><span id="l3.4259" class="difflineminus">-          char *destinationMailbox = OnCreateServerDestinationFolderPathString();</span>
<a href="#l3.4260"></a><span id="l3.4260" class="difflineminus">-</span>
<a href="#l3.4261"></a><span id="l3.4261" class="difflineminus">-          if (destinationMailbox)</span>
<a href="#l3.4262"></a><span id="l3.4262" class="difflineminus">-          {</span>
<a href="#l3.4263"></a><span id="l3.4263" class="difflineminus">-            if (m_imapAction == nsIImapUrl::nsImapOnlineMove)</span>
<a href="#l3.4264"></a><span id="l3.4264" class="difflineminus">-            {</span>
<a href="#l3.4265"></a><span id="l3.4265" class="difflineplus">+          char *destinationMailbox =</span>
<a href="#l3.4266"></a><span id="l3.4266" class="difflineplus">+              OnCreateServerDestinationFolderPathString();</span>
<a href="#l3.4267"></a><span id="l3.4267" class="difflineplus">+</span>
<a href="#l3.4268"></a><span id="l3.4268" class="difflineplus">+          if (destinationMailbox) {</span>
<a href="#l3.4269"></a><span id="l3.4269" class="difflineplus">+            if (m_imapAction == nsIImapUrl::nsImapOnlineMove) {</span>
<a href="#l3.4270"></a><span id="l3.4270">               if (HandlingMultipleMessages(messageIdString))</span>
<a href="#l3.4271"></a><span id="l3.4271" class="difflineminus">-                ProgressEventFunctionUsingNameWithString(&quot;imapMovingMessages&quot;, destinationMailbox);</span>
<a href="#l3.4272"></a><span id="l3.4272" class="difflineplus">+                ProgressEventFunctionUsingNameWithString(&quot;imapMovingMessages&quot;,</span>
<a href="#l3.4273"></a><span id="l3.4273" class="difflineplus">+                                                         destinationMailbox);</span>
<a href="#l3.4274"></a><span id="l3.4274">               else</span>
<a href="#l3.4275"></a><span id="l3.4275" class="difflineminus">-                ProgressEventFunctionUsingNameWithString(&quot;imapMovingMessage&quot;, destinationMailbox);</span>
<a href="#l3.4276"></a><span id="l3.4276" class="difflineminus">-            }</span>
<a href="#l3.4277"></a><span id="l3.4277" class="difflineminus">-            else {</span>
<a href="#l3.4278"></a><span id="l3.4278" class="difflineplus">+                ProgressEventFunctionUsingNameWithString(&quot;imapMovingMessage&quot;,</span>
<a href="#l3.4279"></a><span id="l3.4279" class="difflineplus">+                                                         destinationMailbox);</span>
<a href="#l3.4280"></a><span id="l3.4280" class="difflineplus">+            } else {</span>
<a href="#l3.4281"></a><span id="l3.4281">               if (HandlingMultipleMessages(messageIdString))</span>
<a href="#l3.4282"></a><span id="l3.4282" class="difflineminus">-                ProgressEventFunctionUsingNameWithString(&quot;imapCopyingMessages&quot;, destinationMailbox);</span>
<a href="#l3.4283"></a><span id="l3.4283" class="difflineplus">+                ProgressEventFunctionUsingNameWithString(&quot;imapCopyingMessages&quot;,</span>
<a href="#l3.4284"></a><span id="l3.4284" class="difflineplus">+                                                         destinationMailbox);</span>
<a href="#l3.4285"></a><span id="l3.4285">               else</span>
<a href="#l3.4286"></a><span id="l3.4286" class="difflineminus">-                ProgressEventFunctionUsingNameWithString(&quot;imapCopyingMessage&quot;, destinationMailbox);</span>
<a href="#l3.4287"></a><span id="l3.4287" class="difflineplus">+                ProgressEventFunctionUsingNameWithString(&quot;imapCopyingMessage&quot;,</span>
<a href="#l3.4288"></a><span id="l3.4288" class="difflineplus">+                                                         destinationMailbox);</span>
<a href="#l3.4289"></a><span id="l3.4289">             }</span>
<a href="#l3.4290"></a><span id="l3.4290">             Copy(messageIdString.get(), destinationMailbox, bMessageIdsAreUids);</span>
<a href="#l3.4291"></a><span id="l3.4291" class="difflineminus">-            PR_FREEIF( destinationMailbox);</span>
<a href="#l3.4292"></a><span id="l3.4292" class="difflineplus">+            PR_FREEIF(destinationMailbox);</span>
<a href="#l3.4293"></a><span id="l3.4293">             ImapOnlineCopyState copyState;</span>
<a href="#l3.4294"></a><span id="l3.4294">             if (DeathSignalReceived())</span>
<a href="#l3.4295"></a><span id="l3.4295">               copyState = ImapOnlineCopyStateType::kInterruptedState;</span>
<a href="#l3.4296"></a><span id="l3.4296">             else</span>
<a href="#l3.4297"></a><span id="l3.4297" class="difflineminus">-              copyState = GetServerStateParser().LastCommandSuccessful() ?</span>
<a href="#l3.4298"></a><span id="l3.4298" class="difflineminus">-              (ImapOnlineCopyState) ImapOnlineCopyStateType::kSuccessfulCopy :</span>
<a href="#l3.4299"></a><span id="l3.4299" class="difflineminus">-            (ImapOnlineCopyState) ImapOnlineCopyStateType::kFailedCopy;</span>
<a href="#l3.4300"></a><span id="l3.4300" class="difflineplus">+              copyState = GetServerStateParser().LastCommandSuccessful()</span>
<a href="#l3.4301"></a><span id="l3.4301" class="difflineplus">+                              ? (ImapOnlineCopyState)</span>
<a href="#l3.4302"></a><span id="l3.4302" class="difflineplus">+                                    ImapOnlineCopyStateType::kSuccessfulCopy</span>
<a href="#l3.4303"></a><span id="l3.4303" class="difflineplus">+                              : (ImapOnlineCopyState)</span>
<a href="#l3.4304"></a><span id="l3.4304" class="difflineplus">+                                    ImapOnlineCopyStateType::kFailedCopy;</span>
<a href="#l3.4305"></a><span id="l3.4305">             if (m_imapMailFolderSink)</span>
<a href="#l3.4306"></a><span id="l3.4306">               m_imapMailFolderSink-&gt;OnlineCopyCompleted(this, copyState);</span>
<a href="#l3.4307"></a><span id="l3.4307" class="difflineminus">-            // Don't mark message 'Deleted' for AOL servers or standard imap servers</span>
<a href="#l3.4308"></a><span id="l3.4308" class="difflineminus">-            // that support MOVE since we already issued an 'xaol-move' or 'move' command.</span>
<a href="#l3.4309"></a><span id="l3.4309" class="difflineplus">+            // Don't mark message 'Deleted' for AOL servers or standard imap</span>
<a href="#l3.4310"></a><span id="l3.4310" class="difflineplus">+            // servers that support MOVE since we already issued an 'xaol-move'</span>
<a href="#l3.4311"></a><span id="l3.4311" class="difflineplus">+            // or 'move' command.</span>
<a href="#l3.4312"></a><span id="l3.4312">             if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.4313"></a><span id="l3.4313" class="difflineminus">-              (m_imapAction == nsIImapUrl::nsImapOnlineMove) &amp;&amp;</span>
<a href="#l3.4314"></a><span id="l3.4314" class="difflineminus">-              !(GetServerStateParser().ServerIsAOLServer() ||</span>
<a href="#l3.4315"></a><span id="l3.4315" class="difflineminus">-                GetServerStateParser().GetCapabilityFlag() &amp; kHasMoveCapability))</span>
<a href="#l3.4316"></a><span id="l3.4316" class="difflineminus">-            {</span>
<a href="#l3.4317"></a><span id="l3.4317" class="difflineminus">-              // Simulate MOVE for servers that don't support MOVE: do COPY-DELETE-EXPUNGE.</span>
<a href="#l3.4318"></a><span id="l3.4318" class="difflineplus">+                (m_imapAction == nsIImapUrl::nsImapOnlineMove) &amp;&amp;</span>
<a href="#l3.4319"></a><span id="l3.4319" class="difflineplus">+                !(GetServerStateParser().ServerIsAOLServer() ||</span>
<a href="#l3.4320"></a><span id="l3.4320" class="difflineplus">+                  GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.4321"></a><span id="l3.4321" class="difflineplus">+                      kHasMoveCapability)) {</span>
<a href="#l3.4322"></a><span id="l3.4322" class="difflineplus">+              // Simulate MOVE for servers that don't support MOVE: do</span>
<a href="#l3.4323"></a><span id="l3.4323" class="difflineplus">+              // COPY-DELETE-EXPUNGE.</span>
<a href="#l3.4324"></a><span id="l3.4324">               Store(messageIdString, &quot;+FLAGS (\\Deleted \\Seen)&quot;,</span>
<a href="#l3.4325"></a><span id="l3.4325" class="difflineminus">-                bMessageIdsAreUids);</span>
<a href="#l3.4326"></a><span id="l3.4326" class="difflineminus">-              bool storeSuccessful = GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l3.4327"></a><span id="l3.4327" class="difflineminus">-              if (storeSuccessful)</span>
<a href="#l3.4328"></a><span id="l3.4328" class="difflineminus">-              {</span>
<a href="#l3.4329"></a><span id="l3.4329" class="difflineminus">-                if(gExpungeAfterDelete)</span>
<a href="#l3.4330"></a><span id="l3.4330" class="difflineminus">-                {</span>
<a href="#l3.4331"></a><span id="l3.4331" class="difflineplus">+                    bMessageIdsAreUids);</span>
<a href="#l3.4332"></a><span id="l3.4332" class="difflineplus">+              bool storeSuccessful =</span>
<a href="#l3.4333"></a><span id="l3.4333" class="difflineplus">+                  GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l3.4334"></a><span id="l3.4334" class="difflineplus">+              if (storeSuccessful) {</span>
<a href="#l3.4335"></a><span id="l3.4335" class="difflineplus">+                if (gExpungeAfterDelete) {</span>
<a href="#l3.4336"></a><span id="l3.4336">                   // This will expunge all emails marked as deleted in mailbox,</span>
<a href="#l3.4337"></a><span id="l3.4337">                   // not just the ones marked as deleted above.</span>
<a href="#l3.4338"></a><span id="l3.4338">                   Expunge();</span>
<a href="#l3.4339"></a><span id="l3.4339" class="difflineminus">-                }</span>
<a href="#l3.4340"></a><span id="l3.4340" class="difflineminus">-                else</span>
<a href="#l3.4341"></a><span id="l3.4341" class="difflineminus">-                {</span>
<a href="#l3.4342"></a><span id="l3.4342" class="difflineminus">-                  // Check if UIDPLUS capable so we can just expunge emails we just</span>
<a href="#l3.4343"></a><span id="l3.4343" class="difflineminus">-                  // copied and marked as deleted. This prevents expunging emails</span>
<a href="#l3.4344"></a><span id="l3.4344" class="difflineminus">-                  // that other clients may have marked as deleted in the mailbox</span>
<a href="#l3.4345"></a><span id="l3.4345" class="difflineminus">-                  // and don't want them to disappear.</span>
<a href="#l3.4346"></a><span id="l3.4346" class="difflineminus">-                  // Only do UidExpunge() when user selected delete method is &quot;Move</span>
<a href="#l3.4347"></a><span id="l3.4347" class="difflineminus">-                  // it to this folder&quot; or &quot;Remove it immediately&quot;, not when the</span>
<a href="#l3.4348"></a><span id="l3.4348" class="difflineplus">+                } else {</span>
<a href="#l3.4349"></a><span id="l3.4349" class="difflineplus">+                  // Check if UIDPLUS capable so we can just expunge emails we</span>
<a href="#l3.4350"></a><span id="l3.4350" class="difflineplus">+                  // just copied and marked as deleted. This prevents expunging</span>
<a href="#l3.4351"></a><span id="l3.4351" class="difflineplus">+                  // emails that other clients may have marked as deleted in the</span>
<a href="#l3.4352"></a><span id="l3.4352" class="difflineplus">+                  // mailbox and don't want them to disappear. Only do</span>
<a href="#l3.4353"></a><span id="l3.4353" class="difflineplus">+                  // UidExpunge() when user selected delete method is &quot;Move it</span>
<a href="#l3.4354"></a><span id="l3.4354" class="difflineplus">+                  // to this folder&quot; or &quot;Remove it immediately&quot;, not when the</span>
<a href="#l3.4355"></a><span id="l3.4355">                   // delete method is &quot;Just mark it as deleted&quot;.</span>
<a href="#l3.4356"></a><span id="l3.4356">                   if (!GetShowDeletedMessages() &amp;&amp;</span>
<a href="#l3.4357"></a><span id="l3.4357" class="difflineminus">-                      (GetServerStateParser().GetCapabilityFlag() &amp; kUidplusCapability))</span>
<a href="#l3.4358"></a><span id="l3.4358" class="difflineminus">-                  {</span>
<a href="#l3.4359"></a><span id="l3.4359" class="difflineplus">+                      (GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.4360"></a><span id="l3.4360" class="difflineplus">+                       kUidplusCapability)) {</span>
<a href="#l3.4361"></a><span id="l3.4361">                     UidExpunge(messageIdString);</span>
<a href="#l3.4362"></a><span id="l3.4362">                   }</span>
<a href="#l3.4363"></a><span id="l3.4363">                 }</span>
<a href="#l3.4364"></a><span id="l3.4364">               }</span>
<a href="#l3.4365"></a><span id="l3.4365" class="difflineminus">-              if (m_imapMailFolderSink)</span>
<a href="#l3.4366"></a><span id="l3.4366" class="difflineminus">-              {</span>
<a href="#l3.4367"></a><span id="l3.4367" class="difflineminus">-                copyState = storeSuccessful ? (ImapOnlineCopyState) ImapOnlineCopyStateType::kSuccessfulDelete</span>
<a href="#l3.4368"></a><span id="l3.4368" class="difflineminus">-                  : (ImapOnlineCopyState) ImapOnlineCopyStateType::kFailedDelete;</span>
<a href="#l3.4369"></a><span id="l3.4369" class="difflineplus">+              if (m_imapMailFolderSink) {</span>
<a href="#l3.4370"></a><span id="l3.4370" class="difflineplus">+                copyState = storeSuccessful</span>
<a href="#l3.4371"></a><span id="l3.4371" class="difflineplus">+                                ? (ImapOnlineCopyState)</span>
<a href="#l3.4372"></a><span id="l3.4372" class="difflineplus">+                                      ImapOnlineCopyStateType::kSuccessfulDelete</span>
<a href="#l3.4373"></a><span id="l3.4373" class="difflineplus">+                                : (ImapOnlineCopyState)</span>
<a href="#l3.4374"></a><span id="l3.4374" class="difflineplus">+                                      ImapOnlineCopyStateType::kFailedDelete;</span>
<a href="#l3.4375"></a><span id="l3.4375">                 m_imapMailFolderSink-&gt;OnlineCopyCompleted(this, copyState);</span>
<a href="#l3.4376"></a><span id="l3.4376">               }</span>
<a href="#l3.4377"></a><span id="l3.4377">             }</span>
<a href="#l3.4378"></a><span id="l3.4378" class="difflineminus">-          }</span>
<a href="#l3.4379"></a><span id="l3.4379" class="difflineminus">-          else</span>
<a href="#l3.4380"></a><span id="l3.4380" class="difflineplus">+          } else</span>
<a href="#l3.4381"></a><span id="l3.4381">             HandleMemoryFailure();</span>
<a href="#l3.4382"></a><span id="l3.4382" class="difflineminus">-        }</span>
<a href="#l3.4383"></a><span id="l3.4383" class="difflineminus">-        break;</span>
<a href="#l3.4384"></a><span id="l3.4384" class="difflineminus">-      case nsIImapUrl::nsImapOnlineToOfflineCopy:</span>
<a href="#l3.4385"></a><span id="l3.4385" class="difflineminus">-      case nsIImapUrl::nsImapOnlineToOfflineMove:</span>
<a href="#l3.4386"></a><span id="l3.4386" class="difflineminus">-        {</span>
<a href="#l3.4387"></a><span id="l3.4387" class="difflineplus">+        } break;</span>
<a href="#l3.4388"></a><span id="l3.4388" class="difflineplus">+        case nsIImapUrl::nsImapOnlineToOfflineCopy:</span>
<a href="#l3.4389"></a><span id="l3.4389" class="difflineplus">+        case nsIImapUrl::nsImapOnlineToOfflineMove: {</span>
<a href="#l3.4390"></a><span id="l3.4390">           nsCString messageIdString;</span>
<a href="#l3.4391"></a><span id="l3.4391">           nsresult rv = m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.4392"></a><span id="l3.4392" class="difflineminus">-          if (NS_SUCCEEDED(rv))</span>
<a href="#l3.4393"></a><span id="l3.4393" class="difflineminus">-          {</span>
<a href="#l3.4394"></a><span id="l3.4394" class="difflineplus">+          if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.4395"></a><span id="l3.4395">             SetProgressString(IMAP_MESSAGES_STRING_INDEX);</span>
<a href="#l3.4396"></a><span id="l3.4396">             m_progressCurrentNumber[m_stringIndex] = 0;</span>
<a href="#l3.4397"></a><span id="l3.4397" class="difflineminus">-            m_progressExpectedNumber = CountMessagesInIdString(messageIdString.get());</span>
<a href="#l3.4398"></a><span id="l3.4398" class="difflineplus">+            m_progressExpectedNumber =</span>
<a href="#l3.4399"></a><span id="l3.4399" class="difflineplus">+                CountMessagesInIdString(messageIdString.get());</span>
<a href="#l3.4400"></a><span id="l3.4400"> </span>
<a href="#l3.4401"></a><span id="l3.4401">             FetchMessage(messageIdString, kEveryThingRFC822Peek);</span>
<a href="#l3.4402"></a><span id="l3.4402"> </span>
<a href="#l3.4403"></a><span id="l3.4403">             SetProgressString(IMAP_EMPTY_STRING_INDEX);</span>
<a href="#l3.4404"></a><span id="l3.4404" class="difflineminus">-            if (m_imapMailFolderSink)</span>
<a href="#l3.4405"></a><span id="l3.4405" class="difflineminus">-            {</span>
<a href="#l3.4406"></a><span id="l3.4406" class="difflineplus">+            if (m_imapMailFolderSink) {</span>
<a href="#l3.4407"></a><span id="l3.4407">               ImapOnlineCopyState copyStatus;</span>
<a href="#l3.4408"></a><span id="l3.4408" class="difflineminus">-              copyStatus = GetServerStateParser().LastCommandSuccessful() ?</span>
<a href="#l3.4409"></a><span id="l3.4409" class="difflineminus">-                ImapOnlineCopyStateType::kSuccessfulCopy : ImapOnlineCopyStateType::kFailedCopy;</span>
<a href="#l3.4410"></a><span id="l3.4410" class="difflineplus">+              copyStatus = GetServerStateParser().LastCommandSuccessful()</span>
<a href="#l3.4411"></a><span id="l3.4411" class="difflineplus">+                               ? ImapOnlineCopyStateType::kSuccessfulCopy</span>
<a href="#l3.4412"></a><span id="l3.4412" class="difflineplus">+                               : ImapOnlineCopyStateType::kFailedCopy;</span>
<a href="#l3.4413"></a><span id="l3.4413"> </span>
<a href="#l3.4414"></a><span id="l3.4414">               m_imapMailFolderSink-&gt;OnlineCopyCompleted(this, copyStatus);</span>
<a href="#l3.4415"></a><span id="l3.4415">               if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.4416"></a><span id="l3.4416" class="difflineminus">-                (m_imapAction == nsIImapUrl::nsImapOnlineToOfflineMove))</span>
<a href="#l3.4417"></a><span id="l3.4417" class="difflineminus">-              {</span>
<a href="#l3.4418"></a><span id="l3.4418" class="difflineminus">-                Store(messageIdString, &quot;+FLAGS (\\Deleted \\Seen)&quot;,bMessageIdsAreUids);</span>
<a href="#l3.4419"></a><span id="l3.4419" class="difflineminus">-                if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.4420"></a><span id="l3.4420" class="difflineminus">-                {</span>
<a href="#l3.4421"></a><span id="l3.4421" class="difflineplus">+                  (m_imapAction == nsIImapUrl::nsImapOnlineToOfflineMove)) {</span>
<a href="#l3.4422"></a><span id="l3.4422" class="difflineplus">+                Store(messageIdString, &quot;+FLAGS (\\Deleted \\Seen)&quot;,</span>
<a href="#l3.4423"></a><span id="l3.4423" class="difflineplus">+                      bMessageIdsAreUids);</span>
<a href="#l3.4424"></a><span id="l3.4424" class="difflineplus">+                if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.4425"></a><span id="l3.4425">                   copyStatus = ImapOnlineCopyStateType::kSuccessfulDelete;</span>
<a href="#l3.4426"></a><span id="l3.4426" class="difflineminus">-                  if (gExpungeAfterDelete)</span>
<a href="#l3.4427"></a><span id="l3.4427" class="difflineminus">-                    Expunge();</span>
<a href="#l3.4428"></a><span id="l3.4428" class="difflineminus">-                }</span>
<a href="#l3.4429"></a><span id="l3.4429" class="difflineminus">-                else</span>
<a href="#l3.4430"></a><span id="l3.4430" class="difflineplus">+                  if (gExpungeAfterDelete) Expunge();</span>
<a href="#l3.4431"></a><span id="l3.4431" class="difflineplus">+                } else</span>
<a href="#l3.4432"></a><span id="l3.4432">                   copyStatus = ImapOnlineCopyStateType::kFailedDelete;</span>
<a href="#l3.4433"></a><span id="l3.4433"> </span>
<a href="#l3.4434"></a><span id="l3.4434" class="difflineminus">-                m_imapMailFolderSink-&gt;OnlineCopyCompleted(this,  copyStatus);</span>
<a href="#l3.4435"></a><span id="l3.4435" class="difflineplus">+                m_imapMailFolderSink-&gt;OnlineCopyCompleted(this, copyStatus);</span>
<a href="#l3.4436"></a><span id="l3.4436">               }</span>
<a href="#l3.4437"></a><span id="l3.4437">             }</span>
<a href="#l3.4438"></a><span id="l3.4438" class="difflineminus">-          }</span>
<a href="#l3.4439"></a><span id="l3.4439" class="difflineminus">-          else</span>
<a href="#l3.4440"></a><span id="l3.4440" class="difflineplus">+          } else</span>
<a href="#l3.4441"></a><span id="l3.4441">             HandleMemoryFailure();</span>
<a href="#l3.4442"></a><span id="l3.4442" class="difflineminus">-        }</span>
<a href="#l3.4443"></a><span id="l3.4443" class="difflineminus">-        break;</span>
<a href="#l3.4444"></a><span id="l3.4444" class="difflineminus">-      default:</span>
<a href="#l3.4445"></a><span id="l3.4445" class="difflineminus">-        if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; !uidValidityOk)</span>
<a href="#l3.4446"></a><span id="l3.4446" class="difflineminus">-          ProcessMailboxUpdate(false); // handle uidvalidity change</span>
<a href="#l3.4447"></a><span id="l3.4447" class="difflineminus">-        break;</span>
<a href="#l3.4448"></a><span id="l3.4448" class="difflineplus">+        } break;</span>
<a href="#l3.4449"></a><span id="l3.4449" class="difflineplus">+        default:</span>
<a href="#l3.4450"></a><span id="l3.4450" class="difflineplus">+          if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; !uidValidityOk)</span>
<a href="#l3.4451"></a><span id="l3.4451" class="difflineplus">+            ProcessMailboxUpdate(false);  // handle uidvalidity change</span>
<a href="#l3.4452"></a><span id="l3.4452" class="difflineplus">+          break;</span>
<a href="#l3.4453"></a><span id="l3.4453">       }</span>
<a href="#l3.4454"></a><span id="l3.4454">     }</span>
<a href="#l3.4455"></a><span id="l3.4455" class="difflineminus">-  }</span>
<a href="#l3.4456"></a><span id="l3.4456" class="difflineminus">-  else if (!DeathSignalReceived())</span>
<a href="#l3.4457"></a><span id="l3.4457" class="difflineplus">+  } else if (!DeathSignalReceived())</span>
<a href="#l3.4458"></a><span id="l3.4458">     HandleMemoryFailure();</span>
<a href="#l3.4459"></a><span id="l3.4459"> }</span>
<a href="#l3.4460"></a><span id="l3.4460"> </span>
<a href="#l3.4461"></a><span id="l3.4461"> nsresult nsImapProtocol::BeginMessageDownLoad(</span>
<a href="#l3.4462"></a><span id="l3.4462" class="difflineminus">-                                              uint32_t total_message_size, // for user, headers and body</span>
<a href="#l3.4463"></a><span id="l3.4463" class="difflineminus">-                                              const char *content_type)</span>
<a href="#l3.4464"></a><span id="l3.4464" class="difflineminus">-{</span>
<a href="#l3.4465"></a><span id="l3.4465" class="difflineplus">+    uint32_t total_message_size,  // for user, headers and body</span>
<a href="#l3.4466"></a><span id="l3.4466" class="difflineplus">+    const char *content_type) {</span>
<a href="#l3.4467"></a><span id="l3.4467">   nsresult rv = NS_OK;</span>
<a href="#l3.4468"></a><span id="l3.4468">   char *sizeString = PR_smprintf(&quot;OPEN Size: %ld&quot;, total_message_size);</span>
<a href="#l3.4469"></a><span id="l3.4469" class="difflineminus">-  Log(&quot;STREAM&quot;,sizeString,&quot;Begin Message Download Stream&quot;);</span>
<a href="#l3.4470"></a><span id="l3.4470" class="difflineplus">+  Log(&quot;STREAM&quot;, sizeString, &quot;Begin Message Download Stream&quot;);</span>
<a href="#l3.4471"></a><span id="l3.4471">   PR_Free(sizeString);</span>
<a href="#l3.4472"></a><span id="l3.4472" class="difflineminus">-  // start counting how many bytes we see in this message after all transformations</span>
<a href="#l3.4473"></a><span id="l3.4473" class="difflineplus">+  // start counting how many bytes we see in this message after all</span>
<a href="#l3.4474"></a><span id="l3.4474" class="difflineplus">+  // transformations</span>
<a href="#l3.4475"></a><span id="l3.4475">   m_bytesToChannel = 0;</span>
<a href="#l3.4476"></a><span id="l3.4476"> </span>
<a href="#l3.4477"></a><span id="l3.4477" class="difflineminus">-  if (content_type)</span>
<a href="#l3.4478"></a><span id="l3.4478" class="difflineminus">-  {</span>
<a href="#l3.4479"></a><span id="l3.4479" class="difflineplus">+  if (content_type) {</span>
<a href="#l3.4480"></a><span id="l3.4480">     m_fromHeaderSeen = false;</span>
<a href="#l3.4481"></a><span id="l3.4481" class="difflineminus">-    if (GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.4482"></a><span id="l3.4482" class="difflineminus">-    {</span>
<a href="#l3.4483"></a><span id="l3.4483" class="difflineplus">+    if (GetServerStateParser().GetDownloadingHeaders()) {</span>
<a href="#l3.4484"></a><span id="l3.4484">       // if we get multiple calls to BeginMessageDownload w/o intervening</span>
<a href="#l3.4485"></a><span id="l3.4485">       // calls to NormalEndMessageDownload or Abort, then we're just</span>
<a href="#l3.4486"></a><span id="l3.4486">       // going to fake a NormalMessageEndDownload. This will most likely</span>
<a href="#l3.4487"></a><span id="l3.4487">       // cause an empty header to get written to the db, and the user</span>
<a href="#l3.4488"></a><span id="l3.4488">       // will have to delete the empty header themselves, which</span>
<a href="#l3.4489"></a><span id="l3.4489">       // should remove the message from the server as well.</span>
<a href="#l3.4490"></a><span id="l3.4490" class="difflineminus">-      if (m_curHdrInfo)</span>
<a href="#l3.4491"></a><span id="l3.4491" class="difflineminus">-        NormalMessageEndDownload();</span>
<a href="#l3.4492"></a><span id="l3.4492" class="difflineminus">-      if (!m_curHdrInfo)</span>
<a href="#l3.4493"></a><span id="l3.4493" class="difflineminus">-        m_curHdrInfo = m_hdrDownloadCache-&gt;StartNewHdr();</span>
<a href="#l3.4494"></a><span id="l3.4494" class="difflineminus">-      if (m_curHdrInfo)</span>
<a href="#l3.4495"></a><span id="l3.4495" class="difflineminus">-        m_curHdrInfo-&gt;SetMsgSize(total_message_size);</span>
<a href="#l3.4496"></a><span id="l3.4496" class="difflineplus">+      if (m_curHdrInfo) NormalMessageEndDownload();</span>
<a href="#l3.4497"></a><span id="l3.4497" class="difflineplus">+      if (!m_curHdrInfo) m_curHdrInfo = m_hdrDownloadCache-&gt;StartNewHdr();</span>
<a href="#l3.4498"></a><span id="l3.4498" class="difflineplus">+      if (m_curHdrInfo) m_curHdrInfo-&gt;SetMsgSize(total_message_size);</span>
<a href="#l3.4499"></a><span id="l3.4499">       return NS_OK;</span>
<a href="#l3.4500"></a><span id="l3.4500">     }</span>
<a href="#l3.4501"></a><span id="l3.4501" class="difflineminus">-    // if we have a mock channel, that means we have a channel listener who wants the</span>
<a href="#l3.4502"></a><span id="l3.4502" class="difflineminus">-    // message. So set up a pipe. We'll write the message into one end of the pipe</span>
<a href="#l3.4503"></a><span id="l3.4503" class="difflineminus">-    // and they will read it out of the other end.</span>
<a href="#l3.4504"></a><span id="l3.4504" class="difflineminus">-    if (m_channelListener)</span>
<a href="#l3.4505"></a><span id="l3.4505" class="difflineminus">-    {</span>
<a href="#l3.4506"></a><span id="l3.4506" class="difflineplus">+    // if we have a mock channel, that means we have a channel listener who</span>
<a href="#l3.4507"></a><span id="l3.4507" class="difflineplus">+    // wants the message. So set up a pipe. We'll write the message into one end</span>
<a href="#l3.4508"></a><span id="l3.4508" class="difflineplus">+    // of the pipe and they will read it out of the other end.</span>
<a href="#l3.4509"></a><span id="l3.4509" class="difflineplus">+    if (m_channelListener) {</span>
<a href="#l3.4510"></a><span id="l3.4510">       // create a pipe to pump the message into...the output will go to whoever</span>
<a href="#l3.4511"></a><span id="l3.4511">       // is consuming the message display</span>
<a href="#l3.4512"></a><span id="l3.4512" class="difflineminus">-      // we create an &quot;infinite&quot; pipe in case we get extremely long lines from the imap server,</span>
<a href="#l3.4513"></a><span id="l3.4513" class="difflineminus">-      // and the consumer is waiting for a whole line</span>
<a href="#l3.4514"></a><span id="l3.4514" class="difflineplus">+      // we create an &quot;infinite&quot; pipe in case we get extremely long lines from</span>
<a href="#l3.4515"></a><span id="l3.4515" class="difflineplus">+      // the imap server, and the consumer is waiting for a whole line</span>
<a href="#l3.4516"></a><span id="l3.4516">       nsCOMPtr&lt;nsIPipe&gt; pipe = do_CreateInstance(&quot;@mozilla.org/pipe;1&quot;);</span>
<a href="#l3.4517"></a><span id="l3.4517">       rv = pipe-&gt;Init(false, false, 4096, PR_UINT32_MAX);</span>
<a href="#l3.4518"></a><span id="l3.4518">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.4519"></a><span id="l3.4519"> </span>
<a href="#l3.4520"></a><span id="l3.4520">       // These always succeed because the pipe is initialized above.</span>
<a href="#l3.4521"></a><span id="l3.4521" class="difflineminus">-      MOZ_ALWAYS_SUCCEEDS(pipe-&gt;GetInputStream(getter_AddRefs(m_channelInputStream)));</span>
<a href="#l3.4522"></a><span id="l3.4522" class="difflineminus">-      MOZ_ALWAYS_SUCCEEDS(pipe-&gt;GetOutputStream(getter_AddRefs(m_channelOutputStream)));</span>
<a href="#l3.4523"></a><span id="l3.4523" class="difflineplus">+      MOZ_ALWAYS_SUCCEEDS(</span>
<a href="#l3.4524"></a><span id="l3.4524" class="difflineplus">+          pipe-&gt;GetInputStream(getter_AddRefs(m_channelInputStream)));</span>
<a href="#l3.4525"></a><span id="l3.4525" class="difflineplus">+      MOZ_ALWAYS_SUCCEEDS(</span>
<a href="#l3.4526"></a><span id="l3.4526" class="difflineplus">+          pipe-&gt;GetOutputStream(getter_AddRefs(m_channelOutputStream)));</span>
<a href="#l3.4527"></a><span id="l3.4527">     }</span>
<a href="#l3.4528"></a><span id="l3.4528">     // else, if we are saving the message to disk!</span>
<a href="#l3.4529"></a><span id="l3.4529">     else if (m_imapMessageSink /* &amp;&amp; m_imapAction == nsIImapUrl::nsImapSaveMessageToDisk */)</span>
<a href="#l3.4530"></a><span id="l3.4530">     {</span>
<a href="#l3.4531"></a><span id="l3.4531">       // we get here when download the inbox for offline use</span>
<a href="#l3.4532"></a><span id="l3.4532">       nsCOMPtr&lt;nsIFile&gt; file;</span>
<a href="#l3.4533"></a><span id="l3.4533">       bool addDummyEnvelope = true;</span>
<a href="#l3.4534"></a><span id="l3.4534">       nsCOMPtr&lt;nsIMsgMessageUrl&gt; msgurl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.4535"></a><span id="l3.4535">       msgurl-&gt;GetMessageFile(getter_AddRefs(file));</span>
<a href="#l3.4536"></a><span id="l3.4536">       msgurl-&gt;GetAddDummyEnvelope(&amp;addDummyEnvelope);</span>
<a href="#l3.4537"></a><span id="l3.4537">       if (file)</span>
<a href="#l3.4538"></a><span id="l3.4538">         rv = m_imapMessageSink-&gt;SetupMsgWriteStream(file, addDummyEnvelope);</span>
<a href="#l3.4539"></a><span id="l3.4539">     }</span>
<a href="#l3.4540"></a><span id="l3.4540" class="difflineminus">-    if (m_imapMailFolderSink &amp;&amp; m_runningUrl)</span>
<a href="#l3.4541"></a><span id="l3.4541" class="difflineminus">-    {</span>
<a href="#l3.4542"></a><span id="l3.4542" class="difflineminus">-      nsCOMPtr &lt;nsISupports&gt; copyState;</span>
<a href="#l3.4543"></a><span id="l3.4543" class="difflineminus">-      if (m_runningUrl)</span>
<a href="#l3.4544"></a><span id="l3.4544" class="difflineminus">-      {</span>
<a href="#l3.4545"></a><span id="l3.4545" class="difflineplus">+    if (m_imapMailFolderSink &amp;&amp; m_runningUrl) {</span>
<a href="#l3.4546"></a><span id="l3.4546" class="difflineplus">+      nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l3.4547"></a><span id="l3.4547" class="difflineplus">+      if (m_runningUrl) {</span>
<a href="#l3.4548"></a><span id="l3.4548">         m_runningUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l3.4549"></a><span id="l3.4549" class="difflineminus">-        if (copyState) // only need this notification during copy</span>
<a href="#l3.4550"></a><span id="l3.4550" class="difflineplus">+        if (copyState)  // only need this notification during copy</span>
<a href="#l3.4551"></a><span id="l3.4551">         {</span>
<a href="#l3.4552"></a><span id="l3.4552">           nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailurl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.4553"></a><span id="l3.4553">           m_imapMailFolderSink-&gt;StartMessage(mailurl);</span>
<a href="#l3.4554"></a><span id="l3.4554">         }</span>
<a href="#l3.4555"></a><span id="l3.4555">       }</span>
<a href="#l3.4556"></a><span id="l3.4556">     }</span>
<a href="#l3.4557"></a><span id="l3.4557"> </span>
<a href="#l3.4558"></a><span id="l3.4558" class="difflineminus">-  }</span>
<a href="#l3.4559"></a><span id="l3.4559" class="difflineminus">-  else</span>
<a href="#l3.4560"></a><span id="l3.4560" class="difflineplus">+  } else</span>
<a href="#l3.4561"></a><span id="l3.4561">     HandleMemoryFailure();</span>
<a href="#l3.4562"></a><span id="l3.4562">   return rv;</span>
<a href="#l3.4563"></a><span id="l3.4563"> }</span>
<a href="#l3.4564"></a><span id="l3.4564"> </span>
<a href="#l3.4565"></a><span id="l3.4565" class="difflineminus">-void</span>
<a href="#l3.4566"></a><span id="l3.4566" class="difflineminus">-nsImapProtocol::GetShouldDownloadAllHeaders(bool *aResult)</span>
<a href="#l3.4567"></a><span id="l3.4567" class="difflineminus">-{</span>
<a href="#l3.4568"></a><span id="l3.4568" class="difflineplus">+void nsImapProtocol::GetShouldDownloadAllHeaders(bool *aResult) {</span>
<a href="#l3.4569"></a><span id="l3.4569">   if (m_imapMailFolderSink)</span>
<a href="#l3.4570"></a><span id="l3.4570">     m_imapMailFolderSink-&gt;GetShouldDownloadAllHeaders(aResult);</span>
<a href="#l3.4571"></a><span id="l3.4571"> }</span>
<a href="#l3.4572"></a><span id="l3.4572"> </span>
<a href="#l3.4573"></a><span id="l3.4573" class="difflineminus">-void</span>
<a href="#l3.4574"></a><span id="l3.4574" class="difflineminus">-nsImapProtocol::GetArbitraryHeadersToDownload(nsCString &amp;aResult)</span>
<a href="#l3.4575"></a><span id="l3.4575" class="difflineminus">-{</span>
<a href="#l3.4576"></a><span id="l3.4576" class="difflineminus">-  if (m_imapServerSink)</span>
<a href="#l3.4577"></a><span id="l3.4577" class="difflineminus">-    m_imapServerSink-&gt;GetArbitraryHeaders(aResult);</span>
<a href="#l3.4578"></a><span id="l3.4578" class="difflineminus">-}</span>
<a href="#l3.4579"></a><span id="l3.4579" class="difflineminus">-</span>
<a href="#l3.4580"></a><span id="l3.4580" class="difflineminus">-void</span>
<a href="#l3.4581"></a><span id="l3.4581" class="difflineminus">-nsImapProtocol::AdjustChunkSize()</span>
<a href="#l3.4582"></a><span id="l3.4582" class="difflineminus">-{</span>
<a href="#l3.4583"></a><span id="l3.4583" class="difflineplus">+void nsImapProtocol::GetArbitraryHeadersToDownload(nsCString &amp;aResult) {</span>
<a href="#l3.4584"></a><span id="l3.4584" class="difflineplus">+  if (m_imapServerSink) m_imapServerSink-&gt;GetArbitraryHeaders(aResult);</span>
<a href="#l3.4585"></a><span id="l3.4585" class="difflineplus">+}</span>
<a href="#l3.4586"></a><span id="l3.4586" class="difflineplus">+</span>
<a href="#l3.4587"></a><span id="l3.4587" class="difflineplus">+void nsImapProtocol::AdjustChunkSize() {</span>
<a href="#l3.4588"></a><span id="l3.4588">   int32_t deltaInSeconds;</span>
<a href="#l3.4589"></a><span id="l3.4589">   PRTime2Seconds(m_endTime - m_startTime, &amp;deltaInSeconds);</span>
<a href="#l3.4590"></a><span id="l3.4590">   m_trackingTime = false;</span>
<a href="#l3.4591"></a><span id="l3.4591" class="difflineminus">-  if (deltaInSeconds &lt; 0)</span>
<a href="#l3.4592"></a><span id="l3.4592" class="difflineminus">-    return;            // bogus for some reason</span>
<a href="#l3.4593"></a><span id="l3.4593" class="difflineminus">-</span>
<a href="#l3.4594"></a><span id="l3.4594" class="difflineminus">-  if (deltaInSeconds &lt;= m_tooFastTime &amp;&amp; m_curFetchSize &gt;= m_chunkSize)</span>
<a href="#l3.4595"></a><span id="l3.4595" class="difflineminus">-  {</span>
<a href="#l3.4596"></a><span id="l3.4596" class="difflineplus">+  if (deltaInSeconds &lt; 0) return;  // bogus for some reason</span>
<a href="#l3.4597"></a><span id="l3.4597" class="difflineplus">+</span>
<a href="#l3.4598"></a><span id="l3.4598" class="difflineplus">+  if (deltaInSeconds &lt;= m_tooFastTime &amp;&amp; m_curFetchSize &gt;= m_chunkSize) {</span>
<a href="#l3.4599"></a><span id="l3.4599">     m_chunkSize += m_chunkAddSize;</span>
<a href="#l3.4600"></a><span id="l3.4600">     m_chunkThreshold = m_chunkSize + (m_chunkSize / 2);</span>
<a href="#l3.4601"></a><span id="l3.4601">     // we used to have a max for the chunk size - I don't think that's needed.</span>
<a href="#l3.4602"></a><span id="l3.4602" class="difflineminus">-  }</span>
<a href="#l3.4603"></a><span id="l3.4603" class="difflineminus">-  else if (deltaInSeconds &lt;= m_idealTime)</span>
<a href="#l3.4604"></a><span id="l3.4604" class="difflineplus">+  } else if (deltaInSeconds &lt;= m_idealTime)</span>
<a href="#l3.4605"></a><span id="l3.4605">     return;</span>
<a href="#l3.4606"></a><span id="l3.4606" class="difflineminus">-  else</span>
<a href="#l3.4607"></a><span id="l3.4607" class="difflineminus">-  {</span>
<a href="#l3.4608"></a><span id="l3.4608" class="difflineplus">+  else {</span>
<a href="#l3.4609"></a><span id="l3.4609">     if (m_chunkSize &gt; m_chunkStartSize)</span>
<a href="#l3.4610"></a><span id="l3.4610">       m_chunkSize = m_chunkStartSize;</span>
<a href="#l3.4611"></a><span id="l3.4611">     else if (m_chunkSize &gt; (m_chunkAddSize * 2))</span>
<a href="#l3.4612"></a><span id="l3.4612">       m_chunkSize -= m_chunkAddSize;</span>
<a href="#l3.4613"></a><span id="l3.4613">     m_chunkThreshold = m_chunkSize + (m_chunkSize / 2);</span>
<a href="#l3.4614"></a><span id="l3.4614">   }</span>
<a href="#l3.4615"></a><span id="l3.4615">   // remember these new values globally so new connections</span>
<a href="#l3.4616"></a><span id="l3.4616">   // can take advantage of them.</span>
<a href="#l3.4617"></a><span id="l3.4617" class="difflineminus">-  if (gChunkSize != m_chunkSize)</span>
<a href="#l3.4618"></a><span id="l3.4618" class="difflineminus">-  {</span>
<a href="#l3.4619"></a><span id="l3.4619" class="difflineplus">+  if (gChunkSize != m_chunkSize) {</span>
<a href="#l3.4620"></a><span id="l3.4620">     // will cause chunk size pref to be written in CloseStream.</span>
<a href="#l3.4621"></a><span id="l3.4621">     gChunkSizeDirty = true;</span>
<a href="#l3.4622"></a><span id="l3.4622">     gChunkSize = m_chunkSize;</span>
<a href="#l3.4623"></a><span id="l3.4623">     gChunkThreshold = m_chunkThreshold;</span>
<a href="#l3.4624"></a><span id="l3.4624">   }</span>
<a href="#l3.4625"></a><span id="l3.4625"> }</span>
<a href="#l3.4626"></a><span id="l3.4626"> </span>
<a href="#l3.4627"></a><span id="l3.4627"> // authenticated state commands</span>
<a href="#l3.4628"></a><span id="l3.4628"> </span>
<a href="#l3.4629"></a><span id="l3.4629" class="difflineminus">-// escape any backslashes or quotes.  Backslashes are used a lot with our NT server</span>
<a href="#l3.4630"></a><span id="l3.4630" class="difflineminus">-void nsImapProtocol::CreateEscapedMailboxName(const char *rawName, nsCString &amp;escapedName)</span>
<a href="#l3.4631"></a><span id="l3.4631" class="difflineminus">-{</span>
<a href="#l3.4632"></a><span id="l3.4632" class="difflineplus">+// escape any backslashes or quotes.  Backslashes are used a lot with our NT</span>
<a href="#l3.4633"></a><span id="l3.4633" class="difflineplus">+// server</span>
<a href="#l3.4634"></a><span id="l3.4634" class="difflineplus">+void nsImapProtocol::CreateEscapedMailboxName(const char *rawName,</span>
<a href="#l3.4635"></a><span id="l3.4635" class="difflineplus">+                                              nsCString &amp;escapedName) {</span>
<a href="#l3.4636"></a><span id="l3.4636">   escapedName.Assign(rawName);</span>
<a href="#l3.4637"></a><span id="l3.4637"> </span>
<a href="#l3.4638"></a><span id="l3.4638" class="difflineminus">-  for (int32_t strIndex = 0; *rawName; strIndex++)</span>
<a href="#l3.4639"></a><span id="l3.4639" class="difflineminus">-  {</span>
<a href="#l3.4640"></a><span id="l3.4640" class="difflineplus">+  for (int32_t strIndex = 0; *rawName; strIndex++) {</span>
<a href="#l3.4641"></a><span id="l3.4641">     char currentChar = *rawName++;</span>
<a href="#l3.4642"></a><span id="l3.4642">     if ((currentChar == '\\') || (currentChar == '\&quot;'))</span>
<a href="#l3.4643"></a><span id="l3.4643">       escapedName.Insert('\\', strIndex++);</span>
<a href="#l3.4644"></a><span id="l3.4644">   }</span>
<a href="#l3.4645"></a><span id="l3.4645"> }</span>
<a href="#l3.4646"></a><span id="l3.4646" class="difflineminus">-void nsImapProtocol::SelectMailbox(const char *mailboxName)</span>
<a href="#l3.4647"></a><span id="l3.4647" class="difflineminus">-{</span>
<a href="#l3.4648"></a><span id="l3.4648" class="difflineminus">-  ProgressEventFunctionUsingNameWithString(&quot;imapStatusSelectingMailbox&quot;, mailboxName);</span>
<a href="#l3.4649"></a><span id="l3.4649" class="difflineplus">+void nsImapProtocol::SelectMailbox(const char *mailboxName) {</span>
<a href="#l3.4650"></a><span id="l3.4650" class="difflineplus">+  ProgressEventFunctionUsingNameWithString(&quot;imapStatusSelectingMailbox&quot;,</span>
<a href="#l3.4651"></a><span id="l3.4651" class="difflineplus">+                                           mailboxName);</span>
<a href="#l3.4652"></a><span id="l3.4652">   IncrementCommandTagNumber();</span>
<a href="#l3.4653"></a><span id="l3.4653"> </span>
<a href="#l3.4654"></a><span id="l3.4654" class="difflineminus">-  m_closeNeededBeforeSelect = false;   // initial value</span>
<a href="#l3.4655"></a><span id="l3.4655" class="difflineplus">+  m_closeNeededBeforeSelect = false;  // initial value</span>
<a href="#l3.4656"></a><span id="l3.4656">   GetServerStateParser().ResetFlagInfo();</span>
<a href="#l3.4657"></a><span id="l3.4657">   nsCString escapedName;</span>
<a href="#l3.4658"></a><span id="l3.4658">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.4659"></a><span id="l3.4659">   nsCString commandBuffer(GetServerCommandTag());</span>
<a href="#l3.4660"></a><span id="l3.4660">   commandBuffer.AppendLiteral(&quot; select \&quot;&quot;);</span>
<a href="#l3.4661"></a><span id="l3.4661">   commandBuffer.Append(escapedName.get());</span>
<a href="#l3.4662"></a><span id="l3.4662">   commandBuffer.Append('&quot;');</span>
<a href="#l3.4663"></a><span id="l3.4663" class="difflineminus">-  if (UseCondStore())</span>
<a href="#l3.4664"></a><span id="l3.4664" class="difflineminus">-    commandBuffer.AppendLiteral(&quot; (CONDSTORE)&quot;);</span>
<a href="#l3.4665"></a><span id="l3.4665" class="difflineplus">+  if (UseCondStore()) commandBuffer.AppendLiteral(&quot; (CONDSTORE)&quot;);</span>
<a href="#l3.4666"></a><span id="l3.4666">   commandBuffer.Append(CRLF);</span>
<a href="#l3.4667"></a><span id="l3.4667"> </span>
<a href="#l3.4668"></a><span id="l3.4668">   nsresult res;</span>
<a href="#l3.4669"></a><span id="l3.4669">   res = SendData(commandBuffer.get());</span>
<a href="#l3.4670"></a><span id="l3.4670">   if (NS_FAILED(res)) return;</span>
<a href="#l3.4671"></a><span id="l3.4671">   ParseIMAPandCheckForNewMail();</span>
<a href="#l3.4672"></a><span id="l3.4672"> </span>
<a href="#l3.4673"></a><span id="l3.4673">   int32_t numOfMessagesInFlagState = 0;</span>
<a href="#l3.4674"></a><span id="l3.4674">   nsImapAction imapAction;</span>
<a href="#l3.4675"></a><span id="l3.4675">   m_flagState-&gt;GetNumberOfMessages(&amp;numOfMessagesInFlagState);</span>
<a href="#l3.4676"></a><span id="l3.4676">   res = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.4677"></a><span id="l3.4677" class="difflineminus">-  // if we've selected a mailbox, and we're not going to do an update because of the</span>
<a href="#l3.4678"></a><span id="l3.4678" class="difflineminus">-  // url type, but don't have the flags, go get them!</span>
<a href="#l3.4679"></a><span id="l3.4679" class="difflineplus">+  // if we've selected a mailbox, and we're not going to do an update because of</span>
<a href="#l3.4680"></a><span id="l3.4680" class="difflineplus">+  // the url type, but don't have the flags, go get them!</span>
<a href="#l3.4681"></a><span id="l3.4681">   if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; NS_SUCCEEDED(res) &amp;&amp;</span>
<a href="#l3.4682"></a><span id="l3.4682" class="difflineminus">-    imapAction != nsIImapUrl::nsImapSelectFolder &amp;&amp; imapAction != nsIImapUrl::nsImapExpungeFolder</span>
<a href="#l3.4683"></a><span id="l3.4683" class="difflineminus">-    &amp;&amp; imapAction != nsIImapUrl::nsImapLiteSelectFolder &amp;&amp;</span>
<a href="#l3.4684"></a><span id="l3.4684" class="difflineminus">-    imapAction != nsIImapUrl::nsImapDeleteAllMsgs &amp;&amp;</span>
<a href="#l3.4685"></a><span id="l3.4685" class="difflineminus">-    ((GetServerStateParser().NumberOfMessages() != numOfMessagesInFlagState) &amp;&amp; (numOfMessagesInFlagState == 0)))</span>
<a href="#l3.4686"></a><span id="l3.4686" class="difflineminus">-  {</span>
<a href="#l3.4687"></a><span id="l3.4687" class="difflineminus">-      ProcessMailboxUpdate(false);</span>
<a href="#l3.4688"></a><span id="l3.4688" class="difflineplus">+      imapAction != nsIImapUrl::nsImapSelectFolder &amp;&amp;</span>
<a href="#l3.4689"></a><span id="l3.4689" class="difflineplus">+      imapAction != nsIImapUrl::nsImapExpungeFolder &amp;&amp;</span>
<a href="#l3.4690"></a><span id="l3.4690" class="difflineplus">+      imapAction != nsIImapUrl::nsImapLiteSelectFolder &amp;&amp;</span>
<a href="#l3.4691"></a><span id="l3.4691" class="difflineplus">+      imapAction != nsIImapUrl::nsImapDeleteAllMsgs &amp;&amp;</span>
<a href="#l3.4692"></a><span id="l3.4692" class="difflineplus">+      ((GetServerStateParser().NumberOfMessages() !=</span>
<a href="#l3.4693"></a><span id="l3.4693" class="difflineplus">+        numOfMessagesInFlagState) &amp;&amp;</span>
<a href="#l3.4694"></a><span id="l3.4694" class="difflineplus">+       (numOfMessagesInFlagState == 0))) {</span>
<a href="#l3.4695"></a><span id="l3.4695" class="difflineplus">+    ProcessMailboxUpdate(false);</span>
<a href="#l3.4696"></a><span id="l3.4696">   }</span>
<a href="#l3.4697"></a><span id="l3.4697"> }</span>
<a href="#l3.4698"></a><span id="l3.4698"> </span>
<a href="#l3.4699"></a><span id="l3.4699"> // Please call only with a single message ID</span>
<a href="#l3.4700"></a><span id="l3.4700" class="difflineminus">-void nsImapProtocol::Bodystructure(const nsCString &amp;messageId, bool idIsUid)</span>
<a href="#l3.4701"></a><span id="l3.4701" class="difflineminus">-{</span>
<a href="#l3.4702"></a><span id="l3.4702" class="difflineplus">+void nsImapProtocol::Bodystructure(const nsCString &amp;messageId, bool idIsUid) {</span>
<a href="#l3.4703"></a><span id="l3.4703">   IncrementCommandTagNumber();</span>
<a href="#l3.4704"></a><span id="l3.4704"> </span>
<a href="#l3.4705"></a><span id="l3.4705">   nsCString commandString(GetServerCommandTag());</span>
<a href="#l3.4706"></a><span id="l3.4706" class="difflineminus">-  if (idIsUid)</span>
<a href="#l3.4707"></a><span id="l3.4707" class="difflineminus">-    commandString.AppendLiteral(&quot; UID&quot;);</span>
<a href="#l3.4708"></a><span id="l3.4708" class="difflineplus">+  if (idIsUid) commandString.AppendLiteral(&quot; UID&quot;);</span>
<a href="#l3.4709"></a><span id="l3.4709">   commandString.AppendLiteral(&quot; fetch &quot;);</span>
<a href="#l3.4710"></a><span id="l3.4710"> </span>
<a href="#l3.4711"></a><span id="l3.4711">   commandString.Append(messageId);</span>
<a href="#l3.4712"></a><span id="l3.4712">   commandString.AppendLiteral(&quot; (BODYSTRUCTURE)&quot; CRLF);</span>
<a href="#l3.4713"></a><span id="l3.4713"> </span>
<a href="#l3.4714"></a><span id="l3.4714">   nsresult rv = SendData(commandString.get());</span>
<a href="#l3.4715"></a><span id="l3.4715" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.4716"></a><span id="l3.4716" class="difflineminus">-      ParseIMAPandCheckForNewMail(commandString.get());</span>
<a href="#l3.4717"></a><span id="l3.4717" class="difflineminus">-}</span>
<a href="#l3.4718"></a><span id="l3.4718" class="difflineminus">-</span>
<a href="#l3.4719"></a><span id="l3.4719" class="difflineminus">-void nsImapProtocol::PipelinedFetchMessageParts(const char *uid, nsIMAPMessagePartIDArray *parts)</span>
<a href="#l3.4720"></a><span id="l3.4720" class="difflineminus">-{</span>
<a href="#l3.4721"></a><span id="l3.4721" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(commandString.get());</span>
<a href="#l3.4722"></a><span id="l3.4722" class="difflineplus">+}</span>
<a href="#l3.4723"></a><span id="l3.4723" class="difflineplus">+</span>
<a href="#l3.4724"></a><span id="l3.4724" class="difflineplus">+void nsImapProtocol::PipelinedFetchMessageParts(</span>
<a href="#l3.4725"></a><span id="l3.4725" class="difflineplus">+    const char *uid, nsIMAPMessagePartIDArray *parts) {</span>
<a href="#l3.4726"></a><span id="l3.4726">   // assumes no chunking</span>
<a href="#l3.4727"></a><span id="l3.4727"> </span>
<a href="#l3.4728"></a><span id="l3.4728">   // build up a string to fetch</span>
<a href="#l3.4729"></a><span id="l3.4729">   nsCString stringToFetch, what;</span>
<a href="#l3.4730"></a><span id="l3.4730">   uint32_t currentPartNum = 0;</span>
<a href="#l3.4731"></a><span id="l3.4731" class="difflineminus">-  while ((parts-&gt;GetNumParts() &gt; currentPartNum) &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.4732"></a><span id="l3.4732" class="difflineminus">-  {</span>
<a href="#l3.4733"></a><span id="l3.4733" class="difflineplus">+  while ((parts-&gt;GetNumParts() &gt; currentPartNum) &amp;&amp; !DeathSignalReceived()) {</span>
<a href="#l3.4734"></a><span id="l3.4734">     nsIMAPMessagePartID *currentPart = parts-&gt;GetPart(currentPartNum);</span>
<a href="#l3.4735"></a><span id="l3.4735" class="difflineminus">-    if (currentPart)</span>
<a href="#l3.4736"></a><span id="l3.4736" class="difflineminus">-    {</span>
<a href="#l3.4737"></a><span id="l3.4737" class="difflineplus">+    if (currentPart) {</span>
<a href="#l3.4738"></a><span id="l3.4738">       // Do things here depending on the type of message part</span>
<a href="#l3.4739"></a><span id="l3.4739">       // Append it to the fetch string</span>
<a href="#l3.4740"></a><span id="l3.4740" class="difflineminus">-      if (currentPartNum &gt; 0)</span>
<a href="#l3.4741"></a><span id="l3.4741" class="difflineminus">-        stringToFetch.Append(' ');</span>
<a href="#l3.4742"></a><span id="l3.4742" class="difflineminus">-</span>
<a href="#l3.4743"></a><span id="l3.4743" class="difflineminus">-      switch (currentPart-&gt;GetFields())</span>
<a href="#l3.4744"></a><span id="l3.4744" class="difflineminus">-      {</span>
<a href="#l3.4745"></a><span id="l3.4745" class="difflineminus">-      case kMIMEHeader:</span>
<a href="#l3.4746"></a><span id="l3.4746" class="difflineminus">-        what = &quot;BODY.PEEK[&quot;;</span>
<a href="#l3.4747"></a><span id="l3.4747" class="difflineminus">-        what.Append(currentPart-&gt;GetPartNumberString());</span>
<a href="#l3.4748"></a><span id="l3.4748" class="difflineminus">-        what.AppendLiteral(&quot;.MIME]&quot;);</span>
<a href="#l3.4749"></a><span id="l3.4749" class="difflineminus">-        stringToFetch.Append(what);</span>
<a href="#l3.4750"></a><span id="l3.4750" class="difflineminus">-        break;</span>
<a href="#l3.4751"></a><span id="l3.4751" class="difflineminus">-      case kRFC822HeadersOnly:</span>
<a href="#l3.4752"></a><span id="l3.4752" class="difflineminus">-        if (currentPart-&gt;GetPartNumberString())</span>
<a href="#l3.4753"></a><span id="l3.4753" class="difflineminus">-        {</span>
<a href="#l3.4754"></a><span id="l3.4754" class="difflineplus">+      if (currentPartNum &gt; 0) stringToFetch.Append(' ');</span>
<a href="#l3.4755"></a><span id="l3.4755" class="difflineplus">+</span>
<a href="#l3.4756"></a><span id="l3.4756" class="difflineplus">+      switch (currentPart-&gt;GetFields()) {</span>
<a href="#l3.4757"></a><span id="l3.4757" class="difflineplus">+        case kMIMEHeader:</span>
<a href="#l3.4758"></a><span id="l3.4758">           what = &quot;BODY.PEEK[&quot;;</span>
<a href="#l3.4759"></a><span id="l3.4759">           what.Append(currentPart-&gt;GetPartNumberString());</span>
<a href="#l3.4760"></a><span id="l3.4760" class="difflineminus">-          what.AppendLiteral(&quot;.HEADER]&quot;);</span>
<a href="#l3.4761"></a><span id="l3.4761" class="difflineplus">+          what.AppendLiteral(&quot;.MIME]&quot;);</span>
<a href="#l3.4762"></a><span id="l3.4762">           stringToFetch.Append(what);</span>
<a href="#l3.4763"></a><span id="l3.4763" class="difflineminus">-        }</span>
<a href="#l3.4764"></a><span id="l3.4764" class="difflineminus">-        else</span>
<a href="#l3.4765"></a><span id="l3.4765" class="difflineminus">-        {</span>
<a href="#l3.4766"></a><span id="l3.4766" class="difflineminus">-          // headers for the top-level message</span>
<a href="#l3.4767"></a><span id="l3.4767" class="difflineminus">-          stringToFetch.AppendLiteral(&quot;BODY.PEEK[HEADER]&quot;);</span>
<a href="#l3.4768"></a><span id="l3.4768" class="difflineminus">-        }</span>
<a href="#l3.4769"></a><span id="l3.4769" class="difflineminus">-        break;</span>
<a href="#l3.4770"></a><span id="l3.4770" class="difflineminus">-      default:</span>
<a href="#l3.4771"></a><span id="l3.4771" class="difflineminus">-        NS_ASSERTION(false, &quot;we should only be pipelining MIME headers and Message headers&quot;);</span>
<a href="#l3.4772"></a><span id="l3.4772" class="difflineminus">-        break;</span>
<a href="#l3.4773"></a><span id="l3.4773" class="difflineplus">+          break;</span>
<a href="#l3.4774"></a><span id="l3.4774" class="difflineplus">+        case kRFC822HeadersOnly:</span>
<a href="#l3.4775"></a><span id="l3.4775" class="difflineplus">+          if (currentPart-&gt;GetPartNumberString()) {</span>
<a href="#l3.4776"></a><span id="l3.4776" class="difflineplus">+            what = &quot;BODY.PEEK[&quot;;</span>
<a href="#l3.4777"></a><span id="l3.4777" class="difflineplus">+            what.Append(currentPart-&gt;GetPartNumberString());</span>
<a href="#l3.4778"></a><span id="l3.4778" class="difflineplus">+            what.AppendLiteral(&quot;.HEADER]&quot;);</span>
<a href="#l3.4779"></a><span id="l3.4779" class="difflineplus">+            stringToFetch.Append(what);</span>
<a href="#l3.4780"></a><span id="l3.4780" class="difflineplus">+          } else {</span>
<a href="#l3.4781"></a><span id="l3.4781" class="difflineplus">+            // headers for the top-level message</span>
<a href="#l3.4782"></a><span id="l3.4782" class="difflineplus">+            stringToFetch.AppendLiteral(&quot;BODY.PEEK[HEADER]&quot;);</span>
<a href="#l3.4783"></a><span id="l3.4783" class="difflineplus">+          }</span>
<a href="#l3.4784"></a><span id="l3.4784" class="difflineplus">+          break;</span>
<a href="#l3.4785"></a><span id="l3.4785" class="difflineplus">+        default:</span>
<a href="#l3.4786"></a><span id="l3.4786" class="difflineplus">+          NS_ASSERTION(</span>
<a href="#l3.4787"></a><span id="l3.4787" class="difflineplus">+              false,</span>
<a href="#l3.4788"></a><span id="l3.4788" class="difflineplus">+              &quot;we should only be pipelining MIME headers and Message headers&quot;);</span>
<a href="#l3.4789"></a><span id="l3.4789" class="difflineplus">+          break;</span>
<a href="#l3.4790"></a><span id="l3.4790">       }</span>
<a href="#l3.4791"></a><span id="l3.4791">     }</span>
<a href="#l3.4792"></a><span id="l3.4792">     currentPartNum++;</span>
<a href="#l3.4793"></a><span id="l3.4793">   }</span>
<a href="#l3.4794"></a><span id="l3.4794"> </span>
<a href="#l3.4795"></a><span id="l3.4795">   // Run the single, pipelined fetch command</span>
<a href="#l3.4796"></a><span id="l3.4796" class="difflineminus">-  if ((parts-&gt;GetNumParts() &gt; 0) &amp;&amp; !DeathSignalReceived() &amp;&amp; !GetPseudoInterrupted() &amp;&amp; stringToFetch.get())</span>
<a href="#l3.4797"></a><span id="l3.4797" class="difflineminus">-  {</span>
<a href="#l3.4798"></a><span id="l3.4798" class="difflineminus">-      IncrementCommandTagNumber();</span>
<a href="#l3.4799"></a><span id="l3.4799" class="difflineplus">+  if ((parts-&gt;GetNumParts() &gt; 0) &amp;&amp; !DeathSignalReceived() &amp;&amp;</span>
<a href="#l3.4800"></a><span id="l3.4800" class="difflineplus">+      !GetPseudoInterrupted() &amp;&amp; stringToFetch.get()) {</span>
<a href="#l3.4801"></a><span id="l3.4801" class="difflineplus">+    IncrementCommandTagNumber();</span>
<a href="#l3.4802"></a><span id="l3.4802"> </span>
<a href="#l3.4803"></a><span id="l3.4803">     nsCString commandString(GetServerCommandTag());</span>
<a href="#l3.4804"></a><span id="l3.4804">     commandString.AppendLiteral(&quot; UID fetch &quot;);</span>
<a href="#l3.4805"></a><span id="l3.4805">     commandString.Append(uid, 10);</span>
<a href="#l3.4806"></a><span id="l3.4806">     commandString.AppendLiteral(&quot; (&quot;);</span>
<a href="#l3.4807"></a><span id="l3.4807">     commandString.Append(stringToFetch);</span>
<a href="#l3.4808"></a><span id="l3.4808">     commandString.AppendLiteral(&quot;)&quot; CRLF);</span>
<a href="#l3.4809"></a><span id="l3.4809">     nsresult rv = SendData(commandString.get());</span>
<a href="#l3.4810"></a><span id="l3.4810" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l3.4811"></a><span id="l3.4811" class="difflineminus">-            ParseIMAPandCheckForNewMail(commandString.get());</span>
<a href="#l3.4812"></a><span id="l3.4812" class="difflineminus">-  }</span>
<a href="#l3.4813"></a><span id="l3.4813" class="difflineminus">-}</span>
<a href="#l3.4814"></a><span id="l3.4814" class="difflineminus">-</span>
<a href="#l3.4815"></a><span id="l3.4815" class="difflineminus">-void nsImapProtocol::FetchMsgAttribute(const nsCString &amp;messageIds, const nsCString &amp;attribute)</span>
<a href="#l3.4816"></a><span id="l3.4816" class="difflineminus">-{</span>
<a href="#l3.4817"></a><span id="l3.4817" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.4818"></a><span id="l3.4818" class="difflineminus">-</span>
<a href="#l3.4819"></a><span id="l3.4819" class="difflineminus">-    nsAutoCString commandString (GetServerCommandTag());</span>
<a href="#l3.4820"></a><span id="l3.4820" class="difflineminus">-    commandString.AppendLiteral(&quot; UID fetch &quot;);</span>
<a href="#l3.4821"></a><span id="l3.4821" class="difflineminus">-    commandString.Append(messageIds);</span>
<a href="#l3.4822"></a><span id="l3.4822" class="difflineminus">-    commandString.AppendLiteral(&quot; (&quot;);</span>
<a href="#l3.4823"></a><span id="l3.4823" class="difflineminus">-    commandString.Append(attribute);</span>
<a href="#l3.4824"></a><span id="l3.4824" class="difflineminus">-    commandString.AppendLiteral(&quot;)&quot; CRLF);</span>
<a href="#l3.4825"></a><span id="l3.4825" class="difflineminus">-    nsresult rv = SendData(commandString.get());</span>
<a href="#l3.4826"></a><span id="l3.4826" class="difflineminus">-</span>
<a href="#l3.4827"></a><span id="l3.4827" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.4828"></a><span id="l3.4828" class="difflineminus">-       ParseIMAPandCheckForNewMail(commandString.get());</span>
<a href="#l3.4829"></a><span id="l3.4829" class="difflineminus">-    GetServerStateParser().SetFetchingFlags(false);</span>
<a href="#l3.4830"></a><span id="l3.4830" class="difflineminus">-    // Always clear this flag after every fetch.</span>
<a href="#l3.4831"></a><span id="l3.4831" class="difflineminus">-    m_fetchingWholeMessage = false;</span>
<a href="#l3.4832"></a><span id="l3.4832" class="difflineplus">+    if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(commandString.get());</span>
<a href="#l3.4833"></a><span id="l3.4833" class="difflineplus">+  }</span>
<a href="#l3.4834"></a><span id="l3.4834" class="difflineplus">+}</span>
<a href="#l3.4835"></a><span id="l3.4835" class="difflineplus">+</span>
<a href="#l3.4836"></a><span id="l3.4836" class="difflineplus">+void nsImapProtocol::FetchMsgAttribute(const nsCString &amp;messageIds,</span>
<a href="#l3.4837"></a><span id="l3.4837" class="difflineplus">+                                       const nsCString &amp;attribute) {</span>
<a href="#l3.4838"></a><span id="l3.4838" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.4839"></a><span id="l3.4839" class="difflineplus">+</span>
<a href="#l3.4840"></a><span id="l3.4840" class="difflineplus">+  nsAutoCString commandString(GetServerCommandTag());</span>
<a href="#l3.4841"></a><span id="l3.4841" class="difflineplus">+  commandString.AppendLiteral(&quot; UID fetch &quot;);</span>
<a href="#l3.4842"></a><span id="l3.4842" class="difflineplus">+  commandString.Append(messageIds);</span>
<a href="#l3.4843"></a><span id="l3.4843" class="difflineplus">+  commandString.AppendLiteral(&quot; (&quot;);</span>
<a href="#l3.4844"></a><span id="l3.4844" class="difflineplus">+  commandString.Append(attribute);</span>
<a href="#l3.4845"></a><span id="l3.4845" class="difflineplus">+  commandString.AppendLiteral(&quot;)&quot; CRLF);</span>
<a href="#l3.4846"></a><span id="l3.4846" class="difflineplus">+  nsresult rv = SendData(commandString.get());</span>
<a href="#l3.4847"></a><span id="l3.4847" class="difflineplus">+</span>
<a href="#l3.4848"></a><span id="l3.4848" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(commandString.get());</span>
<a href="#l3.4849"></a><span id="l3.4849" class="difflineplus">+  GetServerStateParser().SetFetchingFlags(false);</span>
<a href="#l3.4850"></a><span id="l3.4850" class="difflineplus">+  // Always clear this flag after every fetch.</span>
<a href="#l3.4851"></a><span id="l3.4851" class="difflineplus">+  m_fetchingWholeMessage = false;</span>
<a href="#l3.4852"></a><span id="l3.4852"> }</span>
<a href="#l3.4853"></a><span id="l3.4853"> </span>
<a href="#l3.4854"></a><span id="l3.4854"> // this routine is used to fetch a message or messages, or headers for a</span>
<a href="#l3.4855"></a><span id="l3.4855"> // message...</span>
<a href="#l3.4856"></a><span id="l3.4856"> </span>
<a href="#l3.4857"></a><span id="l3.4857" class="difflineminus">-void nsImapProtocol::FallbackToFetchWholeMsg(const nsCString &amp;messageId, uint32_t messageSize)</span>
<a href="#l3.4858"></a><span id="l3.4858" class="difflineminus">-{</span>
<a href="#l3.4859"></a><span id="l3.4859" class="difflineminus">-  if (m_imapMessageSink &amp;&amp; m_runningUrl)</span>
<a href="#l3.4860"></a><span id="l3.4860" class="difflineminus">-  {</span>
<a href="#l3.4861"></a><span id="l3.4861" class="difflineplus">+void nsImapProtocol::FallbackToFetchWholeMsg(const nsCString &amp;messageId,</span>
<a href="#l3.4862"></a><span id="l3.4862" class="difflineplus">+                                             uint32_t messageSize) {</span>
<a href="#l3.4863"></a><span id="l3.4863" class="difflineplus">+  if (m_imapMessageSink &amp;&amp; m_runningUrl) {</span>
<a href="#l3.4864"></a><span id="l3.4864">     bool shouldStoreMsgOffline;</span>
<a href="#l3.4865"></a><span id="l3.4865">     m_runningUrl-&gt;GetStoreOfflineOnFallback(&amp;shouldStoreMsgOffline);</span>
<a href="#l3.4866"></a><span id="l3.4866">     m_runningUrl-&gt;SetStoreResultsOffline(shouldStoreMsgOffline);</span>
<a href="#l3.4867"></a><span id="l3.4867">   }</span>
<a href="#l3.4868"></a><span id="l3.4868">   FetchTryChunking(messageId,</span>
<a href="#l3.4869"></a><span id="l3.4869" class="difflineminus">-                   m_imapAction == nsIImapUrl::nsImapMsgFetchPeek ?</span>
<a href="#l3.4870"></a><span id="l3.4870" class="difflineminus">-                     kEveryThingRFC822Peek : kEveryThingRFC822,</span>
<a href="#l3.4871"></a><span id="l3.4871" class="difflineplus">+                   m_imapAction == nsIImapUrl::nsImapMsgFetchPeek</span>
<a href="#l3.4872"></a><span id="l3.4872" class="difflineplus">+                       ? kEveryThingRFC822Peek</span>
<a href="#l3.4873"></a><span id="l3.4873" class="difflineplus">+                       : kEveryThingRFC822,</span>
<a href="#l3.4874"></a><span id="l3.4874">                    true, nullptr, messageSize, true);</span>
<a href="#l3.4875"></a><span id="l3.4875"> }</span>
<a href="#l3.4876"></a><span id="l3.4876"> </span>
<a href="#l3.4877"></a><span id="l3.4877" class="difflineminus">-void</span>
<a href="#l3.4878"></a><span id="l3.4878" class="difflineminus">-nsImapProtocol::FetchMessage(const nsCString &amp;messageIds,</span>
<a href="#l3.4879"></a><span id="l3.4879" class="difflineminus">-                             nsIMAPeFetchFields whatToFetch,</span>
<a href="#l3.4880"></a><span id="l3.4880" class="difflineminus">-                             const char *fetchModifier,</span>
<a href="#l3.4881"></a><span id="l3.4881" class="difflineminus">-                             uint32_t startByte, uint32_t numBytes,</span>
<a href="#l3.4882"></a><span id="l3.4882" class="difflineminus">-                             char *part)</span>
<a href="#l3.4883"></a><span id="l3.4883" class="difflineminus">-{</span>
<a href="#l3.4884"></a><span id="l3.4884" class="difflineplus">+void nsImapProtocol::FetchMessage(const nsCString &amp;messageIds,</span>
<a href="#l3.4885"></a><span id="l3.4885" class="difflineplus">+                                  nsIMAPeFetchFields whatToFetch,</span>
<a href="#l3.4886"></a><span id="l3.4886" class="difflineplus">+                                  const char *fetchModifier, uint32_t startByte,</span>
<a href="#l3.4887"></a><span id="l3.4887" class="difflineplus">+                                  uint32_t numBytes, char *part) {</span>
<a href="#l3.4888"></a><span id="l3.4888">   IncrementCommandTagNumber();</span>
<a href="#l3.4889"></a><span id="l3.4889"> </span>
<a href="#l3.4890"></a><span id="l3.4890">   nsCString commandString;</span>
<a href="#l3.4891"></a><span id="l3.4891">   commandString = &quot;%s UID fetch&quot;;</span>
<a href="#l3.4892"></a><span id="l3.4892"> </span>
<a href="#l3.4893"></a><span id="l3.4893">   switch (whatToFetch) {</span>
<a href="#l3.4894"></a><span id="l3.4894" class="difflineminus">-  case kEveryThingRFC822:</span>
<a href="#l3.4895"></a><span id="l3.4895" class="difflineminus">-    m_flagChangeCount++;</span>
<a href="#l3.4896"></a><span id="l3.4896" class="difflineminus">-    m_fetchingWholeMessage = true;</span>
<a href="#l3.4897"></a><span id="l3.4897" class="difflineminus">-    if (m_trackingTime)</span>
<a href="#l3.4898"></a><span id="l3.4898" class="difflineminus">-      AdjustChunkSize();      // we started another segment</span>
<a href="#l3.4899"></a><span id="l3.4899" class="difflineminus">-    m_startTime = PR_Now();     // save start of download time</span>
<a href="#l3.4900"></a><span id="l3.4900" class="difflineminus">-    m_trackingTime = true;</span>
<a href="#l3.4901"></a><span id="l3.4901" class="difflineminus">-    MOZ_LOG(IMAP, LogLevel::Debug, (&quot;FetchMessage everything: curFetchSize %u numBytes %u&quot;,</span>
<a href="#l3.4902"></a><span id="l3.4902" class="difflineminus">-                                m_curFetchSize, numBytes));</span>
<a href="#l3.4903"></a><span id="l3.4903" class="difflineminus">-    if (numBytes &gt; 0)</span>
<a href="#l3.4904"></a><span id="l3.4904" class="difflineminus">-      m_curFetchSize = numBytes;</span>
<a href="#l3.4905"></a><span id="l3.4905" class="difflineminus">-</span>
<a href="#l3.4906"></a><span id="l3.4906" class="difflineminus">-    if (GetServerStateParser().ServerHasIMAP4Rev1Capability())</span>
<a href="#l3.4907"></a><span id="l3.4907" class="difflineminus">-    {</span>
<a href="#l3.4908"></a><span id="l3.4908" class="difflineminus">-      if (GetServerStateParser().GetCapabilityFlag() &amp; kHasXSenderCapability)</span>
<a href="#l3.4909"></a><span id="l3.4909" class="difflineminus">-        commandString.AppendLiteral(&quot; %s (XSENDER UID RFC822.SIZE BODY[]&quot;);</span>
<a href="#l3.4910"></a><span id="l3.4910" class="difflineminus">-      else</span>
<a href="#l3.4911"></a><span id="l3.4911" class="difflineminus">-        commandString.AppendLiteral(&quot; %s (UID RFC822.SIZE BODY[]&quot;);</span>
<a href="#l3.4912"></a><span id="l3.4912" class="difflineminus">-    }</span>
<a href="#l3.4913"></a><span id="l3.4913" class="difflineminus">-    else</span>
<a href="#l3.4914"></a><span id="l3.4914" class="difflineminus">-    {</span>
<a href="#l3.4915"></a><span id="l3.4915" class="difflineminus">-      if (GetServerStateParser().GetCapabilityFlag() &amp; kHasXSenderCapability)</span>
<a href="#l3.4916"></a><span id="l3.4916" class="difflineminus">-        commandString.AppendLiteral(&quot; %s (XSENDER UID RFC822.SIZE RFC822&quot;);</span>
<a href="#l3.4917"></a><span id="l3.4917" class="difflineminus">-      else</span>
<a href="#l3.4918"></a><span id="l3.4918" class="difflineminus">-        commandString.AppendLiteral(&quot; %s (UID RFC822.SIZE RFC822&quot;);</span>
<a href="#l3.4919"></a><span id="l3.4919" class="difflineminus">-    }</span>
<a href="#l3.4920"></a><span id="l3.4920" class="difflineminus">-    if (numBytes &gt; 0)</span>
<a href="#l3.4921"></a><span id="l3.4921" class="difflineminus">-    {</span>
<a href="#l3.4922"></a><span id="l3.4922" class="difflineminus">-      // if we are retrieving chunks</span>
<a href="#l3.4923"></a><span id="l3.4923" class="difflineminus">-      char *byterangeString = PR_smprintf(&quot;&lt;%ld.%ld&gt;&quot;,startByte, numBytes);</span>
<a href="#l3.4924"></a><span id="l3.4924" class="difflineminus">-      if (byterangeString)</span>
<a href="#l3.4925"></a><span id="l3.4925" class="difflineminus">-      {</span>
<a href="#l3.4926"></a><span id="l3.4926" class="difflineminus">-        commandString.Append(byterangeString);</span>
<a href="#l3.4927"></a><span id="l3.4927" class="difflineminus">-        PR_Free(byterangeString);</span>
<a href="#l3.4928"></a><span id="l3.4928" class="difflineplus">+    case kEveryThingRFC822:</span>
<a href="#l3.4929"></a><span id="l3.4929" class="difflineplus">+      m_flagChangeCount++;</span>
<a href="#l3.4930"></a><span id="l3.4930" class="difflineplus">+      m_fetchingWholeMessage = true;</span>
<a href="#l3.4931"></a><span id="l3.4931" class="difflineplus">+      if (m_trackingTime) AdjustChunkSize();  // we started another segment</span>
<a href="#l3.4932"></a><span id="l3.4932" class="difflineplus">+      m_startTime = PR_Now();                 // save start of download time</span>
<a href="#l3.4933"></a><span id="l3.4933" class="difflineplus">+      m_trackingTime = true;</span>
<a href="#l3.4934"></a><span id="l3.4934" class="difflineplus">+      MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.4935"></a><span id="l3.4935" class="difflineplus">+              (&quot;FetchMessage everything: curFetchSize %u numBytes %u&quot;,</span>
<a href="#l3.4936"></a><span id="l3.4936" class="difflineplus">+               m_curFetchSize, numBytes));</span>
<a href="#l3.4937"></a><span id="l3.4937" class="difflineplus">+      if (numBytes &gt; 0) m_curFetchSize = numBytes;</span>
<a href="#l3.4938"></a><span id="l3.4938" class="difflineplus">+</span>
<a href="#l3.4939"></a><span id="l3.4939" class="difflineplus">+      if (GetServerStateParser().ServerHasIMAP4Rev1Capability()) {</span>
<a href="#l3.4940"></a><span id="l3.4940" class="difflineplus">+        if (GetServerStateParser().GetCapabilityFlag() &amp; kHasXSenderCapability)</span>
<a href="#l3.4941"></a><span id="l3.4941" class="difflineplus">+          commandString.AppendLiteral(&quot; %s (XSENDER UID RFC822.SIZE BODY[]&quot;);</span>
<a href="#l3.4942"></a><span id="l3.4942" class="difflineplus">+        else</span>
<a href="#l3.4943"></a><span id="l3.4943" class="difflineplus">+          commandString.AppendLiteral(&quot; %s (UID RFC822.SIZE BODY[]&quot;);</span>
<a href="#l3.4944"></a><span id="l3.4944" class="difflineplus">+      } else {</span>
<a href="#l3.4945"></a><span id="l3.4945" class="difflineplus">+        if (GetServerStateParser().GetCapabilityFlag() &amp; kHasXSenderCapability)</span>
<a href="#l3.4946"></a><span id="l3.4946" class="difflineplus">+          commandString.AppendLiteral(&quot; %s (XSENDER UID RFC822.SIZE RFC822&quot;);</span>
<a href="#l3.4947"></a><span id="l3.4947" class="difflineplus">+        else</span>
<a href="#l3.4948"></a><span id="l3.4948" class="difflineplus">+          commandString.AppendLiteral(&quot; %s (UID RFC822.SIZE RFC822&quot;);</span>
<a href="#l3.4949"></a><span id="l3.4949">       }</span>
<a href="#l3.4950"></a><span id="l3.4950" class="difflineminus">-    }</span>
<a href="#l3.4951"></a><span id="l3.4951" class="difflineminus">-    commandString.Append(')');</span>
<a href="#l3.4952"></a><span id="l3.4952" class="difflineminus">-</span>
<a href="#l3.4953"></a><span id="l3.4953" class="difflineminus">-    break;</span>
<a href="#l3.4954"></a><span id="l3.4954" class="difflineminus">-</span>
<a href="#l3.4955"></a><span id="l3.4955" class="difflineminus">-  case kEveryThingRFC822Peek:</span>
<a href="#l3.4956"></a><span id="l3.4956" class="difflineminus">-    {</span>
<a href="#l3.4957"></a><span id="l3.4957" class="difflineminus">-      MOZ_LOG(IMAP, LogLevel::Debug, (&quot;FetchMessage peek: curFetchSize %u numBytes %u&quot;,</span>
<a href="#l3.4958"></a><span id="l3.4958" class="difflineminus">-                                  m_curFetchSize, numBytes));</span>
<a href="#l3.4959"></a><span id="l3.4959" class="difflineminus">-      if (numBytes &gt; 0)</span>
<a href="#l3.4960"></a><span id="l3.4960" class="difflineminus">-        m_curFetchSize = numBytes;</span>
<a href="#l3.4961"></a><span id="l3.4961" class="difflineplus">+      if (numBytes &gt; 0) {</span>
<a href="#l3.4962"></a><span id="l3.4962" class="difflineplus">+        // if we are retrieving chunks</span>
<a href="#l3.4963"></a><span id="l3.4963" class="difflineplus">+        char *byterangeString = PR_smprintf(&quot;&lt;%ld.%ld&gt;&quot;, startByte, numBytes);</span>
<a href="#l3.4964"></a><span id="l3.4964" class="difflineplus">+        if (byterangeString) {</span>
<a href="#l3.4965"></a><span id="l3.4965" class="difflineplus">+          commandString.Append(byterangeString);</span>
<a href="#l3.4966"></a><span id="l3.4966" class="difflineplus">+          PR_Free(byterangeString);</span>
<a href="#l3.4967"></a><span id="l3.4967" class="difflineplus">+        }</span>
<a href="#l3.4968"></a><span id="l3.4968" class="difflineplus">+      }</span>
<a href="#l3.4969"></a><span id="l3.4969" class="difflineplus">+      commandString.Append(')');</span>
<a href="#l3.4970"></a><span id="l3.4970" class="difflineplus">+</span>
<a href="#l3.4971"></a><span id="l3.4971" class="difflineplus">+      break;</span>
<a href="#l3.4972"></a><span id="l3.4972" class="difflineplus">+</span>
<a href="#l3.4973"></a><span id="l3.4973" class="difflineplus">+    case kEveryThingRFC822Peek: {</span>
<a href="#l3.4974"></a><span id="l3.4974" class="difflineplus">+      MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.4975"></a><span id="l3.4975" class="difflineplus">+              (&quot;FetchMessage peek: curFetchSize %u numBytes %u&quot;, m_curFetchSize,</span>
<a href="#l3.4976"></a><span id="l3.4976" class="difflineplus">+               numBytes));</span>
<a href="#l3.4977"></a><span id="l3.4977" class="difflineplus">+      if (numBytes &gt; 0) m_curFetchSize = numBytes;</span>
<a href="#l3.4978"></a><span id="l3.4978">       const char *formatString = &quot;&quot;;</span>
<a href="#l3.4979"></a><span id="l3.4979" class="difflineminus">-      eIMAPCapabilityFlags server_capabilityFlags = GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.4980"></a><span id="l3.4980" class="difflineplus">+      eIMAPCapabilityFlags server_capabilityFlags =</span>
<a href="#l3.4981"></a><span id="l3.4981" class="difflineplus">+          GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.4982"></a><span id="l3.4982"> </span>
<a href="#l3.4983"></a><span id="l3.4983">       m_fetchingWholeMessage = true;</span>
<a href="#l3.4984"></a><span id="l3.4984" class="difflineminus">-      if (server_capabilityFlags &amp; kIMAP4rev1Capability)</span>
<a href="#l3.4985"></a><span id="l3.4985" class="difflineminus">-      {</span>
<a href="#l3.4986"></a><span id="l3.4986" class="difflineplus">+      if (server_capabilityFlags &amp; kIMAP4rev1Capability) {</span>
<a href="#l3.4987"></a><span id="l3.4987">         // use body[].peek since rfc822.peek is not in IMAP4rev1</span>
<a href="#l3.4988"></a><span id="l3.4988">         if (server_capabilityFlags &amp; kHasXSenderCapability)</span>
<a href="#l3.4989"></a><span id="l3.4989">           formatString = &quot; %s (XSENDER UID RFC822.SIZE BODY.PEEK[]&quot;;</span>
<a href="#l3.4990"></a><span id="l3.4990">         else</span>
<a href="#l3.4991"></a><span id="l3.4991">           formatString = &quot; %s (UID RFC822.SIZE BODY.PEEK[]&quot;;</span>
<a href="#l3.4992"></a><span id="l3.4992" class="difflineminus">-      }</span>
<a href="#l3.4993"></a><span id="l3.4993" class="difflineminus">-      else</span>
<a href="#l3.4994"></a><span id="l3.4994" class="difflineminus">-      {</span>
<a href="#l3.4995"></a><span id="l3.4995" class="difflineplus">+      } else {</span>
<a href="#l3.4996"></a><span id="l3.4996">         if (server_capabilityFlags &amp; kHasXSenderCapability)</span>
<a href="#l3.4997"></a><span id="l3.4997">           formatString = &quot; %s (XSENDER UID RFC822.SIZE RFC822.peek&quot;;</span>
<a href="#l3.4998"></a><span id="l3.4998">         else</span>
<a href="#l3.4999"></a><span id="l3.4999">           formatString = &quot; %s (UID RFC822.SIZE RFC822.peek&quot;;</span>
<a href="#l3.5000"></a><span id="l3.5000">       }</span>
<a href="#l3.5001"></a><span id="l3.5001"> </span>
<a href="#l3.5002"></a><span id="l3.5002">       commandString.Append(formatString);</span>
<a href="#l3.5003"></a><span id="l3.5003" class="difflineminus">-      if (numBytes &gt; 0)</span>
<a href="#l3.5004"></a><span id="l3.5004" class="difflineminus">-      {</span>
<a href="#l3.5005"></a><span id="l3.5005" class="difflineplus">+      if (numBytes &gt; 0) {</span>
<a href="#l3.5006"></a><span id="l3.5006">         // if we are retrieving chunks</span>
<a href="#l3.5007"></a><span id="l3.5007" class="difflineminus">-        char *byterangeString = PR_smprintf(&quot;&lt;%ld.%ld&gt;&quot;,startByte, numBytes);</span>
<a href="#l3.5008"></a><span id="l3.5008" class="difflineminus">-        if (byterangeString)</span>
<a href="#l3.5009"></a><span id="l3.5009" class="difflineminus">-        {</span>
<a href="#l3.5010"></a><span id="l3.5010" class="difflineplus">+        char *byterangeString = PR_smprintf(&quot;&lt;%ld.%ld&gt;&quot;, startByte, numBytes);</span>
<a href="#l3.5011"></a><span id="l3.5011" class="difflineplus">+        if (byterangeString) {</span>
<a href="#l3.5012"></a><span id="l3.5012">           commandString.Append(byterangeString);</span>
<a href="#l3.5013"></a><span id="l3.5013">           PR_Free(byterangeString);</span>
<a href="#l3.5014"></a><span id="l3.5014">         }</span>
<a href="#l3.5015"></a><span id="l3.5015">       }</span>
<a href="#l3.5016"></a><span id="l3.5016">       commandString.Append(')');</span>
<a href="#l3.5017"></a><span id="l3.5017" class="difflineminus">-    }</span>
<a href="#l3.5018"></a><span id="l3.5018" class="difflineminus">-    break;</span>
<a href="#l3.5019"></a><span id="l3.5019" class="difflineminus">-  case kHeadersRFC822andUid:</span>
<a href="#l3.5020"></a><span id="l3.5020" class="difflineminus">-    if (GetServerStateParser().ServerHasIMAP4Rev1Capability())</span>
<a href="#l3.5021"></a><span id="l3.5021" class="difflineminus">-    {</span>
<a href="#l3.5022"></a><span id="l3.5022" class="difflineminus">-      eIMAPCapabilityFlags server_capabilityFlags = GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.5023"></a><span id="l3.5023" class="difflineminus">-      bool aolImapServer = ((server_capabilityFlags &amp; kAOLImapCapability) != 0);</span>
<a href="#l3.5024"></a><span id="l3.5024" class="difflineminus">-      bool downloadAllHeaders = false;</span>
<a href="#l3.5025"></a><span id="l3.5025" class="difflineminus">-      // checks if we're filtering on &quot;any header&quot; or running a spam filter requiring all headers</span>
<a href="#l3.5026"></a><span id="l3.5026" class="difflineminus">-      GetShouldDownloadAllHeaders(&amp;downloadAllHeaders);</span>
<a href="#l3.5027"></a><span id="l3.5027" class="difflineminus">-</span>
<a href="#l3.5028"></a><span id="l3.5028" class="difflineminus">-      if (!downloadAllHeaders)  // if it's ok -- no filters on any header, etc.</span>
<a href="#l3.5029"></a><span id="l3.5029" class="difflineminus">-      {</span>
<a href="#l3.5030"></a><span id="l3.5030" class="difflineminus">-        char *headersToDL = nullptr;</span>
<a href="#l3.5031"></a><span id="l3.5031" class="difflineminus">-        char *what = nullptr;</span>
<a href="#l3.5032"></a><span id="l3.5032" class="difflineminus">-        const char *dbHeaders = (gUseEnvelopeCmd) ? IMAP_DB_HEADERS : IMAP_ENV_AND_DB_HEADERS;</span>
<a href="#l3.5033"></a><span id="l3.5033" class="difflineminus">-        nsCString arbitraryHeaders;</span>
<a href="#l3.5034"></a><span id="l3.5034" class="difflineminus">-        GetArbitraryHeadersToDownload(arbitraryHeaders);</span>
<a href="#l3.5035"></a><span id="l3.5035" class="difflineminus">-        for (uint32_t i = 0; i &lt; mCustomDBHeaders.Length(); i++)</span>
<a href="#l3.5036"></a><span id="l3.5036" class="difflineminus">-        {</span>
<a href="#l3.5037"></a><span id="l3.5037" class="difflineminus">-          if (arbitraryHeaders.Find(mCustomDBHeaders[i], /* ignoreCase = */ true) == kNotFound)</span>
<a href="#l3.5038"></a><span id="l3.5038" class="difflineminus">-          {</span>
<a href="#l3.5039"></a><span id="l3.5039" class="difflineminus">-            if (!arbitraryHeaders.IsEmpty())</span>
<a href="#l3.5040"></a><span id="l3.5040" class="difflineminus">-              arbitraryHeaders.Append(' ');</span>
<a href="#l3.5041"></a><span id="l3.5041" class="difflineminus">-            arbitraryHeaders.Append(mCustomDBHeaders[i]);</span>
<a href="#l3.5042"></a><span id="l3.5042" class="difflineminus">-          }</span>
<a href="#l3.5043"></a><span id="l3.5043" class="difflineminus">-        }</span>
<a href="#l3.5044"></a><span id="l3.5044" class="difflineminus">-        for (uint32_t i = 0; i &lt; mCustomHeaders.Length(); i++)</span>
<a href="#l3.5045"></a><span id="l3.5045" class="difflineplus">+    } break;</span>
<a href="#l3.5046"></a><span id="l3.5046" class="difflineplus">+    case kHeadersRFC822andUid:</span>
<a href="#l3.5047"></a><span id="l3.5047" class="difflineplus">+      if (GetServerStateParser().ServerHasIMAP4Rev1Capability()) {</span>
<a href="#l3.5048"></a><span id="l3.5048" class="difflineplus">+        eIMAPCapabilityFlags server_capabilityFlags =</span>
<a href="#l3.5049"></a><span id="l3.5049" class="difflineplus">+            GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.5050"></a><span id="l3.5050" class="difflineplus">+        bool aolImapServer =</span>
<a href="#l3.5051"></a><span id="l3.5051" class="difflineplus">+            ((server_capabilityFlags &amp; kAOLImapCapability) != 0);</span>
<a href="#l3.5052"></a><span id="l3.5052" class="difflineplus">+        bool downloadAllHeaders = false;</span>
<a href="#l3.5053"></a><span id="l3.5053" class="difflineplus">+        // checks if we're filtering on &quot;any header&quot; or running a spam filter</span>
<a href="#l3.5054"></a><span id="l3.5054" class="difflineplus">+        // requiring all headers</span>
<a href="#l3.5055"></a><span id="l3.5055" class="difflineplus">+        GetShouldDownloadAllHeaders(&amp;downloadAllHeaders);</span>
<a href="#l3.5056"></a><span id="l3.5056" class="difflineplus">+</span>
<a href="#l3.5057"></a><span id="l3.5057" class="difflineplus">+        if (!downloadAllHeaders)  // if it's ok -- no filters on any header,</span>
<a href="#l3.5058"></a><span id="l3.5058" class="difflineplus">+                                  // etc.</span>
<a href="#l3.5059"></a><span id="l3.5059">         {</span>
<a href="#l3.5060"></a><span id="l3.5060" class="difflineminus">-           if (arbitraryHeaders.Find(mCustomHeaders[i], /* ignoreCase = */ true) == kNotFound)</span>
<a href="#l3.5061"></a><span id="l3.5061" class="difflineminus">-          {</span>
<a href="#l3.5062"></a><span id="l3.5062" class="difflineminus">-            if (!arbitraryHeaders.IsEmpty())</span>
<a href="#l3.5063"></a><span id="l3.5063" class="difflineminus">-              arbitraryHeaders.Append(' ');</span>
<a href="#l3.5064"></a><span id="l3.5064" class="difflineminus">-            arbitraryHeaders.Append(mCustomHeaders[i]);</span>
<a href="#l3.5065"></a><span id="l3.5065" class="difflineplus">+          char *headersToDL = nullptr;</span>
<a href="#l3.5066"></a><span id="l3.5066" class="difflineplus">+          char *what = nullptr;</span>
<a href="#l3.5067"></a><span id="l3.5067" class="difflineplus">+          const char *dbHeaders =</span>
<a href="#l3.5068"></a><span id="l3.5068" class="difflineplus">+              (gUseEnvelopeCmd) ? IMAP_DB_HEADERS : IMAP_ENV_AND_DB_HEADERS;</span>
<a href="#l3.5069"></a><span id="l3.5069" class="difflineplus">+          nsCString arbitraryHeaders;</span>
<a href="#l3.5070"></a><span id="l3.5070" class="difflineplus">+          GetArbitraryHeadersToDownload(arbitraryHeaders);</span>
<a href="#l3.5071"></a><span id="l3.5071" class="difflineplus">+          for (uint32_t i = 0; i &lt; mCustomDBHeaders.Length(); i++) {</span>
<a href="#l3.5072"></a><span id="l3.5072" class="difflineplus">+            if (arbitraryHeaders.Find(mCustomDBHeaders[i],</span>
<a href="#l3.5073"></a><span id="l3.5073" class="difflineplus">+                                      /* ignoreCase = */ true) == kNotFound) {</span>
<a href="#l3.5074"></a><span id="l3.5074" class="difflineplus">+              if (!arbitraryHeaders.IsEmpty()) arbitraryHeaders.Append(' ');</span>
<a href="#l3.5075"></a><span id="l3.5075" class="difflineplus">+              arbitraryHeaders.Append(mCustomDBHeaders[i]);</span>
<a href="#l3.5076"></a><span id="l3.5076" class="difflineplus">+            }</span>
<a href="#l3.5077"></a><span id="l3.5077" class="difflineplus">+          }</span>
<a href="#l3.5078"></a><span id="l3.5078" class="difflineplus">+          for (uint32_t i = 0; i &lt; mCustomHeaders.Length(); i++) {</span>
<a href="#l3.5079"></a><span id="l3.5079" class="difflineplus">+            if (arbitraryHeaders.Find(mCustomHeaders[i],</span>
<a href="#l3.5080"></a><span id="l3.5080" class="difflineplus">+                                      /* ignoreCase = */ true) == kNotFound) {</span>
<a href="#l3.5081"></a><span id="l3.5081" class="difflineplus">+              if (!arbitraryHeaders.IsEmpty()) arbitraryHeaders.Append(' ');</span>
<a href="#l3.5082"></a><span id="l3.5082" class="difflineplus">+              arbitraryHeaders.Append(mCustomHeaders[i]);</span>
<a href="#l3.5083"></a><span id="l3.5083" class="difflineplus">+            }</span>
<a href="#l3.5084"></a><span id="l3.5084">           }</span>
<a href="#l3.5085"></a><span id="l3.5085" class="difflineplus">+          if (arbitraryHeaders.IsEmpty())</span>
<a href="#l3.5086"></a><span id="l3.5086" class="difflineplus">+            headersToDL = strdup(dbHeaders);</span>
<a href="#l3.5087"></a><span id="l3.5087" class="difflineplus">+          else</span>
<a href="#l3.5088"></a><span id="l3.5088" class="difflineplus">+            headersToDL =</span>
<a href="#l3.5089"></a><span id="l3.5089" class="difflineplus">+                PR_smprintf(&quot;%s %s&quot;, dbHeaders, arbitraryHeaders.get());</span>
<a href="#l3.5090"></a><span id="l3.5090" class="difflineplus">+</span>
<a href="#l3.5091"></a><span id="l3.5091" class="difflineplus">+          if (gUseEnvelopeCmd)</span>
<a href="#l3.5092"></a><span id="l3.5092" class="difflineplus">+            what = PR_smprintf(&quot; ENVELOPE BODY.PEEK[HEADER.FIELDS (%s)])&quot;,</span>
<a href="#l3.5093"></a><span id="l3.5093" class="difflineplus">+                               headersToDL);</span>
<a href="#l3.5094"></a><span id="l3.5094" class="difflineplus">+          else</span>
<a href="#l3.5095"></a><span id="l3.5095" class="difflineplus">+            what = PR_smprintf(&quot; BODY.PEEK[HEADER.FIELDS (%s)])&quot;, headersToDL);</span>
<a href="#l3.5096"></a><span id="l3.5096" class="difflineplus">+          free(headersToDL);</span>
<a href="#l3.5097"></a><span id="l3.5097" class="difflineplus">+          if (what) {</span>
<a href="#l3.5098"></a><span id="l3.5098" class="difflineplus">+            commandString.AppendLiteral(&quot; %s (UID &quot;);</span>
<a href="#l3.5099"></a><span id="l3.5099" class="difflineplus">+            if (m_isGmailServer)</span>
<a href="#l3.5100"></a><span id="l3.5100" class="difflineplus">+              commandString.AppendLiteral(&quot;X-GM-MSGID X-GM-THRID X-GM-LABELS &quot;);</span>
<a href="#l3.5101"></a><span id="l3.5101" class="difflineplus">+            if (aolImapServer)</span>
<a href="#l3.5102"></a><span id="l3.5102" class="difflineplus">+              commandString.AppendLiteral(&quot; XAOL.SIZE&quot;);</span>
<a href="#l3.5103"></a><span id="l3.5103" class="difflineplus">+            else</span>
<a href="#l3.5104"></a><span id="l3.5104" class="difflineplus">+              commandString.AppendLiteral(&quot;RFC822.SIZE&quot;);</span>
<a href="#l3.5105"></a><span id="l3.5105" class="difflineplus">+            commandString.AppendLiteral(&quot; FLAGS&quot;);</span>
<a href="#l3.5106"></a><span id="l3.5106" class="difflineplus">+            commandString.Append(what);</span>
<a href="#l3.5107"></a><span id="l3.5107" class="difflineplus">+            PR_Free(what);</span>
<a href="#l3.5108"></a><span id="l3.5108" class="difflineplus">+          } else {</span>
<a href="#l3.5109"></a><span id="l3.5109" class="difflineplus">+            commandString.AppendLiteral(</span>
<a href="#l3.5110"></a><span id="l3.5110" class="difflineplus">+                &quot; %s (UID RFC822.SIZE BODY.PEEK[HEADER] FLAGS)&quot;);</span>
<a href="#l3.5111"></a><span id="l3.5111" class="difflineplus">+          }</span>
<a href="#l3.5112"></a><span id="l3.5112" class="difflineplus">+        } else</span>
<a href="#l3.5113"></a><span id="l3.5113" class="difflineplus">+          commandString.AppendLiteral(</span>
<a href="#l3.5114"></a><span id="l3.5114" class="difflineplus">+              &quot; %s (UID RFC822.SIZE BODY.PEEK[HEADER] FLAGS)&quot;);</span>
<a href="#l3.5115"></a><span id="l3.5115" class="difflineplus">+      } else</span>
<a href="#l3.5116"></a><span id="l3.5116" class="difflineplus">+        commandString.AppendLiteral(</span>
<a href="#l3.5117"></a><span id="l3.5117" class="difflineplus">+            &quot; %s (UID RFC822.SIZE RFC822.HEADER FLAGS)&quot;);</span>
<a href="#l3.5118"></a><span id="l3.5118" class="difflineplus">+      break;</span>
<a href="#l3.5119"></a><span id="l3.5119" class="difflineplus">+    case kUid:</span>
<a href="#l3.5120"></a><span id="l3.5120" class="difflineplus">+      commandString.AppendLiteral(&quot; %s (UID)&quot;);</span>
<a href="#l3.5121"></a><span id="l3.5121" class="difflineplus">+      break;</span>
<a href="#l3.5122"></a><span id="l3.5122" class="difflineplus">+    case kFlags:</span>
<a href="#l3.5123"></a><span id="l3.5123" class="difflineplus">+      GetServerStateParser().SetFetchingFlags(true);</span>
<a href="#l3.5124"></a><span id="l3.5124" class="difflineplus">+      commandString.AppendLiteral(&quot; %s (FLAGS)&quot;);</span>
<a href="#l3.5125"></a><span id="l3.5125" class="difflineplus">+      break;</span>
<a href="#l3.5126"></a><span id="l3.5126" class="difflineplus">+    case kRFC822Size:</span>
<a href="#l3.5127"></a><span id="l3.5127" class="difflineplus">+      commandString.AppendLiteral(&quot; %s (RFC822.SIZE)&quot;);</span>
<a href="#l3.5128"></a><span id="l3.5128" class="difflineplus">+      break;</span>
<a href="#l3.5129"></a><span id="l3.5129" class="difflineplus">+    case kBodyStart: {</span>
<a href="#l3.5130"></a><span id="l3.5130" class="difflineplus">+      int32_t numBytesToFetch;</span>
<a href="#l3.5131"></a><span id="l3.5131" class="difflineplus">+      m_runningUrl-&gt;GetNumBytesToFetch(&amp;numBytesToFetch);</span>
<a href="#l3.5132"></a><span id="l3.5132" class="difflineplus">+</span>
<a href="#l3.5133"></a><span id="l3.5133" class="difflineplus">+      commandString.AppendLiteral(</span>
<a href="#l3.5134"></a><span id="l3.5134" class="difflineplus">+          &quot; %s (UID BODY.PEEK[HEADER.FIELDS (Content-Type &quot;</span>
<a href="#l3.5135"></a><span id="l3.5135" class="difflineplus">+          &quot;Content-Transfer-Encoding)] BODY.PEEK[TEXT]&lt;0.&quot;);</span>
<a href="#l3.5136"></a><span id="l3.5136" class="difflineplus">+      commandString.AppendInt(numBytesToFetch);</span>
<a href="#l3.5137"></a><span id="l3.5137" class="difflineplus">+      commandString.AppendLiteral(&quot;&gt;)&quot;);</span>
<a href="#l3.5138"></a><span id="l3.5138" class="difflineplus">+    } break;</span>
<a href="#l3.5139"></a><span id="l3.5139" class="difflineplus">+    case kRFC822HeadersOnly:</span>
<a href="#l3.5140"></a><span id="l3.5140" class="difflineplus">+      if (GetServerStateParser().ServerHasIMAP4Rev1Capability()) {</span>
<a href="#l3.5141"></a><span id="l3.5141" class="difflineplus">+        if (part) {</span>
<a href="#l3.5142"></a><span id="l3.5142" class="difflineplus">+          commandString.AppendLiteral(&quot; %s (BODY[&quot;);</span>
<a href="#l3.5143"></a><span id="l3.5143" class="difflineplus">+          char *what = PR_smprintf(&quot;%s.HEADER])&quot;, part);</span>
<a href="#l3.5144"></a><span id="l3.5144" class="difflineplus">+          if (what) {</span>
<a href="#l3.5145"></a><span id="l3.5145" class="difflineplus">+            commandString.Append(what);</span>
<a href="#l3.5146"></a><span id="l3.5146" class="difflineplus">+            PR_Free(what);</span>
<a href="#l3.5147"></a><span id="l3.5147" class="difflineplus">+          } else</span>
<a href="#l3.5148"></a><span id="l3.5148" class="difflineplus">+            HandleMemoryFailure();</span>
<a href="#l3.5149"></a><span id="l3.5149" class="difflineplus">+        } else {</span>
<a href="#l3.5150"></a><span id="l3.5150" class="difflineplus">+          // headers for the top-level message</span>
<a href="#l3.5151"></a><span id="l3.5151" class="difflineplus">+          commandString.AppendLiteral(&quot; %s (BODY[HEADER])&quot;);</span>
<a href="#l3.5152"></a><span id="l3.5152">         }</span>
<a href="#l3.5153"></a><span id="l3.5153" class="difflineminus">-        if (arbitraryHeaders.IsEmpty())</span>
<a href="#l3.5154"></a><span id="l3.5154" class="difflineminus">-          headersToDL = strdup(dbHeaders);</span>
<a href="#l3.5155"></a><span id="l3.5155" class="difflineminus">-        else</span>
<a href="#l3.5156"></a><span id="l3.5156" class="difflineminus">-          headersToDL = PR_smprintf(&quot;%s %s&quot;,dbHeaders, arbitraryHeaders.get());</span>
<a href="#l3.5157"></a><span id="l3.5157" class="difflineminus">-</span>
<a href="#l3.5158"></a><span id="l3.5158" class="difflineminus">-        if (gUseEnvelopeCmd)</span>
<a href="#l3.5159"></a><span id="l3.5159" class="difflineminus">-          what = PR_smprintf(&quot; ENVELOPE BODY.PEEK[HEADER.FIELDS (%s)])&quot;, headersToDL);</span>
<a href="#l3.5160"></a><span id="l3.5160" class="difflineminus">-        else</span>
<a href="#l3.5161"></a><span id="l3.5161" class="difflineminus">-          what = PR_smprintf(&quot; BODY.PEEK[HEADER.FIELDS (%s)])&quot;,headersToDL);</span>
<a href="#l3.5162"></a><span id="l3.5162" class="difflineminus">-        free(headersToDL);</span>
<a href="#l3.5163"></a><span id="l3.5163" class="difflineminus">-        if (what)</span>
<a href="#l3.5164"></a><span id="l3.5164" class="difflineminus">-        {</span>
<a href="#l3.5165"></a><span id="l3.5165" class="difflineminus">-          commandString.AppendLiteral(&quot; %s (UID &quot;);</span>
<a href="#l3.5166"></a><span id="l3.5166" class="difflineminus">-           if (m_isGmailServer)</span>
<a href="#l3.5167"></a><span id="l3.5167" class="difflineminus">-            commandString.AppendLiteral(&quot;X-GM-MSGID X-GM-THRID X-GM-LABELS &quot;);</span>
<a href="#l3.5168"></a><span id="l3.5168" class="difflineminus">-          if (aolImapServer)</span>
<a href="#l3.5169"></a><span id="l3.5169" class="difflineminus">-            commandString.AppendLiteral(&quot; XAOL.SIZE&quot;) ;</span>
<a href="#l3.5170"></a><span id="l3.5170" class="difflineminus">-          else</span>
<a href="#l3.5171"></a><span id="l3.5171" class="difflineminus">-            commandString.AppendLiteral(&quot;RFC822.SIZE&quot;);</span>
<a href="#l3.5172"></a><span id="l3.5172" class="difflineminus">-          commandString.AppendLiteral(&quot; FLAGS&quot;);</span>
<a href="#l3.5173"></a><span id="l3.5173" class="difflineminus">-          commandString.Append(what);</span>
<a href="#l3.5174"></a><span id="l3.5174" class="difflineminus">-          PR_Free(what);</span>
<a href="#l3.5175"></a><span id="l3.5175" class="difflineminus">-        }</span>
<a href="#l3.5176"></a><span id="l3.5176" class="difflineminus">-        else</span>
<a href="#l3.5177"></a><span id="l3.5177" class="difflineminus">-        {</span>
<a href="#l3.5178"></a><span id="l3.5178" class="difflineminus">-          commandString.AppendLiteral(&quot; %s (UID RFC822.SIZE BODY.PEEK[HEADER] FLAGS)&quot;);</span>
<a href="#l3.5179"></a><span id="l3.5179" class="difflineplus">+      } else</span>
<a href="#l3.5180"></a><span id="l3.5180" class="difflineplus">+        commandString.AppendLiteral(&quot; %s (RFC822.HEADER)&quot;);</span>
<a href="#l3.5181"></a><span id="l3.5181" class="difflineplus">+      break;</span>
<a href="#l3.5182"></a><span id="l3.5182" class="difflineplus">+    case kMIMEPart:</span>
<a href="#l3.5183"></a><span id="l3.5183" class="difflineplus">+      commandString.AppendLiteral(&quot; %s (BODY.PEEK[%s]&quot;);</span>
<a href="#l3.5184"></a><span id="l3.5184" class="difflineplus">+      if (numBytes &gt; 0) {</span>
<a href="#l3.5185"></a><span id="l3.5185" class="difflineplus">+        // if we are retrieving chunks</span>
<a href="#l3.5186"></a><span id="l3.5186" class="difflineplus">+        char *byterangeString = PR_smprintf(&quot;&lt;%ld.%ld&gt;&quot;, startByte, numBytes);</span>
<a href="#l3.5187"></a><span id="l3.5187" class="difflineplus">+        if (byterangeString) {</span>
<a href="#l3.5188"></a><span id="l3.5188" class="difflineplus">+          commandString.Append(byterangeString);</span>
<a href="#l3.5189"></a><span id="l3.5189" class="difflineplus">+          PR_Free(byterangeString);</span>
<a href="#l3.5190"></a><span id="l3.5190">         }</span>
<a href="#l3.5191"></a><span id="l3.5191">       }</span>
<a href="#l3.5192"></a><span id="l3.5192" class="difflineminus">-      else</span>
<a href="#l3.5193"></a><span id="l3.5193" class="difflineminus">-        commandString.AppendLiteral(&quot; %s (UID RFC822.SIZE BODY.PEEK[HEADER] FLAGS)&quot;);</span>
<a href="#l3.5194"></a><span id="l3.5194" class="difflineminus">-    }</span>
<a href="#l3.5195"></a><span id="l3.5195" class="difflineminus">-    else</span>
<a href="#l3.5196"></a><span id="l3.5196" class="difflineminus">-      commandString.AppendLiteral(&quot; %s (UID RFC822.SIZE RFC822.HEADER FLAGS)&quot;);</span>
<a href="#l3.5197"></a><span id="l3.5197" class="difflineminus">-    break;</span>
<a href="#l3.5198"></a><span id="l3.5198" class="difflineminus">-  case kUid:</span>
<a href="#l3.5199"></a><span id="l3.5199" class="difflineminus">-    commandString.AppendLiteral(&quot; %s (UID)&quot;);</span>
<a href="#l3.5200"></a><span id="l3.5200" class="difflineminus">-    break;</span>
<a href="#l3.5201"></a><span id="l3.5201" class="difflineminus">-  case kFlags:</span>
<a href="#l3.5202"></a><span id="l3.5202" class="difflineminus">-    GetServerStateParser().SetFetchingFlags(true);</span>
<a href="#l3.5203"></a><span id="l3.5203" class="difflineminus">-    commandString.AppendLiteral(&quot; %s (FLAGS)&quot;);</span>
<a href="#l3.5204"></a><span id="l3.5204" class="difflineminus">-    break;</span>
<a href="#l3.5205"></a><span id="l3.5205" class="difflineminus">-  case kRFC822Size:</span>
<a href="#l3.5206"></a><span id="l3.5206" class="difflineminus">-    commandString.AppendLiteral(&quot; %s (RFC822.SIZE)&quot;);</span>
<a href="#l3.5207"></a><span id="l3.5207" class="difflineminus">-    break;</span>
<a href="#l3.5208"></a><span id="l3.5208" class="difflineminus">-  case kBodyStart:</span>
<a href="#l3.5209"></a><span id="l3.5209" class="difflineminus">-    {</span>
<a href="#l3.5210"></a><span id="l3.5210" class="difflineminus">-      int32_t numBytesToFetch;</span>
<a href="#l3.5211"></a><span id="l3.5211" class="difflineminus">-      m_runningUrl-&gt;GetNumBytesToFetch(&amp;numBytesToFetch);</span>
<a href="#l3.5212"></a><span id="l3.5212" class="difflineminus">-</span>
<a href="#l3.5213"></a><span id="l3.5213" class="difflineminus">-      commandString.AppendLiteral(&quot; %s (UID BODY.PEEK[HEADER.FIELDS (Content-Type Content-Transfer-Encoding)] BODY.PEEK[TEXT]&lt;0.&quot;);</span>
<a href="#l3.5214"></a><span id="l3.5214" class="difflineminus">-      commandString.AppendInt(numBytesToFetch);</span>
<a href="#l3.5215"></a><span id="l3.5215" class="difflineminus">-      commandString.AppendLiteral(&quot;&gt;)&quot;);</span>
<a href="#l3.5216"></a><span id="l3.5216" class="difflineminus">-    }</span>
<a href="#l3.5217"></a><span id="l3.5217" class="difflineminus">-    break;</span>
<a href="#l3.5218"></a><span id="l3.5218" class="difflineminus">-  case kRFC822HeadersOnly:</span>
<a href="#l3.5219"></a><span id="l3.5219" class="difflineminus">-    if (GetServerStateParser().ServerHasIMAP4Rev1Capability())</span>
<a href="#l3.5220"></a><span id="l3.5220" class="difflineminus">-    {</span>
<a href="#l3.5221"></a><span id="l3.5221" class="difflineminus">-      if (part)</span>
<a href="#l3.5222"></a><span id="l3.5222" class="difflineminus">-      {</span>
<a href="#l3.5223"></a><span id="l3.5223" class="difflineminus">-        commandString.AppendLiteral(&quot; %s (BODY[&quot;);</span>
<a href="#l3.5224"></a><span id="l3.5224" class="difflineminus">-        char *what = PR_smprintf(&quot;%s.HEADER])&quot;, part);</span>
<a href="#l3.5225"></a><span id="l3.5225" class="difflineminus">-        if (what)</span>
<a href="#l3.5226"></a><span id="l3.5226" class="difflineminus">-        {</span>
<a href="#l3.5227"></a><span id="l3.5227" class="difflineminus">-          commandString.Append(what);</span>
<a href="#l3.5228"></a><span id="l3.5228" class="difflineminus">-          PR_Free(what);</span>
<a href="#l3.5229"></a><span id="l3.5229" class="difflineminus">-        }</span>
<a href="#l3.5230"></a><span id="l3.5230" class="difflineminus">-        else</span>
<a href="#l3.5231"></a><span id="l3.5231" class="difflineminus">-          HandleMemoryFailure();</span>
<a href="#l3.5232"></a><span id="l3.5232" class="difflineminus">-      }</span>
<a href="#l3.5233"></a><span id="l3.5233" class="difflineminus">-      else</span>
<a href="#l3.5234"></a><span id="l3.5234" class="difflineminus">-      {</span>
<a href="#l3.5235"></a><span id="l3.5235" class="difflineminus">-        // headers for the top-level message</span>
<a href="#l3.5236"></a><span id="l3.5236" class="difflineminus">-        commandString.AppendLiteral(&quot; %s (BODY[HEADER])&quot;);</span>
<a href="#l3.5237"></a><span id="l3.5237" class="difflineminus">-      }</span>
<a href="#l3.5238"></a><span id="l3.5238" class="difflineminus">-    }</span>
<a href="#l3.5239"></a><span id="l3.5239" class="difflineminus">-    else</span>
<a href="#l3.5240"></a><span id="l3.5240" class="difflineminus">-      commandString.AppendLiteral(&quot; %s (RFC822.HEADER)&quot;);</span>
<a href="#l3.5241"></a><span id="l3.5241" class="difflineminus">-    break;</span>
<a href="#l3.5242"></a><span id="l3.5242" class="difflineminus">-  case kMIMEPart:</span>
<a href="#l3.5243"></a><span id="l3.5243" class="difflineminus">-    commandString.AppendLiteral(&quot; %s (BODY.PEEK[%s]&quot;);</span>
<a href="#l3.5244"></a><span id="l3.5244" class="difflineminus">-    if (numBytes &gt; 0)</span>
<a href="#l3.5245"></a><span id="l3.5245" class="difflineminus">-    {</span>
<a href="#l3.5246"></a><span id="l3.5246" class="difflineminus">-      // if we are retrieving chunks</span>
<a href="#l3.5247"></a><span id="l3.5247" class="difflineminus">-      char *byterangeString = PR_smprintf(&quot;&lt;%ld.%ld&gt;&quot;,startByte, numBytes);</span>
<a href="#l3.5248"></a><span id="l3.5248" class="difflineminus">-      if (byterangeString)</span>
<a href="#l3.5249"></a><span id="l3.5249" class="difflineminus">-      {</span>
<a href="#l3.5250"></a><span id="l3.5250" class="difflineminus">-        commandString.Append(byterangeString);</span>
<a href="#l3.5251"></a><span id="l3.5251" class="difflineminus">-        PR_Free(byterangeString);</span>
<a href="#l3.5252"></a><span id="l3.5252" class="difflineminus">-      }</span>
<a href="#l3.5253"></a><span id="l3.5253" class="difflineminus">-    }</span>
<a href="#l3.5254"></a><span id="l3.5254" class="difflineminus">-    commandString.Append(')');</span>
<a href="#l3.5255"></a><span id="l3.5255" class="difflineminus">-    break;</span>
<a href="#l3.5256"></a><span id="l3.5256" class="difflineminus">-  case kMIMEHeader:</span>
<a href="#l3.5257"></a><span id="l3.5257" class="difflineminus">-    commandString.AppendLiteral(&quot; %s (BODY[%s.MIME])&quot;);</span>
<a href="#l3.5258"></a><span id="l3.5258" class="difflineminus">-    break;</span>
<a href="#l3.5259"></a><span id="l3.5259" class="difflineminus">-  }</span>
<a href="#l3.5260"></a><span id="l3.5260" class="difflineminus">-</span>
<a href="#l3.5261"></a><span id="l3.5261" class="difflineminus">-  if (fetchModifier)</span>
<a href="#l3.5262"></a><span id="l3.5262" class="difflineminus">-    commandString.Append(fetchModifier);</span>
<a href="#l3.5263"></a><span id="l3.5263" class="difflineplus">+      commandString.Append(')');</span>
<a href="#l3.5264"></a><span id="l3.5264" class="difflineplus">+      break;</span>
<a href="#l3.5265"></a><span id="l3.5265" class="difflineplus">+    case kMIMEHeader:</span>
<a href="#l3.5266"></a><span id="l3.5266" class="difflineplus">+      commandString.AppendLiteral(&quot; %s (BODY[%s.MIME])&quot;);</span>
<a href="#l3.5267"></a><span id="l3.5267" class="difflineplus">+      break;</span>
<a href="#l3.5268"></a><span id="l3.5268" class="difflineplus">+  }</span>
<a href="#l3.5269"></a><span id="l3.5269" class="difflineplus">+</span>
<a href="#l3.5270"></a><span id="l3.5270" class="difflineplus">+  if (fetchModifier) commandString.Append(fetchModifier);</span>
<a href="#l3.5271"></a><span id="l3.5271"> </span>
<a href="#l3.5272"></a><span id="l3.5272">   commandString.Append(CRLF);</span>
<a href="#l3.5273"></a><span id="l3.5273"> </span>
<a href="#l3.5274"></a><span id="l3.5274" class="difflineminus">-  // since messageIds can be infinitely long, use a dynamic buffer rather than the fixed one</span>
<a href="#l3.5275"></a><span id="l3.5275" class="difflineplus">+  // since messageIds can be infinitely long, use a dynamic buffer rather than</span>
<a href="#l3.5276"></a><span id="l3.5276" class="difflineplus">+  // the fixed one</span>
<a href="#l3.5277"></a><span id="l3.5277">   const char *commandTag = GetServerCommandTag();</span>
<a href="#l3.5278"></a><span id="l3.5278" class="difflineminus">-  int protocolStringSize = commandString.Length() + messageIds.Length() + PL_strlen(commandTag) + 1 +</span>
<a href="#l3.5279"></a><span id="l3.5279" class="difflineminus">-    (part ? PL_strlen(part) : 0);</span>
<a href="#l3.5280"></a><span id="l3.5280" class="difflineminus">-  char *protocolString = (char *) PR_CALLOC( protocolStringSize );</span>
<a href="#l3.5281"></a><span id="l3.5281" class="difflineminus">-</span>
<a href="#l3.5282"></a><span id="l3.5282" class="difflineminus">-  if (protocolString)</span>
<a href="#l3.5283"></a><span id="l3.5283" class="difflineminus">-  {</span>
<a href="#l3.5284"></a><span id="l3.5284" class="difflineplus">+  int protocolStringSize = commandString.Length() + messageIds.Length() +</span>
<a href="#l3.5285"></a><span id="l3.5285" class="difflineplus">+                           PL_strlen(commandTag) + 1 +</span>
<a href="#l3.5286"></a><span id="l3.5286" class="difflineplus">+                           (part ? PL_strlen(part) : 0);</span>
<a href="#l3.5287"></a><span id="l3.5287" class="difflineplus">+  char *protocolString = (char *)PR_CALLOC(protocolStringSize);</span>
<a href="#l3.5288"></a><span id="l3.5288" class="difflineplus">+</span>
<a href="#l3.5289"></a><span id="l3.5289" class="difflineplus">+  if (protocolString) {</span>
<a href="#l3.5290"></a><span id="l3.5290">     char *cCommandStr = ToNewCString(commandString);</span>
<a href="#l3.5291"></a><span id="l3.5291" class="difflineminus">-    if ((whatToFetch == kMIMEPart) ||</span>
<a href="#l3.5292"></a><span id="l3.5292" class="difflineminus">-      (whatToFetch == kMIMEHeader))</span>
<a href="#l3.5293"></a><span id="l3.5293" class="difflineminus">-    {</span>
<a href="#l3.5294"></a><span id="l3.5294" class="difflineminus">-      PR_snprintf(protocolString,                                      // string to create</span>
<a href="#l3.5295"></a><span id="l3.5295" class="difflineminus">-        protocolStringSize,                                      // max size</span>
<a href="#l3.5296"></a><span id="l3.5296" class="difflineminus">-        cCommandStr,                                   // format string</span>
<a href="#l3.5297"></a><span id="l3.5297" class="difflineminus">-        commandTag,                          // command tag</span>
<a href="#l3.5298"></a><span id="l3.5298" class="difflineminus">-        messageIds.get(),</span>
<a href="#l3.5299"></a><span id="l3.5299" class="difflineminus">-        part);</span>
<a href="#l3.5300"></a><span id="l3.5300" class="difflineminus">-    }</span>
<a href="#l3.5301"></a><span id="l3.5301" class="difflineminus">-    else</span>
<a href="#l3.5302"></a><span id="l3.5302" class="difflineminus">-    {</span>
<a href="#l3.5303"></a><span id="l3.5303" class="difflineminus">-      PR_snprintf(protocolString,                                      // string to create</span>
<a href="#l3.5304"></a><span id="l3.5304" class="difflineminus">-        protocolStringSize,                                      // max size</span>
<a href="#l3.5305"></a><span id="l3.5305" class="difflineminus">-        cCommandStr,                                   // format string</span>
<a href="#l3.5306"></a><span id="l3.5306" class="difflineminus">-        commandTag,                          // command tag</span>
<a href="#l3.5307"></a><span id="l3.5307" class="difflineminus">-        messageIds.get());</span>
<a href="#l3.5308"></a><span id="l3.5308" class="difflineplus">+    if ((whatToFetch == kMIMEPart) || (whatToFetch == kMIMEHeader)) {</span>
<a href="#l3.5309"></a><span id="l3.5309" class="difflineplus">+      PR_snprintf(protocolString,      // string to create</span>
<a href="#l3.5310"></a><span id="l3.5310" class="difflineplus">+                  protocolStringSize,  // max size</span>
<a href="#l3.5311"></a><span id="l3.5311" class="difflineplus">+                  cCommandStr,         // format string</span>
<a href="#l3.5312"></a><span id="l3.5312" class="difflineplus">+                  commandTag,          // command tag</span>
<a href="#l3.5313"></a><span id="l3.5313" class="difflineplus">+                  messageIds.get(), part);</span>
<a href="#l3.5314"></a><span id="l3.5314" class="difflineplus">+    } else {</span>
<a href="#l3.5315"></a><span id="l3.5315" class="difflineplus">+      PR_snprintf(protocolString,      // string to create</span>
<a href="#l3.5316"></a><span id="l3.5316" class="difflineplus">+                  protocolStringSize,  // max size</span>
<a href="#l3.5317"></a><span id="l3.5317" class="difflineplus">+                  cCommandStr,         // format string</span>
<a href="#l3.5318"></a><span id="l3.5318" class="difflineplus">+                  commandTag,          // command tag</span>
<a href="#l3.5319"></a><span id="l3.5319" class="difflineplus">+                  messageIds.get());</span>
<a href="#l3.5320"></a><span id="l3.5320">     }</span>
<a href="#l3.5321"></a><span id="l3.5321"> </span>
<a href="#l3.5322"></a><span id="l3.5322">     nsresult rv = SendData(protocolString);</span>
<a href="#l3.5323"></a><span id="l3.5323"> </span>
<a href="#l3.5324"></a><span id="l3.5324">     free(cCommandStr);</span>
<a href="#l3.5325"></a><span id="l3.5325" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.5326"></a><span id="l3.5326" class="difflineminus">-      ParseIMAPandCheckForNewMail(protocolString);</span>
<a href="#l3.5327"></a><span id="l3.5327" class="difflineplus">+    if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(protocolString);</span>
<a href="#l3.5328"></a><span id="l3.5328">     PR_Free(protocolString);</span>
<a href="#l3.5329"></a><span id="l3.5329">     GetServerStateParser().SetFetchingFlags(false);</span>
<a href="#l3.5330"></a><span id="l3.5330">     // Always clear this flag after every fetch.</span>
<a href="#l3.5331"></a><span id="l3.5331">     m_fetchingWholeMessage = false;</span>
<a href="#l3.5332"></a><span id="l3.5332">     if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; CheckNeeded())</span>
<a href="#l3.5333"></a><span id="l3.5333">       Check();</span>
<a href="#l3.5334"></a><span id="l3.5334" class="difflineminus">-  }</span>
<a href="#l3.5335"></a><span id="l3.5335" class="difflineminus">-  else</span>
<a href="#l3.5336"></a><span id="l3.5336" class="difflineplus">+  } else</span>
<a href="#l3.5337"></a><span id="l3.5337">     HandleMemoryFailure();</span>
<a href="#l3.5338"></a><span id="l3.5338"> }</span>
<a href="#l3.5339"></a><span id="l3.5339"> </span>
<a href="#l3.5340"></a><span id="l3.5340"> void nsImapProtocol::FetchTryChunking(const nsCString &amp;messageIds,</span>
<a href="#l3.5341"></a><span id="l3.5341">                                       nsIMAPeFetchFields whatToFetch,</span>
<a href="#l3.5342"></a><span id="l3.5342" class="difflineminus">-                                      bool idIsUid,</span>
<a href="#l3.5343"></a><span id="l3.5343" class="difflineminus">-                                      char *part,</span>
<a href="#l3.5344"></a><span id="l3.5344" class="difflineminus">-                                      uint32_t downloadSize,</span>
<a href="#l3.5345"></a><span id="l3.5345" class="difflineminus">-                                      bool tryChunking)</span>
<a href="#l3.5346"></a><span id="l3.5346" class="difflineminus">-{</span>
<a href="#l3.5347"></a><span id="l3.5347" class="difflineplus">+                                      bool idIsUid, char *part,</span>
<a href="#l3.5348"></a><span id="l3.5348" class="difflineplus">+                                      uint32_t downloadSize, bool tryChunking) {</span>
<a href="#l3.5349"></a><span id="l3.5349">   GetServerStateParser().SetTotalDownloadSize(downloadSize);</span>
<a href="#l3.5350"></a><span id="l3.5350" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;FetchTryChunking: curFetchSize %u&quot;, downloadSize));</span>
<a href="#l3.5351"></a><span id="l3.5351" class="difflineminus">-  m_curFetchSize = downloadSize; // we'll change this if chunking.</span>
<a href="#l3.5352"></a><span id="l3.5352" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.5353"></a><span id="l3.5353" class="difflineplus">+          (&quot;FetchTryChunking: curFetchSize %u&quot;, downloadSize));</span>
<a href="#l3.5354"></a><span id="l3.5354" class="difflineplus">+  m_curFetchSize = downloadSize;  // we'll change this if chunking.</span>
<a href="#l3.5355"></a><span id="l3.5355">   if (m_fetchByChunks &amp;&amp; tryChunking &amp;&amp;</span>
<a href="#l3.5356"></a><span id="l3.5356" class="difflineminus">-        GetServerStateParser().ServerHasIMAP4Rev1Capability() &amp;&amp;</span>
<a href="#l3.5357"></a><span id="l3.5357" class="difflineminus">-    (downloadSize &gt; (uint32_t) m_chunkThreshold))</span>
<a href="#l3.5358"></a><span id="l3.5358" class="difflineminus">-  {</span>
<a href="#l3.5359"></a><span id="l3.5359" class="difflineplus">+      GetServerStateParser().ServerHasIMAP4Rev1Capability() &amp;&amp;</span>
<a href="#l3.5360"></a><span id="l3.5360" class="difflineplus">+      (downloadSize &gt; (uint32_t)m_chunkThreshold)) {</span>
<a href="#l3.5361"></a><span id="l3.5361">     uint32_t startByte = 0;</span>
<a href="#l3.5362"></a><span id="l3.5362">     m_curFetchSize = m_chunkSize;</span>
<a href="#l3.5363"></a><span id="l3.5363">     GetServerStateParser().ClearLastFetchChunkReceived();</span>
<a href="#l3.5364"></a><span id="l3.5364">     while (!DeathSignalReceived() &amp;&amp; !GetPseudoInterrupted() &amp;&amp;</span>
<a href="#l3.5365"></a><span id="l3.5365" class="difflineminus">-      !GetServerStateParser().GetLastFetchChunkReceived() &amp;&amp;</span>
<a href="#l3.5366"></a><span id="l3.5366" class="difflineminus">-      GetServerStateParser().ContinueParse())</span>
<a href="#l3.5367"></a><span id="l3.5367" class="difflineminus">-    {</span>
<a href="#l3.5368"></a><span id="l3.5368" class="difflineminus">-      FetchMessage(messageIds,</span>
<a href="#l3.5369"></a><span id="l3.5369" class="difflineminus">-             whatToFetch,</span>
<a href="#l3.5370"></a><span id="l3.5370" class="difflineminus">-             nullptr,</span>
<a href="#l3.5371"></a><span id="l3.5371" class="difflineminus">-             startByte, m_chunkSize,</span>
<a href="#l3.5372"></a><span id="l3.5372" class="difflineminus">-             part);</span>
<a href="#l3.5373"></a><span id="l3.5373" class="difflineplus">+           !GetServerStateParser().GetLastFetchChunkReceived() &amp;&amp;</span>
<a href="#l3.5374"></a><span id="l3.5374" class="difflineplus">+           GetServerStateParser().ContinueParse()) {</span>
<a href="#l3.5375"></a><span id="l3.5375" class="difflineplus">+      FetchMessage(messageIds, whatToFetch, nullptr, startByte, m_chunkSize,</span>
<a href="#l3.5376"></a><span id="l3.5376" class="difflineplus">+                   part);</span>
<a href="#l3.5377"></a><span id="l3.5377">       startByte += m_chunkSize;</span>
<a href="#l3.5378"></a><span id="l3.5378">     }</span>
<a href="#l3.5379"></a><span id="l3.5379"> </span>
<a href="#l3.5380"></a><span id="l3.5380">     // Only abort the stream if this is a normal message download</span>
<a href="#l3.5381"></a><span id="l3.5381">     // Otherwise, let the body shell abort the stream.</span>
<a href="#l3.5382"></a><span id="l3.5382" class="difflineminus">-    if ((whatToFetch == kEveryThingRFC822)</span>
<a href="#l3.5383"></a><span id="l3.5383" class="difflineminus">-      &amp;&amp;</span>
<a href="#l3.5384"></a><span id="l3.5384" class="difflineminus">-      ((startByte &gt; 0 &amp;&amp; (startByte &lt; downloadSize) &amp;&amp;</span>
<a href="#l3.5385"></a><span id="l3.5385" class="difflineminus">-      (DeathSignalReceived() || GetPseudoInterrupted())) ||</span>
<a href="#l3.5386"></a><span id="l3.5386" class="difflineminus">-      !GetServerStateParser().ContinueParse()))</span>
<a href="#l3.5387"></a><span id="l3.5387" class="difflineminus">-    {</span>
<a href="#l3.5388"></a><span id="l3.5388" class="difflineplus">+    if ((whatToFetch == kEveryThingRFC822) &amp;&amp;</span>
<a href="#l3.5389"></a><span id="l3.5389" class="difflineplus">+        ((startByte &gt; 0 &amp;&amp; (startByte &lt; downloadSize) &amp;&amp;</span>
<a href="#l3.5390"></a><span id="l3.5390" class="difflineplus">+          (DeathSignalReceived() || GetPseudoInterrupted())) ||</span>
<a href="#l3.5391"></a><span id="l3.5391" class="difflineplus">+         !GetServerStateParser().ContinueParse())) {</span>
<a href="#l3.5392"></a><span id="l3.5392">       AbortMessageDownLoad();</span>
<a href="#l3.5393"></a><span id="l3.5393">       PseudoInterrupt(false);</span>
<a href="#l3.5394"></a><span id="l3.5394">     }</span>
<a href="#l3.5395"></a><span id="l3.5395" class="difflineminus">-  }</span>
<a href="#l3.5396"></a><span id="l3.5396" class="difflineminus">-  else</span>
<a href="#l3.5397"></a><span id="l3.5397" class="difflineminus">-  {</span>
<a href="#l3.5398"></a><span id="l3.5398" class="difflineplus">+  } else {</span>
<a href="#l3.5399"></a><span id="l3.5399">     // small message, or (we're not chunking and not doing bodystructure),</span>
<a href="#l3.5400"></a><span id="l3.5400">     // or the server is not rev1.</span>
<a href="#l3.5401"></a><span id="l3.5401">     // Just fetch the whole thing.</span>
<a href="#l3.5402"></a><span id="l3.5402">     FetchMessage(messageIds, whatToFetch, nullptr, 0, 0, part);</span>
<a href="#l3.5403"></a><span id="l3.5403">   }</span>
<a href="#l3.5404"></a><span id="l3.5404"> }</span>
<a href="#l3.5405"></a><span id="l3.5405"> </span>
<a href="#l3.5406"></a><span id="l3.5406" class="difflineminus">-</span>
<a href="#l3.5407"></a><span id="l3.5407" class="difflineminus">-void nsImapProtocol::PipelinedFetchMessageParts(nsCString &amp;uid, nsIMAPMessagePartIDArray *parts)</span>
<a href="#l3.5408"></a><span id="l3.5408" class="difflineminus">-{</span>
<a href="#l3.5409"></a><span id="l3.5409" class="difflineplus">+void nsImapProtocol::PipelinedFetchMessageParts(</span>
<a href="#l3.5410"></a><span id="l3.5410" class="difflineplus">+    nsCString &amp;uid, nsIMAPMessagePartIDArray *parts) {</span>
<a href="#l3.5411"></a><span id="l3.5411">   // assumes no chunking</span>
<a href="#l3.5412"></a><span id="l3.5412"> </span>
<a href="#l3.5413"></a><span id="l3.5413">   // build up a string to fetch</span>
<a href="#l3.5414"></a><span id="l3.5414">   nsCString stringToFetch;</span>
<a href="#l3.5415"></a><span id="l3.5415">   nsCString what;</span>
<a href="#l3.5416"></a><span id="l3.5416"> </span>
<a href="#l3.5417"></a><span id="l3.5417">   uint32_t currentPartNum = 0;</span>
<a href="#l3.5418"></a><span id="l3.5418" class="difflineminus">-  while ((parts-&gt;GetNumParts() &gt; currentPartNum) &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.5419"></a><span id="l3.5419" class="difflineminus">-  {</span>
<a href="#l3.5420"></a><span id="l3.5420" class="difflineplus">+  while ((parts-&gt;GetNumParts() &gt; currentPartNum) &amp;&amp; !DeathSignalReceived()) {</span>
<a href="#l3.5421"></a><span id="l3.5421">     nsIMAPMessagePartID *currentPart = parts-&gt;GetPart(currentPartNum);</span>
<a href="#l3.5422"></a><span id="l3.5422" class="difflineminus">-    if (currentPart)</span>
<a href="#l3.5423"></a><span id="l3.5423" class="difflineminus">-    {</span>
<a href="#l3.5424"></a><span id="l3.5424" class="difflineplus">+    if (currentPart) {</span>
<a href="#l3.5425"></a><span id="l3.5425">       // Do things here depending on the type of message part</span>
<a href="#l3.5426"></a><span id="l3.5426">       // Append it to the fetch string</span>
<a href="#l3.5427"></a><span id="l3.5427" class="difflineminus">-      if (currentPartNum &gt; 0)</span>
<a href="#l3.5428"></a><span id="l3.5428" class="difflineminus">-        stringToFetch += &quot; &quot;;</span>
<a href="#l3.5429"></a><span id="l3.5429" class="difflineminus">-</span>
<a href="#l3.5430"></a><span id="l3.5430" class="difflineminus">-      switch (currentPart-&gt;GetFields())</span>
<a href="#l3.5431"></a><span id="l3.5431" class="difflineminus">-      {</span>
<a href="#l3.5432"></a><span id="l3.5432" class="difflineminus">-      case kMIMEHeader:</span>
<a href="#l3.5433"></a><span id="l3.5433" class="difflineminus">-        what = &quot;BODY.PEEK[&quot;;</span>
<a href="#l3.5434"></a><span id="l3.5434" class="difflineminus">-        what += currentPart-&gt;GetPartNumberString();</span>
<a href="#l3.5435"></a><span id="l3.5435" class="difflineminus">-        what += &quot;.MIME]&quot;;</span>
<a href="#l3.5436"></a><span id="l3.5436" class="difflineminus">-        stringToFetch += what;</span>
<a href="#l3.5437"></a><span id="l3.5437" class="difflineminus">-        break;</span>
<a href="#l3.5438"></a><span id="l3.5438" class="difflineminus">-      case kRFC822HeadersOnly:</span>
<a href="#l3.5439"></a><span id="l3.5439" class="difflineminus">-        if (currentPart-&gt;GetPartNumberString())</span>
<a href="#l3.5440"></a><span id="l3.5440" class="difflineminus">-        {</span>
<a href="#l3.5441"></a><span id="l3.5441" class="difflineplus">+      if (currentPartNum &gt; 0) stringToFetch += &quot; &quot;;</span>
<a href="#l3.5442"></a><span id="l3.5442" class="difflineplus">+</span>
<a href="#l3.5443"></a><span id="l3.5443" class="difflineplus">+      switch (currentPart-&gt;GetFields()) {</span>
<a href="#l3.5444"></a><span id="l3.5444" class="difflineplus">+        case kMIMEHeader:</span>
<a href="#l3.5445"></a><span id="l3.5445">           what = &quot;BODY.PEEK[&quot;;</span>
<a href="#l3.5446"></a><span id="l3.5446">           what += currentPart-&gt;GetPartNumberString();</span>
<a href="#l3.5447"></a><span id="l3.5447" class="difflineminus">-          what += &quot;.HEADER]&quot;;</span>
<a href="#l3.5448"></a><span id="l3.5448" class="difflineplus">+          what += &quot;.MIME]&quot;;</span>
<a href="#l3.5449"></a><span id="l3.5449">           stringToFetch += what;</span>
<a href="#l3.5450"></a><span id="l3.5450" class="difflineminus">-        }</span>
<a href="#l3.5451"></a><span id="l3.5451" class="difflineminus">-        else</span>
<a href="#l3.5452"></a><span id="l3.5452" class="difflineminus">-        {</span>
<a href="#l3.5453"></a><span id="l3.5453" class="difflineminus">-          // headers for the top-level message</span>
<a href="#l3.5454"></a><span id="l3.5454" class="difflineminus">-          stringToFetch += &quot;BODY.PEEK[HEADER]&quot;;</span>
<a href="#l3.5455"></a><span id="l3.5455" class="difflineminus">-        }</span>
<a href="#l3.5456"></a><span id="l3.5456" class="difflineminus">-        break;</span>
<a href="#l3.5457"></a><span id="l3.5457" class="difflineminus">-      default:</span>
<a href="#l3.5458"></a><span id="l3.5458" class="difflineminus">-        NS_ASSERTION(false, &quot;we should only be pipelining MIME headers and Message headers&quot;);</span>
<a href="#l3.5459"></a><span id="l3.5459" class="difflineminus">-        break;</span>
<a href="#l3.5460"></a><span id="l3.5460" class="difflineplus">+          break;</span>
<a href="#l3.5461"></a><span id="l3.5461" class="difflineplus">+        case kRFC822HeadersOnly:</span>
<a href="#l3.5462"></a><span id="l3.5462" class="difflineplus">+          if (currentPart-&gt;GetPartNumberString()) {</span>
<a href="#l3.5463"></a><span id="l3.5463" class="difflineplus">+            what = &quot;BODY.PEEK[&quot;;</span>
<a href="#l3.5464"></a><span id="l3.5464" class="difflineplus">+            what += currentPart-&gt;GetPartNumberString();</span>
<a href="#l3.5465"></a><span id="l3.5465" class="difflineplus">+            what += &quot;.HEADER]&quot;;</span>
<a href="#l3.5466"></a><span id="l3.5466" class="difflineplus">+            stringToFetch += what;</span>
<a href="#l3.5467"></a><span id="l3.5467" class="difflineplus">+          } else {</span>
<a href="#l3.5468"></a><span id="l3.5468" class="difflineplus">+            // headers for the top-level message</span>
<a href="#l3.5469"></a><span id="l3.5469" class="difflineplus">+            stringToFetch += &quot;BODY.PEEK[HEADER]&quot;;</span>
<a href="#l3.5470"></a><span id="l3.5470" class="difflineplus">+          }</span>
<a href="#l3.5471"></a><span id="l3.5471" class="difflineplus">+          break;</span>
<a href="#l3.5472"></a><span id="l3.5472" class="difflineplus">+        default:</span>
<a href="#l3.5473"></a><span id="l3.5473" class="difflineplus">+          NS_ASSERTION(</span>
<a href="#l3.5474"></a><span id="l3.5474" class="difflineplus">+              false,</span>
<a href="#l3.5475"></a><span id="l3.5475" class="difflineplus">+              &quot;we should only be pipelining MIME headers and Message headers&quot;);</span>
<a href="#l3.5476"></a><span id="l3.5476" class="difflineplus">+          break;</span>
<a href="#l3.5477"></a><span id="l3.5477">       }</span>
<a href="#l3.5478"></a><span id="l3.5478" class="difflineminus">-</span>
<a href="#l3.5479"></a><span id="l3.5479">     }</span>
<a href="#l3.5480"></a><span id="l3.5480">     currentPartNum++;</span>
<a href="#l3.5481"></a><span id="l3.5481">   }</span>
<a href="#l3.5482"></a><span id="l3.5482"> </span>
<a href="#l3.5483"></a><span id="l3.5483">   // Run the single, pipelined fetch command</span>
<a href="#l3.5484"></a><span id="l3.5484" class="difflineminus">-  if ((parts-&gt;GetNumParts() &gt; 0) &amp;&amp; !DeathSignalReceived() &amp;&amp; !GetPseudoInterrupted() &amp;&amp; stringToFetch.get())</span>
<a href="#l3.5485"></a><span id="l3.5485" class="difflineminus">-  {</span>
<a href="#l3.5486"></a><span id="l3.5486" class="difflineminus">-      IncrementCommandTagNumber();</span>
<a href="#l3.5487"></a><span id="l3.5487" class="difflineminus">-</span>
<a href="#l3.5488"></a><span id="l3.5488" class="difflineminus">-    char *commandString = PR_smprintf(&quot;%s UID fetch %s (%s)%s&quot;,</span>
<a href="#l3.5489"></a><span id="l3.5489" class="difflineminus">-                                          GetServerCommandTag(), uid.get(),</span>
<a href="#l3.5490"></a><span id="l3.5490" class="difflineminus">-                                          stringToFetch.get(), CRLF);</span>
<a href="#l3.5491"></a><span id="l3.5491" class="difflineminus">-</span>
<a href="#l3.5492"></a><span id="l3.5492" class="difflineminus">-    if (commandString)</span>
<a href="#l3.5493"></a><span id="l3.5493" class="difflineminus">-    {</span>
<a href="#l3.5494"></a><span id="l3.5494" class="difflineplus">+  if ((parts-&gt;GetNumParts() &gt; 0) &amp;&amp; !DeathSignalReceived() &amp;&amp;</span>
<a href="#l3.5495"></a><span id="l3.5495" class="difflineplus">+      !GetPseudoInterrupted() &amp;&amp; stringToFetch.get()) {</span>
<a href="#l3.5496"></a><span id="l3.5496" class="difflineplus">+    IncrementCommandTagNumber();</span>
<a href="#l3.5497"></a><span id="l3.5497" class="difflineplus">+</span>
<a href="#l3.5498"></a><span id="l3.5498" class="difflineplus">+    char *commandString =</span>
<a href="#l3.5499"></a><span id="l3.5499" class="difflineplus">+        PR_smprintf(&quot;%s UID fetch %s (%s)%s&quot;, GetServerCommandTag(), uid.get(),</span>
<a href="#l3.5500"></a><span id="l3.5500" class="difflineplus">+                    stringToFetch.get(), CRLF);</span>
<a href="#l3.5501"></a><span id="l3.5501" class="difflineplus">+</span>
<a href="#l3.5502"></a><span id="l3.5502" class="difflineplus">+    if (commandString) {</span>
<a href="#l3.5503"></a><span id="l3.5503">       nsresult rv = SendData(commandString);</span>
<a href="#l3.5504"></a><span id="l3.5504" class="difflineminus">-            if (NS_SUCCEEDED(rv))</span>
<a href="#l3.5505"></a><span id="l3.5505" class="difflineminus">-                ParseIMAPandCheckForNewMail(commandString);</span>
<a href="#l3.5506"></a><span id="l3.5506" class="difflineplus">+      if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(commandString);</span>
<a href="#l3.5507"></a><span id="l3.5507">       PR_Free(commandString);</span>
<a href="#l3.5508"></a><span id="l3.5508" class="difflineminus">-    }</span>
<a href="#l3.5509"></a><span id="l3.5509" class="difflineminus">-    else</span>
<a href="#l3.5510"></a><span id="l3.5510" class="difflineplus">+    } else</span>
<a href="#l3.5511"></a><span id="l3.5511">       HandleMemoryFailure();</span>
<a href="#l3.5512"></a><span id="l3.5512">   }</span>
<a href="#l3.5513"></a><span id="l3.5513"> }</span>
<a href="#l3.5514"></a><span id="l3.5514"> </span>
<a href="#l3.5515"></a><span id="l3.5515" class="difflineminus">-</span>
<a href="#l3.5516"></a><span id="l3.5516" class="difflineminus">-void</span>
<a href="#l3.5517"></a><span id="l3.5517" class="difflineminus">-nsImapProtocol::PostLineDownLoadEvent(const char *line, uint32_t uidOfMessage)</span>
<a href="#l3.5518"></a><span id="l3.5518" class="difflineminus">-{</span>
<a href="#l3.5519"></a><span id="l3.5519" class="difflineminus">-  if (!GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.5520"></a><span id="l3.5520" class="difflineminus">-  {</span>
<a href="#l3.5521"></a><span id="l3.5521" class="difflineplus">+void nsImapProtocol::PostLineDownLoadEvent(const char *line,</span>
<a href="#l3.5522"></a><span id="l3.5522" class="difflineplus">+                                           uint32_t uidOfMessage) {</span>
<a href="#l3.5523"></a><span id="l3.5523" class="difflineplus">+  if (!GetServerStateParser().GetDownloadingHeaders()) {</span>
<a href="#l3.5524"></a><span id="l3.5524">     uint32_t byteCount = PL_strlen(line);</span>
<a href="#l3.5525"></a><span id="l3.5525">     bool echoLineToMessageSink = false;</span>
<a href="#l3.5526"></a><span id="l3.5526">     // if we have a channel listener, then just spool the message</span>
<a href="#l3.5527"></a><span id="l3.5527">     // directly to the listener</span>
<a href="#l3.5528"></a><span id="l3.5528" class="difflineminus">-    if (m_channelListener)</span>
<a href="#l3.5529"></a><span id="l3.5529" class="difflineminus">-    {</span>
<a href="#l3.5530"></a><span id="l3.5530" class="difflineplus">+    if (m_channelListener) {</span>
<a href="#l3.5531"></a><span id="l3.5531">       uint32_t count = 0;</span>
<a href="#l3.5532"></a><span id="l3.5532" class="difflineminus">-      if (m_channelOutputStream)</span>
<a href="#l3.5533"></a><span id="l3.5533" class="difflineminus">-      {</span>
<a href="#l3.5534"></a><span id="l3.5534" class="difflineplus">+      if (m_channelOutputStream) {</span>
<a href="#l3.5535"></a><span id="l3.5535">         nsresult rv = m_channelOutputStream-&gt;Write(line, byteCount, &amp;count);</span>
<a href="#l3.5536"></a><span id="l3.5536" class="difflineminus">-        NS_ASSERTION(count == byteCount, &quot;IMAP channel pipe couldn't buffer entire write&quot;);</span>
<a href="#l3.5537"></a><span id="l3.5537" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l3.5538"></a><span id="l3.5538" class="difflineminus">-        {</span>
<a href="#l3.5539"></a><span id="l3.5539" class="difflineminus">-          m_channelListener-&gt;OnDataAvailable(m_mockChannel, m_channelInputStream, 0, count);</span>
<a href="#l3.5540"></a><span id="l3.5540" class="difflineplus">+        NS_ASSERTION(count == byteCount,</span>
<a href="#l3.5541"></a><span id="l3.5541" class="difflineplus">+                     &quot;IMAP channel pipe couldn't buffer entire write&quot;);</span>
<a href="#l3.5542"></a><span id="l3.5542" class="difflineplus">+        if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.5543"></a><span id="l3.5543" class="difflineplus">+          m_channelListener-&gt;OnDataAvailable(m_mockChannel,</span>
<a href="#l3.5544"></a><span id="l3.5544" class="difflineplus">+                                             m_channelInputStream, 0, count);</span>
<a href="#l3.5545"></a><span id="l3.5545">         }</span>
<a href="#l3.5546"></a><span id="l3.5546">         // else some sort of explosion?</span>
<a href="#l3.5547"></a><span id="l3.5547">       }</span>
<a href="#l3.5548"></a><span id="l3.5548">     }</span>
<a href="#l3.5549"></a><span id="l3.5549">     if (m_runningUrl)</span>
<a href="#l3.5550"></a><span id="l3.5550">       m_runningUrl-&gt;GetStoreResultsOffline(&amp;echoLineToMessageSink);</span>
<a href="#l3.5551"></a><span id="l3.5551"> </span>
<a href="#l3.5552"></a><span id="l3.5552">     m_bytesToChannel += byteCount;</span>
<a href="#l3.5553"></a><span id="l3.5553" class="difflineminus">-    if (m_imapMessageSink &amp;&amp; line &amp;&amp; echoLineToMessageSink &amp;&amp; !GetPseudoInterrupted())</span>
<a href="#l3.5554"></a><span id="l3.5554" class="difflineplus">+    if (m_imapMessageSink &amp;&amp; line &amp;&amp; echoLineToMessageSink &amp;&amp;</span>
<a href="#l3.5555"></a><span id="l3.5555" class="difflineplus">+        !GetPseudoInterrupted())</span>
<a href="#l3.5556"></a><span id="l3.5556">       m_imapMessageSink-&gt;ParseAdoptedMsgLine(line, uidOfMessage, m_runningUrl);</span>
<a href="#l3.5557"></a><span id="l3.5557">   }</span>
<a href="#l3.5558"></a><span id="l3.5558">   // ***** We need to handle the pseudo interrupt here *****</span>
<a href="#l3.5559"></a><span id="l3.5559"> }</span>
<a href="#l3.5560"></a><span id="l3.5560"> </span>
<a href="#l3.5561"></a><span id="l3.5561"> // Handle a line seen by the parser.</span>
<a href="#l3.5562"></a><span id="l3.5562" class="difflineminus">-// * The argument |lineCopy| must be nullptr or should contain the same string as</span>
<a href="#l3.5563"></a><span id="l3.5563" class="difflineminus">-//   |line|.  |lineCopy| will be modified.</span>
<a href="#l3.5564"></a><span id="l3.5564" class="difflineplus">+// * The argument |lineCopy| must be nullptr or should contain the same string</span>
<a href="#l3.5565"></a><span id="l3.5565" class="difflineplus">+//   as |line|.  |lineCopy| will be modified.</span>
<a href="#l3.5566"></a><span id="l3.5566"> // * A line may be passed by parts, e.g., &quot;part1 part2\r\n&quot; may be passed as</span>
<a href="#l3.5567"></a><span id="l3.5567"> //     HandleMessageDownLoadLine(&quot;part 1 &quot;, 1);</span>
<a href="#l3.5568"></a><span id="l3.5568"> //     HandleMessageDownLoadLine(&quot;part 2\r\n&quot;, 0);</span>
<a href="#l3.5569"></a><span id="l3.5569" class="difflineminus">-//   However, it is assumed that a CRLF or a CRCRLF is never split (i.e., this is</span>
<a href="#l3.5570"></a><span id="l3.5570" class="difflineminus">-//   ensured *before* invoking this method).</span>
<a href="#l3.5571"></a><span id="l3.5571" class="difflineminus">-void nsImapProtocol::HandleMessageDownLoadLine(const char *line, bool isPartialLine,</span>
<a href="#l3.5572"></a><span id="l3.5572" class="difflineminus">-                                               char *lineCopy)</span>
<a href="#l3.5573"></a><span id="l3.5573" class="difflineminus">-{</span>
<a href="#l3.5574"></a><span id="l3.5574" class="difflineplus">+//   However, it is assumed that a CRLF or a CRCRLF is never split (i.e., this</span>
<a href="#l3.5575"></a><span id="l3.5575" class="difflineplus">+//   is ensured *before* invoking this method).</span>
<a href="#l3.5576"></a><span id="l3.5576" class="difflineplus">+void nsImapProtocol::HandleMessageDownLoadLine(const char *line,</span>
<a href="#l3.5577"></a><span id="l3.5577" class="difflineplus">+                                               bool isPartialLine,</span>
<a href="#l3.5578"></a><span id="l3.5578" class="difflineplus">+                                               char *lineCopy) {</span>
<a href="#l3.5579"></a><span id="l3.5579">   NS_ENSURE_TRUE_VOID(line);</span>
<a href="#l3.5580"></a><span id="l3.5580">   NS_ASSERTION(lineCopy == nullptr || !PL_strcmp(line, lineCopy),</span>
<a href="#l3.5581"></a><span id="l3.5581">                &quot;line and lineCopy must contain the same string&quot;);</span>
<a href="#l3.5582"></a><span id="l3.5582">   const char *messageLine = line;</span>
<a href="#l3.5583"></a><span id="l3.5583">   uint32_t lineLength = strlen(messageLine);</span>
<a href="#l3.5584"></a><span id="l3.5584">   const char *cEndOfLine = messageLine + lineLength;</span>
<a href="#l3.5585"></a><span id="l3.5585">   char *localMessageLine = nullptr;</span>
<a href="#l3.5586"></a><span id="l3.5586"> </span>
<a href="#l3.5587"></a><span id="l3.5587">   // If we obtain a partial line (due to fetching by chunks), we do not</span>
<a href="#l3.5588"></a><span id="l3.5588">   // add/modify the end-of-line terminator.</span>
<a href="#l3.5589"></a><span id="l3.5589" class="difflineminus">-  if (!isPartialLine)</span>
<a href="#l3.5590"></a><span id="l3.5590" class="difflineminus">-  {</span>
<a href="#l3.5591"></a><span id="l3.5591" class="difflineplus">+  if (!isPartialLine) {</span>
<a href="#l3.5592"></a><span id="l3.5592">     // Change this line to native line termination, duplicate if necessary.</span>
<a href="#l3.5593"></a><span id="l3.5593">     // Do not assume that the line really ends in CRLF</span>
<a href="#l3.5594"></a><span id="l3.5594">     // to start with, even though it is supposed to be RFC822</span>
<a href="#l3.5595"></a><span id="l3.5595"> </span>
<a href="#l3.5596"></a><span id="l3.5596">     // normalize line endings to CRLF unless we are saving the message to disk</span>
<a href="#l3.5597"></a><span id="l3.5597">     bool canonicalLineEnding = true;</span>
<a href="#l3.5598"></a><span id="l3.5598">     nsCOMPtr&lt;nsIMsgMessageUrl&gt; msgUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.5599"></a><span id="l3.5599"> </span>
<a href="#l3.5600"></a><span id="l3.5600">     if (m_imapAction == nsIImapUrl::nsImapSaveMessageToDisk &amp;&amp; msgUrl)</span>
<a href="#l3.5601"></a><span id="l3.5601">       msgUrl-&gt;GetCanonicalLineEnding(&amp;canonicalLineEnding);</span>
<a href="#l3.5602"></a><span id="l3.5602"> </span>
<a href="#l3.5603"></a><span id="l3.5603" class="difflineminus">-    NS_ASSERTION(MSG_LINEBREAK_LEN == 1 ||</span>
<a href="#l3.5604"></a><span id="l3.5604" class="difflineminus">-                    (MSG_LINEBREAK_LEN == 2 &amp;&amp; !PL_strcmp(CRLF, MSG_LINEBREAK)),</span>
<a href="#l3.5605"></a><span id="l3.5605" class="difflineminus">-                    &quot;violated assumptions on MSG_LINEBREAK&quot;);</span>
<a href="#l3.5606"></a><span id="l3.5606" class="difflineminus">-    if (MSG_LINEBREAK_LEN == 1 &amp;&amp; !canonicalLineEnding)</span>
<a href="#l3.5607"></a><span id="l3.5607" class="difflineminus">-    {</span>
<a href="#l3.5608"></a><span id="l3.5608" class="difflineminus">-      bool lineEndsWithCRorLF = lineLength &gt;= 1 &amp;&amp;</span>
<a href="#l3.5609"></a><span id="l3.5609" class="difflineminus">-        (cEndOfLine[-1] == '\r' || cEndOfLine[-1] == '\n');</span>
<a href="#l3.5610"></a><span id="l3.5610" class="difflineplus">+    NS_ASSERTION(MSG_LINEBREAK_LEN == 1 || (MSG_LINEBREAK_LEN == 2 &amp;&amp;</span>
<a href="#l3.5611"></a><span id="l3.5611" class="difflineplus">+                                            !PL_strcmp(CRLF, MSG_LINEBREAK)),</span>
<a href="#l3.5612"></a><span id="l3.5612" class="difflineplus">+                 &quot;violated assumptions on MSG_LINEBREAK&quot;);</span>
<a href="#l3.5613"></a><span id="l3.5613" class="difflineplus">+    if (MSG_LINEBREAK_LEN == 1 &amp;&amp; !canonicalLineEnding) {</span>
<a href="#l3.5614"></a><span id="l3.5614" class="difflineplus">+      bool lineEndsWithCRorLF =</span>
<a href="#l3.5615"></a><span id="l3.5615" class="difflineplus">+          lineLength &gt;= 1 &amp;&amp; (cEndOfLine[-1] == '\r' || cEndOfLine[-1] == '\n');</span>
<a href="#l3.5616"></a><span id="l3.5616">       char *endOfLine;</span>
<a href="#l3.5617"></a><span id="l3.5617">       if (lineCopy &amp;&amp; lineEndsWithCRorLF)  // true for most lines</span>
<a href="#l3.5618"></a><span id="l3.5618">       {</span>
<a href="#l3.5619"></a><span id="l3.5619">         endOfLine = lineCopy + lineLength;</span>
<a href="#l3.5620"></a><span id="l3.5620">         messageLine = lineCopy;</span>
<a href="#l3.5621"></a><span id="l3.5621" class="difflineminus">-      }</span>
<a href="#l3.5622"></a><span id="l3.5622" class="difflineminus">-      else</span>
<a href="#l3.5623"></a><span id="l3.5623" class="difflineminus">-      {</span>
<a href="#l3.5624"></a><span id="l3.5624" class="difflineplus">+      } else {</span>
<a href="#l3.5625"></a><span id="l3.5625">         // leave enough room for one more char, MSG_LINEBREAK[0]</span>
<a href="#l3.5626"></a><span id="l3.5626" class="difflineminus">-        localMessageLine = (char *) PR_MALLOC(lineLength + 2);</span>
<a href="#l3.5627"></a><span id="l3.5627" class="difflineminus">-        if (!localMessageLine) // memory failure</span>
<a href="#l3.5628"></a><span id="l3.5628" class="difflineplus">+        localMessageLine = (char *)PR_MALLOC(lineLength + 2);</span>
<a href="#l3.5629"></a><span id="l3.5629" class="difflineplus">+        if (!localMessageLine)  // memory failure</span>
<a href="#l3.5630"></a><span id="l3.5630">           return;</span>
<a href="#l3.5631"></a><span id="l3.5631">         PL_strcpy(localMessageLine, line);</span>
<a href="#l3.5632"></a><span id="l3.5632">         endOfLine = localMessageLine + lineLength;</span>
<a href="#l3.5633"></a><span id="l3.5633">         messageLine = localMessageLine;</span>
<a href="#l3.5634"></a><span id="l3.5634">       }</span>
<a href="#l3.5635"></a><span id="l3.5635"> </span>
<a href="#l3.5636"></a><span id="l3.5636" class="difflineminus">-      if (lineLength &gt;= 2 &amp;&amp;</span>
<a href="#l3.5637"></a><span id="l3.5637" class="difflineminus">-        endOfLine[-2] == '\r' &amp;&amp;</span>
<a href="#l3.5638"></a><span id="l3.5638" class="difflineminus">-        endOfLine[-1] == '\n')</span>
<a href="#l3.5639"></a><span id="l3.5639" class="difflineminus">-      {</span>
<a href="#l3.5640"></a><span id="l3.5640" class="difflineminus">-        if(lineLength&gt;=3 &amp;&amp; endOfLine[-3] == '\r') // CRCRLF</span>
<a href="#l3.5641"></a><span id="l3.5641" class="difflineplus">+      if (lineLength &gt;= 2 &amp;&amp; endOfLine[-2] == '\r' &amp;&amp; endOfLine[-1] == '\n') {</span>
<a href="#l3.5642"></a><span id="l3.5642" class="difflineplus">+        if (lineLength &gt;= 3 &amp;&amp; endOfLine[-3] == '\r')  // CRCRLF</span>
<a href="#l3.5643"></a><span id="l3.5643">         {</span>
<a href="#l3.5644"></a><span id="l3.5644">           endOfLine--;</span>
<a href="#l3.5645"></a><span id="l3.5645">           lineLength--;</span>
<a href="#l3.5646"></a><span id="l3.5646">         }</span>
<a href="#l3.5647"></a><span id="l3.5647">         /* CRLF -&gt; CR or LF */</span>
<a href="#l3.5648"></a><span id="l3.5648">         endOfLine[-2] = MSG_LINEBREAK[0];</span>
<a href="#l3.5649"></a><span id="l3.5649">         endOfLine[-1] = '\0';</span>
<a href="#l3.5650"></a><span id="l3.5650">         lineLength--;</span>
<a href="#l3.5651"></a><span id="l3.5651" class="difflineminus">-      }</span>
<a href="#l3.5652"></a><span id="l3.5652" class="difflineminus">-      else if (lineLength &gt;= 1 &amp;&amp;</span>
<a href="#l3.5653"></a><span id="l3.5653" class="difflineminus">-        ((endOfLine[-1] == '\r') || (endOfLine[-1] == '\n')))</span>
<a href="#l3.5654"></a><span id="l3.5654" class="difflineminus">-      {</span>
<a href="#l3.5655"></a><span id="l3.5655" class="difflineplus">+      } else if (lineLength &gt;= 1 &amp;&amp;</span>
<a href="#l3.5656"></a><span id="l3.5656" class="difflineplus">+                 ((endOfLine[-1] == '\r') || (endOfLine[-1] == '\n'))) {</span>
<a href="#l3.5657"></a><span id="l3.5657">         /* CR -&gt; LF or LF -&gt; CR */</span>
<a href="#l3.5658"></a><span id="l3.5658">         endOfLine[-1] = MSG_LINEBREAK[0];</span>
<a href="#l3.5659"></a><span id="l3.5659" class="difflineminus">-      }</span>
<a href="#l3.5660"></a><span id="l3.5660" class="difflineminus">-      else // no eol characters at all</span>
<a href="#l3.5661"></a><span id="l3.5661" class="difflineplus">+      } else  // no eol characters at all</span>
<a href="#l3.5662"></a><span id="l3.5662">       {</span>
<a href="#l3.5663"></a><span id="l3.5663" class="difflineminus">-        endOfLine[0] = MSG_LINEBREAK[0]; // CR or LF</span>
<a href="#l3.5664"></a><span id="l3.5664" class="difflineplus">+        endOfLine[0] = MSG_LINEBREAK[0];  // CR or LF</span>
<a href="#l3.5665"></a><span id="l3.5665">         endOfLine[1] = '\0';</span>
<a href="#l3.5666"></a><span id="l3.5666">         lineLength++;</span>
<a href="#l3.5667"></a><span id="l3.5667">       }</span>
<a href="#l3.5668"></a><span id="l3.5668" class="difflineminus">-    }</span>
<a href="#l3.5669"></a><span id="l3.5669" class="difflineminus">-    else  // enforce canonical CRLF linebreaks</span>
<a href="#l3.5670"></a><span id="l3.5670" class="difflineplus">+    } else  // enforce canonical CRLF linebreaks</span>
<a href="#l3.5671"></a><span id="l3.5671">     {</span>
<a href="#l3.5672"></a><span id="l3.5672" class="difflineminus">-      if (lineLength==0 || (lineLength == 1 &amp;&amp; cEndOfLine[-1] == '\n'))</span>
<a href="#l3.5673"></a><span id="l3.5673" class="difflineminus">-      {</span>
<a href="#l3.5674"></a><span id="l3.5674" class="difflineplus">+      if (lineLength == 0 || (lineLength == 1 &amp;&amp; cEndOfLine[-1] == '\n')) {</span>
<a href="#l3.5675"></a><span id="l3.5675">         messageLine = CRLF;</span>
<a href="#l3.5676"></a><span id="l3.5676">         lineLength = 2;</span>
<a href="#l3.5677"></a><span id="l3.5677" class="difflineminus">-      }</span>
<a href="#l3.5678"></a><span id="l3.5678" class="difflineminus">-      else if (cEndOfLine[-1] != '\n' || cEndOfLine[-2] != '\r' ||</span>
<a href="#l3.5679"></a><span id="l3.5679" class="difflineminus">-               (lineLength &gt;=3 &amp;&amp; cEndOfLine[-3] == '\r'))</span>
<a href="#l3.5680"></a><span id="l3.5680" class="difflineminus">-      {</span>
<a href="#l3.5681"></a><span id="l3.5681" class="difflineplus">+      } else if (cEndOfLine[-1] != '\n' || cEndOfLine[-2] != '\r' ||</span>
<a href="#l3.5682"></a><span id="l3.5682" class="difflineplus">+                 (lineLength &gt;= 3 &amp;&amp; cEndOfLine[-3] == '\r')) {</span>
<a href="#l3.5683"></a><span id="l3.5683">         // The line does not end in CRLF (or it ends in CRCRLF).</span>
<a href="#l3.5684"></a><span id="l3.5684">         // Copy line and leave enough room for two more chars (CR and LF).</span>
<a href="#l3.5685"></a><span id="l3.5685" class="difflineminus">-        localMessageLine = (char *) PR_MALLOC(lineLength + 3);</span>
<a href="#l3.5686"></a><span id="l3.5686" class="difflineminus">-        if (!localMessageLine) // memory failure</span>
<a href="#l3.5687"></a><span id="l3.5687" class="difflineminus">-            return;</span>
<a href="#l3.5688"></a><span id="l3.5688" class="difflineplus">+        localMessageLine = (char *)PR_MALLOC(lineLength + 3);</span>
<a href="#l3.5689"></a><span id="l3.5689" class="difflineplus">+        if (!localMessageLine)  // memory failure</span>
<a href="#l3.5690"></a><span id="l3.5690" class="difflineplus">+          return;</span>
<a href="#l3.5691"></a><span id="l3.5691">         PL_strcpy(localMessageLine, line);</span>
<a href="#l3.5692"></a><span id="l3.5692">         char *endOfLine = localMessageLine + lineLength;</span>
<a href="#l3.5693"></a><span id="l3.5693">         messageLine = localMessageLine;</span>
<a href="#l3.5694"></a><span id="l3.5694"> </span>
<a href="#l3.5695"></a><span id="l3.5695" class="difflineminus">-        if (lineLength&gt;=3 &amp;&amp; endOfLine[-1] == '\n' &amp;&amp;</span>
<a href="#l3.5696"></a><span id="l3.5696" class="difflineminus">-            endOfLine[-2] == '\r')</span>
<a href="#l3.5697"></a><span id="l3.5697" class="difflineminus">-        {</span>
<a href="#l3.5698"></a><span id="l3.5698" class="difflineplus">+        if (lineLength &gt;= 3 &amp;&amp; endOfLine[-1] == '\n' &amp;&amp; endOfLine[-2] == '\r') {</span>
<a href="#l3.5699"></a><span id="l3.5699">           // CRCRLF -&gt; CRLF</span>
<a href="#l3.5700"></a><span id="l3.5700">           endOfLine[-2] = '\n';</span>
<a href="#l3.5701"></a><span id="l3.5701">           endOfLine[-1] = '\0';</span>
<a href="#l3.5702"></a><span id="l3.5702">           lineLength--;</span>
<a href="#l3.5703"></a><span id="l3.5703" class="difflineminus">-        }</span>
<a href="#l3.5704"></a><span id="l3.5704" class="difflineminus">-        else if ((endOfLine[-1] == '\r') || (endOfLine[-1] == '\n'))</span>
<a href="#l3.5705"></a><span id="l3.5705" class="difflineminus">-        {</span>
<a href="#l3.5706"></a><span id="l3.5706" class="difflineplus">+        } else if ((endOfLine[-1] == '\r') || (endOfLine[-1] == '\n')) {</span>
<a href="#l3.5707"></a><span id="l3.5707">           // LF -&gt; CRLF or CR -&gt; CRLF</span>
<a href="#l3.5708"></a><span id="l3.5708">           endOfLine[-1] = '\r';</span>
<a href="#l3.5709"></a><span id="l3.5709" class="difflineminus">-          endOfLine[0]  = '\n';</span>
<a href="#l3.5710"></a><span id="l3.5710" class="difflineminus">-          endOfLine[1]  = '\0';</span>
<a href="#l3.5711"></a><span id="l3.5711" class="difflineplus">+          endOfLine[0] = '\n';</span>
<a href="#l3.5712"></a><span id="l3.5712" class="difflineplus">+          endOfLine[1] = '\0';</span>
<a href="#l3.5713"></a><span id="l3.5713">           lineLength++;</span>
<a href="#l3.5714"></a><span id="l3.5714" class="difflineminus">-        }</span>
<a href="#l3.5715"></a><span id="l3.5715" class="difflineminus">-        else // no eol characters at all</span>
<a href="#l3.5716"></a><span id="l3.5716" class="difflineplus">+        } else  // no eol characters at all</span>
<a href="#l3.5717"></a><span id="l3.5717">         {</span>
<a href="#l3.5718"></a><span id="l3.5718">           endOfLine[0] = '\r';</span>
<a href="#l3.5719"></a><span id="l3.5719">           endOfLine[1] = '\n';</span>
<a href="#l3.5720"></a><span id="l3.5720">           endOfLine[2] = '\0';</span>
<a href="#l3.5721"></a><span id="l3.5721">           lineLength += 2;</span>
<a href="#l3.5722"></a><span id="l3.5722">         }</span>
<a href="#l3.5723"></a><span id="l3.5723">       }</span>
<a href="#l3.5724"></a><span id="l3.5724">     }</span>
<a href="#l3.5725"></a><span id="l3.5725">   }</span>
<a href="#l3.5726"></a><span id="l3.5726">   NS_ASSERTION(lineLength == PL_strlen(messageLine), &quot;lineLength not accurate&quot;);</span>
<a href="#l3.5727"></a><span id="l3.5727"> </span>
<a href="#l3.5728"></a><span id="l3.5728">   // check if sender obtained via XSENDER server extension matches &quot;From:&quot; field</span>
<a href="#l3.5729"></a><span id="l3.5729">   const char *xSenderInfo = GetServerStateParser().GetXSenderInfo();</span>
<a href="#l3.5730"></a><span id="l3.5730" class="difflineminus">-  if (xSenderInfo &amp;&amp; *xSenderInfo &amp;&amp; !m_fromHeaderSeen)</span>
<a href="#l3.5731"></a><span id="l3.5731" class="difflineminus">-  {</span>
<a href="#l3.5732"></a><span id="l3.5732" class="difflineminus">-    if (!PL_strncmp(&quot;From: &quot;, messageLine, 6))</span>
<a href="#l3.5733"></a><span id="l3.5733" class="difflineminus">-    {</span>
<a href="#l3.5734"></a><span id="l3.5734" class="difflineplus">+  if (xSenderInfo &amp;&amp; *xSenderInfo &amp;&amp; !m_fromHeaderSeen) {</span>
<a href="#l3.5735"></a><span id="l3.5735" class="difflineplus">+    if (!PL_strncmp(&quot;From: &quot;, messageLine, 6)) {</span>
<a href="#l3.5736"></a><span id="l3.5736">       m_fromHeaderSeen = true;</span>
<a href="#l3.5737"></a><span id="l3.5737">       if (PL_strstr(messageLine, xSenderInfo) != NULL)</span>
<a href="#l3.5738"></a><span id="l3.5738" class="difflineminus">-          // Adding a X-Mozilla-Status line here is not very elegant but it</span>
<a href="#l3.5739"></a><span id="l3.5739" class="difflineminus">-          // works.  Another X-Mozilla-Status line is added to the message when</span>
<a href="#l3.5740"></a><span id="l3.5740" class="difflineminus">-          // downloading to a local folder; this new line will also contain the</span>
<a href="#l3.5741"></a><span id="l3.5741" class="difflineminus">-          // 'authed' flag we are adding here.  (If the message is again</span>
<a href="#l3.5742"></a><span id="l3.5742" class="difflineminus">-          // uploaded to the server, this flag is lost.)</span>
<a href="#l3.5743"></a><span id="l3.5743" class="difflineminus">-          // 0x0200 == nsMsgMessageFlags::SenderAuthed</span>
<a href="#l3.5744"></a><span id="l3.5744" class="difflineminus">-          HandleMessageDownLoadLine(&quot;X-Mozilla-Status: 0200\r\n&quot;, false);</span>
<a href="#l3.5745"></a><span id="l3.5745" class="difflineplus">+        // Adding a X-Mozilla-Status line here is not very elegant but it</span>
<a href="#l3.5746"></a><span id="l3.5746" class="difflineplus">+        // works.  Another X-Mozilla-Status line is added to the message when</span>
<a href="#l3.5747"></a><span id="l3.5747" class="difflineplus">+        // downloading to a local folder; this new line will also contain the</span>
<a href="#l3.5748"></a><span id="l3.5748" class="difflineplus">+        // 'authed' flag we are adding here.  (If the message is again</span>
<a href="#l3.5749"></a><span id="l3.5749" class="difflineplus">+        // uploaded to the server, this flag is lost.)</span>
<a href="#l3.5750"></a><span id="l3.5750" class="difflineplus">+        // 0x0200 == nsMsgMessageFlags::SenderAuthed</span>
<a href="#l3.5751"></a><span id="l3.5751" class="difflineplus">+        HandleMessageDownLoadLine(&quot;X-Mozilla-Status: 0200\r\n&quot;, false);</span>
<a href="#l3.5752"></a><span id="l3.5752">       GetServerStateParser().FreeXSenderInfo();</span>
<a href="#l3.5753"></a><span id="l3.5753">     }</span>
<a href="#l3.5754"></a><span id="l3.5754">   }</span>
<a href="#l3.5755"></a><span id="l3.5755"> </span>
<a href="#l3.5756"></a><span id="l3.5756" class="difflineminus">-  if (GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.5757"></a><span id="l3.5757" class="difflineminus">-  {</span>
<a href="#l3.5758"></a><span id="l3.5758" class="difflineplus">+  if (GetServerStateParser().GetDownloadingHeaders()) {</span>
<a href="#l3.5759"></a><span id="l3.5759">     if (!m_curHdrInfo)</span>
<a href="#l3.5760"></a><span id="l3.5760" class="difflineminus">-      BeginMessageDownLoad(GetServerStateParser().SizeOfMostRecentMessage(), MESSAGE_RFC822);</span>
<a href="#l3.5761"></a><span id="l3.5761" class="difflineplus">+      BeginMessageDownLoad(GetServerStateParser().SizeOfMostRecentMessage(),</span>
<a href="#l3.5762"></a><span id="l3.5762" class="difflineplus">+                           MESSAGE_RFC822);</span>
<a href="#l3.5763"></a><span id="l3.5763">     if (m_curHdrInfo)</span>
<a href="#l3.5764"></a><span id="l3.5764" class="difflineminus">-      m_curHdrInfo-&gt;CacheLine(messageLine, GetServerStateParser().CurrentResponseUID());</span>
<a href="#l3.5765"></a><span id="l3.5765" class="difflineplus">+      m_curHdrInfo-&gt;CacheLine(messageLine,</span>
<a href="#l3.5766"></a><span id="l3.5766" class="difflineplus">+                              GetServerStateParser().CurrentResponseUID());</span>
<a href="#l3.5767"></a><span id="l3.5767">     PR_Free(localMessageLine);</span>
<a href="#l3.5768"></a><span id="l3.5768">     return;</span>
<a href="#l3.5769"></a><span id="l3.5769">   }</span>
<a href="#l3.5770"></a><span id="l3.5770">   // if this line is for a different message, or the incoming line is too big</span>
<a href="#l3.5771"></a><span id="l3.5771" class="difflineminus">-  if (((m_downloadLineCache-&gt;CurrentUID() != GetServerStateParser().CurrentResponseUID()) &amp;&amp; !m_downloadLineCache-&gt;CacheEmpty()) ||</span>
<a href="#l3.5772"></a><span id="l3.5772" class="difflineminus">-      (m_downloadLineCache-&gt;SpaceAvailable() &lt; lineLength + 1) )</span>
<a href="#l3.5773"></a><span id="l3.5773" class="difflineplus">+  if (((m_downloadLineCache-&gt;CurrentUID() !=</span>
<a href="#l3.5774"></a><span id="l3.5774" class="difflineplus">+        GetServerStateParser().CurrentResponseUID()) &amp;&amp;</span>
<a href="#l3.5775"></a><span id="l3.5775" class="difflineplus">+       !m_downloadLineCache-&gt;CacheEmpty()) ||</span>
<a href="#l3.5776"></a><span id="l3.5776" class="difflineplus">+      (m_downloadLineCache-&gt;SpaceAvailable() &lt; lineLength + 1))</span>
<a href="#l3.5777"></a><span id="l3.5777">     FlushDownloadCache();</span>
<a href="#l3.5778"></a><span id="l3.5778"> </span>
<a href="#l3.5779"></a><span id="l3.5779">   // so now the cache is flushed, but this string might still be to big</span>
<a href="#l3.5780"></a><span id="l3.5780">   if (m_downloadLineCache-&gt;SpaceAvailable() &lt; lineLength + 1)</span>
<a href="#l3.5781"></a><span id="l3.5781" class="difflineminus">-      PostLineDownLoadEvent(messageLine, GetServerStateParser().CurrentResponseUID());</span>
<a href="#l3.5782"></a><span id="l3.5782" class="difflineplus">+    PostLineDownLoadEvent(messageLine,</span>
<a href="#l3.5783"></a><span id="l3.5783" class="difflineplus">+                          GetServerStateParser().CurrentResponseUID());</span>
<a href="#l3.5784"></a><span id="l3.5784">   else</span>
<a href="#l3.5785"></a><span id="l3.5785" class="difflineminus">-    m_downloadLineCache-&gt;CacheLine(messageLine, GetServerStateParser().CurrentResponseUID());</span>
<a href="#l3.5786"></a><span id="l3.5786" class="difflineplus">+    m_downloadLineCache-&gt;CacheLine(messageLine,</span>
<a href="#l3.5787"></a><span id="l3.5787" class="difflineplus">+                                   GetServerStateParser().CurrentResponseUID());</span>
<a href="#l3.5788"></a><span id="l3.5788"> </span>
<a href="#l3.5789"></a><span id="l3.5789">   PR_Free(localMessageLine);</span>
<a href="#l3.5790"></a><span id="l3.5790"> }</span>
<a href="#l3.5791"></a><span id="l3.5791"> </span>
<a href="#l3.5792"></a><span id="l3.5792" class="difflineminus">-void nsImapProtocol::FlushDownloadCache()</span>
<a href="#l3.5793"></a><span id="l3.5793" class="difflineminus">-{</span>
<a href="#l3.5794"></a><span id="l3.5794" class="difflineminus">-  if (!m_downloadLineCache-&gt;CacheEmpty())</span>
<a href="#l3.5795"></a><span id="l3.5795" class="difflineminus">-  {</span>
<a href="#l3.5796"></a><span id="l3.5796" class="difflineplus">+void nsImapProtocol::FlushDownloadCache() {</span>
<a href="#l3.5797"></a><span id="l3.5797" class="difflineplus">+  if (!m_downloadLineCache-&gt;CacheEmpty()) {</span>
<a href="#l3.5798"></a><span id="l3.5798">     msg_line_info *downloadLine = m_downloadLineCache-&gt;GetCurrentLineInfo();</span>
<a href="#l3.5799"></a><span id="l3.5799">     PostLineDownLoadEvent(downloadLine-&gt;adoptedMessageLine,</span>
<a href="#l3.5800"></a><span id="l3.5800">                           downloadLine-&gt;uidOfMessage);</span>
<a href="#l3.5801"></a><span id="l3.5801">     m_downloadLineCache-&gt;ResetCache();</span>
<a href="#l3.5802"></a><span id="l3.5802">   }</span>
<a href="#l3.5803"></a><span id="l3.5803"> }</span>
<a href="#l3.5804"></a><span id="l3.5804"> </span>
<a href="#l3.5805"></a><span id="l3.5805" class="difflineminus">-void nsImapProtocol::NormalMessageEndDownload()</span>
<a href="#l3.5806"></a><span id="l3.5806" class="difflineminus">-{</span>
<a href="#l3.5807"></a><span id="l3.5807" class="difflineplus">+void nsImapProtocol::NormalMessageEndDownload() {</span>
<a href="#l3.5808"></a><span id="l3.5808">   Log(&quot;STREAM&quot;, &quot;CLOSE&quot;, &quot;Normal Message End Download Stream&quot;);</span>
<a href="#l3.5809"></a><span id="l3.5809"> </span>
<a href="#l3.5810"></a><span id="l3.5810" class="difflineminus">-  if (m_trackingTime)</span>
<a href="#l3.5811"></a><span id="l3.5811" class="difflineminus">-    AdjustChunkSize();</span>
<a href="#l3.5812"></a><span id="l3.5812" class="difflineminus">-  if (m_imapMailFolderSink &amp;&amp; m_curHdrInfo &amp;&amp; GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.5813"></a><span id="l3.5813" class="difflineminus">-  {</span>
<a href="#l3.5814"></a><span id="l3.5814" class="difflineplus">+  if (m_trackingTime) AdjustChunkSize();</span>
<a href="#l3.5815"></a><span id="l3.5815" class="difflineplus">+  if (m_imapMailFolderSink &amp;&amp; m_curHdrInfo &amp;&amp;</span>
<a href="#l3.5816"></a><span id="l3.5816" class="difflineplus">+      GetServerStateParser().GetDownloadingHeaders()) {</span>
<a href="#l3.5817"></a><span id="l3.5817">     m_curHdrInfo-&gt;SetMsgSize(GetServerStateParser().SizeOfMostRecentMessage());</span>
<a href="#l3.5818"></a><span id="l3.5818">     m_curHdrInfo-&gt;SetMsgUid(GetServerStateParser().CurrentResponseUID());</span>
<a href="#l3.5819"></a><span id="l3.5819">     m_hdrDownloadCache-&gt;FinishCurrentHdr();</span>
<a href="#l3.5820"></a><span id="l3.5820">     int32_t numHdrsCached;</span>
<a href="#l3.5821"></a><span id="l3.5821">     m_hdrDownloadCache-&gt;GetNumHeaders(&amp;numHdrsCached);</span>
<a href="#l3.5822"></a><span id="l3.5822" class="difflineminus">-    if (numHdrsCached == kNumHdrsToXfer)</span>
<a href="#l3.5823"></a><span id="l3.5823" class="difflineminus">-    {</span>
<a href="#l3.5824"></a><span id="l3.5824" class="difflineplus">+    if (numHdrsCached == kNumHdrsToXfer) {</span>
<a href="#l3.5825"></a><span id="l3.5825">       m_imapMailFolderSink-&gt;ParseMsgHdrs(this, m_hdrDownloadCache);</span>
<a href="#l3.5826"></a><span id="l3.5826">       m_hdrDownloadCache-&gt;ResetAll();</span>
<a href="#l3.5827"></a><span id="l3.5827">     }</span>
<a href="#l3.5828"></a><span id="l3.5828">   }</span>
<a href="#l3.5829"></a><span id="l3.5829">   FlushDownloadCache();</span>
<a href="#l3.5830"></a><span id="l3.5830"> </span>
<a href="#l3.5831"></a><span id="l3.5831" class="difflineminus">-  if (!GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.5832"></a><span id="l3.5832" class="difflineminus">-  {</span>
<a href="#l3.5833"></a><span id="l3.5833" class="difflineplus">+  if (!GetServerStateParser().GetDownloadingHeaders()) {</span>
<a href="#l3.5834"></a><span id="l3.5834">     int32_t updatedMessageSize = -1;</span>
<a href="#l3.5835"></a><span id="l3.5835" class="difflineminus">-    if (m_fetchingWholeMessage)</span>
<a href="#l3.5836"></a><span id="l3.5836" class="difflineminus">-    {</span>
<a href="#l3.5837"></a><span id="l3.5837" class="difflineplus">+    if (m_fetchingWholeMessage) {</span>
<a href="#l3.5838"></a><span id="l3.5838">       updatedMessageSize = m_bytesToChannel;</span>
<a href="#l3.5839"></a><span id="l3.5839" class="difflineminus">-      if (m_bytesToChannel != GetServerStateParser().SizeOfMostRecentMessage()) {</span>
<a href="#l3.5840"></a><span id="l3.5840" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Debug, (&quot;STREAM:CLOSE Server's RFC822.SIZE %u, actual size %u&quot;,</span>
<a href="#l3.5841"></a><span id="l3.5841" class="difflineminus">-                                    GetServerStateParser().SizeOfMostRecentMessage(),</span>
<a href="#l3.5842"></a><span id="l3.5842" class="difflineminus">-                                    m_bytesToChannel));</span>
<a href="#l3.5843"></a><span id="l3.5843" class="difflineplus">+      if (m_bytesToChannel !=</span>
<a href="#l3.5844"></a><span id="l3.5844" class="difflineplus">+          GetServerStateParser().SizeOfMostRecentMessage()) {</span>
<a href="#l3.5845"></a><span id="l3.5845" class="difflineplus">+        MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.5846"></a><span id="l3.5846" class="difflineplus">+                (&quot;STREAM:CLOSE Server's RFC822.SIZE %u, actual size %u&quot;,</span>
<a href="#l3.5847"></a><span id="l3.5847" class="difflineplus">+                 GetServerStateParser().SizeOfMostRecentMessage(),</span>
<a href="#l3.5848"></a><span id="l3.5848" class="difflineplus">+                 m_bytesToChannel));</span>
<a href="#l3.5849"></a><span id="l3.5849">       }</span>
<a href="#l3.5850"></a><span id="l3.5850">     }</span>
<a href="#l3.5851"></a><span id="l3.5851" class="difflineminus">-    // need to know if we're downloading for display or not. We'll use action == nsImapMsgFetch for now</span>
<a href="#l3.5852"></a><span id="l3.5852" class="difflineminus">-    nsImapAction imapAction = nsIImapUrl::nsImapSelectFolder; // just set it to some legal value</span>
<a href="#l3.5853"></a><span id="l3.5853" class="difflineminus">-    if (m_runningUrl)</span>
<a href="#l3.5854"></a><span id="l3.5854" class="difflineminus">-      m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.5855"></a><span id="l3.5855" class="difflineplus">+    // need to know if we're downloading for display or not. We'll use action ==</span>
<a href="#l3.5856"></a><span id="l3.5856" class="difflineplus">+    // nsImapMsgFetch for now</span>
<a href="#l3.5857"></a><span id="l3.5857" class="difflineplus">+    nsImapAction imapAction =</span>
<a href="#l3.5858"></a><span id="l3.5858" class="difflineplus">+        nsIImapUrl::nsImapSelectFolder;  // just set it to some legal value</span>
<a href="#l3.5859"></a><span id="l3.5859" class="difflineplus">+    if (m_runningUrl) m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.5860"></a><span id="l3.5860"> </span>
<a href="#l3.5861"></a><span id="l3.5861">     if (m_imapMessageSink)</span>
<a href="#l3.5862"></a><span id="l3.5862" class="difflineminus">-      m_imapMessageSink-&gt;NormalEndMsgWriteStream(m_downloadLineCache-&gt;CurrentUID(), imapAction == nsIImapUrl::nsImapMsgFetch, m_runningUrl, updatedMessageSize);</span>
<a href="#l3.5863"></a><span id="l3.5863" class="difflineminus">-</span>
<a href="#l3.5864"></a><span id="l3.5864" class="difflineminus">-    if (m_runningUrl &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.5865"></a><span id="l3.5865" class="difflineminus">-    {</span>
<a href="#l3.5866"></a><span id="l3.5866" class="difflineminus">-      nsCOMPtr &lt;nsISupports&gt; copyState;</span>
<a href="#l3.5867"></a><span id="l3.5867" class="difflineplus">+      m_imapMessageSink-&gt;NormalEndMsgWriteStream(</span>
<a href="#l3.5868"></a><span id="l3.5868" class="difflineplus">+          m_downloadLineCache-&gt;CurrentUID(),</span>
<a href="#l3.5869"></a><span id="l3.5869" class="difflineplus">+          imapAction == nsIImapUrl::nsImapMsgFetch, m_runningUrl,</span>
<a href="#l3.5870"></a><span id="l3.5870" class="difflineplus">+          updatedMessageSize);</span>
<a href="#l3.5871"></a><span id="l3.5871" class="difflineplus">+</span>
<a href="#l3.5872"></a><span id="l3.5872" class="difflineplus">+    if (m_runningUrl &amp;&amp; m_imapMailFolderSink) {</span>
<a href="#l3.5873"></a><span id="l3.5873" class="difflineplus">+      nsCOMPtr&lt;nsISupports&gt; copyState;</span>
<a href="#l3.5874"></a><span id="l3.5874">       m_runningUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l3.5875"></a><span id="l3.5875" class="difflineminus">-      if (copyState) // only need this notification during copy</span>
<a href="#l3.5876"></a><span id="l3.5876" class="difflineplus">+      if (copyState)  // only need this notification during copy</span>
<a href="#l3.5877"></a><span id="l3.5877">       {</span>
<a href="#l3.5878"></a><span id="l3.5878" class="difflineminus">-        nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl (do_QueryInterface(m_runningUrl));</span>
<a href="#l3.5879"></a><span id="l3.5879" class="difflineminus">-        m_imapMailFolderSink-&gt;EndMessage(mailUrl, m_downloadLineCache-&gt;CurrentUID());</span>
<a href="#l3.5880"></a><span id="l3.5880" class="difflineplus">+        nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl(do_QueryInterface(m_runningUrl));</span>
<a href="#l3.5881"></a><span id="l3.5881" class="difflineplus">+        m_imapMailFolderSink-&gt;EndMessage(mailUrl,</span>
<a href="#l3.5882"></a><span id="l3.5882" class="difflineplus">+                                         m_downloadLineCache-&gt;CurrentUID());</span>
<a href="#l3.5883"></a><span id="l3.5883">       }</span>
<a href="#l3.5884"></a><span id="l3.5884">     }</span>
<a href="#l3.5885"></a><span id="l3.5885">   }</span>
<a href="#l3.5886"></a><span id="l3.5886">   m_curHdrInfo = nullptr;</span>
<a href="#l3.5887"></a><span id="l3.5887"> }</span>
<a href="#l3.5888"></a><span id="l3.5888"> </span>
<a href="#l3.5889"></a><span id="l3.5889" class="difflineminus">-void nsImapProtocol::AbortMessageDownLoad()</span>
<a href="#l3.5890"></a><span id="l3.5890" class="difflineminus">-{</span>
<a href="#l3.5891"></a><span id="l3.5891" class="difflineplus">+void nsImapProtocol::AbortMessageDownLoad() {</span>
<a href="#l3.5892"></a><span id="l3.5892">   Log(&quot;STREAM&quot;, &quot;CLOSE&quot;, &quot;Abort Message  Download Stream&quot;);</span>
<a href="#l3.5893"></a><span id="l3.5893"> </span>
<a href="#l3.5894"></a><span id="l3.5894" class="difflineminus">-  if (m_trackingTime)</span>
<a href="#l3.5895"></a><span id="l3.5895" class="difflineminus">-    AdjustChunkSize();</span>
<a href="#l3.5896"></a><span id="l3.5896" class="difflineplus">+  if (m_trackingTime) AdjustChunkSize();</span>
<a href="#l3.5897"></a><span id="l3.5897">   FlushDownloadCache();</span>
<a href="#l3.5898"></a><span id="l3.5898" class="difflineminus">-  if (GetServerStateParser().GetDownloadingHeaders())</span>
<a href="#l3.5899"></a><span id="l3.5899" class="difflineminus">-  {</span>
<a href="#l3.5900"></a><span id="l3.5900" class="difflineplus">+  if (GetServerStateParser().GetDownloadingHeaders()) {</span>
<a href="#l3.5901"></a><span id="l3.5901">     if (m_imapMailFolderSink)</span>
<a href="#l3.5902"></a><span id="l3.5902">       m_imapMailFolderSink-&gt;AbortHeaderParseStream(this);</span>
<a href="#l3.5903"></a><span id="l3.5903" class="difflineminus">-  }</span>
<a href="#l3.5904"></a><span id="l3.5904" class="difflineminus">-  else if (m_imapMessageSink)</span>
<a href="#l3.5905"></a><span id="l3.5905" class="difflineminus">-        m_imapMessageSink-&gt;AbortMsgWriteStream();</span>
<a href="#l3.5906"></a><span id="l3.5906" class="difflineplus">+  } else if (m_imapMessageSink)</span>
<a href="#l3.5907"></a><span id="l3.5907" class="difflineplus">+    m_imapMessageSink-&gt;AbortMsgWriteStream();</span>
<a href="#l3.5908"></a><span id="l3.5908"> </span>
<a href="#l3.5909"></a><span id="l3.5909">   m_curHdrInfo = nullptr;</span>
<a href="#l3.5910"></a><span id="l3.5910"> }</span>
<a href="#l3.5911"></a><span id="l3.5911"> </span>
<a href="#l3.5912"></a><span id="l3.5912" class="difflineminus">-</span>
<a href="#l3.5913"></a><span id="l3.5913" class="difflineminus">-void nsImapProtocol::ProcessMailboxUpdate(bool handlePossibleUndo)</span>
<a href="#l3.5914"></a><span id="l3.5914" class="difflineminus">-{</span>
<a href="#l3.5915"></a><span id="l3.5915" class="difflineminus">-  if (DeathSignalReceived())</span>
<a href="#l3.5916"></a><span id="l3.5916" class="difflineminus">-    return;</span>
<a href="#l3.5917"></a><span id="l3.5917" class="difflineplus">+void nsImapProtocol::ProcessMailboxUpdate(bool handlePossibleUndo) {</span>
<a href="#l3.5918"></a><span id="l3.5918" class="difflineplus">+  if (DeathSignalReceived()) return;</span>
<a href="#l3.5919"></a><span id="l3.5919"> </span>
<a href="#l3.5920"></a><span id="l3.5920">   // Update quota information</span>
<a href="#l3.5921"></a><span id="l3.5921">   char *boxName;</span>
<a href="#l3.5922"></a><span id="l3.5922">   GetSelectedMailboxName(&amp;boxName);</span>
<a href="#l3.5923"></a><span id="l3.5923">   GetQuotaDataIfSupported(boxName);</span>
<a href="#l3.5924"></a><span id="l3.5924">   PR_Free(boxName);</span>
<a href="#l3.5925"></a><span id="l3.5925"> </span>
<a href="#l3.5926"></a><span id="l3.5926">   // fetch the flags and uids of all existing messages or new ones</span>
<a href="#l3.5927"></a><span id="l3.5927" class="difflineminus">-  if (!DeathSignalReceived() &amp;&amp; GetServerStateParser().NumberOfMessages())</span>
<a href="#l3.5928"></a><span id="l3.5928" class="difflineminus">-  {</span>
<a href="#l3.5929"></a><span id="l3.5929" class="difflineminus">-    if (handlePossibleUndo)</span>
<a href="#l3.5930"></a><span id="l3.5930" class="difflineminus">-    {</span>
<a href="#l3.5931"></a><span id="l3.5931" class="difflineplus">+  if (!DeathSignalReceived() &amp;&amp; GetServerStateParser().NumberOfMessages()) {</span>
<a href="#l3.5932"></a><span id="l3.5932" class="difflineplus">+    if (handlePossibleUndo) {</span>
<a href="#l3.5933"></a><span id="l3.5933">       // undo any delete flags we may have asked to</span>
<a href="#l3.5934"></a><span id="l3.5934">       nsCString undoIdsStr;</span>
<a href="#l3.5935"></a><span id="l3.5935">       nsAutoCString undoIds;</span>
<a href="#l3.5936"></a><span id="l3.5936"> </span>
<a href="#l3.5937"></a><span id="l3.5937">       GetCurrentUrl()-&gt;GetListOfMessageIds(undoIdsStr);</span>
<a href="#l3.5938"></a><span id="l3.5938">       undoIds.Assign(undoIdsStr);</span>
<a href="#l3.5939"></a><span id="l3.5939" class="difflineminus">-      if (!undoIds.IsEmpty())</span>
<a href="#l3.5940"></a><span id="l3.5940" class="difflineminus">-      {</span>
<a href="#l3.5941"></a><span id="l3.5941" class="difflineminus">-        char firstChar = (char) undoIds.CharAt(0);</span>
<a href="#l3.5942"></a><span id="l3.5942" class="difflineplus">+      if (!undoIds.IsEmpty()) {</span>
<a href="#l3.5943"></a><span id="l3.5943" class="difflineplus">+        char firstChar = (char)undoIds.CharAt(0);</span>
<a href="#l3.5944"></a><span id="l3.5944">         undoIds.Cut(0, 1);  // remove first character</span>
<a href="#l3.5945"></a><span id="l3.5945">         // if this string started with a '-', then this is an undo of a delete</span>
<a href="#l3.5946"></a><span id="l3.5946">         // if its a '+' its a redo</span>
<a href="#l3.5947"></a><span id="l3.5947">         if (firstChar == '-')</span>
<a href="#l3.5948"></a><span id="l3.5948" class="difflineminus">-          Store(undoIds, &quot;-FLAGS (\\Deleted)&quot;, true);  // most servers will fail silently on a failure, deal with it?</span>
<a href="#l3.5949"></a><span id="l3.5949" class="difflineminus">-        else  if (firstChar == '+')</span>
<a href="#l3.5950"></a><span id="l3.5950" class="difflineminus">-          Store(undoIds, &quot;+FLAGS (\\Deleted)&quot;, true);  // most servers will fail silently on a failure, deal with it?</span>
<a href="#l3.5951"></a><span id="l3.5951" class="difflineplus">+          Store(undoIds, &quot;-FLAGS (\\Deleted)&quot;,</span>
<a href="#l3.5952"></a><span id="l3.5952" class="difflineplus">+                true);  // most servers will fail silently on a failure, deal</span>
<a href="#l3.5953"></a><span id="l3.5953" class="difflineplus">+                        // with it?</span>
<a href="#l3.5954"></a><span id="l3.5954" class="difflineplus">+        else if (firstChar == '+')</span>
<a href="#l3.5955"></a><span id="l3.5955" class="difflineplus">+          Store(undoIds, &quot;+FLAGS (\\Deleted)&quot;,</span>
<a href="#l3.5956"></a><span id="l3.5956" class="difflineplus">+                true);  // most servers will fail silently on a failure, deal</span>
<a href="#l3.5957"></a><span id="l3.5957" class="difflineplus">+                        // with it?</span>
<a href="#l3.5958"></a><span id="l3.5958">         else</span>
<a href="#l3.5959"></a><span id="l3.5959">           NS_ASSERTION(false, &quot;bogus undo Id's&quot;);</span>
<a href="#l3.5960"></a><span id="l3.5960">       }</span>
<a href="#l3.5961"></a><span id="l3.5961">     }</span>
<a href="#l3.5962"></a><span id="l3.5962"> </span>
<a href="#l3.5963"></a><span id="l3.5963">     // make the parser record these flags</span>
<a href="#l3.5964"></a><span id="l3.5964">     nsCString fetchStr;</span>
<a href="#l3.5965"></a><span id="l3.5965">     int32_t added = 0, deleted = 0;</span>
<a href="#l3.5966"></a><span id="l3.5966" class="difflineat">@@ -4351,1662 +4013,1500 @@ void nsImapProtocol::ProcessMailboxUpdat</span>
<a href="#l3.5967"></a><span id="l3.5967">     // a partial sync using CHANGEDSINCE, or a sync from the previous</span>
<a href="#l3.5968"></a><span id="l3.5968">     // highwater mark.</span>
<a href="#l3.5969"></a><span id="l3.5969"> </span>
<a href="#l3.5970"></a><span id="l3.5970">     // If the folder doesn't know about the highest uid, or the flag state</span>
<a href="#l3.5971"></a><span id="l3.5971">     // is empty, and we're not using CondStore, we definitely need a full sync.</span>
<a href="#l3.5972"></a><span id="l3.5972">     //</span>
<a href="#l3.5973"></a><span id="l3.5973">     // Print to log items affecting needFullFolderSync:</span>
<a href="#l3.5974"></a><span id="l3.5974">     MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.5975"></a><span id="l3.5975" class="difflineminus">-            (&quot;Do full sync?: mFolderHighestUID=%&quot; PRIu32 &quot;, added=%&quot; PRId32 &quot;, useCS=%s&quot;,</span>
<a href="#l3.5976"></a><span id="l3.5976" class="difflineplus">+            (&quot;Do full sync?: mFolderHighestUID=%&quot; PRIu32 &quot;, added=%&quot; PRId32</span>
<a href="#l3.5977"></a><span id="l3.5977" class="difflineplus">+             &quot;, useCS=%s&quot;,</span>
<a href="#l3.5978"></a><span id="l3.5978">              mFolderHighestUID, added, useCS ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.5979"></a><span id="l3.5979">     bool needFullFolderSync = !mFolderHighestUID || (flagStateEmpty &amp;&amp; !useCS);</span>
<a href="#l3.5980"></a><span id="l3.5980">     bool needFolderSync = false;</span>
<a href="#l3.5981"></a><span id="l3.5981"> </span>
<a href="#l3.5982"></a><span id="l3.5982" class="difflineminus">-    if (!needFullFolderSync)</span>
<a href="#l3.5983"></a><span id="l3.5983" class="difflineminus">-    {</span>
<a href="#l3.5984"></a><span id="l3.5984" class="difflineplus">+    if (!needFullFolderSync) {</span>
<a href="#l3.5985"></a><span id="l3.5985">       // Figure out if we need to do a non-highwater mark sync.</span>
<a href="#l3.5986"></a><span id="l3.5986">       // Set needFolderSync true when at least 1 of these 3 cases is true:</span>
<a href="#l3.5987"></a><span id="l3.5987" class="difflineminus">-      // 1. Have no uids in flag array or all flag elements are marked deleted AND</span>
<a href="#l3.5988"></a><span id="l3.5988" class="difflineminus">-      // not using CONDSTORE.</span>
<a href="#l3.5989"></a><span id="l3.5989" class="difflineminus">-      // 2. Have no uids in flag array or all flag elements are marked deleted AND</span>
<a href="#l3.5990"></a><span id="l3.5990" class="difflineminus">-      // using &quot;just mark as deleted&quot; and EXISTS response count differs from</span>
<a href="#l3.5991"></a><span id="l3.5991" class="difflineplus">+      // 1. Have no uids in flag array or all flag elements are marked deleted</span>
<a href="#l3.5992"></a><span id="l3.5992" class="difflineplus">+      // AND not using CONDSTORE.</span>
<a href="#l3.5993"></a><span id="l3.5993" class="difflineplus">+      // 2. Have no uids in flag array or all flag elements are marked deleted</span>
<a href="#l3.5994"></a><span id="l3.5994" class="difflineplus">+      // AND using &quot;just mark as deleted&quot; and EXISTS response count differs from</span>
<a href="#l3.5995"></a><span id="l3.5995">       // stored message count for folder.</span>
<a href="#l3.5996"></a><span id="l3.5996">       // 3. Using CONDSTORE and highest MODSEQ response is not equal to stored</span>
<a href="#l3.5997"></a><span id="l3.5997">       // mod seq for folder.</span>
<a href="#l3.5998"></a><span id="l3.5998"> </span>
<a href="#l3.5999"></a><span id="l3.5999">       // Print to log items affecting needFolderSync:</span>
<a href="#l3.6000"></a><span id="l3.6000" class="difflineplus">+      // clang-format off</span>
<a href="#l3.6001"></a><span id="l3.6001">       MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6002"></a><span id="l3.6002">               (&quot;1. Do a sync?: added=%&quot; PRId32 &quot;, deleted=%&quot; PRId32 &quot;, useCS=%s&quot;,</span>
<a href="#l3.6003"></a><span id="l3.6003" class="difflineminus">-               added, deleted,  useCS ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.6004"></a><span id="l3.6004" class="difflineplus">+               added, deleted, useCS ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.6005"></a><span id="l3.6005">       MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6006"></a><span id="l3.6006" class="difflineminus">-              (&quot;2. Do a sync?: ShowDeletedMsgs=%s, exists=%&quot; PRId32 &quot;, mFolderTotalMsgCount=%&quot; PRId32,</span>
<a href="#l3.6007"></a><span id="l3.6007" class="difflineminus">-               GetShowDeletedMessages() ? &quot;true&quot; : &quot;false&quot;, GetServerStateParser().NumberOfMessages(),</span>
<a href="#l3.6008"></a><span id="l3.6008" class="difflineminus">-               mFolderTotalMsgCount));</span>
<a href="#l3.6009"></a><span id="l3.6009" class="difflineplus">+              (&quot;2. Do a sync?: ShowDeletedMsgs=%s, exists=%&quot; PRId32</span>
<a href="#l3.6010"></a><span id="l3.6010" class="difflineplus">+               &quot;, mFolderTotalMsgCount=%&quot; PRId32,</span>
<a href="#l3.6011"></a><span id="l3.6011" class="difflineplus">+               GetShowDeletedMessages() ? &quot;true&quot; : &quot;false&quot;,</span>
<a href="#l3.6012"></a><span id="l3.6012" class="difflineplus">+               GetServerStateParser().NumberOfMessages(), mFolderTotalMsgCount));</span>
<a href="#l3.6013"></a><span id="l3.6013" class="difflineplus">+      // clang-format on</span>
<a href="#l3.6014"></a><span id="l3.6014">       MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6015"></a><span id="l3.6015" class="difflineminus">-              (&quot;3. Do a sync?: fHighestModSeq=%&quot; PRIu64 &quot;, mFolderLastModSeq=%&quot; PRIu64,</span>
<a href="#l3.6016"></a><span id="l3.6016" class="difflineminus">-               GetServerStateParser().fHighestModSeq,  mFolderLastModSeq));</span>
<a href="#l3.6017"></a><span id="l3.6017" class="difflineplus">+              (&quot;3. Do a sync?: fHighestModSeq=%&quot; PRIu64</span>
<a href="#l3.6018"></a><span id="l3.6018" class="difflineplus">+               &quot;, mFolderLastModSeq=%&quot; PRIu64,</span>
<a href="#l3.6019"></a><span id="l3.6019" class="difflineplus">+               GetServerStateParser().fHighestModSeq, mFolderLastModSeq));</span>
<a href="#l3.6020"></a><span id="l3.6020"> </span>
<a href="#l3.6021"></a><span id="l3.6021">       needFolderSync =</span>
<a href="#l3.6022"></a><span id="l3.6022" class="difflineminus">-        (</span>
<a href="#l3.6023"></a><span id="l3.6023" class="difflineminus">-          (flagStateEmpty || added == deleted) &amp;&amp;</span>
<a href="#l3.6024"></a><span id="l3.6024" class="difflineminus">-          (</span>
<a href="#l3.6025"></a><span id="l3.6025" class="difflineminus">-            !useCS</span>
<a href="#l3.6026"></a><span id="l3.6026" class="difflineminus">-            ||</span>
<a href="#l3.6027"></a><span id="l3.6027" class="difflineminus">-            (GetShowDeletedMessages() &amp;&amp;</span>
<a href="#l3.6028"></a><span id="l3.6028" class="difflineminus">-             GetServerStateParser().NumberOfMessages() != mFolderTotalMsgCount)</span>
<a href="#l3.6029"></a><span id="l3.6029" class="difflineminus">-          )</span>
<a href="#l3.6030"></a><span id="l3.6030" class="difflineminus">-        )</span>
<a href="#l3.6031"></a><span id="l3.6031" class="difflineminus">-        ||</span>
<a href="#l3.6032"></a><span id="l3.6032" class="difflineminus">-        (useCS &amp;&amp; GetServerStateParser().fHighestModSeq != mFolderLastModSeq);</span>
<a href="#l3.6033"></a><span id="l3.6033" class="difflineminus">-    }</span>
<a href="#l3.6034"></a><span id="l3.6034" class="difflineminus">-    MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;needFullFolderSync=%s, needFolderSync=%s&quot;,</span>
<a href="#l3.6035"></a><span id="l3.6035" class="difflineminus">-            needFullFolderSync ? &quot;true&quot; : &quot;false&quot;, needFolderSync ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.6036"></a><span id="l3.6036" class="difflineminus">-</span>
<a href="#l3.6037"></a><span id="l3.6037" class="difflineminus">-    if (needFullFolderSync || needFolderSync)</span>
<a href="#l3.6038"></a><span id="l3.6038" class="difflineminus">-    {</span>
<a href="#l3.6039"></a><span id="l3.6039" class="difflineplus">+          ((flagStateEmpty || added == deleted) &amp;&amp;</span>
<a href="#l3.6040"></a><span id="l3.6040" class="difflineplus">+           (!useCS || (GetShowDeletedMessages() &amp;&amp;</span>
<a href="#l3.6041"></a><span id="l3.6041" class="difflineplus">+                       GetServerStateParser().NumberOfMessages() !=</span>
<a href="#l3.6042"></a><span id="l3.6042" class="difflineplus">+                           mFolderTotalMsgCount))) ||</span>
<a href="#l3.6043"></a><span id="l3.6043" class="difflineplus">+          (useCS &amp;&amp; GetServerStateParser().fHighestModSeq != mFolderLastModSeq);</span>
<a href="#l3.6044"></a><span id="l3.6044" class="difflineplus">+    }</span>
<a href="#l3.6045"></a><span id="l3.6045" class="difflineplus">+    MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6046"></a><span id="l3.6046" class="difflineplus">+            (&quot;needFullFolderSync=%s, needFolderSync=%s&quot;,</span>
<a href="#l3.6047"></a><span id="l3.6047" class="difflineplus">+             needFullFolderSync ? &quot;true&quot; : &quot;false&quot;,</span>
<a href="#l3.6048"></a><span id="l3.6048" class="difflineplus">+             needFolderSync ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.6049"></a><span id="l3.6049" class="difflineplus">+</span>
<a href="#l3.6050"></a><span id="l3.6050" class="difflineplus">+    if (needFullFolderSync || needFolderSync) {</span>
<a href="#l3.6051"></a><span id="l3.6051">       nsCString idsToFetch(&quot;1:*&quot;);</span>
<a href="#l3.6052"></a><span id="l3.6052">       char fetchModifier[40] = &quot;&quot;;</span>
<a href="#l3.6053"></a><span id="l3.6053" class="difflineminus">-      if (!needFullFolderSync &amp;&amp; !GetShowDeletedMessages() &amp;&amp; useCS)</span>
<a href="#l3.6054"></a><span id="l3.6054" class="difflineminus">-      {</span>
<a href="#l3.6055"></a><span id="l3.6055" class="difflineplus">+      if (!needFullFolderSync &amp;&amp; !GetShowDeletedMessages() &amp;&amp; useCS) {</span>
<a href="#l3.6056"></a><span id="l3.6056">         m_flagState-&gt;StartCapture();</span>
<a href="#l3.6057"></a><span id="l3.6057" class="difflineminus">-        MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;Doing UID fetch 1:* (CHANGEDSINCE %&quot; PRIu64 &quot;)&quot;,</span>
<a href="#l3.6058"></a><span id="l3.6058" class="difflineminus">-                mFolderLastModSeq));</span>
<a href="#l3.6059"></a><span id="l3.6059" class="difflineminus">-        PR_snprintf(fetchModifier, sizeof(fetchModifier), &quot; (CHANGEDSINCE %llu)&quot;,</span>
<a href="#l3.6060"></a><span id="l3.6060" class="difflineminus">-                    mFolderLastModSeq);</span>
<a href="#l3.6061"></a><span id="l3.6061" class="difflineminus">-      }</span>
<a href="#l3.6062"></a><span id="l3.6062" class="difflineminus">-      else</span>
<a href="#l3.6063"></a><span id="l3.6063" class="difflineplus">+        MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6064"></a><span id="l3.6064" class="difflineplus">+                (&quot;Doing UID fetch 1:* (CHANGEDSINCE %&quot; PRIu64 &quot;)&quot;,</span>
<a href="#l3.6065"></a><span id="l3.6065" class="difflineplus">+                 mFolderLastModSeq));</span>
<a href="#l3.6066"></a><span id="l3.6066" class="difflineplus">+        PR_snprintf(fetchModifier, sizeof(fetchModifier),</span>
<a href="#l3.6067"></a><span id="l3.6067" class="difflineplus">+                    &quot; (CHANGEDSINCE %llu)&quot;, mFolderLastModSeq);</span>
<a href="#l3.6068"></a><span id="l3.6068" class="difflineplus">+      } else</span>
<a href="#l3.6069"></a><span id="l3.6069">         m_flagState-&gt;SetPartialUIDFetch(false);</span>
<a href="#l3.6070"></a><span id="l3.6070"> </span>
<a href="#l3.6071"></a><span id="l3.6071">       FetchMessage(idsToFetch, kFlags, fetchModifier);</span>
<a href="#l3.6072"></a><span id="l3.6072">       // lets see if we should expunge during a full sync of flags.</span>
<a href="#l3.6073"></a><span id="l3.6073" class="difflineminus">-      if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6074"></a><span id="l3.6074" class="difflineminus">-      {</span>
<a href="#l3.6075"></a><span id="l3.6075" class="difflineplus">+      if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6076"></a><span id="l3.6076">         // if we did a CHANGEDSINCE fetch, do a sanity check on the msg counts</span>
<a href="#l3.6077"></a><span id="l3.6077">         // to see if some other client may have done an expunge.</span>
<a href="#l3.6078"></a><span id="l3.6078" class="difflineminus">-        if (m_flagState-&gt;GetPartialUIDFetch())</span>
<a href="#l3.6079"></a><span id="l3.6079" class="difflineminus">-        {</span>
<a href="#l3.6080"></a><span id="l3.6080" class="difflineplus">+        if (m_flagState-&gt;GetPartialUIDFetch()) {</span>
<a href="#l3.6081"></a><span id="l3.6081">           uint32_t numExists = GetServerStateParser().NumberOfMessages();</span>
<a href="#l3.6082"></a><span id="l3.6082">           uint32_t numPrevExists = mFolderTotalMsgCount;</span>
<a href="#l3.6083"></a><span id="l3.6083"> </span>
<a href="#l3.6084"></a><span id="l3.6084" class="difflineminus">-          if (MOZ_LOG_TEST(IMAP_CS, LogLevel::Debug))</span>
<a href="#l3.6085"></a><span id="l3.6085" class="difflineminus">-          {</span>
<a href="#l3.6086"></a><span id="l3.6086" class="difflineplus">+          if (MOZ_LOG_TEST(IMAP_CS, LogLevel::Debug)) {</span>
<a href="#l3.6087"></a><span id="l3.6087">             int32_t addedByPartialFetch;</span>
<a href="#l3.6088"></a><span id="l3.6088">             m_flagState-&gt;GetNumberOfMessages(&amp;addedByPartialFetch);</span>
<a href="#l3.6089"></a><span id="l3.6089" class="difflineminus">-            MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;Sanity, deleted=%&quot; PRId32 &quot;, numPrevExists=%&quot; PRIu32 &quot;, numExists=%&quot; PRIu32,</span>
<a href="#l3.6090"></a><span id="l3.6090" class="difflineminus">-                    m_flagState-&gt;NumberOfDeletedMessages(), numPrevExists,  numExists));</span>
<a href="#l3.6091"></a><span id="l3.6091" class="difflineminus">-            MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;Sanity, addedByPartialFetch=%&quot; PRId32,</span>
<a href="#l3.6092"></a><span id="l3.6092" class="difflineminus">-                    addedByPartialFetch));</span>
<a href="#l3.6093"></a><span id="l3.6093" class="difflineplus">+            MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6094"></a><span id="l3.6094" class="difflineplus">+                    (&quot;Sanity, deleted=%&quot; PRId32 &quot;, numPrevExists=%&quot; PRIu32</span>
<a href="#l3.6095"></a><span id="l3.6095" class="difflineplus">+                     &quot;, numExists=%&quot; PRIu32,</span>
<a href="#l3.6096"></a><span id="l3.6096" class="difflineplus">+                     m_flagState-&gt;NumberOfDeletedMessages(), numPrevExists,</span>
<a href="#l3.6097"></a><span id="l3.6097" class="difflineplus">+                     numExists));</span>
<a href="#l3.6098"></a><span id="l3.6098" class="difflineplus">+            // clang-format off</span>
<a href="#l3.6099"></a><span id="l3.6099" class="difflineplus">+            MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6100"></a><span id="l3.6100" class="difflineplus">+                    (&quot;Sanity, addedByPartialFetch=%&quot; PRId32, addedByPartialFetch));</span>
<a href="#l3.6101"></a><span id="l3.6101" class="difflineplus">+            // clang-format on</span>
<a href="#l3.6102"></a><span id="l3.6102">           }</span>
<a href="#l3.6103"></a><span id="l3.6103"> </span>
<a href="#l3.6104"></a><span id="l3.6104">           // Determine the number of new UIDs just fetched that are greater than</span>
<a href="#l3.6105"></a><span id="l3.6105">           // the saved highest UID for the folder. numToCheck will contain the</span>
<a href="#l3.6106"></a><span id="l3.6106">           // number of UIDs just fetched and, of course, not all are new.</span>
<a href="#l3.6107"></a><span id="l3.6107">           uint32_t numNewUIDs = 0;</span>
<a href="#l3.6108"></a><span id="l3.6108">           uint32_t numToCheck = m_flagState-&gt;GetNumAdded();</span>
<a href="#l3.6109"></a><span id="l3.6109">           bool flagChangeDetected = false;</span>
<a href="#l3.6110"></a><span id="l3.6110" class="difflineminus">-          MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;numToCheck=%&quot; PRIu32, numToCheck));</span>
<a href="#l3.6111"></a><span id="l3.6111" class="difflineminus">-          if (numToCheck &amp;&amp; mFolderHighestUID)</span>
<a href="#l3.6112"></a><span id="l3.6112" class="difflineminus">-          {</span>
<a href="#l3.6113"></a><span id="l3.6113" class="difflineplus">+          MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6114"></a><span id="l3.6114" class="difflineplus">+                  (&quot;numToCheck=%&quot; PRIu32, numToCheck));</span>
<a href="#l3.6115"></a><span id="l3.6115" class="difflineplus">+          if (numToCheck &amp;&amp; mFolderHighestUID) {</span>
<a href="#l3.6116"></a><span id="l3.6116">             uint32_t uid;</span>
<a href="#l3.6117"></a><span id="l3.6117">             int32_t topIndex;</span>
<a href="#l3.6118"></a><span id="l3.6118">             m_flagState-&gt;GetNumberOfMessages(&amp;topIndex);</span>
<a href="#l3.6119"></a><span id="l3.6119">             do {</span>
<a href="#l3.6120"></a><span id="l3.6120">               topIndex--;</span>
<a href="#l3.6121"></a><span id="l3.6121">               m_flagState-&gt;GetUidOfMessage(topIndex, &amp;uid);</span>
<a href="#l3.6122"></a><span id="l3.6122" class="difflineminus">-              if (uid &amp;&amp; uid != nsMsgKey_None)</span>
<a href="#l3.6123"></a><span id="l3.6123" class="difflineminus">-              {</span>
<a href="#l3.6124"></a><span id="l3.6124" class="difflineminus">-                if (uid &gt; mFolderHighestUID)</span>
<a href="#l3.6125"></a><span id="l3.6125" class="difflineminus">-                {</span>
<a href="#l3.6126"></a><span id="l3.6126" class="difflineplus">+              if (uid &amp;&amp; uid != nsMsgKey_None) {</span>
<a href="#l3.6127"></a><span id="l3.6127" class="difflineplus">+                if (uid &gt; mFolderHighestUID) {</span>
<a href="#l3.6128"></a><span id="l3.6128">                   numNewUIDs++;</span>
<a href="#l3.6129"></a><span id="l3.6129" class="difflineminus">-                  MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;numNewUIDs=%&quot; PRIu32 &quot;, Added new UID=%&quot; PRIu32,</span>
<a href="#l3.6130"></a><span id="l3.6130" class="difflineminus">-                       numNewUIDs ,uid));</span>
<a href="#l3.6131"></a><span id="l3.6131" class="difflineplus">+                  MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6132"></a><span id="l3.6132" class="difflineplus">+                          (&quot;numNewUIDs=%&quot; PRIu32 &quot;, Added new UID=%&quot; PRIu32,</span>
<a href="#l3.6133"></a><span id="l3.6133" class="difflineplus">+                           numNewUIDs, uid));</span>
<a href="#l3.6134"></a><span id="l3.6134">                   numToCheck--;</span>
<a href="#l3.6135"></a><span id="l3.6135" class="difflineminus">-                }</span>
<a href="#l3.6136"></a><span id="l3.6136" class="difflineminus">-                else</span>
<a href="#l3.6137"></a><span id="l3.6137" class="difflineminus">-                {</span>
<a href="#l3.6138"></a><span id="l3.6138" class="difflineplus">+                } else {</span>
<a href="#l3.6139"></a><span id="l3.6139">                   // Just a flag change on an existing UID. No more new UIDs</span>
<a href="#l3.6140"></a><span id="l3.6140">                   // will be found. This does not detect an expunged message.</span>
<a href="#l3.6141"></a><span id="l3.6141">                   flagChangeDetected = true;</span>
<a href="#l3.6142"></a><span id="l3.6142" class="difflineminus">-                  MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;Not new uid=%&quot; PRIu32, uid));</span>
<a href="#l3.6143"></a><span id="l3.6143" class="difflineplus">+                  MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6144"></a><span id="l3.6144" class="difflineplus">+                          (&quot;Not new uid=%&quot; PRIu32, uid));</span>
<a href="#l3.6145"></a><span id="l3.6145">                   break;</span>
<a href="#l3.6146"></a><span id="l3.6146">                 }</span>
<a href="#l3.6147"></a><span id="l3.6147">               }</span>
<a href="#l3.6148"></a><span id="l3.6148" class="difflineminus">-            } while(numToCheck);</span>
<a href="#l3.6149"></a><span id="l3.6149" class="difflineplus">+            } while (numToCheck);</span>
<a href="#l3.6150"></a><span id="l3.6150">           }</span>
<a href="#l3.6151"></a><span id="l3.6151"> </span>
<a href="#l3.6152"></a><span id="l3.6152">           // Another client expunged at least one message if the number of new</span>
<a href="#l3.6153"></a><span id="l3.6153">           // UIDs is not equal to the observed change in the number of messages</span>
<a href="#l3.6154"></a><span id="l3.6154">           // existing in the folder.</span>
<a href="#l3.6155"></a><span id="l3.6155">           bool expungeHappened = numNewUIDs != (numExists - numPrevExists);</span>
<a href="#l3.6156"></a><span id="l3.6156" class="difflineminus">-          if (expungeHappened)</span>
<a href="#l3.6157"></a><span id="l3.6157" class="difflineminus">-          {</span>
<a href="#l3.6158"></a><span id="l3.6158" class="difflineplus">+          if (expungeHappened) {</span>
<a href="#l3.6159"></a><span id="l3.6159">             // Sanity check failed - need full fetch to remove expunged msgs.</span>
<a href="#l3.6160"></a><span id="l3.6160">             MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6161"></a><span id="l3.6161" class="difflineminus">-                    (&quot;Other client expunged msgs, do full fetch to remove expunged msgs&quot;));</span>
<a href="#l3.6162"></a><span id="l3.6162" class="difflineplus">+                    (&quot;Other client expunged msgs, do full fetch to remove &quot;</span>
<a href="#l3.6163"></a><span id="l3.6163" class="difflineplus">+                     &quot;expunged msgs&quot;));</span>
<a href="#l3.6164"></a><span id="l3.6164">             m_flagState-&gt;Reset();</span>
<a href="#l3.6165"></a><span id="l3.6165">             m_flagState-&gt;SetPartialUIDFetch(false);</span>
<a href="#l3.6166"></a><span id="l3.6166">             FetchMessage(NS_LITERAL_CSTRING(&quot;1:*&quot;), kFlags);</span>
<a href="#l3.6167"></a><span id="l3.6167" class="difflineminus">-          }</span>
<a href="#l3.6168"></a><span id="l3.6168" class="difflineminus">-          else if (numNewUIDs == 0)</span>
<a href="#l3.6169"></a><span id="l3.6169" class="difflineminus">-          {</span>
<a href="#l3.6170"></a><span id="l3.6170" class="difflineplus">+          } else if (numNewUIDs == 0) {</span>
<a href="#l3.6171"></a><span id="l3.6171">             // Nothing has been expunged and no new UIDs, so if just a flag</span>
<a href="#l3.6172"></a><span id="l3.6172">             // change on existing message(s), avoid unneeded fetch of flags for</span>
<a href="#l3.6173"></a><span id="l3.6173">             // messages with UIDs at and above uid (see var uid above) when</span>
<a href="#l3.6174"></a><span id="l3.6174">             // &quot;highwater mark&quot; fetch occurs below.</span>
<a href="#l3.6175"></a><span id="l3.6175" class="difflineminus">-            if (mFolderHighestUID &amp;&amp; flagChangeDetected)</span>
<a href="#l3.6176"></a><span id="l3.6176" class="difflineminus">-            {</span>
<a href="#l3.6177"></a><span id="l3.6177" class="difflineminus">-              MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;Avoid unneeded fetches after just flag changes&quot;));</span>
<a href="#l3.6178"></a><span id="l3.6178" class="difflineplus">+            if (mFolderHighestUID &amp;&amp; flagChangeDetected) {</span>
<a href="#l3.6179"></a><span id="l3.6179" class="difflineplus">+              MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6180"></a><span id="l3.6180" class="difflineplus">+                      (&quot;Avoid unneeded fetches after just flag changes&quot;));</span>
<a href="#l3.6181"></a><span id="l3.6181">               GetServerStateParser().ResetHighestRecordedUID();</span>
<a href="#l3.6182"></a><span id="l3.6182">             }</span>
<a href="#l3.6183"></a><span id="l3.6183">           }</span>
<a href="#l3.6184"></a><span id="l3.6184">         }</span>
<a href="#l3.6185"></a><span id="l3.6185">         int32_t numDeleted = m_flagState-&gt;NumberOfDeletedMessages();</span>
<a href="#l3.6186"></a><span id="l3.6186">         // Don't do expunge when we are lite selecting folder because we</span>
<a href="#l3.6187"></a><span id="l3.6187">         // could be doing undo.</span>
<a href="#l3.6188"></a><span id="l3.6188">         // Expunge if we're always expunging, or the number of deleted messages</span>
<a href="#l3.6189"></a><span id="l3.6189">         // is over the threshold, and we're either always respecting the</span>
<a href="#l3.6190"></a><span id="l3.6190">         // threshold, or we're expunging based on the delete model, and</span>
<a href="#l3.6191"></a><span id="l3.6191">         // the delete model is not the imap delete model.</span>
<a href="#l3.6192"></a><span id="l3.6192">         if (m_imapAction != nsIImapUrl::nsImapLiteSelectFolder &amp;&amp;</span>
<a href="#l3.6193"></a><span id="l3.6193">             (gExpungeOption == kAutoExpungeAlways ||</span>
<a href="#l3.6194"></a><span id="l3.6194">              (numDeleted &gt;= gExpungeThreshold &amp;&amp;</span>
<a href="#l3.6195"></a><span id="l3.6195">               (gExpungeOption == kAutoExpungeOnThreshold ||</span>
<a href="#l3.6196"></a><span id="l3.6196" class="difflineminus">-               (gExpungeOption == kAutoExpungeDeleteModel &amp;&amp; !GetShowDeletedMessages())))))</span>
<a href="#l3.6197"></a><span id="l3.6197" class="difflineplus">+               (gExpungeOption == kAutoExpungeDeleteModel &amp;&amp;</span>
<a href="#l3.6198"></a><span id="l3.6198" class="difflineplus">+                !GetShowDeletedMessages())))))</span>
<a href="#l3.6199"></a><span id="l3.6199">           Expunge();</span>
<a href="#l3.6200"></a><span id="l3.6200">       }</span>
<a href="#l3.6201"></a><span id="l3.6201" class="difflineminus">-    }</span>
<a href="#l3.6202"></a><span id="l3.6202" class="difflineminus">-    else</span>
<a href="#l3.6203"></a><span id="l3.6203" class="difflineminus">-    {</span>
<a href="#l3.6204"></a><span id="l3.6204" class="difflineplus">+    } else {</span>
<a href="#l3.6205"></a><span id="l3.6205">       // Obtain the highest (highwater mark) UID seen since the last UIDVALIDITY</span>
<a href="#l3.6206"></a><span id="l3.6206" class="difflineminus">-      // response occurred (associated with the most recent SELECT for the folder).</span>
<a href="#l3.6207"></a><span id="l3.6207" class="difflineplus">+      // response occurred (associated with the most recent SELECT for the</span>
<a href="#l3.6208"></a><span id="l3.6208" class="difflineplus">+      // folder).</span>
<a href="#l3.6209"></a><span id="l3.6209">       uint32_t highestRecordedUID = GetServerStateParser().HighestRecordedUID();</span>
<a href="#l3.6210"></a><span id="l3.6210">       // if we're using CONDSTORE, and the parser hasn't seen any UIDs, use</span>
<a href="#l3.6211"></a><span id="l3.6211">       // the highest UID previously seen and saved for the folder instead.</span>
<a href="#l3.6212"></a><span id="l3.6212" class="difflineminus">-      if (useCS &amp;&amp; !highestRecordedUID)</span>
<a href="#l3.6213"></a><span id="l3.6213" class="difflineminus">-        highestRecordedUID = mFolderHighestUID;</span>
<a href="#l3.6214"></a><span id="l3.6214" class="difflineminus">-      MOZ_LOG(IMAP_CS, LogLevel::Debug, (&quot;Check for new messages above UID=%&quot; PRIu32,</span>
<a href="#l3.6215"></a><span id="l3.6215" class="difflineminus">-              highestRecordedUID));</span>
<a href="#l3.6216"></a><span id="l3.6216" class="difflineplus">+      if (useCS &amp;&amp; !highestRecordedUID) highestRecordedUID = mFolderHighestUID;</span>
<a href="#l3.6217"></a><span id="l3.6217" class="difflineplus">+      // clang-format off</span>
<a href="#l3.6218"></a><span id="l3.6218" class="difflineplus">+      MOZ_LOG(IMAP_CS, LogLevel::Debug,</span>
<a href="#l3.6219"></a><span id="l3.6219" class="difflineplus">+              (&quot;Check for new messages above UID=%&quot; PRIu32, highestRecordedUID));</span>
<a href="#l3.6220"></a><span id="l3.6220" class="difflineplus">+      // clang-format on</span>
<a href="#l3.6221"></a><span id="l3.6221">       AppendUid(fetchStr, highestRecordedUID + 1);</span>
<a href="#l3.6222"></a><span id="l3.6222">       fetchStr.AppendLiteral(&quot;:*&quot;);</span>
<a href="#l3.6223"></a><span id="l3.6223" class="difflineminus">-      FetchMessage(fetchStr, kFlags);      // only new messages please</span>
<a href="#l3.6224"></a><span id="l3.6224" class="difflineminus">-    }</span>
<a href="#l3.6225"></a><span id="l3.6225" class="difflineminus">-  }</span>
<a href="#l3.6226"></a><span id="l3.6226" class="difflineminus">-  else if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6227"></a><span id="l3.6227" class="difflineminus">-  {</span>
<a href="#l3.6228"></a><span id="l3.6228" class="difflineplus">+      FetchMessage(fetchStr, kFlags);  // only new messages please</span>
<a href="#l3.6229"></a><span id="l3.6229" class="difflineplus">+    }</span>
<a href="#l3.6230"></a><span id="l3.6230" class="difflineplus">+  } else if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6231"></a><span id="l3.6231">     GetServerStateParser().ResetFlagInfo();</span>
<a href="#l3.6232"></a><span id="l3.6232">     // the flag state is empty, but not partial.</span>
<a href="#l3.6233"></a><span id="l3.6233">     m_flagState-&gt;SetPartialUIDFetch(false);</span>
<a href="#l3.6234"></a><span id="l3.6234">   }</span>
<a href="#l3.6235"></a><span id="l3.6235"> </span>
<a href="#l3.6236"></a><span id="l3.6236" class="difflineminus">-  if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6237"></a><span id="l3.6237" class="difflineminus">-  {</span>
<a href="#l3.6238"></a><span id="l3.6238" class="difflineplus">+  if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6239"></a><span id="l3.6239">     nsImapAction imapAction;</span>
<a href="#l3.6240"></a><span id="l3.6240">     nsresult res = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.6241"></a><span id="l3.6241">     if (NS_SUCCEEDED(res) &amp;&amp; imapAction == nsIImapUrl::nsImapLiteSelectFolder)</span>
<a href="#l3.6242"></a><span id="l3.6242">       return;</span>
<a href="#l3.6243"></a><span id="l3.6243">   }</span>
<a href="#l3.6244"></a><span id="l3.6244"> </span>
<a href="#l3.6245"></a><span id="l3.6245">   bool entered_waitForBodyIdsMonitor = false;</span>
<a href="#l3.6246"></a><span id="l3.6246"> </span>
<a href="#l3.6247"></a><span id="l3.6247">   uint32_t *msgIdList = nullptr;</span>
<a href="#l3.6248"></a><span id="l3.6248">   uint32_t msgCount = 0;</span>
<a href="#l3.6249"></a><span id="l3.6249"> </span>
<a href="#l3.6250"></a><span id="l3.6250" class="difflineminus">-  RefPtr&lt;nsImapMailboxSpec&gt; new_spec = GetServerStateParser().CreateCurrentMailboxSpec();</span>
<a href="#l3.6251"></a><span id="l3.6251" class="difflineminus">-  if (new_spec &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6252"></a><span id="l3.6252" class="difflineminus">-  {</span>
<a href="#l3.6253"></a><span id="l3.6253" class="difflineplus">+  RefPtr&lt;nsImapMailboxSpec&gt; new_spec =</span>
<a href="#l3.6254"></a><span id="l3.6254" class="difflineplus">+      GetServerStateParser().CreateCurrentMailboxSpec();</span>
<a href="#l3.6255"></a><span id="l3.6255" class="difflineplus">+  if (new_spec &amp;&amp; GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6256"></a><span id="l3.6256">     nsImapAction imapAction;</span>
<a href="#l3.6257"></a><span id="l3.6257">     nsresult res = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.6258"></a><span id="l3.6258">     if (NS_SUCCEEDED(res) &amp;&amp; imapAction == nsIImapUrl::nsImapExpungeFolder)</span>
<a href="#l3.6259"></a><span id="l3.6259">       new_spec-&gt;mBoxFlags |= kJustExpunged;</span>
<a href="#l3.6260"></a><span id="l3.6260">     m_waitForBodyIdsMonitor.Enter();</span>
<a href="#l3.6261"></a><span id="l3.6261">     entered_waitForBodyIdsMonitor = true;</span>
<a href="#l3.6262"></a><span id="l3.6262"> </span>
<a href="#l3.6263"></a><span id="l3.6263" class="difflineminus">-    if (m_imapMailFolderSink)</span>
<a href="#l3.6264"></a><span id="l3.6264" class="difflineminus">-    {</span>
<a href="#l3.6265"></a><span id="l3.6265" class="difflineplus">+    if (m_imapMailFolderSink) {</span>
<a href="#l3.6266"></a><span id="l3.6266">       bool more;</span>
<a href="#l3.6267"></a><span id="l3.6267">       m_imapMailFolderSink-&gt;UpdateImapMailboxInfo(this, new_spec);</span>
<a href="#l3.6268"></a><span id="l3.6268" class="difflineminus">-      m_imapMailFolderSink-&gt;GetMsgHdrsToDownload(&amp;more, &amp;m_progressExpectedNumber,</span>
<a href="#l3.6269"></a><span id="l3.6269" class="difflineminus">-                                                 &amp;msgCount, &amp;msgIdList);</span>
<a href="#l3.6270"></a><span id="l3.6270" class="difflineplus">+      m_imapMailFolderSink-&gt;GetMsgHdrsToDownload(</span>
<a href="#l3.6271"></a><span id="l3.6271" class="difflineplus">+          &amp;more, &amp;m_progressExpectedNumber, &amp;msgCount, &amp;msgIdList);</span>
<a href="#l3.6272"></a><span id="l3.6272">       // Assert that either it's empty string OR it must be header string.</span>
<a href="#l3.6273"></a><span id="l3.6273" class="difflineminus">-      MOZ_ASSERT((m_stringIndex == IMAP_EMPTY_STRING_INDEX) || (m_stringIndex == IMAP_HEADERS_STRING_INDEX));</span>
<a href="#l3.6274"></a><span id="l3.6274" class="difflineplus">+      MOZ_ASSERT((m_stringIndex == IMAP_EMPTY_STRING_INDEX) ||</span>
<a href="#l3.6275"></a><span id="l3.6275" class="difflineplus">+                 (m_stringIndex == IMAP_HEADERS_STRING_INDEX));</span>
<a href="#l3.6276"></a><span id="l3.6276">       m_progressCurrentNumber[m_stringIndex] = 0;</span>
<a href="#l3.6277"></a><span id="l3.6277">       m_runningUrl-&gt;SetMoreHeadersToDownload(more);</span>
<a href="#l3.6278"></a><span id="l3.6278">       // We're going to be re-running this url if there are more headers.</span>
<a href="#l3.6279"></a><span id="l3.6279" class="difflineminus">-      if (more)</span>
<a href="#l3.6280"></a><span id="l3.6280" class="difflineminus">-        m_runningUrl-&gt;SetRerunningUrl(true);</span>
<a href="#l3.6281"></a><span id="l3.6281" class="difflineminus">-    }</span>
<a href="#l3.6282"></a><span id="l3.6282" class="difflineminus">-  }</span>
<a href="#l3.6283"></a><span id="l3.6283" class="difflineminus">-</span>
<a href="#l3.6284"></a><span id="l3.6284" class="difflineminus">-  if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6285"></a><span id="l3.6285" class="difflineminus">-  {</span>
<a href="#l3.6286"></a><span id="l3.6286" class="difflineminus">-    if (entered_waitForBodyIdsMonitor)</span>
<a href="#l3.6287"></a><span id="l3.6287" class="difflineminus">-      m_waitForBodyIdsMonitor.Exit();</span>
<a href="#l3.6288"></a><span id="l3.6288" class="difflineminus">-</span>
<a href="#l3.6289"></a><span id="l3.6289" class="difflineminus">-    if (msgIdList &amp;&amp; !DeathSignalReceived() &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6290"></a><span id="l3.6290" class="difflineminus">-    {</span>
<a href="#l3.6291"></a><span id="l3.6291" class="difflineplus">+      if (more) m_runningUrl-&gt;SetRerunningUrl(true);</span>
<a href="#l3.6292"></a><span id="l3.6292" class="difflineplus">+    }</span>
<a href="#l3.6293"></a><span id="l3.6293" class="difflineplus">+  }</span>
<a href="#l3.6294"></a><span id="l3.6294" class="difflineplus">+</span>
<a href="#l3.6295"></a><span id="l3.6295" class="difflineplus">+  if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6296"></a><span id="l3.6296" class="difflineplus">+    if (entered_waitForBodyIdsMonitor) m_waitForBodyIdsMonitor.Exit();</span>
<a href="#l3.6297"></a><span id="l3.6297" class="difflineplus">+</span>
<a href="#l3.6298"></a><span id="l3.6298" class="difflineplus">+    if (msgIdList &amp;&amp; !DeathSignalReceived() &amp;&amp;</span>
<a href="#l3.6299"></a><span id="l3.6299" class="difflineplus">+        GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6300"></a><span id="l3.6300">       FolderHeaderDump(msgIdList, msgCount);</span>
<a href="#l3.6301"></a><span id="l3.6301" class="difflineminus">-      free( msgIdList);</span>
<a href="#l3.6302"></a><span id="l3.6302" class="difflineplus">+      free(msgIdList);</span>
<a href="#l3.6303"></a><span id="l3.6303">     }</span>
<a href="#l3.6304"></a><span id="l3.6304">     HeaderFetchCompleted();</span>
<a href="#l3.6305"></a><span id="l3.6305" class="difflineminus">-      // this might be bogus, how are we going to do pane notification and stuff when we fetch bodies without</span>
<a href="#l3.6306"></a><span id="l3.6306" class="difflineminus">-      // headers!</span>
<a href="#l3.6307"></a><span id="l3.6307" class="difflineminus">-  }</span>
<a href="#l3.6308"></a><span id="l3.6308" class="difflineminus">-  else if (entered_waitForBodyIdsMonitor) // need to exit this monitor if death signal received</span>
<a href="#l3.6309"></a><span id="l3.6309" class="difflineplus">+    // this might be bogus, how are we going to do pane notification and stuff</span>
<a href="#l3.6310"></a><span id="l3.6310" class="difflineplus">+    // when we fetch bodies without headers!</span>
<a href="#l3.6311"></a><span id="l3.6311" class="difflineplus">+  } else if (entered_waitForBodyIdsMonitor)  // need to exit this monitor if</span>
<a href="#l3.6312"></a><span id="l3.6312" class="difflineplus">+                                             // death signal received</span>
<a href="#l3.6313"></a><span id="l3.6313">     m_waitForBodyIdsMonitor.Exit();</span>
<a href="#l3.6314"></a><span id="l3.6314"> </span>
<a href="#l3.6315"></a><span id="l3.6315">   // wait for a list of bodies to fetch.</span>
<a href="#l3.6316"></a><span id="l3.6316" class="difflineminus">-  if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6317"></a><span id="l3.6317" class="difflineminus">-  {</span>
<a href="#l3.6318"></a><span id="l3.6318" class="difflineplus">+  if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6319"></a><span id="l3.6319">     WaitForPotentialListOfBodysToFetch(&amp;msgIdList, msgCount);</span>
<a href="#l3.6320"></a><span id="l3.6320" class="difflineminus">-    if ( msgCount &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6321"></a><span id="l3.6321" class="difflineminus">-    {</span>
<a href="#l3.6322"></a><span id="l3.6322" class="difflineplus">+    if (msgCount &amp;&amp; GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.6323"></a><span id="l3.6323">       // Tell the url that it should store the msg fetch results offline,</span>
<a href="#l3.6324"></a><span id="l3.6324">       // while we're dumping the messages, and then restore the setting.</span>
<a href="#l3.6325"></a><span id="l3.6325">       bool wasStoringOffline;</span>
<a href="#l3.6326"></a><span id="l3.6326">       m_runningUrl-&gt;GetStoreResultsOffline(&amp;wasStoringOffline);</span>
<a href="#l3.6327"></a><span id="l3.6327">       m_runningUrl-&gt;SetStoreResultsOffline(true);</span>
<a href="#l3.6328"></a><span id="l3.6328">       // Assert that either it's empty string OR it must be message string.</span>
<a href="#l3.6329"></a><span id="l3.6329" class="difflineminus">-      MOZ_ASSERT((m_stringIndex == IMAP_EMPTY_STRING_INDEX) || (m_stringIndex == IMAP_MESSAGES_STRING_INDEX));</span>
<a href="#l3.6330"></a><span id="l3.6330" class="difflineplus">+      MOZ_ASSERT((m_stringIndex == IMAP_EMPTY_STRING_INDEX) ||</span>
<a href="#l3.6331"></a><span id="l3.6331" class="difflineplus">+                 (m_stringIndex == IMAP_MESSAGES_STRING_INDEX));</span>
<a href="#l3.6332"></a><span id="l3.6332">       m_progressCurrentNumber[m_stringIndex] = 0;</span>
<a href="#l3.6333"></a><span id="l3.6333">       m_progressExpectedNumber = msgCount;</span>
<a href="#l3.6334"></a><span id="l3.6334">       FolderMsgDump(msgIdList, msgCount, kEveryThingRFC822Peek);</span>
<a href="#l3.6335"></a><span id="l3.6335">       m_runningUrl-&gt;SetStoreResultsOffline(wasStoringOffline);</span>
<a href="#l3.6336"></a><span id="l3.6336">     }</span>
<a href="#l3.6337"></a><span id="l3.6337">   }</span>
<a href="#l3.6338"></a><span id="l3.6338">   if (!GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.6339"></a><span id="l3.6339">     GetServerStateParser().ResetFlagInfo();</span>
<a href="#l3.6340"></a><span id="l3.6340"> }</span>
<a href="#l3.6341"></a><span id="l3.6341"> </span>
<a href="#l3.6342"></a><span id="l3.6342" class="difflineminus">-void nsImapProtocol::FolderHeaderDump(uint32_t *msgUids, uint32_t msgCount)</span>
<a href="#l3.6343"></a><span id="l3.6343" class="difflineminus">-{</span>
<a href="#l3.6344"></a><span id="l3.6344" class="difflineplus">+void nsImapProtocol::FolderHeaderDump(uint32_t *msgUids, uint32_t msgCount) {</span>
<a href="#l3.6345"></a><span id="l3.6345">   FolderMsgDump(msgUids, msgCount, kHeadersRFC822andUid);</span>
<a href="#l3.6346"></a><span id="l3.6346"> }</span>
<a href="#l3.6347"></a><span id="l3.6347"> </span>
<a href="#l3.6348"></a><span id="l3.6348" class="difflineminus">-void nsImapProtocol::FolderMsgDump(uint32_t *msgUids, uint32_t msgCount, nsIMAPeFetchFields fields)</span>
<a href="#l3.6349"></a><span id="l3.6349" class="difflineminus">-{</span>
<a href="#l3.6350"></a><span id="l3.6350" class="difflineplus">+void nsImapProtocol::FolderMsgDump(uint32_t *msgUids, uint32_t msgCount,</span>
<a href="#l3.6351"></a><span id="l3.6351" class="difflineplus">+                                   nsIMAPeFetchFields fields) {</span>
<a href="#l3.6352"></a><span id="l3.6352">   // lets worry about this progress stuff later.</span>
<a href="#l3.6353"></a><span id="l3.6353">   switch (fields) {</span>
<a href="#l3.6354"></a><span id="l3.6354" class="difflineminus">-  case kHeadersRFC822andUid:</span>
<a href="#l3.6355"></a><span id="l3.6355" class="difflineminus">-    SetProgressString(IMAP_HEADERS_STRING_INDEX);</span>
<a href="#l3.6356"></a><span id="l3.6356" class="difflineminus">-    break;</span>
<a href="#l3.6357"></a><span id="l3.6357" class="difflineminus">-  case kFlags:</span>
<a href="#l3.6358"></a><span id="l3.6358" class="difflineminus">-    SetProgressString(IMAP_FLAGS_STRING_INDEX);</span>
<a href="#l3.6359"></a><span id="l3.6359" class="difflineminus">-    break;</span>
<a href="#l3.6360"></a><span id="l3.6360" class="difflineminus">-  default:</span>
<a href="#l3.6361"></a><span id="l3.6361" class="difflineminus">-    SetProgressString(IMAP_MESSAGES_STRING_INDEX);</span>
<a href="#l3.6362"></a><span id="l3.6362" class="difflineminus">-    break;</span>
<a href="#l3.6363"></a><span id="l3.6363" class="difflineplus">+    case kHeadersRFC822andUid:</span>
<a href="#l3.6364"></a><span id="l3.6364" class="difflineplus">+      SetProgressString(IMAP_HEADERS_STRING_INDEX);</span>
<a href="#l3.6365"></a><span id="l3.6365" class="difflineplus">+      break;</span>
<a href="#l3.6366"></a><span id="l3.6366" class="difflineplus">+    case kFlags:</span>
<a href="#l3.6367"></a><span id="l3.6367" class="difflineplus">+      SetProgressString(IMAP_FLAGS_STRING_INDEX);</span>
<a href="#l3.6368"></a><span id="l3.6368" class="difflineplus">+      break;</span>
<a href="#l3.6369"></a><span id="l3.6369" class="difflineplus">+    default:</span>
<a href="#l3.6370"></a><span id="l3.6370" class="difflineplus">+      SetProgressString(IMAP_MESSAGES_STRING_INDEX);</span>
<a href="#l3.6371"></a><span id="l3.6371" class="difflineplus">+      break;</span>
<a href="#l3.6372"></a><span id="l3.6372">   }</span>
<a href="#l3.6373"></a><span id="l3.6373"> </span>
<a href="#l3.6374"></a><span id="l3.6374">   FolderMsgDumpLoop(msgUids, msgCount, fields);</span>
<a href="#l3.6375"></a><span id="l3.6375"> </span>
<a href="#l3.6376"></a><span id="l3.6376">   SetProgressString(IMAP_EMPTY_STRING_INDEX);</span>
<a href="#l3.6377"></a><span id="l3.6377"> }</span>
<a href="#l3.6378"></a><span id="l3.6378"> </span>
<a href="#l3.6379"></a><span id="l3.6379" class="difflineminus">-void nsImapProtocol::WaitForPotentialListOfBodysToFetch(uint32_t **msgIdList, uint32_t &amp;msgCount)</span>
<a href="#l3.6380"></a><span id="l3.6380" class="difflineminus">-{</span>
<a href="#l3.6381"></a><span id="l3.6381" class="difflineplus">+void nsImapProtocol::WaitForPotentialListOfBodysToFetch(uint32_t **msgIdList,</span>
<a href="#l3.6382"></a><span id="l3.6382" class="difflineplus">+                                                        uint32_t &amp;msgCount) {</span>
<a href="#l3.6383"></a><span id="l3.6383">   PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l3.6384"></a><span id="l3.6384"> </span>
<a href="#l3.6385"></a><span id="l3.6385">   ReentrantMonitorAutoEnter fetchListMon(m_fetchBodyListMonitor);</span>
<a href="#l3.6386"></a><span id="l3.6386" class="difflineminus">-  while(!m_fetchBodyListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.6387"></a><span id="l3.6387" class="difflineplus">+  while (!m_fetchBodyListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.6388"></a><span id="l3.6388">     fetchListMon.Wait(sleepTime);</span>
<a href="#l3.6389"></a><span id="l3.6389">   m_fetchBodyListIsNew = false;</span>
<a href="#l3.6390"></a><span id="l3.6390"> </span>
<a href="#l3.6391"></a><span id="l3.6391">   *msgIdList = m_fetchBodyIdList;</span>
<a href="#l3.6392"></a><span id="l3.6392" class="difflineminus">-  msgCount   = m_fetchBodyCount;</span>
<a href="#l3.6393"></a><span id="l3.6393" class="difflineminus">-}</span>
<a href="#l3.6394"></a><span id="l3.6394" class="difflineminus">-</span>
<a href="#l3.6395"></a><span id="l3.6395" class="difflineminus">-// libmsg uses this to notify a running imap url about message bodies it should download.</span>
<a href="#l3.6396"></a><span id="l3.6396" class="difflineminus">-// why not just have libmsg explicitly download the message bodies?</span>
<a href="#l3.6397"></a><span id="l3.6397" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::NotifyBodysToDownload(uint32_t *keys, uint32_t keyCount)</span>
<a href="#l3.6398"></a><span id="l3.6398" class="difflineminus">-{</span>
<a href="#l3.6399"></a><span id="l3.6399" class="difflineplus">+  msgCount = m_fetchBodyCount;</span>
<a href="#l3.6400"></a><span id="l3.6400" class="difflineplus">+}</span>
<a href="#l3.6401"></a><span id="l3.6401" class="difflineplus">+</span>
<a href="#l3.6402"></a><span id="l3.6402" class="difflineplus">+// libmsg uses this to notify a running imap url about message bodies it should</span>
<a href="#l3.6403"></a><span id="l3.6403" class="difflineplus">+// download. why not just have libmsg explicitly download the message bodies?</span>
<a href="#l3.6404"></a><span id="l3.6404" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::NotifyBodysToDownload(uint32_t *keys,</span>
<a href="#l3.6405"></a><span id="l3.6405" class="difflineplus">+                                                    uint32_t keyCount) {</span>
<a href="#l3.6406"></a><span id="l3.6406">   ReentrantMonitorAutoEnter fetchListMon(m_fetchBodyListMonitor);</span>
<a href="#l3.6407"></a><span id="l3.6407">   PR_FREEIF(m_fetchBodyIdList);</span>
<a href="#l3.6408"></a><span id="l3.6408" class="difflineminus">-  m_fetchBodyIdList = (uint32_t *) PR_MALLOC(keyCount * sizeof(uint32_t));</span>
<a href="#l3.6409"></a><span id="l3.6409" class="difflineplus">+  m_fetchBodyIdList = (uint32_t *)PR_MALLOC(keyCount * sizeof(uint32_t));</span>
<a href="#l3.6410"></a><span id="l3.6410">   if (m_fetchBodyIdList)</span>
<a href="#l3.6411"></a><span id="l3.6411">     memcpy(m_fetchBodyIdList, keys, keyCount * sizeof(uint32_t));</span>
<a href="#l3.6412"></a><span id="l3.6412" class="difflineminus">-  m_fetchBodyCount    = keyCount;</span>
<a href="#l3.6413"></a><span id="l3.6413" class="difflineplus">+  m_fetchBodyCount = keyCount;</span>
<a href="#l3.6414"></a><span id="l3.6414">   m_fetchBodyListIsNew = true;</span>
<a href="#l3.6415"></a><span id="l3.6415">   fetchListMon.Notify();</span>
<a href="#l3.6416"></a><span id="l3.6416">   return NS_OK;</span>
<a href="#l3.6417"></a><span id="l3.6417"> }</span>
<a href="#l3.6418"></a><span id="l3.6418"> </span>
<a href="#l3.6419"></a><span id="l3.6419" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::GetFlagsForUID(uint32_t uid, bool *foundIt, imapMessageFlagsType *resultFlags, char **customFlags)</span>
<a href="#l3.6420"></a><span id="l3.6420" class="difflineminus">-{</span>
<a href="#l3.6421"></a><span id="l3.6421" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::GetFlagsForUID(uint32_t uid, bool *foundIt,</span>
<a href="#l3.6422"></a><span id="l3.6422" class="difflineplus">+                                             imapMessageFlagsType *resultFlags,</span>
<a href="#l3.6423"></a><span id="l3.6423" class="difflineplus">+                                             char **customFlags) {</span>
<a href="#l3.6424"></a><span id="l3.6424">   int32_t i;</span>
<a href="#l3.6425"></a><span id="l3.6425"> </span>
<a href="#l3.6426"></a><span id="l3.6426" class="difflineminus">-  imapMessageFlagsType flags = m_flagState-&gt;GetMessageFlagsFromUID(uid, foundIt, &amp;i);</span>
<a href="#l3.6427"></a><span id="l3.6427" class="difflineminus">-  if (*foundIt)</span>
<a href="#l3.6428"></a><span id="l3.6428" class="difflineminus">-  {</span>
<a href="#l3.6429"></a><span id="l3.6429" class="difflineplus">+  imapMessageFlagsType flags =</span>
<a href="#l3.6430"></a><span id="l3.6430" class="difflineplus">+      m_flagState-&gt;GetMessageFlagsFromUID(uid, foundIt, &amp;i);</span>
<a href="#l3.6431"></a><span id="l3.6431" class="difflineplus">+  if (*foundIt) {</span>
<a href="#l3.6432"></a><span id="l3.6432">     *resultFlags = flags;</span>
<a href="#l3.6433"></a><span id="l3.6433">     if ((flags &amp; kImapMsgCustomKeywordFlag) &amp;&amp; customFlags)</span>
<a href="#l3.6434"></a><span id="l3.6434">       m_flagState-&gt;GetCustomFlags(uid, customFlags);</span>
<a href="#l3.6435"></a><span id="l3.6435">   }</span>
<a href="#l3.6436"></a><span id="l3.6436">   return NS_OK;</span>
<a href="#l3.6437"></a><span id="l3.6437"> }</span>
<a href="#l3.6438"></a><span id="l3.6438"> </span>
<a href="#l3.6439"></a><span id="l3.6439" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::GetFlagAndUidState(nsIImapFlagAndUidState **aFlagState)</span>
<a href="#l3.6440"></a><span id="l3.6440" class="difflineminus">-{</span>
<a href="#l3.6441"></a><span id="l3.6441" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::GetFlagAndUidState(</span>
<a href="#l3.6442"></a><span id="l3.6442" class="difflineplus">+    nsIImapFlagAndUidState **aFlagState) {</span>
<a href="#l3.6443"></a><span id="l3.6443">   NS_ENSURE_ARG_POINTER(aFlagState);</span>
<a href="#l3.6444"></a><span id="l3.6444">   NS_IF_ADDREF(*aFlagState = m_flagState);</span>
<a href="#l3.6445"></a><span id="l3.6445">   return NS_OK;</span>
<a href="#l3.6446"></a><span id="l3.6446"> }</span>
<a href="#l3.6447"></a><span id="l3.6447"> </span>
<a href="#l3.6448"></a><span id="l3.6448" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::GetSupportedUserFlags(uint16_t *supportedFlags)</span>
<a href="#l3.6449"></a><span id="l3.6449" class="difflineminus">-{</span>
<a href="#l3.6450"></a><span id="l3.6450" class="difflineminus">-  if (!supportedFlags)</span>
<a href="#l3.6451"></a><span id="l3.6451" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.6452"></a><span id="l3.6452" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::GetSupportedUserFlags(uint16_t *supportedFlags) {</span>
<a href="#l3.6453"></a><span id="l3.6453" class="difflineplus">+  if (!supportedFlags) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.6454"></a><span id="l3.6454"> </span>
<a href="#l3.6455"></a><span id="l3.6455">   *supportedFlags = m_flagState-&gt;GetSupportedUserFlags();</span>
<a href="#l3.6456"></a><span id="l3.6456">   return NS_OK;</span>
<a href="#l3.6457"></a><span id="l3.6457"> }</span>
<a href="#l3.6458"></a><span id="l3.6458" class="difflineminus">-void nsImapProtocol::FolderMsgDumpLoop(uint32_t *msgUids, uint32_t msgCount, nsIMAPeFetchFields fields)</span>
<a href="#l3.6459"></a><span id="l3.6459" class="difflineminus">-{</span>
<a href="#l3.6460"></a><span id="l3.6460" class="difflineplus">+void nsImapProtocol::FolderMsgDumpLoop(uint32_t *msgUids, uint32_t msgCount,</span>
<a href="#l3.6461"></a><span id="l3.6461" class="difflineplus">+                                       nsIMAPeFetchFields fields) {</span>
<a href="#l3.6462"></a><span id="l3.6462">   int32_t msgCountLeft = msgCount;</span>
<a href="#l3.6463"></a><span id="l3.6463">   uint32_t msgsDownloaded = 0;</span>
<a href="#l3.6464"></a><span id="l3.6464" class="difflineminus">-  do</span>
<a href="#l3.6465"></a><span id="l3.6465" class="difflineminus">-  {</span>
<a href="#l3.6466"></a><span id="l3.6466" class="difflineplus">+  do {</span>
<a href="#l3.6467"></a><span id="l3.6467">     nsCString idString;</span>
<a href="#l3.6468"></a><span id="l3.6468">     uint32_t msgsToDownload = msgCountLeft;</span>
<a href="#l3.6469"></a><span id="l3.6469" class="difflineminus">-    AllocateImapUidString(msgUids + msgsDownloaded, msgsToDownload, m_flagState, idString);  // 20 * 200</span>
<a href="#l3.6470"></a><span id="l3.6470" class="difflineplus">+    AllocateImapUidString(msgUids + msgsDownloaded, msgsToDownload, m_flagState,</span>
<a href="#l3.6471"></a><span id="l3.6471" class="difflineplus">+                          idString);  // 20 * 200</span>
<a href="#l3.6472"></a><span id="l3.6472">     FetchMessage(idString, fields);</span>
<a href="#l3.6473"></a><span id="l3.6473">     msgsDownloaded += msgsToDownload;</span>
<a href="#l3.6474"></a><span id="l3.6474">     msgCountLeft -= msgsToDownload;</span>
<a href="#l3.6475"></a><span id="l3.6475" class="difflineminus">-  }</span>
<a href="#l3.6476"></a><span id="l3.6476" class="difflineminus">-  while (msgCountLeft &gt; 0 &amp;&amp; !DeathSignalReceived());</span>
<a href="#l3.6477"></a><span id="l3.6477" class="difflineminus">-}</span>
<a href="#l3.6478"></a><span id="l3.6478" class="difflineminus">-</span>
<a href="#l3.6479"></a><span id="l3.6479" class="difflineminus">-void nsImapProtocol::HeaderFetchCompleted()</span>
<a href="#l3.6480"></a><span id="l3.6480" class="difflineminus">-{</span>
<a href="#l3.6481"></a><span id="l3.6481" class="difflineplus">+  } while (msgCountLeft &gt; 0 &amp;&amp; !DeathSignalReceived());</span>
<a href="#l3.6482"></a><span id="l3.6482" class="difflineplus">+}</span>
<a href="#l3.6483"></a><span id="l3.6483" class="difflineplus">+</span>
<a href="#l3.6484"></a><span id="l3.6484" class="difflineplus">+void nsImapProtocol::HeaderFetchCompleted() {</span>
<a href="#l3.6485"></a><span id="l3.6485">   if (m_imapMailFolderSink)</span>
<a href="#l3.6486"></a><span id="l3.6486">     m_imapMailFolderSink-&gt;ParseMsgHdrs(this, m_hdrDownloadCache);</span>
<a href="#l3.6487"></a><span id="l3.6487">   m_hdrDownloadCache-&gt;ReleaseAll();</span>
<a href="#l3.6488"></a><span id="l3.6488"> </span>
<a href="#l3.6489"></a><span id="l3.6489" class="difflineminus">-  if (m_imapMailFolderSink)</span>
<a href="#l3.6490"></a><span id="l3.6490" class="difflineminus">-    m_imapMailFolderSink-&gt;HeaderFetchCompleted(this);</span>
<a href="#l3.6491"></a><span id="l3.6491" class="difflineminus">-}</span>
<a href="#l3.6492"></a><span id="l3.6492" class="difflineminus">-</span>
<a href="#l3.6493"></a><span id="l3.6493" class="difflineminus">-</span>
<a href="#l3.6494"></a><span id="l3.6494" class="difflineminus">-// Use the noop to tell the server we are still here, and therefore we are willing to receive</span>
<a href="#l3.6495"></a><span id="l3.6495" class="difflineminus">-// status updates. The recent or exists response from the server could tell us that there is</span>
<a href="#l3.6496"></a><span id="l3.6496" class="difflineminus">-// more mail waiting for us, but we need to check the flags of the mail and the high water mark</span>
<a href="#l3.6497"></a><span id="l3.6497" class="difflineminus">-// to make sure that we do not tell the user that there is new mail when perhaps they have</span>
<a href="#l3.6498"></a><span id="l3.6498" class="difflineminus">-// already read it in another machine.</span>
<a href="#l3.6499"></a><span id="l3.6499" class="difflineminus">-</span>
<a href="#l3.6500"></a><span id="l3.6500" class="difflineminus">-void nsImapProtocol::PeriodicBiff()</span>
<a href="#l3.6501"></a><span id="l3.6501" class="difflineminus">-{</span>
<a href="#l3.6502"></a><span id="l3.6502" class="difflineminus">-</span>
<a href="#l3.6503"></a><span id="l3.6503" class="difflineplus">+  if (m_imapMailFolderSink) m_imapMailFolderSink-&gt;HeaderFetchCompleted(this);</span>
<a href="#l3.6504"></a><span id="l3.6504" class="difflineplus">+}</span>
<a href="#l3.6505"></a><span id="l3.6505" class="difflineplus">+</span>
<a href="#l3.6506"></a><span id="l3.6506" class="difflineplus">+// Use the noop to tell the server we are still here, and therefore we are</span>
<a href="#l3.6507"></a><span id="l3.6507" class="difflineplus">+// willing to receive status updates. The recent or exists response from the</span>
<a href="#l3.6508"></a><span id="l3.6508" class="difflineplus">+// server could tell us that there is more mail waiting for us, but we need to</span>
<a href="#l3.6509"></a><span id="l3.6509" class="difflineplus">+// check the flags of the mail and the high water mark to make sure that we do</span>
<a href="#l3.6510"></a><span id="l3.6510" class="difflineplus">+// not tell the user that there is new mail when perhaps they have already read</span>
<a href="#l3.6511"></a><span id="l3.6511" class="difflineplus">+// it in another machine.</span>
<a href="#l3.6512"></a><span id="l3.6512" class="difflineplus">+</span>
<a href="#l3.6513"></a><span id="l3.6513" class="difflineplus">+void nsImapProtocol::PeriodicBiff() {</span>
<a href="#l3.6514"></a><span id="l3.6514">   nsMsgBiffState startingState = m_currentBiffState;</span>
<a href="#l3.6515"></a><span id="l3.6515"> </span>
<a href="#l3.6516"></a><span id="l3.6516" class="difflineminus">-  if (GetServerStateParser().GetIMAPstate() == nsImapServerResponseParser::kFolderSelected)</span>
<a href="#l3.6517"></a><span id="l3.6517" class="difflineminus">-  {</span>
<a href="#l3.6518"></a><span id="l3.6518" class="difflineminus">-    Noop(); // check the latest number of messages</span>
<a href="#l3.6519"></a><span id="l3.6519" class="difflineplus">+  if (GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.6520"></a><span id="l3.6520" class="difflineplus">+      nsImapServerResponseParser::kFolderSelected) {</span>
<a href="#l3.6521"></a><span id="l3.6521" class="difflineplus">+    Noop();  // check the latest number of messages</span>
<a href="#l3.6522"></a><span id="l3.6522">     int32_t numMessages = 0;</span>
<a href="#l3.6523"></a><span id="l3.6523">     m_flagState-&gt;GetNumberOfMessages(&amp;numMessages);</span>
<a href="#l3.6524"></a><span id="l3.6524" class="difflineminus">-    if (GetServerStateParser().NumberOfMessages() != numMessages)</span>
<a href="#l3.6525"></a><span id="l3.6525" class="difflineminus">-    {</span>
<a href="#l3.6526"></a><span id="l3.6526" class="difflineplus">+    if (GetServerStateParser().NumberOfMessages() != numMessages) {</span>
<a href="#l3.6527"></a><span id="l3.6527">       uint32_t id = GetServerStateParser().HighestRecordedUID() + 1;</span>
<a href="#l3.6528"></a><span id="l3.6528" class="difflineminus">-      nsCString fetchStr;           // only update flags</span>
<a href="#l3.6529"></a><span id="l3.6529" class="difflineplus">+      nsCString fetchStr;  // only update flags</span>
<a href="#l3.6530"></a><span id="l3.6530">       uint32_t added = 0, deleted = 0;</span>
<a href="#l3.6531"></a><span id="l3.6531"> </span>
<a href="#l3.6532"></a><span id="l3.6532">       deleted = m_flagState-&gt;NumberOfDeletedMessages();</span>
<a href="#l3.6533"></a><span id="l3.6533">       added = numMessages;</span>
<a href="#l3.6534"></a><span id="l3.6534" class="difflineminus">-      if (!added || (added == deleted)) // empty keys, get them all</span>
<a href="#l3.6535"></a><span id="l3.6535" class="difflineplus">+      if (!added || (added == deleted))  // empty keys, get them all</span>
<a href="#l3.6536"></a><span id="l3.6536">         id = 1;</span>
<a href="#l3.6537"></a><span id="l3.6537"> </span>
<a href="#l3.6538"></a><span id="l3.6538" class="difflineminus">-      //sprintf(fetchStr, &quot;%ld:%ld&quot;, id, id + GetServerStateParser().NumberOfMessages() - fFlagState-&gt;GetNumberOfMessages());</span>
<a href="#l3.6539"></a><span id="l3.6539" class="difflineplus">+      // sprintf(fetchStr, &quot;%ld:%ld&quot;, id, id +</span>
<a href="#l3.6540"></a><span id="l3.6540" class="difflineplus">+      // GetServerStateParser().NumberOfMessages() -</span>
<a href="#l3.6541"></a><span id="l3.6541" class="difflineplus">+      // fFlagState-&gt;GetNumberOfMessages());</span>
<a href="#l3.6542"></a><span id="l3.6542">       AppendUid(fetchStr, id);</span>
<a href="#l3.6543"></a><span id="l3.6543">       fetchStr.AppendLiteral(&quot;:*&quot;);</span>
<a href="#l3.6544"></a><span id="l3.6544">       FetchMessage(fetchStr, kFlags);</span>
<a href="#l3.6545"></a><span id="l3.6545" class="difflineminus">-      if (((uint32_t) m_flagState-&gt;GetHighestNonDeletedUID() &gt;= id) &amp;&amp; m_flagState-&gt;IsLastMessageUnseen())</span>
<a href="#l3.6546"></a><span id="l3.6546" class="difflineplus">+      if (((uint32_t)m_flagState-&gt;GetHighestNonDeletedUID() &gt;= id) &amp;&amp;</span>
<a href="#l3.6547"></a><span id="l3.6547" class="difflineplus">+          m_flagState-&gt;IsLastMessageUnseen())</span>
<a href="#l3.6548"></a><span id="l3.6548">         m_currentBiffState = nsIMsgFolder::nsMsgBiffState_NewMail;</span>
<a href="#l3.6549"></a><span id="l3.6549">       else</span>
<a href="#l3.6550"></a><span id="l3.6550">         m_currentBiffState = nsIMsgFolder::nsMsgBiffState_NoMail;</span>
<a href="#l3.6551"></a><span id="l3.6551" class="difflineminus">-    }</span>
<a href="#l3.6552"></a><span id="l3.6552" class="difflineminus">-    else</span>
<a href="#l3.6553"></a><span id="l3.6553" class="difflineplus">+    } else</span>
<a href="#l3.6554"></a><span id="l3.6554">       m_currentBiffState = nsIMsgFolder::nsMsgBiffState_NoMail;</span>
<a href="#l3.6555"></a><span id="l3.6555" class="difflineminus">-  }</span>
<a href="#l3.6556"></a><span id="l3.6556" class="difflineminus">-  else</span>
<a href="#l3.6557"></a><span id="l3.6557" class="difflineplus">+  } else</span>
<a href="#l3.6558"></a><span id="l3.6558">     m_currentBiffState = nsIMsgFolder::nsMsgBiffState_Unknown;</span>
<a href="#l3.6559"></a><span id="l3.6559"> </span>
<a href="#l3.6560"></a><span id="l3.6560">   if (startingState != m_currentBiffState)</span>
<a href="#l3.6561"></a><span id="l3.6561">     SendSetBiffIndicatorEvent(m_currentBiffState);</span>
<a href="#l3.6562"></a><span id="l3.6562"> }</span>
<a href="#l3.6563"></a><span id="l3.6563"> </span>
<a href="#l3.6564"></a><span id="l3.6564" class="difflineminus">-void nsImapProtocol::SendSetBiffIndicatorEvent(nsMsgBiffState newState)</span>
<a href="#l3.6565"></a><span id="l3.6565" class="difflineminus">-{</span>
<a href="#l3.6566"></a><span id="l3.6566" class="difflineminus">-    if (m_imapMailFolderSink)</span>
<a href="#l3.6567"></a><span id="l3.6567" class="difflineminus">-      m_imapMailFolderSink-&gt;SetBiffStateAndUpdate(newState);</span>
<a href="#l3.6568"></a><span id="l3.6568" class="difflineminus">-}</span>
<a href="#l3.6569"></a><span id="l3.6569" class="difflineminus">-</span>
<a href="#l3.6570"></a><span id="l3.6570" class="difflineminus">-/* static */ void nsImapProtocol::LogImapUrl(const char *logMsg, nsIImapUrl *imapUrl)</span>
<a href="#l3.6571"></a><span id="l3.6571" class="difflineminus">-{</span>
<a href="#l3.6572"></a><span id="l3.6572" class="difflineminus">-  if (MOZ_LOG_TEST(IMAP, LogLevel::Info))</span>
<a href="#l3.6573"></a><span id="l3.6573" class="difflineminus">-  {</span>
<a href="#l3.6574"></a><span id="l3.6574" class="difflineplus">+void nsImapProtocol::SendSetBiffIndicatorEvent(nsMsgBiffState newState) {</span>
<a href="#l3.6575"></a><span id="l3.6575" class="difflineplus">+  if (m_imapMailFolderSink)</span>
<a href="#l3.6576"></a><span id="l3.6576" class="difflineplus">+    m_imapMailFolderSink-&gt;SetBiffStateAndUpdate(newState);</span>
<a href="#l3.6577"></a><span id="l3.6577" class="difflineplus">+}</span>
<a href="#l3.6578"></a><span id="l3.6578" class="difflineplus">+</span>
<a href="#l3.6579"></a><span id="l3.6579" class="difflineplus">+/* static */ void nsImapProtocol::LogImapUrl(const char *logMsg,</span>
<a href="#l3.6580"></a><span id="l3.6580" class="difflineplus">+                                             nsIImapUrl *imapUrl) {</span>
<a href="#l3.6581"></a><span id="l3.6581" class="difflineplus">+  if (MOZ_LOG_TEST(IMAP, LogLevel::Info)) {</span>
<a href="#l3.6582"></a><span id="l3.6582">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(imapUrl);</span>
<a href="#l3.6583"></a><span id="l3.6583" class="difflineminus">-    if (mailnewsUrl)</span>
<a href="#l3.6584"></a><span id="l3.6584" class="difflineminus">-    {</span>
<a href="#l3.6585"></a><span id="l3.6585" class="difflineplus">+    if (mailnewsUrl) {</span>
<a href="#l3.6586"></a><span id="l3.6586">       nsAutoCString urlSpec, unescapedUrlSpec;</span>
<a href="#l3.6587"></a><span id="l3.6587">       nsresult rv = mailnewsUrl-&gt;GetSpec(urlSpec);</span>
<a href="#l3.6588"></a><span id="l3.6588" class="difflineminus">-      if (NS_FAILED(rv))</span>
<a href="#l3.6589"></a><span id="l3.6589" class="difflineminus">-        return;</span>
<a href="#l3.6590"></a><span id="l3.6590" class="difflineplus">+      if (NS_FAILED(rv)) return;</span>
<a href="#l3.6591"></a><span id="l3.6591">       MsgUnescapeString(urlSpec, 0, unescapedUrlSpec);</span>
<a href="#l3.6592"></a><span id="l3.6592">       MOZ_LOG(IMAP, LogLevel::Info, (&quot;%s:%s&quot;, logMsg, unescapedUrlSpec.get()));</span>
<a href="#l3.6593"></a><span id="l3.6593">     }</span>
<a href="#l3.6594"></a><span id="l3.6594">   }</span>
<a href="#l3.6595"></a><span id="l3.6595"> }</span>
<a href="#l3.6596"></a><span id="l3.6596"> </span>
<a href="#l3.6597"></a><span id="l3.6597"> // log info including current state...</span>
<a href="#l3.6598"></a><span id="l3.6598" class="difflineminus">-void nsImapProtocol::Log(const char *logSubName, const char *extraInfo, const char *logData)</span>
<a href="#l3.6599"></a><span id="l3.6599" class="difflineminus">-{</span>
<a href="#l3.6600"></a><span id="l3.6600" class="difflineminus">-  if (MOZ_LOG_TEST(IMAP, LogLevel::Info))</span>
<a href="#l3.6601"></a><span id="l3.6601" class="difflineminus">-  {</span>
<a href="#l3.6602"></a><span id="l3.6602" class="difflineplus">+void nsImapProtocol::Log(const char *logSubName, const char *extraInfo,</span>
<a href="#l3.6603"></a><span id="l3.6603" class="difflineplus">+                         const char *logData) {</span>
<a href="#l3.6604"></a><span id="l3.6604" class="difflineplus">+  if (MOZ_LOG_TEST(IMAP, LogLevel::Info)) {</span>
<a href="#l3.6605"></a><span id="l3.6605">     static const char nonAuthStateName[] = &quot;NA&quot;;</span>
<a href="#l3.6606"></a><span id="l3.6606">     static const char authStateName[] = &quot;A&quot;;</span>
<a href="#l3.6607"></a><span id="l3.6607">     static const char selectedStateName[] = &quot;S&quot;;</span>
<a href="#l3.6608"></a><span id="l3.6608" class="difflineminus">-    const nsCString&amp; hostName = GetImapHostName();  // initialize to empty string</span>
<a href="#l3.6609"></a><span id="l3.6609" class="difflineminus">-</span>
<a href="#l3.6610"></a><span id="l3.6610" class="difflineminus">-    int32_t logDataLen = PL_strlen(logData); // PL_strlen checks for null</span>
<a href="#l3.6611"></a><span id="l3.6611" class="difflineplus">+    const nsCString &amp;hostName =</span>
<a href="#l3.6612"></a><span id="l3.6612" class="difflineplus">+        GetImapHostName();  // initialize to empty string</span>
<a href="#l3.6613"></a><span id="l3.6613" class="difflineplus">+</span>
<a href="#l3.6614"></a><span id="l3.6614" class="difflineplus">+    int32_t logDataLen = PL_strlen(logData);  // PL_strlen checks for null</span>
<a href="#l3.6615"></a><span id="l3.6615">     nsCString logDataLines;</span>
<a href="#l3.6616"></a><span id="l3.6616">     const char *logDataToLog;</span>
<a href="#l3.6617"></a><span id="l3.6617">     int32_t lastLineEnd;</span>
<a href="#l3.6618"></a><span id="l3.6618"> </span>
<a href="#l3.6619"></a><span id="l3.6619" class="difflineminus">-    const int kLogDataChunkSize = 400; // nspr line length is 512, and we</span>
<a href="#l3.6620"></a><span id="l3.6620" class="difflineminus">-                                       // allow some space for the log preamble.</span>
<a href="#l3.6621"></a><span id="l3.6621" class="difflineplus">+    // nspr line length is 512, and we allow some space for the log preamble.</span>
<a href="#l3.6622"></a><span id="l3.6622" class="difflineplus">+    const int kLogDataChunkSize = 400;</span>
<a href="#l3.6623"></a><span id="l3.6623"> </span>
<a href="#l3.6624"></a><span id="l3.6624">     // break up buffers &gt; 400 bytes on line boundaries.</span>
<a href="#l3.6625"></a><span id="l3.6625" class="difflineminus">-    if (logDataLen &gt; kLogDataChunkSize)</span>
<a href="#l3.6626"></a><span id="l3.6626" class="difflineminus">-    {</span>
<a href="#l3.6627"></a><span id="l3.6627" class="difflineplus">+    if (logDataLen &gt; kLogDataChunkSize) {</span>
<a href="#l3.6628"></a><span id="l3.6628">       logDataLines.Assign(logData);</span>
<a href="#l3.6629"></a><span id="l3.6629">       lastLineEnd = MsgRFindChar(logDataLines, '\n', kLogDataChunkSize);</span>
<a href="#l3.6630"></a><span id="l3.6630">       // null terminate the last line</span>
<a href="#l3.6631"></a><span id="l3.6631" class="difflineminus">-      if (lastLineEnd == kNotFound)</span>
<a href="#l3.6632"></a><span id="l3.6632" class="difflineminus">-        lastLineEnd = kLogDataChunkSize - 1;</span>
<a href="#l3.6633"></a><span id="l3.6633" class="difflineminus">-</span>
<a href="#l3.6634"></a><span id="l3.6634" class="difflineminus">-      logDataLines.Insert( '\0', lastLineEnd + 1);</span>
<a href="#l3.6635"></a><span id="l3.6635" class="difflineplus">+      if (lastLineEnd == kNotFound) lastLineEnd = kLogDataChunkSize - 1;</span>
<a href="#l3.6636"></a><span id="l3.6636" class="difflineplus">+</span>
<a href="#l3.6637"></a><span id="l3.6637" class="difflineplus">+      logDataLines.Insert('\0', lastLineEnd + 1);</span>
<a href="#l3.6638"></a><span id="l3.6638">       logDataToLog = logDataLines.get();</span>
<a href="#l3.6639"></a><span id="l3.6639" class="difflineminus">-    }</span>
<a href="#l3.6640"></a><span id="l3.6640" class="difflineminus">-    else</span>
<a href="#l3.6641"></a><span id="l3.6641" class="difflineminus">-    {</span>
<a href="#l3.6642"></a><span id="l3.6642" class="difflineplus">+    } else {</span>
<a href="#l3.6643"></a><span id="l3.6643">       logDataToLog = logData;</span>
<a href="#l3.6644"></a><span id="l3.6644">       lastLineEnd = logDataLen;</span>
<a href="#l3.6645"></a><span id="l3.6645">     }</span>
<a href="#l3.6646"></a><span id="l3.6646" class="difflineminus">-    switch (GetServerStateParser().GetIMAPstate())</span>
<a href="#l3.6647"></a><span id="l3.6647" class="difflineminus">-    {</span>
<a href="#l3.6648"></a><span id="l3.6648" class="difflineminus">-    case nsImapServerResponseParser::kFolderSelected:</span>
<a href="#l3.6649"></a><span id="l3.6649" class="difflineminus">-      if (extraInfo)</span>
<a href="#l3.6650"></a><span id="l3.6650" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Info, (&quot;%p:%s:%s-%s:%s:%s: %.400s&quot;, this, hostName.get(),</span>
<a href="#l3.6651"></a><span id="l3.6651" class="difflineminus">-               selectedStateName, GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.6652"></a><span id="l3.6652" class="difflineminus">-               logSubName, extraInfo, logDataToLog));</span>
<a href="#l3.6653"></a><span id="l3.6653" class="difflineminus">-      else</span>
<a href="#l3.6654"></a><span id="l3.6654" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Info, (&quot;%p:%s:%s-%s:%s: %.400s&quot;, this, hostName.get(),</span>
<a href="#l3.6655"></a><span id="l3.6655" class="difflineminus">-               selectedStateName, GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.6656"></a><span id="l3.6656" class="difflineminus">-               logSubName, logDataToLog));</span>
<a href="#l3.6657"></a><span id="l3.6657" class="difflineminus">-      break;</span>
<a href="#l3.6658"></a><span id="l3.6658" class="difflineminus">-    case nsImapServerResponseParser::kNonAuthenticated:</span>
<a href="#l3.6659"></a><span id="l3.6659" class="difflineminus">-    case nsImapServerResponseParser::kAuthenticated:</span>
<a href="#l3.6660"></a><span id="l3.6660" class="difflineminus">-    {</span>
<a href="#l3.6661"></a><span id="l3.6661" class="difflineminus">-      const char *stateName = (GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.6662"></a><span id="l3.6662" class="difflineminus">-                               nsImapServerResponseParser::kNonAuthenticated)</span>
<a href="#l3.6663"></a><span id="l3.6663" class="difflineminus">-                               ? nonAuthStateName : authStateName;</span>
<a href="#l3.6664"></a><span id="l3.6664" class="difflineminus">-      if (extraInfo)</span>
<a href="#l3.6665"></a><span id="l3.6665" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Info, (&quot;%p:%s:%s:%s:%s: %.400s&quot;, this,</span>
<a href="#l3.6666"></a><span id="l3.6666" class="difflineminus">-               hostName.get(),stateName,logSubName,extraInfo,logDataToLog));</span>
<a href="#l3.6667"></a><span id="l3.6667" class="difflineminus">-      else</span>
<a href="#l3.6668"></a><span id="l3.6668" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Info, (&quot;%p:%s:%s:%s: %.400s&quot;, this,</span>
<a href="#l3.6669"></a><span id="l3.6669" class="difflineminus">-               hostName.get(),stateName,logSubName,logDataToLog));</span>
<a href="#l3.6670"></a><span id="l3.6670" class="difflineminus">-    }</span>
<a href="#l3.6671"></a><span id="l3.6671" class="difflineplus">+    switch (GetServerStateParser().GetIMAPstate()) {</span>
<a href="#l3.6672"></a><span id="l3.6672" class="difflineplus">+      case nsImapServerResponseParser::kFolderSelected:</span>
<a href="#l3.6673"></a><span id="l3.6673" class="difflineplus">+        if (extraInfo)</span>
<a href="#l3.6674"></a><span id="l3.6674" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Info,</span>
<a href="#l3.6675"></a><span id="l3.6675" class="difflineplus">+                  (&quot;%p:%s:%s-%s:%s:%s: %.400s&quot;, this, hostName.get(),</span>
<a href="#l3.6676"></a><span id="l3.6676" class="difflineplus">+                   selectedStateName,</span>
<a href="#l3.6677"></a><span id="l3.6677" class="difflineplus">+                   GetServerStateParser().GetSelectedMailboxName(), logSubName,</span>
<a href="#l3.6678"></a><span id="l3.6678" class="difflineplus">+                   extraInfo, logDataToLog));</span>
<a href="#l3.6679"></a><span id="l3.6679" class="difflineplus">+        else</span>
<a href="#l3.6680"></a><span id="l3.6680" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Info,</span>
<a href="#l3.6681"></a><span id="l3.6681" class="difflineplus">+                  (&quot;%p:%s:%s-%s:%s: %.400s&quot;, this, hostName.get(),</span>
<a href="#l3.6682"></a><span id="l3.6682" class="difflineplus">+                   selectedStateName,</span>
<a href="#l3.6683"></a><span id="l3.6683" class="difflineplus">+                   GetServerStateParser().GetSelectedMailboxName(), logSubName,</span>
<a href="#l3.6684"></a><span id="l3.6684" class="difflineplus">+                   logDataToLog));</span>
<a href="#l3.6685"></a><span id="l3.6685" class="difflineplus">+        break;</span>
<a href="#l3.6686"></a><span id="l3.6686" class="difflineplus">+      case nsImapServerResponseParser::kNonAuthenticated:</span>
<a href="#l3.6687"></a><span id="l3.6687" class="difflineplus">+      case nsImapServerResponseParser::kAuthenticated: {</span>
<a href="#l3.6688"></a><span id="l3.6688" class="difflineplus">+        const char *stateName = (GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.6689"></a><span id="l3.6689" class="difflineplus">+                                 nsImapServerResponseParser::kNonAuthenticated)</span>
<a href="#l3.6690"></a><span id="l3.6690" class="difflineplus">+                                    ? nonAuthStateName</span>
<a href="#l3.6691"></a><span id="l3.6691" class="difflineplus">+                                    : authStateName;</span>
<a href="#l3.6692"></a><span id="l3.6692" class="difflineplus">+        if (extraInfo)</span>
<a href="#l3.6693"></a><span id="l3.6693" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Info,</span>
<a href="#l3.6694"></a><span id="l3.6694" class="difflineplus">+                  (&quot;%p:%s:%s:%s:%s: %.400s&quot;, this, hostName.get(), stateName,</span>
<a href="#l3.6695"></a><span id="l3.6695" class="difflineplus">+                   logSubName, extraInfo, logDataToLog));</span>
<a href="#l3.6696"></a><span id="l3.6696" class="difflineplus">+        else</span>
<a href="#l3.6697"></a><span id="l3.6697" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Info,</span>
<a href="#l3.6698"></a><span id="l3.6698" class="difflineplus">+                  (&quot;%p:%s:%s:%s: %.400s&quot;, this, hostName.get(), stateName,</span>
<a href="#l3.6699"></a><span id="l3.6699" class="difflineplus">+                   logSubName, logDataToLog));</span>
<a href="#l3.6700"></a><span id="l3.6700" class="difflineplus">+      }</span>
<a href="#l3.6701"></a><span id="l3.6701">     }</span>
<a href="#l3.6702"></a><span id="l3.6702"> </span>
<a href="#l3.6703"></a><span id="l3.6703">     // dump the rest of the string in &lt; 400 byte chunks</span>
<a href="#l3.6704"></a><span id="l3.6704" class="difflineminus">-    while (logDataLen &gt; kLogDataChunkSize)</span>
<a href="#l3.6705"></a><span id="l3.6705" class="difflineminus">-    {</span>
<a href="#l3.6706"></a><span id="l3.6706" class="difflineminus">-      logDataLines.Cut(0, lastLineEnd + 2); // + 2 to account for the LF and the '\0' we added</span>
<a href="#l3.6707"></a><span id="l3.6707" class="difflineplus">+    while (logDataLen &gt; kLogDataChunkSize) {</span>
<a href="#l3.6708"></a><span id="l3.6708" class="difflineplus">+      logDataLines.Cut(</span>
<a href="#l3.6709"></a><span id="l3.6709" class="difflineplus">+          0,</span>
<a href="#l3.6710"></a><span id="l3.6710" class="difflineplus">+          lastLineEnd + 2);  // + 2 to account for the LF and the '\0' we added</span>
<a href="#l3.6711"></a><span id="l3.6711">       logDataLen = logDataLines.Length();</span>
<a href="#l3.6712"></a><span id="l3.6712" class="difflineminus">-      lastLineEnd = (logDataLen &gt; kLogDataChunkSize) ? MsgRFindChar(logDataLines, '\n', kLogDataChunkSize) : kNotFound;</span>
<a href="#l3.6713"></a><span id="l3.6713" class="difflineplus">+      lastLineEnd = (logDataLen &gt; kLogDataChunkSize)</span>
<a href="#l3.6714"></a><span id="l3.6714" class="difflineplus">+                        ? MsgRFindChar(logDataLines, '\n', kLogDataChunkSize)</span>
<a href="#l3.6715"></a><span id="l3.6715" class="difflineplus">+                        : kNotFound;</span>
<a href="#l3.6716"></a><span id="l3.6716">       // null terminate the last line</span>
<a href="#l3.6717"></a><span id="l3.6717" class="difflineminus">-      if (lastLineEnd == kNotFound)</span>
<a href="#l3.6718"></a><span id="l3.6718" class="difflineminus">-        lastLineEnd = kLogDataChunkSize - 1;</span>
<a href="#l3.6719"></a><span id="l3.6719" class="difflineminus">-      logDataLines.Insert( '\0', lastLineEnd + 1);</span>
<a href="#l3.6720"></a><span id="l3.6720" class="difflineplus">+      if (lastLineEnd == kNotFound) lastLineEnd = kLogDataChunkSize - 1;</span>
<a href="#l3.6721"></a><span id="l3.6721" class="difflineplus">+      logDataLines.Insert('\0', lastLineEnd + 1);</span>
<a href="#l3.6722"></a><span id="l3.6722">       logDataToLog = logDataLines.get();</span>
<a href="#l3.6723"></a><span id="l3.6723">       MOZ_LOG(IMAP, LogLevel::Info, (&quot;%.400s&quot;, logDataToLog));</span>
<a href="#l3.6724"></a><span id="l3.6724">     }</span>
<a href="#l3.6725"></a><span id="l3.6725">   }</span>
<a href="#l3.6726"></a><span id="l3.6726"> }</span>
<a href="#l3.6727"></a><span id="l3.6727"> </span>
<a href="#l3.6728"></a><span id="l3.6728" class="difflineminus">-// In 4.5, this posted an event back to libmsg and blocked until it got a response.</span>
<a href="#l3.6729"></a><span id="l3.6729" class="difflineminus">-// We may still have to do this.It would be nice if we could preflight this value,</span>
<a href="#l3.6730"></a><span id="l3.6730" class="difflineminus">-// but we may not always know when we'll need it.</span>
<a href="#l3.6731"></a><span id="l3.6731" class="difflineminus">-uint32_t nsImapProtocol::GetMessageSize(const char * messageId, bool idsAreUids)</span>
<a href="#l3.6732"></a><span id="l3.6732" class="difflineminus">-{</span>
<a href="#l3.6733"></a><span id="l3.6733" class="difflineminus">-  const char *folderFromParser = GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.6734"></a><span id="l3.6734" class="difflineplus">+// In 4.5, this posted an event back to libmsg and blocked until it got a</span>
<a href="#l3.6735"></a><span id="l3.6735" class="difflineplus">+// response. We may still have to do this.It would be nice if we could preflight</span>
<a href="#l3.6736"></a><span id="l3.6736" class="difflineplus">+// this value, but we may not always know when we'll need it.</span>
<a href="#l3.6737"></a><span id="l3.6737" class="difflineplus">+uint32_t nsImapProtocol::GetMessageSize(const char *messageId,</span>
<a href="#l3.6738"></a><span id="l3.6738" class="difflineplus">+                                        bool idsAreUids) {</span>
<a href="#l3.6739"></a><span id="l3.6739" class="difflineplus">+  const char *folderFromParser =</span>
<a href="#l3.6740"></a><span id="l3.6740" class="difflineplus">+      GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.6741"></a><span id="l3.6741">   if (!folderFromParser || !messageId || !m_runningUrl || !m_hostSessionList)</span>
<a href="#l3.6742"></a><span id="l3.6742">     return 0;</span>
<a href="#l3.6743"></a><span id="l3.6743"> </span>
<a href="#l3.6744"></a><span id="l3.6744">   char *folderName = nullptr;</span>
<a href="#l3.6745"></a><span id="l3.6745">   uint32_t size;</span>
<a href="#l3.6746"></a><span id="l3.6746"> </span>
<a href="#l3.6747"></a><span id="l3.6747">   nsIMAPNamespace *nsForMailbox = nullptr;</span>
<a href="#l3.6748"></a><span id="l3.6748" class="difflineminus">-  m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.6749"></a><span id="l3.6749" class="difflineminus">-                                                   folderFromParser,</span>
<a href="#l3.6750"></a><span id="l3.6750" class="difflineminus">-                                                   nsForMailbox);</span>
<a href="#l3.6751"></a><span id="l3.6751" class="difflineplus">+  m_hostSessionList-&gt;GetNamespaceForMailboxForHost(</span>
<a href="#l3.6752"></a><span id="l3.6752" class="difflineplus">+      GetImapServerKey(), folderFromParser, nsForMailbox);</span>
<a href="#l3.6753"></a><span id="l3.6753"> </span>
<a href="#l3.6754"></a><span id="l3.6754">   m_runningUrl-&gt;AllocateCanonicalPath(folderFromParser,</span>
<a href="#l3.6755"></a><span id="l3.6755">                                       nsForMailbox</span>
<a href="#l3.6756"></a><span id="l3.6756" class="difflineminus">-                                        ? nsForMailbox-&gt;GetDelimiter()</span>
<a href="#l3.6757"></a><span id="l3.6757" class="difflineminus">-                                        : kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.6758"></a><span id="l3.6758" class="difflineplus">+                                          ? nsForMailbox-&gt;GetDelimiter()</span>
<a href="#l3.6759"></a><span id="l3.6759" class="difflineplus">+                                          : kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.6760"></a><span id="l3.6760">                                       &amp;folderName);</span>
<a href="#l3.6761"></a><span id="l3.6761"> </span>
<a href="#l3.6762"></a><span id="l3.6762">   if (folderName &amp;&amp; m_imapMessageSink)</span>
<a href="#l3.6763"></a><span id="l3.6763">     m_imapMessageSink-&gt;GetMessageSizeFromDB(messageId, &amp;size);</span>
<a href="#l3.6764"></a><span id="l3.6764"> </span>
<a href="#l3.6765"></a><span id="l3.6765">   PR_FREEIF(folderName);</span>
<a href="#l3.6766"></a><span id="l3.6766"> </span>
<a href="#l3.6767"></a><span id="l3.6767" class="difflineminus">-  if (DeathSignalReceived())</span>
<a href="#l3.6768"></a><span id="l3.6768" class="difflineminus">-    size = 0;</span>
<a href="#l3.6769"></a><span id="l3.6769" class="difflineplus">+  if (DeathSignalReceived()) size = 0;</span>
<a href="#l3.6770"></a><span id="l3.6770"> </span>
<a href="#l3.6771"></a><span id="l3.6771">   return size;</span>
<a href="#l3.6772"></a><span id="l3.6772"> }</span>
<a href="#l3.6773"></a><span id="l3.6773"> </span>
<a href="#l3.6774"></a><span id="l3.6774"> // message id string utility functions</span>
<a href="#l3.6775"></a><span id="l3.6775" class="difflineminus">-/* static */bool nsImapProtocol::HandlingMultipleMessages(const nsCString &amp; messageIdString)</span>
<a href="#l3.6776"></a><span id="l3.6776" class="difflineminus">-{</span>
<a href="#l3.6777"></a><span id="l3.6777" class="difflineplus">+/* static */ bool nsImapProtocol::HandlingMultipleMessages(</span>
<a href="#l3.6778"></a><span id="l3.6778" class="difflineplus">+    const nsCString &amp;messageIdString) {</span>
<a href="#l3.6779"></a><span id="l3.6779">   return (MsgFindCharInSet(messageIdString, &quot;,:&quot;) != kNotFound);</span>
<a href="#l3.6780"></a><span id="l3.6780"> }</span>
<a href="#l3.6781"></a><span id="l3.6781"> </span>
<a href="#l3.6782"></a><span id="l3.6782" class="difflineminus">-uint32_t nsImapProtocol::CountMessagesInIdString(const char *idString)</span>
<a href="#l3.6783"></a><span id="l3.6783" class="difflineminus">-{</span>
<a href="#l3.6784"></a><span id="l3.6784" class="difflineplus">+uint32_t nsImapProtocol::CountMessagesInIdString(const char *idString) {</span>
<a href="#l3.6785"></a><span id="l3.6785">   uint32_t numberOfMessages = 0;</span>
<a href="#l3.6786"></a><span id="l3.6786">   char *uidString = PL_strdup(idString);</span>
<a href="#l3.6787"></a><span id="l3.6787"> </span>
<a href="#l3.6788"></a><span id="l3.6788" class="difflineminus">-  if (uidString)</span>
<a href="#l3.6789"></a><span id="l3.6789" class="difflineminus">-  {</span>
<a href="#l3.6790"></a><span id="l3.6790" class="difflineplus">+  if (uidString) {</span>
<a href="#l3.6791"></a><span id="l3.6791">     // This is in the form &lt;id&gt;,&lt;id&gt;, or &lt;id1&gt;:&lt;id2&gt;</span>
<a href="#l3.6792"></a><span id="l3.6792">     char curChar = *uidString;</span>
<a href="#l3.6793"></a><span id="l3.6793">     bool isRange = false;</span>
<a href="#l3.6794"></a><span id="l3.6794">     int32_t curToken;</span>
<a href="#l3.6795"></a><span id="l3.6795" class="difflineminus">-    int32_t saveStartToken=0;</span>
<a href="#l3.6796"></a><span id="l3.6796" class="difflineminus">-</span>
<a href="#l3.6797"></a><span id="l3.6797" class="difflineminus">-    for (char *curCharPtr = uidString; curChar &amp;&amp; *curCharPtr;)</span>
<a href="#l3.6798"></a><span id="l3.6798" class="difflineminus">-    {</span>
<a href="#l3.6799"></a><span id="l3.6799" class="difflineplus">+    int32_t saveStartToken = 0;</span>
<a href="#l3.6800"></a><span id="l3.6800" class="difflineplus">+</span>
<a href="#l3.6801"></a><span id="l3.6801" class="difflineplus">+    for (char *curCharPtr = uidString; curChar &amp;&amp; *curCharPtr;) {</span>
<a href="#l3.6802"></a><span id="l3.6802">       char *currentKeyToken = curCharPtr;</span>
<a href="#l3.6803"></a><span id="l3.6803">       curChar = *curCharPtr;</span>
<a href="#l3.6804"></a><span id="l3.6804">       while (curChar != ':' &amp;&amp; curChar != ',' &amp;&amp; curChar != '\0')</span>
<a href="#l3.6805"></a><span id="l3.6805">         curChar = *curCharPtr++;</span>
<a href="#l3.6806"></a><span id="l3.6806">       *(curCharPtr - 1) = '\0';</span>
<a href="#l3.6807"></a><span id="l3.6807">       curToken = atol(currentKeyToken);</span>
<a href="#l3.6808"></a><span id="l3.6808" class="difflineminus">-      if (isRange)</span>
<a href="#l3.6809"></a><span id="l3.6809" class="difflineminus">-      {</span>
<a href="#l3.6810"></a><span id="l3.6810" class="difflineminus">-        while (saveStartToken &lt; curToken)</span>
<a href="#l3.6811"></a><span id="l3.6811" class="difflineminus">-        {</span>
<a href="#l3.6812"></a><span id="l3.6812" class="difflineplus">+      if (isRange) {</span>
<a href="#l3.6813"></a><span id="l3.6813" class="difflineplus">+        while (saveStartToken &lt; curToken) {</span>
<a href="#l3.6814"></a><span id="l3.6814">           numberOfMessages++;</span>
<a href="#l3.6815"></a><span id="l3.6815">           saveStartToken++;</span>
<a href="#l3.6816"></a><span id="l3.6816">         }</span>
<a href="#l3.6817"></a><span id="l3.6817">       }</span>
<a href="#l3.6818"></a><span id="l3.6818"> </span>
<a href="#l3.6819"></a><span id="l3.6819">       numberOfMessages++;</span>
<a href="#l3.6820"></a><span id="l3.6820">       isRange = (curChar == ':');</span>
<a href="#l3.6821"></a><span id="l3.6821" class="difflineminus">-      if (isRange)</span>
<a href="#l3.6822"></a><span id="l3.6822" class="difflineminus">-        saveStartToken = curToken + 1;</span>
<a href="#l3.6823"></a><span id="l3.6823" class="difflineplus">+      if (isRange) saveStartToken = curToken + 1;</span>
<a href="#l3.6824"></a><span id="l3.6824">     }</span>
<a href="#l3.6825"></a><span id="l3.6825">     PR_Free(uidString);</span>
<a href="#l3.6826"></a><span id="l3.6826">   }</span>
<a href="#l3.6827"></a><span id="l3.6827">   return numberOfMessages;</span>
<a href="#l3.6828"></a><span id="l3.6828"> }</span>
<a href="#l3.6829"></a><span id="l3.6829"> </span>
<a href="#l3.6830"></a><span id="l3.6830" class="difflineminus">-</span>
<a href="#l3.6831"></a><span id="l3.6831" class="difflineminus">-// It would be really nice not to have to use this method nearly as much as we did</span>
<a href="#l3.6832"></a><span id="l3.6832" class="difflineminus">-// in 4.5 - we need to think about this some. Some of it may just go away in the new world order</span>
<a href="#l3.6833"></a><span id="l3.6833" class="difflineminus">-bool nsImapProtocol::DeathSignalReceived()</span>
<a href="#l3.6834"></a><span id="l3.6834" class="difflineminus">-{</span>
<a href="#l3.6835"></a><span id="l3.6835" class="difflineplus">+// It would be really nice not to have to use this method nearly as much as we</span>
<a href="#l3.6836"></a><span id="l3.6836" class="difflineplus">+// did in 4.5 - we need to think about this some. Some of it may just go away in</span>
<a href="#l3.6837"></a><span id="l3.6837" class="difflineplus">+// the new world order</span>
<a href="#l3.6838"></a><span id="l3.6838" class="difflineplus">+bool nsImapProtocol::DeathSignalReceived() {</span>
<a href="#l3.6839"></a><span id="l3.6839">   // ignore mock channel status if we've been pseudo interrupted</span>
<a href="#l3.6840"></a><span id="l3.6840">   // ### need to make sure we clear pseudo interrupted status appropriately.</span>
<a href="#l3.6841"></a><span id="l3.6841" class="difflineminus">-  if (!GetPseudoInterrupted() &amp;&amp; m_mockChannel)</span>
<a href="#l3.6842"></a><span id="l3.6842" class="difflineminus">-  {</span>
<a href="#l3.6843"></a><span id="l3.6843" class="difflineplus">+  if (!GetPseudoInterrupted() &amp;&amp; m_mockChannel) {</span>
<a href="#l3.6844"></a><span id="l3.6844">     nsresult returnValue;</span>
<a href="#l3.6845"></a><span id="l3.6845">     m_mockChannel-&gt;GetStatus(&amp;returnValue);</span>
<a href="#l3.6846"></a><span id="l3.6846" class="difflineminus">-    if (NS_FAILED(returnValue))</span>
<a href="#l3.6847"></a><span id="l3.6847" class="difflineminus">-      return false;</span>
<a href="#l3.6848"></a><span id="l3.6848" class="difflineplus">+    if (NS_FAILED(returnValue)) return false;</span>
<a href="#l3.6849"></a><span id="l3.6849">   }</span>
<a href="#l3.6850"></a><span id="l3.6850"> </span>
<a href="#l3.6851"></a><span id="l3.6851">   // Check the other way of cancelling.</span>
<a href="#l3.6852"></a><span id="l3.6852">   ReentrantMonitorAutoEnter threadDeathMon(m_threadDeathMonitor);</span>
<a href="#l3.6853"></a><span id="l3.6853">   return m_threadShouldDie;</span>
<a href="#l3.6854"></a><span id="l3.6854"> }</span>
<a href="#l3.6855"></a><span id="l3.6855"> </span>
<a href="#l3.6856"></a><span id="l3.6856" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::ResetToAuthenticatedState()</span>
<a href="#l3.6857"></a><span id="l3.6857" class="difflineminus">-{</span>
<a href="#l3.6858"></a><span id="l3.6858" class="difflineminus">-    GetServerStateParser().PreauthSetAuthenticatedState();</span>
<a href="#l3.6859"></a><span id="l3.6859" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.6860"></a><span id="l3.6860" class="difflineminus">-}</span>
<a href="#l3.6861"></a><span id="l3.6861" class="difflineminus">-</span>
<a href="#l3.6862"></a><span id="l3.6862" class="difflineminus">-</span>
<a href="#l3.6863"></a><span id="l3.6863" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::GetSelectedMailboxName(char ** folderName)</span>
<a href="#l3.6864"></a><span id="l3.6864" class="difflineminus">-{</span>
<a href="#l3.6865"></a><span id="l3.6865" class="difflineminus">-    if (!folderName) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.6866"></a><span id="l3.6866" class="difflineminus">-    if (GetServerStateParser().GetSelectedMailboxName())</span>
<a href="#l3.6867"></a><span id="l3.6867" class="difflineminus">-        *folderName =</span>
<a href="#l3.6868"></a><span id="l3.6868" class="difflineminus">-            PL_strdup((GetServerStateParser().GetSelectedMailboxName()));</span>
<a href="#l3.6869"></a><span id="l3.6869" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.6870"></a><span id="l3.6870" class="difflineminus">-}</span>
<a href="#l3.6871"></a><span id="l3.6871" class="difflineminus">-</span>
<a href="#l3.6872"></a><span id="l3.6872" class="difflineminus">-bool nsImapProtocol::GetPseudoInterrupted()</span>
<a href="#l3.6873"></a><span id="l3.6873" class="difflineminus">-{</span>
<a href="#l3.6874"></a><span id="l3.6874" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::ResetToAuthenticatedState() {</span>
<a href="#l3.6875"></a><span id="l3.6875" class="difflineplus">+  GetServerStateParser().PreauthSetAuthenticatedState();</span>
<a href="#l3.6876"></a><span id="l3.6876" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.6877"></a><span id="l3.6877" class="difflineplus">+}</span>
<a href="#l3.6878"></a><span id="l3.6878" class="difflineplus">+</span>
<a href="#l3.6879"></a><span id="l3.6879" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::GetSelectedMailboxName(char **folderName) {</span>
<a href="#l3.6880"></a><span id="l3.6880" class="difflineplus">+  if (!folderName) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.6881"></a><span id="l3.6881" class="difflineplus">+  if (GetServerStateParser().GetSelectedMailboxName())</span>
<a href="#l3.6882"></a><span id="l3.6882" class="difflineplus">+    *folderName = PL_strdup((GetServerStateParser().GetSelectedMailboxName()));</span>
<a href="#l3.6883"></a><span id="l3.6883" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.6884"></a><span id="l3.6884" class="difflineplus">+}</span>
<a href="#l3.6885"></a><span id="l3.6885" class="difflineplus">+</span>
<a href="#l3.6886"></a><span id="l3.6886" class="difflineplus">+bool nsImapProtocol::GetPseudoInterrupted() {</span>
<a href="#l3.6887"></a><span id="l3.6887">   ReentrantMonitorAutoEnter pseudoInterruptMon(m_pseudoInterruptMonitor);</span>
<a href="#l3.6888"></a><span id="l3.6888">   return m_pseudoInterrupted;</span>
<a href="#l3.6889"></a><span id="l3.6889"> }</span>
<a href="#l3.6890"></a><span id="l3.6890"> </span>
<a href="#l3.6891"></a><span id="l3.6891" class="difflineminus">-void nsImapProtocol::PseudoInterrupt(bool the_interrupt)</span>
<a href="#l3.6892"></a><span id="l3.6892" class="difflineminus">-{</span>
<a href="#l3.6893"></a><span id="l3.6893" class="difflineplus">+void nsImapProtocol::PseudoInterrupt(bool the_interrupt) {</span>
<a href="#l3.6894"></a><span id="l3.6894">   ReentrantMonitorAutoEnter pseudoInterruptMon(m_pseudoInterruptMonitor);</span>
<a href="#l3.6895"></a><span id="l3.6895">   m_pseudoInterrupted = the_interrupt;</span>
<a href="#l3.6896"></a><span id="l3.6896" class="difflineminus">-  if (the_interrupt)</span>
<a href="#l3.6897"></a><span id="l3.6897" class="difflineminus">-    Log(&quot;CONTROL&quot;, NULL, &quot;PSEUDO-Interrupted&quot;);</span>
<a href="#l3.6898"></a><span id="l3.6898" class="difflineminus">-}</span>
<a href="#l3.6899"></a><span id="l3.6899" class="difflineminus">-</span>
<a href="#l3.6900"></a><span id="l3.6900" class="difflineminus">-void  nsImapProtocol::SetActive(bool active)</span>
<a href="#l3.6901"></a><span id="l3.6901" class="difflineminus">-{</span>
<a href="#l3.6902"></a><span id="l3.6902" class="difflineplus">+  if (the_interrupt) Log(&quot;CONTROL&quot;, NULL, &quot;PSEUDO-Interrupted&quot;);</span>
<a href="#l3.6903"></a><span id="l3.6903" class="difflineplus">+}</span>
<a href="#l3.6904"></a><span id="l3.6904" class="difflineplus">+</span>
<a href="#l3.6905"></a><span id="l3.6905" class="difflineplus">+void nsImapProtocol::SetActive(bool active) {</span>
<a href="#l3.6906"></a><span id="l3.6906">   ReentrantMonitorAutoEnter dataMemberMon(m_dataMemberMonitor);</span>
<a href="#l3.6907"></a><span id="l3.6907">   m_active = active;</span>
<a href="#l3.6908"></a><span id="l3.6908"> }</span>
<a href="#l3.6909"></a><span id="l3.6909"> </span>
<a href="#l3.6910"></a><span id="l3.6910" class="difflineminus">-bool    nsImapProtocol::GetActive()</span>
<a href="#l3.6911"></a><span id="l3.6911" class="difflineminus">-{</span>
<a href="#l3.6912"></a><span id="l3.6912" class="difflineplus">+bool nsImapProtocol::GetActive() {</span>
<a href="#l3.6913"></a><span id="l3.6913">   ReentrantMonitorAutoEnter dataMemberMon(m_dataMemberMonitor);</span>
<a href="#l3.6914"></a><span id="l3.6914">   return m_active;</span>
<a href="#l3.6915"></a><span id="l3.6915"> }</span>
<a href="#l3.6916"></a><span id="l3.6916"> </span>
<a href="#l3.6917"></a><span id="l3.6917" class="difflineminus">-bool nsImapProtocol::GetShowAttachmentsInline()</span>
<a href="#l3.6918"></a><span id="l3.6918" class="difflineminus">-{</span>
<a href="#l3.6919"></a><span id="l3.6919" class="difflineplus">+bool nsImapProtocol::GetShowAttachmentsInline() {</span>
<a href="#l3.6920"></a><span id="l3.6920">   bool showAttachmentsInline = true;</span>
<a href="#l3.6921"></a><span id="l3.6921">   if (m_imapServerSink)</span>
<a href="#l3.6922"></a><span id="l3.6922">     m_imapServerSink-&gt;GetShowAttachmentsInline(&amp;showAttachmentsInline);</span>
<a href="#l3.6923"></a><span id="l3.6923">   return showAttachmentsInline;</span>
<a href="#l3.6924"></a><span id="l3.6924" class="difflineminus">-</span>
<a href="#l3.6925"></a><span id="l3.6925" class="difflineminus">-}</span>
<a href="#l3.6926"></a><span id="l3.6926" class="difflineminus">-</span>
<a href="#l3.6927"></a><span id="l3.6927" class="difflineminus">-void nsImapProtocol::SetContentModified(IMAP_ContentModifiedType modified)</span>
<a href="#l3.6928"></a><span id="l3.6928" class="difflineminus">-{</span>
<a href="#l3.6929"></a><span id="l3.6929" class="difflineplus">+}</span>
<a href="#l3.6930"></a><span id="l3.6930" class="difflineplus">+</span>
<a href="#l3.6931"></a><span id="l3.6931" class="difflineplus">+void nsImapProtocol::SetContentModified(IMAP_ContentModifiedType modified) {</span>
<a href="#l3.6932"></a><span id="l3.6932">   if (m_runningUrl &amp;&amp; m_imapMessageSink)</span>
<a href="#l3.6933"></a><span id="l3.6933">     m_imapMessageSink-&gt;SetContentModified(m_runningUrl, modified);</span>
<a href="#l3.6934"></a><span id="l3.6934"> }</span>
<a href="#l3.6935"></a><span id="l3.6935"> </span>
<a href="#l3.6936"></a><span id="l3.6936" class="difflineminus">-</span>
<a href="#l3.6937"></a><span id="l3.6937" class="difflineminus">-bool nsImapProtocol::GetShouldFetchAllParts()</span>
<a href="#l3.6938"></a><span id="l3.6938" class="difflineminus">-{</span>
<a href="#l3.6939"></a><span id="l3.6939" class="difflineminus">-  if (m_runningUrl  &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.6940"></a><span id="l3.6940" class="difflineminus">-  {</span>
<a href="#l3.6941"></a><span id="l3.6941" class="difflineplus">+bool nsImapProtocol::GetShouldFetchAllParts() {</span>
<a href="#l3.6942"></a><span id="l3.6942" class="difflineplus">+  if (m_runningUrl &amp;&amp; !DeathSignalReceived()) {</span>
<a href="#l3.6943"></a><span id="l3.6943">     nsImapContentModifiedType contentModified;</span>
<a href="#l3.6944"></a><span id="l3.6944">     if (NS_SUCCEEDED(m_runningUrl-&gt;GetContentModified(&amp;contentModified)))</span>
<a href="#l3.6945"></a><span id="l3.6945">       return (contentModified == IMAP_CONTENT_FORCE_CONTENT_NOT_MODIFIED);</span>
<a href="#l3.6946"></a><span id="l3.6946">   }</span>
<a href="#l3.6947"></a><span id="l3.6947">   return true;</span>
<a href="#l3.6948"></a><span id="l3.6948"> }</span>
<a href="#l3.6949"></a><span id="l3.6949"> </span>
<a href="#l3.6950"></a><span id="l3.6950"> // Adds a set of rights for a given user on a given mailbox on the current host.</span>
<a href="#l3.6951"></a><span id="l3.6951"> // if userName is NULL, it means &quot;me,&quot; or MYRIGHTS.</span>
<a href="#l3.6952"></a><span id="l3.6952" class="difflineminus">-void nsImapProtocol::AddFolderRightsForUser(const char *mailboxName, const char *userName, const char *rights)</span>
<a href="#l3.6953"></a><span id="l3.6953" class="difflineminus">-{</span>
<a href="#l3.6954"></a><span id="l3.6954" class="difflineminus">-  if (!userName)</span>
<a href="#l3.6955"></a><span id="l3.6955" class="difflineminus">-    userName = &quot;&quot;;</span>
<a href="#l3.6956"></a><span id="l3.6956" class="difflineplus">+void nsImapProtocol::AddFolderRightsForUser(const char *mailboxName,</span>
<a href="#l3.6957"></a><span id="l3.6957" class="difflineplus">+                                            const char *userName,</span>
<a href="#l3.6958"></a><span id="l3.6958" class="difflineplus">+                                            const char *rights) {</span>
<a href="#l3.6959"></a><span id="l3.6959" class="difflineplus">+  if (!userName) userName = &quot;&quot;;</span>
<a href="#l3.6960"></a><span id="l3.6960">   if (m_imapServerSink)</span>
<a href="#l3.6961"></a><span id="l3.6961" class="difflineminus">-    m_imapServerSink-&gt;AddFolderRights(nsDependentCString(mailboxName), nsDependentCString(userName),</span>
<a href="#l3.6962"></a><span id="l3.6962" class="difflineplus">+    m_imapServerSink-&gt;AddFolderRights(nsDependentCString(mailboxName),</span>
<a href="#l3.6963"></a><span id="l3.6963" class="difflineplus">+                                      nsDependentCString(userName),</span>
<a href="#l3.6964"></a><span id="l3.6964">                                       nsDependentCString(rights));</span>
<a href="#l3.6965"></a><span id="l3.6965"> }</span>
<a href="#l3.6966"></a><span id="l3.6966"> </span>
<a href="#l3.6967"></a><span id="l3.6967" class="difflineminus">-void nsImapProtocol::SetCopyResponseUid(const char *msgIdString)</span>
<a href="#l3.6968"></a><span id="l3.6968" class="difflineminus">-{</span>
<a href="#l3.6969"></a><span id="l3.6969" class="difflineplus">+void nsImapProtocol::SetCopyResponseUid(const char *msgIdString) {</span>
<a href="#l3.6970"></a><span id="l3.6970">   if (m_imapMailFolderSink)</span>
<a href="#l3.6971"></a><span id="l3.6971">     m_imapMailFolderSink-&gt;SetCopyResponseUid(msgIdString, m_runningUrl);</span>
<a href="#l3.6972"></a><span id="l3.6972"> }</span>
<a href="#l3.6973"></a><span id="l3.6973"> </span>
<a href="#l3.6974"></a><span id="l3.6974" class="difflineminus">-void nsImapProtocol::CommitNamespacesForHostEvent()</span>
<a href="#l3.6975"></a><span id="l3.6975" class="difflineminus">-{</span>
<a href="#l3.6976"></a><span id="l3.6976" class="difflineminus">-    if (m_imapServerSink)</span>
<a href="#l3.6977"></a><span id="l3.6977" class="difflineminus">-        m_imapServerSink-&gt;CommitNamespaces();</span>
<a href="#l3.6978"></a><span id="l3.6978" class="difflineplus">+void nsImapProtocol::CommitNamespacesForHostEvent() {</span>
<a href="#l3.6979"></a><span id="l3.6979" class="difflineplus">+  if (m_imapServerSink) m_imapServerSink-&gt;CommitNamespaces();</span>
<a href="#l3.6980"></a><span id="l3.6980"> }</span>
<a href="#l3.6981"></a><span id="l3.6981"> </span>
<a href="#l3.6982"></a><span id="l3.6982"> // notifies libmsg that we have new capability data for the current host</span>
<a href="#l3.6983"></a><span id="l3.6983" class="difflineminus">-void nsImapProtocol::CommitCapability()</span>
<a href="#l3.6984"></a><span id="l3.6984" class="difflineminus">-{</span>
<a href="#l3.6985"></a><span id="l3.6985" class="difflineminus">-    if (m_imapServerSink)</span>
<a href="#l3.6986"></a><span id="l3.6986" class="difflineminus">-    {</span>
<a href="#l3.6987"></a><span id="l3.6987" class="difflineminus">-        m_imapServerSink-&gt;SetCapability(GetServerStateParser().GetCapabilityFlag());</span>
<a href="#l3.6988"></a><span id="l3.6988" class="difflineminus">-    }</span>
<a href="#l3.6989"></a><span id="l3.6989" class="difflineminus">-}</span>
<a href="#l3.6990"></a><span id="l3.6990" class="difflineminus">-</span>
<a href="#l3.6991"></a><span id="l3.6991" class="difflineminus">-// rights is a single string of rights, as specified by RFC2086, the IMAP ACL extension.</span>
<a href="#l3.6992"></a><span id="l3.6992" class="difflineminus">-// Clears all rights for a given folder, for all users.</span>
<a href="#l3.6993"></a><span id="l3.6993" class="difflineminus">-void nsImapProtocol::ClearAllFolderRights()</span>
<a href="#l3.6994"></a><span id="l3.6994" class="difflineminus">-{</span>
<a href="#l3.6995"></a><span id="l3.6995" class="difflineminus">-  if (m_imapMailFolderSink)</span>
<a href="#l3.6996"></a><span id="l3.6996" class="difflineminus">-    m_imapMailFolderSink-&gt;ClearFolderRights();</span>
<a href="#l3.6997"></a><span id="l3.6997" class="difflineminus">-}</span>
<a href="#l3.6998"></a><span id="l3.6998" class="difflineminus">-</span>
<a href="#l3.6999"></a><span id="l3.6999" class="difflineminus">-</span>
<a href="#l3.7000"></a><span id="l3.7000" class="difflineminus">-char* nsImapProtocol::CreateNewLineFromSocket()</span>
<a href="#l3.7001"></a><span id="l3.7001" class="difflineminus">-{</span>
<a href="#l3.7002"></a><span id="l3.7002" class="difflineplus">+void nsImapProtocol::CommitCapability() {</span>
<a href="#l3.7003"></a><span id="l3.7003" class="difflineplus">+  if (m_imapServerSink) {</span>
<a href="#l3.7004"></a><span id="l3.7004" class="difflineplus">+    m_imapServerSink-&gt;SetCapability(GetServerStateParser().GetCapabilityFlag());</span>
<a href="#l3.7005"></a><span id="l3.7005" class="difflineplus">+  }</span>
<a href="#l3.7006"></a><span id="l3.7006" class="difflineplus">+}</span>
<a href="#l3.7007"></a><span id="l3.7007" class="difflineplus">+</span>
<a href="#l3.7008"></a><span id="l3.7008" class="difflineplus">+// rights is a single string of rights, as specified by RFC2086, the IMAP ACL</span>
<a href="#l3.7009"></a><span id="l3.7009" class="difflineplus">+// extension. Clears all rights for a given folder, for all users.</span>
<a href="#l3.7010"></a><span id="l3.7010" class="difflineplus">+void nsImapProtocol::ClearAllFolderRights() {</span>
<a href="#l3.7011"></a><span id="l3.7011" class="difflineplus">+  if (m_imapMailFolderSink) m_imapMailFolderSink-&gt;ClearFolderRights();</span>
<a href="#l3.7012"></a><span id="l3.7012" class="difflineplus">+}</span>
<a href="#l3.7013"></a><span id="l3.7013" class="difflineplus">+</span>
<a href="#l3.7014"></a><span id="l3.7014" class="difflineplus">+char *nsImapProtocol::CreateNewLineFromSocket() {</span>
<a href="#l3.7015"></a><span id="l3.7015">   bool needMoreData = false;</span>
<a href="#l3.7016"></a><span id="l3.7016" class="difflineminus">-  char * newLine = nullptr;</span>
<a href="#l3.7017"></a><span id="l3.7017" class="difflineplus">+  char *newLine = nullptr;</span>
<a href="#l3.7018"></a><span id="l3.7018">   uint32_t numBytesInLine = 0;</span>
<a href="#l3.7019"></a><span id="l3.7019">   nsresult rv = NS_OK;</span>
<a href="#l3.7020"></a><span id="l3.7020">   // we hold a ref to the input stream in case we get cancelled from the</span>
<a href="#l3.7021"></a><span id="l3.7021">   // ui thread, which releases our ref to the input stream, and can</span>
<a href="#l3.7022"></a><span id="l3.7022">   // cause the pipe to get deleted before the monitor the read is</span>
<a href="#l3.7023"></a><span id="l3.7023">   // blocked on gets notified. When that happens, the imap thread</span>
<a href="#l3.7024"></a><span id="l3.7024">   // will stay blocked.</span>
<a href="#l3.7025"></a><span id="l3.7025" class="difflineminus">-  nsCOMPtr &lt;nsIInputStream&gt; kungFuGrip = m_inputStream;</span>
<a href="#l3.7026"></a><span id="l3.7026" class="difflineminus">-  do</span>
<a href="#l3.7027"></a><span id="l3.7027" class="difflineminus">-  {</span>
<a href="#l3.7028"></a><span id="l3.7028" class="difflineminus">-    newLine = m_inputStreamBuffer-&gt;ReadNextLine(m_inputStream, numBytesInLine, needMoreData, &amp;rv);</span>
<a href="#l3.7029"></a><span id="l3.7029" class="difflineminus">-    MOZ_LOG(IMAP, LogLevel::Debug, (&quot;ReadNextLine [stream=%p nb=%u needmore=%u]&quot;,</span>
<a href="#l3.7030"></a><span id="l3.7030" class="difflineminus">-        m_inputStream.get(), numBytesInLine, needMoreData));</span>
<a href="#l3.7031"></a><span id="l3.7031" class="difflineminus">-</span>
<a href="#l3.7032"></a><span id="l3.7032" class="difflineminus">-  } while (!newLine &amp;&amp; NS_SUCCEEDED(rv) &amp;&amp; !DeathSignalReceived()); // until we get the next line and haven't been interrupted</span>
<a href="#l3.7033"></a><span id="l3.7033" class="difflineplus">+  nsCOMPtr&lt;nsIInputStream&gt; kungFuGrip = m_inputStream;</span>
<a href="#l3.7034"></a><span id="l3.7034" class="difflineplus">+  do {</span>
<a href="#l3.7035"></a><span id="l3.7035" class="difflineplus">+    newLine = m_inputStreamBuffer-&gt;ReadNextLine(m_inputStream, numBytesInLine,</span>
<a href="#l3.7036"></a><span id="l3.7036" class="difflineplus">+                                                needMoreData, &amp;rv);</span>
<a href="#l3.7037"></a><span id="l3.7037" class="difflineplus">+    MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.7038"></a><span id="l3.7038" class="difflineplus">+            (&quot;ReadNextLine [stream=%p nb=%u needmore=%u]&quot;, m_inputStream.get(),</span>
<a href="#l3.7039"></a><span id="l3.7039" class="difflineplus">+             numBytesInLine, needMoreData));</span>
<a href="#l3.7040"></a><span id="l3.7040" class="difflineplus">+</span>
<a href="#l3.7041"></a><span id="l3.7041" class="difflineplus">+  } while (!newLine &amp;&amp; NS_SUCCEEDED(rv) &amp;&amp;</span>
<a href="#l3.7042"></a><span id="l3.7042" class="difflineplus">+           !DeathSignalReceived());  // until we get the next line and haven't</span>
<a href="#l3.7043"></a><span id="l3.7043" class="difflineplus">+                                     // been interrupted</span>
<a href="#l3.7044"></a><span id="l3.7044"> </span>
<a href="#l3.7045"></a><span id="l3.7045">   kungFuGrip = nullptr;</span>
<a href="#l3.7046"></a><span id="l3.7046"> </span>
<a href="#l3.7047"></a><span id="l3.7047" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l3.7048"></a><span id="l3.7048" class="difflineminus">-  {</span>
<a href="#l3.7049"></a><span id="l3.7049" class="difflineminus">-    switch (rv)</span>
<a href="#l3.7050"></a><span id="l3.7050" class="difflineminus">-    {</span>
<a href="#l3.7051"></a><span id="l3.7051" class="difflineminus">-        case NS_ERROR_UNKNOWN_HOST:</span>
<a href="#l3.7052"></a><span id="l3.7052" class="difflineminus">-        case NS_ERROR_UNKNOWN_PROXY_HOST:</span>
<a href="#l3.7053"></a><span id="l3.7053" class="difflineminus">-            AlertUserEventUsingName(&quot;imapUnknownHostError&quot;);</span>
<a href="#l3.7054"></a><span id="l3.7054" class="difflineminus">-            break;</span>
<a href="#l3.7055"></a><span id="l3.7055" class="difflineminus">-        case NS_ERROR_CONNECTION_REFUSED:</span>
<a href="#l3.7056"></a><span id="l3.7056" class="difflineminus">-        case NS_ERROR_PROXY_CONNECTION_REFUSED:</span>
<a href="#l3.7057"></a><span id="l3.7057" class="difflineminus">-            AlertUserEventUsingName(&quot;imapConnectionRefusedError&quot;);</span>
<a href="#l3.7058"></a><span id="l3.7058" class="difflineplus">+  if (NS_FAILED(rv)) {</span>
<a href="#l3.7059"></a><span id="l3.7059" class="difflineplus">+    switch (rv) {</span>
<a href="#l3.7060"></a><span id="l3.7060" class="difflineplus">+      case NS_ERROR_UNKNOWN_HOST:</span>
<a href="#l3.7061"></a><span id="l3.7061" class="difflineplus">+      case NS_ERROR_UNKNOWN_PROXY_HOST:</span>
<a href="#l3.7062"></a><span id="l3.7062" class="difflineplus">+        AlertUserEventUsingName(&quot;imapUnknownHostError&quot;);</span>
<a href="#l3.7063"></a><span id="l3.7063" class="difflineplus">+        break;</span>
<a href="#l3.7064"></a><span id="l3.7064" class="difflineplus">+      case NS_ERROR_CONNECTION_REFUSED:</span>
<a href="#l3.7065"></a><span id="l3.7065" class="difflineplus">+      case NS_ERROR_PROXY_CONNECTION_REFUSED:</span>
<a href="#l3.7066"></a><span id="l3.7066" class="difflineplus">+        AlertUserEventUsingName(&quot;imapConnectionRefusedError&quot;);</span>
<a href="#l3.7067"></a><span id="l3.7067" class="difflineplus">+        break;</span>
<a href="#l3.7068"></a><span id="l3.7068" class="difflineplus">+      case NS_ERROR_NET_TIMEOUT:</span>
<a href="#l3.7069"></a><span id="l3.7069" class="difflineplus">+      case NS_ERROR_NET_RESET:</span>
<a href="#l3.7070"></a><span id="l3.7070" class="difflineplus">+      case NS_BASE_STREAM_CLOSED:</span>
<a href="#l3.7071"></a><span id="l3.7071" class="difflineplus">+      case NS_ERROR_NET_INTERRUPT:</span>
<a href="#l3.7072"></a><span id="l3.7072" class="difflineplus">+        // we should retry on RESET, especially for SSL...</span>
<a href="#l3.7073"></a><span id="l3.7073" class="difflineplus">+        if ((TestFlag(IMAP_RECEIVED_GREETING) || rv == NS_ERROR_NET_RESET) &amp;&amp;</span>
<a href="#l3.7074"></a><span id="l3.7074" class="difflineplus">+            m_runningUrl &amp;&amp; !m_retryUrlOnError) {</span>
<a href="#l3.7075"></a><span id="l3.7075" class="difflineplus">+          bool rerunningUrl;</span>
<a href="#l3.7076"></a><span id="l3.7076" class="difflineplus">+          nsImapAction imapAction;</span>
<a href="#l3.7077"></a><span id="l3.7077" class="difflineplus">+          m_runningUrl-&gt;GetRerunningUrl(&amp;rerunningUrl);</span>
<a href="#l3.7078"></a><span id="l3.7078" class="difflineplus">+          m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.7079"></a><span id="l3.7079" class="difflineplus">+          // don't rerun if we already were rerunning. And don't rerun</span>
<a href="#l3.7080"></a><span id="l3.7080" class="difflineplus">+          // online move/copies that timeout.</span>
<a href="#l3.7081"></a><span id="l3.7081" class="difflineplus">+          if (!rerunningUrl &amp;&amp; (rv != NS_ERROR_NET_TIMEOUT ||</span>
<a href="#l3.7082"></a><span id="l3.7082" class="difflineplus">+                                (imapAction != nsIImapUrl::nsImapOnlineCopy &amp;&amp;</span>
<a href="#l3.7083"></a><span id="l3.7083" class="difflineplus">+                                 imapAction != nsIImapUrl::nsImapOnlineMove))) {</span>
<a href="#l3.7084"></a><span id="l3.7084" class="difflineplus">+            m_runningUrl-&gt;SetRerunningUrl(true);</span>
<a href="#l3.7085"></a><span id="l3.7085" class="difflineplus">+            m_retryUrlOnError = true;</span>
<a href="#l3.7086"></a><span id="l3.7086">             break;</span>
<a href="#l3.7087"></a><span id="l3.7087" class="difflineminus">-        case NS_ERROR_NET_TIMEOUT:</span>
<a href="#l3.7088"></a><span id="l3.7088" class="difflineminus">-        case NS_ERROR_NET_RESET:</span>
<a href="#l3.7089"></a><span id="l3.7089" class="difflineminus">-        case NS_BASE_STREAM_CLOSED:</span>
<a href="#l3.7090"></a><span id="l3.7090" class="difflineminus">-        case NS_ERROR_NET_INTERRUPT:</span>
<a href="#l3.7091"></a><span id="l3.7091" class="difflineminus">-          // we should retry on RESET, especially for SSL...</span>
<a href="#l3.7092"></a><span id="l3.7092" class="difflineminus">-          if ((TestFlag(IMAP_RECEIVED_GREETING) || rv == NS_ERROR_NET_RESET) &amp;&amp;</span>
<a href="#l3.7093"></a><span id="l3.7093" class="difflineminus">-              m_runningUrl &amp;&amp; !m_retryUrlOnError)</span>
<a href="#l3.7094"></a><span id="l3.7094" class="difflineminus">-          {</span>
<a href="#l3.7095"></a><span id="l3.7095" class="difflineminus">-            bool rerunningUrl;</span>
<a href="#l3.7096"></a><span id="l3.7096" class="difflineminus">-            nsImapAction imapAction;</span>
<a href="#l3.7097"></a><span id="l3.7097" class="difflineminus">-            m_runningUrl-&gt;GetRerunningUrl(&amp;rerunningUrl);</span>
<a href="#l3.7098"></a><span id="l3.7098" class="difflineminus">-            m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.7099"></a><span id="l3.7099" class="difflineminus">-            // don't rerun if we already were rerunning. And don't rerun</span>
<a href="#l3.7100"></a><span id="l3.7100" class="difflineminus">-            // online move/copies that timeout.</span>
<a href="#l3.7101"></a><span id="l3.7101" class="difflineminus">-            if (!rerunningUrl &amp;&amp; (rv != NS_ERROR_NET_TIMEOUT ||</span>
<a href="#l3.7102"></a><span id="l3.7102" class="difflineminus">-                                 (imapAction != nsIImapUrl::nsImapOnlineCopy &amp;&amp;</span>
<a href="#l3.7103"></a><span id="l3.7103" class="difflineminus">-                                  imapAction != nsIImapUrl::nsImapOnlineMove)))</span>
<a href="#l3.7104"></a><span id="l3.7104" class="difflineminus">-            {</span>
<a href="#l3.7105"></a><span id="l3.7105" class="difflineminus">-              m_runningUrl-&gt;SetRerunningUrl(true);</span>
<a href="#l3.7106"></a><span id="l3.7106" class="difflineminus">-              m_retryUrlOnError = true;</span>
<a href="#l3.7107"></a><span id="l3.7107" class="difflineminus">-              break;</span>
<a href="#l3.7108"></a><span id="l3.7108" class="difflineminus">-            }</span>
<a href="#l3.7109"></a><span id="l3.7109">           }</span>
<a href="#l3.7110"></a><span id="l3.7110" class="difflineminus">-          if (rv == NS_ERROR_NET_TIMEOUT)</span>
<a href="#l3.7111"></a><span id="l3.7111" class="difflineminus">-            AlertUserEventUsingName(&quot;imapNetTimeoutError&quot;);</span>
<a href="#l3.7112"></a><span id="l3.7112" class="difflineminus">-          else</span>
<a href="#l3.7113"></a><span id="l3.7113" class="difflineminus">-            AlertUserEventUsingName(TestFlag(IMAP_RECEIVED_GREETING) ?</span>
<a href="#l3.7114"></a><span id="l3.7114" class="difflineminus">-                                    &quot;imapServerDisconnected&quot; :</span>
<a href="#l3.7115"></a><span id="l3.7115" class="difflineminus">-                                    &quot;imapServerDroppedConnection&quot;);</span>
<a href="#l3.7116"></a><span id="l3.7116" class="difflineminus">-          break;</span>
<a href="#l3.7117"></a><span id="l3.7117" class="difflineminus">-        default:</span>
<a href="#l3.7118"></a><span id="l3.7118" class="difflineminus">-          break;</span>
<a href="#l3.7119"></a><span id="l3.7119" class="difflineplus">+        }</span>
<a href="#l3.7120"></a><span id="l3.7120" class="difflineplus">+        if (rv == NS_ERROR_NET_TIMEOUT)</span>
<a href="#l3.7121"></a><span id="l3.7121" class="difflineplus">+          AlertUserEventUsingName(&quot;imapNetTimeoutError&quot;);</span>
<a href="#l3.7122"></a><span id="l3.7122" class="difflineplus">+        else</span>
<a href="#l3.7123"></a><span id="l3.7123" class="difflineplus">+          AlertUserEventUsingName(TestFlag(IMAP_RECEIVED_GREETING)</span>
<a href="#l3.7124"></a><span id="l3.7124" class="difflineplus">+                                      ? &quot;imapServerDisconnected&quot;</span>
<a href="#l3.7125"></a><span id="l3.7125" class="difflineplus">+                                      : &quot;imapServerDroppedConnection&quot;);</span>
<a href="#l3.7126"></a><span id="l3.7126" class="difflineplus">+        break;</span>
<a href="#l3.7127"></a><span id="l3.7127" class="difflineplus">+      default:</span>
<a href="#l3.7128"></a><span id="l3.7128" class="difflineplus">+        break;</span>
<a href="#l3.7129"></a><span id="l3.7129">     }</span>
<a href="#l3.7130"></a><span id="l3.7130"> </span>
<a href="#l3.7131"></a><span id="l3.7131">     nsAutoCString logMsg(&quot;clearing IMAP_CONNECTION_IS_OPEN - rv = &quot;);</span>
<a href="#l3.7132"></a><span id="l3.7132">     logMsg.AppendInt(static_cast&lt;uint32_t&gt;(rv), 16);</span>
<a href="#l3.7133"></a><span id="l3.7133">     Log(&quot;CreateNewLineFromSocket&quot;, nullptr, logMsg.get());</span>
<a href="#l3.7134"></a><span id="l3.7134">     ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.7135"></a><span id="l3.7135">     TellThreadToDie();</span>
<a href="#l3.7136"></a><span id="l3.7136">   }</span>
<a href="#l3.7137"></a><span id="l3.7137">   Log(&quot;CreateNewLineFromSocket&quot;, nullptr, newLine);</span>
<a href="#l3.7138"></a><span id="l3.7138" class="difflineminus">-  SetConnectionStatus(newLine &amp;&amp; numBytesInLine ? NS_OK : rv); // set &gt; 0 if string is not null or empty</span>
<a href="#l3.7139"></a><span id="l3.7139" class="difflineplus">+  SetConnectionStatus(newLine &amp;&amp; numBytesInLine</span>
<a href="#l3.7140"></a><span id="l3.7140" class="difflineplus">+                          ? NS_OK</span>
<a href="#l3.7141"></a><span id="l3.7141" class="difflineplus">+                          : rv);  // set &gt; 0 if string is not null or empty</span>
<a href="#l3.7142"></a><span id="l3.7142">   return newLine;</span>
<a href="#l3.7143"></a><span id="l3.7143"> }</span>
<a href="#l3.7144"></a><span id="l3.7144"> </span>
<a href="#l3.7145"></a><span id="l3.7145" class="difflineminus">-nsresult</span>
<a href="#l3.7146"></a><span id="l3.7146" class="difflineminus">-nsImapProtocol::GetConnectionStatus()</span>
<a href="#l3.7147"></a><span id="l3.7147" class="difflineminus">-{</span>
<a href="#l3.7148"></a><span id="l3.7148" class="difflineminus">-  return m_connectionStatus;</span>
<a href="#l3.7149"></a><span id="l3.7149" class="difflineminus">-}</span>
<a href="#l3.7150"></a><span id="l3.7150" class="difflineminus">-</span>
<a href="#l3.7151"></a><span id="l3.7151" class="difflineminus">-void</span>
<a href="#l3.7152"></a><span id="l3.7152" class="difflineminus">-nsImapProtocol::SetConnectionStatus(nsresult status)</span>
<a href="#l3.7153"></a><span id="l3.7153" class="difflineminus">-{</span>
<a href="#l3.7154"></a><span id="l3.7154" class="difflineplus">+nsresult nsImapProtocol::GetConnectionStatus() { return m_connectionStatus; }</span>
<a href="#l3.7155"></a><span id="l3.7155" class="difflineplus">+</span>
<a href="#l3.7156"></a><span id="l3.7156" class="difflineplus">+void nsImapProtocol::SetConnectionStatus(nsresult status) {</span>
<a href="#l3.7157"></a><span id="l3.7157">   m_connectionStatus = status;</span>
<a href="#l3.7158"></a><span id="l3.7158"> }</span>
<a href="#l3.7159"></a><span id="l3.7159"> </span>
<a href="#l3.7160"></a><span id="l3.7160" class="difflineminus">-void</span>
<a href="#l3.7161"></a><span id="l3.7161" class="difflineminus">-nsImapProtocol::NotifyMessageFlags(imapMessageFlagsType flags,</span>
<a href="#l3.7162"></a><span id="l3.7162" class="difflineminus">-                                   const nsACString &amp;keywords,</span>
<a href="#l3.7163"></a><span id="l3.7163" class="difflineminus">-                                   nsMsgKey key, uint64_t highestModSeq)</span>
<a href="#l3.7164"></a><span id="l3.7164" class="difflineminus">-{</span>
<a href="#l3.7165"></a><span id="l3.7165" class="difflineminus">-    if (m_imapMessageSink)</span>
<a href="#l3.7166"></a><span id="l3.7166" class="difflineminus">-    {</span>
<a href="#l3.7167"></a><span id="l3.7167" class="difflineminus">-      // if we're selecting the folder, don't need to report the flags; we've already fetched them.</span>
<a href="#l3.7168"></a><span id="l3.7168" class="difflineminus">-      if (m_imapAction != nsIImapUrl::nsImapSelectFolder &amp;&amp;</span>
<a href="#l3.7169"></a><span id="l3.7169" class="difflineminus">-          (m_imapAction != nsIImapUrl::nsImapMsgFetch ||</span>
<a href="#l3.7170"></a><span id="l3.7170" class="difflineminus">-          (flags &amp; ~kImapMsgRecentFlag) != kImapMsgSeenFlag))</span>
<a href="#l3.7171"></a><span id="l3.7171" class="difflineminus">-        m_imapMessageSink-&gt;NotifyMessageFlags(flags, keywords, key, highestModSeq);</span>
<a href="#l3.7172"></a><span id="l3.7172" class="difflineminus">-    }</span>
<a href="#l3.7173"></a><span id="l3.7173" class="difflineminus">-}</span>
<a href="#l3.7174"></a><span id="l3.7174" class="difflineminus">-</span>
<a href="#l3.7175"></a><span id="l3.7175" class="difflineminus">-void</span>
<a href="#l3.7176"></a><span id="l3.7176" class="difflineminus">-nsImapProtocol::NotifySearchHit(const char * hitLine)</span>
<a href="#l3.7177"></a><span id="l3.7177" class="difflineminus">-{</span>
<a href="#l3.7178"></a><span id="l3.7178" class="difflineminus">-    nsresult rv;</span>
<a href="#l3.7179"></a><span id="l3.7179" class="difflineminus">-    nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l3.7180"></a><span id="l3.7180" class="difflineminus">-    if (m_imapMailFolderSink)</span>
<a href="#l3.7181"></a><span id="l3.7181" class="difflineminus">-        m_imapMailFolderSink-&gt;NotifySearchHit(mailnewsUrl, hitLine);</span>
<a href="#l3.7182"></a><span id="l3.7182" class="difflineminus">-}</span>
<a href="#l3.7183"></a><span id="l3.7183" class="difflineminus">-</span>
<a href="#l3.7184"></a><span id="l3.7184" class="difflineminus">-void nsImapProtocol::SetMailboxDiscoveryStatus(EMailboxDiscoverStatus status)</span>
<a href="#l3.7185"></a><span id="l3.7185" class="difflineminus">-{</span>
<a href="#l3.7186"></a><span id="l3.7186" class="difflineplus">+void nsImapProtocol::NotifyMessageFlags(imapMessageFlagsType flags,</span>
<a href="#l3.7187"></a><span id="l3.7187" class="difflineplus">+                                        const nsACString &amp;keywords,</span>
<a href="#l3.7188"></a><span id="l3.7188" class="difflineplus">+                                        nsMsgKey key, uint64_t highestModSeq) {</span>
<a href="#l3.7189"></a><span id="l3.7189" class="difflineplus">+  if (m_imapMessageSink) {</span>
<a href="#l3.7190"></a><span id="l3.7190" class="difflineplus">+    // if we're selecting the folder, don't need to report the flags; we've</span>
<a href="#l3.7191"></a><span id="l3.7191" class="difflineplus">+    // already fetched them.</span>
<a href="#l3.7192"></a><span id="l3.7192" class="difflineplus">+    if (m_imapAction != nsIImapUrl::nsImapSelectFolder &amp;&amp;</span>
<a href="#l3.7193"></a><span id="l3.7193" class="difflineplus">+        (m_imapAction != nsIImapUrl::nsImapMsgFetch ||</span>
<a href="#l3.7194"></a><span id="l3.7194" class="difflineplus">+         (flags &amp; ~kImapMsgRecentFlag) != kImapMsgSeenFlag))</span>
<a href="#l3.7195"></a><span id="l3.7195" class="difflineplus">+      m_imapMessageSink-&gt;NotifyMessageFlags(flags, keywords, key,</span>
<a href="#l3.7196"></a><span id="l3.7196" class="difflineplus">+                                            highestModSeq);</span>
<a href="#l3.7197"></a><span id="l3.7197" class="difflineplus">+  }</span>
<a href="#l3.7198"></a><span id="l3.7198" class="difflineplus">+}</span>
<a href="#l3.7199"></a><span id="l3.7199" class="difflineplus">+</span>
<a href="#l3.7200"></a><span id="l3.7200" class="difflineplus">+void nsImapProtocol::NotifySearchHit(const char *hitLine) {</span>
<a href="#l3.7201"></a><span id="l3.7201" class="difflineplus">+  nsresult rv;</span>
<a href="#l3.7202"></a><span id="l3.7202" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl =</span>
<a href="#l3.7203"></a><span id="l3.7203" class="difflineplus">+      do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l3.7204"></a><span id="l3.7204" class="difflineplus">+  if (m_imapMailFolderSink)</span>
<a href="#l3.7205"></a><span id="l3.7205" class="difflineplus">+    m_imapMailFolderSink-&gt;NotifySearchHit(mailnewsUrl, hitLine);</span>
<a href="#l3.7206"></a><span id="l3.7206" class="difflineplus">+}</span>
<a href="#l3.7207"></a><span id="l3.7207" class="difflineplus">+</span>
<a href="#l3.7208"></a><span id="l3.7208" class="difflineplus">+void nsImapProtocol::SetMailboxDiscoveryStatus(EMailboxDiscoverStatus status) {</span>
<a href="#l3.7209"></a><span id="l3.7209">   ReentrantMonitorAutoEnter mon(m_dataMemberMonitor);</span>
<a href="#l3.7210"></a><span id="l3.7210">   m_discoveryStatus = status;</span>
<a href="#l3.7211"></a><span id="l3.7211"> }</span>
<a href="#l3.7212"></a><span id="l3.7212"> </span>
<a href="#l3.7213"></a><span id="l3.7213" class="difflineminus">-EMailboxDiscoverStatus nsImapProtocol::GetMailboxDiscoveryStatus( )</span>
<a href="#l3.7214"></a><span id="l3.7214" class="difflineminus">-{</span>
<a href="#l3.7215"></a><span id="l3.7215" class="difflineplus">+EMailboxDiscoverStatus nsImapProtocol::GetMailboxDiscoveryStatus() {</span>
<a href="#l3.7216"></a><span id="l3.7216">   ReentrantMonitorAutoEnter mon(m_dataMemberMonitor);</span>
<a href="#l3.7217"></a><span id="l3.7217">   return m_discoveryStatus;</span>
<a href="#l3.7218"></a><span id="l3.7218"> }</span>
<a href="#l3.7219"></a><span id="l3.7219"> </span>
<a href="#l3.7220"></a><span id="l3.7220" class="difflineminus">-bool</span>
<a href="#l3.7221"></a><span id="l3.7221" class="difflineminus">-nsImapProtocol::GetSubscribingNow()</span>
<a href="#l3.7222"></a><span id="l3.7222" class="difflineminus">-{</span>
<a href="#l3.7223"></a><span id="l3.7223" class="difflineminus">-    // ***** code me *****</span>
<a href="#l3.7224"></a><span id="l3.7224" class="difflineminus">-    return false;// ***** for now</span>
<a href="#l3.7225"></a><span id="l3.7225" class="difflineminus">-}</span>
<a href="#l3.7226"></a><span id="l3.7226" class="difflineminus">-</span>
<a href="#l3.7227"></a><span id="l3.7227" class="difflineminus">-void</span>
<a href="#l3.7228"></a><span id="l3.7228" class="difflineminus">-nsImapProtocol::DiscoverMailboxSpec(nsImapMailboxSpec * adoptedBoxSpec)</span>
<a href="#l3.7229"></a><span id="l3.7229" class="difflineminus">-{</span>
<a href="#l3.7230"></a><span id="l3.7230" class="difflineplus">+bool nsImapProtocol::GetSubscribingNow() {</span>
<a href="#l3.7231"></a><span id="l3.7231" class="difflineplus">+  // ***** code me *****</span>
<a href="#l3.7232"></a><span id="l3.7232" class="difflineplus">+  return false;  // ***** for now</span>
<a href="#l3.7233"></a><span id="l3.7233" class="difflineplus">+}</span>
<a href="#l3.7234"></a><span id="l3.7234" class="difflineplus">+</span>
<a href="#l3.7235"></a><span id="l3.7235" class="difflineplus">+void nsImapProtocol::DiscoverMailboxSpec(nsImapMailboxSpec *adoptedBoxSpec) {</span>
<a href="#l3.7236"></a><span id="l3.7236">   nsIMAPNamespace *ns = nullptr;</span>
<a href="#l3.7237"></a><span id="l3.7237"> </span>
<a href="#l3.7238"></a><span id="l3.7238" class="difflineminus">-  NS_ASSERTION (m_hostSessionList, &quot;fatal null host session list&quot;);</span>
<a href="#l3.7239"></a><span id="l3.7239" class="difflineminus">-  if (!m_hostSessionList)</span>
<a href="#l3.7240"></a><span id="l3.7240" class="difflineminus">-    return;</span>
<a href="#l3.7241"></a><span id="l3.7241" class="difflineminus">-</span>
<a href="#l3.7242"></a><span id="l3.7242" class="difflineminus">-  m_hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l3.7243"></a><span id="l3.7243" class="difflineminus">-    GetImapServerKey(), kPersonalNamespace, ns);</span>
<a href="#l3.7244"></a><span id="l3.7244" class="difflineplus">+  NS_ASSERTION(m_hostSessionList, &quot;fatal null host session list&quot;);</span>
<a href="#l3.7245"></a><span id="l3.7245" class="difflineplus">+  if (!m_hostSessionList) return;</span>
<a href="#l3.7246"></a><span id="l3.7246" class="difflineplus">+</span>
<a href="#l3.7247"></a><span id="l3.7247" class="difflineplus">+  m_hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(GetImapServerKey(),</span>
<a href="#l3.7248"></a><span id="l3.7248" class="difflineplus">+                                                      kPersonalNamespace, ns);</span>
<a href="#l3.7249"></a><span id="l3.7249">   const char *nsPrefix = ns ? ns-&gt;GetPrefix() : 0;</span>
<a href="#l3.7250"></a><span id="l3.7250"> </span>
<a href="#l3.7251"></a><span id="l3.7251" class="difflineminus">-  if (m_specialXListMailboxes.Count() &gt; 0)</span>
<a href="#l3.7252"></a><span id="l3.7252" class="difflineminus">-  {</span>
<a href="#l3.7253"></a><span id="l3.7253" class="difflineplus">+  if (m_specialXListMailboxes.Count() &gt; 0) {</span>
<a href="#l3.7254"></a><span id="l3.7254">     int32_t hashValue = 0;</span>
<a href="#l3.7255"></a><span id="l3.7255">     nsCString strHashKey(adoptedBoxSpec-&gt;mAllocatedPathName);</span>
<a href="#l3.7256"></a><span id="l3.7256">     m_specialXListMailboxes.Get(strHashKey, &amp;hashValue);</span>
<a href="#l3.7257"></a><span id="l3.7257">     adoptedBoxSpec-&gt;mBoxFlags |= hashValue;</span>
<a href="#l3.7258"></a><span id="l3.7258">   }</span>
<a href="#l3.7259"></a><span id="l3.7259"> </span>
<a href="#l3.7260"></a><span id="l3.7260" class="difflineminus">-  switch (m_hierarchyNameState)</span>
<a href="#l3.7261"></a><span id="l3.7261" class="difflineminus">-  {</span>
<a href="#l3.7262"></a><span id="l3.7262" class="difflineminus">-  case kXListing:</span>
<a href="#l3.7263"></a><span id="l3.7263" class="difflineminus">-    if (adoptedBoxSpec-&gt;mBoxFlags &amp;</span>
<a href="#l3.7264"></a><span id="l3.7264" class="difflineminus">-        (kImapXListTrash|kImapAllMail|kImapInbox|kImapSent|kImapSpam|kImapDrafts))</span>
<a href="#l3.7265"></a><span id="l3.7265" class="difflineminus">-    {</span>
<a href="#l3.7266"></a><span id="l3.7266" class="difflineminus">-      nsCString mailboxName(adoptedBoxSpec-&gt;mAllocatedPathName);</span>
<a href="#l3.7267"></a><span id="l3.7267" class="difflineminus">-      m_specialXListMailboxes.Put(mailboxName, adoptedBoxSpec-&gt;mBoxFlags);</span>
<a href="#l3.7268"></a><span id="l3.7268" class="difflineminus">-      // Remember hierarchy delimiter in case this is the first time we've</span>
<a href="#l3.7269"></a><span id="l3.7269" class="difflineminus">-      // connected to the server and we need it to be correct for the two-level</span>
<a href="#l3.7270"></a><span id="l3.7270" class="difflineminus">-      // XLIST we send (INBOX is guaranteed to be in the first response).</span>
<a href="#l3.7271"></a><span id="l3.7271" class="difflineminus">-      if (adoptedBoxSpec-&gt;mBoxFlags &amp; kImapInbox)</span>
<a href="#l3.7272"></a><span id="l3.7272" class="difflineminus">-        m_runningUrl-&gt;SetOnlineSubDirSeparator(adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l3.7273"></a><span id="l3.7273" class="difflineminus">-</span>
<a href="#l3.7274"></a><span id="l3.7274" class="difflineminus">-    }</span>
<a href="#l3.7275"></a><span id="l3.7275" class="difflineminus">-    break;</span>
<a href="#l3.7276"></a><span id="l3.7276" class="difflineminus">-  case kListingForFolderFlags:</span>
<a href="#l3.7277"></a><span id="l3.7277" class="difflineminus">-    {</span>
<a href="#l3.7278"></a><span id="l3.7278" class="difflineplus">+  switch (m_hierarchyNameState) {</span>
<a href="#l3.7279"></a><span id="l3.7279" class="difflineplus">+    case kXListing:</span>
<a href="#l3.7280"></a><span id="l3.7280" class="difflineplus">+      if (adoptedBoxSpec-&gt;mBoxFlags &amp;</span>
<a href="#l3.7281"></a><span id="l3.7281" class="difflineplus">+          (kImapXListTrash | kImapAllMail | kImapInbox | kImapSent | kImapSpam |</span>
<a href="#l3.7282"></a><span id="l3.7282" class="difflineplus">+           kImapDrafts)) {</span>
<a href="#l3.7283"></a><span id="l3.7283" class="difflineplus">+        nsCString mailboxName(adoptedBoxSpec-&gt;mAllocatedPathName);</span>
<a href="#l3.7284"></a><span id="l3.7284" class="difflineplus">+        m_specialXListMailboxes.Put(mailboxName, adoptedBoxSpec-&gt;mBoxFlags);</span>
<a href="#l3.7285"></a><span id="l3.7285" class="difflineplus">+        // Remember hierarchy delimiter in case this is the first time we've</span>
<a href="#l3.7286"></a><span id="l3.7286" class="difflineplus">+        // connected to the server and we need it to be correct for the</span>
<a href="#l3.7287"></a><span id="l3.7287" class="difflineplus">+        // two-level XLIST we send (INBOX is guaranteed to be in the first</span>
<a href="#l3.7288"></a><span id="l3.7288" class="difflineplus">+        // response).</span>
<a href="#l3.7289"></a><span id="l3.7289" class="difflineplus">+        if (adoptedBoxSpec-&gt;mBoxFlags &amp; kImapInbox)</span>
<a href="#l3.7290"></a><span id="l3.7290" class="difflineplus">+          m_runningUrl-&gt;SetOnlineSubDirSeparator(</span>
<a href="#l3.7291"></a><span id="l3.7291" class="difflineplus">+              adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l3.7292"></a><span id="l3.7292" class="difflineplus">+      }</span>
<a href="#l3.7293"></a><span id="l3.7293" class="difflineplus">+      break;</span>
<a href="#l3.7294"></a><span id="l3.7294" class="difflineplus">+    case kListingForFolderFlags: {</span>
<a href="#l3.7295"></a><span id="l3.7295">       // store mailbox flags from LIST for use by LSUB</span>
<a href="#l3.7296"></a><span id="l3.7296">       nsCString mailboxName(adoptedBoxSpec-&gt;mAllocatedPathName);</span>
<a href="#l3.7297"></a><span id="l3.7297">       m_standardListMailboxes.Put(mailboxName, adoptedBoxSpec-&gt;mBoxFlags);</span>
<a href="#l3.7298"></a><span id="l3.7298" class="difflineminus">-    }</span>
<a href="#l3.7299"></a><span id="l3.7299" class="difflineminus">-    break;</span>
<a href="#l3.7300"></a><span id="l3.7300" class="difflineminus">-  case kListingForCreate:</span>
<a href="#l3.7301"></a><span id="l3.7301" class="difflineminus">-  case kNoOperationInProgress:</span>
<a href="#l3.7302"></a><span id="l3.7302" class="difflineminus">-  case kDiscoverTrashFolderInProgress:</span>
<a href="#l3.7303"></a><span id="l3.7303" class="difflineminus">-  case kListingForInfoAndDiscovery:</span>
<a href="#l3.7304"></a><span id="l3.7304" class="difflineminus">-    {</span>
<a href="#l3.7305"></a><span id="l3.7305" class="difflineplus">+    } break;</span>
<a href="#l3.7306"></a><span id="l3.7306" class="difflineplus">+    case kListingForCreate:</span>
<a href="#l3.7307"></a><span id="l3.7307" class="difflineplus">+    case kNoOperationInProgress:</span>
<a href="#l3.7308"></a><span id="l3.7308" class="difflineplus">+    case kDiscoverTrashFolderInProgress:</span>
<a href="#l3.7309"></a><span id="l3.7309" class="difflineplus">+    case kListingForInfoAndDiscovery: {</span>
<a href="#l3.7310"></a><span id="l3.7310">       // standard mailbox specs are stored in m_standardListMailboxes</span>
<a href="#l3.7311"></a><span id="l3.7311">       // because LSUB does necessarily return all mailbox flags.</span>
<a href="#l3.7312"></a><span id="l3.7312">       // count should be &gt; 0 only when we are looking at response of LSUB</span>
<a href="#l3.7313"></a><span id="l3.7313" class="difflineminus">-      if (m_standardListMailboxes.Count() &gt; 0)</span>
<a href="#l3.7314"></a><span id="l3.7314" class="difflineminus">-      {</span>
<a href="#l3.7315"></a><span id="l3.7315" class="difflineplus">+      if (m_standardListMailboxes.Count() &gt; 0) {</span>
<a href="#l3.7316"></a><span id="l3.7316">         int32_t hashValue = 0;</span>
<a href="#l3.7317"></a><span id="l3.7317">         nsCString strHashKey(adoptedBoxSpec-&gt;mAllocatedPathName);</span>
<a href="#l3.7318"></a><span id="l3.7318">         if (m_standardListMailboxes.Get(strHashKey, &amp;hashValue))</span>
<a href="#l3.7319"></a><span id="l3.7319">           adoptedBoxSpec-&gt;mBoxFlags |= hashValue;</span>
<a href="#l3.7320"></a><span id="l3.7320">         else</span>
<a href="#l3.7321"></a><span id="l3.7321">           // if mailbox is not in hash list, then it is subscribed but does not</span>
<a href="#l3.7322"></a><span id="l3.7322">           // exist, so we make sure it can't be selected</span>
<a href="#l3.7323"></a><span id="l3.7323">           adoptedBoxSpec-&gt;mBoxFlags |= kNoselect;</span>
<a href="#l3.7324"></a><span id="l3.7324">       }</span>
<a href="#l3.7325"></a><span id="l3.7325" class="difflineminus">-      if (ns &amp;&amp; nsPrefix) // if no personal namespace, there can be no Trash folder</span>
<a href="#l3.7326"></a><span id="l3.7326" class="difflineplus">+      if (ns &amp;&amp;</span>
<a href="#l3.7327"></a><span id="l3.7327" class="difflineplus">+          nsPrefix)  // if no personal namespace, there can be no Trash folder</span>
<a href="#l3.7328"></a><span id="l3.7328">       {</span>
<a href="#l3.7329"></a><span id="l3.7329">         bool onlineTrashFolderExists = false;</span>
<a href="#l3.7330"></a><span id="l3.7330" class="difflineminus">-        if (m_hostSessionList)</span>
<a href="#l3.7331"></a><span id="l3.7331" class="difflineminus">-        {</span>
<a href="#l3.7332"></a><span id="l3.7332" class="difflineminus">-          if (adoptedBoxSpec-&gt;mBoxFlags &amp; (kImapTrash|kImapXListTrash))</span>
<a href="#l3.7333"></a><span id="l3.7333" class="difflineminus">-          {</span>
<a href="#l3.7334"></a><span id="l3.7334" class="difflineminus">-             m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(GetImapServerKey(), true);</span>
<a href="#l3.7335"></a><span id="l3.7335" class="difflineminus">-             onlineTrashFolderExists = true;</span>
<a href="#l3.7336"></a><span id="l3.7336" class="difflineminus">-          }</span>
<a href="#l3.7337"></a><span id="l3.7337" class="difflineminus">-          else</span>
<a href="#l3.7338"></a><span id="l3.7338" class="difflineminus">-          {</span>
<a href="#l3.7339"></a><span id="l3.7339" class="difflineplus">+        if (m_hostSessionList) {</span>
<a href="#l3.7340"></a><span id="l3.7340" class="difflineplus">+          if (adoptedBoxSpec-&gt;mBoxFlags &amp; (kImapTrash | kImapXListTrash)) {</span>
<a href="#l3.7341"></a><span id="l3.7341" class="difflineplus">+            m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(</span>
<a href="#l3.7342"></a><span id="l3.7342" class="difflineplus">+                GetImapServerKey(), true);</span>
<a href="#l3.7343"></a><span id="l3.7343" class="difflineplus">+            onlineTrashFolderExists = true;</span>
<a href="#l3.7344"></a><span id="l3.7344" class="difflineplus">+          } else {</span>
<a href="#l3.7345"></a><span id="l3.7345">             m_hostSessionList-&gt;GetOnlineTrashFolderExistsForHost(</span>
<a href="#l3.7346"></a><span id="l3.7346" class="difflineminus">-                                  GetImapServerKey(), onlineTrashFolderExists);</span>
<a href="#l3.7347"></a><span id="l3.7347" class="difflineplus">+                GetImapServerKey(), onlineTrashFolderExists);</span>
<a href="#l3.7348"></a><span id="l3.7348">           }</span>
<a href="#l3.7349"></a><span id="l3.7349">         }</span>
<a href="#l3.7350"></a><span id="l3.7350"> </span>
<a href="#l3.7351"></a><span id="l3.7351">         // Don't set the Trash flag if not using the Trash model</span>
<a href="#l3.7352"></a><span id="l3.7352">         if (GetDeleteIsMoveToTrash() &amp;&amp; !onlineTrashFolderExists &amp;&amp;</span>
<a href="#l3.7353"></a><span id="l3.7353" class="difflineminus">-            adoptedBoxSpec-&gt;mAllocatedPathName.Find(m_trashFolderPath, /* ignoreCase = */ true) != -1)</span>
<a href="#l3.7354"></a><span id="l3.7354" class="difflineminus">-        {</span>
<a href="#l3.7355"></a><span id="l3.7355" class="difflineplus">+            adoptedBoxSpec-&gt;mAllocatedPathName.Find(</span>
<a href="#l3.7356"></a><span id="l3.7356" class="difflineplus">+                m_trashFolderPath, /* ignoreCase = */ true) != -1) {</span>
<a href="#l3.7357"></a><span id="l3.7357">           bool trashExists = false;</span>
<a href="#l3.7358"></a><span id="l3.7358" class="difflineminus">-          if (StringBeginsWith(m_trashFolderPath,</span>
<a href="#l3.7359"></a><span id="l3.7359" class="difflineminus">-                               NS_LITERAL_CSTRING(&quot;INBOX/&quot;),</span>
<a href="#l3.7360"></a><span id="l3.7360" class="difflineminus">-                               nsCaseInsensitiveCStringComparator()))</span>
<a href="#l3.7361"></a><span id="l3.7361" class="difflineminus">-          {</span>
<a href="#l3.7362"></a><span id="l3.7362" class="difflineminus">-            nsAutoCString pathName(adoptedBoxSpec-&gt;mAllocatedPathName.get() + 6);</span>
<a href="#l3.7363"></a><span id="l3.7363" class="difflineplus">+          if (StringBeginsWith(m_trashFolderPath, NS_LITERAL_CSTRING(&quot;INBOX/&quot;),</span>
<a href="#l3.7364"></a><span id="l3.7364" class="difflineplus">+                               nsCaseInsensitiveCStringComparator())) {</span>
<a href="#l3.7365"></a><span id="l3.7365" class="difflineplus">+            nsAutoCString pathName(adoptedBoxSpec-&gt;mAllocatedPathName.get() +</span>
<a href="#l3.7366"></a><span id="l3.7366" class="difflineplus">+                                   6);</span>
<a href="#l3.7367"></a><span id="l3.7367">             trashExists =</span>
<a href="#l3.7368"></a><span id="l3.7368" class="difflineminus">-              StringBeginsWith(adoptedBoxSpec-&gt;mAllocatedPathName,</span>
<a href="#l3.7369"></a><span id="l3.7369" class="difflineminus">-                               m_trashFolderPath,</span>
<a href="#l3.7370"></a><span id="l3.7370" class="difflineminus">-                               nsCaseInsensitiveCStringComparator()) &amp;&amp; /* &quot;INBOX/&quot; */</span>
<a href="#l3.7371"></a><span id="l3.7371" class="difflineminus">-              pathName.Equals(Substring(m_trashFolderPath, 6), nsCaseInsensitiveCStringComparator());</span>
<a href="#l3.7372"></a><span id="l3.7372" class="difflineminus">-          }</span>
<a href="#l3.7373"></a><span id="l3.7373" class="difflineminus">-          else</span>
<a href="#l3.7374"></a><span id="l3.7374" class="difflineminus">-            trashExists = adoptedBoxSpec-&gt;mAllocatedPathName.Equals(m_trashFolderPath, nsCaseInsensitiveCStringComparator());</span>
<a href="#l3.7375"></a><span id="l3.7375" class="difflineplus">+                StringBeginsWith(</span>
<a href="#l3.7376"></a><span id="l3.7376" class="difflineplus">+                    adoptedBoxSpec-&gt;mAllocatedPathName, m_trashFolderPath,</span>
<a href="#l3.7377"></a><span id="l3.7377" class="difflineplus">+                    nsCaseInsensitiveCStringComparator()) &amp;&amp; /* &quot;INBOX/&quot; */</span>
<a href="#l3.7378"></a><span id="l3.7378" class="difflineplus">+                pathName.Equals(Substring(m_trashFolderPath, 6),</span>
<a href="#l3.7379"></a><span id="l3.7379" class="difflineplus">+                                nsCaseInsensitiveCStringComparator());</span>
<a href="#l3.7380"></a><span id="l3.7380" class="difflineplus">+          } else</span>
<a href="#l3.7381"></a><span id="l3.7381" class="difflineplus">+            trashExists = adoptedBoxSpec-&gt;mAllocatedPathName.Equals(</span>
<a href="#l3.7382"></a><span id="l3.7382" class="difflineplus">+                m_trashFolderPath, nsCaseInsensitiveCStringComparator());</span>
<a href="#l3.7383"></a><span id="l3.7383"> </span>
<a href="#l3.7384"></a><span id="l3.7384">           if (m_hostSessionList)</span>
<a href="#l3.7385"></a><span id="l3.7385" class="difflineminus">-            m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(GetImapServerKey(), trashExists);</span>
<a href="#l3.7386"></a><span id="l3.7386" class="difflineminus">-</span>
<a href="#l3.7387"></a><span id="l3.7387" class="difflineminus">-          if (trashExists)</span>
<a href="#l3.7388"></a><span id="l3.7388" class="difflineminus">-            adoptedBoxSpec-&gt;mBoxFlags |= kImapTrash;</span>
<a href="#l3.7389"></a><span id="l3.7389" class="difflineplus">+            m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(</span>
<a href="#l3.7390"></a><span id="l3.7390" class="difflineplus">+                GetImapServerKey(), trashExists);</span>
<a href="#l3.7391"></a><span id="l3.7391" class="difflineplus">+</span>
<a href="#l3.7392"></a><span id="l3.7392" class="difflineplus">+          if (trashExists) adoptedBoxSpec-&gt;mBoxFlags |= kImapTrash;</span>
<a href="#l3.7393"></a><span id="l3.7393">         }</span>
<a href="#l3.7394"></a><span id="l3.7394">       }</span>
<a href="#l3.7395"></a><span id="l3.7395"> </span>
<a href="#l3.7396"></a><span id="l3.7396">       // Discover the folder (shuttle over to libmsg, yay)</span>
<a href="#l3.7397"></a><span id="l3.7397">       // Do this only if the folder name is not empty (i.e. the root)</span>
<a href="#l3.7398"></a><span id="l3.7398" class="difflineminus">-      if (!adoptedBoxSpec-&gt;mAllocatedPathName.IsEmpty())</span>
<a href="#l3.7399"></a><span id="l3.7399" class="difflineminus">-      {</span>
<a href="#l3.7400"></a><span id="l3.7400" class="difflineplus">+      if (!adoptedBoxSpec-&gt;mAllocatedPathName.IsEmpty()) {</span>
<a href="#l3.7401"></a><span id="l3.7401">         if (m_hierarchyNameState == kListingForCreate)</span>
<a href="#l3.7402"></a><span id="l3.7402">           adoptedBoxSpec-&gt;mBoxFlags |= kNewlyCreatedFolder;</span>
<a href="#l3.7403"></a><span id="l3.7403"> </span>
<a href="#l3.7404"></a><span id="l3.7404" class="difflineminus">-        if (m_imapServerSink)</span>
<a href="#l3.7405"></a><span id="l3.7405" class="difflineminus">-        {</span>
<a href="#l3.7406"></a><span id="l3.7406" class="difflineplus">+        if (m_imapServerSink) {</span>
<a href="#l3.7407"></a><span id="l3.7407">           bool newFolder;</span>
<a href="#l3.7408"></a><span id="l3.7408"> </span>
<a href="#l3.7409"></a><span id="l3.7409" class="difflineminus">-          m_imapServerSink-&gt;PossibleImapMailbox(adoptedBoxSpec-&gt;mAllocatedPathName,</span>
<a href="#l3.7410"></a><span id="l3.7410" class="difflineminus">-                                                adoptedBoxSpec-&gt;mHierarchySeparator,</span>
<a href="#l3.7411"></a><span id="l3.7411" class="difflineminus">-                                                adoptedBoxSpec-&gt;mBoxFlags, &amp;newFolder);</span>
<a href="#l3.7412"></a><span id="l3.7412" class="difflineminus">-          // if it's a new folder to the server sink, setting discovery status to</span>
<a href="#l3.7413"></a><span id="l3.7413" class="difflineminus">-          // eContinueNew will cause us to get the ACL for the new folder.</span>
<a href="#l3.7414"></a><span id="l3.7414" class="difflineminus">-          if (newFolder)</span>
<a href="#l3.7415"></a><span id="l3.7415" class="difflineminus">-            SetMailboxDiscoveryStatus(eContinueNew);</span>
<a href="#l3.7416"></a><span id="l3.7416" class="difflineplus">+          m_imapServerSink-&gt;PossibleImapMailbox(</span>
<a href="#l3.7417"></a><span id="l3.7417" class="difflineplus">+              adoptedBoxSpec-&gt;mAllocatedPathName,</span>
<a href="#l3.7418"></a><span id="l3.7418" class="difflineplus">+              adoptedBoxSpec-&gt;mHierarchySeparator, adoptedBoxSpec-&gt;mBoxFlags,</span>
<a href="#l3.7419"></a><span id="l3.7419" class="difflineplus">+              &amp;newFolder);</span>
<a href="#l3.7420"></a><span id="l3.7420" class="difflineplus">+          // if it's a new folder to the server sink, setting discovery status</span>
<a href="#l3.7421"></a><span id="l3.7421" class="difflineplus">+          // to eContinueNew will cause us to get the ACL for the new folder.</span>
<a href="#l3.7422"></a><span id="l3.7422" class="difflineplus">+          if (newFolder) SetMailboxDiscoveryStatus(eContinueNew);</span>
<a href="#l3.7423"></a><span id="l3.7423"> </span>
<a href="#l3.7424"></a><span id="l3.7424">           bool useSubscription = false;</span>
<a href="#l3.7425"></a><span id="l3.7425"> </span>
<a href="#l3.7426"></a><span id="l3.7426">           if (m_hostSessionList)</span>
<a href="#l3.7427"></a><span id="l3.7427">             m_hostSessionList-&gt;GetHostIsUsingSubscription(GetImapServerKey(),</span>
<a href="#l3.7428"></a><span id="l3.7428">                                                           useSubscription);</span>
<a href="#l3.7429"></a><span id="l3.7429"> </span>
<a href="#l3.7430"></a><span id="l3.7430">           if ((GetMailboxDiscoveryStatus() != eContinue) &amp;&amp;</span>
<a href="#l3.7431"></a><span id="l3.7431">               (GetMailboxDiscoveryStatus() != eContinueNew) &amp;&amp;</span>
<a href="#l3.7432"></a><span id="l3.7432" class="difflineminus">-              (GetMailboxDiscoveryStatus() != eListMyChildren))</span>
<a href="#l3.7433"></a><span id="l3.7433" class="difflineminus">-          {</span>
<a href="#l3.7434"></a><span id="l3.7434" class="difflineplus">+              (GetMailboxDiscoveryStatus() != eListMyChildren)) {</span>
<a href="#l3.7435"></a><span id="l3.7435">             SetConnectionStatus(NS_ERROR_FAILURE);</span>
<a href="#l3.7436"></a><span id="l3.7436" class="difflineminus">-          }</span>
<a href="#l3.7437"></a><span id="l3.7437" class="difflineminus">-          else if (!adoptedBoxSpec-&gt;mAllocatedPathName.IsEmpty() &amp;&amp;</span>
<a href="#l3.7438"></a><span id="l3.7438" class="difflineminus">-                   (GetMailboxDiscoveryStatus() == eListMyChildren) &amp;&amp;</span>
<a href="#l3.7439"></a><span id="l3.7439" class="difflineminus">-                   (!useSubscription || GetSubscribingNow()))</span>
<a href="#l3.7440"></a><span id="l3.7440" class="difflineminus">-          {</span>
<a href="#l3.7441"></a><span id="l3.7441" class="difflineminus">-            NS_ASSERTION (false,</span>
<a href="#l3.7442"></a><span id="l3.7442" class="difflineminus">-              &quot;we should never get here anymore&quot;);</span>
<a href="#l3.7443"></a><span id="l3.7443" class="difflineplus">+          } else if (!adoptedBoxSpec-&gt;mAllocatedPathName.IsEmpty() &amp;&amp;</span>
<a href="#l3.7444"></a><span id="l3.7444" class="difflineplus">+                     (GetMailboxDiscoveryStatus() == eListMyChildren) &amp;&amp;</span>
<a href="#l3.7445"></a><span id="l3.7445" class="difflineplus">+                     (!useSubscription || GetSubscribingNow())) {</span>
<a href="#l3.7446"></a><span id="l3.7446" class="difflineplus">+            NS_ASSERTION(false, &quot;we should never get here anymore&quot;);</span>
<a href="#l3.7447"></a><span id="l3.7447">             SetMailboxDiscoveryStatus(eContinue);</span>
<a href="#l3.7448"></a><span id="l3.7448" class="difflineminus">-          }</span>
<a href="#l3.7449"></a><span id="l3.7449" class="difflineminus">-          else if (GetMailboxDiscoveryStatus() == eContinueNew)</span>
<a href="#l3.7450"></a><span id="l3.7450" class="difflineminus">-          {</span>
<a href="#l3.7451"></a><span id="l3.7451" class="difflineplus">+          } else if (GetMailboxDiscoveryStatus() == eContinueNew) {</span>
<a href="#l3.7452"></a><span id="l3.7452">             if (m_hierarchyNameState == kListingForInfoAndDiscovery &amp;&amp;</span>
<a href="#l3.7453"></a><span id="l3.7453">                 !adoptedBoxSpec-&gt;mAllocatedPathName.IsEmpty() &amp;&amp;</span>
<a href="#l3.7454"></a><span id="l3.7454" class="difflineminus">-                !(adoptedBoxSpec-&gt;mBoxFlags &amp; kNameSpace))</span>
<a href="#l3.7455"></a><span id="l3.7455" class="difflineminus">-            {</span>
<a href="#l3.7456"></a><span id="l3.7456" class="difflineplus">+                !(adoptedBoxSpec-&gt;mBoxFlags &amp; kNameSpace)) {</span>
<a href="#l3.7457"></a><span id="l3.7457">               // remember the info here also</span>
<a href="#l3.7458"></a><span id="l3.7458" class="difflineminus">-              nsIMAPMailboxInfo *mb = new nsIMAPMailboxInfo(adoptedBoxSpec-&gt;mAllocatedPathName, adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l3.7459"></a><span id="l3.7459" class="difflineplus">+              nsIMAPMailboxInfo *mb =</span>
<a href="#l3.7460"></a><span id="l3.7460" class="difflineplus">+                  new nsIMAPMailboxInfo(adoptedBoxSpec-&gt;mAllocatedPathName,</span>
<a href="#l3.7461"></a><span id="l3.7461" class="difflineplus">+                                        adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l3.7462"></a><span id="l3.7462">               m_listedMailboxList.AppendElement(mb);</span>
<a href="#l3.7463"></a><span id="l3.7463">             }</span>
<a href="#l3.7464"></a><span id="l3.7464">             SetMailboxDiscoveryStatus(eContinue);</span>
<a href="#l3.7465"></a><span id="l3.7465">           }</span>
<a href="#l3.7466"></a><span id="l3.7466">         }</span>
<a href="#l3.7467"></a><span id="l3.7467">       }</span>
<a href="#l3.7468"></a><span id="l3.7468" class="difflineminus">-      }</span>
<a href="#l3.7469"></a><span id="l3.7469" class="difflineminus">-      break;</span>
<a href="#l3.7470"></a><span id="l3.7470" class="difflineminus">-    case kDeleteSubFoldersInProgress:</span>
<a href="#l3.7471"></a><span id="l3.7471" class="difflineminus">-      {</span>
<a href="#l3.7472"></a><span id="l3.7472" class="difflineminus">-        NS_ASSERTION(m_deletableChildren, &quot;Oops .. null m_deletableChildren&quot;);</span>
<a href="#l3.7473"></a><span id="l3.7473" class="difflineminus">-        m_deletableChildren-&gt;AppendElement(ToNewCString(adoptedBoxSpec-&gt;mAllocatedPathName));</span>
<a href="#l3.7474"></a><span id="l3.7474" class="difflineminus">-      }</span>
<a href="#l3.7475"></a><span id="l3.7475" class="difflineplus">+    } break;</span>
<a href="#l3.7476"></a><span id="l3.7476" class="difflineplus">+    case kDeleteSubFoldersInProgress: {</span>
<a href="#l3.7477"></a><span id="l3.7477" class="difflineplus">+      NS_ASSERTION(m_deletableChildren, &quot;Oops .. null m_deletableChildren&quot;);</span>
<a href="#l3.7478"></a><span id="l3.7478" class="difflineplus">+      m_deletableChildren-&gt;AppendElement(</span>
<a href="#l3.7479"></a><span id="l3.7479" class="difflineplus">+          ToNewCString(adoptedBoxSpec-&gt;mAllocatedPathName));</span>
<a href="#l3.7480"></a><span id="l3.7480" class="difflineplus">+    } break;</span>
<a href="#l3.7481"></a><span id="l3.7481" class="difflineplus">+    case kListingForInfoOnly: {</span>
<a href="#l3.7482"></a><span id="l3.7482" class="difflineplus">+      // UpdateProgressWindowForUpgrade(adoptedBoxSpec-&gt;allocatedPathName);</span>
<a href="#l3.7483"></a><span id="l3.7483" class="difflineplus">+      ProgressEventFunctionUsingNameWithString(</span>
<a href="#l3.7484"></a><span id="l3.7484" class="difflineplus">+          &quot;imapDiscoveringMailbox&quot;, adoptedBoxSpec-&gt;mAllocatedPathName.get());</span>
<a href="#l3.7485"></a><span id="l3.7485" class="difflineplus">+      nsIMAPMailboxInfo *mb =</span>
<a href="#l3.7486"></a><span id="l3.7486" class="difflineplus">+          new nsIMAPMailboxInfo(adoptedBoxSpec-&gt;mAllocatedPathName,</span>
<a href="#l3.7487"></a><span id="l3.7487" class="difflineplus">+                                adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l3.7488"></a><span id="l3.7488" class="difflineplus">+      m_listedMailboxList.AppendElement(mb);</span>
<a href="#l3.7489"></a><span id="l3.7489" class="difflineplus">+    } break;</span>
<a href="#l3.7490"></a><span id="l3.7490" class="difflineplus">+    case kDiscoveringNamespacesOnly: {</span>
<a href="#l3.7491"></a><span id="l3.7491" class="difflineplus">+    } break;</span>
<a href="#l3.7492"></a><span id="l3.7492" class="difflineplus">+    default:</span>
<a href="#l3.7493"></a><span id="l3.7493" class="difflineplus">+      NS_ASSERTION(false, &quot;we aren't supposed to be here&quot;);</span>
<a href="#l3.7494"></a><span id="l3.7494">       break;</span>
<a href="#l3.7495"></a><span id="l3.7495" class="difflineminus">-    case kListingForInfoOnly:</span>
<a href="#l3.7496"></a><span id="l3.7496" class="difflineminus">-      {</span>
<a href="#l3.7497"></a><span id="l3.7497" class="difflineminus">-        //UpdateProgressWindowForUpgrade(adoptedBoxSpec-&gt;allocatedPathName);</span>
<a href="#l3.7498"></a><span id="l3.7498" class="difflineminus">-        ProgressEventFunctionUsingNameWithString(&quot;imapDiscoveringMailbox&quot;,</span>
<a href="#l3.7499"></a><span id="l3.7499" class="difflineminus">-          adoptedBoxSpec-&gt;mAllocatedPathName.get());</span>
<a href="#l3.7500"></a><span id="l3.7500" class="difflineminus">-        nsIMAPMailboxInfo *mb = new nsIMAPMailboxInfo(adoptedBoxSpec-&gt;mAllocatedPathName,</span>
<a href="#l3.7501"></a><span id="l3.7501" class="difflineminus">-                                                      adoptedBoxSpec-&gt;mHierarchySeparator);</span>
<a href="#l3.7502"></a><span id="l3.7502" class="difflineminus">-        m_listedMailboxList.AppendElement(mb);</span>
<a href="#l3.7503"></a><span id="l3.7503" class="difflineminus">-      }</span>
<a href="#l3.7504"></a><span id="l3.7504" class="difflineminus">-      break;</span>
<a href="#l3.7505"></a><span id="l3.7505" class="difflineminus">-    case kDiscoveringNamespacesOnly:</span>
<a href="#l3.7506"></a><span id="l3.7506" class="difflineminus">-      {</span>
<a href="#l3.7507"></a><span id="l3.7507" class="difflineminus">-      }</span>
<a href="#l3.7508"></a><span id="l3.7508" class="difflineminus">-      break;</span>
<a href="#l3.7509"></a><span id="l3.7509" class="difflineminus">-    default:</span>
<a href="#l3.7510"></a><span id="l3.7510" class="difflineminus">-      NS_ASSERTION (false, &quot;we aren't supposed to be here&quot;);</span>
<a href="#l3.7511"></a><span id="l3.7511" class="difflineminus">-      break;</span>
<a href="#l3.7512"></a><span id="l3.7512" class="difflineminus">-  }</span>
<a href="#l3.7513"></a><span id="l3.7513" class="difflineminus">-}</span>
<a href="#l3.7514"></a><span id="l3.7514" class="difflineminus">-</span>
<a href="#l3.7515"></a><span id="l3.7515" class="difflineminus">-void</span>
<a href="#l3.7516"></a><span id="l3.7516" class="difflineminus">-nsImapProtocol::AlertUserEventUsingName(const char* aMessageName)</span>
<a href="#l3.7517"></a><span id="l3.7517" class="difflineminus">-{</span>
<a href="#l3.7518"></a><span id="l3.7518" class="difflineminus">-  if (m_imapServerSink)</span>
<a href="#l3.7519"></a><span id="l3.7519" class="difflineminus">-  {</span>
<a href="#l3.7520"></a><span id="l3.7520" class="difflineplus">+  }</span>
<a href="#l3.7521"></a><span id="l3.7521" class="difflineplus">+}</span>
<a href="#l3.7522"></a><span id="l3.7522" class="difflineplus">+</span>
<a href="#l3.7523"></a><span id="l3.7523" class="difflineplus">+void nsImapProtocol::AlertUserEventUsingName(const char *aMessageName) {</span>
<a href="#l3.7524"></a><span id="l3.7524" class="difflineplus">+  if (m_imapServerSink) {</span>
<a href="#l3.7525"></a><span id="l3.7525">     bool suppressErrorMsg = false;</span>
<a href="#l3.7526"></a><span id="l3.7526"> </span>
<a href="#l3.7527"></a><span id="l3.7527">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.7528"></a><span id="l3.7528" class="difflineminus">-    if (mailnewsUrl)</span>
<a href="#l3.7529"></a><span id="l3.7529" class="difflineminus">-      mailnewsUrl-&gt;GetSuppressErrorMsgs(&amp;suppressErrorMsg);</span>
<a href="#l3.7530"></a><span id="l3.7530" class="difflineplus">+    if (mailnewsUrl) mailnewsUrl-&gt;GetSuppressErrorMsgs(&amp;suppressErrorMsg);</span>
<a href="#l3.7531"></a><span id="l3.7531"> </span>
<a href="#l3.7532"></a><span id="l3.7532">     if (!suppressErrorMsg)</span>
<a href="#l3.7533"></a><span id="l3.7533" class="difflineminus">-      m_imapServerSink-&gt;FEAlertWithName(aMessageName,</span>
<a href="#l3.7534"></a><span id="l3.7534" class="difflineminus">-                                        mailnewsUrl);</span>
<a href="#l3.7535"></a><span id="l3.7535" class="difflineminus">-  }</span>
<a href="#l3.7536"></a><span id="l3.7536" class="difflineminus">-}</span>
<a href="#l3.7537"></a><span id="l3.7537" class="difflineminus">-</span>
<a href="#l3.7538"></a><span id="l3.7538" class="difflineminus">-void</span>
<a href="#l3.7539"></a><span id="l3.7539" class="difflineminus">-nsImapProtocol::AlertUserEvent(const char * message)</span>
<a href="#l3.7540"></a><span id="l3.7540" class="difflineminus">-{</span>
<a href="#l3.7541"></a><span id="l3.7541" class="difflineminus">-  if (m_imapServerSink)</span>
<a href="#l3.7542"></a><span id="l3.7542" class="difflineminus">-  {</span>
<a href="#l3.7543"></a><span id="l3.7543" class="difflineplus">+      m_imapServerSink-&gt;FEAlertWithName(aMessageName, mailnewsUrl);</span>
<a href="#l3.7544"></a><span id="l3.7544" class="difflineplus">+  }</span>
<a href="#l3.7545"></a><span id="l3.7545" class="difflineplus">+}</span>
<a href="#l3.7546"></a><span id="l3.7546" class="difflineplus">+</span>
<a href="#l3.7547"></a><span id="l3.7547" class="difflineplus">+void nsImapProtocol::AlertUserEvent(const char *message) {</span>
<a href="#l3.7548"></a><span id="l3.7548" class="difflineplus">+  if (m_imapServerSink) {</span>
<a href="#l3.7549"></a><span id="l3.7549">     bool suppressErrorMsg = false;</span>
<a href="#l3.7550"></a><span id="l3.7550"> </span>
<a href="#l3.7551"></a><span id="l3.7551">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.7552"></a><span id="l3.7552" class="difflineminus">-    if (mailnewsUrl)</span>
<a href="#l3.7553"></a><span id="l3.7553" class="difflineminus">-      mailnewsUrl-&gt;GetSuppressErrorMsgs(&amp;suppressErrorMsg);</span>
<a href="#l3.7554"></a><span id="l3.7554" class="difflineplus">+    if (mailnewsUrl) mailnewsUrl-&gt;GetSuppressErrorMsgs(&amp;suppressErrorMsg);</span>
<a href="#l3.7555"></a><span id="l3.7555"> </span>
<a href="#l3.7556"></a><span id="l3.7556">     if (!suppressErrorMsg)</span>
<a href="#l3.7557"></a><span id="l3.7557">       m_imapServerSink-&gt;FEAlert(NS_ConvertASCIItoUTF16(message), mailnewsUrl);</span>
<a href="#l3.7558"></a><span id="l3.7558">   }</span>
<a href="#l3.7559"></a><span id="l3.7559"> }</span>
<a href="#l3.7560"></a><span id="l3.7560"> </span>
<a href="#l3.7561"></a><span id="l3.7561" class="difflineminus">-void</span>
<a href="#l3.7562"></a><span id="l3.7562" class="difflineminus">-nsImapProtocol::AlertUserEventFromServer(const char * aServerEvent, bool aForIdle)</span>
<a href="#l3.7563"></a><span id="l3.7563" class="difflineminus">-{</span>
<a href="#l3.7564"></a><span id="l3.7564" class="difflineminus">-  if (aServerEvent)</span>
<a href="#l3.7565"></a><span id="l3.7565" class="difflineminus">-  {</span>
<a href="#l3.7566"></a><span id="l3.7566" class="difflineminus">-    // If called due to BAD/NO imap IDLE response, the server sink and running url</span>
<a href="#l3.7567"></a><span id="l3.7567" class="difflineminus">-    // are typically null when IDLE command is sent. So use the stored latest</span>
<a href="#l3.7568"></a><span id="l3.7568" class="difflineminus">-    // values for these so that the error alert notification occurs.</span>
<a href="#l3.7569"></a><span id="l3.7569" class="difflineminus">-    if (aForIdle &amp;&amp; !m_imapServerSink &amp;&amp; !m_runningUrl &amp;&amp; m_imapServerSinkLatest)</span>
<a href="#l3.7570"></a><span id="l3.7570" class="difflineminus">-    {</span>
<a href="#l3.7571"></a><span id="l3.7571" class="difflineminus">-      nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrlLatest);</span>
<a href="#l3.7572"></a><span id="l3.7572" class="difflineminus">-      m_imapServerSinkLatest-&gt;FEAlertFromServer(nsDependentCString(aServerEvent),</span>
<a href="#l3.7573"></a><span id="l3.7573" class="difflineminus">-                                                mailnewsUrl);</span>
<a href="#l3.7574"></a><span id="l3.7574" class="difflineminus">-    }</span>
<a href="#l3.7575"></a><span id="l3.7575" class="difflineminus">-    else if (m_imapServerSink)</span>
<a href="#l3.7576"></a><span id="l3.7576" class="difflineminus">-    {</span>
<a href="#l3.7577"></a><span id="l3.7577" class="difflineplus">+void nsImapProtocol::AlertUserEventFromServer(const char *aServerEvent,</span>
<a href="#l3.7578"></a><span id="l3.7578" class="difflineplus">+                                              bool aForIdle) {</span>
<a href="#l3.7579"></a><span id="l3.7579" class="difflineplus">+  if (aServerEvent) {</span>
<a href="#l3.7580"></a><span id="l3.7580" class="difflineplus">+    // If called due to BAD/NO imap IDLE response, the server sink and running</span>
<a href="#l3.7581"></a><span id="l3.7581" class="difflineplus">+    // url are typically null when IDLE command is sent. So use the stored</span>
<a href="#l3.7582"></a><span id="l3.7582" class="difflineplus">+    // latest values for these so that the error alert notification occurs.</span>
<a href="#l3.7583"></a><span id="l3.7583" class="difflineplus">+    if (aForIdle &amp;&amp; !m_imapServerSink &amp;&amp; !m_runningUrl &amp;&amp;</span>
<a href="#l3.7584"></a><span id="l3.7584" class="difflineplus">+        m_imapServerSinkLatest) {</span>
<a href="#l3.7585"></a><span id="l3.7585" class="difflineplus">+      nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl =</span>
<a href="#l3.7586"></a><span id="l3.7586" class="difflineplus">+          do_QueryInterface(m_runningUrlLatest);</span>
<a href="#l3.7587"></a><span id="l3.7587" class="difflineplus">+      m_imapServerSinkLatest-&gt;FEAlertFromServer(</span>
<a href="#l3.7588"></a><span id="l3.7588" class="difflineplus">+          nsDependentCString(aServerEvent), mailnewsUrl);</span>
<a href="#l3.7589"></a><span id="l3.7589" class="difflineplus">+    } else if (m_imapServerSink) {</span>
<a href="#l3.7590"></a><span id="l3.7590">       nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.7591"></a><span id="l3.7591">       m_imapServerSink-&gt;FEAlertFromServer(nsDependentCString(aServerEvent),</span>
<a href="#l3.7592"></a><span id="l3.7592">                                           mailnewsUrl);</span>
<a href="#l3.7593"></a><span id="l3.7593">     }</span>
<a href="#l3.7594"></a><span id="l3.7594">   }</span>
<a href="#l3.7595"></a><span id="l3.7595"> }</span>
<a href="#l3.7596"></a><span id="l3.7596"> </span>
<a href="#l3.7597"></a><span id="l3.7597" class="difflineminus">-void nsImapProtocol::ResetProgressInfo()</span>
<a href="#l3.7598"></a><span id="l3.7598" class="difflineminus">-{</span>
<a href="#l3.7599"></a><span id="l3.7599" class="difflineplus">+void nsImapProtocol::ResetProgressInfo() {</span>
<a href="#l3.7600"></a><span id="l3.7600">   m_lastProgressTime = 0;</span>
<a href="#l3.7601"></a><span id="l3.7601">   m_lastPercent = -1;</span>
<a href="#l3.7602"></a><span id="l3.7602">   m_lastProgressStringName.Truncate();</span>
<a href="#l3.7603"></a><span id="l3.7603"> }</span>
<a href="#l3.7604"></a><span id="l3.7604"> </span>
<a href="#l3.7605"></a><span id="l3.7605" class="difflineminus">-void nsImapProtocol::SetProgressString(uint32_t aStringIndex)</span>
<a href="#l3.7606"></a><span id="l3.7606" class="difflineminus">-{</span>
<a href="#l3.7607"></a><span id="l3.7607" class="difflineplus">+void nsImapProtocol::SetProgressString(uint32_t aStringIndex) {</span>
<a href="#l3.7608"></a><span id="l3.7608">   m_stringIndex = aStringIndex;</span>
<a href="#l3.7609"></a><span id="l3.7609">   MOZ_ASSERT(m_stringIndex &lt;= IMAP_EMPTY_STRING_INDEX);</span>
<a href="#l3.7610"></a><span id="l3.7610" class="difflineminus">-  switch (m_stringIndex)</span>
<a href="#l3.7611"></a><span id="l3.7611" class="difflineminus">-  {</span>
<a href="#l3.7612"></a><span id="l3.7612" class="difflineplus">+  switch (m_stringIndex) {</span>
<a href="#l3.7613"></a><span id="l3.7613">     case IMAP_HEADERS_STRING_INDEX:</span>
<a href="#l3.7614"></a><span id="l3.7614">       m_progressStringName = &quot;imapReceivingMessageHeaders3&quot;;</span>
<a href="#l3.7615"></a><span id="l3.7615">       break;</span>
<a href="#l3.7616"></a><span id="l3.7616">     case IMAP_MESSAGES_STRING_INDEX:</span>
<a href="#l3.7617"></a><span id="l3.7617">       m_progressStringName = &quot;imapFolderReceivingMessageOf3&quot;;</span>
<a href="#l3.7618"></a><span id="l3.7618">       break;</span>
<a href="#l3.7619"></a><span id="l3.7619">     case IMAP_FLAGS_STRING_INDEX:</span>
<a href="#l3.7620"></a><span id="l3.7620">       m_progressStringName = &quot;imapReceivingMessageFlags3&quot;;</span>
<a href="#l3.7621"></a><span id="l3.7621">       break;</span>
<a href="#l3.7622"></a><span id="l3.7622">     case IMAP_EMPTY_STRING_INDEX:</span>
<a href="#l3.7623"></a><span id="l3.7623">     default:</span>
<a href="#l3.7624"></a><span id="l3.7624">       break;</span>
<a href="#l3.7625"></a><span id="l3.7625">   }</span>
<a href="#l3.7626"></a><span id="l3.7626"> }</span>
<a href="#l3.7627"></a><span id="l3.7627"> </span>
<a href="#l3.7628"></a><span id="l3.7628" class="difflineminus">-void</span>
<a href="#l3.7629"></a><span id="l3.7629" class="difflineminus">-nsImapProtocol::ShowProgress()</span>
<a href="#l3.7630"></a><span id="l3.7630" class="difflineminus">-{</span>
<a href="#l3.7631"></a><span id="l3.7631" class="difflineminus">-  if (m_imapServerSink &amp;&amp; (m_stringIndex != IMAP_EMPTY_STRING_INDEX))</span>
<a href="#l3.7632"></a><span id="l3.7632" class="difflineminus">-  {</span>
<a href="#l3.7633"></a><span id="l3.7633" class="difflineplus">+void nsImapProtocol::ShowProgress() {</span>
<a href="#l3.7634"></a><span id="l3.7634" class="difflineplus">+  if (m_imapServerSink &amp;&amp; (m_stringIndex != IMAP_EMPTY_STRING_INDEX)) {</span>
<a href="#l3.7635"></a><span id="l3.7635">     nsString progressString;</span>
<a href="#l3.7636"></a><span id="l3.7636">     const char *mailboxName = GetServerStateParser().GetSelectedMailboxName();</span>
<a href="#l3.7637"></a><span id="l3.7637">     nsString unicodeMailboxName;</span>
<a href="#l3.7638"></a><span id="l3.7638" class="difflineminus">-    nsresult rv = CopyMUTF7toUTF16(nsDependentCString(mailboxName),</span>
<a href="#l3.7639"></a><span id="l3.7639" class="difflineminus">-                                   unicodeMailboxName);</span>
<a href="#l3.7640"></a><span id="l3.7640" class="difflineplus">+    nsresult rv =</span>
<a href="#l3.7641"></a><span id="l3.7641" class="difflineplus">+        CopyMUTF7toUTF16(nsDependentCString(mailboxName), unicodeMailboxName);</span>
<a href="#l3.7642"></a><span id="l3.7642">     NS_ENSURE_SUCCESS_VOID(rv);</span>
<a href="#l3.7643"></a><span id="l3.7643"> </span>
<a href="#l3.7644"></a><span id="l3.7644">     int32_t progressCurrentNumber = ++m_progressCurrentNumber[m_stringIndex];</span>
<a href="#l3.7645"></a><span id="l3.7645">     nsAutoString progressCurrentNumberString;</span>
<a href="#l3.7646"></a><span id="l3.7646">     progressCurrentNumberString.AppendInt(progressCurrentNumber);</span>
<a href="#l3.7647"></a><span id="l3.7647"> </span>
<a href="#l3.7648"></a><span id="l3.7648">     nsAutoString progressExpectedNumberString;</span>
<a href="#l3.7649"></a><span id="l3.7649">     progressExpectedNumberString.AppendInt(m_progressExpectedNumber);</span>
<a href="#l3.7650"></a><span id="l3.7650"> </span>
<a href="#l3.7651"></a><span id="l3.7651" class="difflineminus">-    const char16_t *formatStrings[] = {</span>
<a href="#l3.7652"></a><span id="l3.7652" class="difflineminus">-      progressCurrentNumberString.get(),</span>
<a href="#l3.7653"></a><span id="l3.7653" class="difflineminus">-      progressExpectedNumberString.get(),</span>
<a href="#l3.7654"></a><span id="l3.7654" class="difflineminus">-      unicodeMailboxName.get()</span>
<a href="#l3.7655"></a><span id="l3.7655" class="difflineminus">-    };</span>
<a href="#l3.7656"></a><span id="l3.7656" class="difflineminus">-</span>
<a href="#l3.7657"></a><span id="l3.7657" class="difflineminus">-    rv = m_bundle-&gt;FormatStringFromName(</span>
<a href="#l3.7658"></a><span id="l3.7658" class="difflineminus">-                    m_progressStringName.get(),</span>
<a href="#l3.7659"></a><span id="l3.7659" class="difflineminus">-                    formatStrings, 3, progressString);</span>
<a href="#l3.7660"></a><span id="l3.7660" class="difflineminus">-</span>
<a href="#l3.7661"></a><span id="l3.7661" class="difflineminus">-    if (NS_SUCCEEDED(rv) &amp;&amp; !progressString.IsEmpty())</span>
<a href="#l3.7662"></a><span id="l3.7662" class="difflineminus">-    {</span>
<a href="#l3.7663"></a><span id="l3.7663" class="difflineplus">+    const char16_t *formatStrings[] = {progressCurrentNumberString.get(),</span>
<a href="#l3.7664"></a><span id="l3.7664" class="difflineplus">+                                       progressExpectedNumberString.get(),</span>
<a href="#l3.7665"></a><span id="l3.7665" class="difflineplus">+                                       unicodeMailboxName.get()};</span>
<a href="#l3.7666"></a><span id="l3.7666" class="difflineplus">+</span>
<a href="#l3.7667"></a><span id="l3.7667" class="difflineplus">+    rv = m_bundle-&gt;FormatStringFromName(m_progressStringName.get(),</span>
<a href="#l3.7668"></a><span id="l3.7668" class="difflineplus">+                                        formatStrings, 3, progressString);</span>
<a href="#l3.7669"></a><span id="l3.7669" class="difflineplus">+</span>
<a href="#l3.7670"></a><span id="l3.7670" class="difflineplus">+    if (NS_SUCCEEDED(rv) &amp;&amp; !progressString.IsEmpty()) {</span>
<a href="#l3.7671"></a><span id="l3.7671">       PercentProgressUpdateEvent(progressString.get(), progressCurrentNumber,</span>
<a href="#l3.7672"></a><span id="l3.7672" class="difflineminus">-                                m_progressExpectedNumber);</span>
<a href="#l3.7673"></a><span id="l3.7673" class="difflineminus">-    }</span>
<a href="#l3.7674"></a><span id="l3.7674" class="difflineminus">-  }</span>
<a href="#l3.7675"></a><span id="l3.7675" class="difflineminus">-}</span>
<a href="#l3.7676"></a><span id="l3.7676" class="difflineminus">-</span>
<a href="#l3.7677"></a><span id="l3.7677" class="difflineminus">-void</span>
<a href="#l3.7678"></a><span id="l3.7678" class="difflineminus">-nsImapProtocol::ProgressEventFunctionUsingName(const char* aMsgName)</span>
<a href="#l3.7679"></a><span id="l3.7679" class="difflineminus">-{</span>
<a href="#l3.7680"></a><span id="l3.7680" class="difflineminus">-  if (m_imapMailFolderSink &amp;&amp; !m_lastProgressStringName.Equals(aMsgName))</span>
<a href="#l3.7681"></a><span id="l3.7681" class="difflineminus">-  {</span>
<a href="#l3.7682"></a><span id="l3.7682" class="difflineplus">+                                 m_progressExpectedNumber);</span>
<a href="#l3.7683"></a><span id="l3.7683" class="difflineplus">+    }</span>
<a href="#l3.7684"></a><span id="l3.7684" class="difflineplus">+  }</span>
<a href="#l3.7685"></a><span id="l3.7685" class="difflineplus">+}</span>
<a href="#l3.7686"></a><span id="l3.7686" class="difflineplus">+</span>
<a href="#l3.7687"></a><span id="l3.7687" class="difflineplus">+void nsImapProtocol::ProgressEventFunctionUsingName(const char *aMsgName) {</span>
<a href="#l3.7688"></a><span id="l3.7688" class="difflineplus">+  if (m_imapMailFolderSink &amp;&amp; !m_lastProgressStringName.Equals(aMsgName)) {</span>
<a href="#l3.7689"></a><span id="l3.7689">     m_imapMailFolderSink-&gt;ProgressStatusString(this, aMsgName, nullptr);</span>
<a href="#l3.7690"></a><span id="l3.7690">     m_lastProgressStringName.Assign(aMsgName);</span>
<a href="#l3.7691"></a><span id="l3.7691" class="difflineminus">-    // who's going to free this? Does ProgressStatusString complete synchronously?</span>
<a href="#l3.7692"></a><span id="l3.7692" class="difflineminus">-  }</span>
<a href="#l3.7693"></a><span id="l3.7693" class="difflineminus">-}</span>
<a href="#l3.7694"></a><span id="l3.7694" class="difflineminus">-</span>
<a href="#l3.7695"></a><span id="l3.7695" class="difflineminus">-void</span>
<a href="#l3.7696"></a><span id="l3.7696" class="difflineminus">-nsImapProtocol::ProgressEventFunctionUsingNameWithString(const char* aMsgName,</span>
<a href="#l3.7697"></a><span id="l3.7697" class="difflineminus">-                                                         const char * aExtraInfo)</span>
<a href="#l3.7698"></a><span id="l3.7698" class="difflineminus">-{</span>
<a href="#l3.7699"></a><span id="l3.7699" class="difflineminus">-  if (m_imapMailFolderSink)</span>
<a href="#l3.7700"></a><span id="l3.7700" class="difflineminus">-  {</span>
<a href="#l3.7701"></a><span id="l3.7701" class="difflineplus">+    // who's going to free this? Does ProgressStatusString complete</span>
<a href="#l3.7702"></a><span id="l3.7702" class="difflineplus">+    // synchronously?</span>
<a href="#l3.7703"></a><span id="l3.7703" class="difflineplus">+  }</span>
<a href="#l3.7704"></a><span id="l3.7704" class="difflineplus">+}</span>
<a href="#l3.7705"></a><span id="l3.7705" class="difflineplus">+</span>
<a href="#l3.7706"></a><span id="l3.7706" class="difflineplus">+void nsImapProtocol::ProgressEventFunctionUsingNameWithString(</span>
<a href="#l3.7707"></a><span id="l3.7707" class="difflineplus">+    const char *aMsgName, const char *aExtraInfo) {</span>
<a href="#l3.7708"></a><span id="l3.7708" class="difflineplus">+  if (m_imapMailFolderSink) {</span>
<a href="#l3.7709"></a><span id="l3.7709">     nsString unicodeStr;</span>
<a href="#l3.7710"></a><span id="l3.7710">     nsresult rv = CopyMUTF7toUTF16(nsDependentCString(aExtraInfo), unicodeStr);</span>
<a href="#l3.7711"></a><span id="l3.7711">     if (NS_SUCCEEDED(rv))</span>
<a href="#l3.7712"></a><span id="l3.7712" class="difflineminus">-      m_imapMailFolderSink-&gt;ProgressStatusString(this, aMsgName, unicodeStr.get());</span>
<a href="#l3.7713"></a><span id="l3.7713" class="difflineminus">-  }</span>
<a href="#l3.7714"></a><span id="l3.7714" class="difflineminus">-}</span>
<a href="#l3.7715"></a><span id="l3.7715" class="difflineminus">-</span>
<a href="#l3.7716"></a><span id="l3.7716" class="difflineminus">-void</span>
<a href="#l3.7717"></a><span id="l3.7717" class="difflineminus">-nsImapProtocol::PercentProgressUpdateEvent(const char16_t *message, int64_t currentProgress, int64_t maxProgress)</span>
<a href="#l3.7718"></a><span id="l3.7718" class="difflineminus">-{</span>
<a href="#l3.7719"></a><span id="l3.7719" class="difflineplus">+      m_imapMailFolderSink-&gt;ProgressStatusString(this, aMsgName,</span>
<a href="#l3.7720"></a><span id="l3.7720" class="difflineplus">+                                                 unicodeStr.get());</span>
<a href="#l3.7721"></a><span id="l3.7721" class="difflineplus">+  }</span>
<a href="#l3.7722"></a><span id="l3.7722" class="difflineplus">+}</span>
<a href="#l3.7723"></a><span id="l3.7723" class="difflineplus">+</span>
<a href="#l3.7724"></a><span id="l3.7724" class="difflineplus">+void nsImapProtocol::PercentProgressUpdateEvent(const char16_t *message,</span>
<a href="#l3.7725"></a><span id="l3.7725" class="difflineplus">+                                                int64_t currentProgress,</span>
<a href="#l3.7726"></a><span id="l3.7726" class="difflineplus">+                                                int64_t maxProgress) {</span>
<a href="#l3.7727"></a><span id="l3.7727">   int64_t nowMS = 0;</span>
<a href="#l3.7728"></a><span id="l3.7728">   int32_t percent = (100 * currentProgress) / maxProgress;</span>
<a href="#l3.7729"></a><span id="l3.7729">   if (percent == m_lastPercent)</span>
<a href="#l3.7730"></a><span id="l3.7730" class="difflineminus">-    return; // hasn't changed, right? So just return. Do we need to clear this anywhere?</span>
<a href="#l3.7731"></a><span id="l3.7731" class="difflineplus">+    return;  // hasn't changed, right? So just return. Do we need to clear this</span>
<a href="#l3.7732"></a><span id="l3.7732" class="difflineplus">+             // anywhere?</span>
<a href="#l3.7733"></a><span id="l3.7733"> </span>
<a href="#l3.7734"></a><span id="l3.7734">   if (percent &lt; 100)  // always need to do 100%</span>
<a href="#l3.7735"></a><span id="l3.7735">   {</span>
<a href="#l3.7736"></a><span id="l3.7736">     nowMS = PR_IntervalToMilliseconds(PR_IntervalNow());</span>
<a href="#l3.7737"></a><span id="l3.7737" class="difflineminus">-    if (nowMS - m_lastProgressTime &lt; 750)</span>
<a href="#l3.7738"></a><span id="l3.7738" class="difflineminus">-      return;</span>
<a href="#l3.7739"></a><span id="l3.7739" class="difflineplus">+    if (nowMS - m_lastProgressTime &lt; 750) return;</span>
<a href="#l3.7740"></a><span id="l3.7740">   }</span>
<a href="#l3.7741"></a><span id="l3.7741"> </span>
<a href="#l3.7742"></a><span id="l3.7742">   m_lastPercent = percent;</span>
<a href="#l3.7743"></a><span id="l3.7743">   m_lastProgressTime = nowMS;</span>
<a href="#l3.7744"></a><span id="l3.7744"> </span>
<a href="#l3.7745"></a><span id="l3.7745">   // set our max progress on the running URL</span>
<a href="#l3.7746"></a><span id="l3.7746" class="difflineminus">-  if (m_runningUrl)</span>
<a href="#l3.7747"></a><span id="l3.7747" class="difflineminus">-  {</span>
<a href="#l3.7748"></a><span id="l3.7748" class="difflineplus">+  if (m_runningUrl) {</span>
<a href="#l3.7749"></a><span id="l3.7749">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl(do_QueryInterface(m_runningUrl));</span>
<a href="#l3.7750"></a><span id="l3.7750">     mailnewsUrl-&gt;SetMaxProgress(maxProgress);</span>
<a href="#l3.7751"></a><span id="l3.7751">   }</span>
<a href="#l3.7752"></a><span id="l3.7752"> </span>
<a href="#l3.7753"></a><span id="l3.7753">   if (m_imapMailFolderSink)</span>
<a href="#l3.7754"></a><span id="l3.7754" class="difflineminus">-    m_imapMailFolderSink-&gt;PercentProgress(this, message, currentProgress, maxProgress);</span>
<a href="#l3.7755"></a><span id="l3.7755" class="difflineminus">-}</span>
<a href="#l3.7756"></a><span id="l3.7756" class="difflineminus">-</span>
<a href="#l3.7757"></a><span id="l3.7757" class="difflineminus">-  // imap commands issued by the parser</span>
<a href="#l3.7758"></a><span id="l3.7758" class="difflineminus">-void</span>
<a href="#l3.7759"></a><span id="l3.7759" class="difflineminus">-nsImapProtocol::Store(const nsCString &amp;messageList, const char * messageData,</span>
<a href="#l3.7760"></a><span id="l3.7760" class="difflineminus">-                      bool idsAreUid)</span>
<a href="#l3.7761"></a><span id="l3.7761" class="difflineminus">-{</span>
<a href="#l3.7762"></a><span id="l3.7762" class="difflineminus">-</span>
<a href="#l3.7763"></a><span id="l3.7763" class="difflineplus">+    m_imapMailFolderSink-&gt;PercentProgress(this, message, currentProgress,</span>
<a href="#l3.7764"></a><span id="l3.7764" class="difflineplus">+                                          maxProgress);</span>
<a href="#l3.7765"></a><span id="l3.7765" class="difflineplus">+}</span>
<a href="#l3.7766"></a><span id="l3.7766" class="difflineplus">+</span>
<a href="#l3.7767"></a><span id="l3.7767" class="difflineplus">+// imap commands issued by the parser</span>
<a href="#l3.7768"></a><span id="l3.7768" class="difflineplus">+void nsImapProtocol::Store(const nsCString &amp;messageList,</span>
<a href="#l3.7769"></a><span id="l3.7769" class="difflineplus">+                           const char *messageData, bool idsAreUid) {</span>
<a href="#l3.7770"></a><span id="l3.7770">   // turn messageList back into key array and then back into a message id list,</span>
<a href="#l3.7771"></a><span id="l3.7771">   // but use the flag state to handle ranges correctly.</span>
<a href="#l3.7772"></a><span id="l3.7772">   nsCString messageIdList;</span>
<a href="#l3.7773"></a><span id="l3.7773">   nsTArray&lt;nsMsgKey&gt; msgKeys;</span>
<a href="#l3.7774"></a><span id="l3.7774" class="difflineminus">-  if (idsAreUid)</span>
<a href="#l3.7775"></a><span id="l3.7775" class="difflineminus">-    ParseUidString(messageList.get(), msgKeys);</span>
<a href="#l3.7776"></a><span id="l3.7776" class="difflineplus">+  if (idsAreUid) ParseUidString(messageList.get(), msgKeys);</span>
<a href="#l3.7777"></a><span id="l3.7777"> </span>
<a href="#l3.7778"></a><span id="l3.7778">   int32_t msgCountLeft = msgKeys.Length();</span>
<a href="#l3.7779"></a><span id="l3.7779">   uint32_t msgsHandled = 0;</span>
<a href="#l3.7780"></a><span id="l3.7780" class="difflineminus">-  do</span>
<a href="#l3.7781"></a><span id="l3.7781" class="difflineminus">-  {</span>
<a href="#l3.7782"></a><span id="l3.7782" class="difflineplus">+  do {</span>
<a href="#l3.7783"></a><span id="l3.7783">     nsCString idString;</span>
<a href="#l3.7784"></a><span id="l3.7784"> </span>
<a href="#l3.7785"></a><span id="l3.7785">     uint32_t msgsToHandle = msgCountLeft;</span>
<a href="#l3.7786"></a><span id="l3.7786">     if (idsAreUid)</span>
<a href="#l3.7787"></a><span id="l3.7787" class="difflineminus">-      AllocateImapUidString(msgKeys.Elements() + msgsHandled, msgsToHandle, m_flagState, idString);  // 20 * 200</span>
<a href="#l3.7788"></a><span id="l3.7788" class="difflineplus">+      AllocateImapUidString(msgKeys.Elements() + msgsHandled, msgsToHandle,</span>
<a href="#l3.7789"></a><span id="l3.7789" class="difflineplus">+                            m_flagState, idString);  // 20 * 200</span>
<a href="#l3.7790"></a><span id="l3.7790">     else</span>
<a href="#l3.7791"></a><span id="l3.7791">       idString.Assign(messageList);</span>
<a href="#l3.7792"></a><span id="l3.7792"> </span>
<a href="#l3.7793"></a><span id="l3.7793" class="difflineminus">-</span>
<a href="#l3.7794"></a><span id="l3.7794">     msgsHandled += msgsToHandle;</span>
<a href="#l3.7795"></a><span id="l3.7795">     msgCountLeft -= msgsToHandle;</span>
<a href="#l3.7796"></a><span id="l3.7796"> </span>
<a href="#l3.7797"></a><span id="l3.7797">     IncrementCommandTagNumber();</span>
<a href="#l3.7798"></a><span id="l3.7798">     const char *formatString;</span>
<a href="#l3.7799"></a><span id="l3.7799">     if (idsAreUid)</span>
<a href="#l3.7800"></a><span id="l3.7800" class="difflineminus">-        formatString = &quot;%s uid store %s %s\015\012&quot;;</span>
<a href="#l3.7801"></a><span id="l3.7801" class="difflineplus">+      formatString = &quot;%s uid store %s %s\015\012&quot;;</span>
<a href="#l3.7802"></a><span id="l3.7802">     else</span>
<a href="#l3.7803"></a><span id="l3.7803" class="difflineminus">-        formatString = &quot;%s store %s %s\015\012&quot;;</span>
<a href="#l3.7804"></a><span id="l3.7804" class="difflineplus">+      formatString = &quot;%s store %s %s\015\012&quot;;</span>
<a href="#l3.7805"></a><span id="l3.7805"> </span>
<a href="#l3.7806"></a><span id="l3.7806">     // we might need to close this mailbox after this</span>
<a href="#l3.7807"></a><span id="l3.7807" class="difflineminus">-    m_closeNeededBeforeSelect = GetDeleteIsMoveToTrash() &amp;&amp;</span>
<a href="#l3.7808"></a><span id="l3.7808" class="difflineminus">-        (PL_strcasestr(messageData, &quot;\\Deleted&quot;));</span>
<a href="#l3.7809"></a><span id="l3.7809" class="difflineplus">+    m_closeNeededBeforeSelect =</span>
<a href="#l3.7810"></a><span id="l3.7810" class="difflineplus">+        GetDeleteIsMoveToTrash() &amp;&amp; (PL_strcasestr(messageData, &quot;\\Deleted&quot;));</span>
<a href="#l3.7811"></a><span id="l3.7811"> </span>
<a href="#l3.7812"></a><span id="l3.7812">     const char *commandTag = GetServerCommandTag();</span>
<a href="#l3.7813"></a><span id="l3.7813" class="difflineminus">-    int protocolStringSize = PL_strlen(formatString) +</span>
<a href="#l3.7814"></a><span id="l3.7814" class="difflineminus">-          messageList.Length() + PL_strlen(messageData) +</span>
<a href="#l3.7815"></a><span id="l3.7815" class="difflineminus">-          PL_strlen(commandTag) + 1;</span>
<a href="#l3.7816"></a><span id="l3.7816" class="difflineminus">-    char *protocolString = (char *) PR_CALLOC( protocolStringSize );</span>
<a href="#l3.7817"></a><span id="l3.7817" class="difflineminus">-</span>
<a href="#l3.7818"></a><span id="l3.7818" class="difflineminus">-    if (protocolString)</span>
<a href="#l3.7819"></a><span id="l3.7819" class="difflineminus">-    {</span>
<a href="#l3.7820"></a><span id="l3.7820" class="difflineminus">-      PR_snprintf(protocolString, // string to create</span>
<a href="#l3.7821"></a><span id="l3.7821" class="difflineminus">-                    protocolStringSize, // max size</span>
<a href="#l3.7822"></a><span id="l3.7822" class="difflineminus">-                    formatString, // format string</span>
<a href="#l3.7823"></a><span id="l3.7823" class="difflineminus">-                    commandTag, // command tag</span>
<a href="#l3.7824"></a><span id="l3.7824" class="difflineminus">-                    idString.get(),</span>
<a href="#l3.7825"></a><span id="l3.7825" class="difflineminus">-                    messageData);</span>
<a href="#l3.7826"></a><span id="l3.7826" class="difflineplus">+    int protocolStringSize = PL_strlen(formatString) + messageList.Length() +</span>
<a href="#l3.7827"></a><span id="l3.7827" class="difflineplus">+                             PL_strlen(messageData) + PL_strlen(commandTag) + 1;</span>
<a href="#l3.7828"></a><span id="l3.7828" class="difflineplus">+    char *protocolString = (char *)PR_CALLOC(protocolStringSize);</span>
<a href="#l3.7829"></a><span id="l3.7829" class="difflineplus">+</span>
<a href="#l3.7830"></a><span id="l3.7830" class="difflineplus">+    if (protocolString) {</span>
<a href="#l3.7831"></a><span id="l3.7831" class="difflineplus">+      PR_snprintf(protocolString,      // string to create</span>
<a href="#l3.7832"></a><span id="l3.7832" class="difflineplus">+                  protocolStringSize,  // max size</span>
<a href="#l3.7833"></a><span id="l3.7833" class="difflineplus">+                  formatString,        // format string</span>
<a href="#l3.7834"></a><span id="l3.7834" class="difflineplus">+                  commandTag,          // command tag</span>
<a href="#l3.7835"></a><span id="l3.7835" class="difflineplus">+                  idString.get(), messageData);</span>
<a href="#l3.7836"></a><span id="l3.7836"> </span>
<a href="#l3.7837"></a><span id="l3.7837">       nsresult rv = SendData(protocolString);</span>
<a href="#l3.7838"></a><span id="l3.7838" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l3.7839"></a><span id="l3.7839" class="difflineminus">-      {</span>
<a href="#l3.7840"></a><span id="l3.7840" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.7841"></a><span id="l3.7841">         m_flagChangeCount++;</span>
<a href="#l3.7842"></a><span id="l3.7842">         ParseIMAPandCheckForNewMail(protocolString);</span>
<a href="#l3.7843"></a><span id="l3.7843">         if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; CheckNeeded())</span>
<a href="#l3.7844"></a><span id="l3.7844">           Check();</span>
<a href="#l3.7845"></a><span id="l3.7845">       }</span>
<a href="#l3.7846"></a><span id="l3.7846">       PR_Free(protocolString);</span>
<a href="#l3.7847"></a><span id="l3.7847" class="difflineminus">-    }</span>
<a href="#l3.7848"></a><span id="l3.7848" class="difflineminus">-    else</span>
<a href="#l3.7849"></a><span id="l3.7849" class="difflineplus">+    } else</span>
<a href="#l3.7850"></a><span id="l3.7850">       HandleMemoryFailure();</span>
<a href="#l3.7851"></a><span id="l3.7851" class="difflineminus">-  }</span>
<a href="#l3.7852"></a><span id="l3.7852" class="difflineminus">-  while (msgCountLeft &gt; 0 &amp;&amp; !DeathSignalReceived());</span>
<a href="#l3.7853"></a><span id="l3.7853" class="difflineminus">-</span>
<a href="#l3.7854"></a><span id="l3.7854" class="difflineminus">-}</span>
<a href="#l3.7855"></a><span id="l3.7855" class="difflineminus">-</span>
<a href="#l3.7856"></a><span id="l3.7856" class="difflineminus">-void</span>
<a href="#l3.7857"></a><span id="l3.7857" class="difflineminus">-nsImapProtocol::IssueUserDefinedMsgCommand(const char *command, const char * messageList)</span>
<a href="#l3.7858"></a><span id="l3.7858" class="difflineminus">-{</span>
<a href="#l3.7859"></a><span id="l3.7859" class="difflineplus">+  } while (msgCountLeft &gt; 0 &amp;&amp; !DeathSignalReceived());</span>
<a href="#l3.7860"></a><span id="l3.7860" class="difflineplus">+}</span>
<a href="#l3.7861"></a><span id="l3.7861" class="difflineplus">+</span>
<a href="#l3.7862"></a><span id="l3.7862" class="difflineplus">+void nsImapProtocol::IssueUserDefinedMsgCommand(const char *command,</span>
<a href="#l3.7863"></a><span id="l3.7863" class="difflineplus">+                                                const char *messageList) {</span>
<a href="#l3.7864"></a><span id="l3.7864">   IncrementCommandTagNumber();</span>
<a href="#l3.7865"></a><span id="l3.7865"> </span>
<a href="#l3.7866"></a><span id="l3.7866">   const char *formatString;</span>
<a href="#l3.7867"></a><span id="l3.7867">   formatString = &quot;%s uid %s %s\015\012&quot;;</span>
<a href="#l3.7868"></a><span id="l3.7868"> </span>
<a href="#l3.7869"></a><span id="l3.7869">   const char *commandTag = GetServerCommandTag();</span>
<a href="#l3.7870"></a><span id="l3.7870" class="difflineminus">-  int protocolStringSize = PL_strlen(formatString) +</span>
<a href="#l3.7871"></a><span id="l3.7871" class="difflineminus">-        PL_strlen(messageList) + PL_strlen(command) +</span>
<a href="#l3.7872"></a><span id="l3.7872" class="difflineminus">-        PL_strlen(commandTag) + 1;</span>
<a href="#l3.7873"></a><span id="l3.7873" class="difflineminus">-  char *protocolString = (char *) PR_CALLOC( protocolStringSize );</span>
<a href="#l3.7874"></a><span id="l3.7874" class="difflineminus">-</span>
<a href="#l3.7875"></a><span id="l3.7875" class="difflineminus">-  if (protocolString)</span>
<a href="#l3.7876"></a><span id="l3.7876" class="difflineminus">-  {</span>
<a href="#l3.7877"></a><span id="l3.7877" class="difflineminus">-    PR_snprintf(protocolString, // string to create</span>
<a href="#l3.7878"></a><span id="l3.7878" class="difflineminus">-                  protocolStringSize, // max size</span>
<a href="#l3.7879"></a><span id="l3.7879" class="difflineminus">-                  formatString, // format string</span>
<a href="#l3.7880"></a><span id="l3.7880" class="difflineminus">-                  commandTag, // command tag</span>
<a href="#l3.7881"></a><span id="l3.7881" class="difflineminus">-                  command,</span>
<a href="#l3.7882"></a><span id="l3.7882" class="difflineminus">-                  messageList);</span>
<a href="#l3.7883"></a><span id="l3.7883" class="difflineplus">+  int protocolStringSize = PL_strlen(formatString) + PL_strlen(messageList) +</span>
<a href="#l3.7884"></a><span id="l3.7884" class="difflineplus">+                           PL_strlen(command) + PL_strlen(commandTag) + 1;</span>
<a href="#l3.7885"></a><span id="l3.7885" class="difflineplus">+  char *protocolString = (char *)PR_CALLOC(protocolStringSize);</span>
<a href="#l3.7886"></a><span id="l3.7886" class="difflineplus">+</span>
<a href="#l3.7887"></a><span id="l3.7887" class="difflineplus">+  if (protocolString) {</span>
<a href="#l3.7888"></a><span id="l3.7888" class="difflineplus">+    PR_snprintf(protocolString,      // string to create</span>
<a href="#l3.7889"></a><span id="l3.7889" class="difflineplus">+                protocolStringSize,  // max size</span>
<a href="#l3.7890"></a><span id="l3.7890" class="difflineplus">+                formatString,        // format string</span>
<a href="#l3.7891"></a><span id="l3.7891" class="difflineplus">+                commandTag,          // command tag</span>
<a href="#l3.7892"></a><span id="l3.7892" class="difflineplus">+                command, messageList);</span>
<a href="#l3.7893"></a><span id="l3.7893"> </span>
<a href="#l3.7894"></a><span id="l3.7894">     nsresult rv = SendData(protocolString);</span>
<a href="#l3.7895"></a><span id="l3.7895" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.7896"></a><span id="l3.7896" class="difflineminus">-      ParseIMAPandCheckForNewMail(protocolString);</span>
<a href="#l3.7897"></a><span id="l3.7897" class="difflineplus">+    if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(protocolString);</span>
<a href="#l3.7898"></a><span id="l3.7898">     PR_Free(protocolString);</span>
<a href="#l3.7899"></a><span id="l3.7899" class="difflineminus">-  }</span>
<a href="#l3.7900"></a><span id="l3.7900" class="difflineminus">-  else</span>
<a href="#l3.7901"></a><span id="l3.7901" class="difflineplus">+  } else</span>
<a href="#l3.7902"></a><span id="l3.7902">     HandleMemoryFailure();</span>
<a href="#l3.7903"></a><span id="l3.7903"> }</span>
<a href="#l3.7904"></a><span id="l3.7904"> </span>
<a href="#l3.7905"></a><span id="l3.7905" class="difflineminus">-void</span>
<a href="#l3.7906"></a><span id="l3.7906" class="difflineminus">-nsImapProtocol::UidExpunge(const nsCString &amp;messageSet)</span>
<a href="#l3.7907"></a><span id="l3.7907" class="difflineminus">-{</span>
<a href="#l3.7908"></a><span id="l3.7908" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.7909"></a><span id="l3.7909" class="difflineminus">-    nsCString command(GetServerCommandTag());</span>
<a href="#l3.7910"></a><span id="l3.7910" class="difflineminus">-    command.AppendLiteral(&quot; uid expunge &quot;);</span>
<a href="#l3.7911"></a><span id="l3.7911" class="difflineminus">-    command.Append(messageSet);</span>
<a href="#l3.7912"></a><span id="l3.7912" class="difflineminus">-    command.Append(CRLF);</span>
<a href="#l3.7913"></a><span id="l3.7913" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.7914"></a><span id="l3.7914" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.7915"></a><span id="l3.7915" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.7916"></a><span id="l3.7916" class="difflineminus">-}</span>
<a href="#l3.7917"></a><span id="l3.7917" class="difflineminus">-</span>
<a href="#l3.7918"></a><span id="l3.7918" class="difflineminus">-void</span>
<a href="#l3.7919"></a><span id="l3.7919" class="difflineminus">-nsImapProtocol::Expunge()</span>
<a href="#l3.7920"></a><span id="l3.7920" class="difflineminus">-{</span>
<a href="#l3.7921"></a><span id="l3.7921" class="difflineplus">+void nsImapProtocol::UidExpunge(const nsCString &amp;messageSet) {</span>
<a href="#l3.7922"></a><span id="l3.7922" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.7923"></a><span id="l3.7923" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.7924"></a><span id="l3.7924" class="difflineplus">+  command.AppendLiteral(&quot; uid expunge &quot;);</span>
<a href="#l3.7925"></a><span id="l3.7925" class="difflineplus">+  command.Append(messageSet);</span>
<a href="#l3.7926"></a><span id="l3.7926" class="difflineplus">+  command.Append(CRLF);</span>
<a href="#l3.7927"></a><span id="l3.7927" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.7928"></a><span id="l3.7928" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.7929"></a><span id="l3.7929" class="difflineplus">+}</span>
<a href="#l3.7930"></a><span id="l3.7930" class="difflineplus">+</span>
<a href="#l3.7931"></a><span id="l3.7931" class="difflineplus">+void nsImapProtocol::Expunge() {</span>
<a href="#l3.7932"></a><span id="l3.7932">   uint32_t aclFlags = 0;</span>
<a href="#l3.7933"></a><span id="l3.7933">   if (GetServerStateParser().ServerHasACLCapability() &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.7934"></a><span id="l3.7934">     m_imapMailFolderSink-&gt;GetAclFlags(&amp;aclFlags);</span>
<a href="#l3.7935"></a><span id="l3.7935"> </span>
<a href="#l3.7936"></a><span id="l3.7936" class="difflineminus">-  if (aclFlags &amp;&amp; !(aclFlags &amp; IMAP_ACL_EXPUNGE_FLAG))</span>
<a href="#l3.7937"></a><span id="l3.7937" class="difflineminus">-    return;</span>
<a href="#l3.7938"></a><span id="l3.7938" class="difflineplus">+  if (aclFlags &amp;&amp; !(aclFlags &amp; IMAP_ACL_EXPUNGE_FLAG)) return;</span>
<a href="#l3.7939"></a><span id="l3.7939">   ProgressEventFunctionUsingName(&quot;imapStatusExpungingMailbox&quot;);</span>
<a href="#l3.7940"></a><span id="l3.7940"> </span>
<a href="#l3.7941"></a><span id="l3.7941" class="difflineminus">-  if(gCheckDeletedBeforeExpunge)</span>
<a href="#l3.7942"></a><span id="l3.7942" class="difflineminus">-  {</span>
<a href="#l3.7943"></a><span id="l3.7943" class="difflineplus">+  if (gCheckDeletedBeforeExpunge) {</span>
<a href="#l3.7944"></a><span id="l3.7944">     GetServerStateParser().ResetSearchResultSequence();</span>
<a href="#l3.7945"></a><span id="l3.7945">     Search(&quot;SEARCH DELETED&quot;, false, false);</span>
<a href="#l3.7946"></a><span id="l3.7946" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.7947"></a><span id="l3.7947" class="difflineminus">-    {</span>
<a href="#l3.7948"></a><span id="l3.7948" class="difflineminus">-      nsImapSearchResultIterator *search = GetServerStateParser().CreateSearchResultIterator();</span>
<a href="#l3.7949"></a><span id="l3.7949" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.7950"></a><span id="l3.7950" class="difflineplus">+      nsImapSearchResultIterator *search =</span>
<a href="#l3.7951"></a><span id="l3.7951" class="difflineplus">+          GetServerStateParser().CreateSearchResultIterator();</span>
<a href="#l3.7952"></a><span id="l3.7952">       nsMsgKey key = search-&gt;GetNextMessageNumber();</span>
<a href="#l3.7953"></a><span id="l3.7953">       delete search;</span>
<a href="#l3.7954"></a><span id="l3.7954" class="difflineminus">-      if (key == 0)</span>
<a href="#l3.7955"></a><span id="l3.7955" class="difflineminus">-        return;  //no deleted messages to expunge (bug 235004)</span>
<a href="#l3.7956"></a><span id="l3.7956" class="difflineplus">+      if (key == 0) return;  // no deleted messages to expunge (bug 235004)</span>
<a href="#l3.7957"></a><span id="l3.7957">     }</span>
<a href="#l3.7958"></a><span id="l3.7958">   }</span>
<a href="#l3.7959"></a><span id="l3.7959"> </span>
<a href="#l3.7960"></a><span id="l3.7960">   IncrementCommandTagNumber();</span>
<a href="#l3.7961"></a><span id="l3.7961">   nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.7962"></a><span id="l3.7962">   command.AppendLiteral(&quot; expunge&quot; CRLF);</span>
<a href="#l3.7963"></a><span id="l3.7963"> </span>
<a href="#l3.7964"></a><span id="l3.7964">   nsresult rv = SendData(command.get());</span>
<a href="#l3.7965"></a><span id="l3.7965" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.7966"></a><span id="l3.7966" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.7967"></a><span id="l3.7967" class="difflineminus">-}</span>
<a href="#l3.7968"></a><span id="l3.7968" class="difflineminus">-</span>
<a href="#l3.7969"></a><span id="l3.7969" class="difflineminus">-void</span>
<a href="#l3.7970"></a><span id="l3.7970" class="difflineminus">-nsImapProtocol::HandleMemoryFailure()</span>
<a href="#l3.7971"></a><span id="l3.7971" class="difflineminus">-{</span>
<a href="#l3.7972"></a><span id="l3.7972" class="difflineminus">-    PR_CEnterMonitor(this);</span>
<a href="#l3.7973"></a><span id="l3.7973" class="difflineminus">-    // **** jefft fix me!!!!!! ******</span>
<a href="#l3.7974"></a><span id="l3.7974" class="difflineminus">-    // m_imapThreadIsRunning = false;</span>
<a href="#l3.7975"></a><span id="l3.7975" class="difflineminus">-    // SetConnectionStatus(-1);</span>
<a href="#l3.7976"></a><span id="l3.7976" class="difflineminus">-    PR_CExitMonitor(this);</span>
<a href="#l3.7977"></a><span id="l3.7977" class="difflineminus">-}</span>
<a href="#l3.7978"></a><span id="l3.7978" class="difflineminus">-</span>
<a href="#l3.7979"></a><span id="l3.7979" class="difflineminus">-void nsImapProtocol::HandleCurrentUrlError()</span>
<a href="#l3.7980"></a><span id="l3.7980" class="difflineminus">-{</span>
<a href="#l3.7981"></a><span id="l3.7981" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.7982"></a><span id="l3.7982" class="difflineplus">+}</span>
<a href="#l3.7983"></a><span id="l3.7983" class="difflineplus">+</span>
<a href="#l3.7984"></a><span id="l3.7984" class="difflineplus">+void nsImapProtocol::HandleMemoryFailure() {</span>
<a href="#l3.7985"></a><span id="l3.7985" class="difflineplus">+  PR_CEnterMonitor(this);</span>
<a href="#l3.7986"></a><span id="l3.7986" class="difflineplus">+  // **** jefft fix me!!!!!! ******</span>
<a href="#l3.7987"></a><span id="l3.7987" class="difflineplus">+  // m_imapThreadIsRunning = false;</span>
<a href="#l3.7988"></a><span id="l3.7988" class="difflineplus">+  // SetConnectionStatus(-1);</span>
<a href="#l3.7989"></a><span id="l3.7989" class="difflineplus">+  PR_CExitMonitor(this);</span>
<a href="#l3.7990"></a><span id="l3.7990" class="difflineplus">+}</span>
<a href="#l3.7991"></a><span id="l3.7991" class="difflineplus">+</span>
<a href="#l3.7992"></a><span id="l3.7992" class="difflineplus">+void nsImapProtocol::HandleCurrentUrlError() {</span>
<a href="#l3.7993"></a><span id="l3.7993">   // This is to handle a move/copy failing, especially because the user</span>
<a href="#l3.7994"></a><span id="l3.7994">   // cancelled the password prompt.</span>
<a href="#l3.7995"></a><span id="l3.7995" class="difflineminus">-  (void) m_runningUrl-&gt;GetImapAction(&amp;m_imapAction);</span>
<a href="#l3.7996"></a><span id="l3.7996" class="difflineminus">-    if (m_imapAction == nsIImapUrl::nsImapOfflineToOnlineMove || m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile</span>
<a href="#l3.7997"></a><span id="l3.7997" class="difflineminus">-      || m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile)</span>
<a href="#l3.7998"></a><span id="l3.7998" class="difflineminus">-  {</span>
<a href="#l3.7999"></a><span id="l3.7999" class="difflineplus">+  (void)m_runningUrl-&gt;GetImapAction(&amp;m_imapAction);</span>
<a href="#l3.8000"></a><span id="l3.8000" class="difflineplus">+  if (m_imapAction == nsIImapUrl::nsImapOfflineToOnlineMove ||</span>
<a href="#l3.8001"></a><span id="l3.8001" class="difflineplus">+      m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile ||</span>
<a href="#l3.8002"></a><span id="l3.8002" class="difflineplus">+      m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile) {</span>
<a href="#l3.8003"></a><span id="l3.8003">     if (m_imapMailFolderSink)</span>
<a href="#l3.8004"></a><span id="l3.8004" class="difflineminus">-      m_imapMailFolderSink-&gt;OnlineCopyCompleted(this, ImapOnlineCopyStateType::kFailedCopy);</span>
<a href="#l3.8005"></a><span id="l3.8005" class="difflineminus">-  }</span>
<a href="#l3.8006"></a><span id="l3.8006" class="difflineminus">-}</span>
<a href="#l3.8007"></a><span id="l3.8007" class="difflineminus">-</span>
<a href="#l3.8008"></a><span id="l3.8008" class="difflineminus">-void nsImapProtocol::StartTLS()</span>
<a href="#l3.8009"></a><span id="l3.8009" class="difflineminus">-{</span>
<a href="#l3.8010"></a><span id="l3.8010" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.8011"></a><span id="l3.8011" class="difflineminus">-    nsCString command(GetServerCommandTag());</span>
<a href="#l3.8012"></a><span id="l3.8012" class="difflineminus">-</span>
<a href="#l3.8013"></a><span id="l3.8013" class="difflineminus">-    command.AppendLiteral(&quot; STARTTLS&quot; CRLF);</span>
<a href="#l3.8014"></a><span id="l3.8014" class="difflineminus">-</span>
<a href="#l3.8015"></a><span id="l3.8015" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.8016"></a><span id="l3.8016" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8017"></a><span id="l3.8017" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8018"></a><span id="l3.8018" class="difflineminus">-}</span>
<a href="#l3.8019"></a><span id="l3.8019" class="difflineminus">-</span>
<a href="#l3.8020"></a><span id="l3.8020" class="difflineminus">-void nsImapProtocol::Capability()</span>
<a href="#l3.8021"></a><span id="l3.8021" class="difflineminus">-{</span>
<a href="#l3.8022"></a><span id="l3.8022" class="difflineminus">-</span>
<a href="#l3.8023"></a><span id="l3.8023" class="difflineminus">-    ProgressEventFunctionUsingName(&quot;imapStatusCheckCompat&quot;);</span>
<a href="#l3.8024"></a><span id="l3.8024" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.8025"></a><span id="l3.8025" class="difflineminus">-    nsCString command(GetServerCommandTag());</span>
<a href="#l3.8026"></a><span id="l3.8026" class="difflineminus">-</span>
<a href="#l3.8027"></a><span id="l3.8027" class="difflineminus">-    command.AppendLiteral(&quot; capability&quot; CRLF);</span>
<a href="#l3.8028"></a><span id="l3.8028" class="difflineminus">-</span>
<a href="#l3.8029"></a><span id="l3.8029" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.8030"></a><span id="l3.8030" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8031"></a><span id="l3.8031" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8032"></a><span id="l3.8032" class="difflineminus">-}</span>
<a href="#l3.8033"></a><span id="l3.8033" class="difflineminus">-</span>
<a href="#l3.8034"></a><span id="l3.8034" class="difflineminus">-void nsImapProtocol::ID()</span>
<a href="#l3.8035"></a><span id="l3.8035" class="difflineminus">-{</span>
<a href="#l3.8036"></a><span id="l3.8036" class="difflineminus">-  if (!gAppName[0])</span>
<a href="#l3.8037"></a><span id="l3.8037" class="difflineminus">-    return;</span>
<a href="#l3.8038"></a><span id="l3.8038" class="difflineplus">+      m_imapMailFolderSink-&gt;OnlineCopyCompleted(</span>
<a href="#l3.8039"></a><span id="l3.8039" class="difflineplus">+          this, ImapOnlineCopyStateType::kFailedCopy);</span>
<a href="#l3.8040"></a><span id="l3.8040" class="difflineplus">+  }</span>
<a href="#l3.8041"></a><span id="l3.8041" class="difflineplus">+}</span>
<a href="#l3.8042"></a><span id="l3.8042" class="difflineplus">+</span>
<a href="#l3.8043"></a><span id="l3.8043" class="difflineplus">+void nsImapProtocol::StartTLS() {</span>
<a href="#l3.8044"></a><span id="l3.8044" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.8045"></a><span id="l3.8045" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.8046"></a><span id="l3.8046" class="difflineplus">+</span>
<a href="#l3.8047"></a><span id="l3.8047" class="difflineplus">+  command.AppendLiteral(&quot; STARTTLS&quot; CRLF);</span>
<a href="#l3.8048"></a><span id="l3.8048" class="difflineplus">+</span>
<a href="#l3.8049"></a><span id="l3.8049" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.8050"></a><span id="l3.8050" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8051"></a><span id="l3.8051" class="difflineplus">+}</span>
<a href="#l3.8052"></a><span id="l3.8052" class="difflineplus">+</span>
<a href="#l3.8053"></a><span id="l3.8053" class="difflineplus">+void nsImapProtocol::Capability() {</span>
<a href="#l3.8054"></a><span id="l3.8054" class="difflineplus">+  ProgressEventFunctionUsingName(&quot;imapStatusCheckCompat&quot;);</span>
<a href="#l3.8055"></a><span id="l3.8055" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.8056"></a><span id="l3.8056" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.8057"></a><span id="l3.8057" class="difflineplus">+</span>
<a href="#l3.8058"></a><span id="l3.8058" class="difflineplus">+  command.AppendLiteral(&quot; capability&quot; CRLF);</span>
<a href="#l3.8059"></a><span id="l3.8059" class="difflineplus">+</span>
<a href="#l3.8060"></a><span id="l3.8060" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.8061"></a><span id="l3.8061" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8062"></a><span id="l3.8062" class="difflineplus">+}</span>
<a href="#l3.8063"></a><span id="l3.8063" class="difflineplus">+</span>
<a href="#l3.8064"></a><span id="l3.8064" class="difflineplus">+void nsImapProtocol::ID() {</span>
<a href="#l3.8065"></a><span id="l3.8065" class="difflineplus">+  if (!gAppName[0]) return;</span>
<a href="#l3.8066"></a><span id="l3.8066">   IncrementCommandTagNumber();</span>
<a href="#l3.8067"></a><span id="l3.8067">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.8068"></a><span id="l3.8068">   command.AppendLiteral(&quot; ID (\&quot;name\&quot; \&quot;&quot;);</span>
<a href="#l3.8069"></a><span id="l3.8069">   command.Append(gAppName);</span>
<a href="#l3.8070"></a><span id="l3.8070">   command.AppendLiteral(&quot;\&quot; \&quot;version\&quot; \&quot;&quot;);</span>
<a href="#l3.8071"></a><span id="l3.8071">   command.Append(gAppVersion);</span>
<a href="#l3.8072"></a><span id="l3.8072">   command.AppendLiteral(&quot;\&quot;)&quot; CRLF);</span>
<a href="#l3.8073"></a><span id="l3.8073"> </span>
<a href="#l3.8074"></a><span id="l3.8074">   nsresult rv = SendData(command.get());</span>
<a href="#l3.8075"></a><span id="l3.8075" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8076"></a><span id="l3.8076" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8077"></a><span id="l3.8077" class="difflineminus">-}</span>
<a href="#l3.8078"></a><span id="l3.8078" class="difflineminus">-</span>
<a href="#l3.8079"></a><span id="l3.8079" class="difflineminus">-void nsImapProtocol::EnableCondStore()</span>
<a href="#l3.8080"></a><span id="l3.8080" class="difflineminus">-{</span>
<a href="#l3.8081"></a><span id="l3.8081" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8082"></a><span id="l3.8082" class="difflineplus">+}</span>
<a href="#l3.8083"></a><span id="l3.8083" class="difflineplus">+</span>
<a href="#l3.8084"></a><span id="l3.8084" class="difflineplus">+void nsImapProtocol::EnableCondStore() {</span>
<a href="#l3.8085"></a><span id="l3.8085">   IncrementCommandTagNumber();</span>
<a href="#l3.8086"></a><span id="l3.8086">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.8087"></a><span id="l3.8087"> </span>
<a href="#l3.8088"></a><span id="l3.8088">   command.AppendLiteral(&quot; ENABLE CONDSTORE&quot; CRLF);</span>
<a href="#l3.8089"></a><span id="l3.8089"> </span>
<a href="#l3.8090"></a><span id="l3.8090">   nsresult rv = SendData(command.get());</span>
<a href="#l3.8091"></a><span id="l3.8091" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8092"></a><span id="l3.8092" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8093"></a><span id="l3.8093" class="difflineminus">-}</span>
<a href="#l3.8094"></a><span id="l3.8094" class="difflineminus">-</span>
<a href="#l3.8095"></a><span id="l3.8095" class="difflineminus">-void nsImapProtocol::StartCompressDeflate()</span>
<a href="#l3.8096"></a><span id="l3.8096" class="difflineminus">-{</span>
<a href="#l3.8097"></a><span id="l3.8097" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8098"></a><span id="l3.8098" class="difflineplus">+}</span>
<a href="#l3.8099"></a><span id="l3.8099" class="difflineplus">+</span>
<a href="#l3.8100"></a><span id="l3.8100" class="difflineplus">+void nsImapProtocol::StartCompressDeflate() {</span>
<a href="#l3.8101"></a><span id="l3.8101">   // only issue a compression request if we haven't already</span>
<a href="#l3.8102"></a><span id="l3.8102" class="difflineminus">-  if (!TestFlag(IMAP_ISSUED_COMPRESS_REQUEST))</span>
<a href="#l3.8103"></a><span id="l3.8103" class="difflineminus">-  {</span>
<a href="#l3.8104"></a><span id="l3.8104" class="difflineplus">+  if (!TestFlag(IMAP_ISSUED_COMPRESS_REQUEST)) {</span>
<a href="#l3.8105"></a><span id="l3.8105">     SetFlag(IMAP_ISSUED_COMPRESS_REQUEST);</span>
<a href="#l3.8106"></a><span id="l3.8106">     IncrementCommandTagNumber();</span>
<a href="#l3.8107"></a><span id="l3.8107">     nsCString command(GetServerCommandTag());</span>
<a href="#l3.8108"></a><span id="l3.8108"> </span>
<a href="#l3.8109"></a><span id="l3.8109">     command.AppendLiteral(&quot; COMPRESS DEFLATE&quot; CRLF);</span>
<a href="#l3.8110"></a><span id="l3.8110"> </span>
<a href="#l3.8111"></a><span id="l3.8111">     nsresult rv = SendData(command.get());</span>
<a href="#l3.8112"></a><span id="l3.8112" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8113"></a><span id="l3.8113" class="difflineminus">-    {</span>
<a href="#l3.8114"></a><span id="l3.8114" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.8115"></a><span id="l3.8115">       ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8116"></a><span id="l3.8116" class="difflineminus">-      if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8117"></a><span id="l3.8117" class="difflineminus">-      {</span>
<a href="#l3.8118"></a><span id="l3.8118" class="difflineplus">+      if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8119"></a><span id="l3.8119">         rv = BeginCompressing();</span>
<a href="#l3.8120"></a><span id="l3.8120" class="difflineminus">-        if (NS_FAILED(rv))</span>
<a href="#l3.8121"></a><span id="l3.8121" class="difflineminus">-        {</span>
<a href="#l3.8122"></a><span id="l3.8122" class="difflineplus">+        if (NS_FAILED(rv)) {</span>
<a href="#l3.8123"></a><span id="l3.8123">           Log(&quot;CompressDeflate&quot;, nullptr, &quot;failed to enable compression&quot;);</span>
<a href="#l3.8124"></a><span id="l3.8124">           // we can't use this connection without compression any more, so die</span>
<a href="#l3.8125"></a><span id="l3.8125">           ClearFlag(IMAP_CONNECTION_IS_OPEN);</span>
<a href="#l3.8126"></a><span id="l3.8126">           TellThreadToDie();</span>
<a href="#l3.8127"></a><span id="l3.8127">           SetConnectionStatus(rv);</span>
<a href="#l3.8128"></a><span id="l3.8128">           return;</span>
<a href="#l3.8129"></a><span id="l3.8129">         }</span>
<a href="#l3.8130"></a><span id="l3.8130">       }</span>
<a href="#l3.8131"></a><span id="l3.8131">     }</span>
<a href="#l3.8132"></a><span id="l3.8132">   }</span>
<a href="#l3.8133"></a><span id="l3.8133"> }</span>
<a href="#l3.8134"></a><span id="l3.8134"> </span>
<a href="#l3.8135"></a><span id="l3.8135" class="difflineminus">-nsresult nsImapProtocol::BeginCompressing()</span>
<a href="#l3.8136"></a><span id="l3.8136" class="difflineminus">-{</span>
<a href="#l3.8137"></a><span id="l3.8137" class="difflineplus">+nsresult nsImapProtocol::BeginCompressing() {</span>
<a href="#l3.8138"></a><span id="l3.8138">   // wrap the streams in compression layers that compress or decompress</span>
<a href="#l3.8139"></a><span id="l3.8139">   // all traffic.</span>
<a href="#l3.8140"></a><span id="l3.8140">   RefPtr&lt;nsMsgCompressIStream&gt; new_in = new nsMsgCompressIStream();</span>
<a href="#l3.8141"></a><span id="l3.8141" class="difflineminus">-  if (!new_in)</span>
<a href="#l3.8142"></a><span id="l3.8142" class="difflineminus">-    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.8143"></a><span id="l3.8143" class="difflineplus">+  if (!new_in) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.8144"></a><span id="l3.8144"> </span>
<a href="#l3.8145"></a><span id="l3.8145">   nsresult rv = new_in-&gt;InitInputStream(m_inputStream);</span>
<a href="#l3.8146"></a><span id="l3.8146">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8147"></a><span id="l3.8147"> </span>
<a href="#l3.8148"></a><span id="l3.8148">   m_inputStream = new_in;</span>
<a href="#l3.8149"></a><span id="l3.8149"> </span>
<a href="#l3.8150"></a><span id="l3.8150">   RefPtr&lt;nsMsgCompressOStream&gt; new_out = new nsMsgCompressOStream();</span>
<a href="#l3.8151"></a><span id="l3.8151" class="difflineminus">-  if (!new_out)</span>
<a href="#l3.8152"></a><span id="l3.8152" class="difflineminus">-    return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.8153"></a><span id="l3.8153" class="difflineplus">+  if (!new_out) return NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.8154"></a><span id="l3.8154"> </span>
<a href="#l3.8155"></a><span id="l3.8155">   rv = new_out-&gt;InitOutputStream(m_outputStream);</span>
<a href="#l3.8156"></a><span id="l3.8156">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8157"></a><span id="l3.8157"> </span>
<a href="#l3.8158"></a><span id="l3.8158">   m_outputStream = new_out;</span>
<a href="#l3.8159"></a><span id="l3.8159">   return rv;</span>
<a href="#l3.8160"></a><span id="l3.8160"> }</span>
<a href="#l3.8161"></a><span id="l3.8161"> </span>
<a href="#l3.8162"></a><span id="l3.8162" class="difflineminus">-void nsImapProtocol::Language()</span>
<a href="#l3.8163"></a><span id="l3.8163" class="difflineminus">-{</span>
<a href="#l3.8164"></a><span id="l3.8164" class="difflineplus">+void nsImapProtocol::Language() {</span>
<a href="#l3.8165"></a><span id="l3.8165">   // only issue the language request if we haven't done so already...</span>
<a href="#l3.8166"></a><span id="l3.8166" class="difflineminus">-  if (!TestFlag(IMAP_ISSUED_LANGUAGE_REQUEST))</span>
<a href="#l3.8167"></a><span id="l3.8167" class="difflineminus">-  {</span>
<a href="#l3.8168"></a><span id="l3.8168" class="difflineplus">+  if (!TestFlag(IMAP_ISSUED_LANGUAGE_REQUEST)) {</span>
<a href="#l3.8169"></a><span id="l3.8169">     SetFlag(IMAP_ISSUED_LANGUAGE_REQUEST);</span>
<a href="#l3.8170"></a><span id="l3.8170">     ProgressEventFunctionUsingName(&quot;imapStatusCheckCompat&quot;);</span>
<a href="#l3.8171"></a><span id="l3.8171">     IncrementCommandTagNumber();</span>
<a href="#l3.8172"></a><span id="l3.8172">     nsCString command(GetServerCommandTag());</span>
<a href="#l3.8173"></a><span id="l3.8173"> </span>
<a href="#l3.8174"></a><span id="l3.8174">     // extract the desired language attribute from prefs</span>
<a href="#l3.8175"></a><span id="l3.8175">     nsresult rv = NS_OK;</span>
<a href="#l3.8176"></a><span id="l3.8176"> </span>
<a href="#l3.8177"></a><span id="l3.8177" class="difflineminus">-    // we need to parse out the first language out of this comma separated list....</span>
<a href="#l3.8178"></a><span id="l3.8178" class="difflineminus">-    // i.e if we have en,ja we only want to send en to the server.</span>
<a href="#l3.8179"></a><span id="l3.8179" class="difflineminus">-    if (mAcceptLanguages.get())</span>
<a href="#l3.8180"></a><span id="l3.8180" class="difflineminus">-    {</span>
<a href="#l3.8181"></a><span id="l3.8181" class="difflineplus">+    // we need to parse out the first language out of this comma separated</span>
<a href="#l3.8182"></a><span id="l3.8182" class="difflineplus">+    // list.... i.e if we have en,ja we only want to send en to the server.</span>
<a href="#l3.8183"></a><span id="l3.8183" class="difflineplus">+    if (mAcceptLanguages.get()) {</span>
<a href="#l3.8184"></a><span id="l3.8184">       nsAutoCString extractedLanguage;</span>
<a href="#l3.8185"></a><span id="l3.8185">       LossyCopyUTF16toASCII(mAcceptLanguages, extractedLanguage);</span>
<a href="#l3.8186"></a><span id="l3.8186">       int32_t pos = extractedLanguage.FindChar(',');</span>
<a href="#l3.8187"></a><span id="l3.8187" class="difflineminus">-      if (pos &gt; 0) // we have a comma separated list of languages...</span>
<a href="#l3.8188"></a><span id="l3.8188" class="difflineminus">-        extractedLanguage.SetLength(pos); // truncate everything after the first comma (including the comma)</span>
<a href="#l3.8189"></a><span id="l3.8189" class="difflineminus">-</span>
<a href="#l3.8190"></a><span id="l3.8190" class="difflineminus">-      if (extractedLanguage.IsEmpty())</span>
<a href="#l3.8191"></a><span id="l3.8191" class="difflineminus">-        return;</span>
<a href="#l3.8192"></a><span id="l3.8192" class="difflineplus">+      if (pos &gt; 0)  // we have a comma separated list of languages...</span>
<a href="#l3.8193"></a><span id="l3.8193" class="difflineplus">+        extractedLanguage.SetLength(pos);  // truncate everything after the</span>
<a href="#l3.8194"></a><span id="l3.8194" class="difflineplus">+                                           // first comma (including the comma)</span>
<a href="#l3.8195"></a><span id="l3.8195" class="difflineplus">+</span>
<a href="#l3.8196"></a><span id="l3.8196" class="difflineplus">+      if (extractedLanguage.IsEmpty()) return;</span>
<a href="#l3.8197"></a><span id="l3.8197"> </span>
<a href="#l3.8198"></a><span id="l3.8198">       command.AppendLiteral(&quot; LANGUAGE &quot;);</span>
<a href="#l3.8199"></a><span id="l3.8199">       command.Append(extractedLanguage);</span>
<a href="#l3.8200"></a><span id="l3.8200">       command.Append(CRLF);</span>
<a href="#l3.8201"></a><span id="l3.8201"> </span>
<a href="#l3.8202"></a><span id="l3.8202">       rv = SendData(command.get());</span>
<a href="#l3.8203"></a><span id="l3.8203">       if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8204"></a><span id="l3.8204">         ParseIMAPandCheckForNewMail(nullptr, true /* ignore bad or no result from the server for this command */);</span>
<a href="#l3.8205"></a><span id="l3.8205">     }</span>
<a href="#l3.8206"></a><span id="l3.8206">   }</span>
<a href="#l3.8207"></a><span id="l3.8207"> }</span>
<a href="#l3.8208"></a><span id="l3.8208"> </span>
<a href="#l3.8209"></a><span id="l3.8209" class="difflineminus">-void nsImapProtocol::EscapeUserNamePasswordString(const char *strToEscape, nsCString *resultStr)</span>
<a href="#l3.8210"></a><span id="l3.8210" class="difflineminus">-{</span>
<a href="#l3.8211"></a><span id="l3.8211" class="difflineminus">-  if (strToEscape)</span>
<a href="#l3.8212"></a><span id="l3.8212" class="difflineminus">-  {</span>
<a href="#l3.8213"></a><span id="l3.8213" class="difflineplus">+void nsImapProtocol::EscapeUserNamePasswordString(const char *strToEscape,</span>
<a href="#l3.8214"></a><span id="l3.8214" class="difflineplus">+                                                  nsCString *resultStr) {</span>
<a href="#l3.8215"></a><span id="l3.8215" class="difflineplus">+  if (strToEscape) {</span>
<a href="#l3.8216"></a><span id="l3.8216">     uint32_t i = 0;</span>
<a href="#l3.8217"></a><span id="l3.8217">     uint32_t escapeStrlen = strlen(strToEscape);</span>
<a href="#l3.8218"></a><span id="l3.8218" class="difflineminus">-    for (i=0; i&lt;escapeStrlen; i++)</span>
<a href="#l3.8219"></a><span id="l3.8219" class="difflineminus">-    {</span>
<a href="#l3.8220"></a><span id="l3.8220" class="difflineminus">-        if (strToEscape[i] == '\\' || strToEscape[i] == '\&quot;')</span>
<a href="#l3.8221"></a><span id="l3.8221" class="difflineminus">-        {</span>
<a href="#l3.8222"></a><span id="l3.8222" class="difflineminus">-            resultStr-&gt;Append('\\');</span>
<a href="#l3.8223"></a><span id="l3.8223" class="difflineminus">-        }</span>
<a href="#l3.8224"></a><span id="l3.8224" class="difflineminus">-        resultStr-&gt;Append(strToEscape[i]);</span>
<a href="#l3.8225"></a><span id="l3.8225" class="difflineplus">+    for (i = 0; i &lt; escapeStrlen; i++) {</span>
<a href="#l3.8226"></a><span id="l3.8226" class="difflineplus">+      if (strToEscape[i] == '\\' || strToEscape[i] == '\&quot;') {</span>
<a href="#l3.8227"></a><span id="l3.8227" class="difflineplus">+        resultStr-&gt;Append('\\');</span>
<a href="#l3.8228"></a><span id="l3.8228" class="difflineplus">+      }</span>
<a href="#l3.8229"></a><span id="l3.8229" class="difflineplus">+      resultStr-&gt;Append(strToEscape[i]);</span>
<a href="#l3.8230"></a><span id="l3.8230">     }</span>
<a href="#l3.8231"></a><span id="l3.8231">   }</span>
<a href="#l3.8232"></a><span id="l3.8232"> }</span>
<a href="#l3.8233"></a><span id="l3.8233"> </span>
<a href="#l3.8234"></a><span id="l3.8234"> void nsImapProtocol::InitPrefAuthMethods(int32_t authMethodPrefValue,</span>
<a href="#l3.8235"></a><span id="l3.8235" class="difflineminus">-                                         nsIMsgIncomingServer *aServer)</span>
<a href="#l3.8236"></a><span id="l3.8236" class="difflineminus">-{</span>
<a href="#l3.8237"></a><span id="l3.8237" class="difflineminus">-    // for m_prefAuthMethods, using the same flags as server capabilities.</span>
<a href="#l3.8238"></a><span id="l3.8238" class="difflineminus">-    switch (authMethodPrefValue)</span>
<a href="#l3.8239"></a><span id="l3.8239" class="difflineminus">-    {</span>
<a href="#l3.8240"></a><span id="l3.8240" class="difflineminus">-      case nsMsgAuthMethod::none:</span>
<a href="#l3.8241"></a><span id="l3.8241" class="difflineminus">-        m_prefAuthMethods = kHasAuthNoneCapability;</span>
<a href="#l3.8242"></a><span id="l3.8242" class="difflineminus">-        break;</span>
<a href="#l3.8243"></a><span id="l3.8243" class="difflineminus">-      case nsMsgAuthMethod::old:</span>
<a href="#l3.8244"></a><span id="l3.8244" class="difflineminus">-        m_prefAuthMethods = kHasAuthOldLoginCapability;</span>
<a href="#l3.8245"></a><span id="l3.8245" class="difflineminus">-        break;</span>
<a href="#l3.8246"></a><span id="l3.8246" class="difflineminus">-      case nsMsgAuthMethod::passwordCleartext:</span>
<a href="#l3.8247"></a><span id="l3.8247" class="difflineminus">-        m_prefAuthMethods = kHasAuthOldLoginCapability |</span>
<a href="#l3.8248"></a><span id="l3.8248" class="difflineminus">-            kHasAuthLoginCapability | kHasAuthPlainCapability;</span>
<a href="#l3.8249"></a><span id="l3.8249" class="difflineminus">-        break;</span>
<a href="#l3.8250"></a><span id="l3.8250" class="difflineminus">-      case nsMsgAuthMethod::passwordEncrypted:</span>
<a href="#l3.8251"></a><span id="l3.8251" class="difflineminus">-        m_prefAuthMethods = kHasCRAMCapability;</span>
<a href="#l3.8252"></a><span id="l3.8252" class="difflineminus">-        break;</span>
<a href="#l3.8253"></a><span id="l3.8253" class="difflineminus">-      case nsMsgAuthMethod::NTLM:</span>
<a href="#l3.8254"></a><span id="l3.8254" class="difflineminus">-        m_prefAuthMethods = kHasAuthNTLMCapability | kHasAuthMSNCapability;</span>
<a href="#l3.8255"></a><span id="l3.8255" class="difflineminus">-        break;</span>
<a href="#l3.8256"></a><span id="l3.8256" class="difflineminus">-      case nsMsgAuthMethod::GSSAPI:</span>
<a href="#l3.8257"></a><span id="l3.8257" class="difflineminus">-        m_prefAuthMethods = kHasAuthGssApiCapability;</span>
<a href="#l3.8258"></a><span id="l3.8258" class="difflineminus">-        break;</span>
<a href="#l3.8259"></a><span id="l3.8259" class="difflineminus">-      case nsMsgAuthMethod::External:</span>
<a href="#l3.8260"></a><span id="l3.8260" class="difflineminus">-        m_prefAuthMethods = kHasAuthExternalCapability;</span>
<a href="#l3.8261"></a><span id="l3.8261" class="difflineminus">-        break;</span>
<a href="#l3.8262"></a><span id="l3.8262" class="difflineminus">-      case nsMsgAuthMethod::secure:</span>
<a href="#l3.8263"></a><span id="l3.8263" class="difflineminus">-        m_prefAuthMethods = kHasCRAMCapability |</span>
<a href="#l3.8264"></a><span id="l3.8264" class="difflineminus">-            kHasAuthGssApiCapability |</span>
<a href="#l3.8265"></a><span id="l3.8265" class="difflineminus">-            kHasAuthNTLMCapability | kHasAuthMSNCapability;</span>
<a href="#l3.8266"></a><span id="l3.8266" class="difflineminus">-        break;</span>
<a href="#l3.8267"></a><span id="l3.8267" class="difflineminus">-      default:</span>
<a href="#l3.8268"></a><span id="l3.8268" class="difflineminus">-        NS_ASSERTION(false, &quot;IMAP: authMethod pref invalid&quot;);</span>
<a href="#l3.8269"></a><span id="l3.8269" class="difflineminus">-        // TODO log to error console</span>
<a href="#l3.8270"></a><span id="l3.8270" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Error,</span>
<a href="#l3.8271"></a><span id="l3.8271" class="difflineminus">-            (&quot;IMAP: bad pref authMethod = %d&quot;, authMethodPrefValue));</span>
<a href="#l3.8272"></a><span id="l3.8272" class="difflineminus">-        // fall to any</span>
<a href="#l3.8273"></a><span id="l3.8273" class="difflineminus">-        MOZ_FALLTHROUGH;</span>
<a href="#l3.8274"></a><span id="l3.8274" class="difflineminus">-      case nsMsgAuthMethod::anything:</span>
<a href="#l3.8275"></a><span id="l3.8275" class="difflineminus">-        m_prefAuthMethods = kHasAuthOldLoginCapability |</span>
<a href="#l3.8276"></a><span id="l3.8276" class="difflineminus">-            kHasAuthLoginCapability | kHasAuthPlainCapability |</span>
<a href="#l3.8277"></a><span id="l3.8277" class="difflineminus">-            kHasCRAMCapability | kHasAuthGssApiCapability |</span>
<a href="#l3.8278"></a><span id="l3.8278" class="difflineminus">-            kHasAuthNTLMCapability | kHasAuthMSNCapability |</span>
<a href="#l3.8279"></a><span id="l3.8279" class="difflineminus">-            kHasAuthExternalCapability | kHasXOAuth2Capability;</span>
<a href="#l3.8280"></a><span id="l3.8280" class="difflineminus">-        break;</span>
<a href="#l3.8281"></a><span id="l3.8281" class="difflineminus">-      case nsMsgAuthMethod::OAuth2:</span>
<a href="#l3.8282"></a><span id="l3.8282" class="difflineminus">-        m_prefAuthMethods = kHasXOAuth2Capability;</span>
<a href="#l3.8283"></a><span id="l3.8283" class="difflineminus">-        break;</span>
<a href="#l3.8284"></a><span id="l3.8284" class="difflineminus">-    }</span>
<a href="#l3.8285"></a><span id="l3.8285" class="difflineminus">-</span>
<a href="#l3.8286"></a><span id="l3.8286" class="difflineminus">-    if (m_prefAuthMethods &amp; kHasXOAuth2Capability)</span>
<a href="#l3.8287"></a><span id="l3.8287" class="difflineminus">-      mOAuth2Support = new mozilla::mailnews::OAuth2ThreadHelper(aServer);</span>
<a href="#l3.8288"></a><span id="l3.8288" class="difflineminus">-</span>
<a href="#l3.8289"></a><span id="l3.8289" class="difflineminus">-    // Disable OAuth2 support if we don't have the prefs installed.</span>
<a href="#l3.8290"></a><span id="l3.8290" class="difflineminus">-    if (m_prefAuthMethods &amp; kHasXOAuth2Capability &amp;&amp;</span>
<a href="#l3.8291"></a><span id="l3.8291" class="difflineminus">-        (!mOAuth2Support || !mOAuth2Support-&gt;SupportsOAuth2()))</span>
<a href="#l3.8292"></a><span id="l3.8292" class="difflineminus">-      m_prefAuthMethods &amp;= ~kHasXOAuth2Capability;</span>
<a href="#l3.8293"></a><span id="l3.8293" class="difflineminus">-</span>
<a href="#l3.8294"></a><span id="l3.8294" class="difflineminus">-    NS_ASSERTION(m_prefAuthMethods != kCapabilityUndefined,</span>
<a href="#l3.8295"></a><span id="l3.8295" class="difflineminus">-         &quot;IMAP: InitPrefAuthMethods() didn't work&quot;);</span>
<a href="#l3.8296"></a><span id="l3.8296" class="difflineplus">+                                         nsIMsgIncomingServer *aServer) {</span>
<a href="#l3.8297"></a><span id="l3.8297" class="difflineplus">+  // for m_prefAuthMethods, using the same flags as server capabilities.</span>
<a href="#l3.8298"></a><span id="l3.8298" class="difflineplus">+  switch (authMethodPrefValue) {</span>
<a href="#l3.8299"></a><span id="l3.8299" class="difflineplus">+    case nsMsgAuthMethod::none:</span>
<a href="#l3.8300"></a><span id="l3.8300" class="difflineplus">+      m_prefAuthMethods = kHasAuthNoneCapability;</span>
<a href="#l3.8301"></a><span id="l3.8301" class="difflineplus">+      break;</span>
<a href="#l3.8302"></a><span id="l3.8302" class="difflineplus">+    case nsMsgAuthMethod::old:</span>
<a href="#l3.8303"></a><span id="l3.8303" class="difflineplus">+      m_prefAuthMethods = kHasAuthOldLoginCapability;</span>
<a href="#l3.8304"></a><span id="l3.8304" class="difflineplus">+      break;</span>
<a href="#l3.8305"></a><span id="l3.8305" class="difflineplus">+    case nsMsgAuthMethod::passwordCleartext:</span>
<a href="#l3.8306"></a><span id="l3.8306" class="difflineplus">+      m_prefAuthMethods = kHasAuthOldLoginCapability | kHasAuthLoginCapability |</span>
<a href="#l3.8307"></a><span id="l3.8307" class="difflineplus">+                          kHasAuthPlainCapability;</span>
<a href="#l3.8308"></a><span id="l3.8308" class="difflineplus">+      break;</span>
<a href="#l3.8309"></a><span id="l3.8309" class="difflineplus">+    case nsMsgAuthMethod::passwordEncrypted:</span>
<a href="#l3.8310"></a><span id="l3.8310" class="difflineplus">+      m_prefAuthMethods = kHasCRAMCapability;</span>
<a href="#l3.8311"></a><span id="l3.8311" class="difflineplus">+      break;</span>
<a href="#l3.8312"></a><span id="l3.8312" class="difflineplus">+    case nsMsgAuthMethod::NTLM:</span>
<a href="#l3.8313"></a><span id="l3.8313" class="difflineplus">+      m_prefAuthMethods = kHasAuthNTLMCapability | kHasAuthMSNCapability;</span>
<a href="#l3.8314"></a><span id="l3.8314" class="difflineplus">+      break;</span>
<a href="#l3.8315"></a><span id="l3.8315" class="difflineplus">+    case nsMsgAuthMethod::GSSAPI:</span>
<a href="#l3.8316"></a><span id="l3.8316" class="difflineplus">+      m_prefAuthMethods = kHasAuthGssApiCapability;</span>
<a href="#l3.8317"></a><span id="l3.8317" class="difflineplus">+      break;</span>
<a href="#l3.8318"></a><span id="l3.8318" class="difflineplus">+    case nsMsgAuthMethod::External:</span>
<a href="#l3.8319"></a><span id="l3.8319" class="difflineplus">+      m_prefAuthMethods = kHasAuthExternalCapability;</span>
<a href="#l3.8320"></a><span id="l3.8320" class="difflineplus">+      break;</span>
<a href="#l3.8321"></a><span id="l3.8321" class="difflineplus">+    case nsMsgAuthMethod::secure:</span>
<a href="#l3.8322"></a><span id="l3.8322" class="difflineplus">+      m_prefAuthMethods = kHasCRAMCapability | kHasAuthGssApiCapability |</span>
<a href="#l3.8323"></a><span id="l3.8323" class="difflineplus">+                          kHasAuthNTLMCapability | kHasAuthMSNCapability;</span>
<a href="#l3.8324"></a><span id="l3.8324" class="difflineplus">+      break;</span>
<a href="#l3.8325"></a><span id="l3.8325" class="difflineplus">+    default:</span>
<a href="#l3.8326"></a><span id="l3.8326" class="difflineplus">+      NS_ASSERTION(false, &quot;IMAP: authMethod pref invalid&quot;);</span>
<a href="#l3.8327"></a><span id="l3.8327" class="difflineplus">+      // TODO log to error console</span>
<a href="#l3.8328"></a><span id="l3.8328" class="difflineplus">+      MOZ_LOG(IMAP, LogLevel::Error,</span>
<a href="#l3.8329"></a><span id="l3.8329" class="difflineplus">+              (&quot;IMAP: bad pref authMethod = %d&quot;, authMethodPrefValue));</span>
<a href="#l3.8330"></a><span id="l3.8330" class="difflineplus">+      // fall to any</span>
<a href="#l3.8331"></a><span id="l3.8331" class="difflineplus">+      MOZ_FALLTHROUGH;</span>
<a href="#l3.8332"></a><span id="l3.8332" class="difflineplus">+    case nsMsgAuthMethod::anything:</span>
<a href="#l3.8333"></a><span id="l3.8333" class="difflineplus">+      m_prefAuthMethods = kHasAuthOldLoginCapability | kHasAuthLoginCapability |</span>
<a href="#l3.8334"></a><span id="l3.8334" class="difflineplus">+                          kHasAuthPlainCapability | kHasCRAMCapability |</span>
<a href="#l3.8335"></a><span id="l3.8335" class="difflineplus">+                          kHasAuthGssApiCapability | kHasAuthNTLMCapability |</span>
<a href="#l3.8336"></a><span id="l3.8336" class="difflineplus">+                          kHasAuthMSNCapability | kHasAuthExternalCapability |</span>
<a href="#l3.8337"></a><span id="l3.8337" class="difflineplus">+                          kHasXOAuth2Capability;</span>
<a href="#l3.8338"></a><span id="l3.8338" class="difflineplus">+      break;</span>
<a href="#l3.8339"></a><span id="l3.8339" class="difflineplus">+    case nsMsgAuthMethod::OAuth2:</span>
<a href="#l3.8340"></a><span id="l3.8340" class="difflineplus">+      m_prefAuthMethods = kHasXOAuth2Capability;</span>
<a href="#l3.8341"></a><span id="l3.8341" class="difflineplus">+      break;</span>
<a href="#l3.8342"></a><span id="l3.8342" class="difflineplus">+  }</span>
<a href="#l3.8343"></a><span id="l3.8343" class="difflineplus">+</span>
<a href="#l3.8344"></a><span id="l3.8344" class="difflineplus">+  if (m_prefAuthMethods &amp; kHasXOAuth2Capability)</span>
<a href="#l3.8345"></a><span id="l3.8345" class="difflineplus">+    mOAuth2Support = new mozilla::mailnews::OAuth2ThreadHelper(aServer);</span>
<a href="#l3.8346"></a><span id="l3.8346" class="difflineplus">+</span>
<a href="#l3.8347"></a><span id="l3.8347" class="difflineplus">+  // Disable OAuth2 support if we don't have the prefs installed.</span>
<a href="#l3.8348"></a><span id="l3.8348" class="difflineplus">+  if (m_prefAuthMethods &amp; kHasXOAuth2Capability &amp;&amp;</span>
<a href="#l3.8349"></a><span id="l3.8349" class="difflineplus">+      (!mOAuth2Support || !mOAuth2Support-&gt;SupportsOAuth2()))</span>
<a href="#l3.8350"></a><span id="l3.8350" class="difflineplus">+    m_prefAuthMethods &amp;= ~kHasXOAuth2Capability;</span>
<a href="#l3.8351"></a><span id="l3.8351" class="difflineplus">+</span>
<a href="#l3.8352"></a><span id="l3.8352" class="difflineplus">+  NS_ASSERTION(m_prefAuthMethods != kCapabilityUndefined,</span>
<a href="#l3.8353"></a><span id="l3.8353" class="difflineplus">+               &quot;IMAP: InitPrefAuthMethods() didn't work&quot;);</span>
<a href="#l3.8354"></a><span id="l3.8354"> }</span>
<a href="#l3.8355"></a><span id="l3.8355"> </span>
<a href="#l3.8356"></a><span id="l3.8356"> /**</span>
<a href="#l3.8357"></a><span id="l3.8357">  * Changes m_currentAuthMethod to pick the best remaining one</span>
<a href="#l3.8358"></a><span id="l3.8358">  * which is allowed by server and prefs and not marked failed.</span>
<a href="#l3.8359"></a><span id="l3.8359">  * The order of preference and trying of auth methods is encoded here.</span>
<a href="#l3.8360"></a><span id="l3.8360">  */</span>
<a href="#l3.8361"></a><span id="l3.8361" class="difflineminus">-nsresult nsImapProtocol::ChooseAuthMethod()</span>
<a href="#l3.8362"></a><span id="l3.8362" class="difflineminus">-{</span>
<a href="#l3.8363"></a><span id="l3.8363" class="difflineplus">+nsresult nsImapProtocol::ChooseAuthMethod() {</span>
<a href="#l3.8364"></a><span id="l3.8364">   eIMAPCapabilityFlags serverCaps = GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.8365"></a><span id="l3.8365" class="difflineminus">-  eIMAPCapabilityFlags availCaps = serverCaps &amp; m_prefAuthMethods &amp; ~m_failedAuthMethods;</span>
<a href="#l3.8366"></a><span id="l3.8366" class="difflineminus">-</span>
<a href="#l3.8367"></a><span id="l3.8367" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;IMAP auth: server caps 0x%&quot; PRIx64</span>
<a href="#l3.8368"></a><span id="l3.8368" class="difflineminus">-        &quot;, pref 0x%&quot; PRIx64 &quot;, failed 0x%&quot; PRIx64 &quot;, avail caps 0x%&quot; PRIx64,</span>
<a href="#l3.8369"></a><span id="l3.8369" class="difflineminus">-        serverCaps, m_prefAuthMethods, m_failedAuthMethods, availCaps));</span>
<a href="#l3.8370"></a><span id="l3.8370" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;(GSSAPI = 0x%&quot; PRIx64 &quot;, CRAM = 0x%&quot; PRIx64</span>
<a href="#l3.8371"></a><span id="l3.8371" class="difflineminus">-        &quot;, NTLM = 0x%&quot; PRIx64 &quot;, MSN = 0x%&quot; PRIx64 &quot;, PLAIN = 0x%&quot; PRIx64</span>
<a href="#l3.8372"></a><span id="l3.8372" class="difflineminus">-        &quot;, LOGIN = 0x%&quot; PRIx64 &quot;, old-style IMAP login = 0x%&quot; PRIx64</span>
<a href="#l3.8373"></a><span id="l3.8373" class="difflineminus">-        &quot;, auth external IMAP login = 0x%&quot; PRIx64 &quot;, OAUTH2 = 0x%&quot; PRIx64 &quot;)&quot;,</span>
<a href="#l3.8374"></a><span id="l3.8374" class="difflineminus">-        kHasAuthGssApiCapability, kHasCRAMCapability, kHasAuthNTLMCapability,</span>
<a href="#l3.8375"></a><span id="l3.8375" class="difflineminus">-        kHasAuthMSNCapability, kHasAuthPlainCapability, kHasAuthLoginCapability,</span>
<a href="#l3.8376"></a><span id="l3.8376" class="difflineminus">-        kHasAuthOldLoginCapability, kHasAuthExternalCapability,</span>
<a href="#l3.8377"></a><span id="l3.8377" class="difflineminus">-        kHasXOAuth2Capability));</span>
<a href="#l3.8378"></a><span id="l3.8378" class="difflineplus">+  eIMAPCapabilityFlags availCaps =</span>
<a href="#l3.8379"></a><span id="l3.8379" class="difflineplus">+      serverCaps &amp; m_prefAuthMethods &amp; ~m_failedAuthMethods;</span>
<a href="#l3.8380"></a><span id="l3.8380" class="difflineplus">+</span>
<a href="#l3.8381"></a><span id="l3.8381" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.8382"></a><span id="l3.8382" class="difflineplus">+          (&quot;IMAP auth: server caps 0x%&quot; PRIx64 &quot;, pref 0x%&quot; PRIx64</span>
<a href="#l3.8383"></a><span id="l3.8383" class="difflineplus">+           &quot;, failed 0x%&quot; PRIx64 &quot;, avail caps 0x%&quot; PRIx64,</span>
<a href="#l3.8384"></a><span id="l3.8384" class="difflineplus">+           serverCaps, m_prefAuthMethods, m_failedAuthMethods, availCaps));</span>
<a href="#l3.8385"></a><span id="l3.8385" class="difflineplus">+  // clang-format off</span>
<a href="#l3.8386"></a><span id="l3.8386" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.8387"></a><span id="l3.8387" class="difflineplus">+          (&quot;(GSSAPI = 0x%&quot; PRIx64 &quot;, CRAM = 0x%&quot; PRIx64 &quot;, NTLM = 0x%&quot; PRIx64</span>
<a href="#l3.8388"></a><span id="l3.8388" class="difflineplus">+           &quot;, MSN = 0x%&quot; PRIx64 &quot;, PLAIN = 0x%&quot; PRIx64 &quot;, LOGIN = 0x%&quot; PRIx64</span>
<a href="#l3.8389"></a><span id="l3.8389" class="difflineplus">+           &quot;, old-style IMAP login = 0x%&quot; PRIx64</span>
<a href="#l3.8390"></a><span id="l3.8390" class="difflineplus">+           &quot;, auth external IMAP login = 0x%&quot; PRIx64 &quot;, OAUTH2 = 0x%&quot; PRIx64 &quot;)&quot;,</span>
<a href="#l3.8391"></a><span id="l3.8391" class="difflineplus">+           kHasAuthGssApiCapability, kHasCRAMCapability, kHasAuthNTLMCapability,</span>
<a href="#l3.8392"></a><span id="l3.8392" class="difflineplus">+           kHasAuthMSNCapability, kHasAuthPlainCapability, kHasAuthLoginCapability,</span>
<a href="#l3.8393"></a><span id="l3.8393" class="difflineplus">+           kHasAuthOldLoginCapability, kHasAuthExternalCapability,</span>
<a href="#l3.8394"></a><span id="l3.8394" class="difflineplus">+           kHasXOAuth2Capability));</span>
<a href="#l3.8395"></a><span id="l3.8395" class="difflineplus">+  // clang-format on</span>
<a href="#l3.8396"></a><span id="l3.8396"> </span>
<a href="#l3.8397"></a><span id="l3.8397">   if (kHasAuthExternalCapability &amp; availCaps)</span>
<a href="#l3.8398"></a><span id="l3.8398">     m_currentAuthMethod = kHasAuthExternalCapability;</span>
<a href="#l3.8399"></a><span id="l3.8399">   else if (kHasAuthGssApiCapability &amp; availCaps)</span>
<a href="#l3.8400"></a><span id="l3.8400">     m_currentAuthMethod = kHasAuthGssApiCapability;</span>
<a href="#l3.8401"></a><span id="l3.8401">   else if (kHasCRAMCapability &amp; availCaps)</span>
<a href="#l3.8402"></a><span id="l3.8402">     m_currentAuthMethod = kHasCRAMCapability;</span>
<a href="#l3.8403"></a><span id="l3.8403">   else if (kHasAuthNTLMCapability &amp; availCaps)</span>
<a href="#l3.8404"></a><span id="l3.8404" class="difflineat">@@ -6016,278 +5516,265 @@ nsresult nsImapProtocol::ChooseAuthMetho</span>
<a href="#l3.8405"></a><span id="l3.8405">   else if (kHasXOAuth2Capability &amp; availCaps)</span>
<a href="#l3.8406"></a><span id="l3.8406">     m_currentAuthMethod = kHasXOAuth2Capability;</span>
<a href="#l3.8407"></a><span id="l3.8407">   else if (kHasAuthPlainCapability &amp; availCaps)</span>
<a href="#l3.8408"></a><span id="l3.8408">     m_currentAuthMethod = kHasAuthPlainCapability;</span>
<a href="#l3.8409"></a><span id="l3.8409">   else if (kHasAuthLoginCapability &amp; availCaps)</span>
<a href="#l3.8410"></a><span id="l3.8410">     m_currentAuthMethod = kHasAuthLoginCapability;</span>
<a href="#l3.8411"></a><span id="l3.8411">   else if (kHasAuthOldLoginCapability &amp; availCaps)</span>
<a href="#l3.8412"></a><span id="l3.8412">     m_currentAuthMethod = kHasAuthOldLoginCapability;</span>
<a href="#l3.8413"></a><span id="l3.8413" class="difflineminus">-  else</span>
<a href="#l3.8414"></a><span id="l3.8414" class="difflineminus">-  {</span>
<a href="#l3.8415"></a><span id="l3.8415" class="difflineplus">+  else {</span>
<a href="#l3.8416"></a><span id="l3.8416">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;no remaining auth method&quot;));</span>
<a href="#l3.8417"></a><span id="l3.8417">     m_currentAuthMethod = kCapabilityUndefined;</span>
<a href="#l3.8418"></a><span id="l3.8418">     return NS_ERROR_FAILURE;</span>
<a href="#l3.8419"></a><span id="l3.8419">   }</span>
<a href="#l3.8420"></a><span id="l3.8420" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;trying auth method 0x%&quot; PRIx64, m_currentAuthMethod));</span>
<a href="#l3.8421"></a><span id="l3.8421" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.8422"></a><span id="l3.8422" class="difflineplus">+          (&quot;trying auth method 0x%&quot; PRIx64, m_currentAuthMethod));</span>
<a href="#l3.8423"></a><span id="l3.8423">   return NS_OK;</span>
<a href="#l3.8424"></a><span id="l3.8424"> }</span>
<a href="#l3.8425"></a><span id="l3.8425"> </span>
<a href="#l3.8426"></a><span id="l3.8426" class="difflineminus">-void nsImapProtocol::MarkAuthMethodAsFailed(eIMAPCapabilityFlags failedAuthMethod)</span>
<a href="#l3.8427"></a><span id="l3.8427" class="difflineminus">-{</span>
<a href="#l3.8428"></a><span id="l3.8428" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;marking auth method 0x%&quot; PRIx64 &quot; failed&quot;, failedAuthMethod));</span>
<a href="#l3.8429"></a><span id="l3.8429" class="difflineplus">+void nsImapProtocol::MarkAuthMethodAsFailed(</span>
<a href="#l3.8430"></a><span id="l3.8430" class="difflineplus">+    eIMAPCapabilityFlags failedAuthMethod) {</span>
<a href="#l3.8431"></a><span id="l3.8431" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.8432"></a><span id="l3.8432" class="difflineplus">+          (&quot;marking auth method 0x%&quot; PRIx64 &quot; failed&quot;, failedAuthMethod));</span>
<a href="#l3.8433"></a><span id="l3.8433">   m_failedAuthMethods |= failedAuthMethod;</span>
<a href="#l3.8434"></a><span id="l3.8434"> }</span>
<a href="#l3.8435"></a><span id="l3.8435"> </span>
<a href="#l3.8436"></a><span id="l3.8436"> /**</span>
<a href="#l3.8437"></a><span id="l3.8437">  * Start over, trying all auth methods again</span>
<a href="#l3.8438"></a><span id="l3.8438">  */</span>
<a href="#l3.8439"></a><span id="l3.8439" class="difflineminus">-void nsImapProtocol::ResetAuthMethods()</span>
<a href="#l3.8440"></a><span id="l3.8440" class="difflineminus">-{</span>
<a href="#l3.8441"></a><span id="l3.8441" class="difflineplus">+void nsImapProtocol::ResetAuthMethods() {</span>
<a href="#l3.8442"></a><span id="l3.8442">   MOZ_LOG(IMAP, LogLevel::Debug, (&quot;resetting (failed) auth methods&quot;));</span>
<a href="#l3.8443"></a><span id="l3.8443">   m_currentAuthMethod = kCapabilityUndefined;</span>
<a href="#l3.8444"></a><span id="l3.8444">   m_failedAuthMethods = 0;</span>
<a href="#l3.8445"></a><span id="l3.8445"> }</span>
<a href="#l3.8446"></a><span id="l3.8446"> </span>
<a href="#l3.8447"></a><span id="l3.8447" class="difflineminus">-nsresult</span>
<a href="#l3.8448"></a><span id="l3.8448" class="difflineminus">-nsImapProtocol::SendDataParseIMAPandCheckForNewMail(const char *aData, const char *aCommand)</span>
<a href="#l3.8449"></a><span id="l3.8449" class="difflineminus">-{</span>
<a href="#l3.8450"></a><span id="l3.8450" class="difflineplus">+nsresult nsImapProtocol::SendDataParseIMAPandCheckForNewMail(</span>
<a href="#l3.8451"></a><span id="l3.8451" class="difflineplus">+    const char *aData, const char *aCommand) {</span>
<a href="#l3.8452"></a><span id="l3.8452">   nsresult rv;</span>
<a href="#l3.8453"></a><span id="l3.8453">   bool isResend = false;</span>
<a href="#l3.8454"></a><span id="l3.8454" class="difflineminus">-  while (true)</span>
<a href="#l3.8455"></a><span id="l3.8455" class="difflineminus">-  {</span>
<a href="#l3.8456"></a><span id="l3.8456" class="difflineplus">+  while (true) {</span>
<a href="#l3.8457"></a><span id="l3.8457">     // Send authentication string (true: suppress logging the string).</span>
<a href="#l3.8458"></a><span id="l3.8458">     rv = SendData(aData, true);</span>
<a href="#l3.8459"></a><span id="l3.8459" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.8460"></a><span id="l3.8460" class="difflineminus">-      break;</span>
<a href="#l3.8461"></a><span id="l3.8461" class="difflineplus">+    if (NS_FAILED(rv)) break;</span>
<a href="#l3.8462"></a><span id="l3.8462">     ParseIMAPandCheckForNewMail(aCommand);</span>
<a href="#l3.8463"></a><span id="l3.8463" class="difflineminus">-    if (!GetServerStateParser().WaitingForMoreClientInput())</span>
<a href="#l3.8464"></a><span id="l3.8464" class="difflineminus">-      break;</span>
<a href="#l3.8465"></a><span id="l3.8465" class="difflineplus">+    if (!GetServerStateParser().WaitingForMoreClientInput()) break;</span>
<a href="#l3.8466"></a><span id="l3.8466"> </span>
<a href="#l3.8467"></a><span id="l3.8467">     // The server is asking for the authentication string again. So we send</span>
<a href="#l3.8468"></a><span id="l3.8468">     // the same string again although we know that it might be rejected again.</span>
<a href="#l3.8469"></a><span id="l3.8469">     // We do that to get a firm authentication failure instead of a resend</span>
<a href="#l3.8470"></a><span id="l3.8470">     // request. That keeps things in order before failing authentication and</span>
<a href="#l3.8471"></a><span id="l3.8471">     // trying another method if capable.</span>
<a href="#l3.8472"></a><span id="l3.8472" class="difflineminus">-    if (isResend)</span>
<a href="#l3.8473"></a><span id="l3.8473" class="difflineminus">-    {</span>
<a href="#l3.8474"></a><span id="l3.8474" class="difflineplus">+    if (isResend) {</span>
<a href="#l3.8475"></a><span id="l3.8475">       rv = NS_ERROR_FAILURE;</span>
<a href="#l3.8476"></a><span id="l3.8476">       break;</span>
<a href="#l3.8477"></a><span id="l3.8477">     }</span>
<a href="#l3.8478"></a><span id="l3.8478">     isResend = true;</span>
<a href="#l3.8479"></a><span id="l3.8479">   }</span>
<a href="#l3.8480"></a><span id="l3.8480"> </span>
<a href="#l3.8481"></a><span id="l3.8481">   return rv;</span>
<a href="#l3.8482"></a><span id="l3.8482"> }</span>
<a href="#l3.8483"></a><span id="l3.8483"> </span>
<a href="#l3.8484"></a><span id="l3.8484" class="difflineminus">-nsresult nsImapProtocol::AuthLogin(const char *userName, const nsString &amp;aPassword, eIMAPCapabilityFlag flag)</span>
<a href="#l3.8485"></a><span id="l3.8485" class="difflineminus">-{</span>
<a href="#l3.8486"></a><span id="l3.8486" class="difflineplus">+nsresult nsImapProtocol::AuthLogin(const char *userName,</span>
<a href="#l3.8487"></a><span id="l3.8487" class="difflineplus">+                                   const nsString &amp;aPassword,</span>
<a href="#l3.8488"></a><span id="l3.8488" class="difflineplus">+                                   eIMAPCapabilityFlag flag) {</span>
<a href="#l3.8489"></a><span id="l3.8489">   ProgressEventFunctionUsingName(&quot;imapStatusSendingAuthLogin&quot;);</span>
<a href="#l3.8490"></a><span id="l3.8490">   IncrementCommandTagNumber();</span>
<a href="#l3.8491"></a><span id="l3.8491"> </span>
<a href="#l3.8492"></a><span id="l3.8492" class="difflineminus">-  char * currentCommand=nullptr;</span>
<a href="#l3.8493"></a><span id="l3.8493" class="difflineplus">+  char *currentCommand = nullptr;</span>
<a href="#l3.8494"></a><span id="l3.8494">   nsresult rv;</span>
<a href="#l3.8495"></a><span id="l3.8495">   NS_ConvertUTF16toUTF8 password(aPassword);</span>
<a href="#l3.8496"></a><span id="l3.8496" class="difflineminus">-  MOZ_LOG(IMAP, LogLevel::Debug, (&quot;IMAP: trying auth method 0x%&quot; PRIx64, m_currentAuthMethod));</span>
<a href="#l3.8497"></a><span id="l3.8497" class="difflineminus">-</span>
<a href="#l3.8498"></a><span id="l3.8498" class="difflineminus">-  if (flag &amp; kHasAuthExternalCapability)</span>
<a href="#l3.8499"></a><span id="l3.8499" class="difflineminus">-  {</span>
<a href="#l3.8500"></a><span id="l3.8500" class="difflineminus">-      char *base64UserName = PL_Base64Encode(userName, strlen(userName), nullptr);</span>
<a href="#l3.8501"></a><span id="l3.8501" class="difflineminus">-      nsAutoCString command (GetServerCommandTag());</span>
<a href="#l3.8502"></a><span id="l3.8502" class="difflineminus">-      command.AppendLiteral(&quot; authenticate EXTERNAL &quot; );</span>
<a href="#l3.8503"></a><span id="l3.8503" class="difflineminus">-      command.Append(base64UserName);</span>
<a href="#l3.8504"></a><span id="l3.8504" class="difflineminus">-      command.Append(CRLF);</span>
<a href="#l3.8505"></a><span id="l3.8505" class="difflineminus">-      PR_Free(base64UserName);</span>
<a href="#l3.8506"></a><span id="l3.8506" class="difflineminus">-      rv = SendData(command.get());</span>
<a href="#l3.8507"></a><span id="l3.8507" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8508"></a><span id="l3.8508" class="difflineminus">-      nsImapServerResponseParser &amp;parser = GetServerStateParser();</span>
<a href="#l3.8509"></a><span id="l3.8509" class="difflineminus">-      if (parser.LastCommandSuccessful())</span>
<a href="#l3.8510"></a><span id="l3.8510" class="difflineminus">-        return NS_OK;</span>
<a href="#l3.8511"></a><span id="l3.8511" class="difflineminus">-      parser.SetCapabilityFlag(parser.GetCapabilityFlag() &amp; ~kHasAuthExternalCapability);</span>
<a href="#l3.8512"></a><span id="l3.8512" class="difflineminus">-  }</span>
<a href="#l3.8513"></a><span id="l3.8513" class="difflineminus">-  else if (flag &amp; kHasCRAMCapability)</span>
<a href="#l3.8514"></a><span id="l3.8514" class="difflineminus">-  {</span>
<a href="#l3.8515"></a><span id="l3.8515" class="difflineplus">+  MOZ_LOG(IMAP, LogLevel::Debug,</span>
<a href="#l3.8516"></a><span id="l3.8516" class="difflineplus">+          (&quot;IMAP: trying auth method 0x%&quot; PRIx64, m_currentAuthMethod));</span>
<a href="#l3.8517"></a><span id="l3.8517" class="difflineplus">+</span>
<a href="#l3.8518"></a><span id="l3.8518" class="difflineplus">+  if (flag &amp; kHasAuthExternalCapability) {</span>
<a href="#l3.8519"></a><span id="l3.8519" class="difflineplus">+    char *base64UserName = PL_Base64Encode(userName, strlen(userName), nullptr);</span>
<a href="#l3.8520"></a><span id="l3.8520" class="difflineplus">+    nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.8521"></a><span id="l3.8521" class="difflineplus">+    command.AppendLiteral(&quot; authenticate EXTERNAL &quot;);</span>
<a href="#l3.8522"></a><span id="l3.8522" class="difflineplus">+    command.Append(base64UserName);</span>
<a href="#l3.8523"></a><span id="l3.8523" class="difflineplus">+    command.Append(CRLF);</span>
<a href="#l3.8524"></a><span id="l3.8524" class="difflineplus">+    PR_Free(base64UserName);</span>
<a href="#l3.8525"></a><span id="l3.8525" class="difflineplus">+    rv = SendData(command.get());</span>
<a href="#l3.8526"></a><span id="l3.8526" class="difflineplus">+    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8527"></a><span id="l3.8527" class="difflineplus">+    nsImapServerResponseParser &amp;parser = GetServerStateParser();</span>
<a href="#l3.8528"></a><span id="l3.8528" class="difflineplus">+    if (parser.LastCommandSuccessful()) return NS_OK;</span>
<a href="#l3.8529"></a><span id="l3.8529" class="difflineplus">+    parser.SetCapabilityFlag(parser.GetCapabilityFlag() &amp;</span>
<a href="#l3.8530"></a><span id="l3.8530" class="difflineplus">+                             ~kHasAuthExternalCapability);</span>
<a href="#l3.8531"></a><span id="l3.8531" class="difflineplus">+  } else if (flag &amp; kHasCRAMCapability) {</span>
<a href="#l3.8532"></a><span id="l3.8532">     NS_ENSURE_TRUE(m_imapServerSink, NS_ERROR_NULL_POINTER);</span>
<a href="#l3.8533"></a><span id="l3.8533">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;MD5 auth&quot;));</span>
<a href="#l3.8534"></a><span id="l3.8534" class="difflineminus">-    // inform the server that we want to begin a CRAM authentication procedure...</span>
<a href="#l3.8535"></a><span id="l3.8535" class="difflineminus">-    nsAutoCString command (GetServerCommandTag());</span>
<a href="#l3.8536"></a><span id="l3.8536" class="difflineplus">+    // inform the server that we want to begin a CRAM authentication</span>
<a href="#l3.8537"></a><span id="l3.8537" class="difflineplus">+    // procedure...</span>
<a href="#l3.8538"></a><span id="l3.8538" class="difflineplus">+    nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.8539"></a><span id="l3.8539">     command.AppendLiteral(&quot; authenticate CRAM-MD5&quot; CRLF);</span>
<a href="#l3.8540"></a><span id="l3.8540">     rv = SendData(command.get());</span>
<a href="#l3.8541"></a><span id="l3.8541">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8542"></a><span id="l3.8542">     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8543"></a><span id="l3.8543" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8544"></a><span id="l3.8544" class="difflineminus">-    {</span>
<a href="#l3.8545"></a><span id="l3.8545" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8546"></a><span id="l3.8546">       char *digest = nullptr;</span>
<a href="#l3.8547"></a><span id="l3.8547">       char *cramDigest = GetServerStateParser().fAuthChallenge;</span>
<a href="#l3.8548"></a><span id="l3.8548" class="difflineminus">-      char *decodedChallenge = PL_Base64Decode(cramDigest,</span>
<a href="#l3.8549"></a><span id="l3.8549" class="difflineminus">-                                                strlen(cramDigest), nullptr);</span>
<a href="#l3.8550"></a><span id="l3.8550" class="difflineminus">-      rv = m_imapServerSink-&gt;CramMD5Hash(decodedChallenge, password.get(), &amp;digest);</span>
<a href="#l3.8551"></a><span id="l3.8551" class="difflineplus">+      char *decodedChallenge =</span>
<a href="#l3.8552"></a><span id="l3.8552" class="difflineplus">+          PL_Base64Decode(cramDigest, strlen(cramDigest), nullptr);</span>
<a href="#l3.8553"></a><span id="l3.8553" class="difflineplus">+      rv = m_imapServerSink-&gt;CramMD5Hash(decodedChallenge, password.get(),</span>
<a href="#l3.8554"></a><span id="l3.8554" class="difflineplus">+                                         &amp;digest);</span>
<a href="#l3.8555"></a><span id="l3.8555">       PR_Free(decodedChallenge);</span>
<a href="#l3.8556"></a><span id="l3.8556">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8557"></a><span id="l3.8557">       NS_ENSURE_TRUE(digest, NS_ERROR_NULL_POINTER);</span>
<a href="#l3.8558"></a><span id="l3.8558">       // The encoded digest is the hexadecimal representation of</span>
<a href="#l3.8559"></a><span id="l3.8559">       // DIGEST_LENGTH characters, so it will be twice that length.</span>
<a href="#l3.8560"></a><span id="l3.8560">       nsAutoCStringN&lt;2 * DIGEST_LENGTH&gt; encodedDigest;</span>
<a href="#l3.8561"></a><span id="l3.8561"> </span>
<a href="#l3.8562"></a><span id="l3.8562" class="difflineminus">-      for (uint32_t j = 0; j &lt; DIGEST_LENGTH; j++)</span>
<a href="#l3.8563"></a><span id="l3.8563" class="difflineminus">-      {</span>
<a href="#l3.8564"></a><span id="l3.8564" class="difflineplus">+      for (uint32_t j = 0; j &lt; DIGEST_LENGTH; j++) {</span>
<a href="#l3.8565"></a><span id="l3.8565">         char hexVal[3];</span>
<a href="#l3.8566"></a><span id="l3.8566" class="difflineminus">-        PR_snprintf (hexVal, 3, &quot;%.2x&quot;, 0x0ff &amp; (unsigned short)(digest[j]));</span>
<a href="#l3.8567"></a><span id="l3.8567" class="difflineplus">+        PR_snprintf(hexVal, 3, &quot;%.2x&quot;, 0x0ff &amp; (unsigned short)(digest[j]));</span>
<a href="#l3.8568"></a><span id="l3.8568">         encodedDigest.Append(hexVal);</span>
<a href="#l3.8569"></a><span id="l3.8569">       }</span>
<a href="#l3.8570"></a><span id="l3.8570"> </span>
<a href="#l3.8571"></a><span id="l3.8571" class="difflineminus">-      PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%.255s %s&quot;, userName, encodedDigest.get());</span>
<a href="#l3.8572"></a><span id="l3.8572" class="difflineminus">-      char *base64Str = PL_Base64Encode(m_dataOutputBuf, strlen(m_dataOutputBuf), nullptr);</span>
<a href="#l3.8573"></a><span id="l3.8573" class="difflineplus">+      PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%.255s %s&quot;, userName,</span>
<a href="#l3.8574"></a><span id="l3.8574" class="difflineplus">+                  encodedDigest.get());</span>
<a href="#l3.8575"></a><span id="l3.8575" class="difflineplus">+      char *base64Str =</span>
<a href="#l3.8576"></a><span id="l3.8576" class="difflineplus">+          PL_Base64Encode(m_dataOutputBuf, strlen(m_dataOutputBuf), nullptr);</span>
<a href="#l3.8577"></a><span id="l3.8577">       PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s&quot; CRLF, base64Str);</span>
<a href="#l3.8578"></a><span id="l3.8578">       PR_Free(base64Str);</span>
<a href="#l3.8579"></a><span id="l3.8579">       PR_Free(digest);</span>
<a href="#l3.8580"></a><span id="l3.8580">       rv = SendData(m_dataOutputBuf);</span>
<a href="#l3.8581"></a><span id="l3.8581">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8582"></a><span id="l3.8582">       ParseIMAPandCheckForNewMail(command.get());</span>
<a href="#l3.8583"></a><span id="l3.8583">     }</span>
<a href="#l3.8584"></a><span id="l3.8584" class="difflineminus">-  } // if CRAM response was received</span>
<a href="#l3.8585"></a><span id="l3.8585" class="difflineminus">-  else if (flag &amp; kHasAuthGssApiCapability)</span>
<a href="#l3.8586"></a><span id="l3.8586" class="difflineminus">-  {</span>
<a href="#l3.8587"></a><span id="l3.8587" class="difflineplus">+  }  // if CRAM response was received</span>
<a href="#l3.8588"></a><span id="l3.8588" class="difflineplus">+  else if (flag &amp; kHasAuthGssApiCapability) {</span>
<a href="#l3.8589"></a><span id="l3.8589">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;MD5 auth&quot;));</span>
<a href="#l3.8590"></a><span id="l3.8590"> </span>
<a href="#l3.8591"></a><span id="l3.8591">     // Only try GSSAPI once - if it fails, its going to be because we don't</span>
<a href="#l3.8592"></a><span id="l3.8592">     // have valid credentials</span>
<a href="#l3.8593"></a><span id="l3.8593" class="difflineminus">-    //MarkAuthMethodAsFailed(kHasAuthGssApiCapability);</span>
<a href="#l3.8594"></a><span id="l3.8594" class="difflineplus">+    // MarkAuthMethodAsFailed(kHasAuthGssApiCapability);</span>
<a href="#l3.8595"></a><span id="l3.8595"> </span>
<a href="#l3.8596"></a><span id="l3.8596">     // We do step1 first, so we don't try GSSAPI against a server which</span>
<a href="#l3.8597"></a><span id="l3.8597">     // we can't get credentials for.</span>
<a href="#l3.8598"></a><span id="l3.8598">     nsAutoCString response;</span>
<a href="#l3.8599"></a><span id="l3.8599"> </span>
<a href="#l3.8600"></a><span id="l3.8600">     nsAutoCString service(&quot;imap@&quot;);</span>
<a href="#l3.8601"></a><span id="l3.8601">     service.Append(m_realHostName);</span>
<a href="#l3.8602"></a><span id="l3.8602">     rv = DoGSSAPIStep1(service.get(), userName, response);</span>
<a href="#l3.8603"></a><span id="l3.8603">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8604"></a><span id="l3.8604"> </span>
<a href="#l3.8605"></a><span id="l3.8605" class="difflineminus">-    nsAutoCString command (GetServerCommandTag());</span>
<a href="#l3.8606"></a><span id="l3.8606" class="difflineplus">+    nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.8607"></a><span id="l3.8607">     command.AppendLiteral(&quot; authenticate GSSAPI&quot; CRLF);</span>
<a href="#l3.8608"></a><span id="l3.8608">     rv = SendData(command.get());</span>
<a href="#l3.8609"></a><span id="l3.8609">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8610"></a><span id="l3.8610"> </span>
<a href="#l3.8611"></a><span id="l3.8611">     ParseIMAPandCheckForNewMail(&quot;AUTH GSSAPI&quot;);</span>
<a href="#l3.8612"></a><span id="l3.8612" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8613"></a><span id="l3.8613" class="difflineminus">-    {</span>
<a href="#l3.8614"></a><span id="l3.8614" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8615"></a><span id="l3.8615">       response += CRLF;</span>
<a href="#l3.8616"></a><span id="l3.8616">       rv = SendData(response.get());</span>
<a href="#l3.8617"></a><span id="l3.8617">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8618"></a><span id="l3.8618">       ParseIMAPandCheckForNewMail(command.get());</span>
<a href="#l3.8619"></a><span id="l3.8619">       nsresult gssrv = NS_OK;</span>
<a href="#l3.8620"></a><span id="l3.8620"> </span>
<a href="#l3.8621"></a><span id="l3.8621">       while (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.8622"></a><span id="l3.8622" class="difflineminus">-             NS_SUCCEEDED(gssrv) &amp;&amp; gssrv != NS_SUCCESS_AUTH_FINISHED)</span>
<a href="#l3.8623"></a><span id="l3.8623" class="difflineminus">-      {</span>
<a href="#l3.8624"></a><span id="l3.8624" class="difflineplus">+             NS_SUCCEEDED(gssrv) &amp;&amp; gssrv != NS_SUCCESS_AUTH_FINISHED) {</span>
<a href="#l3.8625"></a><span id="l3.8625">         nsCString challengeStr(GetServerStateParser().fAuthChallenge);</span>
<a href="#l3.8626"></a><span id="l3.8626">         gssrv = DoGSSAPIStep2(challengeStr, response);</span>
<a href="#l3.8627"></a><span id="l3.8627" class="difflineminus">-        if (NS_SUCCEEDED(gssrv))</span>
<a href="#l3.8628"></a><span id="l3.8628" class="difflineminus">-        {</span>
<a href="#l3.8629"></a><span id="l3.8629" class="difflineplus">+        if (NS_SUCCEEDED(gssrv)) {</span>
<a href="#l3.8630"></a><span id="l3.8630">           response += CRLF;</span>
<a href="#l3.8631"></a><span id="l3.8631">           rv = SendData(response.get());</span>
<a href="#l3.8632"></a><span id="l3.8632" class="difflineminus">-        }</span>
<a href="#l3.8633"></a><span id="l3.8633" class="difflineminus">-        else</span>
<a href="#l3.8634"></a><span id="l3.8634" class="difflineplus">+        } else</span>
<a href="#l3.8635"></a><span id="l3.8635">           rv = SendData(&quot;*&quot; CRLF);</span>
<a href="#l3.8636"></a><span id="l3.8636"> </span>
<a href="#l3.8637"></a><span id="l3.8637">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8638"></a><span id="l3.8638">         ParseIMAPandCheckForNewMail(command.get());</span>
<a href="#l3.8639"></a><span id="l3.8639">       }</span>
<a href="#l3.8640"></a><span id="l3.8640" class="difflineminus">-      // TODO: whether it worked or not is shown by LastCommandSuccessful(), not gssrv, right?</span>
<a href="#l3.8641"></a><span id="l3.8641" class="difflineminus">-    }</span>
<a href="#l3.8642"></a><span id="l3.8642" class="difflineminus">-  }</span>
<a href="#l3.8643"></a><span id="l3.8643" class="difflineminus">-  else if (flag &amp; (kHasAuthNTLMCapability | kHasAuthMSNCapability))</span>
<a href="#l3.8644"></a><span id="l3.8644" class="difflineminus">-  {</span>
<a href="#l3.8645"></a><span id="l3.8645" class="difflineplus">+      // TODO: whether it worked or not is shown by LastCommandSuccessful(), not</span>
<a href="#l3.8646"></a><span id="l3.8646" class="difflineplus">+      // gssrv, right?</span>
<a href="#l3.8647"></a><span id="l3.8647" class="difflineplus">+    }</span>
<a href="#l3.8648"></a><span id="l3.8648" class="difflineplus">+  } else if (flag &amp; (kHasAuthNTLMCapability | kHasAuthMSNCapability)) {</span>
<a href="#l3.8649"></a><span id="l3.8649">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;NTLM auth&quot;));</span>
<a href="#l3.8650"></a><span id="l3.8650" class="difflineminus">-    nsAutoCString command (GetServerCommandTag());</span>
<a href="#l3.8651"></a><span id="l3.8651" class="difflineplus">+    nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.8652"></a><span id="l3.8652">     command.Append((flag &amp; kHasAuthNTLMCapability) ? &quot; authenticate NTLM&quot; CRLF</span>
<a href="#l3.8653"></a><span id="l3.8653">                                                    : &quot; authenticate MSN&quot; CRLF);</span>
<a href="#l3.8654"></a><span id="l3.8654">     rv = SendData(command.get());</span>
<a href="#l3.8655"></a><span id="l3.8655" class="difflineminus">-    ParseIMAPandCheckForNewMail(&quot;AUTH NTLM&quot;); // this just waits for ntlm step 1</span>
<a href="#l3.8656"></a><span id="l3.8656" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8657"></a><span id="l3.8657" class="difflineminus">-    {</span>
<a href="#l3.8658"></a><span id="l3.8658" class="difflineplus">+    ParseIMAPandCheckForNewMail(</span>
<a href="#l3.8659"></a><span id="l3.8659" class="difflineplus">+        &quot;AUTH NTLM&quot;);  // this just waits for ntlm step 1</span>
<a href="#l3.8660"></a><span id="l3.8660" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8661"></a><span id="l3.8661">       nsAutoCString cmd;</span>
<a href="#l3.8662"></a><span id="l3.8662">       rv = DoNtlmStep1(nsDependentCString(userName), aPassword, cmd);</span>
<a href="#l3.8663"></a><span id="l3.8663">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8664"></a><span id="l3.8664">       cmd += CRLF;</span>
<a href="#l3.8665"></a><span id="l3.8665">       rv = SendData(cmd.get());</span>
<a href="#l3.8666"></a><span id="l3.8666">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8667"></a><span id="l3.8667">       ParseIMAPandCheckForNewMail(command.get());</span>
<a href="#l3.8668"></a><span id="l3.8668" class="difflineminus">-      if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8669"></a><span id="l3.8669" class="difflineminus">-      {</span>
<a href="#l3.8670"></a><span id="l3.8670" class="difflineplus">+      if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8671"></a><span id="l3.8671">         nsCString challengeStr(GetServerStateParser().fAuthChallenge);</span>
<a href="#l3.8672"></a><span id="l3.8672">         nsCString response;</span>
<a href="#l3.8673"></a><span id="l3.8673">         rv = DoNtlmStep2(challengeStr, response);</span>
<a href="#l3.8674"></a><span id="l3.8674">         NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8675"></a><span id="l3.8675">         response += CRLF;</span>
<a href="#l3.8676"></a><span id="l3.8676">         rv = SendData(response.get());</span>
<a href="#l3.8677"></a><span id="l3.8677">         ParseIMAPandCheckForNewMail(command.get());</span>
<a href="#l3.8678"></a><span id="l3.8678">       }</span>
<a href="#l3.8679"></a><span id="l3.8679">     }</span>
<a href="#l3.8680"></a><span id="l3.8680" class="difflineminus">-  }</span>
<a href="#l3.8681"></a><span id="l3.8681" class="difflineminus">-  else if (flag &amp; kHasAuthPlainCapability)</span>
<a href="#l3.8682"></a><span id="l3.8682" class="difflineminus">-  {</span>
<a href="#l3.8683"></a><span id="l3.8683" class="difflineplus">+  } else if (flag &amp; kHasAuthPlainCapability) {</span>
<a href="#l3.8684"></a><span id="l3.8684">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;PLAIN auth&quot;));</span>
<a href="#l3.8685"></a><span id="l3.8685" class="difflineminus">-    PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s authenticate PLAIN&quot; CRLF, GetServerCommandTag());</span>
<a href="#l3.8686"></a><span id="l3.8686" class="difflineplus">+    PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE,</span>
<a href="#l3.8687"></a><span id="l3.8687" class="difflineplus">+                &quot;%s authenticate PLAIN&quot; CRLF, GetServerCommandTag());</span>
<a href="#l3.8688"></a><span id="l3.8688">     rv = SendData(m_dataOutputBuf);</span>
<a href="#l3.8689"></a><span id="l3.8689">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8690"></a><span id="l3.8690" class="difflineminus">-    currentCommand = PL_strdup(m_dataOutputBuf); /* StrAllocCopy(currentCommand, GetOutputBuffer()); */</span>
<a href="#l3.8691"></a><span id="l3.8691" class="difflineplus">+    currentCommand = PL_strdup(</span>
<a href="#l3.8692"></a><span id="l3.8692" class="difflineplus">+        m_dataOutputBuf); /* StrAllocCopy(currentCommand, GetOutputBuffer()); */</span>
<a href="#l3.8693"></a><span id="l3.8693">     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8694"></a><span id="l3.8694" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8695"></a><span id="l3.8695" class="difflineminus">-    {</span>
<a href="#l3.8696"></a><span id="l3.8696" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8697"></a><span id="l3.8697">       // RFC 4616</span>
<a href="#l3.8698"></a><span id="l3.8698">       char plain_string[513];</span>
<a href="#l3.8699"></a><span id="l3.8699">       memset(plain_string, 0, 513);</span>
<a href="#l3.8700"></a><span id="l3.8700">       PR_snprintf(&amp;plain_string[1], 256, &quot;%.255s&quot;, userName);</span>
<a href="#l3.8701"></a><span id="l3.8701" class="difflineminus">-      uint32_t len = std::min(PL_strlen(userName), 255u) + 2;  // We include two &lt;NUL&gt; characters.</span>
<a href="#l3.8702"></a><span id="l3.8702" class="difflineplus">+      uint32_t len = std::min(PL_strlen(userName), 255u) +</span>
<a href="#l3.8703"></a><span id="l3.8703" class="difflineplus">+                     2;  // We include two &lt;NUL&gt; characters.</span>
<a href="#l3.8704"></a><span id="l3.8704">       PR_snprintf(&amp;plain_string[len], 256, &quot;%.255s&quot;, password.get());</span>
<a href="#l3.8705"></a><span id="l3.8705">       len += std::min(password.Length(), 255u);</span>
<a href="#l3.8706"></a><span id="l3.8706">       char *base64Str = PL_Base64Encode(plain_string, len, nullptr);</span>
<a href="#l3.8707"></a><span id="l3.8707">       PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s&quot; CRLF, base64Str);</span>
<a href="#l3.8708"></a><span id="l3.8708">       PR_Free(base64Str);</span>
<a href="#l3.8709"></a><span id="l3.8709"> </span>
<a href="#l3.8710"></a><span id="l3.8710">       rv = SendDataParseIMAPandCheckForNewMail(m_dataOutputBuf, currentCommand);</span>
<a href="#l3.8711"></a><span id="l3.8711" class="difflineminus">-    } // if the last command succeeded</span>
<a href="#l3.8712"></a><span id="l3.8712" class="difflineminus">-  } // if auth plain capability</span>
<a href="#l3.8713"></a><span id="l3.8713" class="difflineminus">-  else if (flag &amp; kHasAuthLoginCapability)</span>
<a href="#l3.8714"></a><span id="l3.8714" class="difflineminus">-  {</span>
<a href="#l3.8715"></a><span id="l3.8715" class="difflineplus">+    }  // if the last command succeeded</span>
<a href="#l3.8716"></a><span id="l3.8716" class="difflineplus">+  }    // if auth plain capability</span>
<a href="#l3.8717"></a><span id="l3.8717" class="difflineplus">+  else if (flag &amp; kHasAuthLoginCapability) {</span>
<a href="#l3.8718"></a><span id="l3.8718">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;LOGIN auth&quot;));</span>
<a href="#l3.8719"></a><span id="l3.8719" class="difflineminus">-    PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s authenticate LOGIN&quot; CRLF, GetServerCommandTag());</span>
<a href="#l3.8720"></a><span id="l3.8720" class="difflineplus">+    PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE,</span>
<a href="#l3.8721"></a><span id="l3.8721" class="difflineplus">+                &quot;%s authenticate LOGIN&quot; CRLF, GetServerCommandTag());</span>
<a href="#l3.8722"></a><span id="l3.8722">     rv = SendData(m_dataOutputBuf);</span>
<a href="#l3.8723"></a><span id="l3.8723">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8724"></a><span id="l3.8724">     currentCommand = PL_strdup(m_dataOutputBuf);</span>
<a href="#l3.8725"></a><span id="l3.8725">     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8726"></a><span id="l3.8726"> </span>
<a href="#l3.8727"></a><span id="l3.8727" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8728"></a><span id="l3.8728" class="difflineminus">-    {</span>
<a href="#l3.8729"></a><span id="l3.8729" class="difflineminus">-      char *base64Str = PL_Base64Encode(userName, std::min(PL_strlen(userName), 255u), nullptr);</span>
<a href="#l3.8730"></a><span id="l3.8730" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8731"></a><span id="l3.8731" class="difflineplus">+      char *base64Str = PL_Base64Encode(</span>
<a href="#l3.8732"></a><span id="l3.8732" class="difflineplus">+          userName, std::min(PL_strlen(userName), 255u), nullptr);</span>
<a href="#l3.8733"></a><span id="l3.8733">       PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s&quot; CRLF, base64Str);</span>
<a href="#l3.8734"></a><span id="l3.8734">       PR_Free(base64Str);</span>
<a href="#l3.8735"></a><span id="l3.8735">       rv = SendData(m_dataOutputBuf, true /* suppress logging */);</span>
<a href="#l3.8736"></a><span id="l3.8736" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8737"></a><span id="l3.8737" class="difflineminus">-      {</span>
<a href="#l3.8738"></a><span id="l3.8738" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.8739"></a><span id="l3.8739">         ParseIMAPandCheckForNewMail(currentCommand);</span>
<a href="#l3.8740"></a><span id="l3.8740" class="difflineminus">-        if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.8741"></a><span id="l3.8741" class="difflineminus">-        {</span>
<a href="#l3.8742"></a><span id="l3.8742" class="difflineminus">-          base64Str = PL_Base64Encode(password.get(), std::min(password.Length(), 255u), nullptr);</span>
<a href="#l3.8743"></a><span id="l3.8743" class="difflineminus">-          PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s&quot; CRLF, base64Str);</span>
<a href="#l3.8744"></a><span id="l3.8744" class="difflineplus">+        if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.8745"></a><span id="l3.8745" class="difflineplus">+          base64Str = PL_Base64Encode(</span>
<a href="#l3.8746"></a><span id="l3.8746" class="difflineplus">+              password.get(), std::min(password.Length(), 255u), nullptr);</span>
<a href="#l3.8747"></a><span id="l3.8747" class="difflineplus">+          PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s&quot; CRLF,</span>
<a href="#l3.8748"></a><span id="l3.8748" class="difflineplus">+                      base64Str);</span>
<a href="#l3.8749"></a><span id="l3.8749">           PR_Free(base64Str);</span>
<a href="#l3.8750"></a><span id="l3.8750">           rv = SendData(m_dataOutputBuf, true /* suppress logging */);</span>
<a href="#l3.8751"></a><span id="l3.8751" class="difflineminus">-          if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8752"></a><span id="l3.8752" class="difflineminus">-            ParseIMAPandCheckForNewMail(currentCommand);</span>
<a href="#l3.8753"></a><span id="l3.8753" class="difflineminus">-        } // if last command successful</span>
<a href="#l3.8754"></a><span id="l3.8754" class="difflineminus">-      } // if last command successful</span>
<a href="#l3.8755"></a><span id="l3.8755" class="difflineminus">-    } // if last command successful</span>
<a href="#l3.8756"></a><span id="l3.8756" class="difflineminus">-  } // if has auth login capability</span>
<a href="#l3.8757"></a><span id="l3.8757" class="difflineminus">-  else if (flag &amp; kHasAuthOldLoginCapability)</span>
<a href="#l3.8758"></a><span id="l3.8758" class="difflineminus">-  {</span>
<a href="#l3.8759"></a><span id="l3.8759" class="difflineplus">+          if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(currentCommand);</span>
<a href="#l3.8760"></a><span id="l3.8760" class="difflineplus">+        }  // if last command successful</span>
<a href="#l3.8761"></a><span id="l3.8761" class="difflineplus">+      }    // if last command successful</span>
<a href="#l3.8762"></a><span id="l3.8762" class="difflineplus">+    }      // if last command successful</span>
<a href="#l3.8763"></a><span id="l3.8763" class="difflineplus">+  }        // if has auth login capability</span>
<a href="#l3.8764"></a><span id="l3.8764" class="difflineplus">+  else if (flag &amp; kHasAuthOldLoginCapability) {</span>
<a href="#l3.8765"></a><span id="l3.8765">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;old-style auth&quot;));</span>
<a href="#l3.8766"></a><span id="l3.8766">     ProgressEventFunctionUsingName(&quot;imapStatusSendingLogin&quot;);</span>
<a href="#l3.8767"></a><span id="l3.8767">     IncrementCommandTagNumber();</span>
<a href="#l3.8768"></a><span id="l3.8768" class="difflineminus">-    nsCString command (GetServerCommandTag());</span>
<a href="#l3.8769"></a><span id="l3.8769" class="difflineplus">+    nsCString command(GetServerCommandTag());</span>
<a href="#l3.8770"></a><span id="l3.8770">     nsAutoCString escapedUserName;</span>
<a href="#l3.8771"></a><span id="l3.8771">     command.AppendLiteral(&quot; login \&quot;&quot;);</span>
<a href="#l3.8772"></a><span id="l3.8772">     EscapeUserNamePasswordString(userName, &amp;escapedUserName);</span>
<a href="#l3.8773"></a><span id="l3.8773">     command.Append(escapedUserName);</span>
<a href="#l3.8774"></a><span id="l3.8774">     command.AppendLiteral(&quot;\&quot; \&quot;&quot;);</span>
<a href="#l3.8775"></a><span id="l3.8775"> </span>
<a href="#l3.8776"></a><span id="l3.8776">     // if the password contains a \, login will fail</span>
<a href="#l3.8777"></a><span id="l3.8777">     // turn foo\bar into foo\\bar</span>
<a href="#l3.8778"></a><span id="l3.8778" class="difflineat">@@ -6295,589 +5782,526 @@ nsresult nsImapProtocol::AuthLogin(const</span>
<a href="#l3.8779"></a><span id="l3.8779">     // We're assuming old style login doesn't want UTF-8</span>
<a href="#l3.8780"></a><span id="l3.8780">     EscapeUserNamePasswordString(NS_LossyConvertUTF16toASCII(aPassword).get(),</span>
<a href="#l3.8781"></a><span id="l3.8781">                                  &amp;correctedPassword);</span>
<a href="#l3.8782"></a><span id="l3.8782">     command.Append(correctedPassword);</span>
<a href="#l3.8783"></a><span id="l3.8783">     command.AppendLiteral(&quot;\&quot;&quot; CRLF);</span>
<a href="#l3.8784"></a><span id="l3.8784">     rv = SendData(command.get(), true /* suppress logging */);</span>
<a href="#l3.8785"></a><span id="l3.8785">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8786"></a><span id="l3.8786">     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8787"></a><span id="l3.8787" class="difflineminus">-  }</span>
<a href="#l3.8788"></a><span id="l3.8788" class="difflineminus">-  else if (flag &amp; kHasXOAuth2Capability)</span>
<a href="#l3.8789"></a><span id="l3.8789" class="difflineminus">-  {</span>
<a href="#l3.8790"></a><span id="l3.8790" class="difflineplus">+  } else if (flag &amp; kHasXOAuth2Capability) {</span>
<a href="#l3.8791"></a><span id="l3.8791">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;XOAUTH2 auth&quot;));</span>
<a href="#l3.8792"></a><span id="l3.8792"> </span>
<a href="#l3.8793"></a><span id="l3.8793">     // Get the XOAuth2 base64 string.</span>
<a href="#l3.8794"></a><span id="l3.8794">     NS_ASSERTION(mOAuth2Support,</span>
<a href="#l3.8795"></a><span id="l3.8795" class="difflineminus">-      &quot;What are we doing here without OAuth2 helper?&quot;);</span>
<a href="#l3.8796"></a><span id="l3.8796" class="difflineminus">-    if (!mOAuth2Support)</span>
<a href="#l3.8797"></a><span id="l3.8797" class="difflineminus">-      return NS_ERROR_UNEXPECTED;</span>
<a href="#l3.8798"></a><span id="l3.8798" class="difflineplus">+                 &quot;What are we doing here without OAuth2 helper?&quot;);</span>
<a href="#l3.8799"></a><span id="l3.8799" class="difflineplus">+    if (!mOAuth2Support) return NS_ERROR_UNEXPECTED;</span>
<a href="#l3.8800"></a><span id="l3.8800">     nsAutoCString base64Str;</span>
<a href="#l3.8801"></a><span id="l3.8801">     mOAuth2Support-&gt;GetXOAuth2String(base64Str);</span>
<a href="#l3.8802"></a><span id="l3.8802" class="difflineminus">-    mOAuth2Support = nullptr; // Its purpose has been served.</span>
<a href="#l3.8803"></a><span id="l3.8803" class="difflineminus">-    if (base64Str.IsEmpty())</span>
<a href="#l3.8804"></a><span id="l3.8804" class="difflineminus">-    {</span>
<a href="#l3.8805"></a><span id="l3.8805" class="difflineplus">+    mOAuth2Support = nullptr;  // Its purpose has been served.</span>
<a href="#l3.8806"></a><span id="l3.8806" class="difflineplus">+    if (base64Str.IsEmpty()) {</span>
<a href="#l3.8807"></a><span id="l3.8807">       MOZ_LOG(IMAP, LogLevel::Debug, (&quot;OAuth2 failed&quot;));</span>
<a href="#l3.8808"></a><span id="l3.8808">       return NS_ERROR_FAILURE;</span>
<a href="#l3.8809"></a><span id="l3.8809">     }</span>
<a href="#l3.8810"></a><span id="l3.8810"> </span>
<a href="#l3.8811"></a><span id="l3.8811">     // Send the data on the network.</span>
<a href="#l3.8812"></a><span id="l3.8812" class="difflineminus">-    nsAutoCString command (GetServerCommandTag());</span>
<a href="#l3.8813"></a><span id="l3.8813" class="difflineplus">+    nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.8814"></a><span id="l3.8814">     command += &quot; AUTHENTICATE XOAUTH2 &quot;;</span>
<a href="#l3.8815"></a><span id="l3.8815">     command += base64Str;</span>
<a href="#l3.8816"></a><span id="l3.8816">     command += CRLF;</span>
<a href="#l3.8817"></a><span id="l3.8817"> </span>
<a href="#l3.8818"></a><span id="l3.8818">     rv = SendDataParseIMAPandCheckForNewMail(command.get(), nullptr);</span>
<a href="#l3.8819"></a><span id="l3.8819" class="difflineminus">-  }</span>
<a href="#l3.8820"></a><span id="l3.8820" class="difflineminus">-  else if (flag &amp; kHasAuthNoneCapability)</span>
<a href="#l3.8821"></a><span id="l3.8821" class="difflineminus">-  {</span>
<a href="#l3.8822"></a><span id="l3.8822" class="difflineplus">+  } else if (flag &amp; kHasAuthNoneCapability) {</span>
<a href="#l3.8823"></a><span id="l3.8823">     // TODO What to do? &quot;login &lt;username&gt;&quot; like POP?</span>
<a href="#l3.8824"></a><span id="l3.8824">     return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l3.8825"></a><span id="l3.8825" class="difflineminus">-  }</span>
<a href="#l3.8826"></a><span id="l3.8826" class="difflineminus">-  else</span>
<a href="#l3.8827"></a><span id="l3.8827" class="difflineminus">-  {</span>
<a href="#l3.8828"></a><span id="l3.8828" class="difflineplus">+  } else {</span>
<a href="#l3.8829"></a><span id="l3.8829">     MOZ_LOG(IMAP, LogLevel::Error, (&quot;flags param has no auth scheme selected&quot;));</span>
<a href="#l3.8830"></a><span id="l3.8830">     return NS_ERROR_ILLEGAL_VALUE;</span>
<a href="#l3.8831"></a><span id="l3.8831">   }</span>
<a href="#l3.8832"></a><span id="l3.8832"> </span>
<a href="#l3.8833"></a><span id="l3.8833">   PR_Free(currentCommand);</span>
<a href="#l3.8834"></a><span id="l3.8834">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.8835"></a><span id="l3.8835" class="difflineminus">-  return GetServerStateParser().LastCommandSuccessful() ?</span>
<a href="#l3.8836"></a><span id="l3.8836" class="difflineminus">-           NS_OK : NS_ERROR_FAILURE;</span>
<a href="#l3.8837"></a><span id="l3.8837" class="difflineminus">-}</span>
<a href="#l3.8838"></a><span id="l3.8838" class="difflineminus">-</span>
<a href="#l3.8839"></a><span id="l3.8839" class="difflineminus">-void nsImapProtocol::OnLSubFolders()</span>
<a href="#l3.8840"></a><span id="l3.8840" class="difflineminus">-{</span>
<a href="#l3.8841"></a><span id="l3.8841" class="difflineplus">+  return GetServerStateParser().LastCommandSuccessful() ? NS_OK</span>
<a href="#l3.8842"></a><span id="l3.8842" class="difflineplus">+                                                        : NS_ERROR_FAILURE;</span>
<a href="#l3.8843"></a><span id="l3.8843" class="difflineplus">+}</span>
<a href="#l3.8844"></a><span id="l3.8844" class="difflineplus">+</span>
<a href="#l3.8845"></a><span id="l3.8845" class="difflineplus">+void nsImapProtocol::OnLSubFolders() {</span>
<a href="#l3.8846"></a><span id="l3.8846">   // **** use to find out whether Drafts, Sent, &amp; Templates folder</span>
<a href="#l3.8847"></a><span id="l3.8847">   // exists or not even the user didn't subscribe to it</span>
<a href="#l3.8848"></a><span id="l3.8848">   char *mailboxName = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.8849"></a><span id="l3.8849" class="difflineminus">-  if (mailboxName)</span>
<a href="#l3.8850"></a><span id="l3.8850" class="difflineminus">-  {</span>
<a href="#l3.8851"></a><span id="l3.8851" class="difflineplus">+  if (mailboxName) {</span>
<a href="#l3.8852"></a><span id="l3.8852">     ProgressEventFunctionUsingName(&quot;imapStatusLookingForMailbox&quot;);</span>
<a href="#l3.8853"></a><span id="l3.8853">     IncrementCommandTagNumber();</span>
<a href="#l3.8854"></a><span id="l3.8854" class="difflineminus">-    PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE,&quot;%s list \&quot;\&quot; \&quot;%s\&quot;&quot; CRLF, GetServerCommandTag(), mailboxName);</span>
<a href="#l3.8855"></a><span id="l3.8855" class="difflineplus">+    PR_snprintf(m_dataOutputBuf, OUTPUT_BUFFER_SIZE, &quot;%s list \&quot;\&quot; \&quot;%s\&quot;&quot; CRLF,</span>
<a href="#l3.8856"></a><span id="l3.8856" class="difflineplus">+                GetServerCommandTag(), mailboxName);</span>
<a href="#l3.8857"></a><span id="l3.8857">     nsresult rv = SendData(m_dataOutputBuf);</span>
<a href="#l3.8858"></a><span id="l3.8858" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.8859"></a><span id="l3.8859" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8860"></a><span id="l3.8860" class="difflineplus">+    if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.8861"></a><span id="l3.8861">     PR_Free(mailboxName);</span>
<a href="#l3.8862"></a><span id="l3.8862" class="difflineminus">-  }</span>
<a href="#l3.8863"></a><span id="l3.8863" class="difflineminus">-  else</span>
<a href="#l3.8864"></a><span id="l3.8864" class="difflineminus">-  {</span>
<a href="#l3.8865"></a><span id="l3.8865" class="difflineplus">+  } else {</span>
<a href="#l3.8866"></a><span id="l3.8866">     HandleMemoryFailure();</span>
<a href="#l3.8867"></a><span id="l3.8867">   }</span>
<a href="#l3.8868"></a><span id="l3.8868" class="difflineminus">-</span>
<a href="#l3.8869"></a><span id="l3.8869" class="difflineminus">-}</span>
<a href="#l3.8870"></a><span id="l3.8870" class="difflineminus">-</span>
<a href="#l3.8871"></a><span id="l3.8871" class="difflineminus">-void nsImapProtocol::OnAppendMsgFromFile()</span>
<a href="#l3.8872"></a><span id="l3.8872" class="difflineminus">-{</span>
<a href="#l3.8873"></a><span id="l3.8873" class="difflineplus">+}</span>
<a href="#l3.8874"></a><span id="l3.8874" class="difflineplus">+</span>
<a href="#l3.8875"></a><span id="l3.8875" class="difflineplus">+void nsImapProtocol::OnAppendMsgFromFile() {</span>
<a href="#l3.8876"></a><span id="l3.8876">   nsCOMPtr&lt;nsIFile&gt; file;</span>
<a href="#l3.8877"></a><span id="l3.8877">   nsresult rv = NS_OK;</span>
<a href="#l3.8878"></a><span id="l3.8878">   rv = m_runningUrl-&gt;GetMsgFile(getter_AddRefs(file));</span>
<a href="#l3.8879"></a><span id="l3.8879" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; file)</span>
<a href="#l3.8880"></a><span id="l3.8880" class="difflineminus">-  {</span>
<a href="#l3.8881"></a><span id="l3.8881" class="difflineminus">-    char *mailboxName =  OnCreateServerSourceFolderPathString();</span>
<a href="#l3.8882"></a><span id="l3.8882" class="difflineminus">-    if (mailboxName)</span>
<a href="#l3.8883"></a><span id="l3.8883" class="difflineminus">-    {</span>
<a href="#l3.8884"></a><span id="l3.8884" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; file) {</span>
<a href="#l3.8885"></a><span id="l3.8885" class="difflineplus">+    char *mailboxName = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.8886"></a><span id="l3.8886" class="difflineplus">+    if (mailboxName) {</span>
<a href="#l3.8887"></a><span id="l3.8887">       imapMessageFlagsType flagsToSet = 0;</span>
<a href="#l3.8888"></a><span id="l3.8888">       uint32_t msgFlags = 0;</span>
<a href="#l3.8889"></a><span id="l3.8889">       PRTime date = 0;</span>
<a href="#l3.8890"></a><span id="l3.8890">       nsCString keywords;</span>
<a href="#l3.8891"></a><span id="l3.8891">       if (m_imapMessageSink)</span>
<a href="#l3.8892"></a><span id="l3.8892">         m_imapMessageSink-&gt;GetCurMoveCopyMessageInfo(m_runningUrl, &amp;date,</span>
<a href="#l3.8893"></a><span id="l3.8893">                                                      keywords, &amp;msgFlags);</span>
<a href="#l3.8894"></a><span id="l3.8894"> </span>
<a href="#l3.8895"></a><span id="l3.8895" class="difflineminus">-      if (msgFlags &amp; nsMsgMessageFlags::Read)</span>
<a href="#l3.8896"></a><span id="l3.8896" class="difflineminus">-        flagsToSet |= kImapMsgSeenFlag;</span>
<a href="#l3.8897"></a><span id="l3.8897" class="difflineplus">+      if (msgFlags &amp; nsMsgMessageFlags::Read) flagsToSet |= kImapMsgSeenFlag;</span>
<a href="#l3.8898"></a><span id="l3.8898">       if (msgFlags &amp; nsMsgMessageFlags::MDNReportSent)</span>
<a href="#l3.8899"></a><span id="l3.8899">         flagsToSet |= kImapMsgMDNSentFlag;</span>
<a href="#l3.8900"></a><span id="l3.8900">       // convert msg flag label (0xE000000) to imap flag label (0x0E00)</span>
<a href="#l3.8901"></a><span id="l3.8901">       if (msgFlags &amp; nsMsgMessageFlags::Labels)</span>
<a href="#l3.8902"></a><span id="l3.8902">         flagsToSet |= (msgFlags &amp; nsMsgMessageFlags::Labels) &gt;&gt; 16;</span>
<a href="#l3.8903"></a><span id="l3.8903">       if (msgFlags &amp; nsMsgMessageFlags::Marked)</span>
<a href="#l3.8904"></a><span id="l3.8904">         flagsToSet |= kImapMsgFlaggedFlag;</span>
<a href="#l3.8905"></a><span id="l3.8905">       if (msgFlags &amp; nsMsgMessageFlags::Replied)</span>
<a href="#l3.8906"></a><span id="l3.8906">         flagsToSet |= kImapMsgAnsweredFlag;</span>
<a href="#l3.8907"></a><span id="l3.8907">       if (msgFlags &amp; nsMsgMessageFlags::Forwarded)</span>
<a href="#l3.8908"></a><span id="l3.8908">         flagsToSet |= kImapMsgForwardedFlag;</span>
<a href="#l3.8909"></a><span id="l3.8909"> </span>
<a href="#l3.8910"></a><span id="l3.8910">       // If the message copied was a draft, flag it as such</span>
<a href="#l3.8911"></a><span id="l3.8911">       nsImapAction imapAction;</span>
<a href="#l3.8912"></a><span id="l3.8912">       rv = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.8913"></a><span id="l3.8913" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; (imapAction == nsIImapUrl::nsImapAppendDraftFromFile))</span>
<a href="#l3.8914"></a><span id="l3.8914" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp;</span>
<a href="#l3.8915"></a><span id="l3.8915" class="difflineplus">+          (imapAction == nsIImapUrl::nsImapAppendDraftFromFile))</span>
<a href="#l3.8916"></a><span id="l3.8916">         flagsToSet |= kImapMsgDraftFlag;</span>
<a href="#l3.8917"></a><span id="l3.8917">       UploadMessageFromFile(file, mailboxName, date, flagsToSet, keywords);</span>
<a href="#l3.8918"></a><span id="l3.8918" class="difflineminus">-      PR_Free( mailboxName );</span>
<a href="#l3.8919"></a><span id="l3.8919" class="difflineminus">-    }</span>
<a href="#l3.8920"></a><span id="l3.8920" class="difflineminus">-    else</span>
<a href="#l3.8921"></a><span id="l3.8921" class="difflineminus">-    {</span>
<a href="#l3.8922"></a><span id="l3.8922" class="difflineplus">+      PR_Free(mailboxName);</span>
<a href="#l3.8923"></a><span id="l3.8923" class="difflineplus">+    } else {</span>
<a href="#l3.8924"></a><span id="l3.8924">       HandleMemoryFailure();</span>
<a href="#l3.8925"></a><span id="l3.8925">     }</span>
<a href="#l3.8926"></a><span id="l3.8926">   }</span>
<a href="#l3.8927"></a><span id="l3.8927"> }</span>
<a href="#l3.8928"></a><span id="l3.8928"> </span>
<a href="#l3.8929"></a><span id="l3.8929" class="difflineminus">-void nsImapProtocol::UploadMessageFromFile (nsIFile* file,</span>
<a href="#l3.8930"></a><span id="l3.8930" class="difflineminus">-                                            const char* mailboxName,</span>
<a href="#l3.8931"></a><span id="l3.8931" class="difflineminus">-                                            PRTime date,</span>
<a href="#l3.8932"></a><span id="l3.8932" class="difflineminus">-                                            imapMessageFlagsType flags,</span>
<a href="#l3.8933"></a><span id="l3.8933" class="difflineminus">-                                            nsCString &amp;keywords)</span>
<a href="#l3.8934"></a><span id="l3.8934" class="difflineminus">-{</span>
<a href="#l3.8935"></a><span id="l3.8935" class="difflineplus">+void nsImapProtocol::UploadMessageFromFile(nsIFile *file,</span>
<a href="#l3.8936"></a><span id="l3.8936" class="difflineplus">+                                           const char *mailboxName, PRTime date,</span>
<a href="#l3.8937"></a><span id="l3.8937" class="difflineplus">+                                           imapMessageFlagsType flags,</span>
<a href="#l3.8938"></a><span id="l3.8938" class="difflineplus">+                                           nsCString &amp;keywords) {</span>
<a href="#l3.8939"></a><span id="l3.8939">   if (!file || !mailboxName) return;</span>
<a href="#l3.8940"></a><span id="l3.8940">   IncrementCommandTagNumber();</span>
<a href="#l3.8941"></a><span id="l3.8941"> </span>
<a href="#l3.8942"></a><span id="l3.8942">   int64_t fileSize = 0;</span>
<a href="#l3.8943"></a><span id="l3.8943">   int64_t totalSize;</span>
<a href="#l3.8944"></a><span id="l3.8944">   uint32_t readCount;</span>
<a href="#l3.8945"></a><span id="l3.8945">   char *dataBuffer = nullptr;</span>
<a href="#l3.8946"></a><span id="l3.8946">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.8947"></a><span id="l3.8947">   nsCString escapedName;</span>
<a href="#l3.8948"></a><span id="l3.8948">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.8949"></a><span id="l3.8949">   nsresult rv;</span>
<a href="#l3.8950"></a><span id="l3.8950">   bool eof = false;</span>
<a href="#l3.8951"></a><span id="l3.8951">   nsCString flagString;</span>
<a href="#l3.8952"></a><span id="l3.8952"> </span>
<a href="#l3.8953"></a><span id="l3.8953" class="difflineminus">-  nsCOMPtr &lt;nsIInputStream&gt; fileInputStream;</span>
<a href="#l3.8954"></a><span id="l3.8954" class="difflineminus">-</span>
<a href="#l3.8955"></a><span id="l3.8955" class="difflineminus">-  if (!escapedName.IsEmpty())</span>
<a href="#l3.8956"></a><span id="l3.8956" class="difflineminus">-  {</span>
<a href="#l3.8957"></a><span id="l3.8957" class="difflineplus">+  nsCOMPtr&lt;nsIInputStream&gt; fileInputStream;</span>
<a href="#l3.8958"></a><span id="l3.8958" class="difflineplus">+</span>
<a href="#l3.8959"></a><span id="l3.8959" class="difflineplus">+  if (!escapedName.IsEmpty()) {</span>
<a href="#l3.8960"></a><span id="l3.8960">     command.AppendLiteral(&quot; append \&quot;&quot;);</span>
<a href="#l3.8961"></a><span id="l3.8961">     command.Append(escapedName);</span>
<a href="#l3.8962"></a><span id="l3.8962">     command.Append('&quot;');</span>
<a href="#l3.8963"></a><span id="l3.8963" class="difflineminus">-    if (flags || keywords.Length())</span>
<a href="#l3.8964"></a><span id="l3.8964" class="difflineminus">-    {</span>
<a href="#l3.8965"></a><span id="l3.8965" class="difflineplus">+    if (flags || keywords.Length()) {</span>
<a href="#l3.8966"></a><span id="l3.8966">       command.AppendLiteral(&quot; (&quot;);</span>
<a href="#l3.8967"></a><span id="l3.8967"> </span>
<a href="#l3.8968"></a><span id="l3.8968" class="difflineminus">-      if (flags)</span>
<a href="#l3.8969"></a><span id="l3.8969" class="difflineminus">-      {</span>
<a href="#l3.8970"></a><span id="l3.8970" class="difflineplus">+      if (flags) {</span>
<a href="#l3.8971"></a><span id="l3.8971">         SetupMessageFlagsString(flagString, flags,</span>
<a href="#l3.8972"></a><span id="l3.8972" class="difflineminus">-          GetServerStateParser().SupportsUserFlags());</span>
<a href="#l3.8973"></a><span id="l3.8973" class="difflineplus">+                                GetServerStateParser().SupportsUserFlags());</span>
<a href="#l3.8974"></a><span id="l3.8974">         command.Append(flagString);</span>
<a href="#l3.8975"></a><span id="l3.8975">       }</span>
<a href="#l3.8976"></a><span id="l3.8976" class="difflineminus">-      if (keywords.Length())</span>
<a href="#l3.8977"></a><span id="l3.8977" class="difflineminus">-      {</span>
<a href="#l3.8978"></a><span id="l3.8978" class="difflineminus">-        if (flags)</span>
<a href="#l3.8979"></a><span id="l3.8979" class="difflineminus">-          command.Append(' ');</span>
<a href="#l3.8980"></a><span id="l3.8980" class="difflineplus">+      if (keywords.Length()) {</span>
<a href="#l3.8981"></a><span id="l3.8981" class="difflineplus">+        if (flags) command.Append(' ');</span>
<a href="#l3.8982"></a><span id="l3.8982">         command.Append(keywords);</span>
<a href="#l3.8983"></a><span id="l3.8983">       }</span>
<a href="#l3.8984"></a><span id="l3.8984">       command.Append(')');</span>
<a href="#l3.8985"></a><span id="l3.8985">     }</span>
<a href="#l3.8986"></a><span id="l3.8986"> </span>
<a href="#l3.8987"></a><span id="l3.8987">     // date should never be 0, but just in case...</span>
<a href="#l3.8988"></a><span id="l3.8988" class="difflineminus">-    if (date)</span>
<a href="#l3.8989"></a><span id="l3.8989" class="difflineminus">-    {</span>
<a href="#l3.8990"></a><span id="l3.8990" class="difflineplus">+    if (date) {</span>
<a href="#l3.8991"></a><span id="l3.8991">       /* Use PR_FormatTimeUSEnglish() to format the date in US English format,</span>
<a href="#l3.8992"></a><span id="l3.8992">         then figure out what our local GMT offset is, and append it (since</span>
<a href="#l3.8993"></a><span id="l3.8993">         PR_FormatTimeUSEnglish() can't do that.) Generate four digit years as</span>
<a href="#l3.8994"></a><span id="l3.8994">         per RFC 1123 (superseding RFC 822.)</span>
<a href="#l3.8995"></a><span id="l3.8995">         */</span>
<a href="#l3.8996"></a><span id="l3.8996">       char szDateTime[64];</span>
<a href="#l3.8997"></a><span id="l3.8997">       char dateStr[100];</span>
<a href="#l3.8998"></a><span id="l3.8998">       PRExplodedTime exploded;</span>
<a href="#l3.8999"></a><span id="l3.8999">       PR_ExplodeTime(date, PR_LocalTimeParameters, &amp;exploded);</span>
<a href="#l3.9000"></a><span id="l3.9000" class="difflineminus">-      PR_FormatTimeUSEnglish(szDateTime, sizeof(szDateTime), &quot;%d-%b-%Y %H:%M:%S&quot;, &amp;exploded);</span>
<a href="#l3.9001"></a><span id="l3.9001" class="difflineplus">+      PR_FormatTimeUSEnglish(szDateTime, sizeof(szDateTime),</span>
<a href="#l3.9002"></a><span id="l3.9002" class="difflineplus">+                             &quot;%d-%b-%Y %H:%M:%S&quot;, &amp;exploded);</span>
<a href="#l3.9003"></a><span id="l3.9003">       PRExplodedTime now;</span>
<a href="#l3.9004"></a><span id="l3.9004">       PR_ExplodeTime(PR_Now(), PR_LocalTimeParameters, &amp;now);</span>
<a href="#l3.9005"></a><span id="l3.9005" class="difflineminus">-      int gmtoffset = (now.tm_params.tp_gmt_offset + now.tm_params.tp_dst_offset) / 60;</span>
<a href="#l3.9006"></a><span id="l3.9006" class="difflineminus">-      PR_snprintf(dateStr, sizeof(dateStr),</span>
<a href="#l3.9007"></a><span id="l3.9007" class="difflineminus">-                            &quot; \&quot;%s %c%02d%02d\&quot;&quot;,</span>
<a href="#l3.9008"></a><span id="l3.9008" class="difflineminus">-                            szDateTime,</span>
<a href="#l3.9009"></a><span id="l3.9009" class="difflineminus">-                            (gmtoffset &gt;= 0 ? '+' : '-'),</span>
<a href="#l3.9010"></a><span id="l3.9010" class="difflineminus">-                            ((gmtoffset &gt;= 0 ? gmtoffset : -gmtoffset) / 60),</span>
<a href="#l3.9011"></a><span id="l3.9011" class="difflineminus">-                            ((gmtoffset &gt;= 0 ? gmtoffset : -gmtoffset) % 60));</span>
<a href="#l3.9012"></a><span id="l3.9012" class="difflineplus">+      int gmtoffset =</span>
<a href="#l3.9013"></a><span id="l3.9013" class="difflineplus">+          (now.tm_params.tp_gmt_offset + now.tm_params.tp_dst_offset) / 60;</span>
<a href="#l3.9014"></a><span id="l3.9014" class="difflineplus">+      PR_snprintf(dateStr, sizeof(dateStr), &quot; \&quot;%s %c%02d%02d\&quot;&quot;, szDateTime,</span>
<a href="#l3.9015"></a><span id="l3.9015" class="difflineplus">+                  (gmtoffset &gt;= 0 ? '+' : '-'),</span>
<a href="#l3.9016"></a><span id="l3.9016" class="difflineplus">+                  ((gmtoffset &gt;= 0 ? gmtoffset : -gmtoffset) / 60),</span>
<a href="#l3.9017"></a><span id="l3.9017" class="difflineplus">+                  ((gmtoffset &gt;= 0 ? gmtoffset : -gmtoffset) % 60));</span>
<a href="#l3.9018"></a><span id="l3.9018"> </span>
<a href="#l3.9019"></a><span id="l3.9019">       command.Append(dateStr);</span>
<a href="#l3.9020"></a><span id="l3.9020">     }</span>
<a href="#l3.9021"></a><span id="l3.9021">     command.AppendLiteral(&quot; {&quot;);</span>
<a href="#l3.9022"></a><span id="l3.9022"> </span>
<a href="#l3.9023"></a><span id="l3.9023" class="difflineminus">-    dataBuffer = (char*) PR_CALLOC(COPY_BUFFER_SIZE+1);</span>
<a href="#l3.9024"></a><span id="l3.9024" class="difflineplus">+    dataBuffer = (char *)PR_CALLOC(COPY_BUFFER_SIZE + 1);</span>
<a href="#l3.9025"></a><span id="l3.9025">     if (!dataBuffer) goto done;</span>
<a href="#l3.9026"></a><span id="l3.9026">     rv = file-&gt;GetFileSize(&amp;fileSize);</span>
<a href="#l3.9027"></a><span id="l3.9027">     NS_ASSERTION(fileSize, &quot;got empty file in UploadMessageFromFile&quot;);</span>
<a href="#l3.9028"></a><span id="l3.9028">     if (NS_FAILED(rv) || !fileSize) goto done;</span>
<a href="#l3.9029"></a><span id="l3.9029">     rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInputStream), file);</span>
<a href="#l3.9030"></a><span id="l3.9030">     if (NS_FAILED(rv) || !fileInputStream) goto done;</span>
<a href="#l3.9031"></a><span id="l3.9031">     command.AppendInt((int32_t)fileSize);</span>
<a href="#l3.9032"></a><span id="l3.9032"> </span>
<a href="#l3.9033"></a><span id="l3.9033">     // Set useLiteralPlus to true if server has capability LITERAL+ and</span>
<a href="#l3.9034"></a><span id="l3.9034">     // LITERAL+ usage is enabled in the config editor,</span>
<a href="#l3.9035"></a><span id="l3.9035">     // i.e., &quot;mail.imap.use_literal_plus&quot; = true.</span>
<a href="#l3.9036"></a><span id="l3.9036" class="difflineminus">-    bool useLiteralPlus = (GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.9037"></a><span id="l3.9037" class="difflineminus">-                          kLiteralPlusCapability) &amp;&amp; gUseLiteralPlus;</span>
<a href="#l3.9038"></a><span id="l3.9038" class="difflineplus">+    bool useLiteralPlus =</span>
<a href="#l3.9039"></a><span id="l3.9039" class="difflineplus">+        (GetServerStateParser().GetCapabilityFlag() &amp; kLiteralPlusCapability) &amp;&amp;</span>
<a href="#l3.9040"></a><span id="l3.9040" class="difflineplus">+        gUseLiteralPlus;</span>
<a href="#l3.9041"></a><span id="l3.9041">     if (useLiteralPlus)</span>
<a href="#l3.9042"></a><span id="l3.9042">       command.AppendLiteral(&quot;+}&quot; CRLF);</span>
<a href="#l3.9043"></a><span id="l3.9043">     else</span>
<a href="#l3.9044"></a><span id="l3.9044">       command.AppendLiteral(&quot;}&quot; CRLF);</span>
<a href="#l3.9045"></a><span id="l3.9045"> </span>
<a href="#l3.9046"></a><span id="l3.9046">     rv = SendData(command.get());</span>
<a href="#l3.9047"></a><span id="l3.9047">     if (NS_FAILED(rv)) goto done;</span>
<a href="#l3.9048"></a><span id="l3.9048"> </span>
<a href="#l3.9049"></a><span id="l3.9049" class="difflineminus">-    if (!useLiteralPlus)</span>
<a href="#l3.9050"></a><span id="l3.9050" class="difflineminus">-    {</span>
<a href="#l3.9051"></a><span id="l3.9051" class="difflineplus">+    if (!useLiteralPlus) {</span>
<a href="#l3.9052"></a><span id="l3.9052">       ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9053"></a><span id="l3.9053" class="difflineminus">-      if (!GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.9054"></a><span id="l3.9054" class="difflineminus">-        goto done;</span>
<a href="#l3.9055"></a><span id="l3.9055" class="difflineplus">+      if (!GetServerStateParser().LastCommandSuccessful()) goto done;</span>
<a href="#l3.9056"></a><span id="l3.9056">     }</span>
<a href="#l3.9057"></a><span id="l3.9057"> </span>
<a href="#l3.9058"></a><span id="l3.9058">     totalSize = fileSize;</span>
<a href="#l3.9059"></a><span id="l3.9059">     readCount = 0;</span>
<a href="#l3.9060"></a><span id="l3.9060" class="difflineminus">-    while(NS_SUCCEEDED(rv) &amp;&amp; !eof &amp;&amp; totalSize &gt; 0)</span>
<a href="#l3.9061"></a><span id="l3.9061" class="difflineminus">-    {</span>
<a href="#l3.9062"></a><span id="l3.9062" class="difflineplus">+    while (NS_SUCCEEDED(rv) &amp;&amp; !eof &amp;&amp; totalSize &gt; 0) {</span>
<a href="#l3.9063"></a><span id="l3.9063">       rv = fileInputStream-&gt;Read(dataBuffer, COPY_BUFFER_SIZE, &amp;readCount);</span>
<a href="#l3.9064"></a><span id="l3.9064" class="difflineminus">-      if (NS_SUCCEEDED(rv) &amp;&amp; !readCount)</span>
<a href="#l3.9065"></a><span id="l3.9065" class="difflineminus">-        rv = NS_ERROR_FAILURE;</span>
<a href="#l3.9066"></a><span id="l3.9066" class="difflineminus">-</span>
<a href="#l3.9067"></a><span id="l3.9067" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9068"></a><span id="l3.9068" class="difflineminus">-      {</span>
<a href="#l3.9069"></a><span id="l3.9069" class="difflineminus">-        NS_ASSERTION(readCount &lt;= (uint32_t) totalSize, &quot;got more bytes than there should be&quot;);</span>
<a href="#l3.9070"></a><span id="l3.9070" class="difflineplus">+      if (NS_SUCCEEDED(rv) &amp;&amp; !readCount) rv = NS_ERROR_FAILURE;</span>
<a href="#l3.9071"></a><span id="l3.9071" class="difflineplus">+</span>
<a href="#l3.9072"></a><span id="l3.9072" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.9073"></a><span id="l3.9073" class="difflineplus">+        NS_ASSERTION(readCount &lt;= (uint32_t)totalSize,</span>
<a href="#l3.9074"></a><span id="l3.9074" class="difflineplus">+                     &quot;got more bytes than there should be&quot;);</span>
<a href="#l3.9075"></a><span id="l3.9075">         dataBuffer[readCount] = 0;</span>
<a href="#l3.9076"></a><span id="l3.9076">         rv = SendData(dataBuffer);</span>
<a href="#l3.9077"></a><span id="l3.9077">         totalSize -= readCount;</span>
<a href="#l3.9078"></a><span id="l3.9078">         PercentProgressUpdateEvent(nullptr, fileSize - totalSize, fileSize);</span>
<a href="#l3.9079"></a><span id="l3.9079">       }</span>
<a href="#l3.9080"></a><span id="l3.9080">     }</span>
<a href="#l3.9081"></a><span id="l3.9081" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9082"></a><span id="l3.9082" class="difflineminus">-    {</span>
<a href="#l3.9083"></a><span id="l3.9083" class="difflineminus">-      rv = SendData(CRLF); // complete the append</span>
<a href="#l3.9084"></a><span id="l3.9084" class="difflineplus">+    if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.9085"></a><span id="l3.9085" class="difflineplus">+      rv = SendData(CRLF);  // complete the append</span>
<a href="#l3.9086"></a><span id="l3.9086">       ParseIMAPandCheckForNewMail(command.get());</span>
<a href="#l3.9087"></a><span id="l3.9087"> </span>
<a href="#l3.9088"></a><span id="l3.9088">       nsImapAction imapAction;</span>
<a href="#l3.9089"></a><span id="l3.9089">       m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.9090"></a><span id="l3.9090"> </span>
<a href="#l3.9091"></a><span id="l3.9091" class="difflineminus">-      if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;  (</span>
<a href="#l3.9092"></a><span id="l3.9092" class="difflineminus">-        imapAction == nsIImapUrl::nsImapAppendDraftFromFile  || imapAction==nsIImapUrl::nsImapAppendMsgFromFile))</span>
<a href="#l3.9093"></a><span id="l3.9093" class="difflineminus">-      {</span>
<a href="#l3.9094"></a><span id="l3.9094" class="difflineminus">-        if (GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.9095"></a><span id="l3.9095" class="difflineminus">-          kUidplusCapability)</span>
<a href="#l3.9096"></a><span id="l3.9096" class="difflineminus">-        {</span>
<a href="#l3.9097"></a><span id="l3.9097" class="difflineplus">+      if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l3.9098"></a><span id="l3.9098" class="difflineplus">+          (imapAction == nsIImapUrl::nsImapAppendDraftFromFile ||</span>
<a href="#l3.9099"></a><span id="l3.9099" class="difflineplus">+           imapAction == nsIImapUrl::nsImapAppendMsgFromFile)) {</span>
<a href="#l3.9100"></a><span id="l3.9100" class="difflineplus">+        if (GetServerStateParser().GetCapabilityFlag() &amp; kUidplusCapability) {</span>
<a href="#l3.9101"></a><span id="l3.9101">           nsMsgKey newKey = GetServerStateParser().CurrentResponseUID();</span>
<a href="#l3.9102"></a><span id="l3.9102">           if (m_imapMailFolderSink)</span>
<a href="#l3.9103"></a><span id="l3.9103">             m_imapMailFolderSink-&gt;SetAppendMsgUid(newKey, m_runningUrl);</span>
<a href="#l3.9104"></a><span id="l3.9104"> </span>
<a href="#l3.9105"></a><span id="l3.9105">           // Courier imap server seems to have problems with recently</span>
<a href="#l3.9106"></a><span id="l3.9106">           // appended messages. Noop seems to clear its confusion.</span>
<a href="#l3.9107"></a><span id="l3.9107" class="difflineminus">-          if (FolderIsSelected(mailboxName))</span>
<a href="#l3.9108"></a><span id="l3.9108" class="difflineminus">-              Noop();</span>
<a href="#l3.9109"></a><span id="l3.9109" class="difflineplus">+          if (FolderIsSelected(mailboxName)) Noop();</span>
<a href="#l3.9110"></a><span id="l3.9110"> </span>
<a href="#l3.9111"></a><span id="l3.9111">           nsCString oldMsgId;</span>
<a href="#l3.9112"></a><span id="l3.9112">           rv = m_runningUrl-&gt;GetListOfMessageIds(oldMsgId);</span>
<a href="#l3.9113"></a><span id="l3.9113" class="difflineminus">-          if (NS_SUCCEEDED(rv) &amp;&amp; !oldMsgId.IsEmpty())</span>
<a href="#l3.9114"></a><span id="l3.9114" class="difflineminus">-          {</span>
<a href="#l3.9115"></a><span id="l3.9115" class="difflineplus">+          if (NS_SUCCEEDED(rv) &amp;&amp; !oldMsgId.IsEmpty()) {</span>
<a href="#l3.9116"></a><span id="l3.9116">             bool idsAreUids = true;</span>
<a href="#l3.9117"></a><span id="l3.9117">             m_runningUrl-&gt;MessageIdsAreUids(&amp;idsAreUids);</span>
<a href="#l3.9118"></a><span id="l3.9118">             Store(oldMsgId, &quot;+FLAGS (\\Deleted)&quot;, idsAreUids);</span>
<a href="#l3.9119"></a><span id="l3.9119">             UidExpunge(oldMsgId);</span>
<a href="#l3.9120"></a><span id="l3.9120">           }</span>
<a href="#l3.9121"></a><span id="l3.9121">         }</span>
<a href="#l3.9122"></a><span id="l3.9122" class="difflineminus">-        // for non UIDPLUS servers,</span>
<a href="#l3.9123"></a><span id="l3.9123" class="difflineminus">-        // this code used to check for imapAction==nsIImapUrl::nsImapAppendMsgFromFile, which</span>
<a href="#l3.9124"></a><span id="l3.9124" class="difflineminus">-        // meant we'd get into this code whenever sending a message, as well</span>
<a href="#l3.9125"></a><span id="l3.9125" class="difflineminus">-        // as when copying messages to an imap folder from local folders or an other imap server.</span>
<a href="#l3.9126"></a><span id="l3.9126" class="difflineminus">-        // This made sending a message slow when there was a large sent folder. I don't believe</span>
<a href="#l3.9127"></a><span id="l3.9127" class="difflineminus">-        // this code worked anyway.</span>
<a href="#l3.9128"></a><span id="l3.9128" class="difflineminus">-        else if (m_imapMailFolderSink &amp;&amp; imapAction == nsIImapUrl::nsImapAppendDraftFromFile )</span>
<a href="#l3.9129"></a><span id="l3.9129" class="difflineminus">-        {   // *** code me to search for the newly appended message</span>
<a href="#l3.9130"></a><span id="l3.9130" class="difflineplus">+        // for non UIDPLUS servers this code used to check for</span>
<a href="#l3.9131"></a><span id="l3.9131" class="difflineplus">+        // imapAction==nsIImapUrl::nsImapAppendMsgFromFile, which meant we'd get</span>
<a href="#l3.9132"></a><span id="l3.9132" class="difflineplus">+        // into this code whenever sending a message, as well as when copying</span>
<a href="#l3.9133"></a><span id="l3.9133" class="difflineplus">+        // messages to an imap folder from local folders or an other imap</span>
<a href="#l3.9134"></a><span id="l3.9134" class="difflineplus">+        // server. This made sending a message slow when there was a large sent</span>
<a href="#l3.9135"></a><span id="l3.9135" class="difflineplus">+        // folder. I don't believe this code worked anyway.</span>
<a href="#l3.9136"></a><span id="l3.9136" class="difflineplus">+        // *** code me to search for the newly appended message</span>
<a href="#l3.9137"></a><span id="l3.9137" class="difflineplus">+        else if (m_imapMailFolderSink &amp;&amp;</span>
<a href="#l3.9138"></a><span id="l3.9138" class="difflineplus">+                 imapAction == nsIImapUrl::nsImapAppendDraftFromFile) {</span>
<a href="#l3.9139"></a><span id="l3.9139">           // go to selected state</span>
<a href="#l3.9140"></a><span id="l3.9140">           nsCString messageId;</span>
<a href="#l3.9141"></a><span id="l3.9141">           rv = m_imapMailFolderSink-&gt;GetMessageId(m_runningUrl, messageId);</span>
<a href="#l3.9142"></a><span id="l3.9142">           if (NS_SUCCEEDED(rv) &amp;&amp; !messageId.IsEmpty() &amp;&amp;</span>
<a href="#l3.9143"></a><span id="l3.9143" class="difflineminus">-            GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.9144"></a><span id="l3.9144" class="difflineminus">-          {</span>
<a href="#l3.9145"></a><span id="l3.9145" class="difflineplus">+              GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.9146"></a><span id="l3.9146">             // if the appended to folder isn't selected in the connection,</span>
<a href="#l3.9147"></a><span id="l3.9147">             // select it.</span>
<a href="#l3.9148"></a><span id="l3.9148">             if (!FolderIsSelected(mailboxName))</span>
<a href="#l3.9149"></a><span id="l3.9149">               SelectMailbox(mailboxName);</span>
<a href="#l3.9150"></a><span id="l3.9150">             else</span>
<a href="#l3.9151"></a><span id="l3.9151" class="difflineminus">-              Noop(); // See if this makes SEARCH work on the newly appended msg.</span>
<a href="#l3.9152"></a><span id="l3.9152" class="difflineminus">-</span>
<a href="#l3.9153"></a><span id="l3.9153" class="difflineminus">-            if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.9154"></a><span id="l3.9154" class="difflineminus">-            {</span>
<a href="#l3.9155"></a><span id="l3.9155" class="difflineplus">+              Noop();  // See if this makes SEARCH work on the newly appended</span>
<a href="#l3.9156"></a><span id="l3.9156" class="difflineplus">+                       // msg.</span>
<a href="#l3.9157"></a><span id="l3.9157" class="difflineplus">+</span>
<a href="#l3.9158"></a><span id="l3.9158" class="difflineplus">+            if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.9159"></a><span id="l3.9159">               command = &quot;SEARCH UNDELETED HEADER Message-ID &quot;;</span>
<a href="#l3.9160"></a><span id="l3.9160">               command.Append(messageId);</span>
<a href="#l3.9161"></a><span id="l3.9161"> </span>
<a href="#l3.9162"></a><span id="l3.9162">               // Clean up result sequence before issuing the cmd.</span>
<a href="#l3.9163"></a><span id="l3.9163">               GetServerStateParser().ResetSearchResultSequence();</span>
<a href="#l3.9164"></a><span id="l3.9164"> </span>
<a href="#l3.9165"></a><span id="l3.9165">               Search(command.get(), true, false);</span>
<a href="#l3.9166"></a><span id="l3.9166" class="difflineminus">-              if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.9167"></a><span id="l3.9167" class="difflineminus">-              {</span>
<a href="#l3.9168"></a><span id="l3.9168" class="difflineplus">+              if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.9169"></a><span id="l3.9169">                 nsMsgKey newkey = nsMsgKey_None;</span>
<a href="#l3.9170"></a><span id="l3.9170">                 nsImapSearchResultIterator *searchResult =</span>
<a href="#l3.9171"></a><span id="l3.9171" class="difflineminus">-                  GetServerStateParser().CreateSearchResultIterator();</span>
<a href="#l3.9172"></a><span id="l3.9172" class="difflineplus">+                    GetServerStateParser().CreateSearchResultIterator();</span>
<a href="#l3.9173"></a><span id="l3.9173">                 newkey = searchResult-&gt;GetNextMessageNumber();</span>
<a href="#l3.9174"></a><span id="l3.9174">                 delete searchResult;</span>
<a href="#l3.9175"></a><span id="l3.9175">                 if (newkey != nsMsgKey_None)</span>
<a href="#l3.9176"></a><span id="l3.9176">                   m_imapMailFolderSink-&gt;SetAppendMsgUid(newkey, m_runningUrl);</span>
<a href="#l3.9177"></a><span id="l3.9177">               }</span>
<a href="#l3.9178"></a><span id="l3.9178">             }</span>
<a href="#l3.9179"></a><span id="l3.9179">           }</span>
<a href="#l3.9180"></a><span id="l3.9180">         }</span>
<a href="#l3.9181"></a><span id="l3.9181">       }</span>
<a href="#l3.9182"></a><span id="l3.9182">     }</span>
<a href="#l3.9183"></a><span id="l3.9183">   }</span>
<a href="#l3.9184"></a><span id="l3.9184"> done:</span>
<a href="#l3.9185"></a><span id="l3.9185">   PR_Free(dataBuffer);</span>
<a href="#l3.9186"></a><span id="l3.9186" class="difflineminus">-  if (fileInputStream)</span>
<a href="#l3.9187"></a><span id="l3.9187" class="difflineminus">-    fileInputStream-&gt;Close();</span>
<a href="#l3.9188"></a><span id="l3.9188" class="difflineminus">-}</span>
<a href="#l3.9189"></a><span id="l3.9189" class="difflineminus">-</span>
<a href="#l3.9190"></a><span id="l3.9190" class="difflineminus">-//caller must free using PR_Free</span>
<a href="#l3.9191"></a><span id="l3.9191" class="difflineminus">-char * nsImapProtocol::OnCreateServerSourceFolderPathString()</span>
<a href="#l3.9192"></a><span id="l3.9192" class="difflineminus">-{</span>
<a href="#l3.9193"></a><span id="l3.9193" class="difflineplus">+  if (fileInputStream) fileInputStream-&gt;Close();</span>
<a href="#l3.9194"></a><span id="l3.9194" class="difflineplus">+}</span>
<a href="#l3.9195"></a><span id="l3.9195" class="difflineplus">+</span>
<a href="#l3.9196"></a><span id="l3.9196" class="difflineplus">+// caller must free using PR_Free</span>
<a href="#l3.9197"></a><span id="l3.9197" class="difflineplus">+char *nsImapProtocol::OnCreateServerSourceFolderPathString() {</span>
<a href="#l3.9198"></a><span id="l3.9198">   char *sourceMailbox = nullptr;</span>
<a href="#l3.9199"></a><span id="l3.9199">   char hierarchyDelimiter = 0;</span>
<a href="#l3.9200"></a><span id="l3.9200">   char onlineDelimiter = 0;</span>
<a href="#l3.9201"></a><span id="l3.9201">   m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;hierarchyDelimiter);</span>
<a href="#l3.9202"></a><span id="l3.9202">   if (m_imapMailFolderSink)</span>
<a href="#l3.9203"></a><span id="l3.9203">     m_imapMailFolderSink-&gt;GetOnlineDelimiter(&amp;onlineDelimiter);</span>
<a href="#l3.9204"></a><span id="l3.9204"> </span>
<a href="#l3.9205"></a><span id="l3.9205">   if (onlineDelimiter != kOnlineHierarchySeparatorUnknown &amp;&amp;</span>
<a href="#l3.9206"></a><span id="l3.9206">       onlineDelimiter != hierarchyDelimiter)</span>
<a href="#l3.9207"></a><span id="l3.9207">     m_runningUrl-&gt;SetOnlineSubDirSeparator(onlineDelimiter);</span>
<a href="#l3.9208"></a><span id="l3.9208"> </span>
<a href="#l3.9209"></a><span id="l3.9209">   m_runningUrl-&gt;CreateServerSourceFolderPathString(&amp;sourceMailbox);</span>
<a href="#l3.9210"></a><span id="l3.9210"> </span>
<a href="#l3.9211"></a><span id="l3.9211">   return sourceMailbox;</span>
<a href="#l3.9212"></a><span id="l3.9212"> }</span>
<a href="#l3.9213"></a><span id="l3.9213"> </span>
<a href="#l3.9214"></a><span id="l3.9214" class="difflineminus">-//caller must free using PR_Free, safe to call from ui thread</span>
<a href="#l3.9215"></a><span id="l3.9215" class="difflineminus">-char * nsImapProtocol::GetFolderPathString()</span>
<a href="#l3.9216"></a><span id="l3.9216" class="difflineminus">-{</span>
<a href="#l3.9217"></a><span id="l3.9217" class="difflineplus">+// caller must free using PR_Free, safe to call from ui thread</span>
<a href="#l3.9218"></a><span id="l3.9218" class="difflineplus">+char *nsImapProtocol::GetFolderPathString() {</span>
<a href="#l3.9219"></a><span id="l3.9219">   char *sourceMailbox = nullptr;</span>
<a href="#l3.9220"></a><span id="l3.9220">   char onlineSubDirDelimiter = 0;</span>
<a href="#l3.9221"></a><span id="l3.9221">   char hierarchyDelimiter = 0;</span>
<a href="#l3.9222"></a><span id="l3.9222" class="difflineminus">-  nsCOMPtr &lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l3.9223"></a><span id="l3.9223" class="difflineplus">+  nsCOMPtr&lt;nsIMsgFolder&gt; msgFolder;</span>
<a href="#l3.9224"></a><span id="l3.9224"> </span>
<a href="#l3.9225"></a><span id="l3.9225">   m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;onlineSubDirDelimiter);</span>
<a href="#l3.9226"></a><span id="l3.9226">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_runningUrl);</span>
<a href="#l3.9227"></a><span id="l3.9227">   mailnewsUrl-&gt;GetFolder(getter_AddRefs(msgFolder));</span>
<a href="#l3.9228"></a><span id="l3.9228" class="difflineminus">-  if (msgFolder)</span>
<a href="#l3.9229"></a><span id="l3.9229" class="difflineminus">-  {</span>
<a href="#l3.9230"></a><span id="l3.9230" class="difflineminus">-    nsCOMPtr &lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(msgFolder);</span>
<a href="#l3.9231"></a><span id="l3.9231" class="difflineminus">-    if (imapFolder)</span>
<a href="#l3.9232"></a><span id="l3.9232" class="difflineminus">-    {</span>
<a href="#l3.9233"></a><span id="l3.9233" class="difflineplus">+  if (msgFolder) {</span>
<a href="#l3.9234"></a><span id="l3.9234" class="difflineplus">+    nsCOMPtr&lt;nsIMsgImapMailFolder&gt; imapFolder = do_QueryInterface(msgFolder);</span>
<a href="#l3.9235"></a><span id="l3.9235" class="difflineplus">+    if (imapFolder) {</span>
<a href="#l3.9236"></a><span id="l3.9236">       imapFolder-&gt;GetHierarchyDelimiter(&amp;hierarchyDelimiter);</span>
<a href="#l3.9237"></a><span id="l3.9237">       if (hierarchyDelimiter != kOnlineHierarchySeparatorUnknown &amp;&amp;</span>
<a href="#l3.9238"></a><span id="l3.9238">           onlineSubDirDelimiter != hierarchyDelimiter)</span>
<a href="#l3.9239"></a><span id="l3.9239">         m_runningUrl-&gt;SetOnlineSubDirSeparator(hierarchyDelimiter);</span>
<a href="#l3.9240"></a><span id="l3.9240">     }</span>
<a href="#l3.9241"></a><span id="l3.9241">   }</span>
<a href="#l3.9242"></a><span id="l3.9242">   m_runningUrl-&gt;CreateServerSourceFolderPathString(&amp;sourceMailbox);</span>
<a href="#l3.9243"></a><span id="l3.9243"> </span>
<a href="#l3.9244"></a><span id="l3.9244">   return sourceMailbox;</span>
<a href="#l3.9245"></a><span id="l3.9245"> }</span>
<a href="#l3.9246"></a><span id="l3.9246"> </span>
<a href="#l3.9247"></a><span id="l3.9247" class="difflineminus">-nsresult nsImapProtocol::CreateServerSourceFolderPathString(char **result)</span>
<a href="#l3.9248"></a><span id="l3.9248" class="difflineminus">-{</span>
<a href="#l3.9249"></a><span id="l3.9249" class="difflineplus">+nsresult nsImapProtocol::CreateServerSourceFolderPathString(char **result) {</span>
<a href="#l3.9250"></a><span id="l3.9250">   NS_ENSURE_ARG(result);</span>
<a href="#l3.9251"></a><span id="l3.9251">   *result = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.9252"></a><span id="l3.9252">   return (*result) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;</span>
<a href="#l3.9253"></a><span id="l3.9253"> }</span>
<a href="#l3.9254"></a><span id="l3.9254"> </span>
<a href="#l3.9255"></a><span id="l3.9255" class="difflineminus">-//caller must free using PR_Free</span>
<a href="#l3.9256"></a><span id="l3.9256" class="difflineminus">-char * nsImapProtocol::OnCreateServerDestinationFolderPathString()</span>
<a href="#l3.9257"></a><span id="l3.9257" class="difflineminus">-{</span>
<a href="#l3.9258"></a><span id="l3.9258" class="difflineplus">+// caller must free using PR_Free</span>
<a href="#l3.9259"></a><span id="l3.9259" class="difflineplus">+char *nsImapProtocol::OnCreateServerDestinationFolderPathString() {</span>
<a href="#l3.9260"></a><span id="l3.9260">   char *destinationMailbox = nullptr;</span>
<a href="#l3.9261"></a><span id="l3.9261">   char hierarchyDelimiter = 0;</span>
<a href="#l3.9262"></a><span id="l3.9262">   char onlineDelimiter = 0;</span>
<a href="#l3.9263"></a><span id="l3.9263">   m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;hierarchyDelimiter);</span>
<a href="#l3.9264"></a><span id="l3.9264">   if (m_imapMailFolderSink)</span>
<a href="#l3.9265"></a><span id="l3.9265">     m_imapMailFolderSink-&gt;GetOnlineDelimiter(&amp;onlineDelimiter);</span>
<a href="#l3.9266"></a><span id="l3.9266">   if (onlineDelimiter != kOnlineHierarchySeparatorUnknown &amp;&amp;</span>
<a href="#l3.9267"></a><span id="l3.9267">       onlineDelimiter != hierarchyDelimiter)</span>
<a href="#l3.9268"></a><span id="l3.9268">     m_runningUrl-&gt;SetOnlineSubDirSeparator(onlineDelimiter);</span>
<a href="#l3.9269"></a><span id="l3.9269"> </span>
<a href="#l3.9270"></a><span id="l3.9270">   m_runningUrl-&gt;CreateServerDestinationFolderPathString(&amp;destinationMailbox);</span>
<a href="#l3.9271"></a><span id="l3.9271"> </span>
<a href="#l3.9272"></a><span id="l3.9272">   return destinationMailbox;</span>
<a href="#l3.9273"></a><span id="l3.9273"> }</span>
<a href="#l3.9274"></a><span id="l3.9274"> </span>
<a href="#l3.9275"></a><span id="l3.9275" class="difflineminus">-void nsImapProtocol::OnCreateFolder(const char * aSourceMailbox)</span>
<a href="#l3.9276"></a><span id="l3.9276" class="difflineminus">-{</span>
<a href="#l3.9277"></a><span id="l3.9277" class="difflineplus">+void nsImapProtocol::OnCreateFolder(const char *aSourceMailbox) {</span>
<a href="#l3.9278"></a><span id="l3.9278">   bool created = CreateMailboxRespectingSubscriptions(aSourceMailbox);</span>
<a href="#l3.9279"></a><span id="l3.9279" class="difflineminus">-  if (created)</span>
<a href="#l3.9280"></a><span id="l3.9280" class="difflineminus">-  {</span>
<a href="#l3.9281"></a><span id="l3.9281" class="difflineplus">+  if (created) {</span>
<a href="#l3.9282"></a><span id="l3.9282">     m_hierarchyNameState = kListingForCreate;</span>
<a href="#l3.9283"></a><span id="l3.9283">     nsCString mailboxWODelim(aSourceMailbox);</span>
<a href="#l3.9284"></a><span id="l3.9284">     RemoveHierarchyDelimiter(mailboxWODelim);</span>
<a href="#l3.9285"></a><span id="l3.9285">     List(mailboxWODelim.get(), false);</span>
<a href="#l3.9286"></a><span id="l3.9286">     m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.9287"></a><span id="l3.9287" class="difflineminus">-  }</span>
<a href="#l3.9288"></a><span id="l3.9288" class="difflineminus">-  else</span>
<a href="#l3.9289"></a><span id="l3.9289" class="difflineplus">+  } else</span>
<a href="#l3.9290"></a><span id="l3.9290">     FolderNotCreated(aSourceMailbox);</span>
<a href="#l3.9291"></a><span id="l3.9291"> }</span>
<a href="#l3.9292"></a><span id="l3.9292"> </span>
<a href="#l3.9293"></a><span id="l3.9293" class="difflineminus">-void nsImapProtocol::OnEnsureExistsFolder(const char * aSourceMailbox)</span>
<a href="#l3.9294"></a><span id="l3.9294" class="difflineminus">-{</span>
<a href="#l3.9295"></a><span id="l3.9295" class="difflineminus">-</span>
<a href="#l3.9296"></a><span id="l3.9296" class="difflineminus">-  List(aSourceMailbox, false); // how to tell if that succeeded?</span>
<a href="#l3.9297"></a><span id="l3.9297" class="difflineplus">+void nsImapProtocol::OnEnsureExistsFolder(const char *aSourceMailbox) {</span>
<a href="#l3.9298"></a><span id="l3.9298" class="difflineplus">+  List(aSourceMailbox, false);  // how to tell if that succeeded?</span>
<a href="#l3.9299"></a><span id="l3.9299">   bool exists = false;</span>
<a href="#l3.9300"></a><span id="l3.9300"> </span>
<a href="#l3.9301"></a><span id="l3.9301">   // try converting aSourceMailbox to canonical format</span>
<a href="#l3.9302"></a><span id="l3.9302"> </span>
<a href="#l3.9303"></a><span id="l3.9303">   nsIMAPNamespace *nsForMailbox = nullptr;</span>
<a href="#l3.9304"></a><span id="l3.9304" class="difflineminus">-  m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.9305"></a><span id="l3.9305" class="difflineminus">-                                                     aSourceMailbox, nsForMailbox);</span>
<a href="#l3.9306"></a><span id="l3.9306" class="difflineplus">+  m_hostSessionList-&gt;GetNamespaceForMailboxForHost(</span>
<a href="#l3.9307"></a><span id="l3.9307" class="difflineplus">+      GetImapServerKey(), aSourceMailbox, nsForMailbox);</span>
<a href="#l3.9308"></a><span id="l3.9308">   // NS_ASSERTION (nsForMailbox, &quot;Oops .. null nsForMailbox&quot;);</span>
<a href="#l3.9309"></a><span id="l3.9309"> </span>
<a href="#l3.9310"></a><span id="l3.9310">   nsCString name;</span>
<a href="#l3.9311"></a><span id="l3.9311"> </span>
<a href="#l3.9312"></a><span id="l3.9312">   if (nsForMailbox)</span>
<a href="#l3.9313"></a><span id="l3.9313" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(aSourceMailbox,</span>
<a href="#l3.9314"></a><span id="l3.9314" class="difflineminus">-                                            nsForMailbox-&gt;GetDelimiter(),</span>
<a href="#l3.9315"></a><span id="l3.9315" class="difflineminus">-                                            getter_Copies(name));</span>
<a href="#l3.9316"></a><span id="l3.9316" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.9317"></a><span id="l3.9317" class="difflineplus">+        aSourceMailbox, nsForMailbox-&gt;GetDelimiter(), getter_Copies(name));</span>
<a href="#l3.9318"></a><span id="l3.9318">   else</span>
<a href="#l3.9319"></a><span id="l3.9319" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(aSourceMailbox,</span>
<a href="#l3.9320"></a><span id="l3.9320" class="difflineminus">-                                            kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.9321"></a><span id="l3.9321" class="difflineminus">-                                            getter_Copies(name));</span>
<a href="#l3.9322"></a><span id="l3.9322" class="difflineminus">-</span>
<a href="#l3.9323"></a><span id="l3.9323" class="difflineminus">-  if (m_imapServerSink)</span>
<a href="#l3.9324"></a><span id="l3.9324" class="difflineminus">-    m_imapServerSink-&gt;FolderVerifiedOnline(name, &amp;exists);</span>
<a href="#l3.9325"></a><span id="l3.9325" class="difflineminus">-</span>
<a href="#l3.9326"></a><span id="l3.9326" class="difflineminus">-  if (exists)</span>
<a href="#l3.9327"></a><span id="l3.9327" class="difflineminus">-  {</span>
<a href="#l3.9328"></a><span id="l3.9328" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.9329"></a><span id="l3.9329" class="difflineplus">+        aSourceMailbox, kOnlineHierarchySeparatorUnknown, getter_Copies(name));</span>
<a href="#l3.9330"></a><span id="l3.9330" class="difflineplus">+</span>
<a href="#l3.9331"></a><span id="l3.9331" class="difflineplus">+  if (m_imapServerSink) m_imapServerSink-&gt;FolderVerifiedOnline(name, &amp;exists);</span>
<a href="#l3.9332"></a><span id="l3.9332" class="difflineplus">+</span>
<a href="#l3.9333"></a><span id="l3.9333" class="difflineplus">+  if (exists) {</span>
<a href="#l3.9334"></a><span id="l3.9334">     Subscribe(aSourceMailbox);</span>
<a href="#l3.9335"></a><span id="l3.9335" class="difflineminus">-  }</span>
<a href="#l3.9336"></a><span id="l3.9336" class="difflineminus">-  else</span>
<a href="#l3.9337"></a><span id="l3.9337" class="difflineminus">-  {</span>
<a href="#l3.9338"></a><span id="l3.9338" class="difflineplus">+  } else {</span>
<a href="#l3.9339"></a><span id="l3.9339">     bool created = CreateMailboxRespectingSubscriptions(aSourceMailbox);</span>
<a href="#l3.9340"></a><span id="l3.9340" class="difflineminus">-    if (created)</span>
<a href="#l3.9341"></a><span id="l3.9341" class="difflineminus">-    {</span>
<a href="#l3.9342"></a><span id="l3.9342" class="difflineminus">-        List(aSourceMailbox, false);</span>
<a href="#l3.9343"></a><span id="l3.9343" class="difflineplus">+    if (created) {</span>
<a href="#l3.9344"></a><span id="l3.9344" class="difflineplus">+      List(aSourceMailbox, false);</span>
<a href="#l3.9345"></a><span id="l3.9345">     }</span>
<a href="#l3.9346"></a><span id="l3.9346">   }</span>
<a href="#l3.9347"></a><span id="l3.9347">   if (!GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.9348"></a><span id="l3.9348" class="difflineminus">-        FolderNotCreated(aSourceMailbox);</span>
<a href="#l3.9349"></a><span id="l3.9349" class="difflineminus">-}</span>
<a href="#l3.9350"></a><span id="l3.9350" class="difflineminus">-</span>
<a href="#l3.9351"></a><span id="l3.9351" class="difflineminus">-</span>
<a href="#l3.9352"></a><span id="l3.9352" class="difflineminus">-void nsImapProtocol::OnSubscribe(const char * sourceMailbox)</span>
<a href="#l3.9353"></a><span id="l3.9353" class="difflineminus">-{</span>
<a href="#l3.9354"></a><span id="l3.9354" class="difflineplus">+    FolderNotCreated(aSourceMailbox);</span>
<a href="#l3.9355"></a><span id="l3.9355" class="difflineplus">+}</span>
<a href="#l3.9356"></a><span id="l3.9356" class="difflineplus">+</span>
<a href="#l3.9357"></a><span id="l3.9357" class="difflineplus">+void nsImapProtocol::OnSubscribe(const char *sourceMailbox) {</span>
<a href="#l3.9358"></a><span id="l3.9358">   Subscribe(sourceMailbox);</span>
<a href="#l3.9359"></a><span id="l3.9359"> }</span>
<a href="#l3.9360"></a><span id="l3.9360"> </span>
<a href="#l3.9361"></a><span id="l3.9361" class="difflineminus">-void nsImapProtocol::OnUnsubscribe(const char * sourceMailbox)</span>
<a href="#l3.9362"></a><span id="l3.9362" class="difflineminus">-{</span>
<a href="#l3.9363"></a><span id="l3.9363" class="difflineplus">+void nsImapProtocol::OnUnsubscribe(const char *sourceMailbox) {</span>
<a href="#l3.9364"></a><span id="l3.9364">   // When we try to auto-unsubscribe from \Noselect folders,</span>
<a href="#l3.9365"></a><span id="l3.9365">   // some servers report errors if we were already unsubscribed</span>
<a href="#l3.9366"></a><span id="l3.9366">   // from them.</span>
<a href="#l3.9367"></a><span id="l3.9367">   bool lastReportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.9368"></a><span id="l3.9368">   GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.9369"></a><span id="l3.9369">   Unsubscribe(sourceMailbox);</span>
<a href="#l3.9370"></a><span id="l3.9370">   GetServerStateParser().SetReportingErrors(lastReportingErrors);</span>
<a href="#l3.9371"></a><span id="l3.9371"> }</span>
<a href="#l3.9372"></a><span id="l3.9372"> </span>
<a href="#l3.9373"></a><span id="l3.9373" class="difflineminus">-void nsImapProtocol::RefreshACLForFolderIfNecessary(const char *mailboxName)</span>
<a href="#l3.9374"></a><span id="l3.9374" class="difflineminus">-{</span>
<a href="#l3.9375"></a><span id="l3.9375" class="difflineminus">-  if (GetServerStateParser().ServerHasACLCapability())</span>
<a href="#l3.9376"></a><span id="l3.9376" class="difflineminus">-  {</span>
<a href="#l3.9377"></a><span id="l3.9377" class="difflineplus">+void nsImapProtocol::RefreshACLForFolderIfNecessary(const char *mailboxName) {</span>
<a href="#l3.9378"></a><span id="l3.9378" class="difflineplus">+  if (GetServerStateParser().ServerHasACLCapability()) {</span>
<a href="#l3.9379"></a><span id="l3.9379">     if (!m_folderNeedsACLRefreshed &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.9380"></a><span id="l3.9380">       m_imapMailFolderSink-&gt;GetFolderNeedsACLListed(&amp;m_folderNeedsACLRefreshed);</span>
<a href="#l3.9381"></a><span id="l3.9381" class="difflineminus">-    if (m_folderNeedsACLRefreshed)</span>
<a href="#l3.9382"></a><span id="l3.9382" class="difflineminus">-    {</span>
<a href="#l3.9383"></a><span id="l3.9383" class="difflineplus">+    if (m_folderNeedsACLRefreshed) {</span>
<a href="#l3.9384"></a><span id="l3.9384">       RefreshACLForFolder(mailboxName);</span>
<a href="#l3.9385"></a><span id="l3.9385">       m_folderNeedsACLRefreshed = false;</span>
<a href="#l3.9386"></a><span id="l3.9386">     }</span>
<a href="#l3.9387"></a><span id="l3.9387">   }</span>
<a href="#l3.9388"></a><span id="l3.9388"> }</span>
<a href="#l3.9389"></a><span id="l3.9389"> </span>
<a href="#l3.9390"></a><span id="l3.9390" class="difflineminus">-void nsImapProtocol::RefreshACLForFolder(const char *mailboxName)</span>
<a href="#l3.9391"></a><span id="l3.9391" class="difflineminus">-{</span>
<a href="#l3.9392"></a><span id="l3.9392" class="difflineminus">-</span>
<a href="#l3.9393"></a><span id="l3.9393" class="difflineplus">+void nsImapProtocol::RefreshACLForFolder(const char *mailboxName) {</span>
<a href="#l3.9394"></a><span id="l3.9394">   nsIMAPNamespace *ns = nullptr;</span>
<a href="#l3.9395"></a><span id="l3.9395" class="difflineminus">-  m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(), mailboxName, ns);</span>
<a href="#l3.9396"></a><span id="l3.9396" class="difflineminus">-  if (ns)</span>
<a href="#l3.9397"></a><span id="l3.9397" class="difflineminus">-  {</span>
<a href="#l3.9398"></a><span id="l3.9398" class="difflineminus">-    switch (ns-&gt;GetType())</span>
<a href="#l3.9399"></a><span id="l3.9399" class="difflineminus">-    {</span>
<a href="#l3.9400"></a><span id="l3.9400" class="difflineminus">-    case kPersonalNamespace:</span>
<a href="#l3.9401"></a><span id="l3.9401" class="difflineminus">-      // It's a personal folder, most likely.</span>
<a href="#l3.9402"></a><span id="l3.9402" class="difflineminus">-      // I find it hard to imagine a server that supports ACL that doesn't support NAMESPACE,</span>
<a href="#l3.9403"></a><span id="l3.9403" class="difflineminus">-      // so most likely we KNOW that this is a personal, rather than the default, namespace.</span>
<a href="#l3.9404"></a><span id="l3.9404" class="difflineminus">-</span>
<a href="#l3.9405"></a><span id="l3.9405" class="difflineminus">-      // First, clear what we have.</span>
<a href="#l3.9406"></a><span id="l3.9406" class="difflineminus">-      ClearAllFolderRights();</span>
<a href="#l3.9407"></a><span id="l3.9407" class="difflineminus">-      // Now, get the new one.</span>
<a href="#l3.9408"></a><span id="l3.9408" class="difflineminus">-      GetMyRightsForFolder(mailboxName);</span>
<a href="#l3.9409"></a><span id="l3.9409" class="difflineminus">-      if (m_imapMailFolderSink)</span>
<a href="#l3.9410"></a><span id="l3.9410" class="difflineminus">-      {</span>
<a href="#l3.9411"></a><span id="l3.9411" class="difflineminus">-        uint32_t aclFlags = 0;</span>
<a href="#l3.9412"></a><span id="l3.9412" class="difflineminus">-        if (NS_SUCCEEDED(m_imapMailFolderSink-&gt;GetAclFlags(&amp;aclFlags)) &amp;&amp; aclFlags &amp; IMAP_ACL_ADMINISTER_FLAG)</span>
<a href="#l3.9413"></a><span id="l3.9413" class="difflineplus">+  m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.9414"></a><span id="l3.9414" class="difflineplus">+                                                   mailboxName, ns);</span>
<a href="#l3.9415"></a><span id="l3.9415" class="difflineplus">+  if (ns) {</span>
<a href="#l3.9416"></a><span id="l3.9416" class="difflineplus">+    switch (ns-&gt;GetType()) {</span>
<a href="#l3.9417"></a><span id="l3.9417" class="difflineplus">+      case kPersonalNamespace:</span>
<a href="#l3.9418"></a><span id="l3.9418" class="difflineplus">+        // It's a personal folder, most likely.</span>
<a href="#l3.9419"></a><span id="l3.9419" class="difflineplus">+        // I find it hard to imagine a server that supports ACL that doesn't</span>
<a href="#l3.9420"></a><span id="l3.9420" class="difflineplus">+        // support NAMESPACE, so most likely we KNOW that this is a personal,</span>
<a href="#l3.9421"></a><span id="l3.9421" class="difflineplus">+        // rather than the default, namespace.</span>
<a href="#l3.9422"></a><span id="l3.9422" class="difflineplus">+</span>
<a href="#l3.9423"></a><span id="l3.9423" class="difflineplus">+        // First, clear what we have.</span>
<a href="#l3.9424"></a><span id="l3.9424" class="difflineplus">+        ClearAllFolderRights();</span>
<a href="#l3.9425"></a><span id="l3.9425" class="difflineplus">+        // Now, get the new one.</span>
<a href="#l3.9426"></a><span id="l3.9426" class="difflineplus">+        GetMyRightsForFolder(mailboxName);</span>
<a href="#l3.9427"></a><span id="l3.9427" class="difflineplus">+        if (m_imapMailFolderSink) {</span>
<a href="#l3.9428"></a><span id="l3.9428" class="difflineplus">+          uint32_t aclFlags = 0;</span>
<a href="#l3.9429"></a><span id="l3.9429" class="difflineplus">+          if (NS_SUCCEEDED(m_imapMailFolderSink-&gt;GetAclFlags(&amp;aclFlags)) &amp;&amp;</span>
<a href="#l3.9430"></a><span id="l3.9430" class="difflineplus">+              aclFlags &amp; IMAP_ACL_ADMINISTER_FLAG)</span>
<a href="#l3.9431"></a><span id="l3.9431">             GetACLForFolder(mailboxName);</span>
<a href="#l3.9432"></a><span id="l3.9432" class="difflineminus">-      }</span>
<a href="#l3.9433"></a><span id="l3.9433" class="difflineminus">-</span>
<a href="#l3.9434"></a><span id="l3.9434" class="difflineminus">-      // We're all done, refresh the icon/flags for this folder</span>
<a href="#l3.9435"></a><span id="l3.9435" class="difflineminus">-      RefreshFolderACLView(mailboxName, ns);</span>
<a href="#l3.9436"></a><span id="l3.9436" class="difflineminus">-      break;</span>
<a href="#l3.9437"></a><span id="l3.9437" class="difflineminus">-    default:</span>
<a href="#l3.9438"></a><span id="l3.9438" class="difflineminus">-      // We know it's a public folder or other user's folder.</span>
<a href="#l3.9439"></a><span id="l3.9439" class="difflineminus">-      // We only want our own rights</span>
<a href="#l3.9440"></a><span id="l3.9440" class="difflineminus">-</span>
<a href="#l3.9441"></a><span id="l3.9441" class="difflineminus">-      // First, clear what we have</span>
<a href="#l3.9442"></a><span id="l3.9442" class="difflineminus">-      ClearAllFolderRights();</span>
<a href="#l3.9443"></a><span id="l3.9443" class="difflineminus">-      // Now, get the new one.</span>
<a href="#l3.9444"></a><span id="l3.9444" class="difflineminus">-      GetMyRightsForFolder(mailboxName);</span>
<a href="#l3.9445"></a><span id="l3.9445" class="difflineminus">-      // We're all done, refresh the icon/flags for this folder</span>
<a href="#l3.9446"></a><span id="l3.9446" class="difflineminus">-      RefreshFolderACLView(mailboxName, ns);</span>
<a href="#l3.9447"></a><span id="l3.9447" class="difflineminus">-      break;</span>
<a href="#l3.9448"></a><span id="l3.9448" class="difflineminus">-    }</span>
<a href="#l3.9449"></a><span id="l3.9449" class="difflineminus">-  }</span>
<a href="#l3.9450"></a><span id="l3.9450" class="difflineminus">-  else</span>
<a href="#l3.9451"></a><span id="l3.9451" class="difflineminus">-  {</span>
<a href="#l3.9452"></a><span id="l3.9452" class="difflineplus">+        }</span>
<a href="#l3.9453"></a><span id="l3.9453" class="difflineplus">+</span>
<a href="#l3.9454"></a><span id="l3.9454" class="difflineplus">+        // We're all done, refresh the icon/flags for this folder</span>
<a href="#l3.9455"></a><span id="l3.9455" class="difflineplus">+        RefreshFolderACLView(mailboxName, ns);</span>
<a href="#l3.9456"></a><span id="l3.9456" class="difflineplus">+        break;</span>
<a href="#l3.9457"></a><span id="l3.9457" class="difflineplus">+      default:</span>
<a href="#l3.9458"></a><span id="l3.9458" class="difflineplus">+        // We know it's a public folder or other user's folder.</span>
<a href="#l3.9459"></a><span id="l3.9459" class="difflineplus">+        // We only want our own rights</span>
<a href="#l3.9460"></a><span id="l3.9460" class="difflineplus">+</span>
<a href="#l3.9461"></a><span id="l3.9461" class="difflineplus">+        // First, clear what we have</span>
<a href="#l3.9462"></a><span id="l3.9462" class="difflineplus">+        ClearAllFolderRights();</span>
<a href="#l3.9463"></a><span id="l3.9463" class="difflineplus">+        // Now, get the new one.</span>
<a href="#l3.9464"></a><span id="l3.9464" class="difflineplus">+        GetMyRightsForFolder(mailboxName);</span>
<a href="#l3.9465"></a><span id="l3.9465" class="difflineplus">+        // We're all done, refresh the icon/flags for this folder</span>
<a href="#l3.9466"></a><span id="l3.9466" class="difflineplus">+        RefreshFolderACLView(mailboxName, ns);</span>
<a href="#l3.9467"></a><span id="l3.9467" class="difflineplus">+        break;</span>
<a href="#l3.9468"></a><span id="l3.9468" class="difflineplus">+    }</span>
<a href="#l3.9469"></a><span id="l3.9469" class="difflineplus">+  } else {</span>
<a href="#l3.9470"></a><span id="l3.9470">     // no namespace, not even default... can this happen?</span>
<a href="#l3.9471"></a><span id="l3.9471">     NS_ASSERTION(false, &quot;couldn't get namespace&quot;);</span>
<a href="#l3.9472"></a><span id="l3.9472">   }</span>
<a href="#l3.9473"></a><span id="l3.9473"> }</span>
<a href="#l3.9474"></a><span id="l3.9474"> </span>
<a href="#l3.9475"></a><span id="l3.9475" class="difflineminus">-void nsImapProtocol::RefreshFolderACLView(const char *mailboxName, nsIMAPNamespace *nsForMailbox)</span>
<a href="#l3.9476"></a><span id="l3.9476" class="difflineminus">-{</span>
<a href="#l3.9477"></a><span id="l3.9477" class="difflineplus">+void nsImapProtocol::RefreshFolderACLView(const char *mailboxName,</span>
<a href="#l3.9478"></a><span id="l3.9478" class="difflineplus">+                                          nsIMAPNamespace *nsForMailbox) {</span>
<a href="#l3.9479"></a><span id="l3.9479">   nsCString canonicalMailboxName;</span>
<a href="#l3.9480"></a><span id="l3.9480"> </span>
<a href="#l3.9481"></a><span id="l3.9481">   if (nsForMailbox)</span>
<a href="#l3.9482"></a><span id="l3.9482" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName, nsForMailbox-&gt;GetDelimiter(), getter_Copies(canonicalMailboxName));</span>
<a href="#l3.9483"></a><span id="l3.9483" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName,</span>
<a href="#l3.9484"></a><span id="l3.9484" class="difflineplus">+                                        nsForMailbox-&gt;GetDelimiter(),</span>
<a href="#l3.9485"></a><span id="l3.9485" class="difflineplus">+                                        getter_Copies(canonicalMailboxName));</span>
<a href="#l3.9486"></a><span id="l3.9486">   else</span>
<a href="#l3.9487"></a><span id="l3.9487" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName, kOnlineHierarchySeparatorUnknown, getter_Copies(canonicalMailboxName));</span>
<a href="#l3.9488"></a><span id="l3.9488" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName,</span>
<a href="#l3.9489"></a><span id="l3.9489" class="difflineplus">+                                        kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.9490"></a><span id="l3.9490" class="difflineplus">+                                        getter_Copies(canonicalMailboxName));</span>
<a href="#l3.9491"></a><span id="l3.9491"> </span>
<a href="#l3.9492"></a><span id="l3.9492">   if (m_imapServerSink)</span>
<a href="#l3.9493"></a><span id="l3.9493">     m_imapServerSink-&gt;RefreshFolderRights(canonicalMailboxName);</span>
<a href="#l3.9494"></a><span id="l3.9494"> }</span>
<a href="#l3.9495"></a><span id="l3.9495"> </span>
<a href="#l3.9496"></a><span id="l3.9496" class="difflineminus">-void nsImapProtocol::GetACLForFolder(const char *mailboxName)</span>
<a href="#l3.9497"></a><span id="l3.9497" class="difflineminus">-{</span>
<a href="#l3.9498"></a><span id="l3.9498" class="difflineplus">+void nsImapProtocol::GetACLForFolder(const char *mailboxName) {</span>
<a href="#l3.9499"></a><span id="l3.9499">   IncrementCommandTagNumber();</span>
<a href="#l3.9500"></a><span id="l3.9500"> </span>
<a href="#l3.9501"></a><span id="l3.9501">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.9502"></a><span id="l3.9502">   nsCString escapedName;</span>
<a href="#l3.9503"></a><span id="l3.9503">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.9504"></a><span id="l3.9504">   command.AppendLiteral(&quot; getacl \&quot;&quot;);</span>
<a href="#l3.9505"></a><span id="l3.9505">   command.Append(escapedName);</span>
<a href="#l3.9506"></a><span id="l3.9506">   command.AppendLiteral(&quot;\&quot;&quot; CRLF);</span>
<a href="#l3.9507"></a><span id="l3.9507"> </span>
<a href="#l3.9508"></a><span id="l3.9508">   nsresult rv = SendData(command.get());</span>
<a href="#l3.9509"></a><span id="l3.9509" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9510"></a><span id="l3.9510" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9511"></a><span id="l3.9511" class="difflineminus">-}</span>
<a href="#l3.9512"></a><span id="l3.9512" class="difflineminus">-</span>
<a href="#l3.9513"></a><span id="l3.9513" class="difflineminus">-void nsImapProtocol::OnRefreshAllACLs()</span>
<a href="#l3.9514"></a><span id="l3.9514" class="difflineminus">-{</span>
<a href="#l3.9515"></a><span id="l3.9515" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9516"></a><span id="l3.9516" class="difflineplus">+}</span>
<a href="#l3.9517"></a><span id="l3.9517" class="difflineplus">+</span>
<a href="#l3.9518"></a><span id="l3.9518" class="difflineplus">+void nsImapProtocol::OnRefreshAllACLs() {</span>
<a href="#l3.9519"></a><span id="l3.9519">   m_hierarchyNameState = kListingForInfoOnly;</span>
<a href="#l3.9520"></a><span id="l3.9520">   nsIMAPMailboxInfo *mb = NULL;</span>
<a href="#l3.9521"></a><span id="l3.9521"> </span>
<a href="#l3.9522"></a><span id="l3.9522">   // This will fill in the list</span>
<a href="#l3.9523"></a><span id="l3.9523">   List(&quot;*&quot;, true);</span>
<a href="#l3.9524"></a><span id="l3.9524"> </span>
<a href="#l3.9525"></a><span id="l3.9525">   int32_t total = m_listedMailboxList.Length(), count = 0;</span>
<a href="#l3.9526"></a><span id="l3.9526">   GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.9527"></a><span id="l3.9527" class="difflineminus">-  for (int32_t i = 0; i &lt; total; i++)</span>
<a href="#l3.9528"></a><span id="l3.9528" class="difflineminus">-  {</span>
<a href="#l3.9529"></a><span id="l3.9529" class="difflineplus">+  for (int32_t i = 0; i &lt; total; i++) {</span>
<a href="#l3.9530"></a><span id="l3.9530">     mb = m_listedMailboxList.ElementAt(i);</span>
<a href="#l3.9531"></a><span id="l3.9531" class="difflineminus">-    if (mb) // paranoia</span>
<a href="#l3.9532"></a><span id="l3.9532" class="difflineplus">+    if (mb)  // paranoia</span>
<a href="#l3.9533"></a><span id="l3.9533">     {</span>
<a href="#l3.9534"></a><span id="l3.9534">       char *onlineName = nullptr;</span>
<a href="#l3.9535"></a><span id="l3.9535" class="difflineminus">-      m_runningUrl-&gt;AllocateServerPath(PromiseFlatCString(mb-&gt;GetMailboxName()).get(), mb-&gt;GetDelimiter(), &amp;onlineName);</span>
<a href="#l3.9536"></a><span id="l3.9536" class="difflineminus">-      if (onlineName)</span>
<a href="#l3.9537"></a><span id="l3.9537" class="difflineminus">-      {</span>
<a href="#l3.9538"></a><span id="l3.9538" class="difflineplus">+      m_runningUrl-&gt;AllocateServerPath(</span>
<a href="#l3.9539"></a><span id="l3.9539" class="difflineplus">+          PromiseFlatCString(mb-&gt;GetMailboxName()).get(), mb-&gt;GetDelimiter(),</span>
<a href="#l3.9540"></a><span id="l3.9540" class="difflineplus">+          &amp;onlineName);</span>
<a href="#l3.9541"></a><span id="l3.9541" class="difflineplus">+      if (onlineName) {</span>
<a href="#l3.9542"></a><span id="l3.9542">         RefreshACLForFolder(onlineName);</span>
<a href="#l3.9543"></a><span id="l3.9543">         free(onlineName);</span>
<a href="#l3.9544"></a><span id="l3.9544">       }</span>
<a href="#l3.9545"></a><span id="l3.9545">       PercentProgressUpdateEvent(NULL, count, total);</span>
<a href="#l3.9546"></a><span id="l3.9546">       delete mb;</span>
<a href="#l3.9547"></a><span id="l3.9547">       count++;</span>
<a href="#l3.9548"></a><span id="l3.9548">     }</span>
<a href="#l3.9549"></a><span id="l3.9549">   }</span>
<a href="#l3.9550"></a><span id="l3.9550" class="difflineat">@@ -6885,786 +6309,693 @@ void nsImapProtocol::OnRefreshAllACLs()</span>
<a href="#l3.9551"></a><span id="l3.9551"> </span>
<a href="#l3.9552"></a><span id="l3.9552">   PercentProgressUpdateEvent(NULL, 100, 100);</span>
<a href="#l3.9553"></a><span id="l3.9553">   GetServerStateParser().SetReportingErrors(true);</span>
<a href="#l3.9554"></a><span id="l3.9554">   m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.9555"></a><span id="l3.9555"> }</span>
<a href="#l3.9556"></a><span id="l3.9556"> </span>
<a href="#l3.9557"></a><span id="l3.9557"> // any state commands</span>
<a href="#l3.9558"></a><span id="l3.9558"> void nsImapProtocol::Logout(bool shuttingDown /* = false */,</span>
<a href="#l3.9559"></a><span id="l3.9559" class="difflineminus">-                            bool waitForResponse /* = true */)</span>
<a href="#l3.9560"></a><span id="l3.9560" class="difflineminus">-{</span>
<a href="#l3.9561"></a><span id="l3.9561" class="difflineminus">-  if (!shuttingDown)</span>
<a href="#l3.9562"></a><span id="l3.9562" class="difflineminus">-    ProgressEventFunctionUsingName(&quot;imapStatusLoggingOut&quot;);</span>
<a href="#l3.9563"></a><span id="l3.9563" class="difflineminus">-</span>
<a href="#l3.9564"></a><span id="l3.9564" class="difflineminus">-/******************************************************************</span>
<a href="#l3.9565"></a><span id="l3.9565" class="difflineminus">- * due to the undo functionality we cannot issule a close when logout; there</span>
<a href="#l3.9566"></a><span id="l3.9566" class="difflineminus">- * is no way to do an undo if the message has been permanently expunge</span>
<a href="#l3.9567"></a><span id="l3.9567" class="difflineminus">- * jt - 07/12/1999</span>
<a href="#l3.9568"></a><span id="l3.9568" class="difflineminus">-</span>
<a href="#l3.9569"></a><span id="l3.9569" class="difflineminus">-    bool closeNeeded = GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.9570"></a><span id="l3.9570" class="difflineminus">-        nsImapServerResponseParser::kFolderSelected;</span>
<a href="#l3.9571"></a><span id="l3.9571" class="difflineminus">-</span>
<a href="#l3.9572"></a><span id="l3.9572" class="difflineminus">-    if (closeNeeded &amp;&amp; GetDeleteIsMoveToTrash())</span>
<a href="#l3.9573"></a><span id="l3.9573" class="difflineminus">-        Close();</span>
<a href="#l3.9574"></a><span id="l3.9574" class="difflineminus">-********************/</span>
<a href="#l3.9575"></a><span id="l3.9575" class="difflineplus">+                            bool waitForResponse /* = true */) {</span>
<a href="#l3.9576"></a><span id="l3.9576" class="difflineplus">+  if (!shuttingDown) ProgressEventFunctionUsingName(&quot;imapStatusLoggingOut&quot;);</span>
<a href="#l3.9577"></a><span id="l3.9577" class="difflineplus">+</span>
<a href="#l3.9578"></a><span id="l3.9578" class="difflineplus">+  /******************************************************************</span>
<a href="#l3.9579"></a><span id="l3.9579" class="difflineplus">+   * due to the undo functionality we cannot issule a close when logout; there</span>
<a href="#l3.9580"></a><span id="l3.9580" class="difflineplus">+   * is no way to do an undo if the message has been permanently expunge</span>
<a href="#l3.9581"></a><span id="l3.9581" class="difflineplus">+   * jt - 07/12/1999</span>
<a href="#l3.9582"></a><span id="l3.9582" class="difflineplus">+</span>
<a href="#l3.9583"></a><span id="l3.9583" class="difflineplus">+      bool closeNeeded = GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.9584"></a><span id="l3.9584" class="difflineplus">+          nsImapServerResponseParser::kFolderSelected;</span>
<a href="#l3.9585"></a><span id="l3.9585" class="difflineplus">+</span>
<a href="#l3.9586"></a><span id="l3.9586" class="difflineplus">+      if (closeNeeded &amp;&amp; GetDeleteIsMoveToTrash())</span>
<a href="#l3.9587"></a><span id="l3.9587" class="difflineplus">+          Close();</span>
<a href="#l3.9588"></a><span id="l3.9588" class="difflineplus">+  ********************/</span>
<a href="#l3.9589"></a><span id="l3.9589"> </span>
<a href="#l3.9590"></a><span id="l3.9590">   IncrementCommandTagNumber();</span>
<a href="#l3.9591"></a><span id="l3.9591"> </span>
<a href="#l3.9592"></a><span id="l3.9592">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.9593"></a><span id="l3.9593"> </span>
<a href="#l3.9594"></a><span id="l3.9594">   command.AppendLiteral(&quot; logout&quot; CRLF);</span>
<a href="#l3.9595"></a><span id="l3.9595"> </span>
<a href="#l3.9596"></a><span id="l3.9596">   nsresult rv = SendData(command.get());</span>
<a href="#l3.9597"></a><span id="l3.9597">   if (m_transport &amp;&amp; shuttingDown)</span>
<a href="#l3.9598"></a><span id="l3.9598">     m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE, 5);</span>
<a href="#l3.9599"></a><span id="l3.9599">   // the socket may be dead before we read the response, so drop it.</span>
<a href="#l3.9600"></a><span id="l3.9600" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; waitForResponse)</span>
<a href="#l3.9601"></a><span id="l3.9601" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9602"></a><span id="l3.9602" class="difflineminus">-}</span>
<a href="#l3.9603"></a><span id="l3.9603" class="difflineminus">-</span>
<a href="#l3.9604"></a><span id="l3.9604" class="difflineminus">-void nsImapProtocol::Noop()</span>
<a href="#l3.9605"></a><span id="l3.9605" class="difflineminus">-{</span>
<a href="#l3.9606"></a><span id="l3.9606" class="difflineminus">-  //ProgressUpdateEvent(&quot;noop...&quot;);</span>
<a href="#l3.9607"></a><span id="l3.9607" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; waitForResponse) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9608"></a><span id="l3.9608" class="difflineplus">+}</span>
<a href="#l3.9609"></a><span id="l3.9609" class="difflineplus">+</span>
<a href="#l3.9610"></a><span id="l3.9610" class="difflineplus">+void nsImapProtocol::Noop() {</span>
<a href="#l3.9611"></a><span id="l3.9611" class="difflineplus">+  // ProgressUpdateEvent(&quot;noop...&quot;);</span>
<a href="#l3.9612"></a><span id="l3.9612">   IncrementCommandTagNumber();</span>
<a href="#l3.9613"></a><span id="l3.9613">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.9614"></a><span id="l3.9614"> </span>
<a href="#l3.9615"></a><span id="l3.9615">   command.AppendLiteral(&quot; noop&quot; CRLF);</span>
<a href="#l3.9616"></a><span id="l3.9616"> </span>
<a href="#l3.9617"></a><span id="l3.9617">   nsresult rv = SendData(command.get());</span>
<a href="#l3.9618"></a><span id="l3.9618" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9619"></a><span id="l3.9619" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9620"></a><span id="l3.9620" class="difflineminus">-}</span>
<a href="#l3.9621"></a><span id="l3.9621" class="difflineminus">-</span>
<a href="#l3.9622"></a><span id="l3.9622" class="difflineminus">-void nsImapProtocol::XServerInfo()</span>
<a href="#l3.9623"></a><span id="l3.9623" class="difflineminus">-{</span>
<a href="#l3.9624"></a><span id="l3.9624" class="difflineminus">-</span>
<a href="#l3.9625"></a><span id="l3.9625" class="difflineminus">-    ProgressEventFunctionUsingName(&quot;imapGettingServerInfo&quot;);</span>
<a href="#l3.9626"></a><span id="l3.9626" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.9627"></a><span id="l3.9627" class="difflineminus">-    nsCString command(GetServerCommandTag());</span>
<a href="#l3.9628"></a><span id="l3.9628" class="difflineminus">-</span>
<a href="#l3.9629"></a><span id="l3.9629" class="difflineminus">-  command.AppendLiteral(&quot; XSERVERINFO MANAGEACCOUNTURL MANAGELISTSURL MANAGEFILTERSURL&quot; CRLF);</span>
<a href="#l3.9630"></a><span id="l3.9630" class="difflineminus">-</span>
<a href="#l3.9631"></a><span id="l3.9631" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.9632"></a><span id="l3.9632" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9633"></a><span id="l3.9633" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9634"></a><span id="l3.9634" class="difflineminus">-}</span>
<a href="#l3.9635"></a><span id="l3.9635" class="difflineminus">-</span>
<a href="#l3.9636"></a><span id="l3.9636" class="difflineminus">-void nsImapProtocol::Netscape()</span>
<a href="#l3.9637"></a><span id="l3.9637" class="difflineminus">-{</span>
<a href="#l3.9638"></a><span id="l3.9638" class="difflineminus">-    ProgressEventFunctionUsingName(&quot;imapGettingServerInfo&quot;);</span>
<a href="#l3.9639"></a><span id="l3.9639" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.9640"></a><span id="l3.9640" class="difflineminus">-</span>
<a href="#l3.9641"></a><span id="l3.9641" class="difflineminus">-    nsCString command(GetServerCommandTag());</span>
<a href="#l3.9642"></a><span id="l3.9642" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9643"></a><span id="l3.9643" class="difflineplus">+}</span>
<a href="#l3.9644"></a><span id="l3.9644" class="difflineplus">+</span>
<a href="#l3.9645"></a><span id="l3.9645" class="difflineplus">+void nsImapProtocol::XServerInfo() {</span>
<a href="#l3.9646"></a><span id="l3.9646" class="difflineplus">+  ProgressEventFunctionUsingName(&quot;imapGettingServerInfo&quot;);</span>
<a href="#l3.9647"></a><span id="l3.9647" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.9648"></a><span id="l3.9648" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.9649"></a><span id="l3.9649" class="difflineplus">+</span>
<a href="#l3.9650"></a><span id="l3.9650" class="difflineplus">+  command.AppendLiteral(</span>
<a href="#l3.9651"></a><span id="l3.9651" class="difflineplus">+      &quot; XSERVERINFO MANAGEACCOUNTURL MANAGELISTSURL MANAGEFILTERSURL&quot; CRLF);</span>
<a href="#l3.9652"></a><span id="l3.9652" class="difflineplus">+</span>
<a href="#l3.9653"></a><span id="l3.9653" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.9654"></a><span id="l3.9654" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9655"></a><span id="l3.9655" class="difflineplus">+}</span>
<a href="#l3.9656"></a><span id="l3.9656" class="difflineplus">+</span>
<a href="#l3.9657"></a><span id="l3.9657" class="difflineplus">+void nsImapProtocol::Netscape() {</span>
<a href="#l3.9658"></a><span id="l3.9658" class="difflineplus">+  ProgressEventFunctionUsingName(&quot;imapGettingServerInfo&quot;);</span>
<a href="#l3.9659"></a><span id="l3.9659" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.9660"></a><span id="l3.9660" class="difflineplus">+</span>
<a href="#l3.9661"></a><span id="l3.9661" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.9662"></a><span id="l3.9662"> </span>
<a href="#l3.9663"></a><span id="l3.9663">   command.AppendLiteral(&quot; netscape&quot; CRLF);</span>
<a href="#l3.9664"></a><span id="l3.9664"> </span>
<a href="#l3.9665"></a><span id="l3.9665" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.9666"></a><span id="l3.9666" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9667"></a><span id="l3.9667" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9668"></a><span id="l3.9668" class="difflineminus">-}</span>
<a href="#l3.9669"></a><span id="l3.9669" class="difflineminus">-</span>
<a href="#l3.9670"></a><span id="l3.9670" class="difflineminus">-</span>
<a href="#l3.9671"></a><span id="l3.9671" class="difflineminus">-</span>
<a href="#l3.9672"></a><span id="l3.9672" class="difflineminus">-void nsImapProtocol::XMailboxInfo(const char *mailboxName)</span>
<a href="#l3.9673"></a><span id="l3.9673" class="difflineminus">-{</span>
<a href="#l3.9674"></a><span id="l3.9674" class="difflineminus">-</span>
<a href="#l3.9675"></a><span id="l3.9675" class="difflineminus">-    ProgressEventFunctionUsingName(&quot;imapGettingMailboxInfo&quot;);</span>
<a href="#l3.9676"></a><span id="l3.9676" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.9677"></a><span id="l3.9677" class="difflineminus">-    nsCString command(GetServerCommandTag());</span>
<a href="#l3.9678"></a><span id="l3.9678" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.9679"></a><span id="l3.9679" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9680"></a><span id="l3.9680" class="difflineplus">+}</span>
<a href="#l3.9681"></a><span id="l3.9681" class="difflineplus">+</span>
<a href="#l3.9682"></a><span id="l3.9682" class="difflineplus">+void nsImapProtocol::XMailboxInfo(const char *mailboxName) {</span>
<a href="#l3.9683"></a><span id="l3.9683" class="difflineplus">+  ProgressEventFunctionUsingName(&quot;imapGettingMailboxInfo&quot;);</span>
<a href="#l3.9684"></a><span id="l3.9684" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.9685"></a><span id="l3.9685" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.9686"></a><span id="l3.9686"> </span>
<a href="#l3.9687"></a><span id="l3.9687">   command.AppendLiteral(&quot; XMAILBOXINFO \&quot;&quot;);</span>
<a href="#l3.9688"></a><span id="l3.9688">   command.Append(mailboxName);</span>
<a href="#l3.9689"></a><span id="l3.9689">   command.AppendLiteral(&quot;\&quot; MANAGEURL POSTURL&quot; CRLF);</span>
<a href="#l3.9690"></a><span id="l3.9690"> </span>
<a href="#l3.9691"></a><span id="l3.9691" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.9692"></a><span id="l3.9692" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9693"></a><span id="l3.9693" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9694"></a><span id="l3.9694" class="difflineminus">-}</span>
<a href="#l3.9695"></a><span id="l3.9695" class="difflineminus">-</span>
<a href="#l3.9696"></a><span id="l3.9696" class="difflineminus">-void nsImapProtocol::Namespace()</span>
<a href="#l3.9697"></a><span id="l3.9697" class="difflineminus">-{</span>
<a href="#l3.9698"></a><span id="l3.9698" class="difflineminus">-</span>
<a href="#l3.9699"></a><span id="l3.9699" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.9700"></a><span id="l3.9700" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.9701"></a><span id="l3.9701" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9702"></a><span id="l3.9702" class="difflineplus">+}</span>
<a href="#l3.9703"></a><span id="l3.9703" class="difflineplus">+</span>
<a href="#l3.9704"></a><span id="l3.9704" class="difflineplus">+void nsImapProtocol::Namespace() {</span>
<a href="#l3.9705"></a><span id="l3.9705" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.9706"></a><span id="l3.9706"> </span>
<a href="#l3.9707"></a><span id="l3.9707">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.9708"></a><span id="l3.9708">   command.AppendLiteral(&quot; namespace&quot; CRLF);</span>
<a href="#l3.9709"></a><span id="l3.9709"> </span>
<a href="#l3.9710"></a><span id="l3.9710" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.9711"></a><span id="l3.9711" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9712"></a><span id="l3.9712" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9713"></a><span id="l3.9713" class="difflineminus">-}</span>
<a href="#l3.9714"></a><span id="l3.9714" class="difflineminus">-</span>
<a href="#l3.9715"></a><span id="l3.9715" class="difflineminus">-</span>
<a href="#l3.9716"></a><span id="l3.9716" class="difflineminus">-void nsImapProtocol::MailboxData()</span>
<a href="#l3.9717"></a><span id="l3.9717" class="difflineminus">-{</span>
<a href="#l3.9718"></a><span id="l3.9718" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.9719"></a><span id="l3.9719" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.9720"></a><span id="l3.9720" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9721"></a><span id="l3.9721" class="difflineplus">+}</span>
<a href="#l3.9722"></a><span id="l3.9722" class="difflineplus">+</span>
<a href="#l3.9723"></a><span id="l3.9723" class="difflineplus">+void nsImapProtocol::MailboxData() {</span>
<a href="#l3.9724"></a><span id="l3.9724" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.9725"></a><span id="l3.9725"> </span>
<a href="#l3.9726"></a><span id="l3.9726">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.9727"></a><span id="l3.9727">   command.AppendLiteral(&quot; mailboxdata&quot; CRLF);</span>
<a href="#l3.9728"></a><span id="l3.9728"> </span>
<a href="#l3.9729"></a><span id="l3.9729" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.9730"></a><span id="l3.9730" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9731"></a><span id="l3.9731" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9732"></a><span id="l3.9732" class="difflineminus">-}</span>
<a href="#l3.9733"></a><span id="l3.9733" class="difflineminus">-</span>
<a href="#l3.9734"></a><span id="l3.9734" class="difflineminus">-</span>
<a href="#l3.9735"></a><span id="l3.9735" class="difflineminus">-void nsImapProtocol::GetMyRightsForFolder(const char *mailboxName)</span>
<a href="#l3.9736"></a><span id="l3.9736" class="difflineminus">-{</span>
<a href="#l3.9737"></a><span id="l3.9737" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.9738"></a><span id="l3.9738" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9739"></a><span id="l3.9739" class="difflineplus">+}</span>
<a href="#l3.9740"></a><span id="l3.9740" class="difflineplus">+</span>
<a href="#l3.9741"></a><span id="l3.9741" class="difflineplus">+void nsImapProtocol::GetMyRightsForFolder(const char *mailboxName) {</span>
<a href="#l3.9742"></a><span id="l3.9742">   IncrementCommandTagNumber();</span>
<a href="#l3.9743"></a><span id="l3.9743"> </span>
<a href="#l3.9744"></a><span id="l3.9744">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.9745"></a><span id="l3.9745">   nsCString escapedName;</span>
<a href="#l3.9746"></a><span id="l3.9746">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.9747"></a><span id="l3.9747"> </span>
<a href="#l3.9748"></a><span id="l3.9748">   if (MailboxIsNoSelectMailbox(escapedName.get()))</span>
<a href="#l3.9749"></a><span id="l3.9749" class="difflineminus">-    return; // Don't issue myrights on Noselect folder</span>
<a href="#l3.9750"></a><span id="l3.9750" class="difflineplus">+    return;  // Don't issue myrights on Noselect folder</span>
<a href="#l3.9751"></a><span id="l3.9751"> </span>
<a href="#l3.9752"></a><span id="l3.9752">   command.AppendLiteral(&quot; myrights \&quot;&quot;);</span>
<a href="#l3.9753"></a><span id="l3.9753">   command.Append(escapedName);</span>
<a href="#l3.9754"></a><span id="l3.9754">   command.AppendLiteral(&quot;\&quot;&quot; CRLF);</span>
<a href="#l3.9755"></a><span id="l3.9755"> </span>
<a href="#l3.9756"></a><span id="l3.9756">   nsresult rv = SendData(command.get());</span>
<a href="#l3.9757"></a><span id="l3.9757" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9758"></a><span id="l3.9758" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9759"></a><span id="l3.9759" class="difflineminus">-}</span>
<a href="#l3.9760"></a><span id="l3.9760" class="difflineminus">-</span>
<a href="#l3.9761"></a><span id="l3.9761" class="difflineminus">-bool nsImapProtocol::FolderIsSelected(const char *mailboxName)</span>
<a href="#l3.9762"></a><span id="l3.9762" class="difflineminus">-{</span>
<a href="#l3.9763"></a><span id="l3.9763" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9764"></a><span id="l3.9764" class="difflineplus">+}</span>
<a href="#l3.9765"></a><span id="l3.9765" class="difflineplus">+</span>
<a href="#l3.9766"></a><span id="l3.9766" class="difflineplus">+bool nsImapProtocol::FolderIsSelected(const char *mailboxName) {</span>
<a href="#l3.9767"></a><span id="l3.9767">   return (GetServerStateParser().GetIMAPstate() ==</span>
<a href="#l3.9768"></a><span id="l3.9768" class="difflineminus">-      nsImapServerResponseParser::kFolderSelected &amp;&amp; GetServerStateParser().GetSelectedMailboxName() &amp;&amp;</span>
<a href="#l3.9769"></a><span id="l3.9769" class="difflineminus">-      PL_strcmp(GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.9770"></a><span id="l3.9770" class="difflineplus">+              nsImapServerResponseParser::kFolderSelected &amp;&amp;</span>
<a href="#l3.9771"></a><span id="l3.9771" class="difflineplus">+          GetServerStateParser().GetSelectedMailboxName() &amp;&amp;</span>
<a href="#l3.9772"></a><span id="l3.9772" class="difflineplus">+          PL_strcmp(GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l3.9773"></a><span id="l3.9773">                     mailboxName) == 0);</span>
<a href="#l3.9774"></a><span id="l3.9774"> }</span>
<a href="#l3.9775"></a><span id="l3.9775"> </span>
<a href="#l3.9776"></a><span id="l3.9776" class="difflineminus">-void nsImapProtocol::OnStatusForFolder(const char *mailboxName)</span>
<a href="#l3.9777"></a><span id="l3.9777" class="difflineminus">-{</span>
<a href="#l3.9778"></a><span id="l3.9778" class="difflineminus">-</span>
<a href="#l3.9779"></a><span id="l3.9779" class="difflineminus">-  if (FolderIsSelected(mailboxName))</span>
<a href="#l3.9780"></a><span id="l3.9780" class="difflineminus">-  {</span>
<a href="#l3.9781"></a><span id="l3.9781" class="difflineplus">+void nsImapProtocol::OnStatusForFolder(const char *mailboxName) {</span>
<a href="#l3.9782"></a><span id="l3.9782" class="difflineplus">+  if (FolderIsSelected(mailboxName)) {</span>
<a href="#l3.9783"></a><span id="l3.9783">     int32_t prevNumMessages = GetServerStateParser().NumberOfMessages();</span>
<a href="#l3.9784"></a><span id="l3.9784">     Noop();</span>
<a href="#l3.9785"></a><span id="l3.9785">     // OnNewIdleMessages will cause the ui thread to update the folder</span>
<a href="#l3.9786"></a><span id="l3.9786" class="difflineminus">-    if (m_imapMailFolderSink &amp;&amp; (GetServerStateParser().NumberOfRecentMessages()</span>
<a href="#l3.9787"></a><span id="l3.9787" class="difflineminus">-          || prevNumMessages != GetServerStateParser().NumberOfMessages()))</span>
<a href="#l3.9788"></a><span id="l3.9788" class="difflineplus">+    if (m_imapMailFolderSink &amp;&amp;</span>
<a href="#l3.9789"></a><span id="l3.9789" class="difflineplus">+        (GetServerStateParser().NumberOfRecentMessages() ||</span>
<a href="#l3.9790"></a><span id="l3.9790" class="difflineplus">+         prevNumMessages != GetServerStateParser().NumberOfMessages()))</span>
<a href="#l3.9791"></a><span id="l3.9791">       m_imapMailFolderSink-&gt;OnNewIdleMessages();</span>
<a href="#l3.9792"></a><span id="l3.9792">     return;</span>
<a href="#l3.9793"></a><span id="l3.9793">   }</span>
<a href="#l3.9794"></a><span id="l3.9794"> </span>
<a href="#l3.9795"></a><span id="l3.9795">   IncrementCommandTagNumber();</span>
<a href="#l3.9796"></a><span id="l3.9796"> </span>
<a href="#l3.9797"></a><span id="l3.9797">   nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.9798"></a><span id="l3.9798">   nsCString escapedName;</span>
<a href="#l3.9799"></a><span id="l3.9799">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.9800"></a><span id="l3.9800"> </span>
<a href="#l3.9801"></a><span id="l3.9801">   command.AppendLiteral(&quot; STATUS \&quot;&quot;);</span>
<a href="#l3.9802"></a><span id="l3.9802">   command.Append(escapedName);</span>
<a href="#l3.9803"></a><span id="l3.9803">   command.AppendLiteral(&quot;\&quot; (UIDNEXT MESSAGES UNSEEN RECENT)&quot; CRLF);</span>
<a href="#l3.9804"></a><span id="l3.9804"> </span>
<a href="#l3.9805"></a><span id="l3.9805">   nsresult rv = SendData(command.get());</span>
<a href="#l3.9806"></a><span id="l3.9806" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.9807"></a><span id="l3.9807" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9808"></a><span id="l3.9808" class="difflineminus">-</span>
<a href="#l3.9809"></a><span id="l3.9809" class="difflineminus">-  if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.9810"></a><span id="l3.9810" class="difflineminus">-  {</span>
<a href="#l3.9811"></a><span id="l3.9811" class="difflineminus">-    RefPtr&lt;nsImapMailboxSpec&gt; new_spec = GetServerStateParser().CreateCurrentMailboxSpec(mailboxName);</span>
<a href="#l3.9812"></a><span id="l3.9812" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.9813"></a><span id="l3.9813" class="difflineplus">+</span>
<a href="#l3.9814"></a><span id="l3.9814" class="difflineplus">+  if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.9815"></a><span id="l3.9815" class="difflineplus">+    RefPtr&lt;nsImapMailboxSpec&gt; new_spec =</span>
<a href="#l3.9816"></a><span id="l3.9816" class="difflineplus">+        GetServerStateParser().CreateCurrentMailboxSpec(mailboxName);</span>
<a href="#l3.9817"></a><span id="l3.9817">     if (new_spec &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l3.9818"></a><span id="l3.9818">       m_imapMailFolderSink-&gt;UpdateImapMailboxStatus(this, new_spec);</span>
<a href="#l3.9819"></a><span id="l3.9819">   }</span>
<a href="#l3.9820"></a><span id="l3.9820"> }</span>
<a href="#l3.9821"></a><span id="l3.9821"> </span>
<a href="#l3.9822"></a><span id="l3.9822" class="difflineminus">-</span>
<a href="#l3.9823"></a><span id="l3.9823" class="difflineminus">-void nsImapProtocol::OnListFolder(const char * aSourceMailbox, bool aBool)</span>
<a href="#l3.9824"></a><span id="l3.9824" class="difflineminus">-{</span>
<a href="#l3.9825"></a><span id="l3.9825" class="difflineplus">+void nsImapProtocol::OnListFolder(const char *aSourceMailbox, bool aBool) {</span>
<a href="#l3.9826"></a><span id="l3.9826">   List(aSourceMailbox, aBool);</span>
<a href="#l3.9827"></a><span id="l3.9827"> }</span>
<a href="#l3.9828"></a><span id="l3.9828"> </span>
<a href="#l3.9829"></a><span id="l3.9829" class="difflineminus">-</span>
<a href="#l3.9830"></a><span id="l3.9830"> // Returns true if the mailbox is a NoSelect mailbox.</span>
<a href="#l3.9831"></a><span id="l3.9831"> // If we don't know about it, returns false.</span>
<a href="#l3.9832"></a><span id="l3.9832" class="difflineminus">-bool nsImapProtocol::MailboxIsNoSelectMailbox(const char *mailboxName)</span>
<a href="#l3.9833"></a><span id="l3.9833" class="difflineminus">-{</span>
<a href="#l3.9834"></a><span id="l3.9834" class="difflineplus">+bool nsImapProtocol::MailboxIsNoSelectMailbox(const char *mailboxName) {</span>
<a href="#l3.9835"></a><span id="l3.9835">   bool rv = false;</span>
<a href="#l3.9836"></a><span id="l3.9836"> </span>
<a href="#l3.9837"></a><span id="l3.9837">   nsIMAPNamespace *nsForMailbox = nullptr;</span>
<a href="#l3.9838"></a><span id="l3.9838" class="difflineminus">-    m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.9839"></a><span id="l3.9839" class="difflineminus">-                                                     mailboxName, nsForMailbox);</span>
<a href="#l3.9840"></a><span id="l3.9840" class="difflineplus">+  m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.9841"></a><span id="l3.9841" class="difflineplus">+                                                   mailboxName, nsForMailbox);</span>
<a href="#l3.9842"></a><span id="l3.9842">   // NS_ASSERTION (nsForMailbox, &quot;Oops .. null nsForMailbox&quot;);</span>
<a href="#l3.9843"></a><span id="l3.9843"> </span>
<a href="#l3.9844"></a><span id="l3.9844">   nsCString name;</span>
<a href="#l3.9845"></a><span id="l3.9845"> </span>
<a href="#l3.9846"></a><span id="l3.9846">   if (nsForMailbox)</span>
<a href="#l3.9847"></a><span id="l3.9847" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName,</span>
<a href="#l3.9848"></a><span id="l3.9848" class="difflineminus">-                                            nsForMailbox-&gt;GetDelimiter(),</span>
<a href="#l3.9849"></a><span id="l3.9849" class="difflineminus">-                                            getter_Copies(name));</span>
<a href="#l3.9850"></a><span id="l3.9850" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.9851"></a><span id="l3.9851" class="difflineplus">+        mailboxName, nsForMailbox-&gt;GetDelimiter(), getter_Copies(name));</span>
<a href="#l3.9852"></a><span id="l3.9852">   else</span>
<a href="#l3.9853"></a><span id="l3.9853" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName,</span>
<a href="#l3.9854"></a><span id="l3.9854" class="difflineminus">-                                            kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.9855"></a><span id="l3.9855" class="difflineminus">-                                            getter_Copies(name));</span>
<a href="#l3.9856"></a><span id="l3.9856" class="difflineminus">-</span>
<a href="#l3.9857"></a><span id="l3.9857" class="difflineminus">-  if (name.IsEmpty())</span>
<a href="#l3.9858"></a><span id="l3.9858" class="difflineminus">-    return false;</span>
<a href="#l3.9859"></a><span id="l3.9859" class="difflineminus">-</span>
<a href="#l3.9860"></a><span id="l3.9860" class="difflineminus">-  NS_ASSERTION(m_imapServerSink, &quot;unexpected, no imap server sink, see bug #194335&quot;);</span>
<a href="#l3.9861"></a><span id="l3.9861" class="difflineminus">-  if (m_imapServerSink)</span>
<a href="#l3.9862"></a><span id="l3.9862" class="difflineminus">-    m_imapServerSink-&gt;FolderIsNoSelect(name, &amp;rv);</span>
<a href="#l3.9863"></a><span id="l3.9863" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.9864"></a><span id="l3.9864" class="difflineplus">+        mailboxName, kOnlineHierarchySeparatorUnknown, getter_Copies(name));</span>
<a href="#l3.9865"></a><span id="l3.9865" class="difflineplus">+</span>
<a href="#l3.9866"></a><span id="l3.9866" class="difflineplus">+  if (name.IsEmpty()) return false;</span>
<a href="#l3.9867"></a><span id="l3.9867" class="difflineplus">+</span>
<a href="#l3.9868"></a><span id="l3.9868" class="difflineplus">+  NS_ASSERTION(m_imapServerSink,</span>
<a href="#l3.9869"></a><span id="l3.9869" class="difflineplus">+               &quot;unexpected, no imap server sink, see bug #194335&quot;);</span>
<a href="#l3.9870"></a><span id="l3.9870" class="difflineplus">+  if (m_imapServerSink) m_imapServerSink-&gt;FolderIsNoSelect(name, &amp;rv);</span>
<a href="#l3.9871"></a><span id="l3.9871">   return rv;</span>
<a href="#l3.9872"></a><span id="l3.9872"> }</span>
<a href="#l3.9873"></a><span id="l3.9873"> </span>
<a href="#l3.9874"></a><span id="l3.9874" class="difflineminus">-nsresult nsImapProtocol::SetFolderAdminUrl(const char *mailboxName)</span>
<a href="#l3.9875"></a><span id="l3.9875" class="difflineminus">-{</span>
<a href="#l3.9876"></a><span id="l3.9876" class="difflineminus">-  nsresult rv = NS_ERROR_NULL_POINTER; // if m_imapServerSink is null, rv will be this.</span>
<a href="#l3.9877"></a><span id="l3.9877" class="difflineplus">+nsresult nsImapProtocol::SetFolderAdminUrl(const char *mailboxName) {</span>
<a href="#l3.9878"></a><span id="l3.9878" class="difflineplus">+  nsresult rv =</span>
<a href="#l3.9879"></a><span id="l3.9879" class="difflineplus">+      NS_ERROR_NULL_POINTER;  // if m_imapServerSink is null, rv will be this.</span>
<a href="#l3.9880"></a><span id="l3.9880"> </span>
<a href="#l3.9881"></a><span id="l3.9881">   nsIMAPNamespace *nsForMailbox = nullptr;</span>
<a href="#l3.9882"></a><span id="l3.9882">   m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.9883"></a><span id="l3.9883" class="difflineminus">-                                                     mailboxName, nsForMailbox);</span>
<a href="#l3.9884"></a><span id="l3.9884" class="difflineplus">+                                                   mailboxName, nsForMailbox);</span>
<a href="#l3.9885"></a><span id="l3.9885"> </span>
<a href="#l3.9886"></a><span id="l3.9886">   nsCString name;</span>
<a href="#l3.9887"></a><span id="l3.9887"> </span>
<a href="#l3.9888"></a><span id="l3.9888">   if (nsForMailbox)</span>
<a href="#l3.9889"></a><span id="l3.9889" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName,</span>
<a href="#l3.9890"></a><span id="l3.9890" class="difflineminus">-                                            nsForMailbox-&gt;GetDelimiter(),</span>
<a href="#l3.9891"></a><span id="l3.9891" class="difflineminus">-                                            getter_Copies(name));</span>
<a href="#l3.9892"></a><span id="l3.9892" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.9893"></a><span id="l3.9893" class="difflineplus">+        mailboxName, nsForMailbox-&gt;GetDelimiter(), getter_Copies(name));</span>
<a href="#l3.9894"></a><span id="l3.9894">   else</span>
<a href="#l3.9895"></a><span id="l3.9895" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName,</span>
<a href="#l3.9896"></a><span id="l3.9896" class="difflineminus">-                                            kOnlineHierarchySeparatorUnknown,</span>
<a href="#l3.9897"></a><span id="l3.9897" class="difflineminus">-                                            getter_Copies(name));</span>
<a href="#l3.9898"></a><span id="l3.9898" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.9899"></a><span id="l3.9899" class="difflineplus">+        mailboxName, kOnlineHierarchySeparatorUnknown, getter_Copies(name));</span>
<a href="#l3.9900"></a><span id="l3.9900"> </span>
<a href="#l3.9901"></a><span id="l3.9901">   if (m_imapServerSink)</span>
<a href="#l3.9902"></a><span id="l3.9902" class="difflineminus">-    rv = m_imapServerSink-&gt;SetFolderAdminURL(name, nsDependentCString(GetServerStateParser().GetManageFolderUrl()));</span>
<a href="#l3.9903"></a><span id="l3.9903" class="difflineplus">+    rv = m_imapServerSink-&gt;SetFolderAdminURL(</span>
<a href="#l3.9904"></a><span id="l3.9904" class="difflineplus">+        name, nsDependentCString(GetServerStateParser().GetManageFolderUrl()));</span>
<a href="#l3.9905"></a><span id="l3.9905">   return rv;</span>
<a href="#l3.9906"></a><span id="l3.9906"> }</span>
<a href="#l3.9907"></a><span id="l3.9907"> // returns true is the delete succeeded (regardless of subscription changes)</span>
<a href="#l3.9908"></a><span id="l3.9908" class="difflineminus">-bool nsImapProtocol::DeleteMailboxRespectingSubscriptions(const char *mailboxName)</span>
<a href="#l3.9909"></a><span id="l3.9909" class="difflineminus">-{</span>
<a href="#l3.9910"></a><span id="l3.9910" class="difflineplus">+bool nsImapProtocol::DeleteMailboxRespectingSubscriptions(</span>
<a href="#l3.9911"></a><span id="l3.9911" class="difflineplus">+    const char *mailboxName) {</span>
<a href="#l3.9912"></a><span id="l3.9912">   bool rv = true;</span>
<a href="#l3.9913"></a><span id="l3.9913" class="difflineminus">-  if (!MailboxIsNoSelectMailbox(mailboxName))</span>
<a href="#l3.9914"></a><span id="l3.9914" class="difflineminus">-  {</span>
<a href="#l3.9915"></a><span id="l3.9915" class="difflineplus">+  if (!MailboxIsNoSelectMailbox(mailboxName)) {</span>
<a href="#l3.9916"></a><span id="l3.9916">     // Only try to delete it if it really exists</span>
<a href="#l3.9917"></a><span id="l3.9917">     DeleteMailbox(mailboxName);</span>
<a href="#l3.9918"></a><span id="l3.9918">     rv = GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l3.9919"></a><span id="l3.9919">   }</span>
<a href="#l3.9920"></a><span id="l3.9920"> </span>
<a href="#l3.9921"></a><span id="l3.9921">   // We can unsubscribe even if the mailbox doesn't exist.</span>
<a href="#l3.9922"></a><span id="l3.9922" class="difflineminus">-  if (rv &amp;&amp; m_autoUnsubscribe) // auto-unsubscribe is on</span>
<a href="#l3.9923"></a><span id="l3.9923" class="difflineplus">+  if (rv &amp;&amp; m_autoUnsubscribe)  // auto-unsubscribe is on</span>
<a href="#l3.9924"></a><span id="l3.9924">   {</span>
<a href="#l3.9925"></a><span id="l3.9925">     bool reportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.9926"></a><span id="l3.9926">     GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.9927"></a><span id="l3.9927">     Unsubscribe(mailboxName);</span>
<a href="#l3.9928"></a><span id="l3.9928">     GetServerStateParser().SetReportingErrors(reportingErrors);</span>
<a href="#l3.9929"></a><span id="l3.9929" class="difflineminus">-</span>
<a href="#l3.9930"></a><span id="l3.9930">   }</span>
<a href="#l3.9931"></a><span id="l3.9931">   return (rv);</span>
<a href="#l3.9932"></a><span id="l3.9932"> }</span>
<a href="#l3.9933"></a><span id="l3.9933"> </span>
<a href="#l3.9934"></a><span id="l3.9934"> // returns true is the rename succeeded (regardless of subscription changes)</span>
<a href="#l3.9935"></a><span id="l3.9935" class="difflineminus">-// reallyRename tells us if we should really do the rename (true) or if we should just move subscriptions (false)</span>
<a href="#l3.9936"></a><span id="l3.9936" class="difflineminus">-bool nsImapProtocol::RenameMailboxRespectingSubscriptions(const char *existingName, const char *newName, bool reallyRename)</span>
<a href="#l3.9937"></a><span id="l3.9937" class="difflineminus">-{</span>
<a href="#l3.9938"></a><span id="l3.9938" class="difflineplus">+// reallyRename tells us if we should really do the rename (true) or if we</span>
<a href="#l3.9939"></a><span id="l3.9939" class="difflineplus">+// should just move subscriptions (false)</span>
<a href="#l3.9940"></a><span id="l3.9940" class="difflineplus">+bool nsImapProtocol::RenameMailboxRespectingSubscriptions(</span>
<a href="#l3.9941"></a><span id="l3.9941" class="difflineplus">+    const char *existingName, const char *newName, bool reallyRename) {</span>
<a href="#l3.9942"></a><span id="l3.9942">   bool rv = true;</span>
<a href="#l3.9943"></a><span id="l3.9943" class="difflineminus">-  if (reallyRename &amp;&amp; !MailboxIsNoSelectMailbox(existingName))</span>
<a href="#l3.9944"></a><span id="l3.9944" class="difflineminus">-  {</span>
<a href="#l3.9945"></a><span id="l3.9945" class="difflineplus">+  if (reallyRename &amp;&amp; !MailboxIsNoSelectMailbox(existingName)) {</span>
<a href="#l3.9946"></a><span id="l3.9946">     RenameMailbox(existingName, newName);</span>
<a href="#l3.9947"></a><span id="l3.9947">     rv = GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l3.9948"></a><span id="l3.9948">   }</span>
<a href="#l3.9949"></a><span id="l3.9949"> </span>
<a href="#l3.9950"></a><span id="l3.9950" class="difflineminus">-  if (rv)</span>
<a href="#l3.9951"></a><span id="l3.9951" class="difflineminus">-  {</span>
<a href="#l3.9952"></a><span id="l3.9952" class="difflineplus">+  if (rv) {</span>
<a href="#l3.9953"></a><span id="l3.9953">     if (m_autoSubscribe)  // if auto-subscribe is on</span>
<a href="#l3.9954"></a><span id="l3.9954">     {</span>
<a href="#l3.9955"></a><span id="l3.9955">       bool reportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.9956"></a><span id="l3.9956">       GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.9957"></a><span id="l3.9957">       Subscribe(newName);</span>
<a href="#l3.9958"></a><span id="l3.9958">       GetServerStateParser().SetReportingErrors(reportingErrors);</span>
<a href="#l3.9959"></a><span id="l3.9959">     }</span>
<a href="#l3.9960"></a><span id="l3.9960" class="difflineminus">-    if (m_autoUnsubscribe) // if auto-unsubscribe is on</span>
<a href="#l3.9961"></a><span id="l3.9961" class="difflineplus">+    if (m_autoUnsubscribe)  // if auto-unsubscribe is on</span>
<a href="#l3.9962"></a><span id="l3.9962">     {</span>
<a href="#l3.9963"></a><span id="l3.9963">       bool reportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.9964"></a><span id="l3.9964">       GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.9965"></a><span id="l3.9965">       Unsubscribe(existingName);</span>
<a href="#l3.9966"></a><span id="l3.9966">       GetServerStateParser().SetReportingErrors(reportingErrors);</span>
<a href="#l3.9967"></a><span id="l3.9967">     }</span>
<a href="#l3.9968"></a><span id="l3.9968">   }</span>
<a href="#l3.9969"></a><span id="l3.9969">   return (rv);</span>
<a href="#l3.9970"></a><span id="l3.9970"> }</span>
<a href="#l3.9971"></a><span id="l3.9971"> </span>
<a href="#l3.9972"></a><span id="l3.9972"> bool nsImapProtocol::RenameHierarchyByHand(const char *oldParentMailboxName,</span>
<a href="#l3.9973"></a><span id="l3.9973" class="difflineminus">-                                             const char *newParentMailboxName)</span>
<a href="#l3.9974"></a><span id="l3.9974" class="difflineminus">-{</span>
<a href="#l3.9975"></a><span id="l3.9975" class="difflineplus">+                                           const char *newParentMailboxName) {</span>
<a href="#l3.9976"></a><span id="l3.9976">   bool renameSucceeded = true;</span>
<a href="#l3.9977"></a><span id="l3.9977" class="difflineminus">-    char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.9978"></a><span id="l3.9978" class="difflineminus">-  m_deletableChildren = new nsTArray&lt;char*&gt;();</span>
<a href="#l3.9979"></a><span id="l3.9979" class="difflineplus">+  char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.9980"></a><span id="l3.9980" class="difflineplus">+  m_deletableChildren = new nsTArray&lt;char *&gt;();</span>
<a href="#l3.9981"></a><span id="l3.9981"> </span>
<a href="#l3.9982"></a><span id="l3.9982">   bool nonHierarchicalRename =</span>
<a href="#l3.9983"></a><span id="l3.9983" class="difflineminus">-        ((GetServerStateParser().GetCapabilityFlag() &amp; kNoHierarchyRename)</span>
<a href="#l3.9984"></a><span id="l3.9984" class="difflineminus">-         || MailboxIsNoSelectMailbox(oldParentMailboxName));</span>
<a href="#l3.9985"></a><span id="l3.9985" class="difflineminus">-</span>
<a href="#l3.9986"></a><span id="l3.9986" class="difflineminus">-  if (m_deletableChildren)</span>
<a href="#l3.9987"></a><span id="l3.9987" class="difflineminus">-  {</span>
<a href="#l3.9988"></a><span id="l3.9988" class="difflineplus">+      ((GetServerStateParser().GetCapabilityFlag() &amp; kNoHierarchyRename) ||</span>
<a href="#l3.9989"></a><span id="l3.9989" class="difflineplus">+       MailboxIsNoSelectMailbox(oldParentMailboxName));</span>
<a href="#l3.9990"></a><span id="l3.9990" class="difflineplus">+</span>
<a href="#l3.9991"></a><span id="l3.9991" class="difflineplus">+  if (m_deletableChildren) {</span>
<a href="#l3.9992"></a><span id="l3.9992">     m_hierarchyNameState = kDeleteSubFoldersInProgress;</span>
<a href="#l3.9993"></a><span id="l3.9993">     nsIMAPNamespace *ns = nullptr;</span>
<a href="#l3.9994"></a><span id="l3.9994" class="difflineminus">-        m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.9995"></a><span id="l3.9995" class="difflineminus">-                                                         oldParentMailboxName,</span>
<a href="#l3.9996"></a><span id="l3.9996" class="difflineminus">-                                                         ns); // for delimiter</span>
<a href="#l3.9997"></a><span id="l3.9997" class="difflineminus">-    if (!ns)</span>
<a href="#l3.9998"></a><span id="l3.9998" class="difflineminus">-    {</span>
<a href="#l3.9999"></a><span id="l3.9999" class="difflineplus">+    m_hostSessionList-&gt;GetNamespaceForMailboxForHost(GetImapServerKey(),</span>
<a href="#l3.10000"></a><span id="l3.10000" class="difflineplus">+                                                     oldParentMailboxName,</span>
<a href="#l3.10001"></a><span id="l3.10001" class="difflineplus">+                                                     ns);  // for delimiter</span>
<a href="#l3.10002"></a><span id="l3.10002" class="difflineplus">+    if (!ns) {</span>
<a href="#l3.10003"></a><span id="l3.10003">       if (!PL_strcasecmp(oldParentMailboxName, &quot;INBOX&quot;))</span>
<a href="#l3.10004"></a><span id="l3.10004" class="difflineminus">-                m_hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(GetImapServerKey(),</span>
<a href="#l3.10005"></a><span id="l3.10005" class="difflineminus">-                                                                    kPersonalNamespace,</span>
<a href="#l3.10006"></a><span id="l3.10006" class="difflineminus">-                                                                    ns);</span>
<a href="#l3.10007"></a><span id="l3.10007" class="difflineminus">-    }</span>
<a href="#l3.10008"></a><span id="l3.10008" class="difflineminus">-    if (ns)</span>
<a href="#l3.10009"></a><span id="l3.10009" class="difflineminus">-    {</span>
<a href="#l3.10010"></a><span id="l3.10010" class="difflineminus">-            nsCString pattern(oldParentMailboxName);</span>
<a href="#l3.10011"></a><span id="l3.10011" class="difflineminus">-            pattern += ns-&gt;GetDelimiter();</span>
<a href="#l3.10012"></a><span id="l3.10012" class="difflineminus">-            pattern += &quot;*&quot;;</span>
<a href="#l3.10013"></a><span id="l3.10013" class="difflineminus">-            bool isUsingSubscription = false;</span>
<a href="#l3.10014"></a><span id="l3.10014" class="difflineminus">-            m_hostSessionList-&gt;GetHostIsUsingSubscription(GetImapServerKey(),</span>
<a href="#l3.10015"></a><span id="l3.10015" class="difflineminus">-                                                          isUsingSubscription);</span>
<a href="#l3.10016"></a><span id="l3.10016" class="difflineminus">-</span>
<a href="#l3.10017"></a><span id="l3.10017" class="difflineminus">-            if (isUsingSubscription)</span>
<a href="#l3.10018"></a><span id="l3.10018" class="difflineminus">-                Lsub(pattern.get(), false);</span>
<a href="#l3.10019"></a><span id="l3.10019" class="difflineminus">-            else</span>
<a href="#l3.10020"></a><span id="l3.10020" class="difflineminus">-                List(pattern.get(), false);</span>
<a href="#l3.10021"></a><span id="l3.10021" class="difflineplus">+        m_hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(</span>
<a href="#l3.10022"></a><span id="l3.10022" class="difflineplus">+            GetImapServerKey(), kPersonalNamespace, ns);</span>
<a href="#l3.10023"></a><span id="l3.10023" class="difflineplus">+    }</span>
<a href="#l3.10024"></a><span id="l3.10024" class="difflineplus">+    if (ns) {</span>
<a href="#l3.10025"></a><span id="l3.10025" class="difflineplus">+      nsCString pattern(oldParentMailboxName);</span>
<a href="#l3.10026"></a><span id="l3.10026" class="difflineplus">+      pattern += ns-&gt;GetDelimiter();</span>
<a href="#l3.10027"></a><span id="l3.10027" class="difflineplus">+      pattern += &quot;*&quot;;</span>
<a href="#l3.10028"></a><span id="l3.10028" class="difflineplus">+      bool isUsingSubscription = false;</span>
<a href="#l3.10029"></a><span id="l3.10029" class="difflineplus">+      m_hostSessionList-&gt;GetHostIsUsingSubscription(GetImapServerKey(),</span>
<a href="#l3.10030"></a><span id="l3.10030" class="difflineplus">+                                                    isUsingSubscription);</span>
<a href="#l3.10031"></a><span id="l3.10031" class="difflineplus">+</span>
<a href="#l3.10032"></a><span id="l3.10032" class="difflineplus">+      if (isUsingSubscription)</span>
<a href="#l3.10033"></a><span id="l3.10033" class="difflineplus">+        Lsub(pattern.get(), false);</span>
<a href="#l3.10034"></a><span id="l3.10034" class="difflineplus">+      else</span>
<a href="#l3.10035"></a><span id="l3.10035" class="difflineplus">+        List(pattern.get(), false);</span>
<a href="#l3.10036"></a><span id="l3.10036">     }</span>
<a href="#l3.10037"></a><span id="l3.10037">     m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.10038"></a><span id="l3.10038"> </span>
<a href="#l3.10039"></a><span id="l3.10039">     if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.10040"></a><span id="l3.10040" class="difflineminus">-      renameSucceeded = // rename this, and move subscriptions</span>
<a href="#l3.10041"></a><span id="l3.10041" class="difflineminus">-                RenameMailboxRespectingSubscriptions(oldParentMailboxName,</span>
<a href="#l3.10042"></a><span id="l3.10042" class="difflineminus">-                                                     newParentMailboxName, true);</span>
<a href="#l3.10043"></a><span id="l3.10043" class="difflineplus">+      renameSucceeded =  // rename this, and move subscriptions</span>
<a href="#l3.10044"></a><span id="l3.10044" class="difflineplus">+          RenameMailboxRespectingSubscriptions(oldParentMailboxName,</span>
<a href="#l3.10045"></a><span id="l3.10045" class="difflineplus">+                                               newParentMailboxName, true);</span>
<a href="#l3.10046"></a><span id="l3.10046"> </span>
<a href="#l3.10047"></a><span id="l3.10047">     size_t numberToDelete = m_deletableChildren-&gt;Length();</span>
<a href="#l3.10048"></a><span id="l3.10048">     size_t childIndex;</span>
<a href="#l3.10049"></a><span id="l3.10049"> </span>
<a href="#l3.10050"></a><span id="l3.10050" class="difflineminus">-    for (childIndex = 0;</span>
<a href="#l3.10051"></a><span id="l3.10051" class="difflineminus">-             (childIndex &lt; numberToDelete) &amp;&amp; renameSucceeded; childIndex++)</span>
<a href="#l3.10052"></a><span id="l3.10052" class="difflineminus">-    {</span>
<a href="#l3.10053"></a><span id="l3.10053" class="difflineminus">-      // the imap parser has already converted to a non UTF7 string in the canonical</span>
<a href="#l3.10054"></a><span id="l3.10054" class="difflineminus">-      // format so convert it back</span>
<a href="#l3.10055"></a><span id="l3.10055" class="difflineminus">-        char *currentName = m_deletableChildren-&gt;ElementAt(childIndex);</span>
<a href="#l3.10056"></a><span id="l3.10056" class="difflineminus">-        if (currentName)</span>
<a href="#l3.10057"></a><span id="l3.10057" class="difflineminus">-        {</span>
<a href="#l3.10058"></a><span id="l3.10058" class="difflineminus">-          char *serverName = nullptr;</span>
<a href="#l3.10059"></a><span id="l3.10059" class="difflineminus">-          m_runningUrl-&gt;AllocateServerPath(currentName,</span>
<a href="#l3.10060"></a><span id="l3.10060" class="difflineminus">-                                         onlineDirSeparator,</span>
<a href="#l3.10061"></a><span id="l3.10061" class="difflineplus">+    for (childIndex = 0; (childIndex &lt; numberToDelete) &amp;&amp; renameSucceeded;</span>
<a href="#l3.10062"></a><span id="l3.10062" class="difflineplus">+         childIndex++) {</span>
<a href="#l3.10063"></a><span id="l3.10063" class="difflineplus">+      // the imap parser has already converted to a non UTF7 string in the</span>
<a href="#l3.10064"></a><span id="l3.10064" class="difflineplus">+      // canonical format so convert it back</span>
<a href="#l3.10065"></a><span id="l3.10065" class="difflineplus">+      char *currentName = m_deletableChildren-&gt;ElementAt(childIndex);</span>
<a href="#l3.10066"></a><span id="l3.10066" class="difflineplus">+      if (currentName) {</span>
<a href="#l3.10067"></a><span id="l3.10067" class="difflineplus">+        char *serverName = nullptr;</span>
<a href="#l3.10068"></a><span id="l3.10068" class="difflineplus">+        m_runningUrl-&gt;AllocateServerPath(currentName, onlineDirSeparator,</span>
<a href="#l3.10069"></a><span id="l3.10069">                                          &amp;serverName);</span>
<a href="#l3.10070"></a><span id="l3.10070" class="difflineminus">-          PR_FREEIF(currentName);</span>
<a href="#l3.10071"></a><span id="l3.10071" class="difflineminus">-          currentName = serverName;</span>
<a href="#l3.10072"></a><span id="l3.10072" class="difflineminus">-        }</span>
<a href="#l3.10073"></a><span id="l3.10073" class="difflineminus">-</span>
<a href="#l3.10074"></a><span id="l3.10074" class="difflineminus">-        // calculate the new name and do the rename</span>
<a href="#l3.10075"></a><span id="l3.10075" class="difflineminus">-        nsCString newChildName(newParentMailboxName);</span>
<a href="#l3.10076"></a><span id="l3.10076" class="difflineminus">-        newChildName += (currentName + PL_strlen(oldParentMailboxName));</span>
<a href="#l3.10077"></a><span id="l3.10077" class="difflineminus">-        // Pass in 'nonHierarchicalRename' to determine if we should really</span>
<a href="#l3.10078"></a><span id="l3.10078" class="difflineminus">-        // reanme, or just move subscriptions.</span>
<a href="#l3.10079"></a><span id="l3.10079" class="difflineminus">-        renameSucceeded =</span>
<a href="#l3.10080"></a><span id="l3.10080" class="difflineminus">-          RenameMailboxRespectingSubscriptions(currentName,</span>
<a href="#l3.10081"></a><span id="l3.10081" class="difflineminus">-                                               newChildName.get(),</span>
<a href="#l3.10082"></a><span id="l3.10082" class="difflineminus">-                                               nonHierarchicalRename);</span>
<a href="#l3.10083"></a><span id="l3.10083">         PR_FREEIF(currentName);</span>
<a href="#l3.10084"></a><span id="l3.10084" class="difflineplus">+        currentName = serverName;</span>
<a href="#l3.10085"></a><span id="l3.10085" class="difflineplus">+      }</span>
<a href="#l3.10086"></a><span id="l3.10086" class="difflineplus">+</span>
<a href="#l3.10087"></a><span id="l3.10087" class="difflineplus">+      // calculate the new name and do the rename</span>
<a href="#l3.10088"></a><span id="l3.10088" class="difflineplus">+      nsCString newChildName(newParentMailboxName);</span>
<a href="#l3.10089"></a><span id="l3.10089" class="difflineplus">+      newChildName += (currentName + PL_strlen(oldParentMailboxName));</span>
<a href="#l3.10090"></a><span id="l3.10090" class="difflineplus">+      // Pass in 'nonHierarchicalRename' to determine if we should really</span>
<a href="#l3.10091"></a><span id="l3.10091" class="difflineplus">+      // reanme, or just move subscriptions.</span>
<a href="#l3.10092"></a><span id="l3.10092" class="difflineplus">+      renameSucceeded = RenameMailboxRespectingSubscriptions(</span>
<a href="#l3.10093"></a><span id="l3.10093" class="difflineplus">+          currentName, newChildName.get(), nonHierarchicalRename);</span>
<a href="#l3.10094"></a><span id="l3.10094" class="difflineplus">+      PR_FREEIF(currentName);</span>
<a href="#l3.10095"></a><span id="l3.10095">     }</span>
<a href="#l3.10096"></a><span id="l3.10096"> </span>
<a href="#l3.10097"></a><span id="l3.10097">     delete m_deletableChildren;</span>
<a href="#l3.10098"></a><span id="l3.10098">     m_deletableChildren = nullptr;</span>
<a href="#l3.10099"></a><span id="l3.10099">   }</span>
<a href="#l3.10100"></a><span id="l3.10100"> </span>
<a href="#l3.10101"></a><span id="l3.10101">   return renameSucceeded;</span>
<a href="#l3.10102"></a><span id="l3.10102"> }</span>
<a href="#l3.10103"></a><span id="l3.10103"> </span>
<a href="#l3.10104"></a><span id="l3.10104" class="difflineminus">-bool nsImapProtocol::DeleteSubFolders(const char* selectedMailbox, bool &amp;aDeleteSelf)</span>
<a href="#l3.10105"></a><span id="l3.10105" class="difflineminus">-{</span>
<a href="#l3.10106"></a><span id="l3.10106" class="difflineplus">+bool nsImapProtocol::DeleteSubFolders(const char *selectedMailbox,</span>
<a href="#l3.10107"></a><span id="l3.10107" class="difflineplus">+                                      bool &amp;aDeleteSelf) {</span>
<a href="#l3.10108"></a><span id="l3.10108">   bool deleteSucceeded = true;</span>
<a href="#l3.10109"></a><span id="l3.10109" class="difflineminus">-  m_deletableChildren = new nsTArray&lt;char*&gt;();</span>
<a href="#l3.10110"></a><span id="l3.10110" class="difflineminus">-</span>
<a href="#l3.10111"></a><span id="l3.10111" class="difflineminus">-  if (m_deletableChildren)</span>
<a href="#l3.10112"></a><span id="l3.10112" class="difflineminus">-  {</span>
<a href="#l3.10113"></a><span id="l3.10113" class="difflineplus">+  m_deletableChildren = new nsTArray&lt;char *&gt;();</span>
<a href="#l3.10114"></a><span id="l3.10114" class="difflineplus">+</span>
<a href="#l3.10115"></a><span id="l3.10115" class="difflineplus">+  if (m_deletableChildren) {</span>
<a href="#l3.10116"></a><span id="l3.10116">     bool folderDeleted = false;</span>
<a href="#l3.10117"></a><span id="l3.10117"> </span>
<a href="#l3.10118"></a><span id="l3.10118">     m_hierarchyNameState = kDeleteSubFoldersInProgress;</span>
<a href="#l3.10119"></a><span id="l3.10119" class="difflineminus">-        nsCString pattern(selectedMailbox);</span>
<a href="#l3.10120"></a><span id="l3.10120" class="difflineminus">-        char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.10121"></a><span id="l3.10121" class="difflineminus">-        m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;onlineDirSeparator);</span>
<a href="#l3.10122"></a><span id="l3.10122" class="difflineminus">-        pattern.Append(onlineDirSeparator);</span>
<a href="#l3.10123"></a><span id="l3.10123" class="difflineminus">-        pattern.Append('*');</span>
<a href="#l3.10124"></a><span id="l3.10124" class="difflineminus">-</span>
<a href="#l3.10125"></a><span id="l3.10125" class="difflineminus">-    if (!pattern.IsEmpty())</span>
<a href="#l3.10126"></a><span id="l3.10126" class="difflineminus">-    {</span>
<a href="#l3.10127"></a><span id="l3.10127" class="difflineplus">+    nsCString pattern(selectedMailbox);</span>
<a href="#l3.10128"></a><span id="l3.10128" class="difflineplus">+    char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.10129"></a><span id="l3.10129" class="difflineplus">+    m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;onlineDirSeparator);</span>
<a href="#l3.10130"></a><span id="l3.10130" class="difflineplus">+    pattern.Append(onlineDirSeparator);</span>
<a href="#l3.10131"></a><span id="l3.10131" class="difflineplus">+    pattern.Append('*');</span>
<a href="#l3.10132"></a><span id="l3.10132" class="difflineplus">+</span>
<a href="#l3.10133"></a><span id="l3.10133" class="difflineplus">+    if (!pattern.IsEmpty()) {</span>
<a href="#l3.10134"></a><span id="l3.10134">       List(pattern.get(), false);</span>
<a href="#l3.10135"></a><span id="l3.10135">     }</span>
<a href="#l3.10136"></a><span id="l3.10136">     m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.10137"></a><span id="l3.10137"> </span>
<a href="#l3.10138"></a><span id="l3.10138">     // this should be a short list so perform a sequential search for the</span>
<a href="#l3.10139"></a><span id="l3.10139">     // longest name mailbox.  Deleting the longest first will hopefully</span>
<a href="#l3.10140"></a><span id="l3.10140" class="difflineminus">-        // prevent the server from having problems about deleting parents</span>
<a href="#l3.10141"></a><span id="l3.10141" class="difflineminus">-        // ** jt - why? I don't understand this.</span>
<a href="#l3.10142"></a><span id="l3.10142" class="difflineplus">+    // prevent the server from having problems about deleting parents</span>
<a href="#l3.10143"></a><span id="l3.10143" class="difflineplus">+    // ** jt - why? I don't understand this.</span>
<a href="#l3.10144"></a><span id="l3.10144">     size_t numberToDelete = m_deletableChildren-&gt;Length();</span>
<a href="#l3.10145"></a><span id="l3.10145">     size_t outerIndex, innerIndex;</span>
<a href="#l3.10146"></a><span id="l3.10146"> </span>
<a href="#l3.10147"></a><span id="l3.10147" class="difflineminus">-    // intelligently decide if myself(either plain format or following the dir-separator)</span>
<a href="#l3.10148"></a><span id="l3.10148" class="difflineminus">-    // is in the sub-folder list</span>
<a href="#l3.10149"></a><span id="l3.10149" class="difflineminus">-    bool folderInSubfolderList = false; // For Performance</span>
<a href="#l3.10150"></a><span id="l3.10150" class="difflineplus">+    // intelligently decide if myself(either plain format or following the</span>
<a href="#l3.10151"></a><span id="l3.10151" class="difflineplus">+    // dir-separator) is in the sub-folder list</span>
<a href="#l3.10152"></a><span id="l3.10152" class="difflineplus">+    bool folderInSubfolderList = false;  // For Performance</span>
<a href="#l3.10153"></a><span id="l3.10153">     char *selectedMailboxDir = nullptr;</span>
<a href="#l3.10154"></a><span id="l3.10154">     {</span>
<a href="#l3.10155"></a><span id="l3.10155" class="difflineminus">-        int32_t length = strlen(selectedMailbox);</span>
<a href="#l3.10156"></a><span id="l3.10156" class="difflineminus">-        selectedMailboxDir = (char *)PR_MALLOC(length+2);</span>
<a href="#l3.10157"></a><span id="l3.10157" class="difflineminus">-        if( selectedMailboxDir )    // only do the intelligent test if there is enough memory</span>
<a href="#l3.10158"></a><span id="l3.10158" class="difflineminus">-        {</span>
<a href="#l3.10159"></a><span id="l3.10159" class="difflineminus">-            strcpy(selectedMailboxDir, selectedMailbox);</span>
<a href="#l3.10160"></a><span id="l3.10160" class="difflineminus">-            selectedMailboxDir[length] = onlineDirSeparator;</span>
<a href="#l3.10161"></a><span id="l3.10161" class="difflineminus">-            selectedMailboxDir[length+1] = '\0';</span>
<a href="#l3.10162"></a><span id="l3.10162" class="difflineminus">-            size_t i;</span>
<a href="#l3.10163"></a><span id="l3.10163" class="difflineminus">-            for( i=0; i&lt;numberToDelete &amp;&amp; !folderInSubfolderList; i++ )</span>
<a href="#l3.10164"></a><span id="l3.10164" class="difflineminus">-            {</span>
<a href="#l3.10165"></a><span id="l3.10165" class="difflineminus">-                char *currentName = m_deletableChildren-&gt;ElementAt(i);</span>
<a href="#l3.10166"></a><span id="l3.10166" class="difflineminus">-                if( !strcmp(currentName, selectedMailbox) || !strcmp(currentName, selectedMailboxDir) )</span>
<a href="#l3.10167"></a><span id="l3.10167" class="difflineminus">-                    folderInSubfolderList = true;</span>
<a href="#l3.10168"></a><span id="l3.10168" class="difflineminus">-            }</span>
<a href="#l3.10169"></a><span id="l3.10169" class="difflineplus">+      int32_t length = strlen(selectedMailbox);</span>
<a href="#l3.10170"></a><span id="l3.10170" class="difflineplus">+      selectedMailboxDir = (char *)PR_MALLOC(length + 2);</span>
<a href="#l3.10171"></a><span id="l3.10171" class="difflineplus">+      if (selectedMailboxDir)  // only do the intelligent test if there is</span>
<a href="#l3.10172"></a><span id="l3.10172" class="difflineplus">+                               // enough memory</span>
<a href="#l3.10173"></a><span id="l3.10173" class="difflineplus">+      {</span>
<a href="#l3.10174"></a><span id="l3.10174" class="difflineplus">+        strcpy(selectedMailboxDir, selectedMailbox);</span>
<a href="#l3.10175"></a><span id="l3.10175" class="difflineplus">+        selectedMailboxDir[length] = onlineDirSeparator;</span>
<a href="#l3.10176"></a><span id="l3.10176" class="difflineplus">+        selectedMailboxDir[length + 1] = '\0';</span>
<a href="#l3.10177"></a><span id="l3.10177" class="difflineplus">+        size_t i;</span>
<a href="#l3.10178"></a><span id="l3.10178" class="difflineplus">+        for (i = 0; i &lt; numberToDelete &amp;&amp; !folderInSubfolderList; i++) {</span>
<a href="#l3.10179"></a><span id="l3.10179" class="difflineplus">+          char *currentName = m_deletableChildren-&gt;ElementAt(i);</span>
<a href="#l3.10180"></a><span id="l3.10180" class="difflineplus">+          if (!strcmp(currentName, selectedMailbox) ||</span>
<a href="#l3.10181"></a><span id="l3.10181" class="difflineplus">+              !strcmp(currentName, selectedMailboxDir))</span>
<a href="#l3.10182"></a><span id="l3.10182" class="difflineplus">+            folderInSubfolderList = true;</span>
<a href="#l3.10183"></a><span id="l3.10183">         }</span>
<a href="#l3.10184"></a><span id="l3.10184" class="difflineplus">+      }</span>
<a href="#l3.10185"></a><span id="l3.10185">     }</span>
<a href="#l3.10186"></a><span id="l3.10186"> </span>
<a href="#l3.10187"></a><span id="l3.10187">     deleteSucceeded = GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l3.10188"></a><span id="l3.10188" class="difflineminus">-    for (outerIndex = 0;</span>
<a href="#l3.10189"></a><span id="l3.10189" class="difflineminus">-         (outerIndex &lt; numberToDelete) &amp;&amp; deleteSucceeded;</span>
<a href="#l3.10190"></a><span id="l3.10190" class="difflineminus">-         outerIndex++)</span>
<a href="#l3.10191"></a><span id="l3.10191" class="difflineminus">-    {</span>
<a href="#l3.10192"></a><span id="l3.10192" class="difflineminus">-        char* longestName = nullptr;</span>
<a href="#l3.10193"></a><span id="l3.10193" class="difflineminus">-        size_t longestIndex = 0; // fix bogus warning by initializing</span>
<a href="#l3.10194"></a><span id="l3.10194" class="difflineminus">-        for (innerIndex = 0;</span>
<a href="#l3.10195"></a><span id="l3.10195" class="difflineminus">-             innerIndex &lt; m_deletableChildren-&gt;Length();</span>
<a href="#l3.10196"></a><span id="l3.10196" class="difflineminus">-             innerIndex++)</span>
<a href="#l3.10197"></a><span id="l3.10197" class="difflineminus">-        {</span>
<a href="#l3.10198"></a><span id="l3.10198" class="difflineminus">-            char *currentName = m_deletableChildren-&gt;ElementAt(innerIndex);</span>
<a href="#l3.10199"></a><span id="l3.10199" class="difflineminus">-            if (!longestName || strlen(longestName) &lt; strlen(currentName))</span>
<a href="#l3.10200"></a><span id="l3.10200" class="difflineminus">-            {</span>
<a href="#l3.10201"></a><span id="l3.10201" class="difflineminus">-                longestName = currentName;</span>
<a href="#l3.10202"></a><span id="l3.10202" class="difflineminus">-                longestIndex = innerIndex;</span>
<a href="#l3.10203"></a><span id="l3.10203" class="difflineminus">-            }</span>
<a href="#l3.10204"></a><span id="l3.10204" class="difflineplus">+    for (outerIndex = 0; (outerIndex &lt; numberToDelete) &amp;&amp; deleteSucceeded;</span>
<a href="#l3.10205"></a><span id="l3.10205" class="difflineplus">+         outerIndex++) {</span>
<a href="#l3.10206"></a><span id="l3.10206" class="difflineplus">+      char *longestName = nullptr;</span>
<a href="#l3.10207"></a><span id="l3.10207" class="difflineplus">+      size_t longestIndex = 0;  // fix bogus warning by initializing</span>
<a href="#l3.10208"></a><span id="l3.10208" class="difflineplus">+      for (innerIndex = 0; innerIndex &lt; m_deletableChildren-&gt;Length();</span>
<a href="#l3.10209"></a><span id="l3.10209" class="difflineplus">+           innerIndex++) {</span>
<a href="#l3.10210"></a><span id="l3.10210" class="difflineplus">+        char *currentName = m_deletableChildren-&gt;ElementAt(innerIndex);</span>
<a href="#l3.10211"></a><span id="l3.10211" class="difflineplus">+        if (!longestName || strlen(longestName) &lt; strlen(currentName)) {</span>
<a href="#l3.10212"></a><span id="l3.10212" class="difflineplus">+          longestName = currentName;</span>
<a href="#l3.10213"></a><span id="l3.10213" class="difflineplus">+          longestIndex = innerIndex;</span>
<a href="#l3.10214"></a><span id="l3.10214">         }</span>
<a href="#l3.10215"></a><span id="l3.10215" class="difflineminus">-        // the imap parser has already converted to a non UTF7 string in</span>
<a href="#l3.10216"></a><span id="l3.10216" class="difflineminus">-        // the canonical format so convert it back</span>
<a href="#l3.10217"></a><span id="l3.10217" class="difflineminus">-        if (longestName)</span>
<a href="#l3.10218"></a><span id="l3.10218" class="difflineminus">-        {</span>
<a href="#l3.10219"></a><span id="l3.10219" class="difflineminus">-            char *serverName = nullptr;</span>
<a href="#l3.10220"></a><span id="l3.10220" class="difflineminus">-</span>
<a href="#l3.10221"></a><span id="l3.10221" class="difflineminus">-            m_deletableChildren-&gt;RemoveElementAt(longestIndex);</span>
<a href="#l3.10222"></a><span id="l3.10222" class="difflineminus">-            m_runningUrl-&gt;AllocateServerPath(longestName,</span>
<a href="#l3.10223"></a><span id="l3.10223" class="difflineminus">-                                             onlineDirSeparator,</span>
<a href="#l3.10224"></a><span id="l3.10224" class="difflineminus">-                                             &amp;serverName);</span>
<a href="#l3.10225"></a><span id="l3.10225" class="difflineminus">-            PR_FREEIF(longestName);</span>
<a href="#l3.10226"></a><span id="l3.10226" class="difflineminus">-            longestName = serverName;</span>
<a href="#l3.10227"></a><span id="l3.10227" class="difflineminus">-        }</span>
<a href="#l3.10228"></a><span id="l3.10228" class="difflineplus">+      }</span>
<a href="#l3.10229"></a><span id="l3.10229" class="difflineplus">+      // the imap parser has already converted to a non UTF7 string in</span>
<a href="#l3.10230"></a><span id="l3.10230" class="difflineplus">+      // the canonical format so convert it back</span>
<a href="#l3.10231"></a><span id="l3.10231" class="difflineplus">+      if (longestName) {</span>
<a href="#l3.10232"></a><span id="l3.10232" class="difflineplus">+        char *serverName = nullptr;</span>
<a href="#l3.10233"></a><span id="l3.10233" class="difflineplus">+</span>
<a href="#l3.10234"></a><span id="l3.10234" class="difflineplus">+        m_deletableChildren-&gt;RemoveElementAt(longestIndex);</span>
<a href="#l3.10235"></a><span id="l3.10235" class="difflineplus">+        m_runningUrl-&gt;AllocateServerPath(longestName, onlineDirSeparator,</span>
<a href="#l3.10236"></a><span id="l3.10236" class="difflineplus">+                                         &amp;serverName);</span>
<a href="#l3.10237"></a><span id="l3.10237" class="difflineplus">+        PR_FREEIF(longestName);</span>
<a href="#l3.10238"></a><span id="l3.10238" class="difflineplus">+        longestName = serverName;</span>
<a href="#l3.10239"></a><span id="l3.10239" class="difflineplus">+      }</span>
<a href="#l3.10240"></a><span id="l3.10240"> </span>
<a href="#l3.10241"></a><span id="l3.10241">       // some imap servers include the selectedMailbox in the list of</span>
<a href="#l3.10242"></a><span id="l3.10242">       // subfolders of the selectedMailbox.  Check for this so we don't</span>
<a href="#l3.10243"></a><span id="l3.10243" class="difflineminus">-            // delete the selectedMailbox (usually the trash and doing an</span>
<a href="#l3.10244"></a><span id="l3.10244" class="difflineminus">-            // empty trash)</span>
<a href="#l3.10245"></a><span id="l3.10245" class="difflineplus">+      // delete the selectedMailbox (usually the trash and doing an</span>
<a href="#l3.10246"></a><span id="l3.10246" class="difflineplus">+      // empty trash)</span>
<a href="#l3.10247"></a><span id="l3.10247">       // The Cyrus imap server ignores the &quot;INBOX.Trash&quot; constraining</span>
<a href="#l3.10248"></a><span id="l3.10248" class="difflineminus">-            // string passed to the list command.  Be defensive and make sure</span>
<a href="#l3.10249"></a><span id="l3.10249" class="difflineminus">-            // we only delete children of the trash</span>
<a href="#l3.10250"></a><span id="l3.10250" class="difflineminus">-      if (longestName &amp;&amp;</span>
<a href="#l3.10251"></a><span id="l3.10251" class="difflineminus">-        strcmp(selectedMailbox, longestName) &amp;&amp;</span>
<a href="#l3.10252"></a><span id="l3.10252" class="difflineminus">-        !strncmp(selectedMailbox, longestName, strlen(selectedMailbox)))</span>
<a href="#l3.10253"></a><span id="l3.10253" class="difflineminus">-      {</span>
<a href="#l3.10254"></a><span id="l3.10254" class="difflineminus">-          if( selectedMailboxDir &amp;&amp; !strcmp(selectedMailboxDir, longestName) )  // just myself</span>
<a href="#l3.10255"></a><span id="l3.10255" class="difflineminus">-          {</span>
<a href="#l3.10256"></a><span id="l3.10256" class="difflineminus">-              if( aDeleteSelf )</span>
<a href="#l3.10257"></a><span id="l3.10257" class="difflineminus">-              {</span>
<a href="#l3.10258"></a><span id="l3.10258" class="difflineminus">-                  bool deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l3.10259"></a><span id="l3.10259" class="difflineminus">-                  if (deleted)</span>
<a href="#l3.10260"></a><span id="l3.10260" class="difflineminus">-                      FolderDeleted(longestName);</span>
<a href="#l3.10261"></a><span id="l3.10261" class="difflineminus">-                  folderDeleted = deleted;</span>
<a href="#l3.10262"></a><span id="l3.10262" class="difflineminus">-                  deleteSucceeded = deleted;</span>
<a href="#l3.10263"></a><span id="l3.10263" class="difflineminus">-              }</span>
<a href="#l3.10264"></a><span id="l3.10264" class="difflineplus">+      // string passed to the list command.  Be defensive and make sure</span>
<a href="#l3.10265"></a><span id="l3.10265" class="difflineplus">+      // we only delete children of the trash</span>
<a href="#l3.10266"></a><span id="l3.10266" class="difflineplus">+      if (longestName &amp;&amp; strcmp(selectedMailbox, longestName) &amp;&amp;</span>
<a href="#l3.10267"></a><span id="l3.10267" class="difflineplus">+          !strncmp(selectedMailbox, longestName, strlen(selectedMailbox))) {</span>
<a href="#l3.10268"></a><span id="l3.10268" class="difflineplus">+        if (selectedMailboxDir &amp;&amp;</span>
<a href="#l3.10269"></a><span id="l3.10269" class="difflineplus">+            !strcmp(selectedMailboxDir, longestName))  // just myself</span>
<a href="#l3.10270"></a><span id="l3.10270" class="difflineplus">+        {</span>
<a href="#l3.10271"></a><span id="l3.10271" class="difflineplus">+          if (aDeleteSelf) {</span>
<a href="#l3.10272"></a><span id="l3.10272" class="difflineplus">+            bool deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l3.10273"></a><span id="l3.10273" class="difflineplus">+            if (deleted) FolderDeleted(longestName);</span>
<a href="#l3.10274"></a><span id="l3.10274" class="difflineplus">+            folderDeleted = deleted;</span>
<a href="#l3.10275"></a><span id="l3.10275" class="difflineplus">+            deleteSucceeded = deleted;</span>
<a href="#l3.10276"></a><span id="l3.10276">           }</span>
<a href="#l3.10277"></a><span id="l3.10277" class="difflineminus">-          else</span>
<a href="#l3.10278"></a><span id="l3.10278" class="difflineplus">+        } else {</span>
<a href="#l3.10279"></a><span id="l3.10279" class="difflineplus">+          if (m_imapServerSink)</span>
<a href="#l3.10280"></a><span id="l3.10280" class="difflineplus">+            m_imapServerSink-&gt;ResetServerConnection(</span>
<a href="#l3.10281"></a><span id="l3.10281" class="difflineplus">+                nsDependentCString(longestName));</span>
<a href="#l3.10282"></a><span id="l3.10282" class="difflineplus">+          bool deleted = false;</span>
<a href="#l3.10283"></a><span id="l3.10283" class="difflineplus">+          if (folderInSubfolderList)  // for performance</span>
<a href="#l3.10284"></a><span id="l3.10284">           {</span>
<a href="#l3.10285"></a><span id="l3.10285" class="difflineminus">-              if (m_imapServerSink)</span>
<a href="#l3.10286"></a><span id="l3.10286" class="difflineminus">-                  m_imapServerSink-&gt;ResetServerConnection(nsDependentCString(longestName));</span>
<a href="#l3.10287"></a><span id="l3.10287" class="difflineminus">-              bool deleted = false;</span>
<a href="#l3.10288"></a><span id="l3.10288" class="difflineminus">-              if( folderInSubfolderList )  // for performance</span>
<a href="#l3.10289"></a><span id="l3.10289" class="difflineminus">-              {</span>
<a href="#l3.10290"></a><span id="l3.10290" class="difflineminus">-                  nsTArray&lt;char*&gt; *pDeletableChildren = m_deletableChildren;</span>
<a href="#l3.10291"></a><span id="l3.10291" class="difflineminus">-                  m_deletableChildren = nullptr;</span>
<a href="#l3.10292"></a><span id="l3.10292" class="difflineminus">-                  bool folderDeleted = true;</span>
<a href="#l3.10293"></a><span id="l3.10293" class="difflineminus">-                  deleted = DeleteSubFolders(longestName, folderDeleted);</span>
<a href="#l3.10294"></a><span id="l3.10294" class="difflineminus">-                  // longestName may have subfolder list including itself</span>
<a href="#l3.10295"></a><span id="l3.10295" class="difflineminus">-                  if( !folderDeleted )</span>
<a href="#l3.10296"></a><span id="l3.10296" class="difflineminus">-                  {</span>
<a href="#l3.10297"></a><span id="l3.10297" class="difflineminus">-                      if (deleted)</span>
<a href="#l3.10298"></a><span id="l3.10298" class="difflineminus">-                      deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l3.10299"></a><span id="l3.10299" class="difflineminus">-                      if (deleted)</span>
<a href="#l3.10300"></a><span id="l3.10300" class="difflineminus">-                          FolderDeleted(longestName);</span>
<a href="#l3.10301"></a><span id="l3.10301" class="difflineminus">-                  }</span>
<a href="#l3.10302"></a><span id="l3.10302" class="difflineminus">-                  m_deletableChildren = pDeletableChildren;</span>
<a href="#l3.10303"></a><span id="l3.10303" class="difflineminus">-              }</span>
<a href="#l3.10304"></a><span id="l3.10304" class="difflineminus">-              else</span>
<a href="#l3.10305"></a><span id="l3.10305" class="difflineminus">-              {</span>
<a href="#l3.10306"></a><span id="l3.10306" class="difflineminus">-                  deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l3.10307"></a><span id="l3.10307" class="difflineminus">-                  if (deleted)</span>
<a href="#l3.10308"></a><span id="l3.10308" class="difflineminus">-                      FolderDeleted(longestName);</span>
<a href="#l3.10309"></a><span id="l3.10309" class="difflineminus">-              }</span>
<a href="#l3.10310"></a><span id="l3.10310" class="difflineminus">-              deleteSucceeded = deleted;</span>
<a href="#l3.10311"></a><span id="l3.10311" class="difflineplus">+            nsTArray&lt;char *&gt; *pDeletableChildren = m_deletableChildren;</span>
<a href="#l3.10312"></a><span id="l3.10312" class="difflineplus">+            m_deletableChildren = nullptr;</span>
<a href="#l3.10313"></a><span id="l3.10313" class="difflineplus">+            bool folderDeleted = true;</span>
<a href="#l3.10314"></a><span id="l3.10314" class="difflineplus">+            deleted = DeleteSubFolders(longestName, folderDeleted);</span>
<a href="#l3.10315"></a><span id="l3.10315" class="difflineplus">+            // longestName may have subfolder list including itself</span>
<a href="#l3.10316"></a><span id="l3.10316" class="difflineplus">+            if (!folderDeleted) {</span>
<a href="#l3.10317"></a><span id="l3.10317" class="difflineplus">+              if (deleted)</span>
<a href="#l3.10318"></a><span id="l3.10318" class="difflineplus">+                deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l3.10319"></a><span id="l3.10319" class="difflineplus">+              if (deleted) FolderDeleted(longestName);</span>
<a href="#l3.10320"></a><span id="l3.10320" class="difflineplus">+            }</span>
<a href="#l3.10321"></a><span id="l3.10321" class="difflineplus">+            m_deletableChildren = pDeletableChildren;</span>
<a href="#l3.10322"></a><span id="l3.10322" class="difflineplus">+          } else {</span>
<a href="#l3.10323"></a><span id="l3.10323" class="difflineplus">+            deleted = DeleteMailboxRespectingSubscriptions(longestName);</span>
<a href="#l3.10324"></a><span id="l3.10324" class="difflineplus">+            if (deleted) FolderDeleted(longestName);</span>
<a href="#l3.10325"></a><span id="l3.10325">           }</span>
<a href="#l3.10326"></a><span id="l3.10326" class="difflineplus">+          deleteSucceeded = deleted;</span>
<a href="#l3.10327"></a><span id="l3.10327" class="difflineplus">+        }</span>
<a href="#l3.10328"></a><span id="l3.10328">       }</span>
<a href="#l3.10329"></a><span id="l3.10329">       PR_FREEIF(longestName);</span>
<a href="#l3.10330"></a><span id="l3.10330">     }</span>
<a href="#l3.10331"></a><span id="l3.10331"> </span>
<a href="#l3.10332"></a><span id="l3.10332">     aDeleteSelf = folderDeleted;  // feedback if myself is deleted</span>
<a href="#l3.10333"></a><span id="l3.10333">     PR_Free(selectedMailboxDir);</span>
<a href="#l3.10334"></a><span id="l3.10334"> </span>
<a href="#l3.10335"></a><span id="l3.10335">     delete m_deletableChildren;</span>
<a href="#l3.10336"></a><span id="l3.10336">     m_deletableChildren = nullptr;</span>
<a href="#l3.10337"></a><span id="l3.10337">   }</span>
<a href="#l3.10338"></a><span id="l3.10338">   return deleteSucceeded;</span>
<a href="#l3.10339"></a><span id="l3.10339"> }</span>
<a href="#l3.10340"></a><span id="l3.10340"> </span>
<a href="#l3.10341"></a><span id="l3.10341" class="difflineminus">-void nsImapProtocol::FolderDeleted(const char *mailboxName)</span>
<a href="#l3.10342"></a><span id="l3.10342" class="difflineminus">-{</span>
<a href="#l3.10343"></a><span id="l3.10343" class="difflineminus">-    char onlineDelimiter = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.10344"></a><span id="l3.10344" class="difflineminus">-    nsCString orphanedMailboxName;</span>
<a href="#l3.10345"></a><span id="l3.10345" class="difflineminus">-</span>
<a href="#l3.10346"></a><span id="l3.10346" class="difflineminus">-    if (mailboxName)</span>
<a href="#l3.10347"></a><span id="l3.10347" class="difflineminus">-    {</span>
<a href="#l3.10348"></a><span id="l3.10348" class="difflineminus">-        m_runningUrl-&gt;AllocateCanonicalPath(mailboxName, onlineDelimiter,</span>
<a href="#l3.10349"></a><span id="l3.10349" class="difflineminus">-                                            getter_Copies(orphanedMailboxName));</span>
<a href="#l3.10350"></a><span id="l3.10350" class="difflineplus">+void nsImapProtocol::FolderDeleted(const char *mailboxName) {</span>
<a href="#l3.10351"></a><span id="l3.10351" class="difflineplus">+  char onlineDelimiter = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.10352"></a><span id="l3.10352" class="difflineplus">+  nsCString orphanedMailboxName;</span>
<a href="#l3.10353"></a><span id="l3.10353" class="difflineplus">+</span>
<a href="#l3.10354"></a><span id="l3.10354" class="difflineplus">+  if (mailboxName) {</span>
<a href="#l3.10355"></a><span id="l3.10355" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(mailboxName, onlineDelimiter,</span>
<a href="#l3.10356"></a><span id="l3.10356" class="difflineplus">+                                        getter_Copies(orphanedMailboxName));</span>
<a href="#l3.10357"></a><span id="l3.10357">     if (m_imapServerSink)</span>
<a href="#l3.10358"></a><span id="l3.10358">       m_imapServerSink-&gt;OnlineFolderDelete(orphanedMailboxName);</span>
<a href="#l3.10359"></a><span id="l3.10359" class="difflineminus">-    }</span>
<a href="#l3.10360"></a><span id="l3.10360" class="difflineminus">-}</span>
<a href="#l3.10361"></a><span id="l3.10361" class="difflineminus">-</span>
<a href="#l3.10362"></a><span id="l3.10362" class="difflineminus">-void nsImapProtocol::FolderNotCreated(const char *folderName)</span>
<a href="#l3.10363"></a><span id="l3.10363" class="difflineminus">-{</span>
<a href="#l3.10364"></a><span id="l3.10364" class="difflineminus">-    if (folderName &amp;&amp; m_imapServerSink)</span>
<a href="#l3.10365"></a><span id="l3.10365" class="difflineminus">-        m_imapServerSink-&gt;OnlineFolderCreateFailed(nsDependentCString(folderName));</span>
<a href="#l3.10366"></a><span id="l3.10366" class="difflineminus">-}</span>
<a href="#l3.10367"></a><span id="l3.10367" class="difflineminus">-</span>
<a href="#l3.10368"></a><span id="l3.10368" class="difflineminus">-void nsImapProtocol::FolderRenamed(const char *oldName,</span>
<a href="#l3.10369"></a><span id="l3.10369" class="difflineminus">-                                   const char *newName)</span>
<a href="#l3.10370"></a><span id="l3.10370" class="difflineminus">-{</span>
<a href="#l3.10371"></a><span id="l3.10371" class="difflineplus">+  }</span>
<a href="#l3.10372"></a><span id="l3.10372" class="difflineplus">+}</span>
<a href="#l3.10373"></a><span id="l3.10373" class="difflineplus">+</span>
<a href="#l3.10374"></a><span id="l3.10374" class="difflineplus">+void nsImapProtocol::FolderNotCreated(const char *folderName) {</span>
<a href="#l3.10375"></a><span id="l3.10375" class="difflineplus">+  if (folderName &amp;&amp; m_imapServerSink)</span>
<a href="#l3.10376"></a><span id="l3.10376" class="difflineplus">+    m_imapServerSink-&gt;OnlineFolderCreateFailed(nsDependentCString(folderName));</span>
<a href="#l3.10377"></a><span id="l3.10377" class="difflineplus">+}</span>
<a href="#l3.10378"></a><span id="l3.10378" class="difflineplus">+</span>
<a href="#l3.10379"></a><span id="l3.10379" class="difflineplus">+void nsImapProtocol::FolderRenamed(const char *oldName, const char *newName) {</span>
<a href="#l3.10380"></a><span id="l3.10380">   char onlineDelimiter = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.10381"></a><span id="l3.10381"> </span>
<a href="#l3.10382"></a><span id="l3.10382">   if ((m_hierarchyNameState == kNoOperationInProgress) ||</span>
<a href="#l3.10383"></a><span id="l3.10383" class="difflineminus">-    (m_hierarchyNameState == kListingForInfoAndDiscovery))</span>
<a href="#l3.10384"></a><span id="l3.10384" class="difflineplus">+      (m_hierarchyNameState == kListingForInfoAndDiscovery))</span>
<a href="#l3.10385"></a><span id="l3.10385"> </span>
<a href="#l3.10386"></a><span id="l3.10386">   {</span>
<a href="#l3.10387"></a><span id="l3.10387">     nsCString canonicalOldName, canonicalNewName;</span>
<a href="#l3.10388"></a><span id="l3.10388" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(oldName,</span>
<a href="#l3.10389"></a><span id="l3.10389" class="difflineminus">-      onlineDelimiter,</span>
<a href="#l3.10390"></a><span id="l3.10390" class="difflineminus">-      getter_Copies(canonicalOldName));</span>
<a href="#l3.10391"></a><span id="l3.10391" class="difflineminus">-    m_runningUrl-&gt;AllocateCanonicalPath(newName,</span>
<a href="#l3.10392"></a><span id="l3.10392" class="difflineminus">-      onlineDelimiter,</span>
<a href="#l3.10393"></a><span id="l3.10393" class="difflineminus">-      getter_Copies(canonicalNewName));</span>
<a href="#l3.10394"></a><span id="l3.10394" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(oldName, onlineDelimiter,</span>
<a href="#l3.10395"></a><span id="l3.10395" class="difflineplus">+                                        getter_Copies(canonicalOldName));</span>
<a href="#l3.10396"></a><span id="l3.10396" class="difflineplus">+    m_runningUrl-&gt;AllocateCanonicalPath(newName, onlineDelimiter,</span>
<a href="#l3.10397"></a><span id="l3.10397" class="difflineplus">+                                        getter_Copies(canonicalNewName));</span>
<a href="#l3.10398"></a><span id="l3.10398">     AutoProxyReleaseMsgWindow msgWindow;</span>
<a href="#l3.10399"></a><span id="l3.10399">     GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.10400"></a><span id="l3.10400" class="difflineminus">-    m_imapServerSink-&gt;OnlineFolderRename(msgWindow, canonicalOldName, canonicalNewName);</span>
<a href="#l3.10401"></a><span id="l3.10401" class="difflineminus">-  }</span>
<a href="#l3.10402"></a><span id="l3.10402" class="difflineminus">-}</span>
<a href="#l3.10403"></a><span id="l3.10403" class="difflineminus">-</span>
<a href="#l3.10404"></a><span id="l3.10404" class="difflineminus">-void nsImapProtocol::OnDeleteFolder(const char * sourceMailbox)</span>
<a href="#l3.10405"></a><span id="l3.10405" class="difflineminus">-{</span>
<a href="#l3.10406"></a><span id="l3.10406" class="difflineplus">+    m_imapServerSink-&gt;OnlineFolderRename(msgWindow, canonicalOldName,</span>
<a href="#l3.10407"></a><span id="l3.10407" class="difflineplus">+                                         canonicalNewName);</span>
<a href="#l3.10408"></a><span id="l3.10408" class="difflineplus">+  }</span>
<a href="#l3.10409"></a><span id="l3.10409" class="difflineplus">+}</span>
<a href="#l3.10410"></a><span id="l3.10410" class="difflineplus">+</span>
<a href="#l3.10411"></a><span id="l3.10411" class="difflineplus">+void nsImapProtocol::OnDeleteFolder(const char *sourceMailbox) {</span>
<a href="#l3.10412"></a><span id="l3.10412">   // intelligently delete the folder</span>
<a href="#l3.10413"></a><span id="l3.10413">   bool folderDeleted = true;</span>
<a href="#l3.10414"></a><span id="l3.10414">   bool deleted = DeleteSubFolders(sourceMailbox, folderDeleted);</span>
<a href="#l3.10415"></a><span id="l3.10415" class="difflineminus">-  if( !folderDeleted )</span>
<a href="#l3.10416"></a><span id="l3.10416" class="difflineminus">-  {</span>
<a href="#l3.10417"></a><span id="l3.10417" class="difflineminus">-    if (deleted)</span>
<a href="#l3.10418"></a><span id="l3.10418" class="difflineminus">-      deleted = DeleteMailboxRespectingSubscriptions(sourceMailbox);</span>
<a href="#l3.10419"></a><span id="l3.10419" class="difflineminus">-    if (deleted)</span>
<a href="#l3.10420"></a><span id="l3.10420" class="difflineminus">-      FolderDeleted(sourceMailbox);</span>
<a href="#l3.10421"></a><span id="l3.10421" class="difflineminus">-  }</span>
<a href="#l3.10422"></a><span id="l3.10422" class="difflineminus">-}</span>
<a href="#l3.10423"></a><span id="l3.10423" class="difflineminus">-</span>
<a href="#l3.10424"></a><span id="l3.10424" class="difflineminus">-void nsImapProtocol::RemoveMsgsAndExpunge()</span>
<a href="#l3.10425"></a><span id="l3.10425" class="difflineminus">-{</span>
<a href="#l3.10426"></a><span id="l3.10426" class="difflineplus">+  if (!folderDeleted) {</span>
<a href="#l3.10427"></a><span id="l3.10427" class="difflineplus">+    if (deleted) deleted = DeleteMailboxRespectingSubscriptions(sourceMailbox);</span>
<a href="#l3.10428"></a><span id="l3.10428" class="difflineplus">+    if (deleted) FolderDeleted(sourceMailbox);</span>
<a href="#l3.10429"></a><span id="l3.10429" class="difflineplus">+  }</span>
<a href="#l3.10430"></a><span id="l3.10430" class="difflineplus">+}</span>
<a href="#l3.10431"></a><span id="l3.10431" class="difflineplus">+</span>
<a href="#l3.10432"></a><span id="l3.10432" class="difflineplus">+void nsImapProtocol::RemoveMsgsAndExpunge() {</span>
<a href="#l3.10433"></a><span id="l3.10433">   uint32_t numberOfMessages = GetServerStateParser().NumberOfMessages();</span>
<a href="#l3.10434"></a><span id="l3.10434" class="difflineminus">-  if (numberOfMessages)</span>
<a href="#l3.10435"></a><span id="l3.10435" class="difflineminus">-  {</span>
<a href="#l3.10436"></a><span id="l3.10436" class="difflineplus">+  if (numberOfMessages) {</span>
<a href="#l3.10437"></a><span id="l3.10437">     // Remove all msgs and expunge the folder (ie, compact it).</span>
<a href="#l3.10438"></a><span id="l3.10438" class="difflineminus">-    Store(NS_LITERAL_CSTRING(&quot;1:*&quot;), &quot;+FLAGS.SILENT (\\Deleted)&quot;, false);  // use sequence #'s</span>
<a href="#l3.10439"></a><span id="l3.10439" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.10440"></a><span id="l3.10440" class="difflineminus">-      Expunge();</span>
<a href="#l3.10441"></a><span id="l3.10441" class="difflineminus">-  }</span>
<a href="#l3.10442"></a><span id="l3.10442" class="difflineminus">-}</span>
<a href="#l3.10443"></a><span id="l3.10443" class="difflineminus">-</span>
<a href="#l3.10444"></a><span id="l3.10444" class="difflineminus">-void nsImapProtocol::DeleteFolderAndMsgs(const char * sourceMailbox)</span>
<a href="#l3.10445"></a><span id="l3.10445" class="difflineminus">-{</span>
<a href="#l3.10446"></a><span id="l3.10446" class="difflineplus">+    Store(NS_LITERAL_CSTRING(&quot;1:*&quot;), &quot;+FLAGS.SILENT (\\Deleted)&quot;,</span>
<a href="#l3.10447"></a><span id="l3.10447" class="difflineplus">+          false);  // use sequence #'s</span>
<a href="#l3.10448"></a><span id="l3.10448" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) Expunge();</span>
<a href="#l3.10449"></a><span id="l3.10449" class="difflineplus">+  }</span>
<a href="#l3.10450"></a><span id="l3.10450" class="difflineplus">+}</span>
<a href="#l3.10451"></a><span id="l3.10451" class="difflineplus">+</span>
<a href="#l3.10452"></a><span id="l3.10452" class="difflineplus">+void nsImapProtocol::DeleteFolderAndMsgs(const char *sourceMailbox) {</span>
<a href="#l3.10453"></a><span id="l3.10453">   RemoveMsgsAndExpunge();</span>
<a href="#l3.10454"></a><span id="l3.10454" class="difflineminus">-  if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.10455"></a><span id="l3.10455" class="difflineminus">-  {</span>
<a href="#l3.10456"></a><span id="l3.10456" class="difflineplus">+  if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.10457"></a><span id="l3.10457">     // All msgs are deleted successfully - let's remove the folder itself.</span>
<a href="#l3.10458"></a><span id="l3.10458">     bool reportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.10459"></a><span id="l3.10459">     GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.10460"></a><span id="l3.10460">     OnDeleteFolder(sourceMailbox);</span>
<a href="#l3.10461"></a><span id="l3.10461">     GetServerStateParser().SetReportingErrors(reportingErrors);</span>
<a href="#l3.10462"></a><span id="l3.10462">   }</span>
<a href="#l3.10463"></a><span id="l3.10463"> }</span>
<a href="#l3.10464"></a><span id="l3.10464"> </span>
<a href="#l3.10465"></a><span id="l3.10465" class="difflineminus">-void nsImapProtocol::OnRenameFolder(const char * sourceMailbox)</span>
<a href="#l3.10466"></a><span id="l3.10466" class="difflineminus">-{</span>
<a href="#l3.10467"></a><span id="l3.10467" class="difflineplus">+void nsImapProtocol::OnRenameFolder(const char *sourceMailbox) {</span>
<a href="#l3.10468"></a><span id="l3.10468">   char *destinationMailbox = OnCreateServerDestinationFolderPathString();</span>
<a href="#l3.10469"></a><span id="l3.10469"> </span>
<a href="#l3.10470"></a><span id="l3.10470" class="difflineminus">-  if (destinationMailbox)</span>
<a href="#l3.10471"></a><span id="l3.10471" class="difflineminus">-  {</span>
<a href="#l3.10472"></a><span id="l3.10472" class="difflineplus">+  if (destinationMailbox) {</span>
<a href="#l3.10473"></a><span id="l3.10473">     bool renamed = RenameHierarchyByHand(sourceMailbox, destinationMailbox);</span>
<a href="#l3.10474"></a><span id="l3.10474" class="difflineminus">-    if (renamed)</span>
<a href="#l3.10475"></a><span id="l3.10475" class="difflineminus">-      FolderRenamed(sourceMailbox, destinationMailbox);</span>
<a href="#l3.10476"></a><span id="l3.10476" class="difflineminus">-</span>
<a href="#l3.10477"></a><span id="l3.10477" class="difflineminus">-    PR_Free( destinationMailbox);</span>
<a href="#l3.10478"></a><span id="l3.10478" class="difflineminus">-  }</span>
<a href="#l3.10479"></a><span id="l3.10479" class="difflineminus">-  else</span>
<a href="#l3.10480"></a><span id="l3.10480" class="difflineplus">+    if (renamed) FolderRenamed(sourceMailbox, destinationMailbox);</span>
<a href="#l3.10481"></a><span id="l3.10481" class="difflineplus">+</span>
<a href="#l3.10482"></a><span id="l3.10482" class="difflineplus">+    PR_Free(destinationMailbox);</span>
<a href="#l3.10483"></a><span id="l3.10483" class="difflineplus">+  } else</span>
<a href="#l3.10484"></a><span id="l3.10484">     HandleMemoryFailure();</span>
<a href="#l3.10485"></a><span id="l3.10485"> }</span>
<a href="#l3.10486"></a><span id="l3.10486"> </span>
<a href="#l3.10487"></a><span id="l3.10487" class="difflineminus">-void nsImapProtocol::OnMoveFolderHierarchy(const char * sourceMailbox)</span>
<a href="#l3.10488"></a><span id="l3.10488" class="difflineminus">-{</span>
<a href="#l3.10489"></a><span id="l3.10489" class="difflineplus">+void nsImapProtocol::OnMoveFolderHierarchy(const char *sourceMailbox) {</span>
<a href="#l3.10490"></a><span id="l3.10490">   char *destinationMailbox = OnCreateServerDestinationFolderPathString();</span>
<a href="#l3.10491"></a><span id="l3.10491"> </span>
<a href="#l3.10492"></a><span id="l3.10492" class="difflineminus">-    if (destinationMailbox)</span>
<a href="#l3.10493"></a><span id="l3.10493" class="difflineminus">-    {</span>
<a href="#l3.10494"></a><span id="l3.10494" class="difflineminus">-        nsCString newBoxName;</span>
<a href="#l3.10495"></a><span id="l3.10495" class="difflineminus">-        newBoxName.Adopt(destinationMailbox);</span>
<a href="#l3.10496"></a><span id="l3.10496" class="difflineminus">-</span>
<a href="#l3.10497"></a><span id="l3.10497" class="difflineminus">-        char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.10498"></a><span id="l3.10498" class="difflineminus">-        m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;onlineDirSeparator);</span>
<a href="#l3.10499"></a><span id="l3.10499" class="difflineminus">-</span>
<a href="#l3.10500"></a><span id="l3.10500" class="difflineminus">-        nsCString oldBoxName(sourceMailbox);</span>
<a href="#l3.10501"></a><span id="l3.10501" class="difflineminus">-        int32_t leafStart = oldBoxName.RFindChar(onlineDirSeparator);</span>
<a href="#l3.10502"></a><span id="l3.10502" class="difflineminus">-        nsCString leafName;</span>
<a href="#l3.10503"></a><span id="l3.10503" class="difflineminus">-</span>
<a href="#l3.10504"></a><span id="l3.10504" class="difflineminus">-        if (-1 == leafStart)</span>
<a href="#l3.10505"></a><span id="l3.10505" class="difflineminus">-            leafName = oldBoxName;  // this is a root level box</span>
<a href="#l3.10506"></a><span id="l3.10506" class="difflineminus">-        else</span>
<a href="#l3.10507"></a><span id="l3.10507" class="difflineminus">-            leafName = Substring(oldBoxName, leafStart+1);</span>
<a href="#l3.10508"></a><span id="l3.10508" class="difflineminus">-</span>
<a href="#l3.10509"></a><span id="l3.10509" class="difflineminus">-        if ( !newBoxName.IsEmpty() )</span>
<a href="#l3.10510"></a><span id="l3.10510" class="difflineminus">-             newBoxName.Append(onlineDirSeparator);</span>
<a href="#l3.10511"></a><span id="l3.10511" class="difflineminus">-        newBoxName.Append(leafName);</span>
<a href="#l3.10512"></a><span id="l3.10512" class="difflineminus">-        bool    renamed = RenameHierarchyByHand(sourceMailbox,</span>
<a href="#l3.10513"></a><span id="l3.10513" class="difflineminus">-                                                newBoxName.get());</span>
<a href="#l3.10514"></a><span id="l3.10514" class="difflineminus">-        if (renamed)</span>
<a href="#l3.10515"></a><span id="l3.10515" class="difflineminus">-            FolderRenamed(sourceMailbox, newBoxName.get());</span>
<a href="#l3.10516"></a><span id="l3.10516" class="difflineminus">-    }</span>
<a href="#l3.10517"></a><span id="l3.10517" class="difflineplus">+  if (destinationMailbox) {</span>
<a href="#l3.10518"></a><span id="l3.10518" class="difflineplus">+    nsCString newBoxName;</span>
<a href="#l3.10519"></a><span id="l3.10519" class="difflineplus">+    newBoxName.Adopt(destinationMailbox);</span>
<a href="#l3.10520"></a><span id="l3.10520" class="difflineplus">+</span>
<a href="#l3.10521"></a><span id="l3.10521" class="difflineplus">+    char onlineDirSeparator = kOnlineHierarchySeparatorUnknown;</span>
<a href="#l3.10522"></a><span id="l3.10522" class="difflineplus">+    m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;onlineDirSeparator);</span>
<a href="#l3.10523"></a><span id="l3.10523" class="difflineplus">+</span>
<a href="#l3.10524"></a><span id="l3.10524" class="difflineplus">+    nsCString oldBoxName(sourceMailbox);</span>
<a href="#l3.10525"></a><span id="l3.10525" class="difflineplus">+    int32_t leafStart = oldBoxName.RFindChar(onlineDirSeparator);</span>
<a href="#l3.10526"></a><span id="l3.10526" class="difflineplus">+    nsCString leafName;</span>
<a href="#l3.10527"></a><span id="l3.10527" class="difflineplus">+</span>
<a href="#l3.10528"></a><span id="l3.10528" class="difflineplus">+    if (-1 == leafStart)</span>
<a href="#l3.10529"></a><span id="l3.10529" class="difflineplus">+      leafName = oldBoxName;  // this is a root level box</span>
<a href="#l3.10530"></a><span id="l3.10530">     else</span>
<a href="#l3.10531"></a><span id="l3.10531" class="difflineminus">-      HandleMemoryFailure();</span>
<a href="#l3.10532"></a><span id="l3.10532" class="difflineminus">-}</span>
<a href="#l3.10533"></a><span id="l3.10533" class="difflineminus">-</span>
<a href="#l3.10534"></a><span id="l3.10534" class="difflineminus">-void nsImapProtocol::FindMailboxesIfNecessary()</span>
<a href="#l3.10535"></a><span id="l3.10535" class="difflineminus">-{</span>
<a href="#l3.10536"></a><span id="l3.10536" class="difflineplus">+      leafName = Substring(oldBoxName, leafStart + 1);</span>
<a href="#l3.10537"></a><span id="l3.10537" class="difflineplus">+</span>
<a href="#l3.10538"></a><span id="l3.10538" class="difflineplus">+    if (!newBoxName.IsEmpty()) newBoxName.Append(onlineDirSeparator);</span>
<a href="#l3.10539"></a><span id="l3.10539" class="difflineplus">+    newBoxName.Append(leafName);</span>
<a href="#l3.10540"></a><span id="l3.10540" class="difflineplus">+    bool renamed = RenameHierarchyByHand(sourceMailbox, newBoxName.get());</span>
<a href="#l3.10541"></a><span id="l3.10541" class="difflineplus">+    if (renamed) FolderRenamed(sourceMailbox, newBoxName.get());</span>
<a href="#l3.10542"></a><span id="l3.10542" class="difflineplus">+  } else</span>
<a href="#l3.10543"></a><span id="l3.10543" class="difflineplus">+    HandleMemoryFailure();</span>
<a href="#l3.10544"></a><span id="l3.10544" class="difflineplus">+}</span>
<a href="#l3.10545"></a><span id="l3.10545" class="difflineplus">+</span>
<a href="#l3.10546"></a><span id="l3.10546" class="difflineplus">+void nsImapProtocol::FindMailboxesIfNecessary() {</span>
<a href="#l3.10547"></a><span id="l3.10547">   // biff should not discover mailboxes</span>
<a href="#l3.10548"></a><span id="l3.10548">   bool foundMailboxesAlready = false;</span>
<a href="#l3.10549"></a><span id="l3.10549">   nsImapAction imapAction;</span>
<a href="#l3.10550"></a><span id="l3.10550"> </span>
<a href="#l3.10551"></a><span id="l3.10551">   // need to do this for every connection in order to see folders.</span>
<a href="#l3.10552"></a><span id="l3.10552" class="difflineminus">-  (void) m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.10553"></a><span id="l3.10553" class="difflineminus">-  nsresult rv = m_hostSessionList-&gt;GetHaveWeEverDiscoveredFoldersForHost(GetImapServerKey(), foundMailboxesAlready);</span>
<a href="#l3.10554"></a><span id="l3.10554" class="difflineplus">+  (void)m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.10555"></a><span id="l3.10555" class="difflineplus">+  nsresult rv = m_hostSessionList-&gt;GetHaveWeEverDiscoveredFoldersForHost(</span>
<a href="#l3.10556"></a><span id="l3.10556" class="difflineplus">+      GetImapServerKey(), foundMailboxesAlready);</span>
<a href="#l3.10557"></a><span id="l3.10557">   if (NS_SUCCEEDED(rv) &amp;&amp; !foundMailboxesAlready &amp;&amp;</span>
<a href="#l3.10558"></a><span id="l3.10558">       (imapAction != nsIImapUrl::nsImapBiff) &amp;&amp;</span>
<a href="#l3.10559"></a><span id="l3.10559">       (imapAction != nsIImapUrl::nsImapVerifylogon) &amp;&amp;</span>
<a href="#l3.10560"></a><span id="l3.10560">       (imapAction != nsIImapUrl::nsImapDiscoverAllBoxesUrl) &amp;&amp;</span>
<a href="#l3.10561"></a><span id="l3.10561">       (imapAction != nsIImapUrl::nsImapUpgradeToSubscription) &amp;&amp;</span>
<a href="#l3.10562"></a><span id="l3.10562">       !GetSubscribingNow())</span>
<a href="#l3.10563"></a><span id="l3.10563">     DiscoverMailboxList();</span>
<a href="#l3.10564"></a><span id="l3.10564"> }</span>
<a href="#l3.10565"></a><span id="l3.10565"> </span>
<a href="#l3.10566"></a><span id="l3.10566" class="difflineminus">-void nsImapProtocol::DiscoverAllAndSubscribedBoxes()</span>
<a href="#l3.10567"></a><span id="l3.10567" class="difflineminus">-{</span>
<a href="#l3.10568"></a><span id="l3.10568" class="difflineplus">+void nsImapProtocol::DiscoverAllAndSubscribedBoxes() {</span>
<a href="#l3.10569"></a><span id="l3.10569">   // used for subscribe pane</span>
<a href="#l3.10570"></a><span id="l3.10570">   // iterate through all namespaces</span>
<a href="#l3.10571"></a><span id="l3.10571">   uint32_t count = 0;</span>
<a href="#l3.10572"></a><span id="l3.10572">   m_hostSessionList-&gt;GetNumberOfNamespacesForHost(GetImapServerKey(), count);</span>
<a href="#l3.10573"></a><span id="l3.10573"> </span>
<a href="#l3.10574"></a><span id="l3.10574" class="difflineminus">-  for (uint32_t i = 0; i &lt; count; i++ )</span>
<a href="#l3.10575"></a><span id="l3.10575" class="difflineminus">-  {</span>
<a href="#l3.10576"></a><span id="l3.10576" class="difflineplus">+  for (uint32_t i = 0; i &lt; count; i++) {</span>
<a href="#l3.10577"></a><span id="l3.10577">     nsIMAPNamespace *ns = nullptr;</span>
<a href="#l3.10578"></a><span id="l3.10578"> </span>
<a href="#l3.10579"></a><span id="l3.10579" class="difflineminus">-    m_hostSessionList-&gt;GetNamespaceNumberForHost(GetImapServerKey(), i,</span>
<a href="#l3.10580"></a><span id="l3.10580" class="difflineminus">-      ns);</span>
<a href="#l3.10581"></a><span id="l3.10581" class="difflineminus">-    if (ns &amp;&amp;</span>
<a href="#l3.10582"></a><span id="l3.10582" class="difflineminus">-      gHideOtherUsersFromList ? (ns-&gt;GetType() != kOtherUsersNamespace)</span>
<a href="#l3.10583"></a><span id="l3.10583" class="difflineminus">-      : true)</span>
<a href="#l3.10584"></a><span id="l3.10584" class="difflineminus">-    {</span>
<a href="#l3.10585"></a><span id="l3.10585" class="difflineplus">+    m_hostSessionList-&gt;GetNamespaceNumberForHost(GetImapServerKey(), i, ns);</span>
<a href="#l3.10586"></a><span id="l3.10586" class="difflineplus">+    if (ns &amp;&amp; gHideOtherUsersFromList ? (ns-&gt;GetType() != kOtherUsersNamespace)</span>
<a href="#l3.10587"></a><span id="l3.10587" class="difflineplus">+                                      : true) {</span>
<a href="#l3.10588"></a><span id="l3.10588">       const char *prefix = ns-&gt;GetPrefix();</span>
<a href="#l3.10589"></a><span id="l3.10589" class="difflineminus">-      if (prefix)</span>
<a href="#l3.10590"></a><span id="l3.10590" class="difflineminus">-      {</span>
<a href="#l3.10591"></a><span id="l3.10591" class="difflineplus">+      if (prefix) {</span>
<a href="#l3.10592"></a><span id="l3.10592">         nsAutoCString inboxNameWithDelim(&quot;INBOX&quot;);</span>
<a href="#l3.10593"></a><span id="l3.10593">         inboxNameWithDelim.Append(ns-&gt;GetDelimiter());</span>
<a href="#l3.10594"></a><span id="l3.10594"> </span>
<a href="#l3.10595"></a><span id="l3.10595" class="difflineplus">+        // Only do it for non-empty namespace prefixes.</span>
<a href="#l3.10596"></a><span id="l3.10596">         if (!gHideUnusedNamespaces &amp;&amp; *prefix &amp;&amp;</span>
<a href="#l3.10597"></a><span id="l3.10597" class="difflineminus">-        PL_strcasecmp(prefix, inboxNameWithDelim.get())) /* only do it for</span>
<a href="#l3.10598"></a><span id="l3.10598" class="difflineminus">-        non-empty namespace prefixes */</span>
<a href="#l3.10599"></a><span id="l3.10599" class="difflineminus">-        {</span>
<a href="#l3.10600"></a><span id="l3.10600" class="difflineplus">+            PL_strcasecmp(prefix, inboxNameWithDelim.get())) {</span>
<a href="#l3.10601"></a><span id="l3.10601">           // Explicitly discover each Namespace, just so they're</span>
<a href="#l3.10602"></a><span id="l3.10602">           // there in the subscribe UI</span>
<a href="#l3.10603"></a><span id="l3.10603">           RefPtr&lt;nsImapMailboxSpec&gt; boxSpec = new nsImapMailboxSpec;</span>
<a href="#l3.10604"></a><span id="l3.10604">           boxSpec-&gt;mFolderSelected = false;</span>
<a href="#l3.10605"></a><span id="l3.10605">           boxSpec-&gt;mHostName.Assign(GetImapHostName());</span>
<a href="#l3.10606"></a><span id="l3.10606">           boxSpec-&gt;mConnection = this;</span>
<a href="#l3.10607"></a><span id="l3.10607">           boxSpec-&gt;mFlagState = nullptr;</span>
<a href="#l3.10608"></a><span id="l3.10608">           boxSpec-&gt;mDiscoveredFromLsub = true;</span>
<a href="#l3.10609"></a><span id="l3.10609">           boxSpec-&gt;mOnlineVerified = true;</span>
<a href="#l3.10610"></a><span id="l3.10610">           boxSpec-&gt;mBoxFlags = kNoselect;</span>
<a href="#l3.10611"></a><span id="l3.10611">           boxSpec-&gt;mHierarchySeparator = ns-&gt;GetDelimiter();</span>
<a href="#l3.10612"></a><span id="l3.10612"> </span>
<a href="#l3.10613"></a><span id="l3.10613" class="difflineminus">-          m_runningUrl-&gt;AllocateCanonicalPath(ns-&gt;GetPrefix(), ns-&gt;GetDelimiter(),</span>
<a href="#l3.10614"></a><span id="l3.10614" class="difflineminus">-                                              getter_Copies(boxSpec-&gt;mAllocatedPathName));</span>
<a href="#l3.10615"></a><span id="l3.10615" class="difflineplus">+          m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.10616"></a><span id="l3.10616" class="difflineplus">+              ns-&gt;GetPrefix(), ns-&gt;GetDelimiter(),</span>
<a href="#l3.10617"></a><span id="l3.10617" class="difflineplus">+              getter_Copies(boxSpec-&gt;mAllocatedPathName));</span>
<a href="#l3.10618"></a><span id="l3.10618">           boxSpec-&gt;mNamespaceForFolder = ns;</span>
<a href="#l3.10619"></a><span id="l3.10619">           boxSpec-&gt;mBoxFlags |= kNameSpace;</span>
<a href="#l3.10620"></a><span id="l3.10620"> </span>
<a href="#l3.10621"></a><span id="l3.10621" class="difflineminus">-          switch (ns-&gt;GetType())</span>
<a href="#l3.10622"></a><span id="l3.10622" class="difflineminus">-          {</span>
<a href="#l3.10623"></a><span id="l3.10623" class="difflineminus">-          case kPersonalNamespace:</span>
<a href="#l3.10624"></a><span id="l3.10624" class="difflineminus">-            boxSpec-&gt;mBoxFlags |= kPersonalMailbox;</span>
<a href="#l3.10625"></a><span id="l3.10625" class="difflineminus">-            break;</span>
<a href="#l3.10626"></a><span id="l3.10626" class="difflineminus">-          case kPublicNamespace:</span>
<a href="#l3.10627"></a><span id="l3.10627" class="difflineminus">-            boxSpec-&gt;mBoxFlags |= kPublicMailbox;</span>
<a href="#l3.10628"></a><span id="l3.10628" class="difflineminus">-            break;</span>
<a href="#l3.10629"></a><span id="l3.10629" class="difflineminus">-          case kOtherUsersNamespace:</span>
<a href="#l3.10630"></a><span id="l3.10630" class="difflineminus">-            boxSpec-&gt;mBoxFlags |= kOtherUsersMailbox;</span>
<a href="#l3.10631"></a><span id="l3.10631" class="difflineminus">-            break;</span>
<a href="#l3.10632"></a><span id="l3.10632" class="difflineminus">-          default:  // (kUnknownNamespace)</span>
<a href="#l3.10633"></a><span id="l3.10633" class="difflineminus">-            break;</span>
<a href="#l3.10634"></a><span id="l3.10634" class="difflineplus">+          switch (ns-&gt;GetType()) {</span>
<a href="#l3.10635"></a><span id="l3.10635" class="difflineplus">+            case kPersonalNamespace:</span>
<a href="#l3.10636"></a><span id="l3.10636" class="difflineplus">+              boxSpec-&gt;mBoxFlags |= kPersonalMailbox;</span>
<a href="#l3.10637"></a><span id="l3.10637" class="difflineplus">+              break;</span>
<a href="#l3.10638"></a><span id="l3.10638" class="difflineplus">+            case kPublicNamespace:</span>
<a href="#l3.10639"></a><span id="l3.10639" class="difflineplus">+              boxSpec-&gt;mBoxFlags |= kPublicMailbox;</span>
<a href="#l3.10640"></a><span id="l3.10640" class="difflineplus">+              break;</span>
<a href="#l3.10641"></a><span id="l3.10641" class="difflineplus">+            case kOtherUsersNamespace:</span>
<a href="#l3.10642"></a><span id="l3.10642" class="difflineplus">+              boxSpec-&gt;mBoxFlags |= kOtherUsersMailbox;</span>
<a href="#l3.10643"></a><span id="l3.10643" class="difflineplus">+              break;</span>
<a href="#l3.10644"></a><span id="l3.10644" class="difflineplus">+            default:  // (kUnknownNamespace)</span>
<a href="#l3.10645"></a><span id="l3.10645" class="difflineplus">+              break;</span>
<a href="#l3.10646"></a><span id="l3.10646">           }</span>
<a href="#l3.10647"></a><span id="l3.10647"> </span>
<a href="#l3.10648"></a><span id="l3.10648">           DiscoverMailboxSpec(boxSpec);</span>
<a href="#l3.10649"></a><span id="l3.10649">         }</span>
<a href="#l3.10650"></a><span id="l3.10650"> </span>
<a href="#l3.10651"></a><span id="l3.10651">         nsAutoCString allPattern(prefix);</span>
<a href="#l3.10652"></a><span id="l3.10652">         allPattern += '*';</span>
<a href="#l3.10653"></a><span id="l3.10653"> </span>
<a href="#l3.10654"></a><span id="l3.10654">         if (!m_imapServerSink) return;</span>
<a href="#l3.10655"></a><span id="l3.10655"> </span>
<a href="#l3.10656"></a><span id="l3.10656">         m_imapServerSink-&gt;SetServerDoingLsub(true);</span>
<a href="#l3.10657"></a><span id="l3.10657">         Lsub(allPattern.get(), true);  // LSUB all the subscribed</span>
<a href="#l3.10658"></a><span id="l3.10658"> </span>
<a href="#l3.10659"></a><span id="l3.10659">         m_imapServerSink-&gt;SetServerDoingLsub(false);</span>
<a href="#l3.10660"></a><span id="l3.10660" class="difflineminus">-        List(allPattern.get(), true); // LIST all folders</span>
<a href="#l3.10661"></a><span id="l3.10661" class="difflineplus">+        List(allPattern.get(), true);  // LIST all folders</span>
<a href="#l3.10662"></a><span id="l3.10662">       }</span>
<a href="#l3.10663"></a><span id="l3.10663">     }</span>
<a href="#l3.10664"></a><span id="l3.10664">   }</span>
<a href="#l3.10665"></a><span id="l3.10665"> }</span>
<a href="#l3.10666"></a><span id="l3.10666"> </span>
<a href="#l3.10667"></a><span id="l3.10667"> // DiscoverMailboxList() is used to actually do the discovery of folders</span>
<a href="#l3.10668"></a><span id="l3.10668"> // for a host.  This is used both when we initially start up (and re-sync)</span>
<a href="#l3.10669"></a><span id="l3.10669"> // and also when the user manually requests a re-sync, by collapsing and</span>
<a href="#l3.10670"></a><span id="l3.10670"> // expanding a host in the folder pane.  This is not used for the subscribe</span>
<a href="#l3.10671"></a><span id="l3.10671"> // pane.</span>
<a href="#l3.10672"></a><span id="l3.10672"> // DiscoverMailboxList() also gets the ACLs for each newly discovered folder</span>
<a href="#l3.10673"></a><span id="l3.10673" class="difflineminus">-void nsImapProtocol::DiscoverMailboxList()</span>
<a href="#l3.10674"></a><span id="l3.10674" class="difflineminus">-{</span>
<a href="#l3.10675"></a><span id="l3.10675" class="difflineplus">+void nsImapProtocol::DiscoverMailboxList() {</span>
<a href="#l3.10676"></a><span id="l3.10676">   bool usingSubscription = false;</span>
<a href="#l3.10677"></a><span id="l3.10677"> </span>
<a href="#l3.10678"></a><span id="l3.10678" class="difflineminus">-  m_hostSessionList-&gt;GetHostIsUsingSubscription(GetImapServerKey(), usingSubscription);</span>
<a href="#l3.10679"></a><span id="l3.10679" class="difflineminus">-  // Pretend that the Trash folder doesn't exist, so we will rediscover it if we need to.</span>
<a href="#l3.10680"></a><span id="l3.10680" class="difflineminus">-  m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(GetImapServerKey(), false);</span>
<a href="#l3.10681"></a><span id="l3.10681" class="difflineplus">+  m_hostSessionList-&gt;GetHostIsUsingSubscription(GetImapServerKey(),</span>
<a href="#l3.10682"></a><span id="l3.10682" class="difflineplus">+                                                usingSubscription);</span>
<a href="#l3.10683"></a><span id="l3.10683" class="difflineplus">+  // Pretend that the Trash folder doesn't exist, so we will rediscover it if we</span>
<a href="#l3.10684"></a><span id="l3.10684" class="difflineplus">+  // need to.</span>
<a href="#l3.10685"></a><span id="l3.10685" class="difflineplus">+  m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(GetImapServerKey(),</span>
<a href="#l3.10686"></a><span id="l3.10686" class="difflineplus">+                                                       false);</span>
<a href="#l3.10687"></a><span id="l3.10687"> </span>
<a href="#l3.10688"></a><span id="l3.10688">   // should we check a pref here, to be able to turn off XList?</span>
<a href="#l3.10689"></a><span id="l3.10689" class="difflineminus">-  bool hasXLIST = GetServerStateParser().GetCapabilityFlag() &amp; kHasXListCapability;</span>
<a href="#l3.10690"></a><span id="l3.10690" class="difflineminus">-  if (hasXLIST &amp;&amp; usingSubscription)</span>
<a href="#l3.10691"></a><span id="l3.10691" class="difflineminus">-  {</span>
<a href="#l3.10692"></a><span id="l3.10692" class="difflineplus">+  bool hasXLIST =</span>
<a href="#l3.10693"></a><span id="l3.10693" class="difflineplus">+      GetServerStateParser().GetCapabilityFlag() &amp; kHasXListCapability;</span>
<a href="#l3.10694"></a><span id="l3.10694" class="difflineplus">+  if (hasXLIST &amp;&amp; usingSubscription) {</span>
<a href="#l3.10695"></a><span id="l3.10695">     m_hierarchyNameState = kXListing;</span>
<a href="#l3.10696"></a><span id="l3.10696">     nsAutoCString pattern(&quot;%&quot;);</span>
<a href="#l3.10697"></a><span id="l3.10697">     List(&quot;%&quot;, true, true);</span>
<a href="#l3.10698"></a><span id="l3.10698">     // We list the first and second levels since special folders are unlikely</span>
<a href="#l3.10699"></a><span id="l3.10699">     // to be more than 2 levels deep.</span>
<a href="#l3.10700"></a><span id="l3.10700">     char separator = 0;</span>
<a href="#l3.10701"></a><span id="l3.10701">     m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;separator);</span>
<a href="#l3.10702"></a><span id="l3.10702">     pattern.Append(separator);</span>
<a href="#l3.10703"></a><span id="l3.10703" class="difflineat">@@ -7676,434 +7007,410 @@ void nsImapProtocol::DiscoverMailboxList</span>
<a href="#l3.10704"></a><span id="l3.10704">   if (GetServerStateParser().ServerHasACLCapability())</span>
<a href="#l3.10705"></a><span id="l3.10705">     m_hierarchyNameState = kListingForInfoAndDiscovery;</span>
<a href="#l3.10706"></a><span id="l3.10706">   else</span>
<a href="#l3.10707"></a><span id="l3.10707">     m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.10708"></a><span id="l3.10708"> </span>
<a href="#l3.10709"></a><span id="l3.10709">   // iterate through all namespaces and LSUB them.</span>
<a href="#l3.10710"></a><span id="l3.10710">   uint32_t count = 0;</span>
<a href="#l3.10711"></a><span id="l3.10711">   m_hostSessionList-&gt;GetNumberOfNamespacesForHost(GetImapServerKey(), count);</span>
<a href="#l3.10712"></a><span id="l3.10712" class="difflineminus">-  for (uint32_t i = 0; i &lt; count; i++ )</span>
<a href="#l3.10713"></a><span id="l3.10713" class="difflineminus">-  {</span>
<a href="#l3.10714"></a><span id="l3.10714" class="difflineminus">-    nsIMAPNamespace * ns = nullptr;</span>
<a href="#l3.10715"></a><span id="l3.10715" class="difflineminus">-    m_hostSessionList-&gt;GetNamespaceNumberForHost(GetImapServerKey(),i,ns);</span>
<a href="#l3.10716"></a><span id="l3.10716" class="difflineminus">-    if (ns)</span>
<a href="#l3.10717"></a><span id="l3.10717" class="difflineminus">-    {</span>
<a href="#l3.10718"></a><span id="l3.10718" class="difflineplus">+  for (uint32_t i = 0; i &lt; count; i++) {</span>
<a href="#l3.10719"></a><span id="l3.10719" class="difflineplus">+    nsIMAPNamespace *ns = nullptr;</span>
<a href="#l3.10720"></a><span id="l3.10720" class="difflineplus">+    m_hostSessionList-&gt;GetNamespaceNumberForHost(GetImapServerKey(), i, ns);</span>
<a href="#l3.10721"></a><span id="l3.10721" class="difflineplus">+    if (ns) {</span>
<a href="#l3.10722"></a><span id="l3.10722">       const char *prefix = ns-&gt;GetPrefix();</span>
<a href="#l3.10723"></a><span id="l3.10723" class="difflineminus">-      if (prefix)</span>
<a href="#l3.10724"></a><span id="l3.10724" class="difflineminus">-      {</span>
<a href="#l3.10725"></a><span id="l3.10725" class="difflineplus">+      if (prefix) {</span>
<a href="#l3.10726"></a><span id="l3.10726">         nsAutoCString inboxNameWithDelim(&quot;INBOX&quot;);</span>
<a href="#l3.10727"></a><span id="l3.10727">         inboxNameWithDelim.Append(ns-&gt;GetDelimiter());</span>
<a href="#l3.10728"></a><span id="l3.10728"> </span>
<a href="#l3.10729"></a><span id="l3.10729">         // static bool gHideUnusedNamespaces = true;</span>
<a href="#l3.10730"></a><span id="l3.10730">         // mscott -&gt; WARNING!!! i where are we going to get this</span>
<a href="#l3.10731"></a><span id="l3.10731">         // global variable for unused name spaces from???</span>
<a href="#l3.10732"></a><span id="l3.10732">         // dmb - we should get this from a per-host preference,</span>
<a href="#l3.10733"></a><span id="l3.10733" class="difflineminus">-        // I'd say. But for now, just make it true;</span>
<a href="#l3.10734"></a><span id="l3.10734" class="difflineplus">+        // I'd say. But for now, just make it true.</span>
<a href="#l3.10735"></a><span id="l3.10735" class="difflineplus">+        // Only do it for non-empty namespace prefixes, and for non-INBOX prefix</span>
<a href="#l3.10736"></a><span id="l3.10736">         if (!gHideUnusedNamespaces &amp;&amp; *prefix &amp;&amp;</span>
<a href="#l3.10737"></a><span id="l3.10737" class="difflineminus">-                    PL_strcasecmp(prefix, inboxNameWithDelim.get()))  // only do it for</span>
<a href="#l3.10738"></a><span id="l3.10738" class="difflineminus">-                    // non-empty namespace prefixes, and for non-INBOX prefix</span>
<a href="#l3.10739"></a><span id="l3.10739" class="difflineminus">-        {</span>
<a href="#l3.10740"></a><span id="l3.10740" class="difflineplus">+            PL_strcasecmp(prefix, inboxNameWithDelim.get())) {</span>
<a href="#l3.10741"></a><span id="l3.10741">           // Explicitly discover each Namespace, so that we can</span>
<a href="#l3.10742"></a><span id="l3.10742" class="difflineminus">-                    // create subfolders of them,</span>
<a href="#l3.10743"></a><span id="l3.10743" class="difflineplus">+          // create subfolders of them,</span>
<a href="#l3.10744"></a><span id="l3.10744">           RefPtr&lt;nsImapMailboxSpec&gt; boxSpec = new nsImapMailboxSpec;</span>
<a href="#l3.10745"></a><span id="l3.10745">           boxSpec-&gt;mFolderSelected = false;</span>
<a href="#l3.10746"></a><span id="l3.10746">           boxSpec-&gt;mHostName = GetImapHostName();</span>
<a href="#l3.10747"></a><span id="l3.10747">           boxSpec-&gt;mConnection = this;</span>
<a href="#l3.10748"></a><span id="l3.10748">           boxSpec-&gt;mFlagState = nullptr;</span>
<a href="#l3.10749"></a><span id="l3.10749">           boxSpec-&gt;mDiscoveredFromLsub = true;</span>
<a href="#l3.10750"></a><span id="l3.10750">           boxSpec-&gt;mOnlineVerified = true;</span>
<a href="#l3.10751"></a><span id="l3.10751">           boxSpec-&gt;mBoxFlags = kNoselect;</span>
<a href="#l3.10752"></a><span id="l3.10752">           boxSpec-&gt;mHierarchySeparator = ns-&gt;GetDelimiter();</span>
<a href="#l3.10753"></a><span id="l3.10753">           // Until |AllocateCanonicalPath()| gets updated:</span>
<a href="#l3.10754"></a><span id="l3.10754">           m_runningUrl-&gt;AllocateCanonicalPath(</span>
<a href="#l3.10755"></a><span id="l3.10755" class="difflineminus">-                          ns-&gt;GetPrefix(), ns-&gt;GetDelimiter(),</span>
<a href="#l3.10756"></a><span id="l3.10756" class="difflineminus">-                          getter_Copies(boxSpec-&gt;mAllocatedPathName));</span>
<a href="#l3.10757"></a><span id="l3.10757" class="difflineplus">+              ns-&gt;GetPrefix(), ns-&gt;GetDelimiter(),</span>
<a href="#l3.10758"></a><span id="l3.10758" class="difflineplus">+              getter_Copies(boxSpec-&gt;mAllocatedPathName));</span>
<a href="#l3.10759"></a><span id="l3.10759">           boxSpec-&gt;mNamespaceForFolder = ns;</span>
<a href="#l3.10760"></a><span id="l3.10760">           boxSpec-&gt;mBoxFlags |= kNameSpace;</span>
<a href="#l3.10761"></a><span id="l3.10761"> </span>
<a href="#l3.10762"></a><span id="l3.10762" class="difflineminus">-          switch (ns-&gt;GetType())</span>
<a href="#l3.10763"></a><span id="l3.10763" class="difflineminus">-          {</span>
<a href="#l3.10764"></a><span id="l3.10764" class="difflineminus">-          case kPersonalNamespace:</span>
<a href="#l3.10765"></a><span id="l3.10765" class="difflineminus">-            boxSpec-&gt;mBoxFlags |= kPersonalMailbox;</span>
<a href="#l3.10766"></a><span id="l3.10766" class="difflineminus">-            break;</span>
<a href="#l3.10767"></a><span id="l3.10767" class="difflineminus">-          case kPublicNamespace:</span>
<a href="#l3.10768"></a><span id="l3.10768" class="difflineminus">-            boxSpec-&gt;mBoxFlags |= kPublicMailbox;</span>
<a href="#l3.10769"></a><span id="l3.10769" class="difflineminus">-            break;</span>
<a href="#l3.10770"></a><span id="l3.10770" class="difflineminus">-          case kOtherUsersNamespace:</span>
<a href="#l3.10771"></a><span id="l3.10771" class="difflineminus">-            boxSpec-&gt;mBoxFlags |= kOtherUsersMailbox;</span>
<a href="#l3.10772"></a><span id="l3.10772" class="difflineminus">-            break;</span>
<a href="#l3.10773"></a><span id="l3.10773" class="difflineminus">-          default:  // (kUnknownNamespace)</span>
<a href="#l3.10774"></a><span id="l3.10774" class="difflineminus">-            break;</span>
<a href="#l3.10775"></a><span id="l3.10775" class="difflineplus">+          switch (ns-&gt;GetType()) {</span>
<a href="#l3.10776"></a><span id="l3.10776" class="difflineplus">+            case kPersonalNamespace:</span>
<a href="#l3.10777"></a><span id="l3.10777" class="difflineplus">+              boxSpec-&gt;mBoxFlags |= kPersonalMailbox;</span>
<a href="#l3.10778"></a><span id="l3.10778" class="difflineplus">+              break;</span>
<a href="#l3.10779"></a><span id="l3.10779" class="difflineplus">+            case kPublicNamespace:</span>
<a href="#l3.10780"></a><span id="l3.10780" class="difflineplus">+              boxSpec-&gt;mBoxFlags |= kPublicMailbox;</span>
<a href="#l3.10781"></a><span id="l3.10781" class="difflineplus">+              break;</span>
<a href="#l3.10782"></a><span id="l3.10782" class="difflineplus">+            case kOtherUsersNamespace:</span>
<a href="#l3.10783"></a><span id="l3.10783" class="difflineplus">+              boxSpec-&gt;mBoxFlags |= kOtherUsersMailbox;</span>
<a href="#l3.10784"></a><span id="l3.10784" class="difflineplus">+              break;</span>
<a href="#l3.10785"></a><span id="l3.10785" class="difflineplus">+            default:  // (kUnknownNamespace)</span>
<a href="#l3.10786"></a><span id="l3.10786" class="difflineplus">+              break;</span>
<a href="#l3.10787"></a><span id="l3.10787">           }</span>
<a href="#l3.10788"></a><span id="l3.10788"> </span>
<a href="#l3.10789"></a><span id="l3.10789">           DiscoverMailboxSpec(boxSpec);</span>
<a href="#l3.10790"></a><span id="l3.10790">         }</span>
<a href="#l3.10791"></a><span id="l3.10791"> </span>
<a href="#l3.10792"></a><span id="l3.10792">         // now do the folders within this namespace</span>
<a href="#l3.10793"></a><span id="l3.10793">         nsCString pattern;</span>
<a href="#l3.10794"></a><span id="l3.10794">         nsCString pattern2;</span>
<a href="#l3.10795"></a><span id="l3.10795" class="difflineminus">-        if (usingSubscription)</span>
<a href="#l3.10796"></a><span id="l3.10796" class="difflineminus">-        {</span>
<a href="#l3.10797"></a><span id="l3.10797" class="difflineplus">+        if (usingSubscription) {</span>
<a href="#l3.10798"></a><span id="l3.10798">           pattern.Append(prefix);</span>
<a href="#l3.10799"></a><span id="l3.10799">           pattern.Append('*');</span>
<a href="#l3.10800"></a><span id="l3.10800" class="difflineminus">-        }</span>
<a href="#l3.10801"></a><span id="l3.10801" class="difflineminus">-        else</span>
<a href="#l3.10802"></a><span id="l3.10802" class="difflineminus">-        {</span>
<a href="#l3.10803"></a><span id="l3.10803" class="difflineplus">+        } else {</span>
<a href="#l3.10804"></a><span id="l3.10804">           pattern.Append(prefix);</span>
<a href="#l3.10805"></a><span id="l3.10805" class="difflineminus">-          pattern.Append('%'); // mscott just need one percent right?</span>
<a href="#l3.10806"></a><span id="l3.10806" class="difflineplus">+          pattern.Append('%');  // mscott just need one percent right?</span>
<a href="#l3.10807"></a><span id="l3.10807">           // pattern = PR_smprintf(&quot;%s%%&quot;, prefix);</span>
<a href="#l3.10808"></a><span id="l3.10808">           char delimiter = ns-&gt;GetDelimiter();</span>
<a href="#l3.10809"></a><span id="l3.10809" class="difflineminus">-          if (delimiter)</span>
<a href="#l3.10810"></a><span id="l3.10810" class="difflineminus">-          {</span>
<a href="#l3.10811"></a><span id="l3.10811" class="difflineplus">+          if (delimiter) {</span>
<a href="#l3.10812"></a><span id="l3.10812">             // delimiter might be NIL, in which case there's no hierarchy anyway</span>
<a href="#l3.10813"></a><span id="l3.10813">             pattern2 = prefix;</span>
<a href="#l3.10814"></a><span id="l3.10814">             pattern2 += &quot;%&quot;;</span>
<a href="#l3.10815"></a><span id="l3.10815">             pattern2 += delimiter;</span>
<a href="#l3.10816"></a><span id="l3.10816">             pattern2 += &quot;%&quot;;</span>
<a href="#l3.10817"></a><span id="l3.10817">             // pattern2 = PR_smprintf(&quot;%s%%%c%%&quot;, prefix, delimiter);</span>
<a href="#l3.10818"></a><span id="l3.10818">           }</span>
<a href="#l3.10819"></a><span id="l3.10819">         }</span>
<a href="#l3.10820"></a><span id="l3.10820" class="difflineminus">-        // Note: It is important to make sure we are respecting the server_sub_directory</span>
<a href="#l3.10821"></a><span id="l3.10821" class="difflineminus">-        //       preference when calling List and Lsub (2nd arg = true), otherwise</span>
<a href="#l3.10822"></a><span id="l3.10822" class="difflineminus">-        //       we end up with performance issues or even crashes when connecting to</span>
<a href="#l3.10823"></a><span id="l3.10823" class="difflineminus">-        //       servers that expose the users entire home directory (like UW-IMAP).</span>
<a href="#l3.10824"></a><span id="l3.10824" class="difflineminus">-        if (usingSubscription) { // &amp;&amp; !GetSubscribingNow())  should never get here from subscribe pane</span>
<a href="#l3.10825"></a><span id="l3.10825" class="difflineminus">-          if (GetServerStateParser().GetCapabilityFlag() &amp; kHasListExtendedCapability)</span>
<a href="#l3.10826"></a><span id="l3.10826" class="difflineminus">-            Lsub(pattern.get(), true); // do LIST (SUBSCRIBED)</span>
<a href="#l3.10827"></a><span id="l3.10827" class="difflineplus">+        // Note: It is important to make sure we are respecting the</span>
<a href="#l3.10828"></a><span id="l3.10828" class="difflineplus">+        // server_sub_directory preference when calling List and Lsub (2nd arg =</span>
<a href="#l3.10829"></a><span id="l3.10829" class="difflineplus">+        // true), otherwise we end up with performance issues or even crashes</span>
<a href="#l3.10830"></a><span id="l3.10830" class="difflineplus">+        // when connecting to servers that expose the users entire home</span>
<a href="#l3.10831"></a><span id="l3.10831" class="difflineplus">+        // directory (like UW-IMAP).</span>
<a href="#l3.10832"></a><span id="l3.10832" class="difflineplus">+        if (usingSubscription) {  // &amp;&amp; !GetSubscribingNow())  should never get</span>
<a href="#l3.10833"></a><span id="l3.10833" class="difflineplus">+                                  // here from subscribe pane</span>
<a href="#l3.10834"></a><span id="l3.10834" class="difflineplus">+          if (GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.10835"></a><span id="l3.10835" class="difflineplus">+              kHasListExtendedCapability)</span>
<a href="#l3.10836"></a><span id="l3.10836" class="difflineplus">+            Lsub(pattern.get(), true);  // do LIST (SUBSCRIBED)</span>
<a href="#l3.10837"></a><span id="l3.10837">           else {</span>
<a href="#l3.10838"></a><span id="l3.10838">             // store mailbox flags from LIST</span>
<a href="#l3.10839"></a><span id="l3.10839">             EMailboxHierarchyNameState currentState = m_hierarchyNameState;</span>
<a href="#l3.10840"></a><span id="l3.10840">             m_hierarchyNameState = kListingForFolderFlags;</span>
<a href="#l3.10841"></a><span id="l3.10841">             List(pattern.get(), true);</span>
<a href="#l3.10842"></a><span id="l3.10842">             m_hierarchyNameState = currentState;</span>
<a href="#l3.10843"></a><span id="l3.10843">             // then do LSUB using stored flags</span>
<a href="#l3.10844"></a><span id="l3.10844">             Lsub(pattern.get(), true);</span>
<a href="#l3.10845"></a><span id="l3.10845">             m_standardListMailboxes.Clear();</span>
<a href="#l3.10846"></a><span id="l3.10846">           }</span>
<a href="#l3.10847"></a><span id="l3.10847" class="difflineminus">-        }</span>
<a href="#l3.10848"></a><span id="l3.10848" class="difflineminus">-        else</span>
<a href="#l3.10849"></a><span id="l3.10849" class="difflineminus">-        {</span>
<a href="#l3.10850"></a><span id="l3.10850" class="difflineplus">+        } else {</span>
<a href="#l3.10851"></a><span id="l3.10851">           List(pattern.get(), true, hasXLIST);</span>
<a href="#l3.10852"></a><span id="l3.10852">           List(pattern2.get(), true, hasXLIST);</span>
<a href="#l3.10853"></a><span id="l3.10853">         }</span>
<a href="#l3.10854"></a><span id="l3.10854">       }</span>
<a href="#l3.10855"></a><span id="l3.10855">     }</span>
<a href="#l3.10856"></a><span id="l3.10856">   }</span>
<a href="#l3.10857"></a><span id="l3.10857"> </span>
<a href="#l3.10858"></a><span id="l3.10858" class="difflineminus">-  // explicitly LIST the INBOX if (a) we're not using subscription, or (b) we are using subscription and</span>
<a href="#l3.10859"></a><span id="l3.10859" class="difflineminus">-  // the user wants us to always show the INBOX.</span>
<a href="#l3.10860"></a><span id="l3.10860" class="difflineplus">+  // explicitly LIST the INBOX if (a) we're not using subscription, or (b) we</span>
<a href="#l3.10861"></a><span id="l3.10861" class="difflineplus">+  // are using subscription and the user wants us to always show the INBOX.</span>
<a href="#l3.10862"></a><span id="l3.10862">   bool listInboxForHost = false;</span>
<a href="#l3.10863"></a><span id="l3.10863" class="difflineminus">-  m_hostSessionList-&gt;GetShouldAlwaysListInboxForHost(GetImapServerKey(), listInboxForHost);</span>
<a href="#l3.10864"></a><span id="l3.10864" class="difflineminus">-  if (!usingSubscription || listInboxForHost)</span>
<a href="#l3.10865"></a><span id="l3.10865" class="difflineminus">-    List(&quot;INBOX&quot;, true);</span>
<a href="#l3.10866"></a><span id="l3.10866" class="difflineplus">+  m_hostSessionList-&gt;GetShouldAlwaysListInboxForHost(GetImapServerKey(),</span>
<a href="#l3.10867"></a><span id="l3.10867" class="difflineplus">+                                                     listInboxForHost);</span>
<a href="#l3.10868"></a><span id="l3.10868" class="difflineplus">+  if (!usingSubscription || listInboxForHost) List(&quot;INBOX&quot;, true);</span>
<a href="#l3.10869"></a><span id="l3.10869"> </span>
<a href="#l3.10870"></a><span id="l3.10870">   m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.10871"></a><span id="l3.10871"> </span>
<a href="#l3.10872"></a><span id="l3.10872">   MailboxDiscoveryFinished();</span>
<a href="#l3.10873"></a><span id="l3.10873"> </span>
<a href="#l3.10874"></a><span id="l3.10874">   // Get the ACLs for newly discovered folders</span>
<a href="#l3.10875"></a><span id="l3.10875" class="difflineminus">-  if (GetServerStateParser().ServerHasACLCapability())</span>
<a href="#l3.10876"></a><span id="l3.10876" class="difflineminus">-  {</span>
<a href="#l3.10877"></a><span id="l3.10877" class="difflineplus">+  if (GetServerStateParser().ServerHasACLCapability()) {</span>
<a href="#l3.10878"></a><span id="l3.10878">     int32_t total = m_listedMailboxList.Length(), cnt = 0;</span>
<a href="#l3.10879"></a><span id="l3.10879">     // Let's not turn this off here, since we don't turn it on after</span>
<a href="#l3.10880"></a><span id="l3.10880">     // GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.10881"></a><span id="l3.10881" class="difflineminus">-    if (total)</span>
<a href="#l3.10882"></a><span id="l3.10882" class="difflineminus">-    {</span>
<a href="#l3.10883"></a><span id="l3.10883" class="difflineplus">+    if (total) {</span>
<a href="#l3.10884"></a><span id="l3.10884">       ProgressEventFunctionUsingName(&quot;imapGettingACLForFolder&quot;);</span>
<a href="#l3.10885"></a><span id="l3.10885" class="difflineminus">-      nsIMAPMailboxInfo * mb = nullptr;</span>
<a href="#l3.10886"></a><span id="l3.10886" class="difflineminus">-      do</span>
<a href="#l3.10887"></a><span id="l3.10887" class="difflineminus">-      {</span>
<a href="#l3.10888"></a><span id="l3.10888" class="difflineminus">-        if (m_listedMailboxList.Length() == 0)</span>
<a href="#l3.10889"></a><span id="l3.10889" class="difflineminus">-            break;</span>
<a href="#l3.10890"></a><span id="l3.10890" class="difflineminus">-</span>
<a href="#l3.10891"></a><span id="l3.10891" class="difflineminus">-        mb = m_listedMailboxList[0]; // get top element</span>
<a href="#l3.10892"></a><span id="l3.10892" class="difflineminus">-        m_listedMailboxList.RemoveElementAt(0); // XP_ListRemoveTopObject(fListedMailboxList);</span>
<a href="#l3.10893"></a><span id="l3.10893" class="difflineminus">-        if (mb)</span>
<a href="#l3.10894"></a><span id="l3.10894" class="difflineminus">-        {</span>
<a href="#l3.10895"></a><span id="l3.10895" class="difflineminus">-          if (FolderNeedsACLInitialized(PromiseFlatCString(mb-&gt;GetMailboxName()).get()))</span>
<a href="#l3.10896"></a><span id="l3.10896" class="difflineminus">-          {</span>
<a href="#l3.10897"></a><span id="l3.10897" class="difflineplus">+      nsIMAPMailboxInfo *mb = nullptr;</span>
<a href="#l3.10898"></a><span id="l3.10898" class="difflineplus">+      do {</span>
<a href="#l3.10899"></a><span id="l3.10899" class="difflineplus">+        if (m_listedMailboxList.Length() == 0) break;</span>
<a href="#l3.10900"></a><span id="l3.10900" class="difflineplus">+</span>
<a href="#l3.10901"></a><span id="l3.10901" class="difflineplus">+        mb = m_listedMailboxList[0];  // get top element</span>
<a href="#l3.10902"></a><span id="l3.10902" class="difflineplus">+        m_listedMailboxList.RemoveElementAt(</span>
<a href="#l3.10903"></a><span id="l3.10903" class="difflineplus">+            0);  // XP_ListRemoveTopObject(fListedMailboxList);</span>
<a href="#l3.10904"></a><span id="l3.10904" class="difflineplus">+        if (mb) {</span>
<a href="#l3.10905"></a><span id="l3.10905" class="difflineplus">+          if (FolderNeedsACLInitialized(</span>
<a href="#l3.10906"></a><span id="l3.10906" class="difflineplus">+                  PromiseFlatCString(mb-&gt;GetMailboxName()).get())) {</span>
<a href="#l3.10907"></a><span id="l3.10907">             char *onlineName = nullptr;</span>
<a href="#l3.10908"></a><span id="l3.10908" class="difflineminus">-            m_runningUrl-&gt;AllocateServerPath(PromiseFlatCString(mb-&gt;GetMailboxName()).get(),</span>
<a href="#l3.10909"></a><span id="l3.10909" class="difflineminus">-                                             mb-&gt;GetDelimiter(), &amp;onlineName);</span>
<a href="#l3.10910"></a><span id="l3.10910" class="difflineminus">-            if (onlineName)</span>
<a href="#l3.10911"></a><span id="l3.10911" class="difflineminus">-            {</span>
<a href="#l3.10912"></a><span id="l3.10912" class="difflineplus">+            m_runningUrl-&gt;AllocateServerPath(</span>
<a href="#l3.10913"></a><span id="l3.10913" class="difflineplus">+                PromiseFlatCString(mb-&gt;GetMailboxName()).get(),</span>
<a href="#l3.10914"></a><span id="l3.10914" class="difflineplus">+                mb-&gt;GetDelimiter(), &amp;onlineName);</span>
<a href="#l3.10915"></a><span id="l3.10915" class="difflineplus">+            if (onlineName) {</span>
<a href="#l3.10916"></a><span id="l3.10916">               RefreshACLForFolder(onlineName);</span>
<a href="#l3.10917"></a><span id="l3.10917">               PR_Free(onlineName);</span>
<a href="#l3.10918"></a><span id="l3.10918">             }</span>
<a href="#l3.10919"></a><span id="l3.10919">           }</span>
<a href="#l3.10920"></a><span id="l3.10920">           PercentProgressUpdateEvent(NULL, cnt, total);</span>
<a href="#l3.10921"></a><span id="l3.10921" class="difflineminus">-          delete mb;  // this is the last time we're using the list, so delete the entries here</span>
<a href="#l3.10922"></a><span id="l3.10922" class="difflineplus">+          delete mb;  // this is the last time we're using the list, so delete</span>
<a href="#l3.10923"></a><span id="l3.10923" class="difflineplus">+                      // the entries here</span>
<a href="#l3.10924"></a><span id="l3.10924">           cnt++;</span>
<a href="#l3.10925"></a><span id="l3.10925">         }</span>
<a href="#l3.10926"></a><span id="l3.10926">       } while (mb &amp;&amp; !DeathSignalReceived());</span>
<a href="#l3.10927"></a><span id="l3.10927">     }</span>
<a href="#l3.10928"></a><span id="l3.10928">   }</span>
<a href="#l3.10929"></a><span id="l3.10929"> }</span>
<a href="#l3.10930"></a><span id="l3.10930"> </span>
<a href="#l3.10931"></a><span id="l3.10931" class="difflineminus">-bool nsImapProtocol::FolderNeedsACLInitialized(const char *folderName)</span>
<a href="#l3.10932"></a><span id="l3.10932" class="difflineminus">-{</span>
<a href="#l3.10933"></a><span id="l3.10933" class="difflineplus">+bool nsImapProtocol::FolderNeedsACLInitialized(const char *folderName) {</span>
<a href="#l3.10934"></a><span id="l3.10934">   bool rv = false;</span>
<a href="#l3.10935"></a><span id="l3.10935" class="difflineminus">-  m_imapServerSink-&gt;FolderNeedsACLInitialized(nsDependentCString(folderName), &amp;rv);</span>
<a href="#l3.10936"></a><span id="l3.10936" class="difflineplus">+  m_imapServerSink-&gt;FolderNeedsACLInitialized(nsDependentCString(folderName),</span>
<a href="#l3.10937"></a><span id="l3.10937" class="difflineplus">+                                              &amp;rv);</span>
<a href="#l3.10938"></a><span id="l3.10938">   return rv;</span>
<a href="#l3.10939"></a><span id="l3.10939"> }</span>
<a href="#l3.10940"></a><span id="l3.10940"> </span>
<a href="#l3.10941"></a><span id="l3.10941" class="difflineminus">-void nsImapProtocol::MailboxDiscoveryFinished()</span>
<a href="#l3.10942"></a><span id="l3.10942" class="difflineminus">-{</span>
<a href="#l3.10943"></a><span id="l3.10943" class="difflineplus">+void nsImapProtocol::MailboxDiscoveryFinished() {</span>
<a href="#l3.10944"></a><span id="l3.10944">   if (!DeathSignalReceived() &amp;&amp; !GetSubscribingNow() &amp;&amp;</span>
<a href="#l3.10945"></a><span id="l3.10945" class="difflineminus">-    ((m_hierarchyNameState == kNoOperationInProgress) ||</span>
<a href="#l3.10946"></a><span id="l3.10946" class="difflineminus">-    (m_hierarchyNameState == kListingForInfoAndDiscovery)))</span>
<a href="#l3.10947"></a><span id="l3.10947" class="difflineminus">-  {</span>
<a href="#l3.10948"></a><span id="l3.10948" class="difflineplus">+      ((m_hierarchyNameState == kNoOperationInProgress) ||</span>
<a href="#l3.10949"></a><span id="l3.10949" class="difflineplus">+       (m_hierarchyNameState == kListingForInfoAndDiscovery))) {</span>
<a href="#l3.10950"></a><span id="l3.10950">     nsIMAPNamespace *ns = nullptr;</span>
<a href="#l3.10951"></a><span id="l3.10951" class="difflineminus">-    m_hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(GetImapServerKey(), kPersonalNamespace, ns);</span>
<a href="#l3.10952"></a><span id="l3.10952" class="difflineplus">+    m_hostSessionList-&gt;GetDefaultNamespaceOfTypeForHost(GetImapServerKey(),</span>
<a href="#l3.10953"></a><span id="l3.10953" class="difflineplus">+                                                        kPersonalNamespace, ns);</span>
<a href="#l3.10954"></a><span id="l3.10954">     const char *personalDir = ns ? ns-&gt;GetPrefix() : 0;</span>
<a href="#l3.10955"></a><span id="l3.10955"> </span>
<a href="#l3.10956"></a><span id="l3.10956">     bool trashFolderExists = false;</span>
<a href="#l3.10957"></a><span id="l3.10957">     bool usingSubscription = false;</span>
<a href="#l3.10958"></a><span id="l3.10958" class="difflineminus">-    m_hostSessionList-&gt;GetOnlineTrashFolderExistsForHost(GetImapServerKey(), trashFolderExists);</span>
<a href="#l3.10959"></a><span id="l3.10959" class="difflineminus">-    m_hostSessionList-&gt;GetHostIsUsingSubscription(GetImapServerKey(),usingSubscription);</span>
<a href="#l3.10960"></a><span id="l3.10960" class="difflineminus">-    if (!trashFolderExists &amp;&amp; GetDeleteIsMoveToTrash() &amp;&amp; usingSubscription)</span>
<a href="#l3.10961"></a><span id="l3.10961" class="difflineminus">-    {</span>
<a href="#l3.10962"></a><span id="l3.10962" class="difflineplus">+    m_hostSessionList-&gt;GetOnlineTrashFolderExistsForHost(GetImapServerKey(),</span>
<a href="#l3.10963"></a><span id="l3.10963" class="difflineplus">+                                                         trashFolderExists);</span>
<a href="#l3.10964"></a><span id="l3.10964" class="difflineplus">+    m_hostSessionList-&gt;GetHostIsUsingSubscription(GetImapServerKey(),</span>
<a href="#l3.10965"></a><span id="l3.10965" class="difflineplus">+                                                  usingSubscription);</span>
<a href="#l3.10966"></a><span id="l3.10966" class="difflineplus">+    if (!trashFolderExists &amp;&amp; GetDeleteIsMoveToTrash() &amp;&amp; usingSubscription) {</span>
<a href="#l3.10967"></a><span id="l3.10967">       // maybe we're not subscribed to the Trash folder</span>
<a href="#l3.10968"></a><span id="l3.10968" class="difflineminus">-      if (personalDir)</span>
<a href="#l3.10969"></a><span id="l3.10969" class="difflineminus">-      {</span>
<a href="#l3.10970"></a><span id="l3.10970" class="difflineplus">+      if (personalDir) {</span>
<a href="#l3.10971"></a><span id="l3.10971">         m_hierarchyNameState = kDiscoverTrashFolderInProgress;</span>
<a href="#l3.10972"></a><span id="l3.10972">         List(m_trashFolderPath.get(), true);</span>
<a href="#l3.10973"></a><span id="l3.10973">         m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.10974"></a><span id="l3.10974">       }</span>
<a href="#l3.10975"></a><span id="l3.10975">     }</span>
<a href="#l3.10976"></a><span id="l3.10976"> </span>
<a href="#l3.10977"></a><span id="l3.10977">     // There is no Trash folder (either LIST'd or LSUB'd), and we're using the</span>
<a href="#l3.10978"></a><span id="l3.10978">     // Delete-is-move-to-Trash model, and there is a personal namespace</span>
<a href="#l3.10979"></a><span id="l3.10979" class="difflineminus">-    if (!trashFolderExists &amp;&amp; GetDeleteIsMoveToTrash() &amp;&amp; ns)</span>
<a href="#l3.10980"></a><span id="l3.10980" class="difflineminus">-    {</span>
<a href="#l3.10981"></a><span id="l3.10981" class="difflineplus">+    if (!trashFolderExists &amp;&amp; GetDeleteIsMoveToTrash() &amp;&amp; ns) {</span>
<a href="#l3.10982"></a><span id="l3.10982">       nsCString onlineTrashName;</span>
<a href="#l3.10983"></a><span id="l3.10983" class="difflineminus">-      m_runningUrl-&gt;AllocateServerPath(m_trashFolderPath.get(), ns-&gt;GetDelimiter(),</span>
<a href="#l3.10984"></a><span id="l3.10984" class="difflineplus">+      m_runningUrl-&gt;AllocateServerPath(m_trashFolderPath.get(),</span>
<a href="#l3.10985"></a><span id="l3.10985" class="difflineplus">+                                       ns-&gt;GetDelimiter(),</span>
<a href="#l3.10986"></a><span id="l3.10986">                                        getter_Copies(onlineTrashName));</span>
<a href="#l3.10987"></a><span id="l3.10987"> </span>
<a href="#l3.10988"></a><span id="l3.10988">       GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.10989"></a><span id="l3.10989" class="difflineminus">-      bool created = CreateMailboxRespectingSubscriptions(onlineTrashName.get());</span>
<a href="#l3.10990"></a><span id="l3.10990" class="difflineplus">+      bool created =</span>
<a href="#l3.10991"></a><span id="l3.10991" class="difflineplus">+          CreateMailboxRespectingSubscriptions(onlineTrashName.get());</span>
<a href="#l3.10992"></a><span id="l3.10992">       GetServerStateParser().SetReportingErrors(true);</span>
<a href="#l3.10993"></a><span id="l3.10993"> </span>
<a href="#l3.10994"></a><span id="l3.10994">       // force discovery of new trash folder.</span>
<a href="#l3.10995"></a><span id="l3.10995" class="difflineminus">-      if (created)</span>
<a href="#l3.10996"></a><span id="l3.10996" class="difflineminus">-      {</span>
<a href="#l3.10997"></a><span id="l3.10997" class="difflineplus">+      if (created) {</span>
<a href="#l3.10998"></a><span id="l3.10998">         m_hierarchyNameState = kDiscoverTrashFolderInProgress;</span>
<a href="#l3.10999"></a><span id="l3.10999">         List(onlineTrashName.get(), false);</span>
<a href="#l3.11000"></a><span id="l3.11000">         m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l3.11001"></a><span id="l3.11001" class="difflineminus">-      }</span>
<a href="#l3.11002"></a><span id="l3.11002" class="difflineminus">-      else</span>
<a href="#l3.11003"></a><span id="l3.11003" class="difflineminus">-        m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(GetImapServerKey(), true);</span>
<a href="#l3.11004"></a><span id="l3.11004" class="difflineminus">-    } //if trash folder doesn't exist</span>
<a href="#l3.11005"></a><span id="l3.11005" class="difflineminus">-    m_hostSessionList-&gt;SetHaveWeEverDiscoveredFoldersForHost(GetImapServerKey(), true);</span>
<a href="#l3.11006"></a><span id="l3.11006" class="difflineplus">+      } else</span>
<a href="#l3.11007"></a><span id="l3.11007" class="difflineplus">+        m_hostSessionList-&gt;SetOnlineTrashFolderExistsForHost(GetImapServerKey(),</span>
<a href="#l3.11008"></a><span id="l3.11008" class="difflineplus">+                                                             true);</span>
<a href="#l3.11009"></a><span id="l3.11009" class="difflineplus">+    }  // if trash folder doesn't exist</span>
<a href="#l3.11010"></a><span id="l3.11010" class="difflineplus">+    m_hostSessionList-&gt;SetHaveWeEverDiscoveredFoldersForHost(GetImapServerKey(),</span>
<a href="#l3.11011"></a><span id="l3.11011" class="difflineplus">+                                                             true);</span>
<a href="#l3.11012"></a><span id="l3.11012"> </span>
<a href="#l3.11013"></a><span id="l3.11013">     // notify front end that folder discovery is complete....</span>
<a href="#l3.11014"></a><span id="l3.11014" class="difflineminus">-    if (m_imapServerSink)</span>
<a href="#l3.11015"></a><span id="l3.11015" class="difflineminus">-      m_imapServerSink-&gt;DiscoveryDone();</span>
<a href="#l3.11016"></a><span id="l3.11016" class="difflineplus">+    if (m_imapServerSink) m_imapServerSink-&gt;DiscoveryDone();</span>
<a href="#l3.11017"></a><span id="l3.11017">   }</span>
<a href="#l3.11018"></a><span id="l3.11018"> }</span>
<a href="#l3.11019"></a><span id="l3.11019"> </span>
<a href="#l3.11020"></a><span id="l3.11020"> // returns the mailboxName with the IMAP delimiter removed from the tail end</span>
<a href="#l3.11021"></a><span id="l3.11021" class="difflineminus">-void nsImapProtocol::RemoveHierarchyDelimiter(nsCString &amp;mailboxName)</span>
<a href="#l3.11022"></a><span id="l3.11022" class="difflineminus">-{</span>
<a href="#l3.11023"></a><span id="l3.11023" class="difflineplus">+void nsImapProtocol::RemoveHierarchyDelimiter(nsCString &amp;mailboxName) {</span>
<a href="#l3.11024"></a><span id="l3.11024">   char onlineDelimiter[2] = {0, 0};</span>
<a href="#l3.11025"></a><span id="l3.11025">   if (m_imapMailFolderSink)</span>
<a href="#l3.11026"></a><span id="l3.11026">     m_imapMailFolderSink-&gt;GetOnlineDelimiter(&amp;onlineDelimiter[0]);</span>
<a href="#l3.11027"></a><span id="l3.11027">   // take the hierarchy delimiter off the end, if any.</span>
<a href="#l3.11028"></a><span id="l3.11028" class="difflineminus">-  if (onlineDelimiter[0])</span>
<a href="#l3.11029"></a><span id="l3.11029" class="difflineminus">-    mailboxName.Trim(onlineDelimiter, false, true);</span>
<a href="#l3.11030"></a><span id="l3.11030" class="difflineplus">+  if (onlineDelimiter[0]) mailboxName.Trim(onlineDelimiter, false, true);</span>
<a href="#l3.11031"></a><span id="l3.11031"> }</span>
<a href="#l3.11032"></a><span id="l3.11032"> </span>
<a href="#l3.11033"></a><span id="l3.11033"> // returns true is the create succeeded (regardless of subscription changes)</span>
<a href="#l3.11034"></a><span id="l3.11034" class="difflineminus">-bool nsImapProtocol::CreateMailboxRespectingSubscriptions(const char *mailboxName)</span>
<a href="#l3.11035"></a><span id="l3.11035" class="difflineminus">-{</span>
<a href="#l3.11036"></a><span id="l3.11036" class="difflineplus">+bool nsImapProtocol::CreateMailboxRespectingSubscriptions(</span>
<a href="#l3.11037"></a><span id="l3.11037" class="difflineplus">+    const char *mailboxName) {</span>
<a href="#l3.11038"></a><span id="l3.11038">   CreateMailbox(mailboxName);</span>
<a href="#l3.11039"></a><span id="l3.11039">   bool rv = GetServerStateParser().LastCommandSuccessful();</span>
<a href="#l3.11040"></a><span id="l3.11040" class="difflineminus">-  if (rv &amp;&amp; m_autoSubscribe) // auto-subscribe is on</span>
<a href="#l3.11041"></a><span id="l3.11041" class="difflineplus">+  if (rv &amp;&amp; m_autoSubscribe)  // auto-subscribe is on</span>
<a href="#l3.11042"></a><span id="l3.11042">   {</span>
<a href="#l3.11043"></a><span id="l3.11043">     // create succeeded - let's subscribe to it</span>
<a href="#l3.11044"></a><span id="l3.11044">     bool reportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.11045"></a><span id="l3.11045">     GetServerStateParser().SetReportingErrors(false);</span>
<a href="#l3.11046"></a><span id="l3.11046">     nsCString mailboxWODelim(mailboxName);</span>
<a href="#l3.11047"></a><span id="l3.11047">     RemoveHierarchyDelimiter(mailboxWODelim);</span>
<a href="#l3.11048"></a><span id="l3.11048">     OnSubscribe(mailboxWODelim.get());</span>
<a href="#l3.11049"></a><span id="l3.11049">     GetServerStateParser().SetReportingErrors(reportingErrors);</span>
<a href="#l3.11050"></a><span id="l3.11050">   }</span>
<a href="#l3.11051"></a><span id="l3.11051">   return rv;</span>
<a href="#l3.11052"></a><span id="l3.11052"> }</span>
<a href="#l3.11053"></a><span id="l3.11053"> </span>
<a href="#l3.11054"></a><span id="l3.11054" class="difflineminus">-void nsImapProtocol::CreateMailbox(const char *mailboxName)</span>
<a href="#l3.11055"></a><span id="l3.11055" class="difflineminus">-{</span>
<a href="#l3.11056"></a><span id="l3.11056" class="difflineplus">+void nsImapProtocol::CreateMailbox(const char *mailboxName) {</span>
<a href="#l3.11057"></a><span id="l3.11057">   ProgressEventFunctionUsingName(&quot;imapStatusCreatingMailbox&quot;);</span>
<a href="#l3.11058"></a><span id="l3.11058"> </span>
<a href="#l3.11059"></a><span id="l3.11059">   IncrementCommandTagNumber();</span>
<a href="#l3.11060"></a><span id="l3.11060"> </span>
<a href="#l3.11061"></a><span id="l3.11061">   nsCString escapedName;</span>
<a href="#l3.11062"></a><span id="l3.11062">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.11063"></a><span id="l3.11063">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.11064"></a><span id="l3.11064">   command += &quot; create \&quot;&quot;;</span>
<a href="#l3.11065"></a><span id="l3.11065">   command += escapedName;</span>
<a href="#l3.11066"></a><span id="l3.11066">   command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11067"></a><span id="l3.11067"> </span>
<a href="#l3.11068"></a><span id="l3.11068">   nsresult rv = SendData(command.get());</span>
<a href="#l3.11069"></a><span id="l3.11069" class="difflineminus">-  if(NS_SUCCEEDED(rv))</span>
<a href="#l3.11070"></a><span id="l3.11070" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11071"></a><span id="l3.11071" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11072"></a><span id="l3.11072">   // If that failed, let's list the parent folder to see if</span>
<a href="#l3.11073"></a><span id="l3.11073">   // it allows inferiors, so we won't try to create sub-folders</span>
<a href="#l3.11074"></a><span id="l3.11074">   // of the parent folder again in the current session.</span>
<a href="#l3.11075"></a><span id="l3.11075" class="difflineminus">-  if (GetServerStateParser().CommandFailed())</span>
<a href="#l3.11076"></a><span id="l3.11076" class="difflineminus">-  {</span>
<a href="#l3.11077"></a><span id="l3.11077" class="difflineplus">+  if (GetServerStateParser().CommandFailed()) {</span>
<a href="#l3.11078"></a><span id="l3.11078">     // Figure out parent folder name.</span>
<a href="#l3.11079"></a><span id="l3.11079">     nsCString parentName(mailboxName);</span>
<a href="#l3.11080"></a><span id="l3.11080">     char hierarchyDelimiter;</span>
<a href="#l3.11081"></a><span id="l3.11081">     m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;hierarchyDelimiter);</span>
<a href="#l3.11082"></a><span id="l3.11082">     int32_t leafPos = parentName.RFindChar(hierarchyDelimiter);</span>
<a href="#l3.11083"></a><span id="l3.11083" class="difflineminus">-    if (leafPos &gt; 0)</span>
<a href="#l3.11084"></a><span id="l3.11084" class="difflineminus">-    {</span>
<a href="#l3.11085"></a><span id="l3.11085" class="difflineplus">+    if (leafPos &gt; 0) {</span>
<a href="#l3.11086"></a><span id="l3.11086">       parentName.SetLength(leafPos);</span>
<a href="#l3.11087"></a><span id="l3.11087">       List(parentName.get(), false);</span>
<a href="#l3.11088"></a><span id="l3.11088">       // We still want the caller to know the create failed, so restore that.</span>
<a href="#l3.11089"></a><span id="l3.11089">       GetServerStateParser().SetCommandFailed(true);</span>
<a href="#l3.11090"></a><span id="l3.11090">     }</span>
<a href="#l3.11091"></a><span id="l3.11091">   }</span>
<a href="#l3.11092"></a><span id="l3.11092"> }</span>
<a href="#l3.11093"></a><span id="l3.11093"> </span>
<a href="#l3.11094"></a><span id="l3.11094" class="difflineminus">-void nsImapProtocol::DeleteMailbox(const char *mailboxName)</span>
<a href="#l3.11095"></a><span id="l3.11095" class="difflineminus">-{</span>
<a href="#l3.11096"></a><span id="l3.11096" class="difflineminus">-</span>
<a href="#l3.11097"></a><span id="l3.11097" class="difflineplus">+void nsImapProtocol::DeleteMailbox(const char *mailboxName) {</span>
<a href="#l3.11098"></a><span id="l3.11098">   // check if this connection currently has the folder to be deleted selected.</span>
<a href="#l3.11099"></a><span id="l3.11099" class="difflineminus">-  // If so, we should close it because at least some UW servers don't like you deleting</span>
<a href="#l3.11100"></a><span id="l3.11100" class="difflineminus">-  // a folder you have open.</span>
<a href="#l3.11101"></a><span id="l3.11101" class="difflineminus">-  if (FolderIsSelected(mailboxName))</span>
<a href="#l3.11102"></a><span id="l3.11102" class="difflineminus">-    Close();</span>
<a href="#l3.11103"></a><span id="l3.11103" class="difflineminus">-</span>
<a href="#l3.11104"></a><span id="l3.11104" class="difflineminus">-</span>
<a href="#l3.11105"></a><span id="l3.11105" class="difflineminus">-  ProgressEventFunctionUsingNameWithString(&quot;imapStatusDeletingMailbox&quot;, mailboxName);</span>
<a href="#l3.11106"></a><span id="l3.11106" class="difflineminus">-</span>
<a href="#l3.11107"></a><span id="l3.11107" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.11108"></a><span id="l3.11108" class="difflineminus">-</span>
<a href="#l3.11109"></a><span id="l3.11109" class="difflineminus">-    nsCString escapedName;</span>
<a href="#l3.11110"></a><span id="l3.11110" class="difflineminus">-    CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.11111"></a><span id="l3.11111" class="difflineminus">-    nsCString command(GetServerCommandTag());</span>
<a href="#l3.11112"></a><span id="l3.11112" class="difflineminus">-    command += &quot; delete \&quot;&quot;;</span>
<a href="#l3.11113"></a><span id="l3.11113" class="difflineminus">-    command += escapedName;</span>
<a href="#l3.11114"></a><span id="l3.11114" class="difflineminus">-    command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11115"></a><span id="l3.11115" class="difflineminus">-</span>
<a href="#l3.11116"></a><span id="l3.11116" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.11117"></a><span id="l3.11117" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11118"></a><span id="l3.11118" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11119"></a><span id="l3.11119" class="difflineplus">+  // If so, we should close it because at least some UW servers don't like you</span>
<a href="#l3.11120"></a><span id="l3.11120" class="difflineplus">+  // deleting a folder you have open.</span>
<a href="#l3.11121"></a><span id="l3.11121" class="difflineplus">+  if (FolderIsSelected(mailboxName)) Close();</span>
<a href="#l3.11122"></a><span id="l3.11122" class="difflineplus">+</span>
<a href="#l3.11123"></a><span id="l3.11123" class="difflineplus">+  ProgressEventFunctionUsingNameWithString(&quot;imapStatusDeletingMailbox&quot;,</span>
<a href="#l3.11124"></a><span id="l3.11124" class="difflineplus">+                                           mailboxName);</span>
<a href="#l3.11125"></a><span id="l3.11125" class="difflineplus">+</span>
<a href="#l3.11126"></a><span id="l3.11126" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.11127"></a><span id="l3.11127" class="difflineplus">+</span>
<a href="#l3.11128"></a><span id="l3.11128" class="difflineplus">+  nsCString escapedName;</span>
<a href="#l3.11129"></a><span id="l3.11129" class="difflineplus">+  CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.11130"></a><span id="l3.11130" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.11131"></a><span id="l3.11131" class="difflineplus">+  command += &quot; delete \&quot;&quot;;</span>
<a href="#l3.11132"></a><span id="l3.11132" class="difflineplus">+  command += escapedName;</span>
<a href="#l3.11133"></a><span id="l3.11133" class="difflineplus">+  command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11134"></a><span id="l3.11134" class="difflineplus">+</span>
<a href="#l3.11135"></a><span id="l3.11135" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.11136"></a><span id="l3.11136" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11137"></a><span id="l3.11137"> }</span>
<a href="#l3.11138"></a><span id="l3.11138"> </span>
<a href="#l3.11139"></a><span id="l3.11139"> void nsImapProtocol::RenameMailbox(const char *existingName,</span>
<a href="#l3.11140"></a><span id="l3.11140" class="difflineminus">-                                   const char *newName)</span>
<a href="#l3.11141"></a><span id="l3.11141" class="difflineminus">-{</span>
<a href="#l3.11142"></a><span id="l3.11142" class="difflineplus">+                                   const char *newName) {</span>
<a href="#l3.11143"></a><span id="l3.11143">   // just like DeleteMailbox; Some UW servers don't like it.</span>
<a href="#l3.11144"></a><span id="l3.11144" class="difflineminus">-  if (FolderIsSelected(existingName))</span>
<a href="#l3.11145"></a><span id="l3.11145" class="difflineminus">-    Close();</span>
<a href="#l3.11146"></a><span id="l3.11146" class="difflineminus">-</span>
<a href="#l3.11147"></a><span id="l3.11147" class="difflineminus">-  ProgressEventFunctionUsingNameWithString(&quot;imapStatusRenamingMailbox&quot;, existingName);</span>
<a href="#l3.11148"></a><span id="l3.11148" class="difflineplus">+  if (FolderIsSelected(existingName)) Close();</span>
<a href="#l3.11149"></a><span id="l3.11149" class="difflineplus">+</span>
<a href="#l3.11150"></a><span id="l3.11150" class="difflineplus">+  ProgressEventFunctionUsingNameWithString(&quot;imapStatusRenamingMailbox&quot;,</span>
<a href="#l3.11151"></a><span id="l3.11151" class="difflineplus">+                                           existingName);</span>
<a href="#l3.11152"></a><span id="l3.11152"> </span>
<a href="#l3.11153"></a><span id="l3.11153">   IncrementCommandTagNumber();</span>
<a href="#l3.11154"></a><span id="l3.11154"> </span>
<a href="#l3.11155"></a><span id="l3.11155">   nsCString escapedExistingName;</span>
<a href="#l3.11156"></a><span id="l3.11156">   nsCString escapedNewName;</span>
<a href="#l3.11157"></a><span id="l3.11157">   CreateEscapedMailboxName(existingName, escapedExistingName);</span>
<a href="#l3.11158"></a><span id="l3.11158">   CreateEscapedMailboxName(newName, escapedNewName);</span>
<a href="#l3.11159"></a><span id="l3.11159">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.11160"></a><span id="l3.11160">   command += &quot; rename \&quot;&quot;;</span>
<a href="#l3.11161"></a><span id="l3.11161">   command += escapedExistingName;</span>
<a href="#l3.11162"></a><span id="l3.11162">   command += &quot;\&quot; \&quot;&quot;;</span>
<a href="#l3.11163"></a><span id="l3.11163">   command += escapedNewName;</span>
<a href="#l3.11164"></a><span id="l3.11164">   command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11165"></a><span id="l3.11165"> </span>
<a href="#l3.11166"></a><span id="l3.11166">   nsresult rv = SendData(command.get());</span>
<a href="#l3.11167"></a><span id="l3.11167" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11168"></a><span id="l3.11168" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11169"></a><span id="l3.11169" class="difflineminus">-}</span>
<a href="#l3.11170"></a><span id="l3.11170" class="difflineminus">-</span>
<a href="#l3.11171"></a><span id="l3.11171" class="difflineminus">-bool nsImapProtocol::GetListSubscribedIsBrokenOnServer()</span>
<a href="#l3.11172"></a><span id="l3.11172" class="difflineminus">-{</span>
<a href="#l3.11173"></a><span id="l3.11173" class="difflineminus">-  // This is a workaround for an issue with LIST(SUBSCRIBED) crashing older versions of Zimbra</span>
<a href="#l3.11174"></a><span id="l3.11174" class="difflineminus">-  if (GetServerStateParser().GetServerID().Find(&quot;\&quot;NAME\&quot; \&quot;Zimbra\&quot;&quot;, /* ignoreCase = */ true) != kNotFound) {</span>
<a href="#l3.11175"></a><span id="l3.11175" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11176"></a><span id="l3.11176" class="difflineplus">+}</span>
<a href="#l3.11177"></a><span id="l3.11177" class="difflineplus">+</span>
<a href="#l3.11178"></a><span id="l3.11178" class="difflineplus">+bool nsImapProtocol::GetListSubscribedIsBrokenOnServer() {</span>
<a href="#l3.11179"></a><span id="l3.11179" class="difflineplus">+  // This is a workaround for an issue with LIST(SUBSCRIBED) crashing older</span>
<a href="#l3.11180"></a><span id="l3.11180" class="difflineplus">+  // versions of Zimbra</span>
<a href="#l3.11181"></a><span id="l3.11181" class="difflineplus">+  if (GetServerStateParser().GetServerID().Find(</span>
<a href="#l3.11182"></a><span id="l3.11182" class="difflineplus">+          &quot;\&quot;NAME\&quot; \&quot;Zimbra\&quot;&quot;, /* ignoreCase = */ true) != kNotFound) {</span>
<a href="#l3.11183"></a><span id="l3.11183">     nsCString serverID(GetServerStateParser().GetServerID());</span>
<a href="#l3.11184"></a><span id="l3.11184">     int start = serverID.Find(&quot;\&quot;VERSION\&quot; \&quot;&quot;, /* ignoreCase = */ true) + 11;</span>
<a href="#l3.11185"></a><span id="l3.11185">     int length = serverID.Find(&quot;\&quot; &quot;, true, start);</span>
<a href="#l3.11186"></a><span id="l3.11186" class="difflineminus">-    const nsDependentCSubstring serverVersionSubstring = Substring(serverID, start, length);</span>
<a href="#l3.11187"></a><span id="l3.11187" class="difflineplus">+    const nsDependentCSubstring serverVersionSubstring =</span>
<a href="#l3.11188"></a><span id="l3.11188" class="difflineplus">+        Substring(serverID, start, length);</span>
<a href="#l3.11189"></a><span id="l3.11189">     nsCString serverVersionStr(serverVersionSubstring);</span>
<a href="#l3.11190"></a><span id="l3.11190">     Version serverVersion(serverVersionStr.get());</span>
<a href="#l3.11191"></a><span id="l3.11191">     Version sevenTwoThree(&quot;7.2.3_&quot;);</span>
<a href="#l3.11192"></a><span id="l3.11192">     Version eightZeroZero(&quot;8.0.0_&quot;);</span>
<a href="#l3.11193"></a><span id="l3.11193">     Version eightZeroThree(&quot;8.0.3_&quot;);</span>
<a href="#l3.11194"></a><span id="l3.11194">     if ((serverVersion &lt; sevenTwoThree) ||</span>
<a href="#l3.11195"></a><span id="l3.11195">         ((serverVersion &gt;= eightZeroZero) &amp;&amp; (serverVersion &lt; eightZeroThree)))</span>
<a href="#l3.11196"></a><span id="l3.11196">       return true;</span>
<a href="#l3.11197"></a><span id="l3.11197">   }</span>
<a href="#l3.11198"></a><span id="l3.11198">   return false;</span>
<a href="#l3.11199"></a><span id="l3.11199"> }</span>
<a href="#l3.11200"></a><span id="l3.11200"> </span>
<a href="#l3.11201"></a><span id="l3.11201"> // This identifies servers that require an extra imap SELECT to detect new</span>
<a href="#l3.11202"></a><span id="l3.11202"> // email in a mailbox. Servers requiring this are found by comparing their</span>
<a href="#l3.11203"></a><span id="l3.11203"> // ID string, returned with imap ID command, to strings entered in</span>
<a href="#l3.11204"></a><span id="l3.11204"> // mail.imap.force_select_detect. Only openwave servers used by</span>
<a href="#l3.11205"></a><span id="l3.11205" class="difflineminus">-// Charter/Spectrum ISP returning an ID containing the strings &quot;&quot;name&quot; &quot;Email Mx&quot;&quot;</span>
<a href="#l3.11206"></a><span id="l3.11206" class="difflineminus">-// and &quot;&quot;vendor&quot; &quot;Openwave Messaging&quot;&quot; are now known to have this issue. The</span>
<a href="#l3.11207"></a><span id="l3.11207" class="difflineminus">-// compared strings can be modified with the config editor if necessary</span>
<a href="#l3.11208"></a><span id="l3.11208" class="difflineplus">+// Charter/Spectrum ISP returning an ID containing the strings &quot;&quot;name&quot; &quot;Email</span>
<a href="#l3.11209"></a><span id="l3.11209" class="difflineplus">+// Mx&quot;&quot; and &quot;&quot;vendor&quot; &quot;Openwave Messaging&quot;&quot; are now known to have this issue.</span>
<a href="#l3.11210"></a><span id="l3.11210" class="difflineplus">+// The compared strings can be modified with the config editor if necessary</span>
<a href="#l3.11211"></a><span id="l3.11211"> // (e.g., a &quot;version&quot; substring could be added). Also, additional servers</span>
<a href="#l3.11212"></a><span id="l3.11212"> // having a different set of strings can be added if ever needed.</span>
<a href="#l3.11213"></a><span id="l3.11213"> // The mail.imap.force_select_detect uses semicolon delimiter between</span>
<a href="#l3.11214"></a><span id="l3.11214"> // servers and within a server substrings to compare are comma delimited.</span>
<a href="#l3.11215"></a><span id="l3.11215"> // This example force_select_detect value shows how two servers types</span>
<a href="#l3.11216"></a><span id="l3.11216"> // could be detected:</span>
<a href="#l3.11217"></a><span id="l3.11217" class="difflineminus">-// &quot;name&quot; &quot;Email Mx&quot;,&quot;vendor&quot; &quot;Openwave Messaging&quot;;&quot;vendor&quot; &quot;Yahoo! Inc.&quot;,&quot;name&quot; &quot;Y!IMAP&quot;;</span>
<a href="#l3.11218"></a><span id="l3.11218" class="difflineminus">-bool nsImapProtocol::IsExtraSelectNeeded()</span>
<a href="#l3.11219"></a><span id="l3.11219" class="difflineminus">-{</span>
<a href="#l3.11220"></a><span id="l3.11220" class="difflineplus">+// &quot;name&quot; &quot;Email Mx&quot;,&quot;vendor&quot; &quot;Openwave Messaging&quot;;&quot;vendor&quot; &quot;Yahoo! Inc.&quot;,&quot;name&quot;</span>
<a href="#l3.11221"></a><span id="l3.11221" class="difflineplus">+// &quot;Y!IMAP&quot;;</span>
<a href="#l3.11222"></a><span id="l3.11222" class="difflineplus">+bool nsImapProtocol::IsExtraSelectNeeded() {</span>
<a href="#l3.11223"></a><span id="l3.11223">   bool retVal;</span>
<a href="#l3.11224"></a><span id="l3.11224" class="difflineminus">-  for (uint32_t i = 0; i &lt; gForceSelectServersArray.Length(); i++)</span>
<a href="#l3.11225"></a><span id="l3.11225" class="difflineminus">-  {</span>
<a href="#l3.11226"></a><span id="l3.11226" class="difflineplus">+  for (uint32_t i = 0; i &lt; gForceSelectServersArray.Length(); i++) {</span>
<a href="#l3.11227"></a><span id="l3.11227">     retVal = true;</span>
<a href="#l3.11228"></a><span id="l3.11228">     nsTArray&lt;nsCString&gt; forceSelectStringsArray;</span>
<a href="#l3.11229"></a><span id="l3.11229">     ParseString(gForceSelectServersArray[i], ',', forceSelectStringsArray);</span>
<a href="#l3.11230"></a><span id="l3.11230" class="difflineminus">-    for (uint32_t j = 0; j &lt; forceSelectStringsArray.Length(); j++)</span>
<a href="#l3.11231"></a><span id="l3.11231" class="difflineminus">-    {</span>
<a href="#l3.11232"></a><span id="l3.11232" class="difflineplus">+    for (uint32_t j = 0; j &lt; forceSelectStringsArray.Length(); j++) {</span>
<a href="#l3.11233"></a><span id="l3.11233">       // Each substring within the server string must be contained in ID string.</span>
<a href="#l3.11234"></a><span id="l3.11234" class="difflineminus">-      // First un-escape any comma (%2c) or semicolon (%3b) within the substring.</span>
<a href="#l3.11235"></a><span id="l3.11235" class="difflineplus">+      // First un-escape any comma (%2c) or semicolon (%3b) within the</span>
<a href="#l3.11236"></a><span id="l3.11236" class="difflineplus">+      // substring.</span>
<a href="#l3.11237"></a><span id="l3.11237">       nsAutoCString unescapedString;</span>
<a href="#l3.11238"></a><span id="l3.11238">       MsgUnescapeString(forceSelectStringsArray[j], 0, unescapedString);</span>
<a href="#l3.11239"></a><span id="l3.11239" class="difflineminus">-      if (GetServerStateParser().GetServerID()</span>
<a href="#l3.11240"></a><span id="l3.11240" class="difflineminus">-          .Find(unescapedString, /* ignoreCase = */ true) == kNotFound)</span>
<a href="#l3.11241"></a><span id="l3.11241" class="difflineminus">-      {</span>
<a href="#l3.11242"></a><span id="l3.11242" class="difflineplus">+      if (GetServerStateParser().GetServerID().Find(</span>
<a href="#l3.11243"></a><span id="l3.11243" class="difflineplus">+              unescapedString, /* ignoreCase = */ true) == kNotFound) {</span>
<a href="#l3.11244"></a><span id="l3.11244">         retVal = false;</span>
<a href="#l3.11245"></a><span id="l3.11245">         break;</span>
<a href="#l3.11246"></a><span id="l3.11246">       }</span>
<a href="#l3.11247"></a><span id="l3.11247">     }</span>
<a href="#l3.11248"></a><span id="l3.11248">     // Matches found for all substrings for the server.</span>
<a href="#l3.11249"></a><span id="l3.11249" class="difflineminus">-    if (retVal)</span>
<a href="#l3.11250"></a><span id="l3.11250" class="difflineminus">-      return true;</span>
<a href="#l3.11251"></a><span id="l3.11251" class="difflineplus">+    if (retVal) return true;</span>
<a href="#l3.11252"></a><span id="l3.11252">   }</span>
<a href="#l3.11253"></a><span id="l3.11253"> </span>
<a href="#l3.11254"></a><span id="l3.11254">   // If reached, no substrings match for any server.</span>
<a href="#l3.11255"></a><span id="l3.11255">   return false;</span>
<a href="#l3.11256"></a><span id="l3.11256"> }</span>
<a href="#l3.11257"></a><span id="l3.11257"> </span>
<a href="#l3.11258"></a><span id="l3.11258" class="difflineminus">-void nsImapProtocol::Lsub(const char *mailboxPattern, bool addDirectoryIfNecessary)</span>
<a href="#l3.11259"></a><span id="l3.11259" class="difflineminus">-{</span>
<a href="#l3.11260"></a><span id="l3.11260" class="difflineplus">+void nsImapProtocol::Lsub(const char *mailboxPattern,</span>
<a href="#l3.11261"></a><span id="l3.11261" class="difflineplus">+                          bool addDirectoryIfNecessary) {</span>
<a href="#l3.11262"></a><span id="l3.11262">   ProgressEventFunctionUsingName(&quot;imapStatusLookingForMailbox&quot;);</span>
<a href="#l3.11263"></a><span id="l3.11263"> </span>
<a href="#l3.11264"></a><span id="l3.11264">   IncrementCommandTagNumber();</span>
<a href="#l3.11265"></a><span id="l3.11265"> </span>
<a href="#l3.11266"></a><span id="l3.11266">   char *boxnameWithOnlineDirectory = nullptr;</span>
<a href="#l3.11267"></a><span id="l3.11267">   if (addDirectoryIfNecessary)</span>
<a href="#l3.11268"></a><span id="l3.11268" class="difflineminus">-    m_runningUrl-&gt;AddOnlineDirectoryIfNecessary(mailboxPattern, &amp;boxnameWithOnlineDirectory);</span>
<a href="#l3.11269"></a><span id="l3.11269" class="difflineplus">+    m_runningUrl-&gt;AddOnlineDirectoryIfNecessary(mailboxPattern,</span>
<a href="#l3.11270"></a><span id="l3.11270" class="difflineplus">+                                                &amp;boxnameWithOnlineDirectory);</span>
<a href="#l3.11271"></a><span id="l3.11271"> </span>
<a href="#l3.11272"></a><span id="l3.11272">   nsCString escapedPattern;</span>
<a href="#l3.11273"></a><span id="l3.11273" class="difflineminus">-  CreateEscapedMailboxName(boxnameWithOnlineDirectory ?</span>
<a href="#l3.11274"></a><span id="l3.11274" class="difflineminus">-                        boxnameWithOnlineDirectory :</span>
<a href="#l3.11275"></a><span id="l3.11275" class="difflineminus">-                        mailboxPattern, escapedPattern);</span>
<a href="#l3.11276"></a><span id="l3.11276" class="difflineminus">-</span>
<a href="#l3.11277"></a><span id="l3.11277" class="difflineminus">-  nsCString command (GetServerCommandTag());</span>
<a href="#l3.11278"></a><span id="l3.11278" class="difflineplus">+  CreateEscapedMailboxName(</span>
<a href="#l3.11279"></a><span id="l3.11279" class="difflineplus">+      boxnameWithOnlineDirectory ? boxnameWithOnlineDirectory : mailboxPattern,</span>
<a href="#l3.11280"></a><span id="l3.11280" class="difflineplus">+      escapedPattern);</span>
<a href="#l3.11281"></a><span id="l3.11281" class="difflineplus">+</span>
<a href="#l3.11282"></a><span id="l3.11282" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.11283"></a><span id="l3.11283">   eIMAPCapabilityFlags flag = GetServerStateParser().GetCapabilityFlag();</span>
<a href="#l3.11284"></a><span id="l3.11284">   bool useListSubscribed = (flag &amp; kHasListExtendedCapability) &amp;&amp;</span>
<a href="#l3.11285"></a><span id="l3.11285">                            !GetListSubscribedIsBrokenOnServer();</span>
<a href="#l3.11286"></a><span id="l3.11286">   if (useListSubscribed)</span>
<a href="#l3.11287"></a><span id="l3.11287">     command += &quot; list (subscribed)&quot;;</span>
<a href="#l3.11288"></a><span id="l3.11288">   else</span>
<a href="#l3.11289"></a><span id="l3.11289">     command += &quot; lsub&quot;;</span>
<a href="#l3.11290"></a><span id="l3.11290">   command += &quot; \&quot;\&quot; \&quot;&quot;;</span>
<a href="#l3.11291"></a><span id="l3.11291" class="difflineat">@@ -8111,317 +7418,283 @@ void nsImapProtocol::Lsub(const char *ma</span>
<a href="#l3.11292"></a><span id="l3.11292">   if (useListSubscribed &amp;&amp; (flag &amp; kHasSpecialUseCapability))</span>
<a href="#l3.11293"></a><span id="l3.11293">     command += &quot;\&quot; return (special-use)&quot; CRLF;</span>
<a href="#l3.11294"></a><span id="l3.11294">   else</span>
<a href="#l3.11295"></a><span id="l3.11295">     command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11296"></a><span id="l3.11296"> </span>
<a href="#l3.11297"></a><span id="l3.11297">   PR_Free(boxnameWithOnlineDirectory);</span>
<a href="#l3.11298"></a><span id="l3.11298"> </span>
<a href="#l3.11299"></a><span id="l3.11299">   nsresult rv = SendData(command.get());</span>
<a href="#l3.11300"></a><span id="l3.11300" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11301"></a><span id="l3.11301" class="difflineminus">-    ParseIMAPandCheckForNewMail(command.get(), true);</span>
<a href="#l3.11302"></a><span id="l3.11302" class="difflineminus">-}</span>
<a href="#l3.11303"></a><span id="l3.11303" class="difflineminus">-</span>
<a href="#l3.11304"></a><span id="l3.11304" class="difflineminus">-void nsImapProtocol::List(const char *mailboxPattern, bool addDirectoryIfNecessary,</span>
<a href="#l3.11305"></a><span id="l3.11305" class="difflineminus">-                          bool useXLIST)</span>
<a href="#l3.11306"></a><span id="l3.11306" class="difflineminus">-{</span>
<a href="#l3.11307"></a><span id="l3.11307" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(command.get(), true);</span>
<a href="#l3.11308"></a><span id="l3.11308" class="difflineplus">+}</span>
<a href="#l3.11309"></a><span id="l3.11309" class="difflineplus">+</span>
<a href="#l3.11310"></a><span id="l3.11310" class="difflineplus">+void nsImapProtocol::List(const char *mailboxPattern,</span>
<a href="#l3.11311"></a><span id="l3.11311" class="difflineplus">+                          bool addDirectoryIfNecessary, bool useXLIST) {</span>
<a href="#l3.11312"></a><span id="l3.11312">   ProgressEventFunctionUsingName(&quot;imapStatusLookingForMailbox&quot;);</span>
<a href="#l3.11313"></a><span id="l3.11313"> </span>
<a href="#l3.11314"></a><span id="l3.11314">   IncrementCommandTagNumber();</span>
<a href="#l3.11315"></a><span id="l3.11315"> </span>
<a href="#l3.11316"></a><span id="l3.11316">   char *boxnameWithOnlineDirectory = nullptr;</span>
<a href="#l3.11317"></a><span id="l3.11317">   if (addDirectoryIfNecessary)</span>
<a href="#l3.11318"></a><span id="l3.11318" class="difflineminus">-    m_runningUrl-&gt;AddOnlineDirectoryIfNecessary(mailboxPattern, &amp;boxnameWithOnlineDirectory);</span>
<a href="#l3.11319"></a><span id="l3.11319" class="difflineplus">+    m_runningUrl-&gt;AddOnlineDirectoryIfNecessary(mailboxPattern,</span>
<a href="#l3.11320"></a><span id="l3.11320" class="difflineplus">+                                                &amp;boxnameWithOnlineDirectory);</span>
<a href="#l3.11321"></a><span id="l3.11321"> </span>
<a href="#l3.11322"></a><span id="l3.11322">   nsCString escapedPattern;</span>
<a href="#l3.11323"></a><span id="l3.11323" class="difflineminus">-  CreateEscapedMailboxName(boxnameWithOnlineDirectory ?</span>
<a href="#l3.11324"></a><span id="l3.11324" class="difflineminus">-                        boxnameWithOnlineDirectory :</span>
<a href="#l3.11325"></a><span id="l3.11325" class="difflineminus">-                        mailboxPattern, escapedPattern);</span>
<a href="#l3.11326"></a><span id="l3.11326" class="difflineminus">-</span>
<a href="#l3.11327"></a><span id="l3.11327" class="difflineminus">-  nsCString command (GetServerCommandTag());</span>
<a href="#l3.11328"></a><span id="l3.11328" class="difflineminus">-  command += useXLIST ?</span>
<a href="#l3.11329"></a><span id="l3.11329" class="difflineminus">-    &quot; xlist \&quot;\&quot; \&quot;&quot; : &quot; list \&quot;\&quot; \&quot;&quot;;</span>
<a href="#l3.11330"></a><span id="l3.11330" class="difflineplus">+  CreateEscapedMailboxName(</span>
<a href="#l3.11331"></a><span id="l3.11331" class="difflineplus">+      boxnameWithOnlineDirectory ? boxnameWithOnlineDirectory : mailboxPattern,</span>
<a href="#l3.11332"></a><span id="l3.11332" class="difflineplus">+      escapedPattern);</span>
<a href="#l3.11333"></a><span id="l3.11333" class="difflineplus">+</span>
<a href="#l3.11334"></a><span id="l3.11334" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.11335"></a><span id="l3.11335" class="difflineplus">+  command += useXLIST ? &quot; xlist \&quot;\&quot; \&quot;&quot; : &quot; list \&quot;\&quot; \&quot;&quot;;</span>
<a href="#l3.11336"></a><span id="l3.11336">   command += escapedPattern;</span>
<a href="#l3.11337"></a><span id="l3.11337">   command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11338"></a><span id="l3.11338"> </span>
<a href="#l3.11339"></a><span id="l3.11339">   PR_Free(boxnameWithOnlineDirectory);</span>
<a href="#l3.11340"></a><span id="l3.11340"> </span>
<a href="#l3.11341"></a><span id="l3.11341">   nsresult rv = SendData(command.get());</span>
<a href="#l3.11342"></a><span id="l3.11342" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11343"></a><span id="l3.11343" class="difflineminus">-    ParseIMAPandCheckForNewMail(command.get(), true);</span>
<a href="#l3.11344"></a><span id="l3.11344" class="difflineminus">-}</span>
<a href="#l3.11345"></a><span id="l3.11345" class="difflineminus">-</span>
<a href="#l3.11346"></a><span id="l3.11346" class="difflineminus">-void nsImapProtocol::Subscribe(const char *mailboxName)</span>
<a href="#l3.11347"></a><span id="l3.11347" class="difflineminus">-{</span>
<a href="#l3.11348"></a><span id="l3.11348" class="difflineminus">-  ProgressEventFunctionUsingNameWithString(&quot;imapStatusSubscribeToMailbox&quot;, mailboxName);</span>
<a href="#l3.11349"></a><span id="l3.11349" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(command.get(), true);</span>
<a href="#l3.11350"></a><span id="l3.11350" class="difflineplus">+}</span>
<a href="#l3.11351"></a><span id="l3.11351" class="difflineplus">+</span>
<a href="#l3.11352"></a><span id="l3.11352" class="difflineplus">+void nsImapProtocol::Subscribe(const char *mailboxName) {</span>
<a href="#l3.11353"></a><span id="l3.11353" class="difflineplus">+  ProgressEventFunctionUsingNameWithString(&quot;imapStatusSubscribeToMailbox&quot;,</span>
<a href="#l3.11354"></a><span id="l3.11354" class="difflineplus">+                                           mailboxName);</span>
<a href="#l3.11355"></a><span id="l3.11355"> </span>
<a href="#l3.11356"></a><span id="l3.11356">   IncrementCommandTagNumber();</span>
<a href="#l3.11357"></a><span id="l3.11357"> </span>
<a href="#l3.11358"></a><span id="l3.11358">   nsCString escapedName;</span>
<a href="#l3.11359"></a><span id="l3.11359">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.11360"></a><span id="l3.11360"> </span>
<a href="#l3.11361"></a><span id="l3.11361" class="difflineminus">-  nsCString command (GetServerCommandTag());</span>
<a href="#l3.11362"></a><span id="l3.11362" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.11363"></a><span id="l3.11363">   command += &quot; subscribe \&quot;&quot;;</span>
<a href="#l3.11364"></a><span id="l3.11364">   command += escapedName;</span>
<a href="#l3.11365"></a><span id="l3.11365">   command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11366"></a><span id="l3.11366"> </span>
<a href="#l3.11367"></a><span id="l3.11367">   nsresult rv = SendData(command.get());</span>
<a href="#l3.11368"></a><span id="l3.11368" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11369"></a><span id="l3.11369" class="difflineminus">-    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11370"></a><span id="l3.11370" class="difflineminus">-}</span>
<a href="#l3.11371"></a><span id="l3.11371" class="difflineminus">-</span>
<a href="#l3.11372"></a><span id="l3.11372" class="difflineminus">-void nsImapProtocol::Unsubscribe(const char *mailboxName)</span>
<a href="#l3.11373"></a><span id="l3.11373" class="difflineminus">-{</span>
<a href="#l3.11374"></a><span id="l3.11374" class="difflineminus">-  ProgressEventFunctionUsingNameWithString(&quot;imapStatusUnsubscribeMailbox&quot;, mailboxName);</span>
<a href="#l3.11375"></a><span id="l3.11375" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11376"></a><span id="l3.11376" class="difflineplus">+}</span>
<a href="#l3.11377"></a><span id="l3.11377" class="difflineplus">+</span>
<a href="#l3.11378"></a><span id="l3.11378" class="difflineplus">+void nsImapProtocol::Unsubscribe(const char *mailboxName) {</span>
<a href="#l3.11379"></a><span id="l3.11379" class="difflineplus">+  ProgressEventFunctionUsingNameWithString(&quot;imapStatusUnsubscribeMailbox&quot;,</span>
<a href="#l3.11380"></a><span id="l3.11380" class="difflineplus">+                                           mailboxName);</span>
<a href="#l3.11381"></a><span id="l3.11381">   IncrementCommandTagNumber();</span>
<a href="#l3.11382"></a><span id="l3.11382"> </span>
<a href="#l3.11383"></a><span id="l3.11383">   nsCString escapedName;</span>
<a href="#l3.11384"></a><span id="l3.11384">   CreateEscapedMailboxName(mailboxName, escapedName);</span>
<a href="#l3.11385"></a><span id="l3.11385"> </span>
<a href="#l3.11386"></a><span id="l3.11386" class="difflineminus">-  nsCString command (GetServerCommandTag());</span>
<a href="#l3.11387"></a><span id="l3.11387" class="difflineplus">+  nsCString command(GetServerCommandTag());</span>
<a href="#l3.11388"></a><span id="l3.11388">   command += &quot; unsubscribe \&quot;&quot;;</span>
<a href="#l3.11389"></a><span id="l3.11389">   command += escapedName;</span>
<a href="#l3.11390"></a><span id="l3.11390">   command += &quot;\&quot;&quot; CRLF;</span>
<a href="#l3.11391"></a><span id="l3.11391"> </span>
<a href="#l3.11392"></a><span id="l3.11392">   nsresult rv = SendData(command.get());</span>
<a href="#l3.11393"></a><span id="l3.11393" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11394"></a><span id="l3.11394" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11395"></a><span id="l3.11395" class="difflineminus">-}</span>
<a href="#l3.11396"></a><span id="l3.11396" class="difflineminus">-</span>
<a href="#l3.11397"></a><span id="l3.11397" class="difflineminus">-void nsImapProtocol::Idle()</span>
<a href="#l3.11398"></a><span id="l3.11398" class="difflineminus">-{</span>
<a href="#l3.11399"></a><span id="l3.11399" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11400"></a><span id="l3.11400" class="difflineplus">+}</span>
<a href="#l3.11401"></a><span id="l3.11401" class="difflineplus">+</span>
<a href="#l3.11402"></a><span id="l3.11402" class="difflineplus">+void nsImapProtocol::Idle() {</span>
<a href="#l3.11403"></a><span id="l3.11403">   IncrementCommandTagNumber();</span>
<a href="#l3.11404"></a><span id="l3.11404"> </span>
<a href="#l3.11405"></a><span id="l3.11405" class="difflineminus">-  if (m_urlInProgress)</span>
<a href="#l3.11406"></a><span id="l3.11406" class="difflineminus">-    return;</span>
<a href="#l3.11407"></a><span id="l3.11407" class="difflineminus">-  nsAutoCString command (GetServerCommandTag());</span>
<a href="#l3.11408"></a><span id="l3.11408" class="difflineplus">+  if (m_urlInProgress) return;</span>
<a href="#l3.11409"></a><span id="l3.11409" class="difflineplus">+  nsAutoCString command(GetServerCommandTag());</span>
<a href="#l3.11410"></a><span id="l3.11410">   command += &quot; IDLE&quot; CRLF;</span>
<a href="#l3.11411"></a><span id="l3.11411">   nsresult rv = SendData(command.get());</span>
<a href="#l3.11412"></a><span id="l3.11412" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11413"></a><span id="l3.11413" class="difflineminus">-  {</span>
<a href="#l3.11414"></a><span id="l3.11414" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.11415"></a><span id="l3.11415">     // we'll just get back a continuation char at first.</span>
<a href="#l3.11416"></a><span id="l3.11416">     // + idling...</span>
<a href="#l3.11417"></a><span id="l3.11417">     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11418"></a><span id="l3.11418" class="difflineminus">-    if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.11419"></a><span id="l3.11419" class="difflineminus">-    {</span>
<a href="#l3.11420"></a><span id="l3.11420" class="difflineplus">+    if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.11421"></a><span id="l3.11421">       m_idle = true;</span>
<a href="#l3.11422"></a><span id="l3.11422" class="difflineminus">-      // this will cause us to get notified of data or the socket getting closed.</span>
<a href="#l3.11423"></a><span id="l3.11423" class="difflineminus">-      // That notification will occur on the socket transport thread - we just</span>
<a href="#l3.11424"></a><span id="l3.11424" class="difflineminus">-      // need to poke a monitor so the imap thread will do a blocking read</span>
<a href="#l3.11425"></a><span id="l3.11425" class="difflineminus">-      // and parse the data.</span>
<a href="#l3.11426"></a><span id="l3.11426" class="difflineminus">-      nsCOMPtr &lt;nsIAsyncInputStream&gt; asyncInputStream = do_QueryInterface(m_inputStream);</span>
<a href="#l3.11427"></a><span id="l3.11427" class="difflineminus">-      if (asyncInputStream)</span>
<a href="#l3.11428"></a><span id="l3.11428" class="difflineminus">-        asyncInputStream-&gt;AsyncWait(this, 0, 0, nullptr);</span>
<a href="#l3.11429"></a><span id="l3.11429" class="difflineminus">-    }</span>
<a href="#l3.11430"></a><span id="l3.11430" class="difflineminus">-    else</span>
<a href="#l3.11431"></a><span id="l3.11431" class="difflineminus">-    {</span>
<a href="#l3.11432"></a><span id="l3.11432" class="difflineplus">+      // this will cause us to get notified of data or the socket getting</span>
<a href="#l3.11433"></a><span id="l3.11433" class="difflineplus">+      // closed. That notification will occur on the socket transport thread -</span>
<a href="#l3.11434"></a><span id="l3.11434" class="difflineplus">+      // we just need to poke a monitor so the imap thread will do a blocking</span>
<a href="#l3.11435"></a><span id="l3.11435" class="difflineplus">+      // read and parse the data.</span>
<a href="#l3.11436"></a><span id="l3.11436" class="difflineplus">+      nsCOMPtr&lt;nsIAsyncInputStream&gt; asyncInputStream =</span>
<a href="#l3.11437"></a><span id="l3.11437" class="difflineplus">+          do_QueryInterface(m_inputStream);</span>
<a href="#l3.11438"></a><span id="l3.11438" class="difflineplus">+      if (asyncInputStream) asyncInputStream-&gt;AsyncWait(this, 0, 0, nullptr);</span>
<a href="#l3.11439"></a><span id="l3.11439" class="difflineplus">+    } else {</span>
<a href="#l3.11440"></a><span id="l3.11440">       m_idle = false;</span>
<a href="#l3.11441"></a><span id="l3.11441">     }</span>
<a href="#l3.11442"></a><span id="l3.11442">   }</span>
<a href="#l3.11443"></a><span id="l3.11443"> }</span>
<a href="#l3.11444"></a><span id="l3.11444"> </span>
<a href="#l3.11445"></a><span id="l3.11445"> // until we can fix the hang on shutdown waiting for server</span>
<a href="#l3.11446"></a><span id="l3.11446"> // responses, we need to not wait for the server response</span>
<a href="#l3.11447"></a><span id="l3.11447"> // on shutdown.</span>
<a href="#l3.11448"></a><span id="l3.11448" class="difflineminus">-void nsImapProtocol::EndIdle(bool waitForResponse /* = true */)</span>
<a href="#l3.11449"></a><span id="l3.11449" class="difflineminus">-{</span>
<a href="#l3.11450"></a><span id="l3.11450" class="difflineminus">-  // clear the async wait - otherwise, we seem to have trouble doing a blocking read</span>
<a href="#l3.11451"></a><span id="l3.11451" class="difflineminus">-  nsCOMPtr &lt;nsIAsyncInputStream&gt; asyncInputStream = do_QueryInterface(m_inputStream);</span>
<a href="#l3.11452"></a><span id="l3.11452" class="difflineminus">-  if (asyncInputStream)</span>
<a href="#l3.11453"></a><span id="l3.11453" class="difflineminus">-    asyncInputStream-&gt;AsyncWait(nullptr, 0, 0, nullptr);</span>
<a href="#l3.11454"></a><span id="l3.11454" class="difflineplus">+void nsImapProtocol::EndIdle(bool waitForResponse /* = true */) {</span>
<a href="#l3.11455"></a><span id="l3.11455" class="difflineplus">+  // clear the async wait - otherwise, we seem to have trouble doing a blocking</span>
<a href="#l3.11456"></a><span id="l3.11456" class="difflineplus">+  // read</span>
<a href="#l3.11457"></a><span id="l3.11457" class="difflineplus">+  nsCOMPtr&lt;nsIAsyncInputStream&gt; asyncInputStream =</span>
<a href="#l3.11458"></a><span id="l3.11458" class="difflineplus">+      do_QueryInterface(m_inputStream);</span>
<a href="#l3.11459"></a><span id="l3.11459" class="difflineplus">+  if (asyncInputStream) asyncInputStream-&gt;AsyncWait(nullptr, 0, 0, nullptr);</span>
<a href="#l3.11460"></a><span id="l3.11460">   nsresult rv = SendData(&quot;DONE&quot; CRLF);</span>
<a href="#l3.11461"></a><span id="l3.11461">   // set a short timeout if we don't want to wait for a response</span>
<a href="#l3.11462"></a><span id="l3.11462">   if (m_transport &amp;&amp; !waitForResponse)</span>
<a href="#l3.11463"></a><span id="l3.11463">     m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE, 5);</span>
<a href="#l3.11464"></a><span id="l3.11464" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11465"></a><span id="l3.11465" class="difflineminus">-  {</span>
<a href="#l3.11466"></a><span id="l3.11466" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.11467"></a><span id="l3.11467">     m_idle = false;</span>
<a href="#l3.11468"></a><span id="l3.11468">     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11469"></a><span id="l3.11469">   }</span>
<a href="#l3.11470"></a><span id="l3.11470">   m_imapMailFolderSink = nullptr;</span>
<a href="#l3.11471"></a><span id="l3.11471"> }</span>
<a href="#l3.11472"></a><span id="l3.11472"> </span>
<a href="#l3.11473"></a><span id="l3.11473" class="difflineminus">-</span>
<a href="#l3.11474"></a><span id="l3.11474" class="difflineminus">-void nsImapProtocol::Search(const char * searchCriteria,</span>
<a href="#l3.11475"></a><span id="l3.11475" class="difflineminus">-                            bool useUID,</span>
<a href="#l3.11476"></a><span id="l3.11476" class="difflineminus">-                            bool notifyHit /* true */)</span>
<a href="#l3.11477"></a><span id="l3.11477" class="difflineminus">-{</span>
<a href="#l3.11478"></a><span id="l3.11478" class="difflineplus">+void nsImapProtocol::Search(const char *searchCriteria, bool useUID,</span>
<a href="#l3.11479"></a><span id="l3.11479" class="difflineplus">+                            bool notifyHit /* true */) {</span>
<a href="#l3.11480"></a><span id="l3.11480">   m_notifySearchHit = notifyHit;</span>
<a href="#l3.11481"></a><span id="l3.11481">   ProgressEventFunctionUsingName(&quot;imapStatusSearchMailbox&quot;);</span>
<a href="#l3.11482"></a><span id="l3.11482">   IncrementCommandTagNumber();</span>
<a href="#l3.11483"></a><span id="l3.11483"> </span>
<a href="#l3.11484"></a><span id="l3.11484">   nsCString protocolString(GetServerCommandTag());</span>
<a href="#l3.11485"></a><span id="l3.11485">   // the searchCriteria string contains the 'search ....' string</span>
<a href="#l3.11486"></a><span id="l3.11486" class="difflineminus">-  if (useUID)</span>
<a href="#l3.11487"></a><span id="l3.11487" class="difflineminus">-     protocolString.AppendLiteral(&quot; uid&quot;);</span>
<a href="#l3.11488"></a><span id="l3.11488" class="difflineplus">+  if (useUID) protocolString.AppendLiteral(&quot; uid&quot;);</span>
<a href="#l3.11489"></a><span id="l3.11489">   protocolString.Append(' ');</span>
<a href="#l3.11490"></a><span id="l3.11490">   protocolString.Append(searchCriteria);</span>
<a href="#l3.11491"></a><span id="l3.11491">   // the search criteria can contain string literals, which means we</span>
<a href="#l3.11492"></a><span id="l3.11492">   // need to break up the protocol string by CRLF's, and after sending CRLF,</span>
<a href="#l3.11493"></a><span id="l3.11493">   // wait for the server to respond OK before sending more data</span>
<a href="#l3.11494"></a><span id="l3.11494">   nsresult rv;</span>
<a href="#l3.11495"></a><span id="l3.11495">   int32_t crlfIndex;</span>
<a href="#l3.11496"></a><span id="l3.11496" class="difflineminus">-  while ((crlfIndex = protocolString.Find(CRLF)) != kNotFound &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.11497"></a><span id="l3.11497" class="difflineminus">-  {</span>
<a href="#l3.11498"></a><span id="l3.11498" class="difflineplus">+  while ((crlfIndex = protocolString.Find(CRLF)) != kNotFound &amp;&amp;</span>
<a href="#l3.11499"></a><span id="l3.11499" class="difflineplus">+         !DeathSignalReceived()) {</span>
<a href="#l3.11500"></a><span id="l3.11500">     nsAutoCString tempProtocolString;</span>
<a href="#l3.11501"></a><span id="l3.11501">     tempProtocolString = StringHead(protocolString, crlfIndex + 2);</span>
<a href="#l3.11502"></a><span id="l3.11502">     rv = SendData(tempProtocolString.get());</span>
<a href="#l3.11503"></a><span id="l3.11503" class="difflineminus">-    if (NS_FAILED(rv))</span>
<a href="#l3.11504"></a><span id="l3.11504" class="difflineminus">-      return;</span>
<a href="#l3.11505"></a><span id="l3.11505" class="difflineplus">+    if (NS_FAILED(rv)) return;</span>
<a href="#l3.11506"></a><span id="l3.11506">     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11507"></a><span id="l3.11507">     protocolString.Cut(0, crlfIndex + 2);</span>
<a href="#l3.11508"></a><span id="l3.11508">   }</span>
<a href="#l3.11509"></a><span id="l3.11509">   protocolString.Append(CRLF);</span>
<a href="#l3.11510"></a><span id="l3.11510"> </span>
<a href="#l3.11511"></a><span id="l3.11511">   rv = SendData(protocolString.get());</span>
<a href="#l3.11512"></a><span id="l3.11512" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11513"></a><span id="l3.11513" class="difflineminus">-     ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11514"></a><span id="l3.11514" class="difflineminus">-}</span>
<a href="#l3.11515"></a><span id="l3.11515" class="difflineminus">-</span>
<a href="#l3.11516"></a><span id="l3.11516" class="difflineminus">-void nsImapProtocol::Copy(const char * messageList,</span>
<a href="#l3.11517"></a><span id="l3.11517" class="difflineminus">-                          const char *destinationMailbox,</span>
<a href="#l3.11518"></a><span id="l3.11518" class="difflineminus">-                          bool idsAreUid)</span>
<a href="#l3.11519"></a><span id="l3.11519" class="difflineminus">-{</span>
<a href="#l3.11520"></a><span id="l3.11520" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.11521"></a><span id="l3.11521" class="difflineplus">+}</span>
<a href="#l3.11522"></a><span id="l3.11522" class="difflineplus">+</span>
<a href="#l3.11523"></a><span id="l3.11523" class="difflineplus">+void nsImapProtocol::Copy(const char *messageList,</span>
<a href="#l3.11524"></a><span id="l3.11524" class="difflineplus">+                          const char *destinationMailbox, bool idsAreUid) {</span>
<a href="#l3.11525"></a><span id="l3.11525">   IncrementCommandTagNumber();</span>
<a href="#l3.11526"></a><span id="l3.11526"> </span>
<a href="#l3.11527"></a><span id="l3.11527">   nsCString escapedDestination;</span>
<a href="#l3.11528"></a><span id="l3.11528">   CreateEscapedMailboxName(destinationMailbox, escapedDestination);</span>
<a href="#l3.11529"></a><span id="l3.11529"> </span>
<a href="#l3.11530"></a><span id="l3.11530">   // turn messageList back into key array and then back into a message id list,</span>
<a href="#l3.11531"></a><span id="l3.11531">   // but use the flag state to handle ranges correctly.</span>
<a href="#l3.11532"></a><span id="l3.11532">   nsCString messageIdList;</span>
<a href="#l3.11533"></a><span id="l3.11533">   nsTArray&lt;nsMsgKey&gt; msgKeys;</span>
<a href="#l3.11534"></a><span id="l3.11534" class="difflineminus">-  if (idsAreUid)</span>
<a href="#l3.11535"></a><span id="l3.11535" class="difflineminus">-    ParseUidString(messageList, msgKeys);</span>
<a href="#l3.11536"></a><span id="l3.11536" class="difflineplus">+  if (idsAreUid) ParseUidString(messageList, msgKeys);</span>
<a href="#l3.11537"></a><span id="l3.11537"> </span>
<a href="#l3.11538"></a><span id="l3.11538">   int32_t msgCountLeft = msgKeys.Length();</span>
<a href="#l3.11539"></a><span id="l3.11539">   uint32_t msgsHandled = 0;</span>
<a href="#l3.11540"></a><span id="l3.11540"> </span>
<a href="#l3.11541"></a><span id="l3.11541" class="difflineminus">-  do</span>
<a href="#l3.11542"></a><span id="l3.11542" class="difflineminus">-  {</span>
<a href="#l3.11543"></a><span id="l3.11543" class="difflineplus">+  do {</span>
<a href="#l3.11544"></a><span id="l3.11544">     nsCString idString;</span>
<a href="#l3.11545"></a><span id="l3.11545"> </span>
<a href="#l3.11546"></a><span id="l3.11546">     uint32_t msgsToHandle = msgCountLeft;</span>
<a href="#l3.11547"></a><span id="l3.11547">     if (idsAreUid)</span>
<a href="#l3.11548"></a><span id="l3.11548" class="difflineminus">-      AllocateImapUidString(msgKeys.Elements() + msgsHandled, msgsToHandle, m_flagState, idString);</span>
<a href="#l3.11549"></a><span id="l3.11549" class="difflineplus">+      AllocateImapUidString(msgKeys.Elements() + msgsHandled, msgsToHandle,</span>
<a href="#l3.11550"></a><span id="l3.11550" class="difflineplus">+                            m_flagState, idString);</span>
<a href="#l3.11551"></a><span id="l3.11551">     else</span>
<a href="#l3.11552"></a><span id="l3.11552">       idString.Assign(messageList);</span>
<a href="#l3.11553"></a><span id="l3.11553"> </span>
<a href="#l3.11554"></a><span id="l3.11554">     msgsHandled += msgsToHandle;</span>
<a href="#l3.11555"></a><span id="l3.11555">     msgCountLeft -= msgsToHandle;</span>
<a href="#l3.11556"></a><span id="l3.11556"> </span>
<a href="#l3.11557"></a><span id="l3.11557">     IncrementCommandTagNumber();</span>
<a href="#l3.11558"></a><span id="l3.11558">     nsAutoCString protocolString(GetServerCommandTag());</span>
<a href="#l3.11559"></a><span id="l3.11559" class="difflineminus">-    if (idsAreUid)</span>
<a href="#l3.11560"></a><span id="l3.11560" class="difflineminus">-      protocolString.AppendLiteral(&quot; uid&quot;);</span>
<a href="#l3.11561"></a><span id="l3.11561" class="difflineplus">+    if (idsAreUid) protocolString.AppendLiteral(&quot; uid&quot;);</span>
<a href="#l3.11562"></a><span id="l3.11562">     // If it's a MOVE operation on aol servers then use 'xaol-move' cmd.</span>
<a href="#l3.11563"></a><span id="l3.11563">     if ((m_imapAction == nsIImapUrl::nsImapOnlineMove) &amp;&amp;</span>
<a href="#l3.11564"></a><span id="l3.11564">         GetServerStateParser().ServerIsAOLServer())</span>
<a href="#l3.11565"></a><span id="l3.11565">       protocolString.AppendLiteral(&quot; xaol-move &quot;);</span>
<a href="#l3.11566"></a><span id="l3.11566">     else if ((m_imapAction == nsIImapUrl::nsImapOnlineMove) &amp;&amp;</span>
<a href="#l3.11567"></a><span id="l3.11567">              GetServerStateParser().GetCapabilityFlag() &amp; kHasMoveCapability)</span>
<a href="#l3.11568"></a><span id="l3.11568">       protocolString.AppendLiteral(&quot; move &quot;);</span>
<a href="#l3.11569"></a><span id="l3.11569">     else</span>
<a href="#l3.11570"></a><span id="l3.11570">       protocolString.AppendLiteral(&quot; copy &quot;);</span>
<a href="#l3.11571"></a><span id="l3.11571"> </span>
<a href="#l3.11572"></a><span id="l3.11572" class="difflineminus">-</span>
<a href="#l3.11573"></a><span id="l3.11573">     protocolString.Append(idString);</span>
<a href="#l3.11574"></a><span id="l3.11574">     protocolString.AppendLiteral(&quot; \&quot;&quot;);</span>
<a href="#l3.11575"></a><span id="l3.11575">     protocolString.Append(escapedDestination);</span>
<a href="#l3.11576"></a><span id="l3.11576">     protocolString.AppendLiteral(&quot;\&quot;&quot; CRLF);</span>
<a href="#l3.11577"></a><span id="l3.11577"> </span>
<a href="#l3.11578"></a><span id="l3.11578">     nsresult rv = SendData(protocolString.get());</span>
<a href="#l3.11579"></a><span id="l3.11579" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.11580"></a><span id="l3.11580" class="difflineminus">-       ParseIMAPandCheckForNewMail(protocolString.get());</span>
<a href="#l3.11581"></a><span id="l3.11581" class="difflineminus">-  }</span>
<a href="#l3.11582"></a><span id="l3.11582" class="difflineminus">-  while (msgCountLeft &gt; 0 &amp;&amp; !DeathSignalReceived());</span>
<a href="#l3.11583"></a><span id="l3.11583" class="difflineminus">-}</span>
<a href="#l3.11584"></a><span id="l3.11584" class="difflineminus">-</span>
<a href="#l3.11585"></a><span id="l3.11585" class="difflineminus">-void nsImapProtocol::NthLevelChildList(const char* onlineMailboxPrefix,</span>
<a href="#l3.11586"></a><span id="l3.11586" class="difflineminus">-                                       int32_t depth)</span>
<a href="#l3.11587"></a><span id="l3.11587" class="difflineminus">-{</span>
<a href="#l3.11588"></a><span id="l3.11588" class="difflineminus">-  NS_ASSERTION (depth &gt;= 0,</span>
<a href="#l3.11589"></a><span id="l3.11589" class="difflineminus">-                  &quot;Oops ... depth must be equal or greater than 0&quot;);</span>
<a href="#l3.11590"></a><span id="l3.11590" class="difflineplus">+    if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail(protocolString.get());</span>
<a href="#l3.11591"></a><span id="l3.11591" class="difflineplus">+  } while (msgCountLeft &gt; 0 &amp;&amp; !DeathSignalReceived());</span>
<a href="#l3.11592"></a><span id="l3.11592" class="difflineplus">+}</span>
<a href="#l3.11593"></a><span id="l3.11593" class="difflineplus">+</span>
<a href="#l3.11594"></a><span id="l3.11594" class="difflineplus">+void nsImapProtocol::NthLevelChildList(const char *onlineMailboxPrefix,</span>
<a href="#l3.11595"></a><span id="l3.11595" class="difflineplus">+                                       int32_t depth) {</span>
<a href="#l3.11596"></a><span id="l3.11596" class="difflineplus">+  NS_ASSERTION(depth &gt;= 0, &quot;Oops ... depth must be equal or greater than 0&quot;);</span>
<a href="#l3.11597"></a><span id="l3.11597">   if (depth &lt; 0) return;</span>
<a href="#l3.11598"></a><span id="l3.11598"> </span>
<a href="#l3.11599"></a><span id="l3.11599" class="difflineminus">-  nsCString truncatedPrefix (onlineMailboxPrefix);</span>
<a href="#l3.11600"></a><span id="l3.11600" class="difflineplus">+  nsCString truncatedPrefix(onlineMailboxPrefix);</span>
<a href="#l3.11601"></a><span id="l3.11601">   char16_t slash = '/';</span>
<a href="#l3.11602"></a><span id="l3.11602">   if (truncatedPrefix.Last() == slash)</span>
<a href="#l3.11603"></a><span id="l3.11603" class="difflineminus">-        truncatedPrefix.SetLength(truncatedPrefix.Length()-1);</span>
<a href="#l3.11604"></a><span id="l3.11604" class="difflineplus">+    truncatedPrefix.SetLength(truncatedPrefix.Length() - 1);</span>
<a href="#l3.11605"></a><span id="l3.11605"> </span>
<a href="#l3.11606"></a><span id="l3.11606">   nsAutoCString pattern(truncatedPrefix);</span>
<a href="#l3.11607"></a><span id="l3.11607">   nsAutoCString suffix;</span>
<a href="#l3.11608"></a><span id="l3.11608">   int count = 0;</span>
<a href="#l3.11609"></a><span id="l3.11609">   char separator = 0;</span>
<a href="#l3.11610"></a><span id="l3.11610">   m_runningUrl-&gt;GetOnlineSubDirSeparator(&amp;separator);</span>
<a href="#l3.11611"></a><span id="l3.11611">   suffix.Assign(separator);</span>
<a href="#l3.11612"></a><span id="l3.11612">   suffix += '%';</span>
<a href="#l3.11613"></a><span id="l3.11613"> </span>
<a href="#l3.11614"></a><span id="l3.11614" class="difflineminus">-  while (count &lt; depth)</span>
<a href="#l3.11615"></a><span id="l3.11615" class="difflineminus">-  {</span>
<a href="#l3.11616"></a><span id="l3.11616" class="difflineminus">-      pattern += suffix;</span>
<a href="#l3.11617"></a><span id="l3.11617" class="difflineminus">-      count++;</span>
<a href="#l3.11618"></a><span id="l3.11618" class="difflineminus">-      List(pattern.get(), false);</span>
<a href="#l3.11619"></a><span id="l3.11619" class="difflineminus">-  }</span>
<a href="#l3.11620"></a><span id="l3.11620" class="difflineminus">-}</span>
<a href="#l3.11621"></a><span id="l3.11621" class="difflineminus">-</span>
<a href="#l3.11622"></a><span id="l3.11622" class="difflineminus">-void nsImapProtocol::ProcessAuthenticatedStateURL()</span>
<a href="#l3.11623"></a><span id="l3.11623" class="difflineminus">-{</span>
<a href="#l3.11624"></a><span id="l3.11624" class="difflineplus">+  while (count &lt; depth) {</span>
<a href="#l3.11625"></a><span id="l3.11625" class="difflineplus">+    pattern += suffix;</span>
<a href="#l3.11626"></a><span id="l3.11626" class="difflineplus">+    count++;</span>
<a href="#l3.11627"></a><span id="l3.11627" class="difflineplus">+    List(pattern.get(), false);</span>
<a href="#l3.11628"></a><span id="l3.11628" class="difflineplus">+  }</span>
<a href="#l3.11629"></a><span id="l3.11629" class="difflineplus">+}</span>
<a href="#l3.11630"></a><span id="l3.11630" class="difflineplus">+</span>
<a href="#l3.11631"></a><span id="l3.11631" class="difflineplus">+void nsImapProtocol::ProcessAuthenticatedStateURL() {</span>
<a href="#l3.11632"></a><span id="l3.11632">   nsImapAction imapAction;</span>
<a href="#l3.11633"></a><span id="l3.11633" class="difflineminus">-  char * sourceMailbox = nullptr;</span>
<a href="#l3.11634"></a><span id="l3.11634" class="difflineplus">+  char *sourceMailbox = nullptr;</span>
<a href="#l3.11635"></a><span id="l3.11635">   m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.11636"></a><span id="l3.11636"> </span>
<a href="#l3.11637"></a><span id="l3.11637">   // switch off of the imap url action and take an appropriate action</span>
<a href="#l3.11638"></a><span id="l3.11638" class="difflineminus">-  switch (imapAction)</span>
<a href="#l3.11639"></a><span id="l3.11639" class="difflineminus">-  {</span>
<a href="#l3.11640"></a><span id="l3.11640" class="difflineplus">+  switch (imapAction) {</span>
<a href="#l3.11641"></a><span id="l3.11641">     case nsIImapUrl::nsImapLsubFolders:</span>
<a href="#l3.11642"></a><span id="l3.11642">       OnLSubFolders();</span>
<a href="#l3.11643"></a><span id="l3.11643">       break;</span>
<a href="#l3.11644"></a><span id="l3.11644">     case nsIImapUrl::nsImapAppendMsgFromFile:</span>
<a href="#l3.11645"></a><span id="l3.11645">       OnAppendMsgFromFile();</span>
<a href="#l3.11646"></a><span id="l3.11646">       break;</span>
<a href="#l3.11647"></a><span id="l3.11647">     case nsIImapUrl::nsImapDiscoverAllBoxesUrl:</span>
<a href="#l3.11648"></a><span id="l3.11648" class="difflineminus">-      NS_ASSERTION (!GetSubscribingNow(),</span>
<a href="#l3.11649"></a><span id="l3.11649" class="difflineminus">-                      &quot;Oops ... should not get here from subscribe UI&quot;);</span>
<a href="#l3.11650"></a><span id="l3.11650" class="difflineplus">+      NS_ASSERTION(!GetSubscribingNow(),</span>
<a href="#l3.11651"></a><span id="l3.11651" class="difflineplus">+                   &quot;Oops ... should not get here from subscribe UI&quot;);</span>
<a href="#l3.11652"></a><span id="l3.11652">       DiscoverMailboxList();</span>
<a href="#l3.11653"></a><span id="l3.11653">       break;</span>
<a href="#l3.11654"></a><span id="l3.11654">     case nsIImapUrl::nsImapDiscoverAllAndSubscribedBoxesUrl:</span>
<a href="#l3.11655"></a><span id="l3.11655">       DiscoverAllAndSubscribedBoxes();</span>
<a href="#l3.11656"></a><span id="l3.11656">       break;</span>
<a href="#l3.11657"></a><span id="l3.11657">     case nsIImapUrl::nsImapCreateFolder:</span>
<a href="#l3.11658"></a><span id="l3.11658">       sourceMailbox = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.11659"></a><span id="l3.11659">       OnCreateFolder(sourceMailbox);</span>
<a href="#l3.11660"></a><span id="l3.11660">       break;</span>
<a href="#l3.11661"></a><span id="l3.11661">     case nsIImapUrl::nsImapEnsureExistsFolder:</span>
<a href="#l3.11662"></a><span id="l3.11662">       sourceMailbox = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.11663"></a><span id="l3.11663">       OnEnsureExistsFolder(sourceMailbox);</span>
<a href="#l3.11664"></a><span id="l3.11664">       break;</span>
<a href="#l3.11665"></a><span id="l3.11665" class="difflineminus">-    case nsIImapUrl::nsImapDiscoverChildrenUrl:</span>
<a href="#l3.11666"></a><span id="l3.11666" class="difflineminus">-      {</span>
<a href="#l3.11667"></a><span id="l3.11667" class="difflineminus">-        char *canonicalParent = nullptr;</span>
<a href="#l3.11668"></a><span id="l3.11668" class="difflineminus">-        m_runningUrl-&gt;CreateServerSourceFolderPathString(&amp;canonicalParent);</span>
<a href="#l3.11669"></a><span id="l3.11669" class="difflineminus">-        if (canonicalParent)</span>
<a href="#l3.11670"></a><span id="l3.11670" class="difflineminus">-        {</span>
<a href="#l3.11671"></a><span id="l3.11671" class="difflineminus">-          NthLevelChildList(canonicalParent, 2);</span>
<a href="#l3.11672"></a><span id="l3.11672" class="difflineminus">-          PR_Free(canonicalParent);</span>
<a href="#l3.11673"></a><span id="l3.11673" class="difflineminus">-        }</span>
<a href="#l3.11674"></a><span id="l3.11674" class="difflineminus">-        break;</span>
<a href="#l3.11675"></a><span id="l3.11675" class="difflineplus">+    case nsIImapUrl::nsImapDiscoverChildrenUrl: {</span>
<a href="#l3.11676"></a><span id="l3.11676" class="difflineplus">+      char *canonicalParent = nullptr;</span>
<a href="#l3.11677"></a><span id="l3.11677" class="difflineplus">+      m_runningUrl-&gt;CreateServerSourceFolderPathString(&amp;canonicalParent);</span>
<a href="#l3.11678"></a><span id="l3.11678" class="difflineplus">+      if (canonicalParent) {</span>
<a href="#l3.11679"></a><span id="l3.11679" class="difflineplus">+        NthLevelChildList(canonicalParent, 2);</span>
<a href="#l3.11680"></a><span id="l3.11680" class="difflineplus">+        PR_Free(canonicalParent);</span>
<a href="#l3.11681"></a><span id="l3.11681">       }</span>
<a href="#l3.11682"></a><span id="l3.11682" class="difflineplus">+      break;</span>
<a href="#l3.11683"></a><span id="l3.11683" class="difflineplus">+    }</span>
<a href="#l3.11684"></a><span id="l3.11684">     case nsIImapUrl::nsImapSubscribe:</span>
<a href="#l3.11685"></a><span id="l3.11685">       sourceMailbox = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.11686"></a><span id="l3.11686" class="difflineminus">-      OnSubscribe(sourceMailbox); // used to be called subscribe</span>
<a href="#l3.11687"></a><span id="l3.11687" class="difflineminus">-</span>
<a href="#l3.11688"></a><span id="l3.11688" class="difflineminus">-      if (GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l3.11689"></a><span id="l3.11689" class="difflineminus">-      {</span>
<a href="#l3.11690"></a><span id="l3.11690" class="difflineplus">+      OnSubscribe(sourceMailbox);  // used to be called subscribe</span>
<a href="#l3.11691"></a><span id="l3.11691" class="difflineplus">+</span>
<a href="#l3.11692"></a><span id="l3.11692" class="difflineplus">+      if (GetServerStateParser().LastCommandSuccessful()) {</span>
<a href="#l3.11693"></a><span id="l3.11693">         bool shouldList;</span>
<a href="#l3.11694"></a><span id="l3.11694">         // if url is an external click url, then we should list the folder</span>
<a href="#l3.11695"></a><span id="l3.11695">         // after subscribing to it, so we can select it.</span>
<a href="#l3.11696"></a><span id="l3.11696">         m_runningUrl-&gt;GetExternalLinkUrl(&amp;shouldList);</span>
<a href="#l3.11697"></a><span id="l3.11697" class="difflineminus">-        if (shouldList)</span>
<a href="#l3.11698"></a><span id="l3.11698" class="difflineminus">-          OnListFolder(sourceMailbox, true);</span>
<a href="#l3.11699"></a><span id="l3.11699" class="difflineplus">+        if (shouldList) OnListFolder(sourceMailbox, true);</span>
<a href="#l3.11700"></a><span id="l3.11700">       }</span>
<a href="#l3.11701"></a><span id="l3.11701">       break;</span>
<a href="#l3.11702"></a><span id="l3.11702">     case nsIImapUrl::nsImapUnsubscribe:</span>
<a href="#l3.11703"></a><span id="l3.11703">       sourceMailbox = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.11704"></a><span id="l3.11704">       OnUnsubscribe(sourceMailbox);</span>
<a href="#l3.11705"></a><span id="l3.11705">       break;</span>
<a href="#l3.11706"></a><span id="l3.11706">     case nsIImapUrl::nsImapRefreshACL:</span>
<a href="#l3.11707"></a><span id="l3.11707">       sourceMailbox = OnCreateServerSourceFolderPathString();</span>
<a href="#l3.11708"></a><span id="l3.11708" class="difflineat">@@ -8459,472 +7732,422 @@ void nsImapProtocol::ProcessAuthenticate</span>
<a href="#l3.11709"></a><span id="l3.11709">     case nsIImapUrl::nsImapVerifylogon:</span>
<a href="#l3.11710"></a><span id="l3.11710">       break;</span>
<a href="#l3.11711"></a><span id="l3.11711">     default:</span>
<a href="#l3.11712"></a><span id="l3.11712">       break;</span>
<a href="#l3.11713"></a><span id="l3.11713">   }</span>
<a href="#l3.11714"></a><span id="l3.11714">   PR_Free(sourceMailbox);</span>
<a href="#l3.11715"></a><span id="l3.11715"> }</span>
<a href="#l3.11716"></a><span id="l3.11716"> </span>
<a href="#l3.11717"></a><span id="l3.11717" class="difflineminus">-void nsImapProtocol::ProcessAfterAuthenticated()</span>
<a href="#l3.11718"></a><span id="l3.11718" class="difflineminus">-{</span>
<a href="#l3.11719"></a><span id="l3.11719" class="difflineplus">+void nsImapProtocol::ProcessAfterAuthenticated() {</span>
<a href="#l3.11720"></a><span id="l3.11720">   // if we're a netscape server, and we haven't got the admin url, get it</span>
<a href="#l3.11721"></a><span id="l3.11721">   bool hasAdminUrl = true;</span>
<a href="#l3.11722"></a><span id="l3.11722"> </span>
<a href="#l3.11723"></a><span id="l3.11723" class="difflineminus">-  if (NS_SUCCEEDED(m_hostSessionList-&gt;GetHostHasAdminURL(GetImapServerKey(), hasAdminUrl))</span>
<a href="#l3.11724"></a><span id="l3.11724" class="difflineminus">-    &amp;&amp; !hasAdminUrl)</span>
<a href="#l3.11725"></a><span id="l3.11725" class="difflineminus">-  {</span>
<a href="#l3.11726"></a><span id="l3.11726" class="difflineminus">-    if (GetServerStateParser().ServerHasServerInfo())</span>
<a href="#l3.11727"></a><span id="l3.11727" class="difflineminus">-    {</span>
<a href="#l3.11728"></a><span id="l3.11728" class="difflineplus">+  if (NS_SUCCEEDED(m_hostSessionList-&gt;GetHostHasAdminURL(GetImapServerKey(),</span>
<a href="#l3.11729"></a><span id="l3.11729" class="difflineplus">+                                                         hasAdminUrl)) &amp;&amp;</span>
<a href="#l3.11730"></a><span id="l3.11730" class="difflineplus">+      !hasAdminUrl) {</span>
<a href="#l3.11731"></a><span id="l3.11731" class="difflineplus">+    if (GetServerStateParser().ServerHasServerInfo()) {</span>
<a href="#l3.11732"></a><span id="l3.11732">       XServerInfo();</span>
<a href="#l3.11733"></a><span id="l3.11733" class="difflineminus">-      if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; m_imapServerSink)</span>
<a href="#l3.11734"></a><span id="l3.11734" class="difflineminus">-      {</span>
<a href="#l3.11735"></a><span id="l3.11735" class="difflineminus">-        m_imapServerSink-&gt;SetMailServerUrls(GetServerStateParser().GetMailAccountUrl(),</span>
<a href="#l3.11736"></a><span id="l3.11736" class="difflineminus">-          GetServerStateParser().GetManageListsUrl(),</span>
<a href="#l3.11737"></a><span id="l3.11737" class="difflineminus">-          GetServerStateParser().GetManageFiltersUrl());</span>
<a href="#l3.11738"></a><span id="l3.11738" class="difflineplus">+      if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; m_imapServerSink) {</span>
<a href="#l3.11739"></a><span id="l3.11739" class="difflineplus">+        m_imapServerSink-&gt;SetMailServerUrls(</span>
<a href="#l3.11740"></a><span id="l3.11740" class="difflineplus">+            GetServerStateParser().GetMailAccountUrl(),</span>
<a href="#l3.11741"></a><span id="l3.11741" class="difflineplus">+            GetServerStateParser().GetManageListsUrl(),</span>
<a href="#l3.11742"></a><span id="l3.11742" class="difflineplus">+            GetServerStateParser().GetManageFiltersUrl());</span>
<a href="#l3.11743"></a><span id="l3.11743">         // we've tried to ask for it, so don't try again this session.</span>
<a href="#l3.11744"></a><span id="l3.11744">         m_hostSessionList-&gt;SetHostHasAdminURL(GetImapServerKey(), true);</span>
<a href="#l3.11745"></a><span id="l3.11745">       }</span>
<a href="#l3.11746"></a><span id="l3.11746" class="difflineminus">-    }</span>
<a href="#l3.11747"></a><span id="l3.11747" class="difflineminus">-    else if (GetServerStateParser().ServerIsNetscape3xServer())</span>
<a href="#l3.11748"></a><span id="l3.11748" class="difflineminus">-    {</span>
<a href="#l3.11749"></a><span id="l3.11749" class="difflineplus">+    } else if (GetServerStateParser().ServerIsNetscape3xServer()) {</span>
<a href="#l3.11750"></a><span id="l3.11750">       Netscape();</span>
<a href="#l3.11751"></a><span id="l3.11751">       if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; m_imapServerSink)</span>
<a href="#l3.11752"></a><span id="l3.11752" class="difflineminus">-        m_imapServerSink-&gt;SetMailServerUrls(GetServerStateParser().GetMailAccountUrl(),</span>
<a href="#l3.11753"></a><span id="l3.11753" class="difflineminus">-                                            EmptyCString(), EmptyCString());</span>
<a href="#l3.11754"></a><span id="l3.11754" class="difflineminus">-    }</span>
<a href="#l3.11755"></a><span id="l3.11755" class="difflineminus">-  }</span>
<a href="#l3.11756"></a><span id="l3.11756" class="difflineminus">-</span>
<a href="#l3.11757"></a><span id="l3.11757" class="difflineminus">-  if (GetServerStateParser().ServerHasNamespaceCapability())</span>
<a href="#l3.11758"></a><span id="l3.11758" class="difflineminus">-  {</span>
<a href="#l3.11759"></a><span id="l3.11759" class="difflineplus">+        m_imapServerSink-&gt;SetMailServerUrls(</span>
<a href="#l3.11760"></a><span id="l3.11760" class="difflineplus">+            GetServerStateParser().GetMailAccountUrl(), EmptyCString(),</span>
<a href="#l3.11761"></a><span id="l3.11761" class="difflineplus">+            EmptyCString());</span>
<a href="#l3.11762"></a><span id="l3.11762" class="difflineplus">+    }</span>
<a href="#l3.11763"></a><span id="l3.11763" class="difflineplus">+  }</span>
<a href="#l3.11764"></a><span id="l3.11764" class="difflineplus">+</span>
<a href="#l3.11765"></a><span id="l3.11765" class="difflineplus">+  if (GetServerStateParser().ServerHasNamespaceCapability()) {</span>
<a href="#l3.11766"></a><span id="l3.11766">     bool nameSpacesOverridable = false;</span>
<a href="#l3.11767"></a><span id="l3.11767">     bool haveNameSpacesForHost = false;</span>
<a href="#l3.11768"></a><span id="l3.11768" class="difflineminus">-    m_hostSessionList-&gt;GetNamespacesOverridableForHost(GetImapServerKey(), nameSpacesOverridable);</span>
<a href="#l3.11769"></a><span id="l3.11769" class="difflineminus">-    m_hostSessionList-&gt;GetGotNamespacesForHost(GetImapServerKey(), haveNameSpacesForHost);</span>
<a href="#l3.11770"></a><span id="l3.11770" class="difflineminus">-</span>
<a href="#l3.11771"></a><span id="l3.11771" class="difflineminus">-  // mscott: VERIFY THIS CLAUSE!!!!!!!</span>
<a href="#l3.11772"></a><span id="l3.11772" class="difflineminus">-    if (nameSpacesOverridable &amp;&amp; !haveNameSpacesForHost)</span>
<a href="#l3.11773"></a><span id="l3.11773" class="difflineminus">-      Namespace();</span>
<a href="#l3.11774"></a><span id="l3.11774" class="difflineplus">+    m_hostSessionList-&gt;GetNamespacesOverridableForHost(GetImapServerKey(),</span>
<a href="#l3.11775"></a><span id="l3.11775" class="difflineplus">+                                                       nameSpacesOverridable);</span>
<a href="#l3.11776"></a><span id="l3.11776" class="difflineplus">+    m_hostSessionList-&gt;GetGotNamespacesForHost(GetImapServerKey(),</span>
<a href="#l3.11777"></a><span id="l3.11777" class="difflineplus">+                                               haveNameSpacesForHost);</span>
<a href="#l3.11778"></a><span id="l3.11778" class="difflineplus">+</span>
<a href="#l3.11779"></a><span id="l3.11779" class="difflineplus">+    // mscott: VERIFY THIS CLAUSE!!!!!!!</span>
<a href="#l3.11780"></a><span id="l3.11780" class="difflineplus">+    if (nameSpacesOverridable &amp;&amp; !haveNameSpacesForHost) Namespace();</span>
<a href="#l3.11781"></a><span id="l3.11781">   }</span>
<a href="#l3.11782"></a><span id="l3.11782"> </span>
<a href="#l3.11783"></a><span id="l3.11783">   // If the server supports compression, turn it on now.</span>
<a href="#l3.11784"></a><span id="l3.11784">   // Choosing this spot (after login has finished) because</span>
<a href="#l3.11785"></a><span id="l3.11785">   // many proxies (e.g. perdition, nginx) talk IMAP to the</span>
<a href="#l3.11786"></a><span id="l3.11786">   // client until login is finished, then hand off to the</span>
<a href="#l3.11787"></a><span id="l3.11787">   // backend.  If we enable compression early the proxy</span>
<a href="#l3.11788"></a><span id="l3.11788">   // will be confused.</span>
<a href="#l3.11789"></a><span id="l3.11789" class="difflineminus">-  if (UseCompressDeflate())</span>
<a href="#l3.11790"></a><span id="l3.11790" class="difflineminus">-    StartCompressDeflate();</span>
<a href="#l3.11791"></a><span id="l3.11791" class="difflineplus">+  if (UseCompressDeflate()) StartCompressDeflate();</span>
<a href="#l3.11792"></a><span id="l3.11792"> </span>
<a href="#l3.11793"></a><span id="l3.11793">   if ((GetServerStateParser().GetCapabilityFlag() &amp; kHasEnableCapability) &amp;&amp;</span>
<a href="#l3.11794"></a><span id="l3.11794" class="difflineminus">-       UseCondStore())</span>
<a href="#l3.11795"></a><span id="l3.11795" class="difflineplus">+      UseCondStore())</span>
<a href="#l3.11796"></a><span id="l3.11796">     EnableCondStore();</span>
<a href="#l3.11797"></a><span id="l3.11797"> </span>
<a href="#l3.11798"></a><span id="l3.11798">   bool haveIdResponse = false;</span>
<a href="#l3.11799"></a><span id="l3.11799">   if ((GetServerStateParser().GetCapabilityFlag() &amp; kHasIDCapability) &amp;&amp;</span>
<a href="#l3.11800"></a><span id="l3.11800" class="difflineminus">-       m_sendID)</span>
<a href="#l3.11801"></a><span id="l3.11801" class="difflineminus">-  {</span>
<a href="#l3.11802"></a><span id="l3.11802" class="difflineplus">+      m_sendID) {</span>
<a href="#l3.11803"></a><span id="l3.11803">     ID();</span>
<a href="#l3.11804"></a><span id="l3.11804" class="difflineminus">-    if (m_imapServerSink &amp;&amp; !GetServerStateParser().GetServerID().IsEmpty())</span>
<a href="#l3.11805"></a><span id="l3.11805" class="difflineminus">-    {</span>
<a href="#l3.11806"></a><span id="l3.11806" class="difflineplus">+    if (m_imapServerSink &amp;&amp; !GetServerStateParser().GetServerID().IsEmpty()) {</span>
<a href="#l3.11807"></a><span id="l3.11807">       haveIdResponse = true;</span>
<a href="#l3.11808"></a><span id="l3.11808">       // Determine value for m_forceSelect based on config editor</span>
<a href="#l3.11809"></a><span id="l3.11809">       // entries and comparison to imap ID string returned by the server.</span>
<a href="#l3.11810"></a><span id="l3.11810">       m_imapServerSink-&gt;SetServerID(GetServerStateParser().GetServerID());</span>
<a href="#l3.11811"></a><span id="l3.11811" class="difflineminus">-      switch (m_forceSelectValue.get()[0])</span>
<a href="#l3.11812"></a><span id="l3.11812" class="difflineminus">-      {</span>
<a href="#l3.11813"></a><span id="l3.11813" class="difflineminus">-      // Yes: Set to always force even if imap server doesn't need it.</span>
<a href="#l3.11814"></a><span id="l3.11814" class="difflineminus">-      case 'y':</span>
<a href="#l3.11815"></a><span id="l3.11815" class="difflineminus">-      case 'Y':</span>
<a href="#l3.11816"></a><span id="l3.11816" class="difflineminus">-        m_forceSelect = true;</span>
<a href="#l3.11817"></a><span id="l3.11817" class="difflineminus">-        break;</span>
<a href="#l3.11818"></a><span id="l3.11818" class="difflineminus">-</span>
<a href="#l3.11819"></a><span id="l3.11819" class="difflineminus">-      // No: Set to never force a select for this imap server.</span>
<a href="#l3.11820"></a><span id="l3.11820" class="difflineminus">-      case 'n':</span>
<a href="#l3.11821"></a><span id="l3.11821" class="difflineminus">-      case 'N':</span>
<a href="#l3.11822"></a><span id="l3.11822" class="difflineminus">-        m_forceSelect = false;</span>
<a href="#l3.11823"></a><span id="l3.11823" class="difflineminus">-        break;</span>
<a href="#l3.11824"></a><span id="l3.11824" class="difflineminus">-</span>
<a href="#l3.11825"></a><span id="l3.11825" class="difflineminus">-      // Auto: Set to force only if imap server requires it.</span>
<a href="#l3.11826"></a><span id="l3.11826" class="difflineminus">-      default:</span>
<a href="#l3.11827"></a><span id="l3.11827" class="difflineminus">-        nsAutoCString statusString;</span>
<a href="#l3.11828"></a><span id="l3.11828" class="difflineminus">-        m_forceSelect = IsExtraSelectNeeded();</span>
<a href="#l3.11829"></a><span id="l3.11829" class="difflineminus">-        // Setting to &quot;yes-auto&quot; or &quot;no-auto&quot; avoids doing redundant calls to</span>
<a href="#l3.11830"></a><span id="l3.11830" class="difflineminus">-        // IsExtraSelectNeeded() on subsequent ID() occurrences. It also</span>
<a href="#l3.11831"></a><span id="l3.11831" class="difflineminus">-        // provides feedback to the user regarding the detection status.</span>
<a href="#l3.11832"></a><span id="l3.11832" class="difflineminus">-        if (m_forceSelect)</span>
<a href="#l3.11833"></a><span id="l3.11833" class="difflineminus">-        {</span>
<a href="#l3.11834"></a><span id="l3.11834" class="difflineminus">-          // Set preference value to &quot;yes-auto&quot;.</span>
<a href="#l3.11835"></a><span id="l3.11835" class="difflineminus">-          statusString.AssignLiteral(&quot;yes-auto&quot;);</span>
<a href="#l3.11836"></a><span id="l3.11836" class="difflineminus">-        }</span>
<a href="#l3.11837"></a><span id="l3.11837" class="difflineminus">-        else</span>
<a href="#l3.11838"></a><span id="l3.11838" class="difflineminus">-        {</span>
<a href="#l3.11839"></a><span id="l3.11839" class="difflineminus">-          // Set preference value to &quot;no-auto&quot;.</span>
<a href="#l3.11840"></a><span id="l3.11840" class="difflineminus">-          statusString.AssignLiteral(&quot;no-auto&quot;);</span>
<a href="#l3.11841"></a><span id="l3.11841" class="difflineminus">-        }</span>
<a href="#l3.11842"></a><span id="l3.11842" class="difflineminus">-        m_imapServerSink-&gt;SetServerForceSelect(statusString);</span>
<a href="#l3.11843"></a><span id="l3.11843" class="difflineminus">-        break;</span>
<a href="#l3.11844"></a><span id="l3.11844" class="difflineplus">+      switch (m_forceSelectValue.get()[0]) {</span>
<a href="#l3.11845"></a><span id="l3.11845" class="difflineplus">+        // Yes: Set to always force even if imap server doesn't need it.</span>
<a href="#l3.11846"></a><span id="l3.11846" class="difflineplus">+        case 'y':</span>
<a href="#l3.11847"></a><span id="l3.11847" class="difflineplus">+        case 'Y':</span>
<a href="#l3.11848"></a><span id="l3.11848" class="difflineplus">+          m_forceSelect = true;</span>
<a href="#l3.11849"></a><span id="l3.11849" class="difflineplus">+          break;</span>
<a href="#l3.11850"></a><span id="l3.11850" class="difflineplus">+</span>
<a href="#l3.11851"></a><span id="l3.11851" class="difflineplus">+        // No: Set to never force a select for this imap server.</span>
<a href="#l3.11852"></a><span id="l3.11852" class="difflineplus">+        case 'n':</span>
<a href="#l3.11853"></a><span id="l3.11853" class="difflineplus">+        case 'N':</span>
<a href="#l3.11854"></a><span id="l3.11854" class="difflineplus">+          m_forceSelect = false;</span>
<a href="#l3.11855"></a><span id="l3.11855" class="difflineplus">+          break;</span>
<a href="#l3.11856"></a><span id="l3.11856" class="difflineplus">+</span>
<a href="#l3.11857"></a><span id="l3.11857" class="difflineplus">+        // Auto: Set to force only if imap server requires it.</span>
<a href="#l3.11858"></a><span id="l3.11858" class="difflineplus">+        default:</span>
<a href="#l3.11859"></a><span id="l3.11859" class="difflineplus">+          nsAutoCString statusString;</span>
<a href="#l3.11860"></a><span id="l3.11860" class="difflineplus">+          m_forceSelect = IsExtraSelectNeeded();</span>
<a href="#l3.11861"></a><span id="l3.11861" class="difflineplus">+          // Setting to &quot;yes-auto&quot; or &quot;no-auto&quot; avoids doing redundant calls to</span>
<a href="#l3.11862"></a><span id="l3.11862" class="difflineplus">+          // IsExtraSelectNeeded() on subsequent ID() occurrences. It also</span>
<a href="#l3.11863"></a><span id="l3.11863" class="difflineplus">+          // provides feedback to the user regarding the detection status.</span>
<a href="#l3.11864"></a><span id="l3.11864" class="difflineplus">+          if (m_forceSelect) {</span>
<a href="#l3.11865"></a><span id="l3.11865" class="difflineplus">+            // Set preference value to &quot;yes-auto&quot;.</span>
<a href="#l3.11866"></a><span id="l3.11866" class="difflineplus">+            statusString.AssignLiteral(&quot;yes-auto&quot;);</span>
<a href="#l3.11867"></a><span id="l3.11867" class="difflineplus">+          } else {</span>
<a href="#l3.11868"></a><span id="l3.11868" class="difflineplus">+            // Set preference value to &quot;no-auto&quot;.</span>
<a href="#l3.11869"></a><span id="l3.11869" class="difflineplus">+            statusString.AssignLiteral(&quot;no-auto&quot;);</span>
<a href="#l3.11870"></a><span id="l3.11870" class="difflineplus">+          }</span>
<a href="#l3.11871"></a><span id="l3.11871" class="difflineplus">+          m_imapServerSink-&gt;SetServerForceSelect(statusString);</span>
<a href="#l3.11872"></a><span id="l3.11872" class="difflineplus">+          break;</span>
<a href="#l3.11873"></a><span id="l3.11873">       }</span>
<a href="#l3.11874"></a><span id="l3.11874">     }</span>
<a href="#l3.11875"></a><span id="l3.11875">   }</span>
<a href="#l3.11876"></a><span id="l3.11876"> </span>
<a href="#l3.11877"></a><span id="l3.11877">   // If no ID capability or empty ID response, user may still want to</span>
<a href="#l3.11878"></a><span id="l3.11878">   // change &quot;force select&quot;.</span>
<a href="#l3.11879"></a><span id="l3.11879" class="difflineminus">-  if (!haveIdResponse)</span>
<a href="#l3.11880"></a><span id="l3.11880" class="difflineminus">-  {</span>
<a href="#l3.11881"></a><span id="l3.11881" class="difflineminus">-    switch (m_forceSelectValue.get()[0])</span>
<a href="#l3.11882"></a><span id="l3.11882" class="difflineminus">-    {</span>
<a href="#l3.11883"></a><span id="l3.11883" class="difflineminus">-    case 'a':</span>
<a href="#l3.11884"></a><span id="l3.11884" class="difflineminus">-      {</span>
<a href="#l3.11885"></a><span id="l3.11885" class="difflineplus">+  if (!haveIdResponse) {</span>
<a href="#l3.11886"></a><span id="l3.11886" class="difflineplus">+    switch (m_forceSelectValue.get()[0]) {</span>
<a href="#l3.11887"></a><span id="l3.11887" class="difflineplus">+      case 'a': {</span>
<a href="#l3.11888"></a><span id="l3.11888">         // If default &quot;auto&quot;, set to &quot;no-auto&quot; so visible in config editor</span>
<a href="#l3.11889"></a><span id="l3.11889">         // and set/keep m_forceSelect false.</span>
<a href="#l3.11890"></a><span id="l3.11890">         nsAutoCString statusString;</span>
<a href="#l3.11891"></a><span id="l3.11891">         statusString.AssignLiteral(&quot;no-auto&quot;);</span>
<a href="#l3.11892"></a><span id="l3.11892">         m_imapServerSink-&gt;SetServerForceSelect(statusString);</span>
<a href="#l3.11893"></a><span id="l3.11893">         m_forceSelect = false;</span>
<a href="#l3.11894"></a><span id="l3.11894" class="difflineminus">-      }</span>
<a href="#l3.11895"></a><span id="l3.11895" class="difflineminus">-      break;</span>
<a href="#l3.11896"></a><span id="l3.11896" class="difflineminus">-    case 'y':</span>
<a href="#l3.11897"></a><span id="l3.11897" class="difflineminus">-    case 'Y':</span>
<a href="#l3.11898"></a><span id="l3.11898" class="difflineminus">-      m_forceSelect = true;</span>
<a href="#l3.11899"></a><span id="l3.11899" class="difflineminus">-      break;</span>
<a href="#l3.11900"></a><span id="l3.11900" class="difflineminus">-    default:</span>
<a href="#l3.11901"></a><span id="l3.11901" class="difflineminus">-      m_forceSelect = false;</span>
<a href="#l3.11902"></a><span id="l3.11902" class="difflineminus">-    }</span>
<a href="#l3.11903"></a><span id="l3.11903" class="difflineminus">-  }</span>
<a href="#l3.11904"></a><span id="l3.11904" class="difflineminus">-}</span>
<a href="#l3.11905"></a><span id="l3.11905" class="difflineminus">-</span>
<a href="#l3.11906"></a><span id="l3.11906" class="difflineminus">-void nsImapProtocol::SetupMessageFlagsString(nsCString&amp; flagString,</span>
<a href="#l3.11907"></a><span id="l3.11907" class="difflineplus">+      } break;</span>
<a href="#l3.11908"></a><span id="l3.11908" class="difflineplus">+      case 'y':</span>
<a href="#l3.11909"></a><span id="l3.11909" class="difflineplus">+      case 'Y':</span>
<a href="#l3.11910"></a><span id="l3.11910" class="difflineplus">+        m_forceSelect = true;</span>
<a href="#l3.11911"></a><span id="l3.11911" class="difflineplus">+        break;</span>
<a href="#l3.11912"></a><span id="l3.11912" class="difflineplus">+      default:</span>
<a href="#l3.11913"></a><span id="l3.11913" class="difflineplus">+        m_forceSelect = false;</span>
<a href="#l3.11914"></a><span id="l3.11914" class="difflineplus">+    }</span>
<a href="#l3.11915"></a><span id="l3.11915" class="difflineplus">+  }</span>
<a href="#l3.11916"></a><span id="l3.11916" class="difflineplus">+}</span>
<a href="#l3.11917"></a><span id="l3.11917" class="difflineplus">+</span>
<a href="#l3.11918"></a><span id="l3.11918" class="difflineplus">+void nsImapProtocol::SetupMessageFlagsString(nsCString &amp;flagString,</span>
<a href="#l3.11919"></a><span id="l3.11919">                                              imapMessageFlagsType flags,</span>
<a href="#l3.11920"></a><span id="l3.11920" class="difflineminus">-                                             uint16_t userFlags)</span>
<a href="#l3.11921"></a><span id="l3.11921" class="difflineminus">-{</span>
<a href="#l3.11922"></a><span id="l3.11922" class="difflineminus">-    if (flags &amp; kImapMsgSeenFlag)</span>
<a href="#l3.11923"></a><span id="l3.11923" class="difflineminus">-        flagString.AppendLiteral(&quot;\\Seen &quot;);</span>
<a href="#l3.11924"></a><span id="l3.11924" class="difflineminus">-    if (flags &amp; kImapMsgAnsweredFlag)</span>
<a href="#l3.11925"></a><span id="l3.11925" class="difflineminus">-        flagString.AppendLiteral(&quot;\\Answered &quot;);</span>
<a href="#l3.11926"></a><span id="l3.11926" class="difflineminus">-    if (flags &amp; kImapMsgFlaggedFlag)</span>
<a href="#l3.11927"></a><span id="l3.11927" class="difflineminus">-        flagString.AppendLiteral(&quot;\\Flagged &quot;);</span>
<a href="#l3.11928"></a><span id="l3.11928" class="difflineminus">-    if (flags &amp; kImapMsgDeletedFlag)</span>
<a href="#l3.11929"></a><span id="l3.11929" class="difflineminus">-        flagString.AppendLiteral(&quot;\\Deleted &quot;);</span>
<a href="#l3.11930"></a><span id="l3.11930" class="difflineminus">-    if (flags &amp; kImapMsgDraftFlag)</span>
<a href="#l3.11931"></a><span id="l3.11931" class="difflineminus">-        flagString.AppendLiteral(&quot;\\Draft &quot;);</span>
<a href="#l3.11932"></a><span id="l3.11932" class="difflineminus">-    if (flags &amp; kImapMsgRecentFlag)</span>
<a href="#l3.11933"></a><span id="l3.11933" class="difflineminus">-        flagString.AppendLiteral(&quot;\\Recent &quot;);</span>
<a href="#l3.11934"></a><span id="l3.11934" class="difflineminus">-    if ((flags &amp; kImapMsgForwardedFlag) &amp;&amp;</span>
<a href="#l3.11935"></a><span id="l3.11935" class="difflineminus">-        (userFlags &amp; kImapMsgSupportForwardedFlag))</span>
<a href="#l3.11936"></a><span id="l3.11936" class="difflineminus">-        flagString.AppendLiteral(&quot;$Forwarded &quot;); // Not always available</span>
<a href="#l3.11937"></a><span id="l3.11937" class="difflineminus">-    if ((flags &amp; kImapMsgMDNSentFlag) &amp;&amp; (</span>
<a href="#l3.11938"></a><span id="l3.11938" class="difflineminus">-        userFlags &amp; kImapMsgSupportMDNSentFlag))</span>
<a href="#l3.11939"></a><span id="l3.11939" class="difflineminus">-        flagString.AppendLiteral(&quot;$MDNSent &quot;); // Not always available</span>
<a href="#l3.11940"></a><span id="l3.11940" class="difflineminus">-</span>
<a href="#l3.11941"></a><span id="l3.11941" class="difflineminus">-    // eat the last space</span>
<a href="#l3.11942"></a><span id="l3.11942" class="difflineminus">-    if (!flagString.IsEmpty())</span>
<a href="#l3.11943"></a><span id="l3.11943" class="difflineminus">-        flagString.SetLength(flagString.Length()-1);</span>
<a href="#l3.11944"></a><span id="l3.11944" class="difflineplus">+                                             uint16_t userFlags) {</span>
<a href="#l3.11945"></a><span id="l3.11945" class="difflineplus">+  if (flags &amp; kImapMsgSeenFlag) flagString.AppendLiteral(&quot;\\Seen &quot;);</span>
<a href="#l3.11946"></a><span id="l3.11946" class="difflineplus">+  if (flags &amp; kImapMsgAnsweredFlag) flagString.AppendLiteral(&quot;\\Answered &quot;);</span>
<a href="#l3.11947"></a><span id="l3.11947" class="difflineplus">+  if (flags &amp; kImapMsgFlaggedFlag) flagString.AppendLiteral(&quot;\\Flagged &quot;);</span>
<a href="#l3.11948"></a><span id="l3.11948" class="difflineplus">+  if (flags &amp; kImapMsgDeletedFlag) flagString.AppendLiteral(&quot;\\Deleted &quot;);</span>
<a href="#l3.11949"></a><span id="l3.11949" class="difflineplus">+  if (flags &amp; kImapMsgDraftFlag) flagString.AppendLiteral(&quot;\\Draft &quot;);</span>
<a href="#l3.11950"></a><span id="l3.11950" class="difflineplus">+  if (flags &amp; kImapMsgRecentFlag) flagString.AppendLiteral(&quot;\\Recent &quot;);</span>
<a href="#l3.11951"></a><span id="l3.11951" class="difflineplus">+  if ((flags &amp; kImapMsgForwardedFlag) &amp;&amp;</span>
<a href="#l3.11952"></a><span id="l3.11952" class="difflineplus">+      (userFlags &amp; kImapMsgSupportForwardedFlag))</span>
<a href="#l3.11953"></a><span id="l3.11953" class="difflineplus">+    flagString.AppendLiteral(&quot;$Forwarded &quot;);  // Not always available</span>
<a href="#l3.11954"></a><span id="l3.11954" class="difflineplus">+  if ((flags &amp; kImapMsgMDNSentFlag) &amp;&amp; (userFlags &amp; kImapMsgSupportMDNSentFlag))</span>
<a href="#l3.11955"></a><span id="l3.11955" class="difflineplus">+    flagString.AppendLiteral(&quot;$MDNSent &quot;);  // Not always available</span>
<a href="#l3.11956"></a><span id="l3.11956" class="difflineplus">+</span>
<a href="#l3.11957"></a><span id="l3.11957" class="difflineplus">+  // eat the last space</span>
<a href="#l3.11958"></a><span id="l3.11958" class="difflineplus">+  if (!flagString.IsEmpty()) flagString.SetLength(flagString.Length() - 1);</span>
<a href="#l3.11959"></a><span id="l3.11959"> }</span>
<a href="#l3.11960"></a><span id="l3.11960"> </span>
<a href="#l3.11961"></a><span id="l3.11961"> void nsImapProtocol::ProcessStoreFlags(const nsCString &amp;messageIdsString,</span>
<a href="#l3.11962"></a><span id="l3.11962" class="difflineminus">-                                                 bool idsAreUids,</span>
<a href="#l3.11963"></a><span id="l3.11963" class="difflineminus">-                                                 imapMessageFlagsType flags,</span>
<a href="#l3.11964"></a><span id="l3.11964" class="difflineminus">-                                                 bool addFlags)</span>
<a href="#l3.11965"></a><span id="l3.11965" class="difflineminus">-{</span>
<a href="#l3.11966"></a><span id="l3.11966" class="difflineplus">+                                       bool idsAreUids,</span>
<a href="#l3.11967"></a><span id="l3.11967" class="difflineplus">+                                       imapMessageFlagsType flags,</span>
<a href="#l3.11968"></a><span id="l3.11968" class="difflineplus">+                                       bool addFlags) {</span>
<a href="#l3.11969"></a><span id="l3.11969">   nsCString flagString;</span>
<a href="#l3.11970"></a><span id="l3.11970"> </span>
<a href="#l3.11971"></a><span id="l3.11971">   uint16_t userFlags = GetServerStateParser().SupportsUserFlags();</span>
<a href="#l3.11972"></a><span id="l3.11972">   uint16_t settableFlags = GetServerStateParser().SettablePermanentFlags();</span>
<a href="#l3.11973"></a><span id="l3.11973"> </span>
<a href="#l3.11974"></a><span id="l3.11974" class="difflineminus">-  if (!addFlags &amp;&amp; (flags &amp; userFlags) &amp;&amp; !(flags &amp; settableFlags))</span>
<a href="#l3.11975"></a><span id="l3.11975" class="difflineminus">-  {</span>
<a href="#l3.11976"></a><span id="l3.11976" class="difflineplus">+  if (!addFlags &amp;&amp; (flags &amp; userFlags) &amp;&amp; !(flags &amp; settableFlags)) {</span>
<a href="#l3.11977"></a><span id="l3.11977">     if (m_runningUrl)</span>
<a href="#l3.11978"></a><span id="l3.11978">       m_runningUrl-&gt;SetExtraStatus(nsIImapUrl::ImapStatusFlagsNotSettable);</span>
<a href="#l3.11979"></a><span id="l3.11979" class="difflineminus">-    return;         // if cannot set any of the flags bail out</span>
<a href="#l3.11980"></a><span id="l3.11980" class="difflineplus">+    return;  // if cannot set any of the flags bail out</span>
<a href="#l3.11981"></a><span id="l3.11981">   }</span>
<a href="#l3.11982"></a><span id="l3.11982"> </span>
<a href="#l3.11983"></a><span id="l3.11983">   if (addFlags)</span>
<a href="#l3.11984"></a><span id="l3.11984" class="difflineminus">-      flagString = &quot;+Flags (&quot;;</span>
<a href="#l3.11985"></a><span id="l3.11985" class="difflineplus">+    flagString = &quot;+Flags (&quot;;</span>
<a href="#l3.11986"></a><span id="l3.11986">   else</span>
<a href="#l3.11987"></a><span id="l3.11987" class="difflineminus">-      flagString = &quot;-Flags (&quot;;</span>
<a href="#l3.11988"></a><span id="l3.11988" class="difflineplus">+    flagString = &quot;-Flags (&quot;;</span>
<a href="#l3.11989"></a><span id="l3.11989"> </span>
<a href="#l3.11990"></a><span id="l3.11990">   if (flags &amp; kImapMsgSeenFlag &amp;&amp; kImapMsgSeenFlag &amp; settableFlags)</span>
<a href="#l3.11991"></a><span id="l3.11991" class="difflineminus">-      flagString .AppendLiteral(&quot;\\Seen &quot;);</span>
<a href="#l3.11992"></a><span id="l3.11992" class="difflineplus">+    flagString.AppendLiteral(&quot;\\Seen &quot;);</span>
<a href="#l3.11993"></a><span id="l3.11993">   if (flags &amp; kImapMsgAnsweredFlag &amp;&amp; kImapMsgAnsweredFlag &amp; settableFlags)</span>
<a href="#l3.11994"></a><span id="l3.11994" class="difflineminus">-      flagString .AppendLiteral(&quot;\\Answered &quot;);</span>
<a href="#l3.11995"></a><span id="l3.11995" class="difflineplus">+    flagString.AppendLiteral(&quot;\\Answered &quot;);</span>
<a href="#l3.11996"></a><span id="l3.11996">   if (flags &amp; kImapMsgFlaggedFlag &amp;&amp; kImapMsgFlaggedFlag &amp; settableFlags)</span>
<a href="#l3.11997"></a><span id="l3.11997" class="difflineminus">-      flagString .AppendLiteral(&quot;\\Flagged &quot;);</span>
<a href="#l3.11998"></a><span id="l3.11998" class="difflineplus">+    flagString.AppendLiteral(&quot;\\Flagged &quot;);</span>
<a href="#l3.11999"></a><span id="l3.11999">   if (flags &amp; kImapMsgDeletedFlag &amp;&amp; kImapMsgDeletedFlag &amp; settableFlags)</span>
<a href="#l3.12000"></a><span id="l3.12000" class="difflineminus">-      flagString .AppendLiteral(&quot;\\Deleted &quot;);</span>
<a href="#l3.12001"></a><span id="l3.12001" class="difflineplus">+    flagString.AppendLiteral(&quot;\\Deleted &quot;);</span>
<a href="#l3.12002"></a><span id="l3.12002">   if (flags &amp; kImapMsgDraftFlag &amp;&amp; kImapMsgDraftFlag &amp; settableFlags)</span>
<a href="#l3.12003"></a><span id="l3.12003" class="difflineminus">-      flagString .AppendLiteral(&quot;\\Draft &quot;);</span>
<a href="#l3.12004"></a><span id="l3.12004" class="difflineplus">+    flagString.AppendLiteral(&quot;\\Draft &quot;);</span>
<a href="#l3.12005"></a><span id="l3.12005">   if (flags &amp; kImapMsgForwardedFlag &amp;&amp; kImapMsgSupportForwardedFlag &amp; userFlags)</span>
<a href="#l3.12006"></a><span id="l3.12006" class="difflineminus">-        flagString .AppendLiteral(&quot;$Forwarded &quot;);  // if supported</span>
<a href="#l3.12007"></a><span id="l3.12007" class="difflineplus">+    flagString.AppendLiteral(&quot;$Forwarded &quot;);  // if supported</span>
<a href="#l3.12008"></a><span id="l3.12008">   if (flags &amp; kImapMsgMDNSentFlag &amp;&amp; kImapMsgSupportMDNSentFlag &amp; userFlags)</span>
<a href="#l3.12009"></a><span id="l3.12009" class="difflineminus">-        flagString .AppendLiteral(&quot;$MDNSent &quot;);  // if supported</span>
<a href="#l3.12010"></a><span id="l3.12010" class="difflineminus">-</span>
<a href="#l3.12011"></a><span id="l3.12011" class="difflineminus">-  if (flagString.Length() &gt; 8) // if more than &quot;+Flags (&quot;</span>
<a href="#l3.12012"></a><span id="l3.12012" class="difflineplus">+    flagString.AppendLiteral(&quot;$MDNSent &quot;);  // if supported</span>
<a href="#l3.12013"></a><span id="l3.12013" class="difflineplus">+</span>
<a href="#l3.12014"></a><span id="l3.12014" class="difflineplus">+  if (flagString.Length() &gt; 8)  // if more than &quot;+Flags (&quot;</span>
<a href="#l3.12015"></a><span id="l3.12015">   {</span>
<a href="#l3.12016"></a><span id="l3.12016" class="difflineminus">-  // replace the final space with ')'</span>
<a href="#l3.12017"></a><span id="l3.12017" class="difflineminus">-    flagString.SetCharAt(')',flagString.Length() - 1);</span>
<a href="#l3.12018"></a><span id="l3.12018" class="difflineplus">+    // replace the final space with ')'</span>
<a href="#l3.12019"></a><span id="l3.12019" class="difflineplus">+    flagString.SetCharAt(')', flagString.Length() - 1);</span>
<a href="#l3.12020"></a><span id="l3.12020"> </span>
<a href="#l3.12021"></a><span id="l3.12021">     Store(messageIdsString, flagString.get(), idsAreUids);</span>
<a href="#l3.12022"></a><span id="l3.12022" class="difflineminus">-    if (m_runningUrl &amp;&amp; idsAreUids)</span>
<a href="#l3.12023"></a><span id="l3.12023" class="difflineminus">-    {</span>
<a href="#l3.12024"></a><span id="l3.12024" class="difflineplus">+    if (m_runningUrl &amp;&amp; idsAreUids) {</span>
<a href="#l3.12025"></a><span id="l3.12025">       nsCString messageIdString;</span>
<a href="#l3.12026"></a><span id="l3.12026">       m_runningUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.12027"></a><span id="l3.12027">       nsTArray&lt;nsMsgKey&gt; msgKeys;</span>
<a href="#l3.12028"></a><span id="l3.12028">       ParseUidString(messageIdString.get(), msgKeys);</span>
<a href="#l3.12029"></a><span id="l3.12029"> </span>
<a href="#l3.12030"></a><span id="l3.12030">       int32_t msgCount = msgKeys.Length();</span>
<a href="#l3.12031"></a><span id="l3.12031" class="difflineminus">-      for (int32_t i = 0; i &lt; msgCount; i++)</span>
<a href="#l3.12032"></a><span id="l3.12032" class="difflineminus">-      {</span>
<a href="#l3.12033"></a><span id="l3.12033" class="difflineplus">+      for (int32_t i = 0; i &lt; msgCount; i++) {</span>
<a href="#l3.12034"></a><span id="l3.12034">         bool found;</span>
<a href="#l3.12035"></a><span id="l3.12035">         imapMessageFlagsType resultFlags;</span>
<a href="#l3.12036"></a><span id="l3.12036" class="difflineminus">-      // check if the flags were added/removed, and if the uid really exists.</span>
<a href="#l3.12037"></a><span id="l3.12037" class="difflineplus">+        // check if the flags were added/removed, and if the uid really exists.</span>
<a href="#l3.12038"></a><span id="l3.12038">         nsresult rv = GetFlagsForUID(msgKeys[i], &amp;found, &amp;resultFlags, nullptr);</span>
<a href="#l3.12039"></a><span id="l3.12039">         if (NS_FAILED(rv) || !found ||</span>
<a href="#l3.12040"></a><span id="l3.12040" class="difflineminus">-           (addFlags &amp;&amp; ((flags &amp; resultFlags) != flags)) ||</span>
<a href="#l3.12041"></a><span id="l3.12041" class="difflineminus">-           (!addFlags &amp;&amp; ((flags &amp; resultFlags) != 0)))</span>
<a href="#l3.12042"></a><span id="l3.12042" class="difflineminus">-        {</span>
<a href="#l3.12043"></a><span id="l3.12043" class="difflineplus">+            (addFlags &amp;&amp; ((flags &amp; resultFlags) != flags)) ||</span>
<a href="#l3.12044"></a><span id="l3.12044" class="difflineplus">+            (!addFlags &amp;&amp; ((flags &amp; resultFlags) != 0))) {</span>
<a href="#l3.12045"></a><span id="l3.12045">           m_runningUrl-&gt;SetExtraStatus(nsIImapUrl::ImapStatusFlagChangeFailed);</span>
<a href="#l3.12046"></a><span id="l3.12046">           break;</span>
<a href="#l3.12047"></a><span id="l3.12047">         }</span>
<a href="#l3.12048"></a><span id="l3.12048">       }</span>
<a href="#l3.12049"></a><span id="l3.12049" class="difflineminus">-</span>
<a href="#l3.12050"></a><span id="l3.12050" class="difflineminus">-    }</span>
<a href="#l3.12051"></a><span id="l3.12051" class="difflineminus">-  }</span>
<a href="#l3.12052"></a><span id="l3.12052" class="difflineminus">-}</span>
<a href="#l3.12053"></a><span id="l3.12053" class="difflineminus">-</span>
<a href="#l3.12054"></a><span id="l3.12054" class="difflineplus">+    }</span>
<a href="#l3.12055"></a><span id="l3.12055" class="difflineplus">+  }</span>
<a href="#l3.12056"></a><span id="l3.12056" class="difflineplus">+}</span>
<a href="#l3.12057"></a><span id="l3.12057"> </span>
<a href="#l3.12058"></a><span id="l3.12058"> void nsImapProtocol::Close(bool shuttingDown /* = false */,</span>
<a href="#l3.12059"></a><span id="l3.12059" class="difflineminus">-                           bool waitForResponse /* = true */)</span>
<a href="#l3.12060"></a><span id="l3.12060" class="difflineminus">-{</span>
<a href="#l3.12061"></a><span id="l3.12061" class="difflineplus">+                           bool waitForResponse /* = true */) {</span>
<a href="#l3.12062"></a><span id="l3.12062">   IncrementCommandTagNumber();</span>
<a href="#l3.12063"></a><span id="l3.12063"> </span>
<a href="#l3.12064"></a><span id="l3.12064">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.12065"></a><span id="l3.12065">   command.AppendLiteral(&quot; close&quot; CRLF);</span>
<a href="#l3.12066"></a><span id="l3.12066"> </span>
<a href="#l3.12067"></a><span id="l3.12067" class="difflineminus">-  if (!shuttingDown)</span>
<a href="#l3.12068"></a><span id="l3.12068" class="difflineminus">-    ProgressEventFunctionUsingName(&quot;imapStatusCloseMailbox&quot;);</span>
<a href="#l3.12069"></a><span id="l3.12069" class="difflineplus">+  if (!shuttingDown) ProgressEventFunctionUsingName(&quot;imapStatusCloseMailbox&quot;);</span>
<a href="#l3.12070"></a><span id="l3.12070"> </span>
<a href="#l3.12071"></a><span id="l3.12071">   GetServerStateParser().ResetFlagInfo();</span>
<a href="#l3.12072"></a><span id="l3.12072"> </span>
<a href="#l3.12073"></a><span id="l3.12073">   nsresult rv = SendData(command.get());</span>
<a href="#l3.12074"></a><span id="l3.12074">   if (m_transport &amp;&amp; shuttingDown)</span>
<a href="#l3.12075"></a><span id="l3.12075">     m_transport-&gt;SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE, 5);</span>
<a href="#l3.12076"></a><span id="l3.12076"> </span>
<a href="#l3.12077"></a><span id="l3.12077" class="difflineminus">-  if (NS_SUCCEEDED(rv) &amp;&amp; waitForResponse)</span>
<a href="#l3.12078"></a><span id="l3.12078" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.12079"></a><span id="l3.12079" class="difflineminus">-}</span>
<a href="#l3.12080"></a><span id="l3.12080" class="difflineminus">-</span>
<a href="#l3.12081"></a><span id="l3.12081" class="difflineminus">-void nsImapProtocol::XAOL_Option(const char *option)</span>
<a href="#l3.12082"></a><span id="l3.12082" class="difflineminus">-{</span>
<a href="#l3.12083"></a><span id="l3.12083" class="difflineplus">+  if (NS_SUCCEEDED(rv) &amp;&amp; waitForResponse) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.12084"></a><span id="l3.12084" class="difflineplus">+}</span>
<a href="#l3.12085"></a><span id="l3.12085" class="difflineplus">+</span>
<a href="#l3.12086"></a><span id="l3.12086" class="difflineplus">+void nsImapProtocol::XAOL_Option(const char *option) {</span>
<a href="#l3.12087"></a><span id="l3.12087">   IncrementCommandTagNumber();</span>
<a href="#l3.12088"></a><span id="l3.12088"> </span>
<a href="#l3.12089"></a><span id="l3.12089">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.12090"></a><span id="l3.12090">   command.AppendLiteral(&quot; XAOL-OPTION &quot;);</span>
<a href="#l3.12091"></a><span id="l3.12091">   command.Append(option);</span>
<a href="#l3.12092"></a><span id="l3.12092">   command.Append(CRLF);</span>
<a href="#l3.12093"></a><span id="l3.12093"> </span>
<a href="#l3.12094"></a><span id="l3.12094">   nsresult rv = SendData(command.get());</span>
<a href="#l3.12095"></a><span id="l3.12095" class="difflineminus">-  if (NS_SUCCEEDED(rv))</span>
<a href="#l3.12096"></a><span id="l3.12096" class="difflineminus">-      ParseIMAPandCheckForNewMail();</span>
<a href="#l3.12097"></a><span id="l3.12097" class="difflineminus">-}</span>
<a href="#l3.12098"></a><span id="l3.12098" class="difflineminus">-</span>
<a href="#l3.12099"></a><span id="l3.12099" class="difflineminus">-void nsImapProtocol::Check()</span>
<a href="#l3.12100"></a><span id="l3.12100" class="difflineminus">-{</span>
<a href="#l3.12101"></a><span id="l3.12101" class="difflineminus">-    //ProgressUpdateEvent(&quot;Checking mailbox...&quot;);</span>
<a href="#l3.12102"></a><span id="l3.12102" class="difflineminus">-</span>
<a href="#l3.12103"></a><span id="l3.12103" class="difflineminus">-    IncrementCommandTagNumber();</span>
<a href="#l3.12104"></a><span id="l3.12104" class="difflineplus">+  if (NS_SUCCEEDED(rv)) ParseIMAPandCheckForNewMail();</span>
<a href="#l3.12105"></a><span id="l3.12105" class="difflineplus">+}</span>
<a href="#l3.12106"></a><span id="l3.12106" class="difflineplus">+</span>
<a href="#l3.12107"></a><span id="l3.12107" class="difflineplus">+void nsImapProtocol::Check() {</span>
<a href="#l3.12108"></a><span id="l3.12108" class="difflineplus">+  // ProgressUpdateEvent(&quot;Checking mailbox...&quot;);</span>
<a href="#l3.12109"></a><span id="l3.12109" class="difflineplus">+</span>
<a href="#l3.12110"></a><span id="l3.12110" class="difflineplus">+  IncrementCommandTagNumber();</span>
<a href="#l3.12111"></a><span id="l3.12111"> </span>
<a href="#l3.12112"></a><span id="l3.12112">   nsCString command(GetServerCommandTag());</span>
<a href="#l3.12113"></a><span id="l3.12113">   command.AppendLiteral(&quot; check&quot; CRLF);</span>
<a href="#l3.12114"></a><span id="l3.12114"> </span>
<a href="#l3.12115"></a><span id="l3.12115" class="difflineminus">-    nsresult rv = SendData(command.get());</span>
<a href="#l3.12116"></a><span id="l3.12116" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.12117"></a><span id="l3.12117" class="difflineminus">-    {</span>
<a href="#l3.12118"></a><span id="l3.12118" class="difflineminus">-        m_flagChangeCount = 0;</span>
<a href="#l3.12119"></a><span id="l3.12119" class="difflineminus">-        m_lastCheckTime = PR_Now();</span>
<a href="#l3.12120"></a><span id="l3.12120" class="difflineminus">-        ParseIMAPandCheckForNewMail();</span>
<a href="#l3.12121"></a><span id="l3.12121" class="difflineminus">-    }</span>
<a href="#l3.12122"></a><span id="l3.12122" class="difflineminus">-}</span>
<a href="#l3.12123"></a><span id="l3.12123" class="difflineminus">-</span>
<a href="#l3.12124"></a><span id="l3.12124" class="difflineminus">-nsresult nsImapProtocol::GetMsgWindow(nsIMsgWindow **aMsgWindow)</span>
<a href="#l3.12125"></a><span id="l3.12125" class="difflineminus">-{</span>
<a href="#l3.12126"></a><span id="l3.12126" class="difflineplus">+  nsresult rv = SendData(command.get());</span>
<a href="#l3.12127"></a><span id="l3.12127" class="difflineplus">+  if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.12128"></a><span id="l3.12128" class="difflineplus">+    m_flagChangeCount = 0;</span>
<a href="#l3.12129"></a><span id="l3.12129" class="difflineplus">+    m_lastCheckTime = PR_Now();</span>
<a href="#l3.12130"></a><span id="l3.12130" class="difflineplus">+    ParseIMAPandCheckForNewMail();</span>
<a href="#l3.12131"></a><span id="l3.12131" class="difflineplus">+  }</span>
<a href="#l3.12132"></a><span id="l3.12132" class="difflineplus">+}</span>
<a href="#l3.12133"></a><span id="l3.12133" class="difflineplus">+</span>
<a href="#l3.12134"></a><span id="l3.12134" class="difflineplus">+nsresult nsImapProtocol::GetMsgWindow(nsIMsgWindow **aMsgWindow) {</span>
<a href="#l3.12135"></a><span id="l3.12135">   nsresult rv;</span>
<a href="#l3.12136"></a><span id="l3.12136">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl =</span>
<a href="#l3.12137"></a><span id="l3.12137">       do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l3.12138"></a><span id="l3.12138">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.12139"></a><span id="l3.12139" class="difflineminus">-  if (!m_imapProtocolSink)</span>
<a href="#l3.12140"></a><span id="l3.12140" class="difflineminus">-    return NS_ERROR_FAILURE;</span>
<a href="#l3.12141"></a><span id="l3.12141" class="difflineplus">+  if (!m_imapProtocolSink) return NS_ERROR_FAILURE;</span>
<a href="#l3.12142"></a><span id="l3.12142">   return m_imapProtocolSink-&gt;GetUrlWindow(mailnewsUrl, aMsgWindow);</span>
<a href="#l3.12143"></a><span id="l3.12143"> }</span>
<a href="#l3.12144"></a><span id="l3.12144"> </span>
<a href="#l3.12145"></a><span id="l3.12145"> /**</span>
<a href="#l3.12146"></a><span id="l3.12146">  * Get password from RAM, disk (password manager) or user (dialog)</span>
<a href="#l3.12147"></a><span id="l3.12147">  * @return NS_MSG_PASSWORD_PROMPT_CANCELLED</span>
<a href="#l3.12148"></a><span id="l3.12148">  *    (which is NS_SUCCEEDED!) when user cancelled</span>
<a href="#l3.12149"></a><span id="l3.12149">  *    NS_FAILED(rv) for other errors</span>
<a href="#l3.12150"></a><span id="l3.12150">  */</span>
<a href="#l3.12151"></a><span id="l3.12151"> nsresult nsImapProtocol::GetPassword(nsString &amp;password,</span>
<a href="#l3.12152"></a><span id="l3.12152" class="difflineminus">-                                     bool newPasswordRequested)</span>
<a href="#l3.12153"></a><span id="l3.12153" class="difflineminus">-{</span>
<a href="#l3.12154"></a><span id="l3.12154" class="difflineplus">+                                     bool newPasswordRequested) {</span>
<a href="#l3.12155"></a><span id="l3.12155">   // we are in the imap thread so *NEVER* try to extract the password with UI</span>
<a href="#l3.12156"></a><span id="l3.12156">   NS_ENSURE_TRUE(m_imapServerSink, NS_ERROR_NULL_POINTER);</span>
<a href="#l3.12157"></a><span id="l3.12157">   NS_ENSURE_TRUE(m_server, NS_ERROR_NULL_POINTER);</span>
<a href="#l3.12158"></a><span id="l3.12158">   nsresult rv;</span>
<a href="#l3.12159"></a><span id="l3.12159"> </span>
<a href="#l3.12160"></a><span id="l3.12160">   // Get the password already stored in mem</span>
<a href="#l3.12161"></a><span id="l3.12161">   rv = m_imapServerSink-&gt;GetServerPassword(password);</span>
<a href="#l3.12162"></a><span id="l3.12162" class="difflineminus">-  if (NS_FAILED(rv) || password.IsEmpty())</span>
<a href="#l3.12163"></a><span id="l3.12163" class="difflineminus">-  {</span>
<a href="#l3.12164"></a><span id="l3.12164" class="difflineplus">+  if (NS_FAILED(rv) || password.IsEmpty()) {</span>
<a href="#l3.12165"></a><span id="l3.12165">     AutoProxyReleaseMsgWindow msgWindow;</span>
<a href="#l3.12166"></a><span id="l3.12166">     GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.12167"></a><span id="l3.12167" class="difflineminus">-    NS_ENSURE_TRUE(msgWindow, NS_ERROR_NOT_AVAILABLE); // biff case</span>
<a href="#l3.12168"></a><span id="l3.12168" class="difflineplus">+    NS_ENSURE_TRUE(msgWindow, NS_ERROR_NOT_AVAILABLE);  // biff case</span>
<a href="#l3.12169"></a><span id="l3.12169"> </span>
<a href="#l3.12170"></a><span id="l3.12170">     // Get the password from pw manager (harddisk) or user (dialog)</span>
<a href="#l3.12171"></a><span id="l3.12171">     m_passwordObtained = false;</span>
<a href="#l3.12172"></a><span id="l3.12172">     rv = m_imapServerSink-&gt;AsyncGetPassword(this, newPasswordRequested,</span>
<a href="#l3.12173"></a><span id="l3.12173">                                             password);</span>
<a href="#l3.12174"></a><span id="l3.12174" class="difflineminus">-    if (password.IsEmpty())</span>
<a href="#l3.12175"></a><span id="l3.12175" class="difflineminus">-    {</span>
<a href="#l3.12176"></a><span id="l3.12176" class="difflineplus">+    if (password.IsEmpty()) {</span>
<a href="#l3.12177"></a><span id="l3.12177">       PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l3.12178"></a><span id="l3.12178">       m_passwordStatus = NS_OK;</span>
<a href="#l3.12179"></a><span id="l3.12179">       ReentrantMonitorAutoEnter mon(m_passwordReadyMonitor);</span>
<a href="#l3.12180"></a><span id="l3.12180">       while (!m_passwordObtained &amp;&amp; !NS_FAILED(m_passwordStatus) &amp;&amp;</span>
<a href="#l3.12181"></a><span id="l3.12181">              m_passwordStatus != NS_MSG_PASSWORD_PROMPT_CANCELLED &amp;&amp;</span>
<a href="#l3.12182"></a><span id="l3.12182">              !DeathSignalReceived())</span>
<a href="#l3.12183"></a><span id="l3.12183">         mon.Wait(sleepTime);</span>
<a href="#l3.12184"></a><span id="l3.12184">       rv = m_passwordStatus;</span>
<a href="#l3.12185"></a><span id="l3.12185">       password = m_password;</span>
<a href="#l3.12186"></a><span id="l3.12186">     }</span>
<a href="#l3.12187"></a><span id="l3.12187">   }</span>
<a href="#l3.12188"></a><span id="l3.12188" class="difflineminus">-  if (!password.IsEmpty())</span>
<a href="#l3.12189"></a><span id="l3.12189" class="difflineminus">-    m_lastPasswordSent = password;</span>
<a href="#l3.12190"></a><span id="l3.12190" class="difflineplus">+  if (!password.IsEmpty()) m_lastPasswordSent = password;</span>
<a href="#l3.12191"></a><span id="l3.12191">   return rv;</span>
<a href="#l3.12192"></a><span id="l3.12192"> }</span>
<a href="#l3.12193"></a><span id="l3.12193"> </span>
<a href="#l3.12194"></a><span id="l3.12194" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::OnPromptStartAsync(nsIMsgAsyncPromptCallback *aCallback)</span>
<a href="#l3.12195"></a><span id="l3.12195" class="difflineminus">-{</span>
<a href="#l3.12196"></a><span id="l3.12196" class="difflineplus">+NS_IMETHODIMP nsImapProtocol::OnPromptStartAsync(</span>
<a href="#l3.12197"></a><span id="l3.12197" class="difflineplus">+    nsIMsgAsyncPromptCallback *aCallback) {</span>
<a href="#l3.12198"></a><span id="l3.12198">   bool result = false;</span>
<a href="#l3.12199"></a><span id="l3.12199">   OnPromptStart(&amp;result);</span>
<a href="#l3.12200"></a><span id="l3.12200">   return aCallback-&gt;OnAuthResult(result);</span>
<a href="#l3.12201"></a><span id="l3.12201"> }</span>
<a href="#l3.12202"></a><span id="l3.12202"> </span>
<a href="#l3.12203"></a><span id="l3.12203"> // This is called from the UI thread.</span>
<a href="#l3.12204"></a><span id="l3.12204"> NS_IMETHODIMP</span>
<a href="#l3.12205"></a><span id="l3.12205" class="difflineminus">-nsImapProtocol::OnPromptStart(bool *aResult)</span>
<a href="#l3.12206"></a><span id="l3.12206" class="difflineminus">-{</span>
<a href="#l3.12207"></a><span id="l3.12207" class="difflineplus">+nsImapProtocol::OnPromptStart(bool *aResult) {</span>
<a href="#l3.12208"></a><span id="l3.12208">   nsresult rv;</span>
<a href="#l3.12209"></a><span id="l3.12209">   nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer = do_QueryReferent(m_server, &amp;rv);</span>
<a href="#l3.12210"></a><span id="l3.12210">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.12211"></a><span id="l3.12211">   nsCOMPtr&lt;nsIMsgWindow&gt; msgWindow;</span>
<a href="#l3.12212"></a><span id="l3.12212"> </span>
<a href="#l3.12213"></a><span id="l3.12213">   *aResult = false;</span>
<a href="#l3.12214"></a><span id="l3.12214">   GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.12215"></a><span id="l3.12215">   nsString password = m_lastPasswordSent;</span>
<a href="#l3.12216"></a><span id="l3.12216">   rv = imapServer-&gt;PromptPassword(msgWindow, password);</span>
<a href="#l3.12217"></a><span id="l3.12217">   m_password = password;</span>
<a href="#l3.12218"></a><span id="l3.12218">   m_passwordStatus = rv;</span>
<a href="#l3.12219"></a><span id="l3.12219" class="difflineminus">-  if (!m_password.IsEmpty())</span>
<a href="#l3.12220"></a><span id="l3.12220" class="difflineminus">-    *aResult = true;</span>
<a href="#l3.12221"></a><span id="l3.12221" class="difflineplus">+  if (!m_password.IsEmpty()) *aResult = true;</span>
<a href="#l3.12222"></a><span id="l3.12222"> </span>
<a href="#l3.12223"></a><span id="l3.12223">   // Notify the imap thread that we have a password.</span>
<a href="#l3.12224"></a><span id="l3.12224">   m_passwordObtained = true;</span>
<a href="#l3.12225"></a><span id="l3.12225">   ReentrantMonitorAutoEnter passwordMon(m_passwordReadyMonitor);</span>
<a href="#l3.12226"></a><span id="l3.12226">   passwordMon.Notify();</span>
<a href="#l3.12227"></a><span id="l3.12227">   return rv;</span>
<a href="#l3.12228"></a><span id="l3.12228"> }</span>
<a href="#l3.12229"></a><span id="l3.12229"> </span>
<a href="#l3.12230"></a><span id="l3.12230"> NS_IMETHODIMP</span>
<a href="#l3.12231"></a><span id="l3.12231" class="difflineminus">-nsImapProtocol::OnPromptAuthAvailable()</span>
<a href="#l3.12232"></a><span id="l3.12232" class="difflineminus">-{</span>
<a href="#l3.12233"></a><span id="l3.12233" class="difflineplus">+nsImapProtocol::OnPromptAuthAvailable() {</span>
<a href="#l3.12234"></a><span id="l3.12234">   nsresult rv;</span>
<a href="#l3.12235"></a><span id="l3.12235">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; imapServer = do_QueryReferent(m_server, &amp;rv);</span>
<a href="#l3.12236"></a><span id="l3.12236">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.12237"></a><span id="l3.12237">   m_passwordStatus = imapServer-&gt;GetPassword(m_password);</span>
<a href="#l3.12238"></a><span id="l3.12238">   // Notify the imap thread that we have a password.</span>
<a href="#l3.12239"></a><span id="l3.12239">   m_passwordObtained = true;</span>
<a href="#l3.12240"></a><span id="l3.12240">   ReentrantMonitorAutoEnter passwordMon(m_passwordReadyMonitor);</span>
<a href="#l3.12241"></a><span id="l3.12241">   passwordMon.Notify();</span>
<a href="#l3.12242"></a><span id="l3.12242">   return m_passwordStatus;</span>
<a href="#l3.12243"></a><span id="l3.12243"> }</span>
<a href="#l3.12244"></a><span id="l3.12244"> </span>
<a href="#l3.12245"></a><span id="l3.12245"> NS_IMETHODIMP</span>
<a href="#l3.12246"></a><span id="l3.12246" class="difflineminus">-nsImapProtocol::OnPromptCanceled()</span>
<a href="#l3.12247"></a><span id="l3.12247" class="difflineminus">-{</span>
<a href="#l3.12248"></a><span id="l3.12248" class="difflineplus">+nsImapProtocol::OnPromptCanceled() {</span>
<a href="#l3.12249"></a><span id="l3.12249">   // A prompt was cancelled, so notify the imap thread.</span>
<a href="#l3.12250"></a><span id="l3.12250">   m_passwordStatus = NS_MSG_PASSWORD_PROMPT_CANCELLED;</span>
<a href="#l3.12251"></a><span id="l3.12251">   ReentrantMonitorAutoEnter passwordMon(m_passwordReadyMonitor);</span>
<a href="#l3.12252"></a><span id="l3.12252">   passwordMon.Notify();</span>
<a href="#l3.12253"></a><span id="l3.12253">   return NS_OK;</span>
<a href="#l3.12254"></a><span id="l3.12254"> }</span>
<a href="#l3.12255"></a><span id="l3.12255"> </span>
<a href="#l3.12256"></a><span id="l3.12256" class="difflineminus">-bool nsImapProtocol::TryToLogon()</span>
<a href="#l3.12257"></a><span id="l3.12257" class="difflineminus">-{</span>
<a href="#l3.12258"></a><span id="l3.12258" class="difflineplus">+bool nsImapProtocol::TryToLogon() {</span>
<a href="#l3.12259"></a><span id="l3.12259">   MOZ_LOG(IMAP, LogLevel::Debug, (&quot;try to log in&quot;));</span>
<a href="#l3.12260"></a><span id="l3.12260">   NS_ENSURE_TRUE(m_imapServerSink, false);</span>
<a href="#l3.12261"></a><span id="l3.12261">   bool loginSucceeded = false;</span>
<a href="#l3.12262"></a><span id="l3.12262">   bool skipLoop = false;</span>
<a href="#l3.12263"></a><span id="l3.12263">   nsAutoString password;</span>
<a href="#l3.12264"></a><span id="l3.12264">   nsAutoCString userName;</span>
<a href="#l3.12265"></a><span id="l3.12265"> </span>
<a href="#l3.12266"></a><span id="l3.12266">   nsresult rv = ChooseAuthMethod();</span>
<a href="#l3.12267"></a><span id="l3.12267" class="difflineminus">-  if (NS_FAILED(rv)) // all methods failed</span>
<a href="#l3.12268"></a><span id="l3.12268" class="difflineplus">+  if (NS_FAILED(rv))  // all methods failed</span>
<a href="#l3.12269"></a><span id="l3.12269">   {</span>
<a href="#l3.12270"></a><span id="l3.12270">     // are there any matching login schemes at all?</span>
<a href="#l3.12271"></a><span id="l3.12271" class="difflineminus">-    if (!(GetServerStateParser().GetCapabilityFlag() &amp; m_prefAuthMethods))</span>
<a href="#l3.12272"></a><span id="l3.12272" class="difflineminus">-    {</span>
<a href="#l3.12273"></a><span id="l3.12273" class="difflineplus">+    if (!(GetServerStateParser().GetCapabilityFlag() &amp; m_prefAuthMethods)) {</span>
<a href="#l3.12274"></a><span id="l3.12274">       // Pref doesn't match server. Now, find an appropriate error msg.</span>
<a href="#l3.12275"></a><span id="l3.12275"> </span>
<a href="#l3.12276"></a><span id="l3.12276">       // pref has plaintext pw &amp; server claims to support encrypted pw</span>
<a href="#l3.12277"></a><span id="l3.12277" class="difflineminus">-      if (m_prefAuthMethods == (kHasAuthOldLoginCapability |</span>
<a href="#l3.12278"></a><span id="l3.12278" class="difflineminus">-              kHasAuthLoginCapability | kHasAuthPlainCapability) &amp;&amp;</span>
<a href="#l3.12279"></a><span id="l3.12279" class="difflineplus">+      if (m_prefAuthMethods ==</span>
<a href="#l3.12280"></a><span id="l3.12280" class="difflineplus">+              (kHasAuthOldLoginCapability | kHasAuthLoginCapability |</span>
<a href="#l3.12281"></a><span id="l3.12281" class="difflineplus">+               kHasAuthPlainCapability) &amp;&amp;</span>
<a href="#l3.12282"></a><span id="l3.12282">           GetServerStateParser().GetCapabilityFlag() &amp; kHasCRAMCapability)</span>
<a href="#l3.12283"></a><span id="l3.12283">         // tell user to change to encrypted pw</span>
<a href="#l3.12284"></a><span id="l3.12284">         AlertUserEventUsingName(&quot;imapAuthChangePlainToEncrypt&quot;);</span>
<a href="#l3.12285"></a><span id="l3.12285">       // pref has encrypted pw &amp; server claims to support plaintext pw</span>
<a href="#l3.12286"></a><span id="l3.12286">       else if (m_prefAuthMethods == kHasCRAMCapability &amp;&amp;</span>
<a href="#l3.12287"></a><span id="l3.12287">                GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.12288"></a><span id="l3.12288">                    (kHasAuthOldLoginCapability | kHasAuthLoginCapability |</span>
<a href="#l3.12289"></a><span id="l3.12289" class="difflineminus">-                    kHasAuthPlainCapability))</span>
<a href="#l3.12290"></a><span id="l3.12290" class="difflineminus">-      {</span>
<a href="#l3.12291"></a><span id="l3.12291" class="difflineplus">+                    kHasAuthPlainCapability)) {</span>
<a href="#l3.12292"></a><span id="l3.12292">         // have SSL</span>
<a href="#l3.12293"></a><span id="l3.12293">         if (m_socketType == nsMsgSocketType::SSL ||</span>
<a href="#l3.12294"></a><span id="l3.12294">             m_socketType == nsMsgSocketType::alwaysSTARTTLS)</span>
<a href="#l3.12295"></a><span id="l3.12295">           // tell user to change to plaintext pw</span>
<a href="#l3.12296"></a><span id="l3.12296">           AlertUserEventUsingName(&quot;imapAuthChangeEncryptToPlainSSL&quot;);</span>
<a href="#l3.12297"></a><span id="l3.12297">         else</span>
<a href="#l3.12298"></a><span id="l3.12298">           // tell user to change to plaintext pw, with big warning</span>
<a href="#l3.12299"></a><span id="l3.12299">           AlertUserEventUsingName(&quot;imapAuthChangeEncryptToPlainNoSSL&quot;);</span>
<a href="#l3.12300"></a><span id="l3.12300" class="difflineminus">-      }</span>
<a href="#l3.12301"></a><span id="l3.12301" class="difflineminus">-      else</span>
<a href="#l3.12302"></a><span id="l3.12302" class="difflineplus">+      } else</span>
<a href="#l3.12303"></a><span id="l3.12303">         // just &quot;change auth method&quot;</span>
<a href="#l3.12304"></a><span id="l3.12304">         AlertUserEventUsingName(&quot;imapAuthMechNotSupported&quot;);</span>
<a href="#l3.12305"></a><span id="l3.12305"> </span>
<a href="#l3.12306"></a><span id="l3.12306">       skipLoop = true;</span>
<a href="#l3.12307"></a><span id="l3.12307" class="difflineminus">-    }</span>
<a href="#l3.12308"></a><span id="l3.12308" class="difflineminus">-    else</span>
<a href="#l3.12309"></a><span id="l3.12309" class="difflineminus">-    {</span>
<a href="#l3.12310"></a><span id="l3.12310" class="difflineplus">+    } else {</span>
<a href="#l3.12311"></a><span id="l3.12311">       // try to reset failed methods and try them again</span>
<a href="#l3.12312"></a><span id="l3.12312">       ResetAuthMethods();</span>
<a href="#l3.12313"></a><span id="l3.12313">       rv = ChooseAuthMethod();</span>
<a href="#l3.12314"></a><span id="l3.12314" class="difflineminus">-      if (NS_FAILED(rv)) // all methods failed</span>
<a href="#l3.12315"></a><span id="l3.12315" class="difflineplus">+      if (NS_FAILED(rv))  // all methods failed</span>
<a href="#l3.12316"></a><span id="l3.12316">       {</span>
<a href="#l3.12317"></a><span id="l3.12317" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Error, (&quot;huch? there are auth methods, and we reset failed ones, but ChooseAuthMethod still fails.&quot;));</span>
<a href="#l3.12318"></a><span id="l3.12318" class="difflineplus">+        MOZ_LOG(IMAP, LogLevel::Error,</span>
<a href="#l3.12319"></a><span id="l3.12319" class="difflineplus">+                (&quot;huch? there are auth methods, and we reset failed ones, but &quot;</span>
<a href="#l3.12320"></a><span id="l3.12320" class="difflineplus">+                 &quot;ChooseAuthMethod still fails.&quot;));</span>
<a href="#l3.12321"></a><span id="l3.12321">         return false;</span>
<a href="#l3.12322"></a><span id="l3.12322">       }</span>
<a href="#l3.12323"></a><span id="l3.12323">     }</span>
<a href="#l3.12324"></a><span id="l3.12324">   }</span>
<a href="#l3.12325"></a><span id="l3.12325"> </span>
<a href="#l3.12326"></a><span id="l3.12326">   // Get username, either the stored one or from user</span>
<a href="#l3.12327"></a><span id="l3.12327">   rv = m_imapServerSink-&gt;GetLoginUsername(userName);</span>
<a href="#l3.12328"></a><span id="l3.12328" class="difflineminus">-  if (NS_FAILED(rv) || userName.IsEmpty())</span>
<a href="#l3.12329"></a><span id="l3.12329" class="difflineminus">-  {</span>
<a href="#l3.12330"></a><span id="l3.12330" class="difflineplus">+  if (NS_FAILED(rv) || userName.IsEmpty()) {</span>
<a href="#l3.12331"></a><span id="l3.12331">     // The user hit &quot;Cancel&quot; on the dialog box</span>
<a href="#l3.12332"></a><span id="l3.12332">     skipLoop = true;</span>
<a href="#l3.12333"></a><span id="l3.12333">   }</span>
<a href="#l3.12334"></a><span id="l3.12334"> </span>
<a href="#l3.12335"></a><span id="l3.12335" class="difflineplus">+  // clang-format off</span>
<a href="#l3.12336"></a><span id="l3.12336">   /*</span>
<a href="#l3.12337"></a><span id="l3.12337">    * Login can fail for various reasons:</span>
<a href="#l3.12338"></a><span id="l3.12338">    * 1. Server claims to support GSSAPI, but it really doesn't.</span>
<a href="#l3.12339"></a><span id="l3.12339">    *    Or the client doesn't support GSSAPI, or is not logged in yet.</span>
<a href="#l3.12340"></a><span id="l3.12340">    *    (GSSAPI is a mechanism without password in apps).</span>
<a href="#l3.12341"></a><span id="l3.12341">    * 2. Server claims to support CRAM-MD5, but it's broken and will fail despite correct password.</span>
<a href="#l3.12342"></a><span id="l3.12342">    * 2.1. Some servers say they support CRAM but are so badly broken that trying it causes</span>
<a href="#l3.12343"></a><span id="l3.12343">    *    all subsequent login attempts to fail during this connection (bug 231303).</span>
<a href="#l3.12344"></a><span id="l3.12344" class="difflineat">@@ -8934,172 +8157,165 @@ bool nsImapProtocol::TryToLogon()</span>
<a href="#l3.12345"></a><span id="l3.12345">    * 3. Prefs are set to require auth methods which the server doesn't support</span>
<a href="#l3.12346"></a><span id="l3.12346">    *     (per CAPS or we tried and they failed).</span>
<a href="#l3.12347"></a><span id="l3.12347">    * 4. User provided wrong password.</span>
<a href="#l3.12348"></a><span id="l3.12348">    * 5. We tried too often and the server shut us down, so even a correct attempt</span>
<a href="#l3.12349"></a><span id="l3.12349">    *    will now (currently) fail.</span>
<a href="#l3.12350"></a><span id="l3.12350">    * The above problems may overlap, e.g. 3. with 1. and 2., and we can't differentiate</span>
<a href="#l3.12351"></a><span id="l3.12351">    * between 2. and 4., which is really unfortunate.</span>
<a href="#l3.12352"></a><span id="l3.12352">    */</span>
<a href="#l3.12353"></a><span id="l3.12353" class="difflineplus">+  // clang-format on</span>
<a href="#l3.12354"></a><span id="l3.12354"> </span>
<a href="#l3.12355"></a><span id="l3.12355">   bool newPasswordRequested = false;</span>
<a href="#l3.12356"></a><span id="l3.12356">   // remember the msgWindow before we start trying to logon, because if the</span>
<a href="#l3.12357"></a><span id="l3.12357">   // server drops the connection on errors, TellThreadToDie will null out the</span>
<a href="#l3.12358"></a><span id="l3.12358">   // protocolsink and we won't be able to get the msgWindow.</span>
<a href="#l3.12359"></a><span id="l3.12359">   AutoProxyReleaseMsgWindow msgWindow;</span>
<a href="#l3.12360"></a><span id="l3.12360">   GetMsgWindow(getter_AddRefs(msgWindow));</span>
<a href="#l3.12361"></a><span id="l3.12361"> </span>
<a href="#l3.12362"></a><span id="l3.12362" class="difflineminus">-  // This loops over 1) auth methods (only one per loop) and 2) password tries (with UI)</span>
<a href="#l3.12363"></a><span id="l3.12363" class="difflineminus">-  while (!loginSucceeded &amp;&amp; !skipLoop &amp;&amp; !DeathSignalReceived())</span>
<a href="#l3.12364"></a><span id="l3.12364" class="difflineminus">-  {</span>
<a href="#l3.12365"></a><span id="l3.12365" class="difflineminus">-      // Get password</span>
<a href="#l3.12366"></a><span id="l3.12366" class="difflineminus">-      if (m_currentAuthMethod != kHasAuthGssApiCapability &amp;&amp; // GSSAPI uses no pw in apps</span>
<a href="#l3.12367"></a><span id="l3.12367" class="difflineminus">-          m_currentAuthMethod != kHasAuthExternalCapability &amp;&amp;</span>
<a href="#l3.12368"></a><span id="l3.12368" class="difflineminus">-          m_currentAuthMethod != kHasXOAuth2Capability &amp;&amp;</span>
<a href="#l3.12369"></a><span id="l3.12369" class="difflineminus">-          m_currentAuthMethod != kHasAuthNoneCapability)</span>
<a href="#l3.12370"></a><span id="l3.12370" class="difflineplus">+  // This loops over 1) auth methods (only one per loop) and 2) password tries</span>
<a href="#l3.12371"></a><span id="l3.12371" class="difflineplus">+  // (with UI)</span>
<a href="#l3.12372"></a><span id="l3.12372" class="difflineplus">+  while (!loginSucceeded &amp;&amp; !skipLoop &amp;&amp; !DeathSignalReceived()) {</span>
<a href="#l3.12373"></a><span id="l3.12373" class="difflineplus">+    // Get password</span>
<a href="#l3.12374"></a><span id="l3.12374" class="difflineplus">+    if (m_currentAuthMethod !=</span>
<a href="#l3.12375"></a><span id="l3.12375" class="difflineplus">+            kHasAuthGssApiCapability &amp;&amp;  // GSSAPI uses no pw in apps</span>
<a href="#l3.12376"></a><span id="l3.12376" class="difflineplus">+        m_currentAuthMethod != kHasAuthExternalCapability &amp;&amp;</span>
<a href="#l3.12377"></a><span id="l3.12377" class="difflineplus">+        m_currentAuthMethod != kHasXOAuth2Capability &amp;&amp;</span>
<a href="#l3.12378"></a><span id="l3.12378" class="difflineplus">+        m_currentAuthMethod != kHasAuthNoneCapability) {</span>
<a href="#l3.12379"></a><span id="l3.12379" class="difflineplus">+      rv = GetPassword(password, newPasswordRequested);</span>
<a href="#l3.12380"></a><span id="l3.12380" class="difflineplus">+      newPasswordRequested = false;</span>
<a href="#l3.12381"></a><span id="l3.12381" class="difflineplus">+      if (rv == NS_MSG_PASSWORD_PROMPT_CANCELLED || NS_FAILED(rv)) {</span>
<a href="#l3.12382"></a><span id="l3.12382" class="difflineplus">+        MOZ_LOG(IMAP, LogLevel::Error,</span>
<a href="#l3.12383"></a><span id="l3.12383" class="difflineplus">+                (&quot;IMAP: password prompt failed or user canceled it&quot;));</span>
<a href="#l3.12384"></a><span id="l3.12384" class="difflineplus">+        break;</span>
<a href="#l3.12385"></a><span id="l3.12385" class="difflineplus">+      }</span>
<a href="#l3.12386"></a><span id="l3.12386" class="difflineplus">+      MOZ_LOG(IMAP, LogLevel::Debug, (&quot;got new password&quot;));</span>
<a href="#l3.12387"></a><span id="l3.12387" class="difflineplus">+    }</span>
<a href="#l3.12388"></a><span id="l3.12388" class="difflineplus">+</span>
<a href="#l3.12389"></a><span id="l3.12389" class="difflineplus">+    bool lastReportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.12390"></a><span id="l3.12390" class="difflineplus">+    GetServerStateParser().SetReportingErrors(</span>
<a href="#l3.12391"></a><span id="l3.12391" class="difflineplus">+        false);  // turn off errors - we'll put up our own.</span>
<a href="#l3.12392"></a><span id="l3.12392" class="difflineplus">+</span>
<a href="#l3.12393"></a><span id="l3.12393" class="difflineplus">+    rv = AuthLogin(userName.get(), password, m_currentAuthMethod);</span>
<a href="#l3.12394"></a><span id="l3.12394" class="difflineplus">+</span>
<a href="#l3.12395"></a><span id="l3.12395" class="difflineplus">+    GetServerStateParser().SetReportingErrors(</span>
<a href="#l3.12396"></a><span id="l3.12396" class="difflineplus">+        lastReportingErrors);  // restore error reports</span>
<a href="#l3.12397"></a><span id="l3.12397" class="difflineplus">+    loginSucceeded = NS_SUCCEEDED(rv);</span>
<a href="#l3.12398"></a><span id="l3.12398" class="difflineplus">+</span>
<a href="#l3.12399"></a><span id="l3.12399" class="difflineplus">+    if (!loginSucceeded) {</span>
<a href="#l3.12400"></a><span id="l3.12400" class="difflineplus">+      MOZ_LOG(IMAP, LogLevel::Debug, (&quot;authlogin failed&quot;));</span>
<a href="#l3.12401"></a><span id="l3.12401" class="difflineplus">+      MarkAuthMethodAsFailed(m_currentAuthMethod);</span>
<a href="#l3.12402"></a><span id="l3.12402" class="difflineplus">+      rv = ChooseAuthMethod();  // change m_currentAuthMethod to try other one</span>
<a href="#l3.12403"></a><span id="l3.12403" class="difflineplus">+                                // next round</span>
<a href="#l3.12404"></a><span id="l3.12404" class="difflineplus">+</span>
<a href="#l3.12405"></a><span id="l3.12405" class="difflineplus">+      if (NS_FAILED(rv))  // all methods failed</span>
<a href="#l3.12406"></a><span id="l3.12406">       {</span>
<a href="#l3.12407"></a><span id="l3.12407" class="difflineminus">-          rv = GetPassword(password, newPasswordRequested);</span>
<a href="#l3.12408"></a><span id="l3.12408" class="difflineminus">-          newPasswordRequested = false;</span>
<a href="#l3.12409"></a><span id="l3.12409" class="difflineminus">-          if (rv == NS_MSG_PASSWORD_PROMPT_CANCELLED || NS_FAILED(rv))</span>
<a href="#l3.12410"></a><span id="l3.12410" class="difflineminus">-          {</span>
<a href="#l3.12411"></a><span id="l3.12411" class="difflineminus">-            MOZ_LOG(IMAP, LogLevel::Error, (&quot;IMAP: password prompt failed or user canceled it&quot;));</span>
<a href="#l3.12412"></a><span id="l3.12412" class="difflineminus">-            break;</span>
<a href="#l3.12413"></a><span id="l3.12413" class="difflineminus">-          }</span>
<a href="#l3.12414"></a><span id="l3.12414" class="difflineminus">-          MOZ_LOG(IMAP, LogLevel::Debug, (&quot;got new password&quot;));</span>
<a href="#l3.12415"></a><span id="l3.12415" class="difflineminus">-      }</span>
<a href="#l3.12416"></a><span id="l3.12416" class="difflineminus">-</span>
<a href="#l3.12417"></a><span id="l3.12417" class="difflineminus">-      bool lastReportingErrors = GetServerStateParser().GetReportingErrors();</span>
<a href="#l3.12418"></a><span id="l3.12418" class="difflineminus">-      GetServerStateParser().SetReportingErrors(false); // turn off errors - we'll put up our own.</span>
<a href="#l3.12419"></a><span id="l3.12419" class="difflineminus">-</span>
<a href="#l3.12420"></a><span id="l3.12420" class="difflineminus">-      rv = AuthLogin(userName.get(), password, m_currentAuthMethod);</span>
<a href="#l3.12421"></a><span id="l3.12421" class="difflineminus">-</span>
<a href="#l3.12422"></a><span id="l3.12422" class="difflineminus">-      GetServerStateParser().SetReportingErrors(lastReportingErrors); // restore error reports</span>
<a href="#l3.12423"></a><span id="l3.12423" class="difflineminus">-      loginSucceeded = NS_SUCCEEDED(rv);</span>
<a href="#l3.12424"></a><span id="l3.12424" class="difflineminus">-</span>
<a href="#l3.12425"></a><span id="l3.12425" class="difflineminus">-      if (!loginSucceeded)</span>
<a href="#l3.12426"></a><span id="l3.12426" class="difflineminus">-      {</span>
<a href="#l3.12427"></a><span id="l3.12427" class="difflineminus">-        MOZ_LOG(IMAP, LogLevel::Debug, (&quot;authlogin failed&quot;));</span>
<a href="#l3.12428"></a><span id="l3.12428" class="difflineminus">-        MarkAuthMethodAsFailed(m_currentAuthMethod);</span>
<a href="#l3.12429"></a><span id="l3.12429" class="difflineminus">-        rv = ChooseAuthMethod(); // change m_currentAuthMethod to try other one next round</span>
<a href="#l3.12430"></a><span id="l3.12430" class="difflineminus">-</span>
<a href="#l3.12431"></a><span id="l3.12431" class="difflineminus">-        if (NS_FAILED(rv)) // all methods failed</span>
<a href="#l3.12432"></a><span id="l3.12432" class="difflineplus">+        if (m_prefAuthMethods == kHasAuthGssApiCapability) {</span>
<a href="#l3.12433"></a><span id="l3.12433" class="difflineplus">+          // GSSAPI failed, and it's the only available method,</span>
<a href="#l3.12434"></a><span id="l3.12434" class="difflineplus">+          // and it's password-less, so nothing left to do.</span>
<a href="#l3.12435"></a><span id="l3.12435" class="difflineplus">+          AlertUserEventUsingName(&quot;imapAuthGssapiFailed&quot;);</span>
<a href="#l3.12436"></a><span id="l3.12436" class="difflineplus">+          break;</span>
<a href="#l3.12437"></a><span id="l3.12437" class="difflineplus">+        }</span>
<a href="#l3.12438"></a><span id="l3.12438" class="difflineplus">+</span>
<a href="#l3.12439"></a><span id="l3.12439" class="difflineplus">+        if (m_prefAuthMethods &amp; kHasXOAuth2Capability) {</span>
<a href="#l3.12440"></a><span id="l3.12440" class="difflineplus">+          // OAuth2 failed. Entering password does not help.</span>
<a href="#l3.12441"></a><span id="l3.12441" class="difflineplus">+          AlertUserEventUsingName(&quot;imapOAuth2Error&quot;);</span>
<a href="#l3.12442"></a><span id="l3.12442" class="difflineplus">+          break;</span>
<a href="#l3.12443"></a><span id="l3.12443" class="difflineplus">+        }</span>
<a href="#l3.12444"></a><span id="l3.12444" class="difflineplus">+</span>
<a href="#l3.12445"></a><span id="l3.12445" class="difflineplus">+        // The reason that we failed might be a wrong password, so</span>
<a href="#l3.12446"></a><span id="l3.12446" class="difflineplus">+        // ask user what to do</span>
<a href="#l3.12447"></a><span id="l3.12447" class="difflineplus">+        MOZ_LOG(IMAP, LogLevel::Warning,</span>
<a href="#l3.12448"></a><span id="l3.12448" class="difflineplus">+                (&quot;IMAP: ask user what to do (after login failed): new &quot;</span>
<a href="#l3.12449"></a><span id="l3.12449" class="difflineplus">+                 &quot;passwort, retry, cancel&quot;));</span>
<a href="#l3.12450"></a><span id="l3.12450" class="difflineplus">+        if (!m_imapServerSink) break;</span>
<a href="#l3.12451"></a><span id="l3.12451" class="difflineplus">+        // if there's no msg window, don't forget the password</span>
<a href="#l3.12452"></a><span id="l3.12452" class="difflineplus">+        if (!msgWindow) break;</span>
<a href="#l3.12453"></a><span id="l3.12453" class="difflineplus">+        int32_t buttonPressed = 1;</span>
<a href="#l3.12454"></a><span id="l3.12454" class="difflineplus">+        rv = m_imapServerSink-&gt;PromptLoginFailed(msgWindow, &amp;buttonPressed);</span>
<a href="#l3.12455"></a><span id="l3.12455" class="difflineplus">+        if (NS_FAILED(rv)) break;</span>
<a href="#l3.12456"></a><span id="l3.12456" class="difflineplus">+        if (buttonPressed == 2)  // 'New password' button</span>
<a href="#l3.12457"></a><span id="l3.12457">         {</span>
<a href="#l3.12458"></a><span id="l3.12458" class="difflineminus">-          if (m_prefAuthMethods == kHasAuthGssApiCapability)</span>
<a href="#l3.12459"></a><span id="l3.12459" class="difflineminus">-          {</span>
<a href="#l3.12460"></a><span id="l3.12460" class="difflineminus">-            // GSSAPI failed, and it's the only available method,</span>
<a href="#l3.12461"></a><span id="l3.12461" class="difflineminus">-            // and it's password-less, so nothing left to do.</span>
<a href="#l3.12462"></a><span id="l3.12462" class="difflineminus">-            AlertUserEventUsingName(&quot;imapAuthGssapiFailed&quot;);</span>
<a href="#l3.12463"></a><span id="l3.12463" class="difflineminus">-            break;</span>
<a href="#l3.12464"></a><span id="l3.12464" class="difflineminus">-          }</span>
<a href="#l3.12465"></a><span id="l3.12465" class="difflineminus">-</span>
<a href="#l3.12466"></a><span id="l3.12466" class="difflineminus">-          if (m_prefAuthMethods &amp; kHasXOAuth2Capability)</span>
<a href="#l3.12467"></a><span id="l3.12467" class="difflineminus">-          {</span>
<a href="#l3.12468"></a><span id="l3.12468" class="difflineminus">-            // OAuth2 failed. Entering password does not help.</span>
<a href="#l3.12469"></a><span id="l3.12469" class="difflineminus">-            AlertUserEventUsingName(&quot;imapOAuth2Error&quot;);</span>
<a href="#l3.12470"></a><span id="l3.12470" class="difflineminus">-            break;</span>
<a href="#l3.12471"></a><span id="l3.12471" class="difflineminus">-          }</span>
<a href="#l3.12472"></a><span id="l3.12472" class="difflineminus">-</span>
<a href="#l3.12473"></a><span id="l3.12473" class="difflineminus">-          // The reason that we failed might be a wrong password, so</span>
<a href="#l3.12474"></a><span id="l3.12474" class="difflineminus">-          // ask user what to do</span>
<a href="#l3.12475"></a><span id="l3.12475" class="difflineminus">-          MOZ_LOG(IMAP, LogLevel::Warning, (&quot;IMAP: ask user what to do (after login failed): new passwort, retry, cancel&quot;));</span>
<a href="#l3.12476"></a><span id="l3.12476" class="difflineminus">-          if (!m_imapServerSink)</span>
<a href="#l3.12477"></a><span id="l3.12477" class="difflineminus">-            break;</span>
<a href="#l3.12478"></a><span id="l3.12478" class="difflineminus">-          // if there's no msg window, don't forget the password</span>
<a href="#l3.12479"></a><span id="l3.12479" class="difflineminus">-          if (!msgWindow)</span>
<a href="#l3.12480"></a><span id="l3.12480" class="difflineminus">-            break;</span>
<a href="#l3.12481"></a><span id="l3.12481" class="difflineminus">-          int32_t buttonPressed = 1;</span>
<a href="#l3.12482"></a><span id="l3.12482" class="difflineminus">-          rv = m_imapServerSink-&gt;PromptLoginFailed(msgWindow,</span>
<a href="#l3.12483"></a><span id="l3.12483" class="difflineminus">-                                                    &amp;buttonPressed);</span>
<a href="#l3.12484"></a><span id="l3.12484" class="difflineminus">-          if (NS_FAILED(rv))</span>
<a href="#l3.12485"></a><span id="l3.12485" class="difflineminus">-            break;</span>
<a href="#l3.12486"></a><span id="l3.12486" class="difflineminus">-          if (buttonPressed == 2) // 'New password' button</span>
<a href="#l3.12487"></a><span id="l3.12487" class="difflineminus">-          {</span>
<a href="#l3.12488"></a><span id="l3.12488" class="difflineminus">-            MOZ_LOG(IMAP, LogLevel::Warning, (&quot;new password button pressed.&quot;));</span>
<a href="#l3.12489"></a><span id="l3.12489" class="difflineminus">-            // Forget the current password</span>
<a href="#l3.12490"></a><span id="l3.12490" class="difflineminus">-            password.Truncate();</span>
<a href="#l3.12491"></a><span id="l3.12491" class="difflineminus">-            m_hostSessionList-&gt;SetPasswordForHost(GetImapServerKey(), EmptyString());</span>
<a href="#l3.12492"></a><span id="l3.12492" class="difflineminus">-            m_imapServerSink-&gt;ForgetPassword();</span>
<a href="#l3.12493"></a><span id="l3.12493" class="difflineminus">-            m_password.Truncate();</span>
<a href="#l3.12494"></a><span id="l3.12494" class="difflineminus">-            MOZ_LOG(IMAP, LogLevel::Warning, (&quot;password reset (nulled)&quot;));</span>
<a href="#l3.12495"></a><span id="l3.12495" class="difflineminus">-            newPasswordRequested = true;</span>
<a href="#l3.12496"></a><span id="l3.12496" class="difflineminus">-            // Will call GetPassword() in beginning of next loop</span>
<a href="#l3.12497"></a><span id="l3.12497" class="difflineminus">-</span>
<a href="#l3.12498"></a><span id="l3.12498" class="difflineminus">-            // Try all possible auth methods again with the new password.</span>
<a href="#l3.12499"></a><span id="l3.12499" class="difflineminus">-            ResetAuthMethods();</span>
<a href="#l3.12500"></a><span id="l3.12500" class="difflineminus">-          }</span>
<a href="#l3.12501"></a><span id="l3.12501" class="difflineminus">-          else if (buttonPressed == 0) // Retry button</span>
<a href="#l3.12502"></a><span id="l3.12502" class="difflineminus">-          {</span>
<a href="#l3.12503"></a><span id="l3.12503" class="difflineminus">-            MOZ_LOG(IMAP, LogLevel::Warning, (&quot;retry button pressed&quot;));</span>
<a href="#l3.12504"></a><span id="l3.12504" class="difflineminus">-            // Try all possible auth methods again</span>
<a href="#l3.12505"></a><span id="l3.12505" class="difflineminus">-            ResetAuthMethods();</span>
<a href="#l3.12506"></a><span id="l3.12506" class="difflineminus">-          }</span>
<a href="#l3.12507"></a><span id="l3.12507" class="difflineminus">-          else if (buttonPressed == 1) // Cancel button</span>
<a href="#l3.12508"></a><span id="l3.12508" class="difflineminus">-          {</span>
<a href="#l3.12509"></a><span id="l3.12509" class="difflineminus">-            MOZ_LOG(IMAP, LogLevel::Warning, (&quot;cancel button pressed&quot;));</span>
<a href="#l3.12510"></a><span id="l3.12510" class="difflineminus">-            break; // Abort quickly</span>
<a href="#l3.12511"></a><span id="l3.12511" class="difflineminus">-          }</span>
<a href="#l3.12512"></a><span id="l3.12512" class="difflineminus">-</span>
<a href="#l3.12513"></a><span id="l3.12513" class="difflineminus">-          // TODO what is this for? When does it get set to != unknown again?</span>
<a href="#l3.12514"></a><span id="l3.12514" class="difflineminus">-          m_currentBiffState = nsIMsgFolder::nsMsgBiffState_Unknown;</span>
<a href="#l3.12515"></a><span id="l3.12515" class="difflineminus">-          SendSetBiffIndicatorEvent(m_currentBiffState);</span>
<a href="#l3.12516"></a><span id="l3.12516" class="difflineminus">-        } // all methods failed</span>
<a href="#l3.12517"></a><span id="l3.12517" class="difflineminus">-      } // login failed</span>
<a href="#l3.12518"></a><span id="l3.12518" class="difflineminus">-  } // while</span>
<a href="#l3.12519"></a><span id="l3.12519" class="difflineminus">-</span>
<a href="#l3.12520"></a><span id="l3.12520" class="difflineminus">-  if (loginSucceeded)</span>
<a href="#l3.12521"></a><span id="l3.12521" class="difflineminus">-  {</span>
<a href="#l3.12522"></a><span id="l3.12522" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Warning, (&quot;new password button pressed.&quot;));</span>
<a href="#l3.12523"></a><span id="l3.12523" class="difflineplus">+          // Forget the current password</span>
<a href="#l3.12524"></a><span id="l3.12524" class="difflineplus">+          password.Truncate();</span>
<a href="#l3.12525"></a><span id="l3.12525" class="difflineplus">+          m_hostSessionList-&gt;SetPasswordForHost(GetImapServerKey(),</span>
<a href="#l3.12526"></a><span id="l3.12526" class="difflineplus">+                                                EmptyString());</span>
<a href="#l3.12527"></a><span id="l3.12527" class="difflineplus">+          m_imapServerSink-&gt;ForgetPassword();</span>
<a href="#l3.12528"></a><span id="l3.12528" class="difflineplus">+          m_password.Truncate();</span>
<a href="#l3.12529"></a><span id="l3.12529" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Warning, (&quot;password reset (nulled)&quot;));</span>
<a href="#l3.12530"></a><span id="l3.12530" class="difflineplus">+          newPasswordRequested = true;</span>
<a href="#l3.12531"></a><span id="l3.12531" class="difflineplus">+          // Will call GetPassword() in beginning of next loop</span>
<a href="#l3.12532"></a><span id="l3.12532" class="difflineplus">+</span>
<a href="#l3.12533"></a><span id="l3.12533" class="difflineplus">+          // Try all possible auth methods again with the new password.</span>
<a href="#l3.12534"></a><span id="l3.12534" class="difflineplus">+          ResetAuthMethods();</span>
<a href="#l3.12535"></a><span id="l3.12535" class="difflineplus">+        } else if (buttonPressed == 0)  // Retry button</span>
<a href="#l3.12536"></a><span id="l3.12536" class="difflineplus">+        {</span>
<a href="#l3.12537"></a><span id="l3.12537" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Warning, (&quot;retry button pressed&quot;));</span>
<a href="#l3.12538"></a><span id="l3.12538" class="difflineplus">+          // Try all possible auth methods again</span>
<a href="#l3.12539"></a><span id="l3.12539" class="difflineplus">+          ResetAuthMethods();</span>
<a href="#l3.12540"></a><span id="l3.12540" class="difflineplus">+        } else if (buttonPressed == 1)  // Cancel button</span>
<a href="#l3.12541"></a><span id="l3.12541" class="difflineplus">+        {</span>
<a href="#l3.12542"></a><span id="l3.12542" class="difflineplus">+          MOZ_LOG(IMAP, LogLevel::Warning, (&quot;cancel button pressed&quot;));</span>
<a href="#l3.12543"></a><span id="l3.12543" class="difflineplus">+          break;  // Abort quickly</span>
<a href="#l3.12544"></a><span id="l3.12544" class="difflineplus">+        }</span>
<a href="#l3.12545"></a><span id="l3.12545" class="difflineplus">+</span>
<a href="#l3.12546"></a><span id="l3.12546" class="difflineplus">+        // TODO what is this for? When does it get set to != unknown again?</span>
<a href="#l3.12547"></a><span id="l3.12547" class="difflineplus">+        m_currentBiffState = nsIMsgFolder::nsMsgBiffState_Unknown;</span>
<a href="#l3.12548"></a><span id="l3.12548" class="difflineplus">+        SendSetBiffIndicatorEvent(m_currentBiffState);</span>
<a href="#l3.12549"></a><span id="l3.12549" class="difflineplus">+      }  // all methods failed</span>
<a href="#l3.12550"></a><span id="l3.12550" class="difflineplus">+    }    // login failed</span>
<a href="#l3.12551"></a><span id="l3.12551" class="difflineplus">+  }      // while</span>
<a href="#l3.12552"></a><span id="l3.12552" class="difflineplus">+</span>
<a href="#l3.12553"></a><span id="l3.12553" class="difflineplus">+  if (loginSucceeded) {</span>
<a href="#l3.12554"></a><span id="l3.12554">     MOZ_LOG(IMAP, LogLevel::Debug, (&quot;login succeeded&quot;));</span>
<a href="#l3.12555"></a><span id="l3.12555">     bool passwordAlreadyVerified;</span>
<a href="#l3.12556"></a><span id="l3.12556">     m_hostSessionList-&gt;SetPasswordForHost(GetImapServerKey(), password);</span>
<a href="#l3.12557"></a><span id="l3.12557" class="difflineminus">-    rv = m_hostSessionList-&gt;GetPasswordVerifiedOnline(GetImapServerKey(), passwordAlreadyVerified);</span>
<a href="#l3.12558"></a><span id="l3.12558" class="difflineplus">+    rv = m_hostSessionList-&gt;GetPasswordVerifiedOnline(GetImapServerKey(),</span>
<a href="#l3.12559"></a><span id="l3.12559" class="difflineplus">+                                                      passwordAlreadyVerified);</span>
<a href="#l3.12560"></a><span id="l3.12560">     if (NS_SUCCEEDED(rv) &amp;&amp; !passwordAlreadyVerified)</span>
<a href="#l3.12561"></a><span id="l3.12561">       m_hostSessionList-&gt;SetPasswordVerifiedOnline(GetImapServerKey());</span>
<a href="#l3.12562"></a><span id="l3.12562">     bool imapPasswordIsNew = !passwordAlreadyVerified;</span>
<a href="#l3.12563"></a><span id="l3.12563" class="difflineminus">-    if (imapPasswordIsNew)</span>
<a href="#l3.12564"></a><span id="l3.12564" class="difflineminus">-    {</span>
<a href="#l3.12565"></a><span id="l3.12565" class="difflineminus">-      if (m_currentBiffState == nsIMsgFolder::nsMsgBiffState_Unknown)</span>
<a href="#l3.12566"></a><span id="l3.12566" class="difflineminus">-      {</span>
<a href="#l3.12567"></a><span id="l3.12567" class="difflineminus">-          m_currentBiffState = nsIMsgFolder::nsMsgBiffState_NoMail;</span>
<a href="#l3.12568"></a><span id="l3.12568" class="difflineminus">-          SendSetBiffIndicatorEvent(m_currentBiffState);</span>
<a href="#l3.12569"></a><span id="l3.12569" class="difflineplus">+    if (imapPasswordIsNew) {</span>
<a href="#l3.12570"></a><span id="l3.12570" class="difflineplus">+      if (m_currentBiffState == nsIMsgFolder::nsMsgBiffState_Unknown) {</span>
<a href="#l3.12571"></a><span id="l3.12571" class="difflineplus">+        m_currentBiffState = nsIMsgFolder::nsMsgBiffState_NoMail;</span>
<a href="#l3.12572"></a><span id="l3.12572" class="difflineplus">+        SendSetBiffIndicatorEvent(m_currentBiffState);</span>
<a href="#l3.12573"></a><span id="l3.12573">       }</span>
<a href="#l3.12574"></a><span id="l3.12574">       m_imapServerSink-&gt;SetUserAuthenticated(true);</span>
<a href="#l3.12575"></a><span id="l3.12575">     }</span>
<a href="#l3.12576"></a><span id="l3.12576"> </span>
<a href="#l3.12577"></a><span id="l3.12577">     nsImapAction imapAction;</span>
<a href="#l3.12578"></a><span id="l3.12578">     m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.12579"></a><span id="l3.12579">     // We don't want to do any more processing if we're just</span>
<a href="#l3.12580"></a><span id="l3.12580">     // verifying the ability to logon because it can leave us in</span>
<a href="#l3.12581"></a><span id="l3.12581">     // a half-constructed state.</span>
<a href="#l3.12582"></a><span id="l3.12582">     if (imapAction != nsIImapUrl::nsImapVerifylogon)</span>
<a href="#l3.12583"></a><span id="l3.12583">       ProcessAfterAuthenticated();</span>
<a href="#l3.12584"></a><span id="l3.12584" class="difflineminus">-  }</span>
<a href="#l3.12585"></a><span id="l3.12585" class="difflineminus">-  else // login failed</span>
<a href="#l3.12586"></a><span id="l3.12586" class="difflineplus">+  } else  // login failed</span>
<a href="#l3.12587"></a><span id="l3.12587">   {</span>
<a href="#l3.12588"></a><span id="l3.12588">     MOZ_LOG(IMAP, LogLevel::Error, (&quot;login failed entirely&quot;));</span>
<a href="#l3.12589"></a><span id="l3.12589">     m_currentBiffState = nsIMsgFolder::nsMsgBiffState_Unknown;</span>
<a href="#l3.12590"></a><span id="l3.12590">     SendSetBiffIndicatorEvent(m_currentBiffState);</span>
<a href="#l3.12591"></a><span id="l3.12591">     HandleCurrentUrlError();</span>
<a href="#l3.12592"></a><span id="l3.12592" class="difflineminus">-    SetConnectionStatus(NS_ERROR_FAILURE); // stop netlib</span>
<a href="#l3.12593"></a><span id="l3.12593" class="difflineplus">+    SetConnectionStatus(NS_ERROR_FAILURE);  // stop netlib</span>
<a href="#l3.12594"></a><span id="l3.12594">   }</span>
<a href="#l3.12595"></a><span id="l3.12595"> </span>
<a href="#l3.12596"></a><span id="l3.12596">   return loginSucceeded;</span>
<a href="#l3.12597"></a><span id="l3.12597"> }</span>
<a href="#l3.12598"></a><span id="l3.12598"> </span>
<a href="#l3.12599"></a><span id="l3.12599" class="difflineminus">-void nsImapProtocol::UpdateFolderQuotaData(nsCString&amp; aQuotaRoot, uint32_t aUsed, uint32_t aMax)</span>
<a href="#l3.12600"></a><span id="l3.12600" class="difflineminus">-{</span>
<a href="#l3.12601"></a><span id="l3.12601" class="difflineplus">+void nsImapProtocol::UpdateFolderQuotaData(nsCString &amp;aQuotaRoot,</span>
<a href="#l3.12602"></a><span id="l3.12602" class="difflineplus">+                                           uint32_t aUsed, uint32_t aMax) {</span>
<a href="#l3.12603"></a><span id="l3.12603">   NS_ASSERTION(m_imapMailFolderSink, &quot;m_imapMailFolderSink is null!&quot;);</span>
<a href="#l3.12604"></a><span id="l3.12604"> </span>
<a href="#l3.12605"></a><span id="l3.12605">   m_imapMailFolderSink-&gt;SetFolderQuotaData(aQuotaRoot, aUsed, aMax);</span>
<a href="#l3.12606"></a><span id="l3.12606"> }</span>
<a href="#l3.12607"></a><span id="l3.12607"> </span>
<a href="#l3.12608"></a><span id="l3.12608" class="difflineminus">-void nsImapProtocol::GetQuotaDataIfSupported(const char *aBoxName)</span>
<a href="#l3.12609"></a><span id="l3.12609" class="difflineminus">-{</span>
<a href="#l3.12610"></a><span id="l3.12610" class="difflineplus">+void nsImapProtocol::GetQuotaDataIfSupported(const char *aBoxName) {</span>
<a href="#l3.12611"></a><span id="l3.12611">   // If server doesn't have quota support, don't do anything</span>
<a href="#l3.12612"></a><span id="l3.12612" class="difflineminus">-  if (! (GetServerStateParser().GetCapabilityFlag() &amp; kQuotaCapability))</span>
<a href="#l3.12613"></a><span id="l3.12613" class="difflineminus">-    return;</span>
<a href="#l3.12614"></a><span id="l3.12614" class="difflineplus">+  if (!(GetServerStateParser().GetCapabilityFlag() &amp; kQuotaCapability)) return;</span>
<a href="#l3.12615"></a><span id="l3.12615"> </span>
<a href="#l3.12616"></a><span id="l3.12616">   nsCString escapedName;</span>
<a href="#l3.12617"></a><span id="l3.12617">   CreateEscapedMailboxName(aBoxName, escapedName);</span>
<a href="#l3.12618"></a><span id="l3.12618"> </span>
<a href="#l3.12619"></a><span id="l3.12619">   IncrementCommandTagNumber();</span>
<a href="#l3.12620"></a><span id="l3.12620"> </span>
<a href="#l3.12621"></a><span id="l3.12621">   nsAutoCString quotacommand(GetServerCommandTag());</span>
<a href="#l3.12622"></a><span id="l3.12622">   quotacommand.AppendLiteral(&quot; getquotaroot \&quot;&quot;);</span>
<a href="#l3.12623"></a><span id="l3.12623" class="difflineat">@@ -9107,420 +8323,388 @@ void nsImapProtocol::GetQuotaDataIfSuppo</span>
<a href="#l3.12624"></a><span id="l3.12624">   quotacommand.AppendLiteral(&quot;\&quot;&quot; CRLF);</span>
<a href="#l3.12625"></a><span id="l3.12625"> </span>
<a href="#l3.12626"></a><span id="l3.12626">   NS_ASSERTION(m_imapMailFolderSink, &quot;m_imapMailFolderSink is null!&quot;);</span>
<a href="#l3.12627"></a><span id="l3.12627">   if (m_imapMailFolderSink)</span>
<a href="#l3.12628"></a><span id="l3.12628">     m_imapMailFolderSink-&gt;SetFolderQuotaCommandIssued(true);</span>
<a href="#l3.12629"></a><span id="l3.12629"> </span>
<a href="#l3.12630"></a><span id="l3.12630">   nsresult quotarv = SendData(quotacommand.get());</span>
<a href="#l3.12631"></a><span id="l3.12631">   if (NS_SUCCEEDED(quotarv))</span>
<a href="#l3.12632"></a><span id="l3.12632" class="difflineminus">-    ParseIMAPandCheckForNewMail(nullptr, true); // don't display errors.</span>
<a href="#l3.12633"></a><span id="l3.12633" class="difflineminus">-}</span>
<a href="#l3.12634"></a><span id="l3.12634" class="difflineminus">-</span>
<a href="#l3.12635"></a><span id="l3.12635" class="difflineminus">-bool</span>
<a href="#l3.12636"></a><span id="l3.12636" class="difflineminus">-nsImapProtocol::GetDeleteIsMoveToTrash()</span>
<a href="#l3.12637"></a><span id="l3.12637" class="difflineminus">-{</span>
<a href="#l3.12638"></a><span id="l3.12638" class="difflineminus">-    bool rv = false;</span>
<a href="#l3.12639"></a><span id="l3.12639" class="difflineminus">-    NS_ASSERTION (m_hostSessionList, &quot;fatal... null host session list&quot;);</span>
<a href="#l3.12640"></a><span id="l3.12640" class="difflineminus">-    if (m_hostSessionList)</span>
<a href="#l3.12641"></a><span id="l3.12641" class="difflineminus">-        m_hostSessionList-&gt;GetDeleteIsMoveToTrashForHost(GetImapServerKey(), rv);</span>
<a href="#l3.12642"></a><span id="l3.12642" class="difflineminus">-    return rv;</span>
<a href="#l3.12643"></a><span id="l3.12643" class="difflineminus">-}</span>
<a href="#l3.12644"></a><span id="l3.12644" class="difflineminus">-</span>
<a href="#l3.12645"></a><span id="l3.12645" class="difflineminus">-bool</span>
<a href="#l3.12646"></a><span id="l3.12646" class="difflineminus">-nsImapProtocol::GetShowDeletedMessages()</span>
<a href="#l3.12647"></a><span id="l3.12647" class="difflineminus">-{</span>
<a href="#l3.12648"></a><span id="l3.12648" class="difflineminus">-    bool rv = false;</span>
<a href="#l3.12649"></a><span id="l3.12649" class="difflineminus">-    if (m_hostSessionList)</span>
<a href="#l3.12650"></a><span id="l3.12650" class="difflineminus">-        m_hostSessionList-&gt;GetShowDeletedMessagesForHost(GetImapServerKey(), rv);</span>
<a href="#l3.12651"></a><span id="l3.12651" class="difflineminus">-    return rv;</span>
<a href="#l3.12652"></a><span id="l3.12652" class="difflineminus">-}</span>
<a href="#l3.12653"></a><span id="l3.12653" class="difflineminus">-</span>
<a href="#l3.12654"></a><span id="l3.12654" class="difflineminus">-bool nsImapProtocol::CheckNeeded()</span>
<a href="#l3.12655"></a><span id="l3.12655" class="difflineminus">-{</span>
<a href="#l3.12656"></a><span id="l3.12656" class="difflineminus">-  if (m_flagChangeCount &gt;= kFlagChangesBeforeCheck)</span>
<a href="#l3.12657"></a><span id="l3.12657" class="difflineminus">-    return true;</span>
<a href="#l3.12658"></a><span id="l3.12658" class="difflineplus">+    ParseIMAPandCheckForNewMail(nullptr, true);  // don't display errors.</span>
<a href="#l3.12659"></a><span id="l3.12659" class="difflineplus">+}</span>
<a href="#l3.12660"></a><span id="l3.12660" class="difflineplus">+</span>
<a href="#l3.12661"></a><span id="l3.12661" class="difflineplus">+bool nsImapProtocol::GetDeleteIsMoveToTrash() {</span>
<a href="#l3.12662"></a><span id="l3.12662" class="difflineplus">+  bool rv = false;</span>
<a href="#l3.12663"></a><span id="l3.12663" class="difflineplus">+  NS_ASSERTION(m_hostSessionList, &quot;fatal... null host session list&quot;);</span>
<a href="#l3.12664"></a><span id="l3.12664" class="difflineplus">+  if (m_hostSessionList)</span>
<a href="#l3.12665"></a><span id="l3.12665" class="difflineplus">+    m_hostSessionList-&gt;GetDeleteIsMoveToTrashForHost(GetImapServerKey(), rv);</span>
<a href="#l3.12666"></a><span id="l3.12666" class="difflineplus">+  return rv;</span>
<a href="#l3.12667"></a><span id="l3.12667" class="difflineplus">+}</span>
<a href="#l3.12668"></a><span id="l3.12668" class="difflineplus">+</span>
<a href="#l3.12669"></a><span id="l3.12669" class="difflineplus">+bool nsImapProtocol::GetShowDeletedMessages() {</span>
<a href="#l3.12670"></a><span id="l3.12670" class="difflineplus">+  bool rv = false;</span>
<a href="#l3.12671"></a><span id="l3.12671" class="difflineplus">+  if (m_hostSessionList)</span>
<a href="#l3.12672"></a><span id="l3.12672" class="difflineplus">+    m_hostSessionList-&gt;GetShowDeletedMessagesForHost(GetImapServerKey(), rv);</span>
<a href="#l3.12673"></a><span id="l3.12673" class="difflineplus">+  return rv;</span>
<a href="#l3.12674"></a><span id="l3.12674" class="difflineplus">+}</span>
<a href="#l3.12675"></a><span id="l3.12675" class="difflineplus">+</span>
<a href="#l3.12676"></a><span id="l3.12676" class="difflineplus">+bool nsImapProtocol::CheckNeeded() {</span>
<a href="#l3.12677"></a><span id="l3.12677" class="difflineplus">+  if (m_flagChangeCount &gt;= kFlagChangesBeforeCheck) return true;</span>
<a href="#l3.12678"></a><span id="l3.12678"> </span>
<a href="#l3.12679"></a><span id="l3.12679">   int32_t deltaInSeconds;</span>
<a href="#l3.12680"></a><span id="l3.12680"> </span>
<a href="#l3.12681"></a><span id="l3.12681">   PRTime2Seconds(PR_Now() - m_lastCheckTime, &amp;deltaInSeconds);</span>
<a href="#l3.12682"></a><span id="l3.12682"> </span>
<a href="#l3.12683"></a><span id="l3.12683">   return (deltaInSeconds &gt;= kMaxSecondsBeforeCheck);</span>
<a href="#l3.12684"></a><span id="l3.12684"> }</span>
<a href="#l3.12685"></a><span id="l3.12685"> </span>
<a href="#l3.12686"></a><span id="l3.12686" class="difflineminus">-bool nsImapProtocol::UseCondStore()</span>
<a href="#l3.12687"></a><span id="l3.12687" class="difflineminus">-{</span>
<a href="#l3.12688"></a><span id="l3.12688" class="difflineplus">+bool nsImapProtocol::UseCondStore() {</span>
<a href="#l3.12689"></a><span id="l3.12689">   // Check that the server is capable of cond store, and the user</span>
<a href="#l3.12690"></a><span id="l3.12690">   // hasn't disabled the use of constore for this server.</span>
<a href="#l3.12691"></a><span id="l3.12691">   return m_useCondStore &amp;&amp;</span>
<a href="#l3.12692"></a><span id="l3.12692">          GetServerStateParser().GetCapabilityFlag() &amp; kHasCondStoreCapability &amp;&amp;</span>
<a href="#l3.12693"></a><span id="l3.12693">          GetServerStateParser().fUseModSeq;</span>
<a href="#l3.12694"></a><span id="l3.12694"> }</span>
<a href="#l3.12695"></a><span id="l3.12695"> </span>
<a href="#l3.12696"></a><span id="l3.12696" class="difflineminus">-bool nsImapProtocol::UseCompressDeflate()</span>
<a href="#l3.12697"></a><span id="l3.12697" class="difflineminus">-{</span>
<a href="#l3.12698"></a><span id="l3.12698" class="difflineplus">+bool nsImapProtocol::UseCompressDeflate() {</span>
<a href="#l3.12699"></a><span id="l3.12699">   // Check that the server is capable of compression, and the user</span>
<a href="#l3.12700"></a><span id="l3.12700">   // hasn't disabled the use of compression for this server.</span>
<a href="#l3.12701"></a><span id="l3.12701" class="difflineminus">-  return m_useCompressDeflate &amp;&amp;</span>
<a href="#l3.12702"></a><span id="l3.12702" class="difflineminus">-         GetServerStateParser().GetCapabilityFlag() &amp; kHasCompressDeflateCapability;</span>
<a href="#l3.12703"></a><span id="l3.12703" class="difflineplus">+  return m_useCompressDeflate &amp;&amp; GetServerStateParser().GetCapabilityFlag() &amp;</span>
<a href="#l3.12704"></a><span id="l3.12704" class="difflineplus">+                                     kHasCompressDeflateCapability;</span>
<a href="#l3.12705"></a><span id="l3.12705"> }</span>
<a href="#l3.12706"></a><span id="l3.12706"> </span>
<a href="#l3.12707"></a><span id="l3.12707"> //////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.12708"></a><span id="l3.12708"> // The following is the implementation of nsImapMockChannel and an intermediary</span>
<a href="#l3.12709"></a><span id="l3.12709" class="difflineminus">-// imap steam listener. The stream listener is used to make a clean binding between the</span>
<a href="#l3.12710"></a><span id="l3.12710" class="difflineminus">-// imap mock channel and the memory cache channel (if we are reading from the cache)</span>
<a href="#l3.12711"></a><span id="l3.12711" class="difflineplus">+// imap steam listener. The stream listener is used to make a clean binding</span>
<a href="#l3.12712"></a><span id="l3.12712" class="difflineplus">+// between the imap mock channel and the memory cache channel (if we are reading</span>
<a href="#l3.12713"></a><span id="l3.12713" class="difflineplus">+// from the cache)</span>
<a href="#l3.12714"></a><span id="l3.12714"> //////////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.12715"></a><span id="l3.12715"> </span>
<a href="#l3.12716"></a><span id="l3.12716" class="difflineminus">-// WARNING: the cache stream listener is intended to be accessed from the UI thread!</span>
<a href="#l3.12717"></a><span id="l3.12717" class="difflineminus">-// it will NOT create another proxy for the stream listener that gets passed in...</span>
<a href="#l3.12718"></a><span id="l3.12718" class="difflineminus">-class nsImapCacheStreamListener : public nsIStreamListener</span>
<a href="#l3.12719"></a><span id="l3.12719" class="difflineminus">-{</span>
<a href="#l3.12720"></a><span id="l3.12720" class="difflineminus">-public:</span>
<a href="#l3.12721"></a><span id="l3.12721" class="difflineplus">+// WARNING: the cache stream listener is intended to be accessed from the UI</span>
<a href="#l3.12722"></a><span id="l3.12722" class="difflineplus">+// thread! it will NOT create another proxy for the stream listener that gets</span>
<a href="#l3.12723"></a><span id="l3.12723" class="difflineplus">+// passed in...</span>
<a href="#l3.12724"></a><span id="l3.12724" class="difflineplus">+class nsImapCacheStreamListener : public nsIStreamListener {</span>
<a href="#l3.12725"></a><span id="l3.12725" class="difflineplus">+ public:</span>
<a href="#l3.12726"></a><span id="l3.12726">   NS_DECL_ISUPPORTS</span>
<a href="#l3.12727"></a><span id="l3.12727">   NS_DECL_NSIREQUESTOBSERVER</span>
<a href="#l3.12728"></a><span id="l3.12728">   NS_DECL_NSISTREAMLISTENER</span>
<a href="#l3.12729"></a><span id="l3.12729"> </span>
<a href="#l3.12730"></a><span id="l3.12730" class="difflineminus">-  nsImapCacheStreamListener ();</span>
<a href="#l3.12731"></a><span id="l3.12731" class="difflineminus">-</span>
<a href="#l3.12732"></a><span id="l3.12732" class="difflineminus">-  nsresult Init(nsIStreamListener * aStreamListener, nsIImapMockChannel * aMockChannelToUse);</span>
<a href="#l3.12733"></a><span id="l3.12733" class="difflineminus">-protected:</span>
<a href="#l3.12734"></a><span id="l3.12734" class="difflineplus">+  nsImapCacheStreamListener();</span>
<a href="#l3.12735"></a><span id="l3.12735" class="difflineplus">+</span>
<a href="#l3.12736"></a><span id="l3.12736" class="difflineplus">+  nsresult Init(nsIStreamListener *aStreamListener,</span>
<a href="#l3.12737"></a><span id="l3.12737" class="difflineplus">+                nsIImapMockChannel *aMockChannelToUse);</span>
<a href="#l3.12738"></a><span id="l3.12738" class="difflineplus">+</span>
<a href="#l3.12739"></a><span id="l3.12739" class="difflineplus">+ protected:</span>
<a href="#l3.12740"></a><span id="l3.12740">   virtual ~nsImapCacheStreamListener();</span>
<a href="#l3.12741"></a><span id="l3.12741">   nsCOMPtr&lt;nsIImapMockChannel&gt; mChannelToUse;</span>
<a href="#l3.12742"></a><span id="l3.12742">   nsCOMPtr&lt;nsIStreamListener&gt; mListener;</span>
<a href="#l3.12743"></a><span id="l3.12743"> };</span>
<a href="#l3.12744"></a><span id="l3.12744"> </span>
<a href="#l3.12745"></a><span id="l3.12745"> NS_IMPL_ADDREF(nsImapCacheStreamListener)</span>
<a href="#l3.12746"></a><span id="l3.12746"> NS_IMPL_RELEASE(nsImapCacheStreamListener)</span>
<a href="#l3.12747"></a><span id="l3.12747"> </span>
<a href="#l3.12748"></a><span id="l3.12748"> NS_INTERFACE_MAP_BEGIN(nsImapCacheStreamListener)</span>
<a href="#l3.12749"></a><span id="l3.12749">   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamListener)</span>
<a href="#l3.12750"></a><span id="l3.12750">   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)</span>
<a href="#l3.12751"></a><span id="l3.12751">   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)</span>
<a href="#l3.12752"></a><span id="l3.12752"> NS_INTERFACE_MAP_END</span>
<a href="#l3.12753"></a><span id="l3.12753"> </span>
<a href="#l3.12754"></a><span id="l3.12754" class="difflineminus">-nsImapCacheStreamListener::nsImapCacheStreamListener()</span>
<a href="#l3.12755"></a><span id="l3.12755" class="difflineminus">-{</span>
<a href="#l3.12756"></a><span id="l3.12756" class="difflineminus">-}</span>
<a href="#l3.12757"></a><span id="l3.12757" class="difflineminus">-</span>
<a href="#l3.12758"></a><span id="l3.12758" class="difflineminus">-nsImapCacheStreamListener::~nsImapCacheStreamListener()</span>
<a href="#l3.12759"></a><span id="l3.12759" class="difflineminus">-{}</span>
<a href="#l3.12760"></a><span id="l3.12760" class="difflineminus">-</span>
<a href="#l3.12761"></a><span id="l3.12761" class="difflineminus">-nsresult nsImapCacheStreamListener::Init(nsIStreamListener * aStreamListener, nsIImapMockChannel * aMockChannelToUse)</span>
<a href="#l3.12762"></a><span id="l3.12762" class="difflineminus">-{</span>
<a href="#l3.12763"></a><span id="l3.12763" class="difflineplus">+nsImapCacheStreamListener::nsImapCacheStreamListener() {}</span>
<a href="#l3.12764"></a><span id="l3.12764" class="difflineplus">+</span>
<a href="#l3.12765"></a><span id="l3.12765" class="difflineplus">+nsImapCacheStreamListener::~nsImapCacheStreamListener() {}</span>
<a href="#l3.12766"></a><span id="l3.12766" class="difflineplus">+</span>
<a href="#l3.12767"></a><span id="l3.12767" class="difflineplus">+nsresult nsImapCacheStreamListener::Init(</span>
<a href="#l3.12768"></a><span id="l3.12768" class="difflineplus">+    nsIStreamListener *aStreamListener, nsIImapMockChannel *aMockChannelToUse) {</span>
<a href="#l3.12769"></a><span id="l3.12769">   NS_ENSURE_ARG(aStreamListener);</span>
<a href="#l3.12770"></a><span id="l3.12770">   NS_ENSURE_ARG(aMockChannelToUse);</span>
<a href="#l3.12771"></a><span id="l3.12771"> </span>
<a href="#l3.12772"></a><span id="l3.12772">   mChannelToUse = aMockChannelToUse;</span>
<a href="#l3.12773"></a><span id="l3.12773">   mListener = aStreamListener;</span>
<a href="#l3.12774"></a><span id="l3.12774"> </span>
<a href="#l3.12775"></a><span id="l3.12775">   return NS_OK;</span>
<a href="#l3.12776"></a><span id="l3.12776"> }</span>
<a href="#l3.12777"></a><span id="l3.12777"> </span>
<a href="#l3.12778"></a><span id="l3.12778"> NS_IMETHODIMP</span>
<a href="#l3.12779"></a><span id="l3.12779" class="difflineminus">-nsImapCacheStreamListener::OnStartRequest(nsIRequest *request)</span>
<a href="#l3.12780"></a><span id="l3.12780" class="difflineminus">-{</span>
<a href="#l3.12781"></a><span id="l3.12781" class="difflineminus">-  if (!mChannelToUse)</span>
<a href="#l3.12782"></a><span id="l3.12782" class="difflineminus">-  {</span>
<a href="#l3.12783"></a><span id="l3.12783" class="difflineplus">+nsImapCacheStreamListener::OnStartRequest(nsIRequest *request) {</span>
<a href="#l3.12784"></a><span id="l3.12784" class="difflineplus">+  if (!mChannelToUse) {</span>
<a href="#l3.12785"></a><span id="l3.12785">     NS_ERROR(&quot;OnStartRequest called after OnStopRequest&quot;);</span>
<a href="#l3.12786"></a><span id="l3.12786">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.12787"></a><span id="l3.12787">   }</span>
<a href="#l3.12788"></a><span id="l3.12788">   nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.12789"></a><span id="l3.12789">   mChannelToUse-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.12790"></a><span id="l3.12790">   if (loadGroup)</span>
<a href="#l3.12791"></a><span id="l3.12791">     loadGroup-&gt;AddRequest(mChannelToUse, nullptr /* context isupports */);</span>
<a href="#l3.12792"></a><span id="l3.12792">   return mListener-&gt;OnStartRequest(mChannelToUse);</span>
<a href="#l3.12793"></a><span id="l3.12793"> }</span>
<a href="#l3.12794"></a><span id="l3.12794"> </span>
<a href="#l3.12795"></a><span id="l3.12795"> NS_IMETHODIMP</span>
<a href="#l3.12796"></a><span id="l3.12796" class="difflineminus">-nsImapCacheStreamListener::OnStopRequest(nsIRequest *request, nsresult aStatus)</span>
<a href="#l3.12797"></a><span id="l3.12797" class="difflineminus">-{</span>
<a href="#l3.12798"></a><span id="l3.12798" class="difflineminus">-  if (!mListener)</span>
<a href="#l3.12799"></a><span id="l3.12799" class="difflineminus">-  {</span>
<a href="#l3.12800"></a><span id="l3.12800" class="difflineplus">+nsImapCacheStreamListener::OnStopRequest(nsIRequest *request,</span>
<a href="#l3.12801"></a><span id="l3.12801" class="difflineplus">+                                         nsresult aStatus) {</span>
<a href="#l3.12802"></a><span id="l3.12802" class="difflineplus">+  if (!mListener) {</span>
<a href="#l3.12803"></a><span id="l3.12803">     NS_ERROR(&quot;OnStopRequest called twice&quot;);</span>
<a href="#l3.12804"></a><span id="l3.12804">     return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.12805"></a><span id="l3.12805">   }</span>
<a href="#l3.12806"></a><span id="l3.12806">   nsresult rv = mListener-&gt;OnStopRequest(mChannelToUse, aStatus);</span>
<a href="#l3.12807"></a><span id="l3.12807" class="difflineminus">-  nsCOMPtr &lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.12808"></a><span id="l3.12808" class="difflineplus">+  nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.12809"></a><span id="l3.12809">   mChannelToUse-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.12810"></a><span id="l3.12810" class="difflineminus">-  if (loadGroup)</span>
<a href="#l3.12811"></a><span id="l3.12811" class="difflineminus">-    loadGroup-&gt;RemoveRequest(mChannelToUse, nullptr, aStatus);</span>
<a href="#l3.12812"></a><span id="l3.12812" class="difflineplus">+  if (loadGroup) loadGroup-&gt;RemoveRequest(mChannelToUse, nullptr, aStatus);</span>
<a href="#l3.12813"></a><span id="l3.12813"> </span>
<a href="#l3.12814"></a><span id="l3.12814">   mListener = nullptr;</span>
<a href="#l3.12815"></a><span id="l3.12815">   mChannelToUse-&gt;Close();</span>
<a href="#l3.12816"></a><span id="l3.12816">   mChannelToUse = nullptr;</span>
<a href="#l3.12817"></a><span id="l3.12817">   return rv;</span>
<a href="#l3.12818"></a><span id="l3.12818"> }</span>
<a href="#l3.12819"></a><span id="l3.12819"> </span>
<a href="#l3.12820"></a><span id="l3.12820"> NS_IMETHODIMP</span>
<a href="#l3.12821"></a><span id="l3.12821" class="difflineminus">-nsImapCacheStreamListener::OnDataAvailable(nsIRequest *request, nsIInputStream * aInStream, uint64_t aSourceOffset, uint32_t aCount)</span>
<a href="#l3.12822"></a><span id="l3.12822" class="difflineminus">-{</span>
<a href="#l3.12823"></a><span id="l3.12823" class="difflineminus">-  return mListener-&gt;OnDataAvailable(mChannelToUse, aInStream, aSourceOffset, aCount);</span>
<a href="#l3.12824"></a><span id="l3.12824" class="difflineminus">-}</span>
<a href="#l3.12825"></a><span id="l3.12825" class="difflineminus">-</span>
<a href="#l3.12826"></a><span id="l3.12826" class="difflineminus">-NS_IMPL_ISUPPORTS(nsImapMockChannel, nsIImapMockChannel, nsIChannel,</span>
<a href="#l3.12827"></a><span id="l3.12827" class="difflineminus">-  nsIRequest, nsICacheEntryOpenCallback, nsITransportEventSink, nsISupportsWeakReference)</span>
<a href="#l3.12828"></a><span id="l3.12828" class="difflineminus">-</span>
<a href="#l3.12829"></a><span id="l3.12829" class="difflineminus">-</span>
<a href="#l3.12830"></a><span id="l3.12830" class="difflineminus">-nsImapMockChannel::nsImapMockChannel()</span>
<a href="#l3.12831"></a><span id="l3.12831" class="difflineminus">-{</span>
<a href="#l3.12832"></a><span id="l3.12832" class="difflineplus">+nsImapCacheStreamListener::OnDataAvailable(nsIRequest *request,</span>
<a href="#l3.12833"></a><span id="l3.12833" class="difflineplus">+                                           nsIInputStream *aInStream,</span>
<a href="#l3.12834"></a><span id="l3.12834" class="difflineplus">+                                           uint64_t aSourceOffset,</span>
<a href="#l3.12835"></a><span id="l3.12835" class="difflineplus">+                                           uint32_t aCount) {</span>
<a href="#l3.12836"></a><span id="l3.12836" class="difflineplus">+  return mListener-&gt;OnDataAvailable(mChannelToUse, aInStream, aSourceOffset,</span>
<a href="#l3.12837"></a><span id="l3.12837" class="difflineplus">+                                    aCount);</span>
<a href="#l3.12838"></a><span id="l3.12838" class="difflineplus">+}</span>
<a href="#l3.12839"></a><span id="l3.12839" class="difflineplus">+</span>
<a href="#l3.12840"></a><span id="l3.12840" class="difflineplus">+NS_IMPL_ISUPPORTS(nsImapMockChannel, nsIImapMockChannel, nsIChannel, nsIRequest,</span>
<a href="#l3.12841"></a><span id="l3.12841" class="difflineplus">+                  nsICacheEntryOpenCallback, nsITransportEventSink,</span>
<a href="#l3.12842"></a><span id="l3.12842" class="difflineplus">+                  nsISupportsWeakReference)</span>
<a href="#l3.12843"></a><span id="l3.12843" class="difflineplus">+</span>
<a href="#l3.12844"></a><span id="l3.12844" class="difflineplus">+nsImapMockChannel::nsImapMockChannel() {</span>
<a href="#l3.12845"></a><span id="l3.12845">   m_channelContext = nullptr;</span>
<a href="#l3.12846"></a><span id="l3.12846">   m_cancelStatus = NS_OK;</span>
<a href="#l3.12847"></a><span id="l3.12847">   mLoadFlags = 0;</span>
<a href="#l3.12848"></a><span id="l3.12848">   mChannelClosed = false;</span>
<a href="#l3.12849"></a><span id="l3.12849">   mReadingFromCache = false;</span>
<a href="#l3.12850"></a><span id="l3.12850">   mTryingToReadPart = false;</span>
<a href="#l3.12851"></a><span id="l3.12851"> }</span>
<a href="#l3.12852"></a><span id="l3.12852"> </span>
<a href="#l3.12853"></a><span id="l3.12853" class="difflineminus">-nsImapMockChannel::~nsImapMockChannel()</span>
<a href="#l3.12854"></a><span id="l3.12854" class="difflineminus">-{</span>
<a href="#l3.12855"></a><span id="l3.12855" class="difflineplus">+nsImapMockChannel::~nsImapMockChannel() {</span>
<a href="#l3.12856"></a><span id="l3.12856">   // if we're offline, we may not get to close the channel correctly.</span>
<a href="#l3.12857"></a><span id="l3.12857">   // we need to do this to send the url state change notification in</span>
<a href="#l3.12858"></a><span id="l3.12858">   // the case of mem and disk cache reads.</span>
<a href="#l3.12859"></a><span id="l3.12859" class="difflineminus">-  NS_WARNING_ASSERTION(NS_IsMainThread(), &quot;should only access mock channel on ui thread&quot;);</span>
<a href="#l3.12860"></a><span id="l3.12860" class="difflineminus">-  if (!mChannelClosed)</span>
<a href="#l3.12861"></a><span id="l3.12861" class="difflineminus">-    Close();</span>
<a href="#l3.12862"></a><span id="l3.12862" class="difflineminus">-}</span>
<a href="#l3.12863"></a><span id="l3.12863" class="difflineminus">-</span>
<a href="#l3.12864"></a><span id="l3.12864" class="difflineminus">-nsresult nsImapMockChannel::NotifyStartEndReadFromCache(bool start)</span>
<a href="#l3.12865"></a><span id="l3.12865" class="difflineminus">-{</span>
<a href="#l3.12866"></a><span id="l3.12866" class="difflineplus">+  NS_WARNING_ASSERTION(NS_IsMainThread(),</span>
<a href="#l3.12867"></a><span id="l3.12867" class="difflineplus">+                       &quot;should only access mock channel on ui thread&quot;);</span>
<a href="#l3.12868"></a><span id="l3.12868" class="difflineplus">+  if (!mChannelClosed) Close();</span>
<a href="#l3.12869"></a><span id="l3.12869" class="difflineplus">+}</span>
<a href="#l3.12870"></a><span id="l3.12870" class="difflineplus">+</span>
<a href="#l3.12871"></a><span id="l3.12871" class="difflineplus">+nsresult nsImapMockChannel::NotifyStartEndReadFromCache(bool start) {</span>
<a href="#l3.12872"></a><span id="l3.12872">   nsresult rv = NS_OK;</span>
<a href="#l3.12873"></a><span id="l3.12873">   mReadingFromCache = start;</span>
<a href="#l3.12874"></a><span id="l3.12874">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url, &amp;rv);</span>
<a href="#l3.12875"></a><span id="l3.12875">   nsCOMPtr&lt;nsIImapProtocol&gt; imapProtocol = do_QueryReferent(mProtocol);</span>
<a href="#l3.12876"></a><span id="l3.12876" class="difflineminus">-  if (imapUrl)</span>
<a href="#l3.12877"></a><span id="l3.12877" class="difflineminus">-  {</span>
<a href="#l3.12878"></a><span id="l3.12878" class="difflineplus">+  if (imapUrl) {</span>
<a href="#l3.12879"></a><span id="l3.12879">     nsCOMPtr&lt;nsIImapMailFolderSink&gt; folderSink;</span>
<a href="#l3.12880"></a><span id="l3.12880">     rv = imapUrl-&gt;GetImapMailFolderSink(getter_AddRefs(folderSink));</span>
<a href="#l3.12881"></a><span id="l3.12881" class="difflineminus">-    if (folderSink)</span>
<a href="#l3.12882"></a><span id="l3.12882" class="difflineminus">-    {</span>
<a href="#l3.12883"></a><span id="l3.12883" class="difflineplus">+    if (folderSink) {</span>
<a href="#l3.12884"></a><span id="l3.12884">       nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(m_url);</span>
<a href="#l3.12885"></a><span id="l3.12885">       rv = folderSink-&gt;SetUrlState(nullptr /* we don't know the protocol */,</span>
<a href="#l3.12886"></a><span id="l3.12886">                                    mailUrl, start, false, m_cancelStatus);</span>
<a href="#l3.12887"></a><span id="l3.12887"> </span>
<a href="#l3.12888"></a><span id="l3.12888">       // Required for killing ImapProtocol thread</span>
<a href="#l3.12889"></a><span id="l3.12889">       if (NS_FAILED(m_cancelStatus) &amp;&amp; imapProtocol)</span>
<a href="#l3.12890"></a><span id="l3.12890">         imapProtocol-&gt;TellThreadToDie(false);</span>
<a href="#l3.12891"></a><span id="l3.12891">     }</span>
<a href="#l3.12892"></a><span id="l3.12892">   }</span>
<a href="#l3.12893"></a><span id="l3.12893">   return rv;</span>
<a href="#l3.12894"></a><span id="l3.12894"> }</span>
<a href="#l3.12895"></a><span id="l3.12895"> </span>
<a href="#l3.12896"></a><span id="l3.12896" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::Close()</span>
<a href="#l3.12897"></a><span id="l3.12897" class="difflineminus">-{</span>
<a href="#l3.12898"></a><span id="l3.12898" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::Close() {</span>
<a href="#l3.12899"></a><span id="l3.12899">   if (mReadingFromCache)</span>
<a href="#l3.12900"></a><span id="l3.12900">     NotifyStartEndReadFromCache(false);</span>
<a href="#l3.12901"></a><span id="l3.12901" class="difflineminus">-  else</span>
<a href="#l3.12902"></a><span id="l3.12902" class="difflineminus">-  {</span>
<a href="#l3.12903"></a><span id="l3.12903" class="difflineplus">+  else {</span>
<a href="#l3.12904"></a><span id="l3.12904">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url);</span>
<a href="#l3.12905"></a><span id="l3.12905" class="difflineminus">-    if (mailnewsUrl)</span>
<a href="#l3.12906"></a><span id="l3.12906" class="difflineminus">-    {</span>
<a href="#l3.12907"></a><span id="l3.12907" class="difflineplus">+    if (mailnewsUrl) {</span>
<a href="#l3.12908"></a><span id="l3.12908">       nsCOMPtr&lt;nsICacheEntry&gt; cacheEntry;</span>
<a href="#l3.12909"></a><span id="l3.12909">       mailnewsUrl-&gt;GetMemCacheEntry(getter_AddRefs(cacheEntry));</span>
<a href="#l3.12910"></a><span id="l3.12910" class="difflineminus">-      if (cacheEntry)</span>
<a href="#l3.12911"></a><span id="l3.12911" class="difflineminus">-        cacheEntry-&gt;MarkValid();</span>
<a href="#l3.12912"></a><span id="l3.12912" class="difflineplus">+      if (cacheEntry) cacheEntry-&gt;MarkValid();</span>
<a href="#l3.12913"></a><span id="l3.12913">       // remove the channel from the load group</span>
<a href="#l3.12914"></a><span id="l3.12914" class="difflineminus">-      nsCOMPtr &lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.12915"></a><span id="l3.12915" class="difflineplus">+      nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.12916"></a><span id="l3.12916">       GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.12917"></a><span id="l3.12917">       // if the mock channel wasn't initialized with a load group then</span>
<a href="#l3.12918"></a><span id="l3.12918">       // use our load group (they may differ)</span>
<a href="#l3.12919"></a><span id="l3.12919" class="difflineminus">-      if (!loadGroup)</span>
<a href="#l3.12920"></a><span id="l3.12920" class="difflineminus">-        mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.12921"></a><span id="l3.12921" class="difflineplus">+      if (!loadGroup) mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.12922"></a><span id="l3.12922">       if (loadGroup)</span>
<a href="#l3.12923"></a><span id="l3.12923" class="difflineminus">-        loadGroup-&gt;RemoveRequest((nsIRequest *) this, nullptr, NS_OK);</span>
<a href="#l3.12924"></a><span id="l3.12924" class="difflineplus">+        loadGroup-&gt;RemoveRequest((nsIRequest *)this, nullptr, NS_OK);</span>
<a href="#l3.12925"></a><span id="l3.12925">     }</span>
<a href="#l3.12926"></a><span id="l3.12926">   }</span>
<a href="#l3.12927"></a><span id="l3.12927"> </span>
<a href="#l3.12928"></a><span id="l3.12928">   m_channelListener = nullptr;</span>
<a href="#l3.12929"></a><span id="l3.12929">   mCacheRequest = nullptr;</span>
<a href="#l3.12930"></a><span id="l3.12930" class="difflineminus">-  if (mTryingToReadPart)</span>
<a href="#l3.12931"></a><span id="l3.12931" class="difflineminus">-  {</span>
<a href="#l3.12932"></a><span id="l3.12932" class="difflineplus">+  if (mTryingToReadPart) {</span>
<a href="#l3.12933"></a><span id="l3.12933">     // clear mem cache entry on imap part url in case it's holding</span>
<a href="#l3.12934"></a><span id="l3.12934">     // onto last reference in mem cache. Need to do this on ui thread</span>
<a href="#l3.12935"></a><span id="l3.12935">     nsresult rv;</span>
<a href="#l3.12936"></a><span id="l3.12936" class="difflineminus">-    nsCOMPtr &lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url, &amp;rv);</span>
<a href="#l3.12937"></a><span id="l3.12937" class="difflineminus">-    if (imapUrl)</span>
<a href="#l3.12938"></a><span id="l3.12938" class="difflineminus">-    {</span>
<a href="#l3.12939"></a><span id="l3.12939" class="difflineminus">-      nsCOMPtr &lt;nsIImapMailFolderSink&gt; folderSink;</span>
<a href="#l3.12940"></a><span id="l3.12940" class="difflineplus">+    nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url, &amp;rv);</span>
<a href="#l3.12941"></a><span id="l3.12941" class="difflineplus">+    if (imapUrl) {</span>
<a href="#l3.12942"></a><span id="l3.12942" class="difflineplus">+      nsCOMPtr&lt;nsIImapMailFolderSink&gt; folderSink;</span>
<a href="#l3.12943"></a><span id="l3.12943">       rv = imapUrl-&gt;GetImapMailFolderSink(getter_AddRefs(folderSink));</span>
<a href="#l3.12944"></a><span id="l3.12944" class="difflineminus">-      if (folderSink)</span>
<a href="#l3.12945"></a><span id="l3.12945" class="difflineminus">-      {</span>
<a href="#l3.12946"></a><span id="l3.12946" class="difflineminus">-        nsCOMPtr &lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(m_url);</span>
<a href="#l3.12947"></a><span id="l3.12947" class="difflineplus">+      if (folderSink) {</span>
<a href="#l3.12948"></a><span id="l3.12948" class="difflineplus">+        nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(m_url);</span>
<a href="#l3.12949"></a><span id="l3.12949">         rv = folderSink-&gt;ReleaseUrlCacheEntry(mailUrl);</span>
<a href="#l3.12950"></a><span id="l3.12950">       }</span>
<a href="#l3.12951"></a><span id="l3.12951">     }</span>
<a href="#l3.12952"></a><span id="l3.12952">   }</span>
<a href="#l3.12953"></a><span id="l3.12953">   mChannelClosed = true;</span>
<a href="#l3.12954"></a><span id="l3.12954">   return NS_OK;</span>
<a href="#l3.12955"></a><span id="l3.12955"> }</span>
<a href="#l3.12956"></a><span id="l3.12956"> </span>
<a href="#l3.12957"></a><span id="l3.12957" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetProgressEventSink(nsIProgressEventSink ** aProgressEventSink)</span>
<a href="#l3.12958"></a><span id="l3.12958" class="difflineminus">-{</span>
<a href="#l3.12959"></a><span id="l3.12959" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetProgressEventSink(</span>
<a href="#l3.12960"></a><span id="l3.12960" class="difflineplus">+    nsIProgressEventSink **aProgressEventSink) {</span>
<a href="#l3.12961"></a><span id="l3.12961">   NS_IF_ADDREF(*aProgressEventSink = mProgressEventSink);</span>
<a href="#l3.12962"></a><span id="l3.12962">   return NS_OK;</span>
<a href="#l3.12963"></a><span id="l3.12963"> }</span>
<a href="#l3.12964"></a><span id="l3.12964"> </span>
<a href="#l3.12965"></a><span id="l3.12965" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetProgressEventSink(nsIProgressEventSink * aProgressEventSink)</span>
<a href="#l3.12966"></a><span id="l3.12966" class="difflineminus">-{</span>
<a href="#l3.12967"></a><span id="l3.12967" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetProgressEventSink(</span>
<a href="#l3.12968"></a><span id="l3.12968" class="difflineplus">+    nsIProgressEventSink *aProgressEventSink) {</span>
<a href="#l3.12969"></a><span id="l3.12969">   mProgressEventSink = aProgressEventSink;</span>
<a href="#l3.12970"></a><span id="l3.12970">   return NS_OK;</span>
<a href="#l3.12971"></a><span id="l3.12971"> }</span>
<a href="#l3.12972"></a><span id="l3.12972"> </span>
<a href="#l3.12973"></a><span id="l3.12973" class="difflineminus">-NS_IMETHODIMP  nsImapMockChannel::GetChannelListener(nsIStreamListener **aChannelListener)</span>
<a href="#l3.12974"></a><span id="l3.12974" class="difflineminus">-{</span>
<a href="#l3.12975"></a><span id="l3.12975" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetChannelListener(</span>
<a href="#l3.12976"></a><span id="l3.12976" class="difflineplus">+    nsIStreamListener **aChannelListener) {</span>
<a href="#l3.12977"></a><span id="l3.12977">   NS_IF_ADDREF(*aChannelListener = m_channelListener);</span>
<a href="#l3.12978"></a><span id="l3.12978">   return NS_OK;</span>
<a href="#l3.12979"></a><span id="l3.12979"> }</span>
<a href="#l3.12980"></a><span id="l3.12980"> </span>
<a href="#l3.12981"></a><span id="l3.12981" class="difflineminus">-NS_IMETHODIMP  nsImapMockChannel::GetChannelContext(nsISupports **aChannelContext)</span>
<a href="#l3.12982"></a><span id="l3.12982" class="difflineminus">-{</span>
<a href="#l3.12983"></a><span id="l3.12983" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetChannelContext(</span>
<a href="#l3.12984"></a><span id="l3.12984" class="difflineplus">+    nsISupports **aChannelContext) {</span>
<a href="#l3.12985"></a><span id="l3.12985">   NS_IF_ADDREF(*aChannelContext = m_channelContext);</span>
<a href="#l3.12986"></a><span id="l3.12986">   return NS_OK;</span>
<a href="#l3.12987"></a><span id="l3.12987"> }</span>
<a href="#l3.12988"></a><span id="l3.12988"> </span>
<a href="#l3.12989"></a><span id="l3.12989" class="difflineminus">-// now implement our mock implementation of the channel interface...we forward all calls to the real</span>
<a href="#l3.12990"></a><span id="l3.12990" class="difflineminus">-// channel if we have one...otherwise we return something bogus...</span>
<a href="#l3.12991"></a><span id="l3.12991" class="difflineminus">-</span>
<a href="#l3.12992"></a><span id="l3.12992" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetLoadGroup(nsILoadGroup * aLoadGroup)</span>
<a href="#l3.12993"></a><span id="l3.12993" class="difflineminus">-{</span>
<a href="#l3.12994"></a><span id="l3.12994" class="difflineplus">+// now implement our mock implementation of the channel interface...we forward</span>
<a href="#l3.12995"></a><span id="l3.12995" class="difflineplus">+// all calls to the real channel if we have one...otherwise we return something</span>
<a href="#l3.12996"></a><span id="l3.12996" class="difflineplus">+// bogus...</span>
<a href="#l3.12997"></a><span id="l3.12997" class="difflineplus">+</span>
<a href="#l3.12998"></a><span id="l3.12998" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetLoadGroup(nsILoadGroup *aLoadGroup) {</span>
<a href="#l3.12999"></a><span id="l3.12999">   m_loadGroup = aLoadGroup;</span>
<a href="#l3.13000"></a><span id="l3.13000">   return NS_OK;</span>
<a href="#l3.13001"></a><span id="l3.13001"> }</span>
<a href="#l3.13002"></a><span id="l3.13002"> </span>
<a href="#l3.13003"></a><span id="l3.13003" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetLoadGroup(nsILoadGroup * *aLoadGroup)</span>
<a href="#l3.13004"></a><span id="l3.13004" class="difflineminus">-{</span>
<a href="#l3.13005"></a><span id="l3.13005" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetLoadGroup(nsILoadGroup **aLoadGroup) {</span>
<a href="#l3.13006"></a><span id="l3.13006">   NS_IF_ADDREF(*aLoadGroup = m_loadGroup);</span>
<a href="#l3.13007"></a><span id="l3.13007">   return NS_OK;</span>
<a href="#l3.13008"></a><span id="l3.13008"> }</span>
<a href="#l3.13009"></a><span id="l3.13009"> </span>
<a href="#l3.13010"></a><span id="l3.13010" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetLoadInfo(nsILoadInfo * *aLoadInfo)</span>
<a href="#l3.13011"></a><span id="l3.13011" class="difflineminus">-{</span>
<a href="#l3.13012"></a><span id="l3.13012" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetLoadInfo(nsILoadInfo **aLoadInfo) {</span>
<a href="#l3.13013"></a><span id="l3.13013">   NS_IF_ADDREF(*aLoadInfo = m_loadInfo);</span>
<a href="#l3.13014"></a><span id="l3.13014">   return NS_OK;</span>
<a href="#l3.13015"></a><span id="l3.13015"> }</span>
<a href="#l3.13016"></a><span id="l3.13016"> </span>
<a href="#l3.13017"></a><span id="l3.13017" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetLoadInfo(nsILoadInfo * aLoadInfo)</span>
<a href="#l3.13018"></a><span id="l3.13018" class="difflineminus">-{</span>
<a href="#l3.13019"></a><span id="l3.13019" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetLoadInfo(nsILoadInfo *aLoadInfo) {</span>
<a href="#l3.13020"></a><span id="l3.13020">   m_loadInfo = aLoadInfo;</span>
<a href="#l3.13021"></a><span id="l3.13021">   return NS_OK;</span>
<a href="#l3.13022"></a><span id="l3.13022"> }</span>
<a href="#l3.13023"></a><span id="l3.13023"> </span>
<a href="#l3.13024"></a><span id="l3.13024" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetOriginalURI(nsIURI* *aURI)</span>
<a href="#l3.13025"></a><span id="l3.13025" class="difflineminus">-{</span>
<a href="#l3.13026"></a><span id="l3.13026" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetOriginalURI(nsIURI **aURI) {</span>
<a href="#l3.13027"></a><span id="l3.13027">   // IMap does not seem to have the notion of an original URI :-(</span>
<a href="#l3.13028"></a><span id="l3.13028">   //  *aURI = m_originalUrl ? m_originalUrl : m_url;</span>
<a href="#l3.13029"></a><span id="l3.13029">   NS_IF_ADDREF(*aURI = m_url);</span>
<a href="#l3.13030"></a><span id="l3.13030">   return NS_OK;</span>
<a href="#l3.13031"></a><span id="l3.13031"> }</span>
<a href="#l3.13032"></a><span id="l3.13032"> </span>
<a href="#l3.13033"></a><span id="l3.13033" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetOriginalURI(nsIURI* aURI)</span>
<a href="#l3.13034"></a><span id="l3.13034" class="difflineminus">-{</span>
<a href="#l3.13035"></a><span id="l3.13035" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetOriginalURI(nsIURI *aURI) {</span>
<a href="#l3.13036"></a><span id="l3.13036">   // IMap does not seem to have the notion of an original URI :-(</span>
<a href="#l3.13037"></a><span id="l3.13037">   //    MOZ_ASSERT_UNREACHABLE(&quot;nsImapMockChannel::SetOriginalURI&quot;);</span>
<a href="#l3.13038"></a><span id="l3.13038">   //    return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l3.13039"></a><span id="l3.13039" class="difflineminus">-  return NS_OK;       // ignore</span>
<a href="#l3.13040"></a><span id="l3.13040" class="difflineminus">-}</span>
<a href="#l3.13041"></a><span id="l3.13041" class="difflineminus">-</span>
<a href="#l3.13042"></a><span id="l3.13042" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetURI(nsIURI* *aURI)</span>
<a href="#l3.13043"></a><span id="l3.13043" class="difflineminus">-{</span>
<a href="#l3.13044"></a><span id="l3.13044" class="difflineplus">+  return NS_OK;  // ignore</span>
<a href="#l3.13045"></a><span id="l3.13045" class="difflineplus">+}</span>
<a href="#l3.13046"></a><span id="l3.13046" class="difflineplus">+</span>
<a href="#l3.13047"></a><span id="l3.13047" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetURI(nsIURI **aURI) {</span>
<a href="#l3.13048"></a><span id="l3.13048">   NS_IF_ADDREF(*aURI = m_url);</span>
<a href="#l3.13049"></a><span id="l3.13049" class="difflineminus">-  return NS_OK ;</span>
<a href="#l3.13050"></a><span id="l3.13050" class="difflineminus">-}</span>
<a href="#l3.13051"></a><span id="l3.13051" class="difflineminus">-</span>
<a href="#l3.13052"></a><span id="l3.13052" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetURI(nsIURI* aURI)</span>
<a href="#l3.13053"></a><span id="l3.13053" class="difflineminus">-{</span>
<a href="#l3.13054"></a><span id="l3.13054" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.13055"></a><span id="l3.13055" class="difflineplus">+}</span>
<a href="#l3.13056"></a><span id="l3.13056" class="difflineplus">+</span>
<a href="#l3.13057"></a><span id="l3.13057" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetURI(nsIURI *aURI) {</span>
<a href="#l3.13058"></a><span id="l3.13058">   m_url = aURI;</span>
<a href="#l3.13059"></a><span id="l3.13059"> #ifdef DEBUG_bienvenu</span>
<a href="#l3.13060"></a><span id="l3.13060" class="difflineminus">-  if (!aURI)</span>
<a href="#l3.13061"></a><span id="l3.13061" class="difflineminus">-    printf(&quot;Clearing URI\n&quot;);</span>
<a href="#l3.13062"></a><span id="l3.13062" class="difflineplus">+  if (!aURI) printf(&quot;Clearing URI\n&quot;);</span>
<a href="#l3.13063"></a><span id="l3.13063"> #endif</span>
<a href="#l3.13064"></a><span id="l3.13064" class="difflineminus">-  if (m_url)</span>
<a href="#l3.13065"></a><span id="l3.13065" class="difflineminus">-  {</span>
<a href="#l3.13066"></a><span id="l3.13066" class="difflineminus">-    // if we don't have a progress event sink yet, get it from the url for now...</span>
<a href="#l3.13067"></a><span id="l3.13067" class="difflineplus">+  if (m_url) {</span>
<a href="#l3.13068"></a><span id="l3.13068" class="difflineplus">+    // if we don't have a progress event sink yet, get it from the url for</span>
<a href="#l3.13069"></a><span id="l3.13069" class="difflineplus">+    // now...</span>
<a href="#l3.13070"></a><span id="l3.13070">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url);</span>
<a href="#l3.13071"></a><span id="l3.13071" class="difflineminus">-    if (mailnewsUrl &amp;&amp; !mProgressEventSink)</span>
<a href="#l3.13072"></a><span id="l3.13072" class="difflineminus">-    {</span>
<a href="#l3.13073"></a><span id="l3.13073" class="difflineplus">+    if (mailnewsUrl &amp;&amp; !mProgressEventSink) {</span>
<a href="#l3.13074"></a><span id="l3.13074">       nsCOMPtr&lt;nsIMsgStatusFeedback&gt; statusFeedback;</span>
<a href="#l3.13075"></a><span id="l3.13075">       mailnewsUrl-&gt;GetStatusFeedback(getter_AddRefs(statusFeedback));</span>
<a href="#l3.13076"></a><span id="l3.13076">       mProgressEventSink = do_QueryInterface(statusFeedback);</span>
<a href="#l3.13077"></a><span id="l3.13077">     }</span>
<a href="#l3.13078"></a><span id="l3.13078">     // If this is a fetch URL and we can, get the message size from the message</span>
<a href="#l3.13079"></a><span id="l3.13079">     // header and set it to be the content length.</span>
<a href="#l3.13080"></a><span id="l3.13080">     // Note that for an attachment URL, this will set the content length to be</span>
<a href="#l3.13081"></a><span id="l3.13081">     // equal to the size of the entire message.</span>
<a href="#l3.13082"></a><span id="l3.13082">     nsCOMPtr&lt;nsIImapUrl&gt; imapUrl(do_QueryInterface(m_url));</span>
<a href="#l3.13083"></a><span id="l3.13083">     nsImapAction imapAction;</span>
<a href="#l3.13084"></a><span id="l3.13084">     imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.13085"></a><span id="l3.13085" class="difflineminus">-    if (imapAction == nsIImapUrl::nsImapMsgFetch)</span>
<a href="#l3.13086"></a><span id="l3.13086" class="difflineminus">-    {</span>
<a href="#l3.13087"></a><span id="l3.13087" class="difflineplus">+    if (imapAction == nsIImapUrl::nsImapMsgFetch) {</span>
<a href="#l3.13088"></a><span id="l3.13088">       nsCOMPtr&lt;nsIMsgMessageUrl&gt; msgUrl(do_QueryInterface(m_url));</span>
<a href="#l3.13089"></a><span id="l3.13089" class="difflineminus">-      if (msgUrl)</span>
<a href="#l3.13090"></a><span id="l3.13090" class="difflineminus">-      {</span>
<a href="#l3.13091"></a><span id="l3.13091" class="difflineplus">+      if (msgUrl) {</span>
<a href="#l3.13092"></a><span id="l3.13092">         nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l3.13093"></a><span id="l3.13093">         // A failure to get a message header isn't an error</span>
<a href="#l3.13094"></a><span id="l3.13094">         msgUrl-&gt;GetMessageHeader(getter_AddRefs(msgHdr));</span>
<a href="#l3.13095"></a><span id="l3.13095" class="difflineminus">-        if (msgHdr)</span>
<a href="#l3.13096"></a><span id="l3.13096" class="difflineminus">-        {</span>
<a href="#l3.13097"></a><span id="l3.13097" class="difflineplus">+        if (msgHdr) {</span>
<a href="#l3.13098"></a><span id="l3.13098">           uint32_t messageSize;</span>
<a href="#l3.13099"></a><span id="l3.13099">           if (NS_SUCCEEDED(msgHdr-&gt;GetMessageSize(&amp;messageSize)))</span>
<a href="#l3.13100"></a><span id="l3.13100">             SetContentLength(messageSize);</span>
<a href="#l3.13101"></a><span id="l3.13101">         }</span>
<a href="#l3.13102"></a><span id="l3.13102">       }</span>
<a href="#l3.13103"></a><span id="l3.13103">     }</span>
<a href="#l3.13104"></a><span id="l3.13104">   }</span>
<a href="#l3.13105"></a><span id="l3.13105">   return NS_OK;</span>
<a href="#l3.13106"></a><span id="l3.13106"> }</span>
<a href="#l3.13107"></a><span id="l3.13107"> </span>
<a href="#l3.13108"></a><span id="l3.13108" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::Open(nsIInputStream **_retval)</span>
<a href="#l3.13109"></a><span id="l3.13109" class="difflineminus">-{</span>
<a href="#l3.13110"></a><span id="l3.13110" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::Open(nsIInputStream **_retval) {</span>
<a href="#l3.13111"></a><span id="l3.13111">   nsCOMPtr&lt;nsIStreamListener&gt; listener;</span>
<a href="#l3.13112"></a><span id="l3.13112" class="difflineminus">-  nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);</span>
<a href="#l3.13113"></a><span id="l3.13113" class="difflineplus">+  nsresult rv =</span>
<a href="#l3.13114"></a><span id="l3.13114" class="difflineplus">+      nsContentSecurityManager::doContentSecurityCheck(this, listener);</span>
<a href="#l3.13115"></a><span id="l3.13115">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13116"></a><span id="l3.13116">   return NS_ImplementChannelOpen(this, _retval);</span>
<a href="#l3.13117"></a><span id="l3.13117"> }</span>
<a href="#l3.13118"></a><span id="l3.13118"> </span>
<a href="#l3.13119"></a><span id="l3.13119"> NS_IMETHODIMP</span>
<a href="#l3.13120"></a><span id="l3.13120" class="difflineminus">-nsImapMockChannel::OnCacheEntryAvailable(nsICacheEntry *entry, bool aNew, nsIApplicationCache* aAppCache, nsresult status)</span>
<a href="#l3.13121"></a><span id="l3.13121" class="difflineminus">-{</span>
<a href="#l3.13122"></a><span id="l3.13122" class="difflineminus">-  if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug))</span>
<a href="#l3.13123"></a><span id="l3.13123" class="difflineminus">-  {</span>
<a href="#l3.13124"></a><span id="l3.13124" class="difflineplus">+nsImapMockChannel::OnCacheEntryAvailable(nsICacheEntry *entry, bool aNew,</span>
<a href="#l3.13125"></a><span id="l3.13125" class="difflineplus">+                                         nsIApplicationCache *aAppCache,</span>
<a href="#l3.13126"></a><span id="l3.13126" class="difflineplus">+                                         nsresult status) {</span>
<a href="#l3.13127"></a><span id="l3.13127" class="difflineplus">+  if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug)) {</span>
<a href="#l3.13128"></a><span id="l3.13128">     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13129"></a><span id="l3.13129" class="difflineminus">-      (&quot;OnCacheEntryAvailable(): Create/write new cache entry=%s&quot;, aNew ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13130"></a><span id="l3.13130" class="difflineplus">+            (&quot;OnCacheEntryAvailable(): Create/write new cache entry=%s&quot;,</span>
<a href="#l3.13131"></a><span id="l3.13131" class="difflineplus">+             aNew ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13132"></a><span id="l3.13132">     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13133"></a><span id="l3.13133" class="difflineminus">-      (&quot;OnCacheEntryAvailable(): Get part from entire message=%s&quot;, mTryingToReadPart ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13134"></a><span id="l3.13134" class="difflineplus">+            (&quot;OnCacheEntryAvailable(): Get part from entire message=%s&quot;,</span>
<a href="#l3.13135"></a><span id="l3.13135" class="difflineplus">+             mTryingToReadPart ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13136"></a><span id="l3.13136">     nsAutoCString key;</span>
<a href="#l3.13137"></a><span id="l3.13137" class="difflineminus">-    if(entry) entry-&gt;GetKey(key);</span>
<a href="#l3.13138"></a><span id="l3.13138" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OnCacheEntryAvailable(): Cache entry key = |%s|&quot;, key.get()));</span>
<a href="#l3.13139"></a><span id="l3.13139" class="difflineplus">+    if (entry) entry-&gt;GetKey(key);</span>
<a href="#l3.13140"></a><span id="l3.13140" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13141"></a><span id="l3.13141" class="difflineplus">+            (&quot;OnCacheEntryAvailable(): Cache entry key = |%s|&quot;, key.get()));</span>
<a href="#l3.13142"></a><span id="l3.13142">   }</span>
<a href="#l3.13143"></a><span id="l3.13143">   nsresult rv = NS_OK;</span>
<a href="#l3.13144"></a><span id="l3.13144"> </span>
<a href="#l3.13145"></a><span id="l3.13145">   // make sure we didn't close the channel before the async call back came in...</span>
<a href="#l3.13146"></a><span id="l3.13146" class="difflineminus">-  // hmmm....if we had write access and we canceled this mock channel then I wonder if we should</span>
<a href="#l3.13147"></a><span id="l3.13147" class="difflineminus">-  // be invalidating the cache entry before kicking out...</span>
<a href="#l3.13148"></a><span id="l3.13148" class="difflineminus">-  if (mChannelClosed)</span>
<a href="#l3.13149"></a><span id="l3.13149" class="difflineminus">-  {</span>
<a href="#l3.13150"></a><span id="l3.13150" class="difflineplus">+  // hmmm....if we had write access and we canceled this mock channel then I</span>
<a href="#l3.13151"></a><span id="l3.13151" class="difflineplus">+  // wonder if we should be invalidating the cache entry before kicking out...</span>
<a href="#l3.13152"></a><span id="l3.13152" class="difflineplus">+  if (mChannelClosed) {</span>
<a href="#l3.13153"></a><span id="l3.13153">     entry-&gt;AsyncDoom(nullptr);</span>
<a href="#l3.13154"></a><span id="l3.13154">     return NS_OK;</span>
<a href="#l3.13155"></a><span id="l3.13155">   }</span>
<a href="#l3.13156"></a><span id="l3.13156"> </span>
<a href="#l3.13157"></a><span id="l3.13157">   if (!m_url) {</span>
<a href="#l3.13158"></a><span id="l3.13158">     // Something has gone terribly wrong.</span>
<a href="#l3.13159"></a><span id="l3.13159">     NS_WARNING(&quot;m_url is null in OnCacheEntryAvailable&quot;);</span>
<a href="#l3.13160"></a><span id="l3.13160">     return Cancel(NS_ERROR_UNEXPECTED);</span>
<a href="#l3.13161"></a><span id="l3.13161">   }</span>
<a href="#l3.13162"></a><span id="l3.13162"> </span>
<a href="#l3.13163"></a><span id="l3.13163">   do {</span>
<a href="#l3.13164"></a><span id="l3.13164">     // For &quot;normal&quot; read/write access we always receive NS_OK here. aNew</span>
<a href="#l3.13165"></a><span id="l3.13165">     // indicates whether the cache entry is new and needs to be written, or not</span>
<a href="#l3.13166"></a><span id="l3.13166">     // new and can be read. If AsyncOpenURI() was called with access read-only,</span>
<a href="#l3.13167"></a><span id="l3.13167" class="difflineminus">-    // status==NS_ERROR_CACHE_KEY_NOT_FOUND can be received here and we just read</span>
<a href="#l3.13168"></a><span id="l3.13168" class="difflineminus">-    // the data directly.</span>
<a href="#l3.13169"></a><span id="l3.13169" class="difflineminus">-    if (NS_FAILED(status))</span>
<a href="#l3.13170"></a><span id="l3.13170" class="difflineminus">-    {</span>
<a href="#l3.13171"></a><span id="l3.13171" class="difflineplus">+    // status==NS_ERROR_CACHE_KEY_NOT_FOUND can be received here and we just</span>
<a href="#l3.13172"></a><span id="l3.13172" class="difflineplus">+    // read the data directly.</span>
<a href="#l3.13173"></a><span id="l3.13173" class="difflineplus">+    if (NS_FAILED(status)) {</span>
<a href="#l3.13174"></a><span id="l3.13174">       MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13175"></a><span id="l3.13175" class="difflineminus">-        (&quot;OnCacheEntryAvailable(): status parameter bad, preference browser.cache.memory not enabled?&quot;));</span>
<a href="#l3.13176"></a><span id="l3.13176" class="difflineplus">+              (&quot;OnCacheEntryAvailable(): status parameter bad, preference &quot;</span>
<a href="#l3.13177"></a><span id="l3.13177" class="difflineplus">+               &quot;browser.cache.memory not enabled?&quot;));</span>
<a href="#l3.13178"></a><span id="l3.13178">       break;</span>
<a href="#l3.13179"></a><span id="l3.13179">     }</span>
<a href="#l3.13180"></a><span id="l3.13180"> </span>
<a href="#l3.13181"></a><span id="l3.13181">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url, &amp;rv);</span>
<a href="#l3.13182"></a><span id="l3.13182">     mailnewsUrl-&gt;SetMemCacheEntry(entry);</span>
<a href="#l3.13183"></a><span id="l3.13183"> </span>
<a href="#l3.13184"></a><span id="l3.13184">     // For URLs not related to parts, the processing is easy:</span>
<a href="#l3.13185"></a><span id="l3.13185">     // aNew==true means that we need to write to the entry,</span>
<a href="#l3.13186"></a><span id="l3.13186" class="difflineat">@@ -9533,149 +8717,155 @@ nsImapMockChannel::OnCacheEntryAvailable</span>
<a href="#l3.13187"></a><span id="l3.13187">     //    In this case, the URL used as cache key addresses the part and</span>
<a href="#l3.13188"></a><span id="l3.13188">     //    mTryingToReadPart==false.</span>
<a href="#l3.13189"></a><span id="l3.13189">     //    The caller has already set up part extraction.</span>
<a href="#l3.13190"></a><span id="l3.13190">     //    This case is no different to non-part processing.</span>
<a href="#l3.13191"></a><span id="l3.13191">     // 2) The caller wants to try to extract the part from the cache entry</span>
<a href="#l3.13192"></a><span id="l3.13192">     //    of the entire message.</span>
<a href="#l3.13193"></a><span id="l3.13193">     //    In this case, the URL used as cache key addresses the message and</span>
<a href="#l3.13194"></a><span id="l3.13194">     //    mTryingToReadPart==true.</span>
<a href="#l3.13195"></a><span id="l3.13195" class="difflineminus">-    if (mTryingToReadPart)</span>
<a href="#l3.13196"></a><span id="l3.13196" class="difflineminus">-    {</span>
<a href="#l3.13197"></a><span id="l3.13197" class="difflineplus">+    if (mTryingToReadPart) {</span>
<a href="#l3.13198"></a><span id="l3.13198" class="difflineplus">+      // clang-format off</span>
<a href="#l3.13199"></a><span id="l3.13199">       MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13200"></a><span id="l3.13200" class="difflineminus">-        (&quot;OnCacheEntryAvailable(): Trying to read part from entire message&quot;));</span>
<a href="#l3.13201"></a><span id="l3.13201" class="difflineplus">+              (&quot;OnCacheEntryAvailable(): Trying to read part from entire message&quot;));</span>
<a href="#l3.13202"></a><span id="l3.13202" class="difflineplus">+      // clang-format on</span>
<a href="#l3.13203"></a><span id="l3.13203">       // We are here with the URI of the entire message which we know exists.</span>
<a href="#l3.13204"></a><span id="l3.13204">       MOZ_ASSERT(!aNew,</span>
<a href="#l3.13205"></a><span id="l3.13205" class="difflineminus">-                 &quot;Logic error: Trying to read part from entire message which doesn't exist&quot;);</span>
<a href="#l3.13206"></a><span id="l3.13206" class="difflineminus">-      if (!aNew)</span>
<a href="#l3.13207"></a><span id="l3.13207" class="difflineminus">-      {</span>
<a href="#l3.13208"></a><span id="l3.13208" class="difflineplus">+                 &quot;Logic error: Trying to read part from entire message which &quot;</span>
<a href="#l3.13209"></a><span id="l3.13209" class="difflineplus">+                 &quot;doesn't exist&quot;);</span>
<a href="#l3.13210"></a><span id="l3.13210" class="difflineplus">+      if (!aNew) {</span>
<a href="#l3.13211"></a><span id="l3.13211">         // Check the meta data.</span>
<a href="#l3.13212"></a><span id="l3.13212">         nsCString annotation;</span>
<a href="#l3.13213"></a><span id="l3.13213" class="difflineminus">-        rv = entry-&gt;GetMetaDataElement(&quot;ContentModified&quot;, getter_Copies(annotation));</span>
<a href="#l3.13214"></a><span id="l3.13214" class="difflineminus">-        if (NS_FAILED(rv) || !annotation.EqualsLiteral(&quot;Not Modified&quot;))</span>
<a href="#l3.13215"></a><span id="l3.13215" class="difflineminus">-        {</span>
<a href="#l3.13216"></a><span id="l3.13216" class="difflineplus">+        rv = entry-&gt;GetMetaDataElement(&quot;ContentModified&quot;,</span>
<a href="#l3.13217"></a><span id="l3.13217" class="difflineplus">+                                       getter_Copies(annotation));</span>
<a href="#l3.13218"></a><span id="l3.13218" class="difflineplus">+        if (NS_FAILED(rv) || !annotation.EqualsLiteral(&quot;Not Modified&quot;)) {</span>
<a href="#l3.13219"></a><span id="l3.13219">           MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13220"></a><span id="l3.13220" class="difflineminus">-            (&quot;OnCacheEntryAvailable(): Entry is not complete and cannot be used&quot;));</span>
<a href="#l3.13221"></a><span id="l3.13221" class="difflineplus">+                  (&quot;OnCacheEntryAvailable(): Entry is not complete and cannot &quot;</span>
<a href="#l3.13222"></a><span id="l3.13222" class="difflineplus">+                   &quot;be used&quot;));</span>
<a href="#l3.13223"></a><span id="l3.13223">           // The cache entry is not marked &quot;Not Modified&quot;, that means it doesn't</span>
<a href="#l3.13224"></a><span id="l3.13224">           // contain the entire message, so we can't use it.</span>
<a href="#l3.13225"></a><span id="l3.13225">           // Call OpenCacheEntry() a second time to get the part.</span>
<a href="#l3.13226"></a><span id="l3.13226">           rv = OpenCacheEntry();</span>
<a href="#l3.13227"></a><span id="l3.13227" class="difflineminus">-          if (NS_SUCCEEDED(rv))</span>
<a href="#l3.13228"></a><span id="l3.13228" class="difflineminus">-            return rv;</span>
<a href="#l3.13229"></a><span id="l3.13229" class="difflineplus">+          if (NS_SUCCEEDED(rv)) return rv;</span>
<a href="#l3.13230"></a><span id="l3.13230"> </span>
<a href="#l3.13231"></a><span id="l3.13231">           // Something has gone wrong, fall back to reading from the imap</span>
<a href="#l3.13232"></a><span id="l3.13232">           // connection so the protocol doesn't hang.</span>
<a href="#l3.13233"></a><span id="l3.13233">           break;</span>
<a href="#l3.13234"></a><span id="l3.13234">         }</span>
<a href="#l3.13235"></a><span id="l3.13235">       }</span>
<a href="#l3.13236"></a><span id="l3.13236">     }</span>
<a href="#l3.13237"></a><span id="l3.13237"> </span>
<a href="#l3.13238"></a><span id="l3.13238" class="difflineminus">-    if (aNew)</span>
<a href="#l3.13239"></a><span id="l3.13239" class="difflineminus">-    {</span>
<a href="#l3.13240"></a><span id="l3.13240" class="difflineminus">-      MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OnCacheEntryAvailable(): Begin cache WRITE&quot;));</span>
<a href="#l3.13241"></a><span id="l3.13241" class="difflineplus">+    if (aNew) {</span>
<a href="#l3.13242"></a><span id="l3.13242" class="difflineplus">+      MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13243"></a><span id="l3.13243" class="difflineplus">+              (&quot;OnCacheEntryAvailable(): Begin cache WRITE&quot;));</span>
<a href="#l3.13244"></a><span id="l3.13244">       // If we are writing, then insert a &quot;stream listener Tee&quot; into the flow</span>
<a href="#l3.13245"></a><span id="l3.13245">       // to force data into the cache and to our current channel listener.</span>
<a href="#l3.13246"></a><span id="l3.13246" class="difflineminus">-      nsCOMPtr&lt;nsIStreamListenerTee&gt; tee = do_CreateInstance(NS_STREAMLISTENERTEE_CONTRACTID, &amp;rv);</span>
<a href="#l3.13247"></a><span id="l3.13247" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l3.13248"></a><span id="l3.13248" class="difflineminus">-      {</span>
<a href="#l3.13249"></a><span id="l3.13249" class="difflineplus">+      nsCOMPtr&lt;nsIStreamListenerTee&gt; tee =</span>
<a href="#l3.13250"></a><span id="l3.13250" class="difflineplus">+          do_CreateInstance(NS_STREAMLISTENERTEE_CONTRACTID, &amp;rv);</span>
<a href="#l3.13251"></a><span id="l3.13251" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.13252"></a><span id="l3.13252">         nsCOMPtr&lt;nsIOutputStream&gt; out;</span>
<a href="#l3.13253"></a><span id="l3.13253">         // This will fail with the cache turned off, so we need to fall through</span>
<a href="#l3.13254"></a><span id="l3.13254" class="difflineminus">-        // to ReadFromImapConnection instead of aborting with NS_ENSURE_SUCCESS(rv,rv).</span>
<a href="#l3.13255"></a><span id="l3.13255" class="difflineplus">+        // to ReadFromImapConnection instead of aborting with</span>
<a href="#l3.13256"></a><span id="l3.13256" class="difflineplus">+        // NS_ENSURE_SUCCESS(rv,rv).</span>
<a href="#l3.13257"></a><span id="l3.13257">         rv = entry-&gt;OpenOutputStream(0, -1, getter_AddRefs(out));</span>
<a href="#l3.13258"></a><span id="l3.13258" class="difflineminus">-        if (NS_SUCCEEDED(rv))</span>
<a href="#l3.13259"></a><span id="l3.13259" class="difflineminus">-        {</span>
<a href="#l3.13260"></a><span id="l3.13260" class="difflineplus">+        if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.13261"></a><span id="l3.13261">           rv = tee-&gt;Init(m_channelListener, out, nullptr);</span>
<a href="#l3.13262"></a><span id="l3.13262">           m_channelListener = tee;</span>
<a href="#l3.13263"></a><span id="l3.13263" class="difflineminus">-        }</span>
<a href="#l3.13264"></a><span id="l3.13264" class="difflineminus">-        else</span>
<a href="#l3.13265"></a><span id="l3.13265" class="difflineminus">-          NS_WARNING(&quot;IMAP Protocol failed to open output stream to Necko cache&quot;);</span>
<a href="#l3.13266"></a><span id="l3.13266" class="difflineplus">+        } else</span>
<a href="#l3.13267"></a><span id="l3.13267" class="difflineplus">+          NS_WARNING(</span>
<a href="#l3.13268"></a><span id="l3.13268" class="difflineplus">+              &quot;IMAP Protocol failed to open output stream to Necko cache&quot;);</span>
<a href="#l3.13269"></a><span id="l3.13269">       }</span>
<a href="#l3.13270"></a><span id="l3.13270" class="difflineminus">-    }</span>
<a href="#l3.13271"></a><span id="l3.13271" class="difflineminus">-    else</span>
<a href="#l3.13272"></a><span id="l3.13272" class="difflineminus">-    {</span>
<a href="#l3.13273"></a><span id="l3.13273" class="difflineminus">-      if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug))</span>
<a href="#l3.13274"></a><span id="l3.13274" class="difflineminus">-      {</span>
<a href="#l3.13275"></a><span id="l3.13275" class="difflineplus">+    } else {</span>
<a href="#l3.13276"></a><span id="l3.13276" class="difflineplus">+      if (MOZ_LOG_TEST(IMAPCache, LogLevel::Debug)) {</span>
<a href="#l3.13277"></a><span id="l3.13277">         int64_t size = 0;</span>
<a href="#l3.13278"></a><span id="l3.13278">         rv = entry-&gt;GetDataSize(&amp;size);</span>
<a href="#l3.13279"></a><span id="l3.13279">         if (rv == NS_ERROR_IN_PROGRESS)</span>
<a href="#l3.13280"></a><span id="l3.13280" class="difflineminus">-          MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OnCacheEntryAvailable(): Concurrent cache READ, no size available&quot;));</span>
<a href="#l3.13281"></a><span id="l3.13281" class="difflineminus">-        MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OnCacheEntryAvailable(): Begin cache READ, size=%&quot; PRIi64 &quot; &quot;, size));</span>
<a href="#l3.13282"></a><span id="l3.13282" class="difflineplus">+          MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13283"></a><span id="l3.13283" class="difflineplus">+                  (&quot;OnCacheEntryAvailable(): Concurrent cache READ, no size &quot;</span>
<a href="#l3.13284"></a><span id="l3.13284" class="difflineplus">+                   &quot;available&quot;));</span>
<a href="#l3.13285"></a><span id="l3.13285" class="difflineplus">+        MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13286"></a><span id="l3.13286" class="difflineplus">+                (&quot;OnCacheEntryAvailable(): Begin cache READ, size=%&quot; PRIi64 &quot; &quot;,</span>
<a href="#l3.13287"></a><span id="l3.13287" class="difflineplus">+                 size));</span>
<a href="#l3.13288"></a><span id="l3.13288">       }</span>
<a href="#l3.13289"></a><span id="l3.13289">       rv = ReadFromMemCache(entry);</span>
<a href="#l3.13290"></a><span id="l3.13290" class="difflineminus">-      if (NS_SUCCEEDED(rv))</span>
<a href="#l3.13291"></a><span id="l3.13291" class="difflineminus">-      {</span>
<a href="#l3.13292"></a><span id="l3.13292" class="difflineplus">+      if (NS_SUCCEEDED(rv)) {</span>
<a href="#l3.13293"></a><span id="l3.13293">         NotifyStartEndReadFromCache(true);</span>
<a href="#l3.13294"></a><span id="l3.13294">         entry-&gt;MarkValid();</span>
<a href="#l3.13295"></a><span id="l3.13295" class="difflineminus">-        return NS_OK; // Kick out if reading from the cache succeeded.</span>
<a href="#l3.13296"></a><span id="l3.13296" class="difflineplus">+        return NS_OK;  // Kick out if reading from the cache succeeded.</span>
<a href="#l3.13297"></a><span id="l3.13297">       }</span>
<a href="#l3.13298"></a><span id="l3.13298" class="difflineminus">-      entry-&gt;AsyncDoom(nullptr); // Doom entry if we failed to read from cache.</span>
<a href="#l3.13299"></a><span id="l3.13299" class="difflineminus">-      mailnewsUrl-&gt;SetMemCacheEntry(nullptr); // We aren't going to be reading from the cache.</span>
<a href="#l3.13300"></a><span id="l3.13300" class="difflineplus">+      entry-&gt;AsyncDoom(nullptr);  // Doom entry if we failed to read from cache.</span>
<a href="#l3.13301"></a><span id="l3.13301" class="difflineplus">+      mailnewsUrl-&gt;SetMemCacheEntry(</span>
<a href="#l3.13302"></a><span id="l3.13302" class="difflineplus">+          nullptr);  // We aren't going to be reading from the cache.</span>
<a href="#l3.13303"></a><span id="l3.13303">     }</span>
<a href="#l3.13304"></a><span id="l3.13304">   } while (false);</span>
<a href="#l3.13305"></a><span id="l3.13305"> </span>
<a href="#l3.13306"></a><span id="l3.13306" class="difflineminus">-  // If reading from the cache failed or if we are writing into the cache, default to ReadFromImapConnection.</span>
<a href="#l3.13307"></a><span id="l3.13307" class="difflineplus">+  // If reading from the cache failed or if we are writing into the cache,</span>
<a href="#l3.13308"></a><span id="l3.13308" class="difflineplus">+  // default to ReadFromImapConnection.</span>
<a href="#l3.13309"></a><span id="l3.13309">   if (aNew)</span>
<a href="#l3.13310"></a><span id="l3.13310" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OnCacheEntryAvailable(): Cache WRITE start successful&quot;));</span>
<a href="#l3.13311"></a><span id="l3.13311" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13312"></a><span id="l3.13312" class="difflineplus">+            (&quot;OnCacheEntryAvailable(): Cache WRITE start successful&quot;));</span>
<a href="#l3.13313"></a><span id="l3.13313">   else</span>
<a href="#l3.13314"></a><span id="l3.13314" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OnCacheEntryAvailable: Cache READ failed&quot;));</span>
<a href="#l3.13315"></a><span id="l3.13315" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13316"></a><span id="l3.13316" class="difflineplus">+            (&quot;OnCacheEntryAvailable: Cache READ failed&quot;));</span>
<a href="#l3.13317"></a><span id="l3.13317">   return ReadFromImapConnection();</span>
<a href="#l3.13318"></a><span id="l3.13318"> }</span>
<a href="#l3.13319"></a><span id="l3.13319"> </span>
<a href="#l3.13320"></a><span id="l3.13320"> NS_IMETHODIMP</span>
<a href="#l3.13321"></a><span id="l3.13321" class="difflineminus">-nsImapMockChannel::OnCacheEntryCheck(nsICacheEntry* entry, nsIApplicationCache* appCache,</span>
<a href="#l3.13322"></a><span id="l3.13322" class="difflineminus">-                                     uint32_t* aResult)</span>
<a href="#l3.13323"></a><span id="l3.13323" class="difflineminus">-{</span>
<a href="#l3.13324"></a><span id="l3.13324" class="difflineplus">+nsImapMockChannel::OnCacheEntryCheck(nsICacheEntry *entry,</span>
<a href="#l3.13325"></a><span id="l3.13325" class="difflineplus">+                                     nsIApplicationCache *appCache,</span>
<a href="#l3.13326"></a><span id="l3.13326" class="difflineplus">+                                     uint32_t *aResult) {</span>
<a href="#l3.13327"></a><span id="l3.13327">   *aResult = nsICacheEntryOpenCallback::ENTRY_WANTED;</span>
<a href="#l3.13328"></a><span id="l3.13328"> </span>
<a href="#l3.13329"></a><span id="l3.13329">   // Check concurrent read: We can't read concurrently since we don't know</span>
<a href="#l3.13330"></a><span id="l3.13330">   // that the entry will ever be written successfully. It may be aborted</span>
<a href="#l3.13331"></a><span id="l3.13331">   // due to a size limitation. If reading concurrently, the following function</span>
<a href="#l3.13332"></a><span id="l3.13332">   // will return NS_ERROR_IN_PROGRESS. Then we tell the cache to wait until</span>
<a href="#l3.13333"></a><span id="l3.13333">   // the write is finished.</span>
<a href="#l3.13334"></a><span id="l3.13334">   int64_t size = 0;</span>
<a href="#l3.13335"></a><span id="l3.13335">   nsresult rv = entry-&gt;GetDataSize(&amp;size);</span>
<a href="#l3.13336"></a><span id="l3.13336" class="difflineminus">-  if (rv == NS_ERROR_IN_PROGRESS)</span>
<a href="#l3.13337"></a><span id="l3.13337" class="difflineminus">-  {</span>
<a href="#l3.13338"></a><span id="l3.13338" class="difflineplus">+  if (rv == NS_ERROR_IN_PROGRESS) {</span>
<a href="#l3.13339"></a><span id="l3.13339">     *aResult = nsICacheEntryOpenCallback::RECHECK_AFTER_WRITE_FINISHED;</span>
<a href="#l3.13340"></a><span id="l3.13340">     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13341"></a><span id="l3.13341" class="difflineminus">-      (&quot;OnCacheEntryCheck(): Attempted cache write while reading, will try again&quot;));</span>
<a href="#l3.13342"></a><span id="l3.13342" class="difflineplus">+            (&quot;OnCacheEntryCheck(): Attempted cache write while reading, will &quot;</span>
<a href="#l3.13343"></a><span id="l3.13343" class="difflineplus">+             &quot;try again&quot;));</span>
<a href="#l3.13344"></a><span id="l3.13344">   }</span>
<a href="#l3.13345"></a><span id="l3.13345">   return NS_OK;</span>
<a href="#l3.13346"></a><span id="l3.13346"> }</span>
<a href="#l3.13347"></a><span id="l3.13347"> </span>
<a href="#l3.13348"></a><span id="l3.13348" class="difflineminus">-nsresult nsImapMockChannel::OpenCacheEntry()</span>
<a href="#l3.13349"></a><span id="l3.13349" class="difflineminus">-{</span>
<a href="#l3.13350"></a><span id="l3.13350" class="difflineplus">+nsresult nsImapMockChannel::OpenCacheEntry() {</span>
<a href="#l3.13351"></a><span id="l3.13351">   nsresult rv;</span>
<a href="#l3.13352"></a><span id="l3.13352">   // get the cache session from our imap service...</span>
<a href="#l3.13353"></a><span id="l3.13353" class="difflineminus">-  nsCOMPtr&lt;nsIImapService&gt; imapService = do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l3.13354"></a><span id="l3.13354" class="difflineplus">+  nsCOMPtr&lt;nsIImapService&gt; imapService =</span>
<a href="#l3.13355"></a><span id="l3.13355" class="difflineplus">+      do_GetService(NS_IMAPSERVICE_CONTRACTID, &amp;rv);</span>
<a href="#l3.13356"></a><span id="l3.13356">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13357"></a><span id="l3.13357"> </span>
<a href="#l3.13358"></a><span id="l3.13358">   nsCOMPtr&lt;nsICacheStorage&gt; cacheStorage;</span>
<a href="#l3.13359"></a><span id="l3.13359">   rv = imapService-&gt;GetCacheStorage(getter_AddRefs(cacheStorage));</span>
<a href="#l3.13360"></a><span id="l3.13360">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13361"></a><span id="l3.13361"> </span>
<a href="#l3.13362"></a><span id="l3.13362">   int32_t uidValidity = -1;</span>
<a href="#l3.13363"></a><span id="l3.13363">   nsCacheAccessMode cacheAccess = nsICacheStorage::OPEN_NORMALLY;</span>
<a href="#l3.13364"></a><span id="l3.13364"> </span>
<a href="#l3.13365"></a><span id="l3.13365">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url, &amp;rv);</span>
<a href="#l3.13366"></a><span id="l3.13366">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13367"></a><span id="l3.13367"> </span>
<a href="#l3.13368"></a><span id="l3.13368">   bool storeResultsOffline;</span>
<a href="#l3.13369"></a><span id="l3.13369">   nsCOMPtr&lt;nsIImapMailFolderSink&gt; folderSink;</span>
<a href="#l3.13370"></a><span id="l3.13370"> </span>
<a href="#l3.13371"></a><span id="l3.13371">   rv = imapUrl-&gt;GetImapMailFolderSink(getter_AddRefs(folderSink));</span>
<a href="#l3.13372"></a><span id="l3.13372" class="difflineminus">-  if (folderSink)</span>
<a href="#l3.13373"></a><span id="l3.13373" class="difflineminus">-    folderSink-&gt;GetUidValidity(&amp;uidValidity);</span>
<a href="#l3.13374"></a><span id="l3.13374" class="difflineplus">+  if (folderSink) folderSink-&gt;GetUidValidity(&amp;uidValidity);</span>
<a href="#l3.13375"></a><span id="l3.13375">   imapUrl-&gt;GetStoreResultsOffline(&amp;storeResultsOffline);</span>
<a href="#l3.13376"></a><span id="l3.13376">   // If we're storing the message in the offline store, don't</span>
<a href="#l3.13377"></a><span id="l3.13377">   // write to the memory cache.</span>
<a href="#l3.13378"></a><span id="l3.13378" class="difflineminus">-  if (storeResultsOffline)</span>
<a href="#l3.13379"></a><span id="l3.13379" class="difflineminus">-    cacheAccess = nsICacheStorage::OPEN_READONLY;</span>
<a href="#l3.13380"></a><span id="l3.13380" class="difflineminus">-</span>
<a href="#l3.13381"></a><span id="l3.13381" class="difflineminus">-  MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OpenCacheEntry(): For URL = |%s|&quot;, m_url-&gt;GetSpecOrDefault().get()));</span>
<a href="#l3.13382"></a><span id="l3.13382" class="difflineplus">+  if (storeResultsOffline) cacheAccess = nsICacheStorage::OPEN_READONLY;</span>
<a href="#l3.13383"></a><span id="l3.13383" class="difflineplus">+</span>
<a href="#l3.13384"></a><span id="l3.13384" class="difflineplus">+  // clang-format off</span>
<a href="#l3.13385"></a><span id="l3.13385" class="difflineplus">+  MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13386"></a><span id="l3.13386" class="difflineplus">+          (&quot;OpenCacheEntry(): For URL = |%s|&quot;, m_url-&gt;GetSpecOrDefault().get()));</span>
<a href="#l3.13387"></a><span id="l3.13387" class="difflineplus">+  // clang-format on</span>
<a href="#l3.13388"></a><span id="l3.13388"> </span>
<a href="#l3.13389"></a><span id="l3.13389">   // Use the uid validity as part of the cache key, so that if the uid validity</span>
<a href="#l3.13390"></a><span id="l3.13390">   // changes, we won't re-use the wrong cache entries.</span>
<a href="#l3.13391"></a><span id="l3.13391">   nsAutoCString extension;</span>
<a href="#l3.13392"></a><span id="l3.13392">   extension.AppendInt(uidValidity, 16);</span>
<a href="#l3.13393"></a><span id="l3.13393"> </span>
<a href="#l3.13394"></a><span id="l3.13394">   // Open a cache entry where the key is the potentially modified URL.</span>
<a href="#l3.13395"></a><span id="l3.13395">   nsAutoCString path;</span>
<a href="#l3.13396"></a><span id="l3.13396" class="difflineat">@@ -9693,727 +8883,691 @@ nsresult nsImapMockChannel::OpenCacheEnt</span>
<a href="#l3.13397"></a><span id="l3.13397">     partQuery = MsgExtractQueryPart(path, &quot;&amp;part=&quot;);</span>
<a href="#l3.13398"></a><span id="l3.13398">     if (!partQuery.IsEmpty()) {</span>
<a href="#l3.13399"></a><span id="l3.13399">       // ? indicates a part query, so set the first character to that.</span>
<a href="#l3.13400"></a><span id="l3.13400">       partQuery.SetCharAt('?', 0);</span>
<a href="#l3.13401"></a><span id="l3.13401">     }</span>
<a href="#l3.13402"></a><span id="l3.13402">   }</span>
<a href="#l3.13403"></a><span id="l3.13403">   nsCString filenameQuery = MsgExtractQueryPart(path, &quot;&amp;filename=&quot;);</span>
<a href="#l3.13404"></a><span id="l3.13404">   MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13405"></a><span id="l3.13405" class="difflineminus">-    (&quot;OpenCacheEntry: part = |%s|, filename = |%s|&quot;, partQuery.get(), filenameQuery.get()));</span>
<a href="#l3.13406"></a><span id="l3.13406" class="difflineplus">+          (&quot;OpenCacheEntry: part = |%s|, filename = |%s|&quot;, partQuery.get(),</span>
<a href="#l3.13407"></a><span id="l3.13407" class="difflineplus">+           filenameQuery.get()));</span>
<a href="#l3.13408"></a><span id="l3.13408"> </span>
<a href="#l3.13409"></a><span id="l3.13409">   // Truncate path at either /; or ?</span>
<a href="#l3.13410"></a><span id="l3.13410">   int32_t ind = path.FindChar('?');</span>
<a href="#l3.13411"></a><span id="l3.13411" class="difflineminus">-  if (ind != kNotFound)</span>
<a href="#l3.13412"></a><span id="l3.13412" class="difflineminus">-    path.SetLength(ind);</span>
<a href="#l3.13413"></a><span id="l3.13413" class="difflineplus">+  if (ind != kNotFound) path.SetLength(ind);</span>
<a href="#l3.13414"></a><span id="l3.13414">   ind = path.Find(&quot;/;&quot;);</span>
<a href="#l3.13415"></a><span id="l3.13415" class="difflineminus">-  if (ind != kNotFound)</span>
<a href="#l3.13416"></a><span id="l3.13416" class="difflineminus">-    path.SetLength(ind);</span>
<a href="#l3.13417"></a><span id="l3.13417" class="difflineplus">+  if (ind != kNotFound) path.SetLength(ind);</span>
<a href="#l3.13418"></a><span id="l3.13418"> </span>
<a href="#l3.13419"></a><span id="l3.13419">   nsCOMPtr&lt;nsIURI&gt; newUri;</span>
<a href="#l3.13420"></a><span id="l3.13420" class="difflineminus">-  if (partQuery.IsEmpty())</span>
<a href="#l3.13421"></a><span id="l3.13421" class="difflineminus">-  {</span>
<a href="#l3.13422"></a><span id="l3.13422" class="difflineplus">+  if (partQuery.IsEmpty()) {</span>
<a href="#l3.13423"></a><span id="l3.13423">     // Not looking for a part. That's the easy part.</span>
<a href="#l3.13424"></a><span id="l3.13424">     rv = NS_MutateURI(m_url).SetPathQueryRef(path).Finalize(newUri);</span>
<a href="#l3.13425"></a><span id="l3.13425">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13426"></a><span id="l3.13426" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OpenCacheEntry(): Call AsyncOpenURI() on entire message&quot;));</span>
<a href="#l3.13427"></a><span id="l3.13427" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13428"></a><span id="l3.13428" class="difflineplus">+            (&quot;OpenCacheEntry(): Call AsyncOpenURI() on entire message&quot;));</span>
<a href="#l3.13429"></a><span id="l3.13429">     return cacheStorage-&gt;AsyncOpenURI(newUri, extension, cacheAccess, this);</span>
<a href="#l3.13430"></a><span id="l3.13430">   }</span>
<a href="#l3.13431"></a><span id="l3.13431"> </span>
<a href="#l3.13432"></a><span id="l3.13432">   /**</span>
<a href="#l3.13433"></a><span id="l3.13433">    * Part processing (rest of this function).</span>
<a href="#l3.13434"></a><span id="l3.13434">    */</span>
<a href="#l3.13435"></a><span id="l3.13435" class="difflineminus">-  if (mTryingToReadPart)</span>
<a href="#l3.13436"></a><span id="l3.13436" class="difflineminus">-  {</span>
<a href="#l3.13437"></a><span id="l3.13437" class="difflineplus">+  if (mTryingToReadPart) {</span>
<a href="#l3.13438"></a><span id="l3.13438">     // If mTryingToReadPart is set, we are here for the second time.</span>
<a href="#l3.13439"></a><span id="l3.13439">     // We tried to read a part from the entire message but the meta data didn't</span>
<a href="#l3.13440"></a><span id="l3.13440">     // allow it. So we come back here.</span>
<a href="#l3.13441"></a><span id="l3.13441">     // Now request the part with its full URL.</span>
<a href="#l3.13442"></a><span id="l3.13442">     mTryingToReadPart = false;</span>
<a href="#l3.13443"></a><span id="l3.13443"> </span>
<a href="#l3.13444"></a><span id="l3.13444">     // Note that part extraction was already set the first time.</span>
<a href="#l3.13445"></a><span id="l3.13445" class="difflineminus">-    rv = NS_MutateURI(m_url).SetPathQueryRef(path + partQuery + filenameQuery).Finalize(newUri);</span>
<a href="#l3.13446"></a><span id="l3.13446" class="difflineplus">+    rv = NS_MutateURI(m_url)</span>
<a href="#l3.13447"></a><span id="l3.13447" class="difflineplus">+             .SetPathQueryRef(path + partQuery + filenameQuery)</span>
<a href="#l3.13448"></a><span id="l3.13448" class="difflineplus">+             .Finalize(newUri);</span>
<a href="#l3.13449"></a><span id="l3.13449">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13450"></a><span id="l3.13450" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OpenCacheEntry(): Call AsyncOpenURI() to write part (2nd try)&quot;));</span>
<a href="#l3.13451"></a><span id="l3.13451" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13452"></a><span id="l3.13452" class="difflineplus">+            (&quot;OpenCacheEntry(): Call AsyncOpenURI() to write part (2nd try)&quot;));</span>
<a href="#l3.13453"></a><span id="l3.13453">     return cacheStorage-&gt;AsyncOpenURI(newUri, extension, cacheAccess, this);</span>
<a href="#l3.13454"></a><span id="l3.13454">   }</span>
<a href="#l3.13455"></a><span id="l3.13455"> </span>
<a href="#l3.13456"></a><span id="l3.13456">   // First time processing. Set up part extraction.</span>
<a href="#l3.13457"></a><span id="l3.13457">   SetupPartExtractorListener(imapUrl, m_channelListener);</span>
<a href="#l3.13458"></a><span id="l3.13458"> </span>
<a href="#l3.13459"></a><span id="l3.13459">   // Check whether part is in the cache.</span>
<a href="#l3.13460"></a><span id="l3.13460">   bool exists = false;</span>
<a href="#l3.13461"></a><span id="l3.13461" class="difflineminus">-  rv = NS_MutateURI(m_url).SetPathQueryRef(path + partQuery + filenameQuery).Finalize(newUri);</span>
<a href="#l3.13462"></a><span id="l3.13462" class="difflineplus">+  rv = NS_MutateURI(m_url)</span>
<a href="#l3.13463"></a><span id="l3.13463" class="difflineplus">+           .SetPathQueryRef(path + partQuery + filenameQuery)</span>
<a href="#l3.13464"></a><span id="l3.13464" class="difflineplus">+           .Finalize(newUri);</span>
<a href="#l3.13465"></a><span id="l3.13465">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13466"></a><span id="l3.13466">   rv = cacheStorage-&gt;Exists(newUri, extension, &amp;exists);</span>
<a href="#l3.13467"></a><span id="l3.13467">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13468"></a><span id="l3.13468">   if (exists) {</span>
<a href="#l3.13469"></a><span id="l3.13469" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;OpenCacheEntry(): Call AsyncOpenURI() to read part from its own cache&quot;));</span>
<a href="#l3.13470"></a><span id="l3.13470" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13471"></a><span id="l3.13471" class="difflineplus">+            (&quot;OpenCacheEntry(): Call AsyncOpenURI() to read part from its own &quot;</span>
<a href="#l3.13472"></a><span id="l3.13472" class="difflineplus">+             &quot;cache&quot;));</span>
<a href="#l3.13473"></a><span id="l3.13473">     return cacheStorage-&gt;AsyncOpenURI(newUri, extension, cacheAccess, this);</span>
<a href="#l3.13474"></a><span id="l3.13474">   }</span>
<a href="#l3.13475"></a><span id="l3.13475"> </span>
<a href="#l3.13476"></a><span id="l3.13476">   // Let's see whether we have the entire message instead.</span>
<a href="#l3.13477"></a><span id="l3.13477">   rv = NS_MutateURI(m_url).SetPathQueryRef(path).Finalize(newUri);</span>
<a href="#l3.13478"></a><span id="l3.13478">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13479"></a><span id="l3.13479">   rv = cacheStorage-&gt;Exists(newUri, extension, &amp;exists);</span>
<a href="#l3.13480"></a><span id="l3.13480">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13481"></a><span id="l3.13481"> </span>
<a href="#l3.13482"></a><span id="l3.13482">   if (!exists) {</span>
<a href="#l3.13483"></a><span id="l3.13483">     // The entire message is not in the cache. Request the part.</span>
<a href="#l3.13484"></a><span id="l3.13484" class="difflineminus">-    rv = NS_MutateURI(m_url).SetPathQueryRef(path + partQuery + filenameQuery).Finalize(newUri);</span>
<a href="#l3.13485"></a><span id="l3.13485" class="difflineplus">+    rv = NS_MutateURI(m_url)</span>
<a href="#l3.13486"></a><span id="l3.13486" class="difflineplus">+             .SetPathQueryRef(path + partQuery + filenameQuery)</span>
<a href="#l3.13487"></a><span id="l3.13487" class="difflineplus">+             .Finalize(newUri);</span>
<a href="#l3.13488"></a><span id="l3.13488">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13489"></a><span id="l3.13489">     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13490"></a><span id="l3.13490" class="difflineminus">-      (&quot;OpenCacheEntry(): Call AsyncOpenURI() to write part (entire message cache doesn't exists)&quot;));</span>
<a href="#l3.13491"></a><span id="l3.13491" class="difflineplus">+            (&quot;OpenCacheEntry(): Call AsyncOpenURI() to write part (entire &quot;</span>
<a href="#l3.13492"></a><span id="l3.13492" class="difflineplus">+             &quot;message cache doesn't exists)&quot;));</span>
<a href="#l3.13493"></a><span id="l3.13493">     return cacheStorage-&gt;AsyncOpenURI(newUri, extension, cacheAccess, this);</span>
<a href="#l3.13494"></a><span id="l3.13494">   }</span>
<a href="#l3.13495"></a><span id="l3.13495"> </span>
<a href="#l3.13496"></a><span id="l3.13496">   // This is where is gets complicated. The entire message is in the cache,</span>
<a href="#l3.13497"></a><span id="l3.13497">   // but we don't know whether it's suitable for use. Its meta data</span>
<a href="#l3.13498"></a><span id="l3.13498">   // might indicate that the message is incomplete.</span>
<a href="#l3.13499"></a><span id="l3.13499">   mTryingToReadPart = true;</span>
<a href="#l3.13500"></a><span id="l3.13500">   MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13501"></a><span id="l3.13501" class="difflineminus">-    (&quot;OpenCacheEntry(): Call AsyncOpenURI() to try to read part from entire message cache&quot;));</span>
<a href="#l3.13502"></a><span id="l3.13502" class="difflineplus">+          (&quot;OpenCacheEntry(): Call AsyncOpenURI() to try to read part from &quot;</span>
<a href="#l3.13503"></a><span id="l3.13503" class="difflineplus">+           &quot;entire message cache&quot;));</span>
<a href="#l3.13504"></a><span id="l3.13504">   return cacheStorage-&gt;AsyncOpenURI(newUri, extension, cacheAccess, this);</span>
<a href="#l3.13505"></a><span id="l3.13505"> }</span>
<a href="#l3.13506"></a><span id="l3.13506"> </span>
<a href="#l3.13507"></a><span id="l3.13507" class="difflineminus">-nsresult nsImapMockChannel::ReadFromMemCache(nsICacheEntry *entry)</span>
<a href="#l3.13508"></a><span id="l3.13508" class="difflineminus">-{</span>
<a href="#l3.13509"></a><span id="l3.13509" class="difflineplus">+nsresult nsImapMockChannel::ReadFromMemCache(nsICacheEntry *entry) {</span>
<a href="#l3.13510"></a><span id="l3.13510">   NS_ENSURE_ARG(entry);</span>
<a href="#l3.13511"></a><span id="l3.13511"> </span>
<a href="#l3.13512"></a><span id="l3.13512">   nsCString annotation;</span>
<a href="#l3.13513"></a><span id="l3.13513">   nsAutoCString entryKey;</span>
<a href="#l3.13514"></a><span id="l3.13514">   nsAutoCString contentType;</span>
<a href="#l3.13515"></a><span id="l3.13515">   nsresult rv = NS_OK;</span>
<a href="#l3.13516"></a><span id="l3.13516">   bool shouldUseCacheEntry = false;</span>
<a href="#l3.13517"></a><span id="l3.13517"> </span>
<a href="#l3.13518"></a><span id="l3.13518">   entry-&gt;GetKey(entryKey);</span>
<a href="#l3.13519"></a><span id="l3.13519" class="difflineminus">-  if (entryKey.FindChar('?') != kNotFound)</span>
<a href="#l3.13520"></a><span id="l3.13520" class="difflineminus">-  {</span>
<a href="#l3.13521"></a><span id="l3.13521" class="difflineplus">+  if (entryKey.FindChar('?') != kNotFound) {</span>
<a href="#l3.13522"></a><span id="l3.13522">     // Part processing: If we have a part, then we should use the cache entry.</span>
<a href="#l3.13523"></a><span id="l3.13523">     entry-&gt;GetMetaDataElement(&quot;contentType&quot;, getter_Copies(contentType));</span>
<a href="#l3.13524"></a><span id="l3.13524" class="difflineminus">-    if (!contentType.IsEmpty())</span>
<a href="#l3.13525"></a><span id="l3.13525" class="difflineminus">-      SetContentType(contentType);</span>
<a href="#l3.13526"></a><span id="l3.13526" class="difflineplus">+    if (!contentType.IsEmpty()) SetContentType(contentType);</span>
<a href="#l3.13527"></a><span id="l3.13527">     shouldUseCacheEntry = true;</span>
<a href="#l3.13528"></a><span id="l3.13528">     MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;ReadFromMemCache(): Reading a part&quot;));</span>
<a href="#l3.13529"></a><span id="l3.13529" class="difflineminus">-  }</span>
<a href="#l3.13530"></a><span id="l3.13530" class="difflineminus">-  else</span>
<a href="#l3.13531"></a><span id="l3.13531" class="difflineminus">-  {</span>
<a href="#l3.13532"></a><span id="l3.13532" class="difflineplus">+  } else {</span>
<a href="#l3.13533"></a><span id="l3.13533">     // Whole message processing: We should make sure the content isn't modified.</span>
<a href="#l3.13534"></a><span id="l3.13534" class="difflineminus">-    rv = entry-&gt;GetMetaDataElement(&quot;ContentModified&quot;, getter_Copies(annotation));</span>
<a href="#l3.13535"></a><span id="l3.13535" class="difflineplus">+    rv =</span>
<a href="#l3.13536"></a><span id="l3.13536" class="difflineplus">+        entry-&gt;GetMetaDataElement(&quot;ContentModified&quot;, getter_Copies(annotation));</span>
<a href="#l3.13537"></a><span id="l3.13537">     if (NS_SUCCEEDED(rv) &amp;&amp; !annotation.IsEmpty())</span>
<a href="#l3.13538"></a><span id="l3.13538">       shouldUseCacheEntry = annotation.EqualsLiteral(&quot;Not Modified&quot;);</span>
<a href="#l3.13539"></a><span id="l3.13539">     MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13540"></a><span id="l3.13540" class="difflineminus">-      (&quot;ReadFromMemCache: Reading entire message, annotation: |%s|&quot;, annotation.get()));</span>
<a href="#l3.13541"></a><span id="l3.13541" class="difflineplus">+            (&quot;ReadFromMemCache: Reading entire message, annotation: |%s|&quot;,</span>
<a href="#l3.13542"></a><span id="l3.13542" class="difflineplus">+             annotation.get()));</span>
<a href="#l3.13543"></a><span id="l3.13543"> </span>
<a href="#l3.13544"></a><span id="l3.13544">     // Compare cache entry size with message size.</span>
<a href="#l3.13545"></a><span id="l3.13545" class="difflineminus">-    if (shouldUseCacheEntry)</span>
<a href="#l3.13546"></a><span id="l3.13546" class="difflineminus">-    {</span>
<a href="#l3.13547"></a><span id="l3.13547" class="difflineplus">+    if (shouldUseCacheEntry) {</span>
<a href="#l3.13548"></a><span id="l3.13548">       int64_t entrySize;</span>
<a href="#l3.13549"></a><span id="l3.13549"> </span>
<a href="#l3.13550"></a><span id="l3.13550">       rv = entry-&gt;GetDataSize(&amp;entrySize);</span>
<a href="#l3.13551"></a><span id="l3.13551">       // We don't expect concurrent read here, so this call should always work.</span>
<a href="#l3.13552"></a><span id="l3.13552">       NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13553"></a><span id="l3.13553"> </span>
<a href="#l3.13554"></a><span id="l3.13554">       nsCOMPtr&lt;nsIMsgMessageUrl&gt; msgUrl(do_QueryInterface(m_url));</span>
<a href="#l3.13555"></a><span id="l3.13555" class="difflineminus">-      if (msgUrl)</span>
<a href="#l3.13556"></a><span id="l3.13556" class="difflineminus">-      {</span>
<a href="#l3.13557"></a><span id="l3.13557" class="difflineplus">+      if (msgUrl) {</span>
<a href="#l3.13558"></a><span id="l3.13558">         nsCOMPtr&lt;nsIMsgDBHdr&gt; msgHdr;</span>
<a href="#l3.13559"></a><span id="l3.13559">         // A failure to get a message header isn't an error</span>
<a href="#l3.13560"></a><span id="l3.13560">         msgUrl-&gt;GetMessageHeader(getter_AddRefs(msgHdr));</span>
<a href="#l3.13561"></a><span id="l3.13561" class="difflineminus">-        if (msgHdr)</span>
<a href="#l3.13562"></a><span id="l3.13562" class="difflineminus">-        {</span>
<a href="#l3.13563"></a><span id="l3.13563" class="difflineplus">+        if (msgHdr) {</span>
<a href="#l3.13564"></a><span id="l3.13564">           uint32_t messageSize;</span>
<a href="#l3.13565"></a><span id="l3.13565">           if (NS_SUCCEEDED(msgHdr-&gt;GetMessageSize(&amp;messageSize)) &amp;&amp;</span>
<a href="#l3.13566"></a><span id="l3.13566" class="difflineminus">-              messageSize != entrySize)</span>
<a href="#l3.13567"></a><span id="l3.13567" class="difflineminus">-          {</span>
<a href="#l3.13568"></a><span id="l3.13568" class="difflineplus">+              messageSize != entrySize) {</span>
<a href="#l3.13569"></a><span id="l3.13569" class="difflineplus">+            // clang-format off</span>
<a href="#l3.13570"></a><span id="l3.13570">             MOZ_LOG(IMAP, LogLevel::Warning,</span>
<a href="#l3.13571"></a><span id="l3.13571" class="difflineminus">-              (&quot;ReadFromMemCache(): Size mismatch for %s: message %&quot; PRIu32 &quot;, cache %&quot; PRIi64,</span>
<a href="#l3.13572"></a><span id="l3.13572" class="difflineminus">-               entryKey.get(), messageSize, entrySize));</span>
<a href="#l3.13573"></a><span id="l3.13573" class="difflineplus">+                    (&quot;ReadFromMemCache(): Size mismatch for %s: message %&quot; PRIu32</span>
<a href="#l3.13574"></a><span id="l3.13574" class="difflineplus">+                     &quot;, cache %&quot; PRIi64,</span>
<a href="#l3.13575"></a><span id="l3.13575" class="difflineplus">+                     entryKey.get(), messageSize, entrySize));</span>
<a href="#l3.13576"></a><span id="l3.13576">             MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13577"></a><span id="l3.13577" class="difflineminus">-              (&quot;ReadFromMemCache(): Size mismatch for %s: message %&quot; PRIu32 &quot;, cache %&quot; PRIi64,</span>
<a href="#l3.13578"></a><span id="l3.13578" class="difflineminus">-               entryKey.get(), messageSize, entrySize));</span>
<a href="#l3.13579"></a><span id="l3.13579" class="difflineplus">+                    (&quot;ReadFromMemCache(): Size mismatch for %s: message %&quot; PRIu32</span>
<a href="#l3.13580"></a><span id="l3.13580" class="difflineplus">+                     &quot;, cache %&quot; PRIi64,</span>
<a href="#l3.13581"></a><span id="l3.13581" class="difflineplus">+                     entryKey.get(), messageSize, entrySize));</span>
<a href="#l3.13582"></a><span id="l3.13582" class="difflineplus">+            // clang-format on</span>
<a href="#l3.13583"></a><span id="l3.13583">             shouldUseCacheEntry = false;</span>
<a href="#l3.13584"></a><span id="l3.13584">           }</span>
<a href="#l3.13585"></a><span id="l3.13585">         }</span>
<a href="#l3.13586"></a><span id="l3.13586">       }</span>
<a href="#l3.13587"></a><span id="l3.13587">     }</span>
<a href="#l3.13588"></a><span id="l3.13588">   }</span>
<a href="#l3.13589"></a><span id="l3.13589"> </span>
<a href="#l3.13590"></a><span id="l3.13590">   /**</span>
<a href="#l3.13591"></a><span id="l3.13591">    * Common processing for full messages and message parts.</span>
<a href="#l3.13592"></a><span id="l3.13592">    */</span>
<a href="#l3.13593"></a><span id="l3.13593" class="difflineplus">+  // clang-format off</span>
<a href="#l3.13594"></a><span id="l3.13594">   MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13595"></a><span id="l3.13595" class="difflineminus">-    (&quot;ReadFromMemCache(): End separate processing: shouldUseCacheEntry=%s&quot;, shouldUseCacheEntry ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13596"></a><span id="l3.13596" class="difflineplus">+          (&quot;ReadFromMemCache(): End separate processing: shouldUseCacheEntry=%s&quot;,</span>
<a href="#l3.13597"></a><span id="l3.13597" class="difflineplus">+           shouldUseCacheEntry ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13598"></a><span id="l3.13598" class="difflineplus">+  // clang-format on</span>
<a href="#l3.13599"></a><span id="l3.13599"> </span>
<a href="#l3.13600"></a><span id="l3.13600">   // Check header of full message or part.</span>
<a href="#l3.13601"></a><span id="l3.13601" class="difflineminus">-  if (shouldUseCacheEntry)</span>
<a href="#l3.13602"></a><span id="l3.13602" class="difflineminus">-  {</span>
<a href="#l3.13603"></a><span id="l3.13603" class="difflineplus">+  if (shouldUseCacheEntry) {</span>
<a href="#l3.13604"></a><span id="l3.13604">     nsCOMPtr&lt;nsIInputStream&gt; in;</span>
<a href="#l3.13605"></a><span id="l3.13605">     uint32_t readCount;</span>
<a href="#l3.13606"></a><span id="l3.13606">     rv = entry-&gt;OpenInputStream(0, getter_AddRefs(in));</span>
<a href="#l3.13607"></a><span id="l3.13607">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13608"></a><span id="l3.13608">     const int kFirstBlockSize = 100;</span>
<a href="#l3.13609"></a><span id="l3.13609">     char firstBlock[kFirstBlockSize + 1];</span>
<a href="#l3.13610"></a><span id="l3.13610"> </span>
<a href="#l3.13611"></a><span id="l3.13611">     // Note: This will not work for a cache2 disk cache.</span>
<a href="#l3.13612"></a><span id="l3.13612">     // (see bug 1302422 comment #4)</span>
<a href="#l3.13613"></a><span id="l3.13613">     rv = in-&gt;Read(firstBlock, sizeof(firstBlock), &amp;readCount);</span>
<a href="#l3.13614"></a><span id="l3.13614">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13615"></a><span id="l3.13615">     firstBlock[kFirstBlockSize] = '\0';</span>
<a href="#l3.13616"></a><span id="l3.13616" class="difflineminus">-    int32_t findPos = MsgFindCharInSet(nsDependentCString(firstBlock),</span>
<a href="#l3.13617"></a><span id="l3.13617" class="difflineminus">-                                       &quot;:\n\r&quot;, 0);</span>
<a href="#l3.13618"></a><span id="l3.13618" class="difflineplus">+    int32_t findPos =</span>
<a href="#l3.13619"></a><span id="l3.13619" class="difflineplus">+        MsgFindCharInSet(nsDependentCString(firstBlock), &quot;:\n\r&quot;, 0);</span>
<a href="#l3.13620"></a><span id="l3.13620">     // Check that the first line is a header line, i.e., with a ':' in it</span>
<a href="#l3.13621"></a><span id="l3.13621">     // Or that it begins with &quot;From &quot; because some IMAP servers allow that,</span>
<a href="#l3.13622"></a><span id="l3.13622">     // even though it's technically invalid.</span>
<a href="#l3.13623"></a><span id="l3.13623">     shouldUseCacheEntry = ((findPos != -1 &amp;&amp; firstBlock[findPos] == ':') ||</span>
<a href="#l3.13624"></a><span id="l3.13624">                            !(strncmp(firstBlock, &quot;From &quot;, 5)));</span>
<a href="#l3.13625"></a><span id="l3.13625">     in-&gt;Close();</span>
<a href="#l3.13626"></a><span id="l3.13626">   }</span>
<a href="#l3.13627"></a><span id="l3.13627"> </span>
<a href="#l3.13628"></a><span id="l3.13628" class="difflineminus">-  MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;ReadFromMemCache(): After header check: shouldUseCacheEntry=%s&quot;,</span>
<a href="#l3.13629"></a><span id="l3.13629" class="difflineminus">-    shouldUseCacheEntry ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13630"></a><span id="l3.13630" class="difflineminus">-</span>
<a href="#l3.13631"></a><span id="l3.13631" class="difflineminus">-  if (shouldUseCacheEntry)</span>
<a href="#l3.13632"></a><span id="l3.13632" class="difflineminus">-  {</span>
<a href="#l3.13633"></a><span id="l3.13633" class="difflineplus">+  MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13634"></a><span id="l3.13634" class="difflineplus">+          (&quot;ReadFromMemCache(): After header check: shouldUseCacheEntry=%s&quot;,</span>
<a href="#l3.13635"></a><span id="l3.13635" class="difflineplus">+           shouldUseCacheEntry ? &quot;true&quot; : &quot;false&quot;));</span>
<a href="#l3.13636"></a><span id="l3.13636" class="difflineplus">+</span>
<a href="#l3.13637"></a><span id="l3.13637" class="difflineplus">+  if (shouldUseCacheEntry) {</span>
<a href="#l3.13638"></a><span id="l3.13638">     nsCOMPtr&lt;nsIInputStream&gt; in;</span>
<a href="#l3.13639"></a><span id="l3.13639">     rv = entry-&gt;OpenInputStream(0, getter_AddRefs(in));</span>
<a href="#l3.13640"></a><span id="l3.13640">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13641"></a><span id="l3.13641" class="difflineminus">-     // if mem cache entry is broken or empty, return error.</span>
<a href="#l3.13642"></a><span id="l3.13642" class="difflineplus">+    // if mem cache entry is broken or empty, return error.</span>
<a href="#l3.13643"></a><span id="l3.13643">     uint64_t bytesAvailable;</span>
<a href="#l3.13644"></a><span id="l3.13644">     rv = in-&gt;Available(&amp;bytesAvailable);</span>
<a href="#l3.13645"></a><span id="l3.13645">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13646"></a><span id="l3.13646" class="difflineminus">-    if (!bytesAvailable)</span>
<a href="#l3.13647"></a><span id="l3.13647" class="difflineminus">-      return NS_ERROR_FAILURE;</span>
<a href="#l3.13648"></a><span id="l3.13648" class="difflineplus">+    if (!bytesAvailable) return NS_ERROR_FAILURE;</span>
<a href="#l3.13649"></a><span id="l3.13649"> </span>
<a href="#l3.13650"></a><span id="l3.13650">     nsCOMPtr&lt;nsIInputStreamPump&gt; pump;</span>
<a href="#l3.13651"></a><span id="l3.13651">     rv = NS_NewInputStreamPump(getter_AddRefs(pump), in.forget());</span>
<a href="#l3.13652"></a><span id="l3.13652">     NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13653"></a><span id="l3.13653"> </span>
<a href="#l3.13654"></a><span id="l3.13654" class="difflineminus">-    // if we are going to read from the cache, then create a mock stream listener class and use it</span>
<a href="#l3.13655"></a><span id="l3.13655" class="difflineminus">-    RefPtr&lt;nsImapCacheStreamListener&gt; cacheListener = new nsImapCacheStreamListener();</span>
<a href="#l3.13656"></a><span id="l3.13656" class="difflineplus">+    // if we are going to read from the cache, then create a mock stream</span>
<a href="#l3.13657"></a><span id="l3.13657" class="difflineplus">+    // listener class and use it</span>
<a href="#l3.13658"></a><span id="l3.13658" class="difflineplus">+    RefPtr&lt;nsImapCacheStreamListener&gt; cacheListener =</span>
<a href="#l3.13659"></a><span id="l3.13659" class="difflineplus">+        new nsImapCacheStreamListener();</span>
<a href="#l3.13660"></a><span id="l3.13660">     cacheListener-&gt;Init(m_channelListener, this);</span>
<a href="#l3.13661"></a><span id="l3.13661">     rv = pump-&gt;AsyncRead(cacheListener, m_channelContext);</span>
<a href="#l3.13662"></a><span id="l3.13662"> </span>
<a href="#l3.13663"></a><span id="l3.13663" class="difflineminus">-    if (NS_SUCCEEDED(rv)) // ONLY if we succeeded in actually starting the read should we return</span>
<a href="#l3.13664"></a><span id="l3.13664" class="difflineplus">+    if (NS_SUCCEEDED(rv))  // ONLY if we succeeded in actually starting the read</span>
<a href="#l3.13665"></a><span id="l3.13665" class="difflineplus">+                           // should we return</span>
<a href="#l3.13666"></a><span id="l3.13666">     {</span>
<a href="#l3.13667"></a><span id="l3.13667">       mCacheRequest = pump;</span>
<a href="#l3.13668"></a><span id="l3.13668">       nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url);</span>
<a href="#l3.13669"></a><span id="l3.13669">       // if the msg is unread, we should mark it read on the server. This lets</span>
<a href="#l3.13670"></a><span id="l3.13670">       // the code running this url we're loading from the cache, if it cares.</span>
<a href="#l3.13671"></a><span id="l3.13671">       imapUrl-&gt;SetMsgLoadingFromCache(true);</span>
<a href="#l3.13672"></a><span id="l3.13672"> </span>
<a href="#l3.13673"></a><span id="l3.13673" class="difflineminus">-      // be sure to set the cache entry's security info status as our security info status...</span>
<a href="#l3.13674"></a><span id="l3.13674" class="difflineplus">+      // be sure to set the cache entry's security info status as our security</span>
<a href="#l3.13675"></a><span id="l3.13675" class="difflineplus">+      // info status...</span>
<a href="#l3.13676"></a><span id="l3.13676">       nsCOMPtr&lt;nsISupports&gt; securityInfo;</span>
<a href="#l3.13677"></a><span id="l3.13677">       entry-&gt;GetSecurityInfo(getter_AddRefs(securityInfo));</span>
<a href="#l3.13678"></a><span id="l3.13678">       SetSecurityInfo(securityInfo);</span>
<a href="#l3.13679"></a><span id="l3.13679" class="difflineminus">-      MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;ReadFromMemCache(): Cache entry accepted&quot;));</span>
<a href="#l3.13680"></a><span id="l3.13680" class="difflineplus">+      MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13681"></a><span id="l3.13681" class="difflineplus">+              (&quot;ReadFromMemCache(): Cache entry accepted&quot;));</span>
<a href="#l3.13682"></a><span id="l3.13682">       return NS_OK;</span>
<a href="#l3.13683"></a><span id="l3.13683" class="difflineminus">-    } // if AsyncRead succeeded.</span>
<a href="#l3.13684"></a><span id="l3.13684" class="difflineminus">-  } // if content is not modified</span>
<a href="#l3.13685"></a><span id="l3.13685" class="difflineminus">-  else</span>
<a href="#l3.13686"></a><span id="l3.13686" class="difflineminus">-  {</span>
<a href="#l3.13687"></a><span id="l3.13687" class="difflineplus">+    }  // if AsyncRead succeeded.</span>
<a href="#l3.13688"></a><span id="l3.13688" class="difflineplus">+  }    // if content is not modified</span>
<a href="#l3.13689"></a><span id="l3.13689" class="difflineplus">+  else {</span>
<a href="#l3.13690"></a><span id="l3.13690">     // Content is modified so return an error so we try to open it the</span>
<a href="#l3.13691"></a><span id="l3.13691">     // old fashioned way.</span>
<a href="#l3.13692"></a><span id="l3.13692" class="difflineminus">-    MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;ReadFromMemCache(): Cache entry rejected&quot;));</span>
<a href="#l3.13693"></a><span id="l3.13693" class="difflineplus">+    MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13694"></a><span id="l3.13694" class="difflineplus">+            (&quot;ReadFromMemCache(): Cache entry rejected&quot;));</span>
<a href="#l3.13695"></a><span id="l3.13695">     rv = NS_ERROR_FAILURE;</span>
<a href="#l3.13696"></a><span id="l3.13696">   }</span>
<a href="#l3.13697"></a><span id="l3.13697" class="difflineminus">-  MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;ReadFromMemCache(): Returning %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.13698"></a><span id="l3.13698" class="difflineplus">+  // clang-format off</span>
<a href="#l3.13699"></a><span id="l3.13699" class="difflineplus">+  MOZ_LOG(IMAPCache, LogLevel::Debug,</span>
<a href="#l3.13700"></a><span id="l3.13700" class="difflineplus">+          (&quot;ReadFromMemCache(): Returning %&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<a href="#l3.13701"></a><span id="l3.13701" class="difflineplus">+  // clang-format on</span>
<a href="#l3.13702"></a><span id="l3.13702">   return rv;</span>
<a href="#l3.13703"></a><span id="l3.13703"> }</span>
<a href="#l3.13704"></a><span id="l3.13704"> </span>
<a href="#l3.13705"></a><span id="l3.13705" class="difflineminus">-class nsReadFromImapConnectionFailure : public mozilla::Runnable</span>
<a href="#l3.13706"></a><span id="l3.13706" class="difflineminus">-{</span>
<a href="#l3.13707"></a><span id="l3.13707" class="difflineminus">-public:</span>
<a href="#l3.13708"></a><span id="l3.13708" class="difflineplus">+class nsReadFromImapConnectionFailure : public mozilla::Runnable {</span>
<a href="#l3.13709"></a><span id="l3.13709" class="difflineplus">+ public:</span>
<a href="#l3.13710"></a><span id="l3.13710">   explicit nsReadFromImapConnectionFailure(nsImapMockChannel *aChannel)</span>
<a href="#l3.13711"></a><span id="l3.13711" class="difflineminus">-    : mozilla::Runnable(&quot;nsReadFromImapConnectionFailure&quot;)</span>
<a href="#l3.13712"></a><span id="l3.13712" class="difflineminus">-    , mImapMockChannel(aChannel)</span>
<a href="#l3.13713"></a><span id="l3.13713" class="difflineminus">-  {}</span>
<a href="#l3.13714"></a><span id="l3.13714" class="difflineminus">-</span>
<a href="#l3.13715"></a><span id="l3.13715" class="difflineminus">-  NS_IMETHOD Run()</span>
<a href="#l3.13716"></a><span id="l3.13716" class="difflineminus">-  {</span>
<a href="#l3.13717"></a><span id="l3.13717" class="difflineplus">+      : mozilla::Runnable(&quot;nsReadFromImapConnectionFailure&quot;),</span>
<a href="#l3.13718"></a><span id="l3.13718" class="difflineplus">+        mImapMockChannel(aChannel) {}</span>
<a href="#l3.13719"></a><span id="l3.13719" class="difflineplus">+</span>
<a href="#l3.13720"></a><span id="l3.13720" class="difflineplus">+  NS_IMETHOD Run() {</span>
<a href="#l3.13721"></a><span id="l3.13721">     if (mImapMockChannel) {</span>
<a href="#l3.13722"></a><span id="l3.13722">       mImapMockChannel-&gt;RunOnStopRequestFailure();</span>
<a href="#l3.13723"></a><span id="l3.13723">     }</span>
<a href="#l3.13724"></a><span id="l3.13724">     return NS_OK;</span>
<a href="#l3.13725"></a><span id="l3.13725">   }</span>
<a href="#l3.13726"></a><span id="l3.13726" class="difflineminus">-private:</span>
<a href="#l3.13727"></a><span id="l3.13727" class="difflineplus">+</span>
<a href="#l3.13728"></a><span id="l3.13728" class="difflineplus">+ private:</span>
<a href="#l3.13729"></a><span id="l3.13729">   RefPtr&lt;nsImapMockChannel&gt; mImapMockChannel;</span>
<a href="#l3.13730"></a><span id="l3.13730"> };</span>
<a href="#l3.13731"></a><span id="l3.13731"> </span>
<a href="#l3.13732"></a><span id="l3.13732" class="difflineminus">-</span>
<a href="#l3.13733"></a><span id="l3.13733" class="difflineminus">-nsresult nsImapMockChannel::RunOnStopRequestFailure()</span>
<a href="#l3.13734"></a><span id="l3.13734" class="difflineminus">-{</span>
<a href="#l3.13735"></a><span id="l3.13735" class="difflineplus">+nsresult nsImapMockChannel::RunOnStopRequestFailure() {</span>
<a href="#l3.13736"></a><span id="l3.13736">   if (m_channelListener) {</span>
<a href="#l3.13737"></a><span id="l3.13737">     m_channelListener-&gt;OnStopRequest(this, NS_MSG_ERROR_MSG_NOT_OFFLINE);</span>
<a href="#l3.13738"></a><span id="l3.13738">   }</span>
<a href="#l3.13739"></a><span id="l3.13739">   return NS_OK;</span>
<a href="#l3.13740"></a><span id="l3.13740"> }</span>
<a href="#l3.13741"></a><span id="l3.13741"> </span>
<a href="#l3.13742"></a><span id="l3.13742"> // the requested url isn't in any of our caches so create an imap connection</span>
<a href="#l3.13743"></a><span id="l3.13743"> // to process it.</span>
<a href="#l3.13744"></a><span id="l3.13744" class="difflineminus">-nsresult nsImapMockChannel::ReadFromImapConnection()</span>
<a href="#l3.13745"></a><span id="l3.13745" class="difflineminus">-{</span>
<a href="#l3.13746"></a><span id="l3.13746" class="difflineplus">+nsresult nsImapMockChannel::ReadFromImapConnection() {</span>
<a href="#l3.13747"></a><span id="l3.13747">   nsresult rv = NS_OK;</span>
<a href="#l3.13748"></a><span id="l3.13748">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url);</span>
<a href="#l3.13749"></a><span id="l3.13749">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url);</span>
<a href="#l3.13750"></a><span id="l3.13750"> </span>
<a href="#l3.13751"></a><span id="l3.13751">   bool localOnly = false;</span>
<a href="#l3.13752"></a><span id="l3.13752">   imapUrl-&gt;GetLocalFetchOnly(&amp;localOnly);</span>
<a href="#l3.13753"></a><span id="l3.13753" class="difflineminus">-  if (localOnly)</span>
<a href="#l3.13754"></a><span id="l3.13754" class="difflineminus">-  {</span>
<a href="#l3.13755"></a><span id="l3.13755" class="difflineplus">+  if (localOnly) {</span>
<a href="#l3.13756"></a><span id="l3.13756">     // This will cause an OnStartRunningUrl, and the subsequent close</span>
<a href="#l3.13757"></a><span id="l3.13757">     // will then cause an OnStopRunningUrl with the cancel status.</span>
<a href="#l3.13758"></a><span id="l3.13758">     NotifyStartEndReadFromCache(true);</span>
<a href="#l3.13759"></a><span id="l3.13759">     Cancel(NS_MSG_ERROR_MSG_NOT_OFFLINE);</span>
<a href="#l3.13760"></a><span id="l3.13760"> </span>
<a href="#l3.13761"></a><span id="l3.13761">     // Dispatch error notification, so ReadFromImapConnection() returns *before*</span>
<a href="#l3.13762"></a><span id="l3.13762">     // the error is sent to the listener's OnStopRequest(). This avoids</span>
<a href="#l3.13763"></a><span id="l3.13763">     // endless recursion where the caller relies on async execution.</span>
<a href="#l3.13764"></a><span id="l3.13764">     nsCOMPtr&lt;nsIRunnable&gt; event = new nsReadFromImapConnectionFailure(this);</span>
<a href="#l3.13765"></a><span id="l3.13765">     NS_DispatchToCurrentThread(event);</span>
<a href="#l3.13766"></a><span id="l3.13766">     return NS_MSG_ERROR_MSG_NOT_OFFLINE;</span>
<a href="#l3.13767"></a><span id="l3.13767">   }</span>
<a href="#l3.13768"></a><span id="l3.13768"> </span>
<a href="#l3.13769"></a><span id="l3.13769" class="difflineminus">-  nsCOMPtr &lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.13770"></a><span id="l3.13770" class="difflineplus">+  nsCOMPtr&lt;nsILoadGroup&gt; loadGroup;</span>
<a href="#l3.13771"></a><span id="l3.13771">   GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.13772"></a><span id="l3.13772" class="difflineminus">-  if (!loadGroup) // if we don't have one, the url will snag one from the msg window...</span>
<a href="#l3.13773"></a><span id="l3.13773" class="difflineplus">+  if (!loadGroup)  // if we don't have one, the url will snag one from the msg</span>
<a href="#l3.13774"></a><span id="l3.13774" class="difflineplus">+                   // window...</span>
<a href="#l3.13775"></a><span id="l3.13775">     mailnewsUrl-&gt;GetLoadGroup(getter_AddRefs(loadGroup));</span>
<a href="#l3.13776"></a><span id="l3.13776"> </span>
<a href="#l3.13777"></a><span id="l3.13777">   // okay, add the mock channel to the load group..</span>
<a href="#l3.13778"></a><span id="l3.13778">   if (loadGroup)</span>
<a href="#l3.13779"></a><span id="l3.13779" class="difflineminus">-    loadGroup-&gt;AddRequest((nsIRequest *) this, nullptr /* context isupports */);</span>
<a href="#l3.13780"></a><span id="l3.13780" class="difflineminus">-</span>
<a href="#l3.13781"></a><span id="l3.13781" class="difflineminus">-  // loading the url consists of asking the server to add the url to it's imap event queue....</span>
<a href="#l3.13782"></a><span id="l3.13782" class="difflineplus">+    loadGroup-&gt;AddRequest((nsIRequest *)this, nullptr /* context isupports */);</span>
<a href="#l3.13783"></a><span id="l3.13783" class="difflineplus">+</span>
<a href="#l3.13784"></a><span id="l3.13784" class="difflineplus">+  // loading the url consists of asking the server to add the url to it's imap</span>
<a href="#l3.13785"></a><span id="l3.13785" class="difflineplus">+  // event queue....</span>
<a href="#l3.13786"></a><span id="l3.13786">   nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l3.13787"></a><span id="l3.13787">   rv = mailnewsUrl-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l3.13788"></a><span id="l3.13788">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13789"></a><span id="l3.13789" class="difflineminus">-  nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer (do_QueryInterface(server, &amp;rv));</span>
<a href="#l3.13790"></a><span id="l3.13790" class="difflineplus">+  nsCOMPtr&lt;nsIImapIncomingServer&gt; imapServer(do_QueryInterface(server, &amp;rv));</span>
<a href="#l3.13791"></a><span id="l3.13791">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13792"></a><span id="l3.13792"> </span>
<a href="#l3.13793"></a><span id="l3.13793">   // Assume AsyncRead is always called from the UI thread.....</span>
<a href="#l3.13794"></a><span id="l3.13794">   return imapServer-&gt;GetImapConnectionAndLoadUrl(imapUrl, m_channelListener);</span>
<a href="#l3.13795"></a><span id="l3.13795"> }</span>
<a href="#l3.13796"></a><span id="l3.13796"> </span>
<a href="#l3.13797"></a><span id="l3.13797" class="difflineminus">-// for messages stored in our offline cache, we have special code to handle that...</span>
<a href="#l3.13798"></a><span id="l3.13798" class="difflineminus">-// If it's in the local cache, we return true and we can abort the download because</span>
<a href="#l3.13799"></a><span id="l3.13799" class="difflineminus">-// this method does the rest of the work.</span>
<a href="#l3.13800"></a><span id="l3.13800" class="difflineminus">-bool nsImapMockChannel::ReadFromLocalCache()</span>
<a href="#l3.13801"></a><span id="l3.13801" class="difflineminus">-{</span>
<a href="#l3.13802"></a><span id="l3.13802" class="difflineplus">+// for messages stored in our offline cache, we have special code to handle</span>
<a href="#l3.13803"></a><span id="l3.13803" class="difflineplus">+// that... If it's in the local cache, we return true and we can abort the</span>
<a href="#l3.13804"></a><span id="l3.13804" class="difflineplus">+// download because this method does the rest of the work.</span>
<a href="#l3.13805"></a><span id="l3.13805" class="difflineplus">+bool nsImapMockChannel::ReadFromLocalCache() {</span>
<a href="#l3.13806"></a><span id="l3.13806">   nsresult rv = NS_OK;</span>
<a href="#l3.13807"></a><span id="l3.13807"> </span>
<a href="#l3.13808"></a><span id="l3.13808">   nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url);</span>
<a href="#l3.13809"></a><span id="l3.13809">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url, &amp;rv);</span>
<a href="#l3.13810"></a><span id="l3.13810"> </span>
<a href="#l3.13811"></a><span id="l3.13811">   bool useLocalCache = false;</span>
<a href="#l3.13812"></a><span id="l3.13812">   mailnewsUrl-&gt;GetMsgIsInLocalCache(&amp;useLocalCache);</span>
<a href="#l3.13813"></a><span id="l3.13813" class="difflineminus">-  if (useLocalCache)</span>
<a href="#l3.13814"></a><span id="l3.13814" class="difflineminus">-  {</span>
<a href="#l3.13815"></a><span id="l3.13815" class="difflineplus">+  if (useLocalCache) {</span>
<a href="#l3.13816"></a><span id="l3.13816">     nsAutoCString messageIdString;</span>
<a href="#l3.13817"></a><span id="l3.13817"> </span>
<a href="#l3.13818"></a><span id="l3.13818">     SetupPartExtractorListener(imapUrl, m_channelListener);</span>
<a href="#l3.13819"></a><span id="l3.13819"> </span>
<a href="#l3.13820"></a><span id="l3.13820">     imapUrl-&gt;GetListOfMessageIds(messageIdString);</span>
<a href="#l3.13821"></a><span id="l3.13821" class="difflineminus">-    nsCOMPtr &lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.13822"></a><span id="l3.13822" class="difflineplus">+    nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l3.13823"></a><span id="l3.13823">     rv = mailnewsUrl-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l3.13824"></a><span id="l3.13824" class="difflineminus">-    if (folder &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l3.13825"></a><span id="l3.13825" class="difflineminus">-    {</span>
<a href="#l3.13826"></a><span id="l3.13826" class="difflineplus">+    if (folder &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<a href="#l3.13827"></a><span id="l3.13827">       // we want to create a file channel and read the msg from there.</span>
<a href="#l3.13828"></a><span id="l3.13828">       nsCOMPtr&lt;nsIInputStream&gt; fileStream;</span>
<a href="#l3.13829"></a><span id="l3.13829">       nsMsgKey msgKey = strtoul(messageIdString.get(), nullptr, 10);</span>
<a href="#l3.13830"></a><span id="l3.13830">       uint32_t size;</span>
<a href="#l3.13831"></a><span id="l3.13831">       int64_t offset;</span>
<a href="#l3.13832"></a><span id="l3.13832" class="difflineminus">-      rv = folder-&gt;GetOfflineFileStream(msgKey, &amp;offset, &amp;size, getter_AddRefs(fileStream));</span>
<a href="#l3.13833"></a><span id="l3.13833" class="difflineplus">+      rv = folder-&gt;GetOfflineFileStream(msgKey, &amp;offset, &amp;size,</span>
<a href="#l3.13834"></a><span id="l3.13834" class="difflineplus">+                                        getter_AddRefs(fileStream));</span>
<a href="#l3.13835"></a><span id="l3.13835">       // get the file channel from the folder, somehow (through the message or</span>
<a href="#l3.13836"></a><span id="l3.13836" class="difflineminus">-      // folder sink?) We also need to set the transfer offset to the message offset</span>
<a href="#l3.13837"></a><span id="l3.13837" class="difflineminus">-      if (fileStream &amp;&amp; NS_SUCCEEDED(rv))</span>
<a href="#l3.13838"></a><span id="l3.13838" class="difflineminus">-      {</span>
<a href="#l3.13839"></a><span id="l3.13839" class="difflineminus">-        // dougt - This may break the ablity to &quot;cancel&quot; a read from offline mail reading.</span>
<a href="#l3.13840"></a><span id="l3.13840" class="difflineminus">-        // fileChannel-&gt;SetLoadGroup(m_loadGroup);</span>
<a href="#l3.13841"></a><span id="l3.13841" class="difflineminus">-        RefPtr&lt;nsImapCacheStreamListener&gt; cacheListener = new nsImapCacheStreamListener();</span>
<a href="#l3.13842"></a><span id="l3.13842" class="difflineplus">+      // folder sink?) We also need to set the transfer offset to the message</span>
<a href="#l3.13843"></a><span id="l3.13843" class="difflineplus">+      // offset</span>
<a href="#l3.13844"></a><span id="l3.13844" class="difflineplus">+      if (fileStream &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<a href="#l3.13845"></a><span id="l3.13845" class="difflineplus">+        // dougt - This may break the ablity to &quot;cancel&quot; a read from offline</span>
<a href="#l3.13846"></a><span id="l3.13846" class="difflineplus">+        // mail reading. fileChannel-&gt;SetLoadGroup(m_loadGroup);</span>
<a href="#l3.13847"></a><span id="l3.13847" class="difflineplus">+        RefPtr&lt;nsImapCacheStreamListener&gt; cacheListener =</span>
<a href="#l3.13848"></a><span id="l3.13848" class="difflineplus">+            new nsImapCacheStreamListener();</span>
<a href="#l3.13849"></a><span id="l3.13849">         cacheListener-&gt;Init(m_channelListener, this);</span>
<a href="#l3.13850"></a><span id="l3.13850"> </span>
<a href="#l3.13851"></a><span id="l3.13851" class="difflineminus">-        // create a stream pump that will async read the specified amount of data.</span>
<a href="#l3.13852"></a><span id="l3.13852" class="difflineplus">+        // create a stream pump that will async read the specified amount of</span>
<a href="#l3.13853"></a><span id="l3.13853" class="difflineplus">+        // data.</span>
<a href="#l3.13854"></a><span id="l3.13854">         // XXX make size 64-bit int</span>
<a href="#l3.13855"></a><span id="l3.13855" class="difflineminus">-        RefPtr&lt;SlicedInputStream&gt; slicedStream =</span>
<a href="#l3.13856"></a><span id="l3.13856" class="difflineminus">-          new SlicedInputStream(fileStream.forget(), uint64_t(offset), uint64_t(size));</span>
<a href="#l3.13857"></a><span id="l3.13857" class="difflineplus">+        RefPtr&lt;SlicedInputStream&gt; slicedStream = new SlicedInputStream(</span>
<a href="#l3.13858"></a><span id="l3.13858" class="difflineplus">+            fileStream.forget(), uint64_t(offset), uint64_t(size));</span>
<a href="#l3.13859"></a><span id="l3.13859">         nsCOMPtr&lt;nsIInputStreamPump&gt; pump;</span>
<a href="#l3.13860"></a><span id="l3.13860">         rv = NS_NewInputStreamPump(getter_AddRefs(pump), slicedStream.forget());</span>
<a href="#l3.13861"></a><span id="l3.13861">         if (NS_SUCCEEDED(rv))</span>
<a href="#l3.13862"></a><span id="l3.13862">           rv = pump-&gt;AsyncRead(cacheListener, m_channelContext);</span>
<a href="#l3.13863"></a><span id="l3.13863"> </span>
<a href="#l3.13864"></a><span id="l3.13864" class="difflineminus">-        if (NS_SUCCEEDED(rv)) // ONLY if we succeeded in actually starting the read should we return</span>
<a href="#l3.13865"></a><span id="l3.13865" class="difflineplus">+        if (NS_SUCCEEDED(rv))  // ONLY if we succeeded in actually starting the</span>
<a href="#l3.13866"></a><span id="l3.13866" class="difflineplus">+                               // read should we return</span>
<a href="#l3.13867"></a><span id="l3.13867">         {</span>
<a href="#l3.13868"></a><span id="l3.13868" class="difflineminus">-          // if the msg is unread, we should mark it read on the server. This lets</span>
<a href="#l3.13869"></a><span id="l3.13869" class="difflineminus">-          // the code running this url we're loading from the cache, if it cares.</span>
<a href="#l3.13870"></a><span id="l3.13870" class="difflineplus">+          // if the msg is unread, we should mark it read on the server. This</span>
<a href="#l3.13871"></a><span id="l3.13871" class="difflineplus">+          // lets the code running this url we're loading from the cache, if it</span>
<a href="#l3.13872"></a><span id="l3.13872" class="difflineplus">+          // cares.</span>
<a href="#l3.13873"></a><span id="l3.13873">           imapUrl-&gt;SetMsgLoadingFromCache(true);</span>
<a href="#l3.13874"></a><span id="l3.13874">           return true;</span>
<a href="#l3.13875"></a><span id="l3.13875">         }</span>
<a href="#l3.13876"></a><span id="l3.13876" class="difflineminus">-      } // if we got an offline file transport</span>
<a href="#l3.13877"></a><span id="l3.13877" class="difflineminus">-    } // if we got the folder for this url</span>
<a href="#l3.13878"></a><span id="l3.13878" class="difflineminus">-  } // if use local cache</span>
<a href="#l3.13879"></a><span id="l3.13879" class="difflineplus">+      }  // if we got an offline file transport</span>
<a href="#l3.13880"></a><span id="l3.13880" class="difflineplus">+    }    // if we got the folder for this url</span>
<a href="#l3.13881"></a><span id="l3.13881" class="difflineplus">+  }      // if use local cache</span>
<a href="#l3.13882"></a><span id="l3.13882"> </span>
<a href="#l3.13883"></a><span id="l3.13883">   return false;</span>
<a href="#l3.13884"></a><span id="l3.13884"> }</span>
<a href="#l3.13885"></a><span id="l3.13885"> </span>
<a href="#l3.13886"></a><span id="l3.13886" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::AsyncOpen(nsIStreamListener *aListener)</span>
<a href="#l3.13887"></a><span id="l3.13887" class="difflineminus">-{</span>
<a href="#l3.13888"></a><span id="l3.13888" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::AsyncOpen(nsIStreamListener *aListener) {</span>
<a href="#l3.13889"></a><span id="l3.13889">   nsCOMPtr&lt;nsIStreamListener&gt; listener = aListener;</span>
<a href="#l3.13890"></a><span id="l3.13890" class="difflineminus">-  nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);</span>
<a href="#l3.13891"></a><span id="l3.13891" class="difflineplus">+  nsresult rv =</span>
<a href="#l3.13892"></a><span id="l3.13892" class="difflineplus">+      nsContentSecurityManager::doContentSecurityCheck(this, listener);</span>
<a href="#l3.13893"></a><span id="l3.13893">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l3.13894"></a><span id="l3.13894"> </span>
<a href="#l3.13895"></a><span id="l3.13895">   int32_t port;</span>
<a href="#l3.13896"></a><span id="l3.13896" class="difflineminus">-  if (!m_url)</span>
<a href="#l3.13897"></a><span id="l3.13897" class="difflineminus">-    return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.13898"></a><span id="l3.13898" class="difflineplus">+  if (!m_url) return NS_ERROR_NULL_POINTER;</span>
<a href="#l3.13899"></a><span id="l3.13899">   rv = m_url-&gt;GetPort(&amp;port);</span>
<a href="#l3.13900"></a><span id="l3.13900" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l3.13901"></a><span id="l3.13901" class="difflineminus">-      return rv;</span>
<a href="#l3.13902"></a><span id="l3.13902" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l3.13903"></a><span id="l3.13903"> </span>
<a href="#l3.13904"></a><span id="l3.13904">   rv = NS_CheckPortSafety(port, &quot;imap&quot;);</span>
<a href="#l3.13905"></a><span id="l3.13905" class="difflineminus">-  if (NS_FAILED(rv))</span>
<a href="#l3.13906"></a><span id="l3.13906" class="difflineminus">-      return rv;</span>
<a href="#l3.13907"></a><span id="l3.13907" class="difflineplus">+  if (NS_FAILED(rv)) return rv;</span>
<a href="#l3.13908"></a><span id="l3.13908"> </span>
<a href="#l3.13909"></a><span id="l3.13909">   // set the stream listener and then load the url</span>
<a href="#l3.13910"></a><span id="l3.13910">   m_channelContext = nullptr;</span>
<a href="#l3.13911"></a><span id="l3.13911" class="difflineminus">-  nsCOMPtr &lt;nsIURI&gt; uri;</span>
<a href="#l3.13912"></a><span id="l3.13912" class="difflineplus">+  nsCOMPtr&lt;nsIURI&gt; uri;</span>
<a href="#l3.13913"></a><span id="l3.13913">   GetURI(getter_AddRefs(uri));</span>
<a href="#l3.13914"></a><span id="l3.13914">   m_channelContext = uri;</span>
<a href="#l3.13915"></a><span id="l3.13915"> </span>
<a href="#l3.13916"></a><span id="l3.13916">   NS_ASSERTION(!m_channelListener, &quot;shouldn't already have a listener&quot;);</span>
<a href="#l3.13917"></a><span id="l3.13917">   m_channelListener = listener;</span>
<a href="#l3.13918"></a><span id="l3.13918" class="difflineminus">-  nsCOMPtr&lt;nsIImapUrl&gt; imapUrl  (do_QueryInterface(m_url));</span>
<a href="#l3.13919"></a><span id="l3.13919" class="difflineplus">+  nsCOMPtr&lt;nsIImapUrl&gt; imapUrl(do_QueryInterface(m_url));</span>
<a href="#l3.13920"></a><span id="l3.13920"> </span>
<a href="#l3.13921"></a><span id="l3.13921">   nsImapAction imapAction;</span>
<a href="#l3.13922"></a><span id="l3.13922">   imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.13923"></a><span id="l3.13923"> </span>
<a href="#l3.13924"></a><span id="l3.13924">   bool externalLink = true;</span>
<a href="#l3.13925"></a><span id="l3.13925">   imapUrl-&gt;GetExternalLinkUrl(&amp;externalLink);</span>
<a href="#l3.13926"></a><span id="l3.13926"> </span>
<a href="#l3.13927"></a><span id="l3.13927" class="difflineminus">-  if (externalLink)</span>
<a href="#l3.13928"></a><span id="l3.13928" class="difflineminus">-  {</span>
<a href="#l3.13929"></a><span id="l3.13929" class="difflineminus">-    // for security purposes, only allow imap urls originating from external sources</span>
<a href="#l3.13930"></a><span id="l3.13930" class="difflineminus">-    // perform a limited set of actions.</span>
<a href="#l3.13931"></a><span id="l3.13931" class="difflineminus">-    // Currently the allowed set includes:</span>
<a href="#l3.13932"></a><span id="l3.13932" class="difflineminus">-    // 1) folder selection</span>
<a href="#l3.13933"></a><span id="l3.13933" class="difflineminus">-    // 2) message fetch</span>
<a href="#l3.13934"></a><span id="l3.13934" class="difflineminus">-    // 3) message part fetch</span>
<a href="#l3.13935"></a><span id="l3.13935" class="difflineminus">-</span>
<a href="#l3.13936"></a><span id="l3.13936" class="difflineminus">-    if (! (imapAction == nsIImapUrl::nsImapSelectFolder || imapAction == nsIImapUrl::nsImapMsgFetch || imapAction == nsIImapUrl::nsImapOpenMimePart</span>
<a href="#l3.13937"></a><span id="l3.13937" class="difflineminus">-      || imapAction == nsIImapUrl::nsImapMsgFetchPeek))</span>
<a href="#l3.13938"></a><span id="l3.13938" class="difflineminus">-      return NS_ERROR_FAILURE; // abort the running of this url....it failed a security check</span>
<a href="#l3.13939"></a><span id="l3.13939" class="difflineminus">-  }</span>
<a href="#l3.13940"></a><span id="l3.13940" class="difflineminus">-</span>
<a href="#l3.13941"></a><span id="l3.13941" class="difflineminus">-  if (ReadFromLocalCache())</span>
<a href="#l3.13942"></a><span id="l3.13942" class="difflineminus">-  {</span>
<a href="#l3.13943"></a><span id="l3.13943" class="difflineminus">-    (void) NotifyStartEndReadFromCache(true);</span>
<a href="#l3.13944"></a><span id="l3.13944" class="difflineplus">+  if (externalLink) {</span>
<a href="#l3.13945"></a><span id="l3.13945" class="difflineplus">+    // for security purposes, only allow imap urls originating from external</span>
<a href="#l3.13946"></a><span id="l3.13946" class="difflineplus">+    // sources perform a limited set of actions. Currently the allowed set</span>
<a href="#l3.13947"></a><span id="l3.13947" class="difflineplus">+    // includes: 1) folder selection 2) message fetch 3) message part fetch</span>
<a href="#l3.13948"></a><span id="l3.13948" class="difflineplus">+</span>
<a href="#l3.13949"></a><span id="l3.13949" class="difflineplus">+    if (!(imapAction == nsIImapUrl::nsImapSelectFolder ||</span>
<a href="#l3.13950"></a><span id="l3.13950" class="difflineplus">+          imapAction == nsIImapUrl::nsImapMsgFetch ||</span>
<a href="#l3.13951"></a><span id="l3.13951" class="difflineplus">+          imapAction == nsIImapUrl::nsImapOpenMimePart ||</span>
<a href="#l3.13952"></a><span id="l3.13952" class="difflineplus">+          imapAction == nsIImapUrl::nsImapMsgFetchPeek))</span>
<a href="#l3.13953"></a><span id="l3.13953" class="difflineplus">+      return NS_ERROR_FAILURE;  // abort the running of this url....it failed a</span>
<a href="#l3.13954"></a><span id="l3.13954" class="difflineplus">+                                // security check</span>
<a href="#l3.13955"></a><span id="l3.13955" class="difflineplus">+  }</span>
<a href="#l3.13956"></a><span id="l3.13956" class="difflineplus">+</span>
<a href="#l3.13957"></a><span id="l3.13957" class="difflineplus">+  if (ReadFromLocalCache()) {</span>
<a href="#l3.13958"></a><span id="l3.13958" class="difflineplus">+    (void)NotifyStartEndReadFromCache(true);</span>
<a href="#l3.13959"></a><span id="l3.13959">     return NS_OK;</span>
<a href="#l3.13960"></a><span id="l3.13960">   }</span>
<a href="#l3.13961"></a><span id="l3.13961"> </span>
<a href="#l3.13962"></a><span id="l3.13962">   // okay, it's not in the local cache, now check the memory cache...</span>
<a href="#l3.13963"></a><span id="l3.13963">   // but we can't download for offline use from the memory cache</span>
<a href="#l3.13964"></a><span id="l3.13964" class="difflineminus">-  if (imapAction != nsIImapUrl::nsImapMsgDownloadForOffline)</span>
<a href="#l3.13965"></a><span id="l3.13965" class="difflineminus">-  {</span>
<a href="#l3.13966"></a><span id="l3.13966" class="difflineplus">+  if (imapAction != nsIImapUrl::nsImapMsgDownloadForOffline) {</span>
<a href="#l3.13967"></a><span id="l3.13967">     rv = OpenCacheEntry();</span>
<a href="#l3.13968"></a><span id="l3.13968" class="difflineminus">-    if (NS_SUCCEEDED(rv))</span>
<a href="#l3.13969"></a><span id="l3.13969" class="difflineminus">-      return rv;</span>
<a href="#l3.13970"></a><span id="l3.13970" class="difflineplus">+    if (NS_SUCCEEDED(rv)) return rv;</span>
<a href="#l3.13971"></a><span id="l3.13971">   }</span>
<a href="#l3.13972"></a><span id="l3.13972"> </span>
<a href="#l3.13973"></a><span id="l3.13973">   SetupPartExtractorListener(imapUrl, m_channelListener);</span>
<a href="#l3.13974"></a><span id="l3.13974" class="difflineminus">-  // if for some reason open cache entry failed then just default to opening an imap connection for the url</span>
<a href="#l3.13975"></a><span id="l3.13975" class="difflineplus">+  // if for some reason open cache entry failed then just default to opening an</span>
<a href="#l3.13976"></a><span id="l3.13976" class="difflineplus">+  // imap connection for the url</span>
<a href="#l3.13977"></a><span id="l3.13977">   return ReadFromImapConnection();</span>
<a href="#l3.13978"></a><span id="l3.13978"> }</span>
<a href="#l3.13979"></a><span id="l3.13979"> </span>
<a href="#l3.13980"></a><span id="l3.13980" class="difflineminus">-nsresult nsImapMockChannel::SetupPartExtractorListener(nsIImapUrl * aUrl, nsIStreamListener * aConsumer)</span>
<a href="#l3.13981"></a><span id="l3.13981" class="difflineminus">-{</span>
<a href="#l3.13982"></a><span id="l3.13982" class="difflineplus">+nsresult nsImapMockChannel::SetupPartExtractorListener(</span>
<a href="#l3.13983"></a><span id="l3.13983" class="difflineplus">+    nsIImapUrl *aUrl, nsIStreamListener *aConsumer) {</span>
<a href="#l3.13984"></a><span id="l3.13984">   // if the url we are loading refers to a specific part then we need</span>
<a href="#l3.13985"></a><span id="l3.13985">   // libmime to extract that part from the message for us.</span>
<a href="#l3.13986"></a><span id="l3.13986">   bool refersToPart = false;</span>
<a href="#l3.13987"></a><span id="l3.13987">   aUrl-&gt;GetMimePartSelectorDetected(&amp;refersToPart);</span>
<a href="#l3.13988"></a><span id="l3.13988" class="difflineminus">-  if (refersToPart)</span>
<a href="#l3.13989"></a><span id="l3.13989" class="difflineminus">-  {</span>
<a href="#l3.13990"></a><span id="l3.13990" class="difflineminus">-    nsCOMPtr&lt;nsIStreamConverterService&gt; converter = do_GetService(&quot;@mozilla.org/streamConverters;1&quot;);</span>
<a href="#l3.13991"></a><span id="l3.13991" class="difflineminus">-    if (converter &amp;&amp; aConsumer)</span>
<a href="#l3.13992"></a><span id="l3.13992" class="difflineminus">-    {</span>
<a href="#l3.13993"></a><span id="l3.13993" class="difflineplus">+  if (refersToPart) {</span>
<a href="#l3.13994"></a><span id="l3.13994" class="difflineplus">+    nsCOMPtr&lt;nsIStreamConverterService&gt; converter =</span>
<a href="#l3.13995"></a><span id="l3.13995" class="difflineplus">+        do_GetService(&quot;@mozilla.org/streamConverters;1&quot;);</span>
<a href="#l3.13996"></a><span id="l3.13996" class="difflineplus">+    if (converter &amp;&amp; aConsumer) {</span>
<a href="#l3.13997"></a><span id="l3.13997">       nsCOMPtr&lt;nsIStreamListener&gt; newConsumer;</span>
<a href="#l3.13998"></a><span id="l3.13998" class="difflineminus">-      converter-&gt;AsyncConvertData(&quot;message/rfc822&quot;, &quot;*/*&quot;,</span>
<a href="#l3.13999"></a><span id="l3.13999" class="difflineminus">-           aConsumer, static_cast&lt;nsIChannel *&gt;(this), getter_AddRefs(newConsumer));</span>
<a href="#l3.14000"></a><span id="l3.14000" class="difflineminus">-      if (newConsumer)</span>
<a href="#l3.14001"></a><span id="l3.14001" class="difflineminus">-        m_channelListener = newConsumer;</span>
<a href="#l3.14002"></a><span id="l3.14002" class="difflineplus">+      converter-&gt;AsyncConvertData(&quot;message/rfc822&quot;, &quot;*/*&quot;, aConsumer,</span>
<a href="#l3.14003"></a><span id="l3.14003" class="difflineplus">+                                  static_cast&lt;nsIChannel *&gt;(this),</span>
<a href="#l3.14004"></a><span id="l3.14004" class="difflineplus">+                                  getter_AddRefs(newConsumer));</span>
<a href="#l3.14005"></a><span id="l3.14005" class="difflineplus">+      if (newConsumer) m_channelListener = newConsumer;</span>
<a href="#l3.14006"></a><span id="l3.14006">     }</span>
<a href="#l3.14007"></a><span id="l3.14007">   }</span>
<a href="#l3.14008"></a><span id="l3.14008"> </span>
<a href="#l3.14009"></a><span id="l3.14009">   return NS_OK;</span>
<a href="#l3.14010"></a><span id="l3.14010"> }</span>
<a href="#l3.14011"></a><span id="l3.14011"> </span>
<a href="#l3.14012"></a><span id="l3.14012" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)</span>
<a href="#l3.14013"></a><span id="l3.14013" class="difflineminus">-{</span>
<a href="#l3.14014"></a><span id="l3.14014" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetLoadFlags(nsLoadFlags *aLoadFlags) {</span>
<a href="#l3.14015"></a><span id="l3.14015">   //*aLoadFlags = nsIRequest::LOAD_NORMAL;</span>
<a href="#l3.14016"></a><span id="l3.14016">   *aLoadFlags = mLoadFlags;</span>
<a href="#l3.14017"></a><span id="l3.14017">   return NS_OK;</span>
<a href="#l3.14018"></a><span id="l3.14018"> }</span>
<a href="#l3.14019"></a><span id="l3.14019"> </span>
<a href="#l3.14020"></a><span id="l3.14020" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetLoadFlags(nsLoadFlags aLoadFlags)</span>
<a href="#l3.14021"></a><span id="l3.14021" class="difflineminus">-{</span>
<a href="#l3.14022"></a><span id="l3.14022" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetLoadFlags(nsLoadFlags aLoadFlags) {</span>
<a href="#l3.14023"></a><span id="l3.14023">   mLoadFlags = aLoadFlags;</span>
<a href="#l3.14024"></a><span id="l3.14024" class="difflineminus">-  return NS_OK;       // don't fail when trying to set this</span>
<a href="#l3.14025"></a><span id="l3.14025" class="difflineminus">-}</span>
<a href="#l3.14026"></a><span id="l3.14026" class="difflineminus">-</span>
<a href="#l3.14027"></a><span id="l3.14027" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetContentType(nsACString &amp;aContentType)</span>
<a href="#l3.14028"></a><span id="l3.14028" class="difflineminus">-{</span>
<a href="#l3.14029"></a><span id="l3.14029" class="difflineminus">-  if (mContentType.IsEmpty())</span>
<a href="#l3.14030"></a><span id="l3.14030" class="difflineminus">-  {</span>
<a href="#l3.14031"></a><span id="l3.14031" class="difflineplus">+  return NS_OK;  // don't fail when trying to set this</span>
<a href="#l3.14032"></a><span id="l3.14032" class="difflineplus">+}</span>
<a href="#l3.14033"></a><span id="l3.14033" class="difflineplus">+</span>
<a href="#l3.14034"></a><span id="l3.14034" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetContentType(nsACString &amp;aContentType) {</span>
<a href="#l3.14035"></a><span id="l3.14035" class="difflineplus">+  if (mContentType.IsEmpty()) {</span>
<a href="#l3.14036"></a><span id="l3.14036">     nsImapAction imapAction = 0;</span>
<a href="#l3.14037"></a><span id="l3.14037" class="difflineminus">-    if (m_url)</span>
<a href="#l3.14038"></a><span id="l3.14038" class="difflineminus">-    {</span>
<a href="#l3.14039"></a><span id="l3.14039" class="difflineplus">+    if (m_url) {</span>
<a href="#l3.14040"></a><span id="l3.14040">       nsCOMPtr&lt;nsIImapUrl&gt; imapUrl = do_QueryInterface(m_url);</span>
<a href="#l3.14041"></a><span id="l3.14041" class="difflineminus">-      if (imapUrl)</span>
<a href="#l3.14042"></a><span id="l3.14042" class="difflineminus">-      {</span>
<a href="#l3.14043"></a><span id="l3.14043" class="difflineplus">+      if (imapUrl) {</span>
<a href="#l3.14044"></a><span id="l3.14044">         imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l3.14045"></a><span id="l3.14045">       }</span>
<a href="#l3.14046"></a><span id="l3.14046">     }</span>
<a href="#l3.14047"></a><span id="l3.14047">     if (imapAction == nsIImapUrl::nsImapSelectFolder)</span>
<a href="#l3.14048"></a><span id="l3.14048">       aContentType.AssignLiteral(&quot;x-application-imapfolder&quot;);</span>
<a href="#l3.14049"></a><span id="l3.14049">     else</span>
<a href="#l3.14050"></a><span id="l3.14050">       aContentType.AssignLiteral(&quot;message/rfc822&quot;);</span>
<a href="#l3.14051"></a><span id="l3.14051" class="difflineminus">-  }</span>
<a href="#l3.14052"></a><span id="l3.14052" class="difflineminus">-  else</span>
<a href="#l3.14053"></a><span id="l3.14053" class="difflineplus">+  } else</span>
<a href="#l3.14054"></a><span id="l3.14054">     aContentType = mContentType;</span>
<a href="#l3.14055"></a><span id="l3.14055">   return NS_OK;</span>
<a href="#l3.14056"></a><span id="l3.14056"> }</span>
<a href="#l3.14057"></a><span id="l3.14057"> </span>
<a href="#l3.14058"></a><span id="l3.14058" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetContentType(const nsACString &amp;aContentType)</span>
<a href="#l3.14059"></a><span id="l3.14059" class="difflineminus">-{</span>
<a href="#l3.14060"></a><span id="l3.14060" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetContentType(</span>
<a href="#l3.14061"></a><span id="l3.14061" class="difflineplus">+    const nsACString &amp;aContentType) {</span>
<a href="#l3.14062"></a><span id="l3.14062">   nsAutoCString charset;</span>
<a href="#l3.14063"></a><span id="l3.14063" class="difflineminus">-  nsresult rv = NS_ParseResponseContentType(aContentType, mContentType, charset);</span>
<a href="#l3.14064"></a><span id="l3.14064" class="difflineplus">+  nsresult rv =</span>
<a href="#l3.14065"></a><span id="l3.14065" class="difflineplus">+      NS_ParseResponseContentType(aContentType, mContentType, charset);</span>
<a href="#l3.14066"></a><span id="l3.14066">   if (NS_FAILED(rv) || mContentType.IsEmpty())</span>
<a href="#l3.14067"></a><span id="l3.14067">     mContentType.AssignLiteral(UNKNOWN_CONTENT_TYPE);</span>
<a href="#l3.14068"></a><span id="l3.14068">   return rv;</span>
<a href="#l3.14069"></a><span id="l3.14069"> }</span>
<a href="#l3.14070"></a><span id="l3.14070"> </span>
<a href="#l3.14071"></a><span id="l3.14071" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetContentCharset(nsACString &amp;aContentCharset)</span>
<a href="#l3.14072"></a><span id="l3.14072" class="difflineminus">-{</span>
<a href="#l3.14073"></a><span id="l3.14073" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetContentCharset(</span>
<a href="#l3.14074"></a><span id="l3.14074" class="difflineplus">+    nsACString &amp;aContentCharset) {</span>
<a href="#l3.14075"></a><span id="l3.14075">   aContentCharset.Assign(mCharset);</span>
<a href="#l3.14076"></a><span id="l3.14076">   return NS_OK;</span>
<a href="#l3.14077"></a><span id="l3.14077"> }</span>
<a href="#l3.14078"></a><span id="l3.14078"> </span>
<a href="#l3.14079"></a><span id="l3.14079" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetContentCharset(const nsACString &amp;aContentCharset)</span>
<a href="#l3.14080"></a><span id="l3.14080" class="difflineminus">-{</span>
<a href="#l3.14081"></a><span id="l3.14081" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetContentCharset(</span>
<a href="#l3.14082"></a><span id="l3.14082" class="difflineplus">+    const nsACString &amp;aContentCharset) {</span>
<a href="#l3.14083"></a><span id="l3.14083">   mCharset.Assign(aContentCharset);</span>
<a href="#l3.14084"></a><span id="l3.14084">   return NS_OK;</span>
<a href="#l3.14085"></a><span id="l3.14085"> }</span>
<a href="#l3.14086"></a><span id="l3.14086"> </span>
<a href="#l3.14087"></a><span id="l3.14087"> NS_IMETHODIMP</span>
<a href="#l3.14088"></a><span id="l3.14088" class="difflineminus">-nsImapMockChannel::GetContentDisposition(uint32_t *aContentDisposition)</span>
<a href="#l3.14089"></a><span id="l3.14089" class="difflineminus">-{</span>
<a href="#l3.14090"></a><span id="l3.14090" class="difflineplus">+nsImapMockChannel::GetContentDisposition(uint32_t *aContentDisposition) {</span>
<a href="#l3.14091"></a><span id="l3.14091">   return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.14092"></a><span id="l3.14092"> }</span>
<a href="#l3.14093"></a><span id="l3.14093"> </span>
<a href="#l3.14094"></a><span id="l3.14094"> NS_IMETHODIMP</span>
<a href="#l3.14095"></a><span id="l3.14095" class="difflineminus">-nsImapMockChannel::SetContentDisposition(uint32_t aContentDisposition)</span>
<a href="#l3.14096"></a><span id="l3.14096" class="difflineminus">-{</span>
<a href="#l3.14097"></a><span id="l3.14097" class="difflineplus">+nsImapMockChannel::SetContentDisposition(uint32_t aContentDisposition) {</span>
<a href="#l3.14098"></a><span id="l3.14098">   return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.14099"></a><span id="l3.14099"> }</span>
<a href="#l3.14100"></a><span id="l3.14100"> </span>
<a href="#l3.14101"></a><span id="l3.14101"> NS_IMETHODIMP</span>
<a href="#l3.14102"></a><span id="l3.14102" class="difflineminus">-nsImapMockChannel::GetContentDispositionFilename(nsAString &amp;aContentDispositionFilename)</span>
<a href="#l3.14103"></a><span id="l3.14103" class="difflineminus">-{</span>
<a href="#l3.14104"></a><span id="l3.14104" class="difflineplus">+nsImapMockChannel::GetContentDispositionFilename(</span>
<a href="#l3.14105"></a><span id="l3.14105" class="difflineplus">+    nsAString &amp;aContentDispositionFilename) {</span>
<a href="#l3.14106"></a><span id="l3.14106">   return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.14107"></a><span id="l3.14107"> }</span>
<a href="#l3.14108"></a><span id="l3.14108"> </span>
<a href="#l3.14109"></a><span id="l3.14109"> NS_IMETHODIMP</span>
<a href="#l3.14110"></a><span id="l3.14110" class="difflineminus">-nsImapMockChannel::SetContentDispositionFilename(const nsAString &amp;aContentDispositionFilename)</span>
<a href="#l3.14111"></a><span id="l3.14111" class="difflineminus">-{</span>
<a href="#l3.14112"></a><span id="l3.14112" class="difflineplus">+nsImapMockChannel::SetContentDispositionFilename(</span>
<a href="#l3.14113"></a><span id="l3.14113" class="difflineplus">+    const nsAString &amp;aContentDispositionFilename) {</span>
<a href="#l3.14114"></a><span id="l3.14114">   return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.14115"></a><span id="l3.14115"> }</span>
<a href="#l3.14116"></a><span id="l3.14116"> </span>
<a href="#l3.14117"></a><span id="l3.14117"> NS_IMETHODIMP</span>
<a href="#l3.14118"></a><span id="l3.14118" class="difflineminus">-nsImapMockChannel::GetContentDispositionHeader(nsACString &amp;aContentDispositionHeader)</span>
<a href="#l3.14119"></a><span id="l3.14119" class="difflineminus">-{</span>
<a href="#l3.14120"></a><span id="l3.14120" class="difflineplus">+nsImapMockChannel::GetContentDispositionHeader(</span>
<a href="#l3.14121"></a><span id="l3.14121" class="difflineplus">+    nsACString &amp;aContentDispositionHeader) {</span>
<a href="#l3.14122"></a><span id="l3.14122">   return NS_ERROR_NOT_AVAILABLE;</span>
<a href="#l3.14123"></a><span id="l3.14123"> }</span>
<a href="#l3.14124"></a><span id="l3.14124"> </span>
<a href="#l3.14125"></a><span id="l3.14125" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetContentLength(int64_t * aContentLength)</span>
<a href="#l3.14126"></a><span id="l3.14126" class="difflineminus">-{</span>
<a href="#l3.14127"></a><span id="l3.14127" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetContentLength(int64_t *aContentLength) {</span>
<a href="#l3.14128"></a><span id="l3.14128">   *aContentLength = mContentLength;</span>
<a href="#l3.14129"></a><span id="l3.14129">   return NS_OK;</span>
<a href="#l3.14130"></a><span id="l3.14130"> }</span>
<a href="#l3.14131"></a><span id="l3.14131"> </span>
<a href="#l3.14132"></a><span id="l3.14132"> NS_IMETHODIMP</span>
<a href="#l3.14133"></a><span id="l3.14133" class="difflineminus">-nsImapMockChannel::SetContentLength(int64_t aContentLength)</span>
<a href="#l3.14134"></a><span id="l3.14134" class="difflineminus">-{</span>
<a href="#l3.14135"></a><span id="l3.14135" class="difflineminus">-    mContentLength = aContentLength;</span>
<a href="#l3.14136"></a><span id="l3.14136" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.14137"></a><span id="l3.14137" class="difflineminus">-}</span>
<a href="#l3.14138"></a><span id="l3.14138" class="difflineminus">-</span>
<a href="#l3.14139"></a><span id="l3.14139" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetOwner(nsISupports * *aPrincipal)</span>
<a href="#l3.14140"></a><span id="l3.14140" class="difflineminus">-{</span>
<a href="#l3.14141"></a><span id="l3.14141" class="difflineplus">+nsImapMockChannel::SetContentLength(int64_t aContentLength) {</span>
<a href="#l3.14142"></a><span id="l3.14142" class="difflineplus">+  mContentLength = aContentLength;</span>
<a href="#l3.14143"></a><span id="l3.14143" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.14144"></a><span id="l3.14144" class="difflineplus">+}</span>
<a href="#l3.14145"></a><span id="l3.14145" class="difflineplus">+</span>
<a href="#l3.14146"></a><span id="l3.14146" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetOwner(nsISupports **aPrincipal) {</span>
<a href="#l3.14147"></a><span id="l3.14147">   NS_IF_ADDREF(*aPrincipal = mOwner);</span>
<a href="#l3.14148"></a><span id="l3.14148">   return NS_OK;</span>
<a href="#l3.14149"></a><span id="l3.14149"> }</span>
<a href="#l3.14150"></a><span id="l3.14150"> </span>
<a href="#l3.14151"></a><span id="l3.14151" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetOwner(nsISupports * aPrincipal)</span>
<a href="#l3.14152"></a><span id="l3.14152" class="difflineminus">-{</span>
<a href="#l3.14153"></a><span id="l3.14153" class="difflineminus">-    mOwner = aPrincipal;</span>
<a href="#l3.14154"></a><span id="l3.14154" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.14155"></a><span id="l3.14155" class="difflineminus">-}</span>
<a href="#l3.14156"></a><span id="l3.14156" class="difflineminus">-</span>
<a href="#l3.14157"></a><span id="l3.14157" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetSecurityInfo(nsISupports * *aSecurityInfo)</span>
<a href="#l3.14158"></a><span id="l3.14158" class="difflineminus">-{</span>
<a href="#l3.14159"></a><span id="l3.14159" class="difflineminus">-    NS_IF_ADDREF(*aSecurityInfo = mSecurityInfo);</span>
<a href="#l3.14160"></a><span id="l3.14160" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.14161"></a><span id="l3.14161" class="difflineminus">-}</span>
<a href="#l3.14162"></a><span id="l3.14162" class="difflineminus">-</span>
<a href="#l3.14163"></a><span id="l3.14163" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetSecurityInfo(nsISupports *aSecurityInfo)</span>
<a href="#l3.14164"></a><span id="l3.14164" class="difflineminus">-{</span>
<a href="#l3.14165"></a><span id="l3.14165" class="difflineminus">-    mSecurityInfo = aSecurityInfo;</span>
<a href="#l3.14166"></a><span id="l3.14166" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.14167"></a><span id="l3.14167" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetOwner(nsISupports *aPrincipal) {</span>
<a href="#l3.14168"></a><span id="l3.14168" class="difflineplus">+  mOwner = aPrincipal;</span>
<a href="#l3.14169"></a><span id="l3.14169" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.14170"></a><span id="l3.14170" class="difflineplus">+}</span>
<a href="#l3.14171"></a><span id="l3.14171" class="difflineplus">+</span>
<a href="#l3.14172"></a><span id="l3.14172" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetSecurityInfo(nsISupports **aSecurityInfo) {</span>
<a href="#l3.14173"></a><span id="l3.14173" class="difflineplus">+  NS_IF_ADDREF(*aSecurityInfo = mSecurityInfo);</span>
<a href="#l3.14174"></a><span id="l3.14174" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.14175"></a><span id="l3.14175" class="difflineplus">+}</span>
<a href="#l3.14176"></a><span id="l3.14176" class="difflineplus">+</span>
<a href="#l3.14177"></a><span id="l3.14177" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetSecurityInfo(nsISupports *aSecurityInfo) {</span>
<a href="#l3.14178"></a><span id="l3.14178" class="difflineplus">+  mSecurityInfo = aSecurityInfo;</span>
<a href="#l3.14179"></a><span id="l3.14179" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.14180"></a><span id="l3.14180"> }</span>
<a href="#l3.14181"></a><span id="l3.14181"> </span>
<a href="#l3.14182"></a><span id="l3.14182"> NS_IMETHODIMP</span>
<a href="#l3.14183"></a><span id="l3.14183" class="difflineminus">-nsImapMockChannel::GetIsDocument(bool *aIsDocument)</span>
<a href="#l3.14184"></a><span id="l3.14184" class="difflineminus">-{</span>
<a href="#l3.14185"></a><span id="l3.14185" class="difflineplus">+nsImapMockChannel::GetIsDocument(bool *aIsDocument) {</span>
<a href="#l3.14186"></a><span id="l3.14186">   return NS_GetIsDocumentChannel(this, aIsDocument);</span>
<a href="#l3.14187"></a><span id="l3.14187"> }</span>
<a href="#l3.14188"></a><span id="l3.14188"> </span>
<a href="#l3.14189"></a><span id="l3.14189"> ////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.14190"></a><span id="l3.14190"> // From nsIRequest</span>
<a href="#l3.14191"></a><span id="l3.14191"> ////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l3.14192"></a><span id="l3.14192"> </span>
<a href="#l3.14193"></a><span id="l3.14193" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetName(nsACString &amp;result)</span>
<a href="#l3.14194"></a><span id="l3.14194" class="difflineminus">-{</span>
<a href="#l3.14195"></a><span id="l3.14195" class="difflineminus">-  if (m_url)</span>
<a href="#l3.14196"></a><span id="l3.14196" class="difflineminus">-    return m_url-&gt;GetSpec(result);</span>
<a href="#l3.14197"></a><span id="l3.14197" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetName(nsACString &amp;result) {</span>
<a href="#l3.14198"></a><span id="l3.14198" class="difflineplus">+  if (m_url) return m_url-&gt;GetSpec(result);</span>
<a href="#l3.14199"></a><span id="l3.14199">   result.Truncate();</span>
<a href="#l3.14200"></a><span id="l3.14200">   return NS_OK;</span>
<a href="#l3.14201"></a><span id="l3.14201"> }</span>
<a href="#l3.14202"></a><span id="l3.14202"> </span>
<a href="#l3.14203"></a><span id="l3.14203" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::IsPending(bool *result)</span>
<a href="#l3.14204"></a><span id="l3.14204" class="difflineminus">-{</span>
<a href="#l3.14205"></a><span id="l3.14205" class="difflineminus">-    *result = m_channelListener != nullptr;</span>
<a href="#l3.14206"></a><span id="l3.14206" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.14207"></a><span id="l3.14207" class="difflineminus">-}</span>
<a href="#l3.14208"></a><span id="l3.14208" class="difflineminus">-</span>
<a href="#l3.14209"></a><span id="l3.14209" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::GetStatus(nsresult *status)</span>
<a href="#l3.14210"></a><span id="l3.14210" class="difflineminus">-{</span>
<a href="#l3.14211"></a><span id="l3.14211" class="difflineminus">-    *status = m_cancelStatus;</span>
<a href="#l3.14212"></a><span id="l3.14212" class="difflineminus">-    return NS_OK;</span>
<a href="#l3.14213"></a><span id="l3.14213" class="difflineminus">-}</span>
<a href="#l3.14214"></a><span id="l3.14214" class="difflineminus">-</span>
<a href="#l3.14215"></a><span id="l3.14215" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::SetImapProtocol(nsIImapProtocol *aProtocol)</span>
<a href="#l3.14216"></a><span id="l3.14216" class="difflineminus">-{</span>
<a href="#l3.14217"></a><span id="l3.14217" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::IsPending(bool *result) {</span>
<a href="#l3.14218"></a><span id="l3.14218" class="difflineplus">+  *result = m_channelListener != nullptr;</span>
<a href="#l3.14219"></a><span id="l3.14219" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.14220"></a><span id="l3.14220" class="difflineplus">+}</span>
<a href="#l3.14221"></a><span id="l3.14221" class="difflineplus">+</span>
<a href="#l3.14222"></a><span id="l3.14222" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::GetStatus(nsresult *status) {</span>
<a href="#l3.14223"></a><span id="l3.14223" class="difflineplus">+  *status = m_cancelStatus;</span>
<a href="#l3.14224"></a><span id="l3.14224" class="difflineplus">+  return NS_OK;</span>
<a href="#l3.14225"></a><span id="l3.14225" class="difflineplus">+}</span>
<a href="#l3.14226"></a><span id="l3.14226" class="difflineplus">+</span>
<a href="#l3.14227"></a><span id="l3.14227" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::SetImapProtocol(nsIImapProtocol *aProtocol) {</span>
<a href="#l3.14228"></a><span id="l3.14228">   mProtocol = do_GetWeakReference(aProtocol);</span>
<a href="#l3.14229"></a><span id="l3.14229">   return NS_OK;</span>
<a href="#l3.14230"></a><span id="l3.14230"> }</span>
<a href="#l3.14231"></a><span id="l3.14231"> </span>
<a href="#l3.14232"></a><span id="l3.14232" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::Cancel(nsresult status)</span>
<a href="#l3.14233"></a><span id="l3.14233" class="difflineminus">-{</span>
<a href="#l3.14234"></a><span id="l3.14234" class="difflineminus">-  NS_WARNING_ASSERTION(NS_IsMainThread(),</span>
<a href="#l3.14235"></a><span id="l3.14235" class="difflineminus">-                       &quot;nsImapMockChannel::Cancel should only be called from UI thread&quot;);</span>
<a href="#l3.14236"></a><span id="l3.14236" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::Cancel(nsresult status) {</span>
<a href="#l3.14237"></a><span id="l3.14237" class="difflineplus">+  NS_WARNING_ASSERTION(</span>
<a href="#l3.14238"></a><span id="l3.14238" class="difflineplus">+      NS_IsMainThread(),</span>
<a href="#l3.14239"></a><span id="l3.14239" class="difflineplus">+      &quot;nsImapMockChannel::Cancel should only be called from UI thread&quot;);</span>
<a href="#l3.14240"></a><span id="l3.14240">   m_cancelStatus = status;</span>
<a href="#l3.14241"></a><span id="l3.14241">   nsCOMPtr&lt;nsIImapProtocol&gt; imapProtocol = do_QueryReferent(mProtocol);</span>
<a href="#l3.14242"></a><span id="l3.14242"> </span>
<a href="#l3.14243"></a><span id="l3.14243" class="difflineminus">-  // if we aren't reading from the cache and we get canceled...doom our cache entry...</span>
<a href="#l3.14244"></a><span id="l3.14244" class="difflineminus">-  if (m_url)</span>
<a href="#l3.14245"></a><span id="l3.14245" class="difflineminus">-  {</span>
<a href="#l3.14246"></a><span id="l3.14246" class="difflineplus">+  // if we aren't reading from the cache and we get canceled...doom our cache</span>
<a href="#l3.14247"></a><span id="l3.14247" class="difflineplus">+  // entry...</span>
<a href="#l3.14248"></a><span id="l3.14248" class="difflineplus">+  if (m_url) {</span>
<a href="#l3.14249"></a><span id="l3.14249">     nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url);</span>
<a href="#l3.14250"></a><span id="l3.14250">     MOZ_LOG(IMAPCache, LogLevel::Debug, (&quot;Cancel(): Calling DoomCacheEntry()&quot;));</span>
<a href="#l3.14251"></a><span id="l3.14251">     DoomCacheEntry(mailnewsUrl);</span>
<a href="#l3.14252"></a><span id="l3.14252">   }</span>
<a href="#l3.14253"></a><span id="l3.14253"> </span>
<a href="#l3.14254"></a><span id="l3.14254">   // Required for killing ImapProtocol thread</span>
<a href="#l3.14255"></a><span id="l3.14255" class="difflineminus">-  if (imapProtocol)</span>
<a href="#l3.14256"></a><span id="l3.14256" class="difflineminus">-    imapProtocol-&gt;TellThreadToDie(false);</span>
<a href="#l3.14257"></a><span id="l3.14257" class="difflineplus">+  if (imapProtocol) imapProtocol-&gt;TellThreadToDie(false);</span>
<a href="#l3.14258"></a><span id="l3.14258"> </span>
<a href="#l3.14259"></a><span id="l3.14259">   return NS_OK;</span>
<a href="#l3.14260"></a><span id="l3.14260"> }</span>
<a href="#l3.14261"></a><span id="l3.14261"> </span>
<a href="#l3.14262"></a><span id="l3.14262" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::Suspend()</span>
<a href="#l3.14263"></a><span id="l3.14263" class="difflineminus">-{</span>
<a href="#l3.14264"></a><span id="l3.14264" class="difflineminus">-    MOZ_ASSERT_UNREACHABLE(&quot;nsImapMockChannel::Suspend&quot;);</span>
<a href="#l3.14265"></a><span id="l3.14265" class="difflineminus">-    return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l3.14266"></a><span id="l3.14266" class="difflineminus">-}</span>
<a href="#l3.14267"></a><span id="l3.14267" class="difflineminus">-</span>
<a href="#l3.14268"></a><span id="l3.14268" class="difflineminus">-NS_IMETHODIMP nsImapMockChannel::Resume()</span>
<a href="#l3.14269"></a><span id="l3.14269" class="difflineminus">-{</span>
<a href="#l3.14270"></a><span id="l3.14270" class="difflineminus">-    MOZ_ASSERT_UNREACHABLE(&quot;nsImapMockChannel::Resume&quot;);</span>
<a href="#l3.14271"></a><span id="l3.14271" class="difflineminus">-    return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l3.14272"></a><span id="l3.14272" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::Suspend() {</span>
<a href="#l3.14273"></a><span id="l3.14273" class="difflineplus">+  MOZ_ASSERT_UNREACHABLE(&quot;nsImapMockChannel::Suspend&quot;);</span>
<a href="#l3.14274"></a><span id="l3.14274" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l3.14275"></a><span id="l3.14275" class="difflineplus">+}</span>
<a href="#l3.14276"></a><span id="l3.14276" class="difflineplus">+</span>
<a href="#l3.14277"></a><span id="l3.14277" class="difflineplus">+NS_IMETHODIMP nsImapMockChannel::Resume() {</span>
<a href="#l3.14278"></a><span id="l3.14278" class="difflineplus">+  MOZ_ASSERT_UNREACHABLE(&quot;nsImapMockChannel::Resume&quot;);</span>
<a href="#l3.14279"></a><span id="l3.14279" class="difflineplus">+  return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l3.14280"></a><span id="l3.14280"> }</span>
<a href="#l3.14281"></a><span id="l3.14281"> </span>
<a href="#l3.14282"></a><span id="l3.14282"> NS_IMETHODIMP</span>
<a href="#l3.14283"></a><span id="l3.14283" class="difflineminus">-nsImapMockChannel::GetNotificationCallbacks(nsIInterfaceRequestor* *aNotificationCallbacks)</span>
<a href="#l3.14284"></a><span id="l3.14284" class="difflineminus">-{</span>
<a href="#l3.14285"></a><span id="l3.14285" class="difflineplus">+nsImapMockChannel::GetNotificationCallbacks(</span>
<a href="#l3.14286"></a><span id="l3.14286" class="difflineplus">+    nsIInterfaceRequestor **aNotificationCallbacks) {</span>
<a href="#l3.14287"></a><span id="l3.14287">   NS_IF_ADDREF(*aNotificationCallbacks = mCallbacks.get());</span>
<a href="#l3.14288"></a><span id="l3.14288">   return NS_OK;</span>
<a href="#l3.14289"></a><span id="l3.14289"> }</span>
<a href="#l3.14290"></a><span id="l3.14290"> </span>
<a href="#l3.14291"></a><span id="l3.14291"> NS_IMETHODIMP</span>
<a href="#l3.14292"></a><span id="l3.14292" class="difflineminus">-nsImapMockChannel::SetNotificationCallbacks(nsIInterfaceRequestor* aNotificationCallbacks)</span>
<a href="#l3.14293"></a><span id="l3.14293" class="difflineminus">-{</span>
<a href="#l3.14294"></a><span id="l3.14294" class="difflineplus">+nsImapMockChannel::SetNotificationCallbacks(</span>
<a href="#l3.14295"></a><span id="l3.14295" class="difflineplus">+    nsIInterfaceRequestor *aNotificationCallbacks) {</span>
<a href="#l3.14296"></a><span id="l3.14296">   mCallbacks = aNotificationCallbacks;</span>
<a href="#l3.14297"></a><span id="l3.14297">   return NS_OK;</span>
<a href="#l3.14298"></a><span id="l3.14298"> }</span>
<a href="#l3.14299"></a><span id="l3.14299"> </span>
<a href="#l3.14300"></a><span id="l3.14300"> NS_IMETHODIMP</span>
<a href="#l3.14301"></a><span id="l3.14301"> nsImapMockChannel::OnTransportStatus(nsITransport *transport, nsresult status,</span>
<a href="#l3.14302"></a><span id="l3.14302" class="difflineminus">-                                     int64_t progress, int64_t progressMax)</span>
<a href="#l3.14303"></a><span id="l3.14303" class="difflineminus">-{</span>
<a href="#l3.14304"></a><span id="l3.14304" class="difflineplus">+                                     int64_t progress, int64_t progressMax) {</span>
<a href="#l3.14305"></a><span id="l3.14305">   if (NS_FAILED(m_cancelStatus) || (mLoadFlags &amp; LOAD_BACKGROUND) || !m_url)</span>
<a href="#l3.14306"></a><span id="l3.14306">     return NS_OK;</span>
<a href="#l3.14307"></a><span id="l3.14307"> </span>
<a href="#l3.14308"></a><span id="l3.14308">   // these transport events should not generate any status messages</span>
<a href="#l3.14309"></a><span id="l3.14309">   if (status == NS_NET_STATUS_RECEIVING_FROM ||</span>
<a href="#l3.14310"></a><span id="l3.14310">       status == NS_NET_STATUS_SENDING_TO)</span>
<a href="#l3.14311"></a><span id="l3.14311">     return NS_OK;</span>
<a href="#l3.14312"></a><span id="l3.14312"> </span>
<a href="#l3.14313"></a><span id="l3.14313" class="difflineminus">-  if (!mProgressEventSink)</span>
<a href="#l3.14314"></a><span id="l3.14314" class="difflineminus">-  {</span>
<a href="#l3.14315"></a><span id="l3.14315" class="difflineplus">+  if (!mProgressEventSink) {</span>
<a href="#l3.14316"></a><span id="l3.14316">     NS_QueryNotificationCallbacks(mCallbacks, m_loadGroup, mProgressEventSink);</span>
<a href="#l3.14317"></a><span id="l3.14317" class="difflineminus">-    if (!mProgressEventSink)</span>
<a href="#l3.14318"></a><span id="l3.14318" class="difflineminus">-      return NS_OK;</span>
<a href="#l3.14319"></a><span id="l3.14319" class="difflineplus">+    if (!mProgressEventSink) return NS_OK;</span>
<a href="#l3.14320"></a><span id="l3.14320">   }</span>
<a href="#l3.14321"></a><span id="l3.14321"> </span>
<a href="#l3.14322"></a><span id="l3.14322">   nsAutoCString host;</span>
<a href="#l3.14323"></a><span id="l3.14323">   m_url-&gt;GetHost(host);</span>
<a href="#l3.14324"></a><span id="l3.14324"> </span>
<a href="#l3.14325"></a><span id="l3.14325">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsUrl = do_QueryInterface(m_url);</span>
<a href="#l3.14326"></a><span id="l3.14326" class="difflineminus">-  if (mailnewsUrl)</span>
<a href="#l3.14327"></a><span id="l3.14327" class="difflineminus">-  {</span>
<a href="#l3.14328"></a><span id="l3.14328" class="difflineplus">+  if (mailnewsUrl) {</span>
<a href="#l3.14329"></a><span id="l3.14329">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l3.14330"></a><span id="l3.14330">     mailnewsUrl-&gt;GetServer(getter_AddRefs(server));</span>
<a href="#l3.14331"></a><span id="l3.14331" class="difflineminus">-    if (server)</span>
<a href="#l3.14332"></a><span id="l3.14332" class="difflineminus">-      server-&gt;GetRealHostName(host);</span>
<a href="#l3.14333"></a><span id="l3.14333" class="difflineplus">+    if (server) server-&gt;GetRealHostName(host);</span>
<a href="#l3.14334"></a><span id="l3.14334">   }</span>
<a href="#l3.14335"></a><span id="l3.14335">   mProgressEventSink-&gt;OnStatus(this, nullptr, status,</span>
<a href="#l3.14336"></a><span id="l3.14336">                                NS_ConvertUTF8toUTF16(host).get());</span>
<a href="#l3.14337"></a><span id="l3.14337"> </span>
<a href="#l3.14338"></a><span id="l3.14338">   return NS_OK;</span>
<a href="#l3.14339"></a><span id="l3.14339"> }</span>
<a href="#l3.14340"></a><span id="l3.14340"> </span>
<a href="#l3.14341"></a><span id="l3.14341" class="difflineminus">-</span>
<a href="#l3.14342"></a><span id="l3.14342" class="difflineminus">-nsIMAPMailboxInfo::nsIMAPMailboxInfo(const nsACString &amp;aName, char aDelimiter)</span>
<a href="#l3.14343"></a><span id="l3.14343" class="difflineminus">-{</span>
<a href="#l3.14344"></a><span id="l3.14344" class="difflineplus">+nsIMAPMailboxInfo::nsIMAPMailboxInfo(const nsACString &amp;aName, char aDelimiter) {</span>
<a href="#l3.14345"></a><span id="l3.14345">   mMailboxName.Assign(aName);</span>
<a href="#l3.14346"></a><span id="l3.14346">   mDelimiter = aDelimiter;</span>
<a href="#l3.14347"></a><span id="l3.14347">   mChildrenListed = false;</span>
<a href="#l3.14348"></a><span id="l3.14348"> }</span>
<a href="#l3.14349"></a><span id="l3.14349"> </span>
<a href="#l3.14350"></a><span id="l3.14350" class="difflineminus">-nsIMAPMailboxInfo::~nsIMAPMailboxInfo()</span>
<a href="#l3.14351"></a><span id="l3.14351" class="difflineminus">-{</span>
<a href="#l3.14352"></a><span id="l3.14352" class="difflineminus">-}</span>
<a href="#l3.14353"></a><span id="l3.14353" class="difflineminus">-</span>
<a href="#l3.14354"></a><span id="l3.14354" class="difflineminus">-void nsIMAPMailboxInfo::SetChildrenListed(bool childrenListed)</span>
<a href="#l3.14355"></a><span id="l3.14355" class="difflineminus">-{</span>
<a href="#l3.14356"></a><span id="l3.14356" class="difflineplus">+nsIMAPMailboxInfo::~nsIMAPMailboxInfo() {}</span>
<a href="#l3.14357"></a><span id="l3.14357" class="difflineplus">+</span>
<a href="#l3.14358"></a><span id="l3.14358" class="difflineplus">+void nsIMAPMailboxInfo::SetChildrenListed(bool childrenListed) {</span>
<a href="#l3.14359"></a><span id="l3.14359">   mChildrenListed = childrenListed;</span>
<a href="#l3.14360"></a><span id="l3.14360"> }</span>
<a href="#l3.14361"></a><span id="l3.14361"> </span>
<a href="#l3.14362"></a><span id="l3.14362" class="difflineminus">-bool nsIMAPMailboxInfo::GetChildrenListed()</span>
<a href="#l3.14363"></a><span id="l3.14363" class="difflineminus">-{</span>
<a href="#l3.14364"></a><span id="l3.14364" class="difflineminus">-  return mChildrenListed;</span>
<a href="#l3.14365"></a><span id="l3.14365" class="difflineminus">-}</span>
<a href="#l3.14366"></a><span id="l3.14366" class="difflineminus">-</span>
<a href="#l3.14367"></a><span id="l3.14367" class="difflineminus">-const nsACString&amp; nsIMAPMailboxInfo::GetMailboxName()</span>
<a href="#l3.14368"></a><span id="l3.14368" class="difflineminus">-{</span>
<a href="#l3.14369"></a><span id="l3.14369" class="difflineminus">-  return mMailboxName;</span>
<a href="#l3.14370"></a><span id="l3.14370" class="difflineminus">-}</span>
<a href="#l3.14371"></a><span id="l3.14371" class="difflineminus">-</span>
<a href="#l3.14372"></a><span id="l3.14372" class="difflineminus">-char nsIMAPMailboxInfo::GetDelimiter()</span>
<a href="#l3.14373"></a><span id="l3.14373" class="difflineminus">-{</span>
<a href="#l3.14374"></a><span id="l3.14374" class="difflineminus">-  return mDelimiter;</span>
<a href="#l3.14375"></a><span id="l3.14375" class="difflineminus">-}</span>
<a href="#l3.14376"></a><span id="l3.14376" class="difflineplus">+bool nsIMAPMailboxInfo::GetChildrenListed() { return mChildrenListed; }</span>
<a href="#l3.14377"></a><span id="l3.14377" class="difflineplus">+</span>
<a href="#l3.14378"></a><span id="l3.14378" class="difflineplus">+const nsACString &amp;nsIMAPMailboxInfo::GetMailboxName() { return mMailboxName; }</span>
<a href="#l3.14379"></a><span id="l3.14379" class="difflineplus">+</span>
<a href="#l3.14380"></a><span id="l3.14380" class="difflineplus">+char nsIMAPMailboxInfo::GetDelimiter() { return mDelimiter; }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -24,17 +24,17 @@</span>
<a href="#l4.4"></a><span id="l4.4"> #include &quot;nsIImapProtocolSink.h&quot;</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6"> #include &quot;nsIIMAPHostSessionList.h&quot;</span>
<a href="#l4.7"></a><span id="l4.7"> #include &quot;nsImapServerResponseParser.h&quot;</span>
<a href="#l4.8"></a><span id="l4.8"> #include &quot;nsImapFlagAndUidState.h&quot;</span>
<a href="#l4.9"></a><span id="l4.9"> #include &quot;nsIMAPNamespace.h&quot;</span>
<a href="#l4.10"></a><span id="l4.10"> #include &quot;nsTArray.h&quot;</span>
<a href="#l4.11"></a><span id="l4.11"> #include &quot;nsIWeakReferenceUtils.h&quot;</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-#include &quot;nsMsgLineBuffer.h&quot; // we need this to use the nsMsgLineStreamBuffer helper class...</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+#include &quot;nsMsgLineBuffer.h&quot;  // we need this to use the nsMsgLineStreamBuffer helper class...</span>
<a href="#l4.14"></a><span id="l4.14"> #include &quot;nsIInputStream.h&quot;</span>
<a href="#l4.15"></a><span id="l4.15"> #include &quot;nsIMsgIncomingServer.h&quot;</span>
<a href="#l4.16"></a><span id="l4.16"> #include &quot;nsCOMArray.h&quot;</span>
<a href="#l4.17"></a><span id="l4.17"> #include &quot;nsIThread.h&quot;</span>
<a href="#l4.18"></a><span id="l4.18"> #include &quot;nsIRunnable.h&quot;</span>
<a href="#l4.19"></a><span id="l4.19"> #include &quot;nsIImapMockChannel.h&quot;</span>
<a href="#l4.20"></a><span id="l4.20"> #include &quot;nsILoadGroup.h&quot;</span>
<a href="#l4.21"></a><span id="l4.21"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -49,130 +49,130 @@</span>
<a href="#l4.23"></a><span id="l4.23"> #include &quot;nsSyncRunnableHelpers.h&quot;</span>
<a href="#l4.24"></a><span id="l4.24"> #include &quot;nsICacheEntryOpenCallback.h&quot;</span>
<a href="#l4.25"></a><span id="l4.25"> #include &quot;nsIProtocolProxyCallback.h&quot;</span>
<a href="#l4.26"></a><span id="l4.26"> #include &quot;nsIStringBundle.h&quot;</span>
<a href="#l4.27"></a><span id="l4.27"> </span>
<a href="#l4.28"></a><span id="l4.28"> class nsIMAPMessagePartIDArray;</span>
<a href="#l4.29"></a><span id="l4.29"> class nsIPrefBranch;</span>
<a href="#l4.30"></a><span id="l4.30"> </span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-#define kDownLoadCacheSize 16000u // was 1536 - try making it bigger</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineminus">-</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+#define kDownLoadCacheSize 16000u  // was 1536 - try making it bigger</span>
<a href="#l4.34"></a><span id="l4.34"> </span>
<a href="#l4.35"></a><span id="l4.35"> typedef struct _msg_line_info {</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineminus">-    const char   *adoptedMessageLine;</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineminus">-    uint32_t uidOfMessage;</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+  const char *adoptedMessageLine;</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+  uint32_t uidOfMessage;</span>
<a href="#l4.40"></a><span id="l4.40"> } msg_line_info;</span>
<a href="#l4.41"></a><span id="l4.41"> </span>
<a href="#l4.42"></a><span id="l4.42" class="difflineminus">-</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineminus">-class nsMsgImapLineDownloadCache : public nsIImapHeaderInfo, public nsByteArray</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineminus">-{</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineminus">-public:</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+class nsMsgImapLineDownloadCache : public nsIImapHeaderInfo,</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+                                   public nsByteArray {</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+ public:</span>
<a href="#l4.49"></a><span id="l4.49">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l4.50"></a><span id="l4.50">   NS_DECL_NSIIMAPHEADERINFO</span>
<a href="#l4.51"></a><span id="l4.51">   nsMsgImapLineDownloadCache();</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineminus">-    uint32_t  CurrentUID();</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineminus">-    uint32_t  SpaceAvailable();</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineminus">-    bool CacheEmpty();</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+  uint32_t CurrentUID();</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+  uint32_t SpaceAvailable();</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+  bool CacheEmpty();</span>
<a href="#l4.58"></a><span id="l4.58"> </span>
<a href="#l4.59"></a><span id="l4.59" class="difflineminus">-    msg_line_info *GetCurrentLineInfo();</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineplus">+  msg_line_info *GetCurrentLineInfo();</span>
<a href="#l4.61"></a><span id="l4.61"> </span>
<a href="#l4.62"></a><span id="l4.62" class="difflineminus">-private:</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineplus">+ private:</span>
<a href="#l4.64"></a><span id="l4.64">   virtual ~nsMsgImapLineDownloadCache();</span>
<a href="#l4.65"></a><span id="l4.65"> </span>
<a href="#l4.66"></a><span id="l4.66" class="difflineminus">-    msg_line_info *fLineInfo;</span>
<a href="#l4.67"></a><span id="l4.67" class="difflineminus">-    int32_t m_msgSize;</span>
<a href="#l4.68"></a><span id="l4.68" class="difflineplus">+  msg_line_info *fLineInfo;</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+  int32_t m_msgSize;</span>
<a href="#l4.70"></a><span id="l4.70"> };</span>
<a href="#l4.71"></a><span id="l4.71"> </span>
<a href="#l4.72"></a><span id="l4.72"> #define kNumHdrsToXfer 10</span>
<a href="#l4.73"></a><span id="l4.73"> </span>
<a href="#l4.74"></a><span id="l4.74" class="difflineminus">-class nsMsgImapHdrXferInfo : public nsIImapHeaderXferInfo</span>
<a href="#l4.75"></a><span id="l4.75" class="difflineminus">-{</span>
<a href="#l4.76"></a><span id="l4.76" class="difflineminus">-public:</span>
<a href="#l4.77"></a><span id="l4.77" class="difflineplus">+class nsMsgImapHdrXferInfo : public nsIImapHeaderXferInfo {</span>
<a href="#l4.78"></a><span id="l4.78" class="difflineplus">+ public:</span>
<a href="#l4.79"></a><span id="l4.79">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l4.80"></a><span id="l4.80">   NS_DECL_NSIIMAPHEADERXFERINFO</span>
<a href="#l4.81"></a><span id="l4.81">   nsMsgImapHdrXferInfo();</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineminus">-  void    ResetAll(); // reset HeaderInfos for re-use</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineminus">-  void    ReleaseAll(); // release HeaderInfos (frees up memory)</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+  void ResetAll();    // reset HeaderInfos for re-use</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+  void ReleaseAll();  // release HeaderInfos (frees up memory)</span>
<a href="#l4.86"></a><span id="l4.86">   // this will return null if we're full, in which case the client code</span>
<a href="#l4.87"></a><span id="l4.87">   // should transfer the headers and retry.</span>
<a href="#l4.88"></a><span id="l4.88">   nsIImapHeaderInfo *StartNewHdr();</span>
<a href="#l4.89"></a><span id="l4.89">   // call when we've finished adding lines to current hdr</span>
<a href="#l4.90"></a><span id="l4.90" class="difflineminus">-  void    FinishCurrentHdr();</span>
<a href="#l4.91"></a><span id="l4.91" class="difflineminus">-private:</span>
<a href="#l4.92"></a><span id="l4.92" class="difflineplus">+  void FinishCurrentHdr();</span>
<a href="#l4.93"></a><span id="l4.93" class="difflineplus">+</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineplus">+ private:</span>
<a href="#l4.95"></a><span id="l4.95">   virtual ~nsMsgImapHdrXferInfo();</span>
<a href="#l4.96"></a><span id="l4.96">   nsCOMArray&lt;nsIImapHeaderInfo&gt; m_hdrInfos;</span>
<a href="#l4.97"></a><span id="l4.97" class="difflineminus">-  int32_t   m_nextFreeHdrInfo;</span>
<a href="#l4.98"></a><span id="l4.98" class="difflineplus">+  int32_t m_nextFreeHdrInfo;</span>
<a href="#l4.99"></a><span id="l4.99"> };</span>
<a href="#l4.100"></a><span id="l4.100"> </span>
<a href="#l4.101"></a><span id="l4.101"> // This class contains the name of a mailbox and whether or not</span>
<a href="#l4.102"></a><span id="l4.102"> // its children have been listed.</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineminus">-class nsIMAPMailboxInfo</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineminus">-{</span>
<a href="#l4.105"></a><span id="l4.105" class="difflineminus">-public:</span>
<a href="#l4.106"></a><span id="l4.106" class="difflineplus">+class nsIMAPMailboxInfo {</span>
<a href="#l4.107"></a><span id="l4.107" class="difflineplus">+ public:</span>
<a href="#l4.108"></a><span id="l4.108">   nsIMAPMailboxInfo(const nsACString &amp;aName, char aDelimiter);</span>
<a href="#l4.109"></a><span id="l4.109">   virtual ~nsIMAPMailboxInfo();</span>
<a href="#l4.110"></a><span id="l4.110"> </span>
<a href="#l4.111"></a><span id="l4.111" class="difflineminus">-  void   SetChildrenListed(bool childrenListed);</span>
<a href="#l4.112"></a><span id="l4.112" class="difflineminus">-  bool   GetChildrenListed();</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineminus">-  const  nsACString&amp; GetMailboxName();</span>
<a href="#l4.114"></a><span id="l4.114" class="difflineminus">-  char   GetDelimiter();</span>
<a href="#l4.115"></a><span id="l4.115" class="difflineplus">+  void SetChildrenListed(bool childrenListed);</span>
<a href="#l4.116"></a><span id="l4.116" class="difflineplus">+  bool GetChildrenListed();</span>
<a href="#l4.117"></a><span id="l4.117" class="difflineplus">+  const nsACString &amp;GetMailboxName();</span>
<a href="#l4.118"></a><span id="l4.118" class="difflineplus">+  char GetDelimiter();</span>
<a href="#l4.119"></a><span id="l4.119"> </span>
<a href="#l4.120"></a><span id="l4.120" class="difflineminus">-protected:</span>
<a href="#l4.121"></a><span id="l4.121" class="difflineplus">+ protected:</span>
<a href="#l4.122"></a><span id="l4.122">   nsCString mMailboxName;</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineminus">-  bool     mChildrenListed;</span>
<a href="#l4.124"></a><span id="l4.124" class="difflineminus">-  char     mDelimiter;</span>
<a href="#l4.125"></a><span id="l4.125" class="difflineplus">+  bool mChildrenListed;</span>
<a href="#l4.126"></a><span id="l4.126" class="difflineplus">+  char mDelimiter;</span>
<a href="#l4.127"></a><span id="l4.127"> };</span>
<a href="#l4.128"></a><span id="l4.128"> </span>
<a href="#l4.129"></a><span id="l4.129"> // State Flags (Note, I use the word state in terms of storing</span>
<a href="#l4.130"></a><span id="l4.130"> // state information about the connection (authentication, have we sent</span>
<a href="#l4.131"></a><span id="l4.131"> // commands, etc. I do not intend it to refer to protocol state)</span>
<a href="#l4.132"></a><span id="l4.132"> // Use these flags in conjunction with SetFlag/TestFlag/ClearFlag instead</span>
<a href="#l4.133"></a><span id="l4.133"> // of creating PRBools for everything....</span>
<a href="#l4.134"></a><span id="l4.134" class="difflineminus">-</span>
<a href="#l4.135"></a><span id="l4.135" class="difflineminus">-#define IMAP_RECEIVED_GREETING        0x00000001  /* should we pause for the next read */</span>
<a href="#l4.136"></a><span id="l4.136" class="difflineminus">-#define  IMAP_CONNECTION_IS_OPEN        0x00000004  /* is the connection currently open? */</span>
<a href="#l4.137"></a><span id="l4.137" class="difflineplus">+// clang-format off</span>
<a href="#l4.138"></a><span id="l4.138" class="difflineplus">+#define IMAP_RECEIVED_GREETING        0x00000001  // should we pause for the next read</span>
<a href="#l4.139"></a><span id="l4.139" class="difflineplus">+#define  IMAP_CONNECTION_IS_OPEN      0x00000004  // is the connection currently open?</span>
<a href="#l4.140"></a><span id="l4.140"> #define IMAP_WAITING_FOR_DATA         0x00000008</span>
<a href="#l4.141"></a><span id="l4.141" class="difflineminus">-#define IMAP_CLEAN_UP_URL_STATE       0x00000010 // processing clean up url state</span>
<a href="#l4.142"></a><span id="l4.142" class="difflineminus">-#define IMAP_ISSUED_LANGUAGE_REQUEST  0x00000020 // make sure we only issue the language request once per connection...</span>
<a href="#l4.143"></a><span id="l4.143" class="difflineminus">-#define IMAP_ISSUED_COMPRESS_REQUEST  0x00000040 // make sure we only request compression once</span>
<a href="#l4.144"></a><span id="l4.144" class="difflineplus">+#define IMAP_CLEAN_UP_URL_STATE       0x00000010  // processing clean up url state</span>
<a href="#l4.145"></a><span id="l4.145" class="difflineplus">+#define IMAP_ISSUED_LANGUAGE_REQUEST  0x00000020  // make sure we only issue the language</span>
<a href="#l4.146"></a><span id="l4.146" class="difflineplus">+                                                  // request once per connection...</span>
<a href="#l4.147"></a><span id="l4.147" class="difflineplus">+#define IMAP_ISSUED_COMPRESS_REQUEST  0x00000040  // make sure we only request compression once</span>
<a href="#l4.148"></a><span id="l4.148"> </span>
<a href="#l4.149"></a><span id="l4.149"> // There are 3 types of progress strings for items downloaded from IMAP servers.</span>
<a href="#l4.150"></a><span id="l4.150"> // An index is needed to keep track of the current count of the number of each</span>
<a href="#l4.151"></a><span id="l4.151"> // item type downloaded. The IMAP_EMPTY_STRING_INDEX means no string displayed.</span>
<a href="#l4.152"></a><span id="l4.152"> #define IMAP_NUMBER_OF_PROGRESS_STRINGS 4</span>
<a href="#l4.153"></a><span id="l4.153"> #define IMAP_HEADERS_STRING_INDEX       0</span>
<a href="#l4.154"></a><span id="l4.154"> #define IMAP_FLAGS_STRING_INDEX         1</span>
<a href="#l4.155"></a><span id="l4.155"> #define IMAP_MESSAGES_STRING_INDEX      2</span>
<a href="#l4.156"></a><span id="l4.156"> #define IMAP_EMPTY_STRING_INDEX         3</span>
<a href="#l4.157"></a><span id="l4.157" class="difflineplus">+// clang-format on</span>
<a href="#l4.158"></a><span id="l4.158"> </span>
<a href="#l4.159"></a><span id="l4.159"> class nsImapProtocol : public nsIImapProtocol,</span>
<a href="#l4.160"></a><span id="l4.160">                        public nsIRunnable,</span>
<a href="#l4.161"></a><span id="l4.161">                        public nsIInputStreamCallback,</span>
<a href="#l4.162"></a><span id="l4.162">                        public nsSupportsWeakReference,</span>
<a href="#l4.163"></a><span id="l4.163">                        public nsMsgProtocol,</span>
<a href="#l4.164"></a><span id="l4.164">                        public nsIImapProtocolSink,</span>
<a href="#l4.165"></a><span id="l4.165">                        public nsIMsgAsyncPromptListener,</span>
<a href="#l4.166"></a><span id="l4.166" class="difflineminus">-                       public nsIProtocolProxyCallback</span>
<a href="#l4.167"></a><span id="l4.167" class="difflineminus">-{</span>
<a href="#l4.168"></a><span id="l4.168" class="difflineminus">-public:</span>
<a href="#l4.169"></a><span id="l4.169" class="difflineplus">+                       public nsIProtocolProxyCallback {</span>
<a href="#l4.170"></a><span id="l4.170" class="difflineplus">+ public:</span>
<a href="#l4.171"></a><span id="l4.171">   struct TCPKeepalive {</span>
<a href="#l4.172"></a><span id="l4.172">     // For enabling and setting TCP keepalive (not related to IMAP IDLE).</span>
<a href="#l4.173"></a><span id="l4.173">     std::atomic&lt;bool&gt; enabled;</span>
<a href="#l4.174"></a><span id="l4.174">     std::atomic&lt;int32_t&gt; idleTimeS;</span>
<a href="#l4.175"></a><span id="l4.175">     std::atomic&lt;int32_t&gt; retryIntervalS;</span>
<a href="#l4.176"></a><span id="l4.176">   };</span>
<a href="#l4.177"></a><span id="l4.177"> </span>
<a href="#l4.178"></a><span id="l4.178">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l4.179"></a><span id="l4.179">   NS_DECL_NSIINPUTSTREAMCALLBACK</span>
<a href="#l4.180"></a><span id="l4.180">   NS_DECL_NSIPROTOCOLPROXYCALLBACK</span>
<a href="#l4.181"></a><span id="l4.181">   nsImapProtocol();</span>
<a href="#l4.182"></a><span id="l4.182"> </span>
<a href="#l4.183"></a><span id="l4.183" class="difflineminus">-  virtual nsresult ProcessProtocolState(nsIURI * url, nsIInputStream * inputStream,</span>
<a href="#l4.184"></a><span id="l4.184" class="difflineminus">-                                        uint64_t sourceOffset, uint32_t length) override;</span>
<a href="#l4.185"></a><span id="l4.185" class="difflineplus">+  virtual nsresult ProcessProtocolState(nsIURI *url,</span>
<a href="#l4.186"></a><span id="l4.186" class="difflineplus">+                                        nsIInputStream *inputStream,</span>
<a href="#l4.187"></a><span id="l4.187" class="difflineplus">+                                        uint64_t sourceOffset,</span>
<a href="#l4.188"></a><span id="l4.188" class="difflineplus">+                                        uint32_t length) override;</span>
<a href="#l4.189"></a><span id="l4.189"> </span>
<a href="#l4.190"></a><span id="l4.190">   // nsIRunnable method</span>
<a href="#l4.191"></a><span id="l4.191">   NS_IMETHOD Run() override;</span>
<a href="#l4.192"></a><span id="l4.192"> </span>
<a href="#l4.193"></a><span id="l4.193">   //////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.194"></a><span id="l4.194">   // we support the nsIImapProtocol interface</span>
<a href="#l4.195"></a><span id="l4.195">   //////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.196"></a><span id="l4.196">   NS_DECL_NSIIMAPPROTOCOL</span>
<a href="#l4.197"></a><span id="l4.197" class="difflineat">@@ -180,592 +180,629 @@ public:</span>
<a href="#l4.198"></a><span id="l4.198">   //////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.199"></a><span id="l4.199">   // we support the nsIImapProtocolSink interface</span>
<a href="#l4.200"></a><span id="l4.200">   //////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.201"></a><span id="l4.201">   NS_DECL_NSIIMAPPROTOCOLSINK</span>
<a href="#l4.202"></a><span id="l4.202"> </span>
<a href="#l4.203"></a><span id="l4.203">   NS_DECL_NSIMSGASYNCPROMPTLISTENER</span>
<a href="#l4.204"></a><span id="l4.204"> </span>
<a href="#l4.205"></a><span id="l4.205">   // message id string utilities.</span>
<a href="#l4.206"></a><span id="l4.206" class="difflineminus">-  uint32_t    CountMessagesInIdString(const char *idString);</span>
<a href="#l4.207"></a><span id="l4.207" class="difflineminus">-  static  bool    HandlingMultipleMessages(const nsCString &amp;messageIdString);</span>
<a href="#l4.208"></a><span id="l4.208" class="difflineplus">+  uint32_t CountMessagesInIdString(const char *idString);</span>
<a href="#l4.209"></a><span id="l4.209" class="difflineplus">+  static bool HandlingMultipleMessages(const nsCString &amp;messageIdString);</span>
<a href="#l4.210"></a><span id="l4.210">   // escape slashes and double quotes in username/passwords for insecure login.</span>
<a href="#l4.211"></a><span id="l4.211" class="difflineminus">-  static void EscapeUserNamePasswordString(const char *strToEscape, nsCString *resultStr);</span>
<a href="#l4.212"></a><span id="l4.212" class="difflineplus">+  static void EscapeUserNamePasswordString(const char *strToEscape,</span>
<a href="#l4.213"></a><span id="l4.213" class="difflineplus">+                                           nsCString *resultStr);</span>
<a href="#l4.214"></a><span id="l4.214"> </span>
<a href="#l4.215"></a><span id="l4.215">   // used to start fetching a message.</span>
<a href="#l4.216"></a><span id="l4.216">   void GetShouldDownloadAllHeaders(bool *aResult);</span>
<a href="#l4.217"></a><span id="l4.217">   void GetArbitraryHeadersToDownload(nsCString &amp;aResult);</span>
<a href="#l4.218"></a><span id="l4.218">   virtual void AdjustChunkSize();</span>
<a href="#l4.219"></a><span id="l4.219">   virtual void FetchMessage(const nsCString &amp;messageIds,</span>
<a href="#l4.220"></a><span id="l4.220" class="difflineminus">-    nsIMAPeFetchFields whatToFetch,</span>
<a href="#l4.221"></a><span id="l4.221" class="difflineminus">-    const char *fetchModifier = nullptr,</span>
<a href="#l4.222"></a><span id="l4.222" class="difflineminus">-    uint32_t startByte = 0, uint32_t numBytes = 0,</span>
<a href="#l4.223"></a><span id="l4.223" class="difflineminus">-    char *part = 0);</span>
<a href="#l4.224"></a><span id="l4.224" class="difflineplus">+                            nsIMAPeFetchFields whatToFetch,</span>
<a href="#l4.225"></a><span id="l4.225" class="difflineplus">+                            const char *fetchModifier = nullptr,</span>
<a href="#l4.226"></a><span id="l4.226" class="difflineplus">+                            uint32_t startByte = 0, uint32_t numBytes = 0,</span>
<a href="#l4.227"></a><span id="l4.227" class="difflineplus">+                            char *part = 0);</span>
<a href="#l4.228"></a><span id="l4.228">   void FetchTryChunking(const nsCString &amp;messageIds,</span>
<a href="#l4.229"></a><span id="l4.229" class="difflineminus">-    nsIMAPeFetchFields whatToFetch,</span>
<a href="#l4.230"></a><span id="l4.230" class="difflineminus">-    bool idIsUid,</span>
<a href="#l4.231"></a><span id="l4.231" class="difflineminus">-    char *part,</span>
<a href="#l4.232"></a><span id="l4.232" class="difflineminus">-    uint32_t downloadSize,</span>
<a href="#l4.233"></a><span id="l4.233" class="difflineminus">-    bool tryChunking);</span>
<a href="#l4.234"></a><span id="l4.234" class="difflineminus">-  virtual void PipelinedFetchMessageParts(nsCString &amp;uid, nsIMAPMessagePartIDArray *parts);</span>
<a href="#l4.235"></a><span id="l4.235" class="difflineminus">-  void FallbackToFetchWholeMsg(const nsCString &amp;messageId, uint32_t messageSize);</span>
<a href="#l4.236"></a><span id="l4.236" class="difflineplus">+                        nsIMAPeFetchFields whatToFetch, bool idIsUid,</span>
<a href="#l4.237"></a><span id="l4.237" class="difflineplus">+                        char *part, uint32_t downloadSize, bool tryChunking);</span>
<a href="#l4.238"></a><span id="l4.238" class="difflineplus">+  virtual void PipelinedFetchMessageParts(nsCString &amp;uid,</span>
<a href="#l4.239"></a><span id="l4.239" class="difflineplus">+                                          nsIMAPMessagePartIDArray *parts);</span>
<a href="#l4.240"></a><span id="l4.240" class="difflineplus">+  void FallbackToFetchWholeMsg(const nsCString &amp;messageId,</span>
<a href="#l4.241"></a><span id="l4.241" class="difflineplus">+                               uint32_t messageSize);</span>
<a href="#l4.242"></a><span id="l4.242">   // used when streaming a message fetch</span>
<a href="#l4.243"></a><span id="l4.243" class="difflineminus">-  virtual nsresult BeginMessageDownLoad(uint32_t totalSize, // for user, headers and body</span>
<a href="#l4.244"></a><span id="l4.244" class="difflineminus">-    const char *contentType);     // some downloads are header only</span>
<a href="#l4.245"></a><span id="l4.245" class="difflineminus">-  virtual void HandleMessageDownLoadLine(const char *line, bool isPartialLine, char *lineCopy=nullptr);</span>
<a href="#l4.246"></a><span id="l4.246" class="difflineplus">+  virtual nsresult BeginMessageDownLoad(</span>
<a href="#l4.247"></a><span id="l4.247" class="difflineplus">+      uint32_t totalSize,        // for user, headers and body</span>
<a href="#l4.248"></a><span id="l4.248" class="difflineplus">+      const char *contentType);  // some downloads are header only</span>
<a href="#l4.249"></a><span id="l4.249" class="difflineplus">+  virtual void HandleMessageDownLoadLine(const char *line, bool isPartialLine,</span>
<a href="#l4.250"></a><span id="l4.250" class="difflineplus">+                                         char *lineCopy = nullptr);</span>
<a href="#l4.251"></a><span id="l4.251">   virtual void NormalMessageEndDownload();</span>
<a href="#l4.252"></a><span id="l4.252">   virtual void AbortMessageDownLoad();</span>
<a href="#l4.253"></a><span id="l4.253">   virtual void PostLineDownLoadEvent(const char *line, uint32_t uid);</span>
<a href="#l4.254"></a><span id="l4.254">   void FlushDownloadCache();</span>
<a href="#l4.255"></a><span id="l4.255"> </span>
<a href="#l4.256"></a><span id="l4.256">   virtual void SetMailboxDiscoveryStatus(EMailboxDiscoverStatus status);</span>
<a href="#l4.257"></a><span id="l4.257">   virtual EMailboxDiscoverStatus GetMailboxDiscoveryStatus();</span>
<a href="#l4.258"></a><span id="l4.258"> </span>
<a href="#l4.259"></a><span id="l4.259">   virtual void ProcessMailboxUpdate(bool handlePossibleUndo);</span>
<a href="#l4.260"></a><span id="l4.260">   // Send log output...</span>
<a href="#l4.261"></a><span id="l4.261" class="difflineminus">-  void  Log(const char *logSubName, const char *extraInfo, const char *logData);</span>
<a href="#l4.262"></a><span id="l4.262" class="difflineplus">+  void Log(const char *logSubName, const char *extraInfo, const char *logData);</span>
<a href="#l4.263"></a><span id="l4.263">   static void LogImapUrl(const char *logMsg, nsIImapUrl *imapUrl);</span>
<a href="#l4.264"></a><span id="l4.264" class="difflineminus">-  // Comment from 4.5: We really need to break out the thread synchronizer from the</span>
<a href="#l4.265"></a><span id="l4.265" class="difflineminus">-  // connection class...Not sure what this means</span>
<a href="#l4.266"></a><span id="l4.266" class="difflineminus">-  bool    GetPseudoInterrupted();</span>
<a href="#l4.267"></a><span id="l4.267" class="difflineminus">-  void  PseudoInterrupt(bool the_interrupt);</span>
<a href="#l4.268"></a><span id="l4.268" class="difflineplus">+  // Comment from 4.5: We really need to break out the thread synchronizer from</span>
<a href="#l4.269"></a><span id="l4.269" class="difflineplus">+  // the connection class...Not sure what this means</span>
<a href="#l4.270"></a><span id="l4.270" class="difflineplus">+  bool GetPseudoInterrupted();</span>
<a href="#l4.271"></a><span id="l4.271" class="difflineplus">+  void PseudoInterrupt(bool the_interrupt);</span>
<a href="#l4.272"></a><span id="l4.272"> </span>
<a href="#l4.273"></a><span id="l4.273" class="difflineminus">-  uint32_t GetMessageSize(const char * messageId, bool idsAreUids);</span>
<a href="#l4.274"></a><span id="l4.274" class="difflineplus">+  uint32_t GetMessageSize(const char *messageId, bool idsAreUids);</span>
<a href="#l4.275"></a><span id="l4.275">   bool GetSubscribingNow();</span>
<a href="#l4.276"></a><span id="l4.276"> </span>
<a href="#l4.277"></a><span id="l4.277" class="difflineminus">-  bool    DeathSignalReceived();</span>
<a href="#l4.278"></a><span id="l4.278" class="difflineminus">-  void    ResetProgressInfo();</span>
<a href="#l4.279"></a><span id="l4.279" class="difflineminus">-  void    SetActive(bool active);</span>
<a href="#l4.280"></a><span id="l4.280" class="difflineminus">-  bool    GetActive();</span>
<a href="#l4.281"></a><span id="l4.281" class="difflineplus">+  bool DeathSignalReceived();</span>
<a href="#l4.282"></a><span id="l4.282" class="difflineplus">+  void ResetProgressInfo();</span>
<a href="#l4.283"></a><span id="l4.283" class="difflineplus">+  void SetActive(bool active);</span>
<a href="#l4.284"></a><span id="l4.284" class="difflineplus">+  bool GetActive();</span>
<a href="#l4.285"></a><span id="l4.285"> </span>
<a href="#l4.286"></a><span id="l4.286">   bool GetShowAttachmentsInline();</span>
<a href="#l4.287"></a><span id="l4.287"> </span>
<a href="#l4.288"></a><span id="l4.288" class="difflineminus">-  // Sets whether or not the content referenced by the current ActiveEntry has been modified.</span>
<a href="#l4.289"></a><span id="l4.289" class="difflineminus">-  // Used for MIME parts on demand.</span>
<a href="#l4.290"></a><span id="l4.290" class="difflineminus">-  void    SetContentModified(IMAP_ContentModifiedType modified);</span>
<a href="#l4.291"></a><span id="l4.291" class="difflineminus">-  bool    GetShouldFetchAllParts();</span>
<a href="#l4.292"></a><span id="l4.292" class="difflineminus">-  bool    GetIgnoreExpunges() {return m_ignoreExpunges;}</span>
<a href="#l4.293"></a><span id="l4.293" class="difflineplus">+  // Sets whether or not the content referenced by the current ActiveEntry has</span>
<a href="#l4.294"></a><span id="l4.294" class="difflineplus">+  // been modified. Used for MIME parts on demand.</span>
<a href="#l4.295"></a><span id="l4.295" class="difflineplus">+  void SetContentModified(IMAP_ContentModifiedType modified);</span>
<a href="#l4.296"></a><span id="l4.296" class="difflineplus">+  bool GetShouldFetchAllParts();</span>
<a href="#l4.297"></a><span id="l4.297" class="difflineplus">+  bool GetIgnoreExpunges() { return m_ignoreExpunges; }</span>
<a href="#l4.298"></a><span id="l4.298">   // Generic accessors required by the imap parser</span>
<a href="#l4.299"></a><span id="l4.299" class="difflineminus">-  char * CreateNewLineFromSocket();</span>
<a href="#l4.300"></a><span id="l4.300" class="difflineplus">+  char *CreateNewLineFromSocket();</span>
<a href="#l4.301"></a><span id="l4.301">   nsresult GetConnectionStatus();</span>
<a href="#l4.302"></a><span id="l4.302">   void SetConnectionStatus(nsresult status);</span>
<a href="#l4.303"></a><span id="l4.303"> </span>
<a href="#l4.304"></a><span id="l4.304">   // Cleanup the connection and shutdown the thread.</span>
<a href="#l4.305"></a><span id="l4.305">   void TellThreadToDie();</span>
<a href="#l4.306"></a><span id="l4.306"> </span>
<a href="#l4.307"></a><span id="l4.307" class="difflineminus">-  const nsCString&amp; GetImapHostName(); // return the host name from the url for the</span>
<a href="#l4.308"></a><span id="l4.308" class="difflineplus">+  const nsCString &amp;</span>
<a href="#l4.309"></a><span id="l4.309" class="difflineplus">+  GetImapHostName();  // return the host name from the url for the</span>
<a href="#l4.310"></a><span id="l4.310">   // current connection</span>
<a href="#l4.311"></a><span id="l4.311" class="difflineminus">-  const nsCString&amp; GetImapUserName(); // return the user name from the identity</span>
<a href="#l4.312"></a><span id="l4.312" class="difflineminus">-  const char* GetImapServerKey(); // return the user name from the incoming server;</span>
<a href="#l4.313"></a><span id="l4.313" class="difflineplus">+  const nsCString &amp;GetImapUserName();  // return the user name from the identity</span>
<a href="#l4.314"></a><span id="l4.314" class="difflineplus">+  const char *</span>
<a href="#l4.315"></a><span id="l4.315" class="difflineplus">+  GetImapServerKey();  // return the user name from the incoming server;</span>
<a href="#l4.316"></a><span id="l4.316"> </span>
<a href="#l4.317"></a><span id="l4.317">   // state set by the imap parser...</span>
<a href="#l4.318"></a><span id="l4.318" class="difflineminus">-  void NotifyMessageFlags(imapMessageFlagsType flags, const nsACString &amp;keywords,</span>
<a href="#l4.319"></a><span id="l4.319" class="difflineminus">-                          nsMsgKey key, uint64_t highestModSeq);</span>
<a href="#l4.320"></a><span id="l4.320" class="difflineminus">-  void NotifySearchHit(const char * hitLine);</span>
<a href="#l4.321"></a><span id="l4.321" class="difflineplus">+  void NotifyMessageFlags(imapMessageFlagsType flags,</span>
<a href="#l4.322"></a><span id="l4.322" class="difflineplus">+                          const nsACString &amp;keywords, nsMsgKey key,</span>
<a href="#l4.323"></a><span id="l4.323" class="difflineplus">+                          uint64_t highestModSeq);</span>
<a href="#l4.324"></a><span id="l4.324" class="difflineplus">+  void NotifySearchHit(const char *hitLine);</span>
<a href="#l4.325"></a><span id="l4.325"> </span>
<a href="#l4.326"></a><span id="l4.326">   // Event handlers for the imap parser.</span>
<a href="#l4.327"></a><span id="l4.327" class="difflineminus">-  void DiscoverMailboxSpec(nsImapMailboxSpec * adoptedBoxSpec);</span>
<a href="#l4.328"></a><span id="l4.328" class="difflineminus">-  void AlertUserEventUsingName(const char* aMessageId);</span>
<a href="#l4.329"></a><span id="l4.329" class="difflineminus">-  void AlertUserEvent(const char * message);</span>
<a href="#l4.330"></a><span id="l4.330" class="difflineminus">-  void AlertUserEventFromServer(const char * aServerEvent, bool aForIdle = false);</span>
<a href="#l4.331"></a><span id="l4.331" class="difflineplus">+  void DiscoverMailboxSpec(nsImapMailboxSpec *adoptedBoxSpec);</span>
<a href="#l4.332"></a><span id="l4.332" class="difflineplus">+  void AlertUserEventUsingName(const char *aMessageId);</span>
<a href="#l4.333"></a><span id="l4.333" class="difflineplus">+  void AlertUserEvent(const char *message);</span>
<a href="#l4.334"></a><span id="l4.334" class="difflineplus">+  void AlertUserEventFromServer(const char *aServerEvent,</span>
<a href="#l4.335"></a><span id="l4.335" class="difflineplus">+                                bool aForIdle = false);</span>
<a href="#l4.336"></a><span id="l4.336"> </span>
<a href="#l4.337"></a><span id="l4.337" class="difflineminus">-  void ProgressEventFunctionUsingName(const char* aMsgId);</span>
<a href="#l4.338"></a><span id="l4.338" class="difflineminus">-  void ProgressEventFunctionUsingNameWithString(const char* aMsgName, const char *</span>
<a href="#l4.339"></a><span id="l4.339" class="difflineminus">-    aExtraInfo);</span>
<a href="#l4.340"></a><span id="l4.340" class="difflineminus">-  void PercentProgressUpdateEvent(const char16_t *message, int64_t currentProgress, int64_t maxProgress);</span>
<a href="#l4.341"></a><span id="l4.341" class="difflineplus">+  void ProgressEventFunctionUsingName(const char *aMsgId);</span>
<a href="#l4.342"></a><span id="l4.342" class="difflineplus">+  void ProgressEventFunctionUsingNameWithString(const char *aMsgName,</span>
<a href="#l4.343"></a><span id="l4.343" class="difflineplus">+                                                const char *aExtraInfo);</span>
<a href="#l4.344"></a><span id="l4.344" class="difflineplus">+  void PercentProgressUpdateEvent(const char16_t *message,</span>
<a href="#l4.345"></a><span id="l4.345" class="difflineplus">+                                  int64_t currentProgress, int64_t maxProgress);</span>
<a href="#l4.346"></a><span id="l4.346">   void ShowProgress();</span>
<a href="#l4.347"></a><span id="l4.347"> </span>
<a href="#l4.348"></a><span id="l4.348">   // utility function calls made by the server</span>
<a href="#l4.349"></a><span id="l4.349"> </span>
<a href="#l4.350"></a><span id="l4.350" class="difflineminus">-  void Copy(const char * messageList, const char *destinationMailbox,</span>
<a href="#l4.351"></a><span id="l4.351" class="difflineminus">-    bool idsAreUid);</span>
<a href="#l4.352"></a><span id="l4.352" class="difflineminus">-  void Search(const char * searchCriteria,  bool useUID,</span>
<a href="#l4.353"></a><span id="l4.353" class="difflineminus">-    bool notifyHit = true);</span>
<a href="#l4.354"></a><span id="l4.354" class="difflineplus">+  void Copy(const char *messageList, const char *destinationMailbox,</span>
<a href="#l4.355"></a><span id="l4.355" class="difflineplus">+            bool idsAreUid);</span>
<a href="#l4.356"></a><span id="l4.356" class="difflineplus">+  void Search(const char *searchCriteria, bool useUID, bool notifyHit = true);</span>
<a href="#l4.357"></a><span id="l4.357">   // imap commands issued by the parser</span>
<a href="#l4.358"></a><span id="l4.358" class="difflineminus">-  void Store(const nsCString &amp;aMessageList, const char * aMessageData, bool</span>
<a href="#l4.359"></a><span id="l4.359" class="difflineminus">-    aIdsAreUid);</span>
<a href="#l4.360"></a><span id="l4.360" class="difflineminus">-  void ProcessStoreFlags(const nsCString &amp;messageIds,</span>
<a href="#l4.361"></a><span id="l4.361" class="difflineminus">-    bool idsAreUids,</span>
<a href="#l4.362"></a><span id="l4.362" class="difflineminus">-    imapMessageFlagsType flags,</span>
<a href="#l4.363"></a><span id="l4.363" class="difflineminus">-    bool addFlags);</span>
<a href="#l4.364"></a><span id="l4.364" class="difflineminus">-  void IssueUserDefinedMsgCommand(const char *command, const char * messageList);</span>
<a href="#l4.365"></a><span id="l4.365" class="difflineminus">-  void FetchMsgAttribute(const nsCString &amp;messageIds, const nsCString &amp;attribute);</span>
<a href="#l4.366"></a><span id="l4.366" class="difflineplus">+  void Store(const nsCString &amp;aMessageList, const char *aMessageData,</span>
<a href="#l4.367"></a><span id="l4.367" class="difflineplus">+             bool aIdsAreUid);</span>
<a href="#l4.368"></a><span id="l4.368" class="difflineplus">+  void ProcessStoreFlags(const nsCString &amp;messageIds, bool idsAreUids,</span>
<a href="#l4.369"></a><span id="l4.369" class="difflineplus">+                         imapMessageFlagsType flags, bool addFlags);</span>
<a href="#l4.370"></a><span id="l4.370" class="difflineplus">+  void IssueUserDefinedMsgCommand(const char *command, const char *messageList);</span>
<a href="#l4.371"></a><span id="l4.371" class="difflineplus">+  void FetchMsgAttribute(const nsCString &amp;messageIds,</span>
<a href="#l4.372"></a><span id="l4.372" class="difflineplus">+                         const nsCString &amp;attribute);</span>
<a href="#l4.373"></a><span id="l4.373">   void Expunge();</span>
<a href="#l4.374"></a><span id="l4.374">   void UidExpunge(const nsCString &amp;messageSet);</span>
<a href="#l4.375"></a><span id="l4.375">   void Close(bool shuttingDown = false, bool waitForResponse = true);</span>
<a href="#l4.376"></a><span id="l4.376">   void Check();</span>
<a href="#l4.377"></a><span id="l4.377">   void SelectMailbox(const char *mailboxName);</span>
<a href="#l4.378"></a><span id="l4.378">   // more imap commands</span>
<a href="#l4.379"></a><span id="l4.379">   void Logout(bool shuttingDown = false, bool waitForResponse = true);</span>
<a href="#l4.380"></a><span id="l4.380">   void Noop();</span>
<a href="#l4.381"></a><span id="l4.381">   void XServerInfo();</span>
<a href="#l4.382"></a><span id="l4.382">   void Netscape();</span>
<a href="#l4.383"></a><span id="l4.383">   void XMailboxInfo(const char *mailboxName);</span>
<a href="#l4.384"></a><span id="l4.384">   void XAOL_Option(const char *option);</span>
<a href="#l4.385"></a><span id="l4.385">   void MailboxData();</span>
<a href="#l4.386"></a><span id="l4.386">   void GetMyRightsForFolder(const char *mailboxName);</span>
<a href="#l4.387"></a><span id="l4.387">   void Bodystructure(const nsCString &amp;messageId, bool idIsUid);</span>
<a href="#l4.388"></a><span id="l4.388" class="difflineminus">-  void PipelinedFetchMessageParts(const char *uid, nsIMAPMessagePartIDArray *parts);</span>
<a href="#l4.389"></a><span id="l4.389" class="difflineminus">-</span>
<a href="#l4.390"></a><span id="l4.390" class="difflineplus">+  void PipelinedFetchMessageParts(const char *uid,</span>
<a href="#l4.391"></a><span id="l4.391" class="difflineplus">+                                  nsIMAPMessagePartIDArray *parts);</span>
<a href="#l4.392"></a><span id="l4.392"> </span>
<a href="#l4.393"></a><span id="l4.393">   // this function does not ref count!!! be careful!!!</span>
<a href="#l4.394"></a><span id="l4.394" class="difflineminus">-  nsIImapUrl  *GetCurrentUrl() {return m_runningUrl;}</span>
<a href="#l4.395"></a><span id="l4.395" class="difflineplus">+  nsIImapUrl *GetCurrentUrl() { return m_runningUrl; }</span>
<a href="#l4.396"></a><span id="l4.396"> </span>
<a href="#l4.397"></a><span id="l4.397">   // acl and namespace stuff</span>
<a href="#l4.398"></a><span id="l4.398" class="difflineminus">-  // notifies libmsg that we have a new personal/default namespace that we're using</span>
<a href="#l4.399"></a><span id="l4.399" class="difflineplus">+  // notifies libmsg that we have a new personal/default namespace that we're</span>
<a href="#l4.400"></a><span id="l4.400" class="difflineplus">+  // using</span>
<a href="#l4.401"></a><span id="l4.401">   void CommitNamespacesForHostEvent();</span>
<a href="#l4.402"></a><span id="l4.402">   // notifies libmsg that we have new capability data for the current host</span>
<a href="#l4.403"></a><span id="l4.403">   void CommitCapability();</span>
<a href="#l4.404"></a><span id="l4.404"> </span>
<a href="#l4.405"></a><span id="l4.405" class="difflineminus">-  // Adds a set of rights for a given user on a given mailbox on the current host.</span>
<a href="#l4.406"></a><span id="l4.406" class="difflineminus">-  // if userName is NULL, it means &quot;me,&quot; or MYRIGHTS.</span>
<a href="#l4.407"></a><span id="l4.407" class="difflineminus">-  // rights is a single string of rights, as specified by RFC2086, the IMAP ACL extension.</span>
<a href="#l4.408"></a><span id="l4.408" class="difflineminus">-  void AddFolderRightsForUser(const char *mailboxName, const char *userName, const char *rights);</span>
<a href="#l4.409"></a><span id="l4.409" class="difflineplus">+  // Adds a set of rights for a given user on a given mailbox on the current</span>
<a href="#l4.410"></a><span id="l4.410" class="difflineplus">+  // host. if userName is NULL, it means &quot;me,&quot; or MYRIGHTS. rights is a single</span>
<a href="#l4.411"></a><span id="l4.411" class="difflineplus">+  // string of rights, as specified by RFC2086, the IMAP ACL extension.</span>
<a href="#l4.412"></a><span id="l4.412" class="difflineplus">+  void AddFolderRightsForUser(const char *mailboxName, const char *userName,</span>
<a href="#l4.413"></a><span id="l4.413" class="difflineplus">+                              const char *rights);</span>
<a href="#l4.414"></a><span id="l4.414">   // Clears all rights for the current folder, for all users.</span>
<a href="#l4.415"></a><span id="l4.415">   void ClearAllFolderRights();</span>
<a href="#l4.416"></a><span id="l4.416" class="difflineminus">-  void RefreshFolderACLView(const char *mailboxName, nsIMAPNamespace *nsForMailbox);</span>
<a href="#l4.417"></a><span id="l4.417" class="difflineplus">+  void RefreshFolderACLView(const char *mailboxName,</span>
<a href="#l4.418"></a><span id="l4.418" class="difflineplus">+                            nsIMAPNamespace *nsForMailbox);</span>
<a href="#l4.419"></a><span id="l4.419"> </span>
<a href="#l4.420"></a><span id="l4.420">   nsresult SetFolderAdminUrl(const char *mailboxName);</span>
<a href="#l4.421"></a><span id="l4.421">   void HandleMemoryFailure();</span>
<a href="#l4.422"></a><span id="l4.422">   void HandleCurrentUrlError();</span>
<a href="#l4.423"></a><span id="l4.423"> </span>
<a href="#l4.424"></a><span id="l4.424">   // UIDPLUS extension</span>
<a href="#l4.425"></a><span id="l4.425" class="difflineminus">-  void SetCopyResponseUid(const char* msgIdString);</span>
<a href="#l4.426"></a><span id="l4.426" class="difflineplus">+  void SetCopyResponseUid(const char *msgIdString);</span>
<a href="#l4.427"></a><span id="l4.427"> </span>
<a href="#l4.428"></a><span id="l4.428">   // Quota support</span>
<a href="#l4.429"></a><span id="l4.429" class="difflineminus">-  void UpdateFolderQuotaData(nsCString&amp; aQuotaRoot, uint32_t aUsed, uint32_t aMax);</span>
<a href="#l4.430"></a><span id="l4.430" class="difflineplus">+  void UpdateFolderQuotaData(nsCString &amp;aQuotaRoot, uint32_t aUsed,</span>
<a href="#l4.431"></a><span id="l4.431" class="difflineplus">+                             uint32_t aMax);</span>
<a href="#l4.432"></a><span id="l4.432"> </span>
<a href="#l4.433"></a><span id="l4.433">   bool GetPreferPlainText() { return m_preferPlainText; }</span>
<a href="#l4.434"></a><span id="l4.434"> </span>
<a href="#l4.435"></a><span id="l4.435">   int32_t GetCurFetchSize() { return m_curFetchSize; }</span>
<a href="#l4.436"></a><span id="l4.436"> </span>
<a href="#l4.437"></a><span id="l4.437">   const nsString &amp;GetEmptyMimePartString() { return m_emptyMimePartString; }</span>
<a href="#l4.438"></a><span id="l4.438" class="difflineminus">-private:</span>
<a href="#l4.439"></a><span id="l4.439" class="difflineminus">-  virtual ~nsImapProtocol();</span>
<a href="#l4.440"></a><span id="l4.440" class="difflineminus">-  // the following flag is used to determine when a url is currently being run. It is cleared when we</span>
<a href="#l4.441"></a><span id="l4.441" class="difflineminus">-  // finish processng a url and it is set whenever we call Load on a url</span>
<a href="#l4.442"></a><span id="l4.442" class="difflineminus">-  bool m_urlInProgress;</span>
<a href="#l4.443"></a><span id="l4.443" class="difflineminus">-  nsCOMPtr&lt;nsIImapUrl&gt; m_runningUrl; // the nsIImapURL that is currently running</span>
<a href="#l4.444"></a><span id="l4.444" class="difflineminus">-  nsCOMPtr&lt;nsIImapUrl&gt; m_runningUrlLatest;</span>
<a href="#l4.445"></a><span id="l4.445" class="difflineminus">-  nsImapAction m_imapAction;  // current imap action associated with this connection...</span>
<a href="#l4.446"></a><span id="l4.446"> </span>
<a href="#l4.447"></a><span id="l4.447" class="difflineminus">-  nsCString             m_hostName;</span>
<a href="#l4.448"></a><span id="l4.448" class="difflineminus">-  nsCString             m_userName;</span>
<a href="#l4.449"></a><span id="l4.449" class="difflineminus">-  nsCString             m_serverKey;</span>
<a href="#l4.450"></a><span id="l4.450" class="difflineminus">-  nsCString             m_realHostName;</span>
<a href="#l4.451"></a><span id="l4.451" class="difflineminus">-  char                  *m_dataOutputBuf;</span>
<a href="#l4.452"></a><span id="l4.452" class="difflineplus">+ private:</span>
<a href="#l4.453"></a><span id="l4.453" class="difflineplus">+  virtual ~nsImapProtocol();</span>
<a href="#l4.454"></a><span id="l4.454" class="difflineplus">+  // the following flag is used to determine when a url is currently being run.</span>
<a href="#l4.455"></a><span id="l4.455" class="difflineplus">+  // It is cleared when we finish processng a url and it is set whenever we call</span>
<a href="#l4.456"></a><span id="l4.456" class="difflineplus">+  // Load on a url</span>
<a href="#l4.457"></a><span id="l4.457" class="difflineplus">+  bool m_urlInProgress;</span>
<a href="#l4.458"></a><span id="l4.458" class="difflineplus">+  nsCOMPtr&lt;nsIImapUrl&gt;</span>
<a href="#l4.459"></a><span id="l4.459" class="difflineplus">+      m_runningUrl;  // the nsIImapURL that is currently running</span>
<a href="#l4.460"></a><span id="l4.460" class="difflineplus">+  nsCOMPtr&lt;nsIImapUrl&gt; m_runningUrlLatest;</span>
<a href="#l4.461"></a><span id="l4.461" class="difflineplus">+  nsImapAction</span>
<a href="#l4.462"></a><span id="l4.462" class="difflineplus">+      m_imapAction;  // current imap action associated with this connection...</span>
<a href="#l4.463"></a><span id="l4.463" class="difflineplus">+</span>
<a href="#l4.464"></a><span id="l4.464" class="difflineplus">+  nsCString m_hostName;</span>
<a href="#l4.465"></a><span id="l4.465" class="difflineplus">+  nsCString m_userName;</span>
<a href="#l4.466"></a><span id="l4.466" class="difflineplus">+  nsCString m_serverKey;</span>
<a href="#l4.467"></a><span id="l4.467" class="difflineplus">+  nsCString m_realHostName;</span>
<a href="#l4.468"></a><span id="l4.468" class="difflineplus">+  char *m_dataOutputBuf;</span>
<a href="#l4.469"></a><span id="l4.469">   RefPtr&lt;nsMsgLineStreamBuffer&gt; m_inputStreamBuffer;</span>
<a href="#l4.470"></a><span id="l4.470" class="difflineminus">-  uint32_t              m_allocatedSize; // allocated size</span>
<a href="#l4.471"></a><span id="l4.471" class="difflineminus">-  uint32_t        m_totalDataSize; // total data size</span>
<a href="#l4.472"></a><span id="l4.472" class="difflineminus">-  uint32_t        m_curReadIndex;  // current read index</span>
<a href="#l4.473"></a><span id="l4.473" class="difflineminus">-  nsCString       m_trashFolderPath;</span>
<a href="#l4.474"></a><span id="l4.474" class="difflineplus">+  uint32_t m_allocatedSize;  // allocated size</span>
<a href="#l4.475"></a><span id="l4.475" class="difflineplus">+  uint32_t m_totalDataSize;  // total data size</span>
<a href="#l4.476"></a><span id="l4.476" class="difflineplus">+  uint32_t m_curReadIndex;   // current read index</span>
<a href="#l4.477"></a><span id="l4.477" class="difflineplus">+  nsCString m_trashFolderPath;</span>
<a href="#l4.478"></a><span id="l4.478"> </span>
<a href="#l4.479"></a><span id="l4.479">   // Output stream for writing commands to the socket</span>
<a href="#l4.480"></a><span id="l4.480" class="difflineminus">-  nsCOMPtr&lt;nsISocketTransport&gt;  m_transport;</span>
<a href="#l4.481"></a><span id="l4.481" class="difflineplus">+  nsCOMPtr&lt;nsISocketTransport&gt; m_transport;</span>
<a href="#l4.482"></a><span id="l4.482">   nsCOMPtr&lt;nsIInputStream&gt; m_inputStream;</span>
<a href="#l4.483"></a><span id="l4.483"> </span>
<a href="#l4.484"></a><span id="l4.484" class="difflineminus">-  nsCOMPtr&lt;nsIAsyncInputStream&gt;   m_channelInputStream;</span>
<a href="#l4.485"></a><span id="l4.485" class="difflineminus">-  nsCOMPtr&lt;nsIAsyncOutputStream&gt;  m_channelOutputStream;</span>
<a href="#l4.486"></a><span id="l4.486" class="difflineminus">-  nsCOMPtr&lt;nsIImapMockChannel&gt;    m_mockChannel;   // this is the channel we should forward to people</span>
<a href="#l4.487"></a><span id="l4.487" class="difflineplus">+  nsCOMPtr&lt;nsIAsyncInputStream&gt; m_channelInputStream;</span>
<a href="#l4.488"></a><span id="l4.488" class="difflineplus">+  nsCOMPtr&lt;nsIAsyncOutputStream&gt; m_channelOutputStream;</span>
<a href="#l4.489"></a><span id="l4.489" class="difflineplus">+  nsCOMPtr&lt;nsIImapMockChannel&gt;</span>
<a href="#l4.490"></a><span id="l4.490" class="difflineplus">+      m_mockChannel;  // this is the channel we should forward to people</span>
<a href="#l4.491"></a><span id="l4.491">   uint32_t m_bytesToChannel;</span>
<a href="#l4.492"></a><span id="l4.492">   bool m_fetchingWholeMessage;</span>
<a href="#l4.493"></a><span id="l4.493" class="difflineminus">-  //nsCOMPtr&lt;nsIRequest&gt; mAsyncReadRequest; // we're going to cancel this when we're done with the conn.</span>
<a href="#l4.494"></a><span id="l4.494" class="difflineminus">-</span>
<a href="#l4.495"></a><span id="l4.495" class="difflineplus">+  // nsCOMPtr&lt;nsIRequest&gt; mAsyncReadRequest; // we're going to cancel this when</span>
<a href="#l4.496"></a><span id="l4.496" class="difflineplus">+  // we're done with the conn.</span>
<a href="#l4.497"></a><span id="l4.497"> </span>
<a href="#l4.498"></a><span id="l4.498">   // ******* Thread support *******</span>
<a href="#l4.499"></a><span id="l4.499" class="difflineminus">-  nsCOMPtr&lt;nsIThread&gt;      m_iThread;</span>
<a href="#l4.500"></a><span id="l4.500" class="difflineminus">-  PRThread     *m_thread;</span>
<a href="#l4.501"></a><span id="l4.501" class="difflineminus">-  mozilla::ReentrantMonitor m_dataAvailableMonitor;   // used to notify the arrival of data from the server</span>
<a href="#l4.502"></a><span id="l4.502" class="difflineminus">-  mozilla::ReentrantMonitor m_urlReadyToRunMonitor;   // used to notify the arrival of a new url to be processed</span>
<a href="#l4.503"></a><span id="l4.503" class="difflineplus">+  nsCOMPtr&lt;nsIThread&gt; m_iThread;</span>
<a href="#l4.504"></a><span id="l4.504" class="difflineplus">+  PRThread *m_thread;</span>
<a href="#l4.505"></a><span id="l4.505" class="difflineplus">+  mozilla::ReentrantMonitor</span>
<a href="#l4.506"></a><span id="l4.506" class="difflineplus">+      m_dataAvailableMonitor;  // used to notify the arrival of data from the</span>
<a href="#l4.507"></a><span id="l4.507" class="difflineplus">+                               // server</span>
<a href="#l4.508"></a><span id="l4.508" class="difflineplus">+  mozilla::ReentrantMonitor</span>
<a href="#l4.509"></a><span id="l4.509" class="difflineplus">+      m_urlReadyToRunMonitor;  // used to notify the arrival of a new url to be</span>
<a href="#l4.510"></a><span id="l4.510" class="difflineplus">+                               // processed</span>
<a href="#l4.511"></a><span id="l4.511">   mozilla::ReentrantMonitor m_pseudoInterruptMonitor;</span>
<a href="#l4.512"></a><span id="l4.512">   mozilla::ReentrantMonitor m_dataMemberMonitor;</span>
<a href="#l4.513"></a><span id="l4.513">   mozilla::ReentrantMonitor m_threadDeathMonitor;</span>
<a href="#l4.514"></a><span id="l4.514">   mozilla::ReentrantMonitor m_waitForBodyIdsMonitor;</span>
<a href="#l4.515"></a><span id="l4.515">   mozilla::ReentrantMonitor m_fetchBodyListMonitor;</span>
<a href="#l4.516"></a><span id="l4.516">   mozilla::ReentrantMonitor m_passwordReadyMonitor;</span>
<a href="#l4.517"></a><span id="l4.517">   mozilla::Mutex mLock;</span>
<a href="#l4.518"></a><span id="l4.518">   // If we get an async password prompt, this is where the UI thread</span>
<a href="#l4.519"></a><span id="l4.519">   // stores the password, before notifying the imap thread of the password</span>
<a href="#l4.520"></a><span id="l4.520">   // via the m_passwordReadyMonitor.</span>
<a href="#l4.521"></a><span id="l4.521">   nsString m_password;</span>
<a href="#l4.522"></a><span id="l4.522">   // Set to the result of nsImapServer::PromptPassword</span>
<a href="#l4.523"></a><span id="l4.523" class="difflineminus">-  nsresult    m_passwordStatus;</span>
<a href="#l4.524"></a><span id="l4.524" class="difflineminus">-  bool        m_passwordObtained;</span>
<a href="#l4.525"></a><span id="l4.525" class="difflineplus">+  nsresult m_passwordStatus;</span>
<a href="#l4.526"></a><span id="l4.526" class="difflineplus">+  bool m_passwordObtained;</span>
<a href="#l4.527"></a><span id="l4.527"> </span>
<a href="#l4.528"></a><span id="l4.528" class="difflineminus">-  bool         m_imapThreadIsRunning;</span>
<a href="#l4.529"></a><span id="l4.529" class="difflineplus">+  bool m_imapThreadIsRunning;</span>
<a href="#l4.530"></a><span id="l4.530">   void ImapThreadMainLoop(void);</span>
<a href="#l4.531"></a><span id="l4.531" class="difflineminus">-  nsresult    m_connectionStatus;</span>
<a href="#l4.532"></a><span id="l4.532" class="difflineminus">-  nsCString   m_connectionType;</span>
<a href="#l4.533"></a><span id="l4.533" class="difflineplus">+  nsresult m_connectionStatus;</span>
<a href="#l4.534"></a><span id="l4.534" class="difflineplus">+  nsCString m_connectionType;</span>
<a href="#l4.535"></a><span id="l4.535"> </span>
<a href="#l4.536"></a><span id="l4.536" class="difflineminus">-  bool        m_nextUrlReadyToRun;</span>
<a href="#l4.537"></a><span id="l4.537" class="difflineminus">-  nsWeakPtr   m_server;</span>
<a href="#l4.538"></a><span id="l4.538" class="difflineplus">+  bool m_nextUrlReadyToRun;</span>
<a href="#l4.539"></a><span id="l4.539" class="difflineplus">+  nsWeakPtr m_server;</span>
<a href="#l4.540"></a><span id="l4.540"> </span>
<a href="#l4.541"></a><span id="l4.541">   RefPtr&lt;ImapMailFolderSinkProxy&gt; m_imapMailFolderSink;</span>
<a href="#l4.542"></a><span id="l4.542" class="difflineminus">-  RefPtr&lt;ImapMessageSinkProxy&gt;    m_imapMessageSink;</span>
<a href="#l4.543"></a><span id="l4.543" class="difflineminus">-  RefPtr&lt;ImapServerSinkProxy&gt;     m_imapServerSink;</span>
<a href="#l4.544"></a><span id="l4.544" class="difflineminus">-  RefPtr&lt;ImapServerSinkProxy&gt;     m_imapServerSinkLatest;</span>
<a href="#l4.545"></a><span id="l4.545" class="difflineminus">-  RefPtr&lt;ImapProtocolSinkProxy&gt;   m_imapProtocolSink;</span>
<a href="#l4.546"></a><span id="l4.546" class="difflineplus">+  RefPtr&lt;ImapMessageSinkProxy&gt; m_imapMessageSink;</span>
<a href="#l4.547"></a><span id="l4.547" class="difflineplus">+  RefPtr&lt;ImapServerSinkProxy&gt; m_imapServerSink;</span>
<a href="#l4.548"></a><span id="l4.548" class="difflineplus">+  RefPtr&lt;ImapServerSinkProxy&gt; m_imapServerSinkLatest;</span>
<a href="#l4.549"></a><span id="l4.549" class="difflineplus">+  RefPtr&lt;ImapProtocolSinkProxy&gt; m_imapProtocolSink;</span>
<a href="#l4.550"></a><span id="l4.550"> </span>
<a href="#l4.551"></a><span id="l4.551">   // helper function to setup imap sink interface proxies</span>
<a href="#l4.552"></a><span id="l4.552">   nsresult SetupSinkProxy();</span>
<a href="#l4.553"></a><span id="l4.553">   // End thread support stuff</span>
<a href="#l4.554"></a><span id="l4.554">   nsresult LoadImapUrlInternal();</span>
<a href="#l4.555"></a><span id="l4.555"> </span>
<a href="#l4.556"></a><span id="l4.556">   bool GetDeleteIsMoveToTrash();</span>
<a href="#l4.557"></a><span id="l4.557">   bool GetShowDeletedMessages();</span>
<a href="#l4.558"></a><span id="l4.558">   nsCString m_currentCommand;</span>
<a href="#l4.559"></a><span id="l4.559">   nsImapServerResponseParser m_parser;</span>
<a href="#l4.560"></a><span id="l4.560" class="difflineminus">-  nsImapServerResponseParser&amp; GetServerStateParser() { return m_parser; }</span>
<a href="#l4.561"></a><span id="l4.561" class="difflineplus">+  nsImapServerResponseParser &amp;GetServerStateParser() { return m_parser; }</span>
<a href="#l4.562"></a><span id="l4.562"> </span>
<a href="#l4.563"></a><span id="l4.563">   void HandleIdleResponses();</span>
<a href="#l4.564"></a><span id="l4.564">   virtual bool ProcessCurrentURL();</span>
<a href="#l4.565"></a><span id="l4.565">   void EstablishServerConnection();</span>
<a href="#l4.566"></a><span id="l4.566" class="difflineminus">-  virtual void ParseIMAPandCheckForNewMail(const char* commandString =</span>
<a href="#l4.567"></a><span id="l4.567" class="difflineminus">-    nullptr, bool ignoreBadNOResponses = false);</span>
<a href="#l4.568"></a><span id="l4.568" class="difflineplus">+  virtual void ParseIMAPandCheckForNewMail(const char *commandString = nullptr,</span>
<a href="#l4.569"></a><span id="l4.569" class="difflineplus">+                                           bool ignoreBadNOResponses = false);</span>
<a href="#l4.570"></a><span id="l4.570">   // biff</span>
<a href="#l4.571"></a><span id="l4.571" class="difflineminus">-  void  PeriodicBiff();</span>
<a href="#l4.572"></a><span id="l4.572" class="difflineminus">-  void  SendSetBiffIndicatorEvent(nsMsgBiffState newState);</span>
<a href="#l4.573"></a><span id="l4.573" class="difflineplus">+  void PeriodicBiff();</span>
<a href="#l4.574"></a><span id="l4.574" class="difflineplus">+  void SendSetBiffIndicatorEvent(nsMsgBiffState newState);</span>
<a href="#l4.575"></a><span id="l4.575"> </span>
<a href="#l4.576"></a><span id="l4.576">   // folder opening and listing header functions</span>
<a href="#l4.577"></a><span id="l4.577">   void FolderHeaderDump(uint32_t *msgUids, uint32_t msgCount);</span>
<a href="#l4.578"></a><span id="l4.578" class="difflineminus">-  void FolderMsgDump(uint32_t *msgUids, uint32_t msgCount, nsIMAPeFetchFields fields);</span>
<a href="#l4.579"></a><span id="l4.579" class="difflineminus">-  void FolderMsgDumpLoop(uint32_t *msgUids, uint32_t msgCount, nsIMAPeFetchFields fields);</span>
<a href="#l4.580"></a><span id="l4.580" class="difflineminus">-  void WaitForPotentialListOfBodysToFetch(uint32_t **msgIdList, uint32_t &amp;msgCount);</span>
<a href="#l4.581"></a><span id="l4.581" class="difflineplus">+  void FolderMsgDump(uint32_t *msgUids, uint32_t msgCount,</span>
<a href="#l4.582"></a><span id="l4.582" class="difflineplus">+                     nsIMAPeFetchFields fields);</span>
<a href="#l4.583"></a><span id="l4.583" class="difflineplus">+  void FolderMsgDumpLoop(uint32_t *msgUids, uint32_t msgCount,</span>
<a href="#l4.584"></a><span id="l4.584" class="difflineplus">+                         nsIMAPeFetchFields fields);</span>
<a href="#l4.585"></a><span id="l4.585" class="difflineplus">+  void WaitForPotentialListOfBodysToFetch(uint32_t **msgIdList,</span>
<a href="#l4.586"></a><span id="l4.586" class="difflineplus">+                                          uint32_t &amp;msgCount);</span>
<a href="#l4.587"></a><span id="l4.587">   void HeaderFetchCompleted();</span>
<a href="#l4.588"></a><span id="l4.588" class="difflineminus">-  void UploadMessageFromFile(nsIFile* file, const char* mailboxName, PRTime date,</span>
<a href="#l4.589"></a><span id="l4.589" class="difflineminus">-    imapMessageFlagsType flags, nsCString &amp;keywords);</span>
<a href="#l4.590"></a><span id="l4.590" class="difflineplus">+  void UploadMessageFromFile(nsIFile *file, const char *mailboxName,</span>
<a href="#l4.591"></a><span id="l4.591" class="difflineplus">+                             PRTime date, imapMessageFlagsType flags,</span>
<a href="#l4.592"></a><span id="l4.592" class="difflineplus">+                             nsCString &amp;keywords);</span>
<a href="#l4.593"></a><span id="l4.593"> </span>
<a href="#l4.594"></a><span id="l4.594">   // mailbox name utilities.</span>
<a href="#l4.595"></a><span id="l4.595">   void CreateEscapedMailboxName(const char *rawName, nsCString &amp;escapedName);</span>
<a href="#l4.596"></a><span id="l4.596" class="difflineminus">-  void SetupMessageFlagsString(nsCString &amp; flagString,</span>
<a href="#l4.597"></a><span id="l4.597" class="difflineminus">-    imapMessageFlagsType flags,</span>
<a href="#l4.598"></a><span id="l4.598" class="difflineminus">-    uint16_t userFlags);</span>
<a href="#l4.599"></a><span id="l4.599" class="difflineplus">+  void SetupMessageFlagsString(nsCString &amp;flagString,</span>
<a href="#l4.600"></a><span id="l4.600" class="difflineplus">+                               imapMessageFlagsType flags, uint16_t userFlags);</span>
<a href="#l4.601"></a><span id="l4.601"> </span>
<a href="#l4.602"></a><span id="l4.602">   // body fetching listing data</span>
<a href="#l4.603"></a><span id="l4.603" class="difflineminus">-  bool      m_fetchBodyListIsNew;</span>
<a href="#l4.604"></a><span id="l4.604" class="difflineminus">-  uint32_t  m_fetchBodyCount;</span>
<a href="#l4.605"></a><span id="l4.605" class="difflineminus">-  uint32_t  *m_fetchBodyIdList;</span>
<a href="#l4.606"></a><span id="l4.606" class="difflineplus">+  bool m_fetchBodyListIsNew;</span>
<a href="#l4.607"></a><span id="l4.607" class="difflineplus">+  uint32_t m_fetchBodyCount;</span>
<a href="#l4.608"></a><span id="l4.608" class="difflineplus">+  uint32_t *m_fetchBodyIdList;</span>
<a href="#l4.609"></a><span id="l4.609"> </span>
<a href="#l4.610"></a><span id="l4.610">   // initialization function given a new url and transport layer</span>
<a href="#l4.611"></a><span id="l4.611" class="difflineminus">-  nsresult  SetupWithUrl(nsIURI * aURL, nsISupports* aConsumer);</span>
<a href="#l4.612"></a><span id="l4.612" class="difflineminus">-  nsresult  SetupWithUrlCallback(nsIProxyInfo* proxyInfo);</span>
<a href="#l4.613"></a><span id="l4.613" class="difflineminus">-  void ReleaseUrlState(bool rerunningUrl); // release any state that is stored on a per action basis.</span>
<a href="#l4.614"></a><span id="l4.614" class="difflineplus">+  nsresult SetupWithUrl(nsIURI *aURL, nsISupports *aConsumer);</span>
<a href="#l4.615"></a><span id="l4.615" class="difflineplus">+  nsresult SetupWithUrlCallback(nsIProxyInfo *proxyInfo);</span>
<a href="#l4.616"></a><span id="l4.616" class="difflineplus">+  void ReleaseUrlState(bool rerunningUrl);  // release any state that is stored</span>
<a href="#l4.617"></a><span id="l4.617" class="difflineplus">+                                            // on a per action basis.</span>
<a href="#l4.618"></a><span id="l4.618">   /**</span>
<a href="#l4.619"></a><span id="l4.619">    * Last ditch effort to run the url without using an imap connection.</span>
<a href="#l4.620"></a><span id="l4.620">    * If it turns out that we don't need to run the url at all (e.g., we're</span>
<a href="#l4.621"></a><span id="l4.621">    * trying to download a single message for offline use and it has already</span>
<a href="#l4.622"></a><span id="l4.622">    * been downloaded, this function will send the appropriate notifications.</span>
<a href="#l4.623"></a><span id="l4.623">    *</span>
<a href="#l4.624"></a><span id="l4.624">    * @returns true if the url has been run locally, or doesn't need to be run.</span>
<a href="#l4.625"></a><span id="l4.625">    */</span>
<a href="#l4.626"></a><span id="l4.626">   bool TryToRunUrlLocally(nsIURI *aURL, nsISupports *aConsumer);</span>
<a href="#l4.627"></a><span id="l4.627"> </span>
<a href="#l4.628"></a><span id="l4.628">   ////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.629"></a><span id="l4.629">   // Communication methods --&gt; Reading and writing protocol</span>
<a href="#l4.630"></a><span id="l4.630">   ////////////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.631"></a><span id="l4.631"> </span>
<a href="#l4.632"></a><span id="l4.632" class="difflineminus">-  // SendData not only writes the NULL terminated data in dataBuffer to our output stream</span>
<a href="#l4.633"></a><span id="l4.633" class="difflineminus">-  // but it also informs the consumer that the data has been written to the stream.</span>
<a href="#l4.634"></a><span id="l4.634" class="difflineminus">-  // aSuppressLogging --&gt; set to true if you wish to suppress logging for this particular command.</span>
<a href="#l4.635"></a><span id="l4.635" class="difflineminus">-  // this is useful for making sure we don't log authenication information like the user's password (which was</span>
<a href="#l4.636"></a><span id="l4.636" class="difflineminus">-  // encoded anyway), but still we shouldn't add that information to the log.</span>
<a href="#l4.637"></a><span id="l4.637" class="difflineminus">-  nsresult SendData(const char * dataBuffer, bool aSuppressLogging = false) override;</span>
<a href="#l4.638"></a><span id="l4.638" class="difflineplus">+  // SendData not only writes the NULL terminated data in dataBuffer to our</span>
<a href="#l4.639"></a><span id="l4.639" class="difflineplus">+  // output stream but it also informs the consumer that the data has been</span>
<a href="#l4.640"></a><span id="l4.640" class="difflineplus">+  // written to the stream. aSuppressLogging --&gt; set to true if you wish to</span>
<a href="#l4.641"></a><span id="l4.641" class="difflineplus">+  // suppress logging for this particular command. this is useful for making</span>
<a href="#l4.642"></a><span id="l4.642" class="difflineplus">+  // sure we don't log authenication information like the user's password (which</span>
<a href="#l4.643"></a><span id="l4.643" class="difflineplus">+  // was encoded anyway), but still we shouldn't add that information to the</span>
<a href="#l4.644"></a><span id="l4.644" class="difflineplus">+  // log.</span>
<a href="#l4.645"></a><span id="l4.645" class="difflineplus">+  nsresult SendData(const char *dataBuffer,</span>
<a href="#l4.646"></a><span id="l4.646" class="difflineplus">+                    bool aSuppressLogging = false) override;</span>
<a href="#l4.647"></a><span id="l4.647"> </span>
<a href="#l4.648"></a><span id="l4.648">   // state ported over from 4.5</span>
<a href="#l4.649"></a><span id="l4.649">   bool m_pseudoInterrupted;</span>
<a href="#l4.650"></a><span id="l4.650">   bool m_active;</span>
<a href="#l4.651"></a><span id="l4.651">   bool m_folderNeedsSubscribing;</span>
<a href="#l4.652"></a><span id="l4.652">   bool m_folderNeedsACLRefreshed;</span>
<a href="#l4.653"></a><span id="l4.653"> </span>
<a href="#l4.654"></a><span id="l4.654">   bool m_threadShouldDie;</span>
<a href="#l4.655"></a><span id="l4.655"> </span>
<a href="#l4.656"></a><span id="l4.656">   // use to prevent re-entering TellThreadToDie.</span>
<a href="#l4.657"></a><span id="l4.657">   bool m_inThreadShouldDie;</span>
<a href="#l4.658"></a><span id="l4.658">   // if the UI thread has signalled the IMAP thread to die, and the</span>
<a href="#l4.659"></a><span id="l4.659">   // connection has timed out, this will be set to FALSE.</span>
<a href="#l4.660"></a><span id="l4.660">   bool m_safeToCloseConnection;</span>
<a href="#l4.661"></a><span id="l4.661"> </span>
<a href="#l4.662"></a><span id="l4.662">   RefPtr&lt;nsImapFlagAndUidState&gt; m_flagState;</span>
<a href="#l4.663"></a><span id="l4.663" class="difflineminus">-  nsMsgBiffState        m_currentBiffState;</span>
<a href="#l4.664"></a><span id="l4.664" class="difflineplus">+  nsMsgBiffState m_currentBiffState;</span>
<a href="#l4.665"></a><span id="l4.665">   // manage the IMAP server command tags</span>
<a href="#l4.666"></a><span id="l4.666" class="difflineminus">-  // 11 = enough memory for the decimal representation of MAX_UINT + trailing nul</span>
<a href="#l4.667"></a><span id="l4.667" class="difflineplus">+  // 11 = enough memory for the decimal representation of MAX_UINT + trailing</span>
<a href="#l4.668"></a><span id="l4.668" class="difflineplus">+  // nul</span>
<a href="#l4.669"></a><span id="l4.669">   char m_currentServerCommandTag[11];</span>
<a href="#l4.670"></a><span id="l4.670">   uint32_t m_currentServerCommandTagNumber;</span>
<a href="#l4.671"></a><span id="l4.671">   void IncrementCommandTagNumber();</span>
<a href="#l4.672"></a><span id="l4.672">   const char *GetServerCommandTag();</span>
<a href="#l4.673"></a><span id="l4.673"> </span>
<a href="#l4.674"></a><span id="l4.674">   void StartTLS();</span>
<a href="#l4.675"></a><span id="l4.675"> </span>
<a href="#l4.676"></a><span id="l4.676">   // login related methods.</span>
<a href="#l4.677"></a><span id="l4.677">   nsresult GetPassword(nsString &amp;password, bool aNewPasswordRequested);</span>
<a href="#l4.678"></a><span id="l4.678">   void InitPrefAuthMethods(int32_t authMethodPrefValue,</span>
<a href="#l4.679"></a><span id="l4.679">                            nsIMsgIncomingServer *aServer);</span>
<a href="#l4.680"></a><span id="l4.680">   nsresult ChooseAuthMethod();</span>
<a href="#l4.681"></a><span id="l4.681">   void MarkAuthMethodAsFailed(eIMAPCapabilityFlags failedAuthMethod);</span>
<a href="#l4.682"></a><span id="l4.682">   void ResetAuthMethods();</span>
<a href="#l4.683"></a><span id="l4.683"> </span>
<a href="#l4.684"></a><span id="l4.684">   // All of these methods actually issue protocol</span>
<a href="#l4.685"></a><span id="l4.685" class="difflineminus">-  void Capability(); // query host for capabilities.</span>
<a href="#l4.686"></a><span id="l4.686" class="difflineminus">-  void ID(); // send RFC 2971 app info to server</span>
<a href="#l4.687"></a><span id="l4.687" class="difflineplus">+  void Capability();  // query host for capabilities.</span>
<a href="#l4.688"></a><span id="l4.688" class="difflineplus">+  void ID();          // send RFC 2971 app info to server</span>
<a href="#l4.689"></a><span id="l4.689">   void EnableCondStore();</span>
<a href="#l4.690"></a><span id="l4.690">   void StartCompressDeflate();</span>
<a href="#l4.691"></a><span id="l4.691">   nsresult BeginCompressing();</span>
<a href="#l4.692"></a><span id="l4.692" class="difflineminus">-  void Language(); // set the language on the server if it supports it</span>
<a href="#l4.693"></a><span id="l4.693" class="difflineplus">+  void Language();  // set the language on the server if it supports it</span>
<a href="#l4.694"></a><span id="l4.694">   void Namespace();</span>
<a href="#l4.695"></a><span id="l4.695">   void InsecureLogin(const char *userName, const nsCString &amp;password);</span>
<a href="#l4.696"></a><span id="l4.696" class="difflineminus">-  nsresult AuthLogin(const char *userName, const nsString &amp;password, eIMAPCapabilityFlag flag);</span>
<a href="#l4.697"></a><span id="l4.697" class="difflineminus">-  nsresult SendDataParseIMAPandCheckForNewMail(const char *data, const char *command);</span>
<a href="#l4.698"></a><span id="l4.698" class="difflineplus">+  nsresult AuthLogin(const char *userName, const nsString &amp;password,</span>
<a href="#l4.699"></a><span id="l4.699" class="difflineplus">+                     eIMAPCapabilityFlag flag);</span>
<a href="#l4.700"></a><span id="l4.700" class="difflineplus">+  nsresult SendDataParseIMAPandCheckForNewMail(const char *data,</span>
<a href="#l4.701"></a><span id="l4.701" class="difflineplus">+                                               const char *command);</span>
<a href="#l4.702"></a><span id="l4.702">   void ProcessAuthenticatedStateURL();</span>
<a href="#l4.703"></a><span id="l4.703">   void ProcessAfterAuthenticated();</span>
<a href="#l4.704"></a><span id="l4.704">   void ProcessSelectedStateURL();</span>
<a href="#l4.705"></a><span id="l4.705">   bool TryToLogon();</span>
<a href="#l4.706"></a><span id="l4.706"> </span>
<a href="#l4.707"></a><span id="l4.707" class="difflineminus">-  // Process Authenticated State Url used to be one giant if statement. I've broken out a set of actions</span>
<a href="#l4.708"></a><span id="l4.708" class="difflineminus">-  // based on the imap action passed into the url. The following functions are imap protocol handlers for</span>
<a href="#l4.709"></a><span id="l4.709" class="difflineminus">-  // each action. They are called by ProcessAuthenticatedStateUrl.</span>
<a href="#l4.710"></a><span id="l4.710" class="difflineplus">+  // Process Authenticated State Url used to be one giant if statement. I've</span>
<a href="#l4.711"></a><span id="l4.711" class="difflineplus">+  // broken out a set of actions based on the imap action passed into the url.</span>
<a href="#l4.712"></a><span id="l4.712" class="difflineplus">+  // The following functions are imap protocol handlers for each action. They</span>
<a href="#l4.713"></a><span id="l4.713" class="difflineplus">+  // are called by ProcessAuthenticatedStateUrl.</span>
<a href="#l4.714"></a><span id="l4.714">   void OnLSubFolders();</span>
<a href="#l4.715"></a><span id="l4.715">   void OnAppendMsgFromFile();</span>
<a href="#l4.716"></a><span id="l4.716"> </span>
<a href="#l4.717"></a><span id="l4.717" class="difflineminus">-  char *GetFolderPathString(); // OK to call from UI thread</span>
<a href="#l4.718"></a><span id="l4.718" class="difflineplus">+  char *GetFolderPathString();  // OK to call from UI thread</span>
<a href="#l4.719"></a><span id="l4.719"> </span>
<a href="#l4.720"></a><span id="l4.720" class="difflineminus">-  char * OnCreateServerSourceFolderPathString();</span>
<a href="#l4.721"></a><span id="l4.721" class="difflineminus">-  char * OnCreateServerDestinationFolderPathString();</span>
<a href="#l4.722"></a><span id="l4.722" class="difflineplus">+  char *OnCreateServerSourceFolderPathString();</span>
<a href="#l4.723"></a><span id="l4.723" class="difflineplus">+  char *OnCreateServerDestinationFolderPathString();</span>
<a href="#l4.724"></a><span id="l4.724">   nsresult CreateServerSourceFolderPathString(char **result);</span>
<a href="#l4.725"></a><span id="l4.725" class="difflineminus">-  void OnCreateFolder(const char * aSourceMailbox);</span>
<a href="#l4.726"></a><span id="l4.726" class="difflineminus">-  void OnEnsureExistsFolder(const char * aSourceMailbox);</span>
<a href="#l4.727"></a><span id="l4.727" class="difflineminus">-  void OnSubscribe(const char * aSourceMailbox);</span>
<a href="#l4.728"></a><span id="l4.728" class="difflineminus">-  void OnUnsubscribe(const char * aSourceMailbox);</span>
<a href="#l4.729"></a><span id="l4.729" class="difflineminus">-  void RefreshACLForFolderIfNecessary(const char * mailboxName);</span>
<a href="#l4.730"></a><span id="l4.730" class="difflineminus">-  void RefreshACLForFolder(const char * aSourceMailbox);</span>
<a href="#l4.731"></a><span id="l4.731" class="difflineplus">+  void OnCreateFolder(const char *aSourceMailbox);</span>
<a href="#l4.732"></a><span id="l4.732" class="difflineplus">+  void OnEnsureExistsFolder(const char *aSourceMailbox);</span>
<a href="#l4.733"></a><span id="l4.733" class="difflineplus">+  void OnSubscribe(const char *aSourceMailbox);</span>
<a href="#l4.734"></a><span id="l4.734" class="difflineplus">+  void OnUnsubscribe(const char *aSourceMailbox);</span>
<a href="#l4.735"></a><span id="l4.735" class="difflineplus">+  void RefreshACLForFolderIfNecessary(const char *mailboxName);</span>
<a href="#l4.736"></a><span id="l4.736" class="difflineplus">+  void RefreshACLForFolder(const char *aSourceMailbox);</span>
<a href="#l4.737"></a><span id="l4.737">   void GetACLForFolder(const char *aMailboxName);</span>
<a href="#l4.738"></a><span id="l4.738">   void OnRefreshAllACLs();</span>
<a href="#l4.739"></a><span id="l4.739" class="difflineminus">-  void OnListFolder(const char * aSourceMailbox, bool aBool);</span>
<a href="#l4.740"></a><span id="l4.740" class="difflineminus">-  void OnStatusForFolder(const char * sourceMailbox);</span>
<a href="#l4.741"></a><span id="l4.741" class="difflineminus">-  void OnDeleteFolder(const char * aSourceMailbox);</span>
<a href="#l4.742"></a><span id="l4.742" class="difflineminus">-  void OnRenameFolder(const char * aSourceMailbox);</span>
<a href="#l4.743"></a><span id="l4.743" class="difflineminus">-  void OnMoveFolderHierarchy(const char * aSourceMailbox);</span>
<a href="#l4.744"></a><span id="l4.744" class="difflineminus">-  void DeleteFolderAndMsgs(const char * aSourceMailbox);</span>
<a href="#l4.745"></a><span id="l4.745" class="difflineplus">+  void OnListFolder(const char *aSourceMailbox, bool aBool);</span>
<a href="#l4.746"></a><span id="l4.746" class="difflineplus">+  void OnStatusForFolder(const char *sourceMailbox);</span>
<a href="#l4.747"></a><span id="l4.747" class="difflineplus">+  void OnDeleteFolder(const char *aSourceMailbox);</span>
<a href="#l4.748"></a><span id="l4.748" class="difflineplus">+  void OnRenameFolder(const char *aSourceMailbox);</span>
<a href="#l4.749"></a><span id="l4.749" class="difflineplus">+  void OnMoveFolderHierarchy(const char *aSourceMailbox);</span>
<a href="#l4.750"></a><span id="l4.750" class="difflineplus">+  void DeleteFolderAndMsgs(const char *aSourceMailbox);</span>
<a href="#l4.751"></a><span id="l4.751">   void RemoveMsgsAndExpunge();</span>
<a href="#l4.752"></a><span id="l4.752">   void FindMailboxesIfNecessary();</span>
<a href="#l4.753"></a><span id="l4.753">   void CreateMailbox(const char *mailboxName);</span>
<a href="#l4.754"></a><span id="l4.754">   void DeleteMailbox(const char *mailboxName);</span>
<a href="#l4.755"></a><span id="l4.755">   void RenameMailbox(const char *existingName, const char *newName);</span>
<a href="#l4.756"></a><span id="l4.756">   void RemoveHierarchyDelimiter(nsCString &amp;mailboxName);</span>
<a href="#l4.757"></a><span id="l4.757">   bool CreateMailboxRespectingSubscriptions(const char *mailboxName);</span>
<a href="#l4.758"></a><span id="l4.758">   bool DeleteMailboxRespectingSubscriptions(const char *mailboxName);</span>
<a href="#l4.759"></a><span id="l4.759" class="difflineminus">-  bool    RenameMailboxRespectingSubscriptions(const char *existingName,</span>
<a href="#l4.760"></a><span id="l4.760" class="difflineminus">-    const char *newName,</span>
<a href="#l4.761"></a><span id="l4.761" class="difflineminus">-    bool reallyRename);</span>
<a href="#l4.762"></a><span id="l4.762" class="difflineplus">+  bool RenameMailboxRespectingSubscriptions(const char *existingName,</span>
<a href="#l4.763"></a><span id="l4.763" class="difflineplus">+                                            const char *newName,</span>
<a href="#l4.764"></a><span id="l4.764" class="difflineplus">+                                            bool reallyRename);</span>
<a href="#l4.765"></a><span id="l4.765">   // notify the fe that a folder was deleted</span>
<a href="#l4.766"></a><span id="l4.766">   void FolderDeleted(const char *mailboxName);</span>
<a href="#l4.767"></a><span id="l4.767">   // notify the fe that a folder creation failed</span>
<a href="#l4.768"></a><span id="l4.768">   void FolderNotCreated(const char *mailboxName);</span>
<a href="#l4.769"></a><span id="l4.769">   // notify the fe that a folder was deleted</span>
<a href="#l4.770"></a><span id="l4.770" class="difflineminus">-  void FolderRenamed(const char *oldName,</span>
<a href="#l4.771"></a><span id="l4.771" class="difflineminus">-    const char *newName);</span>
<a href="#l4.772"></a><span id="l4.772" class="difflineplus">+  void FolderRenamed(const char *oldName, const char *newName);</span>
<a href="#l4.773"></a><span id="l4.773"> </span>
<a href="#l4.774"></a><span id="l4.774">   bool FolderIsSelected(const char *mailboxName);</span>
<a href="#l4.775"></a><span id="l4.775"> </span>
<a href="#l4.776"></a><span id="l4.776" class="difflineminus">-  bool    MailboxIsNoSelectMailbox(const char *mailboxName);</span>
<a href="#l4.777"></a><span id="l4.777" class="difflineplus">+  bool MailboxIsNoSelectMailbox(const char *mailboxName);</span>
<a href="#l4.778"></a><span id="l4.778">   bool FolderNeedsACLInitialized(const char *folderName);</span>
<a href="#l4.779"></a><span id="l4.779">   void DiscoverMailboxList();</span>
<a href="#l4.780"></a><span id="l4.780">   void DiscoverAllAndSubscribedBoxes();</span>
<a href="#l4.781"></a><span id="l4.781">   void MailboxDiscoveryFinished();</span>
<a href="#l4.782"></a><span id="l4.782">   void NthLevelChildList(const char *onlineMailboxPrefix, int32_t depth);</span>
<a href="#l4.783"></a><span id="l4.783">   // LIST SUBSCRIBED command (from RFC 5258) crashes some servers. so we need to</span>
<a href="#l4.784"></a><span id="l4.784">   // identify those servers</span>
<a href="#l4.785"></a><span id="l4.785">   bool GetListSubscribedIsBrokenOnServer();</span>
<a href="#l4.786"></a><span id="l4.786">   bool IsExtraSelectNeeded();</span>
<a href="#l4.787"></a><span id="l4.787">   void Lsub(const char *mailboxPattern, bool addDirectoryIfNecessary);</span>
<a href="#l4.788"></a><span id="l4.788">   void List(const char *mailboxPattern, bool addDirectoryIfNecessary,</span>
<a href="#l4.789"></a><span id="l4.789">             bool useXLIST = false);</span>
<a href="#l4.790"></a><span id="l4.790">   void Subscribe(const char *mailboxName);</span>
<a href="#l4.791"></a><span id="l4.791">   void Unsubscribe(const char *mailboxName);</span>
<a href="#l4.792"></a><span id="l4.792">   void Idle();</span>
<a href="#l4.793"></a><span id="l4.793">   void EndIdle(bool waitForResponse = true);</span>
<a href="#l4.794"></a><span id="l4.794" class="difflineminus">-  // Some imap servers include the mailboxName following the dir-separator in the list of</span>
<a href="#l4.795"></a><span id="l4.795" class="difflineminus">-  // subfolders of the mailboxName. In fact, they are the same. So we should decide if</span>
<a href="#l4.796"></a><span id="l4.796" class="difflineminus">-  // we should delete such subfolder and provide feedback if the delete operation succeed.</span>
<a href="#l4.797"></a><span id="l4.797" class="difflineminus">-  bool DeleteSubFolders(const char* aMailboxName, bool &amp; aDeleteSelf);</span>
<a href="#l4.798"></a><span id="l4.798" class="difflineminus">-  bool    RenameHierarchyByHand(const char *oldParentMailboxName,</span>
<a href="#l4.799"></a><span id="l4.799" class="difflineminus">-    const char *newParentMailboxName);</span>
<a href="#l4.800"></a><span id="l4.800" class="difflineplus">+  // Some imap servers include the mailboxName following the dir-separator in</span>
<a href="#l4.801"></a><span id="l4.801" class="difflineplus">+  // the list of subfolders of the mailboxName. In fact, they are the same. So</span>
<a href="#l4.802"></a><span id="l4.802" class="difflineplus">+  // we should decide if we should delete such subfolder and provide feedback if</span>
<a href="#l4.803"></a><span id="l4.803" class="difflineplus">+  // the delete operation succeed.</span>
<a href="#l4.804"></a><span id="l4.804" class="difflineplus">+  bool DeleteSubFolders(const char *aMailboxName, bool &amp;aDeleteSelf);</span>
<a href="#l4.805"></a><span id="l4.805" class="difflineplus">+  bool RenameHierarchyByHand(const char *oldParentMailboxName,</span>
<a href="#l4.806"></a><span id="l4.806" class="difflineplus">+                             const char *newParentMailboxName);</span>
<a href="#l4.807"></a><span id="l4.807">   bool RetryUrl();</span>
<a href="#l4.808"></a><span id="l4.808"> </span>
<a href="#l4.809"></a><span id="l4.809">   nsresult GlobalInitialization(nsIPrefBranch *aPrefBranch);</span>
<a href="#l4.810"></a><span id="l4.810">   nsresult Configure(int32_t TooFastTime, int32_t IdealTime,</span>
<a href="#l4.811"></a><span id="l4.811" class="difflineminus">-    int32_t ChunkAddSize, int32_t ChunkSize, int32_t ChunkThreshold,</span>
<a href="#l4.812"></a><span id="l4.812" class="difflineminus">-    bool FetchByChunks);</span>
<a href="#l4.813"></a><span id="l4.813" class="difflineminus">-  nsresult GetMsgWindow(nsIMsgWindow ** aMsgWindow);</span>
<a href="#l4.814"></a><span id="l4.814" class="difflineplus">+                     int32_t ChunkAddSize, int32_t ChunkSize,</span>
<a href="#l4.815"></a><span id="l4.815" class="difflineplus">+                     int32_t ChunkThreshold, bool FetchByChunks);</span>
<a href="#l4.816"></a><span id="l4.816" class="difflineplus">+  nsresult GetMsgWindow(nsIMsgWindow **aMsgWindow);</span>
<a href="#l4.817"></a><span id="l4.817">   // End Process AuthenticatedState Url helper methods</span>
<a href="#l4.818"></a><span id="l4.818"> </span>
<a href="#l4.819"></a><span id="l4.819" class="difflineminus">-  virtual char const *GetType() override {return &quot;imap&quot;;}</span>
<a href="#l4.820"></a><span id="l4.820" class="difflineplus">+  virtual char const *GetType() override { return &quot;imap&quot;; }</span>
<a href="#l4.821"></a><span id="l4.821"> </span>
<a href="#l4.822"></a><span id="l4.822">   // Quota support</span>
<a href="#l4.823"></a><span id="l4.823">   void GetQuotaDataIfSupported(const char *aBoxName);</span>
<a href="#l4.824"></a><span id="l4.824"> </span>
<a href="#l4.825"></a><span id="l4.825" class="difflineminus">-  // CondStore support - true if server supports it, and the user hasn't disabled it.</span>
<a href="#l4.826"></a><span id="l4.826" class="difflineplus">+  // CondStore support - true if server supports it, and the user hasn't</span>
<a href="#l4.827"></a><span id="l4.827" class="difflineplus">+  // disabled it.</span>
<a href="#l4.828"></a><span id="l4.828">   bool UseCondStore();</span>
<a href="#l4.829"></a><span id="l4.829">   // false if pref &quot;mail.server.serverxxx.use_condstore&quot; is false;</span>
<a href="#l4.830"></a><span id="l4.830">   bool m_useCondStore;</span>
<a href="#l4.831"></a><span id="l4.831" class="difflineminus">-  // COMPRESS=DEFLATE support - true if server supports it, and the user hasn't disabled it.</span>
<a href="#l4.832"></a><span id="l4.832" class="difflineplus">+  // COMPRESS=DEFLATE support - true if server supports it, and the user hasn't</span>
<a href="#l4.833"></a><span id="l4.833" class="difflineplus">+  // disabled it.</span>
<a href="#l4.834"></a><span id="l4.834">   bool UseCompressDeflate();</span>
<a href="#l4.835"></a><span id="l4.835">   // false if pref &quot;mail.server.serverxxx.use_compress_deflate&quot; is false;</span>
<a href="#l4.836"></a><span id="l4.836">   bool m_useCompressDeflate;</span>
<a href="#l4.837"></a><span id="l4.837">   // these come from the nsIDBFolderInfo in the msgDatabase and</span>
<a href="#l4.838"></a><span id="l4.838">   // are initialized in nsImapProtocol::SetupWithUrl.</span>
<a href="#l4.839"></a><span id="l4.839">   uint64_t mFolderLastModSeq;</span>
<a href="#l4.840"></a><span id="l4.840">   int32_t mFolderTotalMsgCount;</span>
<a href="#l4.841"></a><span id="l4.841">   uint32_t mFolderHighestUID;</span>
<a href="#l4.842"></a><span id="l4.842">   uint32_t mFolderNumDeleted;</span>
<a href="#l4.843"></a><span id="l4.843"> </span>
<a href="#l4.844"></a><span id="l4.844">   bool m_isGmailServer;</span>
<a href="#l4.845"></a><span id="l4.845">   nsTArray&lt;nsCString&gt; mCustomDBHeaders;</span>
<a href="#l4.846"></a><span id="l4.846">   nsTArray&lt;nsCString&gt; mCustomHeaders;</span>
<a href="#l4.847"></a><span id="l4.847" class="difflineminus">-  bool    m_trackingTime;</span>
<a href="#l4.848"></a><span id="l4.848" class="difflineminus">-  PRTime  m_startTime;</span>
<a href="#l4.849"></a><span id="l4.849" class="difflineminus">-  PRTime  m_endTime;</span>
<a href="#l4.850"></a><span id="l4.850" class="difflineminus">-  PRTime  m_lastActiveTime;</span>
<a href="#l4.851"></a><span id="l4.851" class="difflineplus">+  bool m_trackingTime;</span>
<a href="#l4.852"></a><span id="l4.852" class="difflineplus">+  PRTime m_startTime;</span>
<a href="#l4.853"></a><span id="l4.853" class="difflineplus">+  PRTime m_endTime;</span>
<a href="#l4.854"></a><span id="l4.854" class="difflineplus">+  PRTime m_lastActiveTime;</span>
<a href="#l4.855"></a><span id="l4.855">   int32_t m_tooFastTime;</span>
<a href="#l4.856"></a><span id="l4.856">   int32_t m_idealTime;</span>
<a href="#l4.857"></a><span id="l4.857">   int32_t m_chunkAddSize;</span>
<a href="#l4.858"></a><span id="l4.858">   int32_t m_chunkStartSize;</span>
<a href="#l4.859"></a><span id="l4.859" class="difflineminus">-  bool    m_fetchByChunks;</span>
<a href="#l4.860"></a><span id="l4.860" class="difflineminus">-  bool    m_sendID;</span>
<a href="#l4.861"></a><span id="l4.861" class="difflineplus">+  bool m_fetchByChunks;</span>
<a href="#l4.862"></a><span id="l4.862" class="difflineplus">+  bool m_sendID;</span>
<a href="#l4.863"></a><span id="l4.863">   int32_t m_curFetchSize;</span>
<a href="#l4.864"></a><span id="l4.864" class="difflineminus">-  bool    m_ignoreExpunges;</span>
<a href="#l4.865"></a><span id="l4.865" class="difflineminus">-  eIMAPCapabilityFlags m_prefAuthMethods; // set of capability flags (in nsImapCore.h) for auth methods</span>
<a href="#l4.866"></a><span id="l4.866" class="difflineminus">-  eIMAPCapabilityFlags m_failedAuthMethods; // ditto</span>
<a href="#l4.867"></a><span id="l4.867" class="difflineminus">-  eIMAPCapabilityFlag m_currentAuthMethod; // exactly one capability flag, or 0</span>
<a href="#l4.868"></a><span id="l4.868" class="difflineplus">+  bool m_ignoreExpunges;</span>
<a href="#l4.869"></a><span id="l4.869" class="difflineplus">+  eIMAPCapabilityFlags m_prefAuthMethods;    // set of capability flags (in</span>
<a href="#l4.870"></a><span id="l4.870" class="difflineplus">+                                             // nsImapCore.h) for auth methods</span>
<a href="#l4.871"></a><span id="l4.871" class="difflineplus">+  eIMAPCapabilityFlags m_failedAuthMethods;  // ditto</span>
<a href="#l4.872"></a><span id="l4.872" class="difflineplus">+  eIMAPCapabilityFlag m_currentAuthMethod;  // exactly one capability flag, or 0</span>
<a href="#l4.873"></a><span id="l4.873">   int32_t m_socketType;</span>
<a href="#l4.874"></a><span id="l4.874">   int32_t m_chunkSize;</span>
<a href="#l4.875"></a><span id="l4.875">   int32_t m_chunkThreshold;</span>
<a href="#l4.876"></a><span id="l4.876">   RefPtr&lt;nsMsgImapLineDownloadCache&gt; m_downloadLineCache;</span>
<a href="#l4.877"></a><span id="l4.877">   RefPtr&lt;nsMsgImapHdrXferInfo&gt; m_hdrDownloadCache;</span>
<a href="#l4.878"></a><span id="l4.878" class="difflineminus">-  nsCOMPtr &lt;nsIImapHeaderInfo&gt; m_curHdrInfo;</span>
<a href="#l4.879"></a><span id="l4.879" class="difflineplus">+  nsCOMPtr&lt;nsIImapHeaderInfo&gt; m_curHdrInfo;</span>
<a href="#l4.880"></a><span id="l4.880">   // mapping between mailboxes and the corresponding folder flags</span>
<a href="#l4.881"></a><span id="l4.881">   nsDataHashtable&lt;nsCStringHashKey, int32_t&gt; m_standardListMailboxes;</span>
<a href="#l4.882"></a><span id="l4.882">   // mapping between special xlist mailboxes and the corresponding folder flags</span>
<a href="#l4.883"></a><span id="l4.883">   nsDataHashtable&lt;nsCStringHashKey, int32_t&gt; m_specialXListMailboxes;</span>
<a href="#l4.884"></a><span id="l4.884"> </span>
<a href="#l4.885"></a><span id="l4.885" class="difflineminus">-</span>
<a href="#l4.886"></a><span id="l4.886">   nsCOMPtr&lt;nsIImapHostSessionList&gt; m_hostSessionList;</span>
<a href="#l4.887"></a><span id="l4.887"> </span>
<a href="#l4.888"></a><span id="l4.888">   bool m_fromHeaderSeen;</span>
<a href="#l4.889"></a><span id="l4.889"> </span>
<a href="#l4.890"></a><span id="l4.890">   nsString mAcceptLanguages;</span>
<a href="#l4.891"></a><span id="l4.891"> </span>
<a href="#l4.892"></a><span id="l4.892">   // progress stuff</span>
<a href="#l4.893"></a><span id="l4.893">   void SetProgressString(uint32_t aStringIndex);</span>
<a href="#l4.894"></a><span id="l4.894"> </span>
<a href="#l4.895"></a><span id="l4.895" class="difflineminus">-  nsCString     m_progressStringName;</span>
<a href="#l4.896"></a><span id="l4.896" class="difflineminus">-  uint32_t      m_stringIndex;</span>
<a href="#l4.897"></a><span id="l4.897" class="difflineminus">-  int32_t       m_progressCurrentNumber[IMAP_NUMBER_OF_PROGRESS_STRINGS];</span>
<a href="#l4.898"></a><span id="l4.898" class="difflineminus">-  int32_t       m_progressExpectedNumber;</span>
<a href="#l4.899"></a><span id="l4.899" class="difflineminus">-  nsCString     m_lastProgressStringName;</span>
<a href="#l4.900"></a><span id="l4.900" class="difflineminus">-  int32_t       m_lastPercent;</span>
<a href="#l4.901"></a><span id="l4.901" class="difflineminus">-  int64_t       m_lastProgressTime;</span>
<a href="#l4.902"></a><span id="l4.902" class="difflineplus">+  nsCString m_progressStringName;</span>
<a href="#l4.903"></a><span id="l4.903" class="difflineplus">+  uint32_t m_stringIndex;</span>
<a href="#l4.904"></a><span id="l4.904" class="difflineplus">+  int32_t m_progressCurrentNumber[IMAP_NUMBER_OF_PROGRESS_STRINGS];</span>
<a href="#l4.905"></a><span id="l4.905" class="difflineplus">+  int32_t m_progressExpectedNumber;</span>
<a href="#l4.906"></a><span id="l4.906" class="difflineplus">+  nsCString m_lastProgressStringName;</span>
<a href="#l4.907"></a><span id="l4.907" class="difflineplus">+  int32_t m_lastPercent;</span>
<a href="#l4.908"></a><span id="l4.908" class="difflineplus">+  int64_t m_lastProgressTime;</span>
<a href="#l4.909"></a><span id="l4.909">   nsCOMPtr&lt;nsIStringBundle&gt; m_bundle;</span>
<a href="#l4.910"></a><span id="l4.910"> </span>
<a href="#l4.911"></a><span id="l4.911">   bool m_notifySearchHit;</span>
<a href="#l4.912"></a><span id="l4.912">   bool m_needNoop;</span>
<a href="#l4.913"></a><span id="l4.913">   bool m_idle;</span>
<a href="#l4.914"></a><span id="l4.914">   bool m_useIdle;</span>
<a href="#l4.915"></a><span id="l4.915">   int32_t m_noopCount;</span>
<a href="#l4.916"></a><span id="l4.916" class="difflineminus">-  bool    m_autoSubscribe, m_autoUnsubscribe, m_autoSubscribeOnOpen;</span>
<a href="#l4.917"></a><span id="l4.917" class="difflineplus">+  bool m_autoSubscribe, m_autoUnsubscribe, m_autoSubscribeOnOpen;</span>
<a href="#l4.918"></a><span id="l4.918">   bool m_closeNeededBeforeSelect;</span>
<a href="#l4.919"></a><span id="l4.919">   bool m_retryUrlOnError;</span>
<a href="#l4.920"></a><span id="l4.920">   bool m_preferPlainText;</span>
<a href="#l4.921"></a><span id="l4.921">   nsCString m_forceSelectValue;</span>
<a href="#l4.922"></a><span id="l4.922">   bool m_forceSelect;</span>
<a href="#l4.923"></a><span id="l4.923"> </span>
<a href="#l4.924"></a><span id="l4.924" class="difflineminus">-  int32_t m_uidValidity; // stored uid validity for the selected folder.</span>
<a href="#l4.925"></a><span id="l4.925" class="difflineplus">+  int32_t m_uidValidity;  // stored uid validity for the selected folder.</span>
<a href="#l4.926"></a><span id="l4.926"> </span>
<a href="#l4.927"></a><span id="l4.927">   enum EMailboxHierarchyNameState {</span>
<a href="#l4.928"></a><span id="l4.928" class="difflineminus">-      kNoOperationInProgress,</span>
<a href="#l4.929"></a><span id="l4.929" class="difflineminus">-      // kDiscoverBaseFolderInProgress, - Unused. Keeping for historical reasons.</span>
<a href="#l4.930"></a><span id="l4.930" class="difflineminus">-      kDiscoverTrashFolderInProgress,</span>
<a href="#l4.931"></a><span id="l4.931" class="difflineminus">-      kDeleteSubFoldersInProgress,</span>
<a href="#l4.932"></a><span id="l4.932" class="difflineminus">-      kListingForInfoOnly,</span>
<a href="#l4.933"></a><span id="l4.933" class="difflineminus">-      kListingForInfoAndDiscovery,</span>
<a href="#l4.934"></a><span id="l4.934" class="difflineminus">-      kDiscoveringNamespacesOnly,</span>
<a href="#l4.935"></a><span id="l4.935" class="difflineminus">-      kXListing,</span>
<a href="#l4.936"></a><span id="l4.936" class="difflineminus">-      kListingForFolderFlags,</span>
<a href="#l4.937"></a><span id="l4.937" class="difflineminus">-      kListingForCreate</span>
<a href="#l4.938"></a><span id="l4.938" class="difflineplus">+    kNoOperationInProgress,</span>
<a href="#l4.939"></a><span id="l4.939" class="difflineplus">+    // kDiscoverBaseFolderInProgress, - Unused. Keeping for historical reasons.</span>
<a href="#l4.940"></a><span id="l4.940" class="difflineplus">+    kDiscoverTrashFolderInProgress,</span>
<a href="#l4.941"></a><span id="l4.941" class="difflineplus">+    kDeleteSubFoldersInProgress,</span>
<a href="#l4.942"></a><span id="l4.942" class="difflineplus">+    kListingForInfoOnly,</span>
<a href="#l4.943"></a><span id="l4.943" class="difflineplus">+    kListingForInfoAndDiscovery,</span>
<a href="#l4.944"></a><span id="l4.944" class="difflineplus">+    kDiscoveringNamespacesOnly,</span>
<a href="#l4.945"></a><span id="l4.945" class="difflineplus">+    kXListing,</span>
<a href="#l4.946"></a><span id="l4.946" class="difflineplus">+    kListingForFolderFlags,</span>
<a href="#l4.947"></a><span id="l4.947" class="difflineplus">+    kListingForCreate</span>
<a href="#l4.948"></a><span id="l4.948">   };</span>
<a href="#l4.949"></a><span id="l4.949" class="difflineminus">-  EMailboxHierarchyNameState  m_hierarchyNameState;</span>
<a href="#l4.950"></a><span id="l4.950" class="difflineminus">-  EMailboxDiscoverStatus      m_discoveryStatus;</span>
<a href="#l4.951"></a><span id="l4.951" class="difflineminus">-  nsTArray&lt;nsIMAPMailboxInfo*&gt; m_listedMailboxList;</span>
<a href="#l4.952"></a><span id="l4.952" class="difflineminus">-  nsTArray&lt;char*&gt; *            m_deletableChildren;</span>
<a href="#l4.953"></a><span id="l4.953" class="difflineminus">-  uint32_t                    m_flagChangeCount;</span>
<a href="#l4.954"></a><span id="l4.954" class="difflineminus">-  PRTime                      m_lastCheckTime;</span>
<a href="#l4.955"></a><span id="l4.955" class="difflineplus">+  EMailboxHierarchyNameState m_hierarchyNameState;</span>
<a href="#l4.956"></a><span id="l4.956" class="difflineplus">+  EMailboxDiscoverStatus m_discoveryStatus;</span>
<a href="#l4.957"></a><span id="l4.957" class="difflineplus">+  nsTArray&lt;nsIMAPMailboxInfo *&gt; m_listedMailboxList;</span>
<a href="#l4.958"></a><span id="l4.958" class="difflineplus">+  nsTArray&lt;char *&gt; *m_deletableChildren;</span>
<a href="#l4.959"></a><span id="l4.959" class="difflineplus">+  uint32_t m_flagChangeCount;</span>
<a href="#l4.960"></a><span id="l4.960" class="difflineplus">+  PRTime m_lastCheckTime;</span>
<a href="#l4.961"></a><span id="l4.961"> </span>
<a href="#l4.962"></a><span id="l4.962">   bool CheckNeeded();</span>
<a href="#l4.963"></a><span id="l4.963"> </span>
<a href="#l4.964"></a><span id="l4.964">   nsString m_emptyMimePartString;</span>
<a href="#l4.965"></a><span id="l4.965"> </span>
<a href="#l4.966"></a><span id="l4.966">   RefPtr&lt;mozilla::mailnews::OAuth2ThreadHelper&gt; mOAuth2Support;</span>
<a href="#l4.967"></a><span id="l4.967"> };</span>
<a href="#l4.968"></a><span id="l4.968"> </span>
<a href="#l4.969"></a><span id="l4.969" class="difflineminus">-// This small class is a &quot;mock&quot; channel because it is a mockery of the imap channel's implementation...</span>
<a href="#l4.970"></a><span id="l4.970" class="difflineminus">-// it's a light weight channel that we can return to necko when they ask for a channel on a url before</span>
<a href="#l4.971"></a><span id="l4.971" class="difflineminus">-// we actually have an imap protocol instance around which can run the url. Please see my comments in</span>
<a href="#l4.972"></a><span id="l4.972" class="difflineplus">+// This small class is a &quot;mock&quot; channel because it is a mockery of the imap</span>
<a href="#l4.973"></a><span id="l4.973" class="difflineplus">+// channel's implementation... it's a light weight channel that we can return to</span>
<a href="#l4.974"></a><span id="l4.974" class="difflineplus">+// necko when they ask for a channel on a url before we actually have an imap</span>
<a href="#l4.975"></a><span id="l4.975" class="difflineplus">+// protocol instance around which can run the url. Please see my comments in</span>
<a href="#l4.976"></a><span id="l4.976"> // nsIImapMockChannel.idl for more details..</span>
<a href="#l4.977"></a><span id="l4.977"> //</span>
<a href="#l4.978"></a><span id="l4.978"> // Threading concern: This class lives entirely in the UI thread.</span>
<a href="#l4.979"></a><span id="l4.979"> </span>
<a href="#l4.980"></a><span id="l4.980"> class nsICacheEntry;</span>
<a href="#l4.981"></a><span id="l4.981"> </span>
<a href="#l4.982"></a><span id="l4.982" class="difflineminus">-class nsImapMockChannel : public nsIImapMockChannel</span>
<a href="#l4.983"></a><span id="l4.983" class="difflineminus">-                        , public nsICacheEntryOpenCallback</span>
<a href="#l4.984"></a><span id="l4.984" class="difflineminus">-                        , public nsITransportEventSink</span>
<a href="#l4.985"></a><span id="l4.985" class="difflineminus">-                        , public nsSupportsWeakReference</span>
<a href="#l4.986"></a><span id="l4.986" class="difflineminus">-{</span>
<a href="#l4.987"></a><span id="l4.987" class="difflineminus">-public:</span>
<a href="#l4.988"></a><span id="l4.988" class="difflineplus">+class nsImapMockChannel : public nsIImapMockChannel,</span>
<a href="#l4.989"></a><span id="l4.989" class="difflineplus">+                          public nsICacheEntryOpenCallback,</span>
<a href="#l4.990"></a><span id="l4.990" class="difflineplus">+                          public nsITransportEventSink,</span>
<a href="#l4.991"></a><span id="l4.991" class="difflineplus">+                          public nsSupportsWeakReference {</span>
<a href="#l4.992"></a><span id="l4.992" class="difflineplus">+ public:</span>
<a href="#l4.993"></a><span id="l4.993">   friend class nsImapProtocol;</span>
<a href="#l4.994"></a><span id="l4.994"> </span>
<a href="#l4.995"></a><span id="l4.995">   NS_DECL_THREADSAFE_ISUPPORTS</span>
<a href="#l4.996"></a><span id="l4.996">   NS_DECL_NSIIMAPMOCKCHANNEL</span>
<a href="#l4.997"></a><span id="l4.997">   NS_DECL_NSICHANNEL</span>
<a href="#l4.998"></a><span id="l4.998">   NS_DECL_NSIREQUEST</span>
<a href="#l4.999"></a><span id="l4.999">   NS_DECL_NSICACHEENTRYOPENCALLBACK</span>
<a href="#l4.1000"></a><span id="l4.1000">   NS_DECL_NSITRANSPORTEVENTSINK</span>
<a href="#l4.1001"></a><span id="l4.1001"> </span>
<a href="#l4.1002"></a><span id="l4.1002">   nsImapMockChannel();</span>
<a href="#l4.1003"></a><span id="l4.1003" class="difflineminus">-  static nsresult Create (const nsIID&amp; iid, void **result);</span>
<a href="#l4.1004"></a><span id="l4.1004" class="difflineplus">+  static nsresult Create(const nsIID &amp;iid, void **result);</span>
<a href="#l4.1005"></a><span id="l4.1005">   nsresult RunOnStopRequestFailure();</span>
<a href="#l4.1006"></a><span id="l4.1006"> </span>
<a href="#l4.1007"></a><span id="l4.1007" class="difflineminus">-protected:</span>
<a href="#l4.1008"></a><span id="l4.1008" class="difflineplus">+ protected:</span>
<a href="#l4.1009"></a><span id="l4.1009">   virtual ~nsImapMockChannel();</span>
<a href="#l4.1010"></a><span id="l4.1010" class="difflineminus">-  nsCOMPtr &lt;nsIURI&gt; m_url;</span>
<a href="#l4.1011"></a><span id="l4.1011" class="difflineplus">+  nsCOMPtr&lt;nsIURI&gt; m_url;</span>
<a href="#l4.1012"></a><span id="l4.1012"> </span>
<a href="#l4.1013"></a><span id="l4.1013">   nsCOMPtr&lt;nsIURI&gt; m_originalUrl;</span>
<a href="#l4.1014"></a><span id="l4.1014">   nsCOMPtr&lt;nsILoadGroup&gt; m_loadGroup;</span>
<a href="#l4.1015"></a><span id="l4.1015">   nsCOMPtr&lt;nsILoadInfo&gt; m_loadInfo;</span>
<a href="#l4.1016"></a><span id="l4.1016">   nsCOMPtr&lt;nsIStreamListener&gt; m_channelListener;</span>
<a href="#l4.1017"></a><span id="l4.1017">   nsCOMPtr&lt;nsISupports&gt; m_channelContext;</span>
<a href="#l4.1018"></a><span id="l4.1018">   nsresult m_cancelStatus;</span>
<a href="#l4.1019"></a><span id="l4.1019">   nsLoadFlags mLoadFlags;</span>
<a href="#l4.1020"></a><span id="l4.1020">   nsCOMPtr&lt;nsIProgressEventSink&gt; mProgressEventSink;</span>
<a href="#l4.1021"></a><span id="l4.1021">   nsCOMPtr&lt;nsIInterfaceRequestor&gt; mCallbacks;</span>
<a href="#l4.1022"></a><span id="l4.1022">   nsCOMPtr&lt;nsISupports&gt; mOwner;</span>
<a href="#l4.1023"></a><span id="l4.1023">   nsCOMPtr&lt;nsISupports&gt; mSecurityInfo;</span>
<a href="#l4.1024"></a><span id="l4.1024" class="difflineminus">-  nsCOMPtr&lt;nsIRequest&gt; mCacheRequest; // the request associated with a read from the cache</span>
<a href="#l4.1025"></a><span id="l4.1025" class="difflineplus">+  nsCOMPtr&lt;nsIRequest&gt;</span>
<a href="#l4.1026"></a><span id="l4.1026" class="difflineplus">+      mCacheRequest;  // the request associated with a read from the cache</span>
<a href="#l4.1027"></a><span id="l4.1027">   nsCString mContentType;</span>
<a href="#l4.1028"></a><span id="l4.1028">   nsCString mCharset;</span>
<a href="#l4.1029"></a><span id="l4.1029">   nsWeakPtr mProtocol;</span>
<a href="#l4.1030"></a><span id="l4.1030"> </span>
<a href="#l4.1031"></a><span id="l4.1031">   bool mChannelClosed;</span>
<a href="#l4.1032"></a><span id="l4.1032">   bool mReadingFromCache;</span>
<a href="#l4.1033"></a><span id="l4.1033">   bool mTryingToReadPart;</span>
<a href="#l4.1034"></a><span id="l4.1034">   int64_t mContentLength;</span>
<a href="#l4.1035"></a><span id="l4.1035"> </span>
<a href="#l4.1036"></a><span id="l4.1036">   // cache related helper methods</span>
<a href="#l4.1037"></a><span id="l4.1037" class="difflineminus">-  nsresult OpenCacheEntry(); // makes a request to the cache service for a cache entry for a url</span>
<a href="#l4.1038"></a><span id="l4.1038" class="difflineminus">-  bool ReadFromLocalCache(); // attempts to read the url out of our local (offline) cache....</span>
<a href="#l4.1039"></a><span id="l4.1039" class="difflineminus">-  nsresult ReadFromImapConnection(); // creates a new imap connection to read the url</span>
<a href="#l4.1040"></a><span id="l4.1040" class="difflineminus">-  nsresult ReadFromMemCache(nsICacheEntry *entry); // attempts to read the url out of our memory cache</span>
<a href="#l4.1041"></a><span id="l4.1041" class="difflineplus">+  nsresult OpenCacheEntry();  // makes a request to the cache service for a</span>
<a href="#l4.1042"></a><span id="l4.1042" class="difflineplus">+                              // cache entry for a url</span>
<a href="#l4.1043"></a><span id="l4.1043" class="difflineplus">+  bool ReadFromLocalCache();  // attempts to read the url out of our local</span>
<a href="#l4.1044"></a><span id="l4.1044" class="difflineplus">+                              // (offline) cache....</span>
<a href="#l4.1045"></a><span id="l4.1045" class="difflineplus">+  nsresult</span>
<a href="#l4.1046"></a><span id="l4.1046" class="difflineplus">+  ReadFromImapConnection();  // creates a new imap connection to read the url</span>
<a href="#l4.1047"></a><span id="l4.1047" class="difflineplus">+  nsresult ReadFromMemCache(nsICacheEntry *entry);  // attempts to read the url</span>
<a href="#l4.1048"></a><span id="l4.1048" class="difflineplus">+                                                    // out of our memory cache</span>
<a href="#l4.1049"></a><span id="l4.1049">   nsresult NotifyStartEndReadFromCache(bool start);</span>
<a href="#l4.1050"></a><span id="l4.1050"> </span>
<a href="#l4.1051"></a><span id="l4.1051">   // we end up daisy chaining multiple nsIStreamListeners into the load process.</span>
<a href="#l4.1052"></a><span id="l4.1052" class="difflineminus">-  nsresult SetupPartExtractorListener(nsIImapUrl * aUrl, nsIStreamListener * aConsumer);</span>
<a href="#l4.1053"></a><span id="l4.1053" class="difflineplus">+  nsresult SetupPartExtractorListener(nsIImapUrl *aUrl,</span>
<a href="#l4.1054"></a><span id="l4.1054" class="difflineplus">+                                      nsIStreamListener *aConsumer);</span>
<a href="#l4.1055"></a><span id="l4.1055"> };</span>
<a href="#l4.1056"></a><span id="l4.1056"> </span>
<a href="#l4.1057"></a><span id="l4.1057"> #endif  // nsImapProtocol_h___</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:33Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

