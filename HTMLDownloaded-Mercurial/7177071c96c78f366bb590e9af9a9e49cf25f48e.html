<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 30092:7177071c96c78f366bb590e9af9a9e49cf25f48e</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 7177071c96c78f366bb590e9af9a9e49cf25f48e" />
<meta property="og:url" content="/comm-central/rev/7177071c96c78f366bb590e9af9a9e49cf25f48e" />
<meta property="og:description" content="Bug 1651031 - Update RNP to snapshot from 2020-07-07. r=rjl" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 7177071c96c78f366bb590e9af9a9e49cf25f48e 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/7177071c96c78f366bb590e9af9a9e49cf25f48e">shortlog</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/7177071c96c78f366bb590e9af9a9e49cf25f48e">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e">files</a> |
changeset |
<a href="/comm-central/raw-rev/7177071c96c78f366bb590e9af9a9e49cf25f48e">raw</a>  | <a href="/comm-central/archive/7177071c96c78f366bb590e9af9a9e49cf25f48e.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1651031">Bug 1651031</a> - Update RNP to snapshot from 2020-07-07. r=rjl
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#75;&#97;&#105;&#32;&#69;&#110;&#103;&#101;&#114;&#116;&#32;&#60;&#107;&#97;&#105;&#101;&#64;&#107;&#117;&#105;&#120;&#46;&#100;&#101;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 07 Jul 2020 12:56:16 +0200</td></tr>

<tr>
 <td>changeset 30092</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/7177071c96c78f366bb590e9af9a9e49cf25f48e">7177071c96c78f366bb590e9af9a9e49cf25f48e</a></td>
</tr>



<tr>
<td>parent 30091</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/a06bf70755b1cc052b4bb30a292c491d2c7f1541">a06bf70755b1cc052b4bb30a292c491d2c7f1541</a>
</td>
</tr>

<tr>
<td>child 30093</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/178be19733777d46c9abf935e3f3ca927cdfcef5">178be19733777d46c9abf935e3f3ca927cdfcef5</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=7177071c96c78f366bb590e9af9a9e49cf25f48e">17690</a></td></tr>
<tr><td>push user</td><td>kaie@kuix.de</td></tr>
<tr><td>push date</td><td class="date age">Fri, 10 Jul 2020 07:32:34 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a2d8d44099f7 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a2d8d44099f7bb7587f92be50fbfa58ff916ae09">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a2d8d44099f7bb7587f92be50fbfa58ff916ae09&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a2d8d44099f7bb7587f92be50fbfa58ff916ae09&newProject=comm-central&newRevision=7177071c96c78f366bb590e9af9a9e49cf25f48e&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a2d8d44099f7bb7587f92be50fbfa58ff916ae09&newProject=comm-central&newRevision=7177071c96c78f366bb590e9af9a9e49cf25f48e&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a2d8d44099f7bb7587f92be50fbfa58ff916ae09&newProject=comm-central&newRevision=7177071c96c78f366bb590e9af9a9e49cf25f48e&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28rjl%29&revcount=50">rjl</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1651031">1651031</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1651031">Bug 1651031</a> - Update RNP to snapshot from 2020-07-07. r=rjl

Differential Revision: <a href="https://phabricator.services.mozilla.com/D82509">https://phabricator.services.mozilla.com/D82509</a></div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/README.rnp">third_party/README.rnp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/README.rnp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/README.rnp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/README.rnp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/README.rnp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/README.rnp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/README.adoc">third_party/rnp/README.adoc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/README.adoc">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/README.adoc">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/README.adoc">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/README.adoc">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/README.adoc">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/code-of-conduct.adoc">third_party/rnp/docs/code-of-conduct.adoc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/code-of-conduct.adoc">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/code-of-conduct.adoc">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/code-of-conduct.adoc">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/code-of-conduct.adoc">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/code-of-conduct.adoc">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/develop.adoc">third_party/rnp/docs/develop.adoc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/develop.adoc">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/develop.adoc">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/develop.adoc">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/develop.adoc">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/docs/develop.adoc">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rekey/rnp_key_store.h">third_party/rnp/include/rekey/rnp_key_store.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rekey/rnp_key_store.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rekey/rnp_key_store.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rekey/rnp_key_store.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rekey/rnp_key_store.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rekey/rnp_key_store.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp.h">third_party/rnp/include/rnp/rnp.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp_sdk.h">third_party/rnp/include/rnp/rnp_sdk.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp_sdk.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp_sdk.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp_sdk.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp_sdk.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/include/rnp/rnp_sdk.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/CMakeLists.txt">third_party/rnp/src/common/CMakeLists.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/CMakeLists.txt">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/CMakeLists.txt">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/CMakeLists.txt">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/CMakeLists.txt">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/CMakeLists.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.cpp">third_party/rnp/src/common/file-utils.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.h">third_party/rnp/src/common/file-utils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/file-utils.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.cpp">third_party/rnp/src/common/list.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.h">third_party/rnp/src/common/list.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/list.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.cpp">third_party/rnp/src/common/str-utils.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.h">third_party/rnp/src/common/str-utils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/common/str-utils.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/CMakeLists.txt">third_party/rnp/src/lib/CMakeLists.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/CMakeLists.txt">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/CMakeLists.txt">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/CMakeLists.txt">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/CMakeLists.txt">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/CMakeLists.txt">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/config.h.in">third_party/rnp/src/lib/config.h.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/config.h.in">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/config.h.in">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/config.h.in">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/config.h.in">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/config.h.in">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ec.h">third_party/rnp/src/lib/crypto/ec.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ec.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ec.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ec.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ec.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ec.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.cpp">third_party/rnp/src/lib/crypto/ecdh.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.h">third_party/rnp/src/lib/crypto/ecdh.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/ecdh.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.cpp">third_party/rnp/src/lib/crypto/hash.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.h">third_party/rnp/src/lib/crypto/hash.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/crypto/hash.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.cpp">third_party/rnp/src/lib/fingerprint.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.h">third_party/rnp/src/lib/fingerprint.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/fingerprint.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.cpp">third_party/rnp/src/lib/key-provider.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.h">third_party/rnp/src/lib/key-provider.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/key-provider.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.cpp">third_party/rnp/src/lib/list.cpp</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.h">third_party/rnp/src/lib/list.h</a></td>
<td></td>
<td class="link">
file |
annotate |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/list.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/misc.cpp">third_party/rnp/src/lib/misc.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/misc.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/misc.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/misc.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/misc.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/misc.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.cpp">third_party/rnp/src/lib/pgp-key.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.h">third_party/rnp/src/lib/pgp-key.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/pgp-key.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/rnp.cpp">third_party/rnp/src/lib/rnp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/rnp.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/rnp.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/rnp.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/rnp.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/rnp.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/types.h">third_party/rnp/src/lib/types.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/types.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/types.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/types.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/types.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/types.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/utils.h">third_party/rnp/src/lib/utils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/utils.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/utils.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/utils.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/utils.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/utils.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/version.h">third_party/rnp/src/lib/version.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/version.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/version.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/version.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/version.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/lib/version.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_kbx.cpp">third_party/rnp/src/librekey/key_store_kbx.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_kbx.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_kbx.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_kbx.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_kbx.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_kbx.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_pgp.cpp">third_party/rnp/src/librekey/key_store_pgp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_pgp.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_pgp.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_pgp.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_pgp.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/key_store_pgp.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/rnp_key_store.cpp">third_party/rnp/src/librekey/rnp_key_store.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/rnp_key_store.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/rnp_key_store.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/rnp_key_store.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/rnp_key_store.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librekey/rnp_key_store.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.cpp">third_party/rnp/src/librepgp/stream-armor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.h">third_party/rnp/src/librepgp/stream-armor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-armor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.cpp">third_party/rnp/src/librepgp/stream-common.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.h">third_party/rnp/src/librepgp/stream-common.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-common.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-ctx.h">third_party/rnp/src/librepgp/stream-ctx.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-ctx.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-ctx.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-ctx.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-ctx.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-ctx.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-dump.cpp">third_party/rnp/src/librepgp/stream-dump.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-dump.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-dump.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-dump.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-dump.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-dump.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-key.cpp">third_party/rnp/src/librepgp/stream-key.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-key.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-key.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-key.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-key.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-key.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-packet.cpp">third_party/rnp/src/librepgp/stream-packet.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-packet.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-packet.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-packet.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-packet.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-packet.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.cpp">third_party/rnp/src/librepgp/stream-parse.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.h">third_party/rnp/src/librepgp/stream-parse.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-parse.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.cpp">third_party/rnp/src/librepgp/stream-sig.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.h">third_party/rnp/src/librepgp/stream-sig.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-sig.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-write.cpp">third_party/rnp/src/librepgp/stream-write.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-write.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-write.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-write.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-write.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/librepgp/stream-write.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/CMakeLists.txt">third_party/rnp/src/rnp/CMakeLists.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/CMakeLists.txt">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/CMakeLists.txt">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/CMakeLists.txt">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/CMakeLists.txt">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/CMakeLists.txt">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/fficli.cpp">third_party/rnp/src/rnp/fficli.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/fficli.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/fficli.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/fficli.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/fficli.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/fficli.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/rnpcfg.cpp">third_party/rnp/src/rnp/rnpcfg.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/rnpcfg.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/rnpcfg.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/rnpcfg.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/rnpcfg.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnp/rnpcfg.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/CMakeLists.txt">third_party/rnp/src/rnpkeys/CMakeLists.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/CMakeLists.txt">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/CMakeLists.txt">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/CMakeLists.txt">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/CMakeLists.txt">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/CMakeLists.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/tui.cpp">third_party/rnp/src/rnpkeys/tui.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/tui.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/tui.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/tui.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/tui.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/rnpkeys/tui.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/CMakeLists.txt">third_party/rnp/src/tests/CMakeLists.txt</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/CMakeLists.txt">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/CMakeLists.txt">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/CMakeLists.txt">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/CMakeLists.txt">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/CMakeLists.txt">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/cipher.cpp">third_party/rnp/src/tests/cipher.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/cipher.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/cipher.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/cipher.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/cipher.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/cipher.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-keys-same-grip.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-keys-same-grip.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-keys-same-grip.pgp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-keys-same-grip.pgp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-keys-same-grip.pgp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-keys-same-grip.pgp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-keys-same-grip.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-subs-same-grip.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-subs-same-grip.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-subs-same-grip.pgp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-subs-same-grip.pgp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-subs-same-grip.pgp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-subs-same-grip.pgp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_edge_cases/alice-2-subs-same-grip.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc">third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc">third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_messages/message.txt.literal">third_party/rnp/src/tests/data/test_messages/message.txt.literal</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_messages/message.txt.literal">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_messages/message.txt.literal">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_messages/message.txt.literal">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_messages/message.txt.literal">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/data/test_messages/message.txt.literal">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/ffi.cpp">third_party/rnp/src/tests/ffi.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/ffi.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/ffi.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/ffi.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/ffi.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/ffi.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/generatekey.cpp">third_party/rnp/src/tests/generatekey.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/generatekey.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/generatekey.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/generatekey.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/generatekey.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/generatekey.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-store-search.cpp">third_party/rnp/src/tests/key-store-search.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-store-search.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-store-search.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-store-search.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-store-search.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-store-search.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-validate.cpp">third_party/rnp/src/tests/key-validate.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-validate.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-validate.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-validate.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-validate.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/key-validate.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-g10.cpp">third_party/rnp/src/tests/load-g10.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-g10.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-g10.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-g10.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-g10.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-g10.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-pgp.cpp">third_party/rnp/src/tests/load-pgp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-pgp.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-pgp.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-pgp.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-pgp.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/load-pgp.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/pipe.cpp">third_party/rnp/src/tests/pipe.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/pipe.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/pipe.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/pipe.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/pipe.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/pipe.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/rnp_tests.h">third_party/rnp/src/tests/rnp_tests.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/rnp_tests.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/rnp_tests.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/rnp_tests.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/rnp_tests.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/rnp_tests.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/streams.cpp">third_party/rnp/src/tests/streams.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/streams.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/streams.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/streams.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/streams.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/streams.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.cpp">third_party/rnp/src/tests/support.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.cpp">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.cpp">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.cpp">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.cpp">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.h">third_party/rnp/src/tests/support.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.h">file</a> |
<a href="/comm-central/annotate/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.h">annotate</a> |
<a href="/comm-central/diff/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.h">diff</a> |
<a href="/comm-central/comparison/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.h">comparison</a> |
<a href="/comm-central/log/7177071c96c78f366bb590e9af9a9e49cf25f48e/third_party/rnp/src/tests/support.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/third_party/README.rnp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/third_party/README.rnp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -1,12 +1,12 @@</span>
<a href="#l1.4"></a><span id="l1.4"> Directory ./rnp contains a copy of rnp which has been obtained from:</span>
<a href="#l1.5"></a><span id="l1.5"> https://github.com/rnpgp/rnp</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7" class="difflineminus">-[commit ac07057820ece92ddab52536f4a78d7d5bb71ba7]</span>
<a href="#l1.8"></a><span id="l1.8" class="difflineplus">+[commit 2858ccdccbeeda21806849236b3a82679bd591f4]</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> For licensing information, please refer to the included documentation.</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12"> To update this copy, run &quot;update_rnp.sh&quot; in this directory from this directory</span>
<a href="#l1.13"></a><span id="l1.13"> within a complete build tree (including mozilla-central) as &quot;mach python&quot; is</span>
<a href="#l1.14"></a><span id="l1.14"> used.</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16"> update_rnp.sh will generate rnp/src/lib/version.h from rnp/src/lib/version.h.in</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/third_party/rnp/README.adoc</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/third_party/rnp/README.adoc</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -52,8 +52,9 @@ dist` will contain this hash version.</span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5"> The first version of rnp started at `0.8.0` to indicate its development</span>
<a href="#l2.6"></a><span id="l2.6"> completeness (or lack thereof).</span>
<a href="#l2.7"></a><span id="l2.7"> </span>
<a href="#l2.8"></a><span id="l2.8"> RNP originated as an attempt to modernize the NetPGP codebase originally</span>
<a href="#l2.9"></a><span id="l2.9"> created by Alistair Crooks of NetBSD in 2016. RNP has been heavily rewritten,</span>
<a href="#l2.10"></a><span id="l2.10"> and carries minimal if any code from the original codebase.</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+== link:docs/code-of-conduct.adoc[Code of Conduct]</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">new file mode 100644</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineminus">--- /dev/null</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineplus">+++ b/third_party/rnp/docs/code-of-conduct.adoc</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineat">@@ -0,0 +1,128 @@</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+= Contributor Covenant Code of Conduct</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+== Our Pledge</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+We as members, contributors, and leaders pledge to make participation in our</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+community a harassment-free experience for everyone, regardless of age, body</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+size, visible or invisible disability, ethnicity, sex characteristics, gender</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+identity and expression, level of experience, education, socio-economic status,</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+nationality, personal appearance, race, religion, or sexual identity</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+and orientation.</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+We pledge to act and interact in ways that contribute to an open, welcoming,</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+diverse, inclusive, and healthy community.</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+== Our Standards</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+Examples of behavior that contributes to a positive environment for our</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+community include:</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+* Demonstrating empathy and kindness toward other people</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+* Being respectful of differing opinions, viewpoints, and experiences</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+* Giving and gracefully accepting constructive feedback</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+* Accepting responsibility and apologizing to those affected by our mistakes,</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+  and learning from the experience</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+* Focusing on what is best not just for us as individuals, but for the</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+  overall community</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+Examples of unacceptable behavior include:</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+* The use of sexualized language or imagery, and sexual attention or</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+  advances of any kind</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+* Trolling, insulting or derogatory comments, and personal or political attacks</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+* Public or private harassment</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+* Publishing others' private information, such as a physical or email</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+  address, without their explicit permission</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+* Other conduct which could reasonably be considered inappropriate in a</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+  professional setting</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+== Enforcement Responsibilities</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+Community leaders are responsible for clarifying and enforcing our standards of</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+acceptable behavior and will take appropriate and fair corrective action in</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+response to any behavior that they deem inappropriate, threatening, offensive,</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+or harmful.</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+Community leaders have the right and responsibility to remove, edit, or reject</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+comments, commits, code, wiki edits, issues, and other contributions that are</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+not aligned to this Code of Conduct, and will communicate reasons for moderation</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+decisions when appropriate.</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+== Scope</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+This Code of Conduct applies within all community spaces, and also applies when</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+an individual is officially representing the community in public spaces.</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+Examples of representing our community include using an official e-mail address,</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+posting via an official social media account, or acting as an appointed</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+representative at an online or offline event.</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+== Enforcement</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+Instances of abusive, harassing, or otherwise unacceptable behavior may be</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+reported to the community leaders responsible for enforcement at</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+open.source@ribose.com.</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+All complaints will be reviewed and investigated promptly and fairly.</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+All community leaders are obligated to respect the privacy and security of the</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+reporter of any incident.</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+== Enforcement Guidelines</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+Community leaders will follow these Community Impact Guidelines in determining</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+the consequences for any action they deem in violation of this Code of Conduct:</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+=== 1. Correction</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+**Community Impact**: Use of inappropriate language or other behavior deemed</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+unprofessional or unwelcome in the community.</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+**Consequence**: A private, written warning from community leaders, providing</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+clarity around the nature of the violation and an explanation of why the</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+behavior was inappropriate. A public apology may be requested.</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+=== 2. Warning</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+**Community Impact**: A violation through a single incident or series</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+of actions.</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+**Consequence**: A warning with consequences for continued behavior. No</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+interaction with the people involved, including unsolicited interaction with</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+those enforcing the Code of Conduct, for a specified period of time. This</span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+includes avoiding interactions in community spaces as well as external channels</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+like social media. Violating these terms may lead to a temporary or</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+permanent ban.</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+=== 3. Temporary Ban</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+**Community Impact**: A serious violation of community standards, including</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+sustained inappropriate behavior.</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+**Consequence**: A temporary ban from any sort of interaction or public</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+communication with the community for a specified period of time. No public or</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+private interaction with the people involved, including unsolicited interaction</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+with those enforcing the Code of Conduct, is allowed during this period.</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+Violating these terms may lead to a permanent ban.</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+=== 4. Permanent Ban</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineplus">+**Community Impact**: Demonstrating a pattern of violation of community</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineplus">+standards, including sustained inappropriate behavior,  harassment of an</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineplus">+individual, or aggression toward or disparagement of classes of individuals.</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+**Consequence**: A permanent ban from any sort of public interaction within</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineplus">+the community.</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+== Attribution</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+This Code of Conduct is adapted from the</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineplus">+https://www.contributor-covenant.org[Contributor Covenant],</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+version 2.0, available at</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineplus">+https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+Community Impact Guidelines were inspired by</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+https://github.com/mozilla/diversity[Mozilla's code of conduct enforcement ladder].</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+For answers to common questions about this code of conduct, see the FAQ at</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+https://www.contributor-covenant.org/faq. Translations are available at</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+https://www.contributor-covenant.org/translations.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/third_party/rnp/docs/develop.adoc</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/third_party/rnp/docs/develop.adoc</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -426,23 +426,25 @@ Comments should use doxygen markdown sty</span>
<a href="#l4.4"></a><span id="l4.4"> rnp_result_t</span>
<a href="#l4.5"></a><span id="l4.5"> rnp_do_operation(const char *param1, const int param2, int *size, char *buffer);</span>
<a href="#l4.6"></a><span id="l4.6"> --</span>
<a href="#l4.7"></a><span id="l4.7"> </span>
<a href="#l4.8"></a><span id="l4.8"> == OpenPGP protocol specification</span>
<a href="#l4.9"></a><span id="l4.9"> </span>
<a href="#l4.10"></a><span id="l4.10"> During development you'll need to reference OpenPGP protocol and related documents.</span>
<a href="#l4.11"></a><span id="l4.11"> Here is the list of RFCs and Internet Drafts available at the moment:</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+</span>
<a href="#l4.13"></a><span id="l4.13"> * https://www.ietf.org/rfc/rfc1991.txt[RFC 1991]: PGP Message Exchange Formats. Now obsolete, but may have some historical interest.</span>
<a href="#l4.14"></a><span id="l4.14"> * https://www.ietf.org/rfc/rfc2440.txt[RFC 2440]: OpenPGP Message Format. Superceded by RFC 4880.</span>
<a href="#l4.15"></a><span id="l4.15"> * https://www.ietf.org/rfc/rfc4880.txt[RFC 4880]: OpenPGP Message Format. Latest RFC available at the moment, however has a lot of suggested changes via RFC 4880bis</span>
<a href="#l4.16"></a><span id="l4.16"> * https://tools.ietf.org/rfc/rfc5581.txt[RFC 5581]: The Camellia cipher in OpenPGP.</span>
<a href="#l4.17"></a><span id="l4.17" class="difflineminus">-* https://tools.ietf.org/id/draft-ietf-openpgp-rfc4880bis-04.txt[RFC 4880bis-04]: OpenPGP Message Format. Latest suggested update to the RFC 4880.</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineplus">+* https://www.ietf.org/id/draft-ietf-openpgp-rfc4880bis-09.txt[RFC 4880bis-09]: OpenPGP Message Format. Latest suggested update to the RFC 4880.</span>
<a href="#l4.19"></a><span id="l4.19"> </span>
<a href="#l4.20"></a><span id="l4.20"> More information sources:</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+</span>
<a href="#l4.22"></a><span id="l4.22"> * https://mailarchive.ietf.org/arch/browse/openpgp/[OpenPGP Working Group mailing list]. Here you can pick up all the latest discussions and suggestions regarding the update of RFC 4880</span>
<a href="#l4.23"></a><span id="l4.23"> * https://gitlab.com/openpgp-wg/rfc4880bis[OpenPGP Working Group gitlab]. Latest work on RFC update is available here.</span>
<a href="#l4.24"></a><span id="l4.24"> </span>
<a href="#l4.25"></a><span id="l4.25"> == Reviewers and Responsibility areas</span>
<a href="#l4.26"></a><span id="l4.26"> </span>
<a href="#l4.27"></a><span id="l4.27"> The individuals are responsible for the following areas of `rnp`.</span>
<a href="#l4.28"></a><span id="l4.28"> When submitting a Pull Request please seek reviews by whoever is</span>
<a href="#l4.29"></a><span id="l4.29"> responsible according to this list.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/third_party/rnp/include/rekey/rnp_key_store.h</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/third_party/rnp/include/rekey/rnp_key_store.h</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -33,16 +33,17 @@</span>
<a href="#l5.4"></a><span id="l5.4"> </span>
<a href="#l5.5"></a><span id="l5.5"> #include &lt;stdint.h&gt;</span>
<a href="#l5.6"></a><span id="l5.6"> #include &lt;stdbool.h&gt;</span>
<a href="#l5.7"></a><span id="l5.7"> #include &quot;rnp.h&quot;</span>
<a href="#l5.8"></a><span id="l5.8"> #include &quot;librepgp/stream-common.h&quot;</span>
<a href="#l5.9"></a><span id="l5.9"> #include &lt;string&gt;</span>
<a href="#l5.10"></a><span id="l5.10"> #include &lt;list&gt;</span>
<a href="#l5.11"></a><span id="l5.11"> #include &lt;map&gt;</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+#include &lt;unordered_map&gt;</span>
<a href="#l5.13"></a><span id="l5.13"> </span>
<a href="#l5.14"></a><span id="l5.14"> typedef struct pgp_key_t pgp_key_t;</span>
<a href="#l5.15"></a><span id="l5.15"> </span>
<a href="#l5.16"></a><span id="l5.16"> typedef enum {</span>
<a href="#l5.17"></a><span id="l5.17">     KBX_EMPTY_BLOB = 0,</span>
<a href="#l5.18"></a><span id="l5.18">     KBX_HEADER_BLOB = 1,</span>
<a href="#l5.19"></a><span id="l5.19">     KBX_PGP_BLOB = 2,</span>
<a href="#l5.20"></a><span id="l5.20">     KBX_X509_BLOB = 3</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineat">@@ -127,26 +128,26 @@ typedef enum pgp_key_import_status_t {</span>
<a href="#l5.22"></a><span id="l5.22"> </span>
<a href="#l5.23"></a><span id="l5.23"> typedef enum pgp_sig_import_status_t {</span>
<a href="#l5.24"></a><span id="l5.24">     PGP_SIG_IMPORT_STATUS_UNKNOWN = 0,</span>
<a href="#l5.25"></a><span id="l5.25">     PGP_SIG_IMPORT_STATUS_UNKNOWN_KEY,</span>
<a href="#l5.26"></a><span id="l5.26">     PGP_SIG_IMPORT_STATUS_UNCHANGED,</span>
<a href="#l5.27"></a><span id="l5.27">     PGP_SIG_IMPORT_STATUS_NEW</span>
<a href="#l5.28"></a><span id="l5.28"> } pgp_sig_import_status_t;</span>
<a href="#l5.29"></a><span id="l5.29"> </span>
<a href="#l5.30"></a><span id="l5.30" class="difflineminus">-typedef std::map&lt;pgp_key_grip_t, std::list&lt;pgp_key_t&gt;::iterator&gt; pgp_key_grip_map_t;</span>
<a href="#l5.31"></a><span id="l5.31" class="difflineplus">+typedef std::unordered_map&lt;pgp_fingerprint_t, std::list&lt;pgp_key_t&gt;::iterator&gt; pgp_key_fp_map_t;</span>
<a href="#l5.32"></a><span id="l5.32"> </span>
<a href="#l5.33"></a><span id="l5.33"> typedef struct rnp_key_store_t {</span>
<a href="#l5.34"></a><span id="l5.34">     std::string            path;</span>
<a href="#l5.35"></a><span id="l5.35">     pgp_key_store_format_t format;</span>
<a href="#l5.36"></a><span id="l5.36">     bool disable_validation;  /* do not automatically validate keys, added to this key store */</span>
<a href="#l5.37"></a><span id="l5.37">     bool skip_parsing_errors; /* do not fail on parsing errors */</span>
<a href="#l5.38"></a><span id="l5.38"> </span>
<a href="#l5.39"></a><span id="l5.39">     std::list&lt;pgp_key_t&gt; keys;</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineminus">-    pgp_key_grip_map_t   keybygrip;</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+    pgp_key_fp_map_t     keybyfp;</span>
<a href="#l5.42"></a><span id="l5.42"> </span>
<a href="#l5.43"></a><span id="l5.43">     list blobs; // list of kbx_blob_t</span>
<a href="#l5.44"></a><span id="l5.44"> </span>
<a href="#l5.45"></a><span id="l5.45">     ~rnp_key_store_t();</span>
<a href="#l5.46"></a><span id="l5.46">     rnp_key_store_t() = default;</span>
<a href="#l5.47"></a><span id="l5.47">     rnp_key_store_t(pgp_key_store_format_t format, const std::string &amp;path);</span>
<a href="#l5.48"></a><span id="l5.48">     /* make sure we use only empty constructor */</span>
<a href="#l5.49"></a><span id="l5.49">     rnp_key_store_t(rnp_key_store_t &amp;&amp;src) = delete;</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineat">@@ -203,20 +204,24 @@ pgp_sig_import_status_t rnp_key_store_im</span>
<a href="#l5.51"></a><span id="l5.51">  * @return pointer to the key to which this signature belongs (or NULL if key was not found)</span>
<a href="#l5.52"></a><span id="l5.52">  */</span>
<a href="#l5.53"></a><span id="l5.53"> pgp_key_t *rnp_key_store_import_signature(rnp_key_store_t *        keyring,</span>
<a href="#l5.54"></a><span id="l5.54">                                           const pgp_signature_t *  sig,</span>
<a href="#l5.55"></a><span id="l5.55">                                           pgp_sig_import_status_t *status);</span>
<a href="#l5.56"></a><span id="l5.56"> </span>
<a href="#l5.57"></a><span id="l5.57"> bool rnp_key_store_remove_key(rnp_key_store_t *, const pgp_key_t *, bool);</span>
<a href="#l5.58"></a><span id="l5.58"> </span>
<a href="#l5.59"></a><span id="l5.59" class="difflineminus">-pgp_key_t *rnp_key_store_get_key_by_id(rnp_key_store_t *, const unsigned char *, pgp_key_t *);</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineplus">+pgp_key_t *rnp_key_store_get_key_by_id(rnp_key_store_t *   keyring,</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+                                       const pgp_key_id_t &amp;keyid,</span>
<a href="#l5.62"></a><span id="l5.62" class="difflineplus">+                                       pgp_key_t *         key);</span>
<a href="#l5.63"></a><span id="l5.63"> </span>
<a href="#l5.64"></a><span id="l5.64"> bool rnp_key_store_get_key_grip(const pgp_key_material_t *, pgp_key_grip_t &amp;grip);</span>
<a href="#l5.65"></a><span id="l5.65"> </span>
<a href="#l5.66"></a><span id="l5.66"> const pgp_key_t *rnp_key_store_get_key_by_grip(const rnp_key_store_t *,</span>
<a href="#l5.67"></a><span id="l5.67">                                                const pgp_key_grip_t &amp;);</span>
<a href="#l5.68"></a><span id="l5.68"> pgp_key_t *      rnp_key_store_get_key_by_grip(rnp_key_store_t *, const pgp_key_grip_t &amp;);</span>
<a href="#l5.69"></a><span id="l5.69" class="difflineminus">-pgp_key_t *      rnp_key_store_get_key_by_fpr(rnp_key_store_t *, const pgp_fingerprint_t *fpr);</span>
<a href="#l5.70"></a><span id="l5.70" class="difflineplus">+const pgp_key_t *rnp_key_store_get_key_by_fpr(const rnp_key_store_t *,</span>
<a href="#l5.71"></a><span id="l5.71" class="difflineplus">+                                              const pgp_fingerprint_t &amp;fpr);</span>
<a href="#l5.72"></a><span id="l5.72" class="difflineplus">+pgp_key_t *      rnp_key_store_get_key_by_fpr(rnp_key_store_t *, const pgp_fingerprint_t &amp;fpr);</span>
<a href="#l5.73"></a><span id="l5.73"> pgp_key_t *      rnp_key_store_get_primary_key(rnp_key_store_t *, const pgp_key_t *);</span>
<a href="#l5.74"></a><span id="l5.74"> pgp_key_t *rnp_key_store_search(rnp_key_store_t *, const pgp_key_search_t *, pgp_key_t *);</span>
<a href="#l5.75"></a><span id="l5.75"> </span>
<a href="#l5.76"></a><span id="l5.76"> #endif /* KEY_STORE_H_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/third_party/rnp/include/rnp/rnp.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/third_party/rnp/include/rnp/rnp.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l6.4"></a><span id="l6.4"> /*-</span>
<a href="#l6.5"></a><span id="l6.5" class="difflineminus">- * Copyright (c) 2017,2018 Ribose Inc.</span>
<a href="#l6.6"></a><span id="l6.6" class="difflineplus">+ * Copyright (c) 2017-2020 Ribose Inc.</span>
<a href="#l6.7"></a><span id="l6.7">  * All rights reserved.</span>
<a href="#l6.8"></a><span id="l6.8">  *</span>
<a href="#l6.9"></a><span id="l6.9">  * Redistribution and use in source and binary forms, with or without</span>
<a href="#l6.10"></a><span id="l6.10">  * modification, are permitted provided that the following conditions</span>
<a href="#l6.11"></a><span id="l6.11">  * are met:</span>
<a href="#l6.12"></a><span id="l6.12">  * 1. Redistributions of source code must retain the above copyright</span>
<a href="#l6.13"></a><span id="l6.13">  *    notice, this list of conditions and the following disclaimer.</span>
<a href="#l6.14"></a><span id="l6.14">  * 2. Redistributions in binary form must reproduce the above copyright</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineat">@@ -20,16 +20,17 @@</span>
<a href="#l6.16"></a><span id="l6.16">  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a href="#l6.17"></a><span id="l6.17">  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a href="#l6.18"></a><span id="l6.18">  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l6.19"></a><span id="l6.19">  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l6.20"></a><span id="l6.20">  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l6.21"></a><span id="l6.21">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l6.22"></a><span id="l6.22">  */</span>
<a href="#l6.23"></a><span id="l6.23"> </span>
<a href="#l6.24"></a><span id="l6.24" class="difflineplus">+#include &lt;rnp/rnp_export.h&gt;</span>
<a href="#l6.25"></a><span id="l6.25"> #include &lt;stdbool.h&gt;</span>
<a href="#l6.26"></a><span id="l6.26"> #include &lt;stddef.h&gt;</span>
<a href="#l6.27"></a><span id="l6.27"> #include &lt;stdint.h&gt;</span>
<a href="#l6.28"></a><span id="l6.28"> #include &lt;stdio.h&gt;</span>
<a href="#l6.29"></a><span id="l6.29"> </span>
<a href="#l6.30"></a><span id="l6.30"> #if defined(__cplusplus)</span>
<a href="#l6.31"></a><span id="l6.31"> extern &quot;C&quot; {</span>
<a href="#l6.32"></a><span id="l6.32"> #endif</span>
<a href="#l6.33"></a><span id="l6.33" class="difflineat">@@ -81,84 +82,84 @@ typedef uint32_t rnp_result_t;</span>
<a href="#l6.34"></a><span id="l6.34">  * Flags for output structure creation.</span>
<a href="#l6.35"></a><span id="l6.35">  */</span>
<a href="#l6.36"></a><span id="l6.36"> #define RNP_OUTPUT_FILE_OVERWRITE (1U &lt;&lt; 0)</span>
<a href="#l6.37"></a><span id="l6.37"> #define RNP_OUTPUT_FILE_RANDOM (1U &lt;&lt; 1)</span>
<a href="#l6.38"></a><span id="l6.38"> </span>
<a href="#l6.39"></a><span id="l6.39"> /**</span>
<a href="#l6.40"></a><span id="l6.40">  * Return a constant string describing the result code</span>
<a href="#l6.41"></a><span id="l6.41">  */</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineminus">-const char *rnp_result_to_string(rnp_result_t result);</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+RNP_API const char *rnp_result_to_string(rnp_result_t result);</span>
<a href="#l6.44"></a><span id="l6.44"> </span>
<a href="#l6.45"></a><span id="l6.45" class="difflineminus">-const char *rnp_version_string();</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineminus">-const char *rnp_version_string_full();</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+RNP_API const char *rnp_version_string();</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+RNP_API const char *rnp_version_string_full();</span>
<a href="#l6.49"></a><span id="l6.49"> </span>
<a href="#l6.50"></a><span id="l6.50"> /** return a value representing the version of librnp</span>
<a href="#l6.51"></a><span id="l6.51">  *</span>
<a href="#l6.52"></a><span id="l6.52">  *  This function is only useful for releases. For non-releases,</span>
<a href="#l6.53"></a><span id="l6.53">  *  it will return 0.</span>
<a href="#l6.54"></a><span id="l6.54">  *</span>
<a href="#l6.55"></a><span id="l6.55">  *  The value returned can be used in comparisons by utilizing</span>
<a href="#l6.56"></a><span id="l6.56">  *  rnp_version_for.</span>
<a href="#l6.57"></a><span id="l6.57">  *</span>
<a href="#l6.58"></a><span id="l6.58">  *  @return a value representing the librnp version</span>
<a href="#l6.59"></a><span id="l6.59">  **/</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineminus">-uint32_t rnp_version();</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+RNP_API uint32_t rnp_version();</span>
<a href="#l6.62"></a><span id="l6.62"> </span>
<a href="#l6.63"></a><span id="l6.63"> /** return a value representing a specific version of librnp</span>
<a href="#l6.64"></a><span id="l6.64">  *</span>
<a href="#l6.65"></a><span id="l6.65">  *  This value can be used in comparisons.</span>
<a href="#l6.66"></a><span id="l6.66">  *</span>
<a href="#l6.67"></a><span id="l6.67">  *  @return a value representing a librnp version</span>
<a href="#l6.68"></a><span id="l6.68">  **/</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineminus">-uint32_t rnp_version_for(uint32_t major, uint32_t minor, uint32_t patch);</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+RNP_API uint32_t rnp_version_for(uint32_t major, uint32_t minor, uint32_t patch);</span>
<a href="#l6.71"></a><span id="l6.71"> </span>
<a href="#l6.72"></a><span id="l6.72"> /** return the librnp major version</span>
<a href="#l6.73"></a><span id="l6.73">  *</span>
<a href="#l6.74"></a><span id="l6.74">  *  @return</span>
<a href="#l6.75"></a><span id="l6.75">  **/</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineminus">-uint32_t rnp_version_major(uint32_t version);</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+RNP_API uint32_t rnp_version_major(uint32_t version);</span>
<a href="#l6.78"></a><span id="l6.78"> </span>
<a href="#l6.79"></a><span id="l6.79"> /** return the librnp minor version</span>
<a href="#l6.80"></a><span id="l6.80">  *</span>
<a href="#l6.81"></a><span id="l6.81">  *  @return</span>
<a href="#l6.82"></a><span id="l6.82">  **/</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineminus">-uint32_t rnp_version_minor(uint32_t version);</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineplus">+RNP_API uint32_t rnp_version_minor(uint32_t version);</span>
<a href="#l6.85"></a><span id="l6.85"> </span>
<a href="#l6.86"></a><span id="l6.86"> /** return the librnp patch version</span>
<a href="#l6.87"></a><span id="l6.87">  *</span>
<a href="#l6.88"></a><span id="l6.88">  *  @return</span>
<a href="#l6.89"></a><span id="l6.89">  **/</span>
<a href="#l6.90"></a><span id="l6.90" class="difflineminus">-uint32_t rnp_version_patch(uint32_t version);</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineplus">+RNP_API uint32_t rnp_version_patch(uint32_t version);</span>
<a href="#l6.92"></a><span id="l6.92"> </span>
<a href="#l6.93"></a><span id="l6.93"> /** return a unix timestamp of the last commit, if available</span>
<a href="#l6.94"></a><span id="l6.94">  *</span>
<a href="#l6.95"></a><span id="l6.95">  *  This function is only useful for non-releases. For releases,</span>
<a href="#l6.96"></a><span id="l6.96">  *  it will return 0.</span>
<a href="#l6.97"></a><span id="l6.97">  *</span>
<a href="#l6.98"></a><span id="l6.98">  *  The intended usage is to provide a form of versioning for the master</span>
<a href="#l6.99"></a><span id="l6.99">  *  branch.</span>
<a href="#l6.100"></a><span id="l6.100">  *</span>
<a href="#l6.101"></a><span id="l6.101">  *  @return the unix timestamp of the last commit, or 0 if unavailable</span>
<a href="#l6.102"></a><span id="l6.102">  **/</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineminus">-uint64_t rnp_version_commit_timestamp();</span>
<a href="#l6.104"></a><span id="l6.104" class="difflineplus">+RNP_API uint64_t rnp_version_commit_timestamp();</span>
<a href="#l6.105"></a><span id="l6.105"> </span>
<a href="#l6.106"></a><span id="l6.106"> /** Enable debugging for the specified source file. Use 'all' or NULL as parameter to</span>
<a href="#l6.107"></a><span id="l6.107">  *  enable debug for all sources.</span>
<a href="#l6.108"></a><span id="l6.108">  *  Note: this must be only used during development since may print out confidential data.</span>
<a href="#l6.109"></a><span id="l6.109">  *</span>
<a href="#l6.110"></a><span id="l6.110">  * @param file name of the sourcer file. Use 'all' to enable debug for all code.</span>
<a href="#l6.111"></a><span id="l6.111">  */</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineminus">-rnp_result_t rnp_enable_debug(const char *file);</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineplus">+RNP_API rnp_result_t rnp_enable_debug(const char *file);</span>
<a href="#l6.114"></a><span id="l6.114"> </span>
<a href="#l6.115"></a><span id="l6.115"> /**</span>
<a href="#l6.116"></a><span id="l6.116">  * @brief Disable previously enabled debug for all files.</span>
<a href="#l6.117"></a><span id="l6.117">  *</span>
<a href="#l6.118"></a><span id="l6.118">  */</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineminus">-rnp_result_t rnp_disable_debug();</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+RNP_API rnp_result_t rnp_disable_debug();</span>
<a href="#l6.121"></a><span id="l6.121"> </span>
<a href="#l6.122"></a><span id="l6.122"> /*</span>
<a href="#l6.123"></a><span id="l6.123">  * Opaque structures</span>
<a href="#l6.124"></a><span id="l6.124">  */</span>
<a href="#l6.125"></a><span id="l6.125"> typedef struct rnp_ffi_st *                rnp_ffi_t;</span>
<a href="#l6.126"></a><span id="l6.126"> typedef struct rnp_key_handle_st *         rnp_key_handle_t;</span>
<a href="#l6.127"></a><span id="l6.127"> typedef struct rnp_input_st *              rnp_input_t;</span>
<a href="#l6.128"></a><span id="l6.128"> typedef struct rnp_output_st *             rnp_output_t;</span>
<a href="#l6.129"></a><span id="l6.129" class="difflineat">@@ -276,276 +277,283 @@ typedef void (*rnp_get_key_cb)(rnp_ffi_t</span>
<a href="#l6.130"></a><span id="l6.130">  *</span>
<a href="#l6.131"></a><span id="l6.131">  *  @param ffi pointer that will be set to the created ffi object</span>
<a href="#l6.132"></a><span id="l6.132">  *  @param pub_format the format of the public keyring, RNP_KEYSTORE_GPG or other</span>
<a href="#l6.133"></a><span id="l6.133">  *         RNP_KEYSTORE_* constant</span>
<a href="#l6.134"></a><span id="l6.134">  *  @param sec_format the format of the secret keyring, RNP_KEYSTORE_GPG or other</span>
<a href="#l6.135"></a><span id="l6.135">  *         RNP_KEYSTORE_* constant</span>
<a href="#l6.136"></a><span id="l6.136">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.137"></a><span id="l6.137">  */</span>
<a href="#l6.138"></a><span id="l6.138" class="difflineminus">-rnp_result_t rnp_ffi_create(rnp_ffi_t *ffi, const char *pub_format, const char *sec_format);</span>
<a href="#l6.139"></a><span id="l6.139" class="difflineplus">+RNP_API rnp_result_t rnp_ffi_create(rnp_ffi_t * ffi,</span>
<a href="#l6.140"></a><span id="l6.140" class="difflineplus">+                                    const char *pub_format,</span>
<a href="#l6.141"></a><span id="l6.141" class="difflineplus">+                                    const char *sec_format);</span>
<a href="#l6.142"></a><span id="l6.142"> </span>
<a href="#l6.143"></a><span id="l6.143"> /** destroy the top-level object used for interacting with the library</span>
<a href="#l6.144"></a><span id="l6.144">  *</span>
<a href="#l6.145"></a><span id="l6.145">  *  Note that this invalidates key handles, keyrings, and any other</span>
<a href="#l6.146"></a><span id="l6.146">  *  objects associated with this particular object.</span>
<a href="#l6.147"></a><span id="l6.147">  *</span>
<a href="#l6.148"></a><span id="l6.148">  *  @param ffi the ffi object</span>
<a href="#l6.149"></a><span id="l6.149">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.150"></a><span id="l6.150">  */</span>
<a href="#l6.151"></a><span id="l6.151" class="difflineminus">-rnp_result_t rnp_ffi_destroy(rnp_ffi_t ffi);</span>
<a href="#l6.152"></a><span id="l6.152" class="difflineplus">+RNP_API rnp_result_t rnp_ffi_destroy(rnp_ffi_t ffi);</span>
<a href="#l6.153"></a><span id="l6.153"> </span>
<a href="#l6.154"></a><span id="l6.154" class="difflineminus">-rnp_result_t rnp_ffi_set_log_fd(rnp_ffi_t ffi, int fd);</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineminus">-rnp_result_t rnp_ffi_set_key_provider(rnp_ffi_t      ffi,</span>
<a href="#l6.156"></a><span id="l6.156" class="difflineminus">-                                      rnp_get_key_cb getkeycb,</span>
<a href="#l6.157"></a><span id="l6.157" class="difflineminus">-                                      void *         getkeycb_ctx);</span>
<a href="#l6.158"></a><span id="l6.158" class="difflineminus">-rnp_result_t rnp_ffi_set_pass_provider(rnp_ffi_t       ffi,</span>
<a href="#l6.159"></a><span id="l6.159" class="difflineminus">-                                       rnp_password_cb getpasscb,</span>
<a href="#l6.160"></a><span id="l6.160" class="difflineminus">-                                       void *          getpasscb_ctx);</span>
<a href="#l6.161"></a><span id="l6.161" class="difflineplus">+RNP_API rnp_result_t rnp_ffi_set_log_fd(rnp_ffi_t ffi, int fd);</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineplus">+RNP_API rnp_result_t rnp_ffi_set_key_provider(rnp_ffi_t      ffi,</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+                                              rnp_get_key_cb getkeycb,</span>
<a href="#l6.164"></a><span id="l6.164" class="difflineplus">+                                              void *         getkeycb_ctx);</span>
<a href="#l6.165"></a><span id="l6.165" class="difflineplus">+RNP_API rnp_result_t rnp_ffi_set_pass_provider(rnp_ffi_t       ffi,</span>
<a href="#l6.166"></a><span id="l6.166" class="difflineplus">+                                               rnp_password_cb getpasscb,</span>
<a href="#l6.167"></a><span id="l6.167" class="difflineplus">+                                               void *          getpasscb_ctx);</span>
<a href="#l6.168"></a><span id="l6.168"> </span>
<a href="#l6.169"></a><span id="l6.169"> /* Operations on key rings */</span>
<a href="#l6.170"></a><span id="l6.170"> </span>
<a href="#l6.171"></a><span id="l6.171"> /** retrieve the default homedir (example: /home/user/.rnp)</span>
<a href="#l6.172"></a><span id="l6.172">  *</span>
<a href="#l6.173"></a><span id="l6.173">  * @param homedir pointer that will be set to the homedir path.</span>
<a href="#l6.174"></a><span id="l6.174">  *        The caller should free this with rnp_buffer_free.</span>
<a href="#l6.175"></a><span id="l6.175">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.176"></a><span id="l6.176">  */</span>
<a href="#l6.177"></a><span id="l6.177" class="difflineminus">-rnp_result_t rnp_get_default_homedir(char **homedir);</span>
<a href="#l6.178"></a><span id="l6.178" class="difflineplus">+RNP_API rnp_result_t rnp_get_default_homedir(char **homedir);</span>
<a href="#l6.179"></a><span id="l6.179"> </span>
<a href="#l6.180"></a><span id="l6.180"> /** try to detect the formats and paths of the homedir keyrings</span>
<a href="#l6.181"></a><span id="l6.181">  *</span>
<a href="#l6.182"></a><span id="l6.182">  * @param homedir the path to the home directory (example: /home/user/.rnp)</span>
<a href="#l6.183"></a><span id="l6.183">  * @param pub_format pointer that will be set to the format of the public keyring.</span>
<a href="#l6.184"></a><span id="l6.184">  *        The caller should free this with rnp_buffer_free.</span>
<a href="#l6.185"></a><span id="l6.185">  * @param pub_path pointer that will be set to the path to the public keyring.</span>
<a href="#l6.186"></a><span id="l6.186">  *        The caller should free this with rnp_buffer_free.</span>
<a href="#l6.187"></a><span id="l6.187">  * @param sec_format pointer that will be set to the format of the secret keyring.</span>
<a href="#l6.188"></a><span id="l6.188">  *        The caller should free this with rnp_buffer_free.</span>
<a href="#l6.189"></a><span id="l6.189">  * @param sec_path pointer that will be set to the path to the secret keyring.</span>
<a href="#l6.190"></a><span id="l6.190">  *        The caller should free this with rnp_buffer_free.</span>
<a href="#l6.191"></a><span id="l6.191">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.192"></a><span id="l6.192">  */</span>
<a href="#l6.193"></a><span id="l6.193" class="difflineminus">-rnp_result_t rnp_detect_homedir_info(</span>
<a href="#l6.194"></a><span id="l6.194" class="difflineplus">+RNP_API rnp_result_t rnp_detect_homedir_info(</span>
<a href="#l6.195"></a><span id="l6.195">   const char *homedir, char **pub_format, char **pub_path, char **sec_format, char **sec_path);</span>
<a href="#l6.196"></a><span id="l6.196"> </span>
<a href="#l6.197"></a><span id="l6.197"> /** try to detect the key format of the provided data</span>
<a href="#l6.198"></a><span id="l6.198">  *</span>
<a href="#l6.199"></a><span id="l6.199">  * @param buf the key data, must not be NULL</span>
<a href="#l6.200"></a><span id="l6.200">  * @param buf_len the size of the buffer, must be &gt; 0</span>
<a href="#l6.201"></a><span id="l6.201">  * @param format pointer that will be set to the format of the keyring.</span>
<a href="#l6.202"></a><span id="l6.202">  *        Must not be NULL. The caller should free this with rnp_buffer_free.</span>
<a href="#l6.203"></a><span id="l6.203">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.204"></a><span id="l6.204">  */</span>
<a href="#l6.205"></a><span id="l6.205" class="difflineminus">-rnp_result_t rnp_detect_key_format(const uint8_t buf[], size_t buf_len, char **format);</span>
<a href="#l6.206"></a><span id="l6.206" class="difflineplus">+RNP_API rnp_result_t rnp_detect_key_format(const uint8_t buf[], size_t buf_len, char **format);</span>
<a href="#l6.207"></a><span id="l6.207"> </span>
<a href="#l6.208"></a><span id="l6.208"> /** Get the number of s2k hash iterations, based on calculation time requested.</span>
<a href="#l6.209"></a><span id="l6.209">  *  Number of iterations is used to derive encryption key from password.</span>
<a href="#l6.210"></a><span id="l6.210">  *</span>
<a href="#l6.211"></a><span id="l6.211">  * @param hash hash algorithm to try</span>
<a href="#l6.212"></a><span id="l6.212">  * @param msec number of milliseconds which will be needed to derive key from the password.</span>
<a href="#l6.213"></a><span id="l6.213">  *             Since it depends on CPU speed the calculated value will make sense only for the</span>
<a href="#l6.214"></a><span id="l6.214">  *             system it was calculated for.</span>
<a href="#l6.215"></a><span id="l6.215">  * @param iterations approximate number of iterations to satisfy time complexity.</span>
<a href="#l6.216"></a><span id="l6.216">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.217"></a><span id="l6.217">  */</span>
<a href="#l6.218"></a><span id="l6.218" class="difflineminus">-rnp_result_t rnp_calculate_iterations(const char *hash, size_t msec, size_t *iterations);</span>
<a href="#l6.219"></a><span id="l6.219" class="difflineplus">+RNP_API rnp_result_t rnp_calculate_iterations(const char *hash,</span>
<a href="#l6.220"></a><span id="l6.220" class="difflineplus">+                                              size_t      msec,</span>
<a href="#l6.221"></a><span id="l6.221" class="difflineplus">+                                              size_t *    iterations);</span>
<a href="#l6.222"></a><span id="l6.222"> </span>
<a href="#l6.223"></a><span id="l6.223"> /** Check whether rnp supports specific feature (algorithm, elliptic curve, whatever else).</span>
<a href="#l6.224"></a><span id="l6.224">  *</span>
<a href="#l6.225"></a><span id="l6.225">  * @param type string with the feature type:</span>
<a href="#l6.226"></a><span id="l6.226">  *             - 'symmetric algorithm'</span>
<a href="#l6.227"></a><span id="l6.227">  *             - 'aead algorithm'</span>
<a href="#l6.228"></a><span id="l6.228">  *             - 'protection mode'</span>
<a href="#l6.229"></a><span id="l6.229">  *             - 'public key algorithm'</span>
<a href="#l6.230"></a><span id="l6.230">  *             - 'hash algorithm'</span>
<a href="#l6.231"></a><span id="l6.231">  *             - 'compression algorithm'</span>
<a href="#l6.232"></a><span id="l6.232">  *             - 'elliptic curve'</span>
<a href="#l6.233"></a><span id="l6.233">  * @param name value of the feature to check whether it is supported.</span>
<a href="#l6.234"></a><span id="l6.234">  * @param supported will contain true or false depending whether feature is supported or not.</span>
<a href="#l6.235"></a><span id="l6.235">  * @return RNP_SUCCESS on success or any other value on error.</span>
<a href="#l6.236"></a><span id="l6.236">  */</span>
<a href="#l6.237"></a><span id="l6.237" class="difflineminus">-rnp_result_t rnp_supports_feature(const char *type, const char *name, bool *supported);</span>
<a href="#l6.238"></a><span id="l6.238" class="difflineplus">+RNP_API rnp_result_t rnp_supports_feature(const char *type, const char *name, bool *supported);</span>
<a href="#l6.239"></a><span id="l6.239"> </span>
<a href="#l6.240"></a><span id="l6.240"> /** Get the JSON with array of supported rnp feature values (algorithms, curves, etc) by type.</span>
<a href="#l6.241"></a><span id="l6.241">  *</span>
<a href="#l6.242"></a><span id="l6.242">  * @param type type of the feature. See rnp_supports_feature() function for possible values.</span>
<a href="#l6.243"></a><span id="l6.243">  * @param result after successfull execution will contain the JSON with supported feature</span>
<a href="#l6.244"></a><span id="l6.244">  * values. You must destroy it using the rnp_buffer_destroy() function.</span>
<a href="#l6.245"></a><span id="l6.245">  * @return RNP_SUCCESS on success or any other value on error.</span>
<a href="#l6.246"></a><span id="l6.246">  */</span>
<a href="#l6.247"></a><span id="l6.247" class="difflineminus">-rnp_result_t rnp_supported_features(const char *type, char **result);</span>
<a href="#l6.248"></a><span id="l6.248" class="difflineplus">+RNP_API rnp_result_t rnp_supported_features(const char *type, char **result);</span>
<a href="#l6.249"></a><span id="l6.249"> </span>
<a href="#l6.250"></a><span id="l6.250"> /**</span>
<a href="#l6.251"></a><span id="l6.251">  * @brief Request password via configured FFI's callback</span>
<a href="#l6.252"></a><span id="l6.252">  *</span>
<a href="#l6.253"></a><span id="l6.253">  * @param ffi initialized FFI structure</span>
<a href="#l6.254"></a><span id="l6.254">  * @param key key handle for which password is requested. May be NULL.</span>
<a href="#l6.255"></a><span id="l6.255">  * @param context string describing the purpose of password request. See description of</span>
<a href="#l6.256"></a><span id="l6.256">  *                rnp_password_cb for the list of possible values. Also you may use any</span>
<a href="#l6.257"></a><span id="l6.257">  *                custom one as far as your password callback handles it.</span>
<a href="#l6.258"></a><span id="l6.258">  * @param password password will be put here on success. Must be destroyed via</span>
<a href="#l6.259"></a><span id="l6.259">  *                 rnp_buffer_destroy(), also it is good idea to securely clear it via</span>
<a href="#l6.260"></a><span id="l6.260">  *                 rnp_buffer_clear().</span>
<a href="#l6.261"></a><span id="l6.261">  * @return RNP_SUCCESS or other value on error.</span>
<a href="#l6.262"></a><span id="l6.262">  */</span>
<a href="#l6.263"></a><span id="l6.263" class="difflineminus">-rnp_result_t rnp_request_password(rnp_ffi_t        ffi,</span>
<a href="#l6.264"></a><span id="l6.264" class="difflineminus">-                                  rnp_key_handle_t key,</span>
<a href="#l6.265"></a><span id="l6.265" class="difflineminus">-                                  const char *     context,</span>
<a href="#l6.266"></a><span id="l6.266" class="difflineminus">-                                  char **          password);</span>
<a href="#l6.267"></a><span id="l6.267" class="difflineplus">+RNP_API rnp_result_t rnp_request_password(rnp_ffi_t        ffi,</span>
<a href="#l6.268"></a><span id="l6.268" class="difflineplus">+                                          rnp_key_handle_t key,</span>
<a href="#l6.269"></a><span id="l6.269" class="difflineplus">+                                          const char *     context,</span>
<a href="#l6.270"></a><span id="l6.270" class="difflineplus">+                                          char **          password);</span>
<a href="#l6.271"></a><span id="l6.271"> </span>
<a href="#l6.272"></a><span id="l6.272"> /** load keys</span>
<a href="#l6.273"></a><span id="l6.273">  *</span>
<a href="#l6.274"></a><span id="l6.274">  * Note that for G10, the input must be a directory (which must already exist).</span>
<a href="#l6.275"></a><span id="l6.275">  *</span>
<a href="#l6.276"></a><span id="l6.276">  * @param ffi</span>
<a href="#l6.277"></a><span id="l6.277">  * @param format the key format of the data (GPG, KBX, G10). Must not be NULL.</span>
<a href="#l6.278"></a><span id="l6.278">  * @param input source to read from.</span>
<a href="#l6.279"></a><span id="l6.279">  * @param flags the flags. See RNP_LOAD_SAVE_*.</span>
<a href="#l6.280"></a><span id="l6.280">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.281"></a><span id="l6.281">  */</span>
<a href="#l6.282"></a><span id="l6.282" class="difflineminus">-rnp_result_t rnp_load_keys(rnp_ffi_t   ffi,</span>
<a href="#l6.283"></a><span id="l6.283" class="difflineminus">-                           const char *format,</span>
<a href="#l6.284"></a><span id="l6.284" class="difflineminus">-                           rnp_input_t input,</span>
<a href="#l6.285"></a><span id="l6.285" class="difflineminus">-                           uint32_t    flags);</span>
<a href="#l6.286"></a><span id="l6.286" class="difflineplus">+RNP_API rnp_result_t rnp_load_keys(rnp_ffi_t   ffi,</span>
<a href="#l6.287"></a><span id="l6.287" class="difflineplus">+                                   const char *format,</span>
<a href="#l6.288"></a><span id="l6.288" class="difflineplus">+                                   rnp_input_t input,</span>
<a href="#l6.289"></a><span id="l6.289" class="difflineplus">+                                   uint32_t    flags);</span>
<a href="#l6.290"></a><span id="l6.290"> </span>
<a href="#l6.291"></a><span id="l6.291"> /** unload public and/or secret keys</span>
<a href="#l6.292"></a><span id="l6.292">  *  Note: After unloading all key handles will become invalid and must be destroyed.</span>
<a href="#l6.293"></a><span id="l6.293">  * @param ffi</span>
<a href="#l6.294"></a><span id="l6.294">  * @param flags choose which keys should be unloaded (pubic, secret or both).</span>
<a href="#l6.295"></a><span id="l6.295">  *              See RNP_KEY_UNLOAD_PUBLIC/RNP_KEY_UNLOAD_SECRET.</span>
<a href="#l6.296"></a><span id="l6.296">  * @return RNP_SUCCESS on success, or any other value on error.</span>
<a href="#l6.297"></a><span id="l6.297">  */</span>
<a href="#l6.298"></a><span id="l6.298" class="difflineminus">-rnp_result_t rnp_unload_keys(rnp_ffi_t ffi, uint32_t flags);</span>
<a href="#l6.299"></a><span id="l6.299" class="difflineplus">+RNP_API rnp_result_t rnp_unload_keys(rnp_ffi_t ffi, uint32_t flags);</span>
<a href="#l6.300"></a><span id="l6.300"> </span>
<a href="#l6.301"></a><span id="l6.301"> /** import keys to the keyring and receive JSON list of the new/updated keys.</span>
<a href="#l6.302"></a><span id="l6.302">  *  Note: this will work only with keys in OpenPGP format, use rnp_load_keys for other formats.</span>
<a href="#l6.303"></a><span id="l6.303">  * @param ffi</span>
<a href="#l6.304"></a><span id="l6.304">  * @param input source to read from. Cannot be NULL.</span>
<a href="#l6.305"></a><span id="l6.305">  * @param flags see RNP_LOAD_SAVE_* constants. If RNP_LOAD_SAVE_PERMISSIVE is specified</span>
<a href="#l6.306"></a><span id="l6.306">  *              then import process will skip unrecognized or bad keys/signatures instead of</span>
<a href="#l6.307"></a><span id="l6.307">  *              failing the whole operation.</span>
<a href="#l6.308"></a><span id="l6.308">  * @param results if not NULL then after the successfull execution will contain JSON with</span>
<a href="#l6.309"></a><span id="l6.309">  *                information about new and updated keys. You must free it using the</span>
<a href="#l6.310"></a><span id="l6.310">  *                rnp_buffer_destroy() function.</span>
<a href="#l6.311"></a><span id="l6.311">  * @return RNP_SUCCESS on success, or any other value on error.</span>
<a href="#l6.312"></a><span id="l6.312">  */</span>
<a href="#l6.313"></a><span id="l6.313" class="difflineminus">-rnp_result_t rnp_import_keys(rnp_ffi_t ffi, rnp_input_t input, uint32_t flags, char **results);</span>
<a href="#l6.314"></a><span id="l6.314" class="difflineplus">+RNP_API rnp_result_t rnp_import_keys(rnp_ffi_t   ffi,</span>
<a href="#l6.315"></a><span id="l6.315" class="difflineplus">+                                     rnp_input_t input,</span>
<a href="#l6.316"></a><span id="l6.316" class="difflineplus">+                                     uint32_t    flags,</span>
<a href="#l6.317"></a><span id="l6.317" class="difflineplus">+                                     char **     results);</span>
<a href="#l6.318"></a><span id="l6.318"> </span>
<a href="#l6.319"></a><span id="l6.319"> /** import standalone signatures to the keyring and receive JSON list of the updated keys.</span>
<a href="#l6.320"></a><span id="l6.320">  *</span>
<a href="#l6.321"></a><span id="l6.321">  *  @param ffi</span>
<a href="#l6.322"></a><span id="l6.322">  *  @param input source to read from. Cannot be NULL.</span>
<a href="#l6.323"></a><span id="l6.323">  *  @param flags additional import flags, currently must be 0.</span>
<a href="#l6.324"></a><span id="l6.324">  *  @param results if not NULL then after the successfull execution will contain JSON with</span>
<a href="#l6.325"></a><span id="l6.325">  *                 information about the updated keys. You must free it using the</span>
<a href="#l6.326"></a><span id="l6.326">  *                 rnp_buffer_destroy() function.</span>
<a href="#l6.327"></a><span id="l6.327">  *  @return RNP_SUCCESS on success, or any other value on error.</span>
<a href="#l6.328"></a><span id="l6.328">  */</span>
<a href="#l6.329"></a><span id="l6.329" class="difflineminus">-rnp_result_t rnp_import_signatures(rnp_ffi_t   ffi,</span>
<a href="#l6.330"></a><span id="l6.330" class="difflineminus">-                                   rnp_input_t input,</span>
<a href="#l6.331"></a><span id="l6.331" class="difflineminus">-                                   uint32_t    flags,</span>
<a href="#l6.332"></a><span id="l6.332" class="difflineminus">-                                   char **     results);</span>
<a href="#l6.333"></a><span id="l6.333" class="difflineplus">+RNP_API rnp_result_t rnp_import_signatures(rnp_ffi_t   ffi,</span>
<a href="#l6.334"></a><span id="l6.334" class="difflineplus">+                                           rnp_input_t input,</span>
<a href="#l6.335"></a><span id="l6.335" class="difflineplus">+                                           uint32_t    flags,</span>
<a href="#l6.336"></a><span id="l6.336" class="difflineplus">+                                           char **     results);</span>
<a href="#l6.337"></a><span id="l6.337"> </span>
<a href="#l6.338"></a><span id="l6.338"> /** save keys</span>
<a href="#l6.339"></a><span id="l6.339">  *</span>
<a href="#l6.340"></a><span id="l6.340">  * Note that for G10, the output must be a directory (which must already exist).</span>
<a href="#l6.341"></a><span id="l6.341">  *</span>
<a href="#l6.342"></a><span id="l6.342">  * @param ffi</span>
<a href="#l6.343"></a><span id="l6.343">  * @param format the key format of the data (GPG, KBX, G10). Must not be NULL.</span>
<a href="#l6.344"></a><span id="l6.344">  * @param output the output destination to write to.</span>
<a href="#l6.345"></a><span id="l6.345">  * @param flags the flags. See RNP_LOAD_SAVE_*.</span>
<a href="#l6.346"></a><span id="l6.346">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.347"></a><span id="l6.347">  */</span>
<a href="#l6.348"></a><span id="l6.348" class="difflineminus">-rnp_result_t rnp_save_keys(rnp_ffi_t    ffi,</span>
<a href="#l6.349"></a><span id="l6.349" class="difflineminus">-                           const char * format,</span>
<a href="#l6.350"></a><span id="l6.350" class="difflineminus">-                           rnp_output_t output,</span>
<a href="#l6.351"></a><span id="l6.351" class="difflineminus">-                           uint32_t     flags);</span>
<a href="#l6.352"></a><span id="l6.352" class="difflineplus">+RNP_API rnp_result_t rnp_save_keys(rnp_ffi_t    ffi,</span>
<a href="#l6.353"></a><span id="l6.353" class="difflineplus">+                                   const char * format,</span>
<a href="#l6.354"></a><span id="l6.354" class="difflineplus">+                                   rnp_output_t output,</span>
<a href="#l6.355"></a><span id="l6.355" class="difflineplus">+                                   uint32_t     flags);</span>
<a href="#l6.356"></a><span id="l6.356"> </span>
<a href="#l6.357"></a><span id="l6.357" class="difflineminus">-rnp_result_t rnp_get_public_key_count(rnp_ffi_t ffi, size_t *count);</span>
<a href="#l6.358"></a><span id="l6.358" class="difflineminus">-rnp_result_t rnp_get_secret_key_count(rnp_ffi_t ffi, size_t *count);</span>
<a href="#l6.359"></a><span id="l6.359" class="difflineplus">+RNP_API rnp_result_t rnp_get_public_key_count(rnp_ffi_t ffi, size_t *count);</span>
<a href="#l6.360"></a><span id="l6.360" class="difflineplus">+RNP_API rnp_result_t rnp_get_secret_key_count(rnp_ffi_t ffi, size_t *count);</span>
<a href="#l6.361"></a><span id="l6.361"> </span>
<a href="#l6.362"></a><span id="l6.362"> /** search for the key</span>
<a href="#l6.363"></a><span id="l6.363">  *</span>
<a href="#l6.364"></a><span id="l6.364">  *  @param ffi</span>
<a href="#l6.365"></a><span id="l6.365">  *  @param identifier_type string with type of the identifier: userid, keyid, fingerprint, grip</span>
<a href="#l6.366"></a><span id="l6.366">  *  @param identifier for userid is the userid string, for other search types - hex string</span>
<a href="#l6.367"></a><span id="l6.367">  *         representation of the value</span>
<a href="#l6.368"></a><span id="l6.368">  *  @param key if key was found then the resulting key handle will be stored here, otherwise it</span>
<a href="#l6.369"></a><span id="l6.369">  *         will contain NULL value. You must free handle after use with rnp_key_handle_destroy.</span>
<a href="#l6.370"></a><span id="l6.370">  *  @return RNP_SUCCESS on success (including case where key is not found), or any other value</span>
<a href="#l6.371"></a><span id="l6.371">  * on error</span>
<a href="#l6.372"></a><span id="l6.372">  */</span>
<a href="#l6.373"></a><span id="l6.373" class="difflineminus">-rnp_result_t rnp_locate_key(rnp_ffi_t         ffi,</span>
<a href="#l6.374"></a><span id="l6.374" class="difflineminus">-                            const char *      identifier_type,</span>
<a href="#l6.375"></a><span id="l6.375" class="difflineminus">-                            const char *      identifier,</span>
<a href="#l6.376"></a><span id="l6.376" class="difflineminus">-                            rnp_key_handle_t *key);</span>
<a href="#l6.377"></a><span id="l6.377" class="difflineplus">+RNP_API rnp_result_t rnp_locate_key(rnp_ffi_t         ffi,</span>
<a href="#l6.378"></a><span id="l6.378" class="difflineplus">+                                    const char *      identifier_type,</span>
<a href="#l6.379"></a><span id="l6.379" class="difflineplus">+                                    const char *      identifier,</span>
<a href="#l6.380"></a><span id="l6.380" class="difflineplus">+                                    rnp_key_handle_t *key);</span>
<a href="#l6.381"></a><span id="l6.381"> </span>
<a href="#l6.382"></a><span id="l6.382" class="difflineminus">-rnp_result_t rnp_key_handle_destroy(rnp_key_handle_t key);</span>
<a href="#l6.383"></a><span id="l6.383" class="difflineplus">+RNP_API rnp_result_t rnp_key_handle_destroy(rnp_key_handle_t key);</span>
<a href="#l6.384"></a><span id="l6.384"> </span>
<a href="#l6.385"></a><span id="l6.385"> /** generate a key or pair of keys using a JSON description</span>
<a href="#l6.386"></a><span id="l6.386">  *</span>
<a href="#l6.387"></a><span id="l6.387">  *  Notes:</span>
<a href="#l6.388"></a><span id="l6.388">  *  - When generating a subkey, the  pass provider may be required.</span>
<a href="#l6.389"></a><span id="l6.389">  *</span>
<a href="#l6.390"></a><span id="l6.390">  *  @param ffi</span>
<a href="#l6.391"></a><span id="l6.391">  *  @param json the json data that describes the key generation.</span>
<a href="#l6.392"></a><span id="l6.392">  *         Must not be NULL.</span>
<a href="#l6.393"></a><span id="l6.393">  *  @param results pointer that will be set to the JSON results.</span>
<a href="#l6.394"></a><span id="l6.394">  *         Must not be NULL. The caller should free this with rnp_buffer_destroy.</span>
<a href="#l6.395"></a><span id="l6.395">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.396"></a><span id="l6.396">  */</span>
<a href="#l6.397"></a><span id="l6.397" class="difflineminus">-rnp_result_t rnp_generate_key_json(rnp_ffi_t ffi, const char *json, char **results);</span>
<a href="#l6.398"></a><span id="l6.398" class="difflineplus">+RNP_API rnp_result_t rnp_generate_key_json(rnp_ffi_t ffi, const char *json, char **results);</span>
<a href="#l6.399"></a><span id="l6.399"> </span>
<a href="#l6.400"></a><span id="l6.400"> /* Key operations */</span>
<a href="#l6.401"></a><span id="l6.401"> </span>
<a href="#l6.402"></a><span id="l6.402"> /** Shortcut function for rsa key-subkey pair generation. See rnp_generate_key_ex() for the</span>
<a href="#l6.403"></a><span id="l6.403">  *  detailed parameters description.</span>
<a href="#l6.404"></a><span id="l6.404">  */</span>
<a href="#l6.405"></a><span id="l6.405" class="difflineminus">-rnp_result_t rnp_generate_key_rsa(rnp_ffi_t         ffi,</span>
<a href="#l6.406"></a><span id="l6.406" class="difflineminus">-                                  uint32_t          bits,</span>
<a href="#l6.407"></a><span id="l6.407" class="difflineminus">-                                  uint32_t          subbits,</span>
<a href="#l6.408"></a><span id="l6.408" class="difflineminus">-                                  const char *      userid,</span>
<a href="#l6.409"></a><span id="l6.409" class="difflineminus">-                                  const char *      password,</span>
<a href="#l6.410"></a><span id="l6.410" class="difflineminus">-                                  rnp_key_handle_t *key);</span>
<a href="#l6.411"></a><span id="l6.411" class="difflineplus">+RNP_API rnp_result_t rnp_generate_key_rsa(rnp_ffi_t         ffi,</span>
<a href="#l6.412"></a><span id="l6.412" class="difflineplus">+                                          uint32_t          bits,</span>
<a href="#l6.413"></a><span id="l6.413" class="difflineplus">+                                          uint32_t          subbits,</span>
<a href="#l6.414"></a><span id="l6.414" class="difflineplus">+                                          const char *      userid,</span>
<a href="#l6.415"></a><span id="l6.415" class="difflineplus">+                                          const char *      password,</span>
<a href="#l6.416"></a><span id="l6.416" class="difflineplus">+                                          rnp_key_handle_t *key);</span>
<a href="#l6.417"></a><span id="l6.417"> </span>
<a href="#l6.418"></a><span id="l6.418"> /** Shortcut function for DSA/ElGamal key-subkey pair generation. See rnp_generate_key_ex() for</span>
<a href="#l6.419"></a><span id="l6.419">  *  the detailed parameters description.</span>
<a href="#l6.420"></a><span id="l6.420">  */</span>
<a href="#l6.421"></a><span id="l6.421" class="difflineminus">-rnp_result_t rnp_generate_key_dsa_eg(rnp_ffi_t         ffi,</span>
<a href="#l6.422"></a><span id="l6.422" class="difflineminus">-                                     uint32_t          bits,</span>
<a href="#l6.423"></a><span id="l6.423" class="difflineminus">-                                     uint32_t          subbits,</span>
<a href="#l6.424"></a><span id="l6.424" class="difflineminus">-                                     const char *      userid,</span>
<a href="#l6.425"></a><span id="l6.425" class="difflineminus">-                                     const char *      password,</span>
<a href="#l6.426"></a><span id="l6.426" class="difflineminus">-                                     rnp_key_handle_t *key);</span>
<a href="#l6.427"></a><span id="l6.427" class="difflineplus">+RNP_API rnp_result_t rnp_generate_key_dsa_eg(rnp_ffi_t         ffi,</span>
<a href="#l6.428"></a><span id="l6.428" class="difflineplus">+                                             uint32_t          bits,</span>
<a href="#l6.429"></a><span id="l6.429" class="difflineplus">+                                             uint32_t          subbits,</span>
<a href="#l6.430"></a><span id="l6.430" class="difflineplus">+                                             const char *      userid,</span>
<a href="#l6.431"></a><span id="l6.431" class="difflineplus">+                                             const char *      password,</span>
<a href="#l6.432"></a><span id="l6.432" class="difflineplus">+                                             rnp_key_handle_t *key);</span>
<a href="#l6.433"></a><span id="l6.433"> </span>
<a href="#l6.434"></a><span id="l6.434"> /** Shortcut function for ECDSA/ECDH key-subkey pair generation. See rnp_generate_key_ex() for</span>
<a href="#l6.435"></a><span id="l6.435">  *  the detailed parameters description.</span>
<a href="#l6.436"></a><span id="l6.436">  */</span>
<a href="#l6.437"></a><span id="l6.437" class="difflineminus">-rnp_result_t rnp_generate_key_ec(rnp_ffi_t         ffi,</span>
<a href="#l6.438"></a><span id="l6.438" class="difflineminus">-                                 const char *      curve,</span>
<a href="#l6.439"></a><span id="l6.439" class="difflineminus">-                                 const char *      userid,</span>
<a href="#l6.440"></a><span id="l6.440" class="difflineminus">-                                 const char *      password,</span>
<a href="#l6.441"></a><span id="l6.441" class="difflineminus">-                                 rnp_key_handle_t *key);</span>
<a href="#l6.442"></a><span id="l6.442" class="difflineplus">+RNP_API rnp_result_t rnp_generate_key_ec(rnp_ffi_t         ffi,</span>
<a href="#l6.443"></a><span id="l6.443" class="difflineplus">+                                         const char *      curve,</span>
<a href="#l6.444"></a><span id="l6.444" class="difflineplus">+                                         const char *      userid,</span>
<a href="#l6.445"></a><span id="l6.445" class="difflineplus">+                                         const char *      password,</span>
<a href="#l6.446"></a><span id="l6.446" class="difflineplus">+                                         rnp_key_handle_t *key);</span>
<a href="#l6.447"></a><span id="l6.447"> </span>
<a href="#l6.448"></a><span id="l6.448"> /** Shortcut function for EdDSA/x25519 key-subkey pair generation. See rnp_generate_key_ex()</span>
<a href="#l6.449"></a><span id="l6.449">  *  for the detailed parameters description.</span>
<a href="#l6.450"></a><span id="l6.450">  */</span>
<a href="#l6.451"></a><span id="l6.451" class="difflineminus">-rnp_result_t rnp_generate_key_25519(rnp_ffi_t         ffi,</span>
<a href="#l6.452"></a><span id="l6.452" class="difflineminus">-                                    const char *      userid,</span>
<a href="#l6.453"></a><span id="l6.453" class="difflineminus">-                                    const char *      password,</span>
<a href="#l6.454"></a><span id="l6.454" class="difflineminus">-                                    rnp_key_handle_t *key);</span>
<a href="#l6.455"></a><span id="l6.455" class="difflineplus">+RNP_API rnp_result_t rnp_generate_key_25519(rnp_ffi_t         ffi,</span>
<a href="#l6.456"></a><span id="l6.456" class="difflineplus">+                                            const char *      userid,</span>
<a href="#l6.457"></a><span id="l6.457" class="difflineplus">+                                            const char *      password,</span>
<a href="#l6.458"></a><span id="l6.458" class="difflineplus">+                                            rnp_key_handle_t *key);</span>
<a href="#l6.459"></a><span id="l6.459"> </span>
<a href="#l6.460"></a><span id="l6.460"> /** Shortcut function for SM2/SM2 key-subkey pair generation. See rnp_generate_key_ex() for</span>
<a href="#l6.461"></a><span id="l6.461">  *  for the detailed parameters description.</span>
<a href="#l6.462"></a><span id="l6.462">  */</span>
<a href="#l6.463"></a><span id="l6.463" class="difflineminus">-rnp_result_t rnp_generate_key_sm2(rnp_ffi_t         ffi,</span>
<a href="#l6.464"></a><span id="l6.464" class="difflineminus">-                                  const char *      userid,</span>
<a href="#l6.465"></a><span id="l6.465" class="difflineminus">-                                  const char *      password,</span>
<a href="#l6.466"></a><span id="l6.466" class="difflineminus">-                                  rnp_key_handle_t *key);</span>
<a href="#l6.467"></a><span id="l6.467" class="difflineplus">+RNP_API rnp_result_t rnp_generate_key_sm2(rnp_ffi_t         ffi,</span>
<a href="#l6.468"></a><span id="l6.468" class="difflineplus">+                                          const char *      userid,</span>
<a href="#l6.469"></a><span id="l6.469" class="difflineplus">+                                          const char *      password,</span>
<a href="#l6.470"></a><span id="l6.470" class="difflineplus">+                                          rnp_key_handle_t *key);</span>
<a href="#l6.471"></a><span id="l6.471"> </span>
<a href="#l6.472"></a><span id="l6.472"> /**</span>
<a href="#l6.473"></a><span id="l6.473">  * @brief Shortcut for quick key generation. While it is used in other shortcut functions for</span>
<a href="#l6.474"></a><span id="l6.474">  *        key generation</span>
<a href="#l6.475"></a><span id="l6.475">  *</span>
<a href="#l6.476"></a><span id="l6.476">  * @param ffi</span>
<a href="#l6.477"></a><span id="l6.477">  * @param key_alg string with primary key algorithm. Cannot be NULL.</span>
<a href="#l6.478"></a><span id="l6.478">  * @param sub_alg string with subkey algorithm. If NULL then subkey will not be generated.</span>
<a href="#l6.479"></a><span id="l6.479" class="difflineat">@@ -557,291 +565,297 @@ rnp_result_t rnp_generate_key_sm2(rnp_ff</span>
<a href="#l6.480"></a><span id="l6.480">  *              otherwise error will be returned.</span>
<a href="#l6.481"></a><span id="l6.481">  * @param sub_curve Subkey curve name. Must be non-NULL only with EC-based subkey algorithm,</span>
<a href="#l6.482"></a><span id="l6.482">  *               otherwise error will be returned.</span>
<a href="#l6.483"></a><span id="l6.483">  * @param userid String with userid. Cannot be NULL.</span>
<a href="#l6.484"></a><span id="l6.484">  * @param key if non-NULL, then handle of the primary key will be stored here on success.</span>
<a href="#l6.485"></a><span id="l6.485">  *            Caller must destroy it with rnp_key_handle_destroy() call.</span>
<a href="#l6.486"></a><span id="l6.486">  * @return RNP_SUCCESS or error code instead.</span>
<a href="#l6.487"></a><span id="l6.487">  */</span>
<a href="#l6.488"></a><span id="l6.488" class="difflineminus">-rnp_result_t rnp_generate_key_ex(rnp_ffi_t         ffi,</span>
<a href="#l6.489"></a><span id="l6.489" class="difflineminus">-                                 const char *      key_alg,</span>
<a href="#l6.490"></a><span id="l6.490" class="difflineminus">-                                 const char *      sub_alg,</span>
<a href="#l6.491"></a><span id="l6.491" class="difflineminus">-                                 uint32_t          key_bits,</span>
<a href="#l6.492"></a><span id="l6.492" class="difflineminus">-                                 uint32_t          sub_bits,</span>
<a href="#l6.493"></a><span id="l6.493" class="difflineminus">-                                 const char *      key_curve,</span>
<a href="#l6.494"></a><span id="l6.494" class="difflineminus">-                                 const char *      sub_curve,</span>
<a href="#l6.495"></a><span id="l6.495" class="difflineminus">-                                 const char *      userid,</span>
<a href="#l6.496"></a><span id="l6.496" class="difflineminus">-                                 const char *      password,</span>
<a href="#l6.497"></a><span id="l6.497" class="difflineminus">-                                 rnp_key_handle_t *key);</span>
<a href="#l6.498"></a><span id="l6.498" class="difflineplus">+RNP_API rnp_result_t rnp_generate_key_ex(rnp_ffi_t         ffi,</span>
<a href="#l6.499"></a><span id="l6.499" class="difflineplus">+                                         const char *      key_alg,</span>
<a href="#l6.500"></a><span id="l6.500" class="difflineplus">+                                         const char *      sub_alg,</span>
<a href="#l6.501"></a><span id="l6.501" class="difflineplus">+                                         uint32_t          key_bits,</span>
<a href="#l6.502"></a><span id="l6.502" class="difflineplus">+                                         uint32_t          sub_bits,</span>
<a href="#l6.503"></a><span id="l6.503" class="difflineplus">+                                         const char *      key_curve,</span>
<a href="#l6.504"></a><span id="l6.504" class="difflineplus">+                                         const char *      sub_curve,</span>
<a href="#l6.505"></a><span id="l6.505" class="difflineplus">+                                         const char *      userid,</span>
<a href="#l6.506"></a><span id="l6.506" class="difflineplus">+                                         const char *      password,</span>
<a href="#l6.507"></a><span id="l6.507" class="difflineplus">+                                         rnp_key_handle_t *key);</span>
<a href="#l6.508"></a><span id="l6.508"> </span>
<a href="#l6.509"></a><span id="l6.509"> /** Create key generation context for the primary key.</span>
<a href="#l6.510"></a><span id="l6.510">  *  To generate a subkey use function rnp_op_generate_subkey_create() instead.</span>
<a href="#l6.511"></a><span id="l6.511">  *  Note: pass provider is required if generated key needs protection.</span>
<a href="#l6.512"></a><span id="l6.512">  *</span>
<a href="#l6.513"></a><span id="l6.513">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.514"></a><span id="l6.514">  * @param ffi</span>
<a href="#l6.515"></a><span id="l6.515">  * @param alg key algorithm as string. Must be able to sign. Currently the following algorithms</span>
<a href="#l6.516"></a><span id="l6.516">  *            are supported (case-insensetive) : 'rsa', 'dsa', 'ecdsa', 'eddsa', 'sm2'.</span>
<a href="#l6.517"></a><span id="l6.517">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.518"></a><span id="l6.518">  */</span>
<a href="#l6.519"></a><span id="l6.519" class="difflineminus">-rnp_result_t rnp_op_generate_create(rnp_op_generate_t *op, rnp_ffi_t ffi, const char *alg);</span>
<a href="#l6.520"></a><span id="l6.520" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_create(rnp_op_generate_t *op,</span>
<a href="#l6.521"></a><span id="l6.521" class="difflineplus">+                                            rnp_ffi_t          ffi,</span>
<a href="#l6.522"></a><span id="l6.522" class="difflineplus">+                                            const char *       alg);</span>
<a href="#l6.523"></a><span id="l6.523"> </span>
<a href="#l6.524"></a><span id="l6.524"> /** Create key generation context for the subkey.</span>
<a href="#l6.525"></a><span id="l6.525">  *  Note: you need to have primary key before calling this function. It can be loaded from</span>
<a href="#l6.526"></a><span id="l6.526">  * keyring or generated via the function rnp_op_generate_create(). Also pass provider is needed</span>
<a href="#l6.527"></a><span id="l6.527">  * if primary key is encrypted (protected and locked).</span>
<a href="#l6.528"></a><span id="l6.528">  *</span>
<a href="#l6.529"></a><span id="l6.529">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.530"></a><span id="l6.530">  * @param ffi</span>
<a href="#l6.531"></a><span id="l6.531">  * @param primary primary key handle, must have secret part.</span>
<a href="#l6.532"></a><span id="l6.532">  * @param alg key algorithm as string. Currently the following algorithms are supported</span>
<a href="#l6.533"></a><span id="l6.533">  * (case-insensetive) : 'rsa', 'dsa', 'elgamal', 'ecdsa', 'eddsa', 'ecdh', 'sm2'.</span>
<a href="#l6.534"></a><span id="l6.534">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.535"></a><span id="l6.535">  */</span>
<a href="#l6.536"></a><span id="l6.536" class="difflineminus">-rnp_result_t rnp_op_generate_subkey_create(rnp_op_generate_t *op,</span>
<a href="#l6.537"></a><span id="l6.537" class="difflineminus">-                                           rnp_ffi_t          ffi,</span>
<a href="#l6.538"></a><span id="l6.538" class="difflineminus">-                                           rnp_key_handle_t   primary,</span>
<a href="#l6.539"></a><span id="l6.539" class="difflineminus">-                                           const char *       alg);</span>
<a href="#l6.540"></a><span id="l6.540" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_subkey_create(rnp_op_generate_t *op,</span>
<a href="#l6.541"></a><span id="l6.541" class="difflineplus">+                                                   rnp_ffi_t          ffi,</span>
<a href="#l6.542"></a><span id="l6.542" class="difflineplus">+                                                   rnp_key_handle_t   primary,</span>
<a href="#l6.543"></a><span id="l6.543" class="difflineplus">+                                                   const char *       alg);</span>
<a href="#l6.544"></a><span id="l6.544"> </span>
<a href="#l6.545"></a><span id="l6.545"> /** Set bits of the generated key or subkey.</span>
<a href="#l6.546"></a><span id="l6.546">  *  Note: this is applicable only to rsa, dsa and el-gamal keys.</span>
<a href="#l6.547"></a><span id="l6.547">  *</span>
<a href="#l6.548"></a><span id="l6.548">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.549"></a><span id="l6.549">  * @param bits number of bits</span>
<a href="#l6.550"></a><span id="l6.550">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.551"></a><span id="l6.551">  */</span>
<a href="#l6.552"></a><span id="l6.552" class="difflineminus">-rnp_result_t rnp_op_generate_set_bits(rnp_op_generate_t op, uint32_t bits);</span>
<a href="#l6.553"></a><span id="l6.553" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_bits(rnp_op_generate_t op, uint32_t bits);</span>
<a href="#l6.554"></a><span id="l6.554"> </span>
<a href="#l6.555"></a><span id="l6.555"> /** Set hash algorithm used in self signature or subkey binding signature.</span>
<a href="#l6.556"></a><span id="l6.556">  *</span>
<a href="#l6.557"></a><span id="l6.557">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.558"></a><span id="l6.558">  * @param hash string with hash algorithm name. Following hash algorithms are supported:</span>
<a href="#l6.559"></a><span id="l6.559">  *             &quot;MD5&quot;, &quot;SHA1&quot;, &quot;RIPEMD160&quot;, &quot;SHA256&quot;, &quot;SHA384&quot;, &quot;SHA512&quot;, &quot;SHA224&quot;, &quot;SM3&quot;</span>
<a href="#l6.560"></a><span id="l6.560">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.561"></a><span id="l6.561">  */</span>
<a href="#l6.562"></a><span id="l6.562" class="difflineminus">-rnp_result_t rnp_op_generate_set_hash(rnp_op_generate_t op, const char *hash);</span>
<a href="#l6.563"></a><span id="l6.563" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_hash(rnp_op_generate_t op, const char *hash);</span>
<a href="#l6.564"></a><span id="l6.564"> </span>
<a href="#l6.565"></a><span id="l6.565"> /** Set size of q parameter for DSA key.</span>
<a href="#l6.566"></a><span id="l6.566">  *  Note: appropriate default value will be set, depending on key bits. However you may</span>
<a href="#l6.567"></a><span id="l6.567">  *        override it if needed.</span>
<a href="#l6.568"></a><span id="l6.568">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.569"></a><span id="l6.569">  * @param qbits number of bits</span>
<a href="#l6.570"></a><span id="l6.570">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.571"></a><span id="l6.571">  */</span>
<a href="#l6.572"></a><span id="l6.572" class="difflineminus">-rnp_result_t rnp_op_generate_set_dsa_qbits(rnp_op_generate_t op, uint32_t qbits);</span>
<a href="#l6.573"></a><span id="l6.573" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_dsa_qbits(rnp_op_generate_t op, uint32_t qbits);</span>
<a href="#l6.574"></a><span id="l6.574"> </span>
<a href="#l6.575"></a><span id="l6.575"> /** Set the curve used for ECC key</span>
<a href="#l6.576"></a><span id="l6.576">  *  Note: this is only applicable for ECDSA, ECDH and SM2 keys.</span>
<a href="#l6.577"></a><span id="l6.577">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.578"></a><span id="l6.578">  * @param curve string with curve name. Following curve names may be used:</span>
<a href="#l6.579"></a><span id="l6.579">  *              &quot;NIST P-256&quot;, &quot;NIST P-384&quot;, &quot;NIST P-521&quot;, &quot;Curve25519&quot; (ECDH only),</span>
<a href="#l6.580"></a><span id="l6.580">  *              &quot;brainpoolP256r1&quot;, &quot;brainpoolP384r1&quot;, &quot;brainpoolP512r1&quot;, &quot;secp256k1&quot;,</span>
<a href="#l6.581"></a><span id="l6.581">  *              &quot;SM2 P-256&quot; (SM2 only)</span>
<a href="#l6.582"></a><span id="l6.582">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.583"></a><span id="l6.583">  */</span>
<a href="#l6.584"></a><span id="l6.584" class="difflineminus">-rnp_result_t rnp_op_generate_set_curve(rnp_op_generate_t op, const char *curve);</span>
<a href="#l6.585"></a><span id="l6.585" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_curve(rnp_op_generate_t op, const char *curve);</span>
<a href="#l6.586"></a><span id="l6.586"> </span>
<a href="#l6.587"></a><span id="l6.587"> /** Set password, used to encrypt secret key data. If this method is not called then</span>
<a href="#l6.588"></a><span id="l6.588">  *  key will be generated without protection (unencrypted).</span>
<a href="#l6.589"></a><span id="l6.589">  *</span>
<a href="#l6.590"></a><span id="l6.590">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.591"></a><span id="l6.591">  * @param password string with password, could not be NULL. Will be copied internally so may</span>
<a href="#l6.592"></a><span id="l6.592">  *                 be safely freed after the call.</span>
<a href="#l6.593"></a><span id="l6.593">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.594"></a><span id="l6.594">  */</span>
<a href="#l6.595"></a><span id="l6.595" class="difflineminus">-rnp_result_t rnp_op_generate_set_protection_password(rnp_op_generate_t op,</span>
<a href="#l6.596"></a><span id="l6.596" class="difflineminus">-                                                     const char *      password);</span>
<a href="#l6.597"></a><span id="l6.597" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_protection_password(rnp_op_generate_t op,</span>
<a href="#l6.598"></a><span id="l6.598" class="difflineplus">+                                                             const char *      password);</span>
<a href="#l6.599"></a><span id="l6.599"> </span>
<a href="#l6.600"></a><span id="l6.600"> /**</span>
<a href="#l6.601"></a><span id="l6.601">  * @brief Enable or disable password requesting via ffi's password provider. This password</span>
<a href="#l6.602"></a><span id="l6.602">  *        then will be used for key encryption.</span>
<a href="#l6.603"></a><span id="l6.603">  *        Note: this will be ignored if password was set via</span>
<a href="#l6.604"></a><span id="l6.604">  *        rnp_op_generate_set_protection_password().</span>
<a href="#l6.605"></a><span id="l6.605">  *</span>
<a href="#l6.606"></a><span id="l6.606">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.607"></a><span id="l6.607">  * @param request true to enable password requesting or false otherwise. Default value is false</span>
<a href="#l6.608"></a><span id="l6.608">  *                (i.e. key will be generated unencrypted).</span>
<a href="#l6.609"></a><span id="l6.609">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.610"></a><span id="l6.610">  */</span>
<a href="#l6.611"></a><span id="l6.611" class="difflineminus">-rnp_result_t rnp_op_generate_set_request_password(rnp_op_generate_t op, bool request);</span>
<a href="#l6.612"></a><span id="l6.612" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_request_password(rnp_op_generate_t op, bool request);</span>
<a href="#l6.613"></a><span id="l6.613"> </span>
<a href="#l6.614"></a><span id="l6.614"> /** Set cipher used to encrypt secret key data. If not called then default one will be used.</span>
<a href="#l6.615"></a><span id="l6.615">  *</span>
<a href="#l6.616"></a><span id="l6.616">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.617"></a><span id="l6.617">  * @param cipher string with cipher name. Following ciphers are supported:</span>
<a href="#l6.618"></a><span id="l6.618">  *               &quot;Idea&quot;, &quot;Tripledes&quot;, &quot;Cast5&quot;, &quot;Blowfish&quot;, &quot;AES128&quot;, &quot;AES192&quot;, &quot;AES256&quot;,</span>
<a href="#l6.619"></a><span id="l6.619">  *               &quot;Twofish&quot;, &quot;Camellia128&quot;, &quot;Camellia192&quot;, &quot;Camellia256&quot;, &quot;SM4&quot;.</span>
<a href="#l6.620"></a><span id="l6.620">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.621"></a><span id="l6.621">  */</span>
<a href="#l6.622"></a><span id="l6.622" class="difflineminus">-rnp_result_t rnp_op_generate_set_protection_cipher(rnp_op_generate_t op, const char *cipher);</span>
<a href="#l6.623"></a><span id="l6.623" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_protection_cipher(rnp_op_generate_t op,</span>
<a href="#l6.624"></a><span id="l6.624" class="difflineplus">+                                                           const char *      cipher);</span>
<a href="#l6.625"></a><span id="l6.625"> </span>
<a href="#l6.626"></a><span id="l6.626"> /** Set hash algorithm, used to derive key from password for secret key data encryption.</span>
<a href="#l6.627"></a><span id="l6.627">  *  If not called then default one will be used.</span>
<a href="#l6.628"></a><span id="l6.628">  *</span>
<a href="#l6.629"></a><span id="l6.629">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.630"></a><span id="l6.630">  * @param hash string with hash algorithm, see rnp_op_generate_set_hash() for the whole list.</span>
<a href="#l6.631"></a><span id="l6.631">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.632"></a><span id="l6.632">  */</span>
<a href="#l6.633"></a><span id="l6.633" class="difflineminus">-rnp_result_t rnp_op_generate_set_protection_hash(rnp_op_generate_t op, const char *hash);</span>
<a href="#l6.634"></a><span id="l6.634" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_protection_hash(rnp_op_generate_t op,</span>
<a href="#l6.635"></a><span id="l6.635" class="difflineplus">+                                                         const char *      hash);</span>
<a href="#l6.636"></a><span id="l6.636"> </span>
<a href="#l6.637"></a><span id="l6.637"> /** Set encryption mode, used for secret key data encryption.</span>
<a href="#l6.638"></a><span id="l6.638">  *  Note: currently this makes sense only for G10 key format</span>
<a href="#l6.639"></a><span id="l6.639">  *</span>
<a href="#l6.640"></a><span id="l6.640">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.641"></a><span id="l6.641">  * @param mode string with mode name: &quot;CFB&quot;, &quot;CBC&quot;, &quot;OCB&quot;</span>
<a href="#l6.642"></a><span id="l6.642">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.643"></a><span id="l6.643">  */</span>
<a href="#l6.644"></a><span id="l6.644" class="difflineminus">-rnp_result_t rnp_op_generate_set_protection_mode(rnp_op_generate_t op, const char *mode);</span>
<a href="#l6.645"></a><span id="l6.645" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_protection_mode(rnp_op_generate_t op,</span>
<a href="#l6.646"></a><span id="l6.646" class="difflineplus">+                                                         const char *      mode);</span>
<a href="#l6.647"></a><span id="l6.647"> </span>
<a href="#l6.648"></a><span id="l6.648"> /** Set number of iterations used to derive key from password for secret key encryption.</span>
<a href="#l6.649"></a><span id="l6.649">  *  If not called then default one will be used.</span>
<a href="#l6.650"></a><span id="l6.650">  *</span>
<a href="#l6.651"></a><span id="l6.651">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.652"></a><span id="l6.652">  * @param iterations number of iterations</span>
<a href="#l6.653"></a><span id="l6.653">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.654"></a><span id="l6.654">  */</span>
<a href="#l6.655"></a><span id="l6.655" class="difflineminus">-rnp_result_t rnp_op_generate_set_protection_iterations(rnp_op_generate_t op,</span>
<a href="#l6.656"></a><span id="l6.656" class="difflineminus">-                                                       uint32_t          iterations);</span>
<a href="#l6.657"></a><span id="l6.657" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_protection_iterations(rnp_op_generate_t op,</span>
<a href="#l6.658"></a><span id="l6.658" class="difflineplus">+                                                               uint32_t          iterations);</span>
<a href="#l6.659"></a><span id="l6.659"> </span>
<a href="#l6.660"></a><span id="l6.660"> /** Add key usage flag to the key or subkey.</span>
<a href="#l6.661"></a><span id="l6.661">  *  Note: use it only if you need to override defaults, which depend on primary key or subkey,</span>
<a href="#l6.662"></a><span id="l6.662">  *        and public key algorithm.</span>
<a href="#l6.663"></a><span id="l6.663">  *</span>
<a href="#l6.664"></a><span id="l6.664">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.665"></a><span id="l6.665">  * @param usage string, representing key usage. Following values are supported: &quot;sign&quot;,</span>
<a href="#l6.666"></a><span id="l6.666">  *              &quot;certify&quot;, &quot;encrypt&quot;, &quot;authenticate&quot;.</span>
<a href="#l6.667"></a><span id="l6.667">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.668"></a><span id="l6.668">  */</span>
<a href="#l6.669"></a><span id="l6.669" class="difflineminus">-rnp_result_t rnp_op_generate_add_usage(rnp_op_generate_t op, const char *usage);</span>
<a href="#l6.670"></a><span id="l6.670" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_add_usage(rnp_op_generate_t op, const char *usage);</span>
<a href="#l6.671"></a><span id="l6.671"> </span>
<a href="#l6.672"></a><span id="l6.672"> /** Reset key usage flags, so default ones will be used during key/subkey generation</span>
<a href="#l6.673"></a><span id="l6.673">  *</span>
<a href="#l6.674"></a><span id="l6.674">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.675"></a><span id="l6.675">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.676"></a><span id="l6.676">  */</span>
<a href="#l6.677"></a><span id="l6.677" class="difflineminus">-rnp_result_t rnp_op_generate_clear_usage(rnp_op_generate_t op);</span>
<a href="#l6.678"></a><span id="l6.678" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_clear_usage(rnp_op_generate_t op);</span>
<a href="#l6.679"></a><span id="l6.679"> </span>
<a href="#l6.680"></a><span id="l6.680"> /** Set the userid which will represent the generate key.</span>
<a href="#l6.681"></a><span id="l6.681">  *  Note: Makes sense only for primary key generation.</span>
<a href="#l6.682"></a><span id="l6.682">  *</span>
<a href="#l6.683"></a><span id="l6.683">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.684"></a><span id="l6.684">  * @param userid NULL-terminated string with userid.</span>
<a href="#l6.685"></a><span id="l6.685">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.686"></a><span id="l6.686">  */</span>
<a href="#l6.687"></a><span id="l6.687" class="difflineminus">-rnp_result_t rnp_op_generate_set_userid(rnp_op_generate_t op, const char *userid);</span>
<a href="#l6.688"></a><span id="l6.688" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_userid(rnp_op_generate_t op, const char *userid);</span>
<a href="#l6.689"></a><span id="l6.689"> </span>
<a href="#l6.690"></a><span id="l6.690"> /** Set the key or subkey expiration time.</span>
<a href="#l6.691"></a><span id="l6.691">  *</span>
<a href="#l6.692"></a><span id="l6.692">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.693"></a><span id="l6.693">  * @param expiration expiration time in seconds. 0 value means that key doesn't expire.</span>
<a href="#l6.694"></a><span id="l6.694">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.695"></a><span id="l6.695">  */</span>
<a href="#l6.696"></a><span id="l6.696" class="difflineminus">-rnp_result_t rnp_op_generate_set_expiration(rnp_op_generate_t op, uint32_t expiration);</span>
<a href="#l6.697"></a><span id="l6.697" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_expiration(rnp_op_generate_t op, uint32_t expiration);</span>
<a href="#l6.698"></a><span id="l6.698"> </span>
<a href="#l6.699"></a><span id="l6.699"> /** Add preferred hash to user preferences.</span>
<a href="#l6.700"></a><span id="l6.700">  *  Note: the first added hash algorithm has the highest priority, then the second and so on.</span>
<a href="#l6.701"></a><span id="l6.701">  *        Applicable only for the primary key generation.</span>
<a href="#l6.702"></a><span id="l6.702">  *</span>
<a href="#l6.703"></a><span id="l6.703">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.704"></a><span id="l6.704">  * @param hash string, representing the hash algorithm. See the rnp_op_generate_set_hash()</span>
<a href="#l6.705"></a><span id="l6.705">  *             function description for the list of possible values.</span>
<a href="#l6.706"></a><span id="l6.706">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.707"></a><span id="l6.707">  */</span>
<a href="#l6.708"></a><span id="l6.708" class="difflineminus">-rnp_result_t rnp_op_generate_add_pref_hash(rnp_op_generate_t op, const char *hash);</span>
<a href="#l6.709"></a><span id="l6.709" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_add_pref_hash(rnp_op_generate_t op, const char *hash);</span>
<a href="#l6.710"></a><span id="l6.710"> </span>
<a href="#l6.711"></a><span id="l6.711"> /** Clear the preferred hash algorithms list, so default ones will be used.</span>
<a href="#l6.712"></a><span id="l6.712">  *</span>
<a href="#l6.713"></a><span id="l6.713">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.714"></a><span id="l6.714">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.715"></a><span id="l6.715">  */</span>
<a href="#l6.716"></a><span id="l6.716" class="difflineminus">-rnp_result_t rnp_op_generate_clear_pref_hashes(rnp_op_generate_t op);</span>
<a href="#l6.717"></a><span id="l6.717" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_clear_pref_hashes(rnp_op_generate_t op);</span>
<a href="#l6.718"></a><span id="l6.718"> </span>
<a href="#l6.719"></a><span id="l6.719"> /** Add preferred compression algorithm to user preferences.</span>
<a href="#l6.720"></a><span id="l6.720">  *  Note: the first added algorithm has the highest priority, then the second and so on.</span>
<a href="#l6.721"></a><span id="l6.721">  *        Applicable only for the primary key generation.</span>
<a href="#l6.722"></a><span id="l6.722">  *</span>
<a href="#l6.723"></a><span id="l6.723">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.724"></a><span id="l6.724">  * @param compression string, representing the compression algorithm. Possible values are:</span>
<a href="#l6.725"></a><span id="l6.725">  *                    &quot;zip&quot;, &quot;zlib&quot;, &quot;bzip2&quot;</span>
<a href="#l6.726"></a><span id="l6.726">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.727"></a><span id="l6.727">  */</span>
<a href="#l6.728"></a><span id="l6.728" class="difflineminus">-rnp_result_t rnp_op_generate_add_pref_compression(rnp_op_generate_t op,</span>
<a href="#l6.729"></a><span id="l6.729" class="difflineminus">-                                                  const char *      compression);</span>
<a href="#l6.730"></a><span id="l6.730" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_add_pref_compression(rnp_op_generate_t op,</span>
<a href="#l6.731"></a><span id="l6.731" class="difflineplus">+                                                          const char *      compression);</span>
<a href="#l6.732"></a><span id="l6.732"> </span>
<a href="#l6.733"></a><span id="l6.733"> /** Clear the preferred compression algorithms list, so default ones will be used.</span>
<a href="#l6.734"></a><span id="l6.734">  *</span>
<a href="#l6.735"></a><span id="l6.735">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.736"></a><span id="l6.736">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.737"></a><span id="l6.737">  */</span>
<a href="#l6.738"></a><span id="l6.738" class="difflineminus">-rnp_result_t rnp_op_generate_clear_pref_compression(rnp_op_generate_t op);</span>
<a href="#l6.739"></a><span id="l6.739" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_clear_pref_compression(rnp_op_generate_t op);</span>
<a href="#l6.740"></a><span id="l6.740"> </span>
<a href="#l6.741"></a><span id="l6.741"> /** Add preferred encryption algorithm to user preferences.</span>
<a href="#l6.742"></a><span id="l6.742">  *  Note: the first added algorithm has the highest priority, then the second and so on.</span>
<a href="#l6.743"></a><span id="l6.743">  *        Applicable only for the primary key generation.</span>
<a href="#l6.744"></a><span id="l6.744">  *</span>
<a href="#l6.745"></a><span id="l6.745">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.746"></a><span id="l6.746">  * @param cipher string, representing the encryption algorithm.</span>
<a href="#l6.747"></a><span id="l6.747">  *               See the rnp_op_generate_set_protection_cipher() function description for</span>
<a href="#l6.748"></a><span id="l6.748">  *               the list of possible values.</span>
<a href="#l6.749"></a><span id="l6.749">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.750"></a><span id="l6.750">  */</span>
<a href="#l6.751"></a><span id="l6.751" class="difflineminus">-rnp_result_t rnp_op_generate_add_pref_cipher(rnp_op_generate_t op, const char *cipher);</span>
<a href="#l6.752"></a><span id="l6.752" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_add_pref_cipher(rnp_op_generate_t op, const char *cipher);</span>
<a href="#l6.753"></a><span id="l6.753"> </span>
<a href="#l6.754"></a><span id="l6.754"> /** Clear the preferred encryption algorithms list, so default ones will be used.</span>
<a href="#l6.755"></a><span id="l6.755">  *</span>
<a href="#l6.756"></a><span id="l6.756">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.757"></a><span id="l6.757">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.758"></a><span id="l6.758">  */</span>
<a href="#l6.759"></a><span id="l6.759" class="difflineminus">-rnp_result_t rnp_op_generate_clear_pref_ciphers(rnp_op_generate_t op);</span>
<a href="#l6.760"></a><span id="l6.760" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_clear_pref_ciphers(rnp_op_generate_t op);</span>
<a href="#l6.761"></a><span id="l6.761"> </span>
<a href="#l6.762"></a><span id="l6.762"> /** Set the preferred key server. Applicable only for the primary key.</span>
<a href="#l6.763"></a><span id="l6.763">  *</span>
<a href="#l6.764"></a><span id="l6.764">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.765"></a><span id="l6.765">  * @param keyserver NULL-terminated string with key server's URL, or NULL to delete it from</span>
<a href="#l6.766"></a><span id="l6.766">  *                  user preferences.</span>
<a href="#l6.767"></a><span id="l6.767">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.768"></a><span id="l6.768">  */</span>
<a href="#l6.769"></a><span id="l6.769" class="difflineminus">-rnp_result_t rnp_op_generate_set_pref_keyserver(rnp_op_generate_t op, const char *keyserver);</span>
<a href="#l6.770"></a><span id="l6.770" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_set_pref_keyserver(rnp_op_generate_t op,</span>
<a href="#l6.771"></a><span id="l6.771" class="difflineplus">+                                                        const char *      keyserver);</span>
<a href="#l6.772"></a><span id="l6.772"> </span>
<a href="#l6.773"></a><span id="l6.773"> /** Execute the prepared key or subkey generation operation.</span>
<a href="#l6.774"></a><span id="l6.774">  *  Note: if you set protection algorithm, then you need to specify ffi password provider to</span>
<a href="#l6.775"></a><span id="l6.775">  *        be able to request password for key encryption.</span>
<a href="#l6.776"></a><span id="l6.776">  *</span>
<a href="#l6.777"></a><span id="l6.777">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.778"></a><span id="l6.778">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.779"></a><span id="l6.779">  */</span>
<a href="#l6.780"></a><span id="l6.780" class="difflineminus">-rnp_result_t rnp_op_generate_execute(rnp_op_generate_t op);</span>
<a href="#l6.781"></a><span id="l6.781" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_execute(rnp_op_generate_t op);</span>
<a href="#l6.782"></a><span id="l6.782"> </span>
<a href="#l6.783"></a><span id="l6.783"> /** Get the generated key's handle. Should be called only after successfull execution of</span>
<a href="#l6.784"></a><span id="l6.784">  *  rnp_op_generate_execute().</span>
<a href="#l6.785"></a><span id="l6.785">  *</span>
<a href="#l6.786"></a><span id="l6.786">  * @param op pointer to opaque key generation context.</span>
<a href="#l6.787"></a><span id="l6.787">  * @param handle pointer to key handle will be stored here.</span>
<a href="#l6.788"></a><span id="l6.788">  *            You must free handle after use with rnp_key_handle_destroy.</span>
<a href="#l6.789"></a><span id="l6.789">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.790"></a><span id="l6.790">  */</span>
<a href="#l6.791"></a><span id="l6.791" class="difflineminus">-rnp_result_t rnp_op_generate_get_key(rnp_op_generate_t op, rnp_key_handle_t *handle);</span>
<a href="#l6.792"></a><span id="l6.792" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_get_key(rnp_op_generate_t op, rnp_key_handle_t *handle);</span>
<a href="#l6.793"></a><span id="l6.793"> </span>
<a href="#l6.794"></a><span id="l6.794"> /** Free resources associated with signing operation.</span>
<a href="#l6.795"></a><span id="l6.795">  *</span>
<a href="#l6.796"></a><span id="l6.796">  *  @param op opaque key generation context. Must be successfully initialized with one of the</span>
<a href="#l6.797"></a><span id="l6.797">  *         rnp_op_generate_*_create functions.</span>
<a href="#l6.798"></a><span id="l6.798">  *  @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.799"></a><span id="l6.799">  */</span>
<a href="#l6.800"></a><span id="l6.800" class="difflineminus">-rnp_result_t rnp_op_generate_destroy(rnp_op_generate_t op);</span>
<a href="#l6.801"></a><span id="l6.801" class="difflineplus">+RNP_API rnp_result_t rnp_op_generate_destroy(rnp_op_generate_t op);</span>
<a href="#l6.802"></a><span id="l6.802"> </span>
<a href="#l6.803"></a><span id="l6.803"> /** export a key</span>
<a href="#l6.804"></a><span id="l6.804">  *</span>
<a href="#l6.805"></a><span id="l6.805">  *  @param key the key to export</span>
<a href="#l6.806"></a><span id="l6.806">  *  @param output the stream to write to</span>
<a href="#l6.807"></a><span id="l6.807">  *  @param flags see RNP_KEY_EXPORT_*.</span>
<a href="#l6.808"></a><span id="l6.808">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.809"></a><span id="l6.809">  **/</span>
<a href="#l6.810"></a><span id="l6.810" class="difflineminus">-rnp_result_t rnp_key_export(rnp_key_handle_t key, rnp_output_t output, uint32_t flags);</span>
<a href="#l6.811"></a><span id="l6.811" class="difflineplus">+RNP_API rnp_result_t rnp_key_export(rnp_key_handle_t key, rnp_output_t output, uint32_t flags);</span>
<a href="#l6.812"></a><span id="l6.812"> </span>
<a href="#l6.813"></a><span id="l6.813"> /**</span>
<a href="#l6.814"></a><span id="l6.814">  * @brief Generate and export primary key revocation signature.</span>
<a href="#l6.815"></a><span id="l6.815">  *        Note: to revoke a key you'll need to import this signature into the keystore or use</span>
<a href="#l6.816"></a><span id="l6.816">  *        rnp_key_revoke() function.</span>
<a href="#l6.817"></a><span id="l6.817">  * @param key primary key to be revoked. Must have secret key, otherwise keyrings will be</span>
<a href="#l6.818"></a><span id="l6.818">  *            searched for the authorized to issue revocation signature secret key. If secret</span>
<a href="#l6.819"></a><span id="l6.819">  *            key is locked then password will be asked via password provider.</span>
<a href="#l6.820"></a><span id="l6.820" class="difflineat">@@ -850,503 +864,520 @@ rnp_result_t rnp_key_export(rnp_key_hand</span>
<a href="#l6.821"></a><span id="l6.821">  * @param hash hash algorithm used to calculate signature. Pass NULL for default algorithm</span>
<a href="#l6.822"></a><span id="l6.822">  *             selection.</span>
<a href="#l6.823"></a><span id="l6.823">  * @param code reason for revocation code. Possible values: 'no', 'superseded', 'compromised',</span>
<a href="#l6.824"></a><span id="l6.824">  *             'retired'. May be NULL - then 'no' value will be used.</span>
<a href="#l6.825"></a><span id="l6.825">  * @param reason textual representation of the reason for revocation. May be NULL or empty</span>
<a href="#l6.826"></a><span id="l6.826">  *               string.</span>
<a href="#l6.827"></a><span id="l6.827">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.828"></a><span id="l6.828">  */</span>
<a href="#l6.829"></a><span id="l6.829" class="difflineminus">-rnp_result_t rnp_key_export_revocation(rnp_key_handle_t key,</span>
<a href="#l6.830"></a><span id="l6.830" class="difflineminus">-                                       rnp_output_t     output,</span>
<a href="#l6.831"></a><span id="l6.831" class="difflineminus">-                                       uint32_t         flags,</span>
<a href="#l6.832"></a><span id="l6.832" class="difflineminus">-                                       const char *     hash,</span>
<a href="#l6.833"></a><span id="l6.833" class="difflineminus">-                                       const char *     code,</span>
<a href="#l6.834"></a><span id="l6.834" class="difflineminus">-                                       const char *     reason);</span>
<a href="#l6.835"></a><span id="l6.835" class="difflineplus">+RNP_API rnp_result_t rnp_key_export_revocation(rnp_key_handle_t key,</span>
<a href="#l6.836"></a><span id="l6.836" class="difflineplus">+                                               rnp_output_t     output,</span>
<a href="#l6.837"></a><span id="l6.837" class="difflineplus">+                                               uint32_t         flags,</span>
<a href="#l6.838"></a><span id="l6.838" class="difflineplus">+                                               const char *     hash,</span>
<a href="#l6.839"></a><span id="l6.839" class="difflineplus">+                                               const char *     code,</span>
<a href="#l6.840"></a><span id="l6.840" class="difflineplus">+                                               const char *     reason);</span>
<a href="#l6.841"></a><span id="l6.841"> </span>
<a href="#l6.842"></a><span id="l6.842"> /**</span>
<a href="#l6.843"></a><span id="l6.843">  * @brief revoke a key or subkey by generating and adding revocation signature.</span>
<a href="#l6.844"></a><span id="l6.844">  * @param key key or subkey to be revoked. For primary key must have secret key, otherwise</span>
<a href="#l6.845"></a><span id="l6.845">  *            keyrings will be searched for the authorized to issue revocation signatures</span>
<a href="#l6.846"></a><span id="l6.846">  *            secret key. For subkey keyrings must have primary secret key.</span>
<a href="#l6.847"></a><span id="l6.847">  *            If secret key is locked then password will be asked via password provider.</span>
<a href="#l6.848"></a><span id="l6.848">  * @param flags currently must be 0.</span>
<a href="#l6.849"></a><span id="l6.849">  * @param hash hash algorithm used to calculate signature. Pass NULL for default algorithm</span>
<a href="#l6.850"></a><span id="l6.850">  *             selection.</span>
<a href="#l6.851"></a><span id="l6.851">  * @param code reason for revocation code. Possible values: 'no', 'superseded', 'compromised',</span>
<a href="#l6.852"></a><span id="l6.852">  *             'retired'. May be NULL - then 'no' value will be used.</span>
<a href="#l6.853"></a><span id="l6.853">  * @param reason textual representation of the reason for revocation. May be NULL or empty</span>
<a href="#l6.854"></a><span id="l6.854">  *               string.</span>
<a href="#l6.855"></a><span id="l6.855">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.856"></a><span id="l6.856">  */</span>
<a href="#l6.857"></a><span id="l6.857" class="difflineminus">-rnp_result_t rnp_key_revoke(rnp_key_handle_t key,</span>
<a href="#l6.858"></a><span id="l6.858" class="difflineminus">-                            uint32_t         flags,</span>
<a href="#l6.859"></a><span id="l6.859" class="difflineminus">-                            const char *     hash,</span>
<a href="#l6.860"></a><span id="l6.860" class="difflineminus">-                            const char *     code,</span>
<a href="#l6.861"></a><span id="l6.861" class="difflineminus">-                            const char *     reason);</span>
<a href="#l6.862"></a><span id="l6.862" class="difflineplus">+RNP_API rnp_result_t rnp_key_revoke(rnp_key_handle_t key,</span>
<a href="#l6.863"></a><span id="l6.863" class="difflineplus">+                                    uint32_t         flags,</span>
<a href="#l6.864"></a><span id="l6.864" class="difflineplus">+                                    const char *     hash,</span>
<a href="#l6.865"></a><span id="l6.865" class="difflineplus">+                                    const char *     code,</span>
<a href="#l6.866"></a><span id="l6.866" class="difflineplus">+                                    const char *     reason);</span>
<a href="#l6.867"></a><span id="l6.867"> </span>
<a href="#l6.868"></a><span id="l6.868"> /** remove a key from keyring(s)</span>
<a href="#l6.869"></a><span id="l6.869">  *  Note: you need to call rnp_save_keys() to write updated keyring(s) out.</span>
<a href="#l6.870"></a><span id="l6.870">  *        Other handles of the same key should not be used after this call.</span>
<a href="#l6.871"></a><span id="l6.871">  * @param key pointer to the key handle.</span>
<a href="#l6.872"></a><span id="l6.872">  * @param flags see RNP_KEY_REMOVE_* constants. Flag RNP_REMOVE_SUBKEYS will work only for</span>
<a href="#l6.873"></a><span id="l6.873">  *              primary key, and remove all of it's subkeys as well.</span>
<a href="#l6.874"></a><span id="l6.874">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.875"></a><span id="l6.875">  */</span>
<a href="#l6.876"></a><span id="l6.876" class="difflineminus">-rnp_result_t rnp_key_remove(rnp_key_handle_t key, uint32_t flags);</span>
<a href="#l6.877"></a><span id="l6.877" class="difflineplus">+RNP_API rnp_result_t rnp_key_remove(rnp_key_handle_t key, uint32_t flags);</span>
<a href="#l6.878"></a><span id="l6.878"> </span>
<a href="#l6.879"></a><span id="l6.879"> /** guess contents of the OpenPGP data stream.</span>
<a href="#l6.880"></a><span id="l6.880">  *</span>
<a href="#l6.881"></a><span id="l6.881">  * @param input stream with data. Must be opened and cannot be NULL.</span>
<a href="#l6.882"></a><span id="l6.882">  * @param contents string with guessed data format will be stored here.</span>
<a href="#l6.883"></a><span id="l6.883">  *                 Possible values: 'message', 'public key', 'secret key', 'signature',</span>
<a href="#l6.884"></a><span id="l6.884">  * 'unknown'. May be used as type in rnp_enarmor() function. Must be deallocated with</span>
<a href="#l6.885"></a><span id="l6.885">  * rnp_buffer_destroy() call.</span>
<a href="#l6.886"></a><span id="l6.886">  * @return RNP_SUCCESS on success, or any other value on error.</span>
<a href="#l6.887"></a><span id="l6.887">  */</span>
<a href="#l6.888"></a><span id="l6.888" class="difflineminus">-rnp_result_t rnp_guess_contents(rnp_input_t input, char **contents);</span>
<a href="#l6.889"></a><span id="l6.889" class="difflineplus">+RNP_API rnp_result_t rnp_guess_contents(rnp_input_t input, char **contents);</span>
<a href="#l6.890"></a><span id="l6.890"> </span>
<a href="#l6.891"></a><span id="l6.891"> /** Add ASCII Armor</span>
<a href="#l6.892"></a><span id="l6.892">  *</span>
<a href="#l6.893"></a><span id="l6.893">  *  @param input stream to read data from</span>
<a href="#l6.894"></a><span id="l6.894">  *  @param output stream to write armored data to</span>
<a href="#l6.895"></a><span id="l6.895">  *  @param type the type of armor to add (&quot;message&quot;, &quot;public key&quot;,</span>
<a href="#l6.896"></a><span id="l6.896">  *         &quot;secret key&quot;, &quot;signature&quot;, &quot;cleartext&quot;). Use NULL to try</span>
<a href="#l6.897"></a><span id="l6.897">  *         to guess the type.</span>
<a href="#l6.898"></a><span id="l6.898">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.899"></a><span id="l6.899">  */</span>
<a href="#l6.900"></a><span id="l6.900" class="difflineminus">-rnp_result_t rnp_enarmor(rnp_input_t input, rnp_output_t output, const char *type);</span>
<a href="#l6.901"></a><span id="l6.901" class="difflineplus">+RNP_API rnp_result_t rnp_enarmor(rnp_input_t input, rnp_output_t output, const char *type);</span>
<a href="#l6.902"></a><span id="l6.902"> </span>
<a href="#l6.903"></a><span id="l6.903"> /** Remove ASCII Armor</span>
<a href="#l6.904"></a><span id="l6.904">  *</span>
<a href="#l6.905"></a><span id="l6.905">  *  @param input stream to read armored data from</span>
<a href="#l6.906"></a><span id="l6.906">  *  @param output stream to write dearmored data to</span>
<a href="#l6.907"></a><span id="l6.907">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.908"></a><span id="l6.908">  */</span>
<a href="#l6.909"></a><span id="l6.909" class="difflineminus">-rnp_result_t rnp_dearmor(rnp_input_t input, rnp_output_t output);</span>
<a href="#l6.910"></a><span id="l6.910" class="difflineplus">+RNP_API rnp_result_t rnp_dearmor(rnp_input_t input, rnp_output_t output);</span>
<a href="#l6.911"></a><span id="l6.911"> </span>
<a href="#l6.912"></a><span id="l6.912"> /** Get key's primary user id.</span>
<a href="#l6.913"></a><span id="l6.913">  *</span>
<a href="#l6.914"></a><span id="l6.914">  * @param key key handle.</span>
<a href="#l6.915"></a><span id="l6.915">  * @param uid pointer to the string with primary user id will be stored here.</span>
<a href="#l6.916"></a><span id="l6.916">  *            You must free it using the rnp_buffer_destroy().</span>
<a href="#l6.917"></a><span id="l6.917">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.918"></a><span id="l6.918">  */</span>
<a href="#l6.919"></a><span id="l6.919" class="difflineminus">-rnp_result_t rnp_key_get_primary_uid(rnp_key_handle_t key, char **uid);</span>
<a href="#l6.920"></a><span id="l6.920" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_primary_uid(rnp_key_handle_t key, char **uid);</span>
<a href="#l6.921"></a><span id="l6.921"> </span>
<a href="#l6.922"></a><span id="l6.922"> /** Get number of the key's user ids.</span>
<a href="#l6.923"></a><span id="l6.923">  *</span>
<a href="#l6.924"></a><span id="l6.924">  * @param key key handle.</span>
<a href="#l6.925"></a><span id="l6.925">  * @param count number of user ids will be stored here.</span>
<a href="#l6.926"></a><span id="l6.926">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.927"></a><span id="l6.927">  */</span>
<a href="#l6.928"></a><span id="l6.928" class="difflineminus">-rnp_result_t rnp_key_get_uid_count(rnp_key_handle_t key, size_t *count);</span>
<a href="#l6.929"></a><span id="l6.929" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_uid_count(rnp_key_handle_t key, size_t *count);</span>
<a href="#l6.930"></a><span id="l6.930"> </span>
<a href="#l6.931"></a><span id="l6.931"> /** Get key's user id by it's index.</span>
<a href="#l6.932"></a><span id="l6.932">  *</span>
<a href="#l6.933"></a><span id="l6.933">  * @param key key handle.</span>
<a href="#l6.934"></a><span id="l6.934">  * @param idx zero-based index of the userid.</span>
<a href="#l6.935"></a><span id="l6.935">  * @param uid pointer to the string with user id will be stored here.</span>
<a href="#l6.936"></a><span id="l6.936">  *            You must free it using the rnp_buffer_destroy().</span>
<a href="#l6.937"></a><span id="l6.937">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.938"></a><span id="l6.938">  */</span>
<a href="#l6.939"></a><span id="l6.939" class="difflineminus">-rnp_result_t rnp_key_get_uid_at(rnp_key_handle_t key, size_t idx, char **uid);</span>
<a href="#l6.940"></a><span id="l6.940" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_uid_at(rnp_key_handle_t key, size_t idx, char **uid);</span>
<a href="#l6.941"></a><span id="l6.941"> </span>
<a href="#l6.942"></a><span id="l6.942"> /** Get key's user id handle by it's index.</span>
<a href="#l6.943"></a><span id="l6.943">  *  Note: user id handle may become invalid once corresponding user id or key is removed.</span>
<a href="#l6.944"></a><span id="l6.944">  *</span>
<a href="#l6.945"></a><span id="l6.945">  * @param key key handle</span>
<a href="#l6.946"></a><span id="l6.946">  * @param idx zero-based index of the userid.</span>
<a href="#l6.947"></a><span id="l6.947">  * @param uid user id handle will be stored here on success. You must destroy it</span>
<a href="#l6.948"></a><span id="l6.948">  *            using the rnp_uid_handle_destroy().</span>
<a href="#l6.949"></a><span id="l6.949">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.950"></a><span id="l6.950">  */</span>
<a href="#l6.951"></a><span id="l6.951" class="difflineminus">-rnp_result_t rnp_key_get_uid_handle_at(rnp_key_handle_t  key,</span>
<a href="#l6.952"></a><span id="l6.952" class="difflineminus">-                                       size_t            idx,</span>
<a href="#l6.953"></a><span id="l6.953" class="difflineminus">-                                       rnp_uid_handle_t *uid);</span>
<a href="#l6.954"></a><span id="l6.954" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_uid_handle_at(rnp_key_handle_t  key,</span>
<a href="#l6.955"></a><span id="l6.955" class="difflineplus">+                                               size_t            idx,</span>
<a href="#l6.956"></a><span id="l6.956" class="difflineplus">+                                               rnp_uid_handle_t *uid);</span>
<a href="#l6.957"></a><span id="l6.957"> </span>
<a href="#l6.958"></a><span id="l6.958"> /** Get number of key's signatures.</span>
<a href="#l6.959"></a><span id="l6.959">  *  Note: this will not count user id certifications and subkey(s) signatures if any.</span>
<a href="#l6.960"></a><span id="l6.960">  *        I.e. it will return only number of direct-key and key revocation signatures for the</span>
<a href="#l6.961"></a><span id="l6.961">  *        primary key, and number of subkey bindings/revocation signatures for the subkey.</span>
<a href="#l6.962"></a><span id="l6.962">  *        Use rnp_uid_get_signature_count() or call this function on subkey's handle.</span>
<a href="#l6.963"></a><span id="l6.963">  *</span>
<a href="#l6.964"></a><span id="l6.964">  * @param key key handle</span>
<a href="#l6.965"></a><span id="l6.965">  * @param count number of key's signatures will be stored here.</span>
<a href="#l6.966"></a><span id="l6.966">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.967"></a><span id="l6.967">  */</span>
<a href="#l6.968"></a><span id="l6.968" class="difflineminus">-rnp_result_t rnp_key_get_signature_count(rnp_key_handle_t key, size_t *count);</span>
<a href="#l6.969"></a><span id="l6.969" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_signature_count(rnp_key_handle_t key, size_t *count);</span>
<a href="#l6.970"></a><span id="l6.970"> </span>
<a href="#l6.971"></a><span id="l6.971"> /** Get key's signature, based on it's index.</span>
<a href="#l6.972"></a><span id="l6.972">  *  Note: see the rnp_key_get_signature_count() description for the details.</span>
<a href="#l6.973"></a><span id="l6.973">  *</span>
<a href="#l6.974"></a><span id="l6.974">  * @param key key handle</span>
<a href="#l6.975"></a><span id="l6.975">  * @param idx zero-based signature index.</span>
<a href="#l6.976"></a><span id="l6.976">  * @param sig signature handle will be stored here on success. You must free it after use with</span>
<a href="#l6.977"></a><span id="l6.977">  *            the rnp_signature_handle_destroy() function.</span>
<a href="#l6.978"></a><span id="l6.978">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.979"></a><span id="l6.979">  */</span>
<a href="#l6.980"></a><span id="l6.980" class="difflineminus">-rnp_result_t rnp_key_get_signature_at(rnp_key_handle_t        key,</span>
<a href="#l6.981"></a><span id="l6.981" class="difflineminus">-                                      size_t                  idx,</span>
<a href="#l6.982"></a><span id="l6.982" class="difflineminus">-                                      rnp_signature_handle_t *sig);</span>
<a href="#l6.983"></a><span id="l6.983" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_signature_at(rnp_key_handle_t        key,</span>
<a href="#l6.984"></a><span id="l6.984" class="difflineplus">+                                              size_t                  idx,</span>
<a href="#l6.985"></a><span id="l6.985" class="difflineplus">+                                              rnp_signature_handle_t *sig);</span>
<a href="#l6.986"></a><span id="l6.986"> </span>
<a href="#l6.987"></a><span id="l6.987"> /** Get the number of user id's signatures.</span>
<a href="#l6.988"></a><span id="l6.988">  *</span>
<a href="#l6.989"></a><span id="l6.989">  * @param uid user id handle.</span>
<a href="#l6.990"></a><span id="l6.990">  * @param count number of uid's signatures will be stored here.</span>
<a href="#l6.991"></a><span id="l6.991">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.992"></a><span id="l6.992">  */</span>
<a href="#l6.993"></a><span id="l6.993" class="difflineminus">-rnp_result_t rnp_uid_get_signature_count(rnp_uid_handle_t uid, size_t *count);</span>
<a href="#l6.994"></a><span id="l6.994" class="difflineplus">+RNP_API rnp_result_t rnp_uid_get_signature_count(rnp_uid_handle_t uid, size_t *count);</span>
<a href="#l6.995"></a><span id="l6.995"> </span>
<a href="#l6.996"></a><span id="l6.996"> /** Get user id's signature, based on it's index.</span>
<a href="#l6.997"></a><span id="l6.997">  *</span>
<a href="#l6.998"></a><span id="l6.998">  * @param uid uid handle.</span>
<a href="#l6.999"></a><span id="l6.999">  * @param idx zero-based signature index.</span>
<a href="#l6.1000"></a><span id="l6.1000">  * @param sig signature handle will be stored here on success. You must free it after use with</span>
<a href="#l6.1001"></a><span id="l6.1001">  *            the rnp_signature_handle_destroy() function.</span>
<a href="#l6.1002"></a><span id="l6.1002">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1003"></a><span id="l6.1003">  */</span>
<a href="#l6.1004"></a><span id="l6.1004" class="difflineminus">-rnp_result_t rnp_uid_get_signature_at(rnp_uid_handle_t        uid,</span>
<a href="#l6.1005"></a><span id="l6.1005" class="difflineminus">-                                      size_t                  idx,</span>
<a href="#l6.1006"></a><span id="l6.1006" class="difflineminus">-                                      rnp_signature_handle_t *sig);</span>
<a href="#l6.1007"></a><span id="l6.1007" class="difflineplus">+RNP_API rnp_result_t rnp_uid_get_signature_at(rnp_uid_handle_t        uid,</span>
<a href="#l6.1008"></a><span id="l6.1008" class="difflineplus">+                                              size_t                  idx,</span>
<a href="#l6.1009"></a><span id="l6.1009" class="difflineplus">+                                              rnp_signature_handle_t *sig);</span>
<a href="#l6.1010"></a><span id="l6.1010"> </span>
<a href="#l6.1011"></a><span id="l6.1011"> /** Get signature's algorithm.</span>
<a href="#l6.1012"></a><span id="l6.1012">  *</span>
<a href="#l6.1013"></a><span id="l6.1013">  * @param sig signature handle.</span>
<a href="#l6.1014"></a><span id="l6.1014">  * @param alg on success string with algorithm name will be saved here. Cannot be NULL.</span>
<a href="#l6.1015"></a><span id="l6.1015"> *            You must free it using the rnp_buffer_destroy().</span>
<a href="#l6.1016"></a><span id="l6.1016"> </span>
<a href="#l6.1017"></a><span id="l6.1017">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1018"></a><span id="l6.1018">  */</span>
<a href="#l6.1019"></a><span id="l6.1019" class="difflineminus">-rnp_result_t rnp_signature_get_alg(rnp_signature_handle_t sig, char **alg);</span>
<a href="#l6.1020"></a><span id="l6.1020" class="difflineplus">+RNP_API rnp_result_t rnp_signature_get_alg(rnp_signature_handle_t sig, char **alg);</span>
<a href="#l6.1021"></a><span id="l6.1021"> </span>
<a href="#l6.1022"></a><span id="l6.1022"> /** Get signature's hash algorithm.</span>
<a href="#l6.1023"></a><span id="l6.1023">  *</span>
<a href="#l6.1024"></a><span id="l6.1024">  * @param sig signature handle.</span>
<a href="#l6.1025"></a><span id="l6.1025">  * @param alg on success string with algorithm name will be saved here. Cannot be NULL.</span>
<a href="#l6.1026"></a><span id="l6.1026">  *            You must free it using the rnp_buffer_destroy().</span>
<a href="#l6.1027"></a><span id="l6.1027">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1028"></a><span id="l6.1028">  */</span>
<a href="#l6.1029"></a><span id="l6.1029" class="difflineminus">-rnp_result_t rnp_signature_get_hash_alg(rnp_signature_handle_t sig, char **alg);</span>
<a href="#l6.1030"></a><span id="l6.1030" class="difflineplus">+RNP_API rnp_result_t rnp_signature_get_hash_alg(rnp_signature_handle_t sig, char **alg);</span>
<a href="#l6.1031"></a><span id="l6.1031"> </span>
<a href="#l6.1032"></a><span id="l6.1032"> /** Get the signature creation time as number of seconds since Jan, 1 1970 UTC</span>
<a href="#l6.1033"></a><span id="l6.1033">  *</span>
<a href="#l6.1034"></a><span id="l6.1034">  * @param sig signature handle.</span>
<a href="#l6.1035"></a><span id="l6.1035">  * @param create on success result will be stored here. Cannot be NULL.</span>
<a href="#l6.1036"></a><span id="l6.1036">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1037"></a><span id="l6.1037">  */</span>
<a href="#l6.1038"></a><span id="l6.1038" class="difflineminus">-rnp_result_t rnp_signature_get_creation(rnp_signature_handle_t sig, uint32_t *create);</span>
<a href="#l6.1039"></a><span id="l6.1039" class="difflineplus">+RNP_API rnp_result_t rnp_signature_get_creation(rnp_signature_handle_t sig, uint32_t *create);</span>
<a href="#l6.1040"></a><span id="l6.1040"> </span>
<a href="#l6.1041"></a><span id="l6.1041"> /** Get signer's key id from the signature.</span>
<a href="#l6.1042"></a><span id="l6.1042">  *  Note: if key id is not available from the signature then NULL value will</span>
<a href="#l6.1043"></a><span id="l6.1043">  *        be stored to result.</span>
<a href="#l6.1044"></a><span id="l6.1044">  * @param sig signature handle</span>
<a href="#l6.1045"></a><span id="l6.1045">  * @param result hex-encoded key id will be stored here. Cannot be NULL. You must free it</span>
<a href="#l6.1046"></a><span id="l6.1046">  *               later on using the rnp_buffer_destroy() function.</span>
<a href="#l6.1047"></a><span id="l6.1047">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1048"></a><span id="l6.1048">  */</span>
<a href="#l6.1049"></a><span id="l6.1049" class="difflineminus">-rnp_result_t rnp_signature_get_keyid(rnp_signature_handle_t sig, char **result);</span>
<a href="#l6.1050"></a><span id="l6.1050" class="difflineplus">+RNP_API rnp_result_t rnp_signature_get_keyid(rnp_signature_handle_t sig, char **result);</span>
<a href="#l6.1051"></a><span id="l6.1051"> </span>
<a href="#l6.1052"></a><span id="l6.1052"> /** Get signing key handle, if available.</span>
<a href="#l6.1053"></a><span id="l6.1053">  *  Note: if signing key is not available then NULL will be stored in key.</span>
<a href="#l6.1054"></a><span id="l6.1054">  * @param sig signature handle</span>
<a href="#l6.1055"></a><span id="l6.1055">  * @param key on success and key availability will contain signing key's handle. You must</span>
<a href="#l6.1056"></a><span id="l6.1056">  *            destroy it using the rnp_key_handle_destroy() function.</span>
<a href="#l6.1057"></a><span id="l6.1057">  * @return RNP_SUCCESS or error code if f4ailed.</span>
<a href="#l6.1058"></a><span id="l6.1058">  */</span>
<a href="#l6.1059"></a><span id="l6.1059" class="difflineminus">-rnp_result_t rnp_signature_get_signer(rnp_signature_handle_t sig, rnp_key_handle_t *key);</span>
<a href="#l6.1060"></a><span id="l6.1060" class="difflineplus">+RNP_API rnp_result_t rnp_signature_get_signer(rnp_signature_handle_t sig,</span>
<a href="#l6.1061"></a><span id="l6.1061" class="difflineplus">+                                              rnp_key_handle_t *     key);</span>
<a href="#l6.1062"></a><span id="l6.1062"> </span>
<a href="#l6.1063"></a><span id="l6.1063"> /** Dump signature packet to JSON, obtaining the whole information about it.</span>
<a href="#l6.1064"></a><span id="l6.1064">  *</span>
<a href="#l6.1065"></a><span id="l6.1065">  * @param sig sigmature handle, cannot be NULL</span>
<a href="#l6.1066"></a><span id="l6.1066">  * @param flags include additional fields in JSON (see RNP_JSON_DUMP_MPI and other</span>
<a href="#l6.1067"></a><span id="l6.1067">  *              RNP_JSON_DUMP_* flags)</span>
<a href="#l6.1068"></a><span id="l6.1068">  * @param result resulting JSON string will be stored here. You must free it using the</span>
<a href="#l6.1069"></a><span id="l6.1069">  *               rnp_buffer_destroy() function.</span>
<a href="#l6.1070"></a><span id="l6.1070">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1071"></a><span id="l6.1071">  */</span>
<a href="#l6.1072"></a><span id="l6.1072" class="difflineminus">-rnp_result_t rnp_signature_packet_to_json(rnp_signature_handle_t sig,</span>
<a href="#l6.1073"></a><span id="l6.1073" class="difflineminus">-                                          uint32_t               flags,</span>
<a href="#l6.1074"></a><span id="l6.1074" class="difflineminus">-                                          char **                json);</span>
<a href="#l6.1075"></a><span id="l6.1075" class="difflineplus">+RNP_API rnp_result_t rnp_signature_packet_to_json(rnp_signature_handle_t sig,</span>
<a href="#l6.1076"></a><span id="l6.1076" class="difflineplus">+                                                  uint32_t               flags,</span>
<a href="#l6.1077"></a><span id="l6.1077" class="difflineplus">+                                                  char **                json);</span>
<a href="#l6.1078"></a><span id="l6.1078"> </span>
<a href="#l6.1079"></a><span id="l6.1079"> /** Free signature handle.</span>
<a href="#l6.1080"></a><span id="l6.1080">  *</span>
<a href="#l6.1081"></a><span id="l6.1081">  * @param sig signature handle.</span>
<a href="#l6.1082"></a><span id="l6.1082">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1083"></a><span id="l6.1083">  */</span>
<a href="#l6.1084"></a><span id="l6.1084" class="difflineminus">-rnp_result_t rnp_signature_handle_destroy(rnp_signature_handle_t sig);</span>
<a href="#l6.1085"></a><span id="l6.1085" class="difflineplus">+RNP_API rnp_result_t rnp_signature_handle_destroy(rnp_signature_handle_t sig);</span>
<a href="#l6.1086"></a><span id="l6.1086"> </span>
<a href="#l6.1087"></a><span id="l6.1087"> /** Check whether user id is revoked.</span>
<a href="#l6.1088"></a><span id="l6.1088">  *</span>
<a href="#l6.1089"></a><span id="l6.1089">  * @param uid user id handle, should not be NULL.</span>
<a href="#l6.1090"></a><span id="l6.1090">  * @param result boolean result will be stored here on success. Cannot be NULL.</span>
<a href="#l6.1091"></a><span id="l6.1091">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1092"></a><span id="l6.1092">  */</span>
<a href="#l6.1093"></a><span id="l6.1093" class="difflineminus">-rnp_result_t rnp_uid_is_revoked(rnp_uid_handle_t uid, bool *result);</span>
<a href="#l6.1094"></a><span id="l6.1094" class="difflineplus">+RNP_API rnp_result_t rnp_uid_is_revoked(rnp_uid_handle_t uid, bool *result);</span>
<a href="#l6.1095"></a><span id="l6.1095"> </span>
<a href="#l6.1096"></a><span id="l6.1096"> /** Destroy previously allocated user id handle.</span>
<a href="#l6.1097"></a><span id="l6.1097">  *</span>
<a href="#l6.1098"></a><span id="l6.1098">  * @param uid user id handle.</span>
<a href="#l6.1099"></a><span id="l6.1099">  * @return RNP_SUCCESS or error code</span>
<a href="#l6.1100"></a><span id="l6.1100">  */</span>
<a href="#l6.1101"></a><span id="l6.1101" class="difflineminus">-rnp_result_t rnp_uid_handle_destroy(rnp_uid_handle_t uid);</span>
<a href="#l6.1102"></a><span id="l6.1102" class="difflineplus">+RNP_API rnp_result_t rnp_uid_handle_destroy(rnp_uid_handle_t uid);</span>
<a href="#l6.1103"></a><span id="l6.1103"> </span>
<a href="#l6.1104"></a><span id="l6.1104"> /** Get number of the key's subkeys.</span>
<a href="#l6.1105"></a><span id="l6.1105">  *</span>
<a href="#l6.1106"></a><span id="l6.1106">  * @param key key handle.</span>
<a href="#l6.1107"></a><span id="l6.1107">  * @param count number of subkeys will be stored here.</span>
<a href="#l6.1108"></a><span id="l6.1108">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1109"></a><span id="l6.1109">  */</span>
<a href="#l6.1110"></a><span id="l6.1110" class="difflineminus">-rnp_result_t rnp_key_get_subkey_count(rnp_key_handle_t key, size_t *count);</span>
<a href="#l6.1111"></a><span id="l6.1111" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_subkey_count(rnp_key_handle_t key, size_t *count);</span>
<a href="#l6.1112"></a><span id="l6.1112"> </span>
<a href="#l6.1113"></a><span id="l6.1113"> /** Get the handle of one of the key's subkeys, using it's index in the list.</span>
<a href="#l6.1114"></a><span id="l6.1114">  *</span>
<a href="#l6.1115"></a><span id="l6.1115">  * @param key handle of the primary key.</span>
<a href="#l6.1116"></a><span id="l6.1116">  * @param idx zero-based index of the subkey.</span>
<a href="#l6.1117"></a><span id="l6.1117">  * @param subkey on success handle for the subkey will be stored here. You must free it</span>
<a href="#l6.1118"></a><span id="l6.1118">  *               using the rnp_key_handle_destroy() function.</span>
<a href="#l6.1119"></a><span id="l6.1119">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1120"></a><span id="l6.1120">  */</span>
<a href="#l6.1121"></a><span id="l6.1121" class="difflineminus">-rnp_result_t rnp_key_get_subkey_at(rnp_key_handle_t key, size_t idx, rnp_key_handle_t *subkey);</span>
<a href="#l6.1122"></a><span id="l6.1122" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_subkey_at(rnp_key_handle_t  key,</span>
<a href="#l6.1123"></a><span id="l6.1123" class="difflineplus">+                                           size_t            idx,</span>
<a href="#l6.1124"></a><span id="l6.1124" class="difflineplus">+                                           rnp_key_handle_t *subkey);</span>
<a href="#l6.1125"></a><span id="l6.1125"> </span>
<a href="#l6.1126"></a><span id="l6.1126"> /** Get the key's algorithm.</span>
<a href="#l6.1127"></a><span id="l6.1127">  *</span>
<a href="#l6.1128"></a><span id="l6.1128">  * @param key key handle</span>
<a href="#l6.1129"></a><span id="l6.1129">  * @param alg string with algorithm name will be stored here. You must free it using the</span>
<a href="#l6.1130"></a><span id="l6.1130">  *            rnp_buffer_destroy() function.</span>
<a href="#l6.1131"></a><span id="l6.1131">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1132"></a><span id="l6.1132">  */</span>
<a href="#l6.1133"></a><span id="l6.1133" class="difflineminus">-rnp_result_t rnp_key_get_alg(rnp_key_handle_t key, char **alg);</span>
<a href="#l6.1134"></a><span id="l6.1134" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_alg(rnp_key_handle_t key, char **alg);</span>
<a href="#l6.1135"></a><span id="l6.1135"> </span>
<a href="#l6.1136"></a><span id="l6.1136"> /** Get number of bits in the key. For EC-based keys it will return size of the curve.</span>
<a href="#l6.1137"></a><span id="l6.1137">  *</span>
<a href="#l6.1138"></a><span id="l6.1138">  * @param key key handle</span>
<a href="#l6.1139"></a><span id="l6.1139">  * @param bits number of bits will be stored here.</span>
<a href="#l6.1140"></a><span id="l6.1140">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1141"></a><span id="l6.1141">  */</span>
<a href="#l6.1142"></a><span id="l6.1142" class="difflineminus">-rnp_result_t rnp_key_get_bits(rnp_key_handle_t key, uint32_t *bits);</span>
<a href="#l6.1143"></a><span id="l6.1143" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_bits(rnp_key_handle_t key, uint32_t *bits);</span>
<a href="#l6.1144"></a><span id="l6.1144"> </span>
<a href="#l6.1145"></a><span id="l6.1145"> /** Get the number of bits in q parameter of the DSA key. Makes sense only for DSA keys.</span>
<a href="#l6.1146"></a><span id="l6.1146">  *</span>
<a href="#l6.1147"></a><span id="l6.1147">  * @param key key handle</span>
<a href="#l6.1148"></a><span id="l6.1148">  * @param qbits number of bits will be stored here.</span>
<a href="#l6.1149"></a><span id="l6.1149">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1150"></a><span id="l6.1150">  */</span>
<a href="#l6.1151"></a><span id="l6.1151" class="difflineminus">-rnp_result_t rnp_key_get_dsa_qbits(rnp_key_handle_t key, uint32_t *qbits);</span>
<a href="#l6.1152"></a><span id="l6.1152" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_dsa_qbits(rnp_key_handle_t key, uint32_t *qbits);</span>
<a href="#l6.1153"></a><span id="l6.1153"> </span>
<a href="#l6.1154"></a><span id="l6.1154"> /** Get the curve of EC-based key.</span>
<a href="#l6.1155"></a><span id="l6.1155">  *</span>
<a href="#l6.1156"></a><span id="l6.1156">  * @param key key handle</span>
<a href="#l6.1157"></a><span id="l6.1157">  * @param curve string with name of the curve will be stored here. You must free it using the</span>
<a href="#l6.1158"></a><span id="l6.1158">  *              rnp_buffer_destroy() function.</span>
<a href="#l6.1159"></a><span id="l6.1159">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1160"></a><span id="l6.1160">  */</span>
<a href="#l6.1161"></a><span id="l6.1161" class="difflineminus">-rnp_result_t rnp_key_get_curve(rnp_key_handle_t key, char **curve);</span>
<a href="#l6.1162"></a><span id="l6.1162" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_curve(rnp_key_handle_t key, char **curve);</span>
<a href="#l6.1163"></a><span id="l6.1163"> </span>
<a href="#l6.1164"></a><span id="l6.1164"> /** Add a new user identifier to a key</span>
<a href="#l6.1165"></a><span id="l6.1165">  *</span>
<a href="#l6.1166"></a><span id="l6.1166">  *  @param ffi</span>
<a href="#l6.1167"></a><span id="l6.1167">  *  @param key the key to add - must be a secret key</span>
<a href="#l6.1168"></a><span id="l6.1168">  *  @param uid the UID to add</span>
<a href="#l6.1169"></a><span id="l6.1169">  *  @param hash name of the hash function to use for the uid binding</span>
<a href="#l6.1170"></a><span id="l6.1170">  *         signature (eg &quot;SHA256&quot;)</span>
<a href="#l6.1171"></a><span id="l6.1171">  *  @param expiration time when this user id expires</span>
<a href="#l6.1172"></a><span id="l6.1172">  *  @param key_flags usage flags, see section 5.2.3.21 of RFC 4880</span>
<a href="#l6.1173"></a><span id="l6.1173">  *         or just provide zero to indicate no special handling.</span>
<a href="#l6.1174"></a><span id="l6.1174">  *  @param primary indicates if this is the primary UID</span>
<a href="#l6.1175"></a><span id="l6.1175">  *  @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1176"></a><span id="l6.1176">  */</span>
<a href="#l6.1177"></a><span id="l6.1177" class="difflineminus">-rnp_result_t rnp_key_add_uid(rnp_key_handle_t key,</span>
<a href="#l6.1178"></a><span id="l6.1178" class="difflineminus">-                             const char *     uid,</span>
<a href="#l6.1179"></a><span id="l6.1179" class="difflineminus">-                             const char *     hash,</span>
<a href="#l6.1180"></a><span id="l6.1180" class="difflineminus">-                             uint32_t         expiration,</span>
<a href="#l6.1181"></a><span id="l6.1181" class="difflineminus">-                             uint8_t          key_flags,</span>
<a href="#l6.1182"></a><span id="l6.1182" class="difflineminus">-                             bool             primary);</span>
<a href="#l6.1183"></a><span id="l6.1183" class="difflineplus">+RNP_API rnp_result_t rnp_key_add_uid(rnp_key_handle_t key,</span>
<a href="#l6.1184"></a><span id="l6.1184" class="difflineplus">+                                     const char *     uid,</span>
<a href="#l6.1185"></a><span id="l6.1185" class="difflineplus">+                                     const char *     hash,</span>
<a href="#l6.1186"></a><span id="l6.1186" class="difflineplus">+                                     uint32_t         expiration,</span>
<a href="#l6.1187"></a><span id="l6.1187" class="difflineplus">+                                     uint8_t          key_flags,</span>
<a href="#l6.1188"></a><span id="l6.1188" class="difflineplus">+                                     bool             primary);</span>
<a href="#l6.1189"></a><span id="l6.1189"> </span>
<a href="#l6.1190"></a><span id="l6.1190"> /* The following output hex encoded strings */</span>
<a href="#l6.1191"></a><span id="l6.1191"> </span>
<a href="#l6.1192"></a><span id="l6.1192"> /**</span>
<a href="#l6.1193"></a><span id="l6.1193">  * @brief Get key's fingerprint as hex-encoded string.</span>
<a href="#l6.1194"></a><span id="l6.1194">  *</span>
<a href="#l6.1195"></a><span id="l6.1195">  * @param key key handle, should not be NULL</span>
<a href="#l6.1196"></a><span id="l6.1196">  * @param fprint pointer to the NULL-terminated string with hex-encoded fingerprint will be</span>
<a href="#l6.1197"></a><span id="l6.1197">  *        stored here. You must free it later using rnp_buffer_destroy function.</span>
<a href="#l6.1198"></a><span id="l6.1198">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1199"></a><span id="l6.1199">  */</span>
<a href="#l6.1200"></a><span id="l6.1200" class="difflineminus">-rnp_result_t rnp_key_get_fprint(rnp_key_handle_t key, char **fprint);</span>
<a href="#l6.1201"></a><span id="l6.1201" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_fprint(rnp_key_handle_t key, char **fprint);</span>
<a href="#l6.1202"></a><span id="l6.1202"> </span>
<a href="#l6.1203"></a><span id="l6.1203"> /**</span>
<a href="#l6.1204"></a><span id="l6.1204">  * @brief Get key's id as hex-encoded string</span>
<a href="#l6.1205"></a><span id="l6.1205">  *</span>
<a href="#l6.1206"></a><span id="l6.1206">  * @param key key handle, should not be NULL</span>
<a href="#l6.1207"></a><span id="l6.1207">  * @param keyid pointer to the NULL-terminated string with hex-encoded key id will be</span>
<a href="#l6.1208"></a><span id="l6.1208">  *        stored here. You must free it later using rnp_buffer_destroy function.</span>
<a href="#l6.1209"></a><span id="l6.1209">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1210"></a><span id="l6.1210">  */</span>
<a href="#l6.1211"></a><span id="l6.1211" class="difflineminus">-rnp_result_t rnp_key_get_keyid(rnp_key_handle_t key, char **keyid);</span>
<a href="#l6.1212"></a><span id="l6.1212" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_keyid(rnp_key_handle_t key, char **keyid);</span>
<a href="#l6.1213"></a><span id="l6.1213"> </span>
<a href="#l6.1214"></a><span id="l6.1214"> /**</span>
<a href="#l6.1215"></a><span id="l6.1215">  * @brief Get key's grip as hex-encoded string</span>
<a href="#l6.1216"></a><span id="l6.1216">  *</span>
<a href="#l6.1217"></a><span id="l6.1217">  * @param key key handle, should not be NULL</span>
<a href="#l6.1218"></a><span id="l6.1218">  * @param grip pointer to the NULL-terminated string with hex-encoded key grip will be</span>
<a href="#l6.1219"></a><span id="l6.1219">  *        stored here. You must free it later using rnp_buffer_destroy function.</span>
<a href="#l6.1220"></a><span id="l6.1220">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1221"></a><span id="l6.1221">  */</span>
<a href="#l6.1222"></a><span id="l6.1222" class="difflineminus">-rnp_result_t rnp_key_get_grip(rnp_key_handle_t key, char **grip);</span>
<a href="#l6.1223"></a><span id="l6.1223" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_grip(rnp_key_handle_t key, char **grip);</span>
<a href="#l6.1224"></a><span id="l6.1224"> </span>
<a href="#l6.1225"></a><span id="l6.1225"> /**</span>
<a href="#l6.1226"></a><span id="l6.1226">  * @brief Get primary's key grip for the subkey, if available.</span>
<a href="#l6.1227"></a><span id="l6.1227">  *</span>
<a href="#l6.1228"></a><span id="l6.1228">  * @param key key handle, should not be NULL</span>
<a href="#l6.1229"></a><span id="l6.1229">  * @param grip pointer to the NULL-terminated string with hex-encoded key grip or NULL will be</span>
<a href="#l6.1230"></a><span id="l6.1230">  *        stored here, depending whether primary key is available or not.</span>
<a href="#l6.1231"></a><span id="l6.1231">  *        You must free it later using rnp_buffer_destroy function.</span>
<a href="#l6.1232"></a><span id="l6.1232">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1233"></a><span id="l6.1233">  */</span>
<a href="#l6.1234"></a><span id="l6.1234" class="difflineminus">-rnp_result_t rnp_key_get_primary_grip(rnp_key_handle_t key, char **grip);</span>
<a href="#l6.1235"></a><span id="l6.1235" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_primary_grip(rnp_key_handle_t key, char **grip);</span>
<a href="#l6.1236"></a><span id="l6.1236" class="difflineplus">+</span>
<a href="#l6.1237"></a><span id="l6.1237" class="difflineplus">+/**</span>
<a href="#l6.1238"></a><span id="l6.1238" class="difflineplus">+ * @brief Get primary's key fingerprint for the subkey, if available.</span>
<a href="#l6.1239"></a><span id="l6.1239" class="difflineplus">+ *</span>
<a href="#l6.1240"></a><span id="l6.1240" class="difflineplus">+ * @param key key handle, should not be NULL</span>
<a href="#l6.1241"></a><span id="l6.1241" class="difflineplus">+ * @param grip pointer to the NULL-terminated string with hex-encoded key fingerprint or NULL</span>
<a href="#l6.1242"></a><span id="l6.1242" class="difflineplus">+ *             will be stored here, depending whether primary key is available or not. You must</span>
<a href="#l6.1243"></a><span id="l6.1243" class="difflineplus">+ *             free it later using rnp_buffer_destroy function.</span>
<a href="#l6.1244"></a><span id="l6.1244" class="difflineplus">+ * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1245"></a><span id="l6.1245" class="difflineplus">+ */</span>
<a href="#l6.1246"></a><span id="l6.1246" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_primary_fprint(rnp_key_handle_t key, char **fprint);</span>
<a href="#l6.1247"></a><span id="l6.1247"> </span>
<a href="#l6.1248"></a><span id="l6.1248"> /**</span>
<a href="#l6.1249"></a><span id="l6.1249">  * @brief Check whether certain usage type is allowed for the key.</span>
<a href="#l6.1250"></a><span id="l6.1250">  *</span>
<a href="#l6.1251"></a><span id="l6.1251">  * @param key key handle, should not be NULL</span>
<a href="#l6.1252"></a><span id="l6.1252">  * @param usage string describing the key usage. For the list of allowed values see the</span>
<a href="#l6.1253"></a><span id="l6.1253">  *              rnp_op_generate_add_usage() function description.</span>
<a href="#l6.1254"></a><span id="l6.1254">  * @param result function result will be stored here. Could not be NULL.</span>
<a href="#l6.1255"></a><span id="l6.1255">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1256"></a><span id="l6.1256">  */</span>
<a href="#l6.1257"></a><span id="l6.1257" class="difflineminus">-rnp_result_t rnp_key_allows_usage(rnp_key_handle_t key, const char *usage, bool *result);</span>
<a href="#l6.1258"></a><span id="l6.1258" class="difflineplus">+RNP_API rnp_result_t rnp_key_allows_usage(rnp_key_handle_t key,</span>
<a href="#l6.1259"></a><span id="l6.1259" class="difflineplus">+                                          const char *     usage,</span>
<a href="#l6.1260"></a><span id="l6.1260" class="difflineplus">+                                          bool *           result);</span>
<a href="#l6.1261"></a><span id="l6.1261"> </span>
<a href="#l6.1262"></a><span id="l6.1262"> /**</span>
<a href="#l6.1263"></a><span id="l6.1263">  * @brief Get the key's creation time.</span>
<a href="#l6.1264"></a><span id="l6.1264">  *</span>
<a href="#l6.1265"></a><span id="l6.1265">  * @param key key handle, should not be NULL.</span>
<a href="#l6.1266"></a><span id="l6.1266">  * @param result creation time will be stored here. Cannot be NULL.</span>
<a href="#l6.1267"></a><span id="l6.1267">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1268"></a><span id="l6.1268">  */</span>
<a href="#l6.1269"></a><span id="l6.1269" class="difflineminus">-rnp_result_t rnp_key_get_creation(rnp_key_handle_t key, uint32_t *result);</span>
<a href="#l6.1270"></a><span id="l6.1270" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_creation(rnp_key_handle_t key, uint32_t *result);</span>
<a href="#l6.1271"></a><span id="l6.1271"> </span>
<a href="#l6.1272"></a><span id="l6.1272"> /**</span>
<a href="#l6.1273"></a><span id="l6.1273">  * @brief Get the key's expiration time in seconds.</span>
<a href="#l6.1274"></a><span id="l6.1274">  *        Note: 0 means that the key doesn't expire.</span>
<a href="#l6.1275"></a><span id="l6.1275">  *</span>
<a href="#l6.1276"></a><span id="l6.1276">  * @param key key handle, should not be NULL</span>
<a href="#l6.1277"></a><span id="l6.1277">  * @param result expiration time will be stored here. Could not be NULL.</span>
<a href="#l6.1278"></a><span id="l6.1278">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1279"></a><span id="l6.1279">  */</span>
<a href="#l6.1280"></a><span id="l6.1280" class="difflineminus">-rnp_result_t rnp_key_get_expiration(rnp_key_handle_t key, uint32_t *result);</span>
<a href="#l6.1281"></a><span id="l6.1281" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_expiration(rnp_key_handle_t key, uint32_t *result);</span>
<a href="#l6.1282"></a><span id="l6.1282"> </span>
<a href="#l6.1283"></a><span id="l6.1283"> /**</span>
<a href="#l6.1284"></a><span id="l6.1284">  * @brief Set the key's expiration time in seconds.</span>
<a href="#l6.1285"></a><span id="l6.1285">  *        Note: this will require re-signing, which requires availability of the secret key (or</span>
<a href="#l6.1286"></a><span id="l6.1286">  *        secret primary key for the subkey). If the secret key is locked then may ask for</span>
<a href="#l6.1287"></a><span id="l6.1287">  *        key's password via FFI callback.</span>
<a href="#l6.1288"></a><span id="l6.1288">  *</span>
<a href="#l6.1289"></a><span id="l6.1289">  * @param key key's handle.</span>
<a href="#l6.1290"></a><span id="l6.1290" class="difflineminus">- * @param expiry expiration time in seconds (or 0 if key doesn't expire).</span>
<a href="#l6.1291"></a><span id="l6.1291" class="difflineplus">+ * @param expiry expiration time in seconds (or 0 if key doesn't expire). Please note that it</span>
<a href="#l6.1292"></a><span id="l6.1292" class="difflineplus">+ *               is calculated from the key creation time, not from the current time.</span>
<a href="#l6.1293"></a><span id="l6.1293">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1294"></a><span id="l6.1294">  */</span>
<a href="#l6.1295"></a><span id="l6.1295" class="difflineminus">-rnp_result_t rnp_key_set_expiration(rnp_key_handle_t key, uint32_t expiry);</span>
<a href="#l6.1296"></a><span id="l6.1296" class="difflineplus">+RNP_API rnp_result_t rnp_key_set_expiration(rnp_key_handle_t key, uint32_t expiry);</span>
<a href="#l6.1297"></a><span id="l6.1297"> </span>
<a href="#l6.1298"></a><span id="l6.1298"> /**</span>
<a href="#l6.1299"></a><span id="l6.1299">  * @brief Check whether key is revoked.</span>
<a href="#l6.1300"></a><span id="l6.1300">  *</span>
<a href="#l6.1301"></a><span id="l6.1301">  * @param key key handle, should not be NULL</span>
<a href="#l6.1302"></a><span id="l6.1302">  * @param result on success result will be stored here. Could not be NULL.</span>
<a href="#l6.1303"></a><span id="l6.1303">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1304"></a><span id="l6.1304">  */</span>
<a href="#l6.1305"></a><span id="l6.1305" class="difflineminus">-rnp_result_t rnp_key_is_revoked(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1306"></a><span id="l6.1306" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_revoked(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1307"></a><span id="l6.1307"> </span>
<a href="#l6.1308"></a><span id="l6.1308"> /**</span>
<a href="#l6.1309"></a><span id="l6.1309">  * @brief Get textual description of the key's revocation reason (if any)</span>
<a href="#l6.1310"></a><span id="l6.1310">  *</span>
<a href="#l6.1311"></a><span id="l6.1311">  * @param key key handle, should not be NULL</span>
<a href="#l6.1312"></a><span id="l6.1312">  * @param result on success pointer to the NULL-terminated string will be stored here.</span>
<a href="#l6.1313"></a><span id="l6.1313">  *               You must free it later using rnp_buffer_destroy() function.</span>
<a href="#l6.1314"></a><span id="l6.1314">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1315"></a><span id="l6.1315">  */</span>
<a href="#l6.1316"></a><span id="l6.1316" class="difflineminus">-rnp_result_t rnp_key_get_revocation_reason(rnp_key_handle_t key, char **result);</span>
<a href="#l6.1317"></a><span id="l6.1317" class="difflineplus">+RNP_API rnp_result_t rnp_key_get_revocation_reason(rnp_key_handle_t key, char **result);</span>
<a href="#l6.1318"></a><span id="l6.1318"> </span>
<a href="#l6.1319"></a><span id="l6.1319"> /**</span>
<a href="#l6.1320"></a><span id="l6.1320">  * @brief Check whether revoked key was superseded by other key.</span>
<a href="#l6.1321"></a><span id="l6.1321">  *</span>
<a href="#l6.1322"></a><span id="l6.1322">  * @param key key handle, should not be NULL</span>
<a href="#l6.1323"></a><span id="l6.1323">  * @param result on success result will be stored here. Could not be NULL.</span>
<a href="#l6.1324"></a><span id="l6.1324">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1325"></a><span id="l6.1325">  */</span>
<a href="#l6.1326"></a><span id="l6.1326" class="difflineminus">-rnp_result_t rnp_key_is_superseded(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1327"></a><span id="l6.1327" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_superseded(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1328"></a><span id="l6.1328"> </span>
<a href="#l6.1329"></a><span id="l6.1329"> /**</span>
<a href="#l6.1330"></a><span id="l6.1330">  * @brief Check whether revoked key's material was compromised.</span>
<a href="#l6.1331"></a><span id="l6.1331">  *</span>
<a href="#l6.1332"></a><span id="l6.1332">  * @param key key handle, should not be NULL</span>
<a href="#l6.1333"></a><span id="l6.1333">  * @param result on success result will be stored here. Could not be NULL.</span>
<a href="#l6.1334"></a><span id="l6.1334">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1335"></a><span id="l6.1335">  */</span>
<a href="#l6.1336"></a><span id="l6.1336" class="difflineminus">-rnp_result_t rnp_key_is_compromised(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1337"></a><span id="l6.1337" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_compromised(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1338"></a><span id="l6.1338"> </span>
<a href="#l6.1339"></a><span id="l6.1339"> /**</span>
<a href="#l6.1340"></a><span id="l6.1340">  * @brief Check whether revoked key was retired.</span>
<a href="#l6.1341"></a><span id="l6.1341">  *</span>
<a href="#l6.1342"></a><span id="l6.1342">  * @param key key handle, should not be NULL</span>
<a href="#l6.1343"></a><span id="l6.1343">  * @param result on success result will be stored here. Could not be NULL.</span>
<a href="#l6.1344"></a><span id="l6.1344">  * @return RNP_SUCCESS or error code on failure.</span>
<a href="#l6.1345"></a><span id="l6.1345">  */</span>
<a href="#l6.1346"></a><span id="l6.1346" class="difflineminus">-rnp_result_t rnp_key_is_retired(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1347"></a><span id="l6.1347" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_retired(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1348"></a><span id="l6.1348"> </span>
<a href="#l6.1349"></a><span id="l6.1349"> /** check if a key is currently locked</span>
<a href="#l6.1350"></a><span id="l6.1350">  *</span>
<a href="#l6.1351"></a><span id="l6.1351">  *  @param key</span>
<a href="#l6.1352"></a><span id="l6.1352">  *  @param result pointer to hold the result. This will be set to true if</span>
<a href="#l6.1353"></a><span id="l6.1353">  *         the key is currently locked, or false otherwise. Must not be NULL.</span>
<a href="#l6.1354"></a><span id="l6.1354">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1355"></a><span id="l6.1355">  **/</span>
<a href="#l6.1356"></a><span id="l6.1356" class="difflineminus">-rnp_result_t rnp_key_is_locked(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1357"></a><span id="l6.1357" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_locked(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1358"></a><span id="l6.1358"> </span>
<a href="#l6.1359"></a><span id="l6.1359"> /** lock the key</span>
<a href="#l6.1360"></a><span id="l6.1360">  *</span>
<a href="#l6.1361"></a><span id="l6.1361">  *  A locked key does not have the secret key material immediately</span>
<a href="#l6.1362"></a><span id="l6.1362">  *  available for use. A locked and protected (aka encrypted) key</span>
<a href="#l6.1363"></a><span id="l6.1363">  *  is safely encrypted in memory and requires a password for</span>
<a href="#l6.1364"></a><span id="l6.1364">  *  performing any operations involving the secret key material.</span>
<a href="#l6.1365"></a><span id="l6.1365">  *</span>
<a href="#l6.1366"></a><span id="l6.1366">  *  Generally lock/unlock are not useful for unencrypted (not protected) keys.</span>
<a href="#l6.1367"></a><span id="l6.1367">  *</span>
<a href="#l6.1368"></a><span id="l6.1368">  *  @param key</span>
<a href="#l6.1369"></a><span id="l6.1369">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1370"></a><span id="l6.1370">  **/</span>
<a href="#l6.1371"></a><span id="l6.1371" class="difflineminus">-rnp_result_t rnp_key_lock(rnp_key_handle_t key);</span>
<a href="#l6.1372"></a><span id="l6.1372" class="difflineplus">+RNP_API rnp_result_t rnp_key_lock(rnp_key_handle_t key);</span>
<a href="#l6.1373"></a><span id="l6.1373"> </span>
<a href="#l6.1374"></a><span id="l6.1374"> /** unlock the key</span>
<a href="#l6.1375"></a><span id="l6.1375">  *</span>
<a href="#l6.1376"></a><span id="l6.1376">  *  An unlocked key has unencrypted secret key material available for use</span>
<a href="#l6.1377"></a><span id="l6.1377">  *  without a password.</span>
<a href="#l6.1378"></a><span id="l6.1378">  *</span>
<a href="#l6.1379"></a><span id="l6.1379">  *  Generally lock/unlock are not useful for unencrypted (not protected) keys.</span>
<a href="#l6.1380"></a><span id="l6.1380">  *</span>
<a href="#l6.1381"></a><span id="l6.1381">  *  @param key</span>
<a href="#l6.1382"></a><span id="l6.1382">  *  @param password the password to unlock the key. If NULL, the password</span>
<a href="#l6.1383"></a><span id="l6.1383">  *         provider will be used.</span>
<a href="#l6.1384"></a><span id="l6.1384">  *  @param result pointer to hold the result. This will be set to true if</span>
<a href="#l6.1385"></a><span id="l6.1385">  *         the key is currently locked, or false otherwise. Must not be NULL.</span>
<a href="#l6.1386"></a><span id="l6.1386">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1387"></a><span id="l6.1387">  **/</span>
<a href="#l6.1388"></a><span id="l6.1388" class="difflineminus">-rnp_result_t rnp_key_unlock(rnp_key_handle_t key, const char *password);</span>
<a href="#l6.1389"></a><span id="l6.1389" class="difflineplus">+RNP_API rnp_result_t rnp_key_unlock(rnp_key_handle_t key, const char *password);</span>
<a href="#l6.1390"></a><span id="l6.1390"> </span>
<a href="#l6.1391"></a><span id="l6.1391"> /** check if a key is currently protected</span>
<a href="#l6.1392"></a><span id="l6.1392">  *</span>
<a href="#l6.1393"></a><span id="l6.1393">  *  A protected key is one that is encrypted and can be safely held in memory</span>
<a href="#l6.1394"></a><span id="l6.1394">  *  and locked/unlocked as needed.</span>
<a href="#l6.1395"></a><span id="l6.1395">  *</span>
<a href="#l6.1396"></a><span id="l6.1396">  *  @param key</span>
<a href="#l6.1397"></a><span id="l6.1397">  *  @param result pointer to hold the result. This will be set to true if</span>
<a href="#l6.1398"></a><span id="l6.1398">  *         the key is currently protected, or false otherwise. Must not be NULL.</span>
<a href="#l6.1399"></a><span id="l6.1399">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1400"></a><span id="l6.1400">  **/</span>
<a href="#l6.1401"></a><span id="l6.1401" class="difflineminus">-rnp_result_t rnp_key_is_protected(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1402"></a><span id="l6.1402" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_protected(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1403"></a><span id="l6.1403"> </span>
<a href="#l6.1404"></a><span id="l6.1404"> /** protect the key</span>
<a href="#l6.1405"></a><span id="l6.1405">  *</span>
<a href="#l6.1406"></a><span id="l6.1406">  *  This can be used to set a new password on a key or to protect an unprotected</span>
<a href="#l6.1407"></a><span id="l6.1407">  *  key.</span>
<a href="#l6.1408"></a><span id="l6.1408">  *</span>
<a href="#l6.1409"></a><span id="l6.1409">  *  Note that the only required parameter is &quot;password&quot;.</span>
<a href="#l6.1410"></a><span id="l6.1410">  *</span>
<a href="#l6.1411"></a><span id="l6.1411" class="difflineat">@@ -1359,295 +1390,302 @@ rnp_result_t rnp_key_is_protected(rnp_ke</span>
<a href="#l6.1412"></a><span id="l6.1412">  *         well supported currently and is mostly relevant for G10.</span>
<a href="#l6.1413"></a><span id="l6.1413">  *         May be NULL.</span>
<a href="#l6.1414"></a><span id="l6.1414">  *  @param hash the hash algorithm (SHA512, etc) used for the String-to-Key key</span>
<a href="#l6.1415"></a><span id="l6.1415">  *         derivation. May be NULL, in which case a default will be used.</span>
<a href="#l6.1416"></a><span id="l6.1416">  *  @param iterations the number of iterations used for the String-to-Key key</span>
<a href="#l6.1417"></a><span id="l6.1417">  *         derivation. Use 0 to select a reasonable default.</span>
<a href="#l6.1418"></a><span id="l6.1418">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1419"></a><span id="l6.1419">  **/</span>
<a href="#l6.1420"></a><span id="l6.1420" class="difflineminus">-rnp_result_t rnp_key_protect(rnp_key_handle_t handle,</span>
<a href="#l6.1421"></a><span id="l6.1421" class="difflineminus">-                             const char *     password,</span>
<a href="#l6.1422"></a><span id="l6.1422" class="difflineminus">-                             const char *     cipher,</span>
<a href="#l6.1423"></a><span id="l6.1423" class="difflineminus">-                             const char *     cipher_mode,</span>
<a href="#l6.1424"></a><span id="l6.1424" class="difflineminus">-                             const char *     hash,</span>
<a href="#l6.1425"></a><span id="l6.1425" class="difflineminus">-                             size_t           iterations);</span>
<a href="#l6.1426"></a><span id="l6.1426" class="difflineplus">+RNP_API rnp_result_t rnp_key_protect(rnp_key_handle_t handle,</span>
<a href="#l6.1427"></a><span id="l6.1427" class="difflineplus">+                                     const char *     password,</span>
<a href="#l6.1428"></a><span id="l6.1428" class="difflineplus">+                                     const char *     cipher,</span>
<a href="#l6.1429"></a><span id="l6.1429" class="difflineplus">+                                     const char *     cipher_mode,</span>
<a href="#l6.1430"></a><span id="l6.1430" class="difflineplus">+                                     const char *     hash,</span>
<a href="#l6.1431"></a><span id="l6.1431" class="difflineplus">+                                     size_t           iterations);</span>
<a href="#l6.1432"></a><span id="l6.1432"> </span>
<a href="#l6.1433"></a><span id="l6.1433"> /** unprotect the key</span>
<a href="#l6.1434"></a><span id="l6.1434">  *</span>
<a href="#l6.1435"></a><span id="l6.1435">  *  This removes the encryption from the key.</span>
<a href="#l6.1436"></a><span id="l6.1436">  *</span>
<a href="#l6.1437"></a><span id="l6.1437">  *  @param key</span>
<a href="#l6.1438"></a><span id="l6.1438">  *  @param password the password to unlock the key. If NULL, the password</span>
<a href="#l6.1439"></a><span id="l6.1439">  *         provider will be used.</span>
<a href="#l6.1440"></a><span id="l6.1440">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1441"></a><span id="l6.1441">  **/</span>
<a href="#l6.1442"></a><span id="l6.1442" class="difflineminus">-rnp_result_t rnp_key_unprotect(rnp_key_handle_t key, const char *password);</span>
<a href="#l6.1443"></a><span id="l6.1443" class="difflineplus">+RNP_API rnp_result_t rnp_key_unprotect(rnp_key_handle_t key, const char *password);</span>
<a href="#l6.1444"></a><span id="l6.1444"> </span>
<a href="#l6.1445"></a><span id="l6.1445" class="difflineminus">-rnp_result_t rnp_key_is_primary(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1446"></a><span id="l6.1446" class="difflineminus">-rnp_result_t rnp_key_is_sub(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1447"></a><span id="l6.1447" class="difflineminus">-rnp_result_t rnp_key_have_secret(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1448"></a><span id="l6.1448" class="difflineminus">-rnp_result_t rnp_key_have_public(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1449"></a><span id="l6.1449" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_primary(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1450"></a><span id="l6.1450" class="difflineplus">+RNP_API rnp_result_t rnp_key_is_sub(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1451"></a><span id="l6.1451" class="difflineplus">+RNP_API rnp_result_t rnp_key_have_secret(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1452"></a><span id="l6.1452" class="difflineplus">+RNP_API rnp_result_t rnp_key_have_public(rnp_key_handle_t key, bool *result);</span>
<a href="#l6.1453"></a><span id="l6.1453"> </span>
<a href="#l6.1454"></a><span id="l6.1454"> /** Get the information about key packets in JSON string.</span>
<a href="#l6.1455"></a><span id="l6.1455">  *  Note: this will not work for G10 keys.</span>
<a href="#l6.1456"></a><span id="l6.1456">  *</span>
<a href="#l6.1457"></a><span id="l6.1457">  * @param key key's handle, cannot be NULL</span>
<a href="#l6.1458"></a><span id="l6.1458">  * @param secret dump secret key instead of public</span>
<a href="#l6.1459"></a><span id="l6.1459">  * @param flags include additional fields in JSON (see RNP_JSON_DUMP_MPI and other</span>
<a href="#l6.1460"></a><span id="l6.1460">  *              RNP_JSON_DUMP_* flags)</span>
<a href="#l6.1461"></a><span id="l6.1461">  * @param result resulting JSON string will be stored here. You must free it using the</span>
<a href="#l6.1462"></a><span id="l6.1462">  *               rnp_buffer_destroy() function.</span>
<a href="#l6.1463"></a><span id="l6.1463">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1464"></a><span id="l6.1464">  */</span>
<a href="#l6.1465"></a><span id="l6.1465" class="difflineminus">-rnp_result_t rnp_key_packets_to_json(rnp_key_handle_t key,</span>
<a href="#l6.1466"></a><span id="l6.1466" class="difflineminus">-                                     bool             secret,</span>
<a href="#l6.1467"></a><span id="l6.1467" class="difflineminus">-                                     uint32_t         flags,</span>
<a href="#l6.1468"></a><span id="l6.1468" class="difflineminus">-                                     char **          result);</span>
<a href="#l6.1469"></a><span id="l6.1469" class="difflineplus">+RNP_API rnp_result_t rnp_key_packets_to_json(rnp_key_handle_t key,</span>
<a href="#l6.1470"></a><span id="l6.1470" class="difflineplus">+                                             bool             secret,</span>
<a href="#l6.1471"></a><span id="l6.1471" class="difflineplus">+                                             uint32_t         flags,</span>
<a href="#l6.1472"></a><span id="l6.1472" class="difflineplus">+                                             char **          result);</span>
<a href="#l6.1473"></a><span id="l6.1473"> </span>
<a href="#l6.1474"></a><span id="l6.1474"> /** Dump OpenPGP packets stream information to the JSON string.</span>
<a href="#l6.1475"></a><span id="l6.1475">  * @param input source with OpenPGP data</span>
<a href="#l6.1476"></a><span id="l6.1476">  * @param flags include additional fields in JSON (see RNP_JSON_DUMP_MPI and other</span>
<a href="#l6.1477"></a><span id="l6.1477">  *              RNP_JSON_DUMP_* flags)</span>
<a href="#l6.1478"></a><span id="l6.1478">  * @result resulting JSON string will be stored here. You must free it using the</span>
<a href="#l6.1479"></a><span id="l6.1479">  *         rnp_buffer_destroy() function.</span>
<a href="#l6.1480"></a><span id="l6.1480">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1481"></a><span id="l6.1481">  */</span>
<a href="#l6.1482"></a><span id="l6.1482" class="difflineminus">-rnp_result_t rnp_dump_packets_to_json(rnp_input_t input, uint32_t flags, char **result);</span>
<a href="#l6.1483"></a><span id="l6.1483" class="difflineplus">+RNP_API rnp_result_t rnp_dump_packets_to_json(rnp_input_t input,</span>
<a href="#l6.1484"></a><span id="l6.1484" class="difflineplus">+                                              uint32_t    flags,</span>
<a href="#l6.1485"></a><span id="l6.1485" class="difflineplus">+                                              char **     result);</span>
<a href="#l6.1486"></a><span id="l6.1486"> </span>
<a href="#l6.1487"></a><span id="l6.1487"> /** Dump OpenPGP packets stream information to output in humand-readable format.</span>
<a href="#l6.1488"></a><span id="l6.1488">  * @param input source with OpenPGP data</span>
<a href="#l6.1489"></a><span id="l6.1489">  * @param output text, describing packet sequence, will be written here</span>
<a href="#l6.1490"></a><span id="l6.1490">  * @param flags see RNP_DUMP_MPI and other RNP_DUMP_* constants.</span>
<a href="#l6.1491"></a><span id="l6.1491">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.1492"></a><span id="l6.1492">  */</span>
<a href="#l6.1493"></a><span id="l6.1493" class="difflineminus">-rnp_result_t rnp_dump_packets_to_output(rnp_input_t  input,</span>
<a href="#l6.1494"></a><span id="l6.1494" class="difflineminus">-                                        rnp_output_t output,</span>
<a href="#l6.1495"></a><span id="l6.1495" class="difflineminus">-                                        uint32_t     flags);</span>
<a href="#l6.1496"></a><span id="l6.1496" class="difflineplus">+RNP_API rnp_result_t rnp_dump_packets_to_output(rnp_input_t  input,</span>
<a href="#l6.1497"></a><span id="l6.1497" class="difflineplus">+                                                rnp_output_t output,</span>
<a href="#l6.1498"></a><span id="l6.1498" class="difflineplus">+                                                uint32_t     flags);</span>
<a href="#l6.1499"></a><span id="l6.1499"> </span>
<a href="#l6.1500"></a><span id="l6.1500"> /* Signing operations */</span>
<a href="#l6.1501"></a><span id="l6.1501"> </span>
<a href="#l6.1502"></a><span id="l6.1502"> /** @brief Create signing operation context. This method should be used for embedded</span>
<a href="#l6.1503"></a><span id="l6.1503">  *         signatures of binary data. For detached and cleartext signing corresponding</span>
<a href="#l6.1504"></a><span id="l6.1504">  *         function should be used.</span>
<a href="#l6.1505"></a><span id="l6.1505">  *  @param op pointer to opaque signing context</span>
<a href="#l6.1506"></a><span id="l6.1506">  *  @param ffi</span>
<a href="#l6.1507"></a><span id="l6.1507">  *  @param input stream with data to be signed. Could not be NULL.</span>
<a href="#l6.1508"></a><span id="l6.1508">  *  @param output stream to write results to. Could not be NULL.</span>
<a href="#l6.1509"></a><span id="l6.1509">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1510"></a><span id="l6.1510">  */</span>
<a href="#l6.1511"></a><span id="l6.1511" class="difflineminus">-rnp_result_t rnp_op_sign_create(rnp_op_sign_t *op,</span>
<a href="#l6.1512"></a><span id="l6.1512" class="difflineminus">-                                rnp_ffi_t      ffi,</span>
<a href="#l6.1513"></a><span id="l6.1513" class="difflineminus">-                                rnp_input_t    input,</span>
<a href="#l6.1514"></a><span id="l6.1514" class="difflineminus">-                                rnp_output_t   output);</span>
<a href="#l6.1515"></a><span id="l6.1515" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_create(rnp_op_sign_t *op,</span>
<a href="#l6.1516"></a><span id="l6.1516" class="difflineplus">+                                        rnp_ffi_t      ffi,</span>
<a href="#l6.1517"></a><span id="l6.1517" class="difflineplus">+                                        rnp_input_t    input,</span>
<a href="#l6.1518"></a><span id="l6.1518" class="difflineplus">+                                        rnp_output_t   output);</span>
<a href="#l6.1519"></a><span id="l6.1519"> </span>
<a href="#l6.1520"></a><span id="l6.1520"> /** @brief Create cleartext signing operation context. Input should be text data. Output will</span>
<a href="#l6.1521"></a><span id="l6.1521">  *         contain source data with additional headers and armored signature.</span>
<a href="#l6.1522"></a><span id="l6.1522">  *  @param op pointer to opaque signing context</span>
<a href="#l6.1523"></a><span id="l6.1523">  *  @param ffi</span>
<a href="#l6.1524"></a><span id="l6.1524">  *  @param input stream with data to be signed. Could not be NULL.</span>
<a href="#l6.1525"></a><span id="l6.1525">  *  @param output stream to write results to. Could not be NULL.</span>
<a href="#l6.1526"></a><span id="l6.1526">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1527"></a><span id="l6.1527">  */</span>
<a href="#l6.1528"></a><span id="l6.1528" class="difflineminus">-rnp_result_t rnp_op_sign_cleartext_create(rnp_op_sign_t *op,</span>
<a href="#l6.1529"></a><span id="l6.1529" class="difflineminus">-                                          rnp_ffi_t      ffi,</span>
<a href="#l6.1530"></a><span id="l6.1530" class="difflineminus">-                                          rnp_input_t    input,</span>
<a href="#l6.1531"></a><span id="l6.1531" class="difflineminus">-                                          rnp_output_t   output);</span>
<a href="#l6.1532"></a><span id="l6.1532" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_cleartext_create(rnp_op_sign_t *op,</span>
<a href="#l6.1533"></a><span id="l6.1533" class="difflineplus">+                                                  rnp_ffi_t      ffi,</span>
<a href="#l6.1534"></a><span id="l6.1534" class="difflineplus">+                                                  rnp_input_t    input,</span>
<a href="#l6.1535"></a><span id="l6.1535" class="difflineplus">+                                                  rnp_output_t   output);</span>
<a href="#l6.1536"></a><span id="l6.1536"> </span>
<a href="#l6.1537"></a><span id="l6.1537"> /** @brief Create detached signing operation context. Output will contain only signature of the</span>
<a href="#l6.1538"></a><span id="l6.1538">  *         source data.</span>
<a href="#l6.1539"></a><span id="l6.1539">  *  @param op pointer to opaque signing context</span>
<a href="#l6.1540"></a><span id="l6.1540">  *  @param ffi</span>
<a href="#l6.1541"></a><span id="l6.1541">  *  @param input stream with data to be signed. Could not be NULL.</span>
<a href="#l6.1542"></a><span id="l6.1542">  *  @param output stream to write results to. Could not be NULL.</span>
<a href="#l6.1543"></a><span id="l6.1543">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1544"></a><span id="l6.1544">  */</span>
<a href="#l6.1545"></a><span id="l6.1545" class="difflineminus">-rnp_result_t rnp_op_sign_detached_create(rnp_op_sign_t *op,</span>
<a href="#l6.1546"></a><span id="l6.1546" class="difflineminus">-                                         rnp_ffi_t      ffi,</span>
<a href="#l6.1547"></a><span id="l6.1547" class="difflineminus">-                                         rnp_input_t    input,</span>
<a href="#l6.1548"></a><span id="l6.1548" class="difflineminus">-                                         rnp_output_t   signature);</span>
<a href="#l6.1549"></a><span id="l6.1549" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_detached_create(rnp_op_sign_t *op,</span>
<a href="#l6.1550"></a><span id="l6.1550" class="difflineplus">+                                                 rnp_ffi_t      ffi,</span>
<a href="#l6.1551"></a><span id="l6.1551" class="difflineplus">+                                                 rnp_input_t    input,</span>
<a href="#l6.1552"></a><span id="l6.1552" class="difflineplus">+                                                 rnp_output_t   signature);</span>
<a href="#l6.1553"></a><span id="l6.1553"> </span>
<a href="#l6.1554"></a><span id="l6.1554"> /** @brief Add information about the signature so it could be calculated later in execute</span>
<a href="#l6.1555"></a><span id="l6.1555">  *         function call. Multiple signatures could be added.</span>
<a href="#l6.1556"></a><span id="l6.1556">  *  @param op opaque signing context. Must be successfully initialized with one of the</span>
<a href="#l6.1557"></a><span id="l6.1557">  *         rnp_op_sign_*_create functions.</span>
<a href="#l6.1558"></a><span id="l6.1558">  *  @param key handle of the private key. Private key should be capable for signing.</span>
<a href="#l6.1559"></a><span id="l6.1559">  *  @param sig pointer to opaque structure holding the signature information. May be NULL.</span>
<a href="#l6.1560"></a><span id="l6.1560">  *         You should not free it as it will be destroyed together with signing context.</span>
<a href="#l6.1561"></a><span id="l6.1561">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1562"></a><span id="l6.1562">  */</span>
<a href="#l6.1563"></a><span id="l6.1563" class="difflineminus">-rnp_result_t rnp_op_sign_add_signature(rnp_op_sign_t            op,</span>
<a href="#l6.1564"></a><span id="l6.1564" class="difflineminus">-                                       rnp_key_handle_t         key,</span>
<a href="#l6.1565"></a><span id="l6.1565" class="difflineminus">-                                       rnp_op_sign_signature_t *sig);</span>
<a href="#l6.1566"></a><span id="l6.1566" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_add_signature(rnp_op_sign_t            op,</span>
<a href="#l6.1567"></a><span id="l6.1567" class="difflineplus">+                                               rnp_key_handle_t         key,</span>
<a href="#l6.1568"></a><span id="l6.1568" class="difflineplus">+                                               rnp_op_sign_signature_t *sig);</span>
<a href="#l6.1569"></a><span id="l6.1569"> </span>
<a href="#l6.1570"></a><span id="l6.1570"> /** @brief Set hash algorithm used during signature calculation instead of default one, or one</span>
<a href="#l6.1571"></a><span id="l6.1571">  *         set by rnp_op_encrypt_set_hash/rnp_op_sign_set_hash</span>
<a href="#l6.1572"></a><span id="l6.1572">  *  @param sig opaque signature context, returned via rnp_op_sign_add_signature</span>
<a href="#l6.1573"></a><span id="l6.1573">  *  @param hash hash algorithm to be used</span>
<a href="#l6.1574"></a><span id="l6.1574">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1575"></a><span id="l6.1575">  */</span>
<a href="#l6.1576"></a><span id="l6.1576" class="difflineminus">-rnp_result_t rnp_op_sign_signature_set_hash(rnp_op_sign_signature_t sig, const char *hash);</span>
<a href="#l6.1577"></a><span id="l6.1577" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_signature_set_hash(rnp_op_sign_signature_t sig,</span>
<a href="#l6.1578"></a><span id="l6.1578" class="difflineplus">+                                                    const char *            hash);</span>
<a href="#l6.1579"></a><span id="l6.1579"> </span>
<a href="#l6.1580"></a><span id="l6.1580"> /** @brief Set signature creation time. By default current time is used or value set by</span>
<a href="#l6.1581"></a><span id="l6.1581">  *         rnp_op_encrypt_set_creation_time/rnp_op_sign_set_creation_time</span>
<a href="#l6.1582"></a><span id="l6.1582">  *  @param sig opaque signature context, returned via rnp_op_sign_add_signature</span>
<a href="#l6.1583"></a><span id="l6.1583">  *  @param create creation time in seconds since Jan, 1 1970 UTC</span>
<a href="#l6.1584"></a><span id="l6.1584">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1585"></a><span id="l6.1585">  */</span>
<a href="#l6.1586"></a><span id="l6.1586" class="difflineminus">-rnp_result_t rnp_op_sign_signature_set_creation_time(rnp_op_sign_signature_t sig,</span>
<a href="#l6.1587"></a><span id="l6.1587" class="difflineminus">-                                                     uint32_t                create);</span>
<a href="#l6.1588"></a><span id="l6.1588" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_signature_set_creation_time(rnp_op_sign_signature_t sig,</span>
<a href="#l6.1589"></a><span id="l6.1589" class="difflineplus">+                                                             uint32_t                create);</span>
<a href="#l6.1590"></a><span id="l6.1590"> </span>
<a href="#l6.1591"></a><span id="l6.1591"> /** @brief Set signature expiration time. By default is set to never expire or to value set by</span>
<a href="#l6.1592"></a><span id="l6.1592">  *         rnp_op_encrypt_set_expiration_time/rnp_op_sign_set_expiration_time</span>
<a href="#l6.1593"></a><span id="l6.1593">  *  @param sig opaque signature context, returned via rnp_op_sign_add_signature</span>
<a href="#l6.1594"></a><span id="l6.1594">  *  @param expire expiration time in seconds since the creation time. 0 value is used to mark</span>
<a href="#l6.1595"></a><span id="l6.1595">  *         signature as non-expiring (default value)</span>
<a href="#l6.1596"></a><span id="l6.1596">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1597"></a><span id="l6.1597">  */</span>
<a href="#l6.1598"></a><span id="l6.1598" class="difflineminus">-rnp_result_t rnp_op_sign_signature_set_expiration_time(rnp_op_sign_signature_t sig,</span>
<a href="#l6.1599"></a><span id="l6.1599" class="difflineminus">-                                                       uint32_t                expires);</span>
<a href="#l6.1600"></a><span id="l6.1600" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_signature_set_expiration_time(rnp_op_sign_signature_t sig,</span>
<a href="#l6.1601"></a><span id="l6.1601" class="difflineplus">+                                                               uint32_t expires);</span>
<a href="#l6.1602"></a><span id="l6.1602"> </span>
<a href="#l6.1603"></a><span id="l6.1603"> /** @brief Set data compression parameters. Makes sense only for embedded signatures.</span>
<a href="#l6.1604"></a><span id="l6.1604">  *  @param op opaque signing context. Must be initialized with rnp_op_sign_create function</span>
<a href="#l6.1605"></a><span id="l6.1605">  *  @param compression compression algorithm (zlib, zip, bzip2)</span>
<a href="#l6.1606"></a><span id="l6.1606">  *  @param level compression level, 0-9. 0 disables compression.</span>
<a href="#l6.1607"></a><span id="l6.1607">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1608"></a><span id="l6.1608">  */</span>
<a href="#l6.1609"></a><span id="l6.1609" class="difflineminus">-rnp_result_t rnp_op_sign_set_compression(rnp_op_sign_t op, const char *compression, int level);</span>
<a href="#l6.1610"></a><span id="l6.1610" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_set_compression(rnp_op_sign_t op,</span>
<a href="#l6.1611"></a><span id="l6.1611" class="difflineplus">+                                                 const char *  compression,</span>
<a href="#l6.1612"></a><span id="l6.1612" class="difflineplus">+                                                 int           level);</span>
<a href="#l6.1613"></a><span id="l6.1613"> </span>
<a href="#l6.1614"></a><span id="l6.1614"> /** @brief Enabled or disable armored (textual) output. Doesn't make sense for cleartext sign.</span>
<a href="#l6.1615"></a><span id="l6.1615">  *  @param op opaque signing context. Must be initialized with rnp_op_sign_create or</span>
<a href="#l6.1616"></a><span id="l6.1616">  *         rnp_op_sign_detached_create function.</span>
<a href="#l6.1617"></a><span id="l6.1617">  *  @param armored true if armoring should be used (it is disabled by default)</span>
<a href="#l6.1618"></a><span id="l6.1618">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1619"></a><span id="l6.1619">  */</span>
<a href="#l6.1620"></a><span id="l6.1620" class="difflineminus">-rnp_result_t rnp_op_sign_set_armor(rnp_op_sign_t op, bool armored);</span>
<a href="#l6.1621"></a><span id="l6.1621" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_set_armor(rnp_op_sign_t op, bool armored);</span>
<a href="#l6.1622"></a><span id="l6.1622"> </span>
<a href="#l6.1623"></a><span id="l6.1623"> /** @brief Set hash algorithm used during signature calculation. This will set hash function</span>
<a href="#l6.1624"></a><span id="l6.1624">  *         for all signature. To change it for a single signature use</span>
<a href="#l6.1625"></a><span id="l6.1625">  *         rnp_op_sign_signature_set_hash function.</span>
<a href="#l6.1626"></a><span id="l6.1626">  *  @param op opaque signing context. Must be successfully initialized with one of the</span>
<a href="#l6.1627"></a><span id="l6.1627">  *         rnp_op_sign_*_create functions.</span>
<a href="#l6.1628"></a><span id="l6.1628">  *  @param hash hash algorithm to be used</span>
<a href="#l6.1629"></a><span id="l6.1629">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1630"></a><span id="l6.1630">  */</span>
<a href="#l6.1631"></a><span id="l6.1631" class="difflineminus">-rnp_result_t rnp_op_sign_set_hash(rnp_op_sign_t op, const char *hash);</span>
<a href="#l6.1632"></a><span id="l6.1632" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_set_hash(rnp_op_sign_t op, const char *hash);</span>
<a href="#l6.1633"></a><span id="l6.1633"> </span>
<a href="#l6.1634"></a><span id="l6.1634"> /** @brief Set signature creation time. By default current time is used.</span>
<a href="#l6.1635"></a><span id="l6.1635">  *  @param op opaque signing context. Must be successfully initialized with one of the</span>
<a href="#l6.1636"></a><span id="l6.1636">  *         rnp_op_sign_*_create functions.</span>
<a href="#l6.1637"></a><span id="l6.1637">  *  @param create creation time in seconds since Jan, 1 1970 UTC</span>
<a href="#l6.1638"></a><span id="l6.1638">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1639"></a><span id="l6.1639">  */</span>
<a href="#l6.1640"></a><span id="l6.1640" class="difflineminus">-rnp_result_t rnp_op_sign_set_creation_time(rnp_op_sign_t op, uint32_t create);</span>
<a href="#l6.1641"></a><span id="l6.1641" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_set_creation_time(rnp_op_sign_t op, uint32_t create);</span>
<a href="#l6.1642"></a><span id="l6.1642"> </span>
<a href="#l6.1643"></a><span id="l6.1643"> /** @brief Set signature expiration time.</span>
<a href="#l6.1644"></a><span id="l6.1644">  *  @param op opaque signing context. Must be successfully initialized with one of the</span>
<a href="#l6.1645"></a><span id="l6.1645">  *         rnp_op_sign_*_create functions.</span>
<a href="#l6.1646"></a><span id="l6.1646">  *  @param expire expiration time in seconds since the creation time. 0 value is used to mark</span>
<a href="#l6.1647"></a><span id="l6.1647">  *         signature as non-expiring (default value)</span>
<a href="#l6.1648"></a><span id="l6.1648">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1649"></a><span id="l6.1649">  */</span>
<a href="#l6.1650"></a><span id="l6.1650" class="difflineminus">-rnp_result_t rnp_op_sign_set_expiration_time(rnp_op_sign_t op, uint32_t expire);</span>
<a href="#l6.1651"></a><span id="l6.1651" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_set_expiration_time(rnp_op_sign_t op, uint32_t expire);</span>
<a href="#l6.1652"></a><span id="l6.1652"> </span>
<a href="#l6.1653"></a><span id="l6.1653"> /** @brief Set input's file name. Makes sense only for embedded signature.</span>
<a href="#l6.1654"></a><span id="l6.1654">  *  @param op opaque signing context. Must be initialized with rnp_op_sign_create function</span>
<a href="#l6.1655"></a><span id="l6.1655">  *  @param filename source data file name. Special value _CONSOLE may be used to mark message</span>
<a href="#l6.1656"></a><span id="l6.1656">  *         as 'for your eyes only', i.e. it should not be stored anywhere but only displayed</span>
<a href="#l6.1657"></a><span id="l6.1657">  *         to the receiver. Default is the empty string.</span>
<a href="#l6.1658"></a><span id="l6.1658">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1659"></a><span id="l6.1659">  */</span>
<a href="#l6.1660"></a><span id="l6.1660" class="difflineminus">-rnp_result_t rnp_op_sign_set_file_name(rnp_op_sign_t op, const char *filename);</span>
<a href="#l6.1661"></a><span id="l6.1661" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_set_file_name(rnp_op_sign_t op, const char *filename);</span>
<a href="#l6.1662"></a><span id="l6.1662"> </span>
<a href="#l6.1663"></a><span id="l6.1663"> /** @brief Set input's file modification date. Makes sense only for embedded signature.</span>
<a href="#l6.1664"></a><span id="l6.1664">  *  @param op opaque signing context. Must be initialized with rnp_op_sign_create function</span>
<a href="#l6.1665"></a><span id="l6.1665">  *  @param mtime modification time in seconds since Jan, 1 1970 UTC.</span>
<a href="#l6.1666"></a><span id="l6.1666">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1667"></a><span id="l6.1667">  */</span>
<a href="#l6.1668"></a><span id="l6.1668" class="difflineminus">-rnp_result_t rnp_op_sign_set_file_mtime(rnp_op_sign_t op, uint32_t mtime);</span>
<a href="#l6.1669"></a><span id="l6.1669" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_set_file_mtime(rnp_op_sign_t op, uint32_t mtime);</span>
<a href="#l6.1670"></a><span id="l6.1670"> </span>
<a href="#l6.1671"></a><span id="l6.1671"> /** @brief Execute previously initialized signing operation.</span>
<a href="#l6.1672"></a><span id="l6.1672">  *  @param op opaque signing context. Must be successfully initialized with one of the</span>
<a href="#l6.1673"></a><span id="l6.1673">  *         rnp_op_sign_*_create functions. At least one signing key should be added.</span>
<a href="#l6.1674"></a><span id="l6.1674">  *  @return RNP_SUCCESS or error code if failed. On success output stream, passed in the create</span>
<a href="#l6.1675"></a><span id="l6.1675">  *          function call, will be populated with signed data</span>
<a href="#l6.1676"></a><span id="l6.1676">  */</span>
<a href="#l6.1677"></a><span id="l6.1677" class="difflineminus">-rnp_result_t rnp_op_sign_execute(rnp_op_sign_t op);</span>
<a href="#l6.1678"></a><span id="l6.1678" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_execute(rnp_op_sign_t op);</span>
<a href="#l6.1679"></a><span id="l6.1679"> </span>
<a href="#l6.1680"></a><span id="l6.1680"> /** @brief Free resources associated with signing operation.</span>
<a href="#l6.1681"></a><span id="l6.1681">  *  @param op opaque signing context. Must be successfully initialized with one of the</span>
<a href="#l6.1682"></a><span id="l6.1682">  *         rnp_op_sign_*_create functions.</span>
<a href="#l6.1683"></a><span id="l6.1683">  *  @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1684"></a><span id="l6.1684">  */</span>
<a href="#l6.1685"></a><span id="l6.1685" class="difflineminus">-rnp_result_t rnp_op_sign_destroy(rnp_op_sign_t op);</span>
<a href="#l6.1686"></a><span id="l6.1686" class="difflineplus">+RNP_API rnp_result_t rnp_op_sign_destroy(rnp_op_sign_t op);</span>
<a href="#l6.1687"></a><span id="l6.1687"> </span>
<a href="#l6.1688"></a><span id="l6.1688"> /* Verification */</span>
<a href="#l6.1689"></a><span id="l6.1689"> </span>
<a href="#l6.1690"></a><span id="l6.1690"> /** @brief Create verification operation context. This method should be used for embedded</span>
<a href="#l6.1691"></a><span id="l6.1691">  *         signatures or cleartext signed data. For detached verification corresponding</span>
<a href="#l6.1692"></a><span id="l6.1692">  *         function should be used.</span>
<a href="#l6.1693"></a><span id="l6.1693">  *  @param op pointer to opaque verification context</span>
<a href="#l6.1694"></a><span id="l6.1694">  *  @param ffi</span>
<a href="#l6.1695"></a><span id="l6.1695">  *  @param input stream with signed data. Could not be NULL.</span>
<a href="#l6.1696"></a><span id="l6.1696">  *  @param output stream to write results to. Could not be NULL, but may be null output stream</span>
<a href="#l6.1697"></a><span id="l6.1697">  *         if verified data should be discarded.</span>
<a href="#l6.1698"></a><span id="l6.1698">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1699"></a><span id="l6.1699">  */</span>
<a href="#l6.1700"></a><span id="l6.1700" class="difflineminus">-rnp_result_t rnp_op_verify_create(rnp_op_verify_t *op,</span>
<a href="#l6.1701"></a><span id="l6.1701" class="difflineminus">-                                  rnp_ffi_t        ffi,</span>
<a href="#l6.1702"></a><span id="l6.1702" class="difflineminus">-                                  rnp_input_t      input,</span>
<a href="#l6.1703"></a><span id="l6.1703" class="difflineminus">-                                  rnp_output_t     output);</span>
<a href="#l6.1704"></a><span id="l6.1704" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_create(rnp_op_verify_t *op,</span>
<a href="#l6.1705"></a><span id="l6.1705" class="difflineplus">+                                          rnp_ffi_t        ffi,</span>
<a href="#l6.1706"></a><span id="l6.1706" class="difflineplus">+                                          rnp_input_t      input,</span>
<a href="#l6.1707"></a><span id="l6.1707" class="difflineplus">+                                          rnp_output_t     output);</span>
<a href="#l6.1708"></a><span id="l6.1708"> </span>
<a href="#l6.1709"></a><span id="l6.1709"> /** @brief Create verification operation context for detached signature.</span>
<a href="#l6.1710"></a><span id="l6.1710">  *  @param op pointer to opaque verification context</span>
<a href="#l6.1711"></a><span id="l6.1711">  *  @param ffi</span>
<a href="#l6.1712"></a><span id="l6.1712">  *  @param input stream with raw data. Could not be NULL.</span>
<a href="#l6.1713"></a><span id="l6.1713">  *  @param signature stream with detached signature data</span>
<a href="#l6.1714"></a><span id="l6.1714">  *  @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.1715"></a><span id="l6.1715">  */</span>
<a href="#l6.1716"></a><span id="l6.1716" class="difflineminus">-rnp_result_t rnp_op_verify_detached_create(rnp_op_verify_t *op,</span>
<a href="#l6.1717"></a><span id="l6.1717" class="difflineminus">-                                           rnp_ffi_t        ffi,</span>
<a href="#l6.1718"></a><span id="l6.1718" class="difflineminus">-                                           rnp_input_t      input,</span>
<a href="#l6.1719"></a><span id="l6.1719" class="difflineminus">-                                           rnp_input_t      signature);</span>
<a href="#l6.1720"></a><span id="l6.1720" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_detached_create(rnp_op_verify_t *op,</span>
<a href="#l6.1721"></a><span id="l6.1721" class="difflineplus">+                                                   rnp_ffi_t        ffi,</span>
<a href="#l6.1722"></a><span id="l6.1722" class="difflineplus">+                                                   rnp_input_t      input,</span>
<a href="#l6.1723"></a><span id="l6.1723" class="difflineplus">+                                                   rnp_input_t      signature);</span>
<a href="#l6.1724"></a><span id="l6.1724"> </span>
<a href="#l6.1725"></a><span id="l6.1725"> /** @brief Execute previously initialized verification operation.</span>
<a href="#l6.1726"></a><span id="l6.1726">  *  @param op opaque verification context. Must be successfully initialized.</span>
<a href="#l6.1727"></a><span id="l6.1727">  *  @return RNP_SUCCESS if data was processed successfully and all signatures are valid.</span>
<a href="#l6.1728"></a><span id="l6.1728">  *          Otherwise error code is returned. After rnp_op_verify_execute()</span>
<a href="#l6.1729"></a><span id="l6.1729">  *          rnp_op_verify_get_* functions may be used to query information about the</span>
<a href="#l6.1730"></a><span id="l6.1730">  *          signature(s).</span>
<a href="#l6.1731"></a><span id="l6.1731">  */</span>
<a href="#l6.1732"></a><span id="l6.1732" class="difflineminus">-rnp_result_t rnp_op_verify_execute(rnp_op_verify_t op);</span>
<a href="#l6.1733"></a><span id="l6.1733" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_execute(rnp_op_verify_t op);</span>
<a href="#l6.1734"></a><span id="l6.1734"> </span>
<a href="#l6.1735"></a><span id="l6.1735"> /** @brief Get number of the signatures for verified data.</span>
<a href="#l6.1736"></a><span id="l6.1736">  *  @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1737"></a><span id="l6.1737">  *  @param count result will be stored here on success.</span>
<a href="#l6.1738"></a><span id="l6.1738">  *  @return RNP_SUCCESS if call succeeded.</span>
<a href="#l6.1739"></a><span id="l6.1739">  */</span>
<a href="#l6.1740"></a><span id="l6.1740" class="difflineminus">-rnp_result_t rnp_op_verify_get_signature_count(rnp_op_verify_t op, size_t *count);</span>
<a href="#l6.1741"></a><span id="l6.1741" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_signature_count(rnp_op_verify_t op, size_t *count);</span>
<a href="#l6.1742"></a><span id="l6.1742"> </span>
<a href="#l6.1743"></a><span id="l6.1743"> /** @brief Get single signature information based on it's index.</span>
<a href="#l6.1744"></a><span id="l6.1744">  *  @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1745"></a><span id="l6.1745">  *  @param sig opaque signature context data will be stored here on success.</span>
<a href="#l6.1746"></a><span id="l6.1746">  *  @return RNP_SUCCESS if call succeeded.</span>
<a href="#l6.1747"></a><span id="l6.1747">  */</span>
<a href="#l6.1748"></a><span id="l6.1748" class="difflineminus">-rnp_result_t rnp_op_verify_get_signature_at(rnp_op_verify_t            op,</span>
<a href="#l6.1749"></a><span id="l6.1749" class="difflineminus">-                                            size_t                     idx,</span>
<a href="#l6.1750"></a><span id="l6.1750" class="difflineminus">-                                            rnp_op_verify_signature_t *sig);</span>
<a href="#l6.1751"></a><span id="l6.1751" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_signature_at(rnp_op_verify_t            op,</span>
<a href="#l6.1752"></a><span id="l6.1752" class="difflineplus">+                                                    size_t                     idx,</span>
<a href="#l6.1753"></a><span id="l6.1753" class="difflineplus">+                                                    rnp_op_verify_signature_t *sig);</span>
<a href="#l6.1754"></a><span id="l6.1754"> </span>
<a href="#l6.1755"></a><span id="l6.1755"> /** @brief Get embedded in OpenPGP data file name and modification time. Makes sense only for</span>
<a href="#l6.1756"></a><span id="l6.1756">  *         embedded signature verification.</span>
<a href="#l6.1757"></a><span id="l6.1757">  *  @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1758"></a><span id="l6.1758">  *  @param filename pointer to the filename. On success caller is responsible for freeing it</span>
<a href="#l6.1759"></a><span id="l6.1759">  *                  via the rnp_buffer_free function call. May be NULL if this information is</span>
<a href="#l6.1760"></a><span id="l6.1760">  *                  not needed.</span>
<a href="#l6.1761"></a><span id="l6.1761">  *  @param mtime file modification time will be stored here on success. May be NULL.</span>
<a href="#l6.1762"></a><span id="l6.1762">  *  @return RNP_SUCCESS if call succeeded.</span>
<a href="#l6.1763"></a><span id="l6.1763">  */</span>
<a href="#l6.1764"></a><span id="l6.1764" class="difflineminus">-rnp_result_t rnp_op_verify_get_file_info(rnp_op_verify_t op, char **filename, uint32_t *mtime);</span>
<a href="#l6.1765"></a><span id="l6.1765" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_file_info(rnp_op_verify_t op,</span>
<a href="#l6.1766"></a><span id="l6.1766" class="difflineplus">+                                                 char **         filename,</span>
<a href="#l6.1767"></a><span id="l6.1767" class="difflineplus">+                                                 uint32_t *      mtime);</span>
<a href="#l6.1768"></a><span id="l6.1768"> </span>
<a href="#l6.1769"></a><span id="l6.1769"> /**</span>
<a href="#l6.1770"></a><span id="l6.1770">  * @brief Get data protection (encryption) mode, used in processed message.</span>
<a href="#l6.1771"></a><span id="l6.1771">  *</span>
<a href="#l6.1772"></a><span id="l6.1772">  * @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1773"></a><span id="l6.1773">  * @param mode on success string with mode will be stored here. Caller is responsible for</span>
<a href="#l6.1774"></a><span id="l6.1774">  *             freeing it using the rnp_buffer_free() call. May be NULL if information is not</span>
<a href="#l6.1775"></a><span id="l6.1775">  * needed. Currently defined values are as following:</span>
<a href="#l6.1776"></a><span id="l6.1776" class="difflineat">@@ -1658,453 +1696,460 @@ rnp_result_t rnp_op_verify_get_file_info</span>
<a href="#l6.1777"></a><span id="l6.1777">  *             - aead-eax : message was encrypted in AEAD-EAX mode</span>
<a href="#l6.1778"></a><span id="l6.1778">  * @param cipher symmetric cipher, used for data encryption. May be NULL if information is not</span>
<a href="#l6.1779"></a><span id="l6.1779">  *               needed. Must be freed by rnp_buffer_free() call.</span>
<a href="#l6.1780"></a><span id="l6.1780">  * @param valid true if message integrity protection was used (i.e. MDC or AEAD), and it was</span>
<a href="#l6.1781"></a><span id="l6.1781">  *              validated successfully. Otherwise (even for raw cfb mode) will be false. May be</span>
<a href="#l6.1782"></a><span id="l6.1782">  *              NULL if information is not needed.</span>
<a href="#l6.1783"></a><span id="l6.1783">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1784"></a><span id="l6.1784">  */</span>
<a href="#l6.1785"></a><span id="l6.1785" class="difflineminus">-rnp_result_t rnp_op_verify_get_protection_info(rnp_op_verify_t op,</span>
<a href="#l6.1786"></a><span id="l6.1786" class="difflineminus">-                                               char **         mode,</span>
<a href="#l6.1787"></a><span id="l6.1787" class="difflineminus">-                                               char **         cipher,</span>
<a href="#l6.1788"></a><span id="l6.1788" class="difflineminus">-                                               bool *          valid);</span>
<a href="#l6.1789"></a><span id="l6.1789" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_protection_info(rnp_op_verify_t op,</span>
<a href="#l6.1790"></a><span id="l6.1790" class="difflineplus">+                                                       char **         mode,</span>
<a href="#l6.1791"></a><span id="l6.1791" class="difflineplus">+                                                       char **         cipher,</span>
<a href="#l6.1792"></a><span id="l6.1792" class="difflineplus">+                                                       bool *          valid);</span>
<a href="#l6.1793"></a><span id="l6.1793"> </span>
<a href="#l6.1794"></a><span id="l6.1794"> /**</span>
<a href="#l6.1795"></a><span id="l6.1795">  * @brief Get number of public keys (recipients) to whom message was encrypted to.</span>
<a href="#l6.1796"></a><span id="l6.1796">  *</span>
<a href="#l6.1797"></a><span id="l6.1797">  * @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1798"></a><span id="l6.1798">  * @param count on success number of keys will be stored here. Cannot be NULL.</span>
<a href="#l6.1799"></a><span id="l6.1799">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1800"></a><span id="l6.1800">  */</span>
<a href="#l6.1801"></a><span id="l6.1801" class="difflineminus">-rnp_result_t rnp_op_verify_get_recipient_count(rnp_op_verify_t op, size_t *count);</span>
<a href="#l6.1802"></a><span id="l6.1802" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_recipient_count(rnp_op_verify_t op, size_t *count);</span>
<a href="#l6.1803"></a><span id="l6.1803"> </span>
<a href="#l6.1804"></a><span id="l6.1804"> /**</span>
<a href="#l6.1805"></a><span id="l6.1805">  * @brief Get the recipient's handle, used to decrypt message.</span>
<a href="#l6.1806"></a><span id="l6.1806">  *</span>
<a href="#l6.1807"></a><span id="l6.1807">  * @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1808"></a><span id="l6.1808">  * @param recipient pointer to the opaque handle context. Cannot be NULL. If recipient's key</span>
<a href="#l6.1809"></a><span id="l6.1809">  *                  was used to decrypt a message then handle will be stored here, otherwise</span>
<a href="#l6.1810"></a><span id="l6.1810">  *                  it will be set to NULL.</span>
<a href="#l6.1811"></a><span id="l6.1811">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1812"></a><span id="l6.1812">  */</span>
<a href="#l6.1813"></a><span id="l6.1813" class="difflineminus">-rnp_result_t rnp_op_verify_get_used_recipient(rnp_op_verify_t         op,</span>
<a href="#l6.1814"></a><span id="l6.1814" class="difflineminus">-                                              rnp_recipient_handle_t *recipient);</span>
<a href="#l6.1815"></a><span id="l6.1815" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_used_recipient(rnp_op_verify_t         op,</span>
<a href="#l6.1816"></a><span id="l6.1816" class="difflineplus">+                                                      rnp_recipient_handle_t *recipient);</span>
<a href="#l6.1817"></a><span id="l6.1817"> </span>
<a href="#l6.1818"></a><span id="l6.1818"> /**</span>
<a href="#l6.1819"></a><span id="l6.1819">  * @brief Get the recipient's handle by index.</span>
<a href="#l6.1820"></a><span id="l6.1820">  *</span>
<a href="#l6.1821"></a><span id="l6.1821">  * @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1822"></a><span id="l6.1822">  * @param idx zero-based index in array.</span>
<a href="#l6.1823"></a><span id="l6.1823">  * @param recipient pointer to the opaque handle context. Cannot be NULL. On success handle</span>
<a href="#l6.1824"></a><span id="l6.1824">  *                  will be stored here.</span>
<a href="#l6.1825"></a><span id="l6.1825">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1826"></a><span id="l6.1826">  */</span>
<a href="#l6.1827"></a><span id="l6.1827" class="difflineminus">-rnp_result_t rnp_op_verify_get_recipient_at(rnp_op_verify_t         op,</span>
<a href="#l6.1828"></a><span id="l6.1828" class="difflineminus">-                                            size_t                  idx,</span>
<a href="#l6.1829"></a><span id="l6.1829" class="difflineminus">-                                            rnp_recipient_handle_t *recipient);</span>
<a href="#l6.1830"></a><span id="l6.1830" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_recipient_at(rnp_op_verify_t         op,</span>
<a href="#l6.1831"></a><span id="l6.1831" class="difflineplus">+                                                    size_t                  idx,</span>
<a href="#l6.1832"></a><span id="l6.1832" class="difflineplus">+                                                    rnp_recipient_handle_t *recipient);</span>
<a href="#l6.1833"></a><span id="l6.1833"> </span>
<a href="#l6.1834"></a><span id="l6.1834"> /**</span>
<a href="#l6.1835"></a><span id="l6.1835">  * @brief Get recipient's keyid.</span>
<a href="#l6.1836"></a><span id="l6.1836">  *</span>
<a href="#l6.1837"></a><span id="l6.1837">  * @param recipient recipient's handle, obtained via rnp_op_verify_get_used_recipient() or</span>
<a href="#l6.1838"></a><span id="l6.1838">  *                  rnp_op_verify_get_recipient_at() function call. Cannot be NULL.</span>
<a href="#l6.1839"></a><span id="l6.1839">  * @param keyid on success pointer to NULL-terminated string with hex-encoded keyid will be</span>
<a href="#l6.1840"></a><span id="l6.1840">  *              stored here. Cannot be NULL. Must be freed using the rnp_buffer_destroy().</span>
<a href="#l6.1841"></a><span id="l6.1841">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1842"></a><span id="l6.1842">  */</span>
<a href="#l6.1843"></a><span id="l6.1843" class="difflineminus">-rnp_result_t rnp_recipient_get_keyid(rnp_recipient_handle_t recipient, char **keyid);</span>
<a href="#l6.1844"></a><span id="l6.1844" class="difflineplus">+RNP_API rnp_result_t rnp_recipient_get_keyid(rnp_recipient_handle_t recipient, char **keyid);</span>
<a href="#l6.1845"></a><span id="l6.1845"> </span>
<a href="#l6.1846"></a><span id="l6.1846"> /**</span>
<a href="#l6.1847"></a><span id="l6.1847">  * @brief Get recipient's key algorithm.</span>
<a href="#l6.1848"></a><span id="l6.1848">  *</span>
<a href="#l6.1849"></a><span id="l6.1849">  * @param recipient recipient's handle, obtained via rnp_op_verify_get_used_recipient() or</span>
<a href="#l6.1850"></a><span id="l6.1850">  *                  rnp_op_verify_get_recipient_at() function call. Cannot be NULL.</span>
<a href="#l6.1851"></a><span id="l6.1851">  * @param alg on success pointer to NULL-terminated string with algorithm will be stored here.</span>
<a href="#l6.1852"></a><span id="l6.1852">  *            Cannot be NULL. Must be freed using the rnp_buffer_destroy().</span>
<a href="#l6.1853"></a><span id="l6.1853">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1854"></a><span id="l6.1854">  */</span>
<a href="#l6.1855"></a><span id="l6.1855" class="difflineminus">-rnp_result_t rnp_recipient_get_alg(rnp_recipient_handle_t recipient, char **alg);</span>
<a href="#l6.1856"></a><span id="l6.1856" class="difflineplus">+RNP_API rnp_result_t rnp_recipient_get_alg(rnp_recipient_handle_t recipient, char **alg);</span>
<a href="#l6.1857"></a><span id="l6.1857"> </span>
<a href="#l6.1858"></a><span id="l6.1858"> /**</span>
<a href="#l6.1859"></a><span id="l6.1859">  * @brief Get number of symenc entries (i.e. passwords), to which message was encrypted.</span>
<a href="#l6.1860"></a><span id="l6.1860">  *</span>
<a href="#l6.1861"></a><span id="l6.1861">  * @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1862"></a><span id="l6.1862">  * @param count on success number of keys will be stored here. Cannot be NULL.</span>
<a href="#l6.1863"></a><span id="l6.1863">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1864"></a><span id="l6.1864">  */</span>
<a href="#l6.1865"></a><span id="l6.1865" class="difflineminus">-rnp_result_t rnp_op_verify_get_symenc_count(rnp_op_verify_t op, size_t *count);</span>
<a href="#l6.1866"></a><span id="l6.1866" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_symenc_count(rnp_op_verify_t op, size_t *count);</span>
<a href="#l6.1867"></a><span id="l6.1867"> </span>
<a href="#l6.1868"></a><span id="l6.1868"> /**</span>
<a href="#l6.1869"></a><span id="l6.1869">  * @brief Get the symenc handle, used to decrypt a message.</span>
<a href="#l6.1870"></a><span id="l6.1870">  *</span>
<a href="#l6.1871"></a><span id="l6.1871">  * @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1872"></a><span id="l6.1872">  * @param symenc pointer to the opaque symenc context. Cannot be NULL. If password was used to</span>
<a href="#l6.1873"></a><span id="l6.1873">  *               decrypt a message then handle will be stored here, otherwise it will be set to</span>
<a href="#l6.1874"></a><span id="l6.1874">  *               NULL.</span>
<a href="#l6.1875"></a><span id="l6.1875">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1876"></a><span id="l6.1876">  */</span>
<a href="#l6.1877"></a><span id="l6.1877" class="difflineminus">-rnp_result_t rnp_op_verify_get_used_symenc(rnp_op_verify_t op, rnp_symenc_handle_t *symenc);</span>
<a href="#l6.1878"></a><span id="l6.1878" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_used_symenc(rnp_op_verify_t      op,</span>
<a href="#l6.1879"></a><span id="l6.1879" class="difflineplus">+                                                   rnp_symenc_handle_t *symenc);</span>
<a href="#l6.1880"></a><span id="l6.1880"> </span>
<a href="#l6.1881"></a><span id="l6.1881"> /**</span>
<a href="#l6.1882"></a><span id="l6.1882">  * @brief Get the symenc handle by index.</span>
<a href="#l6.1883"></a><span id="l6.1883">  *</span>
<a href="#l6.1884"></a><span id="l6.1884">  * @param op opaque verification context. Must be initialized and have execute() called on it.</span>
<a href="#l6.1885"></a><span id="l6.1885">  * @param idx zero-based index in array.</span>
<a href="#l6.1886"></a><span id="l6.1886">  * @param symenc pointer to the opaque handle context. Cannot be NULL. On success handle</span>
<a href="#l6.1887"></a><span id="l6.1887">  *               will be stored here.</span>
<a href="#l6.1888"></a><span id="l6.1888">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1889"></a><span id="l6.1889">  */</span>
<a href="#l6.1890"></a><span id="l6.1890" class="difflineminus">-rnp_result_t rnp_op_verify_get_symenc_at(rnp_op_verify_t      op,</span>
<a href="#l6.1891"></a><span id="l6.1891" class="difflineminus">-                                         size_t               idx,</span>
<a href="#l6.1892"></a><span id="l6.1892" class="difflineminus">-                                         rnp_symenc_handle_t *symenc);</span>
<a href="#l6.1893"></a><span id="l6.1893" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_get_symenc_at(rnp_op_verify_t      op,</span>
<a href="#l6.1894"></a><span id="l6.1894" class="difflineplus">+                                                 size_t               idx,</span>
<a href="#l6.1895"></a><span id="l6.1895" class="difflineplus">+                                                 rnp_symenc_handle_t *symenc);</span>
<a href="#l6.1896"></a><span id="l6.1896"> </span>
<a href="#l6.1897"></a><span id="l6.1897"> /**</span>
<a href="#l6.1898"></a><span id="l6.1898">  * @brief Get the symmetric cipher, used to encrypt data encryption key.</span>
<a href="#l6.1899"></a><span id="l6.1899">  *        Note: if message is encrypted with only one passphrase and without public keys, then</span>
<a href="#l6.1900"></a><span id="l6.1900">  *        key, derived from password, may be used to encrypt the whole message.</span>
<a href="#l6.1901"></a><span id="l6.1901">  * @param symenc opaque handle, cannot be NULL.</span>
<a href="#l6.1902"></a><span id="l6.1902">  * @param cipher NULL-terminated string with cipher's name will be stored here. Cannot be NULL.</span>
<a href="#l6.1903"></a><span id="l6.1903">  *               Must be freed using the rnp_buffer_destroy().</span>
<a href="#l6.1904"></a><span id="l6.1904">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1905"></a><span id="l6.1905">  */</span>
<a href="#l6.1906"></a><span id="l6.1906" class="difflineminus">-rnp_result_t rnp_symenc_get_cipher(rnp_symenc_handle_t symenc, char **cipher);</span>
<a href="#l6.1907"></a><span id="l6.1907" class="difflineplus">+RNP_API rnp_result_t rnp_symenc_get_cipher(rnp_symenc_handle_t symenc, char **cipher);</span>
<a href="#l6.1908"></a><span id="l6.1908"> </span>
<a href="#l6.1909"></a><span id="l6.1909"> /**</span>
<a href="#l6.1910"></a><span id="l6.1910">  * @brief Get AEAD algorithm if it was used to encrypt data encryption key.</span>
<a href="#l6.1911"></a><span id="l6.1911">  *</span>
<a href="#l6.1912"></a><span id="l6.1912">  * @param symenc opaque handle, cannot be NULL.</span>
<a href="#l6.1913"></a><span id="l6.1913">  * @param alg NULL-terminated string with AEAD algorithm name will be stored here. If AEAD was</span>
<a href="#l6.1914"></a><span id="l6.1914">  *            not used then it will contain string 'None'. Must be freed using the</span>
<a href="#l6.1915"></a><span id="l6.1915">  *            rnp_buffer_destroy().</span>
<a href="#l6.1916"></a><span id="l6.1916">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1917"></a><span id="l6.1917">  */</span>
<a href="#l6.1918"></a><span id="l6.1918" class="difflineminus">-rnp_result_t rnp_symenc_get_aead_alg(rnp_symenc_handle_t symenc, char **alg);</span>
<a href="#l6.1919"></a><span id="l6.1919" class="difflineplus">+RNP_API rnp_result_t rnp_symenc_get_aead_alg(rnp_symenc_handle_t symenc, char **alg);</span>
<a href="#l6.1920"></a><span id="l6.1920"> </span>
<a href="#l6.1921"></a><span id="l6.1921"> /**</span>
<a href="#l6.1922"></a><span id="l6.1922">  * @brief Get hash algorithm, used to derive key from the passphrase.</span>
<a href="#l6.1923"></a><span id="l6.1923">  *</span>
<a href="#l6.1924"></a><span id="l6.1924">  * @param symenc opaque handle, cannot be NULL.</span>
<a href="#l6.1925"></a><span id="l6.1925">  * @param alg NULL-terminated string with hash algorithm name will be stored here. Cannot be</span>
<a href="#l6.1926"></a><span id="l6.1926">  *            NULL. Must be freed using the rnp_buffer_destroy().</span>
<a href="#l6.1927"></a><span id="l6.1927">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1928"></a><span id="l6.1928">  */</span>
<a href="#l6.1929"></a><span id="l6.1929" class="difflineminus">-rnp_result_t rnp_symenc_get_hash_alg(rnp_symenc_handle_t symenc, char **alg);</span>
<a href="#l6.1930"></a><span id="l6.1930" class="difflineplus">+RNP_API rnp_result_t rnp_symenc_get_hash_alg(rnp_symenc_handle_t symenc, char **alg);</span>
<a href="#l6.1931"></a><span id="l6.1931"> </span>
<a href="#l6.1932"></a><span id="l6.1932"> /**</span>
<a href="#l6.1933"></a><span id="l6.1933">  * @brief Get string-to-key type, used to derive password.</span>
<a href="#l6.1934"></a><span id="l6.1934">  *</span>
<a href="#l6.1935"></a><span id="l6.1935">  * @param symenc opaque handle, cannot be NULL.</span>
<a href="#l6.1936"></a><span id="l6.1936">  * @param type NULL-terminated string with s2k type will be stored here. Currently following</span>
<a href="#l6.1937"></a><span id="l6.1937">  *             types are available: 'Simple', 'Salted', 'Iterated and salted'. Please note that</span>
<a href="#l6.1938"></a><span id="l6.1938">  *             first two are considered weak and should not be used. Must be freed using the</span>
<a href="#l6.1939"></a><span id="l6.1939">  *             rnp_buffer_destroy().</span>
<a href="#l6.1940"></a><span id="l6.1940">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1941"></a><span id="l6.1941">  */</span>
<a href="#l6.1942"></a><span id="l6.1942" class="difflineminus">-rnp_result_t rnp_symenc_get_s2k_type(rnp_symenc_handle_t symenc, char **type);</span>
<a href="#l6.1943"></a><span id="l6.1943" class="difflineplus">+RNP_API rnp_result_t rnp_symenc_get_s2k_type(rnp_symenc_handle_t symenc, char **type);</span>
<a href="#l6.1944"></a><span id="l6.1944"> </span>
<a href="#l6.1945"></a><span id="l6.1945"> /**</span>
<a href="#l6.1946"></a><span id="l6.1946">  * @brief Get number of iterations in iterated-and-salted S2K, if it was used.</span>
<a href="#l6.1947"></a><span id="l6.1947">  *</span>
<a href="#l6.1948"></a><span id="l6.1948">  * @param symenc opaque handle, cannot be NULL.</span>
<a href="#l6.1949"></a><span id="l6.1949">  * @param iterations on success number of iterations will be stored here. Cannot be NULL.</span>
<a href="#l6.1950"></a><span id="l6.1950">  *                   If non-iterated s2k was used then will be set to 0.</span>
<a href="#l6.1951"></a><span id="l6.1951">  * @return RNP_SUCCESS if call succeeded, or error code otherwise.</span>
<a href="#l6.1952"></a><span id="l6.1952">  */</span>
<a href="#l6.1953"></a><span id="l6.1953" class="difflineminus">-rnp_result_t rnp_symenc_get_s2k_iterations(rnp_symenc_handle_t symenc, uint32_t *iterations);</span>
<a href="#l6.1954"></a><span id="l6.1954" class="difflineplus">+RNP_API rnp_result_t rnp_symenc_get_s2k_iterations(rnp_symenc_handle_t symenc,</span>
<a href="#l6.1955"></a><span id="l6.1955" class="difflineplus">+                                                   uint32_t *          iterations);</span>
<a href="#l6.1956"></a><span id="l6.1956"> </span>
<a href="#l6.1957"></a><span id="l6.1957"> /** @brief Free resources allocated in verification context.</span>
<a href="#l6.1958"></a><span id="l6.1958">  *  @param op opaque verification context. Must be initialized.</span>
<a href="#l6.1959"></a><span id="l6.1959">  *  @return RNP_SUCCESS if call succeeded.</span>
<a href="#l6.1960"></a><span id="l6.1960">  */</span>
<a href="#l6.1961"></a><span id="l6.1961" class="difflineminus">-rnp_result_t rnp_op_verify_destroy(rnp_op_verify_t op);</span>
<a href="#l6.1962"></a><span id="l6.1962" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_destroy(rnp_op_verify_t op);</span>
<a href="#l6.1963"></a><span id="l6.1963"> </span>
<a href="#l6.1964"></a><span id="l6.1964"> /** @brief Get signature verification status.</span>
<a href="#l6.1965"></a><span id="l6.1965">  *  @param sig opaque signature context obtained via rnp_op_verify_get_signature_at call.</span>
<a href="#l6.1966"></a><span id="l6.1966">  *  @return signature verification status:</span>
<a href="#l6.1967"></a><span id="l6.1967">  *          RNP_SUCCESS : signature is valid</span>
<a href="#l6.1968"></a><span id="l6.1968">  *          RNP_ERROR_SIGNATURE_EXPIRED : signature is valid but expired</span>
<a href="#l6.1969"></a><span id="l6.1969">  *          RNP_ERROR_KEY_NOT_FOUND : public key to verify signature was not available</span>
<a href="#l6.1970"></a><span id="l6.1970">  *          RNP_ERROR_SIGNATURE_INVALID : data or signature was modified</span>
<a href="#l6.1971"></a><span id="l6.1971">  */</span>
<a href="#l6.1972"></a><span id="l6.1972" class="difflineminus">-rnp_result_t rnp_op_verify_signature_get_status(rnp_op_verify_signature_t sig);</span>
<a href="#l6.1973"></a><span id="l6.1973" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_signature_get_status(rnp_op_verify_signature_t sig);</span>
<a href="#l6.1974"></a><span id="l6.1974"> </span>
<a href="#l6.1975"></a><span id="l6.1975"> /** Get the signature handle from the verified signature. This would allow to query extended</span>
<a href="#l6.1976"></a><span id="l6.1976">  * information on the signature.</span>
<a href="#l6.1977"></a><span id="l6.1977">  *</span>
<a href="#l6.1978"></a><span id="l6.1978">  * @param sig verified signature context, cannot be NULL.</span>
<a href="#l6.1979"></a><span id="l6.1979">  * @param handle signature handle will be stored here on success. You must free it after use</span>
<a href="#l6.1980"></a><span id="l6.1980">  * with</span>
<a href="#l6.1981"></a><span id="l6.1981">  *            the rnp_signature_handle_destroy() function.</span>
<a href="#l6.1982"></a><span id="l6.1982">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.1983"></a><span id="l6.1983">  */</span>
<a href="#l6.1984"></a><span id="l6.1984" class="difflineminus">-rnp_result_t rnp_op_verify_signature_get_handle(rnp_op_verify_signature_t sig,</span>
<a href="#l6.1985"></a><span id="l6.1985" class="difflineminus">-                                                rnp_signature_handle_t *  handle);</span>
<a href="#l6.1986"></a><span id="l6.1986" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_signature_get_handle(rnp_op_verify_signature_t sig,</span>
<a href="#l6.1987"></a><span id="l6.1987" class="difflineplus">+                                                        rnp_signature_handle_t *  handle);</span>
<a href="#l6.1988"></a><span id="l6.1988"> </span>
<a href="#l6.1989"></a><span id="l6.1989"> /** @brief Get hash function used to calculate signature</span>
<a href="#l6.1990"></a><span id="l6.1990">  *  @param sig opaque signature context obtained via rnp_op_verify_get_signature_at call.</span>
<a href="#l6.1991"></a><span id="l6.1991">  *  @param hash pointer to string with hash algorithm name will be put here on success.</span>
<a href="#l6.1992"></a><span id="l6.1992">  *              Caller is responsible for freeing it with rnp_buffer_free</span>
<a href="#l6.1993"></a><span id="l6.1993">  *  @return RNP_SUCCESS or error code otherwise</span>
<a href="#l6.1994"></a><span id="l6.1994">  */</span>
<a href="#l6.1995"></a><span id="l6.1995" class="difflineminus">-rnp_result_t rnp_op_verify_signature_get_hash(rnp_op_verify_signature_t sig, char **hash);</span>
<a href="#l6.1996"></a><span id="l6.1996" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_signature_get_hash(rnp_op_verify_signature_t sig,</span>
<a href="#l6.1997"></a><span id="l6.1997" class="difflineplus">+                                                      char **                   hash);</span>
<a href="#l6.1998"></a><span id="l6.1998"> </span>
<a href="#l6.1999"></a><span id="l6.1999"> /** @brief Get key used for signing</span>
<a href="#l6.2000"></a><span id="l6.2000">  *  @param sig opaque signature context obtained via rnp_op_verify_get_signature_at call.</span>
<a href="#l6.2001"></a><span id="l6.2001">  *  @param key pointer to opaque key handle structure.</span>
<a href="#l6.2002"></a><span id="l6.2002">  *  @return RNP_SUCCESS or error code otherwise</span>
<a href="#l6.2003"></a><span id="l6.2003">  */</span>
<a href="#l6.2004"></a><span id="l6.2004" class="difflineminus">-rnp_result_t rnp_op_verify_signature_get_key(rnp_op_verify_signature_t sig,</span>
<a href="#l6.2005"></a><span id="l6.2005" class="difflineminus">-                                             rnp_key_handle_t *        key);</span>
<a href="#l6.2006"></a><span id="l6.2006" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_signature_get_key(rnp_op_verify_signature_t sig,</span>
<a href="#l6.2007"></a><span id="l6.2007" class="difflineplus">+                                                     rnp_key_handle_t *        key);</span>
<a href="#l6.2008"></a><span id="l6.2008"> </span>
<a href="#l6.2009"></a><span id="l6.2009"> /** @brief Get signature creation and expiration times</span>
<a href="#l6.2010"></a><span id="l6.2010">  *  @param sig opaque signature context obtained via rnp_op_verify_get_signature_at call.</span>
<a href="#l6.2011"></a><span id="l6.2011">  *  @param create signature creation time will be put here. It is number of seconds since</span>
<a href="#l6.2012"></a><span id="l6.2012">  *                Jan, 1 1970 UTC. May be NULL if called doesn't need this data.</span>
<a href="#l6.2013"></a><span id="l6.2013">  *  @param expires signature expiration time will be stored here. It is number of seconds since</span>
<a href="#l6.2014"></a><span id="l6.2014">  *                 the creation time or 0 if signature never expires. May be NULL.</span>
<a href="#l6.2015"></a><span id="l6.2015">  *  @return RNP_SUCCESS or error code otherwise</span>
<a href="#l6.2016"></a><span id="l6.2016">  */</span>
<a href="#l6.2017"></a><span id="l6.2017" class="difflineminus">-rnp_result_t rnp_op_verify_signature_get_times(rnp_op_verify_signature_t sig,</span>
<a href="#l6.2018"></a><span id="l6.2018" class="difflineminus">-                                               uint32_t *                create,</span>
<a href="#l6.2019"></a><span id="l6.2019" class="difflineminus">-                                               uint32_t *                expires);</span>
<a href="#l6.2020"></a><span id="l6.2020" class="difflineplus">+RNP_API rnp_result_t rnp_op_verify_signature_get_times(rnp_op_verify_signature_t sig,</span>
<a href="#l6.2021"></a><span id="l6.2021" class="difflineplus">+                                                       uint32_t *                create,</span>
<a href="#l6.2022"></a><span id="l6.2022" class="difflineplus">+                                                       uint32_t *                expires);</span>
<a href="#l6.2023"></a><span id="l6.2023"> </span>
<a href="#l6.2024"></a><span id="l6.2024"> /**</span>
<a href="#l6.2025"></a><span id="l6.2025">  * @brief Free buffer allocated by a function in this header.</span>
<a href="#l6.2026"></a><span id="l6.2026">  *</span>
<a href="#l6.2027"></a><span id="l6.2027">  * @param ptr previously allocated buffer. May be NULL, then nothing is done.</span>
<a href="#l6.2028"></a><span id="l6.2028">  */</span>
<a href="#l6.2029"></a><span id="l6.2029" class="difflineminus">-void rnp_buffer_destroy(void *ptr);</span>
<a href="#l6.2030"></a><span id="l6.2030" class="difflineplus">+RNP_API void rnp_buffer_destroy(void *ptr);</span>
<a href="#l6.2031"></a><span id="l6.2031"> </span>
<a href="#l6.2032"></a><span id="l6.2032"> /**</span>
<a href="#l6.2033"></a><span id="l6.2033">  * @brief Securely clear buffer contents.</span>
<a href="#l6.2034"></a><span id="l6.2034">  *</span>
<a href="#l6.2035"></a><span id="l6.2035">  * @param ptr pointer to the buffer contents, may be NULL.</span>
<a href="#l6.2036"></a><span id="l6.2036">  * @param size number of bytes in buffer.</span>
<a href="#l6.2037"></a><span id="l6.2037">  */</span>
<a href="#l6.2038"></a><span id="l6.2038" class="difflineminus">-void rnp_buffer_clear(void *ptr, size_t size);</span>
<a href="#l6.2039"></a><span id="l6.2039" class="difflineplus">+RNP_API void rnp_buffer_clear(void *ptr, size_t size);</span>
<a href="#l6.2040"></a><span id="l6.2040"> </span>
<a href="#l6.2041"></a><span id="l6.2041"> /**</span>
<a href="#l6.2042"></a><span id="l6.2042">  * @brief Initialize input struct to read from a path</span>
<a href="#l6.2043"></a><span id="l6.2043">  *</span>
<a href="#l6.2044"></a><span id="l6.2044">  * @param input pointer to the input opaque structure</span>
<a href="#l6.2045"></a><span id="l6.2045">  * @param path path of the file to read from</span>
<a href="#l6.2046"></a><span id="l6.2046">  * @return RNP_SUCCESS if operation succeeded and input struct is ready to read, or error code</span>
<a href="#l6.2047"></a><span id="l6.2047">  * otherwise</span>
<a href="#l6.2048"></a><span id="l6.2048">  */</span>
<a href="#l6.2049"></a><span id="l6.2049" class="difflineminus">-rnp_result_t rnp_input_from_path(rnp_input_t *input, const char *path);</span>
<a href="#l6.2050"></a><span id="l6.2050" class="difflineplus">+RNP_API rnp_result_t rnp_input_from_path(rnp_input_t *input, const char *path);</span>
<a href="#l6.2051"></a><span id="l6.2051"> </span>
<a href="#l6.2052"></a><span id="l6.2052"> /**</span>
<a href="#l6.2053"></a><span id="l6.2053">  * @brief Initialize input struct to read from memory</span>
<a href="#l6.2054"></a><span id="l6.2054">  *</span>
<a href="#l6.2055"></a><span id="l6.2055">  * @param input pointer to the input opaque structure</span>
<a href="#l6.2056"></a><span id="l6.2056">  * @param buf memory buffer. Could not be NULL.</span>
<a href="#l6.2057"></a><span id="l6.2057">  * @param buf_len number of bytes available to read from buf</span>
<a href="#l6.2058"></a><span id="l6.2058">  * @param do_copy if true then the buffer will be copied internally. If</span>
<a href="#l6.2059"></a><span id="l6.2059">  *        false then the application should ensure that the buffer</span>
<a href="#l6.2060"></a><span id="l6.2060">  *        is valid and not modified during the lifetime of this object.</span>
<a href="#l6.2061"></a><span id="l6.2061">  * @return RNP_SUCCESS if operation succeeded or error code otherwise</span>
<a href="#l6.2062"></a><span id="l6.2062">  */</span>
<a href="#l6.2063"></a><span id="l6.2063" class="difflineminus">-rnp_result_t rnp_input_from_memory(rnp_input_t * input,</span>
<a href="#l6.2064"></a><span id="l6.2064" class="difflineminus">-                                   const uint8_t buf[],</span>
<a href="#l6.2065"></a><span id="l6.2065" class="difflineminus">-                                   size_t        buf_len,</span>
<a href="#l6.2066"></a><span id="l6.2066" class="difflineminus">-                                   bool          do_copy);</span>
<a href="#l6.2067"></a><span id="l6.2067" class="difflineplus">+RNP_API rnp_result_t rnp_input_from_memory(rnp_input_t * input,</span>
<a href="#l6.2068"></a><span id="l6.2068" class="difflineplus">+                                           const uint8_t buf[],</span>
<a href="#l6.2069"></a><span id="l6.2069" class="difflineplus">+                                           size_t        buf_len,</span>
<a href="#l6.2070"></a><span id="l6.2070" class="difflineplus">+                                           bool          do_copy);</span>
<a href="#l6.2071"></a><span id="l6.2071"> </span>
<a href="#l6.2072"></a><span id="l6.2072"> /**</span>
<a href="#l6.2073"></a><span id="l6.2073">  * @brief Initialize input struct to read via callbacks</span>
<a href="#l6.2074"></a><span id="l6.2074">  *</span>
<a href="#l6.2075"></a><span id="l6.2075">  * @param input pointer to the input opaque structure</span>
<a href="#l6.2076"></a><span id="l6.2076">  * @param reader callback used for reading</span>
<a href="#l6.2077"></a><span id="l6.2077">  * @param closer callback used to close the stream</span>
<a href="#l6.2078"></a><span id="l6.2078">  * @param app_ctx context to pass as parameter to reader and closer</span>
<a href="#l6.2079"></a><span id="l6.2079">  * @return RNP_SUCCESS if operation succeeded or error code otherwise</span>
<a href="#l6.2080"></a><span id="l6.2080">  */</span>
<a href="#l6.2081"></a><span id="l6.2081" class="difflineminus">-rnp_result_t rnp_input_from_callback(rnp_input_t *       input,</span>
<a href="#l6.2082"></a><span id="l6.2082" class="difflineminus">-                                     rnp_input_reader_t *reader,</span>
<a href="#l6.2083"></a><span id="l6.2083" class="difflineminus">-                                     rnp_input_closer_t *closer,</span>
<a href="#l6.2084"></a><span id="l6.2084" class="difflineminus">-                                     void *              app_ctx);</span>
<a href="#l6.2085"></a><span id="l6.2085" class="difflineplus">+RNP_API rnp_result_t rnp_input_from_callback(rnp_input_t *       input,</span>
<a href="#l6.2086"></a><span id="l6.2086" class="difflineplus">+                                             rnp_input_reader_t *reader,</span>
<a href="#l6.2087"></a><span id="l6.2087" class="difflineplus">+                                             rnp_input_closer_t *closer,</span>
<a href="#l6.2088"></a><span id="l6.2088" class="difflineplus">+                                             void *              app_ctx);</span>
<a href="#l6.2089"></a><span id="l6.2089"> </span>
<a href="#l6.2090"></a><span id="l6.2090"> /**</span>
<a href="#l6.2091"></a><span id="l6.2091">  * @brief Close previously opened input and free all corresponding resources</span>
<a href="#l6.2092"></a><span id="l6.2092">  *</span>
<a href="#l6.2093"></a><span id="l6.2093">  * @param input previously opened input structure</span>
<a href="#l6.2094"></a><span id="l6.2094">  * @return RNP_SUCCESS if operation succeeded or error code otherwise</span>
<a href="#l6.2095"></a><span id="l6.2095">  */</span>
<a href="#l6.2096"></a><span id="l6.2096" class="difflineminus">-rnp_result_t rnp_input_destroy(rnp_input_t input);</span>
<a href="#l6.2097"></a><span id="l6.2097" class="difflineplus">+RNP_API rnp_result_t rnp_input_destroy(rnp_input_t input);</span>
<a href="#l6.2098"></a><span id="l6.2098"> </span>
<a href="#l6.2099"></a><span id="l6.2099"> /**</span>
<a href="#l6.2100"></a><span id="l6.2100">  * @brief Initialize output structure to write to a path. If path is a file</span>
<a href="#l6.2101"></a><span id="l6.2101">  * that already exists then it will be overwritten.</span>
<a href="#l6.2102"></a><span id="l6.2102">  *</span>
<a href="#l6.2103"></a><span id="l6.2103">  * @param output pointer to the opaque output structure.</span>
<a href="#l6.2104"></a><span id="l6.2104">  * @param path path to the file.</span>
<a href="#l6.2105"></a><span id="l6.2105">  * @return RNP_SUCCESS if file was opened successfully and ready for writing or error code</span>
<a href="#l6.2106"></a><span id="l6.2106">  * otherwise.</span>
<a href="#l6.2107"></a><span id="l6.2107">  */</span>
<a href="#l6.2108"></a><span id="l6.2108" class="difflineminus">-rnp_result_t rnp_output_to_path(rnp_output_t *output, const char *path);</span>
<a href="#l6.2109"></a><span id="l6.2109" class="difflineplus">+RNP_API rnp_result_t rnp_output_to_path(rnp_output_t *output, const char *path);</span>
<a href="#l6.2110"></a><span id="l6.2110"> </span>
<a href="#l6.2111"></a><span id="l6.2111"> /**</span>
<a href="#l6.2112"></a><span id="l6.2112">  * @brief Initialize structure to write to a file.</span>
<a href="#l6.2113"></a><span id="l6.2113">  *        Note: it doesn't allow output to directory like rnp_output_to_path does, but</span>
<a href="#l6.2114"></a><span id="l6.2114">  *        allows additional options to be specified.</span>
<a href="#l6.2115"></a><span id="l6.2115">  *        When RNP_OUTPUT_FILE_RANDOM flag is included then you may want to call</span>
<a href="#l6.2116"></a><span id="l6.2116">  *        rnp_output_finish() to make sure that final rename succeeded.</span>
<a href="#l6.2117"></a><span id="l6.2117">  * @param output pointer to the opaque output structure. After use you must free it using the</span>
<a href="#l6.2118"></a><span id="l6.2118">  *               rnp_output_destroy() function.</span>
<a href="#l6.2119"></a><span id="l6.2119">  * @param path path to the file.</span>
<a href="#l6.2120"></a><span id="l6.2120">  * @param flags additional flags, see RNP_OUTPUT_* flags.</span>
<a href="#l6.2121"></a><span id="l6.2121">  * @return RNP_SUCCESS if file was opened successfully and ready for writing or error code</span>
<a href="#l6.2122"></a><span id="l6.2122">  *         otherwise.</span>
<a href="#l6.2123"></a><span id="l6.2123">  */</span>
<a href="#l6.2124"></a><span id="l6.2124" class="difflineminus">-rnp_result_t rnp_output_to_file(rnp_output_t *output, const char *path, uint32_t flags);</span>
<a href="#l6.2125"></a><span id="l6.2125" class="difflineplus">+RNP_API rnp_result_t rnp_output_to_file(rnp_output_t *output,</span>
<a href="#l6.2126"></a><span id="l6.2126" class="difflineplus">+                                        const char *  path,</span>
<a href="#l6.2127"></a><span id="l6.2127" class="difflineplus">+                                        uint32_t      flags);</span>
<a href="#l6.2128"></a><span id="l6.2128"> </span>
<a href="#l6.2129"></a><span id="l6.2129"> /**</span>
<a href="#l6.2130"></a><span id="l6.2130">  * @brief Initialize output structure to write to the memory.</span>
<a href="#l6.2131"></a><span id="l6.2131">  *</span>
<a href="#l6.2132"></a><span id="l6.2132">  * @param output pointer to the opaque output structure.</span>
<a href="#l6.2133"></a><span id="l6.2133">  * @param max_alloc maximum amount of memory to allocate. 0 value means unlimited.</span>
<a href="#l6.2134"></a><span id="l6.2134">  * @return RNP_SUCCESS if operation succeeded or error code otherwise.</span>
<a href="#l6.2135"></a><span id="l6.2135">  */</span>
<a href="#l6.2136"></a><span id="l6.2136" class="difflineminus">-rnp_result_t rnp_output_to_memory(rnp_output_t *output, size_t max_alloc);</span>
<a href="#l6.2137"></a><span id="l6.2137" class="difflineplus">+RNP_API rnp_result_t rnp_output_to_memory(rnp_output_t *output, size_t max_alloc);</span>
<a href="#l6.2138"></a><span id="l6.2138"> </span>
<a href="#l6.2139"></a><span id="l6.2139"> /**</span>
<a href="#l6.2140"></a><span id="l6.2140">  * @brief Output data to armored stream (and then output to other destination), allowing</span>
<a href="#l6.2141"></a><span id="l6.2141">  *        streamed output.</span>
<a href="#l6.2142"></a><span id="l6.2142">  *</span>
<a href="#l6.2143"></a><span id="l6.2143">  * @param base initialized output structure, where armored data will be written to.</span>
<a href="#l6.2144"></a><span id="l6.2144">  * @param output pointer to the opaque output structure. You must free it later using the</span>
<a href="#l6.2145"></a><span id="l6.2145">  *               rnp_output_destroy() function.</span>
<a href="#l6.2146"></a><span id="l6.2146">  * @param type type of the armored stream. See rnp_enarmor() for possible values.</span>
<a href="#l6.2147"></a><span id="l6.2147">  * @return RNP_SUCCESS if operation succeeded or error code otherwise.</span>
<a href="#l6.2148"></a><span id="l6.2148">  */</span>
<a href="#l6.2149"></a><span id="l6.2149" class="difflineminus">-rnp_result_t rnp_output_to_armor(rnp_output_t base, rnp_output_t *output, const char *type);</span>
<a href="#l6.2150"></a><span id="l6.2150" class="difflineplus">+RNP_API rnp_result_t rnp_output_to_armor(rnp_output_t  base,</span>
<a href="#l6.2151"></a><span id="l6.2151" class="difflineplus">+                                         rnp_output_t *output,</span>
<a href="#l6.2152"></a><span id="l6.2152" class="difflineplus">+                                         const char *  type);</span>
<a href="#l6.2153"></a><span id="l6.2153"> </span>
<a href="#l6.2154"></a><span id="l6.2154"> /**</span>
<a href="#l6.2155"></a><span id="l6.2155">  * @brief Get the pointer to the buffer of output, initialized by rnp_output_to_memory</span>
<a href="#l6.2156"></a><span id="l6.2156">  *</span>
<a href="#l6.2157"></a><span id="l6.2157">  * @param output output structure, initialized by rnp_output_to_memory and populated with data</span>
<a href="#l6.2158"></a><span id="l6.2158">  * @param buf pointer to the buffer will be stored here, could not be NULL</span>
<a href="#l6.2159"></a><span id="l6.2159">  * @param len number of bytes in buffer will be stored here, could not be NULL</span>
<a href="#l6.2160"></a><span id="l6.2160">  * @param do_copy if true then a newly-allocated buffer will be returned and the application</span>
<a href="#l6.2161"></a><span id="l6.2161">  *        will be responsible for freeing it with rnp_buffer_destroy. If false</span>
<a href="#l6.2162"></a><span id="l6.2162">  *        then the internal buffer is returned and the application must not modify the</span>
<a href="#l6.2163"></a><span id="l6.2163">  *        buffer or access it after this object is destroyed.</span>
<a href="#l6.2164"></a><span id="l6.2164">  * @return RNP_SUCCESS if operation succeeded or error code otherwise.</span>
<a href="#l6.2165"></a><span id="l6.2165">  */</span>
<a href="#l6.2166"></a><span id="l6.2166" class="difflineminus">-rnp_result_t rnp_output_memory_get_buf(rnp_output_t output,</span>
<a href="#l6.2167"></a><span id="l6.2167" class="difflineminus">-                                       uint8_t **   buf,</span>
<a href="#l6.2168"></a><span id="l6.2168" class="difflineminus">-                                       size_t *     len,</span>
<a href="#l6.2169"></a><span id="l6.2169" class="difflineminus">-                                       bool         do_copy);</span>
<a href="#l6.2170"></a><span id="l6.2170" class="difflineplus">+RNP_API rnp_result_t rnp_output_memory_get_buf(rnp_output_t output,</span>
<a href="#l6.2171"></a><span id="l6.2171" class="difflineplus">+                                               uint8_t **   buf,</span>
<a href="#l6.2172"></a><span id="l6.2172" class="difflineplus">+                                               size_t *     len,</span>
<a href="#l6.2173"></a><span id="l6.2173" class="difflineplus">+                                               bool         do_copy);</span>
<a href="#l6.2174"></a><span id="l6.2174"> </span>
<a href="#l6.2175"></a><span id="l6.2175"> /**</span>
<a href="#l6.2176"></a><span id="l6.2176">  * @brief Initialize output structure to write to callbacks.</span>
<a href="#l6.2177"></a><span id="l6.2177">  *</span>
<a href="#l6.2178"></a><span id="l6.2178">  * @param output pointer to the opaque output structure.</span>
<a href="#l6.2179"></a><span id="l6.2179">  * @param writer write callback.</span>
<a href="#l6.2180"></a><span id="l6.2180">  * @param closer close callback.</span>
<a href="#l6.2181"></a><span id="l6.2181">  * @param app_ctx context parameter which will be passed to writer and closer.</span>
<a href="#l6.2182"></a><span id="l6.2182">  * @return RNP_SUCCESS if operation succeeded or error code otherwise.</span>
<a href="#l6.2183"></a><span id="l6.2183">  */</span>
<a href="#l6.2184"></a><span id="l6.2184" class="difflineminus">-rnp_result_t rnp_output_to_callback(rnp_output_t *       output,</span>
<a href="#l6.2185"></a><span id="l6.2185" class="difflineminus">-                                    rnp_output_writer_t *writer,</span>
<a href="#l6.2186"></a><span id="l6.2186" class="difflineminus">-                                    rnp_output_closer_t *closer,</span>
<a href="#l6.2187"></a><span id="l6.2187" class="difflineminus">-                                    void *               app_ctx);</span>
<a href="#l6.2188"></a><span id="l6.2188" class="difflineplus">+RNP_API rnp_result_t rnp_output_to_callback(rnp_output_t *       output,</span>
<a href="#l6.2189"></a><span id="l6.2189" class="difflineplus">+                                            rnp_output_writer_t *writer,</span>
<a href="#l6.2190"></a><span id="l6.2190" class="difflineplus">+                                            rnp_output_closer_t *closer,</span>
<a href="#l6.2191"></a><span id="l6.2191" class="difflineplus">+                                            void *               app_ctx);</span>
<a href="#l6.2192"></a><span id="l6.2192"> </span>
<a href="#l6.2193"></a><span id="l6.2193"> /**</span>
<a href="#l6.2194"></a><span id="l6.2194">  * @brief Initialize output structure which will discard all data</span>
<a href="#l6.2195"></a><span id="l6.2195">  *</span>
<a href="#l6.2196"></a><span id="l6.2196">  * @param output pointer to the opaque output structure.</span>
<a href="#l6.2197"></a><span id="l6.2197">  * @return RNP_SUCCESS if operation succeeded or error code otherwise.</span>
<a href="#l6.2198"></a><span id="l6.2198">  */</span>
<a href="#l6.2199"></a><span id="l6.2199" class="difflineminus">-rnp_result_t rnp_output_to_null(rnp_output_t *output);</span>
<a href="#l6.2200"></a><span id="l6.2200" class="difflineplus">+RNP_API rnp_result_t rnp_output_to_null(rnp_output_t *output);</span>
<a href="#l6.2201"></a><span id="l6.2201"> </span>
<a href="#l6.2202"></a><span id="l6.2202"> /**</span>
<a href="#l6.2203"></a><span id="l6.2203">  * @brief write some data to the output structure.</span>
<a href="#l6.2204"></a><span id="l6.2204">  *</span>
<a href="#l6.2205"></a><span id="l6.2205">  * @param output pointer to the initialized opaque output structure.</span>
<a href="#l6.2206"></a><span id="l6.2206">  * @param data pointer to data which should be written.</span>
<a href="#l6.2207"></a><span id="l6.2207">  * @param size number of bytes to write.</span>
<a href="#l6.2208"></a><span id="l6.2208">  * @param written on success will contain the number of bytes written. May be NULL.</span>
<a href="#l6.2209"></a><span id="l6.2209">  * @return rnp_result_t RNP_SUCCESS if operation succeeded or error code otherwise.</span>
<a href="#l6.2210"></a><span id="l6.2210">  */</span>
<a href="#l6.2211"></a><span id="l6.2211" class="difflineminus">-rnp_result_t rnp_output_write(rnp_output_t output,</span>
<a href="#l6.2212"></a><span id="l6.2212" class="difflineminus">-                              const void * data,</span>
<a href="#l6.2213"></a><span id="l6.2213" class="difflineminus">-                              size_t       size,</span>
<a href="#l6.2214"></a><span id="l6.2214" class="difflineminus">-                              size_t *     written);</span>
<a href="#l6.2215"></a><span id="l6.2215" class="difflineplus">+RNP_API rnp_result_t rnp_output_write(rnp_output_t output,</span>
<a href="#l6.2216"></a><span id="l6.2216" class="difflineplus">+                                      const void * data,</span>
<a href="#l6.2217"></a><span id="l6.2217" class="difflineplus">+                                      size_t       size,</span>
<a href="#l6.2218"></a><span id="l6.2218" class="difflineplus">+                                      size_t *     written);</span>
<a href="#l6.2219"></a><span id="l6.2219"> </span>
<a href="#l6.2220"></a><span id="l6.2220"> /**</span>
<a href="#l6.2221"></a><span id="l6.2221">  * @brief Finish writing to the output.</span>
<a href="#l6.2222"></a><span id="l6.2222">  *        Note: on most output types you'll need just to call rnp_output_destroy().</span>
<a href="#l6.2223"></a><span id="l6.2223">  *        However, for file output with RNP_OUTPUT_FILE_RANDOM flag, you need to call this</span>
<a href="#l6.2224"></a><span id="l6.2224">  *        to make sure that rename from random to required name succeeded.</span>
<a href="#l6.2225"></a><span id="l6.2225">  *</span>
<a href="#l6.2226"></a><span id="l6.2226">  * @param output pointer to the opaque output structure.</span>
<a href="#l6.2227"></a><span id="l6.2227">  * @return RNP_SUCCESS if operation succeeded or error code otherwise.</span>
<a href="#l6.2228"></a><span id="l6.2228">  */</span>
<a href="#l6.2229"></a><span id="l6.2229" class="difflineminus">-rnp_result_t rnp_output_finish(rnp_output_t output);</span>
<a href="#l6.2230"></a><span id="l6.2230" class="difflineplus">+RNP_API rnp_result_t rnp_output_finish(rnp_output_t output);</span>
<a href="#l6.2231"></a><span id="l6.2231"> </span>
<a href="#l6.2232"></a><span id="l6.2232"> /**</span>
<a href="#l6.2233"></a><span id="l6.2233">  * @brief Close previously opened output and free all associated data.</span>
<a href="#l6.2234"></a><span id="l6.2234">  *</span>
<a href="#l6.2235"></a><span id="l6.2235">  * @param output previously opened output structure.</span>
<a href="#l6.2236"></a><span id="l6.2236">  * @return RNP_SUCCESS if operation succeeds or error code otherwise.</span>
<a href="#l6.2237"></a><span id="l6.2237">  */</span>
<a href="#l6.2238"></a><span id="l6.2238" class="difflineminus">-rnp_result_t rnp_output_destroy(rnp_output_t output);</span>
<a href="#l6.2239"></a><span id="l6.2239" class="difflineplus">+RNP_API rnp_result_t rnp_output_destroy(rnp_output_t output);</span>
<a href="#l6.2240"></a><span id="l6.2240"> </span>
<a href="#l6.2241"></a><span id="l6.2241"> /* encrypt */</span>
<a href="#l6.2242"></a><span id="l6.2242" class="difflineminus">-rnp_result_t rnp_op_encrypt_create(rnp_op_encrypt_t *op,</span>
<a href="#l6.2243"></a><span id="l6.2243" class="difflineminus">-                                   rnp_ffi_t         ffi,</span>
<a href="#l6.2244"></a><span id="l6.2244" class="difflineminus">-                                   rnp_input_t       input,</span>
<a href="#l6.2245"></a><span id="l6.2245" class="difflineminus">-                                   rnp_output_t      output);</span>
<a href="#l6.2246"></a><span id="l6.2246" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_create(rnp_op_encrypt_t *op,</span>
<a href="#l6.2247"></a><span id="l6.2247" class="difflineplus">+                                           rnp_ffi_t         ffi,</span>
<a href="#l6.2248"></a><span id="l6.2248" class="difflineplus">+                                           rnp_input_t       input,</span>
<a href="#l6.2249"></a><span id="l6.2249" class="difflineplus">+                                           rnp_output_t      output);</span>
<a href="#l6.2250"></a><span id="l6.2250"> </span>
<a href="#l6.2251"></a><span id="l6.2251" class="difflineminus">-rnp_result_t rnp_op_encrypt_add_recipient(rnp_op_encrypt_t op, rnp_key_handle_t key);</span>
<a href="#l6.2252"></a><span id="l6.2252" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_add_recipient(rnp_op_encrypt_t op, rnp_key_handle_t key);</span>
<a href="#l6.2253"></a><span id="l6.2253"> </span>
<a href="#l6.2254"></a><span id="l6.2254"> /**</span>
<a href="#l6.2255"></a><span id="l6.2255">  * @brief Add signature to encrypting context, so data will be encrypted and signed.</span>
<a href="#l6.2256"></a><span id="l6.2256">  *</span>
<a href="#l6.2257"></a><span id="l6.2257">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2258"></a><span id="l6.2258">  * @param key private key, used for signing.</span>
<a href="#l6.2259"></a><span id="l6.2259">  * @param sig pointer to the newly added signature will be stored here. May be NULL.</span>
<a href="#l6.2260"></a><span id="l6.2260">  * @return RNP_SUCCESS if signature was added or error code otherwise.</span>
<a href="#l6.2261"></a><span id="l6.2261">  */</span>
<a href="#l6.2262"></a><span id="l6.2262" class="difflineminus">-rnp_result_t rnp_op_encrypt_add_signature(rnp_op_encrypt_t         op,</span>
<a href="#l6.2263"></a><span id="l6.2263" class="difflineminus">-                                          rnp_key_handle_t         key,</span>
<a href="#l6.2264"></a><span id="l6.2264" class="difflineminus">-                                          rnp_op_sign_signature_t *sig);</span>
<a href="#l6.2265"></a><span id="l6.2265" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_add_signature(rnp_op_encrypt_t         op,</span>
<a href="#l6.2266"></a><span id="l6.2266" class="difflineplus">+                                                  rnp_key_handle_t         key,</span>
<a href="#l6.2267"></a><span id="l6.2267" class="difflineplus">+                                                  rnp_op_sign_signature_t *sig);</span>
<a href="#l6.2268"></a><span id="l6.2268"> </span>
<a href="#l6.2269"></a><span id="l6.2269"> /**</span>
<a href="#l6.2270"></a><span id="l6.2270">  * @brief Set hash function used for signature calculation. Makes sense if encrypt-and-sign is</span>
<a href="#l6.2271"></a><span id="l6.2271">  * used. To set hash function for each signature separately use rnp_op_sign_signature_set_hash.</span>
<a href="#l6.2272"></a><span id="l6.2272">  *</span>
<a href="#l6.2273"></a><span id="l6.2273">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2274"></a><span id="l6.2274">  * @param hash hash algorithm to be used as NULL-terminated string. Following values are</span>
<a href="#l6.2275"></a><span id="l6.2275">  *        supported: &quot;MD5&quot;, &quot;SHA1&quot;, &quot;RIPEMD160&quot;, &quot;SHA256&quot;, &quot;SHA384&quot;, &quot;SHA512&quot;, &quot;SHA224&quot;, &quot;SM3&quot;.</span>
<a href="#l6.2276"></a><span id="l6.2276">  *        However, some signature types may require specific hash function or hash function</span>
<a href="#l6.2277"></a><span id="l6.2277">  *        output length.</span>
<a href="#l6.2278"></a><span id="l6.2278">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2279"></a><span id="l6.2279">  */</span>
<a href="#l6.2280"></a><span id="l6.2280" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_hash(rnp_op_encrypt_t op, const char *hash);</span>
<a href="#l6.2281"></a><span id="l6.2281" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_hash(rnp_op_encrypt_t op, const char *hash);</span>
<a href="#l6.2282"></a><span id="l6.2282"> </span>
<a href="#l6.2283"></a><span id="l6.2283"> /**</span>
<a href="#l6.2284"></a><span id="l6.2284">  * @brief Set signature creation time. By default current time is used.</span>
<a href="#l6.2285"></a><span id="l6.2285">  *</span>
<a href="#l6.2286"></a><span id="l6.2286">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2287"></a><span id="l6.2287">  * @param create creation time in seconds since Jan, 1 1970 UTC</span>
<a href="#l6.2288"></a><span id="l6.2288">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2289"></a><span id="l6.2289">  */</span>
<a href="#l6.2290"></a><span id="l6.2290" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_creation_time(rnp_op_encrypt_t op, uint32_t create);</span>
<a href="#l6.2291"></a><span id="l6.2291" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_creation_time(rnp_op_encrypt_t op, uint32_t create);</span>
<a href="#l6.2292"></a><span id="l6.2292"> </span>
<a href="#l6.2293"></a><span id="l6.2293"> /**</span>
<a href="#l6.2294"></a><span id="l6.2294">  * @brief Set signature expiration time. By default signatures do not expire.</span>
<a href="#l6.2295"></a><span id="l6.2295">  *</span>
<a href="#l6.2296"></a><span id="l6.2296">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2297"></a><span id="l6.2297">  * @param expire expiration time in seconds since the creation time. 0 value is used to mark</span>
<a href="#l6.2298"></a><span id="l6.2298">  *        signature as non-expiring</span>
<a href="#l6.2299"></a><span id="l6.2299">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2300"></a><span id="l6.2300">  */</span>
<a href="#l6.2301"></a><span id="l6.2301" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_expiration_time(rnp_op_encrypt_t op, uint32_t expire);</span>
<a href="#l6.2302"></a><span id="l6.2302" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_expiration_time(rnp_op_encrypt_t op, uint32_t expire);</span>
<a href="#l6.2303"></a><span id="l6.2303"> </span>
<a href="#l6.2304"></a><span id="l6.2304"> /**</span>
<a href="#l6.2305"></a><span id="l6.2305">  * @brief Add password which is used to encrypt data. Multiple passwords can be added.</span>
<a href="#l6.2306"></a><span id="l6.2306">  *</span>
<a href="#l6.2307"></a><span id="l6.2307">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2308"></a><span id="l6.2308">  * @param password NULL-terminated password string, or NULL if password should be requested</span>
<a href="#l6.2309"></a><span id="l6.2309">  *                 via password provider.</span>
<a href="#l6.2310"></a><span id="l6.2310">  * @param s2k_hash hash algorithm, used in key-from-password derivation. Pass NULL for default</span>
<a href="#l6.2311"></a><span id="l6.2311" class="difflineat">@@ -2115,164 +2160,184 @@ rnp_result_t rnp_op_encrypt_set_expirati</span>
<a href="#l6.2312"></a><span id="l6.2312">  *        encodable value. In case it exceeds the maximum encodable value, it will be decreased</span>
<a href="#l6.2313"></a><span id="l6.2313">  *        to the maximum encodable value.</span>
<a href="#l6.2314"></a><span id="l6.2314">  *        If 0 is passed, an optimal number (greater or equal to 1024) will be calculated based</span>
<a href="#l6.2315"></a><span id="l6.2315">  *        on performance measurement.</span>
<a href="#l6.2316"></a><span id="l6.2316">  * @param s2k_cipher symmetric cipher, used for key encryption. Pass NULL for default value.</span>
<a href="#l6.2317"></a><span id="l6.2317">  * See rnp_op_encrypt_set_cipher for possible values.</span>
<a href="#l6.2318"></a><span id="l6.2318">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2319"></a><span id="l6.2319">  */</span>
<a href="#l6.2320"></a><span id="l6.2320" class="difflineminus">-rnp_result_t rnp_op_encrypt_add_password(rnp_op_encrypt_t op,</span>
<a href="#l6.2321"></a><span id="l6.2321" class="difflineminus">-                                         const char *     password,</span>
<a href="#l6.2322"></a><span id="l6.2322" class="difflineminus">-                                         const char *     s2k_hash,</span>
<a href="#l6.2323"></a><span id="l6.2323" class="difflineminus">-                                         size_t           iterations,</span>
<a href="#l6.2324"></a><span id="l6.2324" class="difflineminus">-                                         const char *     s2k_cipher);</span>
<a href="#l6.2325"></a><span id="l6.2325" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_add_password(rnp_op_encrypt_t op,</span>
<a href="#l6.2326"></a><span id="l6.2326" class="difflineplus">+                                                 const char *     password,</span>
<a href="#l6.2327"></a><span id="l6.2327" class="difflineplus">+                                                 const char *     s2k_hash,</span>
<a href="#l6.2328"></a><span id="l6.2328" class="difflineplus">+                                                 size_t           iterations,</span>
<a href="#l6.2329"></a><span id="l6.2329" class="difflineplus">+                                                 const char *     s2k_cipher);</span>
<a href="#l6.2330"></a><span id="l6.2330"> </span>
<a href="#l6.2331"></a><span id="l6.2331"> /**</span>
<a href="#l6.2332"></a><span id="l6.2332">  * @brief Set whether output should be ASCII-armored, or binary.</span>
<a href="#l6.2333"></a><span id="l6.2333">  *</span>
<a href="#l6.2334"></a><span id="l6.2334">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2335"></a><span id="l6.2335">  * @param armored true for armored, false for binary</span>
<a href="#l6.2336"></a><span id="l6.2336">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2337"></a><span id="l6.2337">  */</span>
<a href="#l6.2338"></a><span id="l6.2338" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_armor(rnp_op_encrypt_t op, bool armored);</span>
<a href="#l6.2339"></a><span id="l6.2339" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_armor(rnp_op_encrypt_t op, bool armored);</span>
<a href="#l6.2340"></a><span id="l6.2340"> </span>
<a href="#l6.2341"></a><span id="l6.2341"> /**</span>
<a href="#l6.2342"></a><span id="l6.2342">  * @brief set the encryption algorithm</span>
<a href="#l6.2343"></a><span id="l6.2343">  *</span>
<a href="#l6.2344"></a><span id="l6.2344">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2345"></a><span id="l6.2345">  * @param cipher NULL-terminated string with cipher's name. One of the &quot;IDEA&quot;, &quot;TRIPLEDES&quot;,</span>
<a href="#l6.2346"></a><span id="l6.2346">  *        &quot;CAST5&quot;, &quot;BLOWFISH&quot;, &quot;AES128&quot;, &quot;AES192&quot;, &quot;AES256&quot;, &quot;TWOFISH&quot;, &quot;CAMELLIA128&quot;,</span>
<a href="#l6.2347"></a><span id="l6.2347">  *        &quot;CAMELLIA192&quot;, &quot;CAMELLIA256&quot;, &quot;SM4&quot;.</span>
<a href="#l6.2348"></a><span id="l6.2348">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2349"></a><span id="l6.2349">  */</span>
<a href="#l6.2350"></a><span id="l6.2350" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_cipher(rnp_op_encrypt_t op, const char *cipher);</span>
<a href="#l6.2351"></a><span id="l6.2351" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_cipher(rnp_op_encrypt_t op, const char *cipher);</span>
<a href="#l6.2352"></a><span id="l6.2352"> </span>
<a href="#l6.2353"></a><span id="l6.2353"> /**</span>
<a href="#l6.2354"></a><span id="l6.2354">  * @brief set AEAD mode algorithm or disable AEAD usage. By default it is disabled.</span>
<a href="#l6.2355"></a><span id="l6.2355">  *</span>
<a href="#l6.2356"></a><span id="l6.2356">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2357"></a><span id="l6.2357">  * @param alg NULL-terminated AEAD algorithm name. Use &quot;None&quot; to disable AEAD, or &quot;EAX&quot;, &quot;OCB&quot;</span>
<a href="#l6.2358"></a><span id="l6.2358">  * to use the corresponding algorithm.</span>
<a href="#l6.2359"></a><span id="l6.2359">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2360"></a><span id="l6.2360">  */</span>
<a href="#l6.2361"></a><span id="l6.2361" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_aead(rnp_op_encrypt_t op, const char *alg);</span>
<a href="#l6.2362"></a><span id="l6.2362" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_aead(rnp_op_encrypt_t op, const char *alg);</span>
<a href="#l6.2363"></a><span id="l6.2363"> </span>
<a href="#l6.2364"></a><span id="l6.2364"> /**</span>
<a href="#l6.2365"></a><span id="l6.2365">  * @brief set chunk length for AEAD mode via number of chunk size bits (refer OpenPGP</span>
<a href="#l6.2366"></a><span id="l6.2366">  * specificationf for the details).</span>
<a href="#l6.2367"></a><span id="l6.2367">  *</span>
<a href="#l6.2368"></a><span id="l6.2368">  * @param op opaque encrypting context. Must be allocated and initialized.</span>
<a href="#l6.2369"></a><span id="l6.2369">  * @param bits number of bits, currently it must be between 0 to 56.</span>
<a href="#l6.2370"></a><span id="l6.2370">  * @return RNP_SUCCESS or error code if failed</span>
<a href="#l6.2371"></a><span id="l6.2371">  */</span>
<a href="#l6.2372"></a><span id="l6.2372" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_aead_bits(rnp_op_encrypt_t op, int bits);</span>
<a href="#l6.2373"></a><span id="l6.2373" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_aead_bits(rnp_op_encrypt_t op, int bits);</span>
<a href="#l6.2374"></a><span id="l6.2374"> </span>
<a href="#l6.2375"></a><span id="l6.2375"> /**</span>
<a href="#l6.2376"></a><span id="l6.2376">  * @brief set the compression algorithm and level for the inner raw data</span>
<a href="#l6.2377"></a><span id="l6.2377">  *</span>
<a href="#l6.2378"></a><span id="l6.2378">  * @param op opaque encrypted context. Must be allocated and initialized</span>
<a href="#l6.2379"></a><span id="l6.2379">  * @param compression compression algorithm name. Can be one of the &quot;Uncompressed&quot;, &quot;ZIP&quot;,</span>
<a href="#l6.2380"></a><span id="l6.2380">  *        &quot;ZLIB&quot;, &quot;BZip2&quot;. Please note that ZIP is not PkWare's ZIP file format but just a</span>
<a href="#l6.2381"></a><span id="l6.2381">  *        DEFLATE compressed data (RFC 1951).</span>
<a href="#l6.2382"></a><span id="l6.2382">  * @param level 0 - 9, where 0 is no compression and 9 is maximum compression level.</span>
<a href="#l6.2383"></a><span id="l6.2383">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2384"></a><span id="l6.2384">  */</span>
<a href="#l6.2385"></a><span id="l6.2385" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_compression(rnp_op_encrypt_t op,</span>
<a href="#l6.2386"></a><span id="l6.2386" class="difflineminus">-                                            const char *     compression,</span>
<a href="#l6.2387"></a><span id="l6.2387" class="difflineminus">-                                            int              level);</span>
<a href="#l6.2388"></a><span id="l6.2388" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_compression(rnp_op_encrypt_t op,</span>
<a href="#l6.2389"></a><span id="l6.2389" class="difflineplus">+                                                    const char *     compression,</span>
<a href="#l6.2390"></a><span id="l6.2390" class="difflineplus">+                                                    int              level);</span>
<a href="#l6.2391"></a><span id="l6.2391"> </span>
<a href="#l6.2392"></a><span id="l6.2392"> /**</span>
<a href="#l6.2393"></a><span id="l6.2393">  * @brief set the internally stored file name for the data being encrypted</span>
<a href="#l6.2394"></a><span id="l6.2394">  *</span>
<a href="#l6.2395"></a><span id="l6.2395">  * @param op opaque encrypted context. Must be allocated and initialized</span>
<a href="#l6.2396"></a><span id="l6.2396">  * @param filename file name as NULL-terminated string. May be empty string. Value &quot;_CONSOLE&quot;</span>
<a href="#l6.2397"></a><span id="l6.2397">  * may have specific processing (see RFC 4880 for the details), depending on implementation.</span>
<a href="#l6.2398"></a><span id="l6.2398">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2399"></a><span id="l6.2399">  */</span>
<a href="#l6.2400"></a><span id="l6.2400" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_file_name(rnp_op_encrypt_t op, const char *filename);</span>
<a href="#l6.2401"></a><span id="l6.2401" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_file_name(rnp_op_encrypt_t op, const char *filename);</span>
<a href="#l6.2402"></a><span id="l6.2402"> </span>
<a href="#l6.2403"></a><span id="l6.2403"> /**</span>
<a href="#l6.2404"></a><span id="l6.2404">  * @brief set the internally stored file modification date for the data being encrypted</span>
<a href="#l6.2405"></a><span id="l6.2405">  *</span>
<a href="#l6.2406"></a><span id="l6.2406">  * @param op opaque encrypted context. Must be allocated and initialized</span>
<a href="#l6.2407"></a><span id="l6.2407">  * @param mtime time in seconds since Jan, 1 1970.</span>
<a href="#l6.2408"></a><span id="l6.2408">  * @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2409"></a><span id="l6.2409">  */</span>
<a href="#l6.2410"></a><span id="l6.2410" class="difflineminus">-rnp_result_t rnp_op_encrypt_set_file_mtime(rnp_op_encrypt_t op, uint32_t mtime);</span>
<a href="#l6.2411"></a><span id="l6.2411" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_set_file_mtime(rnp_op_encrypt_t op, uint32_t mtime);</span>
<a href="#l6.2412"></a><span id="l6.2412"> </span>
<a href="#l6.2413"></a><span id="l6.2413" class="difflineminus">-rnp_result_t rnp_op_encrypt_execute(rnp_op_encrypt_t op);</span>
<a href="#l6.2414"></a><span id="l6.2414" class="difflineminus">-rnp_result_t rnp_op_encrypt_destroy(rnp_op_encrypt_t op);</span>
<a href="#l6.2415"></a><span id="l6.2415" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_execute(rnp_op_encrypt_t op);</span>
<a href="#l6.2416"></a><span id="l6.2416" class="difflineplus">+RNP_API rnp_result_t rnp_op_encrypt_destroy(rnp_op_encrypt_t op);</span>
<a href="#l6.2417"></a><span id="l6.2417"> </span>
<a href="#l6.2418"></a><span id="l6.2418" class="difflineminus">-rnp_result_t rnp_decrypt(rnp_ffi_t ffi, rnp_input_t input, rnp_output_t output);</span>
<a href="#l6.2419"></a><span id="l6.2419" class="difflineplus">+RNP_API rnp_result_t rnp_decrypt(rnp_ffi_t ffi, rnp_input_t input, rnp_output_t output);</span>
<a href="#l6.2420"></a><span id="l6.2420"> </span>
<a href="#l6.2421"></a><span id="l6.2421"> /** retrieve the raw data for a public key</span>
<a href="#l6.2422"></a><span id="l6.2422">  *</span>
<a href="#l6.2423"></a><span id="l6.2423">  *  This will always be PGP packets and will never include ASCII armor.</span>
<a href="#l6.2424"></a><span id="l6.2424">  *</span>
<a href="#l6.2425"></a><span id="l6.2425">  *  @param handle the key handle</span>
<a href="#l6.2426"></a><span id="l6.2426">  *  @param buf</span>
<a href="#l6.2427"></a><span id="l6.2427">  *  @param buf_len</span>
<a href="#l6.2428"></a><span id="l6.2428">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2429"></a><span id="l6.2429">  */</span>
<a href="#l6.2430"></a><span id="l6.2430" class="difflineminus">-rnp_result_t rnp_get_public_key_data(rnp_key_handle_t handle, uint8_t **buf, size_t *buf_len);</span>
<a href="#l6.2431"></a><span id="l6.2431" class="difflineplus">+RNP_API rnp_result_t rnp_get_public_key_data(rnp_key_handle_t handle,</span>
<a href="#l6.2432"></a><span id="l6.2432" class="difflineplus">+                                             uint8_t **       buf,</span>
<a href="#l6.2433"></a><span id="l6.2433" class="difflineplus">+                                             size_t *         buf_len);</span>
<a href="#l6.2434"></a><span id="l6.2434"> </span>
<a href="#l6.2435"></a><span id="l6.2435"> /** retrieve the raw data for a secret key</span>
<a href="#l6.2436"></a><span id="l6.2436">  *</span>
<a href="#l6.2437"></a><span id="l6.2437">  *  If this is a G10 key, this will be the s-expr data. Otherwise, it will</span>
<a href="#l6.2438"></a><span id="l6.2438">  *  be PGP packets.</span>
<a href="#l6.2439"></a><span id="l6.2439">  *</span>
<a href="#l6.2440"></a><span id="l6.2440">  *  Note that this result will never include ASCII armor.</span>
<a href="#l6.2441"></a><span id="l6.2441">  *</span>
<a href="#l6.2442"></a><span id="l6.2442">  *  @param handle the key handle</span>
<a href="#l6.2443"></a><span id="l6.2443">  *  @param buf</span>
<a href="#l6.2444"></a><span id="l6.2444">  *  @param buf_len</span>
<a href="#l6.2445"></a><span id="l6.2445">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2446"></a><span id="l6.2446">  */</span>
<a href="#l6.2447"></a><span id="l6.2447" class="difflineminus">-rnp_result_t rnp_get_secret_key_data(rnp_key_handle_t handle, uint8_t **buf, size_t *buf_len);</span>
<a href="#l6.2448"></a><span id="l6.2448" class="difflineplus">+RNP_API rnp_result_t rnp_get_secret_key_data(rnp_key_handle_t handle,</span>
<a href="#l6.2449"></a><span id="l6.2449" class="difflineplus">+                                             uint8_t **       buf,</span>
<a href="#l6.2450"></a><span id="l6.2450" class="difflineplus">+                                             size_t *         buf_len);</span>
<a href="#l6.2451"></a><span id="l6.2451"> </span>
<a href="#l6.2452"></a><span id="l6.2452"> /** output key information to JSON structure and serialize it to the string</span>
<a href="#l6.2453"></a><span id="l6.2453">  *</span>
<a href="#l6.2454"></a><span id="l6.2454">  * @param handle the key handle, could not be NULL</span>
<a href="#l6.2455"></a><span id="l6.2455">  * @param flags controls which key data is printed, see RNP_JSON_* constants.</span>
<a href="#l6.2456"></a><span id="l6.2456">  * @param result pointer to the resulting string will be stored here on success. You must</span>
<a href="#l6.2457"></a><span id="l6.2457">  *               release it afterwards via rnp_buffer_destroy() function call.</span>
<a href="#l6.2458"></a><span id="l6.2458">  * @return RNP_SUCCESS or error code if failed.</span>
<a href="#l6.2459"></a><span id="l6.2459">  */</span>
<a href="#l6.2460"></a><span id="l6.2460" class="difflineminus">-rnp_result_t rnp_key_to_json(rnp_key_handle_t handle, uint32_t flags, char **result);</span>
<a href="#l6.2461"></a><span id="l6.2461" class="difflineplus">+RNP_API rnp_result_t rnp_key_to_json(rnp_key_handle_t handle, uint32_t flags, char **result);</span>
<a href="#l6.2462"></a><span id="l6.2462"> </span>
<a href="#l6.2463"></a><span id="l6.2463"> /** create an identifier iterator</span>
<a href="#l6.2464"></a><span id="l6.2464">  *</span>
<a href="#l6.2465"></a><span id="l6.2465">  *  @param ffi</span>
<a href="#l6.2466"></a><span id="l6.2466">  *  @param it pointer that will be set to the created iterator</span>
<a href="#l6.2467"></a><span id="l6.2467">  *  @param identifier_type the type of identifier (&quot;userid&quot;, &quot;keyid&quot;, &quot;grip&quot;)</span>
<a href="#l6.2468"></a><span id="l6.2468">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2469"></a><span id="l6.2469">  */</span>
<a href="#l6.2470"></a><span id="l6.2470" class="difflineminus">-rnp_result_t rnp_identifier_iterator_create(rnp_ffi_t                  ffi,</span>
<a href="#l6.2471"></a><span id="l6.2471" class="difflineminus">-                                            rnp_identifier_iterator_t *it,</span>
<a href="#l6.2472"></a><span id="l6.2472" class="difflineminus">-                                            const char *               identifier_type);</span>
<a href="#l6.2473"></a><span id="l6.2473" class="difflineplus">+RNP_API rnp_result_t rnp_identifier_iterator_create(rnp_ffi_t                  ffi,</span>
<a href="#l6.2474"></a><span id="l6.2474" class="difflineplus">+                                                    rnp_identifier_iterator_t *it,</span>
<a href="#l6.2475"></a><span id="l6.2475" class="difflineplus">+                                                    const char *identifier_type);</span>
<a href="#l6.2476"></a><span id="l6.2476"> </span>
<a href="#l6.2477"></a><span id="l6.2477"> /** retrieve the next item from an iterator</span>
<a href="#l6.2478"></a><span id="l6.2478">  *</span>
<a href="#l6.2479"></a><span id="l6.2479">  *  @param it the iterator</span>
<a href="#l6.2480"></a><span id="l6.2480">  *  @param identifier pointer that will be set to the identifier value.</span>
<a href="#l6.2481"></a><span id="l6.2481">  *         Must not be NULL. This buffer should not be freed by the application.</span>
<a href="#l6.2482"></a><span id="l6.2482">  *         It will be modified by subsequent calls to this function, and its</span>
<a href="#l6.2483"></a><span id="l6.2483">  *         life is tied to the iterator.</span>
<a href="#l6.2484"></a><span id="l6.2484">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2485"></a><span id="l6.2485">  */</span>
<a href="#l6.2486"></a><span id="l6.2486" class="difflineminus">-rnp_result_t rnp_identifier_iterator_next(rnp_identifier_iterator_t it,</span>
<a href="#l6.2487"></a><span id="l6.2487" class="difflineminus">-                                          const char **             identifier);</span>
<a href="#l6.2488"></a><span id="l6.2488" class="difflineplus">+RNP_API rnp_result_t rnp_identifier_iterator_next(rnp_identifier_iterator_t it,</span>
<a href="#l6.2489"></a><span id="l6.2489" class="difflineplus">+                                                  const char **             identifier);</span>
<a href="#l6.2490"></a><span id="l6.2490"> </span>
<a href="#l6.2491"></a><span id="l6.2491"> /** destroy an identifier iterator</span>
<a href="#l6.2492"></a><span id="l6.2492">  *</span>
<a href="#l6.2493"></a><span id="l6.2493">  *  @param it the iterator object</span>
<a href="#l6.2494"></a><span id="l6.2494">  *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2495"></a><span id="l6.2495">  */</span>
<a href="#l6.2496"></a><span id="l6.2496" class="difflineminus">-rnp_result_t rnp_identifier_iterator_destroy(rnp_identifier_iterator_t it);</span>
<a href="#l6.2497"></a><span id="l6.2497" class="difflineplus">+RNP_API rnp_result_t rnp_identifier_iterator_destroy(rnp_identifier_iterator_t it);</span>
<a href="#l6.2498"></a><span id="l6.2498" class="difflineplus">+</span>
<a href="#l6.2499"></a><span id="l6.2499" class="difflineplus">+/** Read from input and write to output</span>
<a href="#l6.2500"></a><span id="l6.2500" class="difflineplus">+ *</span>
<a href="#l6.2501"></a><span id="l6.2501" class="difflineplus">+ *  @param input stream to read data from</span>
<a href="#l6.2502"></a><span id="l6.2502" class="difflineplus">+ *  @param output stream to write data to</span>
<a href="#l6.2503"></a><span id="l6.2503" class="difflineplus">+ *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2504"></a><span id="l6.2504" class="difflineplus">+ */</span>
<a href="#l6.2505"></a><span id="l6.2505" class="difflineplus">+RNP_API rnp_result_t rnp_output_pipe(rnp_input_t input, rnp_output_t output);</span>
<a href="#l6.2506"></a><span id="l6.2506" class="difflineplus">+</span>
<a href="#l6.2507"></a><span id="l6.2507" class="difflineplus">+/** Set line length for armored output</span>
<a href="#l6.2508"></a><span id="l6.2508" class="difflineplus">+ *</span>
<a href="#l6.2509"></a><span id="l6.2509" class="difflineplus">+ *  @param output stream to configure</span>
<a href="#l6.2510"></a><span id="l6.2510" class="difflineplus">+ *  @param llen line length in characters [16..76]</span>
<a href="#l6.2511"></a><span id="l6.2511" class="difflineplus">+ *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l6.2512"></a><span id="l6.2512" class="difflineplus">+ */</span>
<a href="#l6.2513"></a><span id="l6.2513" class="difflineplus">+RNP_API rnp_result_t rnp_output_armor_set_line_length(rnp_output_t output, size_t llen);</span>
<a href="#l6.2514"></a><span id="l6.2514"> </span>
<a href="#l6.2515"></a><span id="l6.2515"> #if defined(__cplusplus)</span>
<a href="#l6.2516"></a><span id="l6.2516"> }</span>
<a href="#l6.2517"></a><span id="l6.2517"> </span>
<a href="#l6.2518"></a><span id="l6.2518"> #endif</span>
<a href="#l6.2519"></a><span id="l6.2519"> </span>
<a href="#l6.2520"></a><span id="l6.2520"> /** Algorithm Strings</span>
<a href="#l6.2521"></a><span id="l6.2521">  */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/third_party/rnp/include/rnp/rnp_sdk.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/third_party/rnp/include/rnp/rnp_sdk.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l7.4"></a><span id="l7.4"> /*</span>
<a href="#l7.5"></a><span id="l7.5" class="difflineminus">- * Copyright (c) 2017, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l7.6"></a><span id="l7.6" class="difflineplus">+ * Copyright (c) 2017-2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l7.7"></a><span id="l7.7">  * Copyright (c) 2009-2010 The NetBSD Foundation, Inc.</span>
<a href="#l7.8"></a><span id="l7.8">  * All rights reserved.</span>
<a href="#l7.9"></a><span id="l7.9">  *</span>
<a href="#l7.10"></a><span id="l7.10">  * This code is originally derived from software contributed to</span>
<a href="#l7.11"></a><span id="l7.11">  * The NetBSD Foundation by Alistair Crooks (agc@netbsd.org), and</span>
<a href="#l7.12"></a><span id="l7.12">  * carried further by Ribose Inc (https://www.ribose.com).</span>
<a href="#l7.13"></a><span id="l7.13">  *</span>
<a href="#l7.14"></a><span id="l7.14">  * Redistribution and use in source and binary forms, with or without</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineat">@@ -48,37 +48,28 @@ extern &quot;C&quot; {</span>
<a href="#l7.16"></a><span id="l7.16"> typedef enum { RNP_HEX_LOWERCASE, RNP_HEX_UPPERCASE } rnp_hex_format_t;</span>
<a href="#l7.17"></a><span id="l7.17"> </span>
<a href="#l7.18"></a><span id="l7.18"> void rnp_log(const char *, ...) PRINTFLIKE(1, 2);</span>
<a href="#l7.19"></a><span id="l7.19"> </span>
<a href="#l7.20"></a><span id="l7.20"> int rnp_strcasecmp(const char *, const char *);</span>
<a href="#l7.21"></a><span id="l7.21"> </span>
<a href="#l7.22"></a><span id="l7.22"> char *rnp_strhexdump_upper(char *dest, const uint8_t *src, size_t length, const char *sep);</span>
<a href="#l7.23"></a><span id="l7.23"> </span>
<a href="#l7.24"></a><span id="l7.24" class="difflineminus">-int64_t rnp_filemtime(const char *path);</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineminus">-</span>
<a href="#l7.26"></a><span id="l7.26"> char *rnp_compose_path(const char *first, ...);</span>
<a href="#l7.27"></a><span id="l7.27"> char *rnp_compose_path_ex(char **buf, size_t *buf_len, const char *first, ...);</span>
<a href="#l7.28"></a><span id="l7.28"> </span>
<a href="#l7.29"></a><span id="l7.29"> bool rnp_path_exists(const char *path);</span>
<a href="#l7.30"></a><span id="l7.30"> bool rnp_dir_exists(const char *path);</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-bool rnp_file_exists(const char *path);</span>
<a href="#l7.32"></a><span id="l7.32"> </span>
<a href="#l7.33"></a><span id="l7.33"> bool rnp_hex_encode(</span>
<a href="#l7.34"></a><span id="l7.34">   const uint8_t *buf, size_t buf_len, char *hex, size_t hex_len, rnp_hex_format_t format);</span>
<a href="#l7.35"></a><span id="l7.35"> size_t rnp_hex_decode(const char *hex, uint8_t *buf, size_t buf_len);</span>
<a href="#l7.36"></a><span id="l7.36"> </span>
<a href="#l7.37"></a><span id="l7.37"> char *rnp_strlwr(char *s);</span>
<a href="#l7.38"></a><span id="l7.38"> </span>
<a href="#l7.39"></a><span id="l7.39" class="difflineminus">-/** @brief strip eol symbols (\r, \n) from the end of the string</span>
<a href="#l7.40"></a><span id="l7.40" class="difflineminus">- *  @param s NULL-terminated string, which will be modified</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineminus">- *  @return string s itself</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineminus">- */</span>
<a href="#l7.43"></a><span id="l7.43" class="difflineminus">-char *rnp_strip_eol(char *s);</span>
<a href="#l7.44"></a><span id="l7.44" class="difflineminus">-</span>
<a href="#l7.45"></a><span id="l7.45"> bool hex2bin(const char *hex, size_t hexlen, uint8_t *bin, size_t len, size_t *out);</span>
<a href="#l7.46"></a><span id="l7.46"> </span>
<a href="#l7.47"></a><span id="l7.47"> void pgp_forget(void *, size_t);</span>
<a href="#l7.48"></a><span id="l7.48"> </span>
<a href="#l7.49"></a><span id="l7.49"> #if defined(__cplusplus)</span>
<a href="#l7.50"></a><span id="l7.50"> }</span>
<a href="#l7.51"></a><span id="l7.51"> #endif</span>
<a href="#l7.52"></a><span id="l7.52"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1">new file mode 100644</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineminus">--- /dev/null</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineplus">+++ b/third_party/rnp/src/common/CMakeLists.txt</span>
<a href="#l8.4"></a><span id="l8.4" class="difflineat">@@ -0,0 +1,45 @@</span>
<a href="#l8.5"></a><span id="l8.5" class="difflineplus">+# Copyright (c) 2020 Ribose Inc.</span>
<a href="#l8.6"></a><span id="l8.6" class="difflineplus">+# All rights reserved.</span>
<a href="#l8.7"></a><span id="l8.7" class="difflineplus">+#</span>
<a href="#l8.8"></a><span id="l8.8" class="difflineplus">+# Redistribution and use in source and binary forms, with or without</span>
<a href="#l8.9"></a><span id="l8.9" class="difflineplus">+# modification, are permitted provided that the following conditions</span>
<a href="#l8.10"></a><span id="l8.10" class="difflineplus">+# are met:</span>
<a href="#l8.11"></a><span id="l8.11" class="difflineplus">+# 1. Redistributions of source code must retain the above copyright</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+#    notice, this list of conditions and the following disclaimer.</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+# 2. Redistributions in binary form must reproduce the above copyright</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+#    notice, this list of conditions and the following disclaimer in the</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+#    documentation and/or other materials provided with the distribution.</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+#</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineplus">+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineplus">+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineplus">+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineplus">+# POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+add_library(rnp-common OBJECT</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+  list.cpp</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+  str-utils.cpp</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+  file-utils.cpp</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+)</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+target_include_directories(rnp-common</span>
<a href="#l8.36"></a><span id="l8.36" class="difflineplus">+  PUBLIC</span>
<a href="#l8.37"></a><span id="l8.37" class="difflineplus">+    &quot;$&lt;BUILD_INTERFACE:${PROJECT_BINARY_DIR}/src/lib&gt;&quot;</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineplus">+    &quot;$&lt;BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include&gt;&quot;</span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+    &quot;$&lt;INSTALL_INTERFACE:include&gt;&quot;</span>
<a href="#l8.40"></a><span id="l8.40" class="difflineplus">+  PRIVATE</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineplus">+    &quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;</span>
<a href="#l8.42"></a><span id="l8.42" class="difflineplus">+    &quot;${PROJECT_SOURCE_DIR}/src&quot;</span>
<a href="#l8.43"></a><span id="l8.43" class="difflineplus">+)</span>
<a href="#l8.44"></a><span id="l8.44" class="difflineplus">+</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineplus">+set_target_properties(rnp-common PROPERTIES</span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+  POSITION_INDEPENDENT_CODE ON</span>
<a href="#l8.47"></a><span id="l8.47" class="difflineplus">+  CXX_VISIBILITY_PRESET hidden</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineplus">+)</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1">new file mode 100644</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineminus">--- /dev/null</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineplus">+++ b/third_party/rnp/src/common/file-utils.cpp</span>
<a href="#l9.4"></a><span id="l9.4" class="difflineat">@@ -0,0 +1,54 @@</span>
<a href="#l9.5"></a><span id="l9.5" class="difflineplus">+/*</span>
<a href="#l9.6"></a><span id="l9.6" class="difflineplus">+ * Copyright (c) 2017 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l9.7"></a><span id="l9.7" class="difflineplus">+ * All rights reserved.</span>
<a href="#l9.8"></a><span id="l9.8" class="difflineplus">+ *</span>
<a href="#l9.9"></a><span id="l9.9" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l9.10"></a><span id="l9.10" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l9.11"></a><span id="l9.11" class="difflineplus">+ *</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l9.14"></a><span id="l9.14" class="difflineplus">+ *</span>
<a href="#l9.15"></a><span id="l9.15" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l9.17"></a><span id="l9.17" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l9.18"></a><span id="l9.18" class="difflineplus">+ *</span>
<a href="#l9.19"></a><span id="l9.19" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineplus">+ */</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineplus">+/** File utilities</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineplus">+ *  @file</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+ */</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineplus">+</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineplus">+#include &quot;file-utils.h&quot;</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineplus">+</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineplus">+extern &quot;C&quot; {</span>
<a href="#l9.37"></a><span id="l9.37" class="difflineplus">+#include &lt;sys/stat.h&gt;</span>
<a href="#l9.38"></a><span id="l9.38" class="difflineplus">+}</span>
<a href="#l9.39"></a><span id="l9.39" class="difflineplus">+</span>
<a href="#l9.40"></a><span id="l9.40" class="difflineplus">+bool</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+rnp_file_exists(const char *path)</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+{</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+    struct stat st;</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+    return stat(path, &amp;st) == 0 &amp;&amp; S_ISREG(st.st_mode);</span>
<a href="#l9.45"></a><span id="l9.45" class="difflineplus">+}</span>
<a href="#l9.46"></a><span id="l9.46" class="difflineplus">+</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineplus">+/* return the file modification time */</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineplus">+int64_t</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineplus">+rnp_filemtime(const char *path)</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+{</span>
<a href="#l9.51"></a><span id="l9.51" class="difflineplus">+    struct stat st;</span>
<a href="#l9.52"></a><span id="l9.52" class="difflineplus">+</span>
<a href="#l9.53"></a><span id="l9.53" class="difflineplus">+    if (stat(path, &amp;st) != 0) {</span>
<a href="#l9.54"></a><span id="l9.54" class="difflineplus">+        return 0;</span>
<a href="#l9.55"></a><span id="l9.55" class="difflineplus">+    } else {</span>
<a href="#l9.56"></a><span id="l9.56" class="difflineplus">+        return st.st_mtime;</span>
<a href="#l9.57"></a><span id="l9.57" class="difflineplus">+    }</span>
<a href="#l9.58"></a><span id="l9.58" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1">new file mode 100644</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineminus">--- /dev/null</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineplus">+++ b/third_party/rnp/src/common/file-utils.h</span>
<a href="#l10.4"></a><span id="l10.4" class="difflineat">@@ -0,0 +1,35 @@</span>
<a href="#l10.5"></a><span id="l10.5" class="difflineplus">+/*</span>
<a href="#l10.6"></a><span id="l10.6" class="difflineplus">+ * Copyright (c) 2019-2020, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l10.7"></a><span id="l10.7" class="difflineplus">+ * All rights reserved.</span>
<a href="#l10.8"></a><span id="l10.8" class="difflineplus">+ *</span>
<a href="#l10.9"></a><span id="l10.9" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l10.10"></a><span id="l10.10" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l10.11"></a><span id="l10.11" class="difflineplus">+ *</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+ *</span>
<a href="#l10.15"></a><span id="l10.15" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l10.16"></a><span id="l10.16" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l10.17"></a><span id="l10.17" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineplus">+ *</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l10.25"></a><span id="l10.25" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l10.29"></a><span id="l10.29" class="difflineplus">+ */</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineplus">+</span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+#ifndef RNP_FILE_UTILS_H_</span>
<a href="#l10.32"></a><span id="l10.32" class="difflineplus">+#define RNP_FILE_UTILS_H_</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineplus">+</span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+#include &lt;stdint.h&gt;</span>
<a href="#l10.35"></a><span id="l10.35" class="difflineplus">+</span>
<a href="#l10.36"></a><span id="l10.36" class="difflineplus">+bool    rnp_file_exists(const char *path);</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineplus">+int64_t rnp_filemtime(const char *path);</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+</span>
<a href="#l10.39"></a><span id="l10.39" class="difflineplus">+#endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1">rename from third_party/rnp/src/lib/list.cpp</span>
<a href="#l11.2"></a><span id="l11.2">rename to third_party/rnp/src/common/list.cpp</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1">rename from third_party/rnp/src/lib/list.h</span>
<a href="#l12.2"></a><span id="l12.2">rename to third_party/rnp/src/common/list.h</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1">new file mode 100644</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineminus">--- /dev/null</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineplus">+++ b/third_party/rnp/src/common/str-utils.cpp</span>
<a href="#l13.4"></a><span id="l13.4" class="difflineat">@@ -0,0 +1,47 @@</span>
<a href="#l13.5"></a><span id="l13.5" class="difflineplus">+/*</span>
<a href="#l13.6"></a><span id="l13.6" class="difflineplus">+ * Copyright (c) 2017 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l13.7"></a><span id="l13.7" class="difflineplus">+ * All rights reserved.</span>
<a href="#l13.8"></a><span id="l13.8" class="difflineplus">+ *</span>
<a href="#l13.9"></a><span id="l13.9" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l13.10"></a><span id="l13.10" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l13.11"></a><span id="l13.11" class="difflineplus">+ *</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+ *</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+ *</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l13.26"></a><span id="l13.26" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l13.29"></a><span id="l13.29" class="difflineplus">+ */</span>
<a href="#l13.30"></a><span id="l13.30" class="difflineplus">+/** String utilities</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineplus">+ *  @file</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+ */</span>
<a href="#l13.33"></a><span id="l13.33" class="difflineplus">+</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineplus">+#include &quot;str-utils.h&quot;</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineplus">+#include &lt;cstddef&gt;</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineplus">+#include &lt;cstring&gt;</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineplus">+</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineplus">+using std::size_t;</span>
<a href="#l13.39"></a><span id="l13.39" class="difflineplus">+using std::strlen;</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineplus">+</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+char *</span>
<a href="#l13.42"></a><span id="l13.42" class="difflineplus">+rnp_strip_eol(char *s)</span>
<a href="#l13.43"></a><span id="l13.43" class="difflineplus">+{</span>
<a href="#l13.44"></a><span id="l13.44" class="difflineplus">+    size_t len = strlen(s);</span>
<a href="#l13.45"></a><span id="l13.45" class="difflineplus">+</span>
<a href="#l13.46"></a><span id="l13.46" class="difflineplus">+    while ((len &gt; 0) &amp;&amp; ((s[len - 1] == '\n') || (s[len - 1] == '\r'))) {</span>
<a href="#l13.47"></a><span id="l13.47" class="difflineplus">+        s[--len] = '\0';</span>
<a href="#l13.48"></a><span id="l13.48" class="difflineplus">+    }</span>
<a href="#l13.49"></a><span id="l13.49" class="difflineplus">+</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineplus">+    return s;</span>
<a href="#l13.51"></a><span id="l13.51" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1">new file mode 100644</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineminus">--- /dev/null</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineplus">+++ b/third_party/rnp/src/common/str-utils.h</span>
<a href="#l14.4"></a><span id="l14.4" class="difflineat">@@ -0,0 +1,32 @@</span>
<a href="#l14.5"></a><span id="l14.5" class="difflineplus">+/*</span>
<a href="#l14.6"></a><span id="l14.6" class="difflineplus">+ * Copyright (c) 2019-2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l14.7"></a><span id="l14.7" class="difflineplus">+ * All rights reserved.</span>
<a href="#l14.8"></a><span id="l14.8" class="difflineplus">+ *</span>
<a href="#l14.9"></a><span id="l14.9" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l14.10"></a><span id="l14.10" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l14.11"></a><span id="l14.11" class="difflineplus">+ *</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+ *</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+ *</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l14.23"></a><span id="l14.23" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+ */</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+#ifndef RNP_STR_UTILS_H_</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+#define RNP_STR_UTILS_H_</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+char *rnp_strip_eol(char *s);</span>
<a href="#l14.35"></a><span id="l14.35" class="difflineplus">+</span>
<a href="#l14.36"></a><span id="l14.36" class="difflineplus">+#endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/third_party/rnp/src/lib/CMakeLists.txt</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/third_party/rnp/src/lib/CMakeLists.txt</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -18,16 +18,17 @@</span>
<a href="#l15.4"></a><span id="l15.4"> # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a href="#l15.5"></a><span id="l15.5"> # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a href="#l15.6"></a><span id="l15.6"> # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l15.7"></a><span id="l15.7"> # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l15.8"></a><span id="l15.8"> # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l15.9"></a><span id="l15.9"> # POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l15.10"></a><span id="l15.10"> </span>
<a href="#l15.11"></a><span id="l15.11"> include(GNUInstallDirs)</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+include(GenerateExportHeader)</span>
<a href="#l15.13"></a><span id="l15.13"> </span>
<a href="#l15.14"></a><span id="l15.14"> # these could probably be optional but are currently not</span>
<a href="#l15.15"></a><span id="l15.15"> find_package(BZip2 REQUIRED)</span>
<a href="#l15.16"></a><span id="l15.16"> find_package(ZLIB REQUIRED)</span>
<a href="#l15.17"></a><span id="l15.17"> </span>
<a href="#l15.18"></a><span id="l15.18"> # required packages</span>
<a href="#l15.19"></a><span id="l15.19"> find_package(JSON-C 0.11 REQUIRED)</span>
<a href="#l15.20"></a><span id="l15.20"> find_package(Botan2 2.8.0 REQUIRED)</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineat">@@ -83,17 +84,17 @@ set(_botan_required_features</span>
<a href="#l15.22"></a><span id="l15.22"> foreach(feature ${_botan_required_features})</span>
<a href="#l15.23"></a><span id="l15.23">   check_cxx_symbol_exists(&quot;BOTAN_HAS_${feature}&quot; botan/build.h _botan_has_${feature})</span>
<a href="#l15.24"></a><span id="l15.24">   if (NOT _botan_has_${feature})</span>
<a href="#l15.25"></a><span id="l15.25">     message(FATAL_ERROR &quot;A required botan feature is missing: ${feature}&quot;)</span>
<a href="#l15.26"></a><span id="l15.26">   endif()</span>
<a href="#l15.27"></a><span id="l15.27"> endforeach()</span>
<a href="#l15.28"></a><span id="l15.28"> set(CMAKE_REQUIRED_INCLUDES)</span>
<a href="#l15.29"></a><span id="l15.29"> </span>
<a href="#l15.30"></a><span id="l15.30" class="difflineminus">-add_library(librnp</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+add_library(librnp-obj OBJECT</span>
<a href="#l15.32"></a><span id="l15.32">   # librepgp</span>
<a href="#l15.33"></a><span id="l15.33">   ../librepgp/stream-armor.cpp</span>
<a href="#l15.34"></a><span id="l15.34">   ../librepgp/stream-common.cpp</span>
<a href="#l15.35"></a><span id="l15.35">   ../librepgp/stream-ctx.cpp</span>
<a href="#l15.36"></a><span id="l15.36">   ../librepgp/stream-dump.cpp</span>
<a href="#l15.37"></a><span id="l15.37">   ../librepgp/stream-key.cpp</span>
<a href="#l15.38"></a><span id="l15.38">   ../librepgp/stream-packet.cpp</span>
<a href="#l15.39"></a><span id="l15.39">   ../librepgp/stream-parse.cpp</span>
<a href="#l15.40"></a><span id="l15.40" class="difflineat">@@ -120,62 +121,88 @@ add_library(librnp</span>
<a href="#l15.41"></a><span id="l15.41">   crypto/s2k.cpp</span>
<a href="#l15.42"></a><span id="l15.42">   crypto/sm2.cpp</span>
<a href="#l15.43"></a><span id="l15.43">   crypto/symmetric.cpp</span>
<a href="#l15.44"></a><span id="l15.44">   crypto/signatures.cpp</span>
<a href="#l15.45"></a><span id="l15.45">   crypto.cpp</span>
<a href="#l15.46"></a><span id="l15.46">   fingerprint.cpp</span>
<a href="#l15.47"></a><span id="l15.47">   generate-key.cpp</span>
<a href="#l15.48"></a><span id="l15.48">   key-provider.cpp</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineminus">-  list.cpp</span>
<a href="#l15.50"></a><span id="l15.50">   misc.cpp</span>
<a href="#l15.51"></a><span id="l15.51">   pass-provider.cpp</span>
<a href="#l15.52"></a><span id="l15.52">   pgp-key.cpp</span>
<a href="#l15.53"></a><span id="l15.53">   rnp.cpp</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineplus">+  $&lt;TARGET_OBJECTS:rnp-common&gt;</span>
<a href="#l15.55"></a><span id="l15.55"> )</span>
<a href="#l15.56"></a><span id="l15.56"> </span>
<a href="#l15.57"></a><span id="l15.57" class="difflineplus">+set_target_properties(librnp-obj PROPERTIES POSITION_INDEPENDENT_CODE ON)</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineplus">+target_include_directories(librnp-obj</span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+  PUBLIC</span>
<a href="#l15.60"></a><span id="l15.60" class="difflineplus">+    &quot;$&lt;BUILD_INTERFACE:${PROJECT_BINARY_DIR}/src/lib&gt;&quot;</span>
<a href="#l15.61"></a><span id="l15.61" class="difflineplus">+    &quot;$&lt;BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/src/common&gt;&quot;</span>
<a href="#l15.62"></a><span id="l15.62" class="difflineplus">+    &quot;$&lt;BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include&gt;&quot;</span>
<a href="#l15.63"></a><span id="l15.63" class="difflineplus">+    &quot;$&lt;INSTALL_INTERFACE:include&gt;&quot;</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+  PRIVATE</span>
<a href="#l15.65"></a><span id="l15.65" class="difflineplus">+    &quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineplus">+    &quot;${PROJECT_SOURCE_DIR}/src&quot;</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+)</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+target_link_libraries(librnp-obj</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineplus">+  PRIVATE</span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+    Botan2::Botan2</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineplus">+    JSON-C::JSON-C</span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+)</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineplus">+set_target_properties(librnp-obj PROPERTIES CXX_VISIBILITY_PRESET hidden)</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineplus">+if (TARGET BZip2::BZip2)</span>
<a href="#l15.75"></a><span id="l15.75" class="difflineplus">+  target_link_libraries(librnp-obj PRIVATE BZip2::BZip2)</span>
<a href="#l15.76"></a><span id="l15.76" class="difflineplus">+endif()</span>
<a href="#l15.77"></a><span id="l15.77" class="difflineplus">+if (TARGET ZLIB::ZLIB)</span>
<a href="#l15.78"></a><span id="l15.78" class="difflineplus">+  target_link_libraries(librnp-obj PRIVATE ZLIB::ZLIB)</span>
<a href="#l15.79"></a><span id="l15.79" class="difflineplus">+endif()</span>
<a href="#l15.80"></a><span id="l15.80" class="difflineplus">+if (BUILD_SHARED_LIBS)</span>
<a href="#l15.81"></a><span id="l15.81" class="difflineplus">+  target_compile_definitions(librnp-obj PRIVATE librnp_EXPORTS)</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineplus">+else()</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+  target_compile_definitions(librnp-obj PRIVATE RNP_STATIC)</span>
<a href="#l15.84"></a><span id="l15.84" class="difflineplus">+endif()</span>
<a href="#l15.85"></a><span id="l15.85" class="difflineplus">+</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineplus">+add_library(librnp $&lt;TARGET_OBJECTS:librnp-obj&gt; $&lt;TARGET_OBJECTS:rnp-common&gt;)</span>
<a href="#l15.87"></a><span id="l15.87"> set_target_properties(librnp</span>
<a href="#l15.88"></a><span id="l15.88">   PROPERTIES</span>
<a href="#l15.89"></a><span id="l15.89">     VERSION &quot;${RNP_VERSION}&quot;</span>
<a href="#l15.90"></a><span id="l15.90">     SOVERSION &quot;${RNP_VERSION_MAJOR}&quot;</span>
<a href="#l15.91"></a><span id="l15.91">     PREFIX &quot;lib&quot;</span>
<a href="#l15.92"></a><span id="l15.92">     OUTPUT_NAME &quot;rnp-${RNP_VERSION_MAJOR}&quot;</span>
<a href="#l15.93"></a><span id="l15.93"> )</span>
<a href="#l15.94"></a><span id="l15.94"> </span>
<a href="#l15.95"></a><span id="l15.95" class="difflineminus">-target_include_directories(librnp</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineminus">-  PUBLIC</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineminus">-    &quot;$&lt;BUILD_INTERFACE:${PROJECT_BINARY_DIR}/src/lib&gt;&quot;</span>
<a href="#l15.98"></a><span id="l15.98" class="difflineminus">-    &quot;$&lt;BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include&gt;&quot;</span>
<a href="#l15.99"></a><span id="l15.99" class="difflineminus">-    &quot;$&lt;INSTALL_INTERFACE:include&gt;&quot;</span>
<a href="#l15.100"></a><span id="l15.100" class="difflineminus">-  PRIVATE</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineminus">-    &quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;</span>
<a href="#l15.102"></a><span id="l15.102" class="difflineminus">-    &quot;${PROJECT_SOURCE_DIR}/src&quot;</span>
<a href="#l15.103"></a><span id="l15.103" class="difflineplus">+if (BUILD_SHARED_LIBS)</span>
<a href="#l15.104"></a><span id="l15.104" class="difflineplus">+  add_library(librnp-static STATIC $&lt;TARGET_OBJECTS:librnp-obj&gt; $&lt;TARGET_OBJECTS:rnp-common&gt;)</span>
<a href="#l15.105"></a><span id="l15.105" class="difflineplus">+else()</span>
<a href="#l15.106"></a><span id="l15.106" class="difflineplus">+  add_library(librnp-static ALIAS librnp)</span>
<a href="#l15.107"></a><span id="l15.107" class="difflineplus">+endif()</span>
<a href="#l15.108"></a><span id="l15.108" class="difflineplus">+</span>
<a href="#l15.109"></a><span id="l15.109" class="difflineplus">+foreach (prop LINK_LIBRARIES INTERFACE_LINK_LIBRARIES INCLUDE_DIRECTORIES INTERFACE_INCLUDE_DIRECTORIES)</span>
<a href="#l15.110"></a><span id="l15.110" class="difflineplus">+  get_target_property(val librnp-obj ${prop})</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineplus">+  set_property(TARGET librnp PROPERTY ${prop} ${val})</span>
<a href="#l15.112"></a><span id="l15.112" class="difflineplus">+  if (BUILD_SHARED_LIBS)</span>
<a href="#l15.113"></a><span id="l15.113" class="difflineplus">+    set_property(TARGET librnp-static PROPERTY ${prop} ${val})</span>
<a href="#l15.114"></a><span id="l15.114" class="difflineplus">+  endif()</span>
<a href="#l15.115"></a><span id="l15.115" class="difflineplus">+endforeach()</span>
<a href="#l15.116"></a><span id="l15.116" class="difflineplus">+</span>
<a href="#l15.117"></a><span id="l15.117" class="difflineplus">+generate_export_header(librnp</span>
<a href="#l15.118"></a><span id="l15.118" class="difflineplus">+  BASE_NAME rnp/rnp</span>
<a href="#l15.119"></a><span id="l15.119" class="difflineplus">+  EXPORT_MACRO_NAME RNP_API</span>
<a href="#l15.120"></a><span id="l15.120" class="difflineplus">+  STATIC_DEFINE RNP_STATIC</span>
<a href="#l15.121"></a><span id="l15.121"> )</span>
<a href="#l15.122"></a><span id="l15.122"> </span>
<a href="#l15.123"></a><span id="l15.123"> # This has precedence and can cause some confusion when the binary</span>
<a href="#l15.124"></a><span id="l15.124"> # dir one isn't actually being used. To be improved.</span>
<a href="#l15.125"></a><span id="l15.125"> if (NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)</span>
<a href="#l15.126"></a><span id="l15.126">   file(REMOVE &quot;${CMAKE_CURRENT_SOURCE_DIR}/config.h&quot;)</span>
<a href="#l15.127"></a><span id="l15.127">   file(REMOVE &quot;${CMAKE_CURRENT_SOURCE_DIR}/version.h&quot;)</span>
<a href="#l15.128"></a><span id="l15.128"> endif()</span>
<a href="#l15.129"></a><span id="l15.129"> </span>
<a href="#l15.130"></a><span id="l15.130" class="difflineminus">-target_link_libraries(librnp</span>
<a href="#l15.131"></a><span id="l15.131" class="difflineminus">-  PRIVATE</span>
<a href="#l15.132"></a><span id="l15.132" class="difflineminus">-    Botan2::Botan2</span>
<a href="#l15.133"></a><span id="l15.133" class="difflineminus">-    JSON-C::JSON-C</span>
<a href="#l15.134"></a><span id="l15.134" class="difflineminus">-)</span>
<a href="#l15.135"></a><span id="l15.135" class="difflineminus">-</span>
<a href="#l15.136"></a><span id="l15.136" class="difflineminus">-if (TARGET BZip2::BZip2)</span>
<a href="#l15.137"></a><span id="l15.137" class="difflineminus">-  target_link_libraries(librnp PRIVATE BZip2::BZip2)</span>
<a href="#l15.138"></a><span id="l15.138" class="difflineminus">-endif()</span>
<a href="#l15.139"></a><span id="l15.139" class="difflineminus">-</span>
<a href="#l15.140"></a><span id="l15.140" class="difflineminus">-if (TARGET ZLIB::ZLIB)</span>
<a href="#l15.141"></a><span id="l15.141" class="difflineminus">-  target_link_libraries(librnp PRIVATE ZLIB::ZLIB)</span>
<a href="#l15.142"></a><span id="l15.142" class="difflineminus">-endif()</span>
<a href="#l15.143"></a><span id="l15.143" class="difflineminus">-</span>
<a href="#l15.144"></a><span id="l15.144"> set(LIBRNP_INCLUDEDIR &quot;rnp-${PROJECT_VERSION_MAJOR}&quot;)</span>
<a href="#l15.145"></a><span id="l15.145"> </span>
<a href="#l15.146"></a><span id="l15.146"> if (${CMAKE_VERSION} VERSION_GREATER_EQUAL &quot;3.12.0&quot;)</span>
<a href="#l15.147"></a><span id="l15.147">   set(namelink_component NAMELINK_COMPONENT development)</span>
<a href="#l15.148"></a><span id="l15.148"> else()</span>
<a href="#l15.149"></a><span id="l15.149">   set(namelink_component)</span>
<a href="#l15.150"></a><span id="l15.150"> endif()</span>
<a href="#l15.151"></a><span id="l15.151"> </span>
<a href="#l15.152"></a><span id="l15.152" class="difflineat">@@ -215,16 +242,26 @@ install(</span>
<a href="#l15.153"></a><span id="l15.153">     &quot;${PROJECT_SOURCE_DIR}/include/rnp/rnp_err.h&quot;</span>
<a href="#l15.154"></a><span id="l15.154">   COMPONENT</span>
<a href="#l15.155"></a><span id="l15.155">     development</span>
<a href="#l15.156"></a><span id="l15.156">   DESTINATION</span>
<a href="#l15.157"></a><span id="l15.157">     &quot;${CMAKE_INSTALL_INCLUDEDIR}/${LIBRNP_INCLUDEDIR}/rnp&quot;</span>
<a href="#l15.158"></a><span id="l15.158">   RENAME</span>
<a href="#l15.159"></a><span id="l15.159">     rnp_err.h</span>
<a href="#l15.160"></a><span id="l15.160"> )</span>
<a href="#l15.161"></a><span id="l15.161" class="difflineplus">+install(</span>
<a href="#l15.162"></a><span id="l15.162" class="difflineplus">+  FILES</span>
<a href="#l15.163"></a><span id="l15.163" class="difflineplus">+    &quot;${PROJECT_BINARY_DIR}/src/lib/rnp/rnp_export.h&quot;</span>
<a href="#l15.164"></a><span id="l15.164" class="difflineplus">+  COMPONENT</span>
<a href="#l15.165"></a><span id="l15.165" class="difflineplus">+    development</span>
<a href="#l15.166"></a><span id="l15.166" class="difflineplus">+  DESTINATION</span>
<a href="#l15.167"></a><span id="l15.167" class="difflineplus">+    &quot;${CMAKE_INSTALL_INCLUDEDIR}/${LIBRNP_INCLUDEDIR}/rnp&quot;</span>
<a href="#l15.168"></a><span id="l15.168" class="difflineplus">+  RENAME</span>
<a href="#l15.169"></a><span id="l15.169" class="difflineplus">+    rnp_export.h</span>
<a href="#l15.170"></a><span id="l15.170" class="difflineplus">+)</span>
<a href="#l15.171"></a><span id="l15.171"> </span>
<a href="#l15.172"></a><span id="l15.172"> # .cmake installs</span>
<a href="#l15.173"></a><span id="l15.173"> set(INSTALL_CMAKEDIR &quot;${CMAKE_INSTALL_LIBDIR}/cmake/rnp&quot;)</span>
<a href="#l15.174"></a><span id="l15.174"> </span>
<a href="#l15.175"></a><span id="l15.175"> install(EXPORT rnp-targets</span>
<a href="#l15.176"></a><span id="l15.176">   FILE rnp-targets.cmake</span>
<a href="#l15.177"></a><span id="l15.177">   NAMESPACE rnp::</span>
<a href="#l15.178"></a><span id="l15.178">   DESTINATION &quot;${INSTALL_CMAKEDIR}&quot;</span>
<a href="#l15.179"></a><span id="l15.179" class="difflineat">@@ -303,9 +340,8 @@ if (PKG_CONFIG_FOUND)</span>
<a href="#l15.180"></a><span id="l15.180">     @ONLY</span>
<a href="#l15.181"></a><span id="l15.181">   )</span>
<a href="#l15.182"></a><span id="l15.182">   install(</span>
<a href="#l15.183"></a><span id="l15.183">     FILES &quot;${PROJECT_BINARY_DIR}/librnp-${PROJECT_VERSION_MAJOR}.pc&quot;</span>
<a href="#l15.184"></a><span id="l15.184">     DESTINATION &quot;${CMAKE_INSTALL_LIBDIR}/pkgconfig&quot;</span>
<a href="#l15.185"></a><span id="l15.185">     COMPONENT development</span>
<a href="#l15.186"></a><span id="l15.186">   )</span>
<a href="#l15.187"></a><span id="l15.187"> endif()</span>
<a href="#l15.188"></a><span id="l15.188" class="difflineminus">-</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/third_party/rnp/src/lib/config.h.in</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/third_party/rnp/src/lib/config.h.in</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -19,17 +19,17 @@</span>
<a href="#l16.4"></a><span id="l16.4">  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a href="#l16.5"></a><span id="l16.5">  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a href="#l16.6"></a><span id="l16.6">  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l16.7"></a><span id="l16.7">  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l16.8"></a><span id="l16.8">  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l16.9"></a><span id="l16.9">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l16.10"></a><span id="l16.10">  */</span>
<a href="#l16.11"></a><span id="l16.11"> </span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">-#define PACKAGE_STRING    &quot;rnp 0.13.1+git20200619.ac070578.MZLA&quot;</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+#define PACKAGE_STRING    &quot;rnp 0.13.1+git20200707.2858ccdc.MZLA&quot;</span>
<a href="#l16.14"></a><span id="l16.14"> #define PACKAGE_BUGREPORT &quot;https://bugzilla.mozilla.org/enter_bug.cgi?product=Thunderbird&quot;</span>
<a href="#l16.15"></a><span id="l16.15"> </span>
<a href="#l16.16"></a><span id="l16.16"> #undef HAVE_BZLIB_H</span>
<a href="#l16.17"></a><span id="l16.17"> #undef HAVE_ZLIB_H</span>
<a href="#l16.18"></a><span id="l16.18"> </span>
<a href="#l16.19"></a><span id="l16.19"> #undef HAVE_FCNTL_H</span>
<a href="#l16.20"></a><span id="l16.20"> #undef HAVE_INTTYPES_H</span>
<a href="#l16.21"></a><span id="l16.21"> #undef HAVE_LIMITS_H</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/ec.h</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/ec.h</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l17.4"></a><span id="l17.4"> /*</span>
<a href="#l17.5"></a><span id="l17.5" class="difflineminus">- * Copyright (c) 2017, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l17.6"></a><span id="l17.6" class="difflineplus">+ * Copyright (c) 2017-2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l17.7"></a><span id="l17.7">  * All rights reserved.</span>
<a href="#l17.8"></a><span id="l17.8">  *</span>
<a href="#l17.9"></a><span id="l17.9">  * This code is originally derived from software contributed to</span>
<a href="#l17.10"></a><span id="l17.10">  * The NetBSD Foundation by Alistair Crooks (agc@netbsd.org), and</span>
<a href="#l17.11"></a><span id="l17.11">  * carried further by Ribose Inc (https://www.ribose.com).</span>
<a href="#l17.12"></a><span id="l17.12">  *</span>
<a href="#l17.13"></a><span id="l17.13">  * Redistribution and use in source and binary forms, with or without</span>
<a href="#l17.14"></a><span id="l17.14">  * modification, are permitted provided that the following conditions</span>
<a href="#l17.15"></a><span id="l17.15" class="difflineat">@@ -30,17 +30,17 @@</span>
<a href="#l17.16"></a><span id="l17.16"> #ifndef EC_H_</span>
<a href="#l17.17"></a><span id="l17.17"> #define EC_H_</span>
<a href="#l17.18"></a><span id="l17.18"> </span>
<a href="#l17.19"></a><span id="l17.19"> #include &lt;rnp/rnp_def.h&gt;</span>
<a href="#l17.20"></a><span id="l17.20"> #include &lt;repgp/repgp_def.h&gt;</span>
<a href="#l17.21"></a><span id="l17.21"> #include &quot;crypto/rng.h&quot;</span>
<a href="#l17.22"></a><span id="l17.22"> #include &quot;crypto/mpi.h&quot;</span>
<a href="#l17.23"></a><span id="l17.23"> </span>
<a href="#l17.24"></a><span id="l17.24" class="difflineminus">-#define DEFAULT_CURVE PGP_CURVE_NIST_P_256</span>
<a href="#l17.25"></a><span id="l17.25" class="difflineplus">+#define DEFAULT_CURVE &quot;NIST P-256&quot;</span>
<a href="#l17.26"></a><span id="l17.26"> #define MAX_CURVE_BIT_SIZE 521 // secp521r1</span>
<a href="#l17.27"></a><span id="l17.27"> /* Maximal byte size of elliptic curve order (NIST P-521) */</span>
<a href="#l17.28"></a><span id="l17.28"> #define MAX_CURVE_BYTELEN ((MAX_CURVE_BIT_SIZE + 7) / 8)</span>
<a href="#l17.29"></a><span id="l17.29"> </span>
<a href="#l17.30"></a><span id="l17.30"> /**</span>
<a href="#l17.31"></a><span id="l17.31">  * Maximal length of the OID in hex representation.</span>
<a href="#l17.32"></a><span id="l17.32">  *</span>
<a href="#l17.33"></a><span id="l17.33">  * \see RFC4880 bis01 - 9.2 ECC Curve OID</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/ecdh.cpp</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/ecdh.cpp</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -60,21 +60,21 @@ static const struct ecdh_params_t {</span>
<a href="#l18.4"></a><span id="l18.4"> static const unsigned char ANONYMOUS_SENDER[] = {0x41, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F,</span>
<a href="#l18.5"></a><span id="l18.5">                                                  0x75, 0x73, 0x20, 0x53, 0x65, 0x6E, 0x64,</span>
<a href="#l18.6"></a><span id="l18.6">                                                  0x65, 0x72, 0x20, 0x20, 0x20, 0x20};</span>
<a href="#l18.7"></a><span id="l18.7"> </span>
<a href="#l18.8"></a><span id="l18.8"> // returns size of data written to other_info</span>
<a href="#l18.9"></a><span id="l18.9"> static size_t</span>
<a href="#l18.10"></a><span id="l18.10"> kdf_other_info_serialize(uint8_t                  other_info[MAX_SP800_56A_OTHER_INFO],</span>
<a href="#l18.11"></a><span id="l18.11">                          const ec_curve_desc_t *  ec_curve,</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-                         const pgp_fingerprint_t *fingerprint,</span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+                         const pgp_fingerprint_t &amp;fingerprint,</span>
<a href="#l18.14"></a><span id="l18.14">                          const pgp_hash_alg_t     kdf_hash,</span>
<a href="#l18.15"></a><span id="l18.15">                          const pgp_symm_alg_t     wrap_alg)</span>
<a href="#l18.16"></a><span id="l18.16"> {</span>
<a href="#l18.17"></a><span id="l18.17" class="difflineminus">-    if (fingerprint-&gt;length &lt; 20) {</span>
<a href="#l18.18"></a><span id="l18.18" class="difflineplus">+    if (fingerprint.length &lt; 20) {</span>
<a href="#l18.19"></a><span id="l18.19">         RNP_LOG(&quot;Implementation error: unexpected fingerprint length&quot;);</span>
<a href="#l18.20"></a><span id="l18.20">         return false;</span>
<a href="#l18.21"></a><span id="l18.21">     }</span>
<a href="#l18.22"></a><span id="l18.22"> </span>
<a href="#l18.23"></a><span id="l18.23">     uint8_t *buf_ptr = &amp;other_info[0];</span>
<a href="#l18.24"></a><span id="l18.24"> </span>
<a href="#l18.25"></a><span id="l18.25">     /* KDF-OtherInfo: AlgorithmID</span>
<a href="#l18.26"></a><span id="l18.26">      *   Current implementation will alwyas use SHA-512 and AES-256 for KEK wrapping</span>
<a href="#l18.27"></a><span id="l18.27" class="difflineat">@@ -95,17 +95,17 @@ kdf_other_info_serialize(uint8_t        </span>
<a href="#l18.28"></a><span id="l18.28">     /* KDF-OtherInfo: PartyUInfo</span>
<a href="#l18.29"></a><span id="l18.29">      *   20 bytes representing &quot;Anonymous Sender &quot;</span>
<a href="#l18.30"></a><span id="l18.30">      */</span>
<a href="#l18.31"></a><span id="l18.31">     memcpy(buf_ptr, ANONYMOUS_SENDER, sizeof(ANONYMOUS_SENDER));</span>
<a href="#l18.32"></a><span id="l18.32"> </span>
<a href="#l18.33"></a><span id="l18.33">     buf_ptr += sizeof(ANONYMOUS_SENDER);</span>
<a href="#l18.34"></a><span id="l18.34"> </span>
<a href="#l18.35"></a><span id="l18.35">     // keep 20, as per spec</span>
<a href="#l18.36"></a><span id="l18.36" class="difflineminus">-    memcpy(buf_ptr, fingerprint-&gt;fingerprint, 20);</span>
<a href="#l18.37"></a><span id="l18.37" class="difflineplus">+    memcpy(buf_ptr, fingerprint.fingerprint, 20);</span>
<a href="#l18.38"></a><span id="l18.38">     return (buf_ptr - other_info) + 20 /*anonymous_sender*/;</span>
<a href="#l18.39"></a><span id="l18.39"> }</span>
<a href="#l18.40"></a><span id="l18.40"> </span>
<a href="#l18.41"></a><span id="l18.41"> static bool</span>
<a href="#l18.42"></a><span id="l18.42"> pad_pkcs7(uint8_t *buf, size_t buf_len, size_t offset)</span>
<a href="#l18.43"></a><span id="l18.43"> {</span>
<a href="#l18.44"></a><span id="l18.44">     if (buf_len &lt;= offset) {</span>
<a href="#l18.45"></a><span id="l18.45">         // Must have at least 1 byte of padding</span>
<a href="#l18.46"></a><span id="l18.46" class="difflineat">@@ -307,27 +307,27 @@ done:</span>
<a href="#l18.47"></a><span id="l18.47"> }</span>
<a href="#l18.48"></a><span id="l18.48"> </span>
<a href="#l18.49"></a><span id="l18.49"> rnp_result_t</span>
<a href="#l18.50"></a><span id="l18.50"> ecdh_encrypt_pkcs5(rng_t *                  rng,</span>
<a href="#l18.51"></a><span id="l18.51">                    pgp_ecdh_encrypted_t *   out,</span>
<a href="#l18.52"></a><span id="l18.52">                    const uint8_t *const     in,</span>
<a href="#l18.53"></a><span id="l18.53">                    size_t                   in_len,</span>
<a href="#l18.54"></a><span id="l18.54">                    const pgp_ec_key_t *     key,</span>
<a href="#l18.55"></a><span id="l18.55" class="difflineminus">-                   const pgp_fingerprint_t *fingerprint)</span>
<a href="#l18.56"></a><span id="l18.56" class="difflineplus">+                   const pgp_fingerprint_t &amp;fingerprint)</span>
<a href="#l18.57"></a><span id="l18.57"> {</span>
<a href="#l18.58"></a><span id="l18.58">     botan_privkey_t eph_prv_key = NULL;</span>
<a href="#l18.59"></a><span id="l18.59">     rnp_result_t    ret = RNP_ERROR_GENERIC;</span>
<a href="#l18.60"></a><span id="l18.60">     uint8_t         other_info[MAX_SP800_56A_OTHER_INFO];</span>
<a href="#l18.61"></a><span id="l18.61">     uint8_t         kek[32] = {0}; // Size of SHA-256 or smaller</span>
<a href="#l18.62"></a><span id="l18.62">     // 'm' is padded to the 8-byte granularity</span>
<a href="#l18.63"></a><span id="l18.63">     uint8_t      m[MAX_SESSION_KEY_SIZE];</span>
<a href="#l18.64"></a><span id="l18.64">     const size_t m_padded_len = ((in_len / 8) + 1) * 8;</span>
<a href="#l18.65"></a><span id="l18.65"> </span>
<a href="#l18.66"></a><span id="l18.66" class="difflineminus">-    if (!key || !fingerprint || !out || !in || (in_len &gt; sizeof(m))) {</span>
<a href="#l18.67"></a><span id="l18.67" class="difflineplus">+    if (!key || !out || !in || (in_len &gt; sizeof(m))) {</span>
<a href="#l18.68"></a><span id="l18.68">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l18.69"></a><span id="l18.69">     }</span>
<a href="#l18.70"></a><span id="l18.70"> </span>
<a href="#l18.71"></a><span id="l18.71">     const ec_curve_desc_t *curve_desc = get_curve_desc(key-&gt;curve);</span>
<a href="#l18.72"></a><span id="l18.72">     if (!curve_desc) {</span>
<a href="#l18.73"></a><span id="l18.73">         RNP_LOG(&quot;unsupported curve&quot;);</span>
<a href="#l18.74"></a><span id="l18.74">         return RNP_ERROR_NOT_SUPPORTED;</span>
<a href="#l18.75"></a><span id="l18.75">     }</span>
<a href="#l18.76"></a><span id="l18.76" class="difflineat">@@ -405,17 +405,17 @@ end:</span>
<a href="#l18.77"></a><span id="l18.77">     return ret;</span>
<a href="#l18.78"></a><span id="l18.78"> }</span>
<a href="#l18.79"></a><span id="l18.79"> </span>
<a href="#l18.80"></a><span id="l18.80"> rnp_result_t</span>
<a href="#l18.81"></a><span id="l18.81"> ecdh_decrypt_pkcs5(uint8_t *                   out,</span>
<a href="#l18.82"></a><span id="l18.82">                    size_t *                    out_len,</span>
<a href="#l18.83"></a><span id="l18.83">                    const pgp_ecdh_encrypted_t *in,</span>
<a href="#l18.84"></a><span id="l18.84">                    const pgp_ec_key_t *        key,</span>
<a href="#l18.85"></a><span id="l18.85" class="difflineminus">-                   const pgp_fingerprint_t *   fingerprint)</span>
<a href="#l18.86"></a><span id="l18.86" class="difflineplus">+                   const pgp_fingerprint_t &amp;   fingerprint)</span>
<a href="#l18.87"></a><span id="l18.87"> {</span>
<a href="#l18.88"></a><span id="l18.88">     rnp_result_t ret = RNP_ERROR_GENERIC;</span>
<a href="#l18.89"></a><span id="l18.89">     // Size of SHA-256 or smaller</span>
<a href="#l18.90"></a><span id="l18.90">     uint8_t         kek[MAX_SYMM_KEY_SIZE];</span>
<a href="#l18.91"></a><span id="l18.91">     uint8_t         other_info[MAX_SP800_56A_OTHER_INFO];</span>
<a href="#l18.92"></a><span id="l18.92">     botan_privkey_t prv_key = NULL;</span>
<a href="#l18.93"></a><span id="l18.93">     uint8_t         deckey[MAX_SESSION_KEY_SIZE] = {0};</span>
<a href="#l18.94"></a><span id="l18.94">     size_t          deckey_len = sizeof(deckey);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/ecdh.h</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/ecdh.h</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -81,17 +81,17 @@ bool ecdh_set_params(pgp_ec_key_t *key, </span>
<a href="#l19.4"></a><span id="l19.4">  * @return RNP_ERROR_SHORT_BUFFER `wrapped_key_len' to small to store result</span>
<a href="#l19.5"></a><span id="l19.5">  * @return RNP_ERROR_GENERIC implementation error</span>
<a href="#l19.6"></a><span id="l19.6">  */</span>
<a href="#l19.7"></a><span id="l19.7"> rnp_result_t ecdh_encrypt_pkcs5(rng_t *                  rng,</span>
<a href="#l19.8"></a><span id="l19.8">                                 pgp_ecdh_encrypted_t *   out,</span>
<a href="#l19.9"></a><span id="l19.9">                                 const uint8_t *const     in,</span>
<a href="#l19.10"></a><span id="l19.10">                                 size_t                   in_len,</span>
<a href="#l19.11"></a><span id="l19.11">                                 const pgp_ec_key_t *     key,</span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-                                const pgp_fingerprint_t *fingerprint);</span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+                                const pgp_fingerprint_t &amp;fingerprint);</span>
<a href="#l19.14"></a><span id="l19.14"> </span>
<a href="#l19.15"></a><span id="l19.15"> /*</span>
<a href="#l19.16"></a><span id="l19.16">  * Decrypts session key with a KEK agreed during ECDH as specified in</span>
<a href="#l19.17"></a><span id="l19.17">  * RFC 4880 bis 01, 13.5</span>
<a href="#l19.18"></a><span id="l19.18">  *</span>
<a href="#l19.19"></a><span id="l19.19">  * @param session_key [out] resulting session key</span>
<a href="#l19.20"></a><span id="l19.20">  * @param session_key_len [out] length of the resulting session key</span>
<a href="#l19.21"></a><span id="l19.21">  * @param wrapped_key session key wrapped with some AES as specified</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineat">@@ -107,11 +107,11 @@ rnp_result_t ecdh_encrypt_pkcs5(rng_t * </span>
<a href="#l19.23"></a><span id="l19.23">  * @return RNP_ERROR_BAD_PARAMETERS unexpected input provided</span>
<a href="#l19.24"></a><span id="l19.24">  * @return RNP_ERROR_SHORT_BUFFER `session_key_len' to small to store result</span>
<a href="#l19.25"></a><span id="l19.25">  * @return RNP_ERROR_GENERIC decryption failed or implementation error</span>
<a href="#l19.26"></a><span id="l19.26">  */</span>
<a href="#l19.27"></a><span id="l19.27"> rnp_result_t ecdh_decrypt_pkcs5(uint8_t *                   out,</span>
<a href="#l19.28"></a><span id="l19.28">                                 size_t *                    out_len,</span>
<a href="#l19.29"></a><span id="l19.29">                                 const pgp_ecdh_encrypted_t *in,</span>
<a href="#l19.30"></a><span id="l19.30">                                 const pgp_ec_key_t *        key,</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineminus">-                                const pgp_fingerprint_t *   fingerprint);</span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+                                const pgp_fingerprint_t &amp;   fingerprint);</span>
<a href="#l19.33"></a><span id="l19.33"> </span>
<a href="#l19.34"></a><span id="l19.34"> #endif // ECDH_H_</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/hash.cpp</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/hash.cpp</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -297,62 +297,53 @@ size_t</span>
<a href="#l20.4"></a><span id="l20.4"> pgp_digest_length(pgp_hash_alg_t alg)</span>
<a href="#l20.5"></a><span id="l20.5"> {</span>
<a href="#l20.6"></a><span id="l20.6">     size_t val = 0;</span>
<a href="#l20.7"></a><span id="l20.7">     ARRAY_LOOKUP_BY_ID(hash_alg_map, type, digest_size, alg, val);</span>
<a href="#l20.8"></a><span id="l20.8">     return val;</span>
<a href="#l20.9"></a><span id="l20.9"> }</span>
<a href="#l20.10"></a><span id="l20.10"> </span>
<a href="#l20.11"></a><span id="l20.11"> bool</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-pgp_hash_list_add(list *hashes, pgp_hash_alg_t alg)</span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+pgp_hash_list_add(std::vector&lt;pgp_hash_t&gt; &amp;hashes, pgp_hash_alg_t alg)</span>
<a href="#l20.14"></a><span id="l20.14"> {</span>
<a href="#l20.15"></a><span id="l20.15">     pgp_hash_t hash = {0};</span>
<a href="#l20.16"></a><span id="l20.16" class="difflineminus">-</span>
<a href="#l20.17"></a><span id="l20.17" class="difflineminus">-    if (!pgp_hash_list_get(*hashes, alg)) {</span>
<a href="#l20.18"></a><span id="l20.18" class="difflineplus">+    if (!pgp_hash_list_get(hashes, alg)) {</span>
<a href="#l20.19"></a><span id="l20.19">         if (!pgp_hash_create(&amp;hash, alg)) {</span>
<a href="#l20.20"></a><span id="l20.20">             RNP_LOG(&quot;failed to initialize hash algorithm %d&quot;, (int) alg);</span>
<a href="#l20.21"></a><span id="l20.21">             return false;</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineminus">-        } else if (!list_append(hashes, &amp;hash, sizeof(hash))) {</span>
<a href="#l20.23"></a><span id="l20.23" class="difflineplus">+        }</span>
<a href="#l20.24"></a><span id="l20.24" class="difflineplus">+        try {</span>
<a href="#l20.25"></a><span id="l20.25" class="difflineplus">+            hashes.push_back(hash);</span>
<a href="#l20.26"></a><span id="l20.26" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l20.27"></a><span id="l20.27" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l20.28"></a><span id="l20.28">             pgp_hash_finish(&amp;hash, NULL);</span>
<a href="#l20.29"></a><span id="l20.29" class="difflineminus">-            RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l20.30"></a><span id="l20.30">             return false;</span>
<a href="#l20.31"></a><span id="l20.31">         }</span>
<a href="#l20.32"></a><span id="l20.32">     }</span>
<a href="#l20.33"></a><span id="l20.33" class="difflineminus">-</span>
<a href="#l20.34"></a><span id="l20.34">     return true;</span>
<a href="#l20.35"></a><span id="l20.35"> }</span>
<a href="#l20.36"></a><span id="l20.36"> </span>
<a href="#l20.37"></a><span id="l20.37"> const pgp_hash_t *</span>
<a href="#l20.38"></a><span id="l20.38" class="difflineminus">-pgp_hash_list_get(list hashes, pgp_hash_alg_t alg)</span>
<a href="#l20.39"></a><span id="l20.39" class="difflineplus">+pgp_hash_list_get(std::vector&lt;pgp_hash_t&gt; &amp;hashes, pgp_hash_alg_t alg)</span>
<a href="#l20.40"></a><span id="l20.40"> {</span>
<a href="#l20.41"></a><span id="l20.41" class="difflineminus">-    for (list_item *hash = list_front(hashes); hash; hash = list_next(hash)) {</span>
<a href="#l20.42"></a><span id="l20.42" class="difflineminus">-        if (pgp_hash_alg_type((pgp_hash_t *) hash) == alg) {</span>
<a href="#l20.43"></a><span id="l20.43" class="difflineminus">-            return (pgp_hash_t *) hash;</span>
<a href="#l20.44"></a><span id="l20.44" class="difflineplus">+    for (auto &amp;hash : hashes) {</span>
<a href="#l20.45"></a><span id="l20.45" class="difflineplus">+        if (pgp_hash_alg_type(&amp;hash) == alg) {</span>
<a href="#l20.46"></a><span id="l20.46" class="difflineplus">+            return &amp;hash;</span>
<a href="#l20.47"></a><span id="l20.47">         }</span>
<a href="#l20.48"></a><span id="l20.48">     }</span>
<a href="#l20.49"></a><span id="l20.49" class="difflineminus">-</span>
<a href="#l20.50"></a><span id="l20.50">     return NULL;</span>
<a href="#l20.51"></a><span id="l20.51"> }</span>
<a href="#l20.52"></a><span id="l20.52"> </span>
<a href="#l20.53"></a><span id="l20.53"> void</span>
<a href="#l20.54"></a><span id="l20.54" class="difflineminus">-pgp_hash_list_update(list hashes, const void *buf, size_t len)</span>
<a href="#l20.55"></a><span id="l20.55" class="difflineplus">+pgp_hash_list_update(std::vector&lt;pgp_hash_t&gt; &amp;hashes, const void *buf, size_t len)</span>
<a href="#l20.56"></a><span id="l20.56"> {</span>
<a href="#l20.57"></a><span id="l20.57" class="difflineminus">-    for (list_item *hash = list_front(hashes); hash; hash = list_next(hash)) {</span>
<a href="#l20.58"></a><span id="l20.58" class="difflineminus">-        pgp_hash_add((pgp_hash_t *) hash, buf, len);</span>
<a href="#l20.59"></a><span id="l20.59" class="difflineplus">+    for (auto &amp;hash : hashes) {</span>
<a href="#l20.60"></a><span id="l20.60" class="difflineplus">+        pgp_hash_add(&amp;hash, buf, len);</span>
<a href="#l20.61"></a><span id="l20.61">     }</span>
<a href="#l20.62"></a><span id="l20.62"> }</span>
<a href="#l20.63"></a><span id="l20.63"> </span>
<a href="#l20.64"></a><span id="l20.64" class="difflineminus">-void</span>
<a href="#l20.65"></a><span id="l20.65" class="difflineminus">-pgp_hash_list_free(list *hashes)</span>
<a href="#l20.66"></a><span id="l20.66" class="difflineminus">-{</span>
<a href="#l20.67"></a><span id="l20.67" class="difflineminus">-    for (list_item *hash = list_front(*hashes); hash; hash = list_next(hash)) {</span>
<a href="#l20.68"></a><span id="l20.68" class="difflineminus">-        pgp_hash_finish((pgp_hash_t *) hash, NULL);</span>
<a href="#l20.69"></a><span id="l20.69" class="difflineminus">-    }</span>
<a href="#l20.70"></a><span id="l20.70" class="difflineminus">-    list_destroy(hashes);</span>
<a href="#l20.71"></a><span id="l20.71" class="difflineminus">-}</span>
<a href="#l20.72"></a><span id="l20.72" class="difflineminus">-</span>
<a href="#l20.73"></a><span id="l20.73"> bool</span>
<a href="#l20.74"></a><span id="l20.74"> pgp_hash_uint32(pgp_hash_t *hash, uint32_t n)</span>
<a href="#l20.75"></a><span id="l20.75"> {</span>
<a href="#l20.76"></a><span id="l20.76">     uint8_t ibuf[4];</span>
<a href="#l20.77"></a><span id="l20.77">     STORE32BE(ibuf, n);</span>
<a href="#l20.78"></a><span id="l20.78">     return !pgp_hash_add(hash, ibuf, sizeof(ibuf));</span>
<a href="#l20.79"></a><span id="l20.79"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/hash.h</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/hash.h</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -81,41 +81,35 @@ size_t pgp_digest_length(pgp_hash_alg_t </span>
<a href="#l21.4"></a><span id="l21.4">  *</span>
<a href="#l21.5"></a><span id="l21.5">  * @param hashes non-NULL pointer to the list structure</span>
<a href="#l21.6"></a><span id="l21.6">  * @param alg hash algorithm</span>
<a href="#l21.7"></a><span id="l21.7">  *</span>
<a href="#l21.8"></a><span id="l21.8">  * @return true if hash was added successfully or already exists in the list.</span>
<a href="#l21.9"></a><span id="l21.9">  *         false will be returned if memory allocation failed, or alg is not supported, or</span>
<a href="#l21.10"></a><span id="l21.10">  *         on other error</span>
<a href="#l21.11"></a><span id="l21.11">  **/</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-bool pgp_hash_list_add(list *hashes, pgp_hash_alg_t alg);</span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+bool pgp_hash_list_add(std::vector&lt;pgp_hash_t&gt; &amp;hashes, pgp_hash_alg_t alg);</span>
<a href="#l21.14"></a><span id="l21.14"> </span>
<a href="#l21.15"></a><span id="l21.15"> /* @brief Get hash structure for the corresponding algorithm</span>
<a href="#l21.16"></a><span id="l21.16">  *</span>
<a href="#l21.17"></a><span id="l21.17">  * @param hashes List of pgp_hash_t structures</span>
<a href="#l21.18"></a><span id="l21.18">  * @param alg Hash algorithm</span>
<a href="#l21.19"></a><span id="l21.19">  *</span>
<a href="#l21.20"></a><span id="l21.20">  * @return pointer to the pgp_hash_t structure or NULL if list doesn't contain alg</span>
<a href="#l21.21"></a><span id="l21.21">  **/</span>
<a href="#l21.22"></a><span id="l21.22" class="difflineminus">-const pgp_hash_t *pgp_hash_list_get(list hashes, pgp_hash_alg_t alg);</span>
<a href="#l21.23"></a><span id="l21.23" class="difflineplus">+const pgp_hash_t *pgp_hash_list_get(std::vector&lt;pgp_hash_t&gt; &amp;hashes, pgp_hash_alg_t alg);</span>
<a href="#l21.24"></a><span id="l21.24"> </span>
<a href="#l21.25"></a><span id="l21.25"> /*</span>
<a href="#l21.26"></a><span id="l21.26">  * @brief Update list of hashes with the data</span>
<a href="#l21.27"></a><span id="l21.27">  *</span>
<a href="#l21.28"></a><span id="l21.28">  * @param hashes List of pgp_hash_t structures</span>
<a href="#l21.29"></a><span id="l21.29">  * @param buf buffer with data</span>
<a href="#l21.30"></a><span id="l21.30">  * @param len number of bytes in the buffer</span>
<a href="#l21.31"></a><span id="l21.31">  **/</span>
<a href="#l21.32"></a><span id="l21.32" class="difflineminus">-void pgp_hash_list_update(list hashes, const void *buf, size_t len);</span>
<a href="#l21.33"></a><span id="l21.33" class="difflineminus">-</span>
<a href="#l21.34"></a><span id="l21.34" class="difflineminus">-/* @brief Free the list of hashes and deallocate all internal structures</span>
<a href="#l21.35"></a><span id="l21.35" class="difflineminus">- *</span>
<a href="#l21.36"></a><span id="l21.36" class="difflineminus">- * @param hashes List of pgp_hash_t structures</span>
<a href="#l21.37"></a><span id="l21.37" class="difflineminus">- **/</span>
<a href="#l21.38"></a><span id="l21.38" class="difflineminus">-void pgp_hash_list_free(list *hashes);</span>
<a href="#l21.39"></a><span id="l21.39" class="difflineplus">+void pgp_hash_list_update(std::vector&lt;pgp_hash_t&gt; &amp;hashes, const void *buf, size_t len);</span>
<a href="#l21.40"></a><span id="l21.40"> </span>
<a href="#l21.41"></a><span id="l21.41"> /*</span>
<a href="#l21.42"></a><span id="l21.42">  * @brief Hashes 4 bytes stored as big endian</span>
<a href="#l21.43"></a><span id="l21.43">  *</span>
<a href="#l21.44"></a><span id="l21.44">  * @param hash Initialized hash ctx</span>
<a href="#l21.45"></a><span id="l21.45">  * @param val value to hash</span>
<a href="#l21.46"></a><span id="l21.46">  *</span>
<a href="#l21.47"></a><span id="l21.47">  * @returns true if operation succeeded, otherwise false</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/third_party/rnp/src/lib/fingerprint.cpp</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/third_party/rnp/src/lib/fingerprint.cpp</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -33,82 +33,87 @@</span>
<a href="#l22.4"></a><span id="l22.4"> #include &quot;fingerprint.h&quot;</span>
<a href="#l22.5"></a><span id="l22.5"> #include &quot;crypto/hash.h&quot;</span>
<a href="#l22.6"></a><span id="l22.6"> #include &lt;librepgp/stream-key.h&gt;</span>
<a href="#l22.7"></a><span id="l22.7"> #include &lt;librepgp/stream-sig.h&gt;</span>
<a href="#l22.8"></a><span id="l22.8"> #include &lt;librepgp/stream-packet.h&gt;</span>
<a href="#l22.9"></a><span id="l22.9"> #include &quot;utils.h&quot;</span>
<a href="#l22.10"></a><span id="l22.10"> </span>
<a href="#l22.11"></a><span id="l22.11"> rnp_result_t</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">-pgp_fingerprint(pgp_fingerprint_t *fp, const pgp_key_pkt_t *key)</span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+pgp_fingerprint(pgp_fingerprint_t &amp;fp, const pgp_key_pkt_t *key)</span>
<a href="#l22.14"></a><span id="l22.14"> {</span>
<a href="#l22.15"></a><span id="l22.15">     pgp_hash_t hash = {0};</span>
<a href="#l22.16"></a><span id="l22.16"> </span>
<a href="#l22.17"></a><span id="l22.17">     if ((key-&gt;version == PGP_V2) || (key-&gt;version == PGP_V3)) {</span>
<a href="#l22.18"></a><span id="l22.18">         if (!is_rsa_key_alg(key-&gt;alg)) {</span>
<a href="#l22.19"></a><span id="l22.19">             RNP_LOG(&quot;bad algorithm&quot;);</span>
<a href="#l22.20"></a><span id="l22.20">             return RNP_ERROR_NOT_SUPPORTED;</span>
<a href="#l22.21"></a><span id="l22.21">         }</span>
<a href="#l22.22"></a><span id="l22.22">         if (!pgp_hash_create(&amp;hash, PGP_HASH_MD5)) {</span>
<a href="#l22.23"></a><span id="l22.23">             RNP_LOG(&quot;bad md5 alloc&quot;);</span>
<a href="#l22.24"></a><span id="l22.24">             return RNP_ERROR_NOT_SUPPORTED;</span>
<a href="#l22.25"></a><span id="l22.25">         }</span>
<a href="#l22.26"></a><span id="l22.26">         (void) mpi_hash(&amp;key-&gt;material.rsa.n, &amp;hash);</span>
<a href="#l22.27"></a><span id="l22.27">         (void) mpi_hash(&amp;key-&gt;material.rsa.e, &amp;hash);</span>
<a href="#l22.28"></a><span id="l22.28" class="difflineminus">-        fp-&gt;length = pgp_hash_finish(&amp;hash, fp-&gt;fingerprint);</span>
<a href="#l22.29"></a><span id="l22.29" class="difflineminus">-        RNP_DHEX(&quot;v2/v3 fingerprint&quot;, fp-&gt;fingerprint, fp-&gt;length);</span>
<a href="#l22.30"></a><span id="l22.30" class="difflineplus">+        fp.length = pgp_hash_finish(&amp;hash, fp.fingerprint);</span>
<a href="#l22.31"></a><span id="l22.31" class="difflineplus">+        RNP_DHEX(&quot;v2/v3 fingerprint&quot;, fp.fingerprint, fp.length);</span>
<a href="#l22.32"></a><span id="l22.32">         return RNP_SUCCESS;</span>
<a href="#l22.33"></a><span id="l22.33">     }</span>
<a href="#l22.34"></a><span id="l22.34"> </span>
<a href="#l22.35"></a><span id="l22.35">     if (key-&gt;version == PGP_V4) {</span>
<a href="#l22.36"></a><span id="l22.36">         if (!pgp_hash_create(&amp;hash, PGP_HASH_SHA1)) {</span>
<a href="#l22.37"></a><span id="l22.37">             RNP_LOG(&quot;bad sha1 alloc&quot;);</span>
<a href="#l22.38"></a><span id="l22.38">             return RNP_ERROR_NOT_SUPPORTED;</span>
<a href="#l22.39"></a><span id="l22.39">         }</span>
<a href="#l22.40"></a><span id="l22.40">         if (!signature_hash_key(key, &amp;hash)) {</span>
<a href="#l22.41"></a><span id="l22.41">             return RNP_ERROR_GENERIC;</span>
<a href="#l22.42"></a><span id="l22.42">         }</span>
<a href="#l22.43"></a><span id="l22.43" class="difflineminus">-        fp-&gt;length = pgp_hash_finish(&amp;hash, fp-&gt;fingerprint);</span>
<a href="#l22.44"></a><span id="l22.44" class="difflineminus">-        RNP_DHEX(&quot;sha1 fingerprint&quot;, fp-&gt;fingerprint, fp-&gt;length);</span>
<a href="#l22.45"></a><span id="l22.45" class="difflineplus">+        fp.length = pgp_hash_finish(&amp;hash, fp.fingerprint);</span>
<a href="#l22.46"></a><span id="l22.46" class="difflineplus">+        RNP_DHEX(&quot;sha1 fingerprint&quot;, fp.fingerprint, fp.length);</span>
<a href="#l22.47"></a><span id="l22.47">         return RNP_SUCCESS;</span>
<a href="#l22.48"></a><span id="l22.48">     }</span>
<a href="#l22.49"></a><span id="l22.49"> </span>
<a href="#l22.50"></a><span id="l22.50">     RNP_LOG(&quot;unsupported key version&quot;);</span>
<a href="#l22.51"></a><span id="l22.51">     return RNP_ERROR_NOT_SUPPORTED;</span>
<a href="#l22.52"></a><span id="l22.52"> }</span>
<a href="#l22.53"></a><span id="l22.53"> </span>
<a href="#l22.54"></a><span id="l22.54"> /**</span>
<a href="#l22.55"></a><span id="l22.55">  * \ingroup Core_Keys</span>
<a href="#l22.56"></a><span id="l22.56">  * \brief Calculate the Key ID from the public key.</span>
<a href="#l22.57"></a><span id="l22.57">  * \param keyid Space for the calculated ID to be stored</span>
<a href="#l22.58"></a><span id="l22.58">  * \param key The key for which the ID is calculated</span>
<a href="#l22.59"></a><span id="l22.59">  */</span>
<a href="#l22.60"></a><span id="l22.60"> </span>
<a href="#l22.61"></a><span id="l22.61"> rnp_result_t</span>
<a href="#l22.62"></a><span id="l22.62" class="difflineminus">-pgp_keyid(uint8_t *keyid, const size_t idlen, const pgp_key_pkt_t *key)</span>
<a href="#l22.63"></a><span id="l22.63" class="difflineplus">+pgp_keyid(pgp_key_id_t &amp;keyid, const pgp_key_pkt_t *key)</span>
<a href="#l22.64"></a><span id="l22.64"> {</span>
<a href="#l22.65"></a><span id="l22.65">     pgp_fingerprint_t fp;</span>
<a href="#l22.66"></a><span id="l22.66">     rnp_result_t      ret;</span>
<a href="#l22.67"></a><span id="l22.67">     size_t            n;</span>
<a href="#l22.68"></a><span id="l22.68"> </span>
<a href="#l22.69"></a><span id="l22.69">     if ((key-&gt;version == PGP_V2) || (key-&gt;version == PGP_V3)) {</span>
<a href="#l22.70"></a><span id="l22.70">         if (!is_rsa_key_alg(key-&gt;alg)) {</span>
<a href="#l22.71"></a><span id="l22.71">             RNP_LOG(&quot;bad algorithm&quot;);</span>
<a href="#l22.72"></a><span id="l22.72">             return RNP_ERROR_NOT_SUPPORTED;</span>
<a href="#l22.73"></a><span id="l22.73">         }</span>
<a href="#l22.74"></a><span id="l22.74">         n = mpi_bytes(&amp;key-&gt;material.rsa.n);</span>
<a href="#l22.75"></a><span id="l22.75" class="difflineminus">-        (void) memcpy(keyid, key-&gt;material.rsa.n.mpi + n - idlen, idlen);</span>
<a href="#l22.76"></a><span id="l22.76" class="difflineplus">+        (void) memcpy(keyid.data(), key-&gt;material.rsa.n.mpi + n - keyid.size(), keyid.size());</span>
<a href="#l22.77"></a><span id="l22.77">         return RNP_SUCCESS;</span>
<a href="#l22.78"></a><span id="l22.78">     }</span>
<a href="#l22.79"></a><span id="l22.79"> </span>
<a href="#l22.80"></a><span id="l22.80" class="difflineminus">-    if ((ret = pgp_fingerprint(&amp;fp, key))) {</span>
<a href="#l22.81"></a><span id="l22.81" class="difflineplus">+    if ((ret = pgp_fingerprint(fp, key))) {</span>
<a href="#l22.82"></a><span id="l22.82">         return ret;</span>
<a href="#l22.83"></a><span id="l22.83">     }</span>
<a href="#l22.84"></a><span id="l22.84" class="difflineminus">-    (void) memcpy(keyid, fp.fingerprint + fp.length - idlen, idlen);</span>
<a href="#l22.85"></a><span id="l22.85" class="difflineplus">+    (void) memcpy(keyid.data(), fp.fingerprint + fp.length - keyid.size(), keyid.size());</span>
<a href="#l22.86"></a><span id="l22.86">     return RNP_SUCCESS;</span>
<a href="#l22.87"></a><span id="l22.87"> }</span>
<a href="#l22.88"></a><span id="l22.88"> </span>
<a href="#l22.89"></a><span id="l22.89"> bool</span>
<a href="#l22.90"></a><span id="l22.90" class="difflineminus">-fingerprint_equal(const pgp_fingerprint_t *fp1, const pgp_fingerprint_t *fp2)</span>
<a href="#l22.91"></a><span id="l22.91" class="difflineplus">+pgp_fingerprint_t::operator==(const pgp_fingerprint_t &amp;src) const</span>
<a href="#l22.92"></a><span id="l22.92"> {</span>
<a href="#l22.93"></a><span id="l22.93" class="difflineminus">-    return (fp1-&gt;length == fp2-&gt;length) &amp;&amp;</span>
<a href="#l22.94"></a><span id="l22.94" class="difflineminus">-           (!memcmp(fp1-&gt;fingerprint, fp2-&gt;fingerprint, fp1-&gt;length));</span>
<a href="#l22.95"></a><span id="l22.95" class="difflineplus">+    return (length == src.length) &amp;&amp; !memcmp(fingerprint, src.fingerprint, length);</span>
<a href="#l22.96"></a><span id="l22.96"> }</span>
<a href="#l22.97"></a><span id="l22.97" class="difflineplus">+</span>
<a href="#l22.98"></a><span id="l22.98" class="difflineplus">+bool</span>
<a href="#l22.99"></a><span id="l22.99" class="difflineplus">+pgp_fingerprint_t::operator!=(const pgp_fingerprint_t &amp;src) const</span>
<a href="#l22.100"></a><span id="l22.100" class="difflineplus">+{</span>
<a href="#l22.101"></a><span id="l22.101" class="difflineplus">+    return !(*this == src);</span>
<a href="#l22.102"></a><span id="l22.102" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/third_party/rnp/src/lib/fingerprint.h</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/third_party/rnp/src/lib/fingerprint.h</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -25,19 +25,15 @@</span>
<a href="#l23.4"></a><span id="l23.4">  */</span>
<a href="#l23.5"></a><span id="l23.5"> </span>
<a href="#l23.6"></a><span id="l23.6"> #ifndef RNP_FINGERPRINT_H_</span>
<a href="#l23.7"></a><span id="l23.7"> #define RNP_FINGERPRINT_H_</span>
<a href="#l23.8"></a><span id="l23.8"> </span>
<a href="#l23.9"></a><span id="l23.9"> #include &lt;rnp/rnp_def.h&gt;</span>
<a href="#l23.10"></a><span id="l23.10"> #include &lt;stdint.h&gt;</span>
<a href="#l23.11"></a><span id="l23.11"> #include &lt;stdlib.h&gt;</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineminus">-typedef struct pgp_fingerprint_t pgp_fingerprint_t;</span>
<a href="#l23.14"></a><span id="l23.14" class="difflineminus">-typedef struct pgp_key_pkt_t     pgp_key_pkt_t;</span>
<a href="#l23.15"></a><span id="l23.15" class="difflineplus">+#include &quot;types.h&quot;</span>
<a href="#l23.16"></a><span id="l23.16"> </span>
<a href="#l23.17"></a><span id="l23.17" class="difflineminus">-rnp_result_t pgp_fingerprint(pgp_fingerprint_t *fp, const pgp_key_pkt_t *key);</span>
<a href="#l23.18"></a><span id="l23.18" class="difflineplus">+rnp_result_t pgp_fingerprint(pgp_fingerprint_t &amp;fp, const pgp_key_pkt_t *key);</span>
<a href="#l23.19"></a><span id="l23.19"> </span>
<a href="#l23.20"></a><span id="l23.20" class="difflineminus">-rnp_result_t pgp_keyid(uint8_t *out, const size_t len, const pgp_key_pkt_t *key);</span>
<a href="#l23.21"></a><span id="l23.21" class="difflineminus">-</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineminus">-bool fingerprint_equal(const pgp_fingerprint_t *fp1, const pgp_fingerprint_t *fp2);</span>
<a href="#l23.23"></a><span id="l23.23" class="difflineplus">+rnp_result_t pgp_keyid(pgp_key_id_t &amp;keyid, const pgp_key_pkt_t *key);</span>
<a href="#l23.24"></a><span id="l23.24"> </span>
<a href="#l23.25"></a><span id="l23.25"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/third_party/rnp/src/lib/key-provider.cpp</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/third_party/rnp/src/lib/key-provider.cpp</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -36,19 +36,19 @@</span>
<a href="#l24.4"></a><span id="l24.4"> bool</span>
<a href="#l24.5"></a><span id="l24.5"> rnp_key_matches_search(const pgp_key_t *key, const pgp_key_search_t *search)</span>
<a href="#l24.6"></a><span id="l24.6"> {</span>
<a href="#l24.7"></a><span id="l24.7">     if (!key) {</span>
<a href="#l24.8"></a><span id="l24.8">         return false;</span>
<a href="#l24.9"></a><span id="l24.9">     }</span>
<a href="#l24.10"></a><span id="l24.10">     switch (search-&gt;type) {</span>
<a href="#l24.11"></a><span id="l24.11">     case PGP_KEY_SEARCH_KEYID:</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-        return memcmp(pgp_key_get_keyid(key), search-&gt;by.keyid, PGP_KEY_ID_SIZE) == 0;</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+        return pgp_key_get_keyid(key) == search-&gt;by.keyid;</span>
<a href="#l24.14"></a><span id="l24.14">     case PGP_KEY_SEARCH_FINGERPRINT:</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineminus">-        return fingerprint_equal(pgp_key_get_fp(key), &amp;search-&gt;by.fingerprint);</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+        return pgp_key_get_fp(key) == search-&gt;by.fingerprint;</span>
<a href="#l24.17"></a><span id="l24.17">     case PGP_KEY_SEARCH_GRIP:</span>
<a href="#l24.18"></a><span id="l24.18">         return pgp_key_get_grip(key) == search-&gt;by.grip;</span>
<a href="#l24.19"></a><span id="l24.19">     case PGP_KEY_SEARCH_USERID:</span>
<a href="#l24.20"></a><span id="l24.20">         if (pgp_key_has_userid(key, search-&gt;by.userid)) {</span>
<a href="#l24.21"></a><span id="l24.21">             return true;</span>
<a href="#l24.22"></a><span id="l24.22">         }</span>
<a href="#l24.23"></a><span id="l24.23">         break;</span>
<a href="#l24.24"></a><span id="l24.24">     default:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/third_party/rnp/src/lib/key-provider.h</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/third_party/rnp/src/lib/key-provider.h</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -37,17 +37,17 @@ typedef enum {</span>
<a href="#l25.4"></a><span id="l25.4">     PGP_KEY_SEARCH_FINGERPRINT,</span>
<a href="#l25.5"></a><span id="l25.5">     PGP_KEY_SEARCH_GRIP,</span>
<a href="#l25.6"></a><span id="l25.6">     PGP_KEY_SEARCH_USERID</span>
<a href="#l25.7"></a><span id="l25.7"> } pgp_key_search_type_t;</span>
<a href="#l25.8"></a><span id="l25.8"> </span>
<a href="#l25.9"></a><span id="l25.9"> typedef struct pgp_key_search_t {</span>
<a href="#l25.10"></a><span id="l25.10">     pgp_key_search_type_t type;</span>
<a href="#l25.11"></a><span id="l25.11">     union {</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-        uint8_t           keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+        pgp_key_id_t      keyid;</span>
<a href="#l25.14"></a><span id="l25.14">         pgp_key_grip_t    grip;</span>
<a href="#l25.15"></a><span id="l25.15">         pgp_fingerprint_t fingerprint;</span>
<a href="#l25.16"></a><span id="l25.16">         char              userid[MAX_ID_LENGTH + 1];</span>
<a href="#l25.17"></a><span id="l25.17">     } by;</span>
<a href="#l25.18"></a><span id="l25.18"> } pgp_key_search_t;</span>
<a href="#l25.19"></a><span id="l25.19"> </span>
<a href="#l25.20"></a><span id="l25.20"> typedef struct pgp_key_request_ctx_t {</span>
<a href="#l25.21"></a><span id="l25.21">     pgp_op_t         op;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/third_party/rnp/src/lib/misc.cpp</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/third_party/rnp/src/lib/misc.cpp</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l26.4"></a><span id="l26.4"> /*</span>
<a href="#l26.5"></a><span id="l26.5" class="difflineminus">- * Copyright (c) 2017-2019 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l26.6"></a><span id="l26.6" class="difflineplus">+ * Copyright (c) 2017-2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l26.7"></a><span id="l26.7">  * Copyright (c) 2009-2010 The NetBSD Foundation, Inc.</span>
<a href="#l26.8"></a><span id="l26.8">  * All rights reserved.</span>
<a href="#l26.9"></a><span id="l26.9">  *</span>
<a href="#l26.10"></a><span id="l26.10">  * This code is originally derived from software contributed to</span>
<a href="#l26.11"></a><span id="l26.11">  * The NetBSD Foundation by Alistair Crooks (agc@netbsd.org), and</span>
<a href="#l26.12"></a><span id="l26.12">  * carried further by Ribose Inc (https://www.ribose.com).</span>
<a href="#l26.13"></a><span id="l26.13">  *</span>
<a href="#l26.14"></a><span id="l26.14">  * Redistribution and use in source and binary forms, with or without</span>
<a href="#l26.15"></a><span id="l26.15" class="difflineat">@@ -282,29 +282,16 @@ rnp_strhexdump_upper(char *dest, const u</span>
<a href="#l26.16"></a><span id="l26.16"> </span>
<a href="#l26.17"></a><span id="l26.17">     for (n = 0, i = 0; i &lt; length; i += 2) {</span>
<a href="#l26.18"></a><span id="l26.18">         n += snprintf(&amp;dest[n], 3, &quot;%02X&quot;, *src++);</span>
<a href="#l26.19"></a><span id="l26.19">         n += snprintf(&amp;dest[n], 10, &quot;%02X%s&quot;, *src++, sep);</span>
<a href="#l26.20"></a><span id="l26.20">     }</span>
<a href="#l26.21"></a><span id="l26.21">     return dest;</span>
<a href="#l26.22"></a><span id="l26.22"> }</span>
<a href="#l26.23"></a><span id="l26.23"> </span>
<a href="#l26.24"></a><span id="l26.24" class="difflineminus">-/* return the file modification time */</span>
<a href="#l26.25"></a><span id="l26.25" class="difflineminus">-int64_t</span>
<a href="#l26.26"></a><span id="l26.26" class="difflineminus">-rnp_filemtime(const char *path)</span>
<a href="#l26.27"></a><span id="l26.27" class="difflineminus">-{</span>
<a href="#l26.28"></a><span id="l26.28" class="difflineminus">-    struct stat st;</span>
<a href="#l26.29"></a><span id="l26.29" class="difflineminus">-</span>
<a href="#l26.30"></a><span id="l26.30" class="difflineminus">-    if (stat(path, &amp;st) != 0) {</span>
<a href="#l26.31"></a><span id="l26.31" class="difflineminus">-        return 0;</span>
<a href="#l26.32"></a><span id="l26.32" class="difflineminus">-    } else {</span>
<a href="#l26.33"></a><span id="l26.33" class="difflineminus">-        return st.st_mtime;</span>
<a href="#l26.34"></a><span id="l26.34" class="difflineminus">-    }</span>
<a href="#l26.35"></a><span id="l26.35" class="difflineminus">-}</span>
<a href="#l26.36"></a><span id="l26.36" class="difflineminus">-</span>
<a href="#l26.37"></a><span id="l26.37"> static char *</span>
<a href="#l26.38"></a><span id="l26.38"> vcompose_path(char **buf, size_t *buf_len, const char *first, va_list ap)</span>
<a href="#l26.39"></a><span id="l26.39"> {</span>
<a href="#l26.40"></a><span id="l26.40">     size_t curlen = 0;</span>
<a href="#l26.41"></a><span id="l26.41">     char * tmp_buf = NULL;</span>
<a href="#l26.42"></a><span id="l26.42">     size_t tmp_buf_len = 0;</span>
<a href="#l26.43"></a><span id="l26.43"> </span>
<a href="#l26.44"></a><span id="l26.44">     if (!first) {</span>
<a href="#l26.45"></a><span id="l26.45" class="difflineat">@@ -423,23 +410,16 @@ rnp_path_exists(const char *path)</span>
<a href="#l26.46"></a><span id="l26.46"> bool</span>
<a href="#l26.47"></a><span id="l26.47"> rnp_dir_exists(const char *path)</span>
<a href="#l26.48"></a><span id="l26.48"> {</span>
<a href="#l26.49"></a><span id="l26.49">     struct stat st;</span>
<a href="#l26.50"></a><span id="l26.50">     return stat(path, &amp;st) == 0 &amp;&amp; S_ISDIR(st.st_mode);</span>
<a href="#l26.51"></a><span id="l26.51"> }</span>
<a href="#l26.52"></a><span id="l26.52"> </span>
<a href="#l26.53"></a><span id="l26.53"> bool</span>
<a href="#l26.54"></a><span id="l26.54" class="difflineminus">-rnp_file_exists(const char *path)</span>
<a href="#l26.55"></a><span id="l26.55" class="difflineminus">-{</span>
<a href="#l26.56"></a><span id="l26.56" class="difflineminus">-    struct stat st;</span>
<a href="#l26.57"></a><span id="l26.57" class="difflineminus">-    return stat(path, &amp;st) == 0 &amp;&amp; S_ISREG(st.st_mode);</span>
<a href="#l26.58"></a><span id="l26.58" class="difflineminus">-}</span>
<a href="#l26.59"></a><span id="l26.59" class="difflineminus">-</span>
<a href="#l26.60"></a><span id="l26.60" class="difflineminus">-bool</span>
<a href="#l26.61"></a><span id="l26.61"> rnp_hex_encode(</span>
<a href="#l26.62"></a><span id="l26.62">   const uint8_t *buf, size_t buf_len, char *hex, size_t hex_len, rnp_hex_format_t format)</span>
<a href="#l26.63"></a><span id="l26.63"> {</span>
<a href="#l26.64"></a><span id="l26.64">     uint32_t flags = format == RNP_HEX_LOWERCASE ? BOTAN_FFI_HEX_LOWER_CASE : 0;</span>
<a href="#l26.65"></a><span id="l26.65"> </span>
<a href="#l26.66"></a><span id="l26.66">     if (hex_len &lt; (buf_len * 2 + 1)) {</span>
<a href="#l26.67"></a><span id="l26.67">         return false;</span>
<a href="#l26.68"></a><span id="l26.68">     }</span>
<a href="#l26.69"></a><span id="l26.69" class="difflineat">@@ -470,28 +450,16 @@ rnp_strlwr(char *s)</span>
<a href="#l26.70"></a><span id="l26.70">     char *p = s;</span>
<a href="#l26.71"></a><span id="l26.71">     while (*p) {</span>
<a href="#l26.72"></a><span id="l26.72">         *p = tolower((unsigned char) *p);</span>
<a href="#l26.73"></a><span id="l26.73">         p++;</span>
<a href="#l26.74"></a><span id="l26.74">     }</span>
<a href="#l26.75"></a><span id="l26.75">     return s;</span>
<a href="#l26.76"></a><span id="l26.76"> }</span>
<a href="#l26.77"></a><span id="l26.77"> </span>
<a href="#l26.78"></a><span id="l26.78" class="difflineminus">-char *</span>
<a href="#l26.79"></a><span id="l26.79" class="difflineminus">-rnp_strip_eol(char *s)</span>
<a href="#l26.80"></a><span id="l26.80" class="difflineminus">-{</span>
<a href="#l26.81"></a><span id="l26.81" class="difflineminus">-    size_t len = strlen(s);</span>
<a href="#l26.82"></a><span id="l26.82" class="difflineminus">-</span>
<a href="#l26.83"></a><span id="l26.83" class="difflineminus">-    while ((len &gt; 0) &amp;&amp; ((s[len - 1] == '\n') || (s[len - 1] == '\r'))) {</span>
<a href="#l26.84"></a><span id="l26.84" class="difflineminus">-        s[--len] = '\0';</span>
<a href="#l26.85"></a><span id="l26.85" class="difflineminus">-    }</span>
<a href="#l26.86"></a><span id="l26.86" class="difflineminus">-</span>
<a href="#l26.87"></a><span id="l26.87" class="difflineminus">-    return s;</span>
<a href="#l26.88"></a><span id="l26.88" class="difflineminus">-}</span>
<a href="#l26.89"></a><span id="l26.89" class="difflineminus">-</span>
<a href="#l26.90"></a><span id="l26.90"> /* convert hex string, probably prefixes with 0x, to binary form */</span>
<a href="#l26.91"></a><span id="l26.91"> bool</span>
<a href="#l26.92"></a><span id="l26.92"> hex2bin(const char *hex, size_t hexlen, uint8_t *bin, size_t len, size_t *out)</span>
<a href="#l26.93"></a><span id="l26.93"> {</span>
<a href="#l26.94"></a><span id="l26.94">     *out = rnp_hex_decode(hex, bin, len);</span>
<a href="#l26.95"></a><span id="l26.95">     return *out != 0;</span>
<a href="#l26.96"></a><span id="l26.96"> }</span>
<a href="#l26.97"></a><span id="l26.97"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/third_party/rnp/src/lib/pgp-key.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/third_party/rnp/src/lib/pgp-key.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -171,18 +171,17 @@ pgp_free_user_prefs(pgp_user_prefs_t *pr</span>
<a href="#l27.4"></a><span id="l27.4"> }</span>
<a href="#l27.5"></a><span id="l27.5"> </span>
<a href="#l27.6"></a><span id="l27.6"> static bool</span>
<a href="#l27.7"></a><span id="l27.7"> pgp_key_init_with_pkt(pgp_key_t *key, const pgp_key_pkt_t *pkt)</span>
<a href="#l27.8"></a><span id="l27.8"> {</span>
<a href="#l27.9"></a><span id="l27.9">     assert(!key-&gt;pkt.version);</span>
<a href="#l27.10"></a><span id="l27.10">     assert(is_key_pkt(pkt-&gt;tag));</span>
<a href="#l27.11"></a><span id="l27.11">     assert(pkt-&gt;material.alg);</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-    if (pgp_keyid(key-&gt;keyid, PGP_KEY_ID_SIZE, pkt) ||</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineminus">-        pgp_fingerprint(&amp;key-&gt;fingerprint, pkt) ||</span>
<a href="#l27.14"></a><span id="l27.14" class="difflineplus">+    if (pgp_keyid(key-&gt;keyid, pkt) || pgp_fingerprint(key-&gt;fingerprint, pkt) ||</span>
<a href="#l27.15"></a><span id="l27.15">         !rnp_key_store_get_key_grip(&amp;pkt-&gt;material, key-&gt;grip)) {</span>
<a href="#l27.16"></a><span id="l27.16">         return false;</span>
<a href="#l27.17"></a><span id="l27.17">     }</span>
<a href="#l27.18"></a><span id="l27.18">     /* this is correct since changes ownership */</span>
<a href="#l27.19"></a><span id="l27.19">     key-&gt;pkt = *pkt;</span>
<a href="#l27.20"></a><span id="l27.20">     return true;</span>
<a href="#l27.21"></a><span id="l27.21"> }</span>
<a href="#l27.22"></a><span id="l27.22"> </span>
<a href="#l27.23"></a><span id="l27.23" class="difflineat">@@ -373,35 +372,35 @@ pgp_key_copy_fields(pgp_key_t *dst, cons</span>
<a href="#l27.24"></a><span id="l27.24">         } catch (const std::exception &amp;e) {</span>
<a href="#l27.25"></a><span id="l27.25">             RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l27.26"></a><span id="l27.26">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l27.27"></a><span id="l27.27">         }</span>
<a href="#l27.28"></a><span id="l27.28">     }</span>
<a href="#l27.29"></a><span id="l27.29"> </span>
<a href="#l27.30"></a><span id="l27.30">     /* subkey grips */</span>
<a href="#l27.31"></a><span id="l27.31">     try {</span>
<a href="#l27.32"></a><span id="l27.32" class="difflineminus">-        dst-&gt;subkey_grips = src-&gt;subkey_grips;</span>
<a href="#l27.33"></a><span id="l27.33" class="difflineplus">+        dst-&gt;subkey_fps = src-&gt;subkey_fps;</span>
<a href="#l27.34"></a><span id="l27.34">     } catch (const std::exception &amp;e) {</span>
<a href="#l27.35"></a><span id="l27.35">         RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l27.36"></a><span id="l27.36">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l27.37"></a><span id="l27.37">     }</span>
<a href="#l27.38"></a><span id="l27.38"> </span>
<a href="#l27.39"></a><span id="l27.39">     /* primary grip */</span>
<a href="#l27.40"></a><span id="l27.40" class="difflineminus">-    dst-&gt;primary_grip_set = src-&gt;primary_grip_set;</span>
<a href="#l27.41"></a><span id="l27.41" class="difflineminus">-    dst-&gt;primary_grip = src-&gt;primary_grip;</span>
<a href="#l27.42"></a><span id="l27.42" class="difflineplus">+    dst-&gt;primary_fp_set = src-&gt;primary_fp_set;</span>
<a href="#l27.43"></a><span id="l27.43" class="difflineplus">+    dst-&gt;primary_fp = src-&gt;primary_fp;</span>
<a href="#l27.44"></a><span id="l27.44"> </span>
<a href="#l27.45"></a><span id="l27.45">     /* expiration */</span>
<a href="#l27.46"></a><span id="l27.46">     dst-&gt;expiration = src-&gt;expiration;</span>
<a href="#l27.47"></a><span id="l27.47"> </span>
<a href="#l27.48"></a><span id="l27.48">     /* key_flags */</span>
<a href="#l27.49"></a><span id="l27.49">     dst-&gt;key_flags = src-&gt;key_flags;</span>
<a href="#l27.50"></a><span id="l27.50"> </span>
<a href="#l27.51"></a><span id="l27.51">     /* key id / fingerprint / grip */</span>
<a href="#l27.52"></a><span id="l27.52" class="difflineminus">-    memcpy(dst-&gt;keyid, src-&gt;keyid, sizeof(dst-&gt;keyid));</span>
<a href="#l27.53"></a><span id="l27.53" class="difflineminus">-    memcpy(&amp;dst-&gt;fingerprint, &amp;src-&gt;fingerprint, sizeof(dst-&gt;fingerprint));</span>
<a href="#l27.54"></a><span id="l27.54" class="difflineplus">+    dst-&gt;keyid = src-&gt;keyid;</span>
<a href="#l27.55"></a><span id="l27.55" class="difflineplus">+    dst-&gt;fingerprint = src-&gt;fingerprint;</span>
<a href="#l27.56"></a><span id="l27.56">     dst-&gt;grip = src-&gt;grip;</span>
<a href="#l27.57"></a><span id="l27.57"> </span>
<a href="#l27.58"></a><span id="l27.58">     /* primary uid */</span>
<a href="#l27.59"></a><span id="l27.59">     dst-&gt;uid0 = src-&gt;uid0;</span>
<a href="#l27.60"></a><span id="l27.60">     dst-&gt;uid0_set = src-&gt;uid0_set;</span>
<a href="#l27.61"></a><span id="l27.61"> </span>
<a href="#l27.62"></a><span id="l27.62">     /* revocation */</span>
<a href="#l27.63"></a><span id="l27.63">     dst-&gt;revoked = src-&gt;revoked;</span>
<a href="#l27.64"></a><span id="l27.64" class="difflineat">@@ -640,58 +639,58 @@ pgp_decrypt_seckey(const pgp_key_t *    </span>
<a href="#l27.65"></a><span id="l27.65">     // attempt to decrypt with the provided password</span>
<a href="#l27.66"></a><span id="l27.66">     const pgp_rawpacket_t &amp;pkt = pgp_key_get_rawpacket(key);</span>
<a href="#l27.67"></a><span id="l27.67">     pgp_key_pkt_t *        decrypted_seckey =</span>
<a href="#l27.68"></a><span id="l27.68">       decryptor(pkt.raw.data(), pkt.raw.size(), pgp_key_get_pkt(key), password);</span>
<a href="#l27.69"></a><span id="l27.69">     pgp_forget(password, sizeof(password));</span>
<a href="#l27.70"></a><span id="l27.70">     return decrypted_seckey;</span>
<a href="#l27.71"></a><span id="l27.71"> }</span>
<a href="#l27.72"></a><span id="l27.72"> </span>
<a href="#l27.73"></a><span id="l27.73" class="difflineminus">-const uint8_t *</span>
<a href="#l27.74"></a><span id="l27.74" class="difflineplus">+const pgp_key_id_t &amp;</span>
<a href="#l27.75"></a><span id="l27.75"> pgp_key_get_keyid(const pgp_key_t *key)</span>
<a href="#l27.76"></a><span id="l27.76"> {</span>
<a href="#l27.77"></a><span id="l27.77">     return key-&gt;keyid;</span>
<a href="#l27.78"></a><span id="l27.78"> }</span>
<a href="#l27.79"></a><span id="l27.79"> </span>
<a href="#l27.80"></a><span id="l27.80" class="difflineminus">-const pgp_fingerprint_t *</span>
<a href="#l27.81"></a><span id="l27.81" class="difflineplus">+const pgp_fingerprint_t &amp;</span>
<a href="#l27.82"></a><span id="l27.82"> pgp_key_get_fp(const pgp_key_t *key)</span>
<a href="#l27.83"></a><span id="l27.83"> {</span>
<a href="#l27.84"></a><span id="l27.84" class="difflineminus">-    return &amp;key-&gt;fingerprint;</span>
<a href="#l27.85"></a><span id="l27.85" class="difflineplus">+    return key-&gt;fingerprint;</span>
<a href="#l27.86"></a><span id="l27.86"> }</span>
<a href="#l27.87"></a><span id="l27.87"> </span>
<a href="#l27.88"></a><span id="l27.88"> const pgp_key_grip_t &amp;</span>
<a href="#l27.89"></a><span id="l27.89"> pgp_key_get_grip(const pgp_key_t *key)</span>
<a href="#l27.90"></a><span id="l27.90"> {</span>
<a href="#l27.91"></a><span id="l27.91">     return key-&gt;grip;</span>
<a href="#l27.92"></a><span id="l27.92"> }</span>
<a href="#l27.93"></a><span id="l27.93"> </span>
<a href="#l27.94"></a><span id="l27.94" class="difflineminus">-const pgp_key_grip_t &amp;</span>
<a href="#l27.95"></a><span id="l27.95" class="difflineminus">-pgp_key_get_primary_grip(const pgp_key_t *key)</span>
<a href="#l27.96"></a><span id="l27.96" class="difflineplus">+const pgp_fingerprint_t &amp;</span>
<a href="#l27.97"></a><span id="l27.97" class="difflineplus">+pgp_key_get_primary_fp(const pgp_key_t *key)</span>
<a href="#l27.98"></a><span id="l27.98"> {</span>
<a href="#l27.99"></a><span id="l27.99" class="difflineminus">-    return key-&gt;primary_grip;</span>
<a href="#l27.100"></a><span id="l27.100" class="difflineplus">+    return key-&gt;primary_fp;</span>
<a href="#l27.101"></a><span id="l27.101"> }</span>
<a href="#l27.102"></a><span id="l27.102"> </span>
<a href="#l27.103"></a><span id="l27.103"> bool</span>
<a href="#l27.104"></a><span id="l27.104" class="difflineminus">-pgp_key_has_primary_grip(const pgp_key_t *key)</span>
<a href="#l27.105"></a><span id="l27.105" class="difflineplus">+pgp_key_has_primary_fp(const pgp_key_t *key)</span>
<a href="#l27.106"></a><span id="l27.106"> {</span>
<a href="#l27.107"></a><span id="l27.107" class="difflineminus">-    return key-&gt;primary_grip_set;</span>
<a href="#l27.108"></a><span id="l27.108" class="difflineplus">+    return key-&gt;primary_fp_set;</span>
<a href="#l27.109"></a><span id="l27.109"> }</span>
<a href="#l27.110"></a><span id="l27.110"> </span>
<a href="#l27.111"></a><span id="l27.111"> void</span>
<a href="#l27.112"></a><span id="l27.112" class="difflineminus">-pgp_key_set_primary_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip)</span>
<a href="#l27.113"></a><span id="l27.113" class="difflineplus">+pgp_key_set_primary_fp(pgp_key_t *key, const pgp_fingerprint_t &amp;fp)</span>
<a href="#l27.114"></a><span id="l27.114"> {</span>
<a href="#l27.115"></a><span id="l27.115" class="difflineminus">-    key-&gt;primary_grip = grip;</span>
<a href="#l27.116"></a><span id="l27.116" class="difflineminus">-    key-&gt;primary_grip_set = true;</span>
<a href="#l27.117"></a><span id="l27.117" class="difflineplus">+    key-&gt;primary_fp = fp;</span>
<a href="#l27.118"></a><span id="l27.118" class="difflineplus">+    key-&gt;primary_fp_set = true;</span>
<a href="#l27.119"></a><span id="l27.119"> }</span>
<a href="#l27.120"></a><span id="l27.120"> </span>
<a href="#l27.121"></a><span id="l27.121"> bool</span>
<a href="#l27.122"></a><span id="l27.122" class="difflineminus">-pgp_key_link_subkey_grip(pgp_key_t *key, pgp_key_t *subkey)</span>
<a href="#l27.123"></a><span id="l27.123" class="difflineplus">+pgp_key_link_subkey_fp(pgp_key_t *key, pgp_key_t *subkey)</span>
<a href="#l27.124"></a><span id="l27.124"> {</span>
<a href="#l27.125"></a><span id="l27.125" class="difflineminus">-    pgp_key_set_primary_grip(subkey, pgp_key_get_grip(key));</span>
<a href="#l27.126"></a><span id="l27.126" class="difflineminus">-    if (!pgp_key_add_subkey_grip(key, pgp_key_get_grip(subkey))) {</span>
<a href="#l27.127"></a><span id="l27.127" class="difflineplus">+    pgp_key_set_primary_fp(subkey, pgp_key_get_fp(key));</span>
<a href="#l27.128"></a><span id="l27.128" class="difflineplus">+    if (!pgp_key_add_subkey_fp(key, pgp_key_get_fp(subkey))) {</span>
<a href="#l27.129"></a><span id="l27.129">         RNP_LOG(&quot;failed to add subkey grip&quot;);</span>
<a href="#l27.130"></a><span id="l27.130">         return false;</span>
<a href="#l27.131"></a><span id="l27.131">     }</span>
<a href="#l27.132"></a><span id="l27.132">     return true;</span>
<a href="#l27.133"></a><span id="l27.133"> }</span>
<a href="#l27.134"></a><span id="l27.134"> </span>
<a href="#l27.135"></a><span id="l27.135"> size_t</span>
<a href="#l27.136"></a><span id="l27.136"> pgp_key_get_userid_count(const pgp_key_t *key)</span>
<a href="#l27.137"></a><span id="l27.137" class="difflineat">@@ -929,28 +928,28 @@ pgp_sig_is_certification(const pgp_subsi</span>
<a href="#l27.138"></a><span id="l27.138"> }</span>
<a href="#l27.139"></a><span id="l27.139"> </span>
<a href="#l27.140"></a><span id="l27.140"> static bool</span>
<a href="#l27.141"></a><span id="l27.141"> pgp_sig_self_signed(const pgp_key_t *key, const pgp_subsig_t *sig)</span>
<a href="#l27.142"></a><span id="l27.142"> {</span>
<a href="#l27.143"></a><span id="l27.143">     /* if we have fingerprint let's check it */</span>
<a href="#l27.144"></a><span id="l27.144">     if (signature_has_keyfp(&amp;sig-&gt;sig)) {</span>
<a href="#l27.145"></a><span id="l27.145">         pgp_fingerprint_t sigfp = {};</span>
<a href="#l27.146"></a><span id="l27.146" class="difflineminus">-        if (signature_get_keyfp(&amp;sig-&gt;sig, &amp;sigfp)) {</span>
<a href="#l27.147"></a><span id="l27.147" class="difflineminus">-            return fingerprint_equal(pgp_key_get_fp(key), &amp;sigfp);</span>
<a href="#l27.148"></a><span id="l27.148" class="difflineplus">+        if (signature_get_keyfp(&amp;sig-&gt;sig, sigfp)) {</span>
<a href="#l27.149"></a><span id="l27.149" class="difflineplus">+            return pgp_key_get_fp(key) == sigfp;</span>
<a href="#l27.150"></a><span id="l27.150">         }</span>
<a href="#l27.151"></a><span id="l27.151">     }</span>
<a href="#l27.152"></a><span id="l27.152">     if (!signature_has_keyid(&amp;sig-&gt;sig)) {</span>
<a href="#l27.153"></a><span id="l27.153">         return false;</span>
<a href="#l27.154"></a><span id="l27.154">     }</span>
<a href="#l27.155"></a><span id="l27.155" class="difflineminus">-    uint8_t sigid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l27.156"></a><span id="l27.156" class="difflineplus">+    pgp_key_id_t sigid = {};</span>
<a href="#l27.157"></a><span id="l27.157">     if (!signature_get_keyid(&amp;sig-&gt;sig, sigid)) {</span>
<a href="#l27.158"></a><span id="l27.158">         return false;</span>
<a href="#l27.159"></a><span id="l27.159">     }</span>
<a href="#l27.160"></a><span id="l27.160" class="difflineminus">-    return !memcmp(pgp_key_get_keyid(key), sigid, PGP_KEY_ID_SIZE);</span>
<a href="#l27.161"></a><span id="l27.161" class="difflineplus">+    return pgp_key_get_keyid(key) == sigid;</span>
<a href="#l27.162"></a><span id="l27.162"> }</span>
<a href="#l27.163"></a><span id="l27.163"> </span>
<a href="#l27.164"></a><span id="l27.164"> static bool</span>
<a href="#l27.165"></a><span id="l27.165"> pgp_sig_is_self_signature(const pgp_key_t *key, const pgp_subsig_t *sig)</span>
<a href="#l27.166"></a><span id="l27.166"> {</span>
<a href="#l27.167"></a><span id="l27.167">     if (!pgp_key_is_primary_key(key) || !pgp_sig_is_certification(sig)) {</span>
<a href="#l27.168"></a><span id="l27.168">         return false;</span>
<a href="#l27.169"></a><span id="l27.169">     }</span>
<a href="#l27.170"></a><span id="l27.170" class="difflineat">@@ -1048,83 +1047,72 @@ pgp_key_latest_binding(pgp_key_t *subkey</span>
<a href="#l27.171"></a><span id="l27.171"> static void</span>
<a href="#l27.172"></a><span id="l27.172"> pgp_key_validate_self_signatures(pgp_key_t *key)</span>
<a href="#l27.173"></a><span id="l27.173"> {</span>
<a href="#l27.174"></a><span id="l27.174">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(key); i++) {</span>
<a href="#l27.175"></a><span id="l27.175">         pgp_subsig_t *sig = pgp_key_get_subsig(key, i);</span>
<a href="#l27.176"></a><span id="l27.176">         if (sig-&gt;validated) {</span>
<a href="#l27.177"></a><span id="l27.177">             continue;</span>
<a href="#l27.178"></a><span id="l27.178">         }</span>
<a href="#l27.179"></a><span id="l27.179" class="difflineplus">+        pgp_signature_info_t sinfo = {};</span>
<a href="#l27.180"></a><span id="l27.180" class="difflineplus">+        sinfo.sig = &amp;sig-&gt;sig;</span>
<a href="#l27.181"></a><span id="l27.181" class="difflineplus">+        sinfo.signer = key;</span>
<a href="#l27.182"></a><span id="l27.182" class="difflineplus">+        sinfo.signer_valid = true;</span>
<a href="#l27.183"></a><span id="l27.183"> </span>
<a href="#l27.184"></a><span id="l27.184">         if (pgp_sig_is_self_signature(key, sig)) {</span>
<a href="#l27.185"></a><span id="l27.185" class="difflineminus">-            pgp_signature_info_t sinfo = {};</span>
<a href="#l27.186"></a><span id="l27.186" class="difflineminus">-            sinfo.sig = &amp;sig-&gt;sig;</span>
<a href="#l27.187"></a><span id="l27.187" class="difflineminus">-            sinfo.signer = key;</span>
<a href="#l27.188"></a><span id="l27.188" class="difflineminus">-            sinfo.signer_valid = true;</span>
<a href="#l27.189"></a><span id="l27.189" class="difflineplus">+            sinfo.ignore_expiry = true;</span>
<a href="#l27.190"></a><span id="l27.190">             pgp_userid_t *uid = pgp_key_get_userid(key, sig-&gt;uid);</span>
<a href="#l27.191"></a><span id="l27.191">             if (uid) {</span>
<a href="#l27.192"></a><span id="l27.192">                 signature_check_certification(&amp;sinfo, pgp_key_get_pkt(key), &amp;uid-&gt;pkt);</span>
<a href="#l27.193"></a><span id="l27.193">                 sig-&gt;validated = true;</span>
<a href="#l27.194"></a><span id="l27.194">                 sig-&gt;valid = sinfo.valid &amp;&amp; !sinfo.expired;</span>
<a href="#l27.195"></a><span id="l27.195">             }</span>
<a href="#l27.196"></a><span id="l27.196">             continue;</span>
<a href="#l27.197"></a><span id="l27.197">         }</span>
<a href="#l27.198"></a><span id="l27.198"> </span>
<a href="#l27.199"></a><span id="l27.199">         if (pgp_sig_is_userid_revocation(key, sig)) {</span>
<a href="#l27.200"></a><span id="l27.200" class="difflineminus">-            pgp_signature_info_t sinfo = {};</span>
<a href="#l27.201"></a><span id="l27.201" class="difflineminus">-            sinfo.sig = &amp;sig-&gt;sig;</span>
<a href="#l27.202"></a><span id="l27.202" class="difflineminus">-            sinfo.signer = key;</span>
<a href="#l27.203"></a><span id="l27.203" class="difflineminus">-            sinfo.signer_valid = true;</span>
<a href="#l27.204"></a><span id="l27.204">             pgp_userid_t *uid = pgp_key_get_userid(key, sig-&gt;uid);</span>
<a href="#l27.205"></a><span id="l27.205">             if (uid) {</span>
<a href="#l27.206"></a><span id="l27.206">                 signature_check_certification(&amp;sinfo, pgp_key_get_pkt(key), &amp;uid-&gt;pkt);</span>
<a href="#l27.207"></a><span id="l27.207">                 sig-&gt;validated = true;</span>
<a href="#l27.208"></a><span id="l27.208">                 sig-&gt;valid = sinfo.valid &amp;&amp; !sinfo.expired;</span>
<a href="#l27.209"></a><span id="l27.209">             }</span>
<a href="#l27.210"></a><span id="l27.210">             continue;</span>
<a href="#l27.211"></a><span id="l27.211">         }</span>
<a href="#l27.212"></a><span id="l27.212"> </span>
<a href="#l27.213"></a><span id="l27.213">         if (pgp_sig_is_key_revocation(key, sig)) {</span>
<a href="#l27.214"></a><span id="l27.214" class="difflineminus">-            pgp_signature_info_t sinfo = {};</span>
<a href="#l27.215"></a><span id="l27.215" class="difflineminus">-            sinfo.sig = &amp;sig-&gt;sig;</span>
<a href="#l27.216"></a><span id="l27.216" class="difflineminus">-            sinfo.signer = key;</span>
<a href="#l27.217"></a><span id="l27.217" class="difflineminus">-            sinfo.signer_valid = true;</span>
<a href="#l27.218"></a><span id="l27.218">             signature_check_direct(&amp;sinfo, pgp_key_get_pkt(key));</span>
<a href="#l27.219"></a><span id="l27.219">             sig-&gt;validated = true;</span>
<a href="#l27.220"></a><span id="l27.220">             sig-&gt;valid = sinfo.valid;</span>
<a href="#l27.221"></a><span id="l27.221">             /* revocation signature cannot expire */</span>
<a href="#l27.222"></a><span id="l27.222">         }</span>
<a href="#l27.223"></a><span id="l27.223">     }</span>
<a href="#l27.224"></a><span id="l27.224"> }</span>
<a href="#l27.225"></a><span id="l27.225"> </span>
<a href="#l27.226"></a><span id="l27.226"> static void</span>
<a href="#l27.227"></a><span id="l27.227"> pgp_subkey_validate_self_signatures(pgp_key_t *sub, pgp_key_t *key)</span>
<a href="#l27.228"></a><span id="l27.228"> {</span>
<a href="#l27.229"></a><span id="l27.229">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(sub); i++) {</span>
<a href="#l27.230"></a><span id="l27.230">         pgp_subsig_t *sig = pgp_key_get_subsig(sub, i);</span>
<a href="#l27.231"></a><span id="l27.231">         if (sig-&gt;validated) {</span>
<a href="#l27.232"></a><span id="l27.232">             continue;</span>
<a href="#l27.233"></a><span id="l27.233">         }</span>
<a href="#l27.234"></a><span id="l27.234" class="difflineminus">-</span>
<a href="#l27.235"></a><span id="l27.235" class="difflineplus">+        pgp_signature_info_t sinfo = {};</span>
<a href="#l27.236"></a><span id="l27.236" class="difflineplus">+        sinfo.sig = &amp;sig-&gt;sig;</span>
<a href="#l27.237"></a><span id="l27.237" class="difflineplus">+        sinfo.signer = key;</span>
<a href="#l27.238"></a><span id="l27.238" class="difflineplus">+        sinfo.signer_valid = true;</span>
<a href="#l27.239"></a><span id="l27.239">         if (pgp_sig_is_subkey_binding(sub, sig)) {</span>
<a href="#l27.240"></a><span id="l27.240" class="difflineminus">-            pgp_signature_info_t sinfo = {};</span>
<a href="#l27.241"></a><span id="l27.241" class="difflineminus">-            sinfo.sig = &amp;sig-&gt;sig;</span>
<a href="#l27.242"></a><span id="l27.242" class="difflineminus">-            sinfo.signer = key;</span>
<a href="#l27.243"></a><span id="l27.243" class="difflineminus">-            sinfo.signer_valid = true;</span>
<a href="#l27.244"></a><span id="l27.244" class="difflineplus">+            sinfo.ignore_expiry = true;</span>
<a href="#l27.245"></a><span id="l27.245">             signature_check_binding(&amp;sinfo, pgp_key_get_pkt(key), pgp_key_get_pkt(sub));</span>
<a href="#l27.246"></a><span id="l27.246">             sig-&gt;validated = true;</span>
<a href="#l27.247"></a><span id="l27.247">             sig-&gt;valid = sinfo.valid &amp;&amp; !sinfo.expired;</span>
<a href="#l27.248"></a><span id="l27.248">             continue;</span>
<a href="#l27.249"></a><span id="l27.249">         }</span>
<a href="#l27.250"></a><span id="l27.250"> </span>
<a href="#l27.251"></a><span id="l27.251">         if (pgp_sig_is_subkey_revocation(sub, sig)) {</span>
<a href="#l27.252"></a><span id="l27.252" class="difflineminus">-            pgp_signature_info_t sinfo = {};</span>
<a href="#l27.253"></a><span id="l27.253" class="difflineminus">-            sinfo.sig = &amp;sig-&gt;sig;</span>
<a href="#l27.254"></a><span id="l27.254" class="difflineminus">-            sinfo.signer = key;</span>
<a href="#l27.255"></a><span id="l27.255" class="difflineminus">-            sinfo.signer_valid = true;</span>
<a href="#l27.256"></a><span id="l27.256">             signature_check_subkey_revocation(</span>
<a href="#l27.257"></a><span id="l27.257">               &amp;sinfo, pgp_key_get_pkt(key), pgp_key_get_pkt(sub));</span>
<a href="#l27.258"></a><span id="l27.258">             sig-&gt;validated = true;</span>
<a href="#l27.259"></a><span id="l27.259">             sig-&gt;valid = sinfo.valid;</span>
<a href="#l27.260"></a><span id="l27.260">             /* revocation signature cannot expire */</span>
<a href="#l27.261"></a><span id="l27.261">         }</span>
<a href="#l27.262"></a><span id="l27.262">     }</span>
<a href="#l27.263"></a><span id="l27.263"> }</span>
<a href="#l27.264"></a><span id="l27.264" class="difflineat">@@ -1285,57 +1273,57 @@ const pgp_rawpacket_t &amp;</span>
<a href="#l27.265"></a><span id="l27.265"> pgp_key_get_rawpacket(const pgp_key_t *key)</span>
<a href="#l27.266"></a><span id="l27.266"> {</span>
<a href="#l27.267"></a><span id="l27.267">     return key-&gt;rawpkt;</span>
<a href="#l27.268"></a><span id="l27.268"> }</span>
<a href="#l27.269"></a><span id="l27.269"> </span>
<a href="#l27.270"></a><span id="l27.270"> size_t</span>
<a href="#l27.271"></a><span id="l27.271"> pgp_key_get_subkey_count(const pgp_key_t *key)</span>
<a href="#l27.272"></a><span id="l27.272"> {</span>
<a href="#l27.273"></a><span id="l27.273" class="difflineminus">-    return key-&gt;subkey_grips.size();</span>
<a href="#l27.274"></a><span id="l27.274" class="difflineplus">+    return key-&gt;subkey_fps.size();</span>
<a href="#l27.275"></a><span id="l27.275"> }</span>
<a href="#l27.276"></a><span id="l27.276"> </span>
<a href="#l27.277"></a><span id="l27.277"> bool</span>
<a href="#l27.278"></a><span id="l27.278" class="difflineminus">-pgp_key_add_subkey_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip)</span>
<a href="#l27.279"></a><span id="l27.279" class="difflineplus">+pgp_key_add_subkey_fp(pgp_key_t *key, const pgp_fingerprint_t &amp;fp)</span>
<a href="#l27.280"></a><span id="l27.280"> {</span>
<a href="#l27.281"></a><span id="l27.281" class="difflineminus">-    if (std::find(key-&gt;subkey_grips.begin(), key-&gt;subkey_grips.end(), grip) !=</span>
<a href="#l27.282"></a><span id="l27.282" class="difflineminus">-        key-&gt;subkey_grips.end()) {</span>
<a href="#l27.283"></a><span id="l27.283" class="difflineplus">+    if (std::find(key-&gt;subkey_fps.begin(), key-&gt;subkey_fps.end(), fp) !=</span>
<a href="#l27.284"></a><span id="l27.284" class="difflineplus">+        key-&gt;subkey_fps.end()) {</span>
<a href="#l27.285"></a><span id="l27.285">         return true;</span>
<a href="#l27.286"></a><span id="l27.286">     }</span>
<a href="#l27.287"></a><span id="l27.287"> </span>
<a href="#l27.288"></a><span id="l27.288">     try {</span>
<a href="#l27.289"></a><span id="l27.289" class="difflineminus">-        key-&gt;subkey_grips.push_back(grip);</span>
<a href="#l27.290"></a><span id="l27.290" class="difflineplus">+        key-&gt;subkey_fps.push_back(fp);</span>
<a href="#l27.291"></a><span id="l27.291">         return true;</span>
<a href="#l27.292"></a><span id="l27.292">     } catch (const std::exception &amp;e) {</span>
<a href="#l27.293"></a><span id="l27.293">         RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l27.294"></a><span id="l27.294">         return false;</span>
<a href="#l27.295"></a><span id="l27.295">     }</span>
<a href="#l27.296"></a><span id="l27.296"> }</span>
<a href="#l27.297"></a><span id="l27.297"> </span>
<a href="#l27.298"></a><span id="l27.298"> void</span>
<a href="#l27.299"></a><span id="l27.299" class="difflineminus">-pgp_key_remove_subkey_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip)</span>
<a href="#l27.300"></a><span id="l27.300" class="difflineplus">+pgp_key_remove_subkey_fp(pgp_key_t *key, const pgp_fingerprint_t &amp;fp)</span>
<a href="#l27.301"></a><span id="l27.301"> {</span>
<a href="#l27.302"></a><span id="l27.302" class="difflineminus">-    auto it = std::find(key-&gt;subkey_grips.begin(), key-&gt;subkey_grips.end(), grip);</span>
<a href="#l27.303"></a><span id="l27.303" class="difflineminus">-    if (it != key-&gt;subkey_grips.end()) {</span>
<a href="#l27.304"></a><span id="l27.304" class="difflineminus">-        key-&gt;subkey_grips.erase(it);</span>
<a href="#l27.305"></a><span id="l27.305" class="difflineplus">+    auto it = std::find(key-&gt;subkey_fps.begin(), key-&gt;subkey_fps.end(), fp);</span>
<a href="#l27.306"></a><span id="l27.306" class="difflineplus">+    if (it != key-&gt;subkey_fps.end()) {</span>
<a href="#l27.307"></a><span id="l27.307" class="difflineplus">+        key-&gt;subkey_fps.erase(it);</span>
<a href="#l27.308"></a><span id="l27.308">     }</span>
<a href="#l27.309"></a><span id="l27.309"> }</span>
<a href="#l27.310"></a><span id="l27.310"> </span>
<a href="#l27.311"></a><span id="l27.311" class="difflineminus">-const pgp_key_grip_t &amp;</span>
<a href="#l27.312"></a><span id="l27.312" class="difflineminus">-pgp_key_get_subkey_grip(const pgp_key_t *key, size_t idx)</span>
<a href="#l27.313"></a><span id="l27.313" class="difflineplus">+const pgp_fingerprint_t &amp;</span>
<a href="#l27.314"></a><span id="l27.314" class="difflineplus">+pgp_key_get_subkey_fp(const pgp_key_t *key, size_t idx)</span>
<a href="#l27.315"></a><span id="l27.315"> {</span>
<a href="#l27.316"></a><span id="l27.316" class="difflineminus">-    return key-&gt;subkey_grips[idx];</span>
<a href="#l27.317"></a><span id="l27.317" class="difflineplus">+    return key-&gt;subkey_fps[idx];</span>
<a href="#l27.318"></a><span id="l27.318"> }</span>
<a href="#l27.319"></a><span id="l27.319"> </span>
<a href="#l27.320"></a><span id="l27.320"> pgp_key_t *</span>
<a href="#l27.321"></a><span id="l27.321"> pgp_key_get_subkey(const pgp_key_t *key, rnp_key_store_t *store, size_t idx)</span>
<a href="#l27.322"></a><span id="l27.322"> {</span>
<a href="#l27.323"></a><span id="l27.323">     try {</span>
<a href="#l27.324"></a><span id="l27.324" class="difflineminus">-        const pgp_key_grip_t &amp;grip = pgp_key_get_subkey_grip(key, idx);</span>
<a href="#l27.325"></a><span id="l27.325" class="difflineminus">-        return rnp_key_store_get_key_by_grip(store, grip);</span>
<a href="#l27.326"></a><span id="l27.326" class="difflineplus">+        const pgp_fingerprint_t &amp;fp = pgp_key_get_subkey_fp(key, idx);</span>
<a href="#l27.327"></a><span id="l27.327" class="difflineplus">+        return rnp_key_store_get_key_by_fpr(store, fp);</span>
<a href="#l27.328"></a><span id="l27.328">     } catch (const std::exception &amp;e) {</span>
<a href="#l27.329"></a><span id="l27.329">         RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l27.330"></a><span id="l27.330">         return NULL;</span>
<a href="#l27.331"></a><span id="l27.331">     }</span>
<a href="#l27.332"></a><span id="l27.332"> }</span>
<a href="#l27.333"></a><span id="l27.333"> </span>
<a href="#l27.334"></a><span id="l27.334"> pgp_key_flags_t</span>
<a href="#l27.335"></a><span id="l27.335"> pgp_pk_alg_capabilities(pgp_pubkey_alg_t alg)</span>
<a href="#l27.336"></a><span id="l27.336" class="difflineat">@@ -1738,17 +1726,20 @@ update_sig_expiration(pgp_signature_t *d</span>
<a href="#l27.337"></a><span id="l27.337">     } else {</span>
<a href="#l27.338"></a><span id="l27.338">         signature_set_key_expiration(dst, expiry);</span>
<a href="#l27.339"></a><span id="l27.339">     }</span>
<a href="#l27.340"></a><span id="l27.340">     signature_set_creation(dst, time(NULL));</span>
<a href="#l27.341"></a><span id="l27.341">     return true;</span>
<a href="#l27.342"></a><span id="l27.342"> }</span>
<a href="#l27.343"></a><span id="l27.343"> </span>
<a href="#l27.344"></a><span id="l27.344"> bool</span>
<a href="#l27.345"></a><span id="l27.345" class="difflineminus">-pgp_key_set_expiration(pgp_key_t *key, pgp_key_t *seckey, uint32_t expiry)</span>
<a href="#l27.346"></a><span id="l27.346" class="difflineplus">+pgp_key_set_expiration(pgp_key_t *                    key,</span>
<a href="#l27.347"></a><span id="l27.347" class="difflineplus">+                       pgp_key_t *                    seckey,</span>
<a href="#l27.348"></a><span id="l27.348" class="difflineplus">+                       uint32_t                       expiry,</span>
<a href="#l27.349"></a><span id="l27.349" class="difflineplus">+                       const pgp_password_provider_t *prov)</span>
<a href="#l27.350"></a><span id="l27.350"> {</span>
<a href="#l27.351"></a><span id="l27.351">     if (!pgp_key_is_primary_key(key)) {</span>
<a href="#l27.352"></a><span id="l27.352">         RNP_LOG(&quot;Not a primary key&quot;);</span>
<a href="#l27.353"></a><span id="l27.353">         return false;</span>
<a href="#l27.354"></a><span id="l27.354">     }</span>
<a href="#l27.355"></a><span id="l27.355"> </span>
<a href="#l27.356"></a><span id="l27.356">     /* locate the latest valid certification */</span>
<a href="#l27.357"></a><span id="l27.357">     pgp_subsig_t *subsig = pgp_key_latest_selfsig(key, PGP_SIG_SUBPKT_UNKNOWN);</span>
<a href="#l27.358"></a><span id="l27.358" class="difflineat">@@ -1756,22 +1747,27 @@ pgp_key_set_expiration(pgp_key_t *key, p</span>
<a href="#l27.359"></a><span id="l27.359">         RNP_LOG(&quot;No valid self-signature&quot;);</span>
<a href="#l27.360"></a><span id="l27.360">         return false;</span>
<a href="#l27.361"></a><span id="l27.361">     }</span>
<a href="#l27.362"></a><span id="l27.362"> </span>
<a href="#l27.363"></a><span id="l27.363">     /* update signature and re-sign it */</span>
<a href="#l27.364"></a><span id="l27.364">     if (!expiry &amp;&amp; !signature_has_key_expiration(&amp;subsig-&gt;sig)) {</span>
<a href="#l27.365"></a><span id="l27.365">         return true;</span>
<a href="#l27.366"></a><span id="l27.366">     }</span>
<a href="#l27.367"></a><span id="l27.367" class="difflineminus">-    pgp_signature_t newsig = {};</span>
<a href="#l27.368"></a><span id="l27.368" class="difflineminus">-    if (!update_sig_expiration(&amp;newsig, &amp;subsig-&gt;sig, expiry)) {</span>
<a href="#l27.369"></a><span id="l27.369" class="difflineplus">+</span>
<a href="#l27.370"></a><span id="l27.370" class="difflineplus">+    bool locked = pgp_key_is_locked(seckey);</span>
<a href="#l27.371"></a><span id="l27.371" class="difflineplus">+    if (locked &amp;&amp; !pgp_key_unlock(seckey, prov)) {</span>
<a href="#l27.372"></a><span id="l27.372" class="difflineplus">+        RNP_LOG(&quot;Failed to unlock secret key&quot;);</span>
<a href="#l27.373"></a><span id="l27.373">         return false;</span>
<a href="#l27.374"></a><span id="l27.374">     }</span>
<a href="#l27.375"></a><span id="l27.375" class="difflineminus">-</span>
<a href="#l27.376"></a><span id="l27.376" class="difflineminus">-    bool res = false;</span>
<a href="#l27.377"></a><span id="l27.377" class="difflineplus">+    pgp_signature_t newsig = {};</span>
<a href="#l27.378"></a><span id="l27.378" class="difflineplus">+    bool            res = false;</span>
<a href="#l27.379"></a><span id="l27.379" class="difflineplus">+    if (!update_sig_expiration(&amp;newsig, &amp;subsig-&gt;sig, expiry)) {</span>
<a href="#l27.380"></a><span id="l27.380" class="difflineplus">+        goto done;</span>
<a href="#l27.381"></a><span id="l27.381" class="difflineplus">+    }</span>
<a href="#l27.382"></a><span id="l27.382">     if (pgp_sig_is_certification(subsig)) {</span>
<a href="#l27.383"></a><span id="l27.383">         pgp_userid_t *uid = pgp_key_get_userid(key, subsig-&gt;uid);</span>
<a href="#l27.384"></a><span id="l27.384">         if (!uid) {</span>
<a href="#l27.385"></a><span id="l27.385">             RNP_LOG(&quot;uid not found&quot;);</span>
<a href="#l27.386"></a><span id="l27.386">             goto done;</span>
<a href="#l27.387"></a><span id="l27.387">         }</span>
<a href="#l27.388"></a><span id="l27.388">         if (!signature_calculate_certification(</span>
<a href="#l27.389"></a><span id="l27.389">               pgp_key_get_pkt(key), &amp;uid-&gt;pkt, &amp;newsig, pgp_key_get_pkt(seckey))) {</span>
<a href="#l27.390"></a><span id="l27.390" class="difflineat">@@ -1790,64 +1786,86 @@ pgp_key_set_expiration(pgp_key_t *key, p</span>
<a href="#l27.391"></a><span id="l27.391">     /* replace signature, first for secret key since it may be replaced in public */</span>
<a href="#l27.392"></a><span id="l27.392">     if (pgp_key_has_signature(seckey, &amp;subsig-&gt;sig)) {</span>
<a href="#l27.393"></a><span id="l27.393">         res = pgp_key_replace_signature(seckey, &amp;subsig-&gt;sig, &amp;newsig) &amp;&amp;</span>
<a href="#l27.394"></a><span id="l27.394">               pgp_key_refresh_data(key);</span>
<a href="#l27.395"></a><span id="l27.395">     }</span>
<a href="#l27.396"></a><span id="l27.396">     res = res &amp;&amp; pgp_key_replace_signature(key, &amp;subsig-&gt;sig, &amp;newsig) &amp;&amp;</span>
<a href="#l27.397"></a><span id="l27.397">           pgp_key_refresh_data(key);</span>
<a href="#l27.398"></a><span id="l27.398"> done:</span>
<a href="#l27.399"></a><span id="l27.399" class="difflineplus">+    if (locked) {</span>
<a href="#l27.400"></a><span id="l27.400" class="difflineplus">+        pgp_key_lock(seckey);</span>
<a href="#l27.401"></a><span id="l27.401" class="difflineplus">+    }</span>
<a href="#l27.402"></a><span id="l27.402">     free_signature(&amp;newsig);</span>
<a href="#l27.403"></a><span id="l27.403">     return res;</span>
<a href="#l27.404"></a><span id="l27.404"> }</span>
<a href="#l27.405"></a><span id="l27.405"> </span>
<a href="#l27.406"></a><span id="l27.406"> bool</span>
<a href="#l27.407"></a><span id="l27.407" class="difflineminus">-pgp_subkey_set_expiration(pgp_key_t *sub,</span>
<a href="#l27.408"></a><span id="l27.408" class="difflineminus">-                          pgp_key_t *primsec,</span>
<a href="#l27.409"></a><span id="l27.409" class="difflineminus">-                          pgp_key_t *secsub,</span>
<a href="#l27.410"></a><span id="l27.410" class="difflineminus">-                          uint32_t   expiry)</span>
<a href="#l27.411"></a><span id="l27.411" class="difflineplus">+pgp_subkey_set_expiration(pgp_key_t *                    sub,</span>
<a href="#l27.412"></a><span id="l27.412" class="difflineplus">+                          pgp_key_t *                    primsec,</span>
<a href="#l27.413"></a><span id="l27.413" class="difflineplus">+                          pgp_key_t *                    secsub,</span>
<a href="#l27.414"></a><span id="l27.414" class="difflineplus">+                          uint32_t                       expiry,</span>
<a href="#l27.415"></a><span id="l27.415" class="difflineplus">+                          const pgp_password_provider_t *prov)</span>
<a href="#l27.416"></a><span id="l27.416"> {</span>
<a href="#l27.417"></a><span id="l27.417">     if (!pgp_key_is_subkey(sub)) {</span>
<a href="#l27.418"></a><span id="l27.418">         RNP_LOG(&quot;Not a subkey&quot;);</span>
<a href="#l27.419"></a><span id="l27.419">         return false;</span>
<a href="#l27.420"></a><span id="l27.420">     }</span>
<a href="#l27.421"></a><span id="l27.421"> </span>
<a href="#l27.422"></a><span id="l27.422">     /* find the latest valid subkey binding */</span>
<a href="#l27.423"></a><span id="l27.423" class="difflineminus">-    pgp_subsig_t *subsig = NULL;</span>
<a href="#l27.424"></a><span id="l27.424" class="difflineminus">-    subsig = pgp_key_latest_binding(sub, true);</span>
<a href="#l27.425"></a><span id="l27.425" class="difflineplus">+    pgp_subsig_t *subsig = pgp_key_latest_binding(sub, true);</span>
<a href="#l27.426"></a><span id="l27.426">     if (!subsig) {</span>
<a href="#l27.427"></a><span id="l27.427">         RNP_LOG(&quot;No valid subkey binding&quot;);</span>
<a href="#l27.428"></a><span id="l27.428">         return false;</span>
<a href="#l27.429"></a><span id="l27.429">     }</span>
<a href="#l27.430"></a><span id="l27.430">     if (!expiry &amp;&amp; !signature_has_key_expiration(&amp;subsig-&gt;sig)) {</span>
<a href="#l27.431"></a><span id="l27.431">         return true;</span>
<a href="#l27.432"></a><span id="l27.432">     }</span>
<a href="#l27.433"></a><span id="l27.433" class="difflineminus">-    /* update signature and re-sign */</span>
<a href="#l27.434"></a><span id="l27.434" class="difflineplus">+</span>
<a href="#l27.435"></a><span id="l27.435" class="difflineplus">+    bool res = false;</span>
<a href="#l27.436"></a><span id="l27.436" class="difflineplus">+    bool subsign = pgp_key_get_flags(secsub) &amp; PGP_KF_SIGN;</span>
<a href="#l27.437"></a><span id="l27.437" class="difflineplus">+    bool locked = pgp_key_is_locked(primsec);</span>
<a href="#l27.438"></a><span id="l27.438" class="difflineplus">+    if (locked &amp;&amp; !pgp_key_unlock(primsec, prov)) {</span>
<a href="#l27.439"></a><span id="l27.439" class="difflineplus">+        RNP_LOG(&quot;Failed to unlock primary key&quot;);</span>
<a href="#l27.440"></a><span id="l27.440" class="difflineplus">+        return false;</span>
<a href="#l27.441"></a><span id="l27.441" class="difflineplus">+    }</span>
<a href="#l27.442"></a><span id="l27.442">     pgp_signature_t newsig = {};</span>
<a href="#l27.443"></a><span id="l27.443" class="difflineminus">-    if (!update_sig_expiration(&amp;newsig, &amp;subsig-&gt;sig, expiry)) {</span>
<a href="#l27.444"></a><span id="l27.444" class="difflineminus">-        return false;</span>
<a href="#l27.445"></a><span id="l27.445" class="difflineplus">+    bool            sublocked = false;</span>
<a href="#l27.446"></a><span id="l27.446" class="difflineplus">+    if (subsign &amp;&amp; pgp_key_is_locked(secsub)) {</span>
<a href="#l27.447"></a><span id="l27.447" class="difflineplus">+        if (!pgp_key_unlock(secsub, prov)) {</span>
<a href="#l27.448"></a><span id="l27.448" class="difflineplus">+            RNP_LOG(&quot;Failed to unlock subkey&quot;);</span>
<a href="#l27.449"></a><span id="l27.449" class="difflineplus">+            goto done;</span>
<a href="#l27.450"></a><span id="l27.450" class="difflineplus">+        }</span>
<a href="#l27.451"></a><span id="l27.451" class="difflineplus">+        sublocked = true;</span>
<a href="#l27.452"></a><span id="l27.452">     }</span>
<a href="#l27.453"></a><span id="l27.453"> </span>
<a href="#l27.454"></a><span id="l27.454" class="difflineminus">-    bool res = false;</span>
<a href="#l27.455"></a><span id="l27.455" class="difflineminus">-    if (!signature_calculate_binding(pgp_key_get_pkt(primsec),</span>
<a href="#l27.456"></a><span id="l27.456" class="difflineminus">-                                     pgp_key_get_pkt(secsub),</span>
<a href="#l27.457"></a><span id="l27.457" class="difflineminus">-                                     &amp;newsig,</span>
<a href="#l27.458"></a><span id="l27.458" class="difflineminus">-                                     pgp_key_get_flags(secsub) &amp; PGP_KF_SIGN)) {</span>
<a href="#l27.459"></a><span id="l27.459" class="difflineplus">+    /* update signature and re-sign */</span>
<a href="#l27.460"></a><span id="l27.460" class="difflineplus">+    if (!update_sig_expiration(&amp;newsig, &amp;subsig-&gt;sig, expiry)) {</span>
<a href="#l27.461"></a><span id="l27.461" class="difflineplus">+        goto done;</span>
<a href="#l27.462"></a><span id="l27.462" class="difflineplus">+    }</span>
<a href="#l27.463"></a><span id="l27.463" class="difflineplus">+    if (!signature_calculate_binding(</span>
<a href="#l27.464"></a><span id="l27.464" class="difflineplus">+          pgp_key_get_pkt(primsec), pgp_key_get_pkt(secsub), &amp;newsig, subsign)) {</span>
<a href="#l27.465"></a><span id="l27.465">         RNP_LOG(&quot;failed to calculate signature&quot;);</span>
<a href="#l27.466"></a><span id="l27.466">         goto done;</span>
<a href="#l27.467"></a><span id="l27.467">     }</span>
<a href="#l27.468"></a><span id="l27.468"> </span>
<a href="#l27.469"></a><span id="l27.469">     /* replace signature, first for the secret key since it may be replaced in public */</span>
<a href="#l27.470"></a><span id="l27.470">     if (pgp_key_has_signature(secsub, &amp;subsig-&gt;sig)) {</span>
<a href="#l27.471"></a><span id="l27.471">         res = pgp_key_replace_signature(secsub, &amp;subsig-&gt;sig, &amp;newsig) &amp;&amp;</span>
<a href="#l27.472"></a><span id="l27.472">               pgp_subkey_refresh_data(secsub, primsec);</span>
<a href="#l27.473"></a><span id="l27.473">     }</span>
<a href="#l27.474"></a><span id="l27.474">     res = res &amp;&amp; pgp_key_replace_signature(sub, &amp;subsig-&gt;sig, &amp;newsig) &amp;&amp;</span>
<a href="#l27.475"></a><span id="l27.475">           pgp_subkey_refresh_data(sub, primsec);</span>
<a href="#l27.476"></a><span id="l27.476"> done:</span>
<a href="#l27.477"></a><span id="l27.477" class="difflineplus">+    if (locked) {</span>
<a href="#l27.478"></a><span id="l27.478" class="difflineplus">+        pgp_key_lock(primsec);</span>
<a href="#l27.479"></a><span id="l27.479" class="difflineplus">+    }</span>
<a href="#l27.480"></a><span id="l27.480" class="difflineplus">+    if (sublocked) {</span>
<a href="#l27.481"></a><span id="l27.481" class="difflineplus">+        pgp_key_lock(secsub);</span>
<a href="#l27.482"></a><span id="l27.482" class="difflineplus">+    }</span>
<a href="#l27.483"></a><span id="l27.483">     free_signature(&amp;newsig);</span>
<a href="#l27.484"></a><span id="l27.484">     return res;</span>
<a href="#l27.485"></a><span id="l27.485"> }</span>
<a href="#l27.486"></a><span id="l27.486"> </span>
<a href="#l27.487"></a><span id="l27.487"> static size_t</span>
<a href="#l27.488"></a><span id="l27.488"> pgp_key_write_signatures(pgp_dest_t *dst, const pgp_key_t *key, uint32_t uid, size_t start)</span>
<a href="#l27.489"></a><span id="l27.489"> {</span>
<a href="#l27.490"></a><span id="l27.490">     for (size_t i = start; i &lt; pgp_key_get_subsig_count(key); i++) {</span>
<a href="#l27.491"></a><span id="l27.491" class="difflineat">@@ -1894,23 +1912,22 @@ pgp_key_write_xfer(pgp_dest_t *dst, cons</span>
<a href="#l27.492"></a><span id="l27.492">         return false;</span>
<a href="#l27.493"></a><span id="l27.493">     }</span>
<a href="#l27.494"></a><span id="l27.494"> </span>
<a href="#l27.495"></a><span id="l27.495">     if (!keyring) {</span>
<a href="#l27.496"></a><span id="l27.496">         return !dst-&gt;werr;</span>
<a href="#l27.497"></a><span id="l27.497">     }</span>
<a href="#l27.498"></a><span id="l27.498"> </span>
<a href="#l27.499"></a><span id="l27.499">     // Export subkeys</span>
<a href="#l27.500"></a><span id="l27.500" class="difflineminus">-    for (auto &amp;grip : key-&gt;subkey_grips) {</span>
<a href="#l27.501"></a><span id="l27.501" class="difflineminus">-        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(keyring, grip);</span>
<a href="#l27.502"></a><span id="l27.502" class="difflineplus">+    for (auto &amp;fp : key-&gt;subkey_fps) {</span>
<a href="#l27.503"></a><span id="l27.503" class="difflineplus">+        const pgp_key_t *subkey = rnp_key_store_get_key_by_fpr(keyring, fp);</span>
<a href="#l27.504"></a><span id="l27.504">         if (!subkey) {</span>
<a href="#l27.505"></a><span id="l27.505" class="difflineminus">-            char griphex[PGP_KEY_GRIP_SIZE * 2 + 1] = {0};</span>
<a href="#l27.506"></a><span id="l27.506" class="difflineminus">-            rnp_hex_encode(</span>
<a href="#l27.507"></a><span id="l27.507" class="difflineminus">-              grip.data(), grip.size(), griphex, sizeof(griphex), RNP_HEX_LOWERCASE);</span>
<a href="#l27.508"></a><span id="l27.508" class="difflineminus">-            RNP_LOG(&quot;Warning! Subkey %s not found.&quot;, griphex);</span>
<a href="#l27.509"></a><span id="l27.509" class="difflineplus">+            char fphex[PGP_FINGERPRINT_SIZE * 2 + 1] = {0};</span>
<a href="#l27.510"></a><span id="l27.510" class="difflineplus">+            rnp_hex_encode(fp.fingerprint, fp.length, fphex, sizeof(fphex), RNP_HEX_LOWERCASE);</span>
<a href="#l27.511"></a><span id="l27.511" class="difflineplus">+            RNP_LOG(&quot;Warning! Subkey %s not found.&quot;, fphex);</span>
<a href="#l27.512"></a><span id="l27.512">             continue;</span>
<a href="#l27.513"></a><span id="l27.513">         }</span>
<a href="#l27.514"></a><span id="l27.514">         if (!pgp_key_write_packets(subkey, dst)) {</span>
<a href="#l27.515"></a><span id="l27.515">             RNP_LOG(&quot;Error occured when exporting a subkey&quot;);</span>
<a href="#l27.516"></a><span id="l27.516">             return false;</span>
<a href="#l27.517"></a><span id="l27.517">         }</span>
<a href="#l27.518"></a><span id="l27.518">     }</span>
<a href="#l27.519"></a><span id="l27.519">     return !dst-&gt;werr;</span>
<a href="#l27.520"></a><span id="l27.520" class="difflineat">@@ -1925,20 +1942,20 @@ find_suitable_key(pgp_op_t            op</span>
<a href="#l27.521"></a><span id="l27.521">     assert(desired_usage);</span>
<a href="#l27.522"></a><span id="l27.522">     if (!key) {</span>
<a href="#l27.523"></a><span id="l27.523">         return NULL;</span>
<a href="#l27.524"></a><span id="l27.524">     }</span>
<a href="#l27.525"></a><span id="l27.525">     if (pgp_key_get_flags(key) &amp; desired_usage) {</span>
<a href="#l27.526"></a><span id="l27.526">         return key;</span>
<a href="#l27.527"></a><span id="l27.527">     }</span>
<a href="#l27.528"></a><span id="l27.528">     pgp_key_request_ctx_t ctx{.op = op, .secret = pgp_key_is_secret(key)};</span>
<a href="#l27.529"></a><span id="l27.529" class="difflineminus">-    ctx.search.type = PGP_KEY_SEARCH_GRIP;</span>
<a href="#l27.530"></a><span id="l27.530" class="difflineplus">+    ctx.search.type = PGP_KEY_SEARCH_FINGERPRINT;</span>
<a href="#l27.531"></a><span id="l27.531"> </span>
<a href="#l27.532"></a><span id="l27.532" class="difflineminus">-    for (auto &amp;grip : key-&gt;subkey_grips) {</span>
<a href="#l27.533"></a><span id="l27.533" class="difflineminus">-        ctx.search.by.grip = grip;</span>
<a href="#l27.534"></a><span id="l27.534" class="difflineplus">+    for (auto &amp;fp : key-&gt;subkey_fps) {</span>
<a href="#l27.535"></a><span id="l27.535" class="difflineplus">+        ctx.search.by.fingerprint = fp;</span>
<a href="#l27.536"></a><span id="l27.536">         pgp_key_t *subkey = pgp_request_key(key_provider, &amp;ctx);</span>
<a href="#l27.537"></a><span id="l27.537">         if (subkey &amp;&amp; (pgp_key_get_flags(subkey) &amp; desired_usage)) {</span>
<a href="#l27.538"></a><span id="l27.538">             return subkey;</span>
<a href="#l27.539"></a><span id="l27.539">         }</span>
<a href="#l27.540"></a><span id="l27.540">     }</span>
<a href="#l27.541"></a><span id="l27.541">     return NULL;</span>
<a href="#l27.542"></a><span id="l27.542"> }</span>
<a href="#l27.543"></a><span id="l27.543"> </span>
<a href="#l27.544"></a><span id="l27.544" class="difflineat">@@ -2070,35 +2087,35 @@ void</span>
<a href="#l27.545"></a><span id="l27.545"> pgp_key_validate(pgp_key_t *key, rnp_key_store_t *keyring)</span>
<a href="#l27.546"></a><span id="l27.546"> {</span>
<a href="#l27.547"></a><span id="l27.547">     key-&gt;valid = false;</span>
<a href="#l27.548"></a><span id="l27.548">     key-&gt;validated = false;</span>
<a href="#l27.549"></a><span id="l27.549">     if (!pgp_key_is_subkey(key)) {</span>
<a href="#l27.550"></a><span id="l27.550">         pgp_key_validate_primary(key, keyring);</span>
<a href="#l27.551"></a><span id="l27.551">     } else {</span>
<a href="#l27.552"></a><span id="l27.552">         pgp_key_validate_subkey(</span>
<a href="#l27.553"></a><span id="l27.553" class="difflineminus">-          key, rnp_key_store_get_key_by_grip(keyring, pgp_key_get_primary_grip(key)));</span>
<a href="#l27.554"></a><span id="l27.554" class="difflineplus">+          key, rnp_key_store_get_key_by_fpr(keyring, pgp_key_get_primary_fp(key)));</span>
<a href="#l27.555"></a><span id="l27.555">     }</span>
<a href="#l27.556"></a><span id="l27.556"> }</span>
<a href="#l27.557"></a><span id="l27.557"> </span>
<a href="#l27.558"></a><span id="l27.558"> void</span>
<a href="#l27.559"></a><span id="l27.559"> pgp_key_revalidate_updated(pgp_key_t *key, rnp_key_store_t *keyring)</span>
<a href="#l27.560"></a><span id="l27.560"> {</span>
<a href="#l27.561"></a><span id="l27.561">     if (pgp_key_is_subkey(key)) {</span>
<a href="#l27.562"></a><span id="l27.562">         pgp_key_t *primary = rnp_key_store_get_primary_key(keyring, key);</span>
<a href="#l27.563"></a><span id="l27.563">         if (primary) {</span>
<a href="#l27.564"></a><span id="l27.564">             pgp_key_revalidate_updated(primary, keyring);</span>
<a href="#l27.565"></a><span id="l27.565">         }</span>
<a href="#l27.566"></a><span id="l27.566">         return;</span>
<a href="#l27.567"></a><span id="l27.567">     }</span>
<a href="#l27.568"></a><span id="l27.568"> </span>
<a href="#l27.569"></a><span id="l27.569">     pgp_key_validate(key, keyring);</span>
<a href="#l27.570"></a><span id="l27.570">     /* validate/re-validate all subkeys as well */</span>
<a href="#l27.571"></a><span id="l27.571" class="difflineminus">-    for (auto &amp;grip : key-&gt;subkey_grips) {</span>
<a href="#l27.572"></a><span id="l27.572" class="difflineminus">-        pgp_key_t *subkey = rnp_key_store_get_key_by_grip(keyring, grip);</span>
<a href="#l27.573"></a><span id="l27.573" class="difflineplus">+    for (auto &amp;fp : key-&gt;subkey_fps) {</span>
<a href="#l27.574"></a><span id="l27.574" class="difflineplus">+        pgp_key_t *subkey = rnp_key_store_get_key_by_fpr(keyring, fp);</span>
<a href="#l27.575"></a><span id="l27.575">         if (subkey) {</span>
<a href="#l27.576"></a><span id="l27.576">             pgp_key_validate_subkey(subkey, key);</span>
<a href="#l27.577"></a><span id="l27.577">             pgp_subkey_refresh_data(subkey, key);</span>
<a href="#l27.578"></a><span id="l27.578">         }</span>
<a href="#l27.579"></a><span id="l27.579">     }</span>
<a href="#l27.580"></a><span id="l27.580"> </span>
<a href="#l27.581"></a><span id="l27.581">     if (!pgp_key_refresh_data(key)) {</span>
<a href="#l27.582"></a><span id="l27.582">         RNP_LOG(&quot;Failed to refresh key data&quot;);</span>
<a href="#l27.583"></a><span id="l27.583" class="difflineat">@@ -2284,26 +2301,26 @@ pgp_key_t::operator=(pgp_key_t &amp;&amp;src)</span>
<a href="#l27.584"></a><span id="l27.584">     if (&amp;src == this) {</span>
<a href="#l27.585"></a><span id="l27.585">         return *this;</span>
<a href="#l27.586"></a><span id="l27.586">     }</span>
<a href="#l27.587"></a><span id="l27.587">     uids = std::move(src.uids);</span>
<a href="#l27.588"></a><span id="l27.588">     subsigs = std::move(src.subsigs);</span>
<a href="#l27.589"></a><span id="l27.589">     pgp_key_clear_revokes(this);</span>
<a href="#l27.590"></a><span id="l27.590">     revokes = std::move(src.revokes);</span>
<a href="#l27.591"></a><span id="l27.591"> </span>
<a href="#l27.592"></a><span id="l27.592" class="difflineminus">-    subkey_grips = std::move(src.subkey_grips);</span>
<a href="#l27.593"></a><span id="l27.593" class="difflineminus">-    primary_grip = std::move(src.primary_grip);</span>
<a href="#l27.594"></a><span id="l27.594" class="difflineminus">-    primary_grip_set = src.primary_grip_set;</span>
<a href="#l27.595"></a><span id="l27.595" class="difflineplus">+    subkey_fps = std::move(src.subkey_fps);</span>
<a href="#l27.596"></a><span id="l27.596" class="difflineplus">+    primary_fp = std::move(src.primary_fp);</span>
<a href="#l27.597"></a><span id="l27.597" class="difflineplus">+    primary_fp_set = src.primary_fp_set;</span>
<a href="#l27.598"></a><span id="l27.598">     expiration = src.expiration;</span>
<a href="#l27.599"></a><span id="l27.599">     free_key_pkt(&amp;pkt);</span>
<a href="#l27.600"></a><span id="l27.600">     pkt = src.pkt;</span>
<a href="#l27.601"></a><span id="l27.601">     src.pkt = {};</span>
<a href="#l27.602"></a><span id="l27.602">     rawpkt = std::move(src.rawpkt);</span>
<a href="#l27.603"></a><span id="l27.603">     key_flags = src.key_flags;</span>
<a href="#l27.604"></a><span id="l27.604" class="difflineminus">-    memcpy(keyid, src.keyid, sizeof(keyid));</span>
<a href="#l27.605"></a><span id="l27.605" class="difflineplus">+    keyid = src.keyid;</span>
<a href="#l27.606"></a><span id="l27.606">     fingerprint = src.fingerprint;</span>
<a href="#l27.607"></a><span id="l27.607">     grip = std::move(src.grip);</span>
<a href="#l27.608"></a><span id="l27.608">     uid0 = src.uid0;</span>
<a href="#l27.609"></a><span id="l27.609">     uid0_set = src.uid0_set;</span>
<a href="#l27.610"></a><span id="l27.610">     revoked = src.revoked;</span>
<a href="#l27.611"></a><span id="l27.611">     revocation = src.revocation;</span>
<a href="#l27.612"></a><span id="l27.612">     src.revocation = {};</span>
<a href="#l27.613"></a><span id="l27.613">     format = src.format;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/third_party/rnp/src/lib/pgp-key.h</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/third_party/rnp/src/lib/pgp-key.h</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -57,36 +57,37 @@</span>
<a href="#l28.4"></a><span id="l28.4"> #include &lt;vector&gt;</span>
<a href="#l28.5"></a><span id="l28.5"> #include &quot;pass-provider.h&quot;</span>
<a href="#l28.6"></a><span id="l28.6"> #include &lt;rekey/rnp_key_store.h&gt;</span>
<a href="#l28.7"></a><span id="l28.7"> #include &quot;crypto/symmetric.h&quot;</span>
<a href="#l28.8"></a><span id="l28.8"> #include &quot;types.h&quot;</span>
<a href="#l28.9"></a><span id="l28.9"> </span>
<a href="#l28.10"></a><span id="l28.10"> /* describes a user's key */</span>
<a href="#l28.11"></a><span id="l28.11"> struct pgp_key_t {</span>
<a href="#l28.12"></a><span id="l28.12" class="difflineminus">-    std::vector&lt;pgp_userid_t&gt;   uids;         /* array of user ids */</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineminus">-    std::vector&lt;pgp_subsig_t&gt;   subsigs;      /* array of key signatures */</span>
<a href="#l28.14"></a><span id="l28.14" class="difflineminus">-    std::vector&lt;pgp_revoke_t&gt;   revokes;      /* array of revocations */</span>
<a href="#l28.15"></a><span id="l28.15" class="difflineminus">-    std::vector&lt;pgp_key_grip_t&gt; subkey_grips; /* array of subkey grips (for primary keys) */</span>
<a href="#l28.16"></a><span id="l28.16" class="difflineminus">-    pgp_key_grip_t              primary_grip; /* grip of primary key (for subkeys) */</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineminus">-    bool                        primary_grip_set;</span>
<a href="#l28.18"></a><span id="l28.18" class="difflineminus">-    time_t                      expiration; /* key expiration time, if available */</span>
<a href="#l28.19"></a><span id="l28.19" class="difflineminus">-    pgp_key_pkt_t               pkt;        /* pubkey/seckey data packet */</span>
<a href="#l28.20"></a><span id="l28.20" class="difflineminus">-    pgp_rawpacket_t             rawpkt;     /* key raw packet */</span>
<a href="#l28.21"></a><span id="l28.21" class="difflineminus">-    uint8_t                     key_flags;  /* key flags */</span>
<a href="#l28.22"></a><span id="l28.22" class="difflineminus">-    uint8_t                     keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l28.23"></a><span id="l28.23" class="difflineminus">-    pgp_fingerprint_t           fingerprint;</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineminus">-    pgp_key_grip_t              grip;</span>
<a href="#l28.25"></a><span id="l28.25" class="difflineminus">-    uint32_t                    uid0;         /* primary uid index in uids array */</span>
<a href="#l28.26"></a><span id="l28.26" class="difflineminus">-    unsigned                    uid0_set : 1; /* flag for the above */</span>
<a href="#l28.27"></a><span id="l28.27" class="difflineminus">-    uint8_t                     revoked;      /* key has been revoked */</span>
<a href="#l28.28"></a><span id="l28.28" class="difflineminus">-    pgp_revoke_t                revocation;   /* revocation reason */</span>
<a href="#l28.29"></a><span id="l28.29" class="difflineminus">-    pgp_key_store_format_t      format;       /* the format of the key in packets[0] */</span>
<a href="#l28.30"></a><span id="l28.30" class="difflineminus">-    bool                        valid;        /* this key is valid and usable */</span>
<a href="#l28.31"></a><span id="l28.31" class="difflineminus">-    bool                        validated;    /* this key was validated */</span>
<a href="#l28.32"></a><span id="l28.32" class="difflineplus">+    std::vector&lt;pgp_userid_t&gt; uids;    /* array of user ids */</span>
<a href="#l28.33"></a><span id="l28.33" class="difflineplus">+    std::vector&lt;pgp_subsig_t&gt; subsigs; /* array of key signatures */</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineplus">+    std::vector&lt;pgp_revoke_t&gt; revokes; /* array of revocations */</span>
<a href="#l28.35"></a><span id="l28.35" class="difflineplus">+    std::vector&lt;pgp_fingerprint_t&gt;</span>
<a href="#l28.36"></a><span id="l28.36" class="difflineplus">+                           subkey_fps; /* array of subkey fingerprints (for primary keys) */</span>
<a href="#l28.37"></a><span id="l28.37" class="difflineplus">+    pgp_fingerprint_t      primary_fp; /* fingerprint of primary key (for subkeys) */</span>
<a href="#l28.38"></a><span id="l28.38" class="difflineplus">+    bool                   primary_fp_set;</span>
<a href="#l28.39"></a><span id="l28.39" class="difflineplus">+    time_t                 expiration; /* key expiration time, if available */</span>
<a href="#l28.40"></a><span id="l28.40" class="difflineplus">+    pgp_key_pkt_t          pkt;        /* pubkey/seckey data packet */</span>
<a href="#l28.41"></a><span id="l28.41" class="difflineplus">+    pgp_rawpacket_t        rawpkt;     /* key raw packet */</span>
<a href="#l28.42"></a><span id="l28.42" class="difflineplus">+    uint8_t                key_flags;  /* key flags */</span>
<a href="#l28.43"></a><span id="l28.43" class="difflineplus">+    pgp_key_id_t           keyid;</span>
<a href="#l28.44"></a><span id="l28.44" class="difflineplus">+    pgp_fingerprint_t      fingerprint;</span>
<a href="#l28.45"></a><span id="l28.45" class="difflineplus">+    pgp_key_grip_t         grip;</span>
<a href="#l28.46"></a><span id="l28.46" class="difflineplus">+    uint32_t               uid0;         /* primary uid index in uids array */</span>
<a href="#l28.47"></a><span id="l28.47" class="difflineplus">+    unsigned               uid0_set : 1; /* flag for the above */</span>
<a href="#l28.48"></a><span id="l28.48" class="difflineplus">+    uint8_t                revoked;      /* key has been revoked */</span>
<a href="#l28.49"></a><span id="l28.49" class="difflineplus">+    pgp_revoke_t           revocation;   /* revocation reason */</span>
<a href="#l28.50"></a><span id="l28.50" class="difflineplus">+    pgp_key_store_format_t format;       /* the format of the key in packets[0] */</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineplus">+    bool                   valid;        /* this key is valid and usable */</span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+    bool                   validated;    /* this key was validated */</span>
<a href="#l28.53"></a><span id="l28.53"> </span>
<a href="#l28.54"></a><span id="l28.54">     ~pgp_key_t();</span>
<a href="#l28.55"></a><span id="l28.55">     pgp_key_t() = default;</span>
<a href="#l28.56"></a><span id="l28.56">     pgp_key_t &amp;operator=(pgp_key_t &amp;&amp;);</span>
<a href="#l28.57"></a><span id="l28.57">     /* make sure we use only empty constructor/move operator */</span>
<a href="#l28.58"></a><span id="l28.58">     pgp_key_t(const pgp_key_t &amp;src) = delete;</span>
<a href="#l28.59"></a><span id="l28.59">     pgp_key_t(pgp_key_t &amp;&amp;src) = delete;</span>
<a href="#l28.60"></a><span id="l28.60">     pgp_key_t &amp;operator=(const pgp_key_t &amp;) = delete;</span>
<a href="#l28.61"></a><span id="l28.61" class="difflineat">@@ -192,63 +193,63 @@ pgp_key_pkt_t *pgp_decrypt_seckey_pgp(co</span>
<a href="#l28.62"></a><span id="l28.62"> pgp_key_pkt_t *pgp_decrypt_seckey(const pgp_key_t *,</span>
<a href="#l28.63"></a><span id="l28.63">                                   const pgp_password_provider_t *,</span>
<a href="#l28.64"></a><span id="l28.64">                                   const pgp_password_ctx_t *);</span>
<a href="#l28.65"></a><span id="l28.65"> </span>
<a href="#l28.66"></a><span id="l28.66"> /**</span>
<a href="#l28.67"></a><span id="l28.67">  * @brief Get key's keyid</span>
<a href="#l28.68"></a><span id="l28.68">  *</span>
<a href="#l28.69"></a><span id="l28.69">  * @param key populated key, should not be NULL</span>
<a href="#l28.70"></a><span id="l28.70" class="difflineminus">- * @return pointer to the 8-byte buffer with keyid</span>
<a href="#l28.71"></a><span id="l28.71" class="difflineplus">+ * @return reference to keyid object</span>
<a href="#l28.72"></a><span id="l28.72">  */</span>
<a href="#l28.73"></a><span id="l28.73" class="difflineminus">-const uint8_t *pgp_key_get_keyid(const pgp_key_t *key);</span>
<a href="#l28.74"></a><span id="l28.74" class="difflineplus">+const pgp_key_id_t &amp;pgp_key_get_keyid(const pgp_key_t *key);</span>
<a href="#l28.75"></a><span id="l28.75"> </span>
<a href="#l28.76"></a><span id="l28.76"> /**</span>
<a href="#l28.77"></a><span id="l28.77">  * @brief Get key's fingerprint</span>
<a href="#l28.78"></a><span id="l28.78">  *</span>
<a href="#l28.79"></a><span id="l28.79">  * @param key populated key, should not be NULL</span>
<a href="#l28.80"></a><span id="l28.80" class="difflineminus">- * @return pointer to the fingerprint structure</span>
<a href="#l28.81"></a><span id="l28.81" class="difflineplus">+ * @return reference to the fingerprint structure</span>
<a href="#l28.82"></a><span id="l28.82">  */</span>
<a href="#l28.83"></a><span id="l28.83" class="difflineminus">-const pgp_fingerprint_t *pgp_key_get_fp(const pgp_key_t *key);</span>
<a href="#l28.84"></a><span id="l28.84" class="difflineplus">+const pgp_fingerprint_t &amp;pgp_key_get_fp(const pgp_key_t *key);</span>
<a href="#l28.85"></a><span id="l28.85"> </span>
<a href="#l28.86"></a><span id="l28.86"> /**</span>
<a href="#l28.87"></a><span id="l28.87">  * @brief Get key's grip</span>
<a href="#l28.88"></a><span id="l28.88">  *</span>
<a href="#l28.89"></a><span id="l28.89">  * @param key populated key, should not be NULL</span>
<a href="#l28.90"></a><span id="l28.90">  * @return key's grip</span>
<a href="#l28.91"></a><span id="l28.91">  */</span>
<a href="#l28.92"></a><span id="l28.92"> const pgp_key_grip_t &amp;pgp_key_get_grip(const pgp_key_t *key);</span>
<a href="#l28.93"></a><span id="l28.93"> </span>
<a href="#l28.94"></a><span id="l28.94"> /**</span>
<a href="#l28.95"></a><span id="l28.95" class="difflineminus">- * @brief Get primary key's grip for the subkey, if available.</span>
<a href="#l28.96"></a><span id="l28.96" class="difflineplus">+ * @brief Get primary key's fingerprint for the subkey, if available.</span>
<a href="#l28.97"></a><span id="l28.97">  *</span>
<a href="#l28.98"></a><span id="l28.98" class="difflineminus">- * @param key subkey, which primary key's grip should be returned</span>
<a href="#l28.99"></a><span id="l28.99" class="difflineminus">- * @return pointer to the array with grip or NULL if it is not available</span>
<a href="#l28.100"></a><span id="l28.100" class="difflineplus">+ * @param key subkey, which primary key's fingerprint should be returned</span>
<a href="#l28.101"></a><span id="l28.101" class="difflineplus">+ * @return reference to the fingerprint or NULL if it is not available</span>
<a href="#l28.102"></a><span id="l28.102">  */</span>
<a href="#l28.103"></a><span id="l28.103" class="difflineminus">-const pgp_key_grip_t &amp;pgp_key_get_primary_grip(const pgp_key_t *key);</span>
<a href="#l28.104"></a><span id="l28.104" class="difflineplus">+const pgp_fingerprint_t &amp;pgp_key_get_primary_fp(const pgp_key_t *key);</span>
<a href="#l28.105"></a><span id="l28.105"> </span>
<a href="#l28.106"></a><span id="l28.106" class="difflineminus">-bool pgp_key_has_primary_grip(const pgp_key_t *key);</span>
<a href="#l28.107"></a><span id="l28.107" class="difflineplus">+bool pgp_key_has_primary_fp(const pgp_key_t *key);</span>
<a href="#l28.108"></a><span id="l28.108"> </span>
<a href="#l28.109"></a><span id="l28.109"> /**</span>
<a href="#l28.110"></a><span id="l28.110" class="difflineminus">- * @brief Set primary key's grip for the subkey</span>
<a href="#l28.111"></a><span id="l28.111" class="difflineplus">+ * @brief Set primary key's fingerprint for the subkey</span>
<a href="#l28.112"></a><span id="l28.112">  *</span>
<a href="#l28.113"></a><span id="l28.113">  * @param key subkey</span>
<a href="#l28.114"></a><span id="l28.114" class="difflineminus">- * @param grip buffer with grip</span>
<a href="#l28.115"></a><span id="l28.115" class="difflineplus">+ * @param fp buffer with fingerprint</span>
<a href="#l28.116"></a><span id="l28.116">  * @return void</span>
<a href="#l28.117"></a><span id="l28.117">  */</span>
<a href="#l28.118"></a><span id="l28.118" class="difflineminus">-void pgp_key_set_primary_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip);</span>
<a href="#l28.119"></a><span id="l28.119" class="difflineplus">+void pgp_key_set_primary_fp(pgp_key_t *key, const pgp_fingerprint_t &amp;fp);</span>
<a href="#l28.120"></a><span id="l28.120"> </span>
<a href="#l28.121"></a><span id="l28.121"> /**</span>
<a href="#l28.122"></a><span id="l28.122" class="difflineminus">- * @brief Link key with subkey via primary_grip and subkey_grips list</span>
<a href="#l28.123"></a><span id="l28.123" class="difflineplus">+ * @brief Link key with subkey via primary_fp and subkey_fps list</span>
<a href="#l28.124"></a><span id="l28.124">  *</span>
<a href="#l28.125"></a><span id="l28.125">  * @param key primary key</span>
<a href="#l28.126"></a><span id="l28.126">  * @param subkey subkey of the primary key</span>
<a href="#l28.127"></a><span id="l28.127">  * @return true on success or false otherwise (allocation failed, wrong key types)</span>
<a href="#l28.128"></a><span id="l28.128">  */</span>
<a href="#l28.129"></a><span id="l28.129" class="difflineminus">-bool pgp_key_link_subkey_grip(pgp_key_t *key, pgp_key_t *subkey);</span>
<a href="#l28.130"></a><span id="l28.130" class="difflineplus">+bool pgp_key_link_subkey_fp(pgp_key_t *key, pgp_key_t *subkey);</span>
<a href="#l28.131"></a><span id="l28.131"> </span>
<a href="#l28.132"></a><span id="l28.132"> size_t pgp_key_get_userid_count(const pgp_key_t *);</span>
<a href="#l28.133"></a><span id="l28.133"> </span>
<a href="#l28.134"></a><span id="l28.134"> const pgp_userid_t *pgp_key_get_userid(const pgp_key_t *, size_t);</span>
<a href="#l28.135"></a><span id="l28.135"> </span>
<a href="#l28.136"></a><span id="l28.136"> pgp_userid_t *pgp_key_get_userid(pgp_key_t *, size_t);</span>
<a href="#l28.137"></a><span id="l28.137"> </span>
<a href="#l28.138"></a><span id="l28.138"> const pgp_revoke_t *pgp_key_get_userid_revoke(const pgp_key_t *, size_t userid);</span>
<a href="#l28.139"></a><span id="l28.139" class="difflineat">@@ -313,41 +314,41 @@ const pgp_rawpacket_t &amp;pgp_key_get_rawpa</span>
<a href="#l28.140"></a><span id="l28.140">  * @brief Get the number of pgp key's subkeys.</span>
<a href="#l28.141"></a><span id="l28.141">  *</span>
<a href="#l28.142"></a><span id="l28.142">  * @param key pointer to the primary key</span>
<a href="#l28.143"></a><span id="l28.143">  * @return number of the subkeys</span>
<a href="#l28.144"></a><span id="l28.144">  */</span>
<a href="#l28.145"></a><span id="l28.145"> size_t pgp_key_get_subkey_count(const pgp_key_t *key);</span>
<a href="#l28.146"></a><span id="l28.146"> </span>
<a href="#l28.147"></a><span id="l28.147"> /**</span>
<a href="#l28.148"></a><span id="l28.148" class="difflineminus">- * @brief Add subkey grip to key's list.</span>
<a href="#l28.149"></a><span id="l28.149" class="difflineplus">+ * @brief Add subkey fp to key's list.</span>
<a href="#l28.150"></a><span id="l28.150">  *        Note: this function will check for duplicates.</span>
<a href="#l28.151"></a><span id="l28.151">  *</span>
<a href="#l28.152"></a><span id="l28.152">  * @param key key pointer to the primary key</span>
<a href="#l28.153"></a><span id="l28.153" class="difflineminus">- * @param grip subkey's grip.</span>
<a href="#l28.154"></a><span id="l28.154" class="difflineminus">- * @return true if succeeded (grip already exists in list or added), or false otherwise.</span>
<a href="#l28.155"></a><span id="l28.155" class="difflineplus">+ * @param fp subkey's fingerprint.</span>
<a href="#l28.156"></a><span id="l28.156" class="difflineplus">+ * @return true if succeeded (fingerprint already exists in list or added), or false otherwise.</span>
<a href="#l28.157"></a><span id="l28.157">  */</span>
<a href="#l28.158"></a><span id="l28.158" class="difflineminus">-bool pgp_key_add_subkey_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip);</span>
<a href="#l28.159"></a><span id="l28.159" class="difflineplus">+bool pgp_key_add_subkey_fp(pgp_key_t *key, const pgp_fingerprint_t &amp;fp);</span>
<a href="#l28.160"></a><span id="l28.160"> </span>
<a href="#l28.161"></a><span id="l28.161"> /**</span>
<a href="#l28.162"></a><span id="l28.162" class="difflineminus">- * @brief Remove subkey grip from key's list.</span>
<a href="#l28.163"></a><span id="l28.163" class="difflineplus">+ * @brief Remove subkey fingerprint from key's list.</span>
<a href="#l28.164"></a><span id="l28.164">  *</span>
<a href="#l28.165"></a><span id="l28.165">  * @param key key pointer to the primary key</span>
<a href="#l28.166"></a><span id="l28.166" class="difflineminus">- * @param grip subkey's grip.</span>
<a href="#l28.167"></a><span id="l28.167" class="difflineplus">+ * @param fp subkey's fingerprint.</span>
<a href="#l28.168"></a><span id="l28.168">  */</span>
<a href="#l28.169"></a><span id="l28.169" class="difflineminus">-void pgp_key_remove_subkey_grip(pgp_key_t *key, const pgp_key_grip_t &amp;grip);</span>
<a href="#l28.170"></a><span id="l28.170" class="difflineplus">+void pgp_key_remove_subkey_fp(pgp_key_t *key, const pgp_fingerprint_t &amp;fp);</span>
<a href="#l28.171"></a><span id="l28.171"> </span>
<a href="#l28.172"></a><span id="l28.172"> /**</span>
<a href="#l28.173"></a><span id="l28.173" class="difflineminus">- * @brief Get the pgp key's subkey grip</span>
<a href="#l28.174"></a><span id="l28.174" class="difflineplus">+ * @brief Get the pgp key's subkey fingerprint</span>
<a href="#l28.175"></a><span id="l28.175">  *</span>
<a href="#l28.176"></a><span id="l28.176">  * @param key key pointer to the primary key</span>
<a href="#l28.177"></a><span id="l28.177">  * @param idx index of the subkey</span>
<a href="#l28.178"></a><span id="l28.178">  * @return grip or throws std::out_of_range exception</span>
<a href="#l28.179"></a><span id="l28.179">  */</span>
<a href="#l28.180"></a><span id="l28.180" class="difflineminus">-const pgp_key_grip_t &amp;pgp_key_get_subkey_grip(const pgp_key_t *key, size_t idx);</span>
<a href="#l28.181"></a><span id="l28.181" class="difflineplus">+const pgp_fingerprint_t &amp;pgp_key_get_subkey_fp(const pgp_key_t *key, size_t idx);</span>
<a href="#l28.182"></a><span id="l28.182"> </span>
<a href="#l28.183"></a><span id="l28.183"> /**</span>
<a href="#l28.184"></a><span id="l28.184">  * @brief Get the key's subkey by it's index</span>
<a href="#l28.185"></a><span id="l28.185">  *</span>
<a href="#l28.186"></a><span id="l28.186">  * @param key primary key</span>
<a href="#l28.187"></a><span id="l28.187">  * @param store key store wich will be searched for subkeys</span>
<a href="#l28.188"></a><span id="l28.188">  * @param idx index of the subkey</span>
<a href="#l28.189"></a><span id="l28.189">  * @return pointer to the subkey or NULL if subkey not found</span>
<a href="#l28.190"></a><span id="l28.190" class="difflineat">@@ -437,22 +438,26 @@ bool pgp_key_is_protected(const pgp_key_</span>
<a href="#l28.191"></a><span id="l28.191">  *  @param cert the self-signature information</span>
<a href="#l28.192"></a><span id="l28.192">  *  @return true if the userid was added, false otherwise</span>
<a href="#l28.193"></a><span id="l28.193">  */</span>
<a href="#l28.194"></a><span id="l28.194"> bool pgp_key_add_userid_certified(pgp_key_t *              key,</span>
<a href="#l28.195"></a><span id="l28.195">                                   const pgp_key_pkt_t *    seckey,</span>
<a href="#l28.196"></a><span id="l28.196">                                   pgp_hash_alg_t           hash_alg,</span>
<a href="#l28.197"></a><span id="l28.197">                                   rnp_selfsig_cert_info_t *cert);</span>
<a href="#l28.198"></a><span id="l28.198"> </span>
<a href="#l28.199"></a><span id="l28.199" class="difflineminus">-bool pgp_key_set_expiration(pgp_key_t *key, pgp_key_t *signer, uint32_t expiry);</span>
<a href="#l28.200"></a><span id="l28.200" class="difflineplus">+bool pgp_key_set_expiration(pgp_key_t *                    key,</span>
<a href="#l28.201"></a><span id="l28.201" class="difflineplus">+                            pgp_key_t *                    signer,</span>
<a href="#l28.202"></a><span id="l28.202" class="difflineplus">+                            uint32_t                       expiry,</span>
<a href="#l28.203"></a><span id="l28.203" class="difflineplus">+                            const pgp_password_provider_t *prov);</span>
<a href="#l28.204"></a><span id="l28.204"> </span>
<a href="#l28.205"></a><span id="l28.205" class="difflineminus">-bool pgp_subkey_set_expiration(pgp_key_t *sub,</span>
<a href="#l28.206"></a><span id="l28.206" class="difflineminus">-                               pgp_key_t *primsec,</span>
<a href="#l28.207"></a><span id="l28.207" class="difflineminus">-                               pgp_key_t *secsub,</span>
<a href="#l28.208"></a><span id="l28.208" class="difflineminus">-                               uint32_t   expiry);</span>
<a href="#l28.209"></a><span id="l28.209" class="difflineplus">+bool pgp_subkey_set_expiration(pgp_key_t *                    sub,</span>
<a href="#l28.210"></a><span id="l28.210" class="difflineplus">+                               pgp_key_t *                    primsec,</span>
<a href="#l28.211"></a><span id="l28.211" class="difflineplus">+                               pgp_key_t *                    secsub,</span>
<a href="#l28.212"></a><span id="l28.212" class="difflineplus">+                               uint32_t                       expiry,</span>
<a href="#l28.213"></a><span id="l28.213" class="difflineplus">+                               const pgp_password_provider_t *prov);</span>
<a href="#l28.214"></a><span id="l28.214"> </span>
<a href="#l28.215"></a><span id="l28.215"> bool pgp_key_write_packets(const pgp_key_t *key, pgp_dest_t *dst);</span>
<a href="#l28.216"></a><span id="l28.216"> </span>
<a href="#l28.217"></a><span id="l28.217"> /**</span>
<a href="#l28.218"></a><span id="l28.218">  * @brief Write OpenPGP key packets (including subkeys) to the specified stream</span>
<a href="#l28.219"></a><span id="l28.219">  *</span>
<a href="#l28.220"></a><span id="l28.220">  * @param dst stream to write packets</span>
<a href="#l28.221"></a><span id="l28.221">  * @param key key</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/third_party/rnp/src/lib/rnp.cpp</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/third_party/rnp/src/lib/rnp.cpp</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -49,16 +49,17 @@</span>
<a href="#l29.4"></a><span id="l29.4"> #include &lt;string.h&gt;</span>
<a href="#l29.5"></a><span id="l29.5"> #include &lt;sys/stat.h&gt;</span>
<a href="#l29.6"></a><span id="l29.6"> #include &lt;stdexcept&gt;</span>
<a href="#l29.7"></a><span id="l29.7"> #include &quot;utils.h&quot;</span>
<a href="#l29.8"></a><span id="l29.8"> #include &quot;json_utils.h&quot;</span>
<a href="#l29.9"></a><span id="l29.9"> #include &quot;version.h&quot;</span>
<a href="#l29.10"></a><span id="l29.10"> #include &lt;botan/secmem.h&gt;</span>
<a href="#l29.11"></a><span id="l29.11"> #include &quot;ffi-priv-types.h&quot;</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineplus">+#include &quot;file-utils.h&quot;</span>
<a href="#l29.13"></a><span id="l29.13"> </span>
<a href="#l29.14"></a><span id="l29.14"> #define FFI_LOG(ffi, ...)            \</span>
<a href="#l29.15"></a><span id="l29.15">     do {                             \</span>
<a href="#l29.16"></a><span id="l29.16">         FILE *fp = stderr;           \</span>
<a href="#l29.17"></a><span id="l29.17">         if (ffi &amp;&amp; ffi-&gt;errs) {      \</span>
<a href="#l29.18"></a><span id="l29.18">             fp = ffi-&gt;errs;          \</span>
<a href="#l29.19"></a><span id="l29.19">         }                            \</span>
<a href="#l29.20"></a><span id="l29.20">         RNP_LOG_FD(fp, __VA_ARGS__); \</span>
<a href="#l29.21"></a><span id="l29.21" class="difflineat">@@ -1250,28 +1251,28 @@ key_status_to_str(pgp_key_import_status_</span>
<a href="#l29.22"></a><span id="l29.22"> }</span>
<a href="#l29.23"></a><span id="l29.23"> </span>
<a href="#l29.24"></a><span id="l29.24"> static rnp_result_t</span>
<a href="#l29.25"></a><span id="l29.25"> add_key_status(json_object *           keys,</span>
<a href="#l29.26"></a><span id="l29.26">                const pgp_key_t *       key,</span>
<a href="#l29.27"></a><span id="l29.27">                pgp_key_import_status_t pub,</span>
<a href="#l29.28"></a><span id="l29.28">                pgp_key_import_status_t sec)</span>
<a href="#l29.29"></a><span id="l29.29"> {</span>
<a href="#l29.30"></a><span id="l29.30" class="difflineminus">-    const pgp_fingerprint_t *fp = pgp_key_get_fp(key);</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineplus">+    const pgp_fingerprint_t &amp;fp = pgp_key_get_fp(key);</span>
<a href="#l29.32"></a><span id="l29.32"> </span>
<a href="#l29.33"></a><span id="l29.33">     json_object *jsokey = json_object_new_object();</span>
<a href="#l29.34"></a><span id="l29.34">     if (!jsokey) {</span>
<a href="#l29.35"></a><span id="l29.35">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.36"></a><span id="l29.36">     }</span>
<a href="#l29.37"></a><span id="l29.37"> </span>
<a href="#l29.38"></a><span id="l29.38">     if (!obj_add_field_json(</span>
<a href="#l29.39"></a><span id="l29.39">           jsokey, &quot;public&quot;, json_object_new_string(key_status_to_str(pub))) ||</span>
<a href="#l29.40"></a><span id="l29.40">         !obj_add_field_json(</span>
<a href="#l29.41"></a><span id="l29.41">           jsokey, &quot;secret&quot;, json_object_new_string(key_status_to_str(sec))) ||</span>
<a href="#l29.42"></a><span id="l29.42" class="difflineminus">-        !obj_add_hex_json(jsokey, &quot;fingerprint&quot;, fp-&gt;fingerprint, fp-&gt;length) ||</span>
<a href="#l29.43"></a><span id="l29.43" class="difflineplus">+        !obj_add_hex_json(jsokey, &quot;fingerprint&quot;, fp.fingerprint, fp.length) ||</span>
<a href="#l29.44"></a><span id="l29.44">         !array_add_element_json(keys, jsokey)) {</span>
<a href="#l29.45"></a><span id="l29.45">         json_object_put(jsokey);</span>
<a href="#l29.46"></a><span id="l29.46">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.47"></a><span id="l29.47">     }</span>
<a href="#l29.48"></a><span id="l29.48"> </span>
<a href="#l29.49"></a><span id="l29.49">     return RNP_SUCCESS;</span>
<a href="#l29.50"></a><span id="l29.50"> }</span>
<a href="#l29.51"></a><span id="l29.51"> </span>
<a href="#l29.52"></a><span id="l29.52" class="difflineat">@@ -1338,36 +1339,36 @@ rnp_import_keys(rnp_ffi_t ffi, rnp_input</span>
<a href="#l29.53"></a><span id="l29.53">     // import keys to the main keystore.</span>
<a href="#l29.54"></a><span id="l29.54">     for (auto &amp;key : tmp_store-&gt;keys) {</span>
<a href="#l29.55"></a><span id="l29.55">         pgp_key_import_status_t pub_status = PGP_KEY_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l29.56"></a><span id="l29.56">         pgp_key_import_status_t sec_status = PGP_KEY_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l29.57"></a><span id="l29.57">         if (!pub &amp;&amp; pgp_key_is_public(&amp;key)) {</span>
<a href="#l29.58"></a><span id="l29.58">             continue;</span>
<a href="#l29.59"></a><span id="l29.59">         }</span>
<a href="#l29.60"></a><span id="l29.60">         if (validate_pgp_key_material(pgp_key_get_material(&amp;key), &amp;ffi-&gt;rng)) {</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineminus">-            char hex[PGP_KEY_ID_SIZE * 2 + 1] = {0};</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineminus">-            rnp_hex_encode(</span>
<a href="#l29.63"></a><span id="l29.63" class="difflineminus">-              pgp_key_get_keyid(&amp;key), PGP_KEY_ID_SIZE, hex, sizeof(hex), RNP_HEX_LOWERCASE);</span>
<a href="#l29.64"></a><span id="l29.64" class="difflineplus">+            char                hex[PGP_KEY_ID_SIZE * 2 + 1] = {0};</span>
<a href="#l29.65"></a><span id="l29.65" class="difflineplus">+            const pgp_key_id_t &amp;keyid = pgp_key_get_keyid(&amp;key);</span>
<a href="#l29.66"></a><span id="l29.66" class="difflineplus">+            rnp_hex_encode(keyid.data(), keyid.size(), hex, sizeof(hex), RNP_HEX_LOWERCASE);</span>
<a href="#l29.67"></a><span id="l29.67">             FFI_LOG(ffi, &quot;warning! attempt to import key %s with invalid material.&quot;, hex);</span>
<a href="#l29.68"></a><span id="l29.68">             continue;</span>
<a href="#l29.69"></a><span id="l29.69">         }</span>
<a href="#l29.70"></a><span id="l29.70">         // if we got here then we add public key itself or public part of the secret key</span>
<a href="#l29.71"></a><span id="l29.71">         if (!rnp_key_store_import_key(ffi-&gt;pubring, &amp;key, true, &amp;pub_status)) {</span>
<a href="#l29.72"></a><span id="l29.72">             ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.73"></a><span id="l29.73">             goto done;</span>
<a href="#l29.74"></a><span id="l29.74">         }</span>
<a href="#l29.75"></a><span id="l29.75">         // import secret key part if available and requested</span>
<a href="#l29.76"></a><span id="l29.76">         if (sec &amp;&amp; pgp_key_is_secret(&amp;key)) {</span>
<a href="#l29.77"></a><span id="l29.77">             if (!rnp_key_store_import_key(ffi-&gt;secring, &amp;key, false, &amp;sec_status)) {</span>
<a href="#l29.78"></a><span id="l29.78">                 ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.79"></a><span id="l29.79">                 goto done;</span>
<a href="#l29.80"></a><span id="l29.80">             }</span>
<a href="#l29.81"></a><span id="l29.81">             // add uids, certifications and other stuff from the public key if any</span>
<a href="#l29.82"></a><span id="l29.82">             pgp_key_t *expub =</span>
<a href="#l29.83"></a><span id="l29.83" class="difflineminus">-              rnp_key_store_get_key_by_grip(ffi-&gt;pubring, pgp_key_get_grip(&amp;key));</span>
<a href="#l29.84"></a><span id="l29.84" class="difflineplus">+              rnp_key_store_get_key_by_fpr(ffi-&gt;pubring, pgp_key_get_fp(&amp;key));</span>
<a href="#l29.85"></a><span id="l29.85">             if (expub &amp;&amp; !rnp_key_store_import_key(ffi-&gt;secring, expub, true, NULL)) {</span>
<a href="#l29.86"></a><span id="l29.86">                 ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.87"></a><span id="l29.87">                 goto done;</span>
<a href="#l29.88"></a><span id="l29.88">             }</span>
<a href="#l29.89"></a><span id="l29.89">         }</span>
<a href="#l29.90"></a><span id="l29.90">         // now add key fingerprint to json based on statuses</span>
<a href="#l29.91"></a><span id="l29.91">         if ((tmpret = add_key_status(jsokeys, &amp;key, pub_status, sec_status))) {</span>
<a href="#l29.92"></a><span id="l29.92">             ret = tmpret;</span>
<a href="#l29.93"></a><span id="l29.93" class="difflineat">@@ -1420,18 +1421,18 @@ add_sig_status(json_object *           s</span>
<a href="#l29.94"></a><span id="l29.94">           jsosig, &quot;public&quot;, json_object_new_string(sig_status_to_str(pub))) ||</span>
<a href="#l29.95"></a><span id="l29.95">         !obj_add_field_json(</span>
<a href="#l29.96"></a><span id="l29.96">           jsosig, &quot;secret&quot;, json_object_new_string(sig_status_to_str(sec)))) {</span>
<a href="#l29.97"></a><span id="l29.97">         json_object_put(jsosig);</span>
<a href="#l29.98"></a><span id="l29.98">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.99"></a><span id="l29.99">     }</span>
<a href="#l29.100"></a><span id="l29.100"> </span>
<a href="#l29.101"></a><span id="l29.101">     if (signer) {</span>
<a href="#l29.102"></a><span id="l29.102" class="difflineminus">-        const pgp_fingerprint_t *fp = pgp_key_get_fp(signer);</span>
<a href="#l29.103"></a><span id="l29.103" class="difflineminus">-        if (!obj_add_hex_json(jsosig, &quot;signer fingerprint&quot;, fp-&gt;fingerprint, fp-&gt;length)) {</span>
<a href="#l29.104"></a><span id="l29.104" class="difflineplus">+        const pgp_fingerprint_t &amp;fp = pgp_key_get_fp(signer);</span>
<a href="#l29.105"></a><span id="l29.105" class="difflineplus">+        if (!obj_add_hex_json(jsosig, &quot;signer fingerprint&quot;, fp.fingerprint, fp.length)) {</span>
<a href="#l29.106"></a><span id="l29.106">             json_object_put(jsosig);</span>
<a href="#l29.107"></a><span id="l29.107">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.108"></a><span id="l29.108">         }</span>
<a href="#l29.109"></a><span id="l29.109">     }</span>
<a href="#l29.110"></a><span id="l29.110"> </span>
<a href="#l29.111"></a><span id="l29.111">     if (!array_add_element_json(sigs, jsosig)) {</span>
<a href="#l29.112"></a><span id="l29.112">         json_object_put(jsosig);</span>
<a href="#l29.113"></a><span id="l29.113">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.114"></a><span id="l29.114" class="difflineat">@@ -2642,45 +2643,46 @@ rnp_op_sign_destroy(rnp_op_sign_t op)</span>
<a href="#l29.115"></a><span id="l29.115">         rnp_ctx_free(&amp;op-&gt;rnpctx);</span>
<a href="#l29.116"></a><span id="l29.116">         rnp_op_signatures_destroy(&amp;op-&gt;signatures);</span>
<a href="#l29.117"></a><span id="l29.117">         free(op);</span>
<a href="#l29.118"></a><span id="l29.118">     }</span>
<a href="#l29.119"></a><span id="l29.119">     return RNP_SUCCESS;</span>
<a href="#l29.120"></a><span id="l29.120"> }</span>
<a href="#l29.121"></a><span id="l29.121"> </span>
<a href="#l29.122"></a><span id="l29.122"> static void</span>
<a href="#l29.123"></a><span id="l29.123" class="difflineminus">-rnp_op_verify_on_signatures(pgp_signature_info_t *sigs, int count, void *param)</span>
<a href="#l29.124"></a><span id="l29.124" class="difflineplus">+rnp_op_verify_on_signatures(const std::vector&lt;pgp_signature_info_t&gt; &amp;sigs, void *param)</span>
<a href="#l29.125"></a><span id="l29.125"> {</span>
<a href="#l29.126"></a><span id="l29.126">     struct rnp_op_verify_signature_st res;</span>
<a href="#l29.127"></a><span id="l29.127">     rnp_op_verify_t                   op = (rnp_op_verify_t) param;</span>
<a href="#l29.128"></a><span id="l29.128"> </span>
<a href="#l29.129"></a><span id="l29.129" class="difflineminus">-    op-&gt;signatures = (rnp_op_verify_signature_t) calloc(count, sizeof(*op-&gt;signatures));</span>
<a href="#l29.130"></a><span id="l29.130" class="difflineplus">+    op-&gt;signatures = (rnp_op_verify_signature_t) calloc(sigs.size(), sizeof(*op-&gt;signatures));</span>
<a href="#l29.131"></a><span id="l29.131">     if (!op-&gt;signatures) {</span>
<a href="#l29.132"></a><span id="l29.132" class="difflineminus">-        // TODO: report allocation error?</span>
<a href="#l29.133"></a><span id="l29.133" class="difflineplus">+        FFI_LOG(op-&gt;ffi, &quot;Allocation error&quot;);</span>
<a href="#l29.134"></a><span id="l29.134">         return;</span>
<a href="#l29.135"></a><span id="l29.135">     }</span>
<a href="#l29.136"></a><span id="l29.136" class="difflineminus">-    op-&gt;signature_count = count;</span>
<a href="#l29.137"></a><span id="l29.137" class="difflineminus">-</span>
<a href="#l29.138"></a><span id="l29.138" class="difflineminus">-    for (int i = 0; i &lt; count; i++) {</span>
<a href="#l29.139"></a><span id="l29.139" class="difflineplus">+    op-&gt;signature_count = sigs.size();</span>
<a href="#l29.140"></a><span id="l29.140" class="difflineplus">+</span>
<a href="#l29.141"></a><span id="l29.141" class="difflineplus">+    size_t i = 0;</span>
<a href="#l29.142"></a><span id="l29.142" class="difflineplus">+    for (const auto &amp;sinfo : sigs) {</span>
<a href="#l29.143"></a><span id="l29.143">         memset(&amp;res, 0, sizeof(res));</span>
<a href="#l29.144"></a><span id="l29.144"> </span>
<a href="#l29.145"></a><span id="l29.145">         /* ignore copy result - NULL signature on out of memory error will work for us */</span>
<a href="#l29.146"></a><span id="l29.146" class="difflineminus">-        (void) copy_signature_packet(&amp;res.sig_pkt, sigs[i].sig);</span>
<a href="#l29.147"></a><span id="l29.147" class="difflineminus">-</span>
<a href="#l29.148"></a><span id="l29.148" class="difflineminus">-        if (sigs[i].unknown) {</span>
<a href="#l29.149"></a><span id="l29.149" class="difflineplus">+        (void) copy_signature_packet(&amp;res.sig_pkt, sinfo.sig);</span>
<a href="#l29.150"></a><span id="l29.150" class="difflineplus">+</span>
<a href="#l29.151"></a><span id="l29.151" class="difflineplus">+        if (sinfo.unknown) {</span>
<a href="#l29.152"></a><span id="l29.152">             res.verify_status = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l29.153"></a><span id="l29.153" class="difflineminus">-        } else if (sigs[i].valid) {</span>
<a href="#l29.154"></a><span id="l29.154" class="difflineminus">-            res.verify_status = sigs[i].expired ? RNP_ERROR_SIGNATURE_EXPIRED : RNP_SUCCESS;</span>
<a href="#l29.155"></a><span id="l29.155" class="difflineplus">+        } else if (sinfo.valid) {</span>
<a href="#l29.156"></a><span id="l29.156" class="difflineplus">+            res.verify_status = sinfo.expired ? RNP_ERROR_SIGNATURE_EXPIRED : RNP_SUCCESS;</span>
<a href="#l29.157"></a><span id="l29.157">         } else {</span>
<a href="#l29.158"></a><span id="l29.158">             res.verify_status =</span>
<a href="#l29.159"></a><span id="l29.159" class="difflineminus">-              sigs[i].no_signer ? RNP_ERROR_KEY_NOT_FOUND : RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l29.160"></a><span id="l29.160" class="difflineplus">+              sinfo.no_signer ? RNP_ERROR_KEY_NOT_FOUND : RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l29.161"></a><span id="l29.161">         }</span>
<a href="#l29.162"></a><span id="l29.162"> </span>
<a href="#l29.163"></a><span id="l29.163">         res.ffi = op-&gt;ffi;</span>
<a href="#l29.164"></a><span id="l29.164" class="difflineminus">-        op-&gt;signatures[i] = res;</span>
<a href="#l29.165"></a><span id="l29.165" class="difflineplus">+        op-&gt;signatures[i++] = res;</span>
<a href="#l29.166"></a><span id="l29.166">     }</span>
<a href="#l29.167"></a><span id="l29.167"> }</span>
<a href="#l29.168"></a><span id="l29.168"> </span>
<a href="#l29.169"></a><span id="l29.169"> static bool</span>
<a href="#l29.170"></a><span id="l29.170"> rnp_verify_src_provider(pgp_parse_handler_t *handler, pgp_source_t *src)</span>
<a href="#l29.171"></a><span id="l29.171"> {</span>
<a href="#l29.172"></a><span id="l29.172">     /* this one is called only when input for detached signature is needed */</span>
<a href="#l29.173"></a><span id="l29.173">     rnp_op_verify_t op = (rnp_op_verify_t) handler-&gt;param;</span>
<a href="#l29.174"></a><span id="l29.174" class="difflineat">@@ -2706,17 +2708,18 @@ rnp_verify_dest_provider(pgp_parse_handl</span>
<a href="#l29.175"></a><span id="l29.175"> </span>
<a href="#l29.176"></a><span id="l29.176">     return true;</span>
<a href="#l29.177"></a><span id="l29.177"> }</span>
<a href="#l29.178"></a><span id="l29.178"> </span>
<a href="#l29.179"></a><span id="l29.179"> static void</span>
<a href="#l29.180"></a><span id="l29.180"> recipient_handle_from_pk_sesskey(rnp_recipient_handle_t  handle,</span>
<a href="#l29.181"></a><span id="l29.181">                                  const pgp_pk_sesskey_t &amp;sesskey)</span>
<a href="#l29.182"></a><span id="l29.182"> {</span>
<a href="#l29.183"></a><span id="l29.183" class="difflineminus">-    memcpy(handle-&gt;keyid, sesskey.key_id, PGP_KEY_ID_SIZE);</span>
<a href="#l29.184"></a><span id="l29.184" class="difflineplus">+    static_assert(sizeof(handle-&gt;keyid) == PGP_KEY_ID_SIZE, &quot;Keyid size mismatch&quot;);</span>
<a href="#l29.185"></a><span id="l29.185" class="difflineplus">+    memcpy(handle-&gt;keyid, sesskey.key_id.data(), PGP_KEY_ID_SIZE);</span>
<a href="#l29.186"></a><span id="l29.186">     handle-&gt;palg = sesskey.alg;</span>
<a href="#l29.187"></a><span id="l29.187"> }</span>
<a href="#l29.188"></a><span id="l29.188"> </span>
<a href="#l29.189"></a><span id="l29.189"> static void</span>
<a href="#l29.190"></a><span id="l29.190"> symenc_handle_from_sk_sesskey(rnp_symenc_handle_t handle, const pgp_sk_sesskey_t &amp;sesskey)</span>
<a href="#l29.191"></a><span id="l29.191"> {</span>
<a href="#l29.192"></a><span id="l29.192">     handle-&gt;alg = sesskey.alg;</span>
<a href="#l29.193"></a><span id="l29.193">     handle-&gt;halg = sesskey.s2k.hash_alg;</span>
<a href="#l29.194"></a><span id="l29.194" class="difflineat">@@ -2861,17 +2864,17 @@ rnp_op_verify_execute(rnp_op_verify_t op</span>
<a href="#l29.195"></a><span id="l29.195">     handler.dest_provider = rnp_verify_dest_provider;</span>
<a href="#l29.196"></a><span id="l29.196">     handler.on_recipients = rnp_verify_on_recipients;</span>
<a href="#l29.197"></a><span id="l29.197">     handler.on_decryption_start = rnp_verify_on_decryption_start;</span>
<a href="#l29.198"></a><span id="l29.198">     handler.on_decryption_info = rnp_verify_on_decryption_info;</span>
<a href="#l29.199"></a><span id="l29.199">     handler.on_decryption_done = rnp_verify_on_decryption_done;</span>
<a href="#l29.200"></a><span id="l29.200">     handler.param = op;</span>
<a href="#l29.201"></a><span id="l29.201">     handler.ctx = &amp;op-&gt;rnpctx;</span>
<a href="#l29.202"></a><span id="l29.202"> </span>
<a href="#l29.203"></a><span id="l29.203" class="difflineminus">-    rnp_result_t ret = process_pgp_source(&amp;handler, &amp;op-&gt;input-&gt;src);</span>
<a href="#l29.204"></a><span id="l29.204" class="difflineplus">+    rnp_result_t ret = process_pgp_source(&amp;handler, op-&gt;input-&gt;src);</span>
<a href="#l29.205"></a><span id="l29.205">     if (op-&gt;output) {</span>
<a href="#l29.206"></a><span id="l29.206">         dst_flush(&amp;op-&gt;output-&gt;dst);</span>
<a href="#l29.207"></a><span id="l29.207">         op-&gt;output-&gt;keep = ret == RNP_SUCCESS;</span>
<a href="#l29.208"></a><span id="l29.208">     }</span>
<a href="#l29.209"></a><span id="l29.209">     return ret;</span>
<a href="#l29.210"></a><span id="l29.210"> }</span>
<a href="#l29.211"></a><span id="l29.211"> </span>
<a href="#l29.212"></a><span id="l29.212"> rnp_result_t</span>
<a href="#l29.213"></a><span id="l29.213" class="difflineat">@@ -3009,16 +3012,18 @@ rnp_op_verify_get_recipient_at(rnp_op_ve</span>
<a href="#l29.214"></a><span id="l29.214"> }</span>
<a href="#l29.215"></a><span id="l29.215"> </span>
<a href="#l29.216"></a><span id="l29.216"> rnp_result_t</span>
<a href="#l29.217"></a><span id="l29.217"> rnp_recipient_get_keyid(rnp_recipient_handle_t recipient, char **keyid)</span>
<a href="#l29.218"></a><span id="l29.218"> {</span>
<a href="#l29.219"></a><span id="l29.219">     if (!recipient || !keyid) {</span>
<a href="#l29.220"></a><span id="l29.220">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.221"></a><span id="l29.221">     }</span>
<a href="#l29.222"></a><span id="l29.222" class="difflineplus">+    static_assert(sizeof(recipient-&gt;keyid) == PGP_KEY_ID_SIZE,</span>
<a href="#l29.223"></a><span id="l29.223" class="difflineplus">+                  &quot;rnp_recipient_handle_t.keyid size mismatch&quot;);</span>
<a href="#l29.224"></a><span id="l29.224">     return hex_encode_value(recipient-&gt;keyid, PGP_KEY_ID_SIZE, keyid, RNP_HEX_UPPERCASE);</span>
<a href="#l29.225"></a><span id="l29.225"> }</span>
<a href="#l29.226"></a><span id="l29.226"> </span>
<a href="#l29.227"></a><span id="l29.227"> rnp_result_t</span>
<a href="#l29.228"></a><span id="l29.228"> rnp_recipient_get_alg(rnp_recipient_handle_t recipient, char **alg)</span>
<a href="#l29.229"></a><span id="l29.229"> {</span>
<a href="#l29.230"></a><span id="l29.230">     if (!recipient || !alg) {</span>
<a href="#l29.231"></a><span id="l29.231">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.232"></a><span id="l29.232" class="difflineat">@@ -3175,25 +3180,23 @@ rnp_op_verify_signature_get_hash(rnp_op_</span>
<a href="#l29.233"></a><span id="l29.233">     }</span>
<a href="#l29.234"></a><span id="l29.234">     return get_map_value(hash_alg_map, ARRAY_SIZE(hash_alg_map), sig-&gt;sig_pkt.halg, hash);</span>
<a href="#l29.235"></a><span id="l29.235"> }</span>
<a href="#l29.236"></a><span id="l29.236"> </span>
<a href="#l29.237"></a><span id="l29.237"> rnp_result_t</span>
<a href="#l29.238"></a><span id="l29.238"> rnp_op_verify_signature_get_key(rnp_op_verify_signature_t sig, rnp_key_handle_t *key)</span>
<a href="#l29.239"></a><span id="l29.239"> {</span>
<a href="#l29.240"></a><span id="l29.240">     rnp_ffi_t        ffi = sig-&gt;ffi;</span>
<a href="#l29.241"></a><span id="l29.241" class="difflineminus">-    pgp_key_search_t search;</span>
<a href="#l29.242"></a><span id="l29.242" class="difflineminus">-</span>
<a href="#l29.243"></a><span id="l29.243" class="difflineminus">-    uint8_t keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l29.244"></a><span id="l29.244" class="difflineminus">-    if (!signature_get_keyid(&amp;sig-&gt;sig_pkt, keyid)) {</span>
<a href="#l29.245"></a><span id="l29.245" class="difflineplus">+    pgp_key_search_t search = {};</span>
<a href="#l29.246"></a><span id="l29.246" class="difflineplus">+</span>
<a href="#l29.247"></a><span id="l29.247" class="difflineplus">+    if (!signature_get_keyid(&amp;sig-&gt;sig_pkt, search.by.keyid)) {</span>
<a href="#l29.248"></a><span id="l29.248">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.249"></a><span id="l29.249">     }</span>
<a href="#l29.250"></a><span id="l29.250">     // create a search (since we'll use this later anyways)</span>
<a href="#l29.251"></a><span id="l29.251">     search.type = PGP_KEY_SEARCH_KEYID;</span>
<a href="#l29.252"></a><span id="l29.252" class="difflineminus">-    memcpy(search.by.keyid, keyid, PGP_KEY_ID_SIZE);</span>
<a href="#l29.253"></a><span id="l29.253"> </span>
<a href="#l29.254"></a><span id="l29.254">     // search the stores</span>
<a href="#l29.255"></a><span id="l29.255">     pgp_key_t *pub = rnp_key_store_search(ffi-&gt;pubring, &amp;search, NULL);</span>
<a href="#l29.256"></a><span id="l29.256">     pgp_key_t *sec = rnp_key_store_search(ffi-&gt;secring, &amp;search, NULL);</span>
<a href="#l29.257"></a><span id="l29.257">     if (!pub &amp;&amp; !sec) {</span>
<a href="#l29.258"></a><span id="l29.258">         return RNP_ERROR_KEY_NOT_FOUND;</span>
<a href="#l29.259"></a><span id="l29.259">     }</span>
<a href="#l29.260"></a><span id="l29.260"> </span>
<a href="#l29.261"></a><span id="l29.261" class="difflineat">@@ -3249,17 +3252,17 @@ rnp_decrypt(rnp_ffi_t ffi, rnp_input_t i</span>
<a href="#l29.262"></a><span id="l29.262">     pgp_parse_handler_t handler;</span>
<a href="#l29.263"></a><span id="l29.263">     memset(&amp;handler, 0, sizeof(handler));</span>
<a href="#l29.264"></a><span id="l29.264">     handler.password_provider = &amp;ffi-&gt;pass_provider;</span>
<a href="#l29.265"></a><span id="l29.265">     handler.key_provider = &amp;ffi-&gt;key_provider;</span>
<a href="#l29.266"></a><span id="l29.266">     handler.dest_provider = rnp_decrypt_dest_provider;</span>
<a href="#l29.267"></a><span id="l29.267">     handler.param = output;</span>
<a href="#l29.268"></a><span id="l29.268">     handler.ctx = &amp;rnpctx;</span>
<a href="#l29.269"></a><span id="l29.269"> </span>
<a href="#l29.270"></a><span id="l29.270" class="difflineminus">-    rnp_result_t ret = process_pgp_source(&amp;handler, &amp;input-&gt;src);</span>
<a href="#l29.271"></a><span id="l29.271" class="difflineplus">+    rnp_result_t ret = process_pgp_source(&amp;handler, input-&gt;src);</span>
<a href="#l29.272"></a><span id="l29.272">     dst_flush(&amp;output-&gt;dst);</span>
<a href="#l29.273"></a><span id="l29.273">     output-&gt;keep = (ret == RNP_SUCCESS);</span>
<a href="#l29.274"></a><span id="l29.274">     return ret;</span>
<a href="#l29.275"></a><span id="l29.275"> }</span>
<a href="#l29.276"></a><span id="l29.276"> </span>
<a href="#l29.277"></a><span id="l29.277"> static rnp_result_t</span>
<a href="#l29.278"></a><span id="l29.278"> str_to_locator(rnp_ffi_t         ffi,</span>
<a href="#l29.279"></a><span id="l29.279">                pgp_key_search_t *locator,</span>
<a href="#l29.280"></a><span id="l29.280" class="difflineat">@@ -3279,24 +3282,25 @@ str_to_locator(rnp_ffi_t         ffi,</span>
<a href="#l29.281"></a><span id="l29.281">         if (snprintf(locator-&gt;by.userid, sizeof(locator-&gt;by.userid), &quot;%s&quot;, identifier) &gt;=</span>
<a href="#l29.282"></a><span id="l29.282">             (int) sizeof(locator-&gt;by.userid)) {</span>
<a href="#l29.283"></a><span id="l29.283">             FFI_LOG(ffi, &quot;UserID too long&quot;);</span>
<a href="#l29.284"></a><span id="l29.284">             return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.285"></a><span id="l29.285">         }</span>
<a href="#l29.286"></a><span id="l29.286">         break;</span>
<a href="#l29.287"></a><span id="l29.287">     case PGP_KEY_SEARCH_KEYID: {</span>
<a href="#l29.288"></a><span id="l29.288">         if (strlen(identifier) != (PGP_KEY_ID_SIZE * 2) ||</span>
<a href="#l29.289"></a><span id="l29.289" class="difflineminus">-            !rnp_hex_decode(identifier, locator-&gt;by.keyid, sizeof(locator-&gt;by.keyid))) {</span>
<a href="#l29.290"></a><span id="l29.290" class="difflineplus">+            !rnp_hex_decode(identifier, locator-&gt;by.keyid.data(), locator-&gt;by.keyid.size())) {</span>
<a href="#l29.291"></a><span id="l29.291">             FFI_LOG(ffi, &quot;Invalid keyid: %s&quot;, identifier);</span>
<a href="#l29.292"></a><span id="l29.292">             return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.293"></a><span id="l29.293">         }</span>
<a href="#l29.294"></a><span id="l29.294">     } break;</span>
<a href="#l29.295"></a><span id="l29.295">     case PGP_KEY_SEARCH_FINGERPRINT: {</span>
<a href="#l29.296"></a><span id="l29.296">         // TODO: support v5 fingerprints</span>
<a href="#l29.297"></a><span id="l29.297" class="difflineminus">-        if (strlen(identifier) != (PGP_FINGERPRINT_SIZE * 2)) {</span>
<a href="#l29.298"></a><span id="l29.298" class="difflineplus">+        // Note: v2/v3 fingerprint are 16 bytes (32 chars) long.</span>
<a href="#l29.299"></a><span id="l29.299" class="difflineplus">+        if ((strlen(identifier) != (PGP_FINGERPRINT_SIZE * 2)) &amp;&amp; (strlen(identifier) != 32)) {</span>
<a href="#l29.300"></a><span id="l29.300">             FFI_LOG(ffi, &quot;Invalid fingerprint: %s&quot;, identifier);</span>
<a href="#l29.301"></a><span id="l29.301">             return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.302"></a><span id="l29.302">         }</span>
<a href="#l29.303"></a><span id="l29.303">         locator-&gt;by.fingerprint.length = rnp_hex_decode(</span>
<a href="#l29.304"></a><span id="l29.304">           identifier, locator-&gt;by.fingerprint.fingerprint, PGP_FINGERPRINT_SIZE);</span>
<a href="#l29.305"></a><span id="l29.305">         if (!locator-&gt;by.fingerprint.length) {</span>
<a href="#l29.306"></a><span id="l29.306">             FFI_LOG(ffi, &quot;Invalid fingerprint: %s&quot;, identifier);</span>
<a href="#l29.307"></a><span id="l29.307">             return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.308"></a><span id="l29.308" class="difflineat">@@ -3333,18 +3337,18 @@ locator_to_str(const pgp_key_search_t *l</span>
<a href="#l29.309"></a><span id="l29.309">     switch (locator-&gt;type) {</span>
<a href="#l29.310"></a><span id="l29.310">     case PGP_KEY_SEARCH_USERID:</span>
<a href="#l29.311"></a><span id="l29.311">         if (snprintf(identifier, identifier_size, &quot;%s&quot;, locator-&gt;by.userid) &gt;=</span>
<a href="#l29.312"></a><span id="l29.312">             (int) identifier_size) {</span>
<a href="#l29.313"></a><span id="l29.313">             return false;</span>
<a href="#l29.314"></a><span id="l29.314">         }</span>
<a href="#l29.315"></a><span id="l29.315">         break;</span>
<a href="#l29.316"></a><span id="l29.316">     case PGP_KEY_SEARCH_KEYID:</span>
<a href="#l29.317"></a><span id="l29.317" class="difflineminus">-        if (!rnp_hex_encode(locator-&gt;by.keyid,</span>
<a href="#l29.318"></a><span id="l29.318" class="difflineminus">-                            PGP_KEY_ID_SIZE,</span>
<a href="#l29.319"></a><span id="l29.319" class="difflineplus">+        if (!rnp_hex_encode(locator-&gt;by.keyid.data(),</span>
<a href="#l29.320"></a><span id="l29.320" class="difflineplus">+                            locator-&gt;by.keyid.size(),</span>
<a href="#l29.321"></a><span id="l29.321">                             identifier,</span>
<a href="#l29.322"></a><span id="l29.322">                             identifier_size,</span>
<a href="#l29.323"></a><span id="l29.323">                             RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.324"></a><span id="l29.324">             return false;</span>
<a href="#l29.325"></a><span id="l29.325">         }</span>
<a href="#l29.326"></a><span id="l29.326">         break;</span>
<a href="#l29.327"></a><span id="l29.327">     case PGP_KEY_SEARCH_FINGERPRINT:</span>
<a href="#l29.328"></a><span id="l29.328">         if (!rnp_hex_encode(locator-&gt;by.fingerprint.fingerprint,</span>
<a href="#l29.329"></a><span id="l29.329" class="difflineat">@@ -3482,18 +3486,18 @@ rnp_key_export(rnp_key_handle_t handle, </span>
<a href="#l29.330"></a><span id="l29.330">         }</span>
<a href="#l29.331"></a><span id="l29.331">     } else {</span>
<a href="#l29.332"></a><span id="l29.332">         // subkeys flag is only valid for primary</span>
<a href="#l29.333"></a><span id="l29.333">         if (export_subs) {</span>
<a href="#l29.334"></a><span id="l29.334">             FFI_LOG(handle-&gt;ffi, &quot;export with subkeys requested but key is not primary&quot;);</span>
<a href="#l29.335"></a><span id="l29.335">             return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.336"></a><span id="l29.336">         }</span>
<a href="#l29.337"></a><span id="l29.337">         // subkey, write the primary + this subkey only</span>
<a href="#l29.338"></a><span id="l29.338" class="difflineminus">-        pgp_key_t *primary;</span>
<a href="#l29.339"></a><span id="l29.339" class="difflineminus">-        if (!(primary = rnp_key_store_get_key_by_grip(store, pgp_key_get_primary_grip(key)))) {</span>
<a href="#l29.340"></a><span id="l29.340" class="difflineplus">+        pgp_key_t *primary = rnp_key_store_get_primary_key(store, key);</span>
<a href="#l29.341"></a><span id="l29.341" class="difflineplus">+        if (!primary) {</span>
<a href="#l29.342"></a><span id="l29.342">             // shouldn't happen</span>
<a href="#l29.343"></a><span id="l29.343">             return RNP_ERROR_GENERIC;</span>
<a href="#l29.344"></a><span id="l29.344">         }</span>
<a href="#l29.345"></a><span id="l29.345">         if (!pgp_key_write_xfer(dst, primary, NULL)) {</span>
<a href="#l29.346"></a><span id="l29.346">             return RNP_ERROR_GENERIC;</span>
<a href="#l29.347"></a><span id="l29.347">         }</span>
<a href="#l29.348"></a><span id="l29.348">         if (!pgp_key_write_xfer(dst, key, NULL)) {</span>
<a href="#l29.349"></a><span id="l29.349">             return RNP_ERROR_GENERIC;</span>
<a href="#l29.350"></a><span id="l29.350" class="difflineat">@@ -5110,25 +5114,25 @@ static pgp_key_t *</span>
<a href="#l29.351"></a><span id="l29.351"> get_key_require_public(rnp_key_handle_t handle)</span>
<a href="#l29.352"></a><span id="l29.352"> {</span>
<a href="#l29.353"></a><span id="l29.353">     if (!handle-&gt;pub) {</span>
<a href="#l29.354"></a><span id="l29.354">         pgp_key_request_ctx_t request;</span>
<a href="#l29.355"></a><span id="l29.355">         request.secret = false;</span>
<a href="#l29.356"></a><span id="l29.356"> </span>
<a href="#l29.357"></a><span id="l29.357">         // try fingerprint</span>
<a href="#l29.358"></a><span id="l29.358">         request.search.type = PGP_KEY_SEARCH_FINGERPRINT;</span>
<a href="#l29.359"></a><span id="l29.359" class="difflineminus">-        request.search.by.fingerprint = *pgp_key_get_fp(handle-&gt;sec);</span>
<a href="#l29.360"></a><span id="l29.360" class="difflineplus">+        request.search.by.fingerprint = pgp_key_get_fp(handle-&gt;sec);</span>
<a href="#l29.361"></a><span id="l29.361">         handle-&gt;pub = pgp_request_key(&amp;handle-&gt;ffi-&gt;key_provider, &amp;request);</span>
<a href="#l29.362"></a><span id="l29.362">         if (handle-&gt;pub) {</span>
<a href="#l29.363"></a><span id="l29.363">             return handle-&gt;pub;</span>
<a href="#l29.364"></a><span id="l29.364">         }</span>
<a href="#l29.365"></a><span id="l29.365"> </span>
<a href="#l29.366"></a><span id="l29.366">         // try keyid</span>
<a href="#l29.367"></a><span id="l29.367">         request.search.type = PGP_KEY_SEARCH_KEYID;</span>
<a href="#l29.368"></a><span id="l29.368" class="difflineminus">-        memcpy(request.search.by.keyid, pgp_key_get_keyid(handle-&gt;sec), PGP_KEY_ID_SIZE);</span>
<a href="#l29.369"></a><span id="l29.369" class="difflineplus">+        request.search.by.keyid = pgp_key_get_keyid(handle-&gt;sec);</span>
<a href="#l29.370"></a><span id="l29.370">         handle-&gt;pub = pgp_request_key(&amp;handle-&gt;ffi-&gt;key_provider, &amp;request);</span>
<a href="#l29.371"></a><span id="l29.371">     }</span>
<a href="#l29.372"></a><span id="l29.372">     return handle-&gt;pub;</span>
<a href="#l29.373"></a><span id="l29.373"> }</span>
<a href="#l29.374"></a><span id="l29.374"> </span>
<a href="#l29.375"></a><span id="l29.375"> static pgp_key_t *</span>
<a href="#l29.376"></a><span id="l29.376"> get_key_prefer_public(rnp_key_handle_t handle)</span>
<a href="#l29.377"></a><span id="l29.377"> {</span>
<a href="#l29.378"></a><span id="l29.378" class="difflineat">@@ -5140,25 +5144,25 @@ static pgp_key_t *</span>
<a href="#l29.379"></a><span id="l29.379"> get_key_require_secret(rnp_key_handle_t handle)</span>
<a href="#l29.380"></a><span id="l29.380"> {</span>
<a href="#l29.381"></a><span id="l29.381">     if (!handle-&gt;sec) {</span>
<a href="#l29.382"></a><span id="l29.382">         pgp_key_request_ctx_t request;</span>
<a href="#l29.383"></a><span id="l29.383">         request.secret = true;</span>
<a href="#l29.384"></a><span id="l29.384"> </span>
<a href="#l29.385"></a><span id="l29.385">         // try fingerprint</span>
<a href="#l29.386"></a><span id="l29.386">         request.search.type = PGP_KEY_SEARCH_FINGERPRINT;</span>
<a href="#l29.387"></a><span id="l29.387" class="difflineminus">-        request.search.by.fingerprint = *pgp_key_get_fp(handle-&gt;pub);</span>
<a href="#l29.388"></a><span id="l29.388" class="difflineplus">+        request.search.by.fingerprint = pgp_key_get_fp(handle-&gt;pub);</span>
<a href="#l29.389"></a><span id="l29.389">         handle-&gt;sec = pgp_request_key(&amp;handle-&gt;ffi-&gt;key_provider, &amp;request);</span>
<a href="#l29.390"></a><span id="l29.390">         if (handle-&gt;sec) {</span>
<a href="#l29.391"></a><span id="l29.391">             return handle-&gt;sec;</span>
<a href="#l29.392"></a><span id="l29.392">         }</span>
<a href="#l29.393"></a><span id="l29.393"> </span>
<a href="#l29.394"></a><span id="l29.394">         // try keyid</span>
<a href="#l29.395"></a><span id="l29.395">         request.search.type = PGP_KEY_SEARCH_KEYID;</span>
<a href="#l29.396"></a><span id="l29.396" class="difflineminus">-        memcpy(request.search.by.keyid, pgp_key_get_keyid(handle-&gt;pub), PGP_KEY_ID_SIZE);</span>
<a href="#l29.397"></a><span id="l29.397" class="difflineplus">+        request.search.by.keyid = pgp_key_get_keyid(handle-&gt;pub);</span>
<a href="#l29.398"></a><span id="l29.398">         handle-&gt;sec = pgp_request_key(&amp;handle-&gt;ffi-&gt;key_provider, &amp;request);</span>
<a href="#l29.399"></a><span id="l29.399">     }</span>
<a href="#l29.400"></a><span id="l29.400">     return handle-&gt;sec;</span>
<a href="#l29.401"></a><span id="l29.401"> }</span>
<a href="#l29.402"></a><span id="l29.402"> </span>
<a href="#l29.403"></a><span id="l29.403"> static rnp_result_t</span>
<a href="#l29.404"></a><span id="l29.404"> key_get_uid_at(pgp_key_t *key, size_t idx, char **uid)</span>
<a href="#l29.405"></a><span id="l29.405"> {</span>
<a href="#l29.406"></a><span id="l29.406" class="difflineat">@@ -5432,23 +5436,22 @@ rnp_result_t</span>
<a href="#l29.407"></a><span id="l29.407"> rnp_signature_get_keyid(rnp_signature_handle_t handle, char **result)</span>
<a href="#l29.408"></a><span id="l29.408"> {</span>
<a href="#l29.409"></a><span id="l29.409">     if (!handle || !result) {</span>
<a href="#l29.410"></a><span id="l29.410">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.411"></a><span id="l29.411">     }</span>
<a href="#l29.412"></a><span id="l29.412">     if (!handle-&gt;sig) {</span>
<a href="#l29.413"></a><span id="l29.413">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.414"></a><span id="l29.414">     }</span>
<a href="#l29.415"></a><span id="l29.415" class="difflineminus">-    uint8_t keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l29.416"></a><span id="l29.416" class="difflineplus">+    pgp_key_id_t keyid = {};</span>
<a href="#l29.417"></a><span id="l29.417">     if (!signature_get_keyid(&amp;handle-&gt;sig-&gt;sig, keyid)) {</span>
<a href="#l29.418"></a><span id="l29.418">         *result = NULL;</span>
<a href="#l29.419"></a><span id="l29.419">         return RNP_SUCCESS;</span>
<a href="#l29.420"></a><span id="l29.420">     }</span>
<a href="#l29.421"></a><span id="l29.421" class="difflineminus">-</span>
<a href="#l29.422"></a><span id="l29.422" class="difflineminus">-    return hex_encode_value(keyid, PGP_KEY_ID_SIZE, result, RNP_HEX_UPPERCASE);</span>
<a href="#l29.423"></a><span id="l29.423" class="difflineplus">+    return hex_encode_value(keyid.data(), keyid.size(), result, RNP_HEX_UPPERCASE);</span>
<a href="#l29.424"></a><span id="l29.424"> }</span>
<a href="#l29.425"></a><span id="l29.425"> </span>
<a href="#l29.426"></a><span id="l29.426"> rnp_result_t</span>
<a href="#l29.427"></a><span id="l29.427"> rnp_signature_get_signer(rnp_signature_handle_t sig, rnp_key_handle_t *key)</span>
<a href="#l29.428"></a><span id="l29.428"> {</span>
<a href="#l29.429"></a><span id="l29.429">     char *       keyid = NULL;</span>
<a href="#l29.430"></a><span id="l29.430">     rnp_result_t ret = rnp_signature_get_keyid(sig, &amp;keyid);</span>
<a href="#l29.431"></a><span id="l29.431">     if (ret) {</span>
<a href="#l29.432"></a><span id="l29.432" class="difflineat">@@ -5542,23 +5545,22 @@ rnp_key_get_subkey_at(rnp_key_handle_t h</span>
<a href="#l29.433"></a><span id="l29.433"> {</span>
<a href="#l29.434"></a><span id="l29.434">     if (!handle || !subkey) {</span>
<a href="#l29.435"></a><span id="l29.435">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.436"></a><span id="l29.436">     }</span>
<a href="#l29.437"></a><span id="l29.437">     pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l29.438"></a><span id="l29.438">     if (idx &gt;= pgp_key_get_subkey_count(key)) {</span>
<a href="#l29.439"></a><span id="l29.439">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.440"></a><span id="l29.440">     }</span>
<a href="#l29.441"></a><span id="l29.441" class="difflineminus">-    const pgp_key_grip_t &amp;grip = pgp_key_get_subkey_grip(key, idx);</span>
<a href="#l29.442"></a><span id="l29.442" class="difflineminus">-    char                  griphex[PGP_KEY_GRIP_SIZE * 2 + 1] = {0};</span>
<a href="#l29.443"></a><span id="l29.443" class="difflineminus">-    if (!rnp_hex_encode(</span>
<a href="#l29.444"></a><span id="l29.444" class="difflineminus">-          grip.data(), grip.size(), griphex, sizeof(griphex), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.445"></a><span id="l29.445" class="difflineplus">+    const pgp_fingerprint_t &amp;fp = pgp_key_get_subkey_fp(key, idx);</span>
<a href="#l29.446"></a><span id="l29.446" class="difflineplus">+    char                     fphex[PGP_FINGERPRINT_SIZE * 2 + 1] = {0};</span>
<a href="#l29.447"></a><span id="l29.447" class="difflineplus">+    if (!rnp_hex_encode(fp.fingerprint, fp.length, fphex, sizeof(fphex), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.448"></a><span id="l29.448">         return RNP_ERROR_BAD_STATE;</span>
<a href="#l29.449"></a><span id="l29.449">     }</span>
<a href="#l29.450"></a><span id="l29.450" class="difflineminus">-    return rnp_locate_key(handle-&gt;ffi, &quot;grip&quot;, griphex, subkey);</span>
<a href="#l29.451"></a><span id="l29.451" class="difflineplus">+    return rnp_locate_key(handle-&gt;ffi, &quot;fingerprint&quot;, fphex, subkey);</span>
<a href="#l29.452"></a><span id="l29.452"> }</span>
<a href="#l29.453"></a><span id="l29.453"> </span>
<a href="#l29.454"></a><span id="l29.454"> rnp_result_t</span>
<a href="#l29.455"></a><span id="l29.455"> rnp_key_get_alg(rnp_key_handle_t handle, char **alg)</span>
<a href="#l29.456"></a><span id="l29.456"> {</span>
<a href="#l29.457"></a><span id="l29.457">     if (!handle || !alg) {</span>
<a href="#l29.458"></a><span id="l29.458">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.459"></a><span id="l29.459">     }</span>
<a href="#l29.460"></a><span id="l29.460" class="difflineat">@@ -5622,59 +5624,96 @@ rnp_key_get_curve(rnp_key_handle_t handl</span>
<a href="#l29.461"></a><span id="l29.461"> </span>
<a href="#l29.462"></a><span id="l29.462"> rnp_result_t</span>
<a href="#l29.463"></a><span id="l29.463"> rnp_key_get_fprint(rnp_key_handle_t handle, char **fprint)</span>
<a href="#l29.464"></a><span id="l29.464"> {</span>
<a href="#l29.465"></a><span id="l29.465">     if (!handle || !fprint) {</span>
<a href="#l29.466"></a><span id="l29.466">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.467"></a><span id="l29.467">     }</span>
<a href="#l29.468"></a><span id="l29.468"> </span>
<a href="#l29.469"></a><span id="l29.469" class="difflineminus">-    const pgp_fingerprint_t *fp = pgp_key_get_fp(get_key_prefer_public(handle));</span>
<a href="#l29.470"></a><span id="l29.470" class="difflineminus">-    return hex_encode_value(fp-&gt;fingerprint, fp-&gt;length, fprint, RNP_HEX_UPPERCASE);</span>
<a href="#l29.471"></a><span id="l29.471" class="difflineplus">+    const pgp_fingerprint_t &amp;fp = pgp_key_get_fp(get_key_prefer_public(handle));</span>
<a href="#l29.472"></a><span id="l29.472" class="difflineplus">+    return hex_encode_value(fp.fingerprint, fp.length, fprint, RNP_HEX_UPPERCASE);</span>
<a href="#l29.473"></a><span id="l29.473"> }</span>
<a href="#l29.474"></a><span id="l29.474"> </span>
<a href="#l29.475"></a><span id="l29.475"> rnp_result_t</span>
<a href="#l29.476"></a><span id="l29.476"> rnp_key_get_keyid(rnp_key_handle_t handle, char **keyid)</span>
<a href="#l29.477"></a><span id="l29.477"> {</span>
<a href="#l29.478"></a><span id="l29.478">     if (!handle || !keyid) {</span>
<a href="#l29.479"></a><span id="l29.479">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.480"></a><span id="l29.480">     }</span>
<a href="#l29.481"></a><span id="l29.481"> </span>
<a href="#l29.482"></a><span id="l29.482">     pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l29.483"></a><span id="l29.483" class="difflineminus">-    return hex_encode_value(pgp_key_get_keyid(key), PGP_KEY_ID_SIZE, keyid, RNP_HEX_UPPERCASE);</span>
<a href="#l29.484"></a><span id="l29.484" class="difflineplus">+    return hex_encode_value(</span>
<a href="#l29.485"></a><span id="l29.485" class="difflineplus">+      pgp_key_get_keyid(key).data(), pgp_key_get_keyid(key).size(), keyid, RNP_HEX_UPPERCASE);</span>
<a href="#l29.486"></a><span id="l29.486"> }</span>
<a href="#l29.487"></a><span id="l29.487"> </span>
<a href="#l29.488"></a><span id="l29.488"> rnp_result_t</span>
<a href="#l29.489"></a><span id="l29.489"> rnp_key_get_grip(rnp_key_handle_t handle, char **grip)</span>
<a href="#l29.490"></a><span id="l29.490"> {</span>
<a href="#l29.491"></a><span id="l29.491">     if (!handle || !grip) {</span>
<a href="#l29.492"></a><span id="l29.492">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.493"></a><span id="l29.493">     }</span>
<a href="#l29.494"></a><span id="l29.494"> </span>
<a href="#l29.495"></a><span id="l29.495">     const pgp_key_grip_t &amp;kgrip = pgp_key_get_grip(get_key_prefer_public(handle));</span>
<a href="#l29.496"></a><span id="l29.496">     return hex_encode_value(kgrip.data(), kgrip.size(), grip, RNP_HEX_UPPERCASE);</span>
<a href="#l29.497"></a><span id="l29.497"> }</span>
<a href="#l29.498"></a><span id="l29.498"> </span>
<a href="#l29.499"></a><span id="l29.499" class="difflineplus">+static const pgp_key_grip_t *</span>
<a href="#l29.500"></a><span id="l29.500" class="difflineplus">+rnp_get_grip_by_fp(rnp_ffi_t ffi, const pgp_fingerprint_t &amp;fp)</span>
<a href="#l29.501"></a><span id="l29.501" class="difflineplus">+{</span>
<a href="#l29.502"></a><span id="l29.502" class="difflineplus">+    pgp_key_t *key = NULL;</span>
<a href="#l29.503"></a><span id="l29.503" class="difflineplus">+    if (ffi-&gt;pubring) {</span>
<a href="#l29.504"></a><span id="l29.504" class="difflineplus">+        key = rnp_key_store_get_key_by_fpr(ffi-&gt;pubring, fp);</span>
<a href="#l29.505"></a><span id="l29.505" class="difflineplus">+    }</span>
<a href="#l29.506"></a><span id="l29.506" class="difflineplus">+    if (!key &amp;&amp; ffi-&gt;secring) {</span>
<a href="#l29.507"></a><span id="l29.507" class="difflineplus">+        key = rnp_key_store_get_key_by_fpr(ffi-&gt;secring, fp);</span>
<a href="#l29.508"></a><span id="l29.508" class="difflineplus">+    }</span>
<a href="#l29.509"></a><span id="l29.509" class="difflineplus">+    return key ? &amp;pgp_key_get_grip(key) : NULL;</span>
<a href="#l29.510"></a><span id="l29.510" class="difflineplus">+}</span>
<a href="#l29.511"></a><span id="l29.511" class="difflineplus">+</span>
<a href="#l29.512"></a><span id="l29.512"> rnp_result_t</span>
<a href="#l29.513"></a><span id="l29.513"> rnp_key_get_primary_grip(rnp_key_handle_t handle, char **grip)</span>
<a href="#l29.514"></a><span id="l29.514"> {</span>
<a href="#l29.515"></a><span id="l29.515">     if (!handle || !grip) {</span>
<a href="#l29.516"></a><span id="l29.516">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.517"></a><span id="l29.517">     }</span>
<a href="#l29.518"></a><span id="l29.518"> </span>
<a href="#l29.519"></a><span id="l29.519">     pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l29.520"></a><span id="l29.520">     if (!pgp_key_is_subkey(key)) {</span>
<a href="#l29.521"></a><span id="l29.521">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.522"></a><span id="l29.522">     }</span>
<a href="#l29.523"></a><span id="l29.523" class="difflineminus">-    if (!pgp_key_has_primary_grip(key)) {</span>
<a href="#l29.524"></a><span id="l29.524" class="difflineplus">+    if (!pgp_key_has_primary_fp(key)) {</span>
<a href="#l29.525"></a><span id="l29.525" class="difflineplus">+        *grip = NULL;</span>
<a href="#l29.526"></a><span id="l29.526" class="difflineplus">+        return RNP_SUCCESS;</span>
<a href="#l29.527"></a><span id="l29.527" class="difflineplus">+    }</span>
<a href="#l29.528"></a><span id="l29.528" class="difflineplus">+    const pgp_key_grip_t *pgrip = rnp_get_grip_by_fp(handle-&gt;ffi, pgp_key_get_primary_fp(key));</span>
<a href="#l29.529"></a><span id="l29.529" class="difflineplus">+    if (!pgrip) {</span>
<a href="#l29.530"></a><span id="l29.530">         *grip = NULL;</span>
<a href="#l29.531"></a><span id="l29.531">         return RNP_SUCCESS;</span>
<a href="#l29.532"></a><span id="l29.532">     }</span>
<a href="#l29.533"></a><span id="l29.533" class="difflineminus">-    const pgp_key_grip_t &amp;pgrip = pgp_key_get_primary_grip(key);</span>
<a href="#l29.534"></a><span id="l29.534" class="difflineminus">-    return hex_encode_value(pgrip.data(), pgrip.size(), grip, RNP_HEX_UPPERCASE);</span>
<a href="#l29.535"></a><span id="l29.535" class="difflineplus">+    return hex_encode_value(pgrip-&gt;data(), pgrip-&gt;size(), grip, RNP_HEX_UPPERCASE);</span>
<a href="#l29.536"></a><span id="l29.536" class="difflineplus">+}</span>
<a href="#l29.537"></a><span id="l29.537" class="difflineplus">+</span>
<a href="#l29.538"></a><span id="l29.538" class="difflineplus">+rnp_result_t</span>
<a href="#l29.539"></a><span id="l29.539" class="difflineplus">+rnp_key_get_primary_fprint(rnp_key_handle_t handle, char **fprint)</span>
<a href="#l29.540"></a><span id="l29.540" class="difflineplus">+{</span>
<a href="#l29.541"></a><span id="l29.541" class="difflineplus">+    if (!handle || !fprint) {</span>
<a href="#l29.542"></a><span id="l29.542" class="difflineplus">+        return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.543"></a><span id="l29.543" class="difflineplus">+    }</span>
<a href="#l29.544"></a><span id="l29.544" class="difflineplus">+</span>
<a href="#l29.545"></a><span id="l29.545" class="difflineplus">+    pgp_key_t *key = get_key_prefer_public(handle);</span>
<a href="#l29.546"></a><span id="l29.546" class="difflineplus">+    if (!pgp_key_is_subkey(key)) {</span>
<a href="#l29.547"></a><span id="l29.547" class="difflineplus">+        return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.548"></a><span id="l29.548" class="difflineplus">+    }</span>
<a href="#l29.549"></a><span id="l29.549" class="difflineplus">+    if (!pgp_key_has_primary_fp(key)) {</span>
<a href="#l29.550"></a><span id="l29.550" class="difflineplus">+        *fprint = NULL;</span>
<a href="#l29.551"></a><span id="l29.551" class="difflineplus">+        return RNP_SUCCESS;</span>
<a href="#l29.552"></a><span id="l29.552" class="difflineplus">+    }</span>
<a href="#l29.553"></a><span id="l29.553" class="difflineplus">+    const pgp_fingerprint_t &amp;fp = pgp_key_get_primary_fp(key);</span>
<a href="#l29.554"></a><span id="l29.554" class="difflineplus">+    return hex_encode_value(fp.fingerprint, fp.length, fprint, RNP_HEX_UPPERCASE);</span>
<a href="#l29.555"></a><span id="l29.555"> }</span>
<a href="#l29.556"></a><span id="l29.556"> </span>
<a href="#l29.557"></a><span id="l29.557"> rnp_result_t</span>
<a href="#l29.558"></a><span id="l29.558"> rnp_key_allows_usage(rnp_key_handle_t handle, const char *usage, bool *result)</span>
<a href="#l29.559"></a><span id="l29.559"> {</span>
<a href="#l29.560"></a><span id="l29.560">     if (!handle || !usage || !result) {</span>
<a href="#l29.561"></a><span id="l29.561">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.562"></a><span id="l29.562">     }</span>
<a href="#l29.563"></a><span id="l29.563" class="difflineat">@@ -5745,38 +5784,49 @@ rnp_key_set_expiration(rnp_key_handle_t </span>
<a href="#l29.564"></a><span id="l29.564">     }</span>
<a href="#l29.565"></a><span id="l29.565">     pgp_key_t *skey = get_key_require_secret(key);</span>
<a href="#l29.566"></a><span id="l29.566">     if (!skey) {</span>
<a href="#l29.567"></a><span id="l29.567">         FFI_LOG(key-&gt;ffi, &quot;Secret key required.&quot;);</span>
<a href="#l29.568"></a><span id="l29.568">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.569"></a><span id="l29.569">     }</span>
<a href="#l29.570"></a><span id="l29.570"> </span>
<a href="#l29.571"></a><span id="l29.571">     if (pgp_key_is_primary_key(pkey)) {</span>
<a href="#l29.572"></a><span id="l29.572" class="difflineminus">-        bool res = pgp_key_set_expiration(pkey, skey, expiry);</span>
<a href="#l29.573"></a><span id="l29.573" class="difflineminus">-        return res ? RNP_SUCCESS : RNP_ERROR_GENERIC;</span>
<a href="#l29.574"></a><span id="l29.574" class="difflineplus">+        if (!pgp_key_set_expiration(pkey, skey, expiry, &amp;key-&gt;ffi-&gt;pass_provider)) {</span>
<a href="#l29.575"></a><span id="l29.575" class="difflineplus">+            return RNP_ERROR_GENERIC;</span>
<a href="#l29.576"></a><span id="l29.576" class="difflineplus">+        }</span>
<a href="#l29.577"></a><span id="l29.577" class="difflineplus">+        pgp_key_revalidate_updated(pkey, key-&gt;ffi-&gt;pubring);</span>
<a href="#l29.578"></a><span id="l29.578" class="difflineplus">+        if (pkey != skey) {</span>
<a href="#l29.579"></a><span id="l29.579" class="difflineplus">+            pgp_key_revalidate_updated(skey, key-&gt;ffi-&gt;secring);</span>
<a href="#l29.580"></a><span id="l29.580" class="difflineplus">+        }</span>
<a href="#l29.581"></a><span id="l29.581" class="difflineplus">+        return RNP_SUCCESS;</span>
<a href="#l29.582"></a><span id="l29.582">     }</span>
<a href="#l29.583"></a><span id="l29.583"> </span>
<a href="#l29.584"></a><span id="l29.584">     /* for subkey we need primary key */</span>
<a href="#l29.585"></a><span id="l29.585" class="difflineminus">-    if (!pgp_key_has_primary_grip(pkey)) {</span>
<a href="#l29.586"></a><span id="l29.586" class="difflineminus">-        FFI_LOG(key-&gt;ffi, &quot;Primary key grip not available.&quot;);</span>
<a href="#l29.587"></a><span id="l29.587" class="difflineplus">+    if (!pgp_key_has_primary_fp(pkey)) {</span>
<a href="#l29.588"></a><span id="l29.588" class="difflineplus">+        FFI_LOG(key-&gt;ffi, &quot;Primary key fp not available.&quot;);</span>
<a href="#l29.589"></a><span id="l29.589">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.590"></a><span id="l29.590">     }</span>
<a href="#l29.591"></a><span id="l29.591"> </span>
<a href="#l29.592"></a><span id="l29.592" class="difflineminus">-    pgp_key_request_ctx_t request = {};</span>
<a href="#l29.593"></a><span id="l29.593" class="difflineminus">-    request.secret = true;</span>
<a href="#l29.594"></a><span id="l29.594" class="difflineminus">-    request.search.type = PGP_KEY_SEARCH_GRIP;</span>
<a href="#l29.595"></a><span id="l29.595" class="difflineminus">-    request.search.by.grip = pgp_key_get_primary_grip(pkey);</span>
<a href="#l29.596"></a><span id="l29.596" class="difflineminus">-    pgp_key_t *prim_sec = pgp_request_key(&amp;key-&gt;ffi-&gt;key_provider, &amp;request);</span>
<a href="#l29.597"></a><span id="l29.597" class="difflineplus">+    pgp_key_search_t search = {};</span>
<a href="#l29.598"></a><span id="l29.598" class="difflineplus">+    search.type = PGP_KEY_SEARCH_FINGERPRINT;</span>
<a href="#l29.599"></a><span id="l29.599" class="difflineplus">+    search.by.fingerprint = pgp_key_get_primary_fp(pkey);</span>
<a href="#l29.600"></a><span id="l29.600" class="difflineplus">+    pgp_key_t *prim_sec = find_key(key-&gt;ffi, &amp;search, KEY_TYPE_SECRET, true);</span>
<a href="#l29.601"></a><span id="l29.601">     if (!prim_sec) {</span>
<a href="#l29.602"></a><span id="l29.602">         FFI_LOG(key-&gt;ffi, &quot;Primary secret key not found.&quot;);</span>
<a href="#l29.603"></a><span id="l29.603">         return RNP_ERROR_KEY_NOT_FOUND;</span>
<a href="#l29.604"></a><span id="l29.604">     }</span>
<a href="#l29.605"></a><span id="l29.605" class="difflineminus">-</span>
<a href="#l29.606"></a><span id="l29.606" class="difflineminus">-    bool res = pgp_subkey_set_expiration(pkey, prim_sec, skey, expiry);</span>
<a href="#l29.607"></a><span id="l29.607" class="difflineminus">-    return res ? RNP_SUCCESS : RNP_ERROR_GENERIC;</span>
<a href="#l29.608"></a><span id="l29.608" class="difflineplus">+    if (!pgp_subkey_set_expiration(pkey, prim_sec, skey, expiry, &amp;key-&gt;ffi-&gt;pass_provider)) {</span>
<a href="#l29.609"></a><span id="l29.609" class="difflineplus">+        return RNP_ERROR_GENERIC;</span>
<a href="#l29.610"></a><span id="l29.610" class="difflineplus">+    }</span>
<a href="#l29.611"></a><span id="l29.611" class="difflineplus">+    pgp_key_revalidate_updated(prim_sec, key-&gt;ffi-&gt;secring);</span>
<a href="#l29.612"></a><span id="l29.612" class="difflineplus">+    pgp_key_t *prim_pub = find_key(key-&gt;ffi, &amp;search, KEY_TYPE_PUBLIC, true);</span>
<a href="#l29.613"></a><span id="l29.613" class="difflineplus">+    if (prim_pub) {</span>
<a href="#l29.614"></a><span id="l29.614" class="difflineplus">+        pgp_key_revalidate_updated(prim_pub, key-&gt;ffi-&gt;pubring);</span>
<a href="#l29.615"></a><span id="l29.615" class="difflineplus">+    }</span>
<a href="#l29.616"></a><span id="l29.616" class="difflineplus">+    return RNP_SUCCESS;</span>
<a href="#l29.617"></a><span id="l29.617"> }</span>
<a href="#l29.618"></a><span id="l29.618"> </span>
<a href="#l29.619"></a><span id="l29.619"> rnp_result_t</span>
<a href="#l29.620"></a><span id="l29.620"> rnp_key_get_revocation_reason(rnp_key_handle_t handle, char **result)</span>
<a href="#l29.621"></a><span id="l29.621"> {</span>
<a href="#l29.622"></a><span id="l29.622">     if (!handle || !result) {</span>
<a href="#l29.623"></a><span id="l29.623">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.624"></a><span id="l29.624">     }</span>
<a href="#l29.625"></a><span id="l29.625" class="difflineat">@@ -6428,21 +6478,21 @@ add_json_subsig(json_object *jso, bool i</span>
<a href="#l29.626"></a><span id="l29.626">     // signer</span>
<a href="#l29.627"></a><span id="l29.627">     json_object *jsosigner = NULL;</span>
<a href="#l29.628"></a><span id="l29.628">     // TODO: add signer fingerprint as well (no support internally yet)</span>
<a href="#l29.629"></a><span id="l29.629">     if (signature_has_keyid(sig)) {</span>
<a href="#l29.630"></a><span id="l29.630">         jsosigner = json_object_new_object();</span>
<a href="#l29.631"></a><span id="l29.631">         if (!jsosigner) {</span>
<a href="#l29.632"></a><span id="l29.632">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.633"></a><span id="l29.633">         }</span>
<a href="#l29.634"></a><span id="l29.634" class="difflineminus">-        char    keyid[PGP_KEY_ID_SIZE * 2 + 1];</span>
<a href="#l29.635"></a><span id="l29.635" class="difflineminus">-        uint8_t signer[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l29.636"></a><span id="l29.636" class="difflineplus">+        char         keyid[PGP_KEY_ID_SIZE * 2 + 1];</span>
<a href="#l29.637"></a><span id="l29.637" class="difflineplus">+        pgp_key_id_t signer = {};</span>
<a href="#l29.638"></a><span id="l29.638">         if (!signature_get_keyid(sig, signer) ||</span>
<a href="#l29.639"></a><span id="l29.639">             !rnp_hex_encode(</span>
<a href="#l29.640"></a><span id="l29.640" class="difflineminus">-              signer, PGP_KEY_ID_SIZE, keyid, sizeof(keyid), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.641"></a><span id="l29.641" class="difflineplus">+              signer.data(), signer.size(), keyid, sizeof(keyid), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.642"></a><span id="l29.642">             return RNP_ERROR_GENERIC;</span>
<a href="#l29.643"></a><span id="l29.643">         }</span>
<a href="#l29.644"></a><span id="l29.644">         if (!add_json_string_field(jsosigner, &quot;keyid&quot;, keyid)) {</span>
<a href="#l29.645"></a><span id="l29.645">             json_object_put(jsosigner);</span>
<a href="#l29.646"></a><span id="l29.646">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.647"></a><span id="l29.647">         }</span>
<a href="#l29.648"></a><span id="l29.648">     }</span>
<a href="#l29.649"></a><span id="l29.649">     json_object_object_add(jso, &quot;signer&quot;, jsosigner);</span>
<a href="#l29.650"></a><span id="l29.650" class="difflineat">@@ -6522,27 +6572,30 @@ key_to_json(json_object *jso, rnp_key_ha</span>
<a href="#l29.651"></a><span id="l29.651">         json_object_object_add(jso, &quot;curve&quot;, jsocurve);</span>
<a href="#l29.652"></a><span id="l29.652">     } break;</span>
<a href="#l29.653"></a><span id="l29.653">     default:</span>
<a href="#l29.654"></a><span id="l29.654">         break;</span>
<a href="#l29.655"></a><span id="l29.655">     }</span>
<a href="#l29.656"></a><span id="l29.656"> </span>
<a href="#l29.657"></a><span id="l29.657">     // keyid</span>
<a href="#l29.658"></a><span id="l29.658">     char keyid[PGP_KEY_ID_SIZE * 2 + 1];</span>
<a href="#l29.659"></a><span id="l29.659" class="difflineminus">-    if (!rnp_hex_encode(</span>
<a href="#l29.660"></a><span id="l29.660" class="difflineminus">-          pgp_key_get_keyid(key), PGP_KEY_ID_SIZE, keyid, sizeof(keyid), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.661"></a><span id="l29.661" class="difflineplus">+    if (!rnp_hex_encode(pgp_key_get_keyid(key).data(),</span>
<a href="#l29.662"></a><span id="l29.662" class="difflineplus">+                        pgp_key_get_keyid(key).size(),</span>
<a href="#l29.663"></a><span id="l29.663" class="difflineplus">+                        keyid,</span>
<a href="#l29.664"></a><span id="l29.664" class="difflineplus">+                        sizeof(keyid),</span>
<a href="#l29.665"></a><span id="l29.665" class="difflineplus">+                        RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.666"></a><span id="l29.666">         return RNP_ERROR_GENERIC;</span>
<a href="#l29.667"></a><span id="l29.667">     }</span>
<a href="#l29.668"></a><span id="l29.668">     if (!add_json_string_field(jso, &quot;keyid&quot;, keyid)) {</span>
<a href="#l29.669"></a><span id="l29.669">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.670"></a><span id="l29.670">     }</span>
<a href="#l29.671"></a><span id="l29.671">     // fingerprint</span>
<a href="#l29.672"></a><span id="l29.672">     char fpr[PGP_FINGERPRINT_SIZE * 2 + 1];</span>
<a href="#l29.673"></a><span id="l29.673" class="difflineminus">-    if (!rnp_hex_encode(pgp_key_get_fp(key)-&gt;fingerprint,</span>
<a href="#l29.674"></a><span id="l29.674" class="difflineminus">-                        pgp_key_get_fp(key)-&gt;length,</span>
<a href="#l29.675"></a><span id="l29.675" class="difflineplus">+    if (!rnp_hex_encode(pgp_key_get_fp(key).fingerprint,</span>
<a href="#l29.676"></a><span id="l29.676" class="difflineplus">+                        pgp_key_get_fp(key).length,</span>
<a href="#l29.677"></a><span id="l29.677">                         fpr,</span>
<a href="#l29.678"></a><span id="l29.678">                         sizeof(fpr),</span>
<a href="#l29.679"></a><span id="l29.679">                         RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.680"></a><span id="l29.680">         return RNP_ERROR_GENERIC;</span>
<a href="#l29.681"></a><span id="l29.681">     }</span>
<a href="#l29.682"></a><span id="l29.682">     if (!add_json_string_field(jso, &quot;fingerprint&quot;, fpr)) {</span>
<a href="#l29.683"></a><span id="l29.683">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.684"></a><span id="l29.684">     }</span>
<a href="#l29.685"></a><span id="l29.685" class="difflineat">@@ -6586,35 +6639,42 @@ key_to_json(json_object *jso, rnp_key_ha</span>
<a href="#l29.686"></a><span id="l29.686">     }</span>
<a href="#l29.687"></a><span id="l29.687">     // parent / subkeys</span>
<a href="#l29.688"></a><span id="l29.688">     if (pgp_key_is_primary_key(key)) {</span>
<a href="#l29.689"></a><span id="l29.689">         json_object *jsosubkeys_arr = json_object_new_array();</span>
<a href="#l29.690"></a><span id="l29.690">         if (!jsosubkeys_arr) {</span>
<a href="#l29.691"></a><span id="l29.691">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.692"></a><span id="l29.692">         }</span>
<a href="#l29.693"></a><span id="l29.693">         json_object_object_add(jso, &quot;subkey grips&quot;, jsosubkeys_arr);</span>
<a href="#l29.694"></a><span id="l29.694" class="difflineminus">-        for (auto &amp;subgrip : key-&gt;subkey_grips) {</span>
<a href="#l29.695"></a><span id="l29.695" class="difflineplus">+        for (auto &amp;subfp : key-&gt;subkey_fps) {</span>
<a href="#l29.696"></a><span id="l29.696" class="difflineplus">+            const pgp_key_grip_t *subgrip = rnp_get_grip_by_fp(handle-&gt;ffi, subfp);</span>
<a href="#l29.697"></a><span id="l29.697" class="difflineplus">+            if (!subgrip) {</span>
<a href="#l29.698"></a><span id="l29.698" class="difflineplus">+                continue;</span>
<a href="#l29.699"></a><span id="l29.699" class="difflineplus">+            }</span>
<a href="#l29.700"></a><span id="l29.700">             if (!rnp_hex_encode(</span>
<a href="#l29.701"></a><span id="l29.701" class="difflineminus">-                  subgrip.data(), subgrip.size(), grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.702"></a><span id="l29.702" class="difflineplus">+                  subgrip-&gt;data(), subgrip-&gt;size(), grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.703"></a><span id="l29.703">                 return RNP_ERROR_GENERIC;</span>
<a href="#l29.704"></a><span id="l29.704">             }</span>
<a href="#l29.705"></a><span id="l29.705">             json_object *jsostr = json_object_new_string(grip);</span>
<a href="#l29.706"></a><span id="l29.706">             if (!jsostr || json_object_array_add(jsosubkeys_arr, jsostr)) {</span>
<a href="#l29.707"></a><span id="l29.707">                 json_object_put(jsostr);</span>
<a href="#l29.708"></a><span id="l29.708">                 return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.709"></a><span id="l29.709">             }</span>
<a href="#l29.710"></a><span id="l29.710">         }</span>
<a href="#l29.711"></a><span id="l29.711" class="difflineminus">-    } else {</span>
<a href="#l29.712"></a><span id="l29.712" class="difflineminus">-        auto pgrip = pgp_key_get_primary_grip(key);</span>
<a href="#l29.713"></a><span id="l29.713" class="difflineminus">-        if (!rnp_hex_encode(</span>
<a href="#l29.714"></a><span id="l29.714" class="difflineminus">-              pgrip.data(), pgrip.size(), grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.715"></a><span id="l29.715" class="difflineminus">-            return RNP_ERROR_GENERIC;</span>
<a href="#l29.716"></a><span id="l29.716" class="difflineminus">-        }</span>
<a href="#l29.717"></a><span id="l29.717" class="difflineminus">-        if (!add_json_string_field(jso, &quot;primary key grip&quot;, grip)) {</span>
<a href="#l29.718"></a><span id="l29.718" class="difflineminus">-            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.719"></a><span id="l29.719" class="difflineplus">+    } else if (pgp_key_has_primary_fp(key)) {</span>
<a href="#l29.720"></a><span id="l29.720" class="difflineplus">+        auto                  pfp = pgp_key_get_primary_fp(key);</span>
<a href="#l29.721"></a><span id="l29.721" class="difflineplus">+        const pgp_key_grip_t *pgrip = rnp_get_grip_by_fp(handle-&gt;ffi, pfp);</span>
<a href="#l29.722"></a><span id="l29.722" class="difflineplus">+        if (pgrip) {</span>
<a href="#l29.723"></a><span id="l29.723" class="difflineplus">+            if (!rnp_hex_encode(</span>
<a href="#l29.724"></a><span id="l29.724" class="difflineplus">+                  pgrip-&gt;data(), pgrip-&gt;size(), grip, sizeof(grip), RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.725"></a><span id="l29.725" class="difflineplus">+                return RNP_ERROR_GENERIC;</span>
<a href="#l29.726"></a><span id="l29.726" class="difflineplus">+            }</span>
<a href="#l29.727"></a><span id="l29.727" class="difflineplus">+            if (!add_json_string_field(jso, &quot;primary key grip&quot;, grip)) {</span>
<a href="#l29.728"></a><span id="l29.728" class="difflineplus">+                return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.729"></a><span id="l29.729" class="difflineplus">+            }</span>
<a href="#l29.730"></a><span id="l29.730">         }</span>
<a href="#l29.731"></a><span id="l29.731">     }</span>
<a href="#l29.732"></a><span id="l29.732">     // public</span>
<a href="#l29.733"></a><span id="l29.733">     json_object *jsopublic = json_object_new_object();</span>
<a href="#l29.734"></a><span id="l29.734">     if (!jsopublic) {</span>
<a href="#l29.735"></a><span id="l29.735">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l29.736"></a><span id="l29.736">     }</span>
<a href="#l29.737"></a><span id="l29.737">     json_object_object_add(jso, &quot;public key&quot;, jsopublic);</span>
<a href="#l29.738"></a><span id="l29.738" class="difflineat">@@ -6952,25 +7012,26 @@ key_iter_first_item(rnp_identifier_itera</span>
<a href="#l29.739"></a><span id="l29.739">     return true;</span>
<a href="#l29.740"></a><span id="l29.740"> }</span>
<a href="#l29.741"></a><span id="l29.741"> </span>
<a href="#l29.742"></a><span id="l29.742"> static bool</span>
<a href="#l29.743"></a><span id="l29.743"> key_iter_get_item(const rnp_identifier_iterator_t it, char *buf, size_t buf_len)</span>
<a href="#l29.744"></a><span id="l29.744"> {</span>
<a href="#l29.745"></a><span id="l29.745">     const pgp_key_t *key = &amp;*it-&gt;keyp;</span>
<a href="#l29.746"></a><span id="l29.746">     switch (it-&gt;type) {</span>
<a href="#l29.747"></a><span id="l29.747" class="difflineminus">-    case PGP_KEY_SEARCH_KEYID:</span>
<a href="#l29.748"></a><span id="l29.748" class="difflineminus">-        if (!rnp_hex_encode(</span>
<a href="#l29.749"></a><span id="l29.749" class="difflineminus">-              pgp_key_get_keyid(key), PGP_KEY_ID_SIZE, buf, buf_len, RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.750"></a><span id="l29.750" class="difflineplus">+    case PGP_KEY_SEARCH_KEYID: {</span>
<a href="#l29.751"></a><span id="l29.751" class="difflineplus">+        const pgp_key_id_t &amp;keyid = pgp_key_get_keyid(key);</span>
<a href="#l29.752"></a><span id="l29.752" class="difflineplus">+        if (!rnp_hex_encode(keyid.data(), keyid.size(), buf, buf_len, RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.753"></a><span id="l29.753">             return false;</span>
<a href="#l29.754"></a><span id="l29.754">         }</span>
<a href="#l29.755"></a><span id="l29.755">         break;</span>
<a href="#l29.756"></a><span id="l29.756" class="difflineplus">+    }</span>
<a href="#l29.757"></a><span id="l29.757">     case PGP_KEY_SEARCH_FINGERPRINT:</span>
<a href="#l29.758"></a><span id="l29.758" class="difflineminus">-        if (!rnp_hex_encode(pgp_key_get_fp(key)-&gt;fingerprint,</span>
<a href="#l29.759"></a><span id="l29.759" class="difflineminus">-                            pgp_key_get_fp(key)-&gt;length,</span>
<a href="#l29.760"></a><span id="l29.760" class="difflineplus">+        if (!rnp_hex_encode(pgp_key_get_fp(key).fingerprint,</span>
<a href="#l29.761"></a><span id="l29.761" class="difflineplus">+                            pgp_key_get_fp(key).length,</span>
<a href="#l29.762"></a><span id="l29.762">                             buf,</span>
<a href="#l29.763"></a><span id="l29.763">                             buf_len,</span>
<a href="#l29.764"></a><span id="l29.764">                             RNP_HEX_UPPERCASE)) {</span>
<a href="#l29.765"></a><span id="l29.765">             return false;</span>
<a href="#l29.766"></a><span id="l29.766">         }</span>
<a href="#l29.767"></a><span id="l29.767">         break;</span>
<a href="#l29.768"></a><span id="l29.768">     case PGP_KEY_SEARCH_GRIP:</span>
<a href="#l29.769"></a><span id="l29.769">         if (!rnp_hex_encode(pgp_key_get_grip(key).data(),</span>
<a href="#l29.770"></a><span id="l29.770" class="difflineat">@@ -7157,8 +7218,28 @@ rnp_dearmor(rnp_input_t input, rnp_outpu</span>
<a href="#l29.771"></a><span id="l29.771"> {</span>
<a href="#l29.772"></a><span id="l29.772">     if (!input || !output) {</span>
<a href="#l29.773"></a><span id="l29.773">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.774"></a><span id="l29.774">     }</span>
<a href="#l29.775"></a><span id="l29.775">     rnp_result_t ret = rnp_dearmor_source(&amp;input-&gt;src, &amp;output-&gt;dst);</span>
<a href="#l29.776"></a><span id="l29.776">     output-&gt;keep = !ret;</span>
<a href="#l29.777"></a><span id="l29.777">     return ret;</span>
<a href="#l29.778"></a><span id="l29.778"> }</span>
<a href="#l29.779"></a><span id="l29.779" class="difflineplus">+</span>
<a href="#l29.780"></a><span id="l29.780" class="difflineplus">+rnp_result_t</span>
<a href="#l29.781"></a><span id="l29.781" class="difflineplus">+rnp_output_pipe(rnp_input_t input, rnp_output_t output)</span>
<a href="#l29.782"></a><span id="l29.782" class="difflineplus">+{</span>
<a href="#l29.783"></a><span id="l29.783" class="difflineplus">+    if (!input || !output) {</span>
<a href="#l29.784"></a><span id="l29.784" class="difflineplus">+        return RNP_ERROR_NULL_POINTER;</span>
<a href="#l29.785"></a><span id="l29.785" class="difflineplus">+    }</span>
<a href="#l29.786"></a><span id="l29.786" class="difflineplus">+    rnp_result_t ret = dst_write_src(&amp;input-&gt;src, &amp;output-&gt;dst);</span>
<a href="#l29.787"></a><span id="l29.787" class="difflineplus">+    output-&gt;keep = !ret;</span>
<a href="#l29.788"></a><span id="l29.788" class="difflineplus">+    return ret;</span>
<a href="#l29.789"></a><span id="l29.789" class="difflineplus">+}</span>
<a href="#l29.790"></a><span id="l29.790" class="difflineplus">+</span>
<a href="#l29.791"></a><span id="l29.791" class="difflineplus">+rnp_result_t</span>
<a href="#l29.792"></a><span id="l29.792" class="difflineplus">+rnp_output_armor_set_line_length(rnp_output_t output, size_t llen)</span>
<a href="#l29.793"></a><span id="l29.793" class="difflineplus">+{</span>
<a href="#l29.794"></a><span id="l29.794" class="difflineplus">+    if (!output || !llen) {</span>
<a href="#l29.795"></a><span id="l29.795" class="difflineplus">+        return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l29.796"></a><span id="l29.796" class="difflineplus">+    }</span>
<a href="#l29.797"></a><span id="l29.797" class="difflineplus">+    return armored_dst_set_line_length(&amp;output-&gt;dst, llen);</span>
<a href="#l29.798"></a><span id="l29.798" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/third_party/rnp/src/lib/types.h</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/third_party/rnp/src/lib/types.h</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -50,16 +50,17 @@</span>
<a href="#l30.4"></a><span id="l30.4">  */</span>
<a href="#l30.5"></a><span id="l30.5"> #ifndef TYPES_H_</span>
<a href="#l30.6"></a><span id="l30.6"> #define TYPES_H_</span>
<a href="#l30.7"></a><span id="l30.7"> </span>
<a href="#l30.8"></a><span id="l30.8"> #include &lt;stdint.h&gt;</span>
<a href="#l30.9"></a><span id="l30.9"> #include &lt;string&gt;</span>
<a href="#l30.10"></a><span id="l30.10"> #include &lt;vector&gt;</span>
<a href="#l30.11"></a><span id="l30.11"> #include &lt;array&gt;</span>
<a href="#l30.12"></a><span id="l30.12" class="difflineplus">+#include &lt;cstring&gt;</span>
<a href="#l30.13"></a><span id="l30.13"> </span>
<a href="#l30.14"></a><span id="l30.14"> #include &lt;rnp/rnp_def.h&gt;</span>
<a href="#l30.15"></a><span id="l30.15"> #include &quot;list.h&quot;</span>
<a href="#l30.16"></a><span id="l30.16"> #include &quot;crypto/common.h&quot;</span>
<a href="#l30.17"></a><span id="l30.17"> </span>
<a href="#l30.18"></a><span id="l30.18"> /* SHA1 Hash Size */</span>
<a href="#l30.19"></a><span id="l30.19"> #define PGP_SHA1_HASH_SIZE 20</span>
<a href="#l30.20"></a><span id="l30.20"> </span>
<a href="#l30.21"></a><span id="l30.21" class="difflineat">@@ -85,20 +86,37 @@ typedef struct pgp_hash_t pgp_hash_t;</span>
<a href="#l30.22"></a><span id="l30.22"> </span>
<a href="#l30.23"></a><span id="l30.23"> /** Revocation Reason type */</span>
<a href="#l30.24"></a><span id="l30.24"> typedef uint8_t pgp_ss_rr_code_t;</span>
<a href="#l30.25"></a><span id="l30.25"> </span>
<a href="#l30.26"></a><span id="l30.26"> /** pgp_fingerprint_t */</span>
<a href="#l30.27"></a><span id="l30.27"> typedef struct pgp_fingerprint_t {</span>
<a href="#l30.28"></a><span id="l30.28">     uint8_t  fingerprint[PGP_FINGERPRINT_SIZE];</span>
<a href="#l30.29"></a><span id="l30.29">     unsigned length;</span>
<a href="#l30.30"></a><span id="l30.30" class="difflineplus">+    bool     operator==(const pgp_fingerprint_t &amp;src) const;</span>
<a href="#l30.31"></a><span id="l30.31" class="difflineplus">+    bool     operator!=(const pgp_fingerprint_t &amp;src) const;</span>
<a href="#l30.32"></a><span id="l30.32"> } pgp_fingerprint_t;</span>
<a href="#l30.33"></a><span id="l30.33"> </span>
<a href="#l30.34"></a><span id="l30.34" class="difflineplus">+namespace std {</span>
<a href="#l30.35"></a><span id="l30.35" class="difflineplus">+template &lt;&gt; struct hash&lt;pgp_fingerprint_t&gt; {</span>
<a href="#l30.36"></a><span id="l30.36" class="difflineplus">+    std::size_t</span>
<a href="#l30.37"></a><span id="l30.37" class="difflineplus">+    operator()(pgp_fingerprint_t const &amp;fp) const noexcept</span>
<a href="#l30.38"></a><span id="l30.38" class="difflineplus">+    {</span>
<a href="#l30.39"></a><span id="l30.39" class="difflineplus">+        /* since fingerprint value is hash itself, we may use it's low bytes */</span>
<a href="#l30.40"></a><span id="l30.40" class="difflineplus">+        size_t res = 0;</span>
<a href="#l30.41"></a><span id="l30.41" class="difflineplus">+        std::memcpy(&amp;res, fp.fingerprint, sizeof(res));</span>
<a href="#l30.42"></a><span id="l30.42" class="difflineplus">+        return res;</span>
<a href="#l30.43"></a><span id="l30.43" class="difflineplus">+    }</span>
<a href="#l30.44"></a><span id="l30.44" class="difflineplus">+};</span>
<a href="#l30.45"></a><span id="l30.45" class="difflineplus">+} // namespace std</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineplus">+</span>
<a href="#l30.47"></a><span id="l30.47"> typedef std::array&lt;uint8_t, PGP_KEY_GRIP_SIZE&gt; pgp_key_grip_t;</span>
<a href="#l30.48"></a><span id="l30.48"> </span>
<a href="#l30.49"></a><span id="l30.49" class="difflineplus">+typedef std::array&lt;uint8_t, PGP_KEY_ID_SIZE&gt; pgp_key_id_t;</span>
<a href="#l30.50"></a><span id="l30.50" class="difflineplus">+</span>
<a href="#l30.51"></a><span id="l30.51"> /**</span>
<a href="#l30.52"></a><span id="l30.52">  * Type to keep public/secret key mpis without any openpgp-dependent data.</span>
<a href="#l30.53"></a><span id="l30.53">  */</span>
<a href="#l30.54"></a><span id="l30.54"> typedef struct pgp_key_material_t {</span>
<a href="#l30.55"></a><span id="l30.55">     pgp_pubkey_alg_t alg;    /* algorithm of the key */</span>
<a href="#l30.56"></a><span id="l30.56">     bool             secret; /* secret part of the key material is populated */</span>
<a href="#l30.57"></a><span id="l30.57"> </span>
<a href="#l30.58"></a><span id="l30.58">     union {</span>
<a href="#l30.59"></a><span id="l30.59" class="difflineat">@@ -188,18 +206,18 @@ typedef struct pgp_signature_t {</span>
<a href="#l30.60"></a><span id="l30.60">     pgp_hash_alg_t   halg;</span>
<a href="#l30.61"></a><span id="l30.61">     uint8_t          lbits[2];</span>
<a href="#l30.62"></a><span id="l30.62">     uint8_t *        hashed_data;</span>
<a href="#l30.63"></a><span id="l30.63">     size_t           hashed_len;</span>
<a href="#l30.64"></a><span id="l30.64"> </span>
<a href="#l30.65"></a><span id="l30.65">     pgp_signature_material_t material;</span>
<a href="#l30.66"></a><span id="l30.66"> </span>
<a href="#l30.67"></a><span id="l30.67">     /* v3 - only fields */</span>
<a href="#l30.68"></a><span id="l30.68" class="difflineminus">-    uint32_t creation_time;</span>
<a href="#l30.69"></a><span id="l30.69" class="difflineminus">-    uint8_t  signer[PGP_KEY_ID_SIZE];</span>
<a href="#l30.70"></a><span id="l30.70" class="difflineplus">+    uint32_t     creation_time;</span>
<a href="#l30.71"></a><span id="l30.71" class="difflineplus">+    pgp_key_id_t signer;</span>
<a href="#l30.72"></a><span id="l30.72"> </span>
<a href="#l30.73"></a><span id="l30.73">     /* v4 - only fields */</span>
<a href="#l30.74"></a><span id="l30.74">     list subpkts;</span>
<a href="#l30.75"></a><span id="l30.75"> } pgp_signature_t;</span>
<a href="#l30.76"></a><span id="l30.76"> </span>
<a href="#l30.77"></a><span id="l30.77"> /* Signature subpacket, see 5.2.3.1 in RFC 4880 and RFC 4880 bis 02 */</span>
<a href="#l30.78"></a><span id="l30.78"> typedef struct pgp_sig_subpkt_t {</span>
<a href="#l30.79"></a><span id="l30.79">     pgp_sig_subpacket_type_t type;         /* type of the subpacket */</span>
<a href="#l30.80"></a><span id="l30.80" class="difflineat">@@ -304,17 +322,17 @@ typedef enum {</span>
<a href="#l30.81"></a><span id="l30.81"> } pgp_key_server_prefs_t;</span>
<a href="#l30.82"></a><span id="l30.82"> </span>
<a href="#l30.83"></a><span id="l30.83"> /** pgp_one_pass_sig_t */</span>
<a href="#l30.84"></a><span id="l30.84"> typedef struct pgp_one_pass_sig_t {</span>
<a href="#l30.85"></a><span id="l30.85">     uint8_t          version;</span>
<a href="#l30.86"></a><span id="l30.86">     pgp_sig_type_t   type;</span>
<a href="#l30.87"></a><span id="l30.87">     pgp_hash_alg_t   halg;</span>
<a href="#l30.88"></a><span id="l30.88">     pgp_pubkey_alg_t palg;</span>
<a href="#l30.89"></a><span id="l30.89" class="difflineminus">-    uint8_t          keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l30.90"></a><span id="l30.90" class="difflineplus">+    pgp_key_id_t     keyid;</span>
<a href="#l30.91"></a><span id="l30.91">     unsigned         nested;</span>
<a href="#l30.92"></a><span id="l30.92"> } pgp_one_pass_sig_t;</span>
<a href="#l30.93"></a><span id="l30.93"> </span>
<a href="#l30.94"></a><span id="l30.94"> typedef struct pgp_literal_hdr_t {</span>
<a href="#l30.95"></a><span id="l30.95">     uint8_t  format;</span>
<a href="#l30.96"></a><span id="l30.96">     char     fname[256];</span>
<a href="#l30.97"></a><span id="l30.97">     uint8_t  fname_len;</span>
<a href="#l30.98"></a><span id="l30.98">     uint32_t timestamp;</span>
<a href="#l30.99"></a><span id="l30.99" class="difflineat">@@ -336,17 +354,17 @@ typedef enum {</span>
<a href="#l30.100"></a><span id="l30.100">     PGP_LDT_UTF8 = 'u',</span>
<a href="#l30.101"></a><span id="l30.101">     PGP_LDT_LOCAL = 'l',</span>
<a href="#l30.102"></a><span id="l30.102">     PGP_LDT_LOCAL2 = '1'</span>
<a href="#l30.103"></a><span id="l30.103"> } pgp_litdata_enum;</span>
<a href="#l30.104"></a><span id="l30.104"> </span>
<a href="#l30.105"></a><span id="l30.105"> /** public-key encrypted session key packet */</span>
<a href="#l30.106"></a><span id="l30.106"> typedef struct pgp_pk_sesskey_t {</span>
<a href="#l30.107"></a><span id="l30.107">     unsigned         version;</span>
<a href="#l30.108"></a><span id="l30.108" class="difflineminus">-    uint8_t          key_id[PGP_KEY_ID_SIZE];</span>
<a href="#l30.109"></a><span id="l30.109" class="difflineplus">+    pgp_key_id_t     key_id;</span>
<a href="#l30.110"></a><span id="l30.110">     pgp_pubkey_alg_t alg;</span>
<a href="#l30.111"></a><span id="l30.111"> </span>
<a href="#l30.112"></a><span id="l30.112">     pgp_encrypted_material_t material;</span>
<a href="#l30.113"></a><span id="l30.113"> } pgp_pk_sesskey_t;</span>
<a href="#l30.114"></a><span id="l30.114"> </span>
<a href="#l30.115"></a><span id="l30.115"> /** pkp_sk_sesskey_t */</span>
<a href="#l30.116"></a><span id="l30.116"> typedef struct {</span>
<a href="#l30.117"></a><span id="l30.117">     unsigned       version;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/third_party/rnp/src/lib/utils.h</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/third_party/rnp/src/lib/utils.h</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l31.4"></a><span id="l31.4"> /*</span>
<a href="#l31.5"></a><span id="l31.5" class="difflineminus">- * Copyright (c) 2017, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l31.6"></a><span id="l31.6" class="difflineplus">+ * Copyright (c) 2017-2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l31.7"></a><span id="l31.7">  * All rights reserved.</span>
<a href="#l31.8"></a><span id="l31.8">  *</span>
<a href="#l31.9"></a><span id="l31.9">  * Redistribution and use in source and binary forms, with or without</span>
<a href="#l31.10"></a><span id="l31.10">  * modification, are permitted provided that the following conditions</span>
<a href="#l31.11"></a><span id="l31.11">  * are met:</span>
<a href="#l31.12"></a><span id="l31.12">  * 1. Redistributions of source code must retain the above copyright</span>
<a href="#l31.13"></a><span id="l31.13">  *    notice, this list of conditions and the following disclaimer.</span>
<a href="#l31.14"></a><span id="l31.14">  * 2. Redistributions in binary form must reproduce the above copyright</span>
<a href="#l31.15"></a><span id="l31.15" class="difflineat">@@ -24,55 +24,59 @@</span>
<a href="#l31.16"></a><span id="l31.16">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l31.17"></a><span id="l31.17">  */</span>
<a href="#l31.18"></a><span id="l31.18"> #ifndef RNP_UTILS_H_</span>
<a href="#l31.19"></a><span id="l31.19"> #define RNP_UTILS_H_</span>
<a href="#l31.20"></a><span id="l31.20"> </span>
<a href="#l31.21"></a><span id="l31.21"> #include &lt;stdio.h&gt;</span>
<a href="#l31.22"></a><span id="l31.22"> #include &quot;types.h&quot;</span>
<a href="#l31.23"></a><span id="l31.23"> #include &lt;limits.h&gt;</span>
<a href="#l31.24"></a><span id="l31.24" class="difflineplus">+#include &lt;rnp/rnp_export.h&gt;</span>
<a href="#l31.25"></a><span id="l31.25"> </span>
<a href="#l31.26"></a><span id="l31.26"> #define RNP_MSG(msg) (void) fprintf(stdout, msg);</span>
<a href="#l31.27"></a><span id="l31.27"> </span>
<a href="#l31.28"></a><span id="l31.28" class="difflineminus">-bool rnp_log_switch();</span>
<a href="#l31.29"></a><span id="l31.29" class="difflineminus">-void set_rnp_log_switch(int8_t);</span>
<a href="#l31.30"></a><span id="l31.30" class="difflineplus">+// TODO: It is currently necessary to mark this with RNP_API, but this should</span>
<a href="#l31.31"></a><span id="l31.31" class="difflineplus">+// be removed at some point since it is not part of the public API.</span>
<a href="#l31.32"></a><span id="l31.32" class="difflineplus">+RNP_API bool rnp_log_switch();</span>
<a href="#l31.33"></a><span id="l31.33" class="difflineplus">+void         set_rnp_log_switch(int8_t);</span>
<a href="#l31.34"></a><span id="l31.34"> </span>
<a href="#l31.35"></a><span id="l31.35"> #define RNP_LOG_FD(fd, ...)                                                  \</span>
<a href="#l31.36"></a><span id="l31.36">     do {                                                                     \</span>
<a href="#l31.37"></a><span id="l31.37">         if (!rnp_log_switch())                                               \</span>
<a href="#l31.38"></a><span id="l31.38">             break;                                                           \</span>
<a href="#l31.39"></a><span id="l31.39">         (void) fprintf((fd), &quot;[%s() %s:%d] &quot;, __func__, __FILE__, __LINE__); \</span>
<a href="#l31.40"></a><span id="l31.40">         (void) fprintf((fd), __VA_ARGS__);                                   \</span>
<a href="#l31.41"></a><span id="l31.41">         (void) fprintf((fd), &quot;\n&quot;);                                          \</span>
<a href="#l31.42"></a><span id="l31.42">     } while (0)</span>
<a href="#l31.43"></a><span id="l31.43"> </span>
<a href="#l31.44"></a><span id="l31.44"> #define RNP_LOG(...) RNP_LOG_FD(stderr, __VA_ARGS__)</span>
<a href="#l31.45"></a><span id="l31.45"> </span>
<a href="#l31.46"></a><span id="l31.46" class="difflineminus">-#define RNP_LOG_KEY(msg, key)                                                                \</span>
<a href="#l31.47"></a><span id="l31.47" class="difflineminus">-    do {                                                                                     \</span>
<a href="#l31.48"></a><span id="l31.48" class="difflineminus">-        if (!key) {                                                                          \</span>
<a href="#l31.49"></a><span id="l31.49" class="difflineminus">-            RNP_LOG(msg, &quot;(null)&quot;);                                                          \</span>
<a href="#l31.50"></a><span id="l31.50" class="difflineminus">-            break;                                                                           \</span>
<a href="#l31.51"></a><span id="l31.51" class="difflineminus">-        }                                                                                    \</span>
<a href="#l31.52"></a><span id="l31.52" class="difflineminus">-        char keyid[PGP_KEY_ID_SIZE * 2 + 1] = {0};                                           \</span>
<a href="#l31.53"></a><span id="l31.53" class="difflineminus">-        rnp_hex_encode(                                                                      \</span>
<a href="#l31.54"></a><span id="l31.54" class="difflineminus">-          pgp_key_get_keyid(key), PGP_KEY_ID_SIZE, keyid, sizeof(keyid), RNP_HEX_LOWERCASE); \</span>
<a href="#l31.55"></a><span id="l31.55" class="difflineminus">-        RNP_LOG(msg, keyid);                                                                 \</span>
<a href="#l31.56"></a><span id="l31.56" class="difflineplus">+#define RNP_LOG_KEY(msg, key)                                                          \</span>
<a href="#l31.57"></a><span id="l31.57" class="difflineplus">+    do {                                                                               \</span>
<a href="#l31.58"></a><span id="l31.58" class="difflineplus">+        if (!key) {                                                                    \</span>
<a href="#l31.59"></a><span id="l31.59" class="difflineplus">+            RNP_LOG(msg, &quot;(null)&quot;);                                                    \</span>
<a href="#l31.60"></a><span id="l31.60" class="difflineplus">+            break;                                                                     \</span>
<a href="#l31.61"></a><span id="l31.61" class="difflineplus">+        }                                                                              \</span>
<a href="#l31.62"></a><span id="l31.62" class="difflineplus">+        char                keyid[PGP_KEY_ID_SIZE * 2 + 1] = {0};                      \</span>
<a href="#l31.63"></a><span id="l31.63" class="difflineplus">+        const pgp_key_id_t &amp;id = pgp_key_get_keyid(key);                               \</span>
<a href="#l31.64"></a><span id="l31.64" class="difflineplus">+        rnp_hex_encode(id.data(), id.size(), keyid, sizeof(keyid), RNP_HEX_LOWERCASE); \</span>
<a href="#l31.65"></a><span id="l31.65" class="difflineplus">+        RNP_LOG(msg, keyid);                                                           \</span>
<a href="#l31.66"></a><span id="l31.66">     } while (0)</span>
<a href="#l31.67"></a><span id="l31.67"> </span>
<a href="#l31.68"></a><span id="l31.68" class="difflineminus">-#define RNP_LOG_KEY_PKT(msg, key)                                                            \</span>
<a href="#l31.69"></a><span id="l31.69" class="difflineminus">-    do {                                                                                     \</span>
<a href="#l31.70"></a><span id="l31.70" class="difflineminus">-        uint8_t keyid[PGP_KEY_ID_SIZE] = {0};                                                \</span>
<a href="#l31.71"></a><span id="l31.71" class="difflineminus">-        if (pgp_keyid(keyid, PGP_KEY_ID_SIZE, (key))) {                                      \</span>
<a href="#l31.72"></a><span id="l31.72" class="difflineminus">-            RNP_LOG(msg, &quot;unknown&quot;);                                                         \</span>
<a href="#l31.73"></a><span id="l31.73" class="difflineminus">-            break;                                                                           \</span>
<a href="#l31.74"></a><span id="l31.74" class="difflineminus">-        };                                                                                   \</span>
<a href="#l31.75"></a><span id="l31.75" class="difflineminus">-        char keyidhex[PGP_KEY_ID_SIZE * 2 + 1] = {0};                                        \</span>
<a href="#l31.76"></a><span id="l31.76" class="difflineminus">-        rnp_hex_encode(keyid, sizeof(keyid), keyidhex, sizeof(keyidhex), RNP_HEX_LOWERCASE); \</span>
<a href="#l31.77"></a><span id="l31.77" class="difflineminus">-        RNP_LOG(msg, keyidhex);                                                              \</span>
<a href="#l31.78"></a><span id="l31.78" class="difflineplus">+#define RNP_LOG_KEY_PKT(msg, key)                                                     \</span>
<a href="#l31.79"></a><span id="l31.79" class="difflineplus">+    do {                                                                              \</span>
<a href="#l31.80"></a><span id="l31.80" class="difflineplus">+        pgp_key_id_t keyid = {};                                                      \</span>
<a href="#l31.81"></a><span id="l31.81" class="difflineplus">+        if (pgp_keyid(keyid, (key))) {                                                \</span>
<a href="#l31.82"></a><span id="l31.82" class="difflineplus">+            RNP_LOG(msg, &quot;unknown&quot;);                                                  \</span>
<a href="#l31.83"></a><span id="l31.83" class="difflineplus">+            break;                                                                    \</span>
<a href="#l31.84"></a><span id="l31.84" class="difflineplus">+        };                                                                            \</span>
<a href="#l31.85"></a><span id="l31.85" class="difflineplus">+        char keyidhex[PGP_KEY_ID_SIZE * 2 + 1] = {0};                                 \</span>
<a href="#l31.86"></a><span id="l31.86" class="difflineplus">+        rnp_hex_encode(                                                               \</span>
<a href="#l31.87"></a><span id="l31.87" class="difflineplus">+          keyid.data(), keyid.size(), keyidhex, sizeof(keyidhex), RNP_HEX_LOWERCASE); \</span>
<a href="#l31.88"></a><span id="l31.88" class="difflineplus">+        RNP_LOG(msg, keyidhex);                                                       \</span>
<a href="#l31.89"></a><span id="l31.89">     } while (0)</span>
<a href="#l31.90"></a><span id="l31.90"> </span>
<a href="#l31.91"></a><span id="l31.91"> #define RNP_DLOG(...)                    \</span>
<a href="#l31.92"></a><span id="l31.92">     if (rnp_get_debug(__FILE__)) {       \</span>
<a href="#l31.93"></a><span id="l31.93">         RNP_LOG_FD(stderr, __VA_ARGS__); \</span>
<a href="#l31.94"></a><span id="l31.94">     }</span>
<a href="#l31.95"></a><span id="l31.95"> </span>
<a href="#l31.96"></a><span id="l31.96"> #define RNP_DHEX(msg, mem, len)         \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/third_party/rnp/src/lib/version.h</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/third_party/rnp/src/lib/version.h</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -23,19 +23,19 @@</span>
<a href="#l32.4"></a><span id="l32.4">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l32.5"></a><span id="l32.5">  */</span>
<a href="#l32.6"></a><span id="l32.6"> </span>
<a href="#l32.7"></a><span id="l32.7"> #define RNP_VERSION_MAJOR 0</span>
<a href="#l32.8"></a><span id="l32.8"> #define RNP_VERSION_MINOR 13</span>
<a href="#l32.9"></a><span id="l32.9"> #define RNP_VERSION_PATCH 1</span>
<a href="#l32.10"></a><span id="l32.10"> </span>
<a href="#l32.11"></a><span id="l32.11"> #define RNP_VERSION_STRING &quot;0.13.1&quot;</span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-#define RNP_VERSION_STRING_FULL &quot;0.13.1+git20200619.ac070578.MZLA&quot;</span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+#define RNP_VERSION_STRING_FULL &quot;0.13.1+git20200707.2858ccdc.MZLA&quot;</span>
<a href="#l32.14"></a><span id="l32.14"> </span>
<a href="#l32.15"></a><span id="l32.15" class="difflineminus">-#define RNP_VERSION_COMMIT_TIMESTAMP 1592576776</span>
<a href="#l32.16"></a><span id="l32.16" class="difflineplus">+#define RNP_VERSION_COMMIT_TIMESTAMP 1594144587</span>
<a href="#l32.17"></a><span id="l32.17"> </span>
<a href="#l32.18"></a><span id="l32.18"> // using a 32-bit version with 10 bits per component</span>
<a href="#l32.19"></a><span id="l32.19"> #define RNP_VERSION_COMPONENT_MASK 0x3ff</span>
<a href="#l32.20"></a><span id="l32.20"> #define RNP_VERSION_MAJOR_SHIFT 20</span>
<a href="#l32.21"></a><span id="l32.21"> #define RNP_VERSION_MINOR_SHIFT 10</span>
<a href="#l32.22"></a><span id="l32.22"> #define RNP_VERSION_PATCH_SHIFT 0</span>
<a href="#l32.23"></a><span id="l32.23"> #define RNP_VERSION_CODE_FOR(major, minor, patch)                        \</span>
<a href="#l32.24"></a><span id="l32.24">     (((major &amp; RNP_VERSION_COMPONENT_MASK) &lt;&lt; RNP_VERSION_MAJOR_SHIFT) | \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/third_party/rnp/src/librekey/key_store_kbx.cpp</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/key_store_kbx.cpp</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -534,34 +534,34 @@ rnp_key_store_kbx_write_pgp(rnp_key_stor</span>
<a href="#l33.4"></a><span id="l33.4">         goto finish;</span>
<a href="#l33.5"></a><span id="l33.5">     }</span>
<a href="#l33.6"></a><span id="l33.6"> </span>
<a href="#l33.7"></a><span id="l33.7">     if (!pu32(&amp;memdst, 0) ||</span>
<a href="#l33.8"></a><span id="l33.8">         !pu32(&amp;memdst, 0)) { // offset and length of keyblock, update later</span>
<a href="#l33.9"></a><span id="l33.9">         goto finish;</span>
<a href="#l33.10"></a><span id="l33.10">     }</span>
<a href="#l33.11"></a><span id="l33.11"> </span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-    if (!pu16(&amp;memdst, 1 + key-&gt;subkey_grips.size())) { // number of keys in keyblock</span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+    if (!pu16(&amp;memdst, 1 + key-&gt;subkey_fps.size())) { // number of keys in keyblock</span>
<a href="#l33.14"></a><span id="l33.14">         goto finish;</span>
<a href="#l33.15"></a><span id="l33.15">     }</span>
<a href="#l33.16"></a><span id="l33.16">     if (!pu16(&amp;memdst, 28)) { // size of key info structure)</span>
<a href="#l33.17"></a><span id="l33.17">         goto finish;</span>
<a href="#l33.18"></a><span id="l33.18">     }</span>
<a href="#l33.19"></a><span id="l33.19"> </span>
<a href="#l33.20"></a><span id="l33.20" class="difflineminus">-    if (!pbuf(&amp;memdst, pgp_key_get_fp(key)-&gt;fingerprint, PGP_FINGERPRINT_SIZE) ||</span>
<a href="#l33.21"></a><span id="l33.21" class="difflineplus">+    if (!pbuf(&amp;memdst, pgp_key_get_fp(key).fingerprint, PGP_FINGERPRINT_SIZE) ||</span>
<a href="#l33.22"></a><span id="l33.22">         !pu32(&amp;memdst, memdst.writeb - 8) || // offset to keyid (part of fpr for V4)</span>
<a href="#l33.23"></a><span id="l33.23">         !pu16(&amp;memdst, 0) ||                 // flags, not used by GnuPG</span>
<a href="#l33.24"></a><span id="l33.24">         !pu16(&amp;memdst, 0)) {                 // RFU</span>
<a href="#l33.25"></a><span id="l33.25">         goto finish;</span>
<a href="#l33.26"></a><span id="l33.26">     }</span>
<a href="#l33.27"></a><span id="l33.27"> </span>
<a href="#l33.28"></a><span id="l33.28">     // same as above, for each subkey</span>
<a href="#l33.29"></a><span id="l33.29" class="difflineminus">-    for (auto &amp;sgrip : key-&gt;subkey_grips) {</span>
<a href="#l33.30"></a><span id="l33.30" class="difflineminus">-        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(key_store, sgrip);</span>
<a href="#l33.31"></a><span id="l33.31" class="difflineminus">-        if (!pbuf(&amp;memdst, pgp_key_get_fp(subkey)-&gt;fingerprint, PGP_FINGERPRINT_SIZE) ||</span>
<a href="#l33.32"></a><span id="l33.32" class="difflineplus">+    for (auto &amp;sfp : key-&gt;subkey_fps) {</span>
<a href="#l33.33"></a><span id="l33.33" class="difflineplus">+        const pgp_key_t *subkey = rnp_key_store_get_key_by_fpr(key_store, sfp);</span>
<a href="#l33.34"></a><span id="l33.34" class="difflineplus">+        if (!pbuf(&amp;memdst, pgp_key_get_fp(subkey).fingerprint, PGP_FINGERPRINT_SIZE) ||</span>
<a href="#l33.35"></a><span id="l33.35">             !pu32(&amp;memdst, memdst.writeb - 8) || // offset to keyid (part of fpr for V4)</span>
<a href="#l33.36"></a><span id="l33.36">             !pu16(&amp;memdst, 0) ||                 // flags, not used by GnuPG</span>
<a href="#l33.37"></a><span id="l33.37">             !pu16(&amp;memdst, 0)) {                 // RFU</span>
<a href="#l33.38"></a><span id="l33.38">             goto finish;</span>
<a href="#l33.39"></a><span id="l33.39">         }</span>
<a href="#l33.40"></a><span id="l33.40">         // load signature expirations while we're at it</span>
<a href="#l33.41"></a><span id="l33.41">         for (i = 0; i &lt; pgp_key_get_subsig_count(subkey); i++) {</span>
<a href="#l33.42"></a><span id="l33.42">             expiration = signature_get_key_expiration(&amp;pgp_key_get_subsig(subkey, i)-&gt;sig);</span>
<a href="#l33.43"></a><span id="l33.43" class="difflineat">@@ -657,18 +657,18 @@ rnp_key_store_kbx_write_pgp(rnp_key_stor</span>
<a href="#l33.44"></a><span id="l33.44">     pt = key_start;</span>
<a href="#l33.45"></a><span id="l33.45">     p = (uint8_t *) mem_dest_get_memory(&amp;memdst) + 8;</span>
<a href="#l33.46"></a><span id="l33.46">     STORE32BE(p, pt);</span>
<a href="#l33.47"></a><span id="l33.47"> </span>
<a href="#l33.48"></a><span id="l33.48">     if (!pgp_key_write_packets(key, &amp;memdst)) {</span>
<a href="#l33.49"></a><span id="l33.49">         goto finish;</span>
<a href="#l33.50"></a><span id="l33.50">     }</span>
<a href="#l33.51"></a><span id="l33.51"> </span>
<a href="#l33.52"></a><span id="l33.52" class="difflineminus">-    for (auto &amp;sgrip : key-&gt;subkey_grips) {</span>
<a href="#l33.53"></a><span id="l33.53" class="difflineminus">-        const pgp_key_t *subkey = rnp_key_store_get_key_by_grip(key_store, sgrip);</span>
<a href="#l33.54"></a><span id="l33.54" class="difflineplus">+    for (auto &amp;sfp : key-&gt;subkey_fps) {</span>
<a href="#l33.55"></a><span id="l33.55" class="difflineplus">+        const pgp_key_t *subkey = rnp_key_store_get_key_by_fpr(key_store, sfp);</span>
<a href="#l33.56"></a><span id="l33.56">         if (!pgp_key_write_packets(subkey, &amp;memdst)) {</span>
<a href="#l33.57"></a><span id="l33.57">             goto finish;</span>
<a href="#l33.58"></a><span id="l33.58">         }</span>
<a href="#l33.59"></a><span id="l33.59">     }</span>
<a href="#l33.60"></a><span id="l33.60"> </span>
<a href="#l33.61"></a><span id="l33.61">     /* key blob length */</span>
<a href="#l33.62"></a><span id="l33.62">     pt = memdst.writeb - key_start;</span>
<a href="#l33.63"></a><span id="l33.63">     p = (uint8_t *) mem_dest_get_memory(&amp;memdst) + 12;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/third_party/rnp/src/librekey/key_store_pgp.cpp</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/key_store_pgp.cpp</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -231,17 +231,17 @@ rnp_key_from_transferable_subkey(pgp_key</span>
<a href="#l34.4"></a><span id="l34.4"> </span>
<a href="#l34.5"></a><span id="l34.5">     /* add subkey binding signatures */</span>
<a href="#l34.6"></a><span id="l34.6">     if (!rnp_key_add_signatures(subkey, tskey-&gt;signatures)) {</span>
<a href="#l34.7"></a><span id="l34.7">         RNP_LOG(&quot;failed to add subkey signatures&quot;);</span>
<a href="#l34.8"></a><span id="l34.8">         return false;</span>
<a href="#l34.9"></a><span id="l34.9">     }</span>
<a href="#l34.10"></a><span id="l34.10"> </span>
<a href="#l34.11"></a><span id="l34.11">     /* setup key grips if primary is available */</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-    if (primary &amp;&amp; !pgp_key_link_subkey_grip(primary, subkey)) {</span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+    if (primary &amp;&amp; !pgp_key_link_subkey_fp(primary, subkey)) {</span>
<a href="#l34.14"></a><span id="l34.14">         return false;</span>
<a href="#l34.15"></a><span id="l34.15">     }</span>
<a href="#l34.16"></a><span id="l34.16"> </span>
<a href="#l34.17"></a><span id="l34.17">     return true;</span>
<a href="#l34.18"></a><span id="l34.18"> }</span>
<a href="#l34.19"></a><span id="l34.19"> </span>
<a href="#l34.20"></a><span id="l34.20"> rnp_result_t</span>
<a href="#l34.21"></a><span id="l34.21"> rnp_key_store_pgp_read_from_src(rnp_key_store_t *keyring, pgp_source_t *src)</span>
<a href="#l34.22"></a><span id="l34.22" class="difflineat">@@ -310,18 +310,18 @@ do_write(rnp_key_store_t *key_store, pgp</span>
<a href="#l34.23"></a><span id="l34.23"> </span>
<a href="#l34.24"></a><span id="l34.24">         if (key.format != PGP_KEY_STORE_GPG) {</span>
<a href="#l34.25"></a><span id="l34.25">             RNP_LOG(&quot;incorrect format (conversions not supported): %d&quot;, key.format);</span>
<a href="#l34.26"></a><span id="l34.26">             return false;</span>
<a href="#l34.27"></a><span id="l34.27">         }</span>
<a href="#l34.28"></a><span id="l34.28">         if (!pgp_key_write_packets(&amp;key, dst)) {</span>
<a href="#l34.29"></a><span id="l34.29">             return false;</span>
<a href="#l34.30"></a><span id="l34.30">         }</span>
<a href="#l34.31"></a><span id="l34.31" class="difflineminus">-        for (auto &amp;sgrip : key.subkey_grips) {</span>
<a href="#l34.32"></a><span id="l34.32" class="difflineminus">-            pgp_key_t *subkey = rnp_key_store_get_key_by_grip(key_store, sgrip);</span>
<a href="#l34.33"></a><span id="l34.33" class="difflineplus">+        for (auto &amp;sfp : key.subkey_fps) {</span>
<a href="#l34.34"></a><span id="l34.34" class="difflineplus">+            pgp_key_t *subkey = rnp_key_store_get_key_by_fpr(key_store, sfp);</span>
<a href="#l34.35"></a><span id="l34.35">             if (!subkey) {</span>
<a href="#l34.36"></a><span id="l34.36">                 RNP_LOG(&quot;Missing subkey&quot;);</span>
<a href="#l34.37"></a><span id="l34.37">                 continue;</span>
<a href="#l34.38"></a><span id="l34.38">             }</span>
<a href="#l34.39"></a><span id="l34.39">             if (!pgp_key_write_packets(subkey, dst)) {</span>
<a href="#l34.40"></a><span id="l34.40">                 return false;</span>
<a href="#l34.41"></a><span id="l34.41">             }</span>
<a href="#l34.42"></a><span id="l34.42">         }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/third_party/rnp/src/librekey/rnp_key_store.cpp</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/rnp_key_store.cpp</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -213,17 +213,17 @@ rnp_key_store_write_to_dst(rnp_key_store</span>
<a href="#l35.4"></a><span id="l35.4">     }</span>
<a href="#l35.5"></a><span id="l35.5"> </span>
<a href="#l35.6"></a><span id="l35.6">     return false;</span>
<a href="#l35.7"></a><span id="l35.7"> }</span>
<a href="#l35.8"></a><span id="l35.8"> </span>
<a href="#l35.9"></a><span id="l35.9"> void</span>
<a href="#l35.10"></a><span id="l35.10"> rnp_key_store_clear(rnp_key_store_t *keyring)</span>
<a href="#l35.11"></a><span id="l35.11"> {</span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-    keyring-&gt;keybygrip.clear();</span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+    keyring-&gt;keybyfp.clear();</span>
<a href="#l35.14"></a><span id="l35.14">     keyring-&gt;keys.clear();</span>
<a href="#l35.15"></a><span id="l35.15">     for (list_item *item = list_front(keyring-&gt;blobs); item; item = list_next(item)) {</span>
<a href="#l35.16"></a><span id="l35.16">         kbx_blob_t *blob = *((kbx_blob_t **) item);</span>
<a href="#l35.17"></a><span id="l35.17">         if (blob-&gt;type == KBX_PGP_BLOB) {</span>
<a href="#l35.18"></a><span id="l35.18">             kbx_pgp_blob_t *pgpblob = (kbx_pgp_blob_t *) blob;</span>
<a href="#l35.19"></a><span id="l35.19">             free_kbx_pgp_blob(pgpblob);</span>
<a href="#l35.20"></a><span id="l35.20">         }</span>
<a href="#l35.21"></a><span id="l35.21">         free(blob);</span>
<a href="#l35.22"></a><span id="l35.22" class="difflineat">@@ -339,19 +339,19 @@ rnp_key_store_merge_key(pgp_key_t *dst, </span>
<a href="#l35.23"></a><span id="l35.23">     }</span>
<a href="#l35.24"></a><span id="l35.24"> </span>
<a href="#l35.25"></a><span id="l35.25">     if (!rnp_key_from_transferable_key(&amp;tmpkey, &amp;dstkey)) {</span>
<a href="#l35.26"></a><span id="l35.26">         RNP_LOG(&quot;failed to process key&quot;);</span>
<a href="#l35.27"></a><span id="l35.27">         goto done;</span>
<a href="#l35.28"></a><span id="l35.28">     }</span>
<a href="#l35.29"></a><span id="l35.29"> </span>
<a href="#l35.30"></a><span id="l35.30">     /* move existing subkey grips since they are not present in transferable key */</span>
<a href="#l35.31"></a><span id="l35.31" class="difflineminus">-    tmpkey.subkey_grips = std::move(dst-&gt;subkey_grips);</span>
<a href="#l35.32"></a><span id="l35.32" class="difflineminus">-    for (auto &amp;grip : src-&gt;subkey_grips) {</span>
<a href="#l35.33"></a><span id="l35.33" class="difflineminus">-        if (!pgp_key_add_subkey_grip(&amp;tmpkey, grip)) {</span>
<a href="#l35.34"></a><span id="l35.34" class="difflineplus">+    tmpkey.subkey_fps = std::move(dst-&gt;subkey_fps);</span>
<a href="#l35.35"></a><span id="l35.35" class="difflineplus">+    for (auto &amp;fp : src-&gt;subkey_fps) {</span>
<a href="#l35.36"></a><span id="l35.36" class="difflineplus">+        if (!pgp_key_add_subkey_fp(&amp;tmpkey, fp)) {</span>
<a href="#l35.37"></a><span id="l35.37">             RNP_LOG(&quot;failed to add subkey grip&quot;);</span>
<a href="#l35.38"></a><span id="l35.38">         }</span>
<a href="#l35.39"></a><span id="l35.39">     }</span>
<a href="#l35.40"></a><span id="l35.40">     /* check whether key was unlocked and assign secret key data */</span>
<a href="#l35.41"></a><span id="l35.41">     if (pgp_key_is_secret(dst) &amp;&amp; !pgp_key_is_locked(dst)) {</span>
<a href="#l35.42"></a><span id="l35.42">         /* we may do thing below only because key material is opaque structure without</span>
<a href="#l35.43"></a><span id="l35.43">          * pointers! */</span>
<a href="#l35.44"></a><span id="l35.44">         tmpkey.pkt.material = dst-&gt;pkt.material;</span>
<a href="#l35.45"></a><span id="l35.45" class="difflineat">@@ -371,92 +371,104 @@ done:</span>
<a href="#l35.46"></a><span id="l35.46">     transferable_key_destroy(&amp;dstkey);</span>
<a href="#l35.47"></a><span id="l35.47">     transferable_key_destroy(&amp;srckey);</span>
<a href="#l35.48"></a><span id="l35.48">     return res;</span>
<a href="#l35.49"></a><span id="l35.49"> }</span>
<a href="#l35.50"></a><span id="l35.50"> </span>
<a href="#l35.51"></a><span id="l35.51"> static bool</span>
<a href="#l35.52"></a><span id="l35.52"> rnp_key_store_refresh_subkey_grips(rnp_key_store_t *keyring, pgp_key_t *key)</span>
<a href="#l35.53"></a><span id="l35.53"> {</span>
<a href="#l35.54"></a><span id="l35.54" class="difflineminus">-    uint8_t           keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l35.55"></a><span id="l35.55" class="difflineplus">+    pgp_key_id_t      keyid = {};</span>
<a href="#l35.56"></a><span id="l35.56">     pgp_fingerprint_t keyfp = {};</span>
<a href="#l35.57"></a><span id="l35.57"> </span>
<a href="#l35.58"></a><span id="l35.58">     if (pgp_key_is_subkey(key)) {</span>
<a href="#l35.59"></a><span id="l35.59">         RNP_LOG(&quot;wrong argument&quot;);</span>
<a href="#l35.60"></a><span id="l35.60">         return false;</span>
<a href="#l35.61"></a><span id="l35.61">     }</span>
<a href="#l35.62"></a><span id="l35.62"> </span>
<a href="#l35.63"></a><span id="l35.63">     for (auto &amp;skey : keyring-&gt;keys) {</span>
<a href="#l35.64"></a><span id="l35.64">         bool found = false;</span>
<a href="#l35.65"></a><span id="l35.65"> </span>
<a href="#l35.66"></a><span id="l35.66">         /* if we have primary_grip then we also added to subkey_grips */</span>
<a href="#l35.67"></a><span id="l35.67" class="difflineminus">-        if (!pgp_key_is_subkey(&amp;skey) || pgp_key_has_primary_grip(&amp;skey)) {</span>
<a href="#l35.68"></a><span id="l35.68" class="difflineplus">+        if (!pgp_key_is_subkey(&amp;skey) || pgp_key_has_primary_fp(&amp;skey)) {</span>
<a href="#l35.69"></a><span id="l35.69">             continue;</span>
<a href="#l35.70"></a><span id="l35.70">         }</span>
<a href="#l35.71"></a><span id="l35.71"> </span>
<a href="#l35.72"></a><span id="l35.72">         for (unsigned i = 0; i &lt; pgp_key_get_subsig_count(&amp;skey); i++) {</span>
<a href="#l35.73"></a><span id="l35.73">             const pgp_subsig_t *subsig = pgp_key_get_subsig(&amp;skey, i);</span>
<a href="#l35.74"></a><span id="l35.74"> </span>
<a href="#l35.75"></a><span id="l35.75">             if (subsig-&gt;sig.type != PGP_SIG_SUBKEY) {</span>
<a href="#l35.76"></a><span id="l35.76">                 continue;</span>
<a href="#l35.77"></a><span id="l35.77">             }</span>
<a href="#l35.78"></a><span id="l35.78"> </span>
<a href="#l35.79"></a><span id="l35.79" class="difflineminus">-            if (signature_get_keyfp(&amp;subsig-&gt;sig, &amp;keyfp) &amp;&amp;</span>
<a href="#l35.80"></a><span id="l35.80" class="difflineminus">-                fingerprint_equal(pgp_key_get_fp(key), &amp;keyfp)) {</span>
<a href="#l35.81"></a><span id="l35.81" class="difflineplus">+            if (signature_get_keyfp(&amp;subsig-&gt;sig, keyfp) &amp;&amp; (pgp_key_get_fp(key) == keyfp)) {</span>
<a href="#l35.82"></a><span id="l35.82">                 found = true;</span>
<a href="#l35.83"></a><span id="l35.83">                 break;</span>
<a href="#l35.84"></a><span id="l35.84">             }</span>
<a href="#l35.85"></a><span id="l35.85"> </span>
<a href="#l35.86"></a><span id="l35.86">             if (signature_get_keyid(&amp;subsig-&gt;sig, keyid) &amp;&amp;</span>
<a href="#l35.87"></a><span id="l35.87" class="difflineminus">-                !memcmp(pgp_key_get_keyid(key), keyid, PGP_KEY_ID_SIZE)) {</span>
<a href="#l35.88"></a><span id="l35.88" class="difflineplus">+                (pgp_key_get_keyid(key) != keyid)) {</span>
<a href="#l35.89"></a><span id="l35.89">                 found = true;</span>
<a href="#l35.90"></a><span id="l35.90">                 break;</span>
<a href="#l35.91"></a><span id="l35.91">             }</span>
<a href="#l35.92"></a><span id="l35.92">         }</span>
<a href="#l35.93"></a><span id="l35.93"> </span>
<a href="#l35.94"></a><span id="l35.94" class="difflineminus">-        if (found &amp;&amp; !pgp_key_link_subkey_grip(key, &amp;skey)) {</span>
<a href="#l35.95"></a><span id="l35.95" class="difflineplus">+        if (found &amp;&amp; !pgp_key_link_subkey_fp(key, &amp;skey)) {</span>
<a href="#l35.96"></a><span id="l35.96">             return false;</span>
<a href="#l35.97"></a><span id="l35.97">         }</span>
<a href="#l35.98"></a><span id="l35.98">     }</span>
<a href="#l35.99"></a><span id="l35.99"> </span>
<a href="#l35.100"></a><span id="l35.100">     return true;</span>
<a href="#l35.101"></a><span id="l35.101"> }</span>
<a href="#l35.102"></a><span id="l35.102"> </span>
<a href="#l35.103"></a><span id="l35.103"> static pgp_key_t *</span>
<a href="#l35.104"></a><span id="l35.104"> rnp_key_store_add_subkey(rnp_key_store_t *keyring, pgp_key_t *srckey, pgp_key_t *oldkey)</span>
<a href="#l35.105"></a><span id="l35.105"> {</span>
<a href="#l35.106"></a><span id="l35.106" class="difflineminus">-    pgp_key_t *primary = rnp_key_store_get_primary_key(keyring, srckey);</span>
<a href="#l35.107"></a><span id="l35.107" class="difflineminus">-    if (!primary &amp;&amp; oldkey) {</span>
<a href="#l35.108"></a><span id="l35.108" class="difflineplus">+    pgp_key_t *primary = NULL;</span>
<a href="#l35.109"></a><span id="l35.109" class="difflineplus">+    if (oldkey) {</span>
<a href="#l35.110"></a><span id="l35.110">         primary = rnp_key_store_get_primary_key(keyring, oldkey);</span>
<a href="#l35.111"></a><span id="l35.111">     }</span>
<a href="#l35.112"></a><span id="l35.112" class="difflineplus">+    if (!primary) {</span>
<a href="#l35.113"></a><span id="l35.113" class="difflineplus">+        primary = rnp_key_store_get_primary_key(keyring, srckey);</span>
<a href="#l35.114"></a><span id="l35.114" class="difflineplus">+    }</span>
<a href="#l35.115"></a><span id="l35.115"> </span>
<a href="#l35.116"></a><span id="l35.116">     if (oldkey) {</span>
<a href="#l35.117"></a><span id="l35.117" class="difflineplus">+        /* check for the weird case when same subkey has different primary keys */</span>
<a href="#l35.118"></a><span id="l35.118" class="difflineplus">+        if (pgp_key_has_primary_fp(srckey) &amp;&amp; pgp_key_has_primary_fp(oldkey) &amp;&amp;</span>
<a href="#l35.119"></a><span id="l35.119" class="difflineplus">+            (pgp_key_get_primary_fp(srckey) != pgp_key_get_primary_fp(oldkey))) {</span>
<a href="#l35.120"></a><span id="l35.120" class="difflineplus">+            RNP_LOG_KEY(&quot;Warning: different primary keys for subkey %s&quot;, srckey);</span>
<a href="#l35.121"></a><span id="l35.121" class="difflineplus">+            pgp_key_t *srcprim =</span>
<a href="#l35.122"></a><span id="l35.122" class="difflineplus">+              rnp_key_store_get_key_by_fpr(keyring, pgp_key_get_primary_fp(srckey));</span>
<a href="#l35.123"></a><span id="l35.123" class="difflineplus">+            if (srcprim != primary) {</span>
<a href="#l35.124"></a><span id="l35.124" class="difflineplus">+                pgp_key_remove_subkey_fp(srcprim, pgp_key_get_fp(srckey));</span>
<a href="#l35.125"></a><span id="l35.125" class="difflineplus">+            }</span>
<a href="#l35.126"></a><span id="l35.126" class="difflineplus">+        }</span>
<a href="#l35.127"></a><span id="l35.127">         /* in case we already have key let's merge it in */</span>
<a href="#l35.128"></a><span id="l35.128">         if (!rnp_key_store_merge_subkey(oldkey, srckey, primary)) {</span>
<a href="#l35.129"></a><span id="l35.129">             RNP_LOG_KEY(&quot;failed to merge subkey %s&quot;, srckey);</span>
<a href="#l35.130"></a><span id="l35.130">             RNP_LOG_KEY(&quot;primary key is %s&quot;, primary);</span>
<a href="#l35.131"></a><span id="l35.131">             return NULL;</span>
<a href="#l35.132"></a><span id="l35.132">         }</span>
<a href="#l35.133"></a><span id="l35.133">     } else {</span>
<a href="#l35.134"></a><span id="l35.134">         try {</span>
<a href="#l35.135"></a><span id="l35.135">             keyring-&gt;keys.emplace_back();</span>
<a href="#l35.136"></a><span id="l35.136">             oldkey = &amp;keyring-&gt;keys.back();</span>
<a href="#l35.137"></a><span id="l35.137" class="difflineminus">-            keyring-&gt;keybygrip[pgp_key_get_grip(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l35.138"></a><span id="l35.138" class="difflineplus">+            keyring-&gt;keybyfp[pgp_key_get_fp(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l35.139"></a><span id="l35.139">         } catch (const std::exception &amp;e) {</span>
<a href="#l35.140"></a><span id="l35.140">             RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l35.141"></a><span id="l35.141">             return NULL;</span>
<a href="#l35.142"></a><span id="l35.142">         }</span>
<a href="#l35.143"></a><span id="l35.143">         if (pgp_key_copy(oldkey, srckey, false)) {</span>
<a href="#l35.144"></a><span id="l35.144">             RNP_LOG_KEY(&quot;key %s copying failed&quot;, srckey);</span>
<a href="#l35.145"></a><span id="l35.145">             RNP_LOG_KEY(&quot;primary key is %s&quot;, primary);</span>
<a href="#l35.146"></a><span id="l35.146">             keyring-&gt;keys.pop_back();</span>
<a href="#l35.147"></a><span id="l35.147" class="difflineminus">-            keyring-&gt;keybygrip.erase(pgp_key_get_grip(srckey));</span>
<a href="#l35.148"></a><span id="l35.148" class="difflineplus">+            keyring-&gt;keybyfp.erase(pgp_key_get_fp(srckey));</span>
<a href="#l35.149"></a><span id="l35.149">             return NULL;</span>
<a href="#l35.150"></a><span id="l35.150">         }</span>
<a href="#l35.151"></a><span id="l35.151" class="difflineminus">-        if (primary &amp;&amp; !pgp_key_link_subkey_grip(primary, oldkey)) {</span>
<a href="#l35.152"></a><span id="l35.152" class="difflineplus">+        if (primary &amp;&amp; !pgp_key_link_subkey_fp(primary, oldkey)) {</span>
<a href="#l35.153"></a><span id="l35.153">             RNP_LOG_KEY(&quot;failed to link subkey %s grip&quot;, oldkey);</span>
<a href="#l35.154"></a><span id="l35.154">             RNP_LOG_KEY(&quot;primary key is %s&quot;, primary);</span>
<a href="#l35.155"></a><span id="l35.155">         }</span>
<a href="#l35.156"></a><span id="l35.156">     }</span>
<a href="#l35.157"></a><span id="l35.157"> </span>
<a href="#l35.158"></a><span id="l35.158">     RNP_DLOG(&quot;keyc %lu&quot;, (long unsigned) rnp_key_store_get_key_count(keyring));</span>
<a href="#l35.159"></a><span id="l35.159">     /* validate all added keys if not disabled */</span>
<a href="#l35.160"></a><span id="l35.160">     if (!keyring-&gt;disable_validation &amp;&amp; !oldkey-&gt;validated) {</span>
<a href="#l35.161"></a><span id="l35.161" class="difflineat">@@ -469,17 +481,17 @@ rnp_key_store_add_subkey(rnp_key_store_t</span>
<a href="#l35.162"></a><span id="l35.162">     return oldkey;</span>
<a href="#l35.163"></a><span id="l35.163"> }</span>
<a href="#l35.164"></a><span id="l35.164"> </span>
<a href="#l35.165"></a><span id="l35.165"> /* add a key to keyring */</span>
<a href="#l35.166"></a><span id="l35.166"> pgp_key_t *</span>
<a href="#l35.167"></a><span id="l35.167"> rnp_key_store_add_key(rnp_key_store_t *keyring, pgp_key_t *srckey)</span>
<a href="#l35.168"></a><span id="l35.168"> {</span>
<a href="#l35.169"></a><span id="l35.169">     assert(pgp_key_get_type(srckey) &amp;&amp; pgp_key_get_version(srckey));</span>
<a href="#l35.170"></a><span id="l35.170" class="difflineminus">-    pgp_key_t *added_key = rnp_key_store_get_key_by_grip(keyring, pgp_key_get_grip(srckey));</span>
<a href="#l35.171"></a><span id="l35.171" class="difflineplus">+    pgp_key_t *added_key = rnp_key_store_get_key_by_fpr(keyring, pgp_key_get_fp(srckey));</span>
<a href="#l35.172"></a><span id="l35.172">     /* we cannot merge G10 keys - so just return it */</span>
<a href="#l35.173"></a><span id="l35.173">     if (added_key &amp;&amp; (srckey-&gt;format == PGP_KEY_STORE_G10)) {</span>
<a href="#l35.174"></a><span id="l35.174">         return added_key;</span>
<a href="#l35.175"></a><span id="l35.175">     }</span>
<a href="#l35.176"></a><span id="l35.176">     /* different processing for subkeys */</span>
<a href="#l35.177"></a><span id="l35.177">     if (pgp_key_is_subkey(srckey)) {</span>
<a href="#l35.178"></a><span id="l35.178">         return rnp_key_store_add_subkey(keyring, srckey, added_key);</span>
<a href="#l35.179"></a><span id="l35.179">     }</span>
<a href="#l35.180"></a><span id="l35.180" class="difflineat">@@ -488,25 +500,25 @@ rnp_key_store_add_key(rnp_key_store_t *k</span>
<a href="#l35.181"></a><span id="l35.181">         if (!rnp_key_store_merge_key(added_key, srckey)) {</span>
<a href="#l35.182"></a><span id="l35.182">             RNP_LOG_KEY(&quot;failed to merge key %s&quot;, srckey);</span>
<a href="#l35.183"></a><span id="l35.183">             return NULL;</span>
<a href="#l35.184"></a><span id="l35.184">         }</span>
<a href="#l35.185"></a><span id="l35.185">     } else {</span>
<a href="#l35.186"></a><span id="l35.186">         try {</span>
<a href="#l35.187"></a><span id="l35.187">             keyring-&gt;keys.emplace_back();</span>
<a href="#l35.188"></a><span id="l35.188">             added_key = &amp;keyring-&gt;keys.back();</span>
<a href="#l35.189"></a><span id="l35.189" class="difflineminus">-            keyring-&gt;keybygrip[pgp_key_get_grip(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l35.190"></a><span id="l35.190" class="difflineplus">+            keyring-&gt;keybyfp[pgp_key_get_fp(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l35.191"></a><span id="l35.191">         } catch (const std::exception &amp;e) {</span>
<a href="#l35.192"></a><span id="l35.192">             RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l35.193"></a><span id="l35.193">             return NULL;</span>
<a href="#l35.194"></a><span id="l35.194">         }</span>
<a href="#l35.195"></a><span id="l35.195">         if (pgp_key_copy(added_key, srckey, false)) {</span>
<a href="#l35.196"></a><span id="l35.196">             RNP_LOG_KEY(&quot;key %s copying failed&quot;, srckey);</span>
<a href="#l35.197"></a><span id="l35.197">             keyring-&gt;keys.pop_back();</span>
<a href="#l35.198"></a><span id="l35.198" class="difflineminus">-            keyring-&gt;keybygrip.erase(pgp_key_get_grip(srckey));</span>
<a href="#l35.199"></a><span id="l35.199" class="difflineplus">+            keyring-&gt;keybyfp.erase(pgp_key_get_fp(srckey));</span>
<a href="#l35.200"></a><span id="l35.200">             return NULL;</span>
<a href="#l35.201"></a><span id="l35.201">         }</span>
<a href="#l35.202"></a><span id="l35.202">         /* primary key may be added after subkeys, so let's handle this case correctly */</span>
<a href="#l35.203"></a><span id="l35.203">         if (!rnp_key_store_refresh_subkey_grips(keyring, added_key)) {</span>
<a href="#l35.204"></a><span id="l35.204">             RNP_LOG_KEY(&quot;failed to refresh subkey grips for %s&quot;, added_key);</span>
<a href="#l35.205"></a><span id="l35.205">         }</span>
<a href="#l35.206"></a><span id="l35.206">     }</span>
<a href="#l35.207"></a><span id="l35.207"> </span>
<a href="#l35.208"></a><span id="l35.208" class="difflineat">@@ -531,27 +543,27 @@ rnp_key_store_import_key(rnp_key_store_t</span>
<a href="#l35.209"></a><span id="l35.209">     size_t     expackets = 0;</span>
<a href="#l35.210"></a><span id="l35.210">     bool       changed = false;</span>
<a href="#l35.211"></a><span id="l35.211"> </span>
<a href="#l35.212"></a><span id="l35.212">     /* add public key */</span>
<a href="#l35.213"></a><span id="l35.213">     if (pgp_key_copy(&amp;keycp, srckey, pubkey)) {</span>
<a href="#l35.214"></a><span id="l35.214">         RNP_LOG_KEY(&quot;failed to create key %s copy&quot;, srckey);</span>
<a href="#l35.215"></a><span id="l35.215">         return NULL;</span>
<a href="#l35.216"></a><span id="l35.216">     }</span>
<a href="#l35.217"></a><span id="l35.217" class="difflineminus">-    exkey = rnp_key_store_get_key_by_grip(keyring, pgp_key_get_grip(srckey));</span>
<a href="#l35.218"></a><span id="l35.218" class="difflineplus">+    exkey = rnp_key_store_get_key_by_fpr(keyring, pgp_key_get_fp(srckey));</span>
<a href="#l35.219"></a><span id="l35.219">     expackets = exkey ? pgp_key_get_rawpacket_count(exkey) : 0;</span>
<a href="#l35.220"></a><span id="l35.220">     keyring-&gt;disable_validation = true;</span>
<a href="#l35.221"></a><span id="l35.221">     exkey = rnp_key_store_add_key(keyring, &amp;keycp);</span>
<a href="#l35.222"></a><span id="l35.222">     keyring-&gt;disable_validation = false;</span>
<a href="#l35.223"></a><span id="l35.223">     if (!exkey) {</span>
<a href="#l35.224"></a><span id="l35.224">         RNP_LOG(&quot;failed to add key to the keyring&quot;);</span>
<a href="#l35.225"></a><span id="l35.225">         return NULL;</span>
<a href="#l35.226"></a><span id="l35.226">     }</span>
<a href="#l35.227"></a><span id="l35.227">     changed = pgp_key_get_rawpacket_count(exkey) &gt; expackets;</span>
<a href="#l35.228"></a><span id="l35.228" class="difflineminus">-    if (changed) {</span>
<a href="#l35.229"></a><span id="l35.229" class="difflineplus">+    if (changed || !exkey-&gt;validated) {</span>
<a href="#l35.230"></a><span id="l35.230">         /* this will revalidated primary key with all subkeys */</span>
<a href="#l35.231"></a><span id="l35.231">         pgp_key_revalidate_updated(exkey, keyring);</span>
<a href="#l35.232"></a><span id="l35.232">     }</span>
<a href="#l35.233"></a><span id="l35.233">     if (status) {</span>
<a href="#l35.234"></a><span id="l35.234">         *status = changed ?</span>
<a href="#l35.235"></a><span id="l35.235">                     (expackets ? PGP_KEY_IMPORT_STATUS_UPDATED : PGP_KEY_IMPORT_STATUS_NEW) :</span>
<a href="#l35.236"></a><span id="l35.236">                     PGP_KEY_IMPORT_STATUS_UNCHANGED;</span>
<a href="#l35.237"></a><span id="l35.237">     }</span>
<a href="#l35.238"></a><span id="l35.238" class="difflineat">@@ -559,17 +571,17 @@ rnp_key_store_import_key(rnp_key_store_t</span>
<a href="#l35.239"></a><span id="l35.239">     return exkey;</span>
<a href="#l35.240"></a><span id="l35.240"> }</span>
<a href="#l35.241"></a><span id="l35.241"> </span>
<a href="#l35.242"></a><span id="l35.242"> pgp_key_t *</span>
<a href="#l35.243"></a><span id="l35.243"> rnp_key_store_get_signer_key(rnp_key_store_t *store, const pgp_signature_t *sig)</span>
<a href="#l35.244"></a><span id="l35.244"> {</span>
<a href="#l35.245"></a><span id="l35.245">     pgp_key_search_t search = {};</span>
<a href="#l35.246"></a><span id="l35.246">     // prefer using the issuer fingerprint when available</span>
<a href="#l35.247"></a><span id="l35.247" class="difflineminus">-    if (signature_has_keyfp(sig) &amp;&amp; signature_get_keyfp(sig, &amp;search.by.fingerprint)) {</span>
<a href="#l35.248"></a><span id="l35.248" class="difflineplus">+    if (signature_has_keyfp(sig) &amp;&amp; signature_get_keyfp(sig, search.by.fingerprint)) {</span>
<a href="#l35.249"></a><span id="l35.249">         search.type = PGP_KEY_SEARCH_FINGERPRINT;</span>
<a href="#l35.250"></a><span id="l35.250">         return rnp_key_store_search(store, &amp;search, NULL);</span>
<a href="#l35.251"></a><span id="l35.251">     }</span>
<a href="#l35.252"></a><span id="l35.252">     // fall back to key id search</span>
<a href="#l35.253"></a><span id="l35.253">     if (signature_get_keyid(sig, search.by.keyid)) {</span>
<a href="#l35.254"></a><span id="l35.254">         search.type = PGP_KEY_SEARCH_KEYID;</span>
<a href="#l35.255"></a><span id="l35.255">         return rnp_key_store_search(store, &amp;search, NULL);</span>
<a href="#l35.256"></a><span id="l35.256">     }</span>
<a href="#l35.257"></a><span id="l35.257" class="difflineat">@@ -581,21 +593,21 @@ rnp_key_store_import_subkey_signature(rn</span>
<a href="#l35.258"></a><span id="l35.258">                                       pgp_key_t *            key,</span>
<a href="#l35.259"></a><span id="l35.259">                                       const pgp_signature_t *sig)</span>
<a href="#l35.260"></a><span id="l35.260"> {</span>
<a href="#l35.261"></a><span id="l35.261">     pgp_sig_type_t sigtype = signature_get_type(sig);</span>
<a href="#l35.262"></a><span id="l35.262">     if ((sigtype != PGP_SIG_SUBKEY) &amp;&amp; (sigtype != PGP_SIG_REV_SUBKEY)) {</span>
<a href="#l35.263"></a><span id="l35.263">         return PGP_SIG_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l35.264"></a><span id="l35.264">     }</span>
<a href="#l35.265"></a><span id="l35.265">     pgp_key_t *primary = rnp_key_store_get_signer_key(keyring, sig);</span>
<a href="#l35.266"></a><span id="l35.266" class="difflineminus">-    if (!primary || !pgp_key_has_primary_grip(key)) {</span>
<a href="#l35.267"></a><span id="l35.267" class="difflineplus">+    if (!primary || !pgp_key_has_primary_fp(key)) {</span>
<a href="#l35.268"></a><span id="l35.268">         RNP_LOG(&quot;No primary grip or primary key&quot;);</span>
<a href="#l35.269"></a><span id="l35.269">         return PGP_SIG_IMPORT_STATUS_UNKNOWN_KEY;</span>
<a href="#l35.270"></a><span id="l35.270">     }</span>
<a href="#l35.271"></a><span id="l35.271" class="difflineminus">-    if (pgp_key_get_grip(primary) != pgp_key_get_primary_grip(key)) {</span>
<a href="#l35.272"></a><span id="l35.272" class="difflineplus">+    if (pgp_key_get_fp(primary) != pgp_key_get_primary_fp(key)) {</span>
<a href="#l35.273"></a><span id="l35.273">         RNP_LOG(&quot;Wrong subkey signature's signer.&quot;);</span>
<a href="#l35.274"></a><span id="l35.274">         return PGP_SIG_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l35.275"></a><span id="l35.275">     }</span>
<a href="#l35.276"></a><span id="l35.276"> </span>
<a href="#l35.277"></a><span id="l35.277">     pgp_key_t tmpkey = {};</span>
<a href="#l35.278"></a><span id="l35.278">     if (!pgp_key_from_pkt(&amp;tmpkey, &amp;key-&gt;pkt) || !rnp_key_add_signature(&amp;tmpkey, sig) ||</span>
<a href="#l35.279"></a><span id="l35.279">         !pgp_subkey_refresh_data(&amp;tmpkey, primary)) {</span>
<a href="#l35.280"></a><span id="l35.280">         RNP_LOG(&quot;Failed to add signature to the key.&quot;);</span>
<a href="#l35.281"></a><span id="l35.281" class="difflineat">@@ -667,47 +679,47 @@ rnp_key_store_import_signature(rnp_key_s</span>
<a href="#l35.282"></a><span id="l35.282">     }</span>
<a href="#l35.283"></a><span id="l35.283">     *status = rnp_key_store_import_key_signature(keyring, res_key, sig);</span>
<a href="#l35.284"></a><span id="l35.284">     return res_key;</span>
<a href="#l35.285"></a><span id="l35.285"> }</span>
<a href="#l35.286"></a><span id="l35.286"> </span>
<a href="#l35.287"></a><span id="l35.287"> bool</span>
<a href="#l35.288"></a><span id="l35.288"> rnp_key_store_remove_key(rnp_key_store_t *keyring, const pgp_key_t *key, bool subkeys)</span>
<a href="#l35.289"></a><span id="l35.289"> {</span>
<a href="#l35.290"></a><span id="l35.290" class="difflineminus">-    auto it = keyring-&gt;keybygrip.find(pgp_key_get_grip(key));</span>
<a href="#l35.291"></a><span id="l35.291" class="difflineminus">-    if (it == keyring-&gt;keybygrip.end()) {</span>
<a href="#l35.292"></a><span id="l35.292" class="difflineplus">+    auto it = keyring-&gt;keybyfp.find(pgp_key_get_fp(key));</span>
<a href="#l35.293"></a><span id="l35.293" class="difflineplus">+    if (it == keyring-&gt;keybyfp.end()) {</span>
<a href="#l35.294"></a><span id="l35.294">         return false;</span>
<a href="#l35.295"></a><span id="l35.295">     }</span>
<a href="#l35.296"></a><span id="l35.296"> </span>
<a href="#l35.297"></a><span id="l35.297">     /* cleanup primary_grip (or subkey)/subkey_grips */</span>
<a href="#l35.298"></a><span id="l35.298">     if (pgp_key_is_primary_key(key) &amp;&amp; pgp_key_get_subkey_count(key)) {</span>
<a href="#l35.299"></a><span id="l35.299">         for (size_t i = 0; i &lt; pgp_key_get_subkey_count(key); i++) {</span>
<a href="#l35.300"></a><span id="l35.300" class="difflineminus">-            auto it = keyring-&gt;keybygrip.find(pgp_key_get_subkey_grip(key, i));</span>
<a href="#l35.301"></a><span id="l35.301" class="difflineminus">-            if (it == keyring-&gt;keybygrip.end()) {</span>
<a href="#l35.302"></a><span id="l35.302" class="difflineplus">+            auto it = keyring-&gt;keybyfp.find(pgp_key_get_subkey_fp(key, i));</span>
<a href="#l35.303"></a><span id="l35.303" class="difflineplus">+            if (it == keyring-&gt;keybyfp.end()) {</span>
<a href="#l35.304"></a><span id="l35.304">                 continue;</span>
<a href="#l35.305"></a><span id="l35.305">             }</span>
<a href="#l35.306"></a><span id="l35.306">             /* if subkeys are deleted then no need to update grips */</span>
<a href="#l35.307"></a><span id="l35.307">             if (subkeys) {</span>
<a href="#l35.308"></a><span id="l35.308">                 keyring-&gt;keys.erase(it-&gt;second);</span>
<a href="#l35.309"></a><span id="l35.309" class="difflineminus">-                keyring-&gt;keybygrip.erase(it);</span>
<a href="#l35.310"></a><span id="l35.310" class="difflineplus">+                keyring-&gt;keybyfp.erase(it);</span>
<a href="#l35.311"></a><span id="l35.311">                 continue;</span>
<a href="#l35.312"></a><span id="l35.312">             }</span>
<a href="#l35.313"></a><span id="l35.313" class="difflineminus">-            it-&gt;second-&gt;primary_grip = {};</span>
<a href="#l35.314"></a><span id="l35.314" class="difflineminus">-            it-&gt;second-&gt;primary_grip_set = false;</span>
<a href="#l35.315"></a><span id="l35.315" class="difflineplus">+            it-&gt;second-&gt;primary_fp = {};</span>
<a href="#l35.316"></a><span id="l35.316" class="difflineplus">+            it-&gt;second-&gt;primary_fp_set = false;</span>
<a href="#l35.317"></a><span id="l35.317">         }</span>
<a href="#l35.318"></a><span id="l35.318">     }</span>
<a href="#l35.319"></a><span id="l35.319" class="difflineminus">-    if (pgp_key_is_subkey(key) &amp;&amp; pgp_key_has_primary_grip(key)) {</span>
<a href="#l35.320"></a><span id="l35.320" class="difflineplus">+    if (pgp_key_is_subkey(key) &amp;&amp; pgp_key_has_primary_fp(key)) {</span>
<a href="#l35.321"></a><span id="l35.321">         pgp_key_t *primary = rnp_key_store_get_primary_key(keyring, key);</span>
<a href="#l35.322"></a><span id="l35.322">         if (primary) {</span>
<a href="#l35.323"></a><span id="l35.323" class="difflineminus">-            pgp_key_remove_subkey_grip(primary, pgp_key_get_grip(key));</span>
<a href="#l35.324"></a><span id="l35.324" class="difflineplus">+            pgp_key_remove_subkey_fp(primary, pgp_key_get_fp(key));</span>
<a href="#l35.325"></a><span id="l35.325">         }</span>
<a href="#l35.326"></a><span id="l35.326">     }</span>
<a href="#l35.327"></a><span id="l35.327"> </span>
<a href="#l35.328"></a><span id="l35.328">     keyring-&gt;keys.erase(it-&gt;second);</span>
<a href="#l35.329"></a><span id="l35.329" class="difflineminus">-    keyring-&gt;keybygrip.erase(it);</span>
<a href="#l35.330"></a><span id="l35.330" class="difflineplus">+    keyring-&gt;keybyfp.erase(it);</span>
<a href="#l35.331"></a><span id="l35.331">     return true;</span>
<a href="#l35.332"></a><span id="l35.332"> }</span>
<a href="#l35.333"></a><span id="l35.333"> </span>
<a href="#l35.334"></a><span id="l35.334"> /**</span>
<a href="#l35.335"></a><span id="l35.335">    \ingroup HighLevel_KeyringFind</span>
<a href="#l35.336"></a><span id="l35.336"> </span>
<a href="#l35.337"></a><span id="l35.337">    \brief Finds key in keyring from its Key ID</span>
<a href="#l35.338"></a><span id="l35.338"> </span>
<a href="#l35.339"></a><span id="l35.339" class="difflineat">@@ -716,17 +728,19 @@ rnp_key_store_remove_key(rnp_key_store_t</span>
<a href="#l35.340"></a><span id="l35.340"> </span>
<a href="#l35.341"></a><span id="l35.341">    \return Pointer to key, if found; NULL, if not found</span>
<a href="#l35.342"></a><span id="l35.342"> </span>
<a href="#l35.343"></a><span id="l35.343">    \note This returns a pointer to the key inside the given keyring,</span>
<a href="#l35.344"></a><span id="l35.344">    not a copy.  Do not free it after use.</span>
<a href="#l35.345"></a><span id="l35.345"> </span>
<a href="#l35.346"></a><span id="l35.346"> */</span>
<a href="#l35.347"></a><span id="l35.347"> pgp_key_t *</span>
<a href="#l35.348"></a><span id="l35.348" class="difflineminus">-rnp_key_store_get_key_by_id(rnp_key_store_t *keyring, const uint8_t *keyid, pgp_key_t *after)</span>
<a href="#l35.349"></a><span id="l35.349" class="difflineplus">+rnp_key_store_get_key_by_id(rnp_key_store_t *   keyring,</span>
<a href="#l35.350"></a><span id="l35.350" class="difflineplus">+                            const pgp_key_id_t &amp;keyid,</span>
<a href="#l35.351"></a><span id="l35.351" class="difflineplus">+                            pgp_key_t *         after)</span>
<a href="#l35.352"></a><span id="l35.352"> {</span>
<a href="#l35.353"></a><span id="l35.353">     RNP_DLOG(&quot;searching keyring %p&quot;, keyring);</span>
<a href="#l35.354"></a><span id="l35.354">     if (!keyring) {</span>
<a href="#l35.355"></a><span id="l35.355">         return NULL;</span>
<a href="#l35.356"></a><span id="l35.356">     }</span>
<a href="#l35.357"></a><span id="l35.357"> </span>
<a href="#l35.358"></a><span id="l35.358">     auto it =</span>
<a href="#l35.359"></a><span id="l35.359">       std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [after](const pgp_key_t &amp;key) {</span>
<a href="#l35.360"></a><span id="l35.360" class="difflineat">@@ -735,75 +749,85 @@ rnp_key_store_get_key_by_id(rnp_key_stor</span>
<a href="#l35.361"></a><span id="l35.361">     if (after &amp;&amp; (it == keyring-&gt;keys.end())) {</span>
<a href="#l35.362"></a><span id="l35.362">         RNP_LOG(&quot;searching with non-keyrings after param&quot;);</span>
<a href="#l35.363"></a><span id="l35.363">         return NULL;</span>
<a href="#l35.364"></a><span id="l35.364">     }</span>
<a href="#l35.365"></a><span id="l35.365">     if (after) {</span>
<a href="#l35.366"></a><span id="l35.366">         it = std::next(it);</span>
<a href="#l35.367"></a><span id="l35.367">     }</span>
<a href="#l35.368"></a><span id="l35.368">     it = std::find_if(it, keyring-&gt;keys.end(), [keyid](const pgp_key_t &amp;key) {</span>
<a href="#l35.369"></a><span id="l35.369" class="difflineminus">-        return !memcmp(pgp_key_get_keyid(&amp;key), keyid, PGP_KEY_ID_SIZE) ||</span>
<a href="#l35.370"></a><span id="l35.370" class="difflineminus">-               !memcmp(</span>
<a href="#l35.371"></a><span id="l35.371" class="difflineminus">-                 pgp_key_get_keyid(&amp;key) + PGP_KEY_ID_SIZE / 2, keyid, PGP_KEY_ID_SIZE / 2);</span>
<a href="#l35.372"></a><span id="l35.372" class="difflineplus">+        const pgp_key_id_t &amp;id = pgp_key_get_keyid(&amp;key);</span>
<a href="#l35.373"></a><span id="l35.373" class="difflineplus">+        return (id == keyid) ||</span>
<a href="#l35.374"></a><span id="l35.374" class="difflineplus">+               !memcmp(id.data() + PGP_KEY_ID_SIZE / 2, keyid.data(), PGP_KEY_ID_SIZE / 2);</span>
<a href="#l35.375"></a><span id="l35.375">     });</span>
<a href="#l35.376"></a><span id="l35.376">     return (it == keyring-&gt;keys.end()) ? NULL : &amp;(*it);</span>
<a href="#l35.377"></a><span id="l35.377"> }</span>
<a href="#l35.378"></a><span id="l35.378"> </span>
<a href="#l35.379"></a><span id="l35.379"> const pgp_key_t *</span>
<a href="#l35.380"></a><span id="l35.380"> rnp_key_store_get_key_by_grip(const rnp_key_store_t *keyring, const pgp_key_grip_t &amp;grip)</span>
<a href="#l35.381"></a><span id="l35.381"> {</span>
<a href="#l35.382"></a><span id="l35.382" class="difflineminus">-    auto it = keyring-&gt;keybygrip.find(grip);</span>
<a href="#l35.383"></a><span id="l35.383" class="difflineminus">-    if (it == keyring-&gt;keybygrip.end()) {</span>
<a href="#l35.384"></a><span id="l35.384" class="difflineminus">-        return NULL;</span>
<a href="#l35.385"></a><span id="l35.385" class="difflineminus">-    }</span>
<a href="#l35.386"></a><span id="l35.386" class="difflineminus">-    return &amp;*it-&gt;second;</span>
<a href="#l35.387"></a><span id="l35.387" class="difflineplus">+    auto it =</span>
<a href="#l35.388"></a><span id="l35.388" class="difflineplus">+      std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [grip](const pgp_key_t &amp;key) {</span>
<a href="#l35.389"></a><span id="l35.389" class="difflineplus">+          return pgp_key_get_grip(&amp;key) == grip;</span>
<a href="#l35.390"></a><span id="l35.390" class="difflineplus">+      });</span>
<a href="#l35.391"></a><span id="l35.391" class="difflineplus">+    return (it == keyring-&gt;keys.end()) ? NULL : &amp;(*it);</span>
<a href="#l35.392"></a><span id="l35.392"> }</span>
<a href="#l35.393"></a><span id="l35.393"> </span>
<a href="#l35.394"></a><span id="l35.394"> pgp_key_t *</span>
<a href="#l35.395"></a><span id="l35.395"> rnp_key_store_get_key_by_grip(rnp_key_store_t *keyring, const pgp_key_grip_t &amp;grip)</span>
<a href="#l35.396"></a><span id="l35.396"> {</span>
<a href="#l35.397"></a><span id="l35.397" class="difflineminus">-    auto it = keyring-&gt;keybygrip.find(grip);</span>
<a href="#l35.398"></a><span id="l35.398" class="difflineminus">-    if (it == keyring-&gt;keybygrip.end()) {</span>
<a href="#l35.399"></a><span id="l35.399" class="difflineplus">+    auto it =</span>
<a href="#l35.400"></a><span id="l35.400" class="difflineplus">+      std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [grip](const pgp_key_t &amp;key) {</span>
<a href="#l35.401"></a><span id="l35.401" class="difflineplus">+          return pgp_key_get_grip(&amp;key) == grip;</span>
<a href="#l35.402"></a><span id="l35.402" class="difflineplus">+      });</span>
<a href="#l35.403"></a><span id="l35.403" class="difflineplus">+    return (it == keyring-&gt;keys.end()) ? NULL : &amp;(*it);</span>
<a href="#l35.404"></a><span id="l35.404" class="difflineplus">+}</span>
<a href="#l35.405"></a><span id="l35.405" class="difflineplus">+</span>
<a href="#l35.406"></a><span id="l35.406" class="difflineplus">+const pgp_key_t *</span>
<a href="#l35.407"></a><span id="l35.407" class="difflineplus">+rnp_key_store_get_key_by_fpr(const rnp_key_store_t *keyring, const pgp_fingerprint_t &amp;fpr)</span>
<a href="#l35.408"></a><span id="l35.408" class="difflineplus">+{</span>
<a href="#l35.409"></a><span id="l35.409" class="difflineplus">+    auto it = keyring-&gt;keybyfp.find(fpr);</span>
<a href="#l35.410"></a><span id="l35.410" class="difflineplus">+    if (it == keyring-&gt;keybyfp.end()) {</span>
<a href="#l35.411"></a><span id="l35.411">         return NULL;</span>
<a href="#l35.412"></a><span id="l35.412">     }</span>
<a href="#l35.413"></a><span id="l35.413">     return &amp;*it-&gt;second;</span>
<a href="#l35.414"></a><span id="l35.414"> }</span>
<a href="#l35.415"></a><span id="l35.415"> </span>
<a href="#l35.416"></a><span id="l35.416"> pgp_key_t *</span>
<a href="#l35.417"></a><span id="l35.417" class="difflineminus">-rnp_key_store_get_key_by_fpr(rnp_key_store_t *keyring, const pgp_fingerprint_t *fpr)</span>
<a href="#l35.418"></a><span id="l35.418" class="difflineplus">+rnp_key_store_get_key_by_fpr(rnp_key_store_t *keyring, const pgp_fingerprint_t &amp;fpr)</span>
<a href="#l35.419"></a><span id="l35.419"> {</span>
<a href="#l35.420"></a><span id="l35.420" class="difflineminus">-    auto it =</span>
<a href="#l35.421"></a><span id="l35.421" class="difflineminus">-      std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [fpr](const pgp_key_t &amp;key) {</span>
<a href="#l35.422"></a><span id="l35.422" class="difflineminus">-          return fingerprint_equal(pgp_key_get_fp(&amp;key), fpr);</span>
<a href="#l35.423"></a><span id="l35.423" class="difflineminus">-      });</span>
<a href="#l35.424"></a><span id="l35.424" class="difflineminus">-    return (it == keyring-&gt;keys.end()) ? NULL : &amp;(*it);</span>
<a href="#l35.425"></a><span id="l35.425" class="difflineplus">+    auto it = keyring-&gt;keybyfp.find(fpr);</span>
<a href="#l35.426"></a><span id="l35.426" class="difflineplus">+    if (it == keyring-&gt;keybyfp.end()) {</span>
<a href="#l35.427"></a><span id="l35.427" class="difflineplus">+        return NULL;</span>
<a href="#l35.428"></a><span id="l35.428" class="difflineplus">+    }</span>
<a href="#l35.429"></a><span id="l35.429" class="difflineplus">+    return &amp;*it-&gt;second;</span>
<a href="#l35.430"></a><span id="l35.430"> }</span>
<a href="#l35.431"></a><span id="l35.431"> </span>
<a href="#l35.432"></a><span id="l35.432"> pgp_key_t *</span>
<a href="#l35.433"></a><span id="l35.433"> rnp_key_store_get_primary_key(rnp_key_store_t *keyring, const pgp_key_t *subkey)</span>
<a href="#l35.434"></a><span id="l35.434"> {</span>
<a href="#l35.435"></a><span id="l35.435" class="difflineminus">-    uint8_t           keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l35.436"></a><span id="l35.436" class="difflineplus">+    pgp_key_id_t      keyid = {};</span>
<a href="#l35.437"></a><span id="l35.437">     pgp_fingerprint_t keyfp = {};</span>
<a href="#l35.438"></a><span id="l35.438"> </span>
<a href="#l35.439"></a><span id="l35.439">     if (!pgp_key_is_subkey(subkey)) {</span>
<a href="#l35.440"></a><span id="l35.440">         return NULL;</span>
<a href="#l35.441"></a><span id="l35.441">     }</span>
<a href="#l35.442"></a><span id="l35.442"> </span>
<a href="#l35.443"></a><span id="l35.443" class="difflineminus">-    if (pgp_key_has_primary_grip(subkey)) {</span>
<a href="#l35.444"></a><span id="l35.444" class="difflineminus">-        return rnp_key_store_get_key_by_grip(keyring, pgp_key_get_primary_grip(subkey));</span>
<a href="#l35.445"></a><span id="l35.445" class="difflineplus">+    if (pgp_key_has_primary_fp(subkey)) {</span>
<a href="#l35.446"></a><span id="l35.446" class="difflineplus">+        return rnp_key_store_get_key_by_fpr(keyring, pgp_key_get_primary_fp(subkey));</span>
<a href="#l35.447"></a><span id="l35.447">     }</span>
<a href="#l35.448"></a><span id="l35.448"> </span>
<a href="#l35.449"></a><span id="l35.449">     for (unsigned i = 0; i &lt; pgp_key_get_subsig_count(subkey); i++) {</span>
<a href="#l35.450"></a><span id="l35.450">         const pgp_subsig_t *subsig = pgp_key_get_subsig(subkey, i);</span>
<a href="#l35.451"></a><span id="l35.451">         if (subsig-&gt;sig.type != PGP_SIG_SUBKEY) {</span>
<a href="#l35.452"></a><span id="l35.452">             continue;</span>
<a href="#l35.453"></a><span id="l35.453">         }</span>
<a href="#l35.454"></a><span id="l35.454"> </span>
<a href="#l35.455"></a><span id="l35.455" class="difflineminus">-        if (signature_get_keyfp(&amp;subsig-&gt;sig, &amp;keyfp)) {</span>
<a href="#l35.456"></a><span id="l35.456" class="difflineminus">-            return rnp_key_store_get_key_by_fpr(keyring, &amp;keyfp);</span>
<a href="#l35.457"></a><span id="l35.457" class="difflineplus">+        if (signature_get_keyfp(&amp;subsig-&gt;sig, keyfp)) {</span>
<a href="#l35.458"></a><span id="l35.458" class="difflineplus">+            return rnp_key_store_get_key_by_fpr(keyring, keyfp);</span>
<a href="#l35.459"></a><span id="l35.459">         }</span>
<a href="#l35.460"></a><span id="l35.460"> </span>
<a href="#l35.461"></a><span id="l35.461">         if (signature_get_keyid(&amp;subsig-&gt;sig, keyid)) {</span>
<a href="#l35.462"></a><span id="l35.462">             return rnp_key_store_get_key_by_id(keyring, keyid, NULL);</span>
<a href="#l35.463"></a><span id="l35.463">         }</span>
<a href="#l35.464"></a><span id="l35.464">     }</span>
<a href="#l35.465"></a><span id="l35.465"> </span>
<a href="#l35.466"></a><span id="l35.466">     return NULL;</span>
<a href="#l35.467"></a><span id="l35.467" class="difflineat">@@ -957,16 +981,27 @@ rnp_key_store_get_key_grip(const pgp_key</span>
<a href="#l35.468"></a><span id="l35.468">     return pgp_hash_finish(&amp;hash, grip.data()) == grip.size();</span>
<a href="#l35.469"></a><span id="l35.469"> }</span>
<a href="#l35.470"></a><span id="l35.470"> </span>
<a href="#l35.471"></a><span id="l35.471"> pgp_key_t *</span>
<a href="#l35.472"></a><span id="l35.472"> rnp_key_store_search(rnp_key_store_t *       keyring,</span>
<a href="#l35.473"></a><span id="l35.473">                      const pgp_key_search_t *search,</span>
<a href="#l35.474"></a><span id="l35.474">                      pgp_key_t *             after)</span>
<a href="#l35.475"></a><span id="l35.475"> {</span>
<a href="#l35.476"></a><span id="l35.476" class="difflineplus">+    // since keys are distinguished by fingerprint then just do map lookup</span>
<a href="#l35.477"></a><span id="l35.477" class="difflineplus">+    if (search-&gt;type == PGP_KEY_SEARCH_FINGERPRINT) {</span>
<a href="#l35.478"></a><span id="l35.478" class="difflineplus">+        pgp_key_t *key = rnp_key_store_get_key_by_fpr(keyring, search-&gt;by.fingerprint);</span>
<a href="#l35.479"></a><span id="l35.479" class="difflineplus">+        if (after &amp;&amp; (after != key)) {</span>
<a href="#l35.480"></a><span id="l35.480" class="difflineplus">+            RNP_LOG(&quot;searching with invalid after param&quot;);</span>
<a href="#l35.481"></a><span id="l35.481" class="difflineplus">+            return NULL;</span>
<a href="#l35.482"></a><span id="l35.482" class="difflineplus">+        }</span>
<a href="#l35.483"></a><span id="l35.483" class="difflineplus">+        // return NULL if after is specified</span>
<a href="#l35.484"></a><span id="l35.484" class="difflineplus">+        return after ? NULL : key;</span>
<a href="#l35.485"></a><span id="l35.485" class="difflineplus">+    }</span>
<a href="#l35.486"></a><span id="l35.486" class="difflineplus">+</span>
<a href="#l35.487"></a><span id="l35.487">     // if after is provided, make sure it is a member of the appropriate list</span>
<a href="#l35.488"></a><span id="l35.488">     auto it =</span>
<a href="#l35.489"></a><span id="l35.489">       std::find_if(keyring-&gt;keys.begin(), keyring-&gt;keys.end(), [after](const pgp_key_t &amp;key) {</span>
<a href="#l35.490"></a><span id="l35.490">           return !after || (after == &amp;key);</span>
<a href="#l35.491"></a><span id="l35.491">       });</span>
<a href="#l35.492"></a><span id="l35.492">     if (after &amp;&amp; (it == keyring-&gt;keys.end())) {</span>
<a href="#l35.493"></a><span id="l35.493">         RNP_LOG(&quot;searching with non-keyrings after param&quot;);</span>
<a href="#l35.494"></a><span id="l35.494">         return NULL;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-armor.cpp</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-armor.cpp</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -33,16 +33,18 @@</span>
<a href="#l36.4"></a><span id="l36.4"> #include &lt;rnp/rnp_def.h&gt;</span>
<a href="#l36.5"></a><span id="l36.5"> #include &quot;stream-def.h&quot;</span>
<a href="#l36.6"></a><span id="l36.6"> #include &quot;stream-armor.h&quot;</span>
<a href="#l36.7"></a><span id="l36.7"> #include &quot;stream-packet.h&quot;</span>
<a href="#l36.8"></a><span id="l36.8"> #include &quot;crypto/hash.h&quot;</span>
<a href="#l36.9"></a><span id="l36.9"> #include &quot;types.h&quot;</span>
<a href="#l36.10"></a><span id="l36.10"> </span>
<a href="#l36.11"></a><span id="l36.11"> #define ARMORED_BLOCK_SIZE (4096)</span>
<a href="#l36.12"></a><span id="l36.12" class="difflineplus">+#define ARMORED_MIN_LINE_LENGTH (16)</span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+#define ARMORED_MAX_LINE_LENGTH (76)</span>
<a href="#l36.14"></a><span id="l36.14"> </span>
<a href="#l36.15"></a><span id="l36.15"> typedef struct pgp_source_armored_param_t {</span>
<a href="#l36.16"></a><span id="l36.16">     pgp_source_t *    readsrc;         /* source to read from */</span>
<a href="#l36.17"></a><span id="l36.17">     pgp_armored_msg_t type;            /* type of the message */</span>
<a href="#l36.18"></a><span id="l36.18">     char *            armorhdr;        /* armor header */</span>
<a href="#l36.19"></a><span id="l36.19">     char *            version;         /* Version: header if any */</span>
<a href="#l36.20"></a><span id="l36.20">     char *            comment;         /* Comment: header if any */</span>
<a href="#l36.21"></a><span id="l36.21">     char *            hash;            /* Hash: header if any */</span>
<a href="#l36.22"></a><span id="l36.22" class="difflineat">@@ -784,31 +786,33 @@ armored_dst_write(pgp_dest_t *dst, const</span>
<a href="#l36.23"></a><span id="l36.23">             if (param-&gt;usecrlf) {</span>
<a href="#l36.24"></a><span id="l36.24">                 *encptr++ = CH_CR;</span>
<a href="#l36.25"></a><span id="l36.25">             }</span>
<a href="#l36.26"></a><span id="l36.26">             *encptr++ = CH_LF;</span>
<a href="#l36.27"></a><span id="l36.27">             param-&gt;lout = 0;</span>
<a href="#l36.28"></a><span id="l36.28">         }</span>
<a href="#l36.29"></a><span id="l36.29">     }</span>
<a href="#l36.30"></a><span id="l36.30"> </span>
<a href="#l36.31"></a><span id="l36.31" class="difflineplus">+    /* this version prints whole chunks, so rounding down to the closest 4 */</span>
<a href="#l36.32"></a><span id="l36.32" class="difflineplus">+    auto adjusted_llen = param-&gt;llen &amp; ~3;</span>
<a href="#l36.33"></a><span id="l36.33">     /* number of input bytes to form a whole line of output, param-&gt;llen / 4 * 3 */</span>
<a href="#l36.34"></a><span id="l36.34" class="difflineminus">-    inllen = (param-&gt;llen &gt;&gt; 2) + (param-&gt;llen &gt;&gt; 1);</span>
<a href="#l36.35"></a><span id="l36.35" class="difflineplus">+    inllen = (adjusted_llen &gt;&gt; 2) + (adjusted_llen &gt;&gt; 1);</span>
<a href="#l36.36"></a><span id="l36.36">     /* pointer to the last full line space in encbuf */</span>
<a href="#l36.37"></a><span id="l36.37" class="difflineminus">-    enclast = encbuf + sizeof(encbuf) - param-&gt;llen - 2;</span>
<a href="#l36.38"></a><span id="l36.38" class="difflineplus">+    enclast = encbuf + sizeof(encbuf) - adjusted_llen - 2;</span>
<a href="#l36.39"></a><span id="l36.39"> </span>
<a href="#l36.40"></a><span id="l36.40">     /* processing line chunks, this is the main performance-hitting cycle */</span>
<a href="#l36.41"></a><span id="l36.41">     while (bufptr + 3 &lt;= bufend) {</span>
<a href="#l36.42"></a><span id="l36.42">         /* checking whether we have enough space in encbuf */</span>
<a href="#l36.43"></a><span id="l36.43">         if (encptr &gt; enclast) {</span>
<a href="#l36.44"></a><span id="l36.44">             dst_write(param-&gt;writedst, encbuf, encptr - encbuf);</span>
<a href="#l36.45"></a><span id="l36.45">             encptr = encbuf;</span>
<a href="#l36.46"></a><span id="l36.46">         }</span>
<a href="#l36.47"></a><span id="l36.47">         /* setup length of the input to process in this iteration */</span>
<a href="#l36.48"></a><span id="l36.48" class="difflineminus">-        inlend =</span>
<a href="#l36.49"></a><span id="l36.49" class="difflineminus">-          param-&gt;lout == 0 ? bufptr + inllen : bufptr + ((param-&gt;llen - param-&gt;lout) &gt;&gt; 2) * 3;</span>
<a href="#l36.50"></a><span id="l36.50" class="difflineplus">+        inlend = param-&gt;lout == 0 ? bufptr + inllen :</span>
<a href="#l36.51"></a><span id="l36.51" class="difflineplus">+                                    bufptr + ((adjusted_llen - param-&gt;lout) &gt;&gt; 2) * 3;</span>
<a href="#l36.52"></a><span id="l36.52">         if (inlend &gt; bufend) {</span>
<a href="#l36.53"></a><span id="l36.53">             /* no enough input for the full line */</span>
<a href="#l36.54"></a><span id="l36.54">             inlend = bufptr + (bufend - bufptr) / 3 * 3;</span>
<a href="#l36.55"></a><span id="l36.55">             param-&gt;lout += (inlend - bufptr) / 3 * 4;</span>
<a href="#l36.56"></a><span id="l36.56">         } else {</span>
<a href="#l36.57"></a><span id="l36.57">             /* we have full line of input */</span>
<a href="#l36.58"></a><span id="l36.58">             param-&gt;lout = 0;</span>
<a href="#l36.59"></a><span id="l36.59">         }</span>
<a href="#l36.60"></a><span id="l36.60" class="difflineat">@@ -944,16 +948,34 @@ finish:</span>
<a href="#l36.61"></a><span id="l36.61">     if (ret != RNP_SUCCESS) {</span>
<a href="#l36.62"></a><span id="l36.62">         armored_dst_close(dst, true);</span>
<a href="#l36.63"></a><span id="l36.63">     }</span>
<a href="#l36.64"></a><span id="l36.64"> </span>
<a href="#l36.65"></a><span id="l36.65">     return ret;</span>
<a href="#l36.66"></a><span id="l36.66"> }</span>
<a href="#l36.67"></a><span id="l36.67"> </span>
<a href="#l36.68"></a><span id="l36.68"> bool</span>
<a href="#l36.69"></a><span id="l36.69" class="difflineplus">+is_armored_dest(pgp_dest_t *dst)</span>
<a href="#l36.70"></a><span id="l36.70" class="difflineplus">+{</span>
<a href="#l36.71"></a><span id="l36.71" class="difflineplus">+    return dst-&gt;type == PGP_STREAM_ARMORED;</span>
<a href="#l36.72"></a><span id="l36.72" class="difflineplus">+}</span>
<a href="#l36.73"></a><span id="l36.73" class="difflineplus">+</span>
<a href="#l36.74"></a><span id="l36.74" class="difflineplus">+rnp_result_t</span>
<a href="#l36.75"></a><span id="l36.75" class="difflineplus">+armored_dst_set_line_length(pgp_dest_t *dst, size_t llen)</span>
<a href="#l36.76"></a><span id="l36.76" class="difflineplus">+{</span>
<a href="#l36.77"></a><span id="l36.77" class="difflineplus">+    if (!dst || (llen &lt; ARMORED_MIN_LINE_LENGTH) || (llen &gt; ARMORED_MAX_LINE_LENGTH) ||</span>
<a href="#l36.78"></a><span id="l36.78" class="difflineplus">+        !dst-&gt;param || !is_armored_dest(dst)) {</span>
<a href="#l36.79"></a><span id="l36.79" class="difflineplus">+        return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l36.80"></a><span id="l36.80" class="difflineplus">+    }</span>
<a href="#l36.81"></a><span id="l36.81" class="difflineplus">+    auto param = (pgp_dest_armored_param_t *) dst-&gt;param;</span>
<a href="#l36.82"></a><span id="l36.82" class="difflineplus">+    param-&gt;llen = llen;</span>
<a href="#l36.83"></a><span id="l36.83" class="difflineplus">+    return RNP_SUCCESS;</span>
<a href="#l36.84"></a><span id="l36.84" class="difflineplus">+}</span>
<a href="#l36.85"></a><span id="l36.85" class="difflineplus">+</span>
<a href="#l36.86"></a><span id="l36.86" class="difflineplus">+bool</span>
<a href="#l36.87"></a><span id="l36.87"> is_armored_source(pgp_source_t *src)</span>
<a href="#l36.88"></a><span id="l36.88"> {</span>
<a href="#l36.89"></a><span id="l36.89">     uint8_t buf[128];</span>
<a href="#l36.90"></a><span id="l36.90">     size_t  read = 0;</span>
<a href="#l36.91"></a><span id="l36.91"> </span>
<a href="#l36.92"></a><span id="l36.92">     if (!src_peek(src, buf, sizeof(buf), &amp;read) || (read &lt; strlen(ST_ARMOR_BEGIN) + 1)) {</span>
<a href="#l36.93"></a><span id="l36.93">         return false;</span>
<a href="#l36.94"></a><span id="l36.94">     }</span>
<a href="#l36.95"></a><span id="l36.95" class="difflineat">@@ -974,89 +996,62 @@ is_cleartext_source(pgp_source_t *src)</span>
<a href="#l36.96"></a><span id="l36.96">     return !!strstr((char *) buf, ST_CLEAR_BEGIN);</span>
<a href="#l36.97"></a><span id="l36.97"> }</span>
<a href="#l36.98"></a><span id="l36.98"> </span>
<a href="#l36.99"></a><span id="l36.99"> rnp_result_t</span>
<a href="#l36.100"></a><span id="l36.100"> rnp_dearmor_source(pgp_source_t *src, pgp_dest_t *dst)</span>
<a href="#l36.101"></a><span id="l36.101"> {</span>
<a href="#l36.102"></a><span id="l36.102">     rnp_result_t res = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l36.103"></a><span id="l36.103">     pgp_source_t armorsrc = {0};</span>
<a href="#l36.104"></a><span id="l36.104" class="difflineminus">-    uint8_t      readbuf[PGP_INPUT_CACHE_SIZE];</span>
<a href="#l36.105"></a><span id="l36.105" class="difflineplus">+    uint8_t      readbuf[strlen(ST_CLEAR_BEGIN) + 1];</span>
<a href="#l36.106"></a><span id="l36.106">     size_t       read;</span>
<a href="#l36.107"></a><span id="l36.107"> </span>
<a href="#l36.108"></a><span id="l36.108" class="difflineminus">-    if (!src_peek(src, readbuf, strlen(ST_CLEAR_BEGIN) + 1, &amp;read) ||</span>
<a href="#l36.109"></a><span id="l36.109" class="difflineplus">+    if (!src_peek(src, readbuf, strlen(ST_CLEAR_BEGIN), &amp;read) ||</span>
<a href="#l36.110"></a><span id="l36.110">         (read &lt; strlen(ST_ARMOR_BEGIN))) {</span>
<a href="#l36.111"></a><span id="l36.111">         RNP_LOG(&quot;can't read enough data from source&quot;);</span>
<a href="#l36.112"></a><span id="l36.112">         return RNP_ERROR_READ;</span>
<a href="#l36.113"></a><span id="l36.113">     }</span>
<a href="#l36.114"></a><span id="l36.114"> </span>
<a href="#l36.115"></a><span id="l36.115">     /* Trying armored or cleartext data */</span>
<a href="#l36.116"></a><span id="l36.116" class="difflineminus">-    readbuf[read - 1] = 0;</span>
<a href="#l36.117"></a><span id="l36.117" class="difflineplus">+    readbuf[read] = 0;</span>
<a href="#l36.118"></a><span id="l36.118">     if (strstr((char *) readbuf, ST_ARMOR_BEGIN)) {</span>
<a href="#l36.119"></a><span id="l36.119">         /* checking whether it is cleartext */</span>
<a href="#l36.120"></a><span id="l36.120">         if (strstr((char *) readbuf, ST_CLEAR_BEGIN)) {</span>
<a href="#l36.121"></a><span id="l36.121">             RNP_LOG(&quot;source is cleartext, not armored&quot;);</span>
<a href="#l36.122"></a><span id="l36.122">             return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l36.123"></a><span id="l36.123">         }</span>
<a href="#l36.124"></a><span id="l36.124"> </span>
<a href="#l36.125"></a><span id="l36.125">         /* initializing armored message */</span>
<a href="#l36.126"></a><span id="l36.126">         res = init_armored_src(&amp;armorsrc, src);</span>
<a href="#l36.127"></a><span id="l36.127">         if (res) {</span>
<a href="#l36.128"></a><span id="l36.128" class="difflineminus">-            goto finish;</span>
<a href="#l36.129"></a><span id="l36.129" class="difflineplus">+            return res;</span>
<a href="#l36.130"></a><span id="l36.130">         }</span>
<a href="#l36.131"></a><span id="l36.131">     } else {</span>
<a href="#l36.132"></a><span id="l36.132">         RNP_LOG(&quot;source is not armored data&quot;);</span>
<a href="#l36.133"></a><span id="l36.133">         return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l36.134"></a><span id="l36.134">     }</span>
<a href="#l36.135"></a><span id="l36.135" class="difflineplus">+    /* Reading data from armored source and writing it to the output */</span>
<a href="#l36.136"></a><span id="l36.136" class="difflineplus">+    res = dst_write_src(&amp;armorsrc, dst);</span>
<a href="#l36.137"></a><span id="l36.137" class="difflineplus">+    if (res) {</span>
<a href="#l36.138"></a><span id="l36.138" class="difflineplus">+        RNP_LOG(&quot;dearmoring failed&quot;);</span>
<a href="#l36.139"></a><span id="l36.139" class="difflineplus">+    }</span>
<a href="#l36.140"></a><span id="l36.140"> </span>
<a href="#l36.141"></a><span id="l36.141" class="difflineminus">-    /* Reading data from armored source and writing it to the output */</span>
<a href="#l36.142"></a><span id="l36.142" class="difflineminus">-    while (!armorsrc.eof) {</span>
<a href="#l36.143"></a><span id="l36.143" class="difflineminus">-        if (!src_read(&amp;armorsrc, readbuf, PGP_INPUT_CACHE_SIZE, &amp;read)) {</span>
<a href="#l36.144"></a><span id="l36.144" class="difflineminus">-            res = RNP_ERROR_GENERIC;</span>
<a href="#l36.145"></a><span id="l36.145" class="difflineminus">-            break;</span>
<a href="#l36.146"></a><span id="l36.146" class="difflineminus">-        }</span>
<a href="#l36.147"></a><span id="l36.147" class="difflineminus">-        if (!read) {</span>
<a href="#l36.148"></a><span id="l36.148" class="difflineminus">-            continue;</span>
<a href="#l36.149"></a><span id="l36.149" class="difflineminus">-        }</span>
<a href="#l36.150"></a><span id="l36.150" class="difflineminus">-        dst_write(dst, readbuf, read);</span>
<a href="#l36.151"></a><span id="l36.151" class="difflineminus">-        if (dst-&gt;werr) {</span>
<a href="#l36.152"></a><span id="l36.152" class="difflineminus">-            RNP_LOG(&quot;failed to output data&quot;);</span>
<a href="#l36.153"></a><span id="l36.153" class="difflineminus">-            res = RNP_ERROR_WRITE;</span>
<a href="#l36.154"></a><span id="l36.154" class="difflineminus">-            break;</span>
<a href="#l36.155"></a><span id="l36.155" class="difflineminus">-        }</span>
<a href="#l36.156"></a><span id="l36.156" class="difflineminus">-    }</span>
<a href="#l36.157"></a><span id="l36.157" class="difflineminus">-finish:</span>
<a href="#l36.158"></a><span id="l36.158">     src_close(&amp;armorsrc);</span>
<a href="#l36.159"></a><span id="l36.159">     return res;</span>
<a href="#l36.160"></a><span id="l36.160"> }</span>
<a href="#l36.161"></a><span id="l36.161"> </span>
<a href="#l36.162"></a><span id="l36.162"> rnp_result_t</span>
<a href="#l36.163"></a><span id="l36.163"> rnp_armor_source(pgp_source_t *src, pgp_dest_t *dst, pgp_armored_msg_t msgtype)</span>
<a href="#l36.164"></a><span id="l36.164"> {</span>
<a href="#l36.165"></a><span id="l36.165">     pgp_dest_t   armordst = {0};</span>
<a href="#l36.166"></a><span id="l36.166" class="difflineminus">-    rnp_result_t res = RNP_ERROR_GENERIC;</span>
<a href="#l36.167"></a><span id="l36.167" class="difflineminus">-    uint8_t      readbuf[PGP_INPUT_CACHE_SIZE];</span>
<a href="#l36.168"></a><span id="l36.168" class="difflineminus">-    size_t       read;</span>
<a href="#l36.169"></a><span id="l36.169" class="difflineminus">-</span>
<a href="#l36.170"></a><span id="l36.170" class="difflineminus">-    res = init_armored_dst(&amp;armordst, dst, msgtype);</span>
<a href="#l36.171"></a><span id="l36.171" class="difflineplus">+    rnp_result_t res = init_armored_dst(&amp;armordst, dst, msgtype);</span>
<a href="#l36.172"></a><span id="l36.172">     if (res) {</span>
<a href="#l36.173"></a><span id="l36.173" class="difflineminus">-        goto finish;</span>
<a href="#l36.174"></a><span id="l36.174" class="difflineplus">+        return res;</span>
<a href="#l36.175"></a><span id="l36.175">     }</span>
<a href="#l36.176"></a><span id="l36.176"> </span>
<a href="#l36.177"></a><span id="l36.177" class="difflineminus">-    while (!src-&gt;eof) {</span>
<a href="#l36.178"></a><span id="l36.178" class="difflineminus">-        if (!src_read(src, readbuf, PGP_INPUT_CACHE_SIZE, &amp;read)) {</span>
<a href="#l36.179"></a><span id="l36.179" class="difflineminus">-            res = RNP_ERROR_READ;</span>
<a href="#l36.180"></a><span id="l36.180" class="difflineminus">-            break;</span>
<a href="#l36.181"></a><span id="l36.181" class="difflineminus">-        }</span>
<a href="#l36.182"></a><span id="l36.182" class="difflineminus">-        if (!read) {</span>
<a href="#l36.183"></a><span id="l36.183" class="difflineminus">-            continue;</span>
<a href="#l36.184"></a><span id="l36.184" class="difflineminus">-        }</span>
<a href="#l36.185"></a><span id="l36.185" class="difflineminus">-        dst_write(&amp;armordst, readbuf, read);</span>
<a href="#l36.186"></a><span id="l36.186" class="difflineminus">-        if (armordst.werr) {</span>
<a href="#l36.187"></a><span id="l36.187" class="difflineminus">-            RNP_LOG(&quot;failed to output data&quot;);</span>
<a href="#l36.188"></a><span id="l36.188" class="difflineminus">-            res = RNP_ERROR_WRITE;</span>
<a href="#l36.189"></a><span id="l36.189" class="difflineminus">-            break;</span>
<a href="#l36.190"></a><span id="l36.190" class="difflineminus">-        }</span>
<a href="#l36.191"></a><span id="l36.191" class="difflineplus">+    res = dst_write_src(src, &amp;armordst);</span>
<a href="#l36.192"></a><span id="l36.192" class="difflineplus">+    if (res) {</span>
<a href="#l36.193"></a><span id="l36.193" class="difflineplus">+        RNP_LOG(&quot;armoring failed&quot;);</span>
<a href="#l36.194"></a><span id="l36.194">     }</span>
<a href="#l36.195"></a><span id="l36.195" class="difflineminus">-finish:</span>
<a href="#l36.196"></a><span id="l36.196" class="difflineplus">+</span>
<a href="#l36.197"></a><span id="l36.197">     dst_close(&amp;armordst, res != RNP_SUCCESS);</span>
<a href="#l36.198"></a><span id="l36.198">     return res;</span>
<a href="#l36.199"></a><span id="l36.199"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-armor.h</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-armor.h</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l37.4"></a><span id="l37.4"> /*</span>
<a href="#l37.5"></a><span id="l37.5" class="difflineminus">- * Copyright (c) 2017, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l37.6"></a><span id="l37.6" class="difflineplus">+ * Copyright (c) 2017-2020, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l37.7"></a><span id="l37.7">  * All rights reserved.</span>
<a href="#l37.8"></a><span id="l37.8">  *</span>
<a href="#l37.9"></a><span id="l37.9">  * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l37.10"></a><span id="l37.10">  * are permitted provided that the following conditions are met:</span>
<a href="#l37.11"></a><span id="l37.11">  *</span>
<a href="#l37.12"></a><span id="l37.12">  * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l37.13"></a><span id="l37.13">  *     this list of conditions and the following disclaimer.</span>
<a href="#l37.14"></a><span id="l37.14">  *</span>
<a href="#l37.15"></a><span id="l37.15" class="difflineat">@@ -83,15 +83,29 @@ pgp_armored_msg_t rnp_armor_guess_type(p</span>
<a href="#l37.16"></a><span id="l37.16"> pgp_armored_msg_t rnp_armored_get_type(pgp_source_t *src);</span>
<a href="#l37.17"></a><span id="l37.17"> </span>
<a href="#l37.18"></a><span id="l37.18"> /* @brief Check whether source could be an armored source</span>
<a href="#l37.19"></a><span id="l37.19">  * @param src initialized source with some data</span>
<a href="#l37.20"></a><span id="l37.20">  * @return true if source could be an armored data or false otherwise</span>
<a href="#l37.21"></a><span id="l37.21">  **/</span>
<a href="#l37.22"></a><span id="l37.22"> bool is_armored_source(pgp_source_t *src);</span>
<a href="#l37.23"></a><span id="l37.23"> </span>
<a href="#l37.24"></a><span id="l37.24" class="difflineplus">+/* @brief Check whether destination is armored</span>
<a href="#l37.25"></a><span id="l37.25" class="difflineplus">+ * @param dest initialized destination</span>
<a href="#l37.26"></a><span id="l37.26" class="difflineplus">+ * @return true if destination is armored or false otherwise</span>
<a href="#l37.27"></a><span id="l37.27" class="difflineplus">+ **/</span>
<a href="#l37.28"></a><span id="l37.28" class="difflineplus">+bool is_armored_dest(pgp_dest_t *dst);</span>
<a href="#l37.29"></a><span id="l37.29" class="difflineplus">+</span>
<a href="#l37.30"></a><span id="l37.30"> /* @brief Check whether source is cleartext signed</span>
<a href="#l37.31"></a><span id="l37.31">  * @param src initialized source with some data</span>
<a href="#l37.32"></a><span id="l37.32">  * @return true if source could be a cleartext signed data or false otherwise</span>
<a href="#l37.33"></a><span id="l37.33">  **/</span>
<a href="#l37.34"></a><span id="l37.34"> bool is_cleartext_source(pgp_source_t *src);</span>
<a href="#l37.35"></a><span id="l37.35"> </span>
<a href="#l37.36"></a><span id="l37.36" class="difflineplus">+/** Set line length for armoring</span>
<a href="#l37.37"></a><span id="l37.37" class="difflineplus">+ *</span>
<a href="#l37.38"></a><span id="l37.38" class="difflineplus">+ *  @param dst initialized dest to write armored data to</span>
<a href="#l37.39"></a><span id="l37.39" class="difflineplus">+ *  @param llen line length in characters</span>
<a href="#l37.40"></a><span id="l37.40" class="difflineplus">+ *  @return RNP_SUCCESS on success, or any other value on error</span>
<a href="#l37.41"></a><span id="l37.41" class="difflineplus">+ */</span>
<a href="#l37.42"></a><span id="l37.42" class="difflineplus">+rnp_result_t armored_dst_set_line_length(pgp_dest_t *dst, size_t llen);</span>
<a href="#l37.43"></a><span id="l37.43" class="difflineplus">+</span>
<a href="#l37.44"></a><span id="l37.44"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-common.cpp</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-common.cpp</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -541,34 +541,22 @@ init_null_src(pgp_source_t *src)</span>
<a href="#l38.4"></a><span id="l38.4">     return RNP_SUCCESS;</span>
<a href="#l38.5"></a><span id="l38.5"> }</span>
<a href="#l38.6"></a><span id="l38.6"> </span>
<a href="#l38.7"></a><span id="l38.7"> rnp_result_t</span>
<a href="#l38.8"></a><span id="l38.8"> read_mem_src(pgp_source_t *src, pgp_source_t *readsrc)</span>
<a href="#l38.9"></a><span id="l38.9"> {</span>
<a href="#l38.10"></a><span id="l38.10">     pgp_dest_t   dst;</span>
<a href="#l38.11"></a><span id="l38.11">     rnp_result_t ret;</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-    uint8_t      buf[4096];</span>
<a href="#l38.13"></a><span id="l38.13" class="difflineminus">-    size_t       read;</span>
<a href="#l38.14"></a><span id="l38.14"> </span>
<a href="#l38.15"></a><span id="l38.15">     if ((ret = init_mem_dest(&amp;dst, NULL, 0))) {</span>
<a href="#l38.16"></a><span id="l38.16">         return ret;</span>
<a href="#l38.17"></a><span id="l38.17">     }</span>
<a href="#l38.18"></a><span id="l38.18"> </span>
<a href="#l38.19"></a><span id="l38.19" class="difflineminus">-    while (!src_eof(readsrc)) {</span>
<a href="#l38.20"></a><span id="l38.20" class="difflineminus">-        if (!src_read(readsrc, buf, sizeof(buf), &amp;read)) {</span>
<a href="#l38.21"></a><span id="l38.21" class="difflineminus">-            goto done;</span>
<a href="#l38.22"></a><span id="l38.22" class="difflineminus">-        }</span>
<a href="#l38.23"></a><span id="l38.23" class="difflineminus">-        if (read) {</span>
<a href="#l38.24"></a><span id="l38.24" class="difflineminus">-            dst_write(&amp;dst, buf, read);</span>
<a href="#l38.25"></a><span id="l38.25" class="difflineminus">-        }</span>
<a href="#l38.26"></a><span id="l38.26" class="difflineminus">-    }</span>
<a href="#l38.27"></a><span id="l38.27" class="difflineminus">-</span>
<a href="#l38.28"></a><span id="l38.28" class="difflineminus">-    if (dst.werr) {</span>
<a href="#l38.29"></a><span id="l38.29" class="difflineminus">-        ret = dst.werr;</span>
<a href="#l38.30"></a><span id="l38.30" class="difflineplus">+    if ((ret = dst_write_src(readsrc, &amp;dst))) {</span>
<a href="#l38.31"></a><span id="l38.31">         goto done;</span>
<a href="#l38.32"></a><span id="l38.32">     }</span>
<a href="#l38.33"></a><span id="l38.33"> </span>
<a href="#l38.34"></a><span id="l38.34">     if ((ret = init_mem_src(src, mem_dest_own_memory(&amp;dst), dst.writeb, true))) {</span>
<a href="#l38.35"></a><span id="l38.35">         goto done;</span>
<a href="#l38.36"></a><span id="l38.36">     }</span>
<a href="#l38.37"></a><span id="l38.37"> </span>
<a href="#l38.38"></a><span id="l38.38">     ret = RNP_SUCCESS;</span>
<a href="#l38.39"></a><span id="l38.39" class="difflineat">@@ -1111,8 +1099,37 @@ init_null_dest(pgp_dest_t *dst)</span>
<a href="#l38.40"></a><span id="l38.40">     dst-&gt;type = PGP_STREAM_NULL;</span>
<a href="#l38.41"></a><span id="l38.41">     dst-&gt;writeb = 0;</span>
<a href="#l38.42"></a><span id="l38.42">     dst-&gt;clen = 0;</span>
<a href="#l38.43"></a><span id="l38.43">     dst-&gt;werr = RNP_SUCCESS;</span>
<a href="#l38.44"></a><span id="l38.44">     dst-&gt;no_cache = true;</span>
<a href="#l38.45"></a><span id="l38.45"> </span>
<a href="#l38.46"></a><span id="l38.46">     return RNP_SUCCESS;</span>
<a href="#l38.47"></a><span id="l38.47"> }</span>
<a href="#l38.48"></a><span id="l38.48" class="difflineplus">+</span>
<a href="#l38.49"></a><span id="l38.49" class="difflineplus">+rnp_result_t</span>
<a href="#l38.50"></a><span id="l38.50" class="difflineplus">+dst_write_src(pgp_source_t *src, pgp_dest_t *dst)</span>
<a href="#l38.51"></a><span id="l38.51" class="difflineplus">+{</span>
<a href="#l38.52"></a><span id="l38.52" class="difflineplus">+    uint8_t      readbuf[PGP_INPUT_CACHE_SIZE];</span>
<a href="#l38.53"></a><span id="l38.53" class="difflineplus">+    rnp_result_t res = RNP_SUCCESS;</span>
<a href="#l38.54"></a><span id="l38.54" class="difflineplus">+    size_t       read;</span>
<a href="#l38.55"></a><span id="l38.55" class="difflineplus">+</span>
<a href="#l38.56"></a><span id="l38.56" class="difflineplus">+    while (!src-&gt;eof) {</span>
<a href="#l38.57"></a><span id="l38.57" class="difflineplus">+        if (!src_read(src, readbuf, sizeof(readbuf), &amp;read)) {</span>
<a href="#l38.58"></a><span id="l38.58" class="difflineplus">+            res = RNP_ERROR_GENERIC;</span>
<a href="#l38.59"></a><span id="l38.59" class="difflineplus">+            break;</span>
<a href="#l38.60"></a><span id="l38.60" class="difflineplus">+        }</span>
<a href="#l38.61"></a><span id="l38.61" class="difflineplus">+        if (!read) {</span>
<a href="#l38.62"></a><span id="l38.62" class="difflineplus">+            continue;</span>
<a href="#l38.63"></a><span id="l38.63" class="difflineplus">+        }</span>
<a href="#l38.64"></a><span id="l38.64" class="difflineplus">+        dst_write(dst, readbuf, read);</span>
<a href="#l38.65"></a><span id="l38.65" class="difflineplus">+        if (dst-&gt;werr) {</span>
<a href="#l38.66"></a><span id="l38.66" class="difflineplus">+            RNP_LOG(&quot;failed to output data&quot;);</span>
<a href="#l38.67"></a><span id="l38.67" class="difflineplus">+            res = RNP_ERROR_WRITE;</span>
<a href="#l38.68"></a><span id="l38.68" class="difflineplus">+            break;</span>
<a href="#l38.69"></a><span id="l38.69" class="difflineplus">+        }</span>
<a href="#l38.70"></a><span id="l38.70" class="difflineplus">+    }</span>
<a href="#l38.71"></a><span id="l38.71" class="difflineplus">+    if (res) {</span>
<a href="#l38.72"></a><span id="l38.72" class="difflineplus">+        return res;</span>
<a href="#l38.73"></a><span id="l38.73" class="difflineplus">+    }</span>
<a href="#l38.74"></a><span id="l38.74" class="difflineplus">+    dst_flush(dst);</span>
<a href="#l38.75"></a><span id="l38.75" class="difflineplus">+    return dst-&gt;werr;</span>
<a href="#l38.76"></a><span id="l38.76" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-common.h</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-common.h</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l39.4"></a><span id="l39.4"> /*</span>
<a href="#l39.5"></a><span id="l39.5" class="difflineminus">- * Copyright (c) 2017, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l39.6"></a><span id="l39.6" class="difflineplus">+ * Copyright (c) 2017-2020, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l39.7"></a><span id="l39.7">  * All rights reserved.</span>
<a href="#l39.8"></a><span id="l39.8">  *</span>
<a href="#l39.9"></a><span id="l39.9">  * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l39.10"></a><span id="l39.10">  * are permitted provided that the following conditions are met:</span>
<a href="#l39.11"></a><span id="l39.11">  *</span>
<a href="#l39.12"></a><span id="l39.12">  * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l39.13"></a><span id="l39.13">  *     this list of conditions and the following disclaimer.</span>
<a href="#l39.14"></a><span id="l39.14">  *</span>
<a href="#l39.15"></a><span id="l39.15" class="difflineat">@@ -348,9 +348,16 @@ void *mem_dest_get_memory(pgp_dest_t *ds</span>
<a href="#l39.16"></a><span id="l39.16"> void *mem_dest_own_memory(pgp_dest_t *dst);</span>
<a href="#l39.17"></a><span id="l39.17"> </span>
<a href="#l39.18"></a><span id="l39.18"> /** @brief init null destination which silently discards all the output</span>
<a href="#l39.19"></a><span id="l39.19">  *  @param dst pre-allocated dest structure</span>
<a href="#l39.20"></a><span id="l39.20">  *  @return RNP_SUCCESS or error code</span>
<a href="#l39.21"></a><span id="l39.21">  **/</span>
<a href="#l39.22"></a><span id="l39.22"> rnp_result_t init_null_dest(pgp_dest_t *dst);</span>
<a href="#l39.23"></a><span id="l39.23"> </span>
<a href="#l39.24"></a><span id="l39.24" class="difflineplus">+/** @brief reads from source and writes to destination</span>
<a href="#l39.25"></a><span id="l39.25" class="difflineplus">+ *  @param src initialized source</span>
<a href="#l39.26"></a><span id="l39.26" class="difflineplus">+ *  @param dst initialized destination</span>
<a href="#l39.27"></a><span id="l39.27" class="difflineplus">+ *  @return RNP_SUCCESS or error code</span>
<a href="#l39.28"></a><span id="l39.28" class="difflineplus">+ **/</span>
<a href="#l39.29"></a><span id="l39.29" class="difflineplus">+rnp_result_t dst_write_src(pgp_source_t *src, pgp_dest_t *dst);</span>
<a href="#l39.30"></a><span id="l39.30" class="difflineplus">+</span>
<a href="#l39.31"></a><span id="l39.31"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-ctx.h</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-ctx.h</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -72,46 +72,41 @@ typedef struct rnp_signer_info_t {</span>
<a href="#l40.4"></a><span id="l40.4">  *  - clearsign, detached : controls kind of the signed data. Both are mutually-exclusive.</span>
<a href="#l40.5"></a><span id="l40.5">  *    If both are false then attached signing is used.</span>
<a href="#l40.6"></a><span id="l40.6">  *  - halg : hash algorithm used to calculate signature(s)</span>
<a href="#l40.7"></a><span id="l40.7">  *  - signers : list of rnp_signer_info_t structures describing signing key and parameters</span>
<a href="#l40.8"></a><span id="l40.8">  *  - sigcreate, sigexpire : default signature(s) creation and expiration times</span>
<a href="#l40.9"></a><span id="l40.9">  *  - filename, filemtime, zalg, zlevel : only for attached signatures, see previous</span>
<a href="#l40.10"></a><span id="l40.10">  *</span>
<a href="#l40.11"></a><span id="l40.11">  *  For data decryption and/or verification there is not much of fields:</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">- *  - on_signatures: callback, called when signature verification information is available.</span>
<a href="#l40.13"></a><span id="l40.13" class="difflineminus">- *    If we have just encrypted data then it will not be called.</span>
<a href="#l40.14"></a><span id="l40.14" class="difflineminus">- *  - sig_cb_param: parameter to be passed to on_signatures callback.</span>
<a href="#l40.15"></a><span id="l40.15">  *  - discard: dicard the output data (i.e. just decrypt and/or verify signatures)</span>
<a href="#l40.16"></a><span id="l40.16">  *</span>
<a href="#l40.17"></a><span id="l40.17">  */</span>
<a href="#l40.18"></a><span id="l40.18"> </span>
<a href="#l40.19"></a><span id="l40.19"> typedef struct rnp_ctx_t {</span>
<a href="#l40.20"></a><span id="l40.20" class="difflineminus">-    char *          filename;      /* name of the input file to store in literal data packet */</span>
<a href="#l40.21"></a><span id="l40.21" class="difflineminus">-    int64_t         filemtime;     /* file modification time to store in literal data packet */</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineminus">-    int64_t         sigcreate;     /* signature creation time */</span>
<a href="#l40.23"></a><span id="l40.23" class="difflineminus">-    uint64_t        sigexpire;     /* signature expiration time */</span>
<a href="#l40.24"></a><span id="l40.24" class="difflineminus">-    bool            clearsign;     /* cleartext signature */</span>
<a href="#l40.25"></a><span id="l40.25" class="difflineminus">-    bool            detached;      /* detached signature */</span>
<a href="#l40.26"></a><span id="l40.26" class="difflineminus">-    pgp_hash_alg_t  halg;          /* hash algorithm */</span>
<a href="#l40.27"></a><span id="l40.27" class="difflineminus">-    pgp_symm_alg_t  ealg;          /* encryption algorithm */</span>
<a href="#l40.28"></a><span id="l40.28" class="difflineminus">-    int             zalg;          /* compression algorithm used */</span>
<a href="#l40.29"></a><span id="l40.29" class="difflineminus">-    int             zlevel;        /* compression level */</span>
<a href="#l40.30"></a><span id="l40.30" class="difflineminus">-    pgp_aead_alg_t  aalg;          /* non-zero to use AEAD */</span>
<a href="#l40.31"></a><span id="l40.31" class="difflineminus">-    int             abits;         /* AEAD chunk bits */</span>
<a href="#l40.32"></a><span id="l40.32" class="difflineminus">-    bool            overwrite;     /* allow to overwrite output file if exists */</span>
<a href="#l40.33"></a><span id="l40.33" class="difflineminus">-    bool            armor;         /* whether to use ASCII armor on output */</span>
<a href="#l40.34"></a><span id="l40.34" class="difflineminus">-    list            recipients;    /* recipients of the encrypted message */</span>
<a href="#l40.35"></a><span id="l40.35" class="difflineminus">-    list            passwords;     /* list of rnp_symmetric_pass_info_t */</span>
<a href="#l40.36"></a><span id="l40.36" class="difflineminus">-    list            signers;       /* list of rnp_signer_info_t structures */</span>
<a href="#l40.37"></a><span id="l40.37" class="difflineminus">-    bool            discard;       /* discard the output */</span>
<a href="#l40.38"></a><span id="l40.38" class="difflineminus">-    void *          on_signatures; /* handler for signed messages */</span>
<a href="#l40.39"></a><span id="l40.39" class="difflineminus">-    void *          sig_cb_param;  /* callback data passed to on_signatures */</span>
<a href="#l40.40"></a><span id="l40.40" class="difflineminus">-    rng_t *         rng;           /* pointer to rng_t */</span>
<a href="#l40.41"></a><span id="l40.41" class="difflineminus">-    rnp_operation_t operation;     /* current operation type */</span>
<a href="#l40.42"></a><span id="l40.42" class="difflineplus">+    char *          filename;   /* name of the input file to store in literal data packet */</span>
<a href="#l40.43"></a><span id="l40.43" class="difflineplus">+    int64_t         filemtime;  /* file modification time to store in literal data packet */</span>
<a href="#l40.44"></a><span id="l40.44" class="difflineplus">+    int64_t         sigcreate;  /* signature creation time */</span>
<a href="#l40.45"></a><span id="l40.45" class="difflineplus">+    uint64_t        sigexpire;  /* signature expiration time */</span>
<a href="#l40.46"></a><span id="l40.46" class="difflineplus">+    bool            clearsign;  /* cleartext signature */</span>
<a href="#l40.47"></a><span id="l40.47" class="difflineplus">+    bool            detached;   /* detached signature */</span>
<a href="#l40.48"></a><span id="l40.48" class="difflineplus">+    pgp_hash_alg_t  halg;       /* hash algorithm */</span>
<a href="#l40.49"></a><span id="l40.49" class="difflineplus">+    pgp_symm_alg_t  ealg;       /* encryption algorithm */</span>
<a href="#l40.50"></a><span id="l40.50" class="difflineplus">+    int             zalg;       /* compression algorithm used */</span>
<a href="#l40.51"></a><span id="l40.51" class="difflineplus">+    int             zlevel;     /* compression level */</span>
<a href="#l40.52"></a><span id="l40.52" class="difflineplus">+    pgp_aead_alg_t  aalg;       /* non-zero to use AEAD */</span>
<a href="#l40.53"></a><span id="l40.53" class="difflineplus">+    int             abits;      /* AEAD chunk bits */</span>
<a href="#l40.54"></a><span id="l40.54" class="difflineplus">+    bool            overwrite;  /* allow to overwrite output file if exists */</span>
<a href="#l40.55"></a><span id="l40.55" class="difflineplus">+    bool            armor;      /* whether to use ASCII armor on output */</span>
<a href="#l40.56"></a><span id="l40.56" class="difflineplus">+    list            recipients; /* recipients of the encrypted message */</span>
<a href="#l40.57"></a><span id="l40.57" class="difflineplus">+    list            passwords;  /* list of rnp_symmetric_pass_info_t */</span>
<a href="#l40.58"></a><span id="l40.58" class="difflineplus">+    list            signers;    /* list of rnp_signer_info_t structures */</span>
<a href="#l40.59"></a><span id="l40.59" class="difflineplus">+    bool            discard;    /* discard the output */</span>
<a href="#l40.60"></a><span id="l40.60" class="difflineplus">+    rng_t *         rng;        /* pointer to rng_t */</span>
<a href="#l40.61"></a><span id="l40.61" class="difflineplus">+    rnp_operation_t operation;  /* current operation type */</span>
<a href="#l40.62"></a><span id="l40.62"> } rnp_ctx_t;</span>
<a href="#l40.63"></a><span id="l40.63"> </span>
<a href="#l40.64"></a><span id="l40.64"> typedef struct rnp_symmetric_pass_info_t {</span>
<a href="#l40.65"></a><span id="l40.65">     pgp_s2k_t      s2k;</span>
<a href="#l40.66"></a><span id="l40.66">     pgp_symm_alg_t s2k_cipher;</span>
<a href="#l40.67"></a><span id="l40.67">     uint8_t        key[PGP_MAX_KEY_SIZE];</span>
<a href="#l40.68"></a><span id="l40.68"> } rnp_symmetric_pass_info_t;</span>
<a href="#l40.69"></a><span id="l40.69"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-dump.cpp</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-dump.cpp</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -288,17 +288,17 @@ indent_dest_decrease(pgp_dest_t *dst)</span>
<a href="#l41.4"></a><span id="l41.4"> static void</span>
<a href="#l41.5"></a><span id="l41.5"> indent_dest_set(pgp_dest_t *dst, int level)</span>
<a href="#l41.6"></a><span id="l41.6"> {</span>
<a href="#l41.7"></a><span id="l41.7">     pgp_dest_indent_param_t *param = (pgp_dest_indent_param_t *) dst-&gt;param;</span>
<a href="#l41.8"></a><span id="l41.8">     param-&gt;level = level;</span>
<a href="#l41.9"></a><span id="l41.9"> }</span>
<a href="#l41.10"></a><span id="l41.10"> </span>
<a href="#l41.11"></a><span id="l41.11"> static size_t</span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-vsnprinthex(char *str, size_t slen, uint8_t *buf, size_t buflen)</span>
<a href="#l41.13"></a><span id="l41.13" class="difflineplus">+vsnprinthex(char *str, size_t slen, const uint8_t *buf, size_t buflen)</span>
<a href="#l41.14"></a><span id="l41.14"> {</span>
<a href="#l41.15"></a><span id="l41.15">     static const char *hexes = &quot;0123456789abcdef&quot;;</span>
<a href="#l41.16"></a><span id="l41.16">     size_t             idx = 0;</span>
<a href="#l41.17"></a><span id="l41.17"> </span>
<a href="#l41.18"></a><span id="l41.18">     for (size_t i = 0; (i &lt; buflen) &amp;&amp; (i &lt; (slen - 1) / 2); i++) {</span>
<a href="#l41.19"></a><span id="l41.19">         str[idx++] = hexes[buf[i] &gt;&gt; 4];</span>
<a href="#l41.20"></a><span id="l41.20">         str[idx++] = hexes[buf[i] &amp; 0xf];</span>
<a href="#l41.21"></a><span id="l41.21">     }</span>
<a href="#l41.22"></a><span id="l41.22" class="difflineat">@@ -405,34 +405,34 @@ dst_print_sig_type(pgp_dest_t *dst, cons</span>
<a href="#l41.23"></a><span id="l41.23">     const char *sig_name = pgp_str_from_map(sigtype, sig_type_map);</span>
<a href="#l41.24"></a><span id="l41.24">     if (!name) {</span>
<a href="#l41.25"></a><span id="l41.25">         name = &quot;signature type&quot;;</span>
<a href="#l41.26"></a><span id="l41.26">     }</span>
<a href="#l41.27"></a><span id="l41.27">     dst_printf(dst, &quot;%s: %d (%s)\n&quot;, name, (int) sigtype, sig_name);</span>
<a href="#l41.28"></a><span id="l41.28"> }</span>
<a href="#l41.29"></a><span id="l41.29"> </span>
<a href="#l41.30"></a><span id="l41.30"> static void</span>
<a href="#l41.31"></a><span id="l41.31" class="difflineminus">-dst_print_hex(pgp_dest_t *dst, const char *name, uint8_t *data, size_t len, bool bytes)</span>
<a href="#l41.32"></a><span id="l41.32" class="difflineplus">+dst_print_hex(pgp_dest_t *dst, const char *name, const uint8_t *data, size_t len, bool bytes)</span>
<a href="#l41.33"></a><span id="l41.33"> {</span>
<a href="#l41.34"></a><span id="l41.34">     char hex[512];</span>
<a href="#l41.35"></a><span id="l41.35">     vsnprinthex(hex, sizeof(hex), data, len);</span>
<a href="#l41.36"></a><span id="l41.36">     if (bytes) {</span>
<a href="#l41.37"></a><span id="l41.37">         dst_printf(dst, &quot;%s: 0x%s (%d bytes)\n&quot;, name, hex, (int) len);</span>
<a href="#l41.38"></a><span id="l41.38">     } else {</span>
<a href="#l41.39"></a><span id="l41.39">         dst_printf(dst, &quot;%s: 0x%s\n&quot;, name, hex);</span>
<a href="#l41.40"></a><span id="l41.40">     }</span>
<a href="#l41.41"></a><span id="l41.41"> }</span>
<a href="#l41.42"></a><span id="l41.42"> </span>
<a href="#l41.43"></a><span id="l41.43"> static void</span>
<a href="#l41.44"></a><span id="l41.44" class="difflineminus">-dst_print_keyid(pgp_dest_t *dst, const char *name, uint8_t *keyid)</span>
<a href="#l41.45"></a><span id="l41.45" class="difflineplus">+dst_print_keyid(pgp_dest_t *dst, const char *name, const pgp_key_id_t &amp;keyid)</span>
<a href="#l41.46"></a><span id="l41.46"> {</span>
<a href="#l41.47"></a><span id="l41.47">     if (!name) {</span>
<a href="#l41.48"></a><span id="l41.48">         name = &quot;key id&quot;;</span>
<a href="#l41.49"></a><span id="l41.49">     }</span>
<a href="#l41.50"></a><span id="l41.50" class="difflineminus">-    dst_print_hex(dst, name, keyid, PGP_KEY_ID_SIZE, false);</span>
<a href="#l41.51"></a><span id="l41.51" class="difflineplus">+    dst_print_hex(dst, name, keyid.data(), keyid.size(), false);</span>
<a href="#l41.52"></a><span id="l41.52"> }</span>
<a href="#l41.53"></a><span id="l41.53"> </span>
<a href="#l41.54"></a><span id="l41.54"> static void</span>
<a href="#l41.55"></a><span id="l41.55"> dst_print_s2k(pgp_dest_t *dst, pgp_s2k_t *s2k)</span>
<a href="#l41.56"></a><span id="l41.56"> {</span>
<a href="#l41.57"></a><span id="l41.57">     dst_printf(dst, &quot;s2k specifier: %d\n&quot;, (int) s2k-&gt;specifier);</span>
<a href="#l41.58"></a><span id="l41.58">     dst_print_halg(dst, &quot;s2k hash algorithm&quot;, s2k-&gt;hash_alg);</span>
<a href="#l41.59"></a><span id="l41.59">     if ((s2k-&gt;specifier == PGP_S2KS_SALTED) ||</span>
<a href="#l41.60"></a><span id="l41.60" class="difflineat">@@ -549,17 +549,17 @@ signature_dump_subpacket(rnp_dump_ctx_t </span>
<a href="#l41.61"></a><span id="l41.61">     case PGP_SIG_SUBPKT_REVOCATION_KEY:</span>
<a href="#l41.62"></a><span id="l41.62">         dst_printf(dst, &quot;%s\n&quot;, sname);</span>
<a href="#l41.63"></a><span id="l41.63">         dst_printf(dst, &quot;class: %d\n&quot;, (int) subpkt-&gt;fields.revocation_key.klass);</span>
<a href="#l41.64"></a><span id="l41.64">         dst_print_palg(dst, NULL, subpkt-&gt;fields.revocation_key.pkalg);</span>
<a href="#l41.65"></a><span id="l41.65">         dst_print_hex(</span>
<a href="#l41.66"></a><span id="l41.66">           dst, &quot;fingerprint&quot;, subpkt-&gt;fields.revocation_key.fp, PGP_FINGERPRINT_SIZE, true);</span>
<a href="#l41.67"></a><span id="l41.67">         break;</span>
<a href="#l41.68"></a><span id="l41.68">     case PGP_SIG_SUBPKT_ISSUER_KEY_ID:</span>
<a href="#l41.69"></a><span id="l41.69" class="difflineminus">-        dst_print_keyid(dst, sname, subpkt-&gt;fields.issuer);</span>
<a href="#l41.70"></a><span id="l41.70" class="difflineplus">+        dst_print_hex(dst, sname, subpkt-&gt;fields.issuer, PGP_KEY_ID_SIZE, false);</span>
<a href="#l41.71"></a><span id="l41.71">         break;</span>
<a href="#l41.72"></a><span id="l41.72">     case PGP_SIG_SUBPKT_NOTATION_DATA:</span>
<a href="#l41.73"></a><span id="l41.73">         break;</span>
<a href="#l41.74"></a><span id="l41.74">     case PGP_SIG_SUBPKT_PREFERRED_HASH:</span>
<a href="#l41.75"></a><span id="l41.75">         dst_print_algs(dst,</span>
<a href="#l41.76"></a><span id="l41.76">                        &quot;preferred hash algorithms&quot;,</span>
<a href="#l41.77"></a><span id="l41.77">                        subpkt-&gt;fields.preferred.arr,</span>
<a href="#l41.78"></a><span id="l41.78">                        subpkt-&gt;fields.preferred.len,</span>
<a href="#l41.79"></a><span id="l41.79" class="difflineat">@@ -751,17 +751,16 @@ stream_dump_signature(rnp_dump_ctx_t *ct</span>
<a href="#l41.80"></a><span id="l41.80">     free_signature(&amp;sig);</span>
<a href="#l41.81"></a><span id="l41.81"> }</span>
<a href="#l41.82"></a><span id="l41.82"> </span>
<a href="#l41.83"></a><span id="l41.83"> static rnp_result_t</span>
<a href="#l41.84"></a><span id="l41.84"> stream_dump_key(rnp_dump_ctx_t *ctx, pgp_source_t *src, pgp_dest_t *dst)</span>
<a href="#l41.85"></a><span id="l41.85"> {</span>
<a href="#l41.86"></a><span id="l41.86">     pgp_key_pkt_t     key;</span>
<a href="#l41.87"></a><span id="l41.87">     rnp_result_t      ret;</span>
<a href="#l41.88"></a><span id="l41.88" class="difflineminus">-    uint8_t           keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l41.89"></a><span id="l41.89">     pgp_fingerprint_t keyfp = {};</span>
<a href="#l41.90"></a><span id="l41.90"> </span>
<a href="#l41.91"></a><span id="l41.91">     if ((ret = stream_parse_key(src, &amp;key))) {</span>
<a href="#l41.92"></a><span id="l41.92">         return ret;</span>
<a href="#l41.93"></a><span id="l41.93">     }</span>
<a href="#l41.94"></a><span id="l41.94"> </span>
<a href="#l41.95"></a><span id="l41.95">     dst_printf(dst, &quot;%s packet\n&quot;, pgp_str_from_map(key.tag, key_type_map));</span>
<a href="#l41.96"></a><span id="l41.96">     indent_dest_increase(dst);</span>
<a href="#l41.97"></a><span id="l41.97" class="difflineat">@@ -834,24 +833,25 @@ stream_dump_key(rnp_dump_ctx_t *ctx, pgp</span>
<a href="#l41.98"></a><span id="l41.98">         }</span>
<a href="#l41.99"></a><span id="l41.99"> </span>
<a href="#l41.100"></a><span id="l41.100">         if (!key.sec_protection.s2k.usage) {</span>
<a href="#l41.101"></a><span id="l41.101">             dst_printf(dst, &quot;cleartext secret key data: %d bytes\n&quot;, (int) key.sec_len);</span>
<a href="#l41.102"></a><span id="l41.102">         }</span>
<a href="#l41.103"></a><span id="l41.103">         indent_dest_decrease(dst);</span>
<a href="#l41.104"></a><span id="l41.104">     }</span>
<a href="#l41.105"></a><span id="l41.105"> </span>
<a href="#l41.106"></a><span id="l41.106" class="difflineminus">-    if (!pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key)) {</span>
<a href="#l41.107"></a><span id="l41.107" class="difflineminus">-        dst_print_hex(dst, &quot;keyid&quot;, keyid, PGP_KEY_ID_SIZE, false);</span>
<a href="#l41.108"></a><span id="l41.108" class="difflineplus">+    pgp_key_id_t keyid = {};</span>
<a href="#l41.109"></a><span id="l41.109" class="difflineplus">+    if (!pgp_keyid(keyid, &amp;key)) {</span>
<a href="#l41.110"></a><span id="l41.110" class="difflineplus">+        dst_print_hex(dst, &quot;keyid&quot;, keyid.data(), keyid.size(), false);</span>
<a href="#l41.111"></a><span id="l41.111">     } else {</span>
<a href="#l41.112"></a><span id="l41.112">         dst_printf(dst, &quot;keyid: failed to calculate&quot;);</span>
<a href="#l41.113"></a><span id="l41.113">     }</span>
<a href="#l41.114"></a><span id="l41.114"> </span>
<a href="#l41.115"></a><span id="l41.115">     if ((key.version &gt; PGP_V3) &amp;&amp; (ctx-&gt;dump_grips)) {</span>
<a href="#l41.116"></a><span id="l41.116" class="difflineminus">-        if (!pgp_fingerprint(&amp;keyfp, &amp;key)) {</span>
<a href="#l41.117"></a><span id="l41.117" class="difflineplus">+        if (!pgp_fingerprint(keyfp, &amp;key)) {</span>
<a href="#l41.118"></a><span id="l41.118">             dst_print_hex(dst, &quot;fingerprint&quot;, keyfp.fingerprint, keyfp.length, false);</span>
<a href="#l41.119"></a><span id="l41.119">         } else {</span>
<a href="#l41.120"></a><span id="l41.120">             dst_printf(dst, &quot;fingerprint: failed to calculate&quot;);</span>
<a href="#l41.121"></a><span id="l41.121">         }</span>
<a href="#l41.122"></a><span id="l41.122">     }</span>
<a href="#l41.123"></a><span id="l41.123"> </span>
<a href="#l41.124"></a><span id="l41.124">     if (ctx-&gt;dump_grips) {</span>
<a href="#l41.125"></a><span id="l41.125">         pgp_key_grip_t grip;</span>
<a href="#l41.126"></a><span id="l41.126" class="difflineat">@@ -1646,17 +1646,17 @@ stream_dump_signature_pkt_json(rnp_dump_</span>
<a href="#l41.127"></a><span id="l41.127">         goto done;</span>
<a href="#l41.128"></a><span id="l41.128">     }</span>
<a href="#l41.129"></a><span id="l41.129"> </span>
<a href="#l41.130"></a><span id="l41.130">     if (sig-&gt;version &lt; PGP_V4) {</span>
<a href="#l41.131"></a><span id="l41.131">         if (!obj_add_field_json(</span>
<a href="#l41.132"></a><span id="l41.132">               pkt, &quot;creation time&quot;, json_object_new_int(sig-&gt;creation_time))) {</span>
<a href="#l41.133"></a><span id="l41.133">             goto done;</span>
<a href="#l41.134"></a><span id="l41.134">         }</span>
<a href="#l41.135"></a><span id="l41.135" class="difflineminus">-        if (!obj_add_hex_json(pkt, &quot;signer&quot;, sig-&gt;signer, PGP_KEY_ID_SIZE)) {</span>
<a href="#l41.136"></a><span id="l41.136" class="difflineplus">+        if (!obj_add_hex_json(pkt, &quot;signer&quot;, sig-&gt;signer.data(), sig-&gt;signer.size())) {</span>
<a href="#l41.137"></a><span id="l41.137">             goto done;</span>
<a href="#l41.138"></a><span id="l41.138">         }</span>
<a href="#l41.139"></a><span id="l41.139">     }</span>
<a href="#l41.140"></a><span id="l41.140">     if (!obj_add_intstr_json(pkt, &quot;algorithm&quot;, sig-&gt;palg, pubkey_alg_map)) {</span>
<a href="#l41.141"></a><span id="l41.141">         goto done;</span>
<a href="#l41.142"></a><span id="l41.142">     }</span>
<a href="#l41.143"></a><span id="l41.143">     if (!obj_add_intstr_json(pkt, &quot;hash algorithm&quot;, sig-&gt;halg, hash_alg_map)) {</span>
<a href="#l41.144"></a><span id="l41.144">         goto done;</span>
<a href="#l41.145"></a><span id="l41.145" class="difflineat">@@ -1732,17 +1732,17 @@ stream_dump_signature_json(rnp_dump_ctx_</span>
<a href="#l41.146"></a><span id="l41.146">     return ret;</span>
<a href="#l41.147"></a><span id="l41.147"> }</span>
<a href="#l41.148"></a><span id="l41.148"> </span>
<a href="#l41.149"></a><span id="l41.149"> static rnp_result_t</span>
<a href="#l41.150"></a><span id="l41.150"> stream_dump_key_json(rnp_dump_ctx_t *ctx, pgp_source_t *src, json_object *pkt)</span>
<a href="#l41.151"></a><span id="l41.151"> {</span>
<a href="#l41.152"></a><span id="l41.152">     pgp_key_pkt_t     key;</span>
<a href="#l41.153"></a><span id="l41.153">     rnp_result_t      ret;</span>
<a href="#l41.154"></a><span id="l41.154" class="difflineminus">-    uint8_t           keyid[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l41.155"></a><span id="l41.155" class="difflineplus">+    pgp_key_id_t      keyid = {};</span>
<a href="#l41.156"></a><span id="l41.156">     pgp_fingerprint_t keyfp = {};</span>
<a href="#l41.157"></a><span id="l41.157">     json_object *     material = NULL;</span>
<a href="#l41.158"></a><span id="l41.158"> </span>
<a href="#l41.159"></a><span id="l41.159">     if ((ret = stream_parse_key(src, &amp;key))) {</span>
<a href="#l41.160"></a><span id="l41.160">         return ret;</span>
<a href="#l41.161"></a><span id="l41.161">     }</span>
<a href="#l41.162"></a><span id="l41.162"> </span>
<a href="#l41.163"></a><span id="l41.163">     ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.164"></a><span id="l41.164" class="difflineat">@@ -1839,23 +1839,23 @@ stream_dump_key_json(rnp_dump_ctx_t *ctx</span>
<a href="#l41.165"></a><span id="l41.165">         }</span>
<a href="#l41.166"></a><span id="l41.166">         if (key.sec_protection.s2k.usage &amp;&amp;</span>
<a href="#l41.167"></a><span id="l41.167">             !obj_add_intstr_json(</span>
<a href="#l41.168"></a><span id="l41.168">               material, &quot;symmetric algorithm&quot;, key.sec_protection.symm_alg, symm_alg_map)) {</span>
<a href="#l41.169"></a><span id="l41.169">             goto done;</span>
<a href="#l41.170"></a><span id="l41.170">         }</span>
<a href="#l41.171"></a><span id="l41.171">     }</span>
<a href="#l41.172"></a><span id="l41.172"> </span>
<a href="#l41.173"></a><span id="l41.173" class="difflineminus">-    if (pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key) ||</span>
<a href="#l41.174"></a><span id="l41.174" class="difflineminus">-        !obj_add_hex_json(pkt, &quot;keyid&quot;, keyid, PGP_KEY_ID_SIZE)) {</span>
<a href="#l41.175"></a><span id="l41.175" class="difflineplus">+    if (pgp_keyid(keyid, &amp;key) ||</span>
<a href="#l41.176"></a><span id="l41.176" class="difflineplus">+        !obj_add_hex_json(pkt, &quot;keyid&quot;, keyid.data(), keyid.size())) {</span>
<a href="#l41.177"></a><span id="l41.177">         goto done;</span>
<a href="#l41.178"></a><span id="l41.178">     }</span>
<a href="#l41.179"></a><span id="l41.179"> </span>
<a href="#l41.180"></a><span id="l41.180">     if (ctx-&gt;dump_grips) {</span>
<a href="#l41.181"></a><span id="l41.181" class="difflineminus">-        if (pgp_fingerprint(&amp;keyfp, &amp;key) ||</span>
<a href="#l41.182"></a><span id="l41.182" class="difflineplus">+        if (pgp_fingerprint(keyfp, &amp;key) ||</span>
<a href="#l41.183"></a><span id="l41.183">             !obj_add_hex_json(pkt, &quot;fingerprint&quot;, keyfp.fingerprint, keyfp.length)) {</span>
<a href="#l41.184"></a><span id="l41.184">             goto done;</span>
<a href="#l41.185"></a><span id="l41.185">         }</span>
<a href="#l41.186"></a><span id="l41.186"> </span>
<a href="#l41.187"></a><span id="l41.187">         pgp_key_grip_t grip;</span>
<a href="#l41.188"></a><span id="l41.188">         if (!rnp_key_store_get_key_grip(&amp;key.material, grip) ||</span>
<a href="#l41.189"></a><span id="l41.189">             !obj_add_hex_json(pkt, &quot;grip&quot;, grip.data(), grip.size())) {</span>
<a href="#l41.190"></a><span id="l41.190">             goto done;</span>
<a href="#l41.191"></a><span id="l41.191" class="difflineat">@@ -1907,17 +1907,17 @@ stream_dump_pk_session_key_json(rnp_dump</span>
<a href="#l41.192"></a><span id="l41.192">     pgp_pk_sesskey_t pkey;</span>
<a href="#l41.193"></a><span id="l41.193">     rnp_result_t     ret;</span>
<a href="#l41.194"></a><span id="l41.194"> </span>
<a href="#l41.195"></a><span id="l41.195">     if ((ret = stream_parse_pk_sesskey(src, &amp;pkey))) {</span>
<a href="#l41.196"></a><span id="l41.196">         return ret;</span>
<a href="#l41.197"></a><span id="l41.197">     }</span>
<a href="#l41.198"></a><span id="l41.198"> </span>
<a href="#l41.199"></a><span id="l41.199">     if (!obj_add_field_json(pkt, &quot;version&quot;, json_object_new_int(pkey.version)) ||</span>
<a href="#l41.200"></a><span id="l41.200" class="difflineminus">-        !obj_add_hex_json(pkt, &quot;keyid&quot;, pkey.key_id, PGP_KEY_ID_SIZE) ||</span>
<a href="#l41.201"></a><span id="l41.201" class="difflineplus">+        !obj_add_hex_json(pkt, &quot;keyid&quot;, pkey.key_id.data(), pkey.key_id.size()) ||</span>
<a href="#l41.202"></a><span id="l41.202">         !obj_add_intstr_json(pkt, &quot;algorithm&quot;, pkey.alg, pubkey_alg_map)) {</span>
<a href="#l41.203"></a><span id="l41.203">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.204"></a><span id="l41.204">     }</span>
<a href="#l41.205"></a><span id="l41.205"> </span>
<a href="#l41.206"></a><span id="l41.206">     json_object *material = json_object_new_object();</span>
<a href="#l41.207"></a><span id="l41.207">     if (!obj_add_field_json(pkt, &quot;material&quot;, material)) {</span>
<a href="#l41.208"></a><span id="l41.208">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.209"></a><span id="l41.209">     }</span>
<a href="#l41.210"></a><span id="l41.210" class="difflineat">@@ -2031,17 +2031,17 @@ stream_dump_one_pass_json(pgp_source_t *</span>
<a href="#l41.211"></a><span id="l41.211">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.212"></a><span id="l41.212">     }</span>
<a href="#l41.213"></a><span id="l41.213">     if (!obj_add_intstr_json(pkt, &quot;hash algorithm&quot;, onepass.halg, hash_alg_map)) {</span>
<a href="#l41.214"></a><span id="l41.214">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.215"></a><span id="l41.215">     }</span>
<a href="#l41.216"></a><span id="l41.216">     if (!obj_add_intstr_json(pkt, &quot;public key algorithm&quot;, onepass.palg, pubkey_alg_map)) {</span>
<a href="#l41.217"></a><span id="l41.217">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.218"></a><span id="l41.218">     }</span>
<a href="#l41.219"></a><span id="l41.219" class="difflineminus">-    if (!obj_add_hex_json(pkt, &quot;signer&quot;, onepass.keyid, PGP_KEY_ID_SIZE)) {</span>
<a href="#l41.220"></a><span id="l41.220" class="difflineplus">+    if (!obj_add_hex_json(pkt, &quot;signer&quot;, onepass.keyid.data(), onepass.keyid.size())) {</span>
<a href="#l41.221"></a><span id="l41.221">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.222"></a><span id="l41.222">     }</span>
<a href="#l41.223"></a><span id="l41.223">     if (!obj_add_field_json(pkt, &quot;nested&quot;, json_object_new_boolean(onepass.nested))) {</span>
<a href="#l41.224"></a><span id="l41.224">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l41.225"></a><span id="l41.225">     }</span>
<a href="#l41.226"></a><span id="l41.226">     return RNP_SUCCESS;</span>
<a href="#l41.227"></a><span id="l41.227"> }</span>
<a href="#l41.228"></a><span id="l41.228"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-key.cpp</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-key.cpp</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineat">@@ -407,41 +407,41 @@ pgp_signature_t *</span>
<a href="#l42.4"></a><span id="l42.4"> transferable_userid_certify(const pgp_key_pkt_t *          key,</span>
<a href="#l42.5"></a><span id="l42.5">                             pgp_transferable_userid_t *    userid,</span>
<a href="#l42.6"></a><span id="l42.6">                             const pgp_key_pkt_t *          signer,</span>
<a href="#l42.7"></a><span id="l42.7">                             pgp_hash_alg_t                 hash_alg,</span>
<a href="#l42.8"></a><span id="l42.8">                             const rnp_selfsig_cert_info_t *cert)</span>
<a href="#l42.9"></a><span id="l42.9"> {</span>
<a href="#l42.10"></a><span id="l42.10">     pgp_signature_t         sig = {};</span>
<a href="#l42.11"></a><span id="l42.11">     pgp_signature_t *       res = NULL;</span>
<a href="#l42.12"></a><span id="l42.12" class="difflineminus">-    uint8_t                 keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+    pgp_key_id_t            keyid = {};</span>
<a href="#l42.14"></a><span id="l42.14">     pgp_fingerprint_t       keyfp;</span>
<a href="#l42.15"></a><span id="l42.15">     const pgp_user_prefs_t *prefs = NULL;</span>
<a href="#l42.16"></a><span id="l42.16"> </span>
<a href="#l42.17"></a><span id="l42.17">     if (!key || !userid || !signer || !cert) {</span>
<a href="#l42.18"></a><span id="l42.18">         RNP_LOG(&quot;invalid parameters&quot;);</span>
<a href="#l42.19"></a><span id="l42.19">         return NULL;</span>
<a href="#l42.20"></a><span id="l42.20">     }</span>
<a href="#l42.21"></a><span id="l42.21"> </span>
<a href="#l42.22"></a><span id="l42.22" class="difflineminus">-    if (pgp_keyid(keyid, sizeof(keyid), signer)) {</span>
<a href="#l42.23"></a><span id="l42.23" class="difflineplus">+    if (pgp_keyid(keyid, signer)) {</span>
<a href="#l42.24"></a><span id="l42.24">         RNP_LOG(&quot;failed to calculate keyid&quot;);</span>
<a href="#l42.25"></a><span id="l42.25">         goto end;</span>
<a href="#l42.26"></a><span id="l42.26">     }</span>
<a href="#l42.27"></a><span id="l42.27"> </span>
<a href="#l42.28"></a><span id="l42.28" class="difflineminus">-    if (pgp_fingerprint(&amp;keyfp, signer)) {</span>
<a href="#l42.29"></a><span id="l42.29" class="difflineplus">+    if (pgp_fingerprint(keyfp, signer)) {</span>
<a href="#l42.30"></a><span id="l42.30">         RNP_LOG(&quot;failed to calculate keyfp&quot;);</span>
<a href="#l42.31"></a><span id="l42.31">         goto end;</span>
<a href="#l42.32"></a><span id="l42.32">     }</span>
<a href="#l42.33"></a><span id="l42.33"> </span>
<a href="#l42.34"></a><span id="l42.34">     sig.version = PGP_V4;</span>
<a href="#l42.35"></a><span id="l42.35">     sig.halg = pgp_hash_adjust_alg_to_key(hash_alg, signer);</span>
<a href="#l42.36"></a><span id="l42.36">     sig.palg = signer-&gt;alg;</span>
<a href="#l42.37"></a><span id="l42.37">     sig.type = PGP_CERT_POSITIVE;</span>
<a href="#l42.38"></a><span id="l42.38"> </span>
<a href="#l42.39"></a><span id="l42.39" class="difflineminus">-    if (!signature_set_keyfp(&amp;sig, &amp;keyfp)) {</span>
<a href="#l42.40"></a><span id="l42.40" class="difflineplus">+    if (!signature_set_keyfp(&amp;sig, keyfp)) {</span>
<a href="#l42.41"></a><span id="l42.41">         RNP_LOG(&quot;failed to set issuer fingerprint&quot;);</span>
<a href="#l42.42"></a><span id="l42.42">         goto end;</span>
<a href="#l42.43"></a><span id="l42.43">     }</span>
<a href="#l42.44"></a><span id="l42.44">     if (!signature_set_creation(&amp;sig, time(NULL))) {</span>
<a href="#l42.45"></a><span id="l42.45">         RNP_LOG(&quot;failed to set creation time&quot;);</span>
<a href="#l42.46"></a><span id="l42.46">         goto end;</span>
<a href="#l42.47"></a><span id="l42.47">     }</span>
<a href="#l42.48"></a><span id="l42.48">     if (cert-&gt;key_expiration &amp;&amp; !signature_set_key_expiration(&amp;sig, cert-&gt;key_expiration)) {</span>
<a href="#l42.49"></a><span id="l42.49" class="difflineat">@@ -504,26 +504,26 @@ end:</span>
<a href="#l42.50"></a><span id="l42.50"> static bool</span>
<a href="#l42.51"></a><span id="l42.51"> signature_calculate_primary_binding(const pgp_key_pkt_t *key,</span>
<a href="#l42.52"></a><span id="l42.52">                                     const pgp_key_pkt_t *subkey,</span>
<a href="#l42.53"></a><span id="l42.53">                                     pgp_hash_alg_t       halg,</span>
<a href="#l42.54"></a><span id="l42.54">                                     pgp_signature_t *    sig,</span>
<a href="#l42.55"></a><span id="l42.55">                                     pgp_hash_t *         hash,</span>
<a href="#l42.56"></a><span id="l42.56">                                     rng_t *              rng)</span>
<a href="#l42.57"></a><span id="l42.57"> {</span>
<a href="#l42.58"></a><span id="l42.58" class="difflineminus">-    uint8_t keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l42.59"></a><span id="l42.59" class="difflineminus">-    bool    res = false;</span>
<a href="#l42.60"></a><span id="l42.60" class="difflineplus">+    pgp_key_id_t keyid = {};</span>
<a href="#l42.61"></a><span id="l42.61" class="difflineplus">+    bool         res = false;</span>
<a href="#l42.62"></a><span id="l42.62"> </span>
<a href="#l42.63"></a><span id="l42.63">     memset(sig, 0, sizeof(*sig));</span>
<a href="#l42.64"></a><span id="l42.64">     sig-&gt;version = PGP_V4;</span>
<a href="#l42.65"></a><span id="l42.65">     sig-&gt;halg = pgp_hash_adjust_alg_to_key(halg, subkey);</span>
<a href="#l42.66"></a><span id="l42.66">     sig-&gt;palg = subkey-&gt;alg;</span>
<a href="#l42.67"></a><span id="l42.67">     sig-&gt;type = PGP_SIG_PRIMARY;</span>
<a href="#l42.68"></a><span id="l42.68"> </span>
<a href="#l42.69"></a><span id="l42.69" class="difflineminus">-    if (pgp_keyid(keyid, sizeof(keyid), subkey)) {</span>
<a href="#l42.70"></a><span id="l42.70" class="difflineplus">+    if (pgp_keyid(keyid, subkey)) {</span>
<a href="#l42.71"></a><span id="l42.71">         RNP_LOG(&quot;failed to calculate keyid&quot;);</span>
<a href="#l42.72"></a><span id="l42.72">         goto end;</span>
<a href="#l42.73"></a><span id="l42.73">     }</span>
<a href="#l42.74"></a><span id="l42.74">     if (!signature_set_creation(sig, time(NULL))) {</span>
<a href="#l42.75"></a><span id="l42.75">         RNP_LOG(&quot;failed to set embedded sig creation time&quot;);</span>
<a href="#l42.76"></a><span id="l42.76">         goto end;</span>
<a href="#l42.77"></a><span id="l42.77">     }</span>
<a href="#l42.78"></a><span id="l42.78">     if (!signature_set_keyid(sig, keyid)) {</span>
<a href="#l42.79"></a><span id="l42.79" class="difflineat">@@ -547,22 +547,22 @@ end:</span>
<a href="#l42.80"></a><span id="l42.80"> }</span>
<a href="#l42.81"></a><span id="l42.81"> </span>
<a href="#l42.82"></a><span id="l42.82"> bool</span>
<a href="#l42.83"></a><span id="l42.83"> signature_calculate_binding(const pgp_key_pkt_t *key,</span>
<a href="#l42.84"></a><span id="l42.84">                             const pgp_key_pkt_t *sub,</span>
<a href="#l42.85"></a><span id="l42.85">                             pgp_signature_t *    sig,</span>
<a href="#l42.86"></a><span id="l42.86">                             bool                 subsign)</span>
<a href="#l42.87"></a><span id="l42.87"> {</span>
<a href="#l42.88"></a><span id="l42.88" class="difflineminus">-    pgp_hash_t hash = {};</span>
<a href="#l42.89"></a><span id="l42.89" class="difflineminus">-    pgp_hash_t hashcp = {};</span>
<a href="#l42.90"></a><span id="l42.90" class="difflineminus">-    rng_t      rng = {};</span>
<a href="#l42.91"></a><span id="l42.91" class="difflineminus">-    uint8_t    keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l42.92"></a><span id="l42.92" class="difflineplus">+    pgp_hash_t   hash = {};</span>
<a href="#l42.93"></a><span id="l42.93" class="difflineplus">+    pgp_hash_t   hashcp = {};</span>
<a href="#l42.94"></a><span id="l42.94" class="difflineplus">+    rng_t        rng = {};</span>
<a href="#l42.95"></a><span id="l42.95" class="difflineplus">+    pgp_key_id_t keyid;</span>
<a href="#l42.96"></a><span id="l42.96"> </span>
<a href="#l42.97"></a><span id="l42.97" class="difflineminus">-    if (pgp_keyid(keyid, sizeof(keyid), key)) {</span>
<a href="#l42.98"></a><span id="l42.98" class="difflineplus">+    if (pgp_keyid(keyid, key)) {</span>
<a href="#l42.99"></a><span id="l42.99">         RNP_LOG(&quot;failed to calculate keyid&quot;);</span>
<a href="#l42.100"></a><span id="l42.100">         return false;</span>
<a href="#l42.101"></a><span id="l42.101">     }</span>
<a href="#l42.102"></a><span id="l42.102"> </span>
<a href="#l42.103"></a><span id="l42.103">     if (!rng_init(&amp;rng, RNG_SYSTEM)) {</span>
<a href="#l42.104"></a><span id="l42.104">         RNP_LOG(&quot;RNG init failed&quot;);</span>
<a href="#l42.105"></a><span id="l42.105">         return false;</span>
<a href="#l42.106"></a><span id="l42.106">     }</span>
<a href="#l42.107"></a><span id="l42.107" class="difflineat">@@ -617,31 +617,31 @@ transferable_subkey_bind(const pgp_key_p</span>
<a href="#l42.108"></a><span id="l42.108">                          const rnp_selfsig_binding_info_t *binding)</span>
<a href="#l42.109"></a><span id="l42.109"> {</span>
<a href="#l42.110"></a><span id="l42.110">     if (!key || !subkey || !binding) {</span>
<a href="#l42.111"></a><span id="l42.111">         RNP_LOG(&quot;invalid parameters&quot;);</span>
<a href="#l42.112"></a><span id="l42.112">         return NULL;</span>
<a href="#l42.113"></a><span id="l42.113">     }</span>
<a href="#l42.114"></a><span id="l42.114"> </span>
<a href="#l42.115"></a><span id="l42.115">     pgp_fingerprint_t keyfp;</span>
<a href="#l42.116"></a><span id="l42.116" class="difflineminus">-    if (pgp_fingerprint(&amp;keyfp, key)) {</span>
<a href="#l42.117"></a><span id="l42.117" class="difflineplus">+    if (pgp_fingerprint(keyfp, key)) {</span>
<a href="#l42.118"></a><span id="l42.118">         RNP_LOG(&quot;failed to calculate keyfp&quot;);</span>
<a href="#l42.119"></a><span id="l42.119">         return NULL;</span>
<a href="#l42.120"></a><span id="l42.120">     }</span>
<a href="#l42.121"></a><span id="l42.121"> </span>
<a href="#l42.122"></a><span id="l42.122">     pgp_signature_t  sig = {};</span>
<a href="#l42.123"></a><span id="l42.123">     pgp_signature_t *res = NULL;</span>
<a href="#l42.124"></a><span id="l42.124">     pgp_key_flags_t  realkf = (pgp_key_flags_t) 0;</span>
<a href="#l42.125"></a><span id="l42.125"> </span>
<a href="#l42.126"></a><span id="l42.126">     sig.version = PGP_V4;</span>
<a href="#l42.127"></a><span id="l42.127">     sig.halg = pgp_hash_adjust_alg_to_key(hash_alg, key);</span>
<a href="#l42.128"></a><span id="l42.128">     sig.palg = key-&gt;alg;</span>
<a href="#l42.129"></a><span id="l42.129">     sig.type = PGP_SIG_SUBKEY;</span>
<a href="#l42.130"></a><span id="l42.130"> </span>
<a href="#l42.131"></a><span id="l42.131" class="difflineminus">-    if (!signature_set_keyfp(&amp;sig, &amp;keyfp)) {</span>
<a href="#l42.132"></a><span id="l42.132" class="difflineplus">+    if (!signature_set_keyfp(&amp;sig, keyfp)) {</span>
<a href="#l42.133"></a><span id="l42.133">         RNP_LOG(&quot;failed to set issuer fingerprint&quot;);</span>
<a href="#l42.134"></a><span id="l42.134">         goto end;</span>
<a href="#l42.135"></a><span id="l42.135">     }</span>
<a href="#l42.136"></a><span id="l42.136">     if (!signature_set_creation(&amp;sig, time(NULL))) {</span>
<a href="#l42.137"></a><span id="l42.137">         RNP_LOG(&quot;failed to set creation time&quot;);</span>
<a href="#l42.138"></a><span id="l42.138">         goto end;</span>
<a href="#l42.139"></a><span id="l42.139">     }</span>
<a href="#l42.140"></a><span id="l42.140">     if (binding-&gt;key_expiration &amp;&amp;</span>
<a href="#l42.141"></a><span id="l42.141" class="difflineat">@@ -674,43 +674,43 @@ end:</span>
<a href="#l42.142"></a><span id="l42.142"> pgp_signature_t *</span>
<a href="#l42.143"></a><span id="l42.143"> transferable_key_revoke(const pgp_key_pkt_t *key,</span>
<a href="#l42.144"></a><span id="l42.144">                         const pgp_key_pkt_t *signer,</span>
<a href="#l42.145"></a><span id="l42.145">                         pgp_hash_alg_t       hash_alg,</span>
<a href="#l42.146"></a><span id="l42.146">                         const pgp_revoke_t * revoke)</span>
<a href="#l42.147"></a><span id="l42.147"> {</span>
<a href="#l42.148"></a><span id="l42.148">     pgp_signature_t * sig = NULL;</span>
<a href="#l42.149"></a><span id="l42.149">     bool              res = false;</span>
<a href="#l42.150"></a><span id="l42.150" class="difflineminus">-    uint8_t           keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l42.151"></a><span id="l42.151" class="difflineplus">+    pgp_key_id_t      keyid;</span>
<a href="#l42.152"></a><span id="l42.152">     pgp_fingerprint_t keyfp;</span>
<a href="#l42.153"></a><span id="l42.153"> </span>
<a href="#l42.154"></a><span id="l42.154">     if (!key || !signer || !revoke) {</span>
<a href="#l42.155"></a><span id="l42.155">         RNP_LOG(&quot;invalid parameters&quot;);</span>
<a href="#l42.156"></a><span id="l42.156">         return NULL;</span>
<a href="#l42.157"></a><span id="l42.157">     }</span>
<a href="#l42.158"></a><span id="l42.158">     sig = (pgp_signature_t *) calloc(1, sizeof(*sig));</span>
<a href="#l42.159"></a><span id="l42.159">     if (!sig) {</span>
<a href="#l42.160"></a><span id="l42.160">         RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l42.161"></a><span id="l42.161">         goto end;</span>
<a href="#l42.162"></a><span id="l42.162">     }</span>
<a href="#l42.163"></a><span id="l42.163" class="difflineminus">-    if (pgp_keyid(keyid, sizeof(keyid), signer)) {</span>
<a href="#l42.164"></a><span id="l42.164" class="difflineplus">+    if (pgp_keyid(keyid, signer)) {</span>
<a href="#l42.165"></a><span id="l42.165">         RNP_LOG(&quot;failed to calculate keyid&quot;);</span>
<a href="#l42.166"></a><span id="l42.166">         goto end;</span>
<a href="#l42.167"></a><span id="l42.167">     }</span>
<a href="#l42.168"></a><span id="l42.168" class="difflineminus">-    if (pgp_fingerprint(&amp;keyfp, signer)) {</span>
<a href="#l42.169"></a><span id="l42.169" class="difflineplus">+    if (pgp_fingerprint(keyfp, signer)) {</span>
<a href="#l42.170"></a><span id="l42.170">         RNP_LOG(&quot;failed to calculate keyfp&quot;);</span>
<a href="#l42.171"></a><span id="l42.171">         goto end;</span>
<a href="#l42.172"></a><span id="l42.172">     }</span>
<a href="#l42.173"></a><span id="l42.173"> </span>
<a href="#l42.174"></a><span id="l42.174">     sig-&gt;version = PGP_V4;</span>
<a href="#l42.175"></a><span id="l42.175">     sig-&gt;halg = pgp_hash_adjust_alg_to_key(hash_alg, signer);</span>
<a href="#l42.176"></a><span id="l42.176">     sig-&gt;palg = signer-&gt;alg;</span>
<a href="#l42.177"></a><span id="l42.177">     sig-&gt;type = is_primary_key_pkt(key-&gt;tag) ? PGP_SIG_REV_KEY : PGP_SIG_REV_SUBKEY;</span>
<a href="#l42.178"></a><span id="l42.178"> </span>
<a href="#l42.179"></a><span id="l42.179" class="difflineminus">-    if (!signature_set_keyfp(sig, &amp;keyfp)) {</span>
<a href="#l42.180"></a><span id="l42.180" class="difflineplus">+    if (!signature_set_keyfp(sig, keyfp)) {</span>
<a href="#l42.181"></a><span id="l42.181">         RNP_LOG(&quot;failed to set issuer fingerprint&quot;);</span>
<a href="#l42.182"></a><span id="l42.182">         goto end;</span>
<a href="#l42.183"></a><span id="l42.183">     }</span>
<a href="#l42.184"></a><span id="l42.184">     if (!signature_set_creation(sig, time(NULL))) {</span>
<a href="#l42.185"></a><span id="l42.185">         RNP_LOG(&quot;failed to set creation time&quot;);</span>
<a href="#l42.186"></a><span id="l42.186">         goto end;</span>
<a href="#l42.187"></a><span id="l42.187">     }</span>
<a href="#l42.188"></a><span id="l42.188">     if (!signature_set_revocation_reason(sig, revoke-&gt;code, revoke-&gt;reason.c_str())) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-packet.cpp</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-packet.cpp</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineat">@@ -859,17 +859,17 @@ stream_write_pk_sesskey(pgp_pk_sesskey_t</span>
<a href="#l43.4"></a><span id="l43.4">     pgp_packet_body_t pktbody;</span>
<a href="#l43.5"></a><span id="l43.5">     bool              res;</span>
<a href="#l43.6"></a><span id="l43.6"> </span>
<a href="#l43.7"></a><span id="l43.7">     if (!init_packet_body(&amp;pktbody, PGP_PKT_PK_SESSION_KEY)) {</span>
<a href="#l43.8"></a><span id="l43.8">         return false;</span>
<a href="#l43.9"></a><span id="l43.9">     }</span>
<a href="#l43.10"></a><span id="l43.10"> </span>
<a href="#l43.11"></a><span id="l43.11">     res = add_packet_body_byte(&amp;pktbody, pkey-&gt;version) &amp;&amp;</span>
<a href="#l43.12"></a><span id="l43.12" class="difflineminus">-          add_packet_body(&amp;pktbody, pkey-&gt;key_id, sizeof(pkey-&gt;key_id)) &amp;&amp;</span>
<a href="#l43.13"></a><span id="l43.13" class="difflineplus">+          add_packet_body(&amp;pktbody, pkey-&gt;key_id.data(), pkey-&gt;key_id.size()) &amp;&amp;</span>
<a href="#l43.14"></a><span id="l43.14">           add_packet_body_byte(&amp;pktbody, pkey-&gt;alg);</span>
<a href="#l43.15"></a><span id="l43.15">     if (!res) {</span>
<a href="#l43.16"></a><span id="l43.16">         goto error;</span>
<a href="#l43.17"></a><span id="l43.17">     }</span>
<a href="#l43.18"></a><span id="l43.18"> </span>
<a href="#l43.19"></a><span id="l43.19">     switch (pkey-&gt;alg) {</span>
<a href="#l43.20"></a><span id="l43.20">     case PGP_PKA_RSA:</span>
<a href="#l43.21"></a><span id="l43.21">     case PGP_PKA_RSA_ENCRYPT_ONLY:</span>
<a href="#l43.22"></a><span id="l43.22" class="difflineat">@@ -909,17 +909,17 @@ stream_write_one_pass(pgp_one_pass_sig_t</span>
<a href="#l43.23"></a><span id="l43.23">     if (!init_packet_body(&amp;pktbody, PGP_PKT_ONE_PASS_SIG)) {</span>
<a href="#l43.24"></a><span id="l43.24">         return false;</span>
<a href="#l43.25"></a><span id="l43.25">     }</span>
<a href="#l43.26"></a><span id="l43.26"> </span>
<a href="#l43.27"></a><span id="l43.27">     res = add_packet_body_byte(&amp;pktbody, onepass-&gt;version) &amp;&amp;</span>
<a href="#l43.28"></a><span id="l43.28">           add_packet_body_byte(&amp;pktbody, onepass-&gt;type) &amp;&amp;</span>
<a href="#l43.29"></a><span id="l43.29">           add_packet_body_byte(&amp;pktbody, onepass-&gt;halg) &amp;&amp;</span>
<a href="#l43.30"></a><span id="l43.30">           add_packet_body_byte(&amp;pktbody, onepass-&gt;palg) &amp;&amp;</span>
<a href="#l43.31"></a><span id="l43.31" class="difflineminus">-          add_packet_body(&amp;pktbody, onepass-&gt;keyid, PGP_KEY_ID_SIZE) &amp;&amp;</span>
<a href="#l43.32"></a><span id="l43.32" class="difflineplus">+          add_packet_body(&amp;pktbody, onepass-&gt;keyid.data(), onepass-&gt;keyid.size()) &amp;&amp;</span>
<a href="#l43.33"></a><span id="l43.33">           add_packet_body_byte(&amp;pktbody, onepass-&gt;nested);</span>
<a href="#l43.34"></a><span id="l43.34"> </span>
<a href="#l43.35"></a><span id="l43.35">     if (res) {</span>
<a href="#l43.36"></a><span id="l43.36">         stream_flush_packet_body(&amp;pktbody, dst);</span>
<a href="#l43.37"></a><span id="l43.37">         return true;</span>
<a href="#l43.38"></a><span id="l43.38">     } else {</span>
<a href="#l43.39"></a><span id="l43.39">         free_packet_body(&amp;pktbody);</span>
<a href="#l43.40"></a><span id="l43.40">         return false;</span>
<a href="#l43.41"></a><span id="l43.41" class="difflineat">@@ -942,17 +942,17 @@ stream_write_signature(const pgp_signatu</span>
<a href="#l43.42"></a><span id="l43.42">         return false;</span>
<a href="#l43.43"></a><span id="l43.43">     }</span>
<a href="#l43.44"></a><span id="l43.44"> </span>
<a href="#l43.45"></a><span id="l43.45">     if (sig-&gt;version &lt; PGP_V4) {</span>
<a href="#l43.46"></a><span id="l43.46">         /* for v3 signatures hashed data includes only type + creation_time */</span>
<a href="#l43.47"></a><span id="l43.47">         res = add_packet_body_byte(&amp;pktbody, sig-&gt;version) &amp;&amp;</span>
<a href="#l43.48"></a><span id="l43.48">               add_packet_body_byte(&amp;pktbody, sig-&gt;hashed_len) &amp;&amp;</span>
<a href="#l43.49"></a><span id="l43.49">               add_packet_body(&amp;pktbody, sig-&gt;hashed_data, sig-&gt;hashed_len) &amp;&amp;</span>
<a href="#l43.50"></a><span id="l43.50" class="difflineminus">-              add_packet_body(&amp;pktbody, sig-&gt;signer, PGP_KEY_ID_SIZE) &amp;&amp;</span>
<a href="#l43.51"></a><span id="l43.51" class="difflineplus">+              add_packet_body(&amp;pktbody, sig-&gt;signer.data(), sig-&gt;signer.size()) &amp;&amp;</span>
<a href="#l43.52"></a><span id="l43.52">               add_packet_body_byte(&amp;pktbody, sig-&gt;palg) &amp;&amp;</span>
<a href="#l43.53"></a><span id="l43.53">               add_packet_body_byte(&amp;pktbody, sig-&gt;halg);</span>
<a href="#l43.54"></a><span id="l43.54">     } else {</span>
<a href="#l43.55"></a><span id="l43.55">         /* for v4 sig-&gt;hashed_data must contain most of signature fields */</span>
<a href="#l43.56"></a><span id="l43.56">         res = add_packet_body(&amp;pktbody, sig-&gt;hashed_data, sig-&gt;hashed_len) &amp;&amp;</span>
<a href="#l43.57"></a><span id="l43.57">               add_packet_body_subpackets(&amp;pktbody, sig, false);</span>
<a href="#l43.58"></a><span id="l43.58">     }</span>
<a href="#l43.59"></a><span id="l43.59"> </span>
<a href="#l43.60"></a><span id="l43.60" class="difflineat">@@ -1122,17 +1122,19 @@ stream_parse_pk_sesskey(pgp_source_t *sr</span>
<a href="#l43.61"></a><span id="l43.61">     /* version */</span>
<a href="#l43.62"></a><span id="l43.62">     if (!get_packet_body_byte(&amp;pkt, &amp;bt) || (bt != PGP_PKSK_V3)) {</span>
<a href="#l43.63"></a><span id="l43.63">         RNP_LOG(&quot;wrong packet version&quot;);</span>
<a href="#l43.64"></a><span id="l43.64">         goto finish;</span>
<a href="#l43.65"></a><span id="l43.65">     }</span>
<a href="#l43.66"></a><span id="l43.66">     pkey-&gt;version = bt;</span>
<a href="#l43.67"></a><span id="l43.67"> </span>
<a href="#l43.68"></a><span id="l43.68">     /* key id */</span>
<a href="#l43.69"></a><span id="l43.69" class="difflineminus">-    if (!get_packet_body_buf(&amp;pkt, pkey-&gt;key_id, PGP_KEY_ID_SIZE)) {</span>
<a href="#l43.70"></a><span id="l43.70" class="difflineplus">+    static_assert(std::tuple_size&lt;decltype(pkey-&gt;key_id)&gt;::value == PGP_KEY_ID_SIZE,</span>
<a href="#l43.71"></a><span id="l43.71" class="difflineplus">+                  &quot;pgp_key_id_t size mismatch&quot;);</span>
<a href="#l43.72"></a><span id="l43.72" class="difflineplus">+    if (!get_packet_body_buf(&amp;pkt, pkey-&gt;key_id.data(), PGP_KEY_ID_SIZE)) {</span>
<a href="#l43.73"></a><span id="l43.73">         RNP_LOG(&quot;failed to get key id&quot;);</span>
<a href="#l43.74"></a><span id="l43.74">         goto finish;</span>
<a href="#l43.75"></a><span id="l43.75">     }</span>
<a href="#l43.76"></a><span id="l43.76"> </span>
<a href="#l43.77"></a><span id="l43.77">     /* public key algorithm */</span>
<a href="#l43.78"></a><span id="l43.78">     if (!get_packet_body_byte(&amp;pkt, &amp;bt)) {</span>
<a href="#l43.79"></a><span id="l43.79">         RNP_LOG(&quot;failed to get palg&quot;);</span>
<a href="#l43.80"></a><span id="l43.80">         goto finish;</span>
<a href="#l43.81"></a><span id="l43.81" class="difflineat">@@ -1232,17 +1234,19 @@ stream_parse_one_pass(pgp_source_t *src,</span>
<a href="#l43.82"></a><span id="l43.82"> </span>
<a href="#l43.83"></a><span id="l43.83">     /* hash algorithm */</span>
<a href="#l43.84"></a><span id="l43.84">     onepass-&gt;halg = (pgp_hash_alg_t) buf[2];</span>
<a href="#l43.85"></a><span id="l43.85"> </span>
<a href="#l43.86"></a><span id="l43.86">     /* pk algorithm */</span>
<a href="#l43.87"></a><span id="l43.87">     onepass-&gt;palg = (pgp_pubkey_alg_t) buf[3];</span>
<a href="#l43.88"></a><span id="l43.88"> </span>
<a href="#l43.89"></a><span id="l43.89">     /* key id */</span>
<a href="#l43.90"></a><span id="l43.90" class="difflineminus">-    memcpy(onepass-&gt;keyid, &amp;buf[4], PGP_KEY_ID_SIZE);</span>
<a href="#l43.91"></a><span id="l43.91" class="difflineplus">+    static_assert(std::tuple_size&lt;decltype(onepass-&gt;keyid)&gt;::value == PGP_KEY_ID_SIZE,</span>
<a href="#l43.92"></a><span id="l43.92" class="difflineplus">+                  &quot;pgp_one_pass_sig_t.keyid size mismatch&quot;);</span>
<a href="#l43.93"></a><span id="l43.93" class="difflineplus">+    memcpy(onepass-&gt;keyid.data(), &amp;buf[4], PGP_KEY_ID_SIZE);</span>
<a href="#l43.94"></a><span id="l43.94"> </span>
<a href="#l43.95"></a><span id="l43.95">     /* nested flag */</span>
<a href="#l43.96"></a><span id="l43.96">     onepass-&gt;nested = !!buf[12];</span>
<a href="#l43.97"></a><span id="l43.97"> </span>
<a href="#l43.98"></a><span id="l43.98">     res = RNP_SUCCESS;</span>
<a href="#l43.99"></a><span id="l43.99"> finish:</span>
<a href="#l43.100"></a><span id="l43.100">     free_packet_body(&amp;pkt);</span>
<a href="#l43.101"></a><span id="l43.101">     return res;</span>
<a href="#l43.102"></a><span id="l43.102" class="difflineat">@@ -1275,17 +1279,19 @@ signature_read_v3(pgp_packet_body_t *pkt</span>
<a href="#l43.103"></a><span id="l43.103"> </span>
<a href="#l43.104"></a><span id="l43.104">     /* signature type */</span>
<a href="#l43.105"></a><span id="l43.105">     sig-&gt;type = (pgp_sig_type_t) buf[1];</span>
<a href="#l43.106"></a><span id="l43.106"> </span>
<a href="#l43.107"></a><span id="l43.107">     /* creation time */</span>
<a href="#l43.108"></a><span id="l43.108">     sig-&gt;creation_time = read_uint32(&amp;buf[2]);</span>
<a href="#l43.109"></a><span id="l43.109"> </span>
<a href="#l43.110"></a><span id="l43.110">     /* signer's key id */</span>
<a href="#l43.111"></a><span id="l43.111" class="difflineminus">-    memcpy(sig-&gt;signer, &amp;buf[6], PGP_KEY_ID_SIZE);</span>
<a href="#l43.112"></a><span id="l43.112" class="difflineplus">+    static_assert(std::tuple_size&lt;decltype(sig-&gt;signer)&gt;::value == PGP_KEY_ID_SIZE,</span>
<a href="#l43.113"></a><span id="l43.113" class="difflineplus">+                  &quot;v3 signer field size mismatch&quot;);</span>
<a href="#l43.114"></a><span id="l43.114" class="difflineplus">+    memcpy(sig-&gt;signer.data(), &amp;buf[6], PGP_KEY_ID_SIZE);</span>
<a href="#l43.115"></a><span id="l43.115"> </span>
<a href="#l43.116"></a><span id="l43.116">     /* public key algorithm */</span>
<a href="#l43.117"></a><span id="l43.117">     sig-&gt;palg = (pgp_pubkey_alg_t) buf[14];</span>
<a href="#l43.118"></a><span id="l43.118"> </span>
<a href="#l43.119"></a><span id="l43.119">     /* hash algorithm */</span>
<a href="#l43.120"></a><span id="l43.120">     sig-&gt;halg = (pgp_hash_alg_t) buf[15];</span>
<a href="#l43.121"></a><span id="l43.121"> </span>
<a href="#l43.122"></a><span id="l43.122">     return RNP_SUCCESS;</span>
<a href="#l43.123"></a><span id="l43.123" class="difflineat">@@ -1731,26 +1737,35 @@ stream_parse_signature(pgp_source_t *src</span>
<a href="#l43.124"></a><span id="l43.124"> </span>
<a href="#l43.125"></a><span id="l43.125"> bool</span>
<a href="#l43.126"></a><span id="l43.126"> copy_signature_packet(pgp_signature_t *dst, const pgp_signature_t *src)</span>
<a href="#l43.127"></a><span id="l43.127"> {</span>
<a href="#l43.128"></a><span id="l43.128">     if (!src) {</span>
<a href="#l43.129"></a><span id="l43.129">         return false;</span>
<a href="#l43.130"></a><span id="l43.130">     }</span>
<a href="#l43.131"></a><span id="l43.131"> </span>
<a href="#l43.132"></a><span id="l43.132" class="difflineminus">-    memcpy(dst, src, sizeof(*src));</span>
<a href="#l43.133"></a><span id="l43.133" class="difflineplus">+    dst-&gt;version = src-&gt;version;</span>
<a href="#l43.134"></a><span id="l43.134" class="difflineplus">+    dst-&gt;type = src-&gt;type;</span>
<a href="#l43.135"></a><span id="l43.135" class="difflineplus">+    dst-&gt;palg = src-&gt;palg;</span>
<a href="#l43.136"></a><span id="l43.136" class="difflineplus">+    dst-&gt;halg = src-&gt;halg;</span>
<a href="#l43.137"></a><span id="l43.137" class="difflineplus">+    memcpy(dst-&gt;lbits, src-&gt;lbits, sizeof(src-&gt;lbits));</span>
<a href="#l43.138"></a><span id="l43.138" class="difflineplus">+    dst-&gt;creation_time = src-&gt;creation_time;</span>
<a href="#l43.139"></a><span id="l43.139" class="difflineplus">+    dst-&gt;signer = src-&gt;signer;</span>
<a href="#l43.140"></a><span id="l43.140" class="difflineplus">+    dst-&gt;material = src-&gt;material;</span>
<a href="#l43.141"></a><span id="l43.141" class="difflineplus">+</span>
<a href="#l43.142"></a><span id="l43.142" class="difflineplus">+    dst-&gt;hashed_len = src-&gt;hashed_len;</span>
<a href="#l43.143"></a><span id="l43.143">     dst-&gt;hashed_data = NULL;</span>
<a href="#l43.144"></a><span id="l43.144" class="difflineminus">-    dst-&gt;subpkts = NULL;</span>
<a href="#l43.145"></a><span id="l43.145">     if (src-&gt;hashed_data) {</span>
<a href="#l43.146"></a><span id="l43.146" class="difflineminus">-        if (!(dst-&gt;hashed_data = (uint8_t *) malloc(dst-&gt;hashed_len))) {</span>
<a href="#l43.147"></a><span id="l43.147" class="difflineplus">+        if (!(dst-&gt;hashed_data = (uint8_t *) malloc(src-&gt;hashed_len))) {</span>
<a href="#l43.148"></a><span id="l43.148">             return false;</span>
<a href="#l43.149"></a><span id="l43.149">         }</span>
<a href="#l43.150"></a><span id="l43.150" class="difflineminus">-        memcpy(dst-&gt;hashed_data, src-&gt;hashed_data, dst-&gt;hashed_len);</span>
<a href="#l43.151"></a><span id="l43.151" class="difflineplus">+        memcpy(dst-&gt;hashed_data, src-&gt;hashed_data, src-&gt;hashed_len);</span>
<a href="#l43.152"></a><span id="l43.152">     }</span>
<a href="#l43.153"></a><span id="l43.153"> </span>
<a href="#l43.154"></a><span id="l43.154" class="difflineplus">+    dst-&gt;subpkts = NULL;</span>
<a href="#l43.155"></a><span id="l43.155">     for (list_item *sp = list_front(src-&gt;subpkts); sp; sp = list_next(sp)) {</span>
<a href="#l43.156"></a><span id="l43.156">         pgp_sig_subpkt_t *dstsp;</span>
<a href="#l43.157"></a><span id="l43.157">         pgp_sig_subpkt_t *srcsp = (pgp_sig_subpkt_t *) sp;</span>
<a href="#l43.158"></a><span id="l43.158">         /* subpacket may have internal pointers to the subpkt-&gt;data ! */</span>
<a href="#l43.159"></a><span id="l43.159">         dstsp = (pgp_sig_subpkt_t *) list_append(&amp;dst-&gt;subpkts, srcsp, sizeof(*dstsp));</span>
<a href="#l43.160"></a><span id="l43.160">         if (!dstsp) {</span>
<a href="#l43.161"></a><span id="l43.161">             free_signature(dst);</span>
<a href="#l43.162"></a><span id="l43.162">             return false;</span>
<a href="#l43.163"></a><span id="l43.163" class="difflineat">@@ -1817,16 +1832,17 @@ free_signature_subpkt(pgp_sig_subpkt_t *</span>
<a href="#l43.164"></a><span id="l43.164"> void</span>
<a href="#l43.165"></a><span id="l43.165"> free_signature(pgp_signature_t *sig)</span>
<a href="#l43.166"></a><span id="l43.166"> {</span>
<a href="#l43.167"></a><span id="l43.167">     free(sig-&gt;hashed_data);</span>
<a href="#l43.168"></a><span id="l43.168">     for (list_item *sp = list_front(sig-&gt;subpkts); sp; sp = list_next(sp)) {</span>
<a href="#l43.169"></a><span id="l43.169">         free_signature_subpkt((pgp_sig_subpkt_t *) sp);</span>
<a href="#l43.170"></a><span id="l43.170">     }</span>
<a href="#l43.171"></a><span id="l43.171">     list_destroy(&amp;sig-&gt;subpkts);</span>
<a href="#l43.172"></a><span id="l43.172" class="difflineplus">+    sig-&gt;signer.~array();</span>
<a href="#l43.173"></a><span id="l43.173"> }</span>
<a href="#l43.174"></a><span id="l43.174"> </span>
<a href="#l43.175"></a><span id="l43.175"> bool</span>
<a href="#l43.176"></a><span id="l43.176"> is_key_pkt(int tag)</span>
<a href="#l43.177"></a><span id="l43.177"> {</span>
<a href="#l43.178"></a><span id="l43.178">     switch (tag) {</span>
<a href="#l43.179"></a><span id="l43.179">     case PGP_PKT_PUBLIC_KEY:</span>
<a href="#l43.180"></a><span id="l43.180">     case PGP_PKT_PUBLIC_SUBKEY:</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-parse.cpp</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-parse.cpp</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineat">@@ -40,39 +40,40 @@</span>
<a href="#l44.4"></a><span id="l44.4"> #include &quot;stream-packet.h&quot;</span>
<a href="#l44.5"></a><span id="l44.5"> #include &quot;stream-sig.h&quot;</span>
<a href="#l44.6"></a><span id="l44.6"> #include &quot;types.h&quot;</span>
<a href="#l44.7"></a><span id="l44.7"> #include &quot;crypto/s2k.h&quot;</span>
<a href="#l44.8"></a><span id="l44.8"> #include &quot;crypto.h&quot;</span>
<a href="#l44.9"></a><span id="l44.9"> #include &quot;crypto/signatures.h&quot;</span>
<a href="#l44.10"></a><span id="l44.10"> #include &quot;fingerprint.h&quot;</span>
<a href="#l44.11"></a><span id="l44.11"> #include &quot;pgp-key.h&quot;</span>
<a href="#l44.12"></a><span id="l44.12" class="difflineminus">-#include &quot;list.h&quot;</span>
<a href="#l44.13"></a><span id="l44.13"> </span>
<a href="#l44.14"></a><span id="l44.14"> #ifdef HAVE_ZLIB_H</span>
<a href="#l44.15"></a><span id="l44.15"> #include &lt;zlib.h&gt;</span>
<a href="#l44.16"></a><span id="l44.16"> #endif</span>
<a href="#l44.17"></a><span id="l44.17"> #ifdef HAVE_BZLIB_H</span>
<a href="#l44.18"></a><span id="l44.18"> #include &lt;bzlib.h&gt;</span>
<a href="#l44.19"></a><span id="l44.19"> #endif</span>
<a href="#l44.20"></a><span id="l44.20"> </span>
<a href="#l44.21"></a><span id="l44.21"> typedef enum pgp_message_t {</span>
<a href="#l44.22"></a><span id="l44.22">     PGP_MESSAGE_UNKNOWN = 0,</span>
<a href="#l44.23"></a><span id="l44.23">     PGP_MESSAGE_NORMAL,</span>
<a href="#l44.24"></a><span id="l44.24">     PGP_MESSAGE_DETACHED,</span>
<a href="#l44.25"></a><span id="l44.25">     PGP_MESSAGE_CLEARTEXT</span>
<a href="#l44.26"></a><span id="l44.26"> } pgp_message_t;</span>
<a href="#l44.27"></a><span id="l44.27"> </span>
<a href="#l44.28"></a><span id="l44.28"> typedef struct pgp_processing_ctx_t {</span>
<a href="#l44.29"></a><span id="l44.29" class="difflineminus">-    pgp_parse_handler_t handler;</span>
<a href="#l44.30"></a><span id="l44.30" class="difflineminus">-    pgp_source_t *      signed_src;</span>
<a href="#l44.31"></a><span id="l44.31" class="difflineminus">-    pgp_source_t *      literal_src;</span>
<a href="#l44.32"></a><span id="l44.32" class="difflineminus">-    pgp_message_t       msg_type;</span>
<a href="#l44.33"></a><span id="l44.33" class="difflineminus">-    pgp_dest_t          output;</span>
<a href="#l44.34"></a><span id="l44.34" class="difflineminus">-    list                sources;</span>
<a href="#l44.35"></a><span id="l44.35" class="difflineplus">+    pgp_parse_handler_t     handler;</span>
<a href="#l44.36"></a><span id="l44.36" class="difflineplus">+    pgp_source_t *          signed_src;</span>
<a href="#l44.37"></a><span id="l44.37" class="difflineplus">+    pgp_source_t *          literal_src;</span>
<a href="#l44.38"></a><span id="l44.38" class="difflineplus">+    pgp_message_t           msg_type;</span>
<a href="#l44.39"></a><span id="l44.39" class="difflineplus">+    pgp_dest_t              output;</span>
<a href="#l44.40"></a><span id="l44.40" class="difflineplus">+    std::list&lt;pgp_source_t&gt; sources;</span>
<a href="#l44.41"></a><span id="l44.41" class="difflineplus">+</span>
<a href="#l44.42"></a><span id="l44.42" class="difflineplus">+    ~pgp_processing_ctx_t();</span>
<a href="#l44.43"></a><span id="l44.43"> } pgp_processing_ctx_t;</span>
<a href="#l44.44"></a><span id="l44.44"> </span>
<a href="#l44.45"></a><span id="l44.45"> /* common fields for encrypted, compressed and literal data */</span>
<a href="#l44.46"></a><span id="l44.46"> typedef struct pgp_source_packet_param_t {</span>
<a href="#l44.47"></a><span id="l44.47">     pgp_source_t *readsrc;                  /* source to read from, could be partial*/</span>
<a href="#l44.48"></a><span id="l44.48">     pgp_source_t *origsrc;                  /* original source passed to init_*_src */</span>
<a href="#l44.49"></a><span id="l44.49">     bool          partial;                  /* partial length packet */</span>
<a href="#l44.50"></a><span id="l44.50">     bool          indeterminate;            /* indeterminate length packet */</span>
<a href="#l44.51"></a><span id="l44.51" class="difflineat">@@ -110,20 +111,24 @@ typedef struct pgp_source_signed_param_t</span>
<a href="#l44.52"></a><span id="l44.52">     bool                 detached;        /* detached signature */</span>
<a href="#l44.53"></a><span id="l44.53">     bool                 cleartext;       /* source is cleartext signed */</span>
<a href="#l44.54"></a><span id="l44.54">     bool                 clr_eod;         /* cleartext data is over */</span>
<a href="#l44.55"></a><span id="l44.55">     bool                 clr_fline;       /* first line of the cleartext */</span>
<a href="#l44.56"></a><span id="l44.56">     bool                 clr_mline;       /* in the middle of the very long line */</span>
<a href="#l44.57"></a><span id="l44.57">     uint8_t              out[CT_BUF_LEN]; /* cleartext output cache for easier parsing */</span>
<a href="#l44.58"></a><span id="l44.58">     size_t               outlen;          /* total bytes in out */</span>
<a href="#l44.59"></a><span id="l44.59">     size_t               outpos;          /* offset of first available byte in out */</span>
<a href="#l44.60"></a><span id="l44.60" class="difflineminus">-    list                 onepasses;       /* list of one-pass singatures */</span>
<a href="#l44.61"></a><span id="l44.61" class="difflineminus">-    list                 sigs;            /* list of signatures */</span>
<a href="#l44.62"></a><span id="l44.62" class="difflineminus">-    list                 hashes;          /* hash contexts */</span>
<a href="#l44.63"></a><span id="l44.63" class="difflineminus">-    list                 siginfos;        /* signature validation info */</span>
<a href="#l44.64"></a><span id="l44.64" class="difflineplus">+</span>
<a href="#l44.65"></a><span id="l44.65" class="difflineplus">+    std::vector&lt;pgp_one_pass_sig_t&gt;   onepasses; /* list of one-pass singatures */</span>
<a href="#l44.66"></a><span id="l44.66" class="difflineplus">+    std::list&lt;pgp_signature_t&gt;        sigs;      /* list of signatures */</span>
<a href="#l44.67"></a><span id="l44.67" class="difflineplus">+    std::vector&lt;pgp_signature_info_t&gt; siginfos;  /* signature validation info */</span>
<a href="#l44.68"></a><span id="l44.68" class="difflineplus">+    std::vector&lt;pgp_hash_t&gt;           hashes;    /* hash contexts */</span>
<a href="#l44.69"></a><span id="l44.69" class="difflineplus">+</span>
<a href="#l44.70"></a><span id="l44.70" class="difflineplus">+    pgp_source_signed_param_t() = default;</span>
<a href="#l44.71"></a><span id="l44.71" class="difflineplus">+    ~pgp_source_signed_param_t();</span>
<a href="#l44.72"></a><span id="l44.72"> } pgp_source_signed_param_t;</span>
<a href="#l44.73"></a><span id="l44.73"> </span>
<a href="#l44.74"></a><span id="l44.74"> typedef struct pgp_source_compressed_param_t {</span>
<a href="#l44.75"></a><span id="l44.75">     pgp_source_packet_param_t pkt; /* underlying packet-related params */</span>
<a href="#l44.76"></a><span id="l44.76">     pgp_compression_type_t    alg;</span>
<a href="#l44.77"></a><span id="l44.77">     union {</span>
<a href="#l44.78"></a><span id="l44.78">         z_stream  z;</span>
<a href="#l44.79"></a><span id="l44.79">         bz_stream bz;</span>
<a href="#l44.80"></a><span id="l44.80" class="difflineat">@@ -143,20 +148,20 @@ typedef struct pgp_source_partial_param_</span>
<a href="#l44.81"></a><span id="l44.81">     pgp_source_t *readsrc; /* source to read from */</span>
<a href="#l44.82"></a><span id="l44.82">     int           type;    /* type of the packet */</span>
<a href="#l44.83"></a><span id="l44.83">     size_t        psize;   /* size of the current part */</span>
<a href="#l44.84"></a><span id="l44.84">     size_t        pleft;   /* bytes left to read from the current part */</span>
<a href="#l44.85"></a><span id="l44.85">     bool          last;    /* current part is last */</span>
<a href="#l44.86"></a><span id="l44.86"> } pgp_source_partial_param_t;</span>
<a href="#l44.87"></a><span id="l44.87"> </span>
<a href="#l44.88"></a><span id="l44.88"> static bool</span>
<a href="#l44.89"></a><span id="l44.89" class="difflineminus">-is_pgp_source(pgp_source_t *src)</span>
<a href="#l44.90"></a><span id="l44.90" class="difflineplus">+is_pgp_source(pgp_source_t &amp;src)</span>
<a href="#l44.91"></a><span id="l44.91"> {</span>
<a href="#l44.92"></a><span id="l44.92">     uint8_t buf;</span>
<a href="#l44.93"></a><span id="l44.93" class="difflineminus">-    if (!src_peek_eq(src, &amp;buf, 1)) {</span>
<a href="#l44.94"></a><span id="l44.94" class="difflineplus">+    if (!src_peek_eq(&amp;src, &amp;buf, 1)) {</span>
<a href="#l44.95"></a><span id="l44.95">         return false;</span>
<a href="#l44.96"></a><span id="l44.96">     }</span>
<a href="#l44.97"></a><span id="l44.97"> </span>
<a href="#l44.98"></a><span id="l44.98">     switch (get_packet_type(buf)) {</span>
<a href="#l44.99"></a><span id="l44.99">     case PGP_PKT_PK_SESSION_KEY:</span>
<a href="#l44.100"></a><span id="l44.100">     case PGP_PKT_SK_SESSION_KEY:</span>
<a href="#l44.101"></a><span id="l44.101">     case PGP_PKT_ONE_PASS_SIG:</span>
<a href="#l44.102"></a><span id="l44.102">     case PGP_PKT_SIGNATURE:</span>
<a href="#l44.103"></a><span id="l44.103" class="difflineat">@@ -713,34 +718,29 @@ encrypted_src_finish(pgp_source_t *src)</span>
<a href="#l44.104"></a><span id="l44.104"> </span>
<a href="#l44.105"></a><span id="l44.105"> static void</span>
<a href="#l44.106"></a><span id="l44.106"> encrypted_src_close(pgp_source_t *src)</span>
<a href="#l44.107"></a><span id="l44.107"> {</span>
<a href="#l44.108"></a><span id="l44.108">     pgp_source_encrypted_param_t *param = (pgp_source_encrypted_param_t *) src-&gt;param;</span>
<a href="#l44.109"></a><span id="l44.109">     if (!param) {</span>
<a href="#l44.110"></a><span id="l44.110">         return;</span>
<a href="#l44.111"></a><span id="l44.111">     }</span>
<a href="#l44.112"></a><span id="l44.112" class="difflineminus">-</span>
<a href="#l44.113"></a><span id="l44.113" class="difflineminus">-    /* to be removed once pgp_source_t is migrated to C++ */</span>
<a href="#l44.114"></a><span id="l44.114" class="difflineminus">-    param-&gt;symencs.~vector();</span>
<a href="#l44.115"></a><span id="l44.115" class="difflineminus">-    param-&gt;pubencs.~vector();</span>
<a href="#l44.116"></a><span id="l44.116" class="difflineminus">-</span>
<a href="#l44.117"></a><span id="l44.117">     if (param-&gt;pkt.partial) {</span>
<a href="#l44.118"></a><span id="l44.118">         src_close(param-&gt;pkt.readsrc);</span>
<a href="#l44.119"></a><span id="l44.119">         free(param-&gt;pkt.readsrc);</span>
<a href="#l44.120"></a><span id="l44.120">         param-&gt;pkt.readsrc = NULL;</span>
<a href="#l44.121"></a><span id="l44.121">     }</span>
<a href="#l44.122"></a><span id="l44.122"> </span>
<a href="#l44.123"></a><span id="l44.123">     if (param-&gt;aead) {</span>
<a href="#l44.124"></a><span id="l44.124">         pgp_cipher_aead_destroy(&amp;param-&gt;decrypt);</span>
<a href="#l44.125"></a><span id="l44.125">     } else {</span>
<a href="#l44.126"></a><span id="l44.126">         pgp_cipher_cfb_finish(&amp;param-&gt;decrypt);</span>
<a href="#l44.127"></a><span id="l44.127">     }</span>
<a href="#l44.128"></a><span id="l44.128"> </span>
<a href="#l44.129"></a><span id="l44.129" class="difflineminus">-    free(src-&gt;param);</span>
<a href="#l44.130"></a><span id="l44.130" class="difflineplus">+    delete param;</span>
<a href="#l44.131"></a><span id="l44.131">     src-&gt;param = NULL;</span>
<a href="#l44.132"></a><span id="l44.132"> }</span>
<a href="#l44.133"></a><span id="l44.133"> </span>
<a href="#l44.134"></a><span id="l44.134"> static void</span>
<a href="#l44.135"></a><span id="l44.135"> signed_validate_signature(pgp_source_signed_param_t *param, pgp_signature_info_t *sinfo)</span>
<a href="#l44.136"></a><span id="l44.136"> {</span>
<a href="#l44.137"></a><span id="l44.137">     pgp_hash_t shash = {};</span>
<a href="#l44.138"></a><span id="l44.138"> </span>
<a href="#l44.139"></a><span id="l44.139" class="difflineat">@@ -771,78 +771,71 @@ signed_src_read(pgp_source_t *src, void </span>
<a href="#l44.140"></a><span id="l44.140">     }</span>
<a href="#l44.141"></a><span id="l44.141">     return src_read(param-&gt;readsrc, buf, len, read);</span>
<a href="#l44.142"></a><span id="l44.142"> }</span>
<a href="#l44.143"></a><span id="l44.143"> </span>
<a href="#l44.144"></a><span id="l44.144"> static void</span>
<a href="#l44.145"></a><span id="l44.145"> signed_src_close(pgp_source_t *src)</span>
<a href="#l44.146"></a><span id="l44.146"> {</span>
<a href="#l44.147"></a><span id="l44.147">     pgp_source_signed_param_t *param = (pgp_source_signed_param_t *) src-&gt;param;</span>
<a href="#l44.148"></a><span id="l44.148" class="difflineminus">-</span>
<a href="#l44.149"></a><span id="l44.149">     if (!param) {</span>
<a href="#l44.150"></a><span id="l44.150">         return;</span>
<a href="#l44.151"></a><span id="l44.151">     }</span>
<a href="#l44.152"></a><span id="l44.152" class="difflineminus">-</span>
<a href="#l44.153"></a><span id="l44.153" class="difflineminus">-    list_destroy(&amp;param-&gt;onepasses);</span>
<a href="#l44.154"></a><span id="l44.154" class="difflineminus">-    pgp_hash_list_free(&amp;param-&gt;hashes);</span>
<a href="#l44.155"></a><span id="l44.155" class="difflineminus">-    list_destroy(&amp;param-&gt;siginfos);</span>
<a href="#l44.156"></a><span id="l44.156" class="difflineminus">-    for (list_item *sig = list_front(param-&gt;sigs); sig; sig = list_next(sig)) {</span>
<a href="#l44.157"></a><span id="l44.157" class="difflineminus">-        free_signature((pgp_signature_t *) sig);</span>
<a href="#l44.158"></a><span id="l44.158" class="difflineminus">-    }</span>
<a href="#l44.159"></a><span id="l44.159" class="difflineminus">-    list_destroy(&amp;param-&gt;sigs);</span>
<a href="#l44.160"></a><span id="l44.160" class="difflineminus">-    free(src-&gt;param);</span>
<a href="#l44.161"></a><span id="l44.161" class="difflineplus">+    delete param;</span>
<a href="#l44.162"></a><span id="l44.162">     src-&gt;param = NULL;</span>
<a href="#l44.163"></a><span id="l44.163"> }</span>
<a href="#l44.164"></a><span id="l44.164"> </span>
<a href="#l44.165"></a><span id="l44.165"> static rnp_result_t</span>
<a href="#l44.166"></a><span id="l44.166"> signed_read_single_signature(pgp_source_signed_param_t *param,</span>
<a href="#l44.167"></a><span id="l44.167">                              pgp_source_t *             readsrc,</span>
<a href="#l44.168"></a><span id="l44.168">                              pgp_signature_t **         sig)</span>
<a href="#l44.169"></a><span id="l44.169"> {</span>
<a href="#l44.170"></a><span id="l44.170">     uint8_t               ptag;</span>
<a href="#l44.171"></a><span id="l44.171">     int                   ptype;</span>
<a href="#l44.172"></a><span id="l44.172">     pgp_signature_t       readsig;</span>
<a href="#l44.173"></a><span id="l44.173" class="difflineminus">-    pgp_signature_t *     newsig;</span>
<a href="#l44.174"></a><span id="l44.174">     pgp_signature_info_t *siginfo;</span>
<a href="#l44.175"></a><span id="l44.175"> </span>
<a href="#l44.176"></a><span id="l44.176">     if (!src_peek_eq(readsrc, &amp;ptag, 1)) {</span>
<a href="#l44.177"></a><span id="l44.177">         RNP_LOG(&quot;failed to read signature packet header&quot;);</span>
<a href="#l44.178"></a><span id="l44.178">         return RNP_ERROR_READ;</span>
<a href="#l44.179"></a><span id="l44.179">     }</span>
<a href="#l44.180"></a><span id="l44.180"> </span>
<a href="#l44.181"></a><span id="l44.181">     ptype = get_packet_type(ptag);</span>
<a href="#l44.182"></a><span id="l44.182"> </span>
<a href="#l44.183"></a><span id="l44.183">     if (ptype != PGP_PKT_SIGNATURE) {</span>
<a href="#l44.184"></a><span id="l44.184">         RNP_LOG(&quot;unexpected packet %d&quot;, ptype);</span>
<a href="#l44.185"></a><span id="l44.185">         return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.186"></a><span id="l44.186">     }</span>
<a href="#l44.187"></a><span id="l44.187"> </span>
<a href="#l44.188"></a><span id="l44.188" class="difflineminus">-    siginfo = (pgp_signature_info_t *) list_append(&amp;param-&gt;siginfos, NULL, sizeof(*siginfo));</span>
<a href="#l44.189"></a><span id="l44.189" class="difflineminus">-    if (!siginfo) {</span>
<a href="#l44.190"></a><span id="l44.190" class="difflineminus">-        RNP_LOG(&quot;siginfo allocation failed&quot;);</span>
<a href="#l44.191"></a><span id="l44.191" class="difflineplus">+    try {</span>
<a href="#l44.192"></a><span id="l44.192" class="difflineplus">+        param-&gt;siginfos.push_back({});</span>
<a href="#l44.193"></a><span id="l44.193" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l44.194"></a><span id="l44.194" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.195"></a><span id="l44.195">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.196"></a><span id="l44.196">     }</span>
<a href="#l44.197"></a><span id="l44.197" class="difflineplus">+    siginfo = &amp;param-&gt;siginfos.back();</span>
<a href="#l44.198"></a><span id="l44.198"> </span>
<a href="#l44.199"></a><span id="l44.199">     if (stream_parse_signature(readsrc, &amp;readsig) != RNP_SUCCESS) {</span>
<a href="#l44.200"></a><span id="l44.200">         RNP_LOG(&quot;failed to parse signature&quot;);</span>
<a href="#l44.201"></a><span id="l44.201">         siginfo-&gt;unknown = true;</span>
<a href="#l44.202"></a><span id="l44.202">         if (sig) {</span>
<a href="#l44.203"></a><span id="l44.203">             *sig = NULL;</span>
<a href="#l44.204"></a><span id="l44.204">         }</span>
<a href="#l44.205"></a><span id="l44.205">         return RNP_SUCCESS;</span>
<a href="#l44.206"></a><span id="l44.206">     }</span>
<a href="#l44.207"></a><span id="l44.207"> </span>
<a href="#l44.208"></a><span id="l44.208" class="difflineminus">-    newsig = (pgp_signature_t *) list_append(&amp;param-&gt;sigs, &amp;readsig, sizeof(readsig));</span>
<a href="#l44.209"></a><span id="l44.209" class="difflineminus">-    if (!newsig) {</span>
<a href="#l44.210"></a><span id="l44.210" class="difflineminus">-        RNP_LOG(&quot;sig allocation failed&quot;);</span>
<a href="#l44.211"></a><span id="l44.211" class="difflineplus">+    try {</span>
<a href="#l44.212"></a><span id="l44.212" class="difflineplus">+        param-&gt;sigs.push_back(readsig);</span>
<a href="#l44.213"></a><span id="l44.213" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l44.214"></a><span id="l44.214" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.215"></a><span id="l44.215">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.216"></a><span id="l44.216">     }</span>
<a href="#l44.217"></a><span id="l44.217" class="difflineminus">-    siginfo-&gt;sig = newsig;</span>
<a href="#l44.218"></a><span id="l44.218" class="difflineplus">+    siginfo-&gt;sig = &amp;param-&gt;sigs.back();</span>
<a href="#l44.219"></a><span id="l44.219">     if (sig) {</span>
<a href="#l44.220"></a><span id="l44.220" class="difflineminus">-        *sig = newsig;</span>
<a href="#l44.221"></a><span id="l44.221" class="difflineplus">+        *sig = &amp;param-&gt;sigs.back();</span>
<a href="#l44.222"></a><span id="l44.222">     }</span>
<a href="#l44.223"></a><span id="l44.223">     return RNP_SUCCESS;</span>
<a href="#l44.224"></a><span id="l44.224"> }</span>
<a href="#l44.225"></a><span id="l44.225"> </span>
<a href="#l44.226"></a><span id="l44.226"> static rnp_result_t</span>
<a href="#l44.227"></a><span id="l44.227"> signed_read_cleartext_signatures(pgp_source_t *src)</span>
<a href="#l44.228"></a><span id="l44.228"> {</span>
<a href="#l44.229"></a><span id="l44.229">     pgp_source_t               armor = {0};</span>
<a href="#l44.230"></a><span id="l44.230" class="difflineat">@@ -869,37 +862,34 @@ finish:</span>
<a href="#l44.231"></a><span id="l44.231"> static rnp_result_t</span>
<a href="#l44.232"></a><span id="l44.232"> signed_read_signatures(pgp_source_t *src)</span>
<a href="#l44.233"></a><span id="l44.233"> {</span>
<a href="#l44.234"></a><span id="l44.234">     pgp_signature_t *          sig = NULL;</span>
<a href="#l44.235"></a><span id="l44.235">     rnp_result_t               ret;</span>
<a href="#l44.236"></a><span id="l44.236">     pgp_source_signed_param_t *param = (pgp_source_signed_param_t *) src-&gt;param;</span>
<a href="#l44.237"></a><span id="l44.237"> </span>
<a href="#l44.238"></a><span id="l44.238">     /* reading signatures */</span>
<a href="#l44.239"></a><span id="l44.239" class="difflineminus">-    for (list_item *op = list_back(param-&gt;onepasses); op; op = list_prev(op)) {</span>
<a href="#l44.240"></a><span id="l44.240" class="difflineplus">+    for (auto op = param-&gt;onepasses.rbegin(); op != param-&gt;onepasses.rend(); op++) {</span>
<a href="#l44.241"></a><span id="l44.241">         if ((ret = signed_read_single_signature(param, src, &amp;sig)) != RNP_SUCCESS) {</span>
<a href="#l44.242"></a><span id="l44.242">             return ret;</span>
<a href="#l44.243"></a><span id="l44.243">         }</span>
<a href="#l44.244"></a><span id="l44.244"> </span>
<a href="#l44.245"></a><span id="l44.245" class="difflineminus">-        if (!signature_matches_onepass(sig, (pgp_one_pass_sig_t *) op)) {</span>
<a href="#l44.246"></a><span id="l44.246" class="difflineplus">+        if (!signature_matches_onepass(sig, &amp;*op)) {</span>
<a href="#l44.247"></a><span id="l44.247">             RNP_LOG(&quot;signature doesn't match one-pass&quot;);</span>
<a href="#l44.248"></a><span id="l44.248">             return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.249"></a><span id="l44.249">         }</span>
<a href="#l44.250"></a><span id="l44.250">     }</span>
<a href="#l44.251"></a><span id="l44.251"> </span>
<a href="#l44.252"></a><span id="l44.252">     return RNP_SUCCESS;</span>
<a href="#l44.253"></a><span id="l44.253"> }</span>
<a href="#l44.254"></a><span id="l44.254"> </span>
<a href="#l44.255"></a><span id="l44.255"> static rnp_result_t</span>
<a href="#l44.256"></a><span id="l44.256"> signed_src_finish(pgp_source_t *src)</span>
<a href="#l44.257"></a><span id="l44.257"> {</span>
<a href="#l44.258"></a><span id="l44.258">     pgp_source_signed_param_t *param = (pgp_source_signed_param_t *) src-&gt;param;</span>
<a href="#l44.259"></a><span id="l44.259" class="difflineminus">-    pgp_signature_info_t *     sinfo = NULL;</span>
<a href="#l44.260"></a><span id="l44.260" class="difflineminus">-    pgp_signature_info_t *     sinfos = NULL;</span>
<a href="#l44.261"></a><span id="l44.261" class="difflineminus">-    unsigned                   sinfoc = 0;</span>
<a href="#l44.262"></a><span id="l44.262">     pgp_key_request_ctx_t      keyctx;</span>
<a href="#l44.263"></a><span id="l44.263">     pgp_key_t *                key = NULL;</span>
<a href="#l44.264"></a><span id="l44.264">     rnp_result_t               ret = RNP_ERROR_GENERIC;</span>
<a href="#l44.265"></a><span id="l44.265"> </span>
<a href="#l44.266"></a><span id="l44.266">     if (param-&gt;cleartext) {</span>
<a href="#l44.267"></a><span id="l44.267">         ret = signed_read_cleartext_signatures(src);</span>
<a href="#l44.268"></a><span id="l44.268">     } else {</span>
<a href="#l44.269"></a><span id="l44.269">         ret = signed_read_signatures(src);</span>
<a href="#l44.270"></a><span id="l44.270" class="difflineat">@@ -908,80 +898,68 @@ signed_src_finish(pgp_source_t *src)</span>
<a href="#l44.271"></a><span id="l44.271">     if (ret != RNP_SUCCESS) {</span>
<a href="#l44.272"></a><span id="l44.272">         return ret;</span>
<a href="#l44.273"></a><span id="l44.273">     }</span>
<a href="#l44.274"></a><span id="l44.274"> </span>
<a href="#l44.275"></a><span id="l44.275">     if (!src_eof(src)) {</span>
<a href="#l44.276"></a><span id="l44.276">         RNP_LOG(&quot;warning: unexpected data on the stream end&quot;);</span>
<a href="#l44.277"></a><span id="l44.277">     }</span>
<a href="#l44.278"></a><span id="l44.278"> </span>
<a href="#l44.279"></a><span id="l44.279" class="difflineminus">-    sinfos = (pgp_signature_info_t *) calloc(list_length(param-&gt;siginfos),</span>
<a href="#l44.280"></a><span id="l44.280" class="difflineminus">-                                             sizeof(pgp_signature_info_t));</span>
<a href="#l44.281"></a><span id="l44.281" class="difflineminus">-    if (!sinfos) {</span>
<a href="#l44.282"></a><span id="l44.282" class="difflineminus">-        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.283"></a><span id="l44.283" class="difflineminus">-    }</span>
<a href="#l44.284"></a><span id="l44.284" class="difflineminus">-</span>
<a href="#l44.285"></a><span id="l44.285">     /* validating signatures */</span>
<a href="#l44.286"></a><span id="l44.286">     keyctx.op = PGP_OP_VERIFY;</span>
<a href="#l44.287"></a><span id="l44.287">     keyctx.search.type = PGP_KEY_SEARCH_KEYID;</span>
<a href="#l44.288"></a><span id="l44.288"> </span>
<a href="#l44.289"></a><span id="l44.289" class="difflineminus">-    for (list_item *si = list_front(param-&gt;siginfos); si; si = list_next(si)) {</span>
<a href="#l44.290"></a><span id="l44.290" class="difflineminus">-        sinfo = (pgp_signature_info_t *) si;</span>
<a href="#l44.291"></a><span id="l44.291" class="difflineminus">-        if (!sinfo-&gt;sig) {</span>
<a href="#l44.292"></a><span id="l44.292" class="difflineplus">+    for (auto &amp;sinfo : param-&gt;siginfos) {</span>
<a href="#l44.293"></a><span id="l44.293" class="difflineplus">+        if (!sinfo.sig) {</span>
<a href="#l44.294"></a><span id="l44.294">             continue;</span>
<a href="#l44.295"></a><span id="l44.295">         }</span>
<a href="#l44.296"></a><span id="l44.296"> </span>
<a href="#l44.297"></a><span id="l44.297">         /* we need public key, however may fallback to secret later on */</span>
<a href="#l44.298"></a><span id="l44.298">         keyctx.secret = false;</span>
<a href="#l44.299"></a><span id="l44.299"> </span>
<a href="#l44.300"></a><span id="l44.300">         /* Get the key id */</span>
<a href="#l44.301"></a><span id="l44.301" class="difflineminus">-        if (!signature_get_keyid(sinfo-&gt;sig, keyctx.search.by.keyid)) {</span>
<a href="#l44.302"></a><span id="l44.302" class="difflineplus">+        if (!signature_get_keyid(sinfo.sig, keyctx.search.by.keyid)) {</span>
<a href="#l44.303"></a><span id="l44.303">             RNP_LOG(&quot;cannot get signer's key id from signature&quot;);</span>
<a href="#l44.304"></a><span id="l44.304" class="difflineminus">-            sinfo-&gt;unknown = true;</span>
<a href="#l44.305"></a><span id="l44.305" class="difflineplus">+            sinfo.unknown = true;</span>
<a href="#l44.306"></a><span id="l44.306">             continue;</span>
<a href="#l44.307"></a><span id="l44.307">         }</span>
<a href="#l44.308"></a><span id="l44.308"> </span>
<a href="#l44.309"></a><span id="l44.309">         /* Get the public key */</span>
<a href="#l44.310"></a><span id="l44.310">         if (!(key = pgp_request_key(param-&gt;handler-&gt;key_provider, &amp;keyctx))) {</span>
<a href="#l44.311"></a><span id="l44.311">             // fallback to secret key</span>
<a href="#l44.312"></a><span id="l44.312">             keyctx.secret = true;</span>
<a href="#l44.313"></a><span id="l44.313">             if (!(key = pgp_request_key(param-&gt;handler-&gt;key_provider, &amp;keyctx))) {</span>
<a href="#l44.314"></a><span id="l44.314">                 RNP_LOG(&quot;signer's key not found&quot;);</span>
<a href="#l44.315"></a><span id="l44.315" class="difflineminus">-                sinfo-&gt;no_signer = true;</span>
<a href="#l44.316"></a><span id="l44.316" class="difflineplus">+                sinfo.no_signer = true;</span>
<a href="#l44.317"></a><span id="l44.317">                 continue;</span>
<a href="#l44.318"></a><span id="l44.318">             }</span>
<a href="#l44.319"></a><span id="l44.319">         }</span>
<a href="#l44.320"></a><span id="l44.320" class="difflineminus">-        sinfo-&gt;signer = key;</span>
<a href="#l44.321"></a><span id="l44.321" class="difflineplus">+        sinfo.signer = key;</span>
<a href="#l44.322"></a><span id="l44.322">         /* validate signature */</span>
<a href="#l44.323"></a><span id="l44.323" class="difflineminus">-        signed_validate_signature(param, sinfo);</span>
<a href="#l44.324"></a><span id="l44.324" class="difflineplus">+        signed_validate_signature(param, &amp;sinfo);</span>
<a href="#l44.325"></a><span id="l44.325">     }</span>
<a href="#l44.326"></a><span id="l44.326"> </span>
<a href="#l44.327"></a><span id="l44.327">     /* checking the validation results */</span>
<a href="#l44.328"></a><span id="l44.328">     ret = RNP_SUCCESS;</span>
<a href="#l44.329"></a><span id="l44.329" class="difflineminus">-    for (list_item *si = list_front(param-&gt;siginfos); si; si = list_next(si)) {</span>
<a href="#l44.330"></a><span id="l44.330" class="difflineminus">-        sinfo = (pgp_signature_info_t *) si;</span>
<a href="#l44.331"></a><span id="l44.331" class="difflineminus">-        sinfos[sinfoc++] = *sinfo;</span>
<a href="#l44.332"></a><span id="l44.332" class="difflineminus">-</span>
<a href="#l44.333"></a><span id="l44.333" class="difflineminus">-        if (sinfo-&gt;no_signer &amp;&amp; param-&gt;handler-&gt;ctx-&gt;discard) {</span>
<a href="#l44.334"></a><span id="l44.334" class="difflineplus">+    for (auto &amp;sinfo : param-&gt;siginfos) {</span>
<a href="#l44.335"></a><span id="l44.335" class="difflineplus">+        if (sinfo.no_signer &amp;&amp; param-&gt;handler-&gt;ctx-&gt;discard) {</span>
<a href="#l44.336"></a><span id="l44.336">             /* if output is discarded then we interested in verification */</span>
<a href="#l44.337"></a><span id="l44.337">             ret = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l44.338"></a><span id="l44.338">             continue;</span>
<a href="#l44.339"></a><span id="l44.339">         }</span>
<a href="#l44.340"></a><span id="l44.340" class="difflineminus">-        if (!sinfo-&gt;no_signer &amp;&amp; (!sinfo-&gt;valid || (sinfo-&gt;expired))) {</span>
<a href="#l44.341"></a><span id="l44.341" class="difflineplus">+        if (!sinfo.no_signer &amp;&amp; (!sinfo.valid || (sinfo.expired))) {</span>
<a href="#l44.342"></a><span id="l44.342">             /* do not report error if signer not found */</span>
<a href="#l44.343"></a><span id="l44.343">             ret = RNP_ERROR_SIGNATURE_INVALID;</span>
<a href="#l44.344"></a><span id="l44.344">         }</span>
<a href="#l44.345"></a><span id="l44.345">     }</span>
<a href="#l44.346"></a><span id="l44.346"> </span>
<a href="#l44.347"></a><span id="l44.347">     /* call the callback with signature infos */</span>
<a href="#l44.348"></a><span id="l44.348">     if (param-&gt;handler-&gt;on_signatures) {</span>
<a href="#l44.349"></a><span id="l44.349" class="difflineminus">-        param-&gt;handler-&gt;on_signatures(sinfos, sinfoc, param-&gt;handler-&gt;param);</span>
<a href="#l44.350"></a><span id="l44.350" class="difflineplus">+        param-&gt;handler-&gt;on_signatures(param-&gt;siginfos, param-&gt;handler-&gt;param);</span>
<a href="#l44.351"></a><span id="l44.351">     }</span>
<a href="#l44.352"></a><span id="l44.352" class="difflineminus">-</span>
<a href="#l44.353"></a><span id="l44.353" class="difflineminus">-    free(sinfos);</span>
<a href="#l44.354"></a><span id="l44.354">     return ret;</span>
<a href="#l44.355"></a><span id="l44.355"> }</span>
<a href="#l44.356"></a><span id="l44.356"> </span>
<a href="#l44.357"></a><span id="l44.357"> /*</span>
<a href="#l44.358"></a><span id="l44.358">  * str is a string to tokenize.</span>
<a href="#l44.359"></a><span id="l44.359">  * delims is a string containing a list of delimiter characters.</span>
<a href="#l44.360"></a><span id="l44.360">  * result is a container&lt;string_type&gt; that supports push_back.</span>
<a href="#l44.361"></a><span id="l44.361">  */</span>
<a href="#l44.362"></a><span id="l44.362" class="difflineat">@@ -1035,17 +1013,17 @@ cleartext_parse_headers(pgp_source_t *sr</span>
<a href="#l44.363"></a><span id="l44.363">             std::vector&lt;std::string&gt; tokens;</span>
<a href="#l44.364"></a><span id="l44.364"> </span>
<a href="#l44.365"></a><span id="l44.365">             tokenize(remainder, delimiters, tokens);</span>
<a href="#l44.366"></a><span id="l44.366"> </span>
<a href="#l44.367"></a><span id="l44.367">             for (const auto &amp;token : tokens) {</span>
<a href="#l44.368"></a><span id="l44.368">                 if ((halg = pgp_str_to_hash_alg(token.c_str())) == PGP_HASH_UNKNOWN) {</span>
<a href="#l44.369"></a><span id="l44.369">                     RNP_LOG(&quot;unknown halg: %s&quot;, token.c_str());</span>
<a href="#l44.370"></a><span id="l44.370">                 }</span>
<a href="#l44.371"></a><span id="l44.371" class="difflineminus">-                pgp_hash_list_add(&amp;param-&gt;hashes, halg);</span>
<a href="#l44.372"></a><span id="l44.372" class="difflineplus">+                pgp_hash_list_add(param-&gt;hashes, halg);</span>
<a href="#l44.373"></a><span id="l44.373">             }</span>
<a href="#l44.374"></a><span id="l44.374">         } else {</span>
<a href="#l44.375"></a><span id="l44.375">             RNP_LOG(&quot;unknown header '%s'&quot;, hdr);</span>
<a href="#l44.376"></a><span id="l44.376">         }</span>
<a href="#l44.377"></a><span id="l44.377"> </span>
<a href="#l44.378"></a><span id="l44.378">         src_skip(param-&gt;readsrc, hdrlen);</span>
<a href="#l44.379"></a><span id="l44.379"> </span>
<a href="#l44.380"></a><span id="l44.380">         if (!src_skip_eol(param-&gt;readsrc)) {</span>
<a href="#l44.381"></a><span id="l44.381" class="difflineat">@@ -1322,23 +1300,23 @@ encrypted_try_key(pgp_source_encrypted_p</span>
<a href="#l44.382"></a><span id="l44.382">           elgamal_decrypt_pkcs1(rng, decbuf, &amp;declen, &amp;sesskey-&gt;material.eg, &amp;keymaterial-&gt;eg);</span>
<a href="#l44.383"></a><span id="l44.383">         if (ret) {</span>
<a href="#l44.384"></a><span id="l44.384">             RNP_LOG(&quot;ElGamal decryption failure [%X]&quot;, ret);</span>
<a href="#l44.385"></a><span id="l44.385">             return false;</span>
<a href="#l44.386"></a><span id="l44.386">         }</span>
<a href="#l44.387"></a><span id="l44.387">         break;</span>
<a href="#l44.388"></a><span id="l44.388">     }</span>
<a href="#l44.389"></a><span id="l44.389">     case PGP_PKA_ECDH: {</span>
<a href="#l44.390"></a><span id="l44.390" class="difflineminus">-        if (pgp_fingerprint(&amp;fingerprint, seckey)) {</span>
<a href="#l44.391"></a><span id="l44.391" class="difflineplus">+        if (pgp_fingerprint(fingerprint, seckey)) {</span>
<a href="#l44.392"></a><span id="l44.392">             RNP_LOG(&quot;ECDH fingerprint calculation failed&quot;);</span>
<a href="#l44.393"></a><span id="l44.393">             return false;</span>
<a href="#l44.394"></a><span id="l44.394">         }</span>
<a href="#l44.395"></a><span id="l44.395">         declen = sizeof(decbuf);</span>
<a href="#l44.396"></a><span id="l44.396">         err = ecdh_decrypt_pkcs5(</span>
<a href="#l44.397"></a><span id="l44.397" class="difflineminus">-          decbuf, &amp;declen, &amp;sesskey-&gt;material.ecdh, &amp;keymaterial-&gt;ec, &amp;fingerprint);</span>
<a href="#l44.398"></a><span id="l44.398" class="difflineplus">+          decbuf, &amp;declen, &amp;sesskey-&gt;material.ecdh, &amp;keymaterial-&gt;ec, fingerprint);</span>
<a href="#l44.399"></a><span id="l44.399">         if (err != RNP_SUCCESS) {</span>
<a href="#l44.400"></a><span id="l44.400">             RNP_LOG(&quot;ECDH decryption error %u&quot;, err);</span>
<a href="#l44.401"></a><span id="l44.401">             return false;</span>
<a href="#l44.402"></a><span id="l44.402">         }</span>
<a href="#l44.403"></a><span id="l44.403">         break;</span>
<a href="#l44.404"></a><span id="l44.404">     }</span>
<a href="#l44.405"></a><span id="l44.405">     default:</span>
<a href="#l44.406"></a><span id="l44.406">         RNP_LOG(&quot;unsupported public key algorithm %d\n&quot;, seckey-&gt;alg);</span>
<a href="#l44.407"></a><span id="l44.407" class="difflineat">@@ -1873,20 +1851,26 @@ init_encrypted_src(pgp_parse_handler_t *</span>
<a href="#l44.408"></a><span id="l44.408">     rnp_result_t                  errcode = RNP_ERROR_GENERIC;</span>
<a href="#l44.409"></a><span id="l44.409">     pgp_source_encrypted_param_t *param;</span>
<a href="#l44.410"></a><span id="l44.410">     pgp_key_t *                   seckey = NULL;</span>
<a href="#l44.411"></a><span id="l44.411">     pgp_key_pkt_t *               decrypted_seckey = NULL;</span>
<a href="#l44.412"></a><span id="l44.412">     char                          password[MAX_PASSWORD_LENGTH] = {0};</span>
<a href="#l44.413"></a><span id="l44.413">     int                           intres;</span>
<a href="#l44.414"></a><span id="l44.414">     bool                          have_key = false;</span>
<a href="#l44.415"></a><span id="l44.415"> </span>
<a href="#l44.416"></a><span id="l44.416" class="difflineminus">-    if (!init_src_common(src, sizeof(*param))) {</span>
<a href="#l44.417"></a><span id="l44.417" class="difflineplus">+    if (!init_src_common(src, 0)) {</span>
<a href="#l44.418"></a><span id="l44.418">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.419"></a><span id="l44.419">     }</span>
<a href="#l44.420"></a><span id="l44.420" class="difflineminus">-    param = (pgp_source_encrypted_param_t *) src-&gt;param;</span>
<a href="#l44.421"></a><span id="l44.421" class="difflineplus">+    try {</span>
<a href="#l44.422"></a><span id="l44.422" class="difflineplus">+        param = new pgp_source_encrypted_param_t();</span>
<a href="#l44.423"></a><span id="l44.423" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l44.424"></a><span id="l44.424" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.425"></a><span id="l44.425" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.426"></a><span id="l44.426" class="difflineplus">+    }</span>
<a href="#l44.427"></a><span id="l44.427" class="difflineplus">+    src-&gt;param = param;</span>
<a href="#l44.428"></a><span id="l44.428">     param-&gt;pkt.readsrc = readsrc;</span>
<a href="#l44.429"></a><span id="l44.429">     param-&gt;handler = handler;</span>
<a href="#l44.430"></a><span id="l44.430"> </span>
<a href="#l44.431"></a><span id="l44.431">     src-&gt;close = encrypted_src_close;</span>
<a href="#l44.432"></a><span id="l44.432">     src-&gt;finish = encrypted_src_finish;</span>
<a href="#l44.433"></a><span id="l44.433">     src-&gt;type = PGP_STREAM_ENCRYPTED;</span>
<a href="#l44.434"></a><span id="l44.434"> </span>
<a href="#l44.435"></a><span id="l44.435">     /* Read the packet-related information */</span>
<a href="#l44.436"></a><span id="l44.436" class="difflineat">@@ -1920,17 +1904,17 @@ init_encrypted_src(pgp_parse_handler_t *</span>
<a href="#l44.437"></a><span id="l44.437">         }</span>
<a href="#l44.438"></a><span id="l44.438"> </span>
<a href="#l44.439"></a><span id="l44.439">         pgp_key_request_ctx_t keyctx = {};</span>
<a href="#l44.440"></a><span id="l44.440">         keyctx.op = PGP_OP_DECRYPT_SYM;</span>
<a href="#l44.441"></a><span id="l44.441">         keyctx.secret = true;</span>
<a href="#l44.442"></a><span id="l44.442">         keyctx.search.type = PGP_KEY_SEARCH_KEYID;</span>
<a href="#l44.443"></a><span id="l44.443"> </span>
<a href="#l44.444"></a><span id="l44.444">         for (auto &amp;pubenc : param-&gt;pubencs) {</span>
<a href="#l44.445"></a><span id="l44.445" class="difflineminus">-            memcpy(keyctx.search.by.keyid, pubenc.key_id, sizeof(keyctx.search.by.keyid));</span>
<a href="#l44.446"></a><span id="l44.446" class="difflineplus">+            keyctx.search.by.keyid = pubenc.key_id;</span>
<a href="#l44.447"></a><span id="l44.447">             /* Get the key if any */</span>
<a href="#l44.448"></a><span id="l44.448">             if (!(seckey = pgp_request_key(handler-&gt;key_provider, &amp;keyctx))) {</span>
<a href="#l44.449"></a><span id="l44.449">                 errcode = RNP_ERROR_NO_SUITABLE_KEY;</span>
<a href="#l44.450"></a><span id="l44.450">                 continue;</span>
<a href="#l44.451"></a><span id="l44.451">             }</span>
<a href="#l44.452"></a><span id="l44.452">             /* Decrypt key */</span>
<a href="#l44.453"></a><span id="l44.453">             if (pgp_key_is_encrypted(seckey)) {</span>
<a href="#l44.454"></a><span id="l44.454">                 pgp_password_ctx_t pass_ctx{.op = PGP_OP_DECRYPT, .key = seckey};</span>
<a href="#l44.455"></a><span id="l44.455" class="difflineat">@@ -2037,34 +2021,48 @@ init_cleartext_signed_src(pgp_source_t *</span>
<a href="#l44.456"></a><span id="l44.456">         return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.457"></a><span id="l44.457">     }</span>
<a href="#l44.458"></a><span id="l44.458"> </span>
<a href="#l44.459"></a><span id="l44.459">     /* now we are good to go */</span>
<a href="#l44.460"></a><span id="l44.460">     param-&gt;clr_fline = true;</span>
<a href="#l44.461"></a><span id="l44.461">     return RNP_SUCCESS;</span>
<a href="#l44.462"></a><span id="l44.462"> }</span>
<a href="#l44.463"></a><span id="l44.463"> </span>
<a href="#l44.464"></a><span id="l44.464" class="difflineplus">+pgp_source_signed_param_t::~pgp_source_signed_param_t()</span>
<a href="#l44.465"></a><span id="l44.465" class="difflineplus">+{</span>
<a href="#l44.466"></a><span id="l44.466" class="difflineplus">+    for (auto &amp;hash : hashes) {</span>
<a href="#l44.467"></a><span id="l44.467" class="difflineplus">+        pgp_hash_finish(&amp;hash, NULL);</span>
<a href="#l44.468"></a><span id="l44.468" class="difflineplus">+    }</span>
<a href="#l44.469"></a><span id="l44.469" class="difflineplus">+    for (auto &amp;sig : sigs) {</span>
<a href="#l44.470"></a><span id="l44.470" class="difflineplus">+        free_signature(&amp;sig);</span>
<a href="#l44.471"></a><span id="l44.471" class="difflineplus">+    }</span>
<a href="#l44.472"></a><span id="l44.472" class="difflineplus">+}</span>
<a href="#l44.473"></a><span id="l44.473" class="difflineplus">+</span>
<a href="#l44.474"></a><span id="l44.474"> static rnp_result_t</span>
<a href="#l44.475"></a><span id="l44.475"> init_signed_src(pgp_parse_handler_t *handler, pgp_source_t *src, pgp_source_t *readsrc)</span>
<a href="#l44.476"></a><span id="l44.476"> {</span>
<a href="#l44.477"></a><span id="l44.477">     rnp_result_t               errcode = RNP_ERROR_GENERIC;</span>
<a href="#l44.478"></a><span id="l44.478">     pgp_source_signed_param_t *param;</span>
<a href="#l44.479"></a><span id="l44.479">     uint8_t                    ptag;</span>
<a href="#l44.480"></a><span id="l44.480">     int                        ptype;</span>
<a href="#l44.481"></a><span id="l44.481" class="difflineminus">-    pgp_one_pass_sig_t         onepass = {0};</span>
<a href="#l44.482"></a><span id="l44.482">     pgp_signature_t *          sig = NULL;</span>
<a href="#l44.483"></a><span id="l44.483">     bool                       cleartext;</span>
<a href="#l44.484"></a><span id="l44.484"> </span>
<a href="#l44.485"></a><span id="l44.485" class="difflineminus">-    if (!init_src_common(src, sizeof(*param))) {</span>
<a href="#l44.486"></a><span id="l44.486" class="difflineplus">+    if (!init_src_common(src, 0)) {</span>
<a href="#l44.487"></a><span id="l44.487">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.488"></a><span id="l44.488">     }</span>
<a href="#l44.489"></a><span id="l44.489" class="difflineplus">+    try {</span>
<a href="#l44.490"></a><span id="l44.490" class="difflineplus">+        param = new pgp_source_signed_param_t();</span>
<a href="#l44.491"></a><span id="l44.491" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l44.492"></a><span id="l44.492" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.493"></a><span id="l44.493" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.494"></a><span id="l44.494" class="difflineplus">+    }</span>
<a href="#l44.495"></a><span id="l44.495" class="difflineplus">+    src-&gt;param = param;</span>
<a href="#l44.496"></a><span id="l44.496"> </span>
<a href="#l44.497"></a><span id="l44.497">     cleartext = is_cleartext_source(readsrc);</span>
<a href="#l44.498"></a><span id="l44.498" class="difflineminus">-</span>
<a href="#l44.499"></a><span id="l44.499" class="difflineminus">-    param = (pgp_source_signed_param_t *) src-&gt;param;</span>
<a href="#l44.500"></a><span id="l44.500">     param-&gt;readsrc = readsrc;</span>
<a href="#l44.501"></a><span id="l44.501">     param-&gt;handler = handler;</span>
<a href="#l44.502"></a><span id="l44.502">     param-&gt;cleartext = cleartext;</span>
<a href="#l44.503"></a><span id="l44.503">     src-&gt;read = cleartext ? cleartext_src_read : signed_src_read;</span>
<a href="#l44.504"></a><span id="l44.504">     src-&gt;close = signed_src_close;</span>
<a href="#l44.505"></a><span id="l44.505">     src-&gt;finish = signed_src_finish;</span>
<a href="#l44.506"></a><span id="l44.506">     src-&gt;type = cleartext ? PGP_STREAM_CLEARTEXT : PGP_STREAM_SIGNED;</span>
<a href="#l44.507"></a><span id="l44.507"> </span>
<a href="#l44.508"></a><span id="l44.508" class="difflineat">@@ -2086,98 +2084,94 @@ init_signed_src(pgp_parse_handler_t *han</span>
<a href="#l44.509"></a><span id="l44.509">             RNP_LOG(&quot;failed to read packet header&quot;);</span>
<a href="#l44.510"></a><span id="l44.510">             errcode = RNP_ERROR_READ;</span>
<a href="#l44.511"></a><span id="l44.511">             goto finish;</span>
<a href="#l44.512"></a><span id="l44.512">         }</span>
<a href="#l44.513"></a><span id="l44.513"> </span>
<a href="#l44.514"></a><span id="l44.514">         ptype = get_packet_type(ptag);</span>
<a href="#l44.515"></a><span id="l44.515"> </span>
<a href="#l44.516"></a><span id="l44.516">         if (ptype == PGP_PKT_ONE_PASS_SIG) {</span>
<a href="#l44.517"></a><span id="l44.517" class="difflineplus">+            pgp_one_pass_sig_t onepass = {};</span>
<a href="#l44.518"></a><span id="l44.518">             errcode = stream_parse_one_pass(readsrc, &amp;onepass);</span>
<a href="#l44.519"></a><span id="l44.519">             if (errcode) {</span>
<a href="#l44.520"></a><span id="l44.520">                 if (errcode == RNP_ERROR_READ) {</span>
<a href="#l44.521"></a><span id="l44.521">                     goto finish;</span>
<a href="#l44.522"></a><span id="l44.522">                 }</span>
<a href="#l44.523"></a><span id="l44.523">                 continue;</span>
<a href="#l44.524"></a><span id="l44.524">             }</span>
<a href="#l44.525"></a><span id="l44.525"> </span>
<a href="#l44.526"></a><span id="l44.526" class="difflineminus">-            if (!list_append(&amp;param-&gt;onepasses, &amp;onepass, sizeof(onepass))) {</span>
<a href="#l44.527"></a><span id="l44.527" class="difflineplus">+            try {</span>
<a href="#l44.528"></a><span id="l44.528" class="difflineplus">+                param-&gt;onepasses.push_back(onepass);</span>
<a href="#l44.529"></a><span id="l44.529" class="difflineplus">+            } catch (const std::exception &amp;e) {</span>
<a href="#l44.530"></a><span id="l44.530" class="difflineplus">+                RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.531"></a><span id="l44.531">                 errcode = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.532"></a><span id="l44.532">                 goto finish;</span>
<a href="#l44.533"></a><span id="l44.533">             }</span>
<a href="#l44.534"></a><span id="l44.534"> </span>
<a href="#l44.535"></a><span id="l44.535">             /* adding hash context */</span>
<a href="#l44.536"></a><span id="l44.536" class="difflineminus">-            pgp_hash_list_add(&amp;param-&gt;hashes, onepass.halg);</span>
<a href="#l44.537"></a><span id="l44.537" class="difflineplus">+            pgp_hash_list_add(param-&gt;hashes, onepass.halg);</span>
<a href="#l44.538"></a><span id="l44.538"> </span>
<a href="#l44.539"></a><span id="l44.539">             if (onepass.nested) {</span>
<a href="#l44.540"></a><span id="l44.540">                 /* despite the name non-zero value means that it is the last one-pass */</span>
<a href="#l44.541"></a><span id="l44.541">                 break;</span>
<a href="#l44.542"></a><span id="l44.542">             }</span>
<a href="#l44.543"></a><span id="l44.543">         } else if (ptype == PGP_PKT_SIGNATURE) {</span>
<a href="#l44.544"></a><span id="l44.544">             /* no need to check the error here - we already know tag */</span>
<a href="#l44.545"></a><span id="l44.545">             signed_read_single_signature(param, readsrc, &amp;sig);</span>
<a href="#l44.546"></a><span id="l44.546">             /* adding hash context */</span>
<a href="#l44.547"></a><span id="l44.547">             if (sig) {</span>
<a href="#l44.548"></a><span id="l44.548" class="difflineminus">-                pgp_hash_list_add(&amp;param-&gt;hashes, sig-&gt;halg);</span>
<a href="#l44.549"></a><span id="l44.549" class="difflineplus">+                pgp_hash_list_add(param-&gt;hashes, sig-&gt;halg);</span>
<a href="#l44.550"></a><span id="l44.550">             }</span>
<a href="#l44.551"></a><span id="l44.551">         } else {</span>
<a href="#l44.552"></a><span id="l44.552">             break;</span>
<a href="#l44.553"></a><span id="l44.553">         }</span>
<a href="#l44.554"></a><span id="l44.554"> </span>
<a href="#l44.555"></a><span id="l44.555">         /* for detached signature we'll get eof */</span>
<a href="#l44.556"></a><span id="l44.556">         if (src_eof(readsrc)) {</span>
<a href="#l44.557"></a><span id="l44.557">             param-&gt;detached = true;</span>
<a href="#l44.558"></a><span id="l44.558">             break;</span>
<a href="#l44.559"></a><span id="l44.559">         }</span>
<a href="#l44.560"></a><span id="l44.560">     }</span>
<a href="#l44.561"></a><span id="l44.561"> </span>
<a href="#l44.562"></a><span id="l44.562">     /* checking what we have now */</span>
<a href="#l44.563"></a><span id="l44.563" class="difflineminus">-    if (!list_length(param-&gt;onepasses) &amp;&amp; !list_length(param-&gt;sigs)) {</span>
<a href="#l44.564"></a><span id="l44.564" class="difflineplus">+    if (param-&gt;onepasses.empty() &amp;&amp; param-&gt;sigs.empty()) {</span>
<a href="#l44.565"></a><span id="l44.565">         RNP_LOG(&quot;no signatures&quot;);</span>
<a href="#l44.566"></a><span id="l44.566">         errcode = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l44.567"></a><span id="l44.567">         goto finish;</span>
<a href="#l44.568"></a><span id="l44.568">     }</span>
<a href="#l44.569"></a><span id="l44.569" class="difflineminus">-    if (list_length(param-&gt;onepasses) &amp;&amp; list_length(param-&gt;sigs)) {</span>
<a href="#l44.570"></a><span id="l44.570" class="difflineplus">+    if (!param-&gt;onepasses.empty() &amp;&amp; !param-&gt;sigs.empty()) {</span>
<a href="#l44.571"></a><span id="l44.571">         RNP_LOG(&quot;warning: one-passes are mixed with signatures&quot;);</span>
<a href="#l44.572"></a><span id="l44.572">     }</span>
<a href="#l44.573"></a><span id="l44.573"> </span>
<a href="#l44.574"></a><span id="l44.574">     errcode = RNP_SUCCESS;</span>
<a href="#l44.575"></a><span id="l44.575"> finish:</span>
<a href="#l44.576"></a><span id="l44.576">     if (errcode != RNP_SUCCESS) {</span>
<a href="#l44.577"></a><span id="l44.577">         src_close(src);</span>
<a href="#l44.578"></a><span id="l44.578">     }</span>
<a href="#l44.579"></a><span id="l44.579"> </span>
<a href="#l44.580"></a><span id="l44.580">     return errcode;</span>
<a href="#l44.581"></a><span id="l44.581"> }</span>
<a href="#l44.582"></a><span id="l44.582"> </span>
<a href="#l44.583"></a><span id="l44.583" class="difflineminus">-static void</span>
<a href="#l44.584"></a><span id="l44.584" class="difflineminus">-init_processing_ctx(pgp_processing_ctx_t *ctx)</span>
<a href="#l44.585"></a><span id="l44.585" class="difflineplus">+pgp_processing_ctx_t::~pgp_processing_ctx_t()</span>
<a href="#l44.586"></a><span id="l44.586"> {</span>
<a href="#l44.587"></a><span id="l44.587" class="difflineminus">-    memset(ctx, 0, sizeof(*ctx));</span>
<a href="#l44.588"></a><span id="l44.588" class="difflineminus">-}</span>
<a href="#l44.589"></a><span id="l44.589" class="difflineminus">-</span>
<a href="#l44.590"></a><span id="l44.590" class="difflineminus">-static void</span>
<a href="#l44.591"></a><span id="l44.591" class="difflineminus">-free_processing_ctx(pgp_processing_ctx_t *ctx)</span>
<a href="#l44.592"></a><span id="l44.592" class="difflineminus">-{</span>
<a href="#l44.593"></a><span id="l44.593" class="difflineminus">-    for (list_item *src = list_front(ctx-&gt;sources); src; src = list_next(src)) {</span>
<a href="#l44.594"></a><span id="l44.594" class="difflineminus">-        src_close((pgp_source_t *) src);</span>
<a href="#l44.595"></a><span id="l44.595" class="difflineplus">+    for (auto &amp;src : sources) {</span>
<a href="#l44.596"></a><span id="l44.596" class="difflineplus">+        src_close(&amp;src);</span>
<a href="#l44.597"></a><span id="l44.597">     }</span>
<a href="#l44.598"></a><span id="l44.598" class="difflineminus">-    list_destroy(&amp;ctx-&gt;sources);</span>
<a href="#l44.599"></a><span id="l44.599"> }</span>
<a href="#l44.600"></a><span id="l44.600"> </span>
<a href="#l44.601"></a><span id="l44.601"> /** @brief build PGP source sequence down to the literal data packet</span>
<a href="#l44.602"></a><span id="l44.602">  *</span>
<a href="#l44.603"></a><span id="l44.603">  **/</span>
<a href="#l44.604"></a><span id="l44.604"> static rnp_result_t</span>
<a href="#l44.605"></a><span id="l44.605" class="difflineminus">-init_packet_sequence(pgp_processing_ctx_t *ctx, pgp_source_t *src)</span>
<a href="#l44.606"></a><span id="l44.606" class="difflineplus">+init_packet_sequence(pgp_processing_ctx_t &amp;ctx, pgp_source_t &amp;src)</span>
<a href="#l44.607"></a><span id="l44.607"> {</span>
<a href="#l44.608"></a><span id="l44.608">     uint8_t       ptag;</span>
<a href="#l44.609"></a><span id="l44.609">     int           type;</span>
<a href="#l44.610"></a><span id="l44.610">     pgp_source_t  psrc;</span>
<a href="#l44.611"></a><span id="l44.611" class="difflineminus">-    pgp_source_t *lsrc = src;</span>
<a href="#l44.612"></a><span id="l44.612" class="difflineplus">+    pgp_source_t *lsrc = &amp;src;</span>
<a href="#l44.613"></a><span id="l44.613">     rnp_result_t  ret;</span>
<a href="#l44.614"></a><span id="l44.614"> </span>
<a href="#l44.615"></a><span id="l44.615">     while (1) {</span>
<a href="#l44.616"></a><span id="l44.616">         if (!src_peek_eq(lsrc, &amp;ptag, 1)) {</span>
<a href="#l44.617"></a><span id="l44.617">             RNP_LOG(&quot;cannot read packet tag&quot;);</span>
<a href="#l44.618"></a><span id="l44.618">             return RNP_ERROR_READ;</span>
<a href="#l44.619"></a><span id="l44.619">         }</span>
<a href="#l44.620"></a><span id="l44.620"> </span>
<a href="#l44.621"></a><span id="l44.621" class="difflineat">@@ -2187,128 +2181,132 @@ init_packet_sequence(pgp_processing_ctx_</span>
<a href="#l44.622"></a><span id="l44.622">             return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.623"></a><span id="l44.623">         }</span>
<a href="#l44.624"></a><span id="l44.624"> </span>
<a href="#l44.625"></a><span id="l44.625">         memset(&amp;psrc, 0, sizeof(psrc));</span>
<a href="#l44.626"></a><span id="l44.626"> </span>
<a href="#l44.627"></a><span id="l44.627">         switch (type) {</span>
<a href="#l44.628"></a><span id="l44.628">         case PGP_PKT_PK_SESSION_KEY:</span>
<a href="#l44.629"></a><span id="l44.629">         case PGP_PKT_SK_SESSION_KEY:</span>
<a href="#l44.630"></a><span id="l44.630" class="difflineminus">-            ret = init_encrypted_src(&amp;ctx-&gt;handler, &amp;psrc, lsrc);</span>
<a href="#l44.631"></a><span id="l44.631" class="difflineplus">+            ret = init_encrypted_src(&amp;ctx.handler, &amp;psrc, lsrc);</span>
<a href="#l44.632"></a><span id="l44.632">             break;</span>
<a href="#l44.633"></a><span id="l44.633">         case PGP_PKT_ONE_PASS_SIG:</span>
<a href="#l44.634"></a><span id="l44.634">         case PGP_PKT_SIGNATURE:</span>
<a href="#l44.635"></a><span id="l44.635" class="difflineminus">-            ret = init_signed_src(&amp;ctx-&gt;handler, &amp;psrc, lsrc);</span>
<a href="#l44.636"></a><span id="l44.636" class="difflineplus">+            ret = init_signed_src(&amp;ctx.handler, &amp;psrc, lsrc);</span>
<a href="#l44.637"></a><span id="l44.637">             break;</span>
<a href="#l44.638"></a><span id="l44.638">         case PGP_PKT_COMPRESSED:</span>
<a href="#l44.639"></a><span id="l44.639">             ret = init_compressed_src(&amp;psrc, lsrc);</span>
<a href="#l44.640"></a><span id="l44.640">             break;</span>
<a href="#l44.641"></a><span id="l44.641">         case PGP_PKT_LITDATA:</span>
<a href="#l44.642"></a><span id="l44.642" class="difflineminus">-            if ((lsrc-&gt;type != PGP_STREAM_ENCRYPTED) &amp;&amp; (lsrc-&gt;type != PGP_STREAM_SIGNED) &amp;&amp;</span>
<a href="#l44.643"></a><span id="l44.643" class="difflineminus">-                (lsrc-&gt;type != PGP_STREAM_COMPRESSED)) {</span>
<a href="#l44.644"></a><span id="l44.644" class="difflineplus">+            if ((lsrc != &amp;src) &amp;&amp; (lsrc-&gt;type != PGP_STREAM_ENCRYPTED) &amp;&amp;</span>
<a href="#l44.645"></a><span id="l44.645" class="difflineplus">+                (lsrc-&gt;type != PGP_STREAM_SIGNED) &amp;&amp; (lsrc-&gt;type != PGP_STREAM_COMPRESSED)) {</span>
<a href="#l44.646"></a><span id="l44.646">                 RNP_LOG(&quot;unexpected literal pkt&quot;);</span>
<a href="#l44.647"></a><span id="l44.647">                 ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.648"></a><span id="l44.648">                 break;</span>
<a href="#l44.649"></a><span id="l44.649">             }</span>
<a href="#l44.650"></a><span id="l44.650">             ret = init_literal_src(&amp;psrc, lsrc);</span>
<a href="#l44.651"></a><span id="l44.651">             break;</span>
<a href="#l44.652"></a><span id="l44.652">         default:</span>
<a href="#l44.653"></a><span id="l44.653">             RNP_LOG(&quot;unexpected pkt %d&quot;, type);</span>
<a href="#l44.654"></a><span id="l44.654">             ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.655"></a><span id="l44.655">         }</span>
<a href="#l44.656"></a><span id="l44.656"> </span>
<a href="#l44.657"></a><span id="l44.657">         if (ret) {</span>
<a href="#l44.658"></a><span id="l44.658">             return ret;</span>
<a href="#l44.659"></a><span id="l44.659">         }</span>
<a href="#l44.660"></a><span id="l44.660"> </span>
<a href="#l44.661"></a><span id="l44.661" class="difflineminus">-        if (!(lsrc = (pgp_source_t *) list_append(&amp;ctx-&gt;sources, &amp;psrc, sizeof(psrc)))) {</span>
<a href="#l44.662"></a><span id="l44.662" class="difflineminus">-            RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l44.663"></a><span id="l44.663" class="difflineplus">+        try {</span>
<a href="#l44.664"></a><span id="l44.664" class="difflineplus">+            ctx.sources.push_back(psrc);</span>
<a href="#l44.665"></a><span id="l44.665" class="difflineplus">+            lsrc = &amp;ctx.sources.back();</span>
<a href="#l44.666"></a><span id="l44.666" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l44.667"></a><span id="l44.667" class="difflineplus">+            src_close(&amp;psrc);</span>
<a href="#l44.668"></a><span id="l44.668" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.669"></a><span id="l44.669">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.670"></a><span id="l44.670">         }</span>
<a href="#l44.671"></a><span id="l44.671"> </span>
<a href="#l44.672"></a><span id="l44.672">         if (lsrc-&gt;type == PGP_STREAM_LITERAL) {</span>
<a href="#l44.673"></a><span id="l44.673" class="difflineminus">-            ctx-&gt;literal_src = lsrc;</span>
<a href="#l44.674"></a><span id="l44.674" class="difflineminus">-            ctx-&gt;msg_type = PGP_MESSAGE_NORMAL;</span>
<a href="#l44.675"></a><span id="l44.675" class="difflineplus">+            ctx.literal_src = lsrc;</span>
<a href="#l44.676"></a><span id="l44.676" class="difflineplus">+            ctx.msg_type = PGP_MESSAGE_NORMAL;</span>
<a href="#l44.677"></a><span id="l44.677">             return RNP_SUCCESS;</span>
<a href="#l44.678"></a><span id="l44.678">         }</span>
<a href="#l44.679"></a><span id="l44.679">         if (lsrc-&gt;type == PGP_STREAM_SIGNED) {</span>
<a href="#l44.680"></a><span id="l44.680" class="difflineminus">-            ctx-&gt;signed_src = lsrc;</span>
<a href="#l44.681"></a><span id="l44.681" class="difflineplus">+            ctx.signed_src = lsrc;</span>
<a href="#l44.682"></a><span id="l44.682">             pgp_source_signed_param_t *param = (pgp_source_signed_param_t *) lsrc-&gt;param;</span>
<a href="#l44.683"></a><span id="l44.683">             if (param-&gt;detached) {</span>
<a href="#l44.684"></a><span id="l44.684" class="difflineminus">-                ctx-&gt;msg_type = PGP_MESSAGE_DETACHED;</span>
<a href="#l44.685"></a><span id="l44.685" class="difflineplus">+                ctx.msg_type = PGP_MESSAGE_DETACHED;</span>
<a href="#l44.686"></a><span id="l44.686">                 return RNP_SUCCESS;</span>
<a href="#l44.687"></a><span id="l44.687">             }</span>
<a href="#l44.688"></a><span id="l44.688">         }</span>
<a href="#l44.689"></a><span id="l44.689">     }</span>
<a href="#l44.690"></a><span id="l44.690"> }</span>
<a href="#l44.691"></a><span id="l44.691"> </span>
<a href="#l44.692"></a><span id="l44.692"> static rnp_result_t</span>
<a href="#l44.693"></a><span id="l44.693" class="difflineminus">-init_cleartext_sequence(pgp_processing_ctx_t *ctx, pgp_source_t *src)</span>
<a href="#l44.694"></a><span id="l44.694" class="difflineplus">+init_cleartext_sequence(pgp_processing_ctx_t &amp;ctx, pgp_source_t &amp;src)</span>
<a href="#l44.695"></a><span id="l44.695"> {</span>
<a href="#l44.696"></a><span id="l44.696" class="difflineminus">-    pgp_source_t clrsrc = {0};</span>
<a href="#l44.697"></a><span id="l44.697" class="difflineplus">+    pgp_source_t clrsrc = {};</span>
<a href="#l44.698"></a><span id="l44.698">     rnp_result_t res;</span>
<a href="#l44.699"></a><span id="l44.699"> </span>
<a href="#l44.700"></a><span id="l44.700" class="difflineminus">-    if ((res = init_signed_src(&amp;ctx-&gt;handler, &amp;clrsrc, src))) {</span>
<a href="#l44.701"></a><span id="l44.701" class="difflineplus">+    if ((res = init_signed_src(&amp;ctx.handler, &amp;clrsrc, &amp;src))) {</span>
<a href="#l44.702"></a><span id="l44.702">         return res;</span>
<a href="#l44.703"></a><span id="l44.703">     }</span>
<a href="#l44.704"></a><span id="l44.704" class="difflineminus">-</span>
<a href="#l44.705"></a><span id="l44.705" class="difflineminus">-    if (!list_append(&amp;ctx-&gt;sources, &amp;clrsrc, sizeof(clrsrc))) {</span>
<a href="#l44.706"></a><span id="l44.706" class="difflineminus">-        RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l44.707"></a><span id="l44.707" class="difflineplus">+    try {</span>
<a href="#l44.708"></a><span id="l44.708" class="difflineplus">+        ctx.sources.push_back(clrsrc);</span>
<a href="#l44.709"></a><span id="l44.709" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l44.710"></a><span id="l44.710" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.711"></a><span id="l44.711" class="difflineplus">+        src_close(&amp;clrsrc);</span>
<a href="#l44.712"></a><span id="l44.712">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.713"></a><span id="l44.713">     }</span>
<a href="#l44.714"></a><span id="l44.714" class="difflineminus">-</span>
<a href="#l44.715"></a><span id="l44.715" class="difflineminus">-    return res;</span>
<a href="#l44.716"></a><span id="l44.716" class="difflineplus">+    return RNP_SUCCESS;</span>
<a href="#l44.717"></a><span id="l44.717"> }</span>
<a href="#l44.718"></a><span id="l44.718"> </span>
<a href="#l44.719"></a><span id="l44.719"> static rnp_result_t</span>
<a href="#l44.720"></a><span id="l44.720" class="difflineminus">-init_armored_sequence(pgp_processing_ctx_t *ctx, pgp_source_t *src)</span>
<a href="#l44.721"></a><span id="l44.721" class="difflineplus">+init_armored_sequence(pgp_processing_ctx_t &amp;ctx, pgp_source_t &amp;src)</span>
<a href="#l44.722"></a><span id="l44.722"> {</span>
<a href="#l44.723"></a><span id="l44.723" class="difflineminus">-    pgp_source_t armorsrc = {0};</span>
<a href="#l44.724"></a><span id="l44.724" class="difflineminus">-    list_item *  armorptr;</span>
<a href="#l44.725"></a><span id="l44.725" class="difflineplus">+    pgp_source_t armorsrc = {};</span>
<a href="#l44.726"></a><span id="l44.726">     rnp_result_t res;</span>
<a href="#l44.727"></a><span id="l44.727"> </span>
<a href="#l44.728"></a><span id="l44.728" class="difflineminus">-    if ((res = init_armored_src(&amp;armorsrc, src))) {</span>
<a href="#l44.729"></a><span id="l44.729" class="difflineplus">+    if ((res = init_armored_src(&amp;armorsrc, &amp;src))) {</span>
<a href="#l44.730"></a><span id="l44.730">         return res;</span>
<a href="#l44.731"></a><span id="l44.731">     }</span>
<a href="#l44.732"></a><span id="l44.732"> </span>
<a href="#l44.733"></a><span id="l44.733" class="difflineminus">-    if (!(armorptr = list_append(&amp;ctx-&gt;sources, &amp;armorsrc, sizeof(armorsrc)))) {</span>
<a href="#l44.734"></a><span id="l44.734" class="difflineminus">-        RNP_LOG(&quot;allocation failed&quot;);</span>
<a href="#l44.735"></a><span id="l44.735" class="difflineplus">+    try {</span>
<a href="#l44.736"></a><span id="l44.736" class="difflineplus">+        ctx.sources.push_back(armorsrc);</span>
<a href="#l44.737"></a><span id="l44.737" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l44.738"></a><span id="l44.738" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l44.739"></a><span id="l44.739" class="difflineplus">+        src_close(&amp;armorsrc);</span>
<a href="#l44.740"></a><span id="l44.740">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l44.741"></a><span id="l44.741">     }</span>
<a href="#l44.742"></a><span id="l44.742" class="difflineminus">-</span>
<a href="#l44.743"></a><span id="l44.743" class="difflineminus">-    return init_packet_sequence(ctx, (pgp_source_t *) armorptr);</span>
<a href="#l44.744"></a><span id="l44.744" class="difflineplus">+    return init_packet_sequence(ctx, ctx.sources.back());</span>
<a href="#l44.745"></a><span id="l44.745"> }</span>
<a href="#l44.746"></a><span id="l44.746"> </span>
<a href="#l44.747"></a><span id="l44.747"> rnp_result_t</span>
<a href="#l44.748"></a><span id="l44.748" class="difflineminus">-process_pgp_source(pgp_parse_handler_t *handler, pgp_source_t *src)</span>
<a href="#l44.749"></a><span id="l44.749" class="difflineplus">+process_pgp_source(pgp_parse_handler_t *handler, pgp_source_t &amp;src)</span>
<a href="#l44.750"></a><span id="l44.750"> {</span>
<a href="#l44.751"></a><span id="l44.751">     rnp_result_t         res = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.752"></a><span id="l44.752">     rnp_result_t         fres;</span>
<a href="#l44.753"></a><span id="l44.753" class="difflineminus">-    pgp_processing_ctx_t ctx;</span>
<a href="#l44.754"></a><span id="l44.754" class="difflineplus">+    pgp_processing_ctx_t ctx = {};</span>
<a href="#l44.755"></a><span id="l44.755">     pgp_source_t *       decsrc = NULL;</span>
<a href="#l44.756"></a><span id="l44.756">     pgp_source_t         datasrc = {0};</span>
<a href="#l44.757"></a><span id="l44.757">     pgp_dest_t *         outdest = NULL;</span>
<a href="#l44.758"></a><span id="l44.758">     bool                 closeout = true;</span>
<a href="#l44.759"></a><span id="l44.759">     uint8_t *            readbuf = NULL;</span>
<a href="#l44.760"></a><span id="l44.760">     char *               filename = NULL;</span>
<a href="#l44.761"></a><span id="l44.761"> </span>
<a href="#l44.762"></a><span id="l44.762" class="difflineminus">-    init_processing_ctx(&amp;ctx);</span>
<a href="#l44.763"></a><span id="l44.763">     ctx.handler = *handler;</span>
<a href="#l44.764"></a><span id="l44.764" class="difflineminus">-</span>
<a href="#l44.765"></a><span id="l44.765">     /* Building readers sequence. Checking whether it is binary data */</span>
<a href="#l44.766"></a><span id="l44.766">     if (is_pgp_source(src)) {</span>
<a href="#l44.767"></a><span id="l44.767" class="difflineminus">-        res = init_packet_sequence(&amp;ctx, src);</span>
<a href="#l44.768"></a><span id="l44.768" class="difflineplus">+        res = init_packet_sequence(ctx, src);</span>
<a href="#l44.769"></a><span id="l44.769">     } else {</span>
<a href="#l44.770"></a><span id="l44.770">         /* Trying armored or cleartext data */</span>
<a href="#l44.771"></a><span id="l44.771" class="difflineminus">-        if (is_cleartext_source(src)) {</span>
<a href="#l44.772"></a><span id="l44.772" class="difflineplus">+        if (is_cleartext_source(&amp;src)) {</span>
<a href="#l44.773"></a><span id="l44.773">             /* Initializing cleartext message */</span>
<a href="#l44.774"></a><span id="l44.774" class="difflineminus">-            res = init_cleartext_sequence(&amp;ctx, src);</span>
<a href="#l44.775"></a><span id="l44.775" class="difflineminus">-        } else if (is_armored_source(src)) {</span>
<a href="#l44.776"></a><span id="l44.776" class="difflineplus">+            res = init_cleartext_sequence(ctx, src);</span>
<a href="#l44.777"></a><span id="l44.777" class="difflineplus">+        } else if (is_armored_source(&amp;src)) {</span>
<a href="#l44.778"></a><span id="l44.778">             /* Initializing armored message */</span>
<a href="#l44.779"></a><span id="l44.779" class="difflineminus">-            res = init_armored_sequence(&amp;ctx, src);</span>
<a href="#l44.780"></a><span id="l44.780" class="difflineplus">+            res = init_armored_sequence(ctx, src);</span>
<a href="#l44.781"></a><span id="l44.781">         } else {</span>
<a href="#l44.782"></a><span id="l44.782">             RNP_LOG(&quot;not an OpenPGP data provided&quot;);</span>
<a href="#l44.783"></a><span id="l44.783">             res = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l44.784"></a><span id="l44.784">             goto finish;</span>
<a href="#l44.785"></a><span id="l44.785">         }</span>
<a href="#l44.786"></a><span id="l44.786">     }</span>
<a href="#l44.787"></a><span id="l44.787"> </span>
<a href="#l44.788"></a><span id="l44.788">     if (res != RNP_SUCCESS) {</span>
<a href="#l44.789"></a><span id="l44.789" class="difflineat">@@ -2337,17 +2335,17 @@ process_pgp_source(pgp_parse_handler_t *</span>
<a href="#l44.790"></a><span id="l44.790">             }</span>
<a href="#l44.791"></a><span id="l44.791">             if (read &gt; 0) {</span>
<a href="#l44.792"></a><span id="l44.792">                 signed_src_update(ctx.signed_src, readbuf, read);</span>
<a href="#l44.793"></a><span id="l44.793">             }</span>
<a href="#l44.794"></a><span id="l44.794">         }</span>
<a href="#l44.795"></a><span id="l44.795">         src_close(&amp;datasrc);</span>
<a href="#l44.796"></a><span id="l44.796">     } else {</span>
<a href="#l44.797"></a><span id="l44.797">         /* file processing case */</span>
<a href="#l44.798"></a><span id="l44.798" class="difflineminus">-        decsrc = (pgp_source_t *) list_back(ctx.sources);</span>
<a href="#l44.799"></a><span id="l44.799" class="difflineplus">+        decsrc = &amp;ctx.sources.back();</span>
<a href="#l44.800"></a><span id="l44.800">         if (ctx.literal_src) {</span>
<a href="#l44.801"></a><span id="l44.801">             filename = ((pgp_source_literal_param_t *) ctx.literal_src)-&gt;hdr.fname;</span>
<a href="#l44.802"></a><span id="l44.802">         }</span>
<a href="#l44.803"></a><span id="l44.803"> </span>
<a href="#l44.804"></a><span id="l44.804">         if (!handler-&gt;dest_provider ||</span>
<a href="#l44.805"></a><span id="l44.805">             !handler-&gt;dest_provider(handler, &amp;outdest, &amp;closeout, filename)) {</span>
<a href="#l44.806"></a><span id="l44.806">             res = RNP_ERROR_WRITE;</span>
<a href="#l44.807"></a><span id="l44.807">             goto finish;</span>
<a href="#l44.808"></a><span id="l44.808" class="difflineat">@@ -2372,25 +2370,24 @@ process_pgp_source(pgp_parse_handler_t *</span>
<a href="#l44.809"></a><span id="l44.809">                 res = RNP_ERROR_WRITE;</span>
<a href="#l44.810"></a><span id="l44.810">                 break;</span>
<a href="#l44.811"></a><span id="l44.811">             }</span>
<a href="#l44.812"></a><span id="l44.812">         }</span>
<a href="#l44.813"></a><span id="l44.813">     }</span>
<a href="#l44.814"></a><span id="l44.814"> </span>
<a href="#l44.815"></a><span id="l44.815">     /* finalizing the input. Signatures are checked on this step */</span>
<a href="#l44.816"></a><span id="l44.816">     if (res == RNP_SUCCESS) {</span>
<a href="#l44.817"></a><span id="l44.817" class="difflineminus">-        for (list_item *src = list_back(ctx.sources); src; src = list_prev(src)) {</span>
<a href="#l44.818"></a><span id="l44.818" class="difflineminus">-            fres = src_finish((pgp_source_t *) src);</span>
<a href="#l44.819"></a><span id="l44.819" class="difflineplus">+        for (auto &amp;src : ctx.sources) {</span>
<a href="#l44.820"></a><span id="l44.820" class="difflineplus">+            fres = src_finish(&amp;src);</span>
<a href="#l44.821"></a><span id="l44.821">             if (fres) {</span>
<a href="#l44.822"></a><span id="l44.822">                 res = fres;</span>
<a href="#l44.823"></a><span id="l44.823">             }</span>
<a href="#l44.824"></a><span id="l44.824">         }</span>
<a href="#l44.825"></a><span id="l44.825">     }</span>
<a href="#l44.826"></a><span id="l44.826"> </span>
<a href="#l44.827"></a><span id="l44.827">     if (closeout &amp;&amp; (ctx.msg_type != PGP_MESSAGE_DETACHED)) {</span>
<a href="#l44.828"></a><span id="l44.828">         dst_close(outdest, res != RNP_SUCCESS);</span>
<a href="#l44.829"></a><span id="l44.829">     }</span>
<a href="#l44.830"></a><span id="l44.830"> </span>
<a href="#l44.831"></a><span id="l44.831"> finish:</span>
<a href="#l44.832"></a><span id="l44.832" class="difflineminus">-    free_processing_ctx(&amp;ctx);</span>
<a href="#l44.833"></a><span id="l44.833">     free(readbuf);</span>
<a href="#l44.834"></a><span id="l44.834">     return res;</span>
<a href="#l44.835"></a><span id="l44.835"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-parse.h</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-parse.h</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineat">@@ -36,17 +36,17 @@</span>
<a href="#l45.4"></a><span id="l45.4"> </span>
<a href="#l45.5"></a><span id="l45.5"> typedef struct pgp_parse_handler_t  pgp_parse_handler_t;</span>
<a href="#l45.6"></a><span id="l45.6"> typedef struct pgp_signature_info_t pgp_signature_info_t;</span>
<a href="#l45.7"></a><span id="l45.7"> typedef bool                        pgp_destination_func_t(pgp_parse_handler_t *handler,</span>
<a href="#l45.8"></a><span id="l45.8">                                                            pgp_dest_t **        dst,</span>
<a href="#l45.9"></a><span id="l45.9">                                                            bool *               closedst,</span>
<a href="#l45.10"></a><span id="l45.10">                                                            const char *         filename);</span>
<a href="#l45.11"></a><span id="l45.11"> typedef bool pgp_source_func_t(pgp_parse_handler_t *handler, pgp_source_t *src);</span>
<a href="#l45.12"></a><span id="l45.12" class="difflineminus">-typedef void pgp_signatures_func_t(pgp_signature_info_t *sigs, int count, void *param);</span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+typedef void pgp_signatures_func_t(const std::vector&lt;pgp_signature_info_t&gt; &amp;sigs, void *param);</span>
<a href="#l45.14"></a><span id="l45.14"> </span>
<a href="#l45.15"></a><span id="l45.15"> typedef void pgp_on_recipients_func_t(const std::vector&lt;pgp_pk_sesskey_t&gt; &amp;recipients,</span>
<a href="#l45.16"></a><span id="l45.16">                                       const std::vector&lt;pgp_sk_sesskey_t&gt; &amp;passwords,</span>
<a href="#l45.17"></a><span id="l45.17">                                       void *                               param);</span>
<a href="#l45.18"></a><span id="l45.18"> typedef void pgp_decryption_start_func_t(pgp_pk_sesskey_t *pubenc,</span>
<a href="#l45.19"></a><span id="l45.19">                                          pgp_sk_sesskey_t *symenc,</span>
<a href="#l45.20"></a><span id="l45.20">                                          void *            param);</span>
<a href="#l45.21"></a><span id="l45.21"> typedef void pgp_decryption_info_func_t(bool           mdc,</span>
<a href="#l45.22"></a><span id="l45.22" class="difflineat">@@ -76,17 +76,17 @@ typedef struct pgp_parse_handler_t {</span>
<a href="#l45.23"></a><span id="l45.23"> </span>
<a href="#l45.24"></a><span id="l45.24"> /* @brief Process the OpenPGP source: file, memory, stdin</span>
<a href="#l45.25"></a><span id="l45.25">  * Function will parse input data, provided by any source conforming to pgp_source_t,</span>
<a href="#l45.26"></a><span id="l45.26">  * autodetecting whether it is armored, cleartext or binary.</span>
<a href="#l45.27"></a><span id="l45.27">  * @param handler handler to respond on stream reader callbacks</span>
<a href="#l45.28"></a><span id="l45.28">  * @param src initialized source with cache</span>
<a href="#l45.29"></a><span id="l45.29">  * @return RNP_SUCCESS on success or error code otherwise</span>
<a href="#l45.30"></a><span id="l45.30">  **/</span>
<a href="#l45.31"></a><span id="l45.31" class="difflineminus">-rnp_result_t process_pgp_source(pgp_parse_handler_t *handler, pgp_source_t *src);</span>
<a href="#l45.32"></a><span id="l45.32" class="difflineplus">+rnp_result_t process_pgp_source(pgp_parse_handler_t *handler, pgp_source_t &amp;src);</span>
<a href="#l45.33"></a><span id="l45.33"> </span>
<a href="#l45.34"></a><span id="l45.34"> /* @brief Init source with OpenPGP compressed data packet</span>
<a href="#l45.35"></a><span id="l45.35">  * @param src allocated pgp_source_t structure</span>
<a href="#l45.36"></a><span id="l45.36">  * @param readsrc source to read compressed data from</span>
<a href="#l45.37"></a><span id="l45.37">  * @return RNP_SUCCESS on success or error code otherwise</span>
<a href="#l45.38"></a><span id="l45.38">  */</span>
<a href="#l45.39"></a><span id="l45.39"> rnp_result_t init_compressed_src(pgp_source_t *src, pgp_source_t *readsrc);</span>
<a href="#l45.40"></a><span id="l45.40"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-sig.cpp</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-sig.cpp</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineat">@@ -24,40 +24,40 @@</span>
<a href="#l46.4"></a><span id="l46.4">  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l46.5"></a><span id="l46.5">  */</span>
<a href="#l46.6"></a><span id="l46.6"> </span>
<a href="#l46.7"></a><span id="l46.7"> #include &quot;config.h&quot;</span>
<a href="#l46.8"></a><span id="l46.8"> #include &lt;stdlib.h&gt;</span>
<a href="#l46.9"></a><span id="l46.9"> #include &lt;stdio.h&gt;</span>
<a href="#l46.10"></a><span id="l46.10"> #include &lt;unistd.h&gt;</span>
<a href="#l46.11"></a><span id="l46.11"> #include &lt;string.h&gt;</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineplus">+#include &lt;type_traits&gt;</span>
<a href="#l46.13"></a><span id="l46.13"> #include &lt;rnp/rnp_def.h&gt;</span>
<a href="#l46.14"></a><span id="l46.14"> #include &quot;types.h&quot;</span>
<a href="#l46.15"></a><span id="l46.15"> #include &quot;stream-sig.h&quot;</span>
<a href="#l46.16"></a><span id="l46.16"> #include &quot;stream-packet.h&quot;</span>
<a href="#l46.17"></a><span id="l46.17"> #include &quot;stream-armor.h&quot;</span>
<a href="#l46.18"></a><span id="l46.18"> #include &quot;pgp-key.h&quot;</span>
<a href="#l46.19"></a><span id="l46.19"> #include &quot;crypto/signatures.h&quot;</span>
<a href="#l46.20"></a><span id="l46.20"> </span>
<a href="#l46.21"></a><span id="l46.21"> #include &lt;time.h&gt;</span>
<a href="#l46.22"></a><span id="l46.22"> </span>
<a href="#l46.23"></a><span id="l46.23"> bool</span>
<a href="#l46.24"></a><span id="l46.24"> signature_matches_onepass(pgp_signature_t *sig, pgp_one_pass_sig_t *onepass)</span>
<a href="#l46.25"></a><span id="l46.25"> {</span>
<a href="#l46.26"></a><span id="l46.26" class="difflineminus">-    uint8_t keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l46.27"></a><span id="l46.27" class="difflineminus">-</span>
<a href="#l46.28"></a><span id="l46.28">     if (!sig || !onepass) {</span>
<a href="#l46.29"></a><span id="l46.29">         return false;</span>
<a href="#l46.30"></a><span id="l46.30">     }</span>
<a href="#l46.31"></a><span id="l46.31"> </span>
<a href="#l46.32"></a><span id="l46.32" class="difflineplus">+    pgp_key_id_t keyid = {};</span>
<a href="#l46.33"></a><span id="l46.33">     if (!signature_get_keyid(sig, keyid)) {</span>
<a href="#l46.34"></a><span id="l46.34">         return false;</span>
<a href="#l46.35"></a><span id="l46.35">     }</span>
<a href="#l46.36"></a><span id="l46.36"> </span>
<a href="#l46.37"></a><span id="l46.37" class="difflineminus">-    return !memcmp(keyid, onepass-&gt;keyid, PGP_KEY_ID_SIZE) &amp;&amp; (sig-&gt;halg == onepass-&gt;halg) &amp;&amp;</span>
<a href="#l46.38"></a><span id="l46.38" class="difflineplus">+    return (keyid == onepass-&gt;keyid) &amp;&amp; (sig-&gt;halg == onepass-&gt;halg) &amp;&amp;</span>
<a href="#l46.39"></a><span id="l46.39">            (sig-&gt;palg == onepass-&gt;palg) &amp;&amp; (sig-&gt;type == onepass-&gt;type);</span>
<a href="#l46.40"></a><span id="l46.40"> }</span>
<a href="#l46.41"></a><span id="l46.41"> </span>
<a href="#l46.42"></a><span id="l46.42"> pgp_sig_subpkt_t *</span>
<a href="#l46.43"></a><span id="l46.43"> signature_get_subpkt(const pgp_signature_t *sig, pgp_sig_subpacket_type_t type)</span>
<a href="#l46.44"></a><span id="l46.44"> {</span>
<a href="#l46.45"></a><span id="l46.45">     pgp_sig_subpkt_t *res = NULL;</span>
<a href="#l46.46"></a><span id="l46.46"> </span>
<a href="#l46.47"></a><span id="l46.47" class="difflineat">@@ -130,56 +130,56 @@ signature_get_type(const pgp_signature_t</span>
<a href="#l46.48"></a><span id="l46.48"> </span>
<a href="#l46.49"></a><span id="l46.49"> bool</span>
<a href="#l46.50"></a><span id="l46.50"> signature_has_keyfp(const pgp_signature_t *sig)</span>
<a href="#l46.51"></a><span id="l46.51"> {</span>
<a href="#l46.52"></a><span id="l46.52">     return signature_get_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_FPR);</span>
<a href="#l46.53"></a><span id="l46.53"> }</span>
<a href="#l46.54"></a><span id="l46.54"> </span>
<a href="#l46.55"></a><span id="l46.55"> bool</span>
<a href="#l46.56"></a><span id="l46.56" class="difflineminus">-signature_get_keyfp(const pgp_signature_t *sig, pgp_fingerprint_t *fp)</span>
<a href="#l46.57"></a><span id="l46.57" class="difflineplus">+signature_get_keyfp(const pgp_signature_t *sig, pgp_fingerprint_t &amp;fp)</span>
<a href="#l46.58"></a><span id="l46.58"> {</span>
<a href="#l46.59"></a><span id="l46.59">     pgp_sig_subpkt_t *subpkt;</span>
<a href="#l46.60"></a><span id="l46.60"> </span>
<a href="#l46.61"></a><span id="l46.61" class="difflineminus">-    if (!sig || !fp || (sig-&gt;version &lt; PGP_V4)) {</span>
<a href="#l46.62"></a><span id="l46.62" class="difflineplus">+    if (!sig || (sig-&gt;version &lt; PGP_V4)) {</span>
<a href="#l46.63"></a><span id="l46.63">         return false;</span>
<a href="#l46.64"></a><span id="l46.64">     }</span>
<a href="#l46.65"></a><span id="l46.65"> </span>
<a href="#l46.66"></a><span id="l46.66" class="difflineminus">-    fp-&gt;length = 0;</span>
<a href="#l46.67"></a><span id="l46.67" class="difflineplus">+    fp.length = 0;</span>
<a href="#l46.68"></a><span id="l46.68">     if (!(subpkt = signature_get_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_FPR))) {</span>
<a href="#l46.69"></a><span id="l46.69">         return false;</span>
<a href="#l46.70"></a><span id="l46.70">     }</span>
<a href="#l46.71"></a><span id="l46.71" class="difflineminus">-    fp-&gt;length = subpkt-&gt;fields.issuer_fp.len;</span>
<a href="#l46.72"></a><span id="l46.72" class="difflineminus">-    if (subpkt-&gt;fields.issuer_fp.len &lt;= sizeof(fp-&gt;fingerprint)) {</span>
<a href="#l46.73"></a><span id="l46.73" class="difflineminus">-        memcpy(fp-&gt;fingerprint, subpkt-&gt;fields.issuer_fp.fp, subpkt-&gt;fields.issuer_fp.len);</span>
<a href="#l46.74"></a><span id="l46.74" class="difflineplus">+    fp.length = subpkt-&gt;fields.issuer_fp.len;</span>
<a href="#l46.75"></a><span id="l46.75" class="difflineplus">+    if (subpkt-&gt;fields.issuer_fp.len &lt;= sizeof(fp.fingerprint)) {</span>
<a href="#l46.76"></a><span id="l46.76" class="difflineplus">+        memcpy(fp.fingerprint, subpkt-&gt;fields.issuer_fp.fp, subpkt-&gt;fields.issuer_fp.len);</span>
<a href="#l46.77"></a><span id="l46.77">         return true;</span>
<a href="#l46.78"></a><span id="l46.78">     }</span>
<a href="#l46.79"></a><span id="l46.79"> </span>
<a href="#l46.80"></a><span id="l46.80">     return false;</span>
<a href="#l46.81"></a><span id="l46.81"> }</span>
<a href="#l46.82"></a><span id="l46.82"> </span>
<a href="#l46.83"></a><span id="l46.83"> bool</span>
<a href="#l46.84"></a><span id="l46.84" class="difflineminus">-signature_set_keyfp(pgp_signature_t *sig, const pgp_fingerprint_t *fp)</span>
<a href="#l46.85"></a><span id="l46.85" class="difflineplus">+signature_set_keyfp(pgp_signature_t *sig, const pgp_fingerprint_t &amp;fp)</span>
<a href="#l46.86"></a><span id="l46.86"> {</span>
<a href="#l46.87"></a><span id="l46.87">     pgp_sig_subpkt_t *subpkt = NULL;</span>
<a href="#l46.88"></a><span id="l46.88"> </span>
<a href="#l46.89"></a><span id="l46.89" class="difflineminus">-    if (!sig || !fp) {</span>
<a href="#l46.90"></a><span id="l46.90" class="difflineplus">+    if (!sig) {</span>
<a href="#l46.91"></a><span id="l46.91">         return false;</span>
<a href="#l46.92"></a><span id="l46.92">     }</span>
<a href="#l46.93"></a><span id="l46.93"> </span>
<a href="#l46.94"></a><span id="l46.94" class="difflineminus">-    subpkt = signature_add_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_FPR, 1 + fp-&gt;length, true);</span>
<a href="#l46.95"></a><span id="l46.95" class="difflineplus">+    subpkt = signature_add_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_FPR, 1 + fp.length, true);</span>
<a href="#l46.96"></a><span id="l46.96">     if (!subpkt) {</span>
<a href="#l46.97"></a><span id="l46.97">         return false;</span>
<a href="#l46.98"></a><span id="l46.98">     }</span>
<a href="#l46.99"></a><span id="l46.99"> </span>
<a href="#l46.100"></a><span id="l46.100">     subpkt-&gt;parsed = 1;</span>
<a href="#l46.101"></a><span id="l46.101">     subpkt-&gt;hashed = 1;</span>
<a href="#l46.102"></a><span id="l46.102">     subpkt-&gt;data[0] = 4;</span>
<a href="#l46.103"></a><span id="l46.103" class="difflineminus">-    memcpy(subpkt-&gt;data + 1, fp-&gt;fingerprint, fp-&gt;length);</span>
<a href="#l46.104"></a><span id="l46.104" class="difflineminus">-    subpkt-&gt;fields.issuer_fp.len = fp-&gt;length;</span>
<a href="#l46.105"></a><span id="l46.105" class="difflineplus">+    memcpy(subpkt-&gt;data + 1, fp.fingerprint, fp.length);</span>
<a href="#l46.106"></a><span id="l46.106" class="difflineplus">+    subpkt-&gt;fields.issuer_fp.len = fp.length;</span>
<a href="#l46.107"></a><span id="l46.107">     subpkt-&gt;fields.issuer_fp.version = subpkt-&gt;data[0];</span>
<a href="#l46.108"></a><span id="l46.108">     subpkt-&gt;fields.issuer_fp.fp = subpkt-&gt;data + 1;</span>
<a href="#l46.109"></a><span id="l46.109">     return true;</span>
<a href="#l46.110"></a><span id="l46.110"> }</span>
<a href="#l46.111"></a><span id="l46.111"> </span>
<a href="#l46.112"></a><span id="l46.112"> bool</span>
<a href="#l46.113"></a><span id="l46.113"> signature_has_keyid(const pgp_signature_t *sig)</span>
<a href="#l46.114"></a><span id="l46.114"> {</span>
<a href="#l46.115"></a><span id="l46.115" class="difflineat">@@ -188,67 +188,71 @@ signature_has_keyid(const pgp_signature_</span>
<a href="#l46.116"></a><span id="l46.116">     }</span>
<a href="#l46.117"></a><span id="l46.117"> </span>
<a href="#l46.118"></a><span id="l46.118">     return (sig-&gt;version &lt; PGP_V4) ||</span>
<a href="#l46.119"></a><span id="l46.119">            signature_get_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_KEY_ID) ||</span>
<a href="#l46.120"></a><span id="l46.120">            signature_get_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_FPR);</span>
<a href="#l46.121"></a><span id="l46.121"> }</span>
<a href="#l46.122"></a><span id="l46.122"> </span>
<a href="#l46.123"></a><span id="l46.123"> bool</span>
<a href="#l46.124"></a><span id="l46.124" class="difflineminus">-signature_get_keyid(const pgp_signature_t *sig, uint8_t *id)</span>
<a href="#l46.125"></a><span id="l46.125" class="difflineplus">+signature_get_keyid(const pgp_signature_t *sig, pgp_key_id_t &amp;id)</span>
<a href="#l46.126"></a><span id="l46.126"> {</span>
<a href="#l46.127"></a><span id="l46.127" class="difflineminus">-    pgp_sig_subpkt_t *subpkt;</span>
<a href="#l46.128"></a><span id="l46.128" class="difflineminus">-</span>
<a href="#l46.129"></a><span id="l46.129" class="difflineminus">-    if (!sig || !id) {</span>
<a href="#l46.130"></a><span id="l46.130" class="difflineplus">+    if (!sig) {</span>
<a href="#l46.131"></a><span id="l46.131">         return false;</span>
<a href="#l46.132"></a><span id="l46.132">     }</span>
<a href="#l46.133"></a><span id="l46.133"> </span>
<a href="#l46.134"></a><span id="l46.134">     /* version 3 uses signature field */</span>
<a href="#l46.135"></a><span id="l46.135">     if (sig-&gt;version &lt; PGP_V4) {</span>
<a href="#l46.136"></a><span id="l46.136" class="difflineminus">-        memcpy(id, sig-&gt;signer, PGP_KEY_ID_SIZE);</span>
<a href="#l46.137"></a><span id="l46.137" class="difflineplus">+        id = sig-&gt;signer;</span>
<a href="#l46.138"></a><span id="l46.138">         return true;</span>
<a href="#l46.139"></a><span id="l46.139">     }</span>
<a href="#l46.140"></a><span id="l46.140"> </span>
<a href="#l46.141"></a><span id="l46.141">     /* version 4 and up use subpackets */</span>
<a href="#l46.142"></a><span id="l46.142" class="difflineplus">+    pgp_sig_subpkt_t *subpkt;</span>
<a href="#l46.143"></a><span id="l46.143" class="difflineplus">+    static_assert(std::tuple_size&lt;std::remove_reference&lt;decltype(id)&gt;::type&gt;::value ==</span>
<a href="#l46.144"></a><span id="l46.144" class="difflineplus">+                    PGP_KEY_ID_SIZE,</span>
<a href="#l46.145"></a><span id="l46.145" class="difflineplus">+                  &quot;pgp_key_id_t size mismatch&quot;);</span>
<a href="#l46.146"></a><span id="l46.146">     if ((subpkt = signature_get_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_KEY_ID))) {</span>
<a href="#l46.147"></a><span id="l46.147" class="difflineminus">-        memcpy(id, subpkt-&gt;fields.issuer, PGP_KEY_ID_SIZE);</span>
<a href="#l46.148"></a><span id="l46.148" class="difflineplus">+        memcpy(id.data(), subpkt-&gt;fields.issuer, PGP_KEY_ID_SIZE);</span>
<a href="#l46.149"></a><span id="l46.149">         return true;</span>
<a href="#l46.150"></a><span id="l46.150">     }</span>
<a href="#l46.151"></a><span id="l46.151">     if ((subpkt = signature_get_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_FPR))) {</span>
<a href="#l46.152"></a><span id="l46.152" class="difflineminus">-        memcpy(id,</span>
<a href="#l46.153"></a><span id="l46.153" class="difflineplus">+        memcpy(id.data(),</span>
<a href="#l46.154"></a><span id="l46.154">                subpkt-&gt;fields.issuer_fp.fp + subpkt-&gt;fields.issuer_fp.len - PGP_KEY_ID_SIZE,</span>
<a href="#l46.155"></a><span id="l46.155">                PGP_KEY_ID_SIZE);</span>
<a href="#l46.156"></a><span id="l46.156">         return true;</span>
<a href="#l46.157"></a><span id="l46.157">     }</span>
<a href="#l46.158"></a><span id="l46.158"> </span>
<a href="#l46.159"></a><span id="l46.159">     return false;</span>
<a href="#l46.160"></a><span id="l46.160"> }</span>
<a href="#l46.161"></a><span id="l46.161"> </span>
<a href="#l46.162"></a><span id="l46.162"> bool</span>
<a href="#l46.163"></a><span id="l46.163" class="difflineminus">-signature_set_keyid(pgp_signature_t *sig, const uint8_t *id)</span>
<a href="#l46.164"></a><span id="l46.164" class="difflineplus">+signature_set_keyid(pgp_signature_t *sig, const pgp_key_id_t &amp;id)</span>
<a href="#l46.165"></a><span id="l46.165"> {</span>
<a href="#l46.166"></a><span id="l46.166" class="difflineminus">-    pgp_sig_subpkt_t *subpkt;</span>
<a href="#l46.167"></a><span id="l46.167" class="difflineminus">-</span>
<a href="#l46.168"></a><span id="l46.168" class="difflineminus">-    if (!sig || !id) {</span>
<a href="#l46.169"></a><span id="l46.169" class="difflineplus">+    if (!sig) {</span>
<a href="#l46.170"></a><span id="l46.170">         return false;</span>
<a href="#l46.171"></a><span id="l46.171">     }</span>
<a href="#l46.172"></a><span id="l46.172"> </span>
<a href="#l46.173"></a><span id="l46.173">     if (sig-&gt;version &lt; PGP_V4) {</span>
<a href="#l46.174"></a><span id="l46.174" class="difflineminus">-        memcpy(sig-&gt;signer, id, PGP_KEY_ID_SIZE);</span>
<a href="#l46.175"></a><span id="l46.175" class="difflineplus">+        sig-&gt;signer = id;</span>
<a href="#l46.176"></a><span id="l46.176">         return true;</span>
<a href="#l46.177"></a><span id="l46.177">     }</span>
<a href="#l46.178"></a><span id="l46.178"> </span>
<a href="#l46.179"></a><span id="l46.179" class="difflineminus">-    subpkt = signature_add_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_KEY_ID, PGP_KEY_ID_SIZE, true);</span>
<a href="#l46.180"></a><span id="l46.180" class="difflineplus">+    static_assert(std::tuple_size&lt;std::remove_reference&lt;decltype(id)&gt;::type&gt;::value ==</span>
<a href="#l46.181"></a><span id="l46.181" class="difflineplus">+                    PGP_KEY_ID_SIZE,</span>
<a href="#l46.182"></a><span id="l46.182" class="difflineplus">+                  &quot;pgp_key_id_t size mismatch&quot;);</span>
<a href="#l46.183"></a><span id="l46.183" class="difflineplus">+    pgp_sig_subpkt_t *subpkt =</span>
<a href="#l46.184"></a><span id="l46.184" class="difflineplus">+      signature_add_subpkt(sig, PGP_SIG_SUBPKT_ISSUER_KEY_ID, PGP_KEY_ID_SIZE, true);</span>
<a href="#l46.185"></a><span id="l46.185">     if (!subpkt) {</span>
<a href="#l46.186"></a><span id="l46.186">         return false;</span>
<a href="#l46.187"></a><span id="l46.187">     }</span>
<a href="#l46.188"></a><span id="l46.188"> </span>
<a href="#l46.189"></a><span id="l46.189">     subpkt-&gt;parsed = 1;</span>
<a href="#l46.190"></a><span id="l46.190">     subpkt-&gt;hashed = 0;</span>
<a href="#l46.191"></a><span id="l46.191" class="difflineminus">-    memcpy(subpkt-&gt;data, id, PGP_KEY_ID_SIZE);</span>
<a href="#l46.192"></a><span id="l46.192" class="difflineplus">+    memcpy(subpkt-&gt;data, id.data(), PGP_KEY_ID_SIZE);</span>
<a href="#l46.193"></a><span id="l46.193">     subpkt-&gt;fields.issuer = subpkt-&gt;data;</span>
<a href="#l46.194"></a><span id="l46.194">     return true;</span>
<a href="#l46.195"></a><span id="l46.195"> }</span>
<a href="#l46.196"></a><span id="l46.196"> </span>
<a href="#l46.197"></a><span id="l46.197"> uint32_t</span>
<a href="#l46.198"></a><span id="l46.198"> signature_get_creation(const pgp_signature_t *sig)</span>
<a href="#l46.199"></a><span id="l46.199"> {</span>
<a href="#l46.200"></a><span id="l46.200">     pgp_sig_subpkt_t *subpkt;</span>
<a href="#l46.201"></a><span id="l46.201" class="difflineat">@@ -1065,25 +1069,24 @@ signature_check(pgp_signature_info_t *si</span>
<a href="#l46.202"></a><span id="l46.202">     /* check key creation time vs signature creation */</span>
<a href="#l46.203"></a><span id="l46.203">     kcreate = pgp_key_get_creation(sinfo-&gt;signer);</span>
<a href="#l46.204"></a><span id="l46.204">     if (kcreate &gt; create) {</span>
<a href="#l46.205"></a><span id="l46.205">         RNP_LOG(&quot;key is newer than signature&quot;);</span>
<a href="#l46.206"></a><span id="l46.206">         sinfo-&gt;valid = false;</span>
<a href="#l46.207"></a><span id="l46.207">     }</span>
<a href="#l46.208"></a><span id="l46.208"> </span>
<a href="#l46.209"></a><span id="l46.209">     /* check whether key was not expired when sig created */</span>
<a href="#l46.210"></a><span id="l46.210" class="difflineminus">-    if (pgp_key_get_expiration(sinfo-&gt;signer) &amp;&amp;</span>
<a href="#l46.211"></a><span id="l46.211" class="difflineplus">+    if (!sinfo-&gt;ignore_expiry &amp;&amp; pgp_key_get_expiration(sinfo-&gt;signer) &amp;&amp;</span>
<a href="#l46.212"></a><span id="l46.212">         (kcreate + pgp_key_get_expiration(sinfo-&gt;signer) &lt; create)) {</span>
<a href="#l46.213"></a><span id="l46.213">         RNP_LOG(&quot;signature made after key expiration&quot;);</span>
<a href="#l46.214"></a><span id="l46.214">         sinfo-&gt;valid = false;</span>
<a href="#l46.215"></a><span id="l46.215">     }</span>
<a href="#l46.216"></a><span id="l46.216"> </span>
<a href="#l46.217"></a><span id="l46.217">     /* Check signer's fingerprint */</span>
<a href="#l46.218"></a><span id="l46.218" class="difflineminus">-    if (signature_get_keyfp(sinfo-&gt;sig, &amp;fp) &amp;&amp;</span>
<a href="#l46.219"></a><span id="l46.219" class="difflineminus">-        !fingerprint_equal(&amp;fp, pgp_key_get_fp(sinfo-&gt;signer))) {</span>
<a href="#l46.220"></a><span id="l46.220" class="difflineplus">+    if (signature_get_keyfp(sinfo-&gt;sig, fp) &amp;&amp; (fp != pgp_key_get_fp(sinfo-&gt;signer))) {</span>
<a href="#l46.221"></a><span id="l46.221">         RNP_LOG(&quot;issuer fingerprint doesn't match signer's one&quot;);</span>
<a href="#l46.222"></a><span id="l46.222">         sinfo-&gt;valid = false;</span>
<a href="#l46.223"></a><span id="l46.223">     }</span>
<a href="#l46.224"></a><span id="l46.224"> </span>
<a href="#l46.225"></a><span id="l46.225">     if (sinfo-&gt;expired &amp;&amp; sinfo-&gt;valid) {</span>
<a href="#l46.226"></a><span id="l46.226">         ret = RNP_ERROR_SIGNATURE_EXPIRED;</span>
<a href="#l46.227"></a><span id="l46.227">     } else {</span>
<a href="#l46.228"></a><span id="l46.228">         ret = sinfo-&gt;valid ? RNP_SUCCESS : RNP_ERROR_SIGNATURE_INVALID;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-sig.h</span>
<a href="#l47.2"></a><span id="l47.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-sig.h</span>
<a href="#l47.3"></a><span id="l47.3" class="difflineat">@@ -36,17 +36,18 @@</span>
<a href="#l47.4"></a><span id="l47.4"> /* information about the validated signature */</span>
<a href="#l47.5"></a><span id="l47.5"> typedef struct pgp_signature_info_t {</span>
<a href="#l47.6"></a><span id="l47.6">     pgp_signature_t *sig;       /* signature, or NULL if there were parsing error */</span>
<a href="#l47.7"></a><span id="l47.7">     pgp_key_t *      signer;    /* signer's public key if found */</span>
<a href="#l47.8"></a><span id="l47.8">     bool             valid;     /* signature is cryptographically valid (but may be expired) */</span>
<a href="#l47.9"></a><span id="l47.9">     bool             unknown;   /* signature is unknown - parsing error, wrong version, etc */</span>
<a href="#l47.10"></a><span id="l47.10">     bool             no_signer; /* no signer's public key available */</span>
<a href="#l47.11"></a><span id="l47.11">     bool             expired;   /* signature is expired */</span>
<a href="#l47.12"></a><span id="l47.12" class="difflineminus">-    bool             signer_valid; /* assume that signing key is valid */</span>
<a href="#l47.13"></a><span id="l47.13" class="difflineplus">+    bool             signer_valid;  /* assume that signing key is valid */</span>
<a href="#l47.14"></a><span id="l47.14" class="difflineplus">+    bool             ignore_expiry; /* ignore signer's key expiration time */</span>
<a href="#l47.15"></a><span id="l47.15"> } pgp_signature_info_t;</span>
<a href="#l47.16"></a><span id="l47.16"> </span>
<a href="#l47.17"></a><span id="l47.17"> /**</span>
<a href="#l47.18"></a><span id="l47.18">  * @brief Check whether signature packet matches one-pass signature packet.</span>
<a href="#l47.19"></a><span id="l47.19">  * @param sig pointer to the read signature packet</span>
<a href="#l47.20"></a><span id="l47.20">  * @param onepass pointer to the read one-pass signature packet</span>
<a href="#l47.21"></a><span id="l47.21">  * @return true if sig corresponds to onepass or false otherwise</span>
<a href="#l47.22"></a><span id="l47.22">  */</span>
<a href="#l47.23"></a><span id="l47.23" class="difflineat">@@ -93,53 +94,51 @@ pgp_sig_type_t signature_get_type(const </span>
<a href="#l47.24"></a><span id="l47.24">  * @param sig loaded or populated v4 signature, could not be NULL</span>
<a href="#l47.25"></a><span id="l47.25">  * @return true if fingerprint is available or false otherwise</span>
<a href="#l47.26"></a><span id="l47.26">  */</span>
<a href="#l47.27"></a><span id="l47.27"> bool signature_has_keyfp(const pgp_signature_t *sig);</span>
<a href="#l47.28"></a><span id="l47.28"> </span>
<a href="#l47.29"></a><span id="l47.29"> /**</span>
<a href="#l47.30"></a><span id="l47.30">  * @brief Get signing key's fingerprint if it is available</span>
<a href="#l47.31"></a><span id="l47.31">  * @param sig loaded or populated v4 signature, could not be NULL</span>
<a href="#l47.32"></a><span id="l47.32" class="difflineminus">- * @param fp pointer to the buffer of at least PGP_FINGERPRINT_SIZE bytes</span>
<a href="#l47.33"></a><span id="l47.33" class="difflineminus">- * @param len number of bytes in buffer</span>
<a href="#l47.34"></a><span id="l47.34" class="difflineminus">- * @param outlen pointer to the number of bytes written to fp (if succeeded). Could not be 0.</span>
<a href="#l47.35"></a><span id="l47.35" class="difflineplus">+ * @param fp reference to the fingerprint structure</span>
<a href="#l47.36"></a><span id="l47.36">  * @return true if fingerprint is available and returned or false otherwise</span>
<a href="#l47.37"></a><span id="l47.37">  */</span>
<a href="#l47.38"></a><span id="l47.38" class="difflineminus">-bool signature_get_keyfp(const pgp_signature_t *sig, pgp_fingerprint_t *fp);</span>
<a href="#l47.39"></a><span id="l47.39" class="difflineplus">+bool signature_get_keyfp(const pgp_signature_t *sig, pgp_fingerprint_t &amp;fp);</span>
<a href="#l47.40"></a><span id="l47.40"> </span>
<a href="#l47.41"></a><span id="l47.41"> /**</span>
<a href="#l47.42"></a><span id="l47.42">  * @brief Set signing key fingerprint</span>
<a href="#l47.43"></a><span id="l47.43">  * @param sig v4 signature being populated</span>
<a href="#l47.44"></a><span id="l47.44">  * @param fp fingerprint structure</span>
<a href="#l47.45"></a><span id="l47.45">  * @return true on success or false otherwise;</span>
<a href="#l47.46"></a><span id="l47.46">  */</span>
<a href="#l47.47"></a><span id="l47.47" class="difflineminus">-bool signature_set_keyfp(pgp_signature_t *sig, const pgp_fingerprint_t *fp);</span>
<a href="#l47.48"></a><span id="l47.48" class="difflineplus">+bool signature_set_keyfp(pgp_signature_t *sig, const pgp_fingerprint_t &amp;fp);</span>
<a href="#l47.49"></a><span id="l47.49"> </span>
<a href="#l47.50"></a><span id="l47.50"> /**</span>
<a href="#l47.51"></a><span id="l47.51">  * @brief Check whether signature has signing key id</span>
<a href="#l47.52"></a><span id="l47.52">  * @param sig populated or loaded signature</span>
<a href="#l47.53"></a><span id="l47.53">  * @return true if key id available (via v3 field, or v4 key id/key fp subpacket)</span>
<a href="#l47.54"></a><span id="l47.54">  */</span>
<a href="#l47.55"></a><span id="l47.55"> bool signature_has_keyid(const pgp_signature_t *sig);</span>
<a href="#l47.56"></a><span id="l47.56"> </span>
<a href="#l47.57"></a><span id="l47.57"> /**</span>
<a href="#l47.58"></a><span id="l47.58">  * @brief Get signature's signing key id</span>
<a href="#l47.59"></a><span id="l47.59">  * @param sig populated or loaded signature</span>
<a href="#l47.60"></a><span id="l47.60" class="difflineminus">- * @param id buffer to return key identifier, must be capable of storing PGP_KEY_ID_SIZE bytes</span>
<a href="#l47.61"></a><span id="l47.61" class="difflineplus">+ * @param id reference to return key identifier</span>
<a href="#l47.62"></a><span id="l47.62">  * @return true on success or false otherwise</span>
<a href="#l47.63"></a><span id="l47.63">  */</span>
<a href="#l47.64"></a><span id="l47.64" class="difflineminus">-bool signature_get_keyid(const pgp_signature_t *sig, uint8_t *id);</span>
<a href="#l47.65"></a><span id="l47.65" class="difflineplus">+bool signature_get_keyid(const pgp_signature_t *sig, pgp_key_id_t &amp;id);</span>
<a href="#l47.66"></a><span id="l47.66"> </span>
<a href="#l47.67"></a><span id="l47.67"> /**</span>
<a href="#l47.68"></a><span id="l47.68">  * @brief Set the signature's key id</span>
<a href="#l47.69"></a><span id="l47.69">  * @param sig signature being populated. Version should be set prior of setting key id.</span>
<a href="#l47.70"></a><span id="l47.70" class="difflineminus">- * @param id pointer to buffer with PGP_KEY_ID_SIZE bytes of key id.</span>
<a href="#l47.71"></a><span id="l47.71" class="difflineplus">+ * @param id reference to key identifier</span>
<a href="#l47.72"></a><span id="l47.72">  * @return true on success or false otherwise</span>
<a href="#l47.73"></a><span id="l47.73">  */</span>
<a href="#l47.74"></a><span id="l47.74" class="difflineminus">-bool signature_set_keyid(pgp_signature_t *sig, const uint8_t *id);</span>
<a href="#l47.75"></a><span id="l47.75" class="difflineplus">+bool signature_set_keyid(pgp_signature_t *sig, const pgp_key_id_t &amp;id);</span>
<a href="#l47.76"></a><span id="l47.76"> </span>
<a href="#l47.77"></a><span id="l47.77"> /**</span>
<a href="#l47.78"></a><span id="l47.78">  * @brief Get signature's creation time</span>
<a href="#l47.79"></a><span id="l47.79">  * @param sig pointer to the loaded or populated signature.</span>
<a href="#l47.80"></a><span id="l47.80">  * @return time in seconds since the Jan 1, 1970 UTC. 0 is the default value and returned even</span>
<a href="#l47.81"></a><span id="l47.81">  *         if creation time is not available</span>
<a href="#l47.82"></a><span id="l47.82">  */</span>
<a href="#l47.83"></a><span id="l47.83"> uint32_t signature_get_creation(const pgp_signature_t *sig);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-write.cpp</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-write.cpp</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineat">@@ -103,22 +103,25 @@ typedef struct pgp_dest_signer_info_t {</span>
<a href="#l48.4"></a><span id="l48.4">     pgp_hash_alg_t     halg;</span>
<a href="#l48.5"></a><span id="l48.5">     int64_t            sigcreate;</span>
<a href="#l48.6"></a><span id="l48.6">     uint64_t           sigexpire;</span>
<a href="#l48.7"></a><span id="l48.7"> } pgp_dest_signer_info_t;</span>
<a href="#l48.8"></a><span id="l48.8"> </span>
<a href="#l48.9"></a><span id="l48.9"> typedef struct pgp_dest_signed_param_t {</span>
<a href="#l48.10"></a><span id="l48.10">     pgp_dest_t *             writedst; /* destination to write to */</span>
<a href="#l48.11"></a><span id="l48.11">     rnp_ctx_t *              ctx;      /* rnp operation context with additional parameters */</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineminus">-    pgp_password_provider_t *password_provider; /* password provider from write handler */</span>
<a href="#l48.13"></a><span id="l48.13" class="difflineminus">-    list                     siginfos;          /* list of  pgp_dest_signer_info_t */</span>
<a href="#l48.14"></a><span id="l48.14" class="difflineminus">-    list                     hashes;    /* hashes to pass raw data through and then sign */</span>
<a href="#l48.15"></a><span id="l48.15" class="difflineminus">-    bool                     clr_start; /* we are on the start of the line */</span>
<a href="#l48.16"></a><span id="l48.16" class="difflineminus">-    uint8_t                  clr_buf[CT_BUF_LEN]; /* buffer to hold partial line data */</span>
<a href="#l48.17"></a><span id="l48.17" class="difflineminus">-    size_t                   clr_buflen;          /* number of bytes in buffer */</span>
<a href="#l48.18"></a><span id="l48.18" class="difflineplus">+    pgp_password_provider_t *password_provider;   /* password provider from write handler */</span>
<a href="#l48.19"></a><span id="l48.19" class="difflineplus">+    std::vector&lt;pgp_dest_signer_info_t&gt; siginfos; /* list of  pgp_dest_signer_info_t */</span>
<a href="#l48.20"></a><span id="l48.20" class="difflineplus">+    std::vector&lt;pgp_hash_t&gt; hashes;    /* hashes to pass raw data through and then sign */</span>
<a href="#l48.21"></a><span id="l48.21" class="difflineplus">+    bool                    clr_start; /* we are on the start of the line */</span>
<a href="#l48.22"></a><span id="l48.22" class="difflineplus">+    uint8_t                 clr_buf[CT_BUF_LEN]; /* buffer to hold partial line data */</span>
<a href="#l48.23"></a><span id="l48.23" class="difflineplus">+    size_t                  clr_buflen;          /* number of bytes in buffer */</span>
<a href="#l48.24"></a><span id="l48.24" class="difflineplus">+</span>
<a href="#l48.25"></a><span id="l48.25" class="difflineplus">+    pgp_dest_signed_param_t() = default;</span>
<a href="#l48.26"></a><span id="l48.26" class="difflineplus">+    ~pgp_dest_signed_param_t();</span>
<a href="#l48.27"></a><span id="l48.27"> } pgp_dest_signed_param_t;</span>
<a href="#l48.28"></a><span id="l48.28"> </span>
<a href="#l48.29"></a><span id="l48.29"> typedef struct pgp_dest_partial_param_t {</span>
<a href="#l48.30"></a><span id="l48.30">     pgp_dest_t *writedst;</span>
<a href="#l48.31"></a><span id="l48.31">     uint8_t     part[PGP_PARTIAL_PKT_BLOCK_SIZE];</span>
<a href="#l48.32"></a><span id="l48.32">     uint8_t     parthdr; /* header byte for the current part */</span>
<a href="#l48.33"></a><span id="l48.33">     size_t      partlen; /* length of the current part, up to PARTIAL_PKT_BLOCK_SIZE */</span>
<a href="#l48.34"></a><span id="l48.34">     size_t      len;     /* bytes cached in part */</span>
<a href="#l48.35"></a><span id="l48.35" class="difflineat">@@ -509,17 +512,17 @@ encrypted_add_recipient(pgp_write_handle</span>
<a href="#l48.36"></a><span id="l48.36">     if (!userkey-&gt;valid) {</span>
<a href="#l48.37"></a><span id="l48.37">         RNP_LOG(&quot;attempt to use invalid key as recipient&quot;);</span>
<a href="#l48.38"></a><span id="l48.38">         return RNP_ERROR_NO_SUITABLE_KEY;</span>
<a href="#l48.39"></a><span id="l48.39">     }</span>
<a href="#l48.40"></a><span id="l48.40"> </span>
<a href="#l48.41"></a><span id="l48.41">     /* Fill pkey */</span>
<a href="#l48.42"></a><span id="l48.42">     pkey.version = PGP_PKSK_V3;</span>
<a href="#l48.43"></a><span id="l48.43">     pkey.alg = pgp_key_get_alg(userkey);</span>
<a href="#l48.44"></a><span id="l48.44" class="difflineminus">-    memcpy(pkey.key_id, pgp_key_get_keyid(userkey), PGP_KEY_ID_SIZE);</span>
<a href="#l48.45"></a><span id="l48.45" class="difflineplus">+    pkey.key_id = pgp_key_get_keyid(userkey);</span>
<a href="#l48.46"></a><span id="l48.46"> </span>
<a href="#l48.47"></a><span id="l48.47">     /* Encrypt the session key */</span>
<a href="#l48.48"></a><span id="l48.48">     enckey[0] = param-&gt;ctx-&gt;ealg;</span>
<a href="#l48.49"></a><span id="l48.49">     memcpy(&amp;enckey[1], key, keylen);</span>
<a href="#l48.50"></a><span id="l48.50"> </span>
<a href="#l48.51"></a><span id="l48.51">     /* Calculate checksum */</span>
<a href="#l48.52"></a><span id="l48.52">     for (unsigned i = 1; i &lt;= keylen; i++) {</span>
<a href="#l48.53"></a><span id="l48.53">         checksum += enckey[i];</span>
<a href="#l48.54"></a><span id="l48.54" class="difflineat">@@ -1135,37 +1138,35 @@ signed_write_signature(pgp_dest_signed_p</span>
<a href="#l48.55"></a><span id="l48.55"> </span>
<a href="#l48.56"></a><span id="l48.56"> static rnp_result_t</span>
<a href="#l48.57"></a><span id="l48.57"> signed_dst_finish(pgp_dest_t *dst)</span>
<a href="#l48.58"></a><span id="l48.58"> {</span>
<a href="#l48.59"></a><span id="l48.59">     rnp_result_t             ret;</span>
<a href="#l48.60"></a><span id="l48.60">     pgp_dest_signed_param_t *param = (pgp_dest_signed_param_t *) dst-&gt;param;</span>
<a href="#l48.61"></a><span id="l48.61"> </span>
<a href="#l48.62"></a><span id="l48.62">     /* attached signature, we keep onepasses in order of signatures */</span>
<a href="#l48.63"></a><span id="l48.63" class="difflineminus">-    for (list_item *sinfo = list_front(param-&gt;siginfos); sinfo; sinfo = list_next(sinfo)) {</span>
<a href="#l48.64"></a><span id="l48.64" class="difflineminus">-        if ((ret = signed_write_signature(</span>
<a href="#l48.65"></a><span id="l48.65" class="difflineminus">-               param, (pgp_dest_signer_info_t *) sinfo, param-&gt;writedst))) {</span>
<a href="#l48.66"></a><span id="l48.66" class="difflineplus">+    for (auto &amp;sinfo : param-&gt;siginfos) {</span>
<a href="#l48.67"></a><span id="l48.67" class="difflineplus">+        if ((ret = signed_write_signature(param, &amp;sinfo, param-&gt;writedst))) {</span>
<a href="#l48.68"></a><span id="l48.68">             RNP_LOG(&quot;failed to calculate signature&quot;);</span>
<a href="#l48.69"></a><span id="l48.69">             return ret;</span>
<a href="#l48.70"></a><span id="l48.70">         }</span>
<a href="#l48.71"></a><span id="l48.71">     }</span>
<a href="#l48.72"></a><span id="l48.72"> </span>
<a href="#l48.73"></a><span id="l48.73">     return RNP_SUCCESS;</span>
<a href="#l48.74"></a><span id="l48.74"> }</span>
<a href="#l48.75"></a><span id="l48.75"> </span>
<a href="#l48.76"></a><span id="l48.76"> static rnp_result_t</span>
<a href="#l48.77"></a><span id="l48.77"> signed_detached_dst_finish(pgp_dest_t *dst)</span>
<a href="#l48.78"></a><span id="l48.78"> {</span>
<a href="#l48.79"></a><span id="l48.79">     rnp_result_t             ret;</span>
<a href="#l48.80"></a><span id="l48.80">     pgp_dest_signed_param_t *param = (pgp_dest_signed_param_t *) dst-&gt;param;</span>
<a href="#l48.81"></a><span id="l48.81"> </span>
<a href="#l48.82"></a><span id="l48.82">     /* just calculating and writing signatures to the output */</span>
<a href="#l48.83"></a><span id="l48.83" class="difflineminus">-    for (list_item *sinfo = list_front(param-&gt;siginfos); sinfo; sinfo = list_next(sinfo)) {</span>
<a href="#l48.84"></a><span id="l48.84" class="difflineminus">-        if ((ret = signed_write_signature(</span>
<a href="#l48.85"></a><span id="l48.85" class="difflineminus">-               param, (pgp_dest_signer_info_t *) sinfo, param-&gt;writedst))) {</span>
<a href="#l48.86"></a><span id="l48.86" class="difflineplus">+    for (auto &amp;sinfo : param-&gt;siginfos) {</span>
<a href="#l48.87"></a><span id="l48.87" class="difflineplus">+        if ((ret = signed_write_signature(param, &amp;sinfo, param-&gt;writedst))) {</span>
<a href="#l48.88"></a><span id="l48.88">             RNP_LOG(&quot;failed to calculate detached signature&quot;);</span>
<a href="#l48.89"></a><span id="l48.89">             return ret;</span>
<a href="#l48.90"></a><span id="l48.90">         }</span>
<a href="#l48.91"></a><span id="l48.91">     }</span>
<a href="#l48.92"></a><span id="l48.92"> </span>
<a href="#l48.93"></a><span id="l48.93">     return RNP_SUCCESS;</span>
<a href="#l48.94"></a><span id="l48.94"> }</span>
<a href="#l48.95"></a><span id="l48.95"> </span>
<a href="#l48.96"></a><span id="l48.96" class="difflineat">@@ -1183,43 +1184,38 @@ cleartext_dst_finish(pgp_dest_t *dst)</span>
<a href="#l48.97"></a><span id="l48.97">     /* trailing \r\n which is not hashed */</span>
<a href="#l48.98"></a><span id="l48.98">     dst_write(param-&gt;writedst, ST_CRLF, 2);</span>
<a href="#l48.99"></a><span id="l48.99"> </span>
<a href="#l48.100"></a><span id="l48.100">     /* writing signatures to the armored stream, which outputs to param-&gt;writedst */</span>
<a href="#l48.101"></a><span id="l48.101">     if ((ret = init_armored_dst(&amp;armordst, param-&gt;writedst, PGP_ARMORED_SIGNATURE))) {</span>
<a href="#l48.102"></a><span id="l48.102">         return ret;</span>
<a href="#l48.103"></a><span id="l48.103">     }</span>
<a href="#l48.104"></a><span id="l48.104"> </span>
<a href="#l48.105"></a><span id="l48.105" class="difflineminus">-    for (list_item *sinfo = list_front(param-&gt;siginfos); sinfo; sinfo = list_next(sinfo)) {</span>
<a href="#l48.106"></a><span id="l48.106" class="difflineminus">-        if ((ret =</span>
<a href="#l48.107"></a><span id="l48.107" class="difflineminus">-               signed_write_signature(param, (pgp_dest_signer_info_t *) sinfo, &amp;armordst))) {</span>
<a href="#l48.108"></a><span id="l48.108" class="difflineplus">+    for (auto &amp;sinfo : param-&gt;siginfos) {</span>
<a href="#l48.109"></a><span id="l48.109" class="difflineplus">+        if ((ret = signed_write_signature(param, &amp;sinfo, &amp;armordst))) {</span>
<a href="#l48.110"></a><span id="l48.110">             break;</span>
<a href="#l48.111"></a><span id="l48.111">         }</span>
<a href="#l48.112"></a><span id="l48.112">     }</span>
<a href="#l48.113"></a><span id="l48.113"> </span>
<a href="#l48.114"></a><span id="l48.114">     if (ret == RNP_SUCCESS) {</span>
<a href="#l48.115"></a><span id="l48.115">         ret = dst_finish(&amp;armordst);</span>
<a href="#l48.116"></a><span id="l48.116">     }</span>
<a href="#l48.117"></a><span id="l48.117"> </span>
<a href="#l48.118"></a><span id="l48.118">     dst_close(&amp;armordst, ret != RNP_SUCCESS);</span>
<a href="#l48.119"></a><span id="l48.119">     return ret;</span>
<a href="#l48.120"></a><span id="l48.120"> }</span>
<a href="#l48.121"></a><span id="l48.121"> </span>
<a href="#l48.122"></a><span id="l48.122"> static void</span>
<a href="#l48.123"></a><span id="l48.123"> signed_dst_close(pgp_dest_t *dst, bool discard)</span>
<a href="#l48.124"></a><span id="l48.124"> {</span>
<a href="#l48.125"></a><span id="l48.125">     pgp_dest_signed_param_t *param = (pgp_dest_signed_param_t *) dst-&gt;param;</span>
<a href="#l48.126"></a><span id="l48.126" class="difflineminus">-</span>
<a href="#l48.127"></a><span id="l48.127">     if (!param) {</span>
<a href="#l48.128"></a><span id="l48.128">         return;</span>
<a href="#l48.129"></a><span id="l48.129">     }</span>
<a href="#l48.130"></a><span id="l48.130" class="difflineminus">-</span>
<a href="#l48.131"></a><span id="l48.131" class="difflineminus">-    pgp_hash_list_free(&amp;param-&gt;hashes);</span>
<a href="#l48.132"></a><span id="l48.132" class="difflineminus">-    list_destroy(&amp;param-&gt;siginfos);</span>
<a href="#l48.133"></a><span id="l48.133" class="difflineminus">-    free(param);</span>
<a href="#l48.134"></a><span id="l48.134" class="difflineplus">+    delete param;</span>
<a href="#l48.135"></a><span id="l48.135">     dst-&gt;param = NULL;</span>
<a href="#l48.136"></a><span id="l48.136"> }</span>
<a href="#l48.137"></a><span id="l48.137"> </span>
<a href="#l48.138"></a><span id="l48.138"> static void</span>
<a href="#l48.139"></a><span id="l48.139"> signed_dst_update(pgp_dest_t *dst, const void *buf, size_t len)</span>
<a href="#l48.140"></a><span id="l48.140"> {</span>
<a href="#l48.141"></a><span id="l48.141">     pgp_dest_signed_param_t *param = (pgp_dest_signed_param_t *) dst-&gt;param;</span>
<a href="#l48.142"></a><span id="l48.142">     pgp_hash_list_update(param-&gt;hashes, buf, len);</span>
<a href="#l48.143"></a><span id="l48.143" class="difflineat">@@ -1237,70 +1233,90 @@ signed_add_signer(pgp_dest_signed_param_</span>
<a href="#l48.144"></a><span id="l48.144"> </span>
<a href="#l48.145"></a><span id="l48.145">     /* copy fields */</span>
<a href="#l48.146"></a><span id="l48.146">     sinfo.key = signer-&gt;key;</span>
<a href="#l48.147"></a><span id="l48.147">     sinfo.sigcreate = signer-&gt;sigcreate;</span>
<a href="#l48.148"></a><span id="l48.148">     sinfo.sigexpire = signer-&gt;sigexpire;</span>
<a href="#l48.149"></a><span id="l48.149"> </span>
<a href="#l48.150"></a><span id="l48.150">     /* Add hash to the list */</span>
<a href="#l48.151"></a><span id="l48.151">     sinfo.halg = pgp_hash_adjust_alg_to_key(signer-&gt;halg, pgp_key_get_pkt(signer-&gt;key));</span>
<a href="#l48.152"></a><span id="l48.152" class="difflineminus">-    if (!pgp_hash_list_add(&amp;param-&gt;hashes, sinfo.halg)) {</span>
<a href="#l48.153"></a><span id="l48.153" class="difflineplus">+    if (!pgp_hash_list_add(param-&gt;hashes, sinfo.halg)) {</span>
<a href="#l48.154"></a><span id="l48.154">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l48.155"></a><span id="l48.155">     }</span>
<a href="#l48.156"></a><span id="l48.156"> </span>
<a href="#l48.157"></a><span id="l48.157">     // Do not add onepass for detached/clearsign</span>
<a href="#l48.158"></a><span id="l48.158">     if (param-&gt;ctx-&gt;detached || param-&gt;ctx-&gt;clearsign) {</span>
<a href="#l48.159"></a><span id="l48.159">         sinfo.onepass.version = 0;</span>
<a href="#l48.160"></a><span id="l48.160" class="difflineminus">-        return list_append(&amp;param-&gt;siginfos, &amp;sinfo, sizeof(sinfo)) ? RNP_SUCCESS :</span>
<a href="#l48.161"></a><span id="l48.161" class="difflineminus">-                                                                      RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l48.162"></a><span id="l48.162" class="difflineplus">+        try {</span>
<a href="#l48.163"></a><span id="l48.163" class="difflineplus">+            param-&gt;siginfos.push_back(sinfo);</span>
<a href="#l48.164"></a><span id="l48.164" class="difflineplus">+            return RNP_SUCCESS;</span>
<a href="#l48.165"></a><span id="l48.165" class="difflineplus">+        } catch (const std::exception &amp;e) {</span>
<a href="#l48.166"></a><span id="l48.166" class="difflineplus">+            RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l48.167"></a><span id="l48.167" class="difflineplus">+            return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l48.168"></a><span id="l48.168" class="difflineplus">+        }</span>
<a href="#l48.169"></a><span id="l48.169">     }</span>
<a href="#l48.170"></a><span id="l48.170"> </span>
<a href="#l48.171"></a><span id="l48.171">     // Setup and add onepass</span>
<a href="#l48.172"></a><span id="l48.172">     sinfo.onepass.version = 3;</span>
<a href="#l48.173"></a><span id="l48.173">     sinfo.onepass.type = PGP_SIG_BINARY;</span>
<a href="#l48.174"></a><span id="l48.174">     sinfo.onepass.halg = sinfo.halg;</span>
<a href="#l48.175"></a><span id="l48.175">     sinfo.onepass.palg = pgp_key_get_alg(sinfo.key);</span>
<a href="#l48.176"></a><span id="l48.176" class="difflineminus">-    memcpy(sinfo.onepass.keyid, pgp_key_get_keyid(sinfo.key), PGP_KEY_ID_SIZE);</span>
<a href="#l48.177"></a><span id="l48.177" class="difflineplus">+    sinfo.onepass.keyid = pgp_key_get_keyid(sinfo.key);</span>
<a href="#l48.178"></a><span id="l48.178">     sinfo.onepass.nested = false;</span>
<a href="#l48.179"></a><span id="l48.179" class="difflineminus">-    if (!list_append(&amp;param-&gt;siginfos, &amp;sinfo, sizeof(sinfo))) {</span>
<a href="#l48.180"></a><span id="l48.180" class="difflineplus">+    try {</span>
<a href="#l48.181"></a><span id="l48.181" class="difflineplus">+        param-&gt;siginfos.push_back(sinfo);</span>
<a href="#l48.182"></a><span id="l48.182" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l48.183"></a><span id="l48.183" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l48.184"></a><span id="l48.184">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l48.185"></a><span id="l48.185">     }</span>
<a href="#l48.186"></a><span id="l48.186"> </span>
<a href="#l48.187"></a><span id="l48.187">     // write onepasses in reverse order so signature order will match signers list</span>
<a href="#l48.188"></a><span id="l48.188">     if (last) {</span>
<a href="#l48.189"></a><span id="l48.189" class="difflineminus">-        for (list_item *si = list_back(param-&gt;siginfos); si; si = list_prev(si)) {</span>
<a href="#l48.190"></a><span id="l48.190" class="difflineminus">-            pgp_dest_signer_info_t *sinfo = (pgp_dest_signer_info_t *) si;</span>
<a href="#l48.191"></a><span id="l48.191" class="difflineminus">-            sinfo-&gt;onepass.nested = !list_prev(si);</span>
<a href="#l48.192"></a><span id="l48.192" class="difflineminus">-</span>
<a href="#l48.193"></a><span id="l48.193" class="difflineminus">-            if (!stream_write_one_pass(&amp;sinfo-&gt;onepass, param-&gt;writedst)) {</span>
<a href="#l48.194"></a><span id="l48.194" class="difflineplus">+        for (auto it = param-&gt;siginfos.rbegin(); it != param-&gt;siginfos.rend(); it++) {</span>
<a href="#l48.195"></a><span id="l48.195" class="difflineplus">+            pgp_dest_signer_info_t &amp;sinfo = *it;</span>
<a href="#l48.196"></a><span id="l48.196" class="difflineplus">+            sinfo.onepass.nested = &amp;sinfo == &amp;param-&gt;siginfos.front();</span>
<a href="#l48.197"></a><span id="l48.197" class="difflineplus">+            if (!stream_write_one_pass(&amp;sinfo.onepass, param-&gt;writedst)) {</span>
<a href="#l48.198"></a><span id="l48.198">                 return RNP_ERROR_WRITE;</span>
<a href="#l48.199"></a><span id="l48.199">             }</span>
<a href="#l48.200"></a><span id="l48.200">         }</span>
<a href="#l48.201"></a><span id="l48.201">     }</span>
<a href="#l48.202"></a><span id="l48.202"> </span>
<a href="#l48.203"></a><span id="l48.203">     return RNP_SUCCESS;</span>
<a href="#l48.204"></a><span id="l48.204"> }</span>
<a href="#l48.205"></a><span id="l48.205"> </span>
<a href="#l48.206"></a><span id="l48.206" class="difflineplus">+pgp_dest_signed_param_t::~pgp_dest_signed_param_t()</span>
<a href="#l48.207"></a><span id="l48.207" class="difflineplus">+{</span>
<a href="#l48.208"></a><span id="l48.208" class="difflineplus">+    for (auto &amp;hash : hashes) {</span>
<a href="#l48.209"></a><span id="l48.209" class="difflineplus">+        pgp_hash_finish(&amp;hash, NULL);</span>
<a href="#l48.210"></a><span id="l48.210" class="difflineplus">+    }</span>
<a href="#l48.211"></a><span id="l48.211" class="difflineplus">+}</span>
<a href="#l48.212"></a><span id="l48.212" class="difflineplus">+</span>
<a href="#l48.213"></a><span id="l48.213"> static rnp_result_t</span>
<a href="#l48.214"></a><span id="l48.214"> init_signed_dst(pgp_write_handler_t *handler, pgp_dest_t *dst, pgp_dest_t *writedst)</span>
<a href="#l48.215"></a><span id="l48.215"> {</span>
<a href="#l48.216"></a><span id="l48.216">     pgp_dest_signed_param_t *param;</span>
<a href="#l48.217"></a><span id="l48.217">     rnp_result_t             ret = RNP_ERROR_GENERIC;</span>
<a href="#l48.218"></a><span id="l48.218">     const char *             hname;</span>
<a href="#l48.219"></a><span id="l48.219"> </span>
<a href="#l48.220"></a><span id="l48.220">     if (!handler-&gt;key_provider) {</span>
<a href="#l48.221"></a><span id="l48.221">         RNP_LOG(&quot;no key provider&quot;);</span>
<a href="#l48.222"></a><span id="l48.222">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l48.223"></a><span id="l48.223">     }</span>
<a href="#l48.224"></a><span id="l48.224"> </span>
<a href="#l48.225"></a><span id="l48.225" class="difflineminus">-    if (!init_dst_common(dst, sizeof(*param))) {</span>
<a href="#l48.226"></a><span id="l48.226" class="difflineplus">+    if (!init_dst_common(dst, 0)) {</span>
<a href="#l48.227"></a><span id="l48.227" class="difflineplus">+        return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l48.228"></a><span id="l48.228" class="difflineplus">+    }</span>
<a href="#l48.229"></a><span id="l48.229" class="difflineplus">+    try {</span>
<a href="#l48.230"></a><span id="l48.230" class="difflineplus">+        param = new pgp_dest_signed_param_t();</span>
<a href="#l48.231"></a><span id="l48.231" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l48.232"></a><span id="l48.232" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l48.233"></a><span id="l48.233">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l48.234"></a><span id="l48.234">     }</span>
<a href="#l48.235"></a><span id="l48.235"> </span>
<a href="#l48.236"></a><span id="l48.236" class="difflineminus">-    param = (pgp_dest_signed_param_t *) dst-&gt;param;</span>
<a href="#l48.237"></a><span id="l48.237" class="difflineplus">+    dst-&gt;param = param;</span>
<a href="#l48.238"></a><span id="l48.238">     param-&gt;writedst = writedst;</span>
<a href="#l48.239"></a><span id="l48.239">     param-&gt;ctx = handler-&gt;ctx;</span>
<a href="#l48.240"></a><span id="l48.240">     param-&gt;password_provider = handler-&gt;password_provider;</span>
<a href="#l48.241"></a><span id="l48.241">     if (param-&gt;ctx-&gt;clearsign) {</span>
<a href="#l48.242"></a><span id="l48.242">         dst-&gt;type = PGP_STREAM_CLEARTEXT;</span>
<a href="#l48.243"></a><span id="l48.243">         dst-&gt;write = cleartext_dst_write;</span>
<a href="#l48.244"></a><span id="l48.244">         dst-&gt;finish = cleartext_dst_finish;</span>
<a href="#l48.245"></a><span id="l48.245">         param-&gt;clr_start = true;</span>
<a href="#l48.246"></a><span id="l48.246" class="difflineat">@@ -1316,31 +1332,31 @@ init_signed_dst(pgp_write_handler_t *han</span>
<a href="#l48.247"></a><span id="l48.247">         ret = signed_add_signer(param, (rnp_signer_info_t *) sg, !list_next(sg));</span>
<a href="#l48.248"></a><span id="l48.248">         if (ret) {</span>
<a href="#l48.249"></a><span id="l48.249">             RNP_LOG(&quot;failed to add one-pass signature for signer&quot;);</span>
<a href="#l48.250"></a><span id="l48.250">             goto finish;</span>
<a href="#l48.251"></a><span id="l48.251">         }</span>
<a href="#l48.252"></a><span id="l48.252">     }</span>
<a href="#l48.253"></a><span id="l48.253"> </span>
<a href="#l48.254"></a><span id="l48.254">     /* Do we have any signatures? */</span>
<a href="#l48.255"></a><span id="l48.255" class="difflineminus">-    if (!list_length(param-&gt;hashes)) {</span>
<a href="#l48.256"></a><span id="l48.256" class="difflineplus">+    if (param-&gt;hashes.empty()) {</span>
<a href="#l48.257"></a><span id="l48.257">         ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l48.258"></a><span id="l48.258">         goto finish;</span>
<a href="#l48.259"></a><span id="l48.259">     }</span>
<a href="#l48.260"></a><span id="l48.260"> </span>
<a href="#l48.261"></a><span id="l48.261">     /* Writing headers for cleartext signed document */</span>
<a href="#l48.262"></a><span id="l48.262">     if (param-&gt;ctx-&gt;clearsign) {</span>
<a href="#l48.263"></a><span id="l48.263">         dst_write(param-&gt;writedst, ST_CLEAR_BEGIN, strlen(ST_CLEAR_BEGIN));</span>
<a href="#l48.264"></a><span id="l48.264">         dst_write(param-&gt;writedst, ST_CRLF, strlen(ST_CRLF));</span>
<a href="#l48.265"></a><span id="l48.265">         dst_write(param-&gt;writedst, ST_HEADER_HASH, strlen(ST_HEADER_HASH));</span>
<a href="#l48.266"></a><span id="l48.266"> </span>
<a href="#l48.267"></a><span id="l48.267" class="difflineminus">-        for (list_item *hash = list_front(param-&gt;hashes); hash; hash = list_next(hash)) {</span>
<a href="#l48.268"></a><span id="l48.268" class="difflineminus">-            hname = pgp_hash_name((pgp_hash_t *) hash);</span>
<a href="#l48.269"></a><span id="l48.269" class="difflineplus">+        for (const auto &amp;hash : param-&gt;hashes) {</span>
<a href="#l48.270"></a><span id="l48.270" class="difflineplus">+            hname = pgp_hash_name(&amp;hash);</span>
<a href="#l48.271"></a><span id="l48.271">             dst_write(param-&gt;writedst, hname, strlen(hname));</span>
<a href="#l48.272"></a><span id="l48.272" class="difflineminus">-            if (hash != list_back(param-&gt;hashes)) {</span>
<a href="#l48.273"></a><span id="l48.273" class="difflineplus">+            if (&amp;hash != &amp;param-&gt;hashes.back()) {</span>
<a href="#l48.274"></a><span id="l48.274">                 dst_write(param-&gt;writedst, ST_COMMA, 1);</span>
<a href="#l48.275"></a><span id="l48.275">             }</span>
<a href="#l48.276"></a><span id="l48.276">         }</span>
<a href="#l48.277"></a><span id="l48.277"> </span>
<a href="#l48.278"></a><span id="l48.278">         dst_write(param-&gt;writedst, ST_CRLFCRLF, strlen(ST_CRLFCRLF));</span>
<a href="#l48.279"></a><span id="l48.279">     }</span>
<a href="#l48.280"></a><span id="l48.280"> </span>
<a href="#l48.281"></a><span id="l48.281">     ret = RNP_SUCCESS;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1" class="difflineminus">--- a/third_party/rnp/src/rnp/CMakeLists.txt</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineplus">+++ b/third_party/rnp/src/rnp/CMakeLists.txt</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineat">@@ -20,17 +20,23 @@</span>
<a href="#l49.4"></a><span id="l49.4"> # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l49.5"></a><span id="l49.5"> # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l49.6"></a><span id="l49.6"> # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l49.7"></a><span id="l49.7"> # POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l49.8"></a><span id="l49.8"> </span>
<a href="#l49.9"></a><span id="l49.9"> # for the headers</span>
<a href="#l49.10"></a><span id="l49.10"> find_package(JSON-C 0.11 REQUIRED)</span>
<a href="#l49.11"></a><span id="l49.11"> </span>
<a href="#l49.12"></a><span id="l49.12" class="difflineminus">-add_executable(rnp rnp.cpp fficli.cpp ../rnpkeys/tui.cpp rnpcfg.cpp)</span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+add_executable(rnp</span>
<a href="#l49.14"></a><span id="l49.14" class="difflineplus">+  rnp.cpp</span>
<a href="#l49.15"></a><span id="l49.15" class="difflineplus">+  fficli.cpp</span>
<a href="#l49.16"></a><span id="l49.16" class="difflineplus">+  ../rnpkeys/tui.cpp</span>
<a href="#l49.17"></a><span id="l49.17" class="difflineplus">+  rnpcfg.cpp</span>
<a href="#l49.18"></a><span id="l49.18" class="difflineplus">+  $&lt;TARGET_OBJECTS:rnp-common&gt;</span>
<a href="#l49.19"></a><span id="l49.19" class="difflineplus">+)</span>
<a href="#l49.20"></a><span id="l49.20"> </span>
<a href="#l49.21"></a><span id="l49.21"> target_include_directories(rnp</span>
<a href="#l49.22"></a><span id="l49.22">   PRIVATE</span>
<a href="#l49.23"></a><span id="l49.23">     &quot;${PROJECT_SOURCE_DIR}/src&quot;</span>
<a href="#l49.24"></a><span id="l49.24">     &quot;${PROJECT_SOURCE_DIR}/src/lib&quot;</span>
<a href="#l49.25"></a><span id="l49.25">     &quot;${JSON-C_INCLUDE_DIRS}&quot;</span>
<a href="#l49.26"></a><span id="l49.26"> )</span>
<a href="#l49.27"></a><span id="l49.27"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1" class="difflineminus">--- a/third_party/rnp/src/rnp/fficli.cpp</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineplus">+++ b/third_party/rnp/src/rnp/fficli.cpp</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineat">@@ -42,16 +42,18 @@</span>
<a href="#l50.4"></a><span id="l50.4"> #include &lt;termios.h&gt;</span>
<a href="#l50.5"></a><span id="l50.5"> #include &lt;sys/resource.h&gt;</span>
<a href="#l50.6"></a><span id="l50.6"> #endif</span>
<a href="#l50.7"></a><span id="l50.7"> </span>
<a href="#l50.8"></a><span id="l50.8"> #include &lt;time.h&gt;</span>
<a href="#l50.9"></a><span id="l50.9"> #include &quot;config.h&quot;</span>
<a href="#l50.10"></a><span id="l50.10"> #include &quot;fficli.h&quot;</span>
<a href="#l50.11"></a><span id="l50.11"> #include &quot;utils.h&quot;</span>
<a href="#l50.12"></a><span id="l50.12" class="difflineplus">+#include &quot;str-utils.h&quot;</span>
<a href="#l50.13"></a><span id="l50.13" class="difflineplus">+#include &quot;file-utils.h&quot;</span>
<a href="#l50.14"></a><span id="l50.14"> </span>
<a href="#l50.15"></a><span id="l50.15"> // must be placed after include &quot;utils.h&quot;</span>
<a href="#l50.16"></a><span id="l50.16"> #ifndef RNP_USE_STD_REGEX</span>
<a href="#l50.17"></a><span id="l50.17"> #include &lt;regex.h&gt;</span>
<a href="#l50.18"></a><span id="l50.18"> #else</span>
<a href="#l50.19"></a><span id="l50.19"> #include &lt;regex&gt;</span>
<a href="#l50.20"></a><span id="l50.20"> #endif</span>
<a href="#l50.21"></a><span id="l50.21"> </span>
<a href="#l50.22"></a><span id="l50.22" class="difflineat">@@ -1255,28 +1257,28 @@ bool</span>
<a href="#l50.23"></a><span id="l50.23"> cli_rnp_keys_matching_string(cli_rnp_t *                    rnp,</span>
<a href="#l50.24"></a><span id="l50.24">                              std::vector&lt;rnp_key_handle_t&gt; &amp;keys,</span>
<a href="#l50.25"></a><span id="l50.25">                              const std::string &amp;            str,</span>
<a href="#l50.26"></a><span id="l50.26">                              int                            flags)</span>
<a href="#l50.27"></a><span id="l50.27"> {</span>
<a href="#l50.28"></a><span id="l50.28">     bool                      res = false;</span>
<a href="#l50.29"></a><span id="l50.29">     rnp_identifier_iterator_t it = NULL;</span>
<a href="#l50.30"></a><span id="l50.30">     rnp_key_handle_t          handle = NULL;</span>
<a href="#l50.31"></a><span id="l50.31" class="difflineminus">-    const char *              grip = NULL;</span>
<a href="#l50.32"></a><span id="l50.32" class="difflineplus">+    const char *              fp = NULL;</span>
<a href="#l50.33"></a><span id="l50.33"> </span>
<a href="#l50.34"></a><span id="l50.34">     /* iterate through the keys */</span>
<a href="#l50.35"></a><span id="l50.35" class="difflineminus">-    if (rnp_identifier_iterator_create(rnp-&gt;ffi, &amp;it, &quot;grip&quot;)) {</span>
<a href="#l50.36"></a><span id="l50.36" class="difflineplus">+    if (rnp_identifier_iterator_create(rnp-&gt;ffi, &amp;it, &quot;fingerprint&quot;)) {</span>
<a href="#l50.37"></a><span id="l50.37">         return false;</span>
<a href="#l50.38"></a><span id="l50.38">     }</span>
<a href="#l50.39"></a><span id="l50.39"> </span>
<a href="#l50.40"></a><span id="l50.40" class="difflineminus">-    while (!rnp_identifier_iterator_next(it, &amp;grip)) {</span>
<a href="#l50.41"></a><span id="l50.41" class="difflineminus">-        if (!grip) {</span>
<a href="#l50.42"></a><span id="l50.42" class="difflineplus">+    while (!rnp_identifier_iterator_next(it, &amp;fp)) {</span>
<a href="#l50.43"></a><span id="l50.43" class="difflineplus">+        if (!fp) {</span>
<a href="#l50.44"></a><span id="l50.44">             break;</span>
<a href="#l50.45"></a><span id="l50.45">         }</span>
<a href="#l50.46"></a><span id="l50.46" class="difflineminus">-        if (rnp_locate_key(rnp-&gt;ffi, &quot;grip&quot;, grip, &amp;handle) || !handle) {</span>
<a href="#l50.47"></a><span id="l50.47" class="difflineplus">+        if (rnp_locate_key(rnp-&gt;ffi, &quot;fingerprint&quot;, fp, &amp;handle) || !handle) {</span>
<a href="#l50.48"></a><span id="l50.48">             goto done;</span>
<a href="#l50.49"></a><span id="l50.49">         }</span>
<a href="#l50.50"></a><span id="l50.50">         if (!key_matches_flags(handle, flags) || !key_matches_string(handle, str.c_str())) {</span>
<a href="#l50.51"></a><span id="l50.51">             rnp_key_handle_destroy(handle);</span>
<a href="#l50.52"></a><span id="l50.52">             continue;</span>
<a href="#l50.53"></a><span id="l50.53">         }</span>
<a href="#l50.54"></a><span id="l50.54">         if (!add_key_to_array(rnp-&gt;ffi, keys, handle, flags)) {</span>
<a href="#l50.55"></a><span id="l50.55">             rnp_key_handle_destroy(handle);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l51.1"></a><span id="l51.1" class="difflineminus">--- a/third_party/rnp/src/rnp/rnpcfg.cpp</span>
<a href="#l51.2"></a><span id="l51.2" class="difflineplus">+++ b/third_party/rnp/src/rnp/rnpcfg.cpp</span>
<a href="#l51.3"></a><span id="l51.3" class="difflineat">@@ -1,10 +1,10 @@</span>
<a href="#l51.4"></a><span id="l51.4"> /*</span>
<a href="#l51.5"></a><span id="l51.5" class="difflineminus">- * Copyright (c) 2017, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l51.6"></a><span id="l51.6" class="difflineplus">+ * Copyright (c) 2017-2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l51.7"></a><span id="l51.7">  * All rights reserved.</span>
<a href="#l51.8"></a><span id="l51.8">  *</span>
<a href="#l51.9"></a><span id="l51.9">  * Redistribution and use in source and binary forms, with or without</span>
<a href="#l51.10"></a><span id="l51.10">  * modification, are permitted provided that the following conditions</span>
<a href="#l51.11"></a><span id="l51.11">  * are met:</span>
<a href="#l51.12"></a><span id="l51.12">  * 1. Redistributions of source code must retain the above copyright</span>
<a href="#l51.13"></a><span id="l51.13">  *    notice, this list of conditions and the following disclaimer.</span>
<a href="#l51.14"></a><span id="l51.14">  * 2. Redistributions in binary form must reproduce the above copyright</span>
<a href="#l51.15"></a><span id="l51.15" class="difflineat">@@ -463,17 +463,17 @@ fail:</span>
<a href="#l51.16"></a><span id="l51.16"> }</span>
<a href="#l51.17"></a><span id="l51.17"> </span>
<a href="#l51.18"></a><span id="l51.18"> void</span>
<a href="#l51.19"></a><span id="l51.19"> rnp_cfg_free(rnp_cfg_t *cfg)</span>
<a href="#l51.20"></a><span id="l51.20"> {</span>
<a href="#l51.21"></a><span id="l51.21">     const char *passwd = rnp_cfg_getstr(cfg, CFG_PASSWD);</span>
<a href="#l51.22"></a><span id="l51.22"> </span>
<a href="#l51.23"></a><span id="l51.23">     if (passwd) {</span>
<a href="#l51.24"></a><span id="l51.24" class="difflineminus">-        pgp_forget((void *) passwd, strlen(passwd) + 1);</span>
<a href="#l51.25"></a><span id="l51.25" class="difflineplus">+        rnp_buffer_clear((void *) passwd, strlen(passwd) + 1);</span>
<a href="#l51.26"></a><span id="l51.26">     }</span>
<a href="#l51.27"></a><span id="l51.27"> </span>
<a href="#l51.28"></a><span id="l51.28">     for (list_item *li = list_front(cfg-&gt;vals); li; li = list_next(li)) {</span>
<a href="#l51.29"></a><span id="l51.29">         rnp_cfg_item_free((rnp_cfg_item_t *) li);</span>
<a href="#l51.30"></a><span id="l51.30">     }</span>
<a href="#l51.31"></a><span id="l51.31"> </span>
<a href="#l51.32"></a><span id="l51.32">     list_destroy(&amp;cfg-&gt;vals);</span>
<a href="#l51.33"></a><span id="l51.33"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l52.1"></a><span id="l52.1" class="difflineminus">--- a/third_party/rnp/src/rnpkeys/CMakeLists.txt</span>
<a href="#l52.2"></a><span id="l52.2" class="difflineplus">+++ b/third_party/rnp/src/rnpkeys/CMakeLists.txt</span>
<a href="#l52.3"></a><span id="l52.3" class="difflineat">@@ -26,16 +26,17 @@</span>
<a href="#l52.4"></a><span id="l52.4"> find_package(JSON-C 0.11 REQUIRED)</span>
<a href="#l52.5"></a><span id="l52.5"> </span>
<a href="#l52.6"></a><span id="l52.6"> add_executable(rnpkeys</span>
<a href="#l52.7"></a><span id="l52.7">   rnpkeys.cpp</span>
<a href="#l52.8"></a><span id="l52.8">   tui.cpp</span>
<a href="#l52.9"></a><span id="l52.9">   main.cpp</span>
<a href="#l52.10"></a><span id="l52.10">   ../rnp/rnpcfg.cpp</span>
<a href="#l52.11"></a><span id="l52.11">   ../rnp/fficli.cpp</span>
<a href="#l52.12"></a><span id="l52.12" class="difflineplus">+  $&lt;TARGET_OBJECTS:rnp-common&gt;</span>
<a href="#l52.13"></a><span id="l52.13"> )</span>
<a href="#l52.14"></a><span id="l52.14"> </span>
<a href="#l52.15"></a><span id="l52.15"> target_include_directories(rnpkeys</span>
<a href="#l52.16"></a><span id="l52.16">   PRIVATE</span>
<a href="#l52.17"></a><span id="l52.17">     &quot;${PROJECT_SOURCE_DIR}/src&quot;</span>
<a href="#l52.18"></a><span id="l52.18">     &quot;${PROJECT_SOURCE_DIR}/src/lib&quot;</span>
<a href="#l52.19"></a><span id="l52.19">     &quot;${JSON-C_INCLUDE_DIRS}&quot;</span>
<a href="#l52.20"></a><span id="l52.20"> )</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l53.1"></a><span id="l53.1" class="difflineminus">--- a/third_party/rnp/src/rnpkeys/tui.cpp</span>
<a href="#l53.2"></a><span id="l53.2" class="difflineplus">+++ b/third_party/rnp/src/rnpkeys/tui.cpp</span>
<a href="#l53.3"></a><span id="l53.3" class="difflineat">@@ -1,8 +1,35 @@</span>
<a href="#l53.4"></a><span id="l53.4" class="difflineplus">+/*</span>
<a href="#l53.5"></a><span id="l53.5" class="difflineplus">+ * Copyright (c) 2017-2020, [Ribose Inc](https://www.ribose.com).</span>
<a href="#l53.6"></a><span id="l53.6" class="difflineplus">+ * All rights reserved.</span>
<a href="#l53.7"></a><span id="l53.7" class="difflineplus">+ *</span>
<a href="#l53.8"></a><span id="l53.8" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l53.9"></a><span id="l53.9" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l53.10"></a><span id="l53.10" class="difflineplus">+ *</span>
<a href="#l53.11"></a><span id="l53.11" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l53.12"></a><span id="l53.12" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l53.13"></a><span id="l53.13" class="difflineplus">+ *</span>
<a href="#l53.14"></a><span id="l53.14" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l53.15"></a><span id="l53.15" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l53.16"></a><span id="l53.16" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l53.17"></a><span id="l53.17" class="difflineplus">+ *</span>
<a href="#l53.18"></a><span id="l53.18" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l53.19"></a><span id="l53.19" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l53.20"></a><span id="l53.20" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l53.21"></a><span id="l53.21" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l53.22"></a><span id="l53.22" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l53.23"></a><span id="l53.23" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l53.24"></a><span id="l53.24" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l53.25"></a><span id="l53.25" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l53.26"></a><span id="l53.26" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l53.27"></a><span id="l53.27" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l53.28"></a><span id="l53.28" class="difflineplus">+ */</span>
<a href="#l53.29"></a><span id="l53.29" class="difflineplus">+</span>
<a href="#l53.30"></a><span id="l53.30" class="difflineplus">+#include &lt;algorithm&gt;</span>
<a href="#l53.31"></a><span id="l53.31"> #include &lt;unistd.h&gt;</span>
<a href="#l53.32"></a><span id="l53.32"> #include &lt;errno.h&gt;</span>
<a href="#l53.33"></a><span id="l53.33"> #include &quot;rnp/rnpcfg.h&quot;</span>
<a href="#l53.34"></a><span id="l53.34"> #include &quot;rnpkeys.h&quot;</span>
<a href="#l53.35"></a><span id="l53.35"> #include &quot;defaults.h&quot;</span>
<a href="#l53.36"></a><span id="l53.36"> #include &quot;utils.h&quot;</span>
<a href="#l53.37"></a><span id="l53.37"> </span>
<a href="#l53.38"></a><span id="l53.38"> /* -----------------------------------------------------------------------------</span>
<a href="#l53.39"></a><span id="l53.39" class="difflineat">@@ -58,44 +85,58 @@ static bool</span>
<a href="#l53.40"></a><span id="l53.40"> is_rsa_keysize_supported(uint32_t keysize)</span>
<a href="#l53.41"></a><span id="l53.41"> {</span>
<a href="#l53.42"></a><span id="l53.42">     return ((keysize &gt;= 1024) &amp;&amp; (keysize &lt;= 4096) &amp;&amp; !(keysize % 8));</span>
<a href="#l53.43"></a><span id="l53.43"> }</span>
<a href="#l53.44"></a><span id="l53.44"> </span>
<a href="#l53.45"></a><span id="l53.45"> static const char *</span>
<a href="#l53.46"></a><span id="l53.46"> ask_curve_name(FILE *input_fp)</span>
<a href="#l53.47"></a><span id="l53.47"> {</span>
<a href="#l53.48"></a><span id="l53.48" class="difflineminus">-    pgp_curve_t       result = PGP_CURVE_MAX;</span>
<a href="#l53.49"></a><span id="l53.49" class="difflineminus">-    long              val = 0;</span>
<a href="#l53.50"></a><span id="l53.50" class="difflineminus">-    bool              ok = false;</span>
<a href="#l53.51"></a><span id="l53.51" class="difflineminus">-    const pgp_curve_t curves[] = {PGP_CURVE_NIST_P_256,</span>
<a href="#l53.52"></a><span id="l53.52" class="difflineminus">-                                  PGP_CURVE_NIST_P_384,</span>
<a href="#l53.53"></a><span id="l53.53" class="difflineminus">-                                  PGP_CURVE_NIST_P_521,</span>
<a href="#l53.54"></a><span id="l53.54" class="difflineminus">-                                  PGP_CURVE_BP256,</span>
<a href="#l53.55"></a><span id="l53.55" class="difflineminus">-                                  PGP_CURVE_BP384,</span>
<a href="#l53.56"></a><span id="l53.56" class="difflineminus">-                                  PGP_CURVE_BP512,</span>
<a href="#l53.57"></a><span id="l53.57" class="difflineminus">-                                  PGP_CURVE_P256K1};</span>
<a href="#l53.58"></a><span id="l53.58" class="difflineminus">-    size_t            ccount = ARRAY_SIZE(curves);</span>
<a href="#l53.59"></a><span id="l53.59" class="difflineplus">+    const char *              result = NULL;</span>
<a href="#l53.60"></a><span id="l53.60" class="difflineplus">+    long                      val = 0;</span>
<a href="#l53.61"></a><span id="l53.61" class="difflineplus">+    bool                      ok = false;</span>
<a href="#l53.62"></a><span id="l53.62" class="difflineplus">+    std::vector&lt;const char *&gt; curves;</span>
<a href="#l53.63"></a><span id="l53.63" class="difflineplus">+    static const char *const  known_curves[] = {</span>
<a href="#l53.64"></a><span id="l53.64" class="difflineplus">+      &quot;NIST P-256&quot;,</span>
<a href="#l53.65"></a><span id="l53.65" class="difflineplus">+      &quot;NIST P-384&quot;,</span>
<a href="#l53.66"></a><span id="l53.66" class="difflineplus">+      &quot;NIST P-521&quot;,</span>
<a href="#l53.67"></a><span id="l53.67" class="difflineplus">+      &quot;brainpoolP256r1&quot;,</span>
<a href="#l53.68"></a><span id="l53.68" class="difflineplus">+      &quot;brainpoolP384r1&quot;,</span>
<a href="#l53.69"></a><span id="l53.69" class="difflineplus">+      &quot;brainpoolP512r1&quot;,</span>
<a href="#l53.70"></a><span id="l53.70" class="difflineplus">+      &quot;secp256k1&quot;,</span>
<a href="#l53.71"></a><span id="l53.71" class="difflineplus">+    };</span>
<a href="#l53.72"></a><span id="l53.72"> </span>
<a href="#l53.73"></a><span id="l53.73" class="difflineplus">+    try {</span>
<a href="#l53.74"></a><span id="l53.74" class="difflineplus">+        std::copy_if(known_curves,</span>
<a href="#l53.75"></a><span id="l53.75" class="difflineplus">+                     known_curves + ARRAY_SIZE(known_curves),</span>
<a href="#l53.76"></a><span id="l53.76" class="difflineplus">+                     std::back_inserter(curves),</span>
<a href="#l53.77"></a><span id="l53.77" class="difflineplus">+                     [](const char *curve) {</span>
<a href="#l53.78"></a><span id="l53.78" class="difflineplus">+                         bool supported = false;</span>
<a href="#l53.79"></a><span id="l53.79" class="difflineplus">+                         return !rnp_supports_feature(&quot;elliptic curve&quot;, curve, &amp;supported) &amp;&amp;</span>
<a href="#l53.80"></a><span id="l53.80" class="difflineplus">+                                supported;</span>
<a href="#l53.81"></a><span id="l53.81" class="difflineplus">+                     });</span>
<a href="#l53.82"></a><span id="l53.82" class="difflineplus">+    } catch (const std::exception &amp;e) {</span>
<a href="#l53.83"></a><span id="l53.83" class="difflineplus">+        RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l53.84"></a><span id="l53.84" class="difflineplus">+        return NULL;</span>
<a href="#l53.85"></a><span id="l53.85" class="difflineplus">+    }</span>
<a href="#l53.86"></a><span id="l53.86" class="difflineplus">+    const size_t ccount = curves.size();</span>
<a href="#l53.87"></a><span id="l53.87">     do {</span>
<a href="#l53.88"></a><span id="l53.88">         printf(&quot;Please select which elliptic curve you want:\n&quot;);</span>
<a href="#l53.89"></a><span id="l53.89" class="difflineminus">-        for (size_t i = 1; i &lt;= ccount; i++) {</span>
<a href="#l53.90"></a><span id="l53.90" class="difflineminus">-            printf(</span>
<a href="#l53.91"></a><span id="l53.91" class="difflineminus">-              &quot;\t(%zu) %s\n&quot;, i, get_curve_desc((const pgp_curve_t)(curves[i - 1]))-&gt;pgp_name);</span>
<a href="#l53.92"></a><span id="l53.92" class="difflineplus">+        for (size_t i = 0; i &lt; ccount; i++) {</span>
<a href="#l53.93"></a><span id="l53.93" class="difflineplus">+            printf(&quot;\t(%zu) %s\n&quot;, i + 1, curves[i]);</span>
<a href="#l53.94"></a><span id="l53.94">         }</span>
<a href="#l53.95"></a><span id="l53.95" class="difflineminus">-        printf(&quot;(default %s)&gt; &quot;, get_curve_desc(DEFAULT_CURVE)-&gt;pgp_name);</span>
<a href="#l53.96"></a><span id="l53.96" class="difflineminus">-        result = DEFAULT_CURVE;</span>
<a href="#l53.97"></a><span id="l53.97" class="difflineplus">+        printf(&quot;(default %s)&gt; &quot;, DEFAULT_CURVE);</span>
<a href="#l53.98"></a><span id="l53.98">         ok = rnp_secure_get_long_from_fd(input_fp, &amp;val, true) &amp;&amp; (val &gt; 0) &amp;&amp;</span>
<a href="#l53.99"></a><span id="l53.99">              (val &lt;= (long) ccount);</span>
<a href="#l53.100"></a><span id="l53.100">         if (ok) {</span>
<a href="#l53.101"></a><span id="l53.101">             result = curves[val - 1];</span>
<a href="#l53.102"></a><span id="l53.102">         }</span>
<a href="#l53.103"></a><span id="l53.103">     } while (!ok);</span>
<a href="#l53.104"></a><span id="l53.104"> </span>
<a href="#l53.105"></a><span id="l53.105" class="difflineminus">-    return get_curve_desc(result)-&gt;pgp_name;</span>
<a href="#l53.106"></a><span id="l53.106" class="difflineplus">+    return result;</span>
<a href="#l53.107"></a><span id="l53.107"> }</span>
<a href="#l53.108"></a><span id="l53.108"> </span>
<a href="#l53.109"></a><span id="l53.109"> static long</span>
<a href="#l53.110"></a><span id="l53.110"> ask_rsa_bitlen(FILE *input_fp)</span>
<a href="#l53.111"></a><span id="l53.111"> {</span>
<a href="#l53.112"></a><span id="l53.112">     long result = 0;</span>
<a href="#l53.113"></a><span id="l53.113">     do {</span>
<a href="#l53.114"></a><span id="l53.114">         result = DEFAULT_RSA_NUMBITS;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l54.1"></a><span id="l54.1" class="difflineminus">--- a/third_party/rnp/src/tests/CMakeLists.txt</span>
<a href="#l54.2"></a><span id="l54.2" class="difflineplus">+++ b/third_party/rnp/src/tests/CMakeLists.txt</span>
<a href="#l54.3"></a><span id="l54.3" class="difflineat">@@ -17,27 +17,30 @@</span>
<a href="#l54.4"></a><span id="l54.4"> # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<a href="#l54.5"></a><span id="l54.5"> # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a href="#l54.6"></a><span id="l54.6"> # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a href="#l54.7"></a><span id="l54.7"> # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l54.8"></a><span id="l54.8"> # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l54.9"></a><span id="l54.9"> # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l54.10"></a><span id="l54.10"> # POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l54.11"></a><span id="l54.11"> </span>
<a href="#l54.12"></a><span id="l54.12" class="difflineminus">-# for rnp_tests</span>
<a href="#l54.13"></a><span id="l54.13" class="difflineminus">-find_package(JSON-C 0.11 REQUIRED)</span>
<a href="#l54.14"></a><span id="l54.14" class="difflineminus">-# for cli_tests</span>
<a href="#l54.15"></a><span id="l54.15" class="difflineminus">-# Note that we do this call early because Google Test will also do</span>
<a href="#l54.16"></a><span id="l54.16" class="difflineminus">-# this but with less strict version requirements, which will cause</span>
<a href="#l54.17"></a><span id="l54.17" class="difflineminus">-# problems for us.</span>
<a href="#l54.18"></a><span id="l54.18" class="difflineminus">-find_package(Python3 COMPONENTS Interpreter)</span>
<a href="#l54.19"></a><span id="l54.19" class="difflineminus">-find_package(GnuPG 2.2 COMPONENTS gpg gpgconf)</span>
<a href="#l54.20"></a><span id="l54.20" class="difflineplus">+if (BUILD_TESTING_GENERATORS)</span>
<a href="#l54.21"></a><span id="l54.21" class="difflineplus">+  add_subdirectory(data/test_key_validity)</span>
<a href="#l54.22"></a><span id="l54.22" class="difflineplus">+endif()</span>
<a href="#l54.23"></a><span id="l54.23"> </span>
<a href="#l54.24"></a><span id="l54.24" class="difflineplus">+# fixture to copy the test data directory</span>
<a href="#l54.25"></a><span id="l54.25" class="difflineplus">+add_test(</span>
<a href="#l54.26"></a><span id="l54.26" class="difflineplus">+  NAME setupTestData</span>
<a href="#l54.27"></a><span id="l54.27" class="difflineplus">+  COMMAND &quot;${CMAKE_COMMAND}&quot; -E copy_directory</span>
<a href="#l54.28"></a><span id="l54.28" class="difflineplus">+          &quot;${CMAKE_CURRENT_SOURCE_DIR}/data&quot; &quot;${CMAKE_CURRENT_BINARY_DIR}/data&quot;</span>
<a href="#l54.29"></a><span id="l54.29" class="difflineplus">+)</span>
<a href="#l54.30"></a><span id="l54.30" class="difflineplus">+set_tests_properties(setupTestData PROPERTIES FIXTURES_SETUP testdata)</span>
<a href="#l54.31"></a><span id="l54.31" class="difflineplus">+</span>
<a href="#l54.32"></a><span id="l54.32" class="difflineplus">+# rnp_tests</span>
<a href="#l54.33"></a><span id="l54.33"> include(GoogleTest)</span>
<a href="#l54.34"></a><span id="l54.34" class="difflineminus">-</span>
<a href="#l54.35"></a><span id="l54.35"> # download and buld googletest</span>
<a href="#l54.36"></a><span id="l54.36"> configure_file(gtest-CMakeLists.txt.in googletest-download/CMakeLists.txt)</span>
<a href="#l54.37"></a><span id="l54.37"> execute_process(COMMAND ${CMAKE_COMMAND} -G &quot;${CMAKE_GENERATOR}&quot; .</span>
<a href="#l54.38"></a><span id="l54.38">   RESULT_VARIABLE result</span>
<a href="#l54.39"></a><span id="l54.39">   WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download )</span>
<a href="#l54.40"></a><span id="l54.40"> if(result)</span>
<a href="#l54.41"></a><span id="l54.41">   message(FATAL_ERROR &quot;CMake step for googletest failed: ${result}&quot;)</span>
<a href="#l54.42"></a><span id="l54.42"> endif()</span>
<a href="#l54.43"></a><span id="l54.43" class="difflineat">@@ -49,20 +52,17 @@ if(result)</span>
<a href="#l54.44"></a><span id="l54.44"> endif()</span>
<a href="#l54.45"></a><span id="l54.45"> # maintain compiler/linker settings on Windows</span>
<a href="#l54.46"></a><span id="l54.46"> set(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)</span>
<a href="#l54.47"></a><span id="l54.47"> # add to our build (provides gtest_main target)</span>
<a href="#l54.48"></a><span id="l54.48"> add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src</span>
<a href="#l54.49"></a><span id="l54.49">                  ${CMAKE_CURRENT_BINARY_DIR}/googletest-build</span>
<a href="#l54.50"></a><span id="l54.50">                  EXCLUDE_FROM_ALL)</span>
<a href="#l54.51"></a><span id="l54.51"> </span>
<a href="#l54.52"></a><span id="l54.52" class="difflineminus">-if (BUILD_TESTING_GENERATORS)</span>
<a href="#l54.53"></a><span id="l54.53" class="difflineminus">-  add_subdirectory(data/test_key_validity)</span>
<a href="#l54.54"></a><span id="l54.54" class="difflineminus">-endif()</span>
<a href="#l54.55"></a><span id="l54.55" class="difflineminus">-</span>
<a href="#l54.56"></a><span id="l54.56" class="difflineplus">+find_package(JSON-C 0.11 REQUIRED)</span>
<a href="#l54.57"></a><span id="l54.57"> add_executable(rnp_tests</span>
<a href="#l54.58"></a><span id="l54.58">   ../rnp/rnpcfg.cpp</span>
<a href="#l54.59"></a><span id="l54.59">   ../rnp/fficli.cpp</span>
<a href="#l54.60"></a><span id="l54.60">   ../rnp/rnp.cpp</span>
<a href="#l54.61"></a><span id="l54.61">   ../rnpkeys/rnpkeys.cpp</span>
<a href="#l54.62"></a><span id="l54.62">   ../rnpkeys/main.cpp</span>
<a href="#l54.63"></a><span id="l54.63">   ../rnpkeys/tui.cpp</span>
<a href="#l54.64"></a><span id="l54.64">   cipher.cpp</span>
<a href="#l54.65"></a><span id="l54.65" class="difflineat">@@ -79,106 +79,56 @@ add_executable(rnp_tests</span>
<a href="#l54.66"></a><span id="l54.66">   key-unlock.cpp</span>
<a href="#l54.67"></a><span id="l54.67">   key-validate.cpp</span>
<a href="#l54.68"></a><span id="l54.68">   large-packet.cpp</span>
<a href="#l54.69"></a><span id="l54.69">   large-mpi.cpp</span>
<a href="#l54.70"></a><span id="l54.70">   load-g10.cpp</span>
<a href="#l54.71"></a><span id="l54.71">   load-pgp.cpp</span>
<a href="#l54.72"></a><span id="l54.72">   log-switch.cpp</span>
<a href="#l54.73"></a><span id="l54.73">   partial-length.cpp</span>
<a href="#l54.74"></a><span id="l54.74" class="difflineplus">+  pipe.cpp</span>
<a href="#l54.75"></a><span id="l54.75">   rnp_tests.cpp</span>
<a href="#l54.76"></a><span id="l54.76">   s2k-iterations.cpp</span>
<a href="#l54.77"></a><span id="l54.77">   streams.cpp</span>
<a href="#l54.78"></a><span id="l54.78">   support.cpp</span>
<a href="#l54.79"></a><span id="l54.79">   user-prefs.cpp</span>
<a href="#l54.80"></a><span id="l54.80">   utils-hex2bin.cpp</span>
<a href="#l54.81"></a><span id="l54.81">   utils-list.cpp</span>
<a href="#l54.82"></a><span id="l54.82">   utils-rnpcfg.cpp</span>
<a href="#l54.83"></a><span id="l54.83">   issues/1030.cpp</span>
<a href="#l54.84"></a><span id="l54.84">   issues/1115.cpp</span>
<a href="#l54.85"></a><span id="l54.85">   issues/1171.cpp</span>
<a href="#l54.86"></a><span id="l54.86"> )</span>
<a href="#l54.87"></a><span id="l54.87" class="difflineminus">-</span>
<a href="#l54.88"></a><span id="l54.88"> target_include_directories(rnp_tests</span>
<a href="#l54.89"></a><span id="l54.89">   PRIVATE</span>
<a href="#l54.90"></a><span id="l54.90">     &quot;${PROJECT_SOURCE_DIR}/src&quot;</span>
<a href="#l54.91"></a><span id="l54.91">     &quot;${PROJECT_SOURCE_DIR}/src/lib&quot;</span>
<a href="#l54.92"></a><span id="l54.92"> )</span>
<a href="#l54.93"></a><span id="l54.93" class="difflineminus">-</span>
<a href="#l54.94"></a><span id="l54.94"> target_link_libraries(rnp_tests</span>
<a href="#l54.95"></a><span id="l54.95">   PRIVATE</span>
<a href="#l54.96"></a><span id="l54.96" class="difflineminus">-    librnp</span>
<a href="#l54.97"></a><span id="l54.97" class="difflineplus">+    librnp-static</span>
<a href="#l54.98"></a><span id="l54.98">     JSON-C::JSON-C</span>
<a href="#l54.99"></a><span id="l54.99">     gtest_main</span>
<a href="#l54.100"></a><span id="l54.100"> )</span>
<a href="#l54.101"></a><span id="l54.101"> if (WIN32 AND CMAKE_CXX_COMPILER_ID STREQUAL &quot;GNU&quot;)</span>
<a href="#l54.102"></a><span id="l54.102">   target_link_libraries(rnp_tests PRIVATE regex)</span>
<a href="#l54.103"></a><span id="l54.103"> endif()</span>
<a href="#l54.104"></a><span id="l54.104"> target_compile_definitions(rnp_tests</span>
<a href="#l54.105"></a><span id="l54.105">   PRIVATE</span>
<a href="#l54.106"></a><span id="l54.106">     RNP_RUN_TESTS</span>
<a href="#l54.107"></a><span id="l54.107" class="difflineplus">+    RNP_STATIC</span>
<a href="#l54.108"></a><span id="l54.108"> )</span>
<a href="#l54.109"></a><span id="l54.109" class="difflineminus">-</span>
<a href="#l54.110"></a><span id="l54.110" class="difflineminus">-if (WIN32)</span>
<a href="#l54.111"></a><span id="l54.111" class="difflineminus">-  add_custom_command(TARGET rnp_tests POST_BUILD</span>
<a href="#l54.112"></a><span id="l54.112" class="difflineminus">-    COMMAND ${CMAKE_COMMAND} -E copy_if_different &quot;$&lt;TARGET_FILE:librnp&gt;&quot; &quot;$&lt;TARGET_FILE_DIR:rnp_tests&gt;&quot;)</span>
<a href="#l54.113"></a><span id="l54.113" class="difflineminus">-endif()</span>
<a href="#l54.114"></a><span id="l54.114" class="difflineminus">-</span>
<a href="#l54.115"></a><span id="l54.115" class="difflineminus">-# fixture to copy the test data directory</span>
<a href="#l54.116"></a><span id="l54.116" class="difflineminus">-add_test(</span>
<a href="#l54.117"></a><span id="l54.117" class="difflineminus">-  NAME setupTestData</span>
<a href="#l54.118"></a><span id="l54.118" class="difflineminus">-  COMMAND &quot;${CMAKE_COMMAND}&quot; -E copy_directory</span>
<a href="#l54.119"></a><span id="l54.119" class="difflineminus">-          &quot;${CMAKE_CURRENT_SOURCE_DIR}/data&quot; &quot;${CMAKE_CURRENT_BINARY_DIR}/data&quot;</span>
<a href="#l54.120"></a><span id="l54.120" class="difflineminus">-)</span>
<a href="#l54.121"></a><span id="l54.121" class="difflineminus">-set_tests_properties(setupTestData PROPERTIES FIXTURES_SETUP testdata)</span>
<a href="#l54.122"></a><span id="l54.122" class="difflineminus">-</span>
<a href="#l54.123"></a><span id="l54.123"> gtest_discover_tests(rnp_tests</span>
<a href="#l54.124"></a><span id="l54.124">   PROPERTIES</span>
<a href="#l54.125"></a><span id="l54.125">     FIXTURES_REQUIRED testdata</span>
<a href="#l54.126"></a><span id="l54.126">     TIMEOUT 3000</span>
<a href="#l54.127"></a><span id="l54.127">     ENVIRONMENT &quot;RNP_TEST_DATA=${CMAKE_CURRENT_SOURCE_DIR}/data&quot;</span>
<a href="#l54.128"></a><span id="l54.128"> )</span>
<a href="#l54.129"></a><span id="l54.129"> </span>
<a href="#l54.130"></a><span id="l54.130" class="difflineminus">-function(add_cli_test suite)</span>
<a href="#l54.131"></a><span id="l54.131" class="difflineminus">-  set(_test_name cli_tests-${suite})</span>
<a href="#l54.132"></a><span id="l54.132" class="difflineminus">-  add_test(</span>
<a href="#l54.133"></a><span id="l54.133" class="difflineminus">-    NAME ${_test_name}</span>
<a href="#l54.134"></a><span id="l54.134" class="difflineminus">-    COMMAND &quot;${Python3_EXECUTABLE}&quot; &quot;${CMAKE_CURRENT_SOURCE_DIR}/cli_tests.py&quot; -v -d &quot;${suite}&quot;</span>
<a href="#l54.135"></a><span id="l54.135" class="difflineminus">-  )</span>
<a href="#l54.136"></a><span id="l54.136" class="difflineminus">-  set(_env)</span>
<a href="#l54.137"></a><span id="l54.137" class="difflineminus">-  list(APPEND _env</span>
<a href="#l54.138"></a><span id="l54.138" class="difflineminus">-    &quot;RNP_TESTS_RNP_PATH=$&lt;TARGET_FILE:rnp&gt;&quot;</span>
<a href="#l54.139"></a><span id="l54.139" class="difflineminus">-    &quot;RNP_TESTS_RNPKEYS_PATH=$&lt;TARGET_FILE:rnpkeys&gt;&quot;</span>
<a href="#l54.140"></a><span id="l54.140" class="difflineminus">-    &quot;RNP_TESTS_GPG_PATH=${GPG_EXECUTABLE}&quot;</span>
<a href="#l54.141"></a><span id="l54.141" class="difflineminus">-    &quot;RNP_TESTS_GPGCONF_PATH=${GPGCONF_EXECUTABLE}&quot;</span>
<a href="#l54.142"></a><span id="l54.142" class="difflineminus">-  )</span>
<a href="#l54.143"></a><span id="l54.143" class="difflineminus">-  set_tests_properties(${_test_name} PROPERTIES</span>
<a href="#l54.144"></a><span id="l54.144" class="difflineminus">-    TIMEOUT 3000</span>
<a href="#l54.145"></a><span id="l54.145" class="difflineminus">-    FIXTURES_REQUIRED testdata</span>
<a href="#l54.146"></a><span id="l54.146" class="difflineminus">-    ENVIRONMENT &quot;${_env}&quot;</span>
<a href="#l54.147"></a><span id="l54.147" class="difflineminus">-  )</span>
<a href="#l54.148"></a><span id="l54.148" class="difflineminus">-endfunction()</span>
<a href="#l54.149"></a><span id="l54.149" class="difflineminus">-# get a list of test suites</span>
<a href="#l54.150"></a><span id="l54.150" class="difflineminus">-execute_process(</span>
<a href="#l54.151"></a><span id="l54.151" class="difflineminus">-  COMMAND &quot;${Python3_EXECUTABLE}&quot; &quot;${CMAKE_CURRENT_SOURCE_DIR}/cli_tests.py&quot; -ls</span>
<a href="#l54.152"></a><span id="l54.152" class="difflineminus">-  RESULT_VARIABLE _ec</span>
<a href="#l54.153"></a><span id="l54.153" class="difflineminus">-  OUTPUT_VARIABLE suitelist</span>
<a href="#l54.154"></a><span id="l54.154" class="difflineminus">-  OUTPUT_STRIP_TRAILING_WHITESPACE</span>
<a href="#l54.155"></a><span id="l54.155" class="difflineminus">-)</span>
<a href="#l54.156"></a><span id="l54.156" class="difflineminus">-if (NOT _ec EQUAL 0)</span>
<a href="#l54.157"></a><span id="l54.157" class="difflineminus">-  message(FATAL_ERROR &quot;Failed to retrieve test suite list for cli_tests&quot;)</span>
<a href="#l54.158"></a><span id="l54.158" class="difflineminus">-endif()</span>
<a href="#l54.159"></a><span id="l54.159" class="difflineminus">-# convert to a CMake list</span>
<a href="#l54.160"></a><span id="l54.160" class="difflineminus">-string(REGEX REPLACE &quot;;&quot; &quot;\\\\;&quot; suitelist &quot;${suitelist}&quot;)</span>
<a href="#l54.161"></a><span id="l54.161" class="difflineminus">-string(REGEX REPLACE &quot;\n&quot; &quot;;&quot; suitelist &quot;${suitelist}&quot;)</span>
<a href="#l54.162"></a><span id="l54.162" class="difflineminus">-# create a CTest test for each suite</span>
<a href="#l54.163"></a><span id="l54.163" class="difflineminus">-foreach(suite IN LISTS suitelist)</span>
<a href="#l54.164"></a><span id="l54.164" class="difflineminus">-  add_cli_test(&quot;${suite}&quot;)</span>
<a href="#l54.165"></a><span id="l54.165" class="difflineminus">-endforeach()</span>
<a href="#l54.166"></a><span id="l54.166" class="difflineminus">-</span>
<a href="#l54.167"></a><span id="l54.167" class="difflineplus">+# ruby-rnp</span>
<a href="#l54.168"></a><span id="l54.168"> # cruby does not currently play nice with ASaN et al.</span>
<a href="#l54.169"></a><span id="l54.169"> if (NOT ENABLE_SANITIZERS AND BUILD_SHARED_LIBS AND NOT WIN32)</span>
<a href="#l54.170"></a><span id="l54.170">   include(ExternalProject)</span>
<a href="#l54.171"></a><span id="l54.171">   set(_sourcedir &quot;${CMAKE_BINARY_DIR}/ruby-rnp&quot;)</span>
<a href="#l54.172"></a><span id="l54.172">   if (DEFINED ENV{RUBY_RNP_INSTALL})</span>
<a href="#l54.173"></a><span id="l54.173">     set(_sourcedir &quot;$ENV{RUBY_RNP_INSTALL}&quot;)</span>
<a href="#l54.174"></a><span id="l54.174">   endif()</span>
<a href="#l54.175"></a><span id="l54.175">   set(_ruby_rnp_ver &quot;master&quot;)</span>
<a href="#l54.176"></a><span id="l54.176" class="difflineat">@@ -211,8 +161,51 @@ if (NOT ENABLE_SANITIZERS AND BUILD_SHAR</span>
<a href="#l54.177"></a><span id="l54.177">     COMMAND bundle exec parallel_rspec spec/</span>
<a href="#l54.178"></a><span id="l54.178">   )</span>
<a href="#l54.179"></a><span id="l54.179">   set_tests_properties(ruby-rnp PROPERTIES</span>
<a href="#l54.180"></a><span id="l54.180">     TIMEOUT 1000</span>
<a href="#l54.181"></a><span id="l54.181">     ENVIRONMENT &quot;${_env}&quot;</span>
<a href="#l54.182"></a><span id="l54.182">   )</span>
<a href="#l54.183"></a><span id="l54.183"> endif()</span>
<a href="#l54.184"></a><span id="l54.184"> </span>
<a href="#l54.185"></a><span id="l54.185" class="difflineplus">+# cli_tests</span>
<a href="#l54.186"></a><span id="l54.186" class="difflineplus">+# Note that we do this call early because Google Test will also do</span>
<a href="#l54.187"></a><span id="l54.187" class="difflineplus">+# this but with less strict version requirements, which will cause</span>
<a href="#l54.188"></a><span id="l54.188" class="difflineplus">+# problems for us.</span>
<a href="#l54.189"></a><span id="l54.189" class="difflineplus">+find_package(Python3 COMPONENTS Interpreter)</span>
<a href="#l54.190"></a><span id="l54.190" class="difflineplus">+find_package(GnuPG 2.2 COMPONENTS gpg gpgconf)</span>
<a href="#l54.191"></a><span id="l54.191" class="difflineplus">+function(add_cli_test suite)</span>
<a href="#l54.192"></a><span id="l54.192" class="difflineplus">+  set(_test_name cli_tests-${suite})</span>
<a href="#l54.193"></a><span id="l54.193" class="difflineplus">+  add_test(</span>
<a href="#l54.194"></a><span id="l54.194" class="difflineplus">+    NAME ${_test_name}</span>
<a href="#l54.195"></a><span id="l54.195" class="difflineplus">+    COMMAND &quot;${Python3_EXECUTABLE}&quot; &quot;${CMAKE_CURRENT_SOURCE_DIR}/cli_tests.py&quot; -v -d &quot;${suite}&quot;</span>
<a href="#l54.196"></a><span id="l54.196" class="difflineplus">+  )</span>
<a href="#l54.197"></a><span id="l54.197" class="difflineplus">+  set(_env)</span>
<a href="#l54.198"></a><span id="l54.198" class="difflineplus">+  list(APPEND _env</span>
<a href="#l54.199"></a><span id="l54.199" class="difflineplus">+    &quot;RNP_TESTS_RNP_PATH=$&lt;TARGET_FILE:rnp&gt;&quot;</span>
<a href="#l54.200"></a><span id="l54.200" class="difflineplus">+    &quot;RNP_TESTS_RNPKEYS_PATH=$&lt;TARGET_FILE:rnpkeys&gt;&quot;</span>
<a href="#l54.201"></a><span id="l54.201" class="difflineplus">+    &quot;RNP_TESTS_GPG_PATH=${GPG_EXECUTABLE}&quot;</span>
<a href="#l54.202"></a><span id="l54.202" class="difflineplus">+    &quot;RNP_TESTS_GPGCONF_PATH=${GPGCONF_EXECUTABLE}&quot;</span>
<a href="#l54.203"></a><span id="l54.203" class="difflineplus">+  )</span>
<a href="#l54.204"></a><span id="l54.204" class="difflineplus">+  set_tests_properties(${_test_name} PROPERTIES</span>
<a href="#l54.205"></a><span id="l54.205" class="difflineplus">+    TIMEOUT 3000</span>
<a href="#l54.206"></a><span id="l54.206" class="difflineplus">+    FIXTURES_REQUIRED testdata</span>
<a href="#l54.207"></a><span id="l54.207" class="difflineplus">+    ENVIRONMENT &quot;${_env}&quot;</span>
<a href="#l54.208"></a><span id="l54.208" class="difflineplus">+  )</span>
<a href="#l54.209"></a><span id="l54.209" class="difflineplus">+endfunction()</span>
<a href="#l54.210"></a><span id="l54.210" class="difflineplus">+# get a list of test suites</span>
<a href="#l54.211"></a><span id="l54.211" class="difflineplus">+execute_process(</span>
<a href="#l54.212"></a><span id="l54.212" class="difflineplus">+  COMMAND &quot;${Python3_EXECUTABLE}&quot; &quot;${CMAKE_CURRENT_SOURCE_DIR}/cli_tests.py&quot; -ls</span>
<a href="#l54.213"></a><span id="l54.213" class="difflineplus">+  RESULT_VARIABLE _ec</span>
<a href="#l54.214"></a><span id="l54.214" class="difflineplus">+  OUTPUT_VARIABLE suitelist</span>
<a href="#l54.215"></a><span id="l54.215" class="difflineplus">+  OUTPUT_STRIP_TRAILING_WHITESPACE</span>
<a href="#l54.216"></a><span id="l54.216" class="difflineplus">+)</span>
<a href="#l54.217"></a><span id="l54.217" class="difflineplus">+if (NOT _ec EQUAL 0)</span>
<a href="#l54.218"></a><span id="l54.218" class="difflineplus">+  message(FATAL_ERROR &quot;Failed to retrieve test suite list for cli_tests&quot;)</span>
<a href="#l54.219"></a><span id="l54.219" class="difflineplus">+endif()</span>
<a href="#l54.220"></a><span id="l54.220" class="difflineplus">+# convert to a CMake list</span>
<a href="#l54.221"></a><span id="l54.221" class="difflineplus">+string(REGEX REPLACE &quot;;&quot; &quot;\\\\;&quot; suitelist &quot;${suitelist}&quot;)</span>
<a href="#l54.222"></a><span id="l54.222" class="difflineplus">+string(REGEX REPLACE &quot;\n&quot; &quot;;&quot; suitelist &quot;${suitelist}&quot;)</span>
<a href="#l54.223"></a><span id="l54.223" class="difflineplus">+# create a CTest test for each suite</span>
<a href="#l54.224"></a><span id="l54.224" class="difflineplus">+foreach(suite IN LISTS suitelist)</span>
<a href="#l54.225"></a><span id="l54.225" class="difflineplus">+  add_cli_test(&quot;${suite}&quot;)</span>
<a href="#l54.226"></a><span id="l54.226" class="difflineplus">+endforeach()</span>
<a href="#l54.227"></a><span id="l54.227" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l55.1"></a><span id="l55.1" class="difflineminus">--- a/third_party/rnp/src/tests/cipher.cpp</span>
<a href="#l55.2"></a><span id="l55.2" class="difflineplus">+++ b/third_party/rnp/src/tests/cipher.cpp</span>
<a href="#l55.3"></a><span id="l55.3" class="difflineat">@@ -217,40 +217,40 @@ TEST_F(rnp_tests, rnp_test_x25519)</span>
<a href="#l55.4"></a><span id="l55.4">     pgp_fingerprint_t fp = {};</span>
<a href="#l55.5"></a><span id="l55.5"> </span>
<a href="#l55.6"></a><span id="l55.6">     key_desc.key_alg = PGP_PKA_ECDH;</span>
<a href="#l55.7"></a><span id="l55.7">     key_desc.hash_alg = PGP_HASH_SHA256;</span>
<a href="#l55.8"></a><span id="l55.8">     key_desc.rng = &amp;global_rng;</span>
<a href="#l55.9"></a><span id="l55.9">     key_desc.ecc.curve = PGP_CURVE_25519;</span>
<a href="#l55.10"></a><span id="l55.10"> </span>
<a href="#l55.11"></a><span id="l55.11">     assert_true(pgp_generate_seckey(&amp;key_desc, &amp;seckey, true));</span>
<a href="#l55.12"></a><span id="l55.12" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;fp, &amp;seckey));</span>
<a href="#l55.13"></a><span id="l55.13" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(fp, &amp;seckey));</span>
<a href="#l55.14"></a><span id="l55.14">     assert_rnp_success(</span>
<a href="#l55.15"></a><span id="l55.15" class="difflineminus">-      ecdh_encrypt_pkcs5(&amp;global_rng, &amp;enc, in, sizeof(in), &amp;seckey.material.ec, &amp;fp));</span>
<a href="#l55.16"></a><span id="l55.16" class="difflineplus">+      ecdh_encrypt_pkcs5(&amp;global_rng, &amp;enc, in, sizeof(in), &amp;seckey.material.ec, fp));</span>
<a href="#l55.17"></a><span id="l55.17">     assert_true(enc.mlen &gt; 16);</span>
<a href="#l55.18"></a><span id="l55.18">     assert_true((enc.p.mpi[0] == 0x40) &amp;&amp; (enc.p.len == 33));</span>
<a href="#l55.19"></a><span id="l55.19">     outlen = sizeof(out);</span>
<a href="#l55.20"></a><span id="l55.20" class="difflineminus">-    assert_rnp_success(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, &amp;fp));</span>
<a href="#l55.21"></a><span id="l55.21" class="difflineplus">+    assert_rnp_success(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, fp));</span>
<a href="#l55.22"></a><span id="l55.22">     assert_true(outlen == 16);</span>
<a href="#l55.23"></a><span id="l55.23">     assert_true(memcmp(in, out, 16) == 0);</span>
<a href="#l55.24"></a><span id="l55.24"> </span>
<a href="#l55.25"></a><span id="l55.25">     /* negative cases */</span>
<a href="#l55.26"></a><span id="l55.26">     enc.p.mpi[16] ^= 0xff;</span>
<a href="#l55.27"></a><span id="l55.27" class="difflineminus">-    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, &amp;fp));</span>
<a href="#l55.28"></a><span id="l55.28" class="difflineplus">+    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, fp));</span>
<a href="#l55.29"></a><span id="l55.29"> </span>
<a href="#l55.30"></a><span id="l55.30">     enc.p.mpi[16] ^= 0xff;</span>
<a href="#l55.31"></a><span id="l55.31">     enc.p.mpi[0] = 0x04;</span>
<a href="#l55.32"></a><span id="l55.32" class="difflineminus">-    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, &amp;fp));</span>
<a href="#l55.33"></a><span id="l55.33" class="difflineplus">+    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, fp));</span>
<a href="#l55.34"></a><span id="l55.34"> </span>
<a href="#l55.35"></a><span id="l55.35">     enc.p.mpi[0] = 0x40;</span>
<a href="#l55.36"></a><span id="l55.36">     enc.mlen--;</span>
<a href="#l55.37"></a><span id="l55.37" class="difflineminus">-    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, &amp;fp));</span>
<a href="#l55.38"></a><span id="l55.38" class="difflineplus">+    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, fp));</span>
<a href="#l55.39"></a><span id="l55.39"> </span>
<a href="#l55.40"></a><span id="l55.40">     enc.mlen += 2;</span>
<a href="#l55.41"></a><span id="l55.41" class="difflineminus">-    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, &amp;fp));</span>
<a href="#l55.42"></a><span id="l55.42" class="difflineplus">+    assert_rnp_failure(ecdh_decrypt_pkcs5(out, &amp;outlen, &amp;enc, &amp;seckey.material.ec, fp));</span>
<a href="#l55.43"></a><span id="l55.43"> </span>
<a href="#l55.44"></a><span id="l55.44">     free_key_pkt(&amp;seckey);</span>
<a href="#l55.45"></a><span id="l55.45"> }</span>
<a href="#l55.46"></a><span id="l55.46"> </span>
<a href="#l55.47"></a><span id="l55.47"> static void</span>
<a href="#l55.48"></a><span id="l55.48"> elgamal_roundtrip(pgp_eg_key_t *key)</span>
<a href="#l55.49"></a><span id="l55.49"> {</span>
<a href="#l55.50"></a><span id="l55.50">     const uint8_t      in_b[] = {0x01, 0x02, 0x03, 0x04, 0x17};</span>
<a href="#l55.51"></a><span id="l55.51" class="difflineat">@@ -344,27 +344,23 @@ TEST_F(rnp_tests, ecdh_roundtrip)</span>
<a href="#l55.52"></a><span id="l55.52">         key_desc.rng = &amp;global_rng;</span>
<a href="#l55.53"></a><span id="l55.53"> </span>
<a href="#l55.54"></a><span id="l55.54">         pgp_key_pkt_t ecdh_key1;</span>
<a href="#l55.55"></a><span id="l55.55">         memset(&amp;ecdh_key1, 0, sizeof(ecdh_key1));</span>
<a href="#l55.56"></a><span id="l55.56">         assert_true(pgp_generate_seckey(&amp;key_desc, &amp;ecdh_key1, true));</span>
<a href="#l55.57"></a><span id="l55.57"> </span>
<a href="#l55.58"></a><span id="l55.58">         pgp_fingerprint_t ecdh_key1_fpr;</span>
<a href="#l55.59"></a><span id="l55.59">         memset(&amp;ecdh_key1_fpr, 0, sizeof(ecdh_key1_fpr));</span>
<a href="#l55.60"></a><span id="l55.60" class="difflineminus">-        assert_rnp_success(pgp_fingerprint(&amp;ecdh_key1_fpr, &amp;ecdh_key1));</span>
<a href="#l55.61"></a><span id="l55.61" class="difflineplus">+        assert_rnp_success(pgp_fingerprint(ecdh_key1_fpr, &amp;ecdh_key1));</span>
<a href="#l55.62"></a><span id="l55.62"> </span>
<a href="#l55.63"></a><span id="l55.63" class="difflineminus">-        assert_rnp_success(ecdh_encrypt_pkcs5(&amp;global_rng,</span>
<a href="#l55.64"></a><span id="l55.64" class="difflineminus">-                                              &amp;enc,</span>
<a href="#l55.65"></a><span id="l55.65" class="difflineminus">-                                              plaintext,</span>
<a href="#l55.66"></a><span id="l55.66" class="difflineminus">-                                              plaintext_len,</span>
<a href="#l55.67"></a><span id="l55.67" class="difflineminus">-                                              &amp;ecdh_key1.material.ec,</span>
<a href="#l55.68"></a><span id="l55.68" class="difflineminus">-                                              &amp;ecdh_key1_fpr));</span>
<a href="#l55.69"></a><span id="l55.69" class="difflineplus">+        assert_rnp_success(ecdh_encrypt_pkcs5(</span>
<a href="#l55.70"></a><span id="l55.70" class="difflineplus">+          &amp;global_rng, &amp;enc, plaintext, plaintext_len, &amp;ecdh_key1.material.ec, ecdh_key1_fpr));</span>
<a href="#l55.71"></a><span id="l55.71"> </span>
<a href="#l55.72"></a><span id="l55.72">         assert_rnp_success(ecdh_decrypt_pkcs5(</span>
<a href="#l55.73"></a><span id="l55.73" class="difflineminus">-          result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, &amp;ecdh_key1_fpr));</span>
<a href="#l55.74"></a><span id="l55.74" class="difflineplus">+          result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, ecdh_key1_fpr));</span>
<a href="#l55.75"></a><span id="l55.75"> </span>
<a href="#l55.76"></a><span id="l55.76">         assert_int_equal(plaintext_len, result_len);</span>
<a href="#l55.77"></a><span id="l55.77">         assert_int_equal(memcmp(plaintext, result, result_len), 0);</span>
<a href="#l55.78"></a><span id="l55.78">         free_key_pkt(&amp;ecdh_key1);</span>
<a href="#l55.79"></a><span id="l55.79">     }</span>
<a href="#l55.80"></a><span id="l55.80"> }</span>
<a href="#l55.81"></a><span id="l55.81"> </span>
<a href="#l55.82"></a><span id="l55.82"> TEST_F(rnp_tests, ecdh_decryptionNegativeCases)</span>
<a href="#l55.83"></a><span id="l55.83" class="difflineat">@@ -382,46 +378,46 @@ TEST_F(rnp_tests, ecdh_decryptionNegativ</span>
<a href="#l55.84"></a><span id="l55.84">     key_desc.rng = &amp;global_rng;</span>
<a href="#l55.85"></a><span id="l55.85"> </span>
<a href="#l55.86"></a><span id="l55.86">     pgp_key_pkt_t ecdh_key1;</span>
<a href="#l55.87"></a><span id="l55.87">     memset(&amp;ecdh_key1, 0, sizeof(ecdh_key1));</span>
<a href="#l55.88"></a><span id="l55.88">     assert_true(pgp_generate_seckey(&amp;key_desc, &amp;ecdh_key1, true));</span>
<a href="#l55.89"></a><span id="l55.89"> </span>
<a href="#l55.90"></a><span id="l55.90">     pgp_fingerprint_t ecdh_key1_fpr;</span>
<a href="#l55.91"></a><span id="l55.91">     memset(&amp;ecdh_key1_fpr, 0, sizeof(ecdh_key1_fpr));</span>
<a href="#l55.92"></a><span id="l55.92" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;ecdh_key1_fpr, &amp;ecdh_key1));</span>
<a href="#l55.93"></a><span id="l55.93" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(ecdh_key1_fpr, &amp;ecdh_key1));</span>
<a href="#l55.94"></a><span id="l55.94"> </span>
<a href="#l55.95"></a><span id="l55.95">     assert_rnp_success(ecdh_encrypt_pkcs5(</span>
<a href="#l55.96"></a><span id="l55.96" class="difflineminus">-      &amp;global_rng, &amp;enc, plaintext, plaintext_len, &amp;ecdh_key1.material.ec, &amp;ecdh_key1_fpr));</span>
<a href="#l55.97"></a><span id="l55.97" class="difflineplus">+      &amp;global_rng, &amp;enc, plaintext, plaintext_len, &amp;ecdh_key1.material.ec, ecdh_key1_fpr));</span>
<a href="#l55.98"></a><span id="l55.98"> </span>
<a href="#l55.99"></a><span id="l55.99" class="difflineminus">-    assert_int_equal(ecdh_decrypt_pkcs5(NULL, 0, &amp;enc, &amp;ecdh_key1.material.ec, &amp;ecdh_key1_fpr),</span>
<a href="#l55.100"></a><span id="l55.100" class="difflineplus">+    assert_int_equal(ecdh_decrypt_pkcs5(NULL, 0, &amp;enc, &amp;ecdh_key1.material.ec, ecdh_key1_fpr),</span>
<a href="#l55.101"></a><span id="l55.101">                      RNP_ERROR_BAD_PARAMETERS);</span>
<a href="#l55.102"></a><span id="l55.102"> </span>
<a href="#l55.103"></a><span id="l55.103" class="difflineminus">-    assert_int_equal(ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, NULL, &amp;ecdh_key1_fpr),</span>
<a href="#l55.104"></a><span id="l55.104" class="difflineplus">+    assert_int_equal(ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, NULL, ecdh_key1_fpr),</span>
<a href="#l55.105"></a><span id="l55.105">                      RNP_ERROR_BAD_PARAMETERS);</span>
<a href="#l55.106"></a><span id="l55.106"> </span>
<a href="#l55.107"></a><span id="l55.107">     assert_int_equal(</span>
<a href="#l55.108"></a><span id="l55.108" class="difflineminus">-      ecdh_decrypt_pkcs5(result, &amp;result_len, NULL, &amp;ecdh_key1.material.ec, &amp;ecdh_key1_fpr),</span>
<a href="#l55.109"></a><span id="l55.109" class="difflineplus">+      ecdh_decrypt_pkcs5(result, &amp;result_len, NULL, &amp;ecdh_key1.material.ec, ecdh_key1_fpr),</span>
<a href="#l55.110"></a><span id="l55.110">       RNP_ERROR_BAD_PARAMETERS);</span>
<a href="#l55.111"></a><span id="l55.111"> </span>
<a href="#l55.112"></a><span id="l55.112">     size_t mlen = enc.mlen;</span>
<a href="#l55.113"></a><span id="l55.113">     enc.mlen = 0;</span>
<a href="#l55.114"></a><span id="l55.114">     assert_int_equal(</span>
<a href="#l55.115"></a><span id="l55.115" class="difflineminus">-      ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, &amp;ecdh_key1_fpr),</span>
<a href="#l55.116"></a><span id="l55.116" class="difflineplus">+      ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, ecdh_key1_fpr),</span>
<a href="#l55.117"></a><span id="l55.117">       RNP_ERROR_GENERIC);</span>
<a href="#l55.118"></a><span id="l55.118"> </span>
<a href="#l55.119"></a><span id="l55.119">     enc.mlen = mlen - 1;</span>
<a href="#l55.120"></a><span id="l55.120">     assert_int_equal(</span>
<a href="#l55.121"></a><span id="l55.121" class="difflineminus">-      ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, &amp;ecdh_key1_fpr),</span>
<a href="#l55.122"></a><span id="l55.122" class="difflineplus">+      ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, ecdh_key1_fpr),</span>
<a href="#l55.123"></a><span id="l55.123">       RNP_ERROR_GENERIC);</span>
<a href="#l55.124"></a><span id="l55.124"> </span>
<a href="#l55.125"></a><span id="l55.125">     int key_wrapping_alg = ecdh_key1.material.ec.key_wrap_alg;</span>
<a href="#l55.126"></a><span id="l55.126">     ecdh_key1.material.ec.key_wrap_alg = PGP_SA_IDEA;</span>
<a href="#l55.127"></a><span id="l55.127">     assert_int_equal(</span>
<a href="#l55.128"></a><span id="l55.128" class="difflineminus">-      ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, &amp;ecdh_key1_fpr),</span>
<a href="#l55.129"></a><span id="l55.129" class="difflineplus">+      ecdh_decrypt_pkcs5(result, &amp;result_len, &amp;enc, &amp;ecdh_key1.material.ec, ecdh_key1_fpr),</span>
<a href="#l55.130"></a><span id="l55.130">       RNP_ERROR_NOT_SUPPORTED);</span>
<a href="#l55.131"></a><span id="l55.131">     ecdh_key1.material.ec.key_wrap_alg = (pgp_symm_alg_t) key_wrapping_alg;</span>
<a href="#l55.132"></a><span id="l55.132"> </span>
<a href="#l55.133"></a><span id="l55.133">     free_key_pkt(&amp;ecdh_key1);</span>
<a href="#l55.134"></a><span id="l55.134"> }</span>
<a href="#l55.135"></a><span id="l55.135"> </span>
<a href="#l55.136"></a><span id="l55.136"> TEST_F(rnp_tests, sm2_roundtrip)</span>
<a href="#l55.137"></a><span id="l55.137"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l56.1"></a><span id="l56.1">new file mode 100644</span>
<a href="#l56.2"></a><span id="l56.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..6729aedb99619ffdb861dcbda84289db6d00b8dc</span>
<a href="#l56.3"></a><span id="l56.3">GIT binary patch
literal 858
zc$}MI%o4}4Utf$&lt;n~jl$@s&gt;M3BO|+m`iFGhlXEN-ng4Cwemds7tm&gt;~R3?6TCYu#7&amp;
zx3QmSvfm=;n3I{Ds$i1{q8y6y3hX*2un3EBFj$BwvJ}5PGf{H=iAT5ho_)#^=rAqw
z|2-R4CXg*m(#)*foE+&gt;-Y@%G89NbJSVoc18Omd7&amp;;tdR3oB}Y#DsvhB`$etSv+{F%
zvQ^jaWBRd$OV-YGkh{OOQFixLmIaNX&lt;pzul`!4-o_by}8`Q+nyEh{^|NqVqL-IiE&amp;
z=1+gj-nV+GhFm+sS&gt;o9E4hnH&lt;t1vS&amp;aRB|r#LN=oZ({dcv}w)zV15zT3ZMEr?=lZx
z&lt;nHG$^sajx&gt;sPSUnSa~zXv5}^6b7*c-#0rlGrI9{xn@6KXKWw&amp;XZtS0&lt;IId4&gt;&gt;U*&gt;
z5&lt;ssi;PxueS|({8WG^jTz{s%W@AcF3r}giSS#?2u+uDe8j(;*=JPWwXprX&amp;Y=Ah$c
zXNG@9^CrDy?bMC+=8t{-B4C*_m$a_k^@VqHbdFglF{?N*&amp;j3f30bL@?U^KEQi!1;@
CIz&lt;Km</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l57.1"></a><span id="l57.1">new file mode 100644</span>
<a href="#l57.2"></a><span id="l57.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..1d312c80c546d6cf08168657a1f11064d43e96a4</span>
<a href="#l57.3"></a><span id="l57.3">GIT binary patch
literal 640
zc$}MI%o4}4Utf$&lt;n~jl$@s&gt;M3BO|+m`iFGhlXEN-ng4Cwemds7tm&gt;~R3?6TCYu#7&amp;
zx3QmSvfm=;n3I{Ds$i1{q8y6y3hX*2un3EBFj$BwvJ}5PGf{H=iAT5ho_)#^=rAqw
z|2-R4CXg*m(#)*foE+&gt;-Y@%G89NbJSVoc18Omd7&amp;;tdR3oB}Y#DsvhB`$etSv+{F%
zvQ^jaWBRd$OV-YGkh{OOQFixLmIaNX&lt;pzul`!4-o_by}8`Q+nyEh{^|NqVqL-IiE&amp;
z=1+gj-nV+GhFm+sS&gt;o9E4hnH&lt;t1vS&amp;aRB|r#LN=oZ({dcv}w)zV15zT3ZMEr?=lZx
z&lt;nHG$^sajx&gt;sPSUnSa~zXv5}^6b7*c-#0rlGrI9{xn@6KXKWw&amp;XZtS0&lt;IId4&gt;&gt;U*&gt;
z5&lt;ssi;PxueS|({8WG^jTz{s%W@AcF3r}giSS#?2u+uDe8j(;*=JPWwXprX&amp;Y=Ah$c
zXNG@9^CrDy?bMC+=8t{-B4C*_m$a_k^@VqHbdFglF{?N*L%eioV7zpgCSC#nTyykB</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l58.1"></a><span id="l58.1">new file mode 100644</span>
<a href="#l58.2"></a><span id="l58.2" class="difflineminus">--- /dev/null</span>
<a href="#l58.3"></a><span id="l58.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-pub.asc</span>
<a href="#l58.4"></a><span id="l58.4" class="difflineat">@@ -0,0 +1,14 @@</span>
<a href="#l58.5"></a><span id="l58.5" class="difflineplus">+-----BEGIN PGP PUBLIC KEY BLOCK-----</span>
<a href="#l58.6"></a><span id="l58.6" class="difflineplus">+</span>
<a href="#l58.7"></a><span id="l58.7" class="difflineplus">+xjMEXgS/LxYJKwYBBAHaRw8BAQdAJ/BnDcmcOCED/rW3y1zPHSX6lABI7G19R6mPhgfIgj/NEUFs</span>
<a href="#l58.8"></a><span id="l58.8" class="difflineplus">+aWNlIDxhbGljZUBybnA+wpYEExYIAD4WIQRz7cyRGa/I4tu9zeUEUUCWaf/ePAUCXv3VBAIbAwUL</span>
<a href="#l58.9"></a><span id="l58.9" class="difflineplus">+CQgHAgYVCgkICwIEFgIDAQIeAQIXgAUJAPkV1wAKCRAEUUCWaf/ePP4FAQCNXznY8KJThLGqXU34</span>
<a href="#l58.10"></a><span id="l58.10" class="difflineplus">+2JyGobV2qEb/XN0yf50sLQ02KgEAzpkPMaVArBKi3y3jBvNGnGhuBtW4eqbDoZ5XRi3p0QTOTwRe</span>
<a href="#l58.11"></a><span id="l58.11" class="difflineplus">+mYNBEwUrgQQACgIDBFPE8ItgY9glqERWNtvK+Nn1nizHiqOcbhFuW6zK4FfsQcnbodf/CfRjKbe3</span>
<a href="#l58.12"></a><span id="l58.12" class="difflineplus">+XnGpi58+s7xjZdrpYp9JdzZaTmHCwB4EGBYIACYWIQRz7cyRGa/I4tu9zeUEUUCWaf/ePAUCXv3V</span>
<a href="#l58.13"></a><span id="l58.13" class="difflineplus">+BQIbAgUJAGRRxwBqCRAEUUCWaf/ePF8gBBkTCAAGBQJe/dUGAAoJECLzohfA5DnL088A/2o3wWzo</span>
<a href="#l58.14"></a><span id="l58.14" class="difflineplus">+oEzmQXLOdH/WeqeC2s7GxYwYM8mPpWZwZHd/AQDMXPj4HX0p8Qvwk+1Gj7utGLjDb1t8816mO8an</span>
<a href="#l58.15"></a><span id="l58.15" class="difflineplus">+B2MTIb2CAQCTLUSN21aCiEdcCstPza6EGff8QfmmTUDkztcv9MXODwEAloWl4Es42VubkI9G+yOC</span>
<a href="#l58.16"></a><span id="l58.16" class="difflineplus">+mHD+4wEM7QAx5MtV/5d1lwU=</span>
<a href="#l58.17"></a><span id="l58.17" class="difflineplus">+=AXHJ</span>
<a href="#l58.18"></a><span id="l58.18" class="difflineplus">+-----END PGP PUBLIC KEY BLOCK-----</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l59.1"></a><span id="l59.1">new file mode 100644</span>
<a href="#l59.2"></a><span id="l59.2" class="difflineminus">--- /dev/null</span>
<a href="#l59.3"></a><span id="l59.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_validity/alice-sign-sub-exp-sec.asc</span>
<a href="#l59.4"></a><span id="l59.4" class="difflineat">@@ -0,0 +1,17 @@</span>
<a href="#l59.5"></a><span id="l59.5" class="difflineplus">+-----BEGIN PGP PRIVATE KEY BLOCK-----</span>
<a href="#l59.6"></a><span id="l59.6" class="difflineplus">+</span>
<a href="#l59.7"></a><span id="l59.7" class="difflineplus">+xYYEXgS/LxYJKwYBBAHaRw8BAQdAJ/BnDcmcOCED/rW3y1zPHSX6lABI7G19R6mPhgfIgj/+BwMC</span>
<a href="#l59.8"></a><span id="l59.8" class="difflineplus">+Tty9b5Ilu0Ljpjxw8rMT7GLc1MvcD+MxmlIjudT5ZQKX6jSH0VhxvX3cvgsazWZ2Rhu4S1QkNaHa</span>
<a href="#l59.9"></a><span id="l59.9" class="difflineplus">+3PUstbe2HT4n6Igr/pXWkKH4moHJzs0RQWxpY2UgPGFsaWNlQHJucD7ClgQTFggAPhYhBHPtzJEZ</span>
<a href="#l59.10"></a><span id="l59.10" class="difflineplus">+r8ji273N5QRRQJZp/948BQJe/dUEAhsDBQsJCAcCBhUKCQgLAgQWAgMBAh4BAheABQkA+RXXAAoJ</span>
<a href="#l59.11"></a><span id="l59.11" class="difflineplus">+EARRQJZp/948/gUBAI1fOdjwolOEsapdTfjYnIahtXaoRv9c3TJ/nSwtDTYqAQDOmQ8xpUCsEqLf</span>
<a href="#l59.12"></a><span id="l59.12" class="difflineplus">+LeMG80acaG4G1bh6psOhnldGLenRBMeiBF6Zg0ETBSuBBAAKAgMEU8Twi2Bj2CWoRFY228r42fWe</span>
<a href="#l59.13"></a><span id="l59.13" class="difflineplus">+LMeKo5xuEW5brMrgV+xByduh1/8J9GMpt7decamLnz6zvGNl2ulin0l3NlpOYf4HAwKlLd08tunp</span>
<a href="#l59.14"></a><span id="l59.14" class="difflineplus">+b+M8yaWryRt1ixLVhitlej6Ytg/H7gjqpHUSOECgKqJQRrRiDzjqFShgenbGVKvSghp0ZokveXao</span>
<a href="#l59.15"></a><span id="l59.15" class="difflineplus">+rYpSu9GNEUdYnARGszpEwsAeBBgWCAAmFiEEc+3MkRmvyOLbvc3lBFFAlmn/3jwFAl791QUCGwIF</span>
<a href="#l59.16"></a><span id="l59.16" class="difflineplus">+CQBkUccAagkQBFFAlmn/3jxfIAQZEwgABgUCXv3VBgAKCRAi86IXwOQ5y9PPAP9qN8Fs6KBM5kFy</span>
<a href="#l59.17"></a><span id="l59.17" class="difflineplus">+znR/1nqngtrOxsWMGDPJj6VmcGR3fwEAzFz4+B19KfEL8JPtRo+7rRi4w29bfPNepjvGpwdjEyG9</span>
<a href="#l59.18"></a><span id="l59.18" class="difflineplus">+ggEAky1EjdtWgohHXArLT82uhBn3/EH5pk1A5M7XL/TFzg8BAJaFpeBLONlbm5CPRvsjgphw/uMB</span>
<a href="#l59.19"></a><span id="l59.19" class="difflineplus">+DO0AMeTLVf+XdZcF</span>
<a href="#l59.20"></a><span id="l59.20" class="difflineplus">+=O2AD</span>
<a href="#l59.21"></a><span id="l59.21" class="difflineplus">+-----END PGP PRIVATE KEY BLOCK-----</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l60.1"></a><span id="l60.1">new file mode 100644</span>
<a href="#l60.2"></a><span id="l60.2" class="difflineminus">--- /dev/null</span>
<a href="#l60.3"></a><span id="l60.3" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_messages/message.txt.literal</span>
<a href="#l60.4"></a><span id="l60.4" class="difflineat">@@ -0,0 +1,3 @@</span>
<a href="#l60.5"></a><span id="l60.5" class="difflineplus">+bmessage.txt_4This is test message to be signed, and/or encrypted, cleartext signed and detached signed.</span>
<a href="#l60.6"></a><span id="l60.6" class="difflineplus">+It will use keys from keyrings/1.</span>
<a href="#l60.7"></a><span id="l60.7" class="difflineplus">+End of message.</span>
<a href="#l60.8"></a><span id="l60.8">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l61.1"></a><span id="l61.1" class="difflineminus">--- a/third_party/rnp/src/tests/ffi.cpp</span>
<a href="#l61.2"></a><span id="l61.2" class="difflineplus">+++ b/third_party/rnp/src/tests/ffi.cpp</span>
<a href="#l61.3"></a><span id="l61.3" class="difflineat">@@ -32,16 +32,20 @@</span>
<a href="#l61.4"></a><span id="l61.4"> #include &quot;rnp_tests.h&quot;</span>
<a href="#l61.5"></a><span id="l61.5"> #include &quot;support.h&quot;</span>
<a href="#l61.6"></a><span id="l61.6"> #include &quot;librepgp/stream-common.h&quot;</span>
<a href="#l61.7"></a><span id="l61.7"> #include &quot;librepgp/stream-packet.h&quot;</span>
<a href="#l61.8"></a><span id="l61.8"> #include &quot;librepgp/stream-sig.h&quot;</span>
<a href="#l61.9"></a><span id="l61.9"> #include &lt;json.h&gt;</span>
<a href="#l61.10"></a><span id="l61.10"> #include &lt;vector&gt;</span>
<a href="#l61.11"></a><span id="l61.11"> #include &lt;string&gt;</span>
<a href="#l61.12"></a><span id="l61.12" class="difflineplus">+#include &quot;file-utils.h&quot;</span>
<a href="#l61.13"></a><span id="l61.13" class="difflineplus">+#include &lt;librepgp/stream-ctx.h&gt;</span>
<a href="#l61.14"></a><span id="l61.14" class="difflineplus">+#include &quot;pgp-key.h&quot;</span>
<a href="#l61.15"></a><span id="l61.15" class="difflineplus">+#include &quot;ffi-priv-types.h&quot;</span>
<a href="#l61.16"></a><span id="l61.16"> </span>
<a href="#l61.17"></a><span id="l61.17"> TEST_F(rnp_tests, test_ffi_homedir)</span>
<a href="#l61.18"></a><span id="l61.18"> {</span>
<a href="#l61.19"></a><span id="l61.19">     rnp_ffi_t   ffi = NULL;</span>
<a href="#l61.20"></a><span id="l61.20">     char *      pub_format = NULL;</span>
<a href="#l61.21"></a><span id="l61.21">     char *      pub_path = NULL;</span>
<a href="#l61.22"></a><span id="l61.22">     char *      sec_format = NULL;</span>
<a href="#l61.23"></a><span id="l61.23">     char *      sec_path = NULL;</span>
<a href="#l61.24"></a><span id="l61.24" class="difflineat">@@ -767,16 +771,40 @@ check_key_properties(rnp_key_handle_t ke</span>
<a href="#l61.25"></a><span id="l61.25">     bool have_public = !have_public_expected;</span>
<a href="#l61.26"></a><span id="l61.26">     assert_int_equal(RNP_SUCCESS, rnp_key_have_public(key, &amp;have_public));</span>
<a href="#l61.27"></a><span id="l61.27">     assert_true(have_public == have_public_expected);</span>
<a href="#l61.28"></a><span id="l61.28">     bool have_secret = !have_secret_expected;</span>
<a href="#l61.29"></a><span id="l61.29">     assert_int_equal(RNP_SUCCESS, rnp_key_have_secret(key, &amp;have_secret));</span>
<a href="#l61.30"></a><span id="l61.30">     assert_true(have_secret == have_secret_expected);</span>
<a href="#l61.31"></a><span id="l61.31"> }</span>
<a href="#l61.32"></a><span id="l61.32"> </span>
<a href="#l61.33"></a><span id="l61.33" class="difflineplus">+static size_t</span>
<a href="#l61.34"></a><span id="l61.34" class="difflineplus">+get_longest_line_length(const std::string &amp;str, const std::set&lt;std::string&gt; lines_to_skip)</span>
<a href="#l61.35"></a><span id="l61.35" class="difflineplus">+{</span>
<a href="#l61.36"></a><span id="l61.36" class="difflineplus">+    // eol could be \n or \r\n</span>
<a href="#l61.37"></a><span id="l61.37" class="difflineplus">+    size_t index = 0;</span>
<a href="#l61.38"></a><span id="l61.38" class="difflineplus">+    size_t max_len = 0;</span>
<a href="#l61.39"></a><span id="l61.39" class="difflineplus">+    for (;;) {</span>
<a href="#l61.40"></a><span id="l61.40" class="difflineplus">+        auto new_index = str.find('\n', index);</span>
<a href="#l61.41"></a><span id="l61.41" class="difflineplus">+        if (new_index == std::string::npos) {</span>
<a href="#l61.42"></a><span id="l61.42" class="difflineplus">+            break;</span>
<a href="#l61.43"></a><span id="l61.43" class="difflineplus">+        }</span>
<a href="#l61.44"></a><span id="l61.44" class="difflineplus">+        size_t line_length = new_index - index;</span>
<a href="#l61.45"></a><span id="l61.45" class="difflineplus">+        if (str[new_index - 1] == '\r') {</span>
<a href="#l61.46"></a><span id="l61.46" class="difflineplus">+            line_length--;</span>
<a href="#l61.47"></a><span id="l61.47" class="difflineplus">+        }</span>
<a href="#l61.48"></a><span id="l61.48" class="difflineplus">+        if (line_length &gt; max_len &amp;&amp;</span>
<a href="#l61.49"></a><span id="l61.49" class="difflineplus">+            lines_to_skip.find(str.substr(index, line_length)) == lines_to_skip.end()) {</span>
<a href="#l61.50"></a><span id="l61.50" class="difflineplus">+            max_len = line_length;</span>
<a href="#l61.51"></a><span id="l61.51" class="difflineplus">+        }</span>
<a href="#l61.52"></a><span id="l61.52" class="difflineplus">+        index = new_index + 1;</span>
<a href="#l61.53"></a><span id="l61.53" class="difflineplus">+    }</span>
<a href="#l61.54"></a><span id="l61.54" class="difflineplus">+    return max_len;</span>
<a href="#l61.55"></a><span id="l61.55" class="difflineplus">+}</span>
<a href="#l61.56"></a><span id="l61.56" class="difflineplus">+</span>
<a href="#l61.57"></a><span id="l61.57"> TEST_F(rnp_tests, test_ffi_keygen_json_pair)</span>
<a href="#l61.58"></a><span id="l61.58"> {</span>
<a href="#l61.59"></a><span id="l61.59">     rnp_ffi_t ffi = NULL;</span>
<a href="#l61.60"></a><span id="l61.60">     char *    json = NULL;</span>
<a href="#l61.61"></a><span id="l61.61">     char *    results = NULL;</span>
<a href="#l61.62"></a><span id="l61.62">     size_t    count = 0;</span>
<a href="#l61.63"></a><span id="l61.63"> </span>
<a href="#l61.64"></a><span id="l61.64">     // setup FFI</span>
<a href="#l61.65"></a><span id="l61.65" class="difflineat">@@ -4495,16 +4523,81 @@ TEST_F(rnp_tests, test_ffi_enarmor_dearm</span>
<a href="#l61.66"></a><span id="l61.66">             assert_rnp_failure(rnp_dearmor(input, output));</span>
<a href="#l61.67"></a><span id="l61.67"> </span>
<a href="#l61.68"></a><span id="l61.68">             rnp_input_destroy(input);</span>
<a href="#l61.69"></a><span id="l61.69">             rnp_output_destroy(output);</span>
<a href="#l61.70"></a><span id="l61.70">         }</span>
<a href="#l61.71"></a><span id="l61.71">     }</span>
<a href="#l61.72"></a><span id="l61.72"> }</span>
<a href="#l61.73"></a><span id="l61.73"> </span>
<a href="#l61.74"></a><span id="l61.74" class="difflineplus">+TEST_F(rnp_tests, test_ffi_customized_enarmor)</span>
<a href="#l61.75"></a><span id="l61.75" class="difflineplus">+{</span>
<a href="#l61.76"></a><span id="l61.76" class="difflineplus">+    rnp_input_t           input = NULL;</span>
<a href="#l61.77"></a><span id="l61.77" class="difflineplus">+    rnp_output_t          output = NULL;</span>
<a href="#l61.78"></a><span id="l61.78" class="difflineplus">+    rnp_output_t          armor_layer = NULL;</span>
<a href="#l61.79"></a><span id="l61.79" class="difflineplus">+    const std::string     msg(&quot;this is a test long enough to have more than 76 characters in &quot;</span>
<a href="#l61.80"></a><span id="l61.80" class="difflineplus">+                          &quot;enarmored representation&quot;);</span>
<a href="#l61.81"></a><span id="l61.81" class="difflineplus">+    std::set&lt;std::string&gt; lines_to_skip{&quot;-----BEGIN PGP MESSAGE-----&quot;,</span>
<a href="#l61.82"></a><span id="l61.82" class="difflineplus">+                                        &quot;-----END PGP MESSAGE-----&quot;};</span>
<a href="#l61.83"></a><span id="l61.83" class="difflineplus">+</span>
<a href="#l61.84"></a><span id="l61.84" class="difflineplus">+    assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.85"></a><span id="l61.85" class="difflineplus">+    assert_rnp_success(rnp_output_to_armor(output, &amp;armor_layer, &quot;message&quot;));</span>
<a href="#l61.86"></a><span id="l61.86" class="difflineplus">+    // should fail when trying to set line length on non-armor output</span>
<a href="#l61.87"></a><span id="l61.87" class="difflineplus">+    assert_rnp_failure(rnp_output_armor_set_line_length(output, 64));</span>
<a href="#l61.88"></a><span id="l61.88" class="difflineplus">+    // should fail when trying to set zero line length</span>
<a href="#l61.89"></a><span id="l61.89" class="difflineplus">+    assert_rnp_failure(rnp_output_armor_set_line_length(armor_layer, 0));</span>
<a href="#l61.90"></a><span id="l61.90" class="difflineplus">+    // should fail when trying to set line length less than the minimum allowed 16</span>
<a href="#l61.91"></a><span id="l61.91" class="difflineplus">+    assert_rnp_failure(rnp_output_armor_set_line_length(armor_layer, 15));</span>
<a href="#l61.92"></a><span id="l61.92" class="difflineplus">+    assert_rnp_success(rnp_output_armor_set_line_length(armor_layer, 16));</span>
<a href="#l61.93"></a><span id="l61.93" class="difflineplus">+    assert_rnp_success(rnp_output_armor_set_line_length(armor_layer, 76));</span>
<a href="#l61.94"></a><span id="l61.94" class="difflineplus">+    // should fail when trying to set line length greater than the maximum allowed 76</span>
<a href="#l61.95"></a><span id="l61.95" class="difflineplus">+    assert_rnp_failure(rnp_output_armor_set_line_length(armor_layer, 77));</span>
<a href="#l61.96"></a><span id="l61.96" class="difflineplus">+    assert_rnp_success(rnp_output_destroy(armor_layer));</span>
<a href="#l61.97"></a><span id="l61.97" class="difflineplus">+    assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l61.98"></a><span id="l61.98" class="difflineplus">+</span>
<a href="#l61.99"></a><span id="l61.99" class="difflineplus">+    for (size_t llen = 16; llen &lt;= 76; llen++) {</span>
<a href="#l61.100"></a><span id="l61.100" class="difflineplus">+        std::string data;</span>
<a href="#l61.101"></a><span id="l61.101" class="difflineplus">+        uint8_t *   buf = NULL;</span>
<a href="#l61.102"></a><span id="l61.102" class="difflineplus">+        size_t      buf_size = 0;</span>
<a href="#l61.103"></a><span id="l61.103" class="difflineplus">+</span>
<a href="#l61.104"></a><span id="l61.104" class="difflineplus">+        input = NULL;</span>
<a href="#l61.105"></a><span id="l61.105" class="difflineplus">+        output = NULL;</span>
<a href="#l61.106"></a><span id="l61.106" class="difflineplus">+        armor_layer = NULL;</span>
<a href="#l61.107"></a><span id="l61.107" class="difflineplus">+        assert_rnp_success(</span>
<a href="#l61.108"></a><span id="l61.108" class="difflineplus">+          rnp_input_from_memory(&amp;input, (const uint8_t *) msg.data(), msg.size(), true));</span>
<a href="#l61.109"></a><span id="l61.109" class="difflineplus">+        assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.110"></a><span id="l61.110" class="difflineplus">+        assert_rnp_success(rnp_output_to_armor(output, &amp;armor_layer, &quot;message&quot;));</span>
<a href="#l61.111"></a><span id="l61.111" class="difflineplus">+        assert_rnp_success(rnp_output_armor_set_line_length(armor_layer, llen));</span>
<a href="#l61.112"></a><span id="l61.112" class="difflineplus">+        assert_rnp_success(rnp_output_pipe(input, armor_layer));</span>
<a href="#l61.113"></a><span id="l61.113" class="difflineplus">+        assert_rnp_success(rnp_output_finish(armor_layer));</span>
<a href="#l61.114"></a><span id="l61.114" class="difflineplus">+        assert_rnp_success(rnp_output_memory_get_buf(output, &amp;buf, &amp;buf_size, false));</span>
<a href="#l61.115"></a><span id="l61.115" class="difflineplus">+        data = std::string(buf, buf + buf_size);</span>
<a href="#l61.116"></a><span id="l61.116" class="difflineplus">+        auto effective_llen = get_longest_line_length(data, lines_to_skip);</span>
<a href="#l61.117"></a><span id="l61.117" class="difflineplus">+        assert_int_equal(llen / 4, effective_llen / 4);</span>
<a href="#l61.118"></a><span id="l61.118" class="difflineplus">+        assert_true(llen &gt;= effective_llen);</span>
<a href="#l61.119"></a><span id="l61.119" class="difflineplus">+        assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.120"></a><span id="l61.120" class="difflineplus">+        assert_rnp_success(rnp_output_destroy(armor_layer));</span>
<a href="#l61.121"></a><span id="l61.121" class="difflineplus">+        assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l61.122"></a><span id="l61.122" class="difflineplus">+</span>
<a href="#l61.123"></a><span id="l61.123" class="difflineplus">+        // test that the dearmored message is correct</span>
<a href="#l61.124"></a><span id="l61.124" class="difflineplus">+        assert_rnp_success(</span>
<a href="#l61.125"></a><span id="l61.125" class="difflineplus">+          rnp_input_from_memory(&amp;input, (const uint8_t *) data.data(), data.size(), true));</span>
<a href="#l61.126"></a><span id="l61.126" class="difflineplus">+        assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.127"></a><span id="l61.127" class="difflineplus">+</span>
<a href="#l61.128"></a><span id="l61.128" class="difflineplus">+        assert_rnp_success(rnp_dearmor(input, output));</span>
<a href="#l61.129"></a><span id="l61.129" class="difflineplus">+</span>
<a href="#l61.130"></a><span id="l61.130" class="difflineplus">+        assert_rnp_success(rnp_output_memory_get_buf(output, &amp;buf, &amp;buf_size, false));</span>
<a href="#l61.131"></a><span id="l61.131" class="difflineplus">+        std::string dearmored(buf, buf + buf_size);</span>
<a href="#l61.132"></a><span id="l61.132" class="difflineplus">+        assert_true(msg == dearmored);</span>
<a href="#l61.133"></a><span id="l61.133" class="difflineplus">+</span>
<a href="#l61.134"></a><span id="l61.134" class="difflineplus">+        assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.135"></a><span id="l61.135" class="difflineplus">+        assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l61.136"></a><span id="l61.136" class="difflineplus">+    }</span>
<a href="#l61.137"></a><span id="l61.137" class="difflineplus">+}</span>
<a href="#l61.138"></a><span id="l61.138" class="difflineplus">+</span>
<a href="#l61.139"></a><span id="l61.139"> TEST_F(rnp_tests, test_ffi_version)</span>
<a href="#l61.140"></a><span id="l61.140"> {</span>
<a href="#l61.141"></a><span id="l61.141">     const uint32_t version = rnp_version();</span>
<a href="#l61.142"></a><span id="l61.142">     const uint32_t major = rnp_version_major(version);</span>
<a href="#l61.143"></a><span id="l61.143">     const uint32_t minor = rnp_version_minor(version);</span>
<a href="#l61.144"></a><span id="l61.144">     const uint32_t patch = rnp_version_patch(version);</span>
<a href="#l61.145"></a><span id="l61.145"> </span>
<a href="#l61.146"></a><span id="l61.146">     // reconstruct the version string</span>
<a href="#l61.147"></a><span id="l61.147" class="difflineat">@@ -4797,16 +4890,206 @@ TEST_F(rnp_tests, test_ffi_key_export)</span>
<a href="#l61.148"></a><span id="l61.148">         rnp_output_destroy(output);</span>
<a href="#l61.149"></a><span id="l61.149">         rnp_key_handle_destroy(key);</span>
<a href="#l61.150"></a><span id="l61.150">     }</span>
<a href="#l61.151"></a><span id="l61.151"> </span>
<a href="#l61.152"></a><span id="l61.152">     // cleanup</span>
<a href="#l61.153"></a><span id="l61.153">     rnp_ffi_destroy(ffi);</span>
<a href="#l61.154"></a><span id="l61.154"> }</span>
<a href="#l61.155"></a><span id="l61.155"> </span>
<a href="#l61.156"></a><span id="l61.156" class="difflineplus">+TEST_F(rnp_tests, test_ffi_key_export_customized_enarmor)</span>
<a href="#l61.157"></a><span id="l61.157" class="difflineplus">+{</span>
<a href="#l61.158"></a><span id="l61.158" class="difflineplus">+    rnp_ffi_t             ffi = NULL;</span>
<a href="#l61.159"></a><span id="l61.159" class="difflineplus">+    rnp_input_t           input = NULL;</span>
<a href="#l61.160"></a><span id="l61.160" class="difflineplus">+    rnp_output_t          output = NULL;</span>
<a href="#l61.161"></a><span id="l61.161" class="difflineplus">+    rnp_output_t          armor_layer = NULL;</span>
<a href="#l61.162"></a><span id="l61.162" class="difflineplus">+    rnp_key_handle_t      key = NULL;</span>
<a href="#l61.163"></a><span id="l61.163" class="difflineplus">+    uint8_t *             buf = NULL;</span>
<a href="#l61.164"></a><span id="l61.164" class="difflineplus">+    size_t                buf_len = 0;</span>
<a href="#l61.165"></a><span id="l61.165" class="difflineplus">+    std::set&lt;std::string&gt; lines_to_skip{&quot;-----BEGIN PGP PUBLIC KEY BLOCK-----&quot;,</span>
<a href="#l61.166"></a><span id="l61.166" class="difflineplus">+                                        &quot;-----END PGP PUBLIC KEY BLOCK-----&quot;,</span>
<a href="#l61.167"></a><span id="l61.167" class="difflineplus">+                                        &quot;-----BEGIN PGP PRIVATE KEY BLOCK-----&quot;,</span>
<a href="#l61.168"></a><span id="l61.168" class="difflineplus">+                                        &quot;-----END PGP PRIVATE KEY BLOCK-----&quot;};</span>
<a href="#l61.169"></a><span id="l61.169" class="difflineplus">+    // setup FFI</span>
<a href="#l61.170"></a><span id="l61.170" class="difflineplus">+    assert_int_equal(RNP_SUCCESS, rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l61.171"></a><span id="l61.171" class="difflineplus">+</span>
<a href="#l61.172"></a><span id="l61.172" class="difflineplus">+    // load our keyrings</span>
<a href="#l61.173"></a><span id="l61.173" class="difflineplus">+    assert_int_equal(RNP_SUCCESS, rnp_input_from_path(&amp;input, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l61.174"></a><span id="l61.174" class="difflineplus">+    assert_int_equal(RNP_SUCCESS, rnp_load_keys(ffi, &quot;GPG&quot;, input, RNP_LOAD_SAVE_PUBLIC_KEYS));</span>
<a href="#l61.175"></a><span id="l61.175" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.176"></a><span id="l61.176" class="difflineplus">+    input = NULL;</span>
<a href="#l61.177"></a><span id="l61.177" class="difflineplus">+    assert_int_equal(RNP_SUCCESS, rnp_input_from_path(&amp;input, &quot;data/keyrings/1/secring.gpg&quot;));</span>
<a href="#l61.178"></a><span id="l61.178" class="difflineplus">+    assert_int_equal(RNP_SUCCESS, rnp_load_keys(ffi, &quot;GPG&quot;, input, RNP_LOAD_SAVE_SECRET_KEYS));</span>
<a href="#l61.179"></a><span id="l61.179" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.180"></a><span id="l61.180" class="difflineplus">+    input = NULL;</span>
<a href="#l61.181"></a><span id="l61.181" class="difflineplus">+</span>
<a href="#l61.182"></a><span id="l61.182" class="difflineplus">+    for (size_t llen = 16; llen &lt;= 76; llen++) {</span>
<a href="#l61.183"></a><span id="l61.183" class="difflineplus">+        // primary pub only</span>
<a href="#l61.184"></a><span id="l61.184" class="difflineplus">+        {</span>
<a href="#l61.185"></a><span id="l61.185" class="difflineplus">+            // locate key</span>
<a href="#l61.186"></a><span id="l61.186" class="difflineplus">+            key = NULL;</span>
<a href="#l61.187"></a><span id="l61.187" class="difflineplus">+            assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;2FCADF05FFA501BB&quot;, &amp;key));</span>
<a href="#l61.188"></a><span id="l61.188" class="difflineplus">+            assert_non_null(key);</span>
<a href="#l61.189"></a><span id="l61.189" class="difflineplus">+</span>
<a href="#l61.190"></a><span id="l61.190" class="difflineplus">+            // create output</span>
<a href="#l61.191"></a><span id="l61.191" class="difflineplus">+            output = NULL;</span>
<a href="#l61.192"></a><span id="l61.192" class="difflineplus">+            assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.193"></a><span id="l61.193" class="difflineplus">+            assert_non_null(output);</span>
<a href="#l61.194"></a><span id="l61.194" class="difflineplus">+            assert_rnp_success(rnp_output_to_armor(output, &amp;armor_layer, &quot;public key&quot;));</span>
<a href="#l61.195"></a><span id="l61.195" class="difflineplus">+            assert_non_null(armor_layer);</span>
<a href="#l61.196"></a><span id="l61.196" class="difflineplus">+            assert_rnp_success(rnp_output_armor_set_line_length(armor_layer, llen));</span>
<a href="#l61.197"></a><span id="l61.197" class="difflineplus">+</span>
<a href="#l61.198"></a><span id="l61.198" class="difflineplus">+            // export</span>
<a href="#l61.199"></a><span id="l61.199" class="difflineplus">+            assert_rnp_success(rnp_key_export(key, armor_layer, RNP_KEY_EXPORT_PUBLIC));</span>
<a href="#l61.200"></a><span id="l61.200" class="difflineplus">+            assert_rnp_success(rnp_output_finish(armor_layer));</span>
<a href="#l61.201"></a><span id="l61.201" class="difflineplus">+            // get output</span>
<a href="#l61.202"></a><span id="l61.202" class="difflineplus">+            buf = NULL;</span>
<a href="#l61.203"></a><span id="l61.203" class="difflineplus">+            assert_rnp_success(rnp_output_memory_get_buf(output, &amp;buf, &amp;buf_len, false));</span>
<a href="#l61.204"></a><span id="l61.204" class="difflineplus">+            assert_non_null(buf);</span>
<a href="#l61.205"></a><span id="l61.205" class="difflineplus">+            std::string data = std::string(buf, buf + buf_len);</span>
<a href="#l61.206"></a><span id="l61.206" class="difflineplus">+            auto        effective_llen = get_longest_line_length(data, lines_to_skip);</span>
<a href="#l61.207"></a><span id="l61.207" class="difflineplus">+            assert_int_equal(llen / 4, effective_llen / 4);</span>
<a href="#l61.208"></a><span id="l61.208" class="difflineplus">+            assert_true(llen &gt;= effective_llen);</span>
<a href="#l61.209"></a><span id="l61.209" class="difflineplus">+</span>
<a href="#l61.210"></a><span id="l61.210" class="difflineplus">+            // check results</span>
<a href="#l61.211"></a><span id="l61.211" class="difflineplus">+            check_loaded_keys(&quot;GPG&quot;, true, buf, buf_len, &quot;keyid&quot;, {&quot;2FCADF05FFA501BB&quot;}, false);</span>
<a href="#l61.212"></a><span id="l61.212" class="difflineplus">+</span>
<a href="#l61.213"></a><span id="l61.213" class="difflineplus">+            // cleanup</span>
<a href="#l61.214"></a><span id="l61.214" class="difflineplus">+            rnp_output_destroy(armor_layer);</span>
<a href="#l61.215"></a><span id="l61.215" class="difflineplus">+            rnp_output_destroy(output);</span>
<a href="#l61.216"></a><span id="l61.216" class="difflineplus">+            rnp_key_handle_destroy(key);</span>
<a href="#l61.217"></a><span id="l61.217" class="difflineplus">+        }</span>
<a href="#l61.218"></a><span id="l61.218" class="difflineplus">+</span>
<a href="#l61.219"></a><span id="l61.219" class="difflineplus">+        // primary sec only</span>
<a href="#l61.220"></a><span id="l61.220" class="difflineplus">+        {</span>
<a href="#l61.221"></a><span id="l61.221" class="difflineplus">+            // locate key</span>
<a href="#l61.222"></a><span id="l61.222" class="difflineplus">+            key = NULL;</span>
<a href="#l61.223"></a><span id="l61.223" class="difflineplus">+            assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;2FCADF05FFA501BB&quot;, &amp;key));</span>
<a href="#l61.224"></a><span id="l61.224" class="difflineplus">+            assert_non_null(key);</span>
<a href="#l61.225"></a><span id="l61.225" class="difflineplus">+</span>
<a href="#l61.226"></a><span id="l61.226" class="difflineplus">+            // create output</span>
<a href="#l61.227"></a><span id="l61.227" class="difflineplus">+            output = NULL;</span>
<a href="#l61.228"></a><span id="l61.228" class="difflineplus">+            assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.229"></a><span id="l61.229" class="difflineplus">+            assert_non_null(output);</span>
<a href="#l61.230"></a><span id="l61.230" class="difflineplus">+            assert_rnp_success(rnp_output_to_armor(output, &amp;armor_layer, &quot;secret key&quot;));</span>
<a href="#l61.231"></a><span id="l61.231" class="difflineplus">+            assert_non_null(armor_layer);</span>
<a href="#l61.232"></a><span id="l61.232" class="difflineplus">+            assert_rnp_success(rnp_output_armor_set_line_length(armor_layer, llen));</span>
<a href="#l61.233"></a><span id="l61.233" class="difflineplus">+</span>
<a href="#l61.234"></a><span id="l61.234" class="difflineplus">+            // export</span>
<a href="#l61.235"></a><span id="l61.235" class="difflineplus">+            assert_rnp_success(rnp_key_export(key, armor_layer, RNP_KEY_EXPORT_SECRET));</span>
<a href="#l61.236"></a><span id="l61.236" class="difflineplus">+            assert_rnp_success(rnp_output_finish(armor_layer));</span>
<a href="#l61.237"></a><span id="l61.237" class="difflineplus">+</span>
<a href="#l61.238"></a><span id="l61.238" class="difflineplus">+            // get output</span>
<a href="#l61.239"></a><span id="l61.239" class="difflineplus">+            buf = NULL;</span>
<a href="#l61.240"></a><span id="l61.240" class="difflineplus">+            assert_rnp_success(rnp_output_memory_get_buf(output, &amp;buf, &amp;buf_len, false));</span>
<a href="#l61.241"></a><span id="l61.241" class="difflineplus">+            assert_non_null(buf);</span>
<a href="#l61.242"></a><span id="l61.242" class="difflineplus">+            std::string data = std::string(buf, buf + buf_len);</span>
<a href="#l61.243"></a><span id="l61.243" class="difflineplus">+            auto        effective_llen = get_longest_line_length(data, lines_to_skip);</span>
<a href="#l61.244"></a><span id="l61.244" class="difflineplus">+            assert_int_equal(llen / 4, effective_llen / 4);</span>
<a href="#l61.245"></a><span id="l61.245" class="difflineplus">+            assert_true(llen &gt;= effective_llen);</span>
<a href="#l61.246"></a><span id="l61.246" class="difflineplus">+</span>
<a href="#l61.247"></a><span id="l61.247" class="difflineplus">+            // check results</span>
<a href="#l61.248"></a><span id="l61.248" class="difflineplus">+            check_loaded_keys(&quot;GPG&quot;, true, buf, buf_len, &quot;keyid&quot;, {&quot;2FCADF05FFA501BB&quot;}, true);</span>
<a href="#l61.249"></a><span id="l61.249" class="difflineplus">+</span>
<a href="#l61.250"></a><span id="l61.250" class="difflineplus">+            // cleanup</span>
<a href="#l61.251"></a><span id="l61.251" class="difflineplus">+            rnp_output_destroy(armor_layer);</span>
<a href="#l61.252"></a><span id="l61.252" class="difflineplus">+            rnp_output_destroy(output);</span>
<a href="#l61.253"></a><span id="l61.253" class="difflineplus">+            rnp_key_handle_destroy(key);</span>
<a href="#l61.254"></a><span id="l61.254" class="difflineplus">+        }</span>
<a href="#l61.255"></a><span id="l61.255" class="difflineplus">+</span>
<a href="#l61.256"></a><span id="l61.256" class="difflineplus">+        // sub pub</span>
<a href="#l61.257"></a><span id="l61.257" class="difflineplus">+        {</span>
<a href="#l61.258"></a><span id="l61.258" class="difflineplus">+            // locate key</span>
<a href="#l61.259"></a><span id="l61.259" class="difflineplus">+            key = NULL;</span>
<a href="#l61.260"></a><span id="l61.260" class="difflineplus">+            assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;54505A936A4A970E&quot;, &amp;key));</span>
<a href="#l61.261"></a><span id="l61.261" class="difflineplus">+            assert_non_null(key);</span>
<a href="#l61.262"></a><span id="l61.262" class="difflineplus">+</span>
<a href="#l61.263"></a><span id="l61.263" class="difflineplus">+            // create output</span>
<a href="#l61.264"></a><span id="l61.264" class="difflineplus">+            output = NULL;</span>
<a href="#l61.265"></a><span id="l61.265" class="difflineplus">+            assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.266"></a><span id="l61.266" class="difflineplus">+            assert_non_null(output);</span>
<a href="#l61.267"></a><span id="l61.267" class="difflineplus">+            assert_rnp_success(rnp_output_to_armor(output, &amp;armor_layer, &quot;public key&quot;));</span>
<a href="#l61.268"></a><span id="l61.268" class="difflineplus">+            assert_non_null(armor_layer);</span>
<a href="#l61.269"></a><span id="l61.269" class="difflineplus">+            assert_rnp_success(rnp_output_armor_set_line_length(armor_layer, llen));</span>
<a href="#l61.270"></a><span id="l61.270" class="difflineplus">+</span>
<a href="#l61.271"></a><span id="l61.271" class="difflineplus">+            // export</span>
<a href="#l61.272"></a><span id="l61.272" class="difflineplus">+            assert_rnp_success(rnp_key_export(key, armor_layer, RNP_KEY_EXPORT_PUBLIC));</span>
<a href="#l61.273"></a><span id="l61.273" class="difflineplus">+            assert_rnp_success(rnp_output_finish(armor_layer));</span>
<a href="#l61.274"></a><span id="l61.274" class="difflineplus">+</span>
<a href="#l61.275"></a><span id="l61.275" class="difflineplus">+            // get output</span>
<a href="#l61.276"></a><span id="l61.276" class="difflineplus">+            buf = NULL;</span>
<a href="#l61.277"></a><span id="l61.277" class="difflineplus">+            assert_rnp_success(rnp_output_memory_get_buf(output, &amp;buf, &amp;buf_len, false));</span>
<a href="#l61.278"></a><span id="l61.278" class="difflineplus">+            assert_non_null(buf);</span>
<a href="#l61.279"></a><span id="l61.279" class="difflineplus">+            std::string data = std::string(buf, buf + buf_len);</span>
<a href="#l61.280"></a><span id="l61.280" class="difflineplus">+            auto        effective_llen = get_longest_line_length(data, lines_to_skip);</span>
<a href="#l61.281"></a><span id="l61.281" class="difflineplus">+            assert_int_equal(llen / 4, effective_llen / 4);</span>
<a href="#l61.282"></a><span id="l61.282" class="difflineplus">+            assert_true(llen &gt;= effective_llen);</span>
<a href="#l61.283"></a><span id="l61.283" class="difflineplus">+</span>
<a href="#l61.284"></a><span id="l61.284" class="difflineplus">+            // check results</span>
<a href="#l61.285"></a><span id="l61.285" class="difflineplus">+            check_loaded_keys(&quot;GPG&quot;,</span>
<a href="#l61.286"></a><span id="l61.286" class="difflineplus">+                              true,</span>
<a href="#l61.287"></a><span id="l61.287" class="difflineplus">+                              buf,</span>
<a href="#l61.288"></a><span id="l61.288" class="difflineplus">+                              buf_len,</span>
<a href="#l61.289"></a><span id="l61.289" class="difflineplus">+                              &quot;keyid&quot;,</span>
<a href="#l61.290"></a><span id="l61.290" class="difflineplus">+                              {&quot;2FCADF05FFA501BB&quot;, &quot;54505A936A4A970E&quot;},</span>
<a href="#l61.291"></a><span id="l61.291" class="difflineplus">+                              false);</span>
<a href="#l61.292"></a><span id="l61.292" class="difflineplus">+</span>
<a href="#l61.293"></a><span id="l61.293" class="difflineplus">+            // cleanup</span>
<a href="#l61.294"></a><span id="l61.294" class="difflineplus">+            rnp_output_destroy(armor_layer);</span>
<a href="#l61.295"></a><span id="l61.295" class="difflineplus">+            rnp_output_destroy(output);</span>
<a href="#l61.296"></a><span id="l61.296" class="difflineplus">+            rnp_key_handle_destroy(key);</span>
<a href="#l61.297"></a><span id="l61.297" class="difflineplus">+        }</span>
<a href="#l61.298"></a><span id="l61.298" class="difflineplus">+</span>
<a href="#l61.299"></a><span id="l61.299" class="difflineplus">+        // sub sec</span>
<a href="#l61.300"></a><span id="l61.300" class="difflineplus">+        {</span>
<a href="#l61.301"></a><span id="l61.301" class="difflineplus">+            // locate key</span>
<a href="#l61.302"></a><span id="l61.302" class="difflineplus">+            key = NULL;</span>
<a href="#l61.303"></a><span id="l61.303" class="difflineplus">+            assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;54505A936A4A970E&quot;, &amp;key));</span>
<a href="#l61.304"></a><span id="l61.304" class="difflineplus">+            assert_non_null(key);</span>
<a href="#l61.305"></a><span id="l61.305" class="difflineplus">+</span>
<a href="#l61.306"></a><span id="l61.306" class="difflineplus">+            // create output</span>
<a href="#l61.307"></a><span id="l61.307" class="difflineplus">+            output = NULL;</span>
<a href="#l61.308"></a><span id="l61.308" class="difflineplus">+            assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.309"></a><span id="l61.309" class="difflineplus">+            assert_non_null(output);</span>
<a href="#l61.310"></a><span id="l61.310" class="difflineplus">+            assert_rnp_success(rnp_output_to_armor(output, &amp;armor_layer, &quot;secret key&quot;));</span>
<a href="#l61.311"></a><span id="l61.311" class="difflineplus">+            assert_non_null(armor_layer);</span>
<a href="#l61.312"></a><span id="l61.312" class="difflineplus">+            assert_rnp_success(rnp_output_armor_set_line_length(armor_layer, llen));</span>
<a href="#l61.313"></a><span id="l61.313" class="difflineplus">+</span>
<a href="#l61.314"></a><span id="l61.314" class="difflineplus">+            // export</span>
<a href="#l61.315"></a><span id="l61.315" class="difflineplus">+            assert_rnp_success(rnp_key_export(key, armor_layer, RNP_KEY_EXPORT_SECRET));</span>
<a href="#l61.316"></a><span id="l61.316" class="difflineplus">+            assert_rnp_success(rnp_output_finish(armor_layer));</span>
<a href="#l61.317"></a><span id="l61.317" class="difflineplus">+</span>
<a href="#l61.318"></a><span id="l61.318" class="difflineplus">+            // get output</span>
<a href="#l61.319"></a><span id="l61.319" class="difflineplus">+            buf = NULL;</span>
<a href="#l61.320"></a><span id="l61.320" class="difflineplus">+            assert_rnp_success(rnp_output_memory_get_buf(output, &amp;buf, &amp;buf_len, false));</span>
<a href="#l61.321"></a><span id="l61.321" class="difflineplus">+            assert_non_null(buf);</span>
<a href="#l61.322"></a><span id="l61.322" class="difflineplus">+            std::string data = std::string(buf, buf + buf_len);</span>
<a href="#l61.323"></a><span id="l61.323" class="difflineplus">+            auto        effective_llen = get_longest_line_length(data, lines_to_skip);</span>
<a href="#l61.324"></a><span id="l61.324" class="difflineplus">+            assert_int_equal(llen / 4, effective_llen / 4);</span>
<a href="#l61.325"></a><span id="l61.325" class="difflineplus">+            assert_true(llen &gt;= effective_llen);</span>
<a href="#l61.326"></a><span id="l61.326" class="difflineplus">+</span>
<a href="#l61.327"></a><span id="l61.327" class="difflineplus">+            // check results</span>
<a href="#l61.328"></a><span id="l61.328" class="difflineplus">+            check_loaded_keys(&quot;GPG&quot;,</span>
<a href="#l61.329"></a><span id="l61.329" class="difflineplus">+                              true,</span>
<a href="#l61.330"></a><span id="l61.330" class="difflineplus">+                              buf,</span>
<a href="#l61.331"></a><span id="l61.331" class="difflineplus">+                              buf_len,</span>
<a href="#l61.332"></a><span id="l61.332" class="difflineplus">+                              &quot;keyid&quot;,</span>
<a href="#l61.333"></a><span id="l61.333" class="difflineplus">+                              {&quot;2FCADF05FFA501BB&quot;, &quot;54505A936A4A970E&quot;},</span>
<a href="#l61.334"></a><span id="l61.334" class="difflineplus">+                              true);</span>
<a href="#l61.335"></a><span id="l61.335" class="difflineplus">+</span>
<a href="#l61.336"></a><span id="l61.336" class="difflineplus">+            // cleanup</span>
<a href="#l61.337"></a><span id="l61.337" class="difflineplus">+            rnp_output_destroy(armor_layer);</span>
<a href="#l61.338"></a><span id="l61.338" class="difflineplus">+            rnp_output_destroy(output);</span>
<a href="#l61.339"></a><span id="l61.339" class="difflineplus">+            rnp_key_handle_destroy(key);</span>
<a href="#l61.340"></a><span id="l61.340" class="difflineplus">+        }</span>
<a href="#l61.341"></a><span id="l61.341" class="difflineplus">+    }</span>
<a href="#l61.342"></a><span id="l61.342" class="difflineplus">+    // cleanup</span>
<a href="#l61.343"></a><span id="l61.343" class="difflineplus">+    rnp_ffi_destroy(ffi);</span>
<a href="#l61.344"></a><span id="l61.344" class="difflineplus">+}</span>
<a href="#l61.345"></a><span id="l61.345" class="difflineplus">+</span>
<a href="#l61.346"></a><span id="l61.346"> TEST_F(rnp_tests, test_ffi_key_dump)</span>
<a href="#l61.347"></a><span id="l61.347"> {</span>
<a href="#l61.348"></a><span id="l61.348">     rnp_ffi_t        ffi = NULL;</span>
<a href="#l61.349"></a><span id="l61.349">     rnp_input_t      input = NULL;</span>
<a href="#l61.350"></a><span id="l61.350">     rnp_key_handle_t key = NULL;</span>
<a href="#l61.351"></a><span id="l61.351">     char *           json = NULL;</span>
<a href="#l61.352"></a><span id="l61.352">     json_object *    jso = NULL;</span>
<a href="#l61.353"></a><span id="l61.353"> </span>
<a href="#l61.354"></a><span id="l61.354" class="difflineat">@@ -6195,21 +6478,21 @@ TEST_F(rnp_tests, test_ffi_enable_debug)</span>
<a href="#l61.355"></a><span id="l61.355"> TEST_F(rnp_tests, test_ffi_rnp_key_get_primary_grip)</span>
<a href="#l61.356"></a><span id="l61.356"> {</span>
<a href="#l61.357"></a><span id="l61.357">     rnp_ffi_t        ffi = NULL;</span>
<a href="#l61.358"></a><span id="l61.358">     rnp_input_t      input = NULL;</span>
<a href="#l61.359"></a><span id="l61.359">     rnp_key_handle_t key = NULL;</span>
<a href="#l61.360"></a><span id="l61.360">     char *           grip = NULL;</span>
<a href="#l61.361"></a><span id="l61.361"> </span>
<a href="#l61.362"></a><span id="l61.362">     // setup FFI</span>
<a href="#l61.363"></a><span id="l61.363" class="difflineminus">-    assert_int_equal(RNP_SUCCESS, rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l61.364"></a><span id="l61.364" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l61.365"></a><span id="l61.365"> </span>
<a href="#l61.366"></a><span id="l61.366">     // load our keyrings</span>
<a href="#l61.367"></a><span id="l61.367" class="difflineminus">-    assert_int_equal(RNP_SUCCESS, rnp_input_from_path(&amp;input, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l61.368"></a><span id="l61.368" class="difflineminus">-    assert_int_equal(RNP_SUCCESS, rnp_load_keys(ffi, &quot;GPG&quot;, input, RNP_LOAD_SAVE_PUBLIC_KEYS));</span>
<a href="#l61.369"></a><span id="l61.369" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l61.370"></a><span id="l61.370" class="difflineplus">+    assert_rnp_success(rnp_load_keys(ffi, &quot;GPG&quot;, input, RNP_LOAD_SAVE_PUBLIC_KEYS));</span>
<a href="#l61.371"></a><span id="l61.371">     rnp_input_destroy(input);</span>
<a href="#l61.372"></a><span id="l61.372"> </span>
<a href="#l61.373"></a><span id="l61.373">     // locate primary key</span>
<a href="#l61.374"></a><span id="l61.374">     key = NULL;</span>
<a href="#l61.375"></a><span id="l61.375">     assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7BC6709B15C23A4A&quot;, &amp;key));</span>
<a href="#l61.376"></a><span id="l61.376">     assert_non_null(key);</span>
<a href="#l61.377"></a><span id="l61.377"> </span>
<a href="#l61.378"></a><span id="l61.378">     // some edge cases</span>
<a href="#l61.379"></a><span id="l61.379" class="difflineat">@@ -6252,16 +6535,103 @@ TEST_F(rnp_tests, test_ffi_rnp_key_get_p</span>
<a href="#l61.380"></a><span id="l61.380">     rnp_buffer_destroy(grip);</span>
<a href="#l61.381"></a><span id="l61.381">     grip = NULL;</span>
<a href="#l61.382"></a><span id="l61.382">     rnp_key_handle_destroy(key);</span>
<a href="#l61.383"></a><span id="l61.383"> </span>
<a href="#l61.384"></a><span id="l61.384">     // cleanup</span>
<a href="#l61.385"></a><span id="l61.385">     rnp_ffi_destroy(ffi);</span>
<a href="#l61.386"></a><span id="l61.386"> }</span>
<a href="#l61.387"></a><span id="l61.387"> </span>
<a href="#l61.388"></a><span id="l61.388" class="difflineplus">+TEST_F(rnp_tests, test_ffi_rnp_key_get_primary_fprint)</span>
<a href="#l61.389"></a><span id="l61.389" class="difflineplus">+{</span>
<a href="#l61.390"></a><span id="l61.390" class="difflineplus">+    rnp_ffi_t        ffi = NULL;</span>
<a href="#l61.391"></a><span id="l61.391" class="difflineplus">+    rnp_input_t      input = NULL;</span>
<a href="#l61.392"></a><span id="l61.392" class="difflineplus">+    rnp_key_handle_t key = NULL;</span>
<a href="#l61.393"></a><span id="l61.393" class="difflineplus">+    char *           fp = NULL;</span>
<a href="#l61.394"></a><span id="l61.394" class="difflineplus">+</span>
<a href="#l61.395"></a><span id="l61.395" class="difflineplus">+    // setup FFI</span>
<a href="#l61.396"></a><span id="l61.396" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l61.397"></a><span id="l61.397" class="difflineplus">+</span>
<a href="#l61.398"></a><span id="l61.398" class="difflineplus">+    // load our keyrings</span>
<a href="#l61.399"></a><span id="l61.399" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l61.400"></a><span id="l61.400" class="difflineplus">+    assert_rnp_success(rnp_load_keys(ffi, &quot;GPG&quot;, input, RNP_LOAD_SAVE_PUBLIC_KEYS));</span>
<a href="#l61.401"></a><span id="l61.401" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.402"></a><span id="l61.402" class="difflineplus">+</span>
<a href="#l61.403"></a><span id="l61.403" class="difflineplus">+    // locate primary key</span>
<a href="#l61.404"></a><span id="l61.404" class="difflineplus">+    key = NULL;</span>
<a href="#l61.405"></a><span id="l61.405" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7BC6709B15C23A4A&quot;, &amp;key));</span>
<a href="#l61.406"></a><span id="l61.406" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l61.407"></a><span id="l61.407" class="difflineplus">+</span>
<a href="#l61.408"></a><span id="l61.408" class="difflineplus">+    // some edge cases</span>
<a href="#l61.409"></a><span id="l61.409" class="difflineplus">+    assert_rnp_failure(rnp_key_get_primary_fprint(NULL, NULL));</span>
<a href="#l61.410"></a><span id="l61.410" class="difflineplus">+    assert_rnp_failure(rnp_key_get_primary_fprint(NULL, &amp;fp));</span>
<a href="#l61.411"></a><span id="l61.411" class="difflineplus">+    assert_rnp_failure(rnp_key_get_primary_fprint(key, NULL));</span>
<a href="#l61.412"></a><span id="l61.412" class="difflineplus">+    assert_rnp_failure(rnp_key_get_primary_fprint(key, &amp;fp));</span>
<a href="#l61.413"></a><span id="l61.413" class="difflineplus">+    assert_null(fp);</span>
<a href="#l61.414"></a><span id="l61.414" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.415"></a><span id="l61.415" class="difflineplus">+</span>
<a href="#l61.416"></a><span id="l61.416" class="difflineplus">+    // locate subkey 1</span>
<a href="#l61.417"></a><span id="l61.417" class="difflineplus">+    key = NULL;</span>
<a href="#l61.418"></a><span id="l61.418" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;1ED63EE56FADC34D&quot;, &amp;key));</span>
<a href="#l61.419"></a><span id="l61.419" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l61.420"></a><span id="l61.420" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(key, &amp;fp));</span>
<a href="#l61.421"></a><span id="l61.421" class="difflineplus">+    assert_non_null(fp);</span>
<a href="#l61.422"></a><span id="l61.422" class="difflineplus">+    assert_string_equal(fp, &quot;E95A3CBF583AA80A2CCC53AA7BC6709B15C23A4A&quot;);</span>
<a href="#l61.423"></a><span id="l61.423" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.424"></a><span id="l61.424" class="difflineplus">+    fp = NULL;</span>
<a href="#l61.425"></a><span id="l61.425" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.426"></a><span id="l61.426" class="difflineplus">+</span>
<a href="#l61.427"></a><span id="l61.427" class="difflineplus">+    // locate subkey 2</span>
<a href="#l61.428"></a><span id="l61.428" class="difflineplus">+    key = NULL;</span>
<a href="#l61.429"></a><span id="l61.429" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;1D7E8A5393C997A8&quot;, &amp;key));</span>
<a href="#l61.430"></a><span id="l61.430" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l61.431"></a><span id="l61.431" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(key, &amp;fp));</span>
<a href="#l61.432"></a><span id="l61.432" class="difflineplus">+    assert_non_null(fp);</span>
<a href="#l61.433"></a><span id="l61.433" class="difflineplus">+    assert_string_equal(fp, &quot;E95A3CBF583AA80A2CCC53AA7BC6709B15C23A4A&quot;);</span>
<a href="#l61.434"></a><span id="l61.434" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.435"></a><span id="l61.435" class="difflineplus">+    fp = NULL;</span>
<a href="#l61.436"></a><span id="l61.436" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.437"></a><span id="l61.437" class="difflineplus">+</span>
<a href="#l61.438"></a><span id="l61.438" class="difflineplus">+    // locate subkey 3</span>
<a href="#l61.439"></a><span id="l61.439" class="difflineplus">+    key = NULL;</span>
<a href="#l61.440"></a><span id="l61.440" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;8A05B89FAD5ADED1&quot;, &amp;key));</span>
<a href="#l61.441"></a><span id="l61.441" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l61.442"></a><span id="l61.442" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(key, &amp;fp));</span>
<a href="#l61.443"></a><span id="l61.443" class="difflineplus">+    assert_non_null(fp);</span>
<a href="#l61.444"></a><span id="l61.444" class="difflineplus">+    assert_string_equal(fp, &quot;E95A3CBF583AA80A2CCC53AA7BC6709B15C23A4A&quot;);</span>
<a href="#l61.445"></a><span id="l61.445" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.446"></a><span id="l61.446" class="difflineplus">+    fp = NULL;</span>
<a href="#l61.447"></a><span id="l61.447" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.448"></a><span id="l61.448" class="difflineplus">+</span>
<a href="#l61.449"></a><span id="l61.449" class="difflineplus">+    // locate key 1 - subkey 0</span>
<a href="#l61.450"></a><span id="l61.450" class="difflineplus">+    key = NULL;</span>
<a href="#l61.451"></a><span id="l61.451" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;54505A936A4A970E&quot;, &amp;key));</span>
<a href="#l61.452"></a><span id="l61.452" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l61.453"></a><span id="l61.453" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(key, &amp;fp));</span>
<a href="#l61.454"></a><span id="l61.454" class="difflineplus">+    assert_non_null(fp);</span>
<a href="#l61.455"></a><span id="l61.455" class="difflineplus">+    assert_string_equal(fp, &quot;BE1C4AB951F4C2F6B604C7F82FCADF05FFA501BB&quot;);</span>
<a href="#l61.456"></a><span id="l61.456" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.457"></a><span id="l61.457" class="difflineplus">+    fp = NULL;</span>
<a href="#l61.458"></a><span id="l61.458" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.459"></a><span id="l61.459" class="difflineplus">+</span>
<a href="#l61.460"></a><span id="l61.460" class="difflineplus">+    // locate key 2 - subkey 1</span>
<a href="#l61.461"></a><span id="l61.461" class="difflineplus">+    key = NULL;</span>
<a href="#l61.462"></a><span id="l61.462" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;326EF111425D14A5&quot;, &amp;key));</span>
<a href="#l61.463"></a><span id="l61.463" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l61.464"></a><span id="l61.464" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(key, &amp;fp));</span>
<a href="#l61.465"></a><span id="l61.465" class="difflineplus">+    assert_non_null(fp);</span>
<a href="#l61.466"></a><span id="l61.466" class="difflineplus">+    assert_string_equal(fp, &quot;BE1C4AB951F4C2F6B604C7F82FCADF05FFA501BB&quot;);</span>
<a href="#l61.467"></a><span id="l61.467" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.468"></a><span id="l61.468" class="difflineplus">+    fp = NULL;</span>
<a href="#l61.469"></a><span id="l61.469" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.470"></a><span id="l61.470" class="difflineplus">+</span>
<a href="#l61.471"></a><span id="l61.471" class="difflineplus">+    // cleanup</span>
<a href="#l61.472"></a><span id="l61.472" class="difflineplus">+    rnp_ffi_destroy(ffi);</span>
<a href="#l61.473"></a><span id="l61.473" class="difflineplus">+}</span>
<a href="#l61.474"></a><span id="l61.474" class="difflineplus">+</span>
<a href="#l61.475"></a><span id="l61.475"> TEST_F(rnp_tests, test_ffi_output_to_armor)</span>
<a href="#l61.476"></a><span id="l61.476"> {</span>
<a href="#l61.477"></a><span id="l61.477">     rnp_ffi_t    ffi = NULL;</span>
<a href="#l61.478"></a><span id="l61.478">     rnp_output_t memory = NULL;</span>
<a href="#l61.479"></a><span id="l61.479">     rnp_output_t armor = NULL;</span>
<a href="#l61.480"></a><span id="l61.480">     rnp_input_t  input = NULL;</span>
<a href="#l61.481"></a><span id="l61.481"> </span>
<a href="#l61.482"></a><span id="l61.482">     assert_int_equal(RNP_SUCCESS, rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l61.483"></a><span id="l61.483" class="difflineat">@@ -7986,16 +8356,17 @@ TEST_F(rnp_tests, test_ffi_key_set_expir</span>
<a href="#l61.484"></a><span id="l61.484">     assert_rnp_success(</span>
<a href="#l61.485"></a><span id="l61.485">       rnp_input_from_path(&amp;input, &quot;data/test_key_validity/alice-sub-sec.pgp&quot;));</span>
<a href="#l61.486"></a><span id="l61.486">     assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_SECRET_KEYS, NULL));</span>
<a href="#l61.487"></a><span id="l61.487">     assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.488"></a><span id="l61.488"> </span>
<a href="#l61.489"></a><span id="l61.489">     uint32_t       expiry = 0;</span>
<a href="#l61.490"></a><span id="l61.490">     const uint32_t new_expiry = 10 * 365 * 24 * 60 * 60;</span>
<a href="#l61.491"></a><span id="l61.491">     assert_rnp_success(rnp_locate_key(ffi, &quot;userid&quot;, &quot;Alice &lt;alice@rnp&gt;&quot;, &amp;key));</span>
<a href="#l61.492"></a><span id="l61.492" class="difflineplus">+    expiry = 255;</span>
<a href="#l61.493"></a><span id="l61.493">     assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.494"></a><span id="l61.494">     assert_int_equal(expiry, 0);</span>
<a href="#l61.495"></a><span id="l61.495">     assert_rnp_success(rnp_key_set_expiration(key, 0));</span>
<a href="#l61.496"></a><span id="l61.496">     /* will fail on locked key */</span>
<a href="#l61.497"></a><span id="l61.497">     assert_rnp_failure(rnp_key_set_expiration(key, new_expiry));</span>
<a href="#l61.498"></a><span id="l61.498">     assert_rnp_success(rnp_key_unlock(key, &quot;password&quot;));</span>
<a href="#l61.499"></a><span id="l61.499">     assert_rnp_success(rnp_key_set_expiration(key, new_expiry));</span>
<a href="#l61.500"></a><span id="l61.500">     assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.501"></a><span id="l61.501" class="difflineat">@@ -8136,25 +8507,238 @@ TEST_F(rnp_tests, test_ffi_key_set_expir</span>
<a href="#l61.502"></a><span id="l61.502">     assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.503"></a><span id="l61.503">     assert_rnp_success(rnp_locate_key(ffi, &quot;userid&quot;, &quot;Alice &lt;alice@rnp&gt;&quot;, &amp;key));</span>
<a href="#l61.504"></a><span id="l61.504">     assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;22F3A217C0E439CB&quot;, &amp;sub));</span>
<a href="#l61.505"></a><span id="l61.505">     assert_rnp_success(rnp_key_unlock(key, &quot;password&quot;));</span>
<a href="#l61.506"></a><span id="l61.506">     assert_rnp_success(rnp_key_unlock(sub, &quot;password&quot;));</span>
<a href="#l61.507"></a><span id="l61.507">     assert_rnp_success(rnp_key_set_expiration(key, 1));</span>
<a href="#l61.508"></a><span id="l61.508">     assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.509"></a><span id="l61.509">     assert_int_equal(expiry, 1);</span>
<a href="#l61.510"></a><span id="l61.510" class="difflineplus">+    /* key is invalid since it is expired */</span>
<a href="#l61.511"></a><span id="l61.511" class="difflineplus">+    assert_false(key-&gt;pub-&gt;valid);</span>
<a href="#l61.512"></a><span id="l61.512">     assert_rnp_success(rnp_key_set_expiration(sub, 1));</span>
<a href="#l61.513"></a><span id="l61.513">     assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.514"></a><span id="l61.514">     assert_int_equal(expiry, 1);</span>
<a href="#l61.515"></a><span id="l61.515" class="difflineplus">+    assert_false(sub-&gt;pub-&gt;valid);</span>
<a href="#l61.516"></a><span id="l61.516">     assert_rnp_success(rnp_key_set_expiration(key, 0));</span>
<a href="#l61.517"></a><span id="l61.517">     assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.518"></a><span id="l61.518">     assert_int_equal(expiry, 0);</span>
<a href="#l61.519"></a><span id="l61.519" class="difflineplus">+    assert_true(key-&gt;pub-&gt;valid);</span>
<a href="#l61.520"></a><span id="l61.520">     assert_rnp_success(rnp_key_set_expiration(sub, 0));</span>
<a href="#l61.521"></a><span id="l61.521">     assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.522"></a><span id="l61.522">     assert_int_equal(expiry, 0);</span>
<a href="#l61.523"></a><span id="l61.523" class="difflineplus">+    assert_true(sub-&gt;pub-&gt;valid);</span>
<a href="#l61.524"></a><span id="l61.524" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l61.525"></a><span id="l61.525" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(sub));</span>
<a href="#l61.526"></a><span id="l61.526" class="difflineplus">+</span>
<a href="#l61.527"></a><span id="l61.527" class="difflineplus">+    /* check whether we can change expiration with password provider/locked key */</span>
<a href="#l61.528"></a><span id="l61.528" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC | RNP_KEY_UNLOAD_SECRET));</span>
<a href="#l61.529"></a><span id="l61.529" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l61.530"></a><span id="l61.530" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_validity/alice-sign-sub-pub.pgp&quot;));</span>
<a href="#l61.531"></a><span id="l61.531" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, NULL));</span>
<a href="#l61.532"></a><span id="l61.532" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.533"></a><span id="l61.533" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l61.534"></a><span id="l61.534" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_validity/alice-sign-sub-sec.pgp&quot;));</span>
<a href="#l61.535"></a><span id="l61.535" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_SECRET_KEYS, NULL));</span>
<a href="#l61.536"></a><span id="l61.536" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.537"></a><span id="l61.537" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;userid&quot;, &quot;Alice &lt;alice@rnp&gt;&quot;, &amp;key));</span>
<a href="#l61.538"></a><span id="l61.538" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;22F3A217C0E439CB&quot;, &amp;sub));</span>
<a href="#l61.539"></a><span id="l61.539" class="difflineplus">+</span>
<a href="#l61.540"></a><span id="l61.540" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;wrong&quot;));</span>
<a href="#l61.541"></a><span id="l61.541" class="difflineplus">+    assert_rnp_failure(rnp_key_set_expiration(key, 1));</span>
<a href="#l61.542"></a><span id="l61.542" class="difflineplus">+    expiry = 255;</span>
<a href="#l61.543"></a><span id="l61.543" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.544"></a><span id="l61.544" class="difflineplus">+    assert_int_equal(expiry, 0);</span>
<a href="#l61.545"></a><span id="l61.545" class="difflineplus">+    assert_rnp_failure(rnp_key_set_expiration(sub, 1));</span>
<a href="#l61.546"></a><span id="l61.546" class="difflineplus">+    expiry = 255;</span>
<a href="#l61.547"></a><span id="l61.547" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.548"></a><span id="l61.548" class="difflineplus">+    assert_int_equal(expiry, 0);</span>
<a href="#l61.549"></a><span id="l61.549" class="difflineplus">+</span>
<a href="#l61.550"></a><span id="l61.550" class="difflineplus">+    bool locked = true;</span>
<a href="#l61.551"></a><span id="l61.551" class="difflineplus">+    assert_rnp_success(rnp_key_is_locked(key, &amp;locked));</span>
<a href="#l61.552"></a><span id="l61.552" class="difflineplus">+    assert_true(locked);</span>
<a href="#l61.553"></a><span id="l61.553" class="difflineplus">+    locked = false;</span>
<a href="#l61.554"></a><span id="l61.554" class="difflineplus">+    assert_rnp_success(rnp_key_is_locked(sub, &amp;locked));</span>
<a href="#l61.555"></a><span id="l61.555" class="difflineplus">+    assert_true(locked);</span>
<a href="#l61.556"></a><span id="l61.556" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l61.557"></a><span id="l61.557" class="difflineplus">+    uint32_t creation = 0;</span>
<a href="#l61.558"></a><span id="l61.558" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(key, &amp;creation));</span>
<a href="#l61.559"></a><span id="l61.559" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.560"></a><span id="l61.560" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(key, creation + 2));</span>
<a href="#l61.561"></a><span id="l61.561" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.562"></a><span id="l61.562" class="difflineplus">+    assert_int_equal(expiry, creation + 2);</span>
<a href="#l61.563"></a><span id="l61.563" class="difflineplus">+    locked = false;</span>
<a href="#l61.564"></a><span id="l61.564" class="difflineplus">+    assert_rnp_success(rnp_key_is_locked(key, &amp;locked));</span>
<a href="#l61.565"></a><span id="l61.565" class="difflineplus">+    assert_true(locked);</span>
<a href="#l61.566"></a><span id="l61.566" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(sub, &amp;creation));</span>
<a href="#l61.567"></a><span id="l61.567" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.568"></a><span id="l61.568" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(sub, creation + 3));</span>
<a href="#l61.569"></a><span id="l61.569" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.570"></a><span id="l61.570" class="difflineplus">+    assert_int_equal(expiry, creation + 3);</span>
<a href="#l61.571"></a><span id="l61.571" class="difflineplus">+    locked = false;</span>
<a href="#l61.572"></a><span id="l61.572" class="difflineplus">+    assert_rnp_success(rnp_key_is_locked(sub, &amp;locked));</span>
<a href="#l61.573"></a><span id="l61.573" class="difflineplus">+    assert_true(locked);</span>
<a href="#l61.574"></a><span id="l61.574" class="difflineplus">+    locked = false;</span>
<a href="#l61.575"></a><span id="l61.575" class="difflineplus">+    assert_rnp_success(rnp_key_is_locked(key, &amp;locked));</span>
<a href="#l61.576"></a><span id="l61.576" class="difflineplus">+    assert_true(locked);</span>
<a href="#l61.577"></a><span id="l61.577" class="difflineplus">+</span>
<a href="#l61.578"></a><span id="l61.578" class="difflineplus">+    /* now change just subkey's expiration - should also work */</span>
<a href="#l61.579"></a><span id="l61.579" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(sub, 4));</span>
<a href="#l61.580"></a><span id="l61.580" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.581"></a><span id="l61.581" class="difflineplus">+    assert_int_equal(expiry, 4);</span>
<a href="#l61.582"></a><span id="l61.582" class="difflineplus">+    locked = false;</span>
<a href="#l61.583"></a><span id="l61.583" class="difflineplus">+    assert_rnp_success(rnp_key_is_locked(sub, &amp;locked));</span>
<a href="#l61.584"></a><span id="l61.584" class="difflineplus">+    assert_true(locked);</span>
<a href="#l61.585"></a><span id="l61.585" class="difflineplus">+    locked = false;</span>
<a href="#l61.586"></a><span id="l61.586" class="difflineplus">+    assert_rnp_success(rnp_key_is_locked(key, &amp;locked));</span>
<a href="#l61.587"></a><span id="l61.587" class="difflineplus">+    assert_true(locked);</span>
<a href="#l61.588"></a><span id="l61.588" class="difflineplus">+</span>
<a href="#l61.589"></a><span id="l61.589" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l61.590"></a><span id="l61.590" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(sub));</span>
<a href="#l61.591"></a><span id="l61.591" class="difflineplus">+</span>
<a href="#l61.592"></a><span id="l61.592" class="difflineplus">+    /* now try to update already expired key and subkey */</span>
<a href="#l61.593"></a><span id="l61.593" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC | RNP_KEY_UNLOAD_SECRET));</span>
<a href="#l61.594"></a><span id="l61.594" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l61.595"></a><span id="l61.595" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_validity/alice-sign-sub-exp-pub.asc&quot;));</span>
<a href="#l61.596"></a><span id="l61.596" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, NULL));</span>
<a href="#l61.597"></a><span id="l61.597" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.598"></a><span id="l61.598" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l61.599"></a><span id="l61.599" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_validity/alice-sign-sub-exp-sec.asc&quot;));</span>
<a href="#l61.600"></a><span id="l61.600" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_SECRET_KEYS, NULL));</span>
<a href="#l61.601"></a><span id="l61.601" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.602"></a><span id="l61.602" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;userid&quot;, &quot;Alice &lt;alice@rnp&gt;&quot;, &amp;key));</span>
<a href="#l61.603"></a><span id="l61.603" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;22F3A217C0E439CB&quot;, &amp;sub));</span>
<a href="#l61.604"></a><span id="l61.604" class="difflineplus">+    assert_false(key-&gt;pub-&gt;valid);</span>
<a href="#l61.605"></a><span id="l61.605" class="difflineplus">+    assert_true(key-&gt;sec-&gt;valid);</span>
<a href="#l61.606"></a><span id="l61.606" class="difflineplus">+    assert_false(sub-&gt;pub-&gt;valid);</span>
<a href="#l61.607"></a><span id="l61.607" class="difflineplus">+    assert_true(sub-&gt;sec-&gt;valid);</span>
<a href="#l61.608"></a><span id="l61.608" class="difflineplus">+    creation = 0;</span>
<a href="#l61.609"></a><span id="l61.609" class="difflineplus">+    uint32_t validity = 2 * 30 * 24 * 60 * 60; // 2 monthes</span>
<a href="#l61.610"></a><span id="l61.610" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(key, &amp;creation));</span>
<a href="#l61.611"></a><span id="l61.611" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.612"></a><span id="l61.612" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(key, creation + validity));</span>
<a href="#l61.613"></a><span id="l61.613" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.614"></a><span id="l61.614" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.615"></a><span id="l61.615" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(sub, &amp;creation));</span>
<a href="#l61.616"></a><span id="l61.616" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.617"></a><span id="l61.617" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(sub, creation + validity));</span>
<a href="#l61.618"></a><span id="l61.618" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.619"></a><span id="l61.619" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.620"></a><span id="l61.620" class="difflineplus">+    assert_true(key-&gt;pub-&gt;valid);</span>
<a href="#l61.621"></a><span id="l61.621" class="difflineplus">+    assert_true(key-&gt;sec-&gt;valid);</span>
<a href="#l61.622"></a><span id="l61.622" class="difflineplus">+    assert_true(sub-&gt;pub-&gt;valid);</span>
<a href="#l61.623"></a><span id="l61.623" class="difflineplus">+    assert_true(sub-&gt;sec-&gt;valid);</span>
<a href="#l61.624"></a><span id="l61.624" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l61.625"></a><span id="l61.625" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(sub));</span>
<a href="#l61.626"></a><span id="l61.626" class="difflineplus">+</span>
<a href="#l61.627"></a><span id="l61.627" class="difflineplus">+    /* update expiration time when only secret key is available */</span>
<a href="#l61.628"></a><span id="l61.628" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC));</span>
<a href="#l61.629"></a><span id="l61.629" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;userid&quot;, &quot;Alice &lt;alice@rnp&gt;&quot;, &amp;key));</span>
<a href="#l61.630"></a><span id="l61.630" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;22F3A217C0E439CB&quot;, &amp;sub));</span>
<a href="#l61.631"></a><span id="l61.631" class="difflineplus">+    validity = 30 * 24 * 60 * 60; // 1 month</span>
<a href="#l61.632"></a><span id="l61.632" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(key, &amp;creation));</span>
<a href="#l61.633"></a><span id="l61.633" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.634"></a><span id="l61.634" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(key, creation + validity));</span>
<a href="#l61.635"></a><span id="l61.635" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.636"></a><span id="l61.636" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.637"></a><span id="l61.637" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(sub, &amp;creation));</span>
<a href="#l61.638"></a><span id="l61.638" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.639"></a><span id="l61.639" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(sub, creation + validity));</span>
<a href="#l61.640"></a><span id="l61.640" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.641"></a><span id="l61.641" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.642"></a><span id="l61.642" class="difflineplus">+    assert_null(key-&gt;pub);</span>
<a href="#l61.643"></a><span id="l61.643" class="difflineplus">+    assert_true(key-&gt;sec-&gt;valid);</span>
<a href="#l61.644"></a><span id="l61.644" class="difflineplus">+    assert_null(sub-&gt;pub);</span>
<a href="#l61.645"></a><span id="l61.645" class="difflineplus">+    assert_true(sub-&gt;sec-&gt;valid);</span>
<a href="#l61.646"></a><span id="l61.646" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l61.647"></a><span id="l61.647" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(sub));</span>
<a href="#l61.648"></a><span id="l61.648" class="difflineplus">+    assert_rnp_success(rnp_ffi_destroy(ffi));</span>
<a href="#l61.649"></a><span id="l61.649" class="difflineplus">+</span>
<a href="#l61.650"></a><span id="l61.650" class="difflineplus">+    /* check whether things work for G10 keyring */</span>
<a href="#l61.651"></a><span id="l61.651" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;KBX&quot;, &quot;G10&quot;));</span>
<a href="#l61.652"></a><span id="l61.652" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l61.653"></a><span id="l61.653" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/keyrings/3/pubring.kbx&quot;));</span>
<a href="#l61.654"></a><span id="l61.654" class="difflineplus">+    assert_rnp_success(rnp_load_keys(ffi, &quot;KBX&quot;, input, RNP_LOAD_SAVE_PUBLIC_KEYS));</span>
<a href="#l61.655"></a><span id="l61.655" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.656"></a><span id="l61.656" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/keyrings/3/private-keys-v1.d&quot;));</span>
<a href="#l61.657"></a><span id="l61.657" class="difflineplus">+    assert_rnp_success(rnp_load_keys(ffi, &quot;G10&quot;, input, RNP_LOAD_SAVE_SECRET_KEYS));</span>
<a href="#l61.658"></a><span id="l61.658" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.659"></a><span id="l61.659" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;4BE147BB22DF1E60&quot;, &amp;key));</span>
<a href="#l61.660"></a><span id="l61.660" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;A49BAE05C16E8BC8&quot;, &amp;sub));</span>
<a href="#l61.661"></a><span id="l61.661" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(key, &amp;creation));</span>
<a href="#l61.662"></a><span id="l61.662" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.663"></a><span id="l61.663" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(key, creation + validity));</span>
<a href="#l61.664"></a><span id="l61.664" class="difflineplus">+    expiry = 255;</span>
<a href="#l61.665"></a><span id="l61.665" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.666"></a><span id="l61.666" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.667"></a><span id="l61.667" class="difflineplus">+    size_t key_expiry = expiry;</span>
<a href="#l61.668"></a><span id="l61.668" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(sub, &amp;creation));</span>
<a href="#l61.669"></a><span id="l61.669" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.670"></a><span id="l61.670" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(sub, creation + validity));</span>
<a href="#l61.671"></a><span id="l61.671" class="difflineplus">+    expiry = 255;</span>
<a href="#l61.672"></a><span id="l61.672" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.673"></a><span id="l61.673" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.674"></a><span id="l61.674" class="difflineplus">+    size_t sub_expiry = expiry;</span>
<a href="#l61.675"></a><span id="l61.675" class="difflineplus">+    assert_true(key-&gt;pub-&gt;valid);</span>
<a href="#l61.676"></a><span id="l61.676" class="difflineplus">+    assert_true(key-&gt;sec-&gt;valid);</span>
<a href="#l61.677"></a><span id="l61.677" class="difflineplus">+    assert_true(sub-&gt;pub-&gt;valid);</span>
<a href="#l61.678"></a><span id="l61.678" class="difflineplus">+    assert_true(sub-&gt;sec-&gt;valid);</span>
<a href="#l61.679"></a><span id="l61.679" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l61.680"></a><span id="l61.680" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(sub));</span>
<a href="#l61.681"></a><span id="l61.681" class="difflineplus">+</span>
<a href="#l61.682"></a><span id="l61.682" class="difflineplus">+    /* save keyring to KBX and reload it: fails now */</span>
<a href="#l61.683"></a><span id="l61.683" class="difflineplus">+    rnp_output_t output = NULL;</span>
<a href="#l61.684"></a><span id="l61.684" class="difflineplus">+    assert_rnp_success(rnp_output_to_path(&amp;output, &quot;pubring.kbx&quot;));</span>
<a href="#l61.685"></a><span id="l61.685" class="difflineplus">+    assert_rnp_success(rnp_save_keys(ffi, &quot;KBX&quot;, output, RNP_LOAD_SAVE_PUBLIC_KEYS));</span>
<a href="#l61.686"></a><span id="l61.686" class="difflineplus">+    assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l61.687"></a><span id="l61.687" class="difflineplus">+    assert_rnp_success(rnp_ffi_destroy(ffi));</span>
<a href="#l61.688"></a><span id="l61.688" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;KBX&quot;, &quot;G10&quot;));</span>
<a href="#l61.689"></a><span id="l61.689" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;pubring.kbx&quot;));</span>
<a href="#l61.690"></a><span id="l61.690" class="difflineplus">+    /* Saving to KBX doesn't work well, or was broken at some point. */</span>
<a href="#l61.691"></a><span id="l61.691" class="difflineplus">+    assert_rnp_failure(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, NULL));</span>
<a href="#l61.692"></a><span id="l61.692" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l61.693"></a><span id="l61.693" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;4BE147BB22DF1E60&quot;, &amp;key));</span>
<a href="#l61.694"></a><span id="l61.694" class="difflineplus">+    assert_null(key);</span>
<a href="#l61.695"></a><span id="l61.695" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;A49BAE05C16E8BC8&quot;, &amp;sub));</span>
<a href="#l61.696"></a><span id="l61.696" class="difflineplus">+    assert_null(sub);</span>
<a href="#l61.697"></a><span id="l61.697" class="difflineplus">+    expiry = 255;</span>
<a href="#l61.698"></a><span id="l61.698" class="difflineplus">+    assert_rnp_failure(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.699"></a><span id="l61.699" class="difflineplus">+    assert_int_not_equal(expiry, key_expiry);</span>
<a href="#l61.700"></a><span id="l61.700" class="difflineplus">+    expiry = 255;</span>
<a href="#l61.701"></a><span id="l61.701" class="difflineplus">+    assert_rnp_failure(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.702"></a><span id="l61.702" class="difflineplus">+    assert_int_not_equal(expiry, sub_expiry);</span>
<a href="#l61.703"></a><span id="l61.703" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l61.704"></a><span id="l61.704" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(sub));</span>
<a href="#l61.705"></a><span id="l61.705" class="difflineplus">+    assert_int_equal(unlink(&quot;pubring.kbx&quot;), 0);</span>
<a href="#l61.706"></a><span id="l61.706" class="difflineplus">+    assert_rnp_success(rnp_ffi_destroy(ffi));</span>
<a href="#l61.707"></a><span id="l61.707" class="difflineplus">+</span>
<a href="#l61.708"></a><span id="l61.708" class="difflineplus">+    /* load G10/KBX and unload public keys - must succeed */</span>
<a href="#l61.709"></a><span id="l61.709" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;KBX&quot;, &quot;G10&quot;));</span>
<a href="#l61.710"></a><span id="l61.710" class="difflineplus">+    assert_rnp_success(rnp_ffi_set_pass_provider(ffi, getpasscb, (void *) &quot;password&quot;));</span>
<a href="#l61.711"></a><span id="l61.711" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/keyrings/3/pubring.kbx&quot;));</span>
<a href="#l61.712"></a><span id="l61.712" class="difflineplus">+    assert_rnp_success(rnp_load_keys(ffi, &quot;KBX&quot;, input, RNP_LOAD_SAVE_PUBLIC_KEYS));</span>
<a href="#l61.713"></a><span id="l61.713" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.714"></a><span id="l61.714" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/keyrings/3/private-keys-v1.d&quot;));</span>
<a href="#l61.715"></a><span id="l61.715" class="difflineplus">+    assert_rnp_success(rnp_load_keys(ffi, &quot;G10&quot;, input, RNP_LOAD_SAVE_SECRET_KEYS));</span>
<a href="#l61.716"></a><span id="l61.716" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.717"></a><span id="l61.717" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC));</span>
<a href="#l61.718"></a><span id="l61.718" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;4BE147BB22DF1E60&quot;, &amp;key));</span>
<a href="#l61.719"></a><span id="l61.719" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;A49BAE05C16E8BC8&quot;, &amp;sub));</span>
<a href="#l61.720"></a><span id="l61.720" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(key, &amp;creation));</span>
<a href="#l61.721"></a><span id="l61.721" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.722"></a><span id="l61.722" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(key, creation + validity));</span>
<a href="#l61.723"></a><span id="l61.723" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(key, &amp;expiry));</span>
<a href="#l61.724"></a><span id="l61.724" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.725"></a><span id="l61.725" class="difflineplus">+    key_expiry = expiry;</span>
<a href="#l61.726"></a><span id="l61.726" class="difflineplus">+    assert_rnp_success(rnp_key_get_creation(sub, &amp;creation));</span>
<a href="#l61.727"></a><span id="l61.727" class="difflineplus">+    creation = time(NULL) - creation;</span>
<a href="#l61.728"></a><span id="l61.728" class="difflineplus">+    assert_rnp_success(rnp_key_set_expiration(sub, creation + validity));</span>
<a href="#l61.729"></a><span id="l61.729" class="difflineplus">+    assert_rnp_success(rnp_key_get_expiration(sub, &amp;expiry));</span>
<a href="#l61.730"></a><span id="l61.730" class="difflineplus">+    assert_int_equal(expiry, creation + validity);</span>
<a href="#l61.731"></a><span id="l61.731" class="difflineplus">+    sub_expiry = expiry;</span>
<a href="#l61.732"></a><span id="l61.732">     assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l61.733"></a><span id="l61.733">     assert_rnp_success(rnp_key_handle_destroy(sub));</span>
<a href="#l61.734"></a><span id="l61.734"> </span>
<a href="#l61.735"></a><span id="l61.735">     // TODO: check expiration date in direct-key signature, check without</span>
<a href="#l61.736"></a><span id="l61.736">     // self-signature/binding signature.</span>
<a href="#l61.737"></a><span id="l61.737"> </span>
<a href="#l61.738"></a><span id="l61.738">     assert_rnp_success(rnp_ffi_destroy(ffi));</span>
<a href="#l61.739"></a><span id="l61.739"> }</span>
<a href="#l61.740"></a><span id="l61.740" class="difflineat">@@ -8386,16 +8970,93 @@ TEST_F(rnp_tests, test_ffi_key_import_ed</span>
<a href="#l61.741"></a><span id="l61.741">     assert_rnp_success(rnp_key_get_revocation_reason(key, &amp;results));</span>
<a href="#l61.742"></a><span id="l61.742">     assert_int_equal(strcmp(results, &quot;No reason specified&quot;), 0);</span>
<a href="#l61.743"></a><span id="l61.743">     rnp_buffer_destroy(results);</span>
<a href="#l61.744"></a><span id="l61.744">     revoked = false;</span>
<a href="#l61.745"></a><span id="l61.745">     assert_rnp_success(rnp_key_is_revoked(key, &amp;revoked));</span>
<a href="#l61.746"></a><span id="l61.746">     assert_true(revoked);</span>
<a href="#l61.747"></a><span id="l61.747">     rnp_key_handle_destroy(key);</span>
<a href="#l61.748"></a><span id="l61.748"> </span>
<a href="#l61.749"></a><span id="l61.749" class="difflineplus">+    /* key with two subkeys with same material but different creation time */</span>
<a href="#l61.750"></a><span id="l61.750" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l61.751"></a><span id="l61.751" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/alice-2-subs-same-grip.pgp&quot;));</span>
<a href="#l61.752"></a><span id="l61.752" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, &amp;results));</span>
<a href="#l61.753"></a><span id="l61.753" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.754"></a><span id="l61.754" class="difflineplus">+    assert_non_null(results);</span>
<a href="#l61.755"></a><span id="l61.755" class="difflineplus">+    rnp_buffer_destroy(results);</span>
<a href="#l61.756"></a><span id="l61.756" class="difflineplus">+    count = 0;</span>
<a href="#l61.757"></a><span id="l61.757" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;count));</span>
<a href="#l61.758"></a><span id="l61.758" class="difflineplus">+    assert_int_equal(count, 3);</span>
<a href="#l61.759"></a><span id="l61.759" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;0451409669FFDE3C&quot;, &amp;key));</span>
<a href="#l61.760"></a><span id="l61.760" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_count(key, &amp;count));</span>
<a href="#l61.761"></a><span id="l61.761" class="difflineplus">+    assert_int_equal(count, 2);</span>
<a href="#l61.762"></a><span id="l61.762" class="difflineplus">+    rnp_key_handle_t sub = NULL;</span>
<a href="#l61.763"></a><span id="l61.763" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_at(key, 0, &amp;sub));</span>
<a href="#l61.764"></a><span id="l61.764" class="difflineplus">+    char *keyid = NULL;</span>
<a href="#l61.765"></a><span id="l61.765" class="difflineplus">+    assert_rnp_success(rnp_key_get_keyid(sub, &amp;keyid));</span>
<a href="#l61.766"></a><span id="l61.766" class="difflineplus">+    assert_string_equal(keyid, &quot;DD23CEB7FEBEFF17&quot;);</span>
<a href="#l61.767"></a><span id="l61.767" class="difflineplus">+    rnp_buffer_destroy(keyid);</span>
<a href="#l61.768"></a><span id="l61.768" class="difflineplus">+    char *fp = NULL;</span>
<a href="#l61.769"></a><span id="l61.769" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(sub, &amp;fp));</span>
<a href="#l61.770"></a><span id="l61.770" class="difflineplus">+    assert_string_equal(fp, &quot;73EDCC9119AFC8E2DBBDCDE50451409669FFDE3C&quot;);</span>
<a href="#l61.771"></a><span id="l61.771" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.772"></a><span id="l61.772" class="difflineplus">+    rnp_key_handle_destroy(sub);</span>
<a href="#l61.773"></a><span id="l61.773" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_at(key, 1, &amp;sub));</span>
<a href="#l61.774"></a><span id="l61.774" class="difflineplus">+    assert_rnp_success(rnp_key_get_keyid(sub, &amp;keyid));</span>
<a href="#l61.775"></a><span id="l61.775" class="difflineplus">+    assert_string_equal(keyid, &quot;C2E7FDCC9CD59FB5&quot;);</span>
<a href="#l61.776"></a><span id="l61.776" class="difflineplus">+    rnp_buffer_destroy(keyid);</span>
<a href="#l61.777"></a><span id="l61.777" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(sub, &amp;fp));</span>
<a href="#l61.778"></a><span id="l61.778" class="difflineplus">+    assert_string_equal(fp, &quot;73EDCC9119AFC8E2DBBDCDE50451409669FFDE3C&quot;);</span>
<a href="#l61.779"></a><span id="l61.779" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.780"></a><span id="l61.780" class="difflineplus">+    rnp_key_handle_destroy(sub);</span>
<a href="#l61.781"></a><span id="l61.781" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;DD23CEB7FEBEFF17&quot;, &amp;sub));</span>
<a href="#l61.782"></a><span id="l61.782" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(sub, &amp;fp));</span>
<a href="#l61.783"></a><span id="l61.783" class="difflineplus">+    assert_string_equal(fp, &quot;73EDCC9119AFC8E2DBBDCDE50451409669FFDE3C&quot;);</span>
<a href="#l61.784"></a><span id="l61.784" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.785"></a><span id="l61.785" class="difflineplus">+    rnp_key_handle_destroy(sub);</span>
<a href="#l61.786"></a><span id="l61.786" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;C2E7FDCC9CD59FB5&quot;, &amp;sub));</span>
<a href="#l61.787"></a><span id="l61.787" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(sub, &amp;fp));</span>
<a href="#l61.788"></a><span id="l61.788" class="difflineplus">+    assert_string_equal(fp, &quot;73EDCC9119AFC8E2DBBDCDE50451409669FFDE3C&quot;);</span>
<a href="#l61.789"></a><span id="l61.789" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.790"></a><span id="l61.790" class="difflineplus">+    rnp_key_handle_destroy(sub);</span>
<a href="#l61.791"></a><span id="l61.791" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.792"></a><span id="l61.792" class="difflineplus">+</span>
<a href="#l61.793"></a><span id="l61.793" class="difflineplus">+    /* two keys with subkeys with same material but different creation time */</span>
<a href="#l61.794"></a><span id="l61.794" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l61.795"></a><span id="l61.795" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/alice-2-keys-same-grip.pgp&quot;));</span>
<a href="#l61.796"></a><span id="l61.796" class="difflineplus">+    assert_rnp_success(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, NULL));</span>
<a href="#l61.797"></a><span id="l61.797" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.798"></a><span id="l61.798" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;count));</span>
<a href="#l61.799"></a><span id="l61.799" class="difflineplus">+    assert_int_equal(count, 4);</span>
<a href="#l61.800"></a><span id="l61.800" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;0451409669FFDE3C&quot;, &amp;key));</span>
<a href="#l61.801"></a><span id="l61.801" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_count(key, &amp;count));</span>
<a href="#l61.802"></a><span id="l61.802" class="difflineplus">+    assert_int_equal(count, 2);</span>
<a href="#l61.803"></a><span id="l61.803" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_at(key, 0, &amp;sub));</span>
<a href="#l61.804"></a><span id="l61.804" class="difflineplus">+    assert_rnp_success(rnp_key_get_keyid(sub, &amp;keyid));</span>
<a href="#l61.805"></a><span id="l61.805" class="difflineplus">+    assert_string_equal(keyid, &quot;DD23CEB7FEBEFF17&quot;);</span>
<a href="#l61.806"></a><span id="l61.806" class="difflineplus">+    rnp_buffer_destroy(keyid);</span>
<a href="#l61.807"></a><span id="l61.807" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(sub, &amp;fp));</span>
<a href="#l61.808"></a><span id="l61.808" class="difflineplus">+    assert_string_equal(fp, &quot;73EDCC9119AFC8E2DBBDCDE50451409669FFDE3C&quot;);</span>
<a href="#l61.809"></a><span id="l61.809" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.810"></a><span id="l61.810" class="difflineplus">+    rnp_key_handle_destroy(sub);</span>
<a href="#l61.811"></a><span id="l61.811" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_at(key, 1, &amp;sub));</span>
<a href="#l61.812"></a><span id="l61.812" class="difflineplus">+    assert_rnp_success(rnp_key_get_keyid(sub, &amp;keyid));</span>
<a href="#l61.813"></a><span id="l61.813" class="difflineplus">+    assert_string_equal(keyid, &quot;C2E7FDCC9CD59FB5&quot;);</span>
<a href="#l61.814"></a><span id="l61.814" class="difflineplus">+    rnp_buffer_destroy(keyid);</span>
<a href="#l61.815"></a><span id="l61.815" class="difflineplus">+    assert_rnp_success(rnp_key_get_primary_fprint(sub, &amp;fp));</span>
<a href="#l61.816"></a><span id="l61.816" class="difflineplus">+    assert_string_equal(fp, &quot;73EDCC9119AFC8E2DBBDCDE50451409669FFDE3C&quot;);</span>
<a href="#l61.817"></a><span id="l61.817" class="difflineplus">+    rnp_buffer_destroy(fp);</span>
<a href="#l61.818"></a><span id="l61.818" class="difflineplus">+    rnp_key_handle_destroy(sub);</span>
<a href="#l61.819"></a><span id="l61.819" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.820"></a><span id="l61.820" class="difflineplus">+    /* subkey should belong to original key */</span>
<a href="#l61.821"></a><span id="l61.821" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;467A2DE826ABA0DB&quot;, &amp;key));</span>
<a href="#l61.822"></a><span id="l61.822" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_count(key, &amp;count));</span>
<a href="#l61.823"></a><span id="l61.823" class="difflineplus">+    assert_int_equal(count, 0);</span>
<a href="#l61.824"></a><span id="l61.824" class="difflineplus">+    rnp_key_handle_destroy(key);</span>
<a href="#l61.825"></a><span id="l61.825" class="difflineplus">+</span>
<a href="#l61.826"></a><span id="l61.826">     rnp_ffi_destroy(ffi);</span>
<a href="#l61.827"></a><span id="l61.827"> }</span>
<a href="#l61.828"></a><span id="l61.828"> </span>
<a href="#l61.829"></a><span id="l61.829"> TEST_F(rnp_tests, test_ffi_key_remove)</span>
<a href="#l61.830"></a><span id="l61.830"> {</span>
<a href="#l61.831"></a><span id="l61.831">     rnp_ffi_t ffi = NULL;</span>
<a href="#l61.832"></a><span id="l61.832">     test_ffi_init(&amp;ffi);</span>
<a href="#l61.833"></a><span id="l61.833"> </span>
<a href="#l61.834"></a><span id="l61.834" class="difflineat">@@ -8552,8 +9213,64 @@ TEST_F(rnp_tests, test_ffi_key_remove)</span>
<a href="#l61.835"></a><span id="l61.835">     assert_rnp_success(rnp_get_public_key_count(ffi, &amp;count));</span>
<a href="#l61.836"></a><span id="l61.836">     assert_int_equal(count, 0);</span>
<a href="#l61.837"></a><span id="l61.837">     assert_rnp_success(rnp_get_secret_key_count(ffi, &amp;count));</span>
<a href="#l61.838"></a><span id="l61.838">     assert_int_equal(count, 0);</span>
<a href="#l61.839"></a><span id="l61.839">     rnp_key_handle_destroy(key0);</span>
<a href="#l61.840"></a><span id="l61.840"> </span>
<a href="#l61.841"></a><span id="l61.841">     rnp_ffi_destroy(ffi);</span>
<a href="#l61.842"></a><span id="l61.842"> }</span>
<a href="#l61.843"></a><span id="l61.843" class="difflineplus">+</span>
<a href="#l61.844"></a><span id="l61.844" class="difflineplus">+TEST_F(rnp_tests, test_ffi_literal_packet)</span>
<a href="#l61.845"></a><span id="l61.845" class="difflineplus">+{</span>
<a href="#l61.846"></a><span id="l61.846" class="difflineplus">+    rnp_ffi_t    ffi = NULL;</span>
<a href="#l61.847"></a><span id="l61.847" class="difflineplus">+    rnp_input_t  input = NULL;</span>
<a href="#l61.848"></a><span id="l61.848" class="difflineplus">+    rnp_output_t output = NULL;</span>
<a href="#l61.849"></a><span id="l61.849" class="difflineplus">+</span>
<a href="#l61.850"></a><span id="l61.850" class="difflineplus">+    // init ffi</span>
<a href="#l61.851"></a><span id="l61.851" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l61.852"></a><span id="l61.852" class="difflineplus">+</span>
<a href="#l61.853"></a><span id="l61.853" class="difflineplus">+    /* try rnp_decrypt() */</span>
<a href="#l61.854"></a><span id="l61.854" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.literal&quot;));</span>
<a href="#l61.855"></a><span id="l61.855" class="difflineplus">+    assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.856"></a><span id="l61.856" class="difflineplus">+    assert_rnp_success(rnp_decrypt(ffi, input, output));</span>
<a href="#l61.857"></a><span id="l61.857" class="difflineplus">+    uint8_t *buf = NULL;</span>
<a href="#l61.858"></a><span id="l61.858" class="difflineplus">+    size_t   len = 0;</span>
<a href="#l61.859"></a><span id="l61.859" class="difflineplus">+    rnp_output_memory_get_buf(output, &amp;buf, &amp;len, false);</span>
<a href="#l61.860"></a><span id="l61.860" class="difflineplus">+    std::string out;</span>
<a href="#l61.861"></a><span id="l61.861" class="difflineplus">+    out.assign((char *) buf, len);</span>
<a href="#l61.862"></a><span id="l61.862" class="difflineplus">+    assert_true(out == file_to_str(&quot;data/test_messages/message.txt&quot;));</span>
<a href="#l61.863"></a><span id="l61.863" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.864"></a><span id="l61.864" class="difflineplus">+    rnp_output_destroy(output);</span>
<a href="#l61.865"></a><span id="l61.865" class="difflineplus">+</span>
<a href="#l61.866"></a><span id="l61.866" class="difflineplus">+    /* try rnp_op_verify() */</span>
<a href="#l61.867"></a><span id="l61.867" class="difflineplus">+    assert_rnp_success(rnp_input_from_path(&amp;input, &quot;data/test_messages/message.txt.literal&quot;));</span>
<a href="#l61.868"></a><span id="l61.868" class="difflineplus">+    assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l61.869"></a><span id="l61.869" class="difflineplus">+    rnp_op_verify_t verify = NULL;</span>
<a href="#l61.870"></a><span id="l61.870" class="difflineplus">+    assert_rnp_success(rnp_op_verify_create(&amp;verify, ffi, input, output));</span>
<a href="#l61.871"></a><span id="l61.871" class="difflineplus">+    assert_rnp_success(rnp_op_verify_execute(verify));</span>
<a href="#l61.872"></a><span id="l61.872" class="difflineplus">+    rnp_output_memory_get_buf(output, &amp;buf, &amp;len, false);</span>
<a href="#l61.873"></a><span id="l61.873" class="difflineplus">+    out.assign((char *) buf, len);</span>
<a href="#l61.874"></a><span id="l61.874" class="difflineplus">+    assert_true(out == file_to_str(&quot;data/test_messages/message.txt&quot;));</span>
<a href="#l61.875"></a><span id="l61.875" class="difflineplus">+    char *mode = NULL;</span>
<a href="#l61.876"></a><span id="l61.876" class="difflineplus">+    char *cipher = NULL;</span>
<a href="#l61.877"></a><span id="l61.877" class="difflineplus">+    bool  valid = true;</span>
<a href="#l61.878"></a><span id="l61.878" class="difflineplus">+    assert_rnp_success(rnp_op_verify_get_protection_info(verify, &amp;mode, &amp;cipher, &amp;valid));</span>
<a href="#l61.879"></a><span id="l61.879" class="difflineplus">+    assert_string_equal(mode, &quot;none&quot;);</span>
<a href="#l61.880"></a><span id="l61.880" class="difflineplus">+    assert_string_equal(cipher, &quot;none&quot;);</span>
<a href="#l61.881"></a><span id="l61.881" class="difflineplus">+    assert_false(valid);</span>
<a href="#l61.882"></a><span id="l61.882" class="difflineplus">+    rnp_buffer_destroy(mode);</span>
<a href="#l61.883"></a><span id="l61.883" class="difflineplus">+    rnp_buffer_destroy(cipher);</span>
<a href="#l61.884"></a><span id="l61.884" class="difflineplus">+    size_t count = 255;</span>
<a href="#l61.885"></a><span id="l61.885" class="difflineplus">+    assert_rnp_success(rnp_op_verify_get_signature_count(verify, &amp;count));</span>
<a href="#l61.886"></a><span id="l61.886" class="difflineplus">+    assert_int_equal(count, 0);</span>
<a href="#l61.887"></a><span id="l61.887" class="difflineplus">+    count = 255;</span>
<a href="#l61.888"></a><span id="l61.888" class="difflineplus">+    assert_rnp_success(rnp_op_verify_get_recipient_count(verify, &amp;count));</span>
<a href="#l61.889"></a><span id="l61.889" class="difflineplus">+    assert_int_equal(count, 0);</span>
<a href="#l61.890"></a><span id="l61.890" class="difflineplus">+    count = 255;</span>
<a href="#l61.891"></a><span id="l61.891" class="difflineplus">+    assert_rnp_success(rnp_op_verify_get_symenc_count(verify, &amp;count));</span>
<a href="#l61.892"></a><span id="l61.892" class="difflineplus">+    assert_int_equal(count, 0);</span>
<a href="#l61.893"></a><span id="l61.893" class="difflineplus">+    rnp_op_verify_destroy(verify);</span>
<a href="#l61.894"></a><span id="l61.894" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l61.895"></a><span id="l61.895" class="difflineplus">+    rnp_output_destroy(output);</span>
<a href="#l61.896"></a><span id="l61.896" class="difflineplus">+</span>
<a href="#l61.897"></a><span id="l61.897" class="difflineplus">+    rnp_ffi_destroy(ffi);</span>
<a href="#l61.898"></a><span id="l61.898" class="difflineplus">+}</span>
<a href="#l61.899"></a><span id="l61.899">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l62.1"></a><span id="l62.1" class="difflineminus">--- a/third_party/rnp/src/tests/generatekey.cpp</span>
<a href="#l62.2"></a><span id="l62.2" class="difflineplus">+++ b/third_party/rnp/src/tests/generatekey.cpp</span>
<a href="#l62.3"></a><span id="l62.3" class="difflineat">@@ -956,38 +956,38 @@ TEST_F(rnp_tests, test_generated_key_sig</span>
<a href="#l62.4"></a><span id="l62.4">         assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_subsig(&amp;sec, 0)-&gt;rawpkt.tag);</span>
<a href="#l62.5"></a><span id="l62.5"> </span>
<a href="#l62.6"></a><span id="l62.6">         // validate the userid self-sig</span>
<a href="#l62.7"></a><span id="l62.7"> </span>
<a href="#l62.8"></a><span id="l62.8">         psiginfo.sig = psig;</span>
<a href="#l62.9"></a><span id="l62.9">         psiginfo.signer = &amp;pub;</span>
<a href="#l62.10"></a><span id="l62.10">         assert_rnp_success(signature_check_certification(</span>
<a href="#l62.11"></a><span id="l62.11">           &amp;psiginfo, pgp_key_get_pkt(&amp;pub), &amp;pgp_key_get_userid(&amp;pub, 0)-&gt;pkt));</span>
<a href="#l62.12"></a><span id="l62.12" class="difflineminus">-        assert_true(signature_get_keyfp(psig, &amp;fp));</span>
<a href="#l62.13"></a><span id="l62.13" class="difflineminus">-        assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(&amp;pub)));</span>
<a href="#l62.14"></a><span id="l62.14" class="difflineplus">+        assert_true(signature_get_keyfp(psig, fp));</span>
<a href="#l62.15"></a><span id="l62.15" class="difflineplus">+        assert_true(fp == pgp_key_get_fp(&amp;pub));</span>
<a href="#l62.16"></a><span id="l62.16">         // check subpackets and their contents</span>
<a href="#l62.17"></a><span id="l62.17">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_FPR);</span>
<a href="#l62.18"></a><span id="l62.18">         assert_non_null(subpkt);</span>
<a href="#l62.19"></a><span id="l62.19">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l62.20"></a><span id="l62.20">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_KEY_ID);</span>
<a href="#l62.21"></a><span id="l62.21">         assert_non_null(subpkt);</span>
<a href="#l62.22"></a><span id="l62.22">         assert_false(subpkt-&gt;hashed);</span>
<a href="#l62.23"></a><span id="l62.23">         assert_int_equal(</span>
<a href="#l62.24"></a><span id="l62.24" class="difflineminus">-          0, memcmp(subpkt-&gt;fields.issuer, pgp_key_get_keyid(&amp;pub), PGP_KEY_ID_SIZE));</span>
<a href="#l62.25"></a><span id="l62.25" class="difflineplus">+          0, memcmp(subpkt-&gt;fields.issuer, pgp_key_get_keyid(&amp;pub).data(), PGP_KEY_ID_SIZE));</span>
<a href="#l62.26"></a><span id="l62.26">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_CREATION_TIME);</span>
<a href="#l62.27"></a><span id="l62.27">         assert_non_null(subpkt);</span>
<a href="#l62.28"></a><span id="l62.28">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l62.29"></a><span id="l62.29">         assert_true(subpkt-&gt;fields.create &lt;= time(NULL));</span>
<a href="#l62.30"></a><span id="l62.30"> </span>
<a href="#l62.31"></a><span id="l62.31">         ssiginfo.sig = ssig;</span>
<a href="#l62.32"></a><span id="l62.32">         ssiginfo.signer = &amp;sec;</span>
<a href="#l62.33"></a><span id="l62.33">         assert_rnp_success(signature_check_certification(</span>
<a href="#l62.34"></a><span id="l62.34">           &amp;ssiginfo, pgp_key_get_pkt(&amp;sec), &amp;pgp_key_get_userid(&amp;sec, 0)-&gt;pkt));</span>
<a href="#l62.35"></a><span id="l62.35" class="difflineminus">-        assert_true(signature_get_keyfp(ssig, &amp;fp));</span>
<a href="#l62.36"></a><span id="l62.36" class="difflineminus">-        assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(&amp;sec)));</span>
<a href="#l62.37"></a><span id="l62.37" class="difflineplus">+        assert_true(signature_get_keyfp(ssig, fp));</span>
<a href="#l62.38"></a><span id="l62.38" class="difflineplus">+        assert_true(fp == pgp_key_get_fp(&amp;sec));</span>
<a href="#l62.39"></a><span id="l62.39"> </span>
<a href="#l62.40"></a><span id="l62.40">         // modify a hashed portion of the sig packets</span>
<a href="#l62.41"></a><span id="l62.41">         psig-&gt;hashed_data[32] ^= 0xff;</span>
<a href="#l62.42"></a><span id="l62.42">         ssig-&gt;hashed_data[32] ^= 0xff;</span>
<a href="#l62.43"></a><span id="l62.43">         // ensure validation fails</span>
<a href="#l62.44"></a><span id="l62.44">         assert_rnp_failure(signature_check_certification(</span>
<a href="#l62.45"></a><span id="l62.45">           &amp;psiginfo, pgp_key_get_pkt(&amp;pub), &amp;pgp_key_get_userid(&amp;pub, 0)-&gt;pkt));</span>
<a href="#l62.46"></a><span id="l62.46">         assert_rnp_failure(signature_check_certification(</span>
<a href="#l62.47"></a><span id="l62.47" class="difflineat">@@ -1082,38 +1082,40 @@ TEST_F(rnp_tests, test_generated_key_sig</span>
<a href="#l62.48"></a><span id="l62.48">         // make sure we're targeting the right packet</span>
<a href="#l62.49"></a><span id="l62.49">         assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_subsig(&amp;pub, 0)-&gt;rawpkt.tag);</span>
<a href="#l62.50"></a><span id="l62.50">         assert_int_equal(PGP_PKT_SIGNATURE, pgp_key_get_subsig(&amp;sec, 0)-&gt;rawpkt.tag);</span>
<a href="#l62.51"></a><span id="l62.51">         // validate the binding sig</span>
<a href="#l62.52"></a><span id="l62.52">         psiginfo.sig = psig;</span>
<a href="#l62.53"></a><span id="l62.53">         psiginfo.signer = primary_pub;</span>
<a href="#l62.54"></a><span id="l62.54">         assert_rnp_success(signature_check_binding(</span>
<a href="#l62.55"></a><span id="l62.55">           &amp;psiginfo, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;pub)));</span>
<a href="#l62.56"></a><span id="l62.56" class="difflineminus">-        assert_true(signature_get_keyfp(psig, &amp;fp));</span>
<a href="#l62.57"></a><span id="l62.57" class="difflineminus">-        assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(primary_pub)));</span>
<a href="#l62.58"></a><span id="l62.58" class="difflineplus">+        assert_true(signature_get_keyfp(psig, fp));</span>
<a href="#l62.59"></a><span id="l62.59" class="difflineplus">+        assert_true(fp == pgp_key_get_fp(primary_pub));</span>
<a href="#l62.60"></a><span id="l62.60">         // check subpackets and their contents</span>
<a href="#l62.61"></a><span id="l62.61">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_FPR);</span>
<a href="#l62.62"></a><span id="l62.62">         assert_non_null(subpkt);</span>
<a href="#l62.63"></a><span id="l62.63">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l62.64"></a><span id="l62.64">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_ISSUER_KEY_ID);</span>
<a href="#l62.65"></a><span id="l62.65">         assert_non_null(subpkt);</span>
<a href="#l62.66"></a><span id="l62.66">         assert_false(subpkt-&gt;hashed);</span>
<a href="#l62.67"></a><span id="l62.67" class="difflineminus">-        assert_int_equal(</span>
<a href="#l62.68"></a><span id="l62.68" class="difflineminus">-          0, memcmp(subpkt-&gt;fields.issuer, pgp_key_get_keyid(primary_pub), PGP_KEY_ID_SIZE));</span>
<a href="#l62.69"></a><span id="l62.69" class="difflineplus">+        assert_int_equal(0,</span>
<a href="#l62.70"></a><span id="l62.70" class="difflineplus">+                         memcmp(subpkt-&gt;fields.issuer,</span>
<a href="#l62.71"></a><span id="l62.71" class="difflineplus">+                                pgp_key_get_keyid(primary_pub).data(),</span>
<a href="#l62.72"></a><span id="l62.72" class="difflineplus">+                                PGP_KEY_ID_SIZE));</span>
<a href="#l62.73"></a><span id="l62.73">         subpkt = signature_get_subpkt(psig, PGP_SIG_SUBPKT_CREATION_TIME);</span>
<a href="#l62.74"></a><span id="l62.74">         assert_non_null(subpkt);</span>
<a href="#l62.75"></a><span id="l62.75">         assert_true(subpkt-&gt;hashed);</span>
<a href="#l62.76"></a><span id="l62.76">         assert_true(subpkt-&gt;fields.create &lt;= time(NULL));</span>
<a href="#l62.77"></a><span id="l62.77"> </span>
<a href="#l62.78"></a><span id="l62.78">         ssiginfo.sig = ssig;</span>
<a href="#l62.79"></a><span id="l62.79">         ssiginfo.signer = primary_pub;</span>
<a href="#l62.80"></a><span id="l62.80">         assert_rnp_success(signature_check_binding(</span>
<a href="#l62.81"></a><span id="l62.81">           &amp;ssiginfo, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;sec)));</span>
<a href="#l62.82"></a><span id="l62.82" class="difflineminus">-        assert_true(signature_get_keyfp(ssig, &amp;fp));</span>
<a href="#l62.83"></a><span id="l62.83" class="difflineminus">-        assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(primary_sec)));</span>
<a href="#l62.84"></a><span id="l62.84" class="difflineplus">+        assert_true(signature_get_keyfp(ssig, fp));</span>
<a href="#l62.85"></a><span id="l62.85" class="difflineplus">+        assert_true(fp == pgp_key_get_fp(primary_sec));</span>
<a href="#l62.86"></a><span id="l62.86"> </span>
<a href="#l62.87"></a><span id="l62.87">         // modify a hashed portion of the sig packets</span>
<a href="#l62.88"></a><span id="l62.88">         psig-&gt;hashed_data[10] ^= 0xff;</span>
<a href="#l62.89"></a><span id="l62.89">         ssig-&gt;hashed_data[10] ^= 0xff;</span>
<a href="#l62.90"></a><span id="l62.90">         // ensure validation fails</span>
<a href="#l62.91"></a><span id="l62.91">         assert_rnp_failure(signature_check_binding(</span>
<a href="#l62.92"></a><span id="l62.92">           &amp;psiginfo, pgp_key_get_pkt(primary_pub), pgp_key_get_pkt(&amp;pub)));</span>
<a href="#l62.93"></a><span id="l62.93">         assert_rnp_failure(signature_check_binding(</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l63.1"></a><span id="l63.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-store-search.cpp</span>
<a href="#l63.2"></a><span id="l63.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-store-search.cpp</span>
<a href="#l63.3"></a><span id="l63.3" class="difflineat">@@ -50,62 +50,67 @@ TEST_F(rnp_tests, test_key_store_search)</span>
<a href="#l63.4"></a><span id="l63.4">                     {&quot;FFFFFFFFFFFFFFFF&quot;, 0, {NULL}}};</span>
<a href="#l63.5"></a><span id="l63.5">     // add our fake test keys</span>
<a href="#l63.6"></a><span id="l63.6">     for (size_t i = 0; i &lt; ARRAY_SIZE(testdata); i++) {</span>
<a href="#l63.7"></a><span id="l63.7">         for (size_t n = 0; n &lt; testdata[i].count; n++) {</span>
<a href="#l63.8"></a><span id="l63.8">             pgp_key_t key = {};</span>
<a href="#l63.9"></a><span id="l63.9"> </span>
<a href="#l63.10"></a><span id="l63.10">             key.pkt.tag = PGP_PKT_PUBLIC_KEY;</span>
<a href="#l63.11"></a><span id="l63.11">             key.pkt.version = PGP_V4;</span>
<a href="#l63.12"></a><span id="l63.12" class="difflineplus">+            key.pkt.alg = PGP_PKA_RSA;</span>
<a href="#l63.13"></a><span id="l63.13"> </span>
<a href="#l63.14"></a><span id="l63.14">             // set the keyid</span>
<a href="#l63.15"></a><span id="l63.15" class="difflineminus">-            assert_true(rnp_hex_decode(testdata[i].keyid, key.keyid, sizeof(key.keyid)));</span>
<a href="#l63.16"></a><span id="l63.16" class="difflineplus">+            assert_true(rnp_hex_decode(testdata[i].keyid, key.keyid.data(), key.keyid.size()));</span>
<a href="#l63.17"></a><span id="l63.17">             // keys should have different grips otherwise rnp_key_store_add_key will fail here</span>
<a href="#l63.18"></a><span id="l63.18">             assert_true(rnp_hex_decode(testdata[i].keyid, key.grip.data(), key.grip.size()));</span>
<a href="#l63.19"></a><span id="l63.19">             key.grip[0] = (uint8_t) n;</span>
<a href="#l63.20"></a><span id="l63.20" class="difflineplus">+            // and fingerprint</span>
<a href="#l63.21"></a><span id="l63.21" class="difflineplus">+            assert_true(rnp_hex_decode(</span>
<a href="#l63.22"></a><span id="l63.22" class="difflineplus">+              testdata[i].keyid, key.fingerprint.fingerprint, PGP_FINGERPRINT_SIZE));</span>
<a href="#l63.23"></a><span id="l63.23" class="difflineplus">+            key.fingerprint.fingerprint[0] = (uint8_t) n;</span>
<a href="#l63.24"></a><span id="l63.24" class="difflineplus">+            key.fingerprint.length = PGP_FINGERPRINT_SIZE;</span>
<a href="#l63.25"></a><span id="l63.25">             // set the userids</span>
<a href="#l63.26"></a><span id="l63.26">             for (size_t uidn = 0; testdata[i].userids[uidn]; uidn++) {</span>
<a href="#l63.27"></a><span id="l63.27">                 pgp_userid_t *userid = pgp_key_add_userid(&amp;key);</span>
<a href="#l63.28"></a><span id="l63.28">                 assert_non_null(userid);</span>
<a href="#l63.29"></a><span id="l63.29">                 userid-&gt;str = testdata[i].userids[uidn];</span>
<a href="#l63.30"></a><span id="l63.30">             }</span>
<a href="#l63.31"></a><span id="l63.31">             // add to the store</span>
<a href="#l63.32"></a><span id="l63.32">             assert_true(rnp_key_store_add_key(store, &amp;key));</span>
<a href="#l63.33"></a><span id="l63.33">         }</span>
<a href="#l63.34"></a><span id="l63.34">     }</span>
<a href="#l63.35"></a><span id="l63.35"> </span>
<a href="#l63.36"></a><span id="l63.36">     // keyid search</span>
<a href="#l63.37"></a><span id="l63.37">     for (size_t i = 0; i &lt; ARRAY_SIZE(testdata); i++) {</span>
<a href="#l63.38"></a><span id="l63.38" class="difflineminus">-        uint8_t keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l63.39"></a><span id="l63.39" class="difflineminus">-        assert_true(rnp_hex_decode(testdata[i].keyid, keyid, sizeof(keyid)));</span>
<a href="#l63.40"></a><span id="l63.40" class="difflineplus">+        pgp_key_id_t keyid = {};</span>
<a href="#l63.41"></a><span id="l63.41" class="difflineplus">+        assert_true(rnp_hex_decode(testdata[i].keyid, keyid.data(), keyid.size()));</span>
<a href="#l63.42"></a><span id="l63.42">         list seen_keys = NULL;</span>
<a href="#l63.43"></a><span id="l63.43">         for (pgp_key_t *key = rnp_key_store_get_key_by_id(store, keyid, NULL); key;</span>
<a href="#l63.44"></a><span id="l63.44">              key = rnp_key_store_get_key_by_id(store, keyid, key)) {</span>
<a href="#l63.45"></a><span id="l63.45">             // check that the keyid actually matches</span>
<a href="#l63.46"></a><span id="l63.46" class="difflineminus">-            assert_int_equal(0, memcmp(pgp_key_get_keyid(key), keyid, PGP_KEY_ID_SIZE));</span>
<a href="#l63.47"></a><span id="l63.47" class="difflineplus">+            assert_true(pgp_key_get_keyid(key) == keyid);</span>
<a href="#l63.48"></a><span id="l63.48">             // check that we have not already encountered this key pointer</span>
<a href="#l63.49"></a><span id="l63.49">             assert_null(list_find(seen_keys, &amp;key, sizeof(key)));</span>
<a href="#l63.50"></a><span id="l63.50">             // keep track of what key pointers we have seen</span>
<a href="#l63.51"></a><span id="l63.51">             assert_non_null(list_append(&amp;seen_keys, &amp;key, sizeof(key)));</span>
<a href="#l63.52"></a><span id="l63.52">         }</span>
<a href="#l63.53"></a><span id="l63.53">         assert_int_equal(list_length(seen_keys), testdata[i].count);</span>
<a href="#l63.54"></a><span id="l63.54">         list_destroy(&amp;seen_keys);</span>
<a href="#l63.55"></a><span id="l63.55">     }</span>
<a href="#l63.56"></a><span id="l63.56">     // keyid search (by_name)</span>
<a href="#l63.57"></a><span id="l63.57">     for (size_t i = 0; i &lt; ARRAY_SIZE(testdata); i++) {</span>
<a href="#l63.58"></a><span id="l63.58">         list       seen_keys = NULL;</span>
<a href="#l63.59"></a><span id="l63.59">         pgp_key_t *key = NULL;</span>
<a href="#l63.60"></a><span id="l63.60">         key = rnp_tests_get_key_by_id(store, testdata[i].keyid, NULL);</span>
<a href="#l63.61"></a><span id="l63.61">         while (key) {</span>
<a href="#l63.62"></a><span id="l63.62">             // check that the keyid actually matches</span>
<a href="#l63.63"></a><span id="l63.63" class="difflineminus">-            uint8_t expected_keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l63.64"></a><span id="l63.64" class="difflineplus">+            pgp_key_id_t expected_keyid = {};</span>
<a href="#l63.65"></a><span id="l63.65">             assert_true(</span>
<a href="#l63.66"></a><span id="l63.66" class="difflineminus">-              rnp_hex_decode(testdata[i].keyid, expected_keyid, sizeof(expected_keyid)));</span>
<a href="#l63.67"></a><span id="l63.67" class="difflineminus">-            assert_int_equal(0,</span>
<a href="#l63.68"></a><span id="l63.68" class="difflineminus">-                             memcmp(pgp_key_get_keyid(key), expected_keyid, PGP_KEY_ID_SIZE));</span>
<a href="#l63.69"></a><span id="l63.69" class="difflineplus">+              rnp_hex_decode(testdata[i].keyid, expected_keyid.data(), expected_keyid.size()));</span>
<a href="#l63.70"></a><span id="l63.70" class="difflineplus">+            assert_true(pgp_key_get_keyid(key) == expected_keyid);</span>
<a href="#l63.71"></a><span id="l63.71">             // check that we have not already encountered this key pointer</span>
<a href="#l63.72"></a><span id="l63.72">             assert_null(list_find(seen_keys, &amp;key, sizeof(key)));</span>
<a href="#l63.73"></a><span id="l63.73">             // keep track of what key pointers we have seen</span>
<a href="#l63.74"></a><span id="l63.74">             assert_non_null(list_append(&amp;seen_keys, &amp;key, sizeof(key)));</span>
<a href="#l63.75"></a><span id="l63.75"> </span>
<a href="#l63.76"></a><span id="l63.76">             // this only returns false on error, regardless of whether it found a match</span>
<a href="#l63.77"></a><span id="l63.77">             key = rnp_tests_get_key_by_id(store, testdata[i].keyid, key);</span>
<a href="#l63.78"></a><span id="l63.78">         }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l64.1"></a><span id="l64.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-validate.cpp</span>
<a href="#l64.2"></a><span id="l64.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-validate.cpp</span>
<a href="#l64.3"></a><span id="l64.3" class="difflineat">@@ -33,18 +33,18 @@</span>
<a href="#l64.4"></a><span id="l64.4"> </span>
<a href="#l64.5"></a><span id="l64.5"> static bool</span>
<a href="#l64.6"></a><span id="l64.6"> all_keys_valid(const rnp_key_store_t *keyring)</span>
<a href="#l64.7"></a><span id="l64.7"> {</span>
<a href="#l64.8"></a><span id="l64.8">     char keyid[PGP_KEY_ID_SIZE * 2 + 3] = {0};</span>
<a href="#l64.9"></a><span id="l64.9"> </span>
<a href="#l64.10"></a><span id="l64.10">     for (auto &amp;key : keyring-&gt;keys) {</span>
<a href="#l64.11"></a><span id="l64.11">         if (!key.valid) {</span>
<a href="#l64.12"></a><span id="l64.12" class="difflineminus">-            assert_true(rnp_hex_encode(pgp_key_get_keyid(&amp;key),</span>
<a href="#l64.13"></a><span id="l64.13" class="difflineminus">-                                       PGP_KEY_ID_SIZE,</span>
<a href="#l64.14"></a><span id="l64.14" class="difflineplus">+            assert_true(rnp_hex_encode(pgp_key_get_keyid(&amp;key).data(),</span>
<a href="#l64.15"></a><span id="l64.15" class="difflineplus">+                                       pgp_key_get_keyid(&amp;key).size(),</span>
<a href="#l64.16"></a><span id="l64.16">                                        keyid,</span>
<a href="#l64.17"></a><span id="l64.17">                                        sizeof(keyid),</span>
<a href="#l64.18"></a><span id="l64.18">                                        RNP_HEX_LOWERCASE));</span>
<a href="#l64.19"></a><span id="l64.19">             RNP_LOG(&quot;key %s is not valid&quot;, keyid);</span>
<a href="#l64.20"></a><span id="l64.20">             return false;</span>
<a href="#l64.21"></a><span id="l64.21">         }</span>
<a href="#l64.22"></a><span id="l64.22">     }</span>
<a href="#l64.23"></a><span id="l64.23">     return true;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l65.1"></a><span id="l65.1" class="difflineminus">--- a/third_party/rnp/src/tests/load-g10.cpp</span>
<a href="#l65.2"></a><span id="l65.2" class="difflineplus">+++ b/third_party/rnp/src/tests/load-g10.cpp</span>
<a href="#l65.3"></a><span id="l65.3" class="difflineat">@@ -28,22 +28,22 @@</span>
<a href="#l65.4"></a><span id="l65.4"> #include &quot;pgp-key.h&quot;</span>
<a href="#l65.5"></a><span id="l65.5"> </span>
<a href="#l65.6"></a><span id="l65.6"> #include &quot;rnp_tests.h&quot;</span>
<a href="#l65.7"></a><span id="l65.7"> #include &quot;support.h&quot;</span>
<a href="#l65.8"></a><span id="l65.8"> </span>
<a href="#l65.9"></a><span id="l65.9"> static bool</span>
<a href="#l65.10"></a><span id="l65.10"> test_load_g10_check_key(rnp_key_store_t *pub, rnp_key_store_t *sec, const char *id)</span>
<a href="#l65.11"></a><span id="l65.11"> {</span>
<a href="#l65.12"></a><span id="l65.12" class="difflineminus">-    uint8_t                 keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l65.13"></a><span id="l65.13" class="difflineplus">+    pgp_key_id_t            keyid = {};</span>
<a href="#l65.14"></a><span id="l65.14">     pgp_key_t *             key = NULL;</span>
<a href="#l65.15"></a><span id="l65.15">     pgp_password_provider_t pswd_prov = {.callback = string_copy_password_callback,</span>
<a href="#l65.16"></a><span id="l65.16">                                          .userdata = (void *) &quot;password&quot;};</span>
<a href="#l65.17"></a><span id="l65.17"> </span>
<a href="#l65.18"></a><span id="l65.18" class="difflineminus">-    if (!rnp_hex_decode(id, keyid, sizeof(keyid))) {</span>
<a href="#l65.19"></a><span id="l65.19" class="difflineplus">+    if (!rnp_hex_decode(id, keyid.data(), keyid.size())) {</span>
<a href="#l65.20"></a><span id="l65.20">         return false;</span>
<a href="#l65.21"></a><span id="l65.21">     }</span>
<a href="#l65.22"></a><span id="l65.22">     if (!rnp_key_store_get_key_by_id(pub, keyid, NULL)) {</span>
<a href="#l65.23"></a><span id="l65.23">         return false;</span>
<a href="#l65.24"></a><span id="l65.24">     }</span>
<a href="#l65.25"></a><span id="l65.25">     if (!(key = rnp_key_store_get_key_by_id(sec, keyid, NULL))) {</span>
<a href="#l65.26"></a><span id="l65.26">         return false;</span>
<a href="#l65.27"></a><span id="l65.27">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l66.1"></a><span id="l66.1" class="difflineminus">--- a/third_party/rnp/src/tests/load-pgp.cpp</span>
<a href="#l66.2"></a><span id="l66.2" class="difflineplus">+++ b/third_party/rnp/src/tests/load-pgp.cpp</span>
<a href="#l66.3"></a><span id="l66.3" class="difflineat">@@ -44,18 +44,18 @@ TEST_F(rnp_tests, test_load_v3_keyring_p</span>
<a href="#l66.4"></a><span id="l66.4"> </span>
<a href="#l66.5"></a><span id="l66.5">     // load pubring in to the key store</span>
<a href="#l66.6"></a><span id="l66.6">     assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/2/pubring.gpg&quot;));</span>
<a href="#l66.7"></a><span id="l66.7">     assert_rnp_success(rnp_key_store_pgp_read_from_src(key_store, &amp;src));</span>
<a href="#l66.8"></a><span id="l66.8">     src_close(&amp;src);</span>
<a href="#l66.9"></a><span id="l66.9">     assert_int_equal(1, rnp_key_store_get_key_count(key_store));</span>
<a href="#l66.10"></a><span id="l66.10"> </span>
<a href="#l66.11"></a><span id="l66.11">     // find the key by keyid</span>
<a href="#l66.12"></a><span id="l66.12" class="difflineminus">-    static const uint8_t keyid[] = {0xDC, 0x70, 0xC1, 0x24, 0xA5, 0x02, 0x83, 0xF1};</span>
<a href="#l66.13"></a><span id="l66.13" class="difflineminus">-    const pgp_key_t *    key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.14"></a><span id="l66.14" class="difflineplus">+    static const pgp_key_id_t keyid = {0xDC, 0x70, 0xC1, 0x24, 0xA5, 0x02, 0x83, 0xF1};</span>
<a href="#l66.15"></a><span id="l66.15" class="difflineplus">+    const pgp_key_t *         key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.16"></a><span id="l66.16">     assert_non_null(key);</span>
<a href="#l66.17"></a><span id="l66.17"> </span>
<a href="#l66.18"></a><span id="l66.18">     // confirm the key flags are correct</span>
<a href="#l66.19"></a><span id="l66.19">     assert_int_equal(pgp_key_get_flags(key),</span>
<a href="#l66.20"></a><span id="l66.20">                      PGP_KF_ENCRYPT | PGP_KF_SIGN | PGP_KF_CERTIFY | PGP_KF_AUTH);</span>
<a href="#l66.21"></a><span id="l66.21"> </span>
<a href="#l66.22"></a><span id="l66.22">     // confirm that key expiration is correct</span>
<a href="#l66.23"></a><span id="l66.23">     assert_int_equal(pgp_key_get_expiration(key), 0);</span>
<a href="#l66.24"></a><span id="l66.24" class="difflineat">@@ -67,17 +67,17 @@ TEST_F(rnp_tests, test_load_v3_keyring_p</span>
<a href="#l66.25"></a><span id="l66.25"> </span>
<a href="#l66.26"></a><span id="l66.26">     key_store = new rnp_key_store_t();</span>
<a href="#l66.27"></a><span id="l66.27"> </span>
<a href="#l66.28"></a><span id="l66.28">     assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/4/secring.pgp&quot;));</span>
<a href="#l66.29"></a><span id="l66.29">     assert_rnp_success(rnp_key_store_pgp_read_from_src(key_store, &amp;src));</span>
<a href="#l66.30"></a><span id="l66.30">     src_close(&amp;src);</span>
<a href="#l66.31"></a><span id="l66.31">     assert_int_equal(1, rnp_key_store_get_key_count(key_store));</span>
<a href="#l66.32"></a><span id="l66.32"> </span>
<a href="#l66.33"></a><span id="l66.33" class="difflineminus">-    static const uint8_t keyid2[] = {0x7D, 0x0B, 0xC1, 0x0E, 0x93, 0x34, 0x04, 0xC9};</span>
<a href="#l66.34"></a><span id="l66.34" class="difflineplus">+    static const pgp_key_id_t keyid2 = {0x7D, 0x0B, 0xC1, 0x0E, 0x93, 0x34, 0x04, 0xC9};</span>
<a href="#l66.35"></a><span id="l66.35">     key = rnp_key_store_get_key_by_id(key_store, keyid2, NULL);</span>
<a href="#l66.36"></a><span id="l66.36">     assert_non_null(key);</span>
<a href="#l66.37"></a><span id="l66.37"> </span>
<a href="#l66.38"></a><span id="l66.38">     // confirm the key flags are correct</span>
<a href="#l66.39"></a><span id="l66.39">     assert_int_equal(pgp_key_get_flags(key),</span>
<a href="#l66.40"></a><span id="l66.40">                      PGP_KF_ENCRYPT | PGP_KF_SIGN | PGP_KF_CERTIFY | PGP_KF_AUTH);</span>
<a href="#l66.41"></a><span id="l66.41"> </span>
<a href="#l66.42"></a><span id="l66.42">     // check if the key is secret and is locked</span>
<a href="#l66.43"></a><span id="l66.43" class="difflineat">@@ -108,18 +108,18 @@ TEST_F(rnp_tests, test_load_v4_keyring_p</span>
<a href="#l66.44"></a><span id="l66.44"> </span>
<a href="#l66.45"></a><span id="l66.45">     // load it in to the key store</span>
<a href="#l66.46"></a><span id="l66.46">     assert_rnp_success(init_file_src(&amp;src, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l66.47"></a><span id="l66.47">     assert_rnp_success(rnp_key_store_pgp_read_from_src(key_store, &amp;src));</span>
<a href="#l66.48"></a><span id="l66.48">     src_close(&amp;src);</span>
<a href="#l66.49"></a><span id="l66.49">     assert_int_equal(7, rnp_key_store_get_key_count(key_store));</span>
<a href="#l66.50"></a><span id="l66.50"> </span>
<a href="#l66.51"></a><span id="l66.51">     // find the key by keyid</span>
<a href="#l66.52"></a><span id="l66.52" class="difflineminus">-    static const uint8_t keyid[] = {0x8a, 0x05, 0xb8, 0x9f, 0xad, 0x5a, 0xde, 0xd1};</span>
<a href="#l66.53"></a><span id="l66.53" class="difflineminus">-    const pgp_key_t *    key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.54"></a><span id="l66.54" class="difflineplus">+    static const pgp_key_id_t keyid = {0x8a, 0x05, 0xb8, 0x9f, 0xad, 0x5a, 0xde, 0xd1};</span>
<a href="#l66.55"></a><span id="l66.55" class="difflineplus">+    const pgp_key_t *         key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.56"></a><span id="l66.56">     assert_non_null(key);</span>
<a href="#l66.57"></a><span id="l66.57"> </span>
<a href="#l66.58"></a><span id="l66.58">     // confirm the key flags are correct</span>
<a href="#l66.59"></a><span id="l66.59">     assert_int_equal(pgp_key_get_flags(key), PGP_KF_ENCRYPT);</span>
<a href="#l66.60"></a><span id="l66.60"> </span>
<a href="#l66.61"></a><span id="l66.61">     // cleanup</span>
<a href="#l66.62"></a><span id="l66.62">     delete key_store;</span>
<a href="#l66.63"></a><span id="l66.63"> }</span>
<a href="#l66.64"></a><span id="l66.64" class="difflineat">@@ -183,163 +183,164 @@ TEST_F(rnp_tests, test_load_keyring_and_</span>
<a href="#l66.65"></a><span id="l66.65">     check_pgp_keyring_counts(&quot;data/keyrings/1/secring.gpg&quot;, primary_count, subkey_counts);</span>
<a href="#l66.66"></a><span id="l66.66"> }</span>
<a href="#l66.67"></a><span id="l66.67"> </span>
<a href="#l66.68"></a><span id="l66.68"> /* This test loads a V4 keyring and confirms that certain</span>
<a href="#l66.69"></a><span id="l66.69">  * bitfields and time fields are set correctly.</span>
<a href="#l66.70"></a><span id="l66.70">  */</span>
<a href="#l66.71"></a><span id="l66.71"> TEST_F(rnp_tests, test_load_check_bitfields_and_times)</span>
<a href="#l66.72"></a><span id="l66.72"> {</span>
<a href="#l66.73"></a><span id="l66.73" class="difflineminus">-    uint8_t                keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.74"></a><span id="l66.74" class="difflineminus">-    uint8_t                signer_id[PGP_KEY_ID_SIZE] = {0};</span>
<a href="#l66.75"></a><span id="l66.75" class="difflineplus">+    pgp_key_id_t           keyid = {};</span>
<a href="#l66.76"></a><span id="l66.76" class="difflineplus">+    pgp_key_id_t           signer_id = {};</span>
<a href="#l66.77"></a><span id="l66.77">     const pgp_key_t *      key;</span>
<a href="#l66.78"></a><span id="l66.78">     const pgp_signature_t *sig = NULL;</span>
<a href="#l66.79"></a><span id="l66.79"> </span>
<a href="#l66.80"></a><span id="l66.80">     // load keyring</span>
<a href="#l66.81"></a><span id="l66.81">     rnp_key_store_t *key_store =</span>
<a href="#l66.82"></a><span id="l66.82">       new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l66.83"></a><span id="l66.83">     assert_true(rnp_key_store_load_from_path(key_store, NULL));</span>
<a href="#l66.84"></a><span id="l66.84"> </span>
<a href="#l66.85"></a><span id="l66.85">     // find</span>
<a href="#l66.86"></a><span id="l66.86">     key = NULL;</span>
<a href="#l66.87"></a><span id="l66.87" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.88"></a><span id="l66.88" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.89"></a><span id="l66.89">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.90"></a><span id="l66.90">     assert_non_null(key);</span>
<a href="#l66.91"></a><span id="l66.91">     // check subsig count</span>
<a href="#l66.92"></a><span id="l66.92">     assert_int_equal(pgp_key_get_subsig_count(key), 3);</span>
<a href="#l66.93"></a><span id="l66.93">     // check subsig properties</span>
<a href="#l66.94"></a><span id="l66.94">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(key); i++) {</span>
<a href="#l66.95"></a><span id="l66.95">         sig = &amp;pgp_key_get_subsig(key, i)-&gt;sig;</span>
<a href="#l66.96"></a><span id="l66.96">         static const time_t expected_creation_times[] = {1500569820, 1500569836, 1500569846};</span>
<a href="#l66.97"></a><span id="l66.97">         // check SS_ISSUER_KEY_ID</span>
<a href="#l66.98"></a><span id="l66.98">         assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.99"></a><span id="l66.99" class="difflineminus">-        assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.100"></a><span id="l66.100" class="difflineplus">+        assert_true(keyid == signer_id);</span>
<a href="#l66.101"></a><span id="l66.101">         // check SS_CREATION_TIME</span>
<a href="#l66.102"></a><span id="l66.102">         assert_int_equal(signature_get_creation(sig), expected_creation_times[i]);</span>
<a href="#l66.103"></a><span id="l66.103">         // check SS_EXPIRATION_TIME</span>
<a href="#l66.104"></a><span id="l66.104">         assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.105"></a><span id="l66.105">     }</span>
<a href="#l66.106"></a><span id="l66.106">     // check SS_KEY_EXPIRY</span>
<a href="#l66.107"></a><span id="l66.107">     assert_int_equal(pgp_key_get_expiration(key), 0);</span>
<a href="#l66.108"></a><span id="l66.108"> </span>
<a href="#l66.109"></a><span id="l66.109">     // find</span>
<a href="#l66.110"></a><span id="l66.110">     key = NULL;</span>
<a href="#l66.111"></a><span id="l66.111" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;1ED63EE56FADC34D&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.112"></a><span id="l66.112" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;1ED63EE56FADC34D&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.113"></a><span id="l66.113">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.114"></a><span id="l66.114">     assert_non_null(key);</span>
<a href="#l66.115"></a><span id="l66.115">     // check subsig count</span>
<a href="#l66.116"></a><span id="l66.116">     assert_int_equal(pgp_key_get_subsig_count(key), 1);</span>
<a href="#l66.117"></a><span id="l66.117">     sig = &amp;pgp_key_get_subsig(key, 0)-&gt;sig;</span>
<a href="#l66.118"></a><span id="l66.118">     // check SS_ISSUER_KEY_ID</span>
<a href="#l66.119"></a><span id="l66.119" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.120"></a><span id="l66.120" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.121"></a><span id="l66.121">     assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.122"></a><span id="l66.122" class="difflineminus">-    assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.123"></a><span id="l66.123" class="difflineplus">+    assert_true(keyid == signer_id);</span>
<a href="#l66.124"></a><span id="l66.124">     // check SS_CREATION_TIME [0]</span>
<a href="#l66.125"></a><span id="l66.125">     assert_int_equal(signature_get_creation(sig), 1500569820);</span>
<a href="#l66.126"></a><span id="l66.126">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.127"></a><span id="l66.127">     // check SS_EXPIRATION_TIME [0]</span>
<a href="#l66.128"></a><span id="l66.128">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.129"></a><span id="l66.129">     // check SS_KEY_EXPIRY</span>
<a href="#l66.130"></a><span id="l66.130">     assert_int_equal(pgp_key_get_expiration(key), 0);</span>
<a href="#l66.131"></a><span id="l66.131"> </span>
<a href="#l66.132"></a><span id="l66.132">     // find</span>
<a href="#l66.133"></a><span id="l66.133">     key = NULL;</span>
<a href="#l66.134"></a><span id="l66.134" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;1D7E8A5393C997A8&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.135"></a><span id="l66.135" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;1D7E8A5393C997A8&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.136"></a><span id="l66.136">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.137"></a><span id="l66.137">     assert_non_null(key);</span>
<a href="#l66.138"></a><span id="l66.138">     // check subsig count</span>
<a href="#l66.139"></a><span id="l66.139">     assert_int_equal(pgp_key_get_subsig_count(key), 1);</span>
<a href="#l66.140"></a><span id="l66.140">     sig = &amp;pgp_key_get_subsig(key, 0)-&gt;sig;</span>
<a href="#l66.141"></a><span id="l66.141">     // check SS_ISSUER_KEY_ID</span>
<a href="#l66.142"></a><span id="l66.142" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.143"></a><span id="l66.143" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.144"></a><span id="l66.144">     assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.145"></a><span id="l66.145" class="difflineminus">-    assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.146"></a><span id="l66.146" class="difflineplus">+    assert_true(keyid == signer_id);</span>
<a href="#l66.147"></a><span id="l66.147">     // check SS_CREATION_TIME [0]</span>
<a href="#l66.148"></a><span id="l66.148">     assert_int_equal(signature_get_creation(sig), 1500569851);</span>
<a href="#l66.149"></a><span id="l66.149">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.150"></a><span id="l66.150">     // check SS_EXPIRATION_TIME [0]</span>
<a href="#l66.151"></a><span id="l66.151">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.152"></a><span id="l66.152">     // check SS_KEY_EXPIRY</span>
<a href="#l66.153"></a><span id="l66.153">     assert_int_equal(pgp_key_get_expiration(key), 123 * 24 * 60 * 60 /* 123 days */);</span>
<a href="#l66.154"></a><span id="l66.154"> </span>
<a href="#l66.155"></a><span id="l66.155">     // find</span>
<a href="#l66.156"></a><span id="l66.156">     key = NULL;</span>
<a href="#l66.157"></a><span id="l66.157" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;8A05B89FAD5ADED1&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.158"></a><span id="l66.158" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;8A05B89FAD5ADED1&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.159"></a><span id="l66.159">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.160"></a><span id="l66.160">     assert_non_null(key);</span>
<a href="#l66.161"></a><span id="l66.161">     // check subsig count</span>
<a href="#l66.162"></a><span id="l66.162">     assert_int_equal(pgp_key_get_subsig_count(key), 1);</span>
<a href="#l66.163"></a><span id="l66.163">     sig = &amp;pgp_key_get_subsig(key, 0)-&gt;sig;</span>
<a href="#l66.164"></a><span id="l66.164">     // check SS_ISSUER_KEY_ID</span>
<a href="#l66.165"></a><span id="l66.165" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.166"></a><span id="l66.166" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;7BC6709B15C23A4A&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.167"></a><span id="l66.167">     assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.168"></a><span id="l66.168" class="difflineminus">-    assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.169"></a><span id="l66.169" class="difflineplus">+    assert_true(keyid == signer_id);</span>
<a href="#l66.170"></a><span id="l66.170">     // check SS_CREATION_TIME [0]</span>
<a href="#l66.171"></a><span id="l66.171">     assert_int_equal(signature_get_creation(sig), 1500569896);</span>
<a href="#l66.172"></a><span id="l66.172">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.173"></a><span id="l66.173">     // check SS_EXPIRATION_TIME [0]</span>
<a href="#l66.174"></a><span id="l66.174">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.175"></a><span id="l66.175">     // check SS_KEY_EXPIRY</span>
<a href="#l66.176"></a><span id="l66.176">     assert_int_equal(pgp_key_get_expiration(key), 0);</span>
<a href="#l66.177"></a><span id="l66.177"> </span>
<a href="#l66.178"></a><span id="l66.178">     // find</span>
<a href="#l66.179"></a><span id="l66.179">     key = NULL;</span>
<a href="#l66.180"></a><span id="l66.180" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;2FCADF05FFA501BB&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.181"></a><span id="l66.181" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;2FCADF05FFA501BB&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.182"></a><span id="l66.182">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.183"></a><span id="l66.183">     assert_non_null(key);</span>
<a href="#l66.184"></a><span id="l66.184">     // check subsig count</span>
<a href="#l66.185"></a><span id="l66.185" class="difflineplus">+</span>
<a href="#l66.186"></a><span id="l66.186">     assert_int_equal(pgp_key_get_subsig_count(key), 3);</span>
<a href="#l66.187"></a><span id="l66.187">     // check subsig properties</span>
<a href="#l66.188"></a><span id="l66.188">     for (size_t i = 0; i &lt; pgp_key_get_subsig_count(key); i++) {</span>
<a href="#l66.189"></a><span id="l66.189">         sig = &amp;pgp_key_get_subsig(key, i)-&gt;sig;</span>
<a href="#l66.190"></a><span id="l66.190">         static const time_t expected_creation_times[] = {1501372449, 1500570153, 1500570147};</span>
<a href="#l66.191"></a><span id="l66.191"> </span>
<a href="#l66.192"></a><span id="l66.192">         // check SS_ISSUER_KEY_ID</span>
<a href="#l66.193"></a><span id="l66.193">         assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.194"></a><span id="l66.194" class="difflineminus">-        assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.195"></a><span id="l66.195" class="difflineplus">+        assert_true(keyid == signer_id);</span>
<a href="#l66.196"></a><span id="l66.196">         // check SS_CREATION_TIME</span>
<a href="#l66.197"></a><span id="l66.197">         assert_int_equal(signature_get_creation(sig), expected_creation_times[i]);</span>
<a href="#l66.198"></a><span id="l66.198">         // check SS_EXPIRATION_TIME</span>
<a href="#l66.199"></a><span id="l66.199">         assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.200"></a><span id="l66.200">     }</span>
<a href="#l66.201"></a><span id="l66.201">     // check SS_KEY_EXPIRY</span>
<a href="#l66.202"></a><span id="l66.202">     assert_int_equal(pgp_key_get_expiration(key), 2076663808);</span>
<a href="#l66.203"></a><span id="l66.203"> </span>
<a href="#l66.204"></a><span id="l66.204">     // find</span>
<a href="#l66.205"></a><span id="l66.205">     key = NULL;</span>
<a href="#l66.206"></a><span id="l66.206" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;54505A936A4A970E&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.207"></a><span id="l66.207" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;54505A936A4A970E&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.208"></a><span id="l66.208">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.209"></a><span id="l66.209">     assert_non_null(key);</span>
<a href="#l66.210"></a><span id="l66.210">     // check subsig count</span>
<a href="#l66.211"></a><span id="l66.211">     assert_int_equal(pgp_key_get_subsig_count(key), 1);</span>
<a href="#l66.212"></a><span id="l66.212">     sig = &amp;pgp_key_get_subsig(key, 0)-&gt;sig;</span>
<a href="#l66.213"></a><span id="l66.213">     // check SS_ISSUER_KEY_ID</span>
<a href="#l66.214"></a><span id="l66.214" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;2FCADF05FFA501BB&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.215"></a><span id="l66.215" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;2FCADF05FFA501BB&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.216"></a><span id="l66.216">     assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.217"></a><span id="l66.217" class="difflineminus">-    assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.218"></a><span id="l66.218" class="difflineplus">+    assert_true(keyid == signer_id);</span>
<a href="#l66.219"></a><span id="l66.219">     // check SS_CREATION_TIME [0]</span>
<a href="#l66.220"></a><span id="l66.220">     assert_int_equal(signature_get_creation(sig), 1500569946);</span>
<a href="#l66.221"></a><span id="l66.221">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.222"></a><span id="l66.222">     // check SS_EXPIRATION_TIME [0]</span>
<a href="#l66.223"></a><span id="l66.223">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.224"></a><span id="l66.224">     // check SS_KEY_EXPIRY</span>
<a href="#l66.225"></a><span id="l66.225">     assert_int_equal(pgp_key_get_expiration(key), 2076663808);</span>
<a href="#l66.226"></a><span id="l66.226"> </span>
<a href="#l66.227"></a><span id="l66.227">     // find</span>
<a href="#l66.228"></a><span id="l66.228">     key = NULL;</span>
<a href="#l66.229"></a><span id="l66.229" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;326EF111425D14A5&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.230"></a><span id="l66.230" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;326EF111425D14A5&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.231"></a><span id="l66.231">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.232"></a><span id="l66.232">     assert_non_null(key);</span>
<a href="#l66.233"></a><span id="l66.233">     // check subsig count</span>
<a href="#l66.234"></a><span id="l66.234">     assert_int_equal(pgp_key_get_subsig_count(key), 1);</span>
<a href="#l66.235"></a><span id="l66.235">     sig = &amp;pgp_key_get_subsig(key, 0)-&gt;sig;</span>
<a href="#l66.236"></a><span id="l66.236">     // check SS_ISSUER_KEY_ID</span>
<a href="#l66.237"></a><span id="l66.237" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;2FCADF05FFA501BB&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.238"></a><span id="l66.238" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;2FCADF05FFA501BB&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.239"></a><span id="l66.239">     assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.240"></a><span id="l66.240" class="difflineminus">-    assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.241"></a><span id="l66.241" class="difflineplus">+    assert_true(keyid == signer_id);</span>
<a href="#l66.242"></a><span id="l66.242">     // check SS_CREATION_TIME [0]</span>
<a href="#l66.243"></a><span id="l66.243">     assert_int_equal(signature_get_creation(sig), 1500570165);</span>
<a href="#l66.244"></a><span id="l66.244">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.245"></a><span id="l66.245">     // check SS_EXPIRATION_TIME [0]</span>
<a href="#l66.246"></a><span id="l66.246">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.247"></a><span id="l66.247">     // check SS_KEY_EXPIRY</span>
<a href="#l66.248"></a><span id="l66.248">     assert_int_equal(pgp_key_get_expiration(key), 0);</span>
<a href="#l66.249"></a><span id="l66.249"> </span>
<a href="#l66.250"></a><span id="l66.250" class="difflineat">@@ -347,42 +348,42 @@ TEST_F(rnp_tests, test_load_check_bitfie</span>
<a href="#l66.251"></a><span id="l66.251">     delete key_store;</span>
<a href="#l66.252"></a><span id="l66.252"> }</span>
<a href="#l66.253"></a><span id="l66.253"> </span>
<a href="#l66.254"></a><span id="l66.254"> /* This test loads a V3 keyring and confirms that certain</span>
<a href="#l66.255"></a><span id="l66.255">  * bitfields and time fields are set correctly.</span>
<a href="#l66.256"></a><span id="l66.256">  */</span>
<a href="#l66.257"></a><span id="l66.257"> TEST_F(rnp_tests, test_load_check_bitfields_and_times_v3)</span>
<a href="#l66.258"></a><span id="l66.258"> {</span>
<a href="#l66.259"></a><span id="l66.259" class="difflineminus">-    uint8_t                keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.260"></a><span id="l66.260" class="difflineminus">-    uint8_t                signer_id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.261"></a><span id="l66.261" class="difflineplus">+    pgp_key_id_t           keyid = {};</span>
<a href="#l66.262"></a><span id="l66.262" class="difflineplus">+    pgp_key_id_t           signer_id = {};</span>
<a href="#l66.263"></a><span id="l66.263">     const pgp_key_t *      key;</span>
<a href="#l66.264"></a><span id="l66.264">     const pgp_signature_t *sig = NULL;</span>
<a href="#l66.265"></a><span id="l66.265"> </span>
<a href="#l66.266"></a><span id="l66.266">     // load keyring</span>
<a href="#l66.267"></a><span id="l66.267">     rnp_key_store_t *key_store =</span>
<a href="#l66.268"></a><span id="l66.268">       new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/2/pubring.gpg&quot;);</span>
<a href="#l66.269"></a><span id="l66.269">     assert_true(rnp_key_store_load_from_path(key_store, NULL));</span>
<a href="#l66.270"></a><span id="l66.270"> </span>
<a href="#l66.271"></a><span id="l66.271">     // find</span>
<a href="#l66.272"></a><span id="l66.272">     key = NULL;</span>
<a href="#l66.273"></a><span id="l66.273" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;DC70C124A50283F1&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.274"></a><span id="l66.274" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;DC70C124A50283F1&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.275"></a><span id="l66.275">     key = rnp_key_store_get_key_by_id(key_store, keyid, NULL);</span>
<a href="#l66.276"></a><span id="l66.276">     assert_non_null(key);</span>
<a href="#l66.277"></a><span id="l66.277">     // check key version</span>
<a href="#l66.278"></a><span id="l66.278">     assert_int_equal(pgp_key_get_version(key), PGP_V3);</span>
<a href="#l66.279"></a><span id="l66.279">     // check subsig count</span>
<a href="#l66.280"></a><span id="l66.280">     assert_int_equal(pgp_key_get_subsig_count(key), 1);</span>
<a href="#l66.281"></a><span id="l66.281">     sig = &amp;pgp_key_get_subsig(key, 0)-&gt;sig;</span>
<a href="#l66.282"></a><span id="l66.282">     // check signature version</span>
<a href="#l66.283"></a><span id="l66.283">     assert_int_equal(sig-&gt;version, 3);</span>
<a href="#l66.284"></a><span id="l66.284">     // check issuer</span>
<a href="#l66.285"></a><span id="l66.285" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;DC70C124A50283F1&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.286"></a><span id="l66.286" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;DC70C124A50283F1&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.287"></a><span id="l66.287">     assert_true(signature_get_keyid(sig, signer_id));</span>
<a href="#l66.288"></a><span id="l66.288" class="difflineminus">-    assert_int_equal(memcmp(keyid, signer_id, PGP_KEY_ID_SIZE), 0);</span>
<a href="#l66.289"></a><span id="l66.289" class="difflineplus">+    assert_true(keyid == signer_id);</span>
<a href="#l66.290"></a><span id="l66.290">     // check creation time</span>
<a href="#l66.291"></a><span id="l66.291">     assert_int_equal(signature_get_creation(sig), 1005209227);</span>
<a href="#l66.292"></a><span id="l66.292">     assert_int_equal(signature_get_creation(sig), pgp_key_get_creation(key));</span>
<a href="#l66.293"></a><span id="l66.293">     // check signature expiration time (V3 sigs have none)</span>
<a href="#l66.294"></a><span id="l66.294">     assert_int_equal(signature_get_expiration(sig), 0);</span>
<a href="#l66.295"></a><span id="l66.295">     // check key expiration</span>
<a href="#l66.296"></a><span id="l66.296">     assert_int_equal(pgp_key_get_expiration(key), 0); // only for V4 keys</span>
<a href="#l66.297"></a><span id="l66.297">     assert_int_equal(pgp_key_get_pkt(key)-&gt;v3_days, 0);</span>
<a href="#l66.298"></a><span id="l66.298" class="difflineat">@@ -391,47 +392,47 @@ TEST_F(rnp_tests, test_load_check_bitfie</span>
<a href="#l66.299"></a><span id="l66.299">     delete key_store;</span>
<a href="#l66.300"></a><span id="l66.300"> }</span>
<a href="#l66.301"></a><span id="l66.301"> </span>
<a href="#l66.302"></a><span id="l66.302"> #define MERGE_PATH &quot;data/test_stream_key_merge/&quot;</span>
<a href="#l66.303"></a><span id="l66.303"> </span>
<a href="#l66.304"></a><span id="l66.304"> TEST_F(rnp_tests, test_load_armored_pub_sec)</span>
<a href="#l66.305"></a><span id="l66.305"> {</span>
<a href="#l66.306"></a><span id="l66.306">     pgp_key_t *      key;</span>
<a href="#l66.307"></a><span id="l66.307" class="difflineminus">-    uint8_t          keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.308"></a><span id="l66.308" class="difflineplus">+    pgp_key_id_t     keyid = {};</span>
<a href="#l66.309"></a><span id="l66.309">     rnp_key_store_t *key_store;</span>
<a href="#l66.310"></a><span id="l66.310"> </span>
<a href="#l66.311"></a><span id="l66.311">     key_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, MERGE_PATH &quot;key-both.asc&quot;);</span>
<a href="#l66.312"></a><span id="l66.312">     assert_true(rnp_key_store_load_from_path(key_store, NULL));</span>
<a href="#l66.313"></a><span id="l66.313"> </span>
<a href="#l66.314"></a><span id="l66.314">     /* we must have 1 main key and 2 subkeys */</span>
<a href="#l66.315"></a><span id="l66.315">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.316"></a><span id="l66.316"> </span>
<a href="#l66.317"></a><span id="l66.317" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.318"></a><span id="l66.318" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.319"></a><span id="l66.319">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.320"></a><span id="l66.320">     assert_true(key-&gt;valid);</span>
<a href="#l66.321"></a><span id="l66.321">     assert_true(pgp_key_is_primary_key(key));</span>
<a href="#l66.322"></a><span id="l66.322">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l66.323"></a><span id="l66.323">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.324"></a><span id="l66.324">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.325"></a><span id="l66.325">     assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.326"></a><span id="l66.326">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.327"></a><span id="l66.327">     assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.328"></a><span id="l66.328">     assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.329"></a><span id="l66.329"> </span>
<a href="#l66.330"></a><span id="l66.330" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.331"></a><span id="l66.331" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.332"></a><span id="l66.332">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.333"></a><span id="l66.333">     assert_true(key-&gt;valid);</span>
<a href="#l66.334"></a><span id="l66.334">     assert_true(pgp_key_is_subkey(key));</span>
<a href="#l66.335"></a><span id="l66.335">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l66.336"></a><span id="l66.336">     assert_int_equal(pgp_key_get_rawpacket_count(key), 2);</span>
<a href="#l66.337"></a><span id="l66.337">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.338"></a><span id="l66.338">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.339"></a><span id="l66.339"> </span>
<a href="#l66.340"></a><span id="l66.340" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.341"></a><span id="l66.341" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.342"></a><span id="l66.342">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.343"></a><span id="l66.343">     assert_true(key-&gt;valid);</span>
<a href="#l66.344"></a><span id="l66.344">     assert_true(pgp_key_is_subkey(key));</span>
<a href="#l66.345"></a><span id="l66.345">     assert_true(pgp_key_is_secret(key));</span>
<a href="#l66.346"></a><span id="l66.346">     assert_int_equal(pgp_key_get_rawpacket_count(key), 2);</span>
<a href="#l66.347"></a><span id="l66.347">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_SUBKEY);</span>
<a href="#l66.348"></a><span id="l66.348">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.349"></a><span id="l66.349"> </span>
<a href="#l66.350"></a><span id="l66.350" class="difflineat">@@ -465,40 +466,40 @@ load_keystore(rnp_key_store_t *keystore,</span>
<a href="#l66.351"></a><span id="l66.351"> {</span>
<a href="#l66.352"></a><span id="l66.352">     pgp_source_t src = {};</span>
<a href="#l66.353"></a><span id="l66.353">     bool res = !init_file_src(&amp;src, fname) &amp;&amp; !rnp_key_store_pgp_read_from_src(keystore, &amp;src);</span>
<a href="#l66.354"></a><span id="l66.354">     src_close(&amp;src);</span>
<a href="#l66.355"></a><span id="l66.355">     return res;</span>
<a href="#l66.356"></a><span id="l66.356"> }</span>
<a href="#l66.357"></a><span id="l66.357"> </span>
<a href="#l66.358"></a><span id="l66.358"> static bool</span>
<a href="#l66.359"></a><span id="l66.359" class="difflineminus">-check_subkey_grip(pgp_key_t *key, pgp_key_t *subkey, size_t index)</span>
<a href="#l66.360"></a><span id="l66.360" class="difflineplus">+check_subkey_fp(pgp_key_t *key, pgp_key_t *subkey, size_t index)</span>
<a href="#l66.361"></a><span id="l66.361"> {</span>
<a href="#l66.362"></a><span id="l66.362" class="difflineminus">-    if (pgp_key_get_subkey_grip(key, index) != pgp_key_get_grip(subkey)) {</span>
<a href="#l66.363"></a><span id="l66.363" class="difflineplus">+    if (pgp_key_get_subkey_fp(key, index) != pgp_key_get_fp(subkey)) {</span>
<a href="#l66.364"></a><span id="l66.364">         return false;</span>
<a href="#l66.365"></a><span id="l66.365">     }</span>
<a href="#l66.366"></a><span id="l66.366" class="difflineminus">-    return pgp_key_get_grip(key) == pgp_key_get_primary_grip(subkey);</span>
<a href="#l66.367"></a><span id="l66.367" class="difflineplus">+    return pgp_key_get_fp(key) == pgp_key_get_primary_fp(subkey);</span>
<a href="#l66.368"></a><span id="l66.368"> }</span>
<a href="#l66.369"></a><span id="l66.369"> </span>
<a href="#l66.370"></a><span id="l66.370"> TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.371"></a><span id="l66.371"> {</span>
<a href="#l66.372"></a><span id="l66.372">     pgp_key_t *               key, *skey1, *skey2;</span>
<a href="#l66.373"></a><span id="l66.373" class="difflineminus">-    uint8_t                   keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.374"></a><span id="l66.374" class="difflineminus">-    uint8_t                   sub1id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.375"></a><span id="l66.375" class="difflineminus">-    uint8_t                   sub2id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.376"></a><span id="l66.376" class="difflineplus">+    pgp_key_id_t              keyid = {};</span>
<a href="#l66.377"></a><span id="l66.377" class="difflineplus">+    pgp_key_id_t              sub1id = {};</span>
<a href="#l66.378"></a><span id="l66.378" class="difflineplus">+    pgp_key_id_t              sub2id = {};</span>
<a href="#l66.379"></a><span id="l66.379">     rnp_key_store_t *         key_store;</span>
<a href="#l66.380"></a><span id="l66.380">     pgp_transferable_key_t    tkey = {};</span>
<a href="#l66.381"></a><span id="l66.381">     pgp_transferable_subkey_t tskey = {};</span>
<a href="#l66.382"></a><span id="l66.382">     pgp_password_provider_t   provider = (pgp_password_provider_t){</span>
<a href="#l66.383"></a><span id="l66.383">       .callback = string_copy_password_callback, .userdata = (void *) &quot;password&quot;};</span>
<a href="#l66.384"></a><span id="l66.384"> </span>
<a href="#l66.385"></a><span id="l66.385">     key_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l66.386"></a><span id="l66.386" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.387"></a><span id="l66.387" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id, sizeof(sub1id)));</span>
<a href="#l66.388"></a><span id="l66.388" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id, sizeof(sub2id)));</span>
<a href="#l66.389"></a><span id="l66.389" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.390"></a><span id="l66.390" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id.data(), sub1id.size()));</span>
<a href="#l66.391"></a><span id="l66.391" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id.data(), sub2id.size()));</span>
<a href="#l66.392"></a><span id="l66.392"> </span>
<a href="#l66.393"></a><span id="l66.393">     /* load just key packet */</span>
<a href="#l66.394"></a><span id="l66.394">     assert_true(load_transferable_key(&amp;tkey, MERGE_PATH &quot;key-pub-just-key.pgp&quot;));</span>
<a href="#l66.395"></a><span id="l66.395">     assert_true(rnp_key_store_add_transferable_key(key_store, &amp;tkey));</span>
<a href="#l66.396"></a><span id="l66.396">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.397"></a><span id="l66.397">     assert_int_equal(rnp_key_store_get_key_count(key_store), 1);</span>
<a href="#l66.398"></a><span id="l66.398">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.399"></a><span id="l66.399">     assert_false(key-&gt;valid);</span>
<a href="#l66.400"></a><span id="l66.400" class="difflineat">@@ -557,17 +558,17 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.401"></a><span id="l66.401">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.402"></a><span id="l66.402">     assert_int_equal(rnp_key_store_get_key_count(key_store), 2);</span>
<a href="#l66.403"></a><span id="l66.403">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.404"></a><span id="l66.404">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.405"></a><span id="l66.405">     assert_true(key-&gt;valid);</span>
<a href="#l66.406"></a><span id="l66.406">     assert_false(skey1-&gt;valid);</span>
<a href="#l66.407"></a><span id="l66.407">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.408"></a><span id="l66.408">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l66.409"></a><span id="l66.409" class="difflineminus">-    assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.410"></a><span id="l66.410" class="difflineplus">+    assert_true(check_subkey_fp(key, skey1, 0));</span>
<a href="#l66.411"></a><span id="l66.411">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.412"></a><span id="l66.412">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.413"></a><span id="l66.413">     assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.414"></a><span id="l66.414">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.415"></a><span id="l66.415">     assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.416"></a><span id="l66.416">     assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.417"></a><span id="l66.417">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.418"></a><span id="l66.418">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 1);</span>
<a href="#l66.419"></a><span id="l66.419" class="difflineat">@@ -581,17 +582,17 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.420"></a><span id="l66.420">     transferable_subkey_destroy(&amp;tskey);</span>
<a href="#l66.421"></a><span id="l66.421">     assert_int_equal(rnp_key_store_get_key_count(key_store), 2);</span>
<a href="#l66.422"></a><span id="l66.422">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.423"></a><span id="l66.423">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.424"></a><span id="l66.424">     assert_true(key-&gt;valid);</span>
<a href="#l66.425"></a><span id="l66.425">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.426"></a><span id="l66.426">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.427"></a><span id="l66.427">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l66.428"></a><span id="l66.428" class="difflineminus">-    assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.429"></a><span id="l66.429" class="difflineplus">+    assert_true(check_subkey_fp(key, skey1, 0));</span>
<a href="#l66.430"></a><span id="l66.430">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.431"></a><span id="l66.431">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.432"></a><span id="l66.432">     assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.433"></a><span id="l66.433">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.434"></a><span id="l66.434">     assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.435"></a><span id="l66.435">     assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.436"></a><span id="l66.436">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.437"></a><span id="l66.437">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.438"></a><span id="l66.438" class="difflineat">@@ -608,18 +609,18 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.439"></a><span id="l66.439">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.440"></a><span id="l66.440">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.441"></a><span id="l66.441">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.442"></a><span id="l66.442">     assert_true(key-&gt;valid);</span>
<a href="#l66.443"></a><span id="l66.443">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.444"></a><span id="l66.444">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.445"></a><span id="l66.445">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.446"></a><span id="l66.446">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.447"></a><span id="l66.447" class="difflineminus">-    assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.448"></a><span id="l66.448" class="difflineminus">-    assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.449"></a><span id="l66.449" class="difflineplus">+    assert_true(check_subkey_fp(key, skey1, 0));</span>
<a href="#l66.450"></a><span id="l66.450" class="difflineplus">+    assert_true(check_subkey_fp(key, skey2, 1));</span>
<a href="#l66.451"></a><span id="l66.451">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.452"></a><span id="l66.452">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.453"></a><span id="l66.453">     assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.454"></a><span id="l66.454">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.455"></a><span id="l66.455">     assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.456"></a><span id="l66.456">     assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.457"></a><span id="l66.457">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.458"></a><span id="l66.458">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.459"></a><span id="l66.459" class="difflineat">@@ -640,18 +641,18 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.460"></a><span id="l66.460">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.461"></a><span id="l66.461">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.462"></a><span id="l66.462">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.463"></a><span id="l66.463">     assert_true(key-&gt;valid);</span>
<a href="#l66.464"></a><span id="l66.464">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.465"></a><span id="l66.465">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.466"></a><span id="l66.466">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.467"></a><span id="l66.467">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.468"></a><span id="l66.468" class="difflineminus">-    assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.469"></a><span id="l66.469" class="difflineminus">-    assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.470"></a><span id="l66.470" class="difflineplus">+    assert_true(check_subkey_fp(key, skey1, 0));</span>
<a href="#l66.471"></a><span id="l66.471" class="difflineplus">+    assert_true(check_subkey_fp(key, skey2, 1));</span>
<a href="#l66.472"></a><span id="l66.472">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.473"></a><span id="l66.473">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.474"></a><span id="l66.474">     assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.475"></a><span id="l66.475">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.476"></a><span id="l66.476">     assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.477"></a><span id="l66.477">     assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.478"></a><span id="l66.478">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.479"></a><span id="l66.479">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.480"></a><span id="l66.480" class="difflineat">@@ -677,18 +678,18 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.481"></a><span id="l66.481">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.482"></a><span id="l66.482">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.483"></a><span id="l66.483">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.484"></a><span id="l66.484">     assert_true(key-&gt;valid);</span>
<a href="#l66.485"></a><span id="l66.485">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.486"></a><span id="l66.486">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.487"></a><span id="l66.487">     assert_int_equal(pgp_key_get_userid_count(key), 2);</span>
<a href="#l66.488"></a><span id="l66.488">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.489"></a><span id="l66.489" class="difflineminus">-    assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.490"></a><span id="l66.490" class="difflineminus">-    assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.491"></a><span id="l66.491" class="difflineplus">+    assert_true(check_subkey_fp(key, skey1, 0));</span>
<a href="#l66.492"></a><span id="l66.492" class="difflineplus">+    assert_true(check_subkey_fp(key, skey2, 1));</span>
<a href="#l66.493"></a><span id="l66.493">     assert_int_equal(pgp_key_get_rawpacket_count(key), 5);</span>
<a href="#l66.494"></a><span id="l66.494">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.495"></a><span id="l66.495">     assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.496"></a><span id="l66.496">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.497"></a><span id="l66.497">     assert_int_equal(pgp_key_get_userid(key, 1)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.498"></a><span id="l66.498">     assert_int_equal(pgp_key_get_subsig(key, 1)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.499"></a><span id="l66.499">     assert_int_equal(pgp_key_get_userid_count(skey1), 0);</span>
<a href="#l66.500"></a><span id="l66.500">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.501"></a><span id="l66.501" class="difflineat">@@ -702,73 +703,73 @@ TEST_F(rnp_tests, test_load_merge)</span>
<a href="#l66.502"></a><span id="l66.502">     assert_true(key == rnp_tests_key_search(key_store, &quot;key-merge-uid-2&quot;));</span>
<a href="#l66.503"></a><span id="l66.503"> </span>
<a href="#l66.504"></a><span id="l66.504">     delete key_store;</span>
<a href="#l66.505"></a><span id="l66.505"> }</span>
<a href="#l66.506"></a><span id="l66.506"> </span>
<a href="#l66.507"></a><span id="l66.507"> TEST_F(rnp_tests, test_load_public_from_secret)</span>
<a href="#l66.508"></a><span id="l66.508"> {</span>
<a href="#l66.509"></a><span id="l66.509">     pgp_key_t *      key, *skey1, *skey2, keycp = {};</span>
<a href="#l66.510"></a><span id="l66.510" class="difflineminus">-    uint8_t          keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.511"></a><span id="l66.511" class="difflineminus">-    uint8_t          sub1id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.512"></a><span id="l66.512" class="difflineminus">-    uint8_t          sub2id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.513"></a><span id="l66.513" class="difflineplus">+    pgp_key_id_t     keyid = {};</span>
<a href="#l66.514"></a><span id="l66.514" class="difflineplus">+    pgp_key_id_t     sub1id = {};</span>
<a href="#l66.515"></a><span id="l66.515" class="difflineplus">+    pgp_key_id_t     sub2id = {};</span>
<a href="#l66.516"></a><span id="l66.516">     rnp_key_store_t *secstore, *pubstore;</span>
<a href="#l66.517"></a><span id="l66.517"> </span>
<a href="#l66.518"></a><span id="l66.518">     secstore = new rnp_key_store_t(PGP_KEY_STORE_GPG, MERGE_PATH &quot;key-sec.asc&quot;);</span>
<a href="#l66.519"></a><span id="l66.519">     assert_true(rnp_key_store_load_from_path(secstore, NULL));</span>
<a href="#l66.520"></a><span id="l66.520">     pubstore = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;pubring.gpg&quot;);</span>
<a href="#l66.521"></a><span id="l66.521"> </span>
<a href="#l66.522"></a><span id="l66.522" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.523"></a><span id="l66.523" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id, sizeof(sub1id)));</span>
<a href="#l66.524"></a><span id="l66.524" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id, sizeof(sub2id)));</span>
<a href="#l66.525"></a><span id="l66.525" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.526"></a><span id="l66.526" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id.data(), sub1id.size()));</span>
<a href="#l66.527"></a><span id="l66.527" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id.data(), sub2id.size()));</span>
<a href="#l66.528"></a><span id="l66.528"> </span>
<a href="#l66.529"></a><span id="l66.529">     assert_non_null(key = rnp_key_store_get_key_by_id(secstore, keyid, NULL));</span>
<a href="#l66.530"></a><span id="l66.530">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(secstore, sub1id, NULL));</span>
<a href="#l66.531"></a><span id="l66.531">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(secstore, sub2id, NULL));</span>
<a href="#l66.532"></a><span id="l66.532"> </span>
<a href="#l66.533"></a><span id="l66.533">     /* copy the secret key */</span>
<a href="#l66.534"></a><span id="l66.534">     assert_rnp_success(pgp_key_copy(&amp;keycp, key, false));</span>
<a href="#l66.535"></a><span id="l66.535">     assert_true(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.536"></a><span id="l66.536">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 2);</span>
<a href="#l66.537"></a><span id="l66.537" class="difflineminus">-    assert_true(pgp_key_get_subkey_grip(&amp;keycp, 0) == pgp_key_get_grip(skey1));</span>
<a href="#l66.538"></a><span id="l66.538" class="difflineminus">-    assert_true(pgp_key_get_subkey_grip(&amp;keycp, 1) == pgp_key_get_grip(skey2));</span>
<a href="#l66.539"></a><span id="l66.539" class="difflineplus">+    assert_true(pgp_key_get_subkey_fp(&amp;keycp, 0) == pgp_key_get_fp(skey1));</span>
<a href="#l66.540"></a><span id="l66.540" class="difflineplus">+    assert_true(pgp_key_get_subkey_fp(&amp;keycp, 1) == pgp_key_get_fp(skey2));</span>
<a href="#l66.541"></a><span id="l66.541">     assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(key));</span>
<a href="#l66.542"></a><span id="l66.542">     assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_SECRET_KEY);</span>
<a href="#l66.543"></a><span id="l66.543"> </span>
<a href="#l66.544"></a><span id="l66.544">     /* copy the public part */</span>
<a href="#l66.545"></a><span id="l66.545">     assert_rnp_success(pgp_key_copy(&amp;keycp, key, true));</span>
<a href="#l66.546"></a><span id="l66.546">     assert_false(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.547"></a><span id="l66.547">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 2);</span>
<a href="#l66.548"></a><span id="l66.548" class="difflineminus">-    assert_true(check_subkey_grip(&amp;keycp, skey1, 0));</span>
<a href="#l66.549"></a><span id="l66.549" class="difflineminus">-    assert_true(check_subkey_grip(&amp;keycp, skey2, 1));</span>
<a href="#l66.550"></a><span id="l66.550" class="difflineplus">+    assert_true(check_subkey_fp(&amp;keycp, skey1, 0));</span>
<a href="#l66.551"></a><span id="l66.551" class="difflineplus">+    assert_true(check_subkey_fp(&amp;keycp, skey2, 1));</span>
<a href="#l66.552"></a><span id="l66.552">     assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(key));</span>
<a href="#l66.553"></a><span id="l66.553">     assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.554"></a><span id="l66.554">     assert_null(pgp_key_get_pkt(&amp;keycp)-&gt;sec_data);</span>
<a href="#l66.555"></a><span id="l66.555">     assert_int_equal(pgp_key_get_pkt(&amp;keycp)-&gt;sec_len, 0);</span>
<a href="#l66.556"></a><span id="l66.556">     assert_false(pgp_key_get_pkt(&amp;keycp)-&gt;material.secret);</span>
<a href="#l66.557"></a><span id="l66.557">     rnp_key_store_add_key(pubstore, &amp;keycp);</span>
<a href="#l66.558"></a><span id="l66.558">     /* subkey 1 */</span>
<a href="#l66.559"></a><span id="l66.559">     assert_rnp_success(pgp_key_copy(&amp;keycp, skey1, true));</span>
<a href="#l66.560"></a><span id="l66.560">     assert_false(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.561"></a><span id="l66.561">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 0);</span>
<a href="#l66.562"></a><span id="l66.562" class="difflineminus">-    assert_true(check_subkey_grip(key, &amp;keycp, 0));</span>
<a href="#l66.563"></a><span id="l66.563" class="difflineplus">+    assert_true(check_subkey_fp(key, &amp;keycp, 0));</span>
<a href="#l66.564"></a><span id="l66.564">     assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(skey1));</span>
<a href="#l66.565"></a><span id="l66.565" class="difflineminus">-    assert_false(memcmp(pgp_key_get_keyid(&amp;keycp), sub1id, PGP_KEY_ID_SIZE));</span>
<a href="#l66.566"></a><span id="l66.566" class="difflineplus">+    assert_true(pgp_key_get_keyid(&amp;keycp) == sub1id);</span>
<a href="#l66.567"></a><span id="l66.567">     assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.568"></a><span id="l66.568">     assert_null(pgp_key_get_pkt(&amp;keycp)-&gt;sec_data);</span>
<a href="#l66.569"></a><span id="l66.569">     assert_int_equal(pgp_key_get_pkt(&amp;keycp)-&gt;sec_len, 0);</span>
<a href="#l66.570"></a><span id="l66.570">     assert_false(pgp_key_get_pkt(&amp;keycp)-&gt;material.secret);</span>
<a href="#l66.571"></a><span id="l66.571">     rnp_key_store_add_key(pubstore, &amp;keycp);</span>
<a href="#l66.572"></a><span id="l66.572">     /* subkey 2 */</span>
<a href="#l66.573"></a><span id="l66.573">     assert_rnp_success(pgp_key_copy(&amp;keycp, skey2, true));</span>
<a href="#l66.574"></a><span id="l66.574">     assert_false(pgp_key_is_secret(&amp;keycp));</span>
<a href="#l66.575"></a><span id="l66.575">     assert_int_equal(pgp_key_get_subkey_count(&amp;keycp), 0);</span>
<a href="#l66.576"></a><span id="l66.576" class="difflineminus">-    assert_true(check_subkey_grip(key, &amp;keycp, 1));</span>
<a href="#l66.577"></a><span id="l66.577" class="difflineplus">+    assert_true(check_subkey_fp(key, &amp;keycp, 1));</span>
<a href="#l66.578"></a><span id="l66.578">     assert_true(pgp_key_get_grip(&amp;keycp) == pgp_key_get_grip(skey2));</span>
<a href="#l66.579"></a><span id="l66.579" class="difflineminus">-    assert_false(memcmp(pgp_key_get_keyid(&amp;keycp), sub2id, PGP_KEY_ID_SIZE));</span>
<a href="#l66.580"></a><span id="l66.580" class="difflineplus">+    assert_true(pgp_key_get_keyid(&amp;keycp) == sub2id);</span>
<a href="#l66.581"></a><span id="l66.581">     assert_int_equal(pgp_key_get_rawpacket(&amp;keycp).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.582"></a><span id="l66.582">     assert_null(pgp_key_get_pkt(&amp;keycp)-&gt;sec_data);</span>
<a href="#l66.583"></a><span id="l66.583">     assert_int_equal(pgp_key_get_pkt(&amp;keycp)-&gt;sec_len, 0);</span>
<a href="#l66.584"></a><span id="l66.584">     assert_false(pgp_key_get_pkt(&amp;keycp)-&gt;material.secret);</span>
<a href="#l66.585"></a><span id="l66.585">     rnp_key_store_add_key(pubstore, &amp;keycp);</span>
<a href="#l66.586"></a><span id="l66.586">     /* save pubring */</span>
<a href="#l66.587"></a><span id="l66.587">     assert_true(rnp_key_store_write_to_path(pubstore));</span>
<a href="#l66.588"></a><span id="l66.588">     delete pubstore;</span>
<a href="#l66.589"></a><span id="l66.589" class="difflineat">@@ -968,68 +969,68 @@ TEST_F(rnp_tests, test_key_import)</span>
<a href="#l66.590"></a><span id="l66.590">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l66.591"></a><span id="l66.591"> </span>
<a href="#l66.592"></a><span id="l66.592">     cli_rnp_end(&amp;rnp);</span>
<a href="#l66.593"></a><span id="l66.593"> }</span>
<a href="#l66.594"></a><span id="l66.594"> </span>
<a href="#l66.595"></a><span id="l66.595"> TEST_F(rnp_tests, test_load_subkey)</span>
<a href="#l66.596"></a><span id="l66.596"> {</span>
<a href="#l66.597"></a><span id="l66.597">     pgp_key_t *      key, *skey1, *skey2;</span>
<a href="#l66.598"></a><span id="l66.598" class="difflineminus">-    uint8_t          keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l66.599"></a><span id="l66.599" class="difflineminus">-    uint8_t          sub1id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.600"></a><span id="l66.600" class="difflineminus">-    uint8_t          sub2id[PGP_KEY_ID_SIZE];</span>
<a href="#l66.601"></a><span id="l66.601" class="difflineplus">+    pgp_key_id_t     keyid = {};</span>
<a href="#l66.602"></a><span id="l66.602" class="difflineplus">+    pgp_key_id_t     sub1id = {};</span>
<a href="#l66.603"></a><span id="l66.603" class="difflineplus">+    pgp_key_id_t     sub2id = {};</span>
<a href="#l66.604"></a><span id="l66.604">     rnp_key_store_t *key_store;</span>
<a href="#l66.605"></a><span id="l66.605"> </span>
<a href="#l66.606"></a><span id="l66.606">     key_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l66.607"></a><span id="l66.607" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid, sizeof(keyid)));</span>
<a href="#l66.608"></a><span id="l66.608" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id, sizeof(sub1id)));</span>
<a href="#l66.609"></a><span id="l66.609" class="difflineminus">-    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id, sizeof(sub2id)));</span>
<a href="#l66.610"></a><span id="l66.610" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;9747D2A6B3A63124&quot;, keyid.data(), keyid.size()));</span>
<a href="#l66.611"></a><span id="l66.611" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;AF1114A47F5F5B28&quot;, sub1id.data(), sub1id.size()));</span>
<a href="#l66.612"></a><span id="l66.612" class="difflineplus">+    assert_true(rnp_hex_decode(&quot;16CD16F267CCDD4F&quot;, sub2id.data(), sub2id.size()));</span>
<a href="#l66.613"></a><span id="l66.613"> </span>
<a href="#l66.614"></a><span id="l66.614">     /* load first subkey with signature */</span>
<a href="#l66.615"></a><span id="l66.615">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-just-subkey-1.pgp&quot;));</span>
<a href="#l66.616"></a><span id="l66.616">     assert_int_equal(rnp_key_store_get_key_count(key_store), 1);</span>
<a href="#l66.617"></a><span id="l66.617">     assert_non_null(skey1 = rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.618"></a><span id="l66.618">     assert_false(skey1-&gt;valid);</span>
<a href="#l66.619"></a><span id="l66.619">     assert_int_equal(pgp_key_get_rawpacket_count(skey1), 2);</span>
<a href="#l66.620"></a><span id="l66.620">     assert_int_equal(pgp_key_get_rawpacket(skey1).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.621"></a><span id="l66.621">     assert_int_equal(pgp_key_get_subsig(skey1, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.622"></a><span id="l66.622" class="difflineminus">-    assert_false(pgp_key_has_primary_grip(skey1));</span>
<a href="#l66.623"></a><span id="l66.623" class="difflineplus">+    assert_false(pgp_key_has_primary_fp(skey1));</span>
<a href="#l66.624"></a><span id="l66.624"> </span>
<a href="#l66.625"></a><span id="l66.625">     /* load second subkey, without signature */</span>
<a href="#l66.626"></a><span id="l66.626">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-just-subkey-2-no-sigs.pgp&quot;));</span>
<a href="#l66.627"></a><span id="l66.627">     assert_int_equal(rnp_key_store_get_key_count(key_store), 2);</span>
<a href="#l66.628"></a><span id="l66.628">     assert_non_null(skey2 = rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.629"></a><span id="l66.629">     assert_false(skey2-&gt;valid);</span>
<a href="#l66.630"></a><span id="l66.630">     assert_int_equal(pgp_key_get_rawpacket_count(skey2), 1);</span>
<a href="#l66.631"></a><span id="l66.631">     assert_int_equal(pgp_key_get_rawpacket(skey2).tag, PGP_PKT_PUBLIC_SUBKEY);</span>
<a href="#l66.632"></a><span id="l66.632" class="difflineminus">-    assert_false(pgp_key_has_primary_grip(skey2));</span>
<a href="#l66.633"></a><span id="l66.633" class="difflineplus">+    assert_false(pgp_key_has_primary_fp(skey2));</span>
<a href="#l66.634"></a><span id="l66.634">     assert_false(skey1 == skey2);</span>
<a href="#l66.635"></a><span id="l66.635"> </span>
<a href="#l66.636"></a><span id="l66.636">     /* load primary key without subkey signatures */</span>
<a href="#l66.637"></a><span id="l66.637">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-uid-1.pgp&quot;));</span>
<a href="#l66.638"></a><span id="l66.638">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.639"></a><span id="l66.639">     assert_non_null(key = rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.640"></a><span id="l66.640">     assert_true(key-&gt;valid);</span>
<a href="#l66.641"></a><span id="l66.641">     assert_int_equal(pgp_key_get_rawpacket_count(key), 3);</span>
<a href="#l66.642"></a><span id="l66.642">     assert_int_equal(pgp_key_get_rawpacket(key).tag, PGP_PKT_PUBLIC_KEY);</span>
<a href="#l66.643"></a><span id="l66.643">     assert_int_equal(pgp_key_get_userid(key, 0)-&gt;rawpkt.tag, PGP_PKT_USER_ID);</span>
<a href="#l66.644"></a><span id="l66.644">     assert_int_equal(pgp_key_get_subsig(key, 0)-&gt;rawpkt.tag, PGP_PKT_SIGNATURE);</span>
<a href="#l66.645"></a><span id="l66.645">     assert_true(skey1 == rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.646"></a><span id="l66.646">     assert_true(skey2 == rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.647"></a><span id="l66.647" class="difflineminus">-    assert_true(pgp_key_has_primary_grip(skey1));</span>
<a href="#l66.648"></a><span id="l66.648" class="difflineminus">-    assert_true(check_subkey_grip(key, skey1, 0));</span>
<a href="#l66.649"></a><span id="l66.649" class="difflineplus">+    assert_true(pgp_key_has_primary_fp(skey1));</span>
<a href="#l66.650"></a><span id="l66.650" class="difflineplus">+    assert_true(check_subkey_fp(key, skey1, 0));</span>
<a href="#l66.651"></a><span id="l66.651">     assert_int_equal(pgp_key_get_subkey_count(key), 1);</span>
<a href="#l66.652"></a><span id="l66.652">     assert_true(skey1-&gt;valid);</span>
<a href="#l66.653"></a><span id="l66.653">     assert_false(skey2-&gt;valid);</span>
<a href="#l66.654"></a><span id="l66.654"> </span>
<a href="#l66.655"></a><span id="l66.655">     /* load second subkey with signature */</span>
<a href="#l66.656"></a><span id="l66.656">     assert_true(load_keystore(key_store, MERGE_PATH &quot;key-pub-just-subkey-2.pgp&quot;));</span>
<a href="#l66.657"></a><span id="l66.657">     assert_int_equal(rnp_key_store_get_key_count(key_store), 3);</span>
<a href="#l66.658"></a><span id="l66.658">     assert_true(key == rnp_key_store_get_key_by_id(key_store, keyid, NULL));</span>
<a href="#l66.659"></a><span id="l66.659">     assert_true(skey1 == rnp_key_store_get_key_by_id(key_store, sub1id, NULL));</span>
<a href="#l66.660"></a><span id="l66.660">     assert_true(skey2 == rnp_key_store_get_key_by_id(key_store, sub2id, NULL));</span>
<a href="#l66.661"></a><span id="l66.661" class="difflineminus">-    assert_true(pgp_key_has_primary_grip(skey2));</span>
<a href="#l66.662"></a><span id="l66.662" class="difflineminus">-    assert_true(check_subkey_grip(key, skey2, 1));</span>
<a href="#l66.663"></a><span id="l66.663" class="difflineplus">+    assert_true(pgp_key_has_primary_fp(skey2));</span>
<a href="#l66.664"></a><span id="l66.664" class="difflineplus">+    assert_true(check_subkey_fp(key, skey2, 1));</span>
<a href="#l66.665"></a><span id="l66.665">     assert_int_equal(pgp_key_get_subkey_count(key), 2);</span>
<a href="#l66.666"></a><span id="l66.666">     assert_true(skey2-&gt;valid);</span>
<a href="#l66.667"></a><span id="l66.667"> </span>
<a href="#l66.668"></a><span id="l66.668">     delete key_store;</span>
<a href="#l66.669"></a><span id="l66.669"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l67.1"></a><span id="l67.1">new file mode 100644</span>
<a href="#l67.2"></a><span id="l67.2" class="difflineminus">--- /dev/null</span>
<a href="#l67.3"></a><span id="l67.3" class="difflineplus">+++ b/third_party/rnp/src/tests/pipe.cpp</span>
<a href="#l67.4"></a><span id="l67.4" class="difflineat">@@ -0,0 +1,105 @@</span>
<a href="#l67.5"></a><span id="l67.5" class="difflineplus">+/*</span>
<a href="#l67.6"></a><span id="l67.6" class="difflineplus">+ * Copyright (c) 2017-2020 [Ribose Inc](https://www.ribose.com).</span>
<a href="#l67.7"></a><span id="l67.7" class="difflineplus">+ * All rights reserved.</span>
<a href="#l67.8"></a><span id="l67.8" class="difflineplus">+ *</span>
<a href="#l67.9"></a><span id="l67.9" class="difflineplus">+ * Redistribution and use in source and binary forms, with or without modification,</span>
<a href="#l67.10"></a><span id="l67.10" class="difflineplus">+ * are permitted provided that the following conditions are met:</span>
<a href="#l67.11"></a><span id="l67.11" class="difflineplus">+ *</span>
<a href="#l67.12"></a><span id="l67.12" class="difflineplus">+ * 1.  Redistributions of source code must retain the above copyright notice,</span>
<a href="#l67.13"></a><span id="l67.13" class="difflineplus">+ *     this list of conditions and the following disclaimer.</span>
<a href="#l67.14"></a><span id="l67.14" class="difflineplus">+ *</span>
<a href="#l67.15"></a><span id="l67.15" class="difflineplus">+ * 2.  Redistributions in binary form must reproduce the above copyright notice,</span>
<a href="#l67.16"></a><span id="l67.16" class="difflineplus">+ *     this list of conditions and the following disclaimer in the documentation</span>
<a href="#l67.17"></a><span id="l67.17" class="difflineplus">+ *     and/or other materials provided with the distribution.</span>
<a href="#l67.18"></a><span id="l67.18" class="difflineplus">+ *</span>
<a href="#l67.19"></a><span id="l67.19" class="difflineplus">+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a href="#l67.20"></a><span id="l67.20" class="difflineplus">+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a href="#l67.21"></a><span id="l67.21" class="difflineplus">+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a href="#l67.22"></a><span id="l67.22" class="difflineplus">+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<a href="#l67.23"></a><span id="l67.23" class="difflineplus">+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a href="#l67.24"></a><span id="l67.24" class="difflineplus">+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a href="#l67.25"></a><span id="l67.25" class="difflineplus">+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a href="#l67.26"></a><span id="l67.26" class="difflineplus">+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a href="#l67.27"></a><span id="l67.27" class="difflineplus">+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a href="#l67.28"></a><span id="l67.28" class="difflineplus">+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l67.29"></a><span id="l67.29" class="difflineplus">+ */</span>
<a href="#l67.30"></a><span id="l67.30" class="difflineplus">+</span>
<a href="#l67.31"></a><span id="l67.31" class="difflineplus">+#include &lt;fstream&gt;</span>
<a href="#l67.32"></a><span id="l67.32" class="difflineplus">+#include &lt;vector&gt;</span>
<a href="#l67.33"></a><span id="l67.33" class="difflineplus">+#include &lt;string&gt;</span>
<a href="#l67.34"></a><span id="l67.34" class="difflineplus">+</span>
<a href="#l67.35"></a><span id="l67.35" class="difflineplus">+#include &lt;rnp/rnp.h&gt;</span>
<a href="#l67.36"></a><span id="l67.36" class="difflineplus">+#include &quot;rnp_tests.h&quot;</span>
<a href="#l67.37"></a><span id="l67.37" class="difflineplus">+#include &quot;support.h&quot;</span>
<a href="#l67.38"></a><span id="l67.38" class="difflineplus">+#include &quot;utils.h&quot;</span>
<a href="#l67.39"></a><span id="l67.39" class="difflineplus">+#include &lt;json.h&gt;</span>
<a href="#l67.40"></a><span id="l67.40" class="difflineplus">+#include &lt;vector&gt;</span>
<a href="#l67.41"></a><span id="l67.41" class="difflineplus">+#include &lt;string&gt;</span>
<a href="#l67.42"></a><span id="l67.42" class="difflineplus">+</span>
<a href="#l67.43"></a><span id="l67.43" class="difflineplus">+// this reader produces errors</span>
<a href="#l67.44"></a><span id="l67.44" class="difflineplus">+static bool</span>
<a href="#l67.45"></a><span id="l67.45" class="difflineplus">+error_reader(void *app_ctx, void *buf, size_t len, size_t *read)</span>
<a href="#l67.46"></a><span id="l67.46" class="difflineplus">+{</span>
<a href="#l67.47"></a><span id="l67.47" class="difflineplus">+    return false;</span>
<a href="#l67.48"></a><span id="l67.48" class="difflineplus">+}</span>
<a href="#l67.49"></a><span id="l67.49" class="difflineplus">+</span>
<a href="#l67.50"></a><span id="l67.50" class="difflineplus">+// this writer produces errors</span>
<a href="#l67.51"></a><span id="l67.51" class="difflineplus">+static bool</span>
<a href="#l67.52"></a><span id="l67.52" class="difflineplus">+error_writer(void *app_ctx, const void *buf, size_t len)</span>
<a href="#l67.53"></a><span id="l67.53" class="difflineplus">+{</span>
<a href="#l67.54"></a><span id="l67.54" class="difflineplus">+    return false;</span>
<a href="#l67.55"></a><span id="l67.55" class="difflineplus">+}</span>
<a href="#l67.56"></a><span id="l67.56" class="difflineplus">+</span>
<a href="#l67.57"></a><span id="l67.57" class="difflineplus">+TEST_F(rnp_tests, test_pipe)</span>
<a href="#l67.58"></a><span id="l67.58" class="difflineplus">+{</span>
<a href="#l67.59"></a><span id="l67.59" class="difflineplus">+    uint8_t *         buf = NULL;</span>
<a href="#l67.60"></a><span id="l67.60" class="difflineplus">+    size_t            buf_size = 0;</span>
<a href="#l67.61"></a><span id="l67.61" class="difflineplus">+    rnp_input_t       input = NULL;</span>
<a href="#l67.62"></a><span id="l67.62" class="difflineplus">+    rnp_output_t      output = NULL;</span>
<a href="#l67.63"></a><span id="l67.63" class="difflineplus">+    const std::string msg(&quot;this is a test&quot;);</span>
<a href="#l67.64"></a><span id="l67.64" class="difflineplus">+</span>
<a href="#l67.65"></a><span id="l67.65" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l67.66"></a><span id="l67.66" class="difflineplus">+      rnp_input_from_memory(&amp;input, (const uint8_t *) msg.data(), msg.size(), true));</span>
<a href="#l67.67"></a><span id="l67.67" class="difflineplus">+    assert_rnp_success(rnp_output_to_memory(&amp;output, 0));</span>
<a href="#l67.68"></a><span id="l67.68" class="difflineplus">+</span>
<a href="#l67.69"></a><span id="l67.69" class="difflineplus">+    assert_rnp_failure(rnp_output_pipe(input, NULL));</span>
<a href="#l67.70"></a><span id="l67.70" class="difflineplus">+    assert_rnp_failure(rnp_output_pipe(NULL, output));</span>
<a href="#l67.71"></a><span id="l67.71" class="difflineplus">+    assert_rnp_success(rnp_output_pipe(input, output));</span>
<a href="#l67.72"></a><span id="l67.72" class="difflineplus">+    assert_rnp_success(rnp_output_finish(output));</span>
<a href="#l67.73"></a><span id="l67.73" class="difflineplus">+    assert_rnp_success(rnp_output_memory_get_buf(output, &amp;buf, &amp;buf_size, false));</span>
<a href="#l67.74"></a><span id="l67.74" class="difflineplus">+    std::string data = std::string(buf, buf + buf_size);</span>
<a href="#l67.75"></a><span id="l67.75" class="difflineplus">+    assert_string_equal(data.c_str(), msg.c_str());</span>
<a href="#l67.76"></a><span id="l67.76" class="difflineplus">+</span>
<a href="#l67.77"></a><span id="l67.77" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l67.78"></a><span id="l67.78" class="difflineplus">+    assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l67.79"></a><span id="l67.79" class="difflineplus">+}</span>
<a href="#l67.80"></a><span id="l67.80" class="difflineplus">+</span>
<a href="#l67.81"></a><span id="l67.81" class="difflineplus">+TEST_F(rnp_tests, test_pipe_source_error)</span>
<a href="#l67.82"></a><span id="l67.82" class="difflineplus">+{</span>
<a href="#l67.83"></a><span id="l67.83" class="difflineplus">+    rnp_input_t  input = NULL;</span>
<a href="#l67.84"></a><span id="l67.84" class="difflineplus">+    rnp_output_t output = NULL;</span>
<a href="#l67.85"></a><span id="l67.85" class="difflineplus">+</span>
<a href="#l67.86"></a><span id="l67.86" class="difflineplus">+    assert_rnp_success(rnp_input_from_callback(&amp;input, error_reader, NULL, NULL));</span>
<a href="#l67.87"></a><span id="l67.87" class="difflineplus">+    assert_rnp_success(rnp_output_to_null(&amp;output));</span>
<a href="#l67.88"></a><span id="l67.88" class="difflineplus">+</span>
<a href="#l67.89"></a><span id="l67.89" class="difflineplus">+    assert_rnp_failure(rnp_output_pipe(input, output));</span>
<a href="#l67.90"></a><span id="l67.90" class="difflineplus">+</span>
<a href="#l67.91"></a><span id="l67.91" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l67.92"></a><span id="l67.92" class="difflineplus">+    assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l67.93"></a><span id="l67.93" class="difflineplus">+}</span>
<a href="#l67.94"></a><span id="l67.94" class="difflineplus">+</span>
<a href="#l67.95"></a><span id="l67.95" class="difflineplus">+TEST_F(rnp_tests, test_pipe_dest_error)</span>
<a href="#l67.96"></a><span id="l67.96" class="difflineplus">+{</span>
<a href="#l67.97"></a><span id="l67.97" class="difflineplus">+    rnp_input_t       input = NULL;</span>
<a href="#l67.98"></a><span id="l67.98" class="difflineplus">+    rnp_output_t      output = NULL;</span>
<a href="#l67.99"></a><span id="l67.99" class="difflineplus">+    const std::string msg(&quot;this is a test&quot;);</span>
<a href="#l67.100"></a><span id="l67.100" class="difflineplus">+</span>
<a href="#l67.101"></a><span id="l67.101" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l67.102"></a><span id="l67.102" class="difflineplus">+      rnp_input_from_memory(&amp;input, (const uint8_t *) msg.data(), msg.size(), true));</span>
<a href="#l67.103"></a><span id="l67.103" class="difflineplus">+    assert_rnp_success(rnp_output_to_callback(&amp;output, error_writer, NULL, NULL));</span>
<a href="#l67.104"></a><span id="l67.104" class="difflineplus">+</span>
<a href="#l67.105"></a><span id="l67.105" class="difflineplus">+    assert_rnp_failure(rnp_output_pipe(input, output));</span>
<a href="#l67.106"></a><span id="l67.106" class="difflineplus">+</span>
<a href="#l67.107"></a><span id="l67.107" class="difflineplus">+    assert_rnp_success(rnp_input_destroy(input));</span>
<a href="#l67.108"></a><span id="l67.108" class="difflineplus">+    assert_rnp_success(rnp_output_destroy(output));</span>
<a href="#l67.109"></a><span id="l67.109" class="difflineplus">+}</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l68.1"></a><span id="l68.1" class="difflineminus">--- a/third_party/rnp/src/tests/rnp_tests.h</span>
<a href="#l68.2"></a><span id="l68.2" class="difflineplus">+++ b/third_party/rnp/src/tests/rnp_tests.h</span>
<a href="#l68.3"></a><span id="l68.3" class="difflineat">@@ -218,20 +218,24 @@ void test_ffi_key_to_json(void **state);</span>
<a href="#l68.4"></a><span id="l68.4"> void test_ffi_key_iter(void **state);</span>
<a href="#l68.5"></a><span id="l68.5"> </span>
<a href="#l68.6"></a><span id="l68.6"> void test_ffi_locate_key(void **state);</span>
<a href="#l68.7"></a><span id="l68.7"> </span>
<a href="#l68.8"></a><span id="l68.8"> void test_ffi_signatures_detached_memory_g10(void **state);</span>
<a href="#l68.9"></a><span id="l68.9"> </span>
<a href="#l68.10"></a><span id="l68.10"> void test_ffi_enarmor_dearmor(void **state);</span>
<a href="#l68.11"></a><span id="l68.11"> </span>
<a href="#l68.12"></a><span id="l68.12" class="difflineplus">+void test_ffi_customized_enarmor(void **state);</span>
<a href="#l68.13"></a><span id="l68.13" class="difflineplus">+</span>
<a href="#l68.14"></a><span id="l68.14"> void test_ffi_version(void **state);</span>
<a href="#l68.15"></a><span id="l68.15"> </span>
<a href="#l68.16"></a><span id="l68.16"> void test_ffi_key_export(void **state);</span>
<a href="#l68.17"></a><span id="l68.17"> </span>
<a href="#l68.18"></a><span id="l68.18" class="difflineplus">+void test_ffi_key_export_customized_enarmor(void **state);</span>
<a href="#l68.19"></a><span id="l68.19" class="difflineplus">+</span>
<a href="#l68.20"></a><span id="l68.20"> void test_ffi_key_dump(void **state);</span>
<a href="#l68.21"></a><span id="l68.21"> </span>
<a href="#l68.22"></a><span id="l68.22"> void test_ffi_key_userid_dump_has_no_special_chars(void **state);</span>
<a href="#l68.23"></a><span id="l68.23"> </span>
<a href="#l68.24"></a><span id="l68.24"> void test_ffi_pkt_dump(void **state);</span>
<a href="#l68.25"></a><span id="l68.25"> </span>
<a href="#l68.26"></a><span id="l68.26"> void test_ffi_rsa_v3_dump(void **state);</span>
<a href="#l68.27"></a><span id="l68.27"> </span>
<a href="#l68.28"></a><span id="l68.28" class="difflineat">@@ -256,16 +260,18 @@ void test_ffi_elgamal4096(void **state);</span>
<a href="#l68.29"></a><span id="l68.29"> void test_ffi_calculate_iterations(void **state);</span>
<a href="#l68.30"></a><span id="l68.30"> </span>
<a href="#l68.31"></a><span id="l68.31"> void test_ffi_supported_features(void **state);</span>
<a href="#l68.32"></a><span id="l68.32"> </span>
<a href="#l68.33"></a><span id="l68.33"> void test_ffi_enable_debug(void **state);</span>
<a href="#l68.34"></a><span id="l68.34"> </span>
<a href="#l68.35"></a><span id="l68.35"> void test_ffi_rnp_key_get_primary_grip(void **state);</span>
<a href="#l68.36"></a><span id="l68.36"> </span>
<a href="#l68.37"></a><span id="l68.37" class="difflineplus">+void test_ffi_rnp_key_get_primary_fprint(void **state);</span>
<a href="#l68.38"></a><span id="l68.38" class="difflineplus">+</span>
<a href="#l68.39"></a><span id="l68.39"> void test_ffi_output_to_armor(void **state);</span>
<a href="#l68.40"></a><span id="l68.40"> </span>
<a href="#l68.41"></a><span id="l68.41"> void test_ffi_rnp_guess_contents(void **state);</span>
<a href="#l68.42"></a><span id="l68.42"> </span>
<a href="#l68.43"></a><span id="l68.43"> void test_ffi_literal_filename(void **state);</span>
<a href="#l68.44"></a><span id="l68.44"> </span>
<a href="#l68.45"></a><span id="l68.45"> void test_ffi_op_set_hash(void **state);</span>
<a href="#l68.46"></a><span id="l68.46"> </span>
<a href="#l68.47"></a><span id="l68.47" class="difflineat">@@ -296,16 +302,18 @@ void test_ffi_set_key_expiry(void **stat</span>
<a href="#l68.48"></a><span id="l68.48"> void test_ffi_mdc_8k_boundary(void **state);</span>
<a href="#l68.49"></a><span id="l68.49"> </span>
<a href="#l68.50"></a><span id="l68.50"> void test_ffi_decrypt_wrong_mpi_bits(void **state);</span>
<a href="#l68.51"></a><span id="l68.51"> </span>
<a href="#l68.52"></a><span id="l68.52"> void test_ffi_key_import_edge_cases(void **state);</span>
<a href="#l68.53"></a><span id="l68.53"> </span>
<a href="#l68.54"></a><span id="l68.54"> void test_ffi_key_remove(void **state);</span>
<a href="#l68.55"></a><span id="l68.55"> </span>
<a href="#l68.56"></a><span id="l68.56" class="difflineplus">+void test_ffi_literal_packet(void **state);</span>
<a href="#l68.57"></a><span id="l68.57" class="difflineplus">+</span>
<a href="#l68.58"></a><span id="l68.58"> void test_dsa_roundtrip(void **state);</span>
<a href="#l68.59"></a><span id="l68.59"> </span>
<a href="#l68.60"></a><span id="l68.60"> void test_dsa_verify_negative(void **state);</span>
<a href="#l68.61"></a><span id="l68.61"> </span>
<a href="#l68.62"></a><span id="l68.62"> void test_stream_memory(void **state);</span>
<a href="#l68.63"></a><span id="l68.63"> </span>
<a href="#l68.64"></a><span id="l68.64"> void test_stream_memory_discard(void **state);</span>
<a href="#l68.65"></a><span id="l68.65"> </span>
<a href="#l68.66"></a><span id="l68.66" class="difflineat">@@ -366,16 +374,22 @@ void test_partial_length_public_key(void</span>
<a href="#l68.67"></a><span id="l68.67"> void test_partial_length_first_packet_256(void **state);</span>
<a href="#l68.68"></a><span id="l68.68"> </span>
<a href="#l68.69"></a><span id="l68.69"> void test_partial_length_zero_last_chunk(void **state);</span>
<a href="#l68.70"></a><span id="l68.70"> </span>
<a href="#l68.71"></a><span id="l68.71"> void test_partial_length_largest(void **state);</span>
<a href="#l68.72"></a><span id="l68.72"> </span>
<a href="#l68.73"></a><span id="l68.73"> void test_partial_length_first_packet_length(void **state);</span>
<a href="#l68.74"></a><span id="l68.74"> </span>
<a href="#l68.75"></a><span id="l68.75" class="difflineplus">+void test_pipe(void **state);</span>
<a href="#l68.76"></a><span id="l68.76" class="difflineplus">+</span>
<a href="#l68.77"></a><span id="l68.77" class="difflineplus">+void test_pipe_source_error(void **state);</span>
<a href="#l68.78"></a><span id="l68.78" class="difflineplus">+</span>
<a href="#l68.79"></a><span id="l68.79" class="difflineplus">+void test_pipe_dest_error(void **state);</span>
<a href="#l68.80"></a><span id="l68.80" class="difflineplus">+</span>
<a href="#l68.81"></a><span id="l68.81"> void test_kbx_nsigs(void **state);</span>
<a href="#l68.82"></a><span id="l68.82"> </span>
<a href="#l68.83"></a><span id="l68.83"> void test_issue_1115(void **state);</span>
<a href="#l68.84"></a><span id="l68.84"> </span>
<a href="#l68.85"></a><span id="l68.85"> void issue_1030_rnpkeys_secret_keys_unprotected(void **state);</span>
<a href="#l68.86"></a><span id="l68.86"> </span>
<a href="#l68.87"></a><span id="l68.87"> void test_issue_1171_key_import_and_remove(void **state);</span>
<a href="#l68.88"></a><span id="l68.88"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l69.1"></a><span id="l69.1" class="difflineminus">--- a/third_party/rnp/src/tests/streams.cpp</span>
<a href="#l69.2"></a><span id="l69.2" class="difflineplus">+++ b/third_party/rnp/src/tests/streams.cpp</span>
<a href="#l69.3"></a><span id="l69.3" class="difflineat">@@ -334,17 +334,17 @@ TEST_F(rnp_tests, test_stream_signatures</span>
<a href="#l69.4"></a><span id="l69.4">     rnp_key_store_t * pubring;</span>
<a href="#l69.5"></a><span id="l69.5">     rnp_key_store_t * secring;</span>
<a href="#l69.6"></a><span id="l69.6">     pgp_signature_t   sig;</span>
<a href="#l69.7"></a><span id="l69.7">     pgp_hash_t        hash_orig;</span>
<a href="#l69.8"></a><span id="l69.8">     pgp_hash_t        hash_forged;</span>
<a href="#l69.9"></a><span id="l69.9">     pgp_hash_t        hash;</span>
<a href="#l69.10"></a><span id="l69.10">     pgp_hash_alg_t    halg;</span>
<a href="#l69.11"></a><span id="l69.11">     pgp_source_t      sigsrc;</span>
<a href="#l69.12"></a><span id="l69.12" class="difflineminus">-    uint8_t           keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l69.13"></a><span id="l69.13" class="difflineplus">+    pgp_key_id_t      keyid = {};</span>
<a href="#l69.14"></a><span id="l69.14">     pgp_key_t *       key = NULL;</span>
<a href="#l69.15"></a><span id="l69.15">     rng_t             rng;</span>
<a href="#l69.16"></a><span id="l69.16">     pgp_fingerprint_t fp;</span>
<a href="#l69.17"></a><span id="l69.17"> </span>
<a href="#l69.18"></a><span id="l69.18">     /* we need rng for key validation */</span>
<a href="#l69.19"></a><span id="l69.19">     assert_true(rng_init(&amp;rng, RNG_SYSTEM));</span>
<a href="#l69.20"></a><span id="l69.20">     /* load keys */</span>
<a href="#l69.21"></a><span id="l69.21">     pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/test_stream_signatures/pub.asc&quot;);</span>
<a href="#l69.22"></a><span id="l69.22" class="difflineat">@@ -402,18 +402,18 @@ TEST_F(rnp_tests, test_stream_signatures</span>
<a href="#l69.23"></a><span id="l69.23">     assert_true(pgp_hash_copy(&amp;hash, &amp;hash_orig));</span>
<a href="#l69.24"></a><span id="l69.24">     assert_rnp_success(signature_calculate(&amp;sig, pgp_key_get_material(key), &amp;hash, &amp;rng));</span>
<a href="#l69.25"></a><span id="l69.25">     /* now verify signature */</span>
<a href="#l69.26"></a><span id="l69.26">     assert_true(pgp_hash_copy(&amp;hash, &amp;hash_orig));</span>
<a href="#l69.27"></a><span id="l69.27">     /* validate signature and fields */</span>
<a href="#l69.28"></a><span id="l69.28">     assert_int_equal(signature_get_creation(&amp;sig), create);</span>
<a href="#l69.29"></a><span id="l69.29">     assert_int_equal(signature_get_expiration(&amp;sig), expire);</span>
<a href="#l69.30"></a><span id="l69.30">     assert_true(signature_has_keyfp(&amp;sig));</span>
<a href="#l69.31"></a><span id="l69.31" class="difflineminus">-    assert_true(signature_get_keyfp(&amp;sig, &amp;fp));</span>
<a href="#l69.32"></a><span id="l69.32" class="difflineminus">-    assert_true(fingerprint_equal(&amp;fp, pgp_key_get_fp(key)));</span>
<a href="#l69.33"></a><span id="l69.33" class="difflineplus">+    assert_true(signature_get_keyfp(&amp;sig, fp));</span>
<a href="#l69.34"></a><span id="l69.34" class="difflineplus">+    assert_true(fp == pgp_key_get_fp(key));</span>
<a href="#l69.35"></a><span id="l69.35">     assert_rnp_success(signature_validate(&amp;sig, pgp_key_get_material(key), &amp;hash));</span>
<a href="#l69.36"></a><span id="l69.36">     free_signature(&amp;sig);</span>
<a href="#l69.37"></a><span id="l69.37">     /* cleanup */</span>
<a href="#l69.38"></a><span id="l69.38">     delete pubring;</span>
<a href="#l69.39"></a><span id="l69.39">     delete secring;</span>
<a href="#l69.40"></a><span id="l69.40">     pgp_hash_finish(&amp;hash_orig, NULL);</span>
<a href="#l69.41"></a><span id="l69.41">     pgp_hash_finish(&amp;hash_forged, NULL);</span>
<a href="#l69.42"></a><span id="l69.42">     rng_destroy(&amp;rng);</span>
<a href="#l69.43"></a><span id="l69.43" class="difflineat">@@ -442,17 +442,17 @@ TEST_F(rnp_tests, test_stream_signatures</span>
<a href="#l69.44"></a><span id="l69.44">     free_signature(&amp;sig);</span>
<a href="#l69.45"></a><span id="l69.45"> }</span>
<a href="#l69.46"></a><span id="l69.46"> </span>
<a href="#l69.47"></a><span id="l69.47"> TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.48"></a><span id="l69.48"> {</span>
<a href="#l69.49"></a><span id="l69.49">     pgp_source_t               keysrc = {0};</span>
<a href="#l69.50"></a><span id="l69.50">     pgp_dest_t                 keydst = {0};</span>
<a href="#l69.51"></a><span id="l69.51">     pgp_key_sequence_t         keyseq;</span>
<a href="#l69.52"></a><span id="l69.52" class="difflineminus">-    uint8_t                    keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l69.53"></a><span id="l69.53" class="difflineplus">+    pgp_key_id_t               keyid = {};</span>
<a href="#l69.54"></a><span id="l69.54">     pgp_fingerprint_t          keyfp;</span>
<a href="#l69.55"></a><span id="l69.55">     pgp_transferable_key_t *   key = NULL;</span>
<a href="#l69.56"></a><span id="l69.56">     pgp_transferable_subkey_t *skey = NULL;</span>
<a href="#l69.57"></a><span id="l69.57"> </span>
<a href="#l69.58"></a><span id="l69.58">     /* public keyring, read-save-read-save armored-read */</span>
<a href="#l69.59"></a><span id="l69.59">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l69.60"></a><span id="l69.60">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.61"></a><span id="l69.61">     assert_true(list_length(keyseq.keys) &gt; 1);</span>
<a href="#l69.62"></a><span id="l69.62" class="difflineat">@@ -502,70 +502,70 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.63"></a><span id="l69.63">     src_close(&amp;keysrc);</span>
<a href="#l69.64"></a><span id="l69.64">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.65"></a><span id="l69.65"> </span>
<a href="#l69.66"></a><span id="l69.66">     /* armored v3 public key */</span>
<a href="#l69.67"></a><span id="l69.67">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/4/rsav3-p.asc&quot;));</span>
<a href="#l69.68"></a><span id="l69.68">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.69"></a><span id="l69.69">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.70"></a><span id="l69.70">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.71"></a><span id="l69.71" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l69.72"></a><span id="l69.72" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;key-&gt;key));</span>
<a href="#l69.73"></a><span id="l69.73">     assert_true(cmp_keyid(keyid, &quot;7D0BC10E933404C9&quot;));</span>
<a href="#l69.74"></a><span id="l69.74">     assert_false(cmp_keyid(keyid, &quot;1D0BC10E933404C9&quot;));</span>
<a href="#l69.75"></a><span id="l69.75">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.76"></a><span id="l69.76">     src_close(&amp;keysrc);</span>
<a href="#l69.77"></a><span id="l69.77"> </span>
<a href="#l69.78"></a><span id="l69.78">     /* armored v3 secret key */</span>
<a href="#l69.79"></a><span id="l69.79">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/4/rsav3-s.asc&quot;));</span>
<a href="#l69.80"></a><span id="l69.80">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.81"></a><span id="l69.81">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.82"></a><span id="l69.82">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.83"></a><span id="l69.83" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l69.84"></a><span id="l69.84" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;key-&gt;key));</span>
<a href="#l69.85"></a><span id="l69.85">     assert_true(cmp_keyid(keyid, &quot;7D0BC10E933404C9&quot;));</span>
<a href="#l69.86"></a><span id="l69.86">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.87"></a><span id="l69.87">     src_close(&amp;keysrc);</span>
<a href="#l69.88"></a><span id="l69.88"> </span>
<a href="#l69.89"></a><span id="l69.89">     /* rsa/rsa public key */</span>
<a href="#l69.90"></a><span id="l69.90">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/rsa-rsa-pub.asc&quot;));</span>
<a href="#l69.91"></a><span id="l69.91">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.92"></a><span id="l69.92">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.93"></a><span id="l69.93">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.94"></a><span id="l69.94" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.95"></a><span id="l69.95" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;6BC04A5A3DDB35766B9A40D82FB9179118898E8B&quot;));</span>
<a href="#l69.96"></a><span id="l69.96" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l69.97"></a><span id="l69.97" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.98"></a><span id="l69.98" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;6BC04A5A3DDB35766B9A40D82FB9179118898E8B&quot;));</span>
<a href="#l69.99"></a><span id="l69.99" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;key-&gt;key));</span>
<a href="#l69.100"></a><span id="l69.100">     assert_true(cmp_keyid(keyid, &quot;2FB9179118898E8B&quot;));</span>
<a href="#l69.101"></a><span id="l69.101">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l69.102"></a><span id="l69.102">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l69.103"></a><span id="l69.103">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.104"></a><span id="l69.104">     src_close(&amp;keysrc);</span>
<a href="#l69.105"></a><span id="l69.105"> </span>
<a href="#l69.106"></a><span id="l69.106">     /* rsa/rsa secret key */</span>
<a href="#l69.107"></a><span id="l69.107">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/rsa-rsa-sec.asc&quot;));</span>
<a href="#l69.108"></a><span id="l69.108">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.109"></a><span id="l69.109">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.110"></a><span id="l69.110">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.111"></a><span id="l69.111" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.112"></a><span id="l69.112" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;6BC04A5A3DDB35766B9A40D82FB9179118898E8B&quot;));</span>
<a href="#l69.113"></a><span id="l69.113" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l69.114"></a><span id="l69.114" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.115"></a><span id="l69.115" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;6BC04A5A3DDB35766B9A40D82FB9179118898E8B&quot;));</span>
<a href="#l69.116"></a><span id="l69.116" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;key-&gt;key));</span>
<a href="#l69.117"></a><span id="l69.117">     assert_true(cmp_keyid(keyid, &quot;2FB9179118898E8B&quot;));</span>
<a href="#l69.118"></a><span id="l69.118">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l69.119"></a><span id="l69.119">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l69.120"></a><span id="l69.120">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.121"></a><span id="l69.121">     src_close(&amp;keysrc);</span>
<a href="#l69.122"></a><span id="l69.122"> </span>
<a href="#l69.123"></a><span id="l69.123">     /* dsa/el-gamal public key */</span>
<a href="#l69.124"></a><span id="l69.124">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/dsa-eg-pub.asc&quot;));</span>
<a href="#l69.125"></a><span id="l69.125">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.126"></a><span id="l69.126">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.127"></a><span id="l69.127">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.128"></a><span id="l69.128" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.129"></a><span id="l69.129" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;091C44CE9CFBC3FF7EC7A64DC8A10A7D78273E10&quot;));</span>
<a href="#l69.130"></a><span id="l69.130" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.131"></a><span id="l69.131" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;091C44CE9CFBC3FF7EC7A64DC8A10A7D78273E10&quot;));</span>
<a href="#l69.132"></a><span id="l69.132">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l69.133"></a><span id="l69.133">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.134"></a><span id="l69.134" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.135"></a><span id="l69.135" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.136"></a><span id="l69.136">     assert_true(cmp_keyid(keyid, &quot;02A5715C3537717E&quot;));</span>
<a href="#l69.137"></a><span id="l69.137">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.138"></a><span id="l69.138">     src_close(&amp;keysrc);</span>
<a href="#l69.139"></a><span id="l69.139"> </span>
<a href="#l69.140"></a><span id="l69.140">     /* dsa/el-gamal secret key */</span>
<a href="#l69.141"></a><span id="l69.141">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/dsa-eg-sec.asc&quot;));</span>
<a href="#l69.142"></a><span id="l69.142">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.143"></a><span id="l69.143">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.144"></a><span id="l69.144" class="difflineat">@@ -575,18 +575,18 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.145"></a><span id="l69.145">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.146"></a><span id="l69.146">     src_close(&amp;keysrc);</span>
<a href="#l69.147"></a><span id="l69.147"> </span>
<a href="#l69.148"></a><span id="l69.148">     /* curve 25519 ecc public key */</span>
<a href="#l69.149"></a><span id="l69.149">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-25519-pub.asc&quot;));</span>
<a href="#l69.150"></a><span id="l69.150">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.151"></a><span id="l69.151">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.152"></a><span id="l69.152">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.153"></a><span id="l69.153" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.154"></a><span id="l69.154" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;21FC68274AAE3B5DE39A4277CC786278981B0728&quot;));</span>
<a href="#l69.155"></a><span id="l69.155" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.156"></a><span id="l69.156" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;21FC68274AAE3B5DE39A4277CC786278981B0728&quot;));</span>
<a href="#l69.157"></a><span id="l69.157">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.158"></a><span id="l69.158">     src_close(&amp;keysrc);</span>
<a href="#l69.159"></a><span id="l69.159"> </span>
<a href="#l69.160"></a><span id="l69.160">     /* curve 25519 ecc secret key */</span>
<a href="#l69.161"></a><span id="l69.161">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-25519-sec.asc&quot;));</span>
<a href="#l69.162"></a><span id="l69.162">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.163"></a><span id="l69.163">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.164"></a><span id="l69.164">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.165"></a><span id="l69.165" class="difflineat">@@ -595,21 +595,21 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.166"></a><span id="l69.166">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.167"></a><span id="l69.167">     src_close(&amp;keysrc);</span>
<a href="#l69.168"></a><span id="l69.168"> </span>
<a href="#l69.169"></a><span id="l69.169">     /* eddsa/x25519 ecc public key */</span>
<a href="#l69.170"></a><span id="l69.170">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-x25519-pub.asc&quot;));</span>
<a href="#l69.171"></a><span id="l69.171">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.172"></a><span id="l69.172">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.173"></a><span id="l69.173">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.174"></a><span id="l69.174" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.175"></a><span id="l69.175" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;4C9738A6F2BE4E1A796C9B7B941822A0FC1B30A5&quot;));</span>
<a href="#l69.176"></a><span id="l69.176" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.177"></a><span id="l69.177" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;4C9738A6F2BE4E1A796C9B7B941822A0FC1B30A5&quot;));</span>
<a href="#l69.178"></a><span id="l69.178">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l69.179"></a><span id="l69.179">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.180"></a><span id="l69.180" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.181"></a><span id="l69.181" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.182"></a><span id="l69.182">     assert_true(cmp_keyid(keyid, &quot;C711187E594376AF&quot;));</span>
<a href="#l69.183"></a><span id="l69.183">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.184"></a><span id="l69.184">     src_close(&amp;keysrc);</span>
<a href="#l69.185"></a><span id="l69.185"> </span>
<a href="#l69.186"></a><span id="l69.186">     /* eddsa/x25519 ecc secret key */</span>
<a href="#l69.187"></a><span id="l69.187">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-x25519-sec.asc&quot;));</span>
<a href="#l69.188"></a><span id="l69.188">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.189"></a><span id="l69.189">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.190"></a><span id="l69.190" class="difflineat">@@ -619,20 +619,20 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.191"></a><span id="l69.191">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.192"></a><span id="l69.192">     src_close(&amp;keysrc);</span>
<a href="#l69.193"></a><span id="l69.193"> </span>
<a href="#l69.194"></a><span id="l69.194">     /* p-256 ecc public key */</span>
<a href="#l69.195"></a><span id="l69.195">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256-pub.asc&quot;));</span>
<a href="#l69.196"></a><span id="l69.196">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.197"></a><span id="l69.197">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.198"></a><span id="l69.198">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.199"></a><span id="l69.199" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.200"></a><span id="l69.200" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;B54FDEBBB673423A5D0AA54423674F21B2441527&quot;));</span>
<a href="#l69.201"></a><span id="l69.201" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.202"></a><span id="l69.202" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;B54FDEBBB673423A5D0AA54423674F21B2441527&quot;));</span>
<a href="#l69.203"></a><span id="l69.203">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.204"></a><span id="l69.204" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.205"></a><span id="l69.205" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.206"></a><span id="l69.206">     assert_true(cmp_keyid(keyid, &quot;37E285E9E9851491&quot;));</span>
<a href="#l69.207"></a><span id="l69.207">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.208"></a><span id="l69.208">     src_close(&amp;keysrc);</span>
<a href="#l69.209"></a><span id="l69.209"> </span>
<a href="#l69.210"></a><span id="l69.210">     /* p-256 ecc secret key */</span>
<a href="#l69.211"></a><span id="l69.211">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256-sec.asc&quot;));</span>
<a href="#l69.212"></a><span id="l69.212">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.213"></a><span id="l69.213">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.214"></a><span id="l69.214" class="difflineat">@@ -642,20 +642,20 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.215"></a><span id="l69.215">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.216"></a><span id="l69.216">     src_close(&amp;keysrc);</span>
<a href="#l69.217"></a><span id="l69.217"> </span>
<a href="#l69.218"></a><span id="l69.218">     /* p-384 ecc public key */</span>
<a href="#l69.219"></a><span id="l69.219">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p384-pub.asc&quot;));</span>
<a href="#l69.220"></a><span id="l69.220">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.221"></a><span id="l69.221">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.222"></a><span id="l69.222">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.223"></a><span id="l69.223" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.224"></a><span id="l69.224" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;AB25CBA042DD924C3ACC3ED3242A3AA5EA85F44A&quot;));</span>
<a href="#l69.225"></a><span id="l69.225" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.226"></a><span id="l69.226" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;AB25CBA042DD924C3ACC3ED3242A3AA5EA85F44A&quot;));</span>
<a href="#l69.227"></a><span id="l69.227">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.228"></a><span id="l69.228" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.229"></a><span id="l69.229" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.230"></a><span id="l69.230">     assert_true(cmp_keyid(keyid, &quot;E210E3D554A4FAD9&quot;));</span>
<a href="#l69.231"></a><span id="l69.231">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.232"></a><span id="l69.232">     src_close(&amp;keysrc);</span>
<a href="#l69.233"></a><span id="l69.233"> </span>
<a href="#l69.234"></a><span id="l69.234">     /* p-384 ecc secret key */</span>
<a href="#l69.235"></a><span id="l69.235">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p384-sec.asc&quot;));</span>
<a href="#l69.236"></a><span id="l69.236">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.237"></a><span id="l69.237">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.238"></a><span id="l69.238" class="difflineat">@@ -665,20 +665,20 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.239"></a><span id="l69.239">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.240"></a><span id="l69.240">     src_close(&amp;keysrc);</span>
<a href="#l69.241"></a><span id="l69.241"> </span>
<a href="#l69.242"></a><span id="l69.242">     /* p-521 ecc public key */</span>
<a href="#l69.243"></a><span id="l69.243">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p521-pub.asc&quot;));</span>
<a href="#l69.244"></a><span id="l69.244">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.245"></a><span id="l69.245">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.246"></a><span id="l69.246">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.247"></a><span id="l69.247" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.248"></a><span id="l69.248" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;4FB39FF6FA4857A4BD7EF5B42092CA8324263B6A&quot;));</span>
<a href="#l69.249"></a><span id="l69.249" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.250"></a><span id="l69.250" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;4FB39FF6FA4857A4BD7EF5B42092CA8324263B6A&quot;));</span>
<a href="#l69.251"></a><span id="l69.251">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.252"></a><span id="l69.252" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.253"></a><span id="l69.253" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.254"></a><span id="l69.254">     assert_true(cmp_keyid(keyid, &quot;9853DF2F6D297442&quot;));</span>
<a href="#l69.255"></a><span id="l69.255">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.256"></a><span id="l69.256">     src_close(&amp;keysrc);</span>
<a href="#l69.257"></a><span id="l69.257"> </span>
<a href="#l69.258"></a><span id="l69.258">     /* p-521 ecc secret key */</span>
<a href="#l69.259"></a><span id="l69.259">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p521-sec.asc&quot;));</span>
<a href="#l69.260"></a><span id="l69.260">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.261"></a><span id="l69.261">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.262"></a><span id="l69.262" class="difflineat">@@ -688,20 +688,20 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.263"></a><span id="l69.263">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.264"></a><span id="l69.264">     src_close(&amp;keysrc);</span>
<a href="#l69.265"></a><span id="l69.265"> </span>
<a href="#l69.266"></a><span id="l69.266">     /* Brainpool P256 ecc public key */</span>
<a href="#l69.267"></a><span id="l69.267">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp256-pub.asc&quot;));</span>
<a href="#l69.268"></a><span id="l69.268">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.269"></a><span id="l69.269">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.270"></a><span id="l69.270">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.271"></a><span id="l69.271" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.272"></a><span id="l69.272" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;0633C5F72A198F51E650E4ABD0C8A3DAF9E0634A&quot;));</span>
<a href="#l69.273"></a><span id="l69.273" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.274"></a><span id="l69.274" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;0633C5F72A198F51E650E4ABD0C8A3DAF9E0634A&quot;));</span>
<a href="#l69.275"></a><span id="l69.275">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.276"></a><span id="l69.276" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.277"></a><span id="l69.277" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.278"></a><span id="l69.278">     assert_true(cmp_keyid(keyid, &quot;2EDABB94D3055F76&quot;));</span>
<a href="#l69.279"></a><span id="l69.279">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.280"></a><span id="l69.280">     src_close(&amp;keysrc);</span>
<a href="#l69.281"></a><span id="l69.281"> </span>
<a href="#l69.282"></a><span id="l69.282">     /* Brainpool P256 ecc secret key */</span>
<a href="#l69.283"></a><span id="l69.283">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp256-sec.asc&quot;));</span>
<a href="#l69.284"></a><span id="l69.284">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.285"></a><span id="l69.285">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.286"></a><span id="l69.286" class="difflineat">@@ -711,20 +711,20 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.287"></a><span id="l69.287">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.288"></a><span id="l69.288">     src_close(&amp;keysrc);</span>
<a href="#l69.289"></a><span id="l69.289"> </span>
<a href="#l69.290"></a><span id="l69.290">     /* Brainpool P384 ecc public key */</span>
<a href="#l69.291"></a><span id="l69.291">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp384-pub.asc&quot;));</span>
<a href="#l69.292"></a><span id="l69.292">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.293"></a><span id="l69.293">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.294"></a><span id="l69.294">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.295"></a><span id="l69.295" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.296"></a><span id="l69.296" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;5B8A254C823CED98DECD10ED6CF2DCE85599ADA2&quot;));</span>
<a href="#l69.297"></a><span id="l69.297" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.298"></a><span id="l69.298" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;5B8A254C823CED98DECD10ED6CF2DCE85599ADA2&quot;));</span>
<a href="#l69.299"></a><span id="l69.299">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.300"></a><span id="l69.300" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.301"></a><span id="l69.301" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.302"></a><span id="l69.302">     assert_true(cmp_keyid(keyid, &quot;CFF1BB6F16D28191&quot;));</span>
<a href="#l69.303"></a><span id="l69.303">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.304"></a><span id="l69.304">     src_close(&amp;keysrc);</span>
<a href="#l69.305"></a><span id="l69.305"> </span>
<a href="#l69.306"></a><span id="l69.306">     /* Brainpool P384 ecc secret key */</span>
<a href="#l69.307"></a><span id="l69.307">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp384-sec.asc&quot;));</span>
<a href="#l69.308"></a><span id="l69.308">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.309"></a><span id="l69.309">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.310"></a><span id="l69.310" class="difflineat">@@ -734,20 +734,20 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.311"></a><span id="l69.311">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.312"></a><span id="l69.312">     src_close(&amp;keysrc);</span>
<a href="#l69.313"></a><span id="l69.313"> </span>
<a href="#l69.314"></a><span id="l69.314">     /* Brainpool P512 ecc public key */</span>
<a href="#l69.315"></a><span id="l69.315">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp512-pub.asc&quot;));</span>
<a href="#l69.316"></a><span id="l69.316">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.317"></a><span id="l69.317">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.318"></a><span id="l69.318">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.319"></a><span id="l69.319" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.320"></a><span id="l69.320" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;4C59AB9272AA6A1F60B85BD0AA5C58D14F7B8F48&quot;));</span>
<a href="#l69.321"></a><span id="l69.321" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.322"></a><span id="l69.322" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;4C59AB9272AA6A1F60B85BD0AA5C58D14F7B8F48&quot;));</span>
<a href="#l69.323"></a><span id="l69.323">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.324"></a><span id="l69.324" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.325"></a><span id="l69.325" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.326"></a><span id="l69.326">     assert_true(cmp_keyid(keyid, &quot;20CDAA1482BA79CE&quot;));</span>
<a href="#l69.327"></a><span id="l69.327">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.328"></a><span id="l69.328">     src_close(&amp;keysrc);</span>
<a href="#l69.329"></a><span id="l69.329"> </span>
<a href="#l69.330"></a><span id="l69.330">     /* Brainpool P512 ecc secret key */</span>
<a href="#l69.331"></a><span id="l69.331">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp512-sec.asc&quot;));</span>
<a href="#l69.332"></a><span id="l69.332">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.333"></a><span id="l69.333">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.334"></a><span id="l69.334" class="difflineat">@@ -757,20 +757,20 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l69.335"></a><span id="l69.335">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.336"></a><span id="l69.336">     src_close(&amp;keysrc);</span>
<a href="#l69.337"></a><span id="l69.337"> </span>
<a href="#l69.338"></a><span id="l69.338">     /* secp256k1 ecc public key, not supported now */</span>
<a href="#l69.339"></a><span id="l69.339">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256k1-pub.asc&quot;));</span>
<a href="#l69.340"></a><span id="l69.340">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.341"></a><span id="l69.341">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.342"></a><span id="l69.342">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l69.343"></a><span id="l69.343" class="difflineminus">-    assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l69.344"></a><span id="l69.344" class="difflineminus">-    assert_true(cmp_keyfp(&amp;keyfp, &quot;81F772B57D4EBFE7000A66233EA5BB6F9692C1A0&quot;));</span>
<a href="#l69.345"></a><span id="l69.345" class="difflineplus">+    assert_rnp_success(pgp_fingerprint(keyfp, &amp;key-&gt;key));</span>
<a href="#l69.346"></a><span id="l69.346" class="difflineplus">+    assert_true(cmp_keyfp(keyfp, &quot;81F772B57D4EBFE7000A66233EA5BB6F9692C1A0&quot;));</span>
<a href="#l69.347"></a><span id="l69.347">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l69.348"></a><span id="l69.348" class="difflineminus">-    assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l69.349"></a><span id="l69.349" class="difflineplus">+    assert_rnp_success(pgp_keyid(keyid, &amp;skey-&gt;subkey));</span>
<a href="#l69.350"></a><span id="l69.350">     assert_true(cmp_keyid(keyid, &quot;7635401F90D3E533&quot;));</span>
<a href="#l69.351"></a><span id="l69.351">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l69.352"></a><span id="l69.352">     src_close(&amp;keysrc);</span>
<a href="#l69.353"></a><span id="l69.353"> </span>
<a href="#l69.354"></a><span id="l69.354">     /* secp256k1 ecc secret key */</span>
<a href="#l69.355"></a><span id="l69.355">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256k1-sec.asc&quot;));</span>
<a href="#l69.356"></a><span id="l69.356">     assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l69.357"></a><span id="l69.357">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l69.358"></a><span id="l69.358" class="difflineat">@@ -1060,17 +1060,17 @@ TEST_F(rnp_tests, test_stream_key_signat</span>
<a href="#l69.359"></a><span id="l69.359">     rnp_key_store_t *          pubring;</span>
<a href="#l69.360"></a><span id="l69.360">     pgp_source_t               keysrc = {0};</span>
<a href="#l69.361"></a><span id="l69.361">     pgp_key_sequence_t         keyseq;</span>
<a href="#l69.362"></a><span id="l69.362">     pgp_transferable_key_t *   key = NULL;</span>
<a href="#l69.363"></a><span id="l69.363">     pgp_transferable_subkey_t *subkey = NULL;</span>
<a href="#l69.364"></a><span id="l69.364">     pgp_transferable_userid_t *uid = NULL;</span>
<a href="#l69.365"></a><span id="l69.365">     rng_t                      rng;</span>
<a href="#l69.366"></a><span id="l69.366">     pgp_signature_t *          sig;</span>
<a href="#l69.367"></a><span id="l69.367" class="difflineminus">-    uint8_t                    keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l69.368"></a><span id="l69.368" class="difflineplus">+    pgp_key_id_t               keyid = {};</span>
<a href="#l69.369"></a><span id="l69.369">     pgp_key_t *                pkey = NULL;</span>
<a href="#l69.370"></a><span id="l69.370">     pgp_hash_t                 hash;</span>
<a href="#l69.371"></a><span id="l69.371">     pgp_signature_info_t       sinfo = {};</span>
<a href="#l69.372"></a><span id="l69.372"> </span>
<a href="#l69.373"></a><span id="l69.373">     /* we need rng for key validation */</span>
<a href="#l69.374"></a><span id="l69.374">     assert_true(rng_init(&amp;rng, RNG_SYSTEM));</span>
<a href="#l69.375"></a><span id="l69.375"> </span>
<a href="#l69.376"></a><span id="l69.376">     /* v3 public key */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l70.1"></a><span id="l70.1" class="difflineminus">--- a/third_party/rnp/src/tests/support.cpp</span>
<a href="#l70.2"></a><span id="l70.2" class="difflineplus">+++ b/third_party/rnp/src/tests/support.cpp</span>
<a href="#l70.3"></a><span id="l70.3" class="difflineat">@@ -384,41 +384,41 @@ hex_encode(const uint8_t v[], size_t len</span>
<a href="#l70.4"></a><span id="l70.4">         s[2 * i + 1] = c2;</span>
<a href="#l70.5"></a><span id="l70.5">     }</span>
<a href="#l70.6"></a><span id="l70.6">     s[2 * len] = 0;</span>
<a href="#l70.7"></a><span id="l70.7"> </span>
<a href="#l70.8"></a><span id="l70.8">     return s;</span>
<a href="#l70.9"></a><span id="l70.9"> }</span>
<a href="#l70.10"></a><span id="l70.10"> </span>
<a href="#l70.11"></a><span id="l70.11"> bool</span>
<a href="#l70.12"></a><span id="l70.12" class="difflineminus">-bin_eq_hex(uint8_t *data, size_t len, const char *val)</span>
<a href="#l70.13"></a><span id="l70.13" class="difflineplus">+bin_eq_hex(const uint8_t *data, size_t len, const char *val)</span>
<a href="#l70.14"></a><span id="l70.14"> {</span>
<a href="#l70.15"></a><span id="l70.15">     uint8_t *dec;</span>
<a href="#l70.16"></a><span id="l70.16">     size_t   stlen = strlen(val);</span>
<a href="#l70.17"></a><span id="l70.17">     if (stlen != len * 2) {</span>
<a href="#l70.18"></a><span id="l70.18">         return false;</span>
<a href="#l70.19"></a><span id="l70.19">     }</span>
<a href="#l70.20"></a><span id="l70.20"> </span>
<a href="#l70.21"></a><span id="l70.21">     assert_non_null(dec = (uint8_t *) malloc(len));</span>
<a href="#l70.22"></a><span id="l70.22">     assert_true(rnp_hex_decode(val, dec, len));</span>
<a href="#l70.23"></a><span id="l70.23">     bool res = !memcmp(data, dec, len);</span>
<a href="#l70.24"></a><span id="l70.24">     free(dec);</span>
<a href="#l70.25"></a><span id="l70.25">     return res;</span>
<a href="#l70.26"></a><span id="l70.26"> }</span>
<a href="#l70.27"></a><span id="l70.27"> </span>
<a href="#l70.28"></a><span id="l70.28"> bool</span>
<a href="#l70.29"></a><span id="l70.29" class="difflineminus">-cmp_keyid(uint8_t *id, const char *val)</span>
<a href="#l70.30"></a><span id="l70.30" class="difflineplus">+cmp_keyid(const pgp_key_id_t &amp;id, const char *val)</span>
<a href="#l70.31"></a><span id="l70.31"> {</span>
<a href="#l70.32"></a><span id="l70.32" class="difflineminus">-    return bin_eq_hex(id, PGP_KEY_ID_SIZE, val);</span>
<a href="#l70.33"></a><span id="l70.33" class="difflineplus">+    return bin_eq_hex(id.data(), id.size(), val);</span>
<a href="#l70.34"></a><span id="l70.34"> }</span>
<a href="#l70.35"></a><span id="l70.35"> </span>
<a href="#l70.36"></a><span id="l70.36"> bool</span>
<a href="#l70.37"></a><span id="l70.37" class="difflineminus">-cmp_keyfp(pgp_fingerprint_t *fp, const char *val)</span>
<a href="#l70.38"></a><span id="l70.38" class="difflineplus">+cmp_keyfp(const pgp_fingerprint_t &amp;fp, const char *val)</span>
<a href="#l70.39"></a><span id="l70.39"> {</span>
<a href="#l70.40"></a><span id="l70.40" class="difflineminus">-    return bin_eq_hex(fp-&gt;fingerprint, fp-&gt;length, val);</span>
<a href="#l70.41"></a><span id="l70.41" class="difflineplus">+    return bin_eq_hex(fp.fingerprint, fp.length, val);</span>
<a href="#l70.42"></a><span id="l70.42"> }</span>
<a href="#l70.43"></a><span id="l70.43"> </span>
<a href="#l70.44"></a><span id="l70.44"> int</span>
<a href="#l70.45"></a><span id="l70.45"> test_value_equal(const char *what, const char *expected_value, const uint8_t v[], size_t v_len)</span>
<a href="#l70.46"></a><span id="l70.46"> {</span>
<a href="#l70.47"></a><span id="l70.47">     assert_int_equal(strlen(expected_value), v_len * 2);</span>
<a href="#l70.48"></a><span id="l70.48"> </span>
<a href="#l70.49"></a><span id="l70.49">     char *produced = hex_encode(v, v_len);</span>
<a href="#l70.50"></a><span id="l70.50" class="difflineat">@@ -778,27 +778,27 @@ ishex(const std::string &amp;hexid)</span>
<a href="#l70.51"></a><span id="l70.51">         return false;</span>
<a href="#l70.52"></a><span id="l70.52">     }</span>
<a href="#l70.53"></a><span id="l70.53">     return true;</span>
<a href="#l70.54"></a><span id="l70.54"> }</span>
<a href="#l70.55"></a><span id="l70.55"> </span>
<a href="#l70.56"></a><span id="l70.56"> pgp_key_t *</span>
<a href="#l70.57"></a><span id="l70.57"> rnp_tests_get_key_by_id(rnp_key_store_t *keyring, const std::string &amp;keyid, pgp_key_t *after)</span>
<a href="#l70.58"></a><span id="l70.58"> {</span>
<a href="#l70.59"></a><span id="l70.59" class="difflineminus">-    pgp_key_t *          key = NULL;</span>
<a href="#l70.60"></a><span id="l70.60" class="difflineminus">-    std::vector&lt;uint8_t&gt; keyid_bin(PGP_KEY_ID_SIZE, 0);</span>
<a href="#l70.61"></a><span id="l70.61" class="difflineminus">-    size_t               binlen = 0;</span>
<a href="#l70.62"></a><span id="l70.62" class="difflineplus">+    pgp_key_t *  key = NULL;</span>
<a href="#l70.63"></a><span id="l70.63" class="difflineplus">+    pgp_key_id_t keyid_bin = {};</span>
<a href="#l70.64"></a><span id="l70.64" class="difflineplus">+    size_t       binlen = 0;</span>
<a href="#l70.65"></a><span id="l70.65"> </span>
<a href="#l70.66"></a><span id="l70.66">     if (!keyring || keyid.empty()) {</span>
<a href="#l70.67"></a><span id="l70.67">         return NULL;</span>
<a href="#l70.68"></a><span id="l70.68">     }</span>
<a href="#l70.69"></a><span id="l70.69">     if (ishex(keyid) &amp;&amp;</span>
<a href="#l70.70"></a><span id="l70.70">         hex2bin(keyid.c_str(), keyid.size(), keyid_bin.data(), keyid_bin.size(), &amp;binlen)) {</span>
<a href="#l70.71"></a><span id="l70.71">         if (binlen &lt;= PGP_KEY_ID_SIZE) {</span>
<a href="#l70.72"></a><span id="l70.72" class="difflineminus">-            key = rnp_key_store_get_key_by_id(keyring, keyid_bin.data(), after);</span>
<a href="#l70.73"></a><span id="l70.73" class="difflineplus">+            key = rnp_key_store_get_key_by_id(keyring, keyid_bin, after);</span>
<a href="#l70.74"></a><span id="l70.74">         }</span>
<a href="#l70.75"></a><span id="l70.75">     }</span>
<a href="#l70.76"></a><span id="l70.76">     return key;</span>
<a href="#l70.77"></a><span id="l70.77"> }</span>
<a href="#l70.78"></a><span id="l70.78"> </span>
<a href="#l70.79"></a><span id="l70.79"> pgp_key_t *</span>
<a href="#l70.80"></a><span id="l70.80"> rnp_tests_get_key_by_fpr(rnp_key_store_t *keyring, const std::string &amp;keyid)</span>
<a href="#l70.81"></a><span id="l70.81"> {</span>
<a href="#l70.82"></a><span id="l70.82" class="difflineat">@@ -810,17 +810,17 @@ rnp_tests_get_key_by_fpr(rnp_key_store_t</span>
<a href="#l70.83"></a><span id="l70.83">         return NULL;</span>
<a href="#l70.84"></a><span id="l70.84">     }</span>
<a href="#l70.85"></a><span id="l70.85"> </span>
<a href="#l70.86"></a><span id="l70.86">     if (ishex(keyid) &amp;&amp;</span>
<a href="#l70.87"></a><span id="l70.87">         hex2bin(keyid.c_str(), keyid.size(), keyid_bin.data(), keyid_bin.size(), &amp;binlen)) {</span>
<a href="#l70.88"></a><span id="l70.88">         if (binlen &lt;= PGP_FINGERPRINT_SIZE) {</span>
<a href="#l70.89"></a><span id="l70.89">             pgp_fingerprint_t fp = {{}, static_cast&lt;unsigned&gt;(binlen)};</span>
<a href="#l70.90"></a><span id="l70.90">             memcpy(fp.fingerprint, keyid_bin.data(), binlen);</span>
<a href="#l70.91"></a><span id="l70.91" class="difflineminus">-            key = rnp_key_store_get_key_by_fpr(keyring, &amp;fp);</span>
<a href="#l70.92"></a><span id="l70.92" class="difflineplus">+            key = rnp_key_store_get_key_by_fpr(keyring, fp);</span>
<a href="#l70.93"></a><span id="l70.93">         }</span>
<a href="#l70.94"></a><span id="l70.94">     }</span>
<a href="#l70.95"></a><span id="l70.95">     return key;</span>
<a href="#l70.96"></a><span id="l70.96"> }</span>
<a href="#l70.97"></a><span id="l70.97"> </span>
<a href="#l70.98"></a><span id="l70.98"> pgp_key_t *</span>
<a href="#l70.99"></a><span id="l70.99"> rnp_tests_key_search(rnp_key_store_t *keyring, const std::string &amp;keyid)</span>
<a href="#l70.100"></a><span id="l70.100"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l71.1"></a><span id="l71.1" class="difflineminus">--- a/third_party/rnp/src/tests/support.h</span>
<a href="#l71.2"></a><span id="l71.2" class="difflineplus">+++ b/third_party/rnp/src/tests/support.h</span>
<a href="#l71.3"></a><span id="l71.3" class="difflineat">@@ -127,23 +127,23 @@ char *make_temp_dir(void);</span>
<a href="#l71.4"></a><span id="l71.4">  **/</span>
<a href="#l71.5"></a><span id="l71.5"> char *directory_from_file_path(const char *file_path, const char *reldir);</span>
<a href="#l71.6"></a><span id="l71.6"> </span>
<a href="#l71.7"></a><span id="l71.7"> /*</span>
<a href="#l71.8"></a><span id="l71.8">  */</span>
<a href="#l71.9"></a><span id="l71.9"> char *hex_encode(const uint8_t v[], size_t len);</span>
<a href="#l71.10"></a><span id="l71.10"> </span>
<a href="#l71.11"></a><span id="l71.11"> /* check whether bin value is equals hex string */</span>
<a href="#l71.12"></a><span id="l71.12" class="difflineminus">-bool bin_eq_hex(uint8_t *data, size_t len, const char *val);</span>
<a href="#l71.13"></a><span id="l71.13" class="difflineplus">+bool bin_eq_hex(const uint8_t *data, size_t len, const char *val);</span>
<a href="#l71.14"></a><span id="l71.14"> </span>
<a href="#l71.15"></a><span id="l71.15"> /* check whether key id is equal to hex string */</span>
<a href="#l71.16"></a><span id="l71.16" class="difflineminus">-bool cmp_keyid(uint8_t *id, const char *val);</span>
<a href="#l71.17"></a><span id="l71.17" class="difflineplus">+bool cmp_keyid(const pgp_key_id_t &amp;id, const char *val);</span>
<a href="#l71.18"></a><span id="l71.18"> </span>
<a href="#l71.19"></a><span id="l71.19"> /* check whether key fp is equal to hex string */</span>
<a href="#l71.20"></a><span id="l71.20" class="difflineminus">-bool cmp_keyfp(pgp_fingerprint_t *fp, const char *val);</span>
<a href="#l71.21"></a><span id="l71.21" class="difflineplus">+bool cmp_keyfp(const pgp_fingerprint_t &amp;fp, const char *val);</span>
<a href="#l71.22"></a><span id="l71.22"> </span>
<a href="#l71.23"></a><span id="l71.23"> /*</span>
<a href="#l71.24"></a><span id="l71.24">  */</span>
<a href="#l71.25"></a><span id="l71.25"> int test_value_equal(const char *  what,</span>
<a href="#l71.26"></a><span id="l71.26">                      const char *  expected_value,</span>
<a href="#l71.27"></a><span id="l71.27">                      const uint8_t v[],</span>
<a href="#l71.28"></a><span id="l71.28">                      size_t        v_len);</span>
<a href="#l71.29"></a><span id="l71.29"> </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:31Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

