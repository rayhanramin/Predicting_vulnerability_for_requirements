<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 4341:f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82" />
<meta property="og:url" content="/comm-central/rev/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82" />
<meta property="og:description" content="Bug 465618 - Correctness oversight fix where event-driven indexing was corrupting filthy state.  Additional compaction edge-cases dealt with too. rs=dmose, a=blocking-thunderbird3." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">shortlog</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">files</a> |
changeset |
<a href="/comm-central/raw-rev/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">raw</a>  | <a href="/comm-central/archive/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465618">Bug 465618</a> - Correctness oversight fix where event-driven indexing was corrupting filthy state.  Additional compaction edge-cases dealt with too. rs=dmose, a=blocking-thunderbird3.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 07 Nov 2009 17:05:43 -0800</td></tr>

<tr>
 <td>changeset 4341</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82</a></td>
</tr>



<tr>
<td>parent 4340</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/c60babecfea5fd0e3828ed594c252fbaac2bcaec">c60babecfea5fd0e3828ed594c252fbaac2bcaec</a>
</td>
</tr>

<tr>
<td>child 4342</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/3e12668e5de491aaa7fd8b8602eda1789df40b47">3e12668e5de491aaa7fd8b8602eda1789df40b47</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">3392</a></td></tr>
<tr><td>push user</td><td>bugmail@asutherland.org</td></tr>
<tr><td>push date</td><td class="date age">Sun, 08 Nov 2009 01:06:13 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@f0c1f7b4f5c2 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82&newProject=comm-central&newRevision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82&newProject=comm-central&newRevision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82&newProject=comm-central&newRevision=f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28dmose%29&revcount=50">dmose</a>, <a href="/comm-central/log?rev=reviewer%28blocking-thunderbird3%29&revcount=50">blocking-thunderbird3</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465618">465618</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=465618">Bug 465618</a> - Correctness oversight fix where event-driven indexing was corrupting filthy state.  Additional compaction edge-cases dealt with too. rs=dmose, a=blocking-thunderbird3.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datamodel.js">mailnews/db/gloda/modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datastore.js">mailnews/db/gloda/modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/index_msg.js">mailnews/db/gloda/modules/index_msg.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/index_msg.js">file</a> |
<a href="/comm-central/annotate/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/index_msg.js">annotate</a> |
<a href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/index_msg.js">diff</a> |
<a href="/comm-central/comparison/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/index_msg.js">comparison</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/modules/index_msg.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/base_index_messages.js">mailnews/db/gloda/test/unit/base_index_messages.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/base_index_messages.js">file</a> |
<a href="/comm-central/annotate/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/base_index_messages.js">annotate</a> |
<a href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/base_index_messages.js">diff</a> |
<a href="/comm-central/comparison/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/base_index_messages.js">comparison</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/base_index_messages.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">file</a> |
<a href="/comm-central/annotate/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">annotate</a> |
<a href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">diff</a> |
<a href="/comm-central/comparison/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">comparison</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/test_index_compaction.js">mailnews/db/gloda/test/unit/test_index_compaction.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/test_index_compaction.js">file</a> |
<a href="/comm-central/annotate/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/test_index_compaction.js">annotate</a> |
<a href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/test_index_compaction.js">diff</a> |
<a href="/comm-central/comparison/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/test_index_compaction.js">comparison</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/db/gloda/test/unit/test_index_compaction.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/test/resources/messageInjection.js">mailnews/test/resources/messageInjection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/test/resources/messageInjection.js">file</a> |
<a href="/comm-central/annotate/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/test/resources/messageInjection.js">annotate</a> |
<a href="/comm-central/diff/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/test/resources/messageInjection.js">diff</a> |
<a href="/comm-central/comparison/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/test/resources/messageInjection.js">comparison</a> |
<a href="/comm-central/log/f0c1f7b4f5c2e9adcd0ee12bac81a6ca2a248f82/mailnews/test/resources/messageInjection.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datamodel.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -239,16 +239,25 @@ GlodaFolder.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">   /** The folder is believed to be up-to-date */</span>
<a href="#l1.5"></a><span id="l1.5">   kFolderClean: 0,</span>
<a href="#l1.6"></a><span id="l1.6">   /** The folder has some un-indexed or dirty messages */</span>
<a href="#l1.7"></a><span id="l1.7">   kFolderDirty: 1,</span>
<a href="#l1.8"></a><span id="l1.8">   /** The folder needs to be entirely re-indexed, regardless of the flags on</span>
<a href="#l1.9"></a><span id="l1.9">    * the messages in the folder. This state will be downgraded to dirty */</span>
<a href="#l1.10"></a><span id="l1.10">   kFolderFilthy: 2,</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+  _kFolderDirtyStatusMask: 0x7,</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  /**</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+   * The (local) folder has been compacted and all of its message keys are</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+   *  potentially incorrect.  This is not a possible state for IMAP folders</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+   *  because their message keys are based on UIDs rather than offsets into</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+   *  the mbox file.</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+   */</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+  _kFolderCompactedFlag: 0x8,</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+</span>
<a href="#l1.21"></a><span id="l1.21">   /** The folder should never be indexed. */</span>
<a href="#l1.22"></a><span id="l1.22">   kIndexingNeverPriority: -1,</span>
<a href="#l1.23"></a><span id="l1.23">   /** The lowest priority assigned to a folder. */</span>
<a href="#l1.24"></a><span id="l1.24">   kIndexingLowestPriority: 0,</span>
<a href="#l1.25"></a><span id="l1.25">   /** The highest priority assigned to a folder. */</span>
<a href="#l1.26"></a><span id="l1.26">   kIndexingHighestPriority: 100,</span>
<a href="#l1.27"></a><span id="l1.27"> </span>
<a href="#l1.28"></a><span id="l1.28">   /** The indexing priority for a folder if no other priority is assigned. */</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineat">@@ -259,23 +268,78 @@ GlodaFolder.prototype = {</span>
<a href="#l1.30"></a><span id="l1.30">   kIndexingFavoritePriority: 40,</span>
<a href="#l1.31"></a><span id="l1.31">   /** The indexing priority for inboxes. */</span>
<a href="#l1.32"></a><span id="l1.32">   kIndexingInboxPriority: 50,</span>
<a href="#l1.33"></a><span id="l1.33">   /** The indexing priority for sent mail folders. */</span>
<a href="#l1.34"></a><span id="l1.34">   kIndexingSentMailPriority: 60,</span>
<a href="#l1.35"></a><span id="l1.35"> </span>
<a href="#l1.36"></a><span id="l1.36">   get id() { return this._id; },</span>
<a href="#l1.37"></a><span id="l1.37">   get uri() { return this._uri; },</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineminus">-  get dirtyStatus() { return this._dirtyStatus; },</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineminus">-  set dirtyStatus(aNewStatus) {</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-    if (aNewStatus != this._dirtyStatus) {</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-      this._dirtyStatus = aNewStatus;</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+  get dirtyStatus() {</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+    return this._dirtyStatus &amp; this._kFolderDirtyStatusMask;</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+  },</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+  /**</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+   * Mark a folder as dirty if it was clean.  Do nothing if it was already dirty</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+   *  or filthy.  For use by GlodaMsgIndexer only.  And maybe rkent and his</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+   *  marvelous extensions.</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+   */</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+  _ensureFolderDirty: function gloda_folder__markFolderDirty() {</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+    if (this.dirtyStatus == this.kFolderClean) {</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+      this._dirtyStatus = (this.kFolderDirty &amp; this._kFolderDirtyStatusMask) |</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+                          (this._dirtyStatus &amp; ~this._kFolderDirtyStatusMask);</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+      this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+    }</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+  },</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+  /**</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+   * Definitely for use only by GlodaMsgIndexer to downgrade the dirty status of</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+   *  a folder.</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+   */</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+  _downgradeDirtyStatus: function gloda_folder__downgradeDirtyStatus(</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+                           aNewStatus) {</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+    if (this._dirtyStatus != aNewStatus) {</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+      this._dirtyStatus = (aNewStatus &amp; this._kFolderDirtyStatusMask) |</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+                          (this._dirtyStatus &amp; ~this._kFolderDirtyStatusMask);</span>
<a href="#l1.66"></a><span id="l1.66">       this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l1.67"></a><span id="l1.67">     }</span>
<a href="#l1.68"></a><span id="l1.68">   },</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+  /**</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+   * Indicate whether this folder is currently being compacted.  The</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+   *  |GlodaMsgIndexer| keeps this in-memory-only value up-to-date.</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineplus">+   */</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+  get compacting gloda_folder_get_compacting() {</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+    return this._compacting;</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+  },</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+  /**</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+   * Set whether this folder is currently being compacted.  This is really only</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+   *  for the |GlodaMsgIndexer| to set.</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+   */</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+  set compacting gloda_folder_set_compacting(aCompacting) {</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+    this._compacting = aCompacting;</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+  },</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+  /**</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+   * Indicate whether this folder was compacted and has not yet been</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+   *  compaction processed.</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineplus">+   */</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineplus">+  get compacted gloda_folder_get_compacted() {</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+    return Boolean(this._dirtyStatus &amp; this._kFolderCompactedFlag);</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+  },</span>
<a href="#l1.90"></a><span id="l1.90" class="difflineplus">+  /**</span>
<a href="#l1.91"></a><span id="l1.91" class="difflineplus">+   * For use only by GlodaMsgIndexer to set/clear the compaction state of this</span>
<a href="#l1.92"></a><span id="l1.92" class="difflineplus">+   *  folder.</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineplus">+   */</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineplus">+  _setCompactedState: function gloda_folder__clearCompactedState(aCompacted) {</span>
<a href="#l1.95"></a><span id="l1.95" class="difflineplus">+    if (this.compacted != aCompacted) {</span>
<a href="#l1.96"></a><span id="l1.96" class="difflineplus">+      if (aCompacted)</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineplus">+        this._dirtyStatus |= this._kFolderCompactedFlag;</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+      else</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+        this._dirtyStatus &amp;= ~this._kFolderCompactedFlag;</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+      this._datastore.updateFolderDirtyStatus(this);</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+    }</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+  },</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+</span>
<a href="#l1.104"></a><span id="l1.104">   get name() { return this._prettyName; },</span>
<a href="#l1.105"></a><span id="l1.105">   toString: function gloda_folder_toString() {</span>
<a href="#l1.106"></a><span id="l1.106">     return &quot;Folder:&quot; + this._id;</span>
<a href="#l1.107"></a><span id="l1.107">   },</span>
<a href="#l1.108"></a><span id="l1.108"> </span>
<a href="#l1.109"></a><span id="l1.109">   toLocaleString: function gloda_folder_toLocaleString() {</span>
<a href="#l1.110"></a><span id="l1.110">     let xpcomFolder = this.getXPCOMFolder(this.kActivityFolderOnlyNoData);</span>
<a href="#l1.111"></a><span id="l1.111">     if (!xpcomFolder)</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineat">@@ -399,31 +463,16 @@ GlodaFolder.prototype = {</span>
<a href="#l1.113"></a><span id="l1.113">       //  not, this needs to be reset to 0 too.</span>
<a href="#l1.114"></a><span id="l1.114">       this._activeHeaderRetrievalLastStamp = 0;</span>
<a href="#l1.115"></a><span id="l1.115">     }</span>
<a href="#l1.116"></a><span id="l1.116"> </span>
<a href="#l1.117"></a><span id="l1.117">     return true;</span>
<a href="#l1.118"></a><span id="l1.118">   },</span>
<a href="#l1.119"></a><span id="l1.119"> </span>
<a href="#l1.120"></a><span id="l1.120">   /**</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineminus">-   * Indicate whether this folder is currently being compacted.  The</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineminus">-   *  |GlodaMsgIndexer| keeps this in-memory-only value up-to-date.</span>
<a href="#l1.123"></a><span id="l1.123" class="difflineminus">-   */</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-  get compacting gloda_folder_get_compacting() {</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineminus">-    return this._compacting;</span>
<a href="#l1.126"></a><span id="l1.126" class="difflineminus">-  },</span>
<a href="#l1.127"></a><span id="l1.127" class="difflineminus">-  /**</span>
<a href="#l1.128"></a><span id="l1.128" class="difflineminus">-   * Set whether this folder is currently being compacted.  This is really only</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineminus">-   *  for the |GlodaMsgIndexer| to set.</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineminus">-   */</span>
<a href="#l1.131"></a><span id="l1.131" class="difflineminus">-  set compacting gloda_folder_set_compacting(aCompacting) {</span>
<a href="#l1.132"></a><span id="l1.132" class="difflineminus">-    this._compacting = aCompacting;</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineminus">-  },</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineminus">-</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineminus">-  /**</span>
<a href="#l1.136"></a><span id="l1.136">    * Return the string associated with this account.</span>
<a href="#l1.137"></a><span id="l1.137">    */</span>
<a href="#l1.138"></a><span id="l1.138">   get accountLabel() {</span>
<a href="#l1.139"></a><span id="l1.139">     let msgFolder = this.getXPCOMFolder(this.kActivityFolderOnlyNoData);</span>
<a href="#l1.140"></a><span id="l1.140">     return msgFolder.server.prettyName;</span>
<a href="#l1.141"></a><span id="l1.141">   }</span>
<a href="#l1.142"></a><span id="l1.142"> };</span>
<a href="#l1.143"></a><span id="l1.143"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -558,17 +558,17 @@ var GlodaDatastore = {</span>
<a href="#l2.4"></a><span id="l2.4">   kConstraintIn: 1,</span>
<a href="#l2.5"></a><span id="l2.5">   kConstraintRanges: 2,</span>
<a href="#l2.6"></a><span id="l2.6">   kConstraintEquals: 3,</span>
<a href="#l2.7"></a><span id="l2.7">   kConstraintStringLike: 4,</span>
<a href="#l2.8"></a><span id="l2.8">   kConstraintFulltext: 5,</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10">   /* ******************* SCHEMA ******************* */</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  _schemaVersion: 16,</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  _schemaVersion: 17,</span>
<a href="#l2.14"></a><span id="l2.14">   _schema: {</span>
<a href="#l2.15"></a><span id="l2.15">     tables: {</span>
<a href="#l2.16"></a><span id="l2.16"> </span>
<a href="#l2.17"></a><span id="l2.17">       // ----- Messages</span>
<a href="#l2.18"></a><span id="l2.18">       folderLocations: {</span>
<a href="#l2.19"></a><span id="l2.19">         columns: [</span>
<a href="#l2.20"></a><span id="l2.20">           [&quot;id&quot;, &quot;INTEGER PRIMARY KEY&quot;],</span>
<a href="#l2.21"></a><span id="l2.21">           [&quot;folderURI&quot;, &quot;TEXT NOT NULL&quot;],</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -1065,16 +1065,18 @@ var GlodaDatastore = {</span>
<a href="#l2.23"></a><span id="l2.23">     // version 15ish, still labeled 13:</span>
<a href="#l2.24"></a><span id="l2.24">     // - change tokenizer to mozporter to support CJK</span>
<a href="#l2.25"></a><span id="l2.25">     // (We are slip-streaming this so that only people who want to test CJK</span>
<a href="#l2.26"></a><span id="l2.26">     //  have to test it.  We will properly bump the schema revision when the</span>
<a href="#l2.27"></a><span id="l2.27">     //  gloda correctness patch lands.)</span>
<a href="#l2.28"></a><span id="l2.28">     // version 16ish, labeled 14 and now 16</span>
<a href="#l2.29"></a><span id="l2.29">     // - gloda message id's start from 32 now</span>
<a href="#l2.30"></a><span id="l2.30">     // - all kinds of correctness changes</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+    // version 17</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+    // - more correctness fixes.</span>
<a href="#l2.33"></a><span id="l2.33"> </span>
<a href="#l2.34"></a><span id="l2.34">     aDBConnection.close();</span>
<a href="#l2.35"></a><span id="l2.35">     aDBFile.remove(false);</span>
<a href="#l2.36"></a><span id="l2.36">     this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l2.37"></a><span id="l2.37">     return this._createDB(aDBService, aDBFile);</span>
<a href="#l2.38"></a><span id="l2.38"> </span>
<a href="#l2.39"></a><span id="l2.39">     //aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l2.40"></a><span id="l2.40">     //return aDBConnection;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/db/gloda/modules/index_msg.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -463,29 +463,16 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.4"></a><span id="l3.4">    *  they are indexed.  We downgrade the folder to just kMessageDirty after</span>
<a href="#l3.5"></a><span id="l3.5">    *  marking all the messages in the folder as dirty.  We do this so that if we</span>
<a href="#l3.6"></a><span id="l3.6">    *  have to stop indexing the folder we can still build on our progress next</span>
<a href="#l3.7"></a><span id="l3.7">    *  time we enter the folder.</span>
<a href="#l3.8"></a><span id="l3.8">    * We mark all folders filthy when (re-)creating the database because there</span>
<a href="#l3.9"></a><span id="l3.9">    *  may be previous state left over from an earlier database.</span>
<a href="#l3.10"></a><span id="l3.10">    */</span>
<a href="#l3.11"></a><span id="l3.11">   kMessageFilthy: 2,</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-  /**</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineminus">-   * The (local) folder has been compacted and all of its message keys are</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineminus">-   *  potentially incorrect.  This is not a possible state for IMAP folders</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineminus">-   *  because their message keys are based on UIDs rather than offsets into</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineminus">-   *  the mbox file.</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineminus">-   * This is dealt with via a specialized/optimized processing pass and does not</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineminus">-   *  attempt to touch every message and mark its dirty state.  This is because</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineminus">-   *  we are able to (comparatively) efficiently process the folder, so it is</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineminus">-   *  sufficiently likely we will run to completion.  Additionally, immediately</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineminus">-   *  touching a property on every message in a folder and then touching them</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineminus">-   *  again once processed in some ways defeats the benefits of compaction.</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineminus">-   */</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineminus">-  kMessageCompactedDirtyBit: 4,</span>
<a href="#l3.25"></a><span id="l3.25"> </span>
<a href="#l3.26"></a><span id="l3.26">   /**</span>
<a href="#l3.27"></a><span id="l3.27">    * A message addition job yet to be (completely) processed.  Since message</span>
<a href="#l3.28"></a><span id="l3.28">    *  addition events come to us one-by-one, in order to aggregate them into a</span>
<a href="#l3.29"></a><span id="l3.29">    *  job, we need something like this.  It's up to the indexing loop to</span>
<a href="#l3.30"></a><span id="l3.30">    *  decide when to null this out; it can either do it when it first starts</span>
<a href="#l3.31"></a><span id="l3.31">    *  processing it, or when it has processed the last thing.  It's really a</span>
<a href="#l3.32"></a><span id="l3.32">    *  question of whether we want retrograde motion in the folder progress bar</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineat">@@ -642,19 +629,22 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.34"></a><span id="l3.34">   kEnumIndexedMsgs: 2,</span>
<a href="#l3.35"></a><span id="l3.35"> </span>
<a href="#l3.36"></a><span id="l3.36">   /**</span>
<a href="#l3.37"></a><span id="l3.37">    * Synchronous helper to get an enumerator for the current folder (as found</span>
<a href="#l3.38"></a><span id="l3.38">    *  in |_indexingFolder|.</span>
<a href="#l3.39"></a><span id="l3.39">    *</span>
<a href="#l3.40"></a><span id="l3.40">    * @param aEnumKind One of |kEnumAllMsgs|, |kEnumMsgsToIndex|, or</span>
<a href="#l3.41"></a><span id="l3.41">    *     |kEnumIndexedMsgs|.</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+   * @param [aAllowPreBadIds=false] Only valid for |kEnumIndexedMsgs|, tells us</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+   *     that we should treat message with any gloda-id as dirty, not just</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+   *     messages that have non-bad message id's.</span>
<a href="#l3.45"></a><span id="l3.45">    */</span>
<a href="#l3.46"></a><span id="l3.46">   _indexerGetEnumerator: function gloda_indexer_indexerGetEnumerator(</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineminus">-      aEnumKind) {</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+      aEnumKind, aAllowPreBadIds) {</span>
<a href="#l3.49"></a><span id="l3.49">     if (aEnumKind == this.kEnumMsgsToIndex) {</span>
<a href="#l3.50"></a><span id="l3.50">       // We need to create search terms for messages to index. Messages should</span>
<a href="#l3.51"></a><span id="l3.51">       //  be indexed if they're indexable (local or offline and not expunged)</span>
<a href="#l3.52"></a><span id="l3.52">       //  and either haven't been indexed or are dirty.</span>
<a href="#l3.53"></a><span id="l3.53">       // The basic search expression is:</span>
<a href="#l3.54"></a><span id="l3.54">       //  ((GLODA_MESSAGE_ID_PROPERTY Is 0) || (GLODA_DIRTY_PROPERTY Isnt 0)) &amp;&amp;</span>
<a href="#l3.55"></a><span id="l3.55">       //  (JUNK_SCORE_PROPERTY Isnt 100)</span>
<a href="#l3.56"></a><span id="l3.56">       // If the folder !isLocal we add the terms:</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineat">@@ -763,20 +753,22 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.58"></a><span id="l3.58">       let nsMsgSearchAttrib = Ci.nsMsgSearchAttrib;</span>
<a href="#l3.59"></a><span id="l3.59">       let nsMsgSearchOp = Ci.nsMsgSearchOp;</span>
<a href="#l3.60"></a><span id="l3.60"> </span>
<a href="#l3.61"></a><span id="l3.61">       // first term: (GLODA_MESSAGE_ID_PROPERTY &gt; GLODA_FIRST_VALID_MESSAGE_ID-1</span>
<a href="#l3.62"></a><span id="l3.62">       let searchTerm = searchSession.createTerm();</span>
<a href="#l3.63"></a><span id="l3.63">       searchTerm.booleanAnd = false; // actually don't care here</span>
<a href="#l3.64"></a><span id="l3.64">       searchTerm.beginsGrouping = true;</span>
<a href="#l3.65"></a><span id="l3.65">       searchTerm.attrib = nsMsgSearchAttrib.Uint32HdrProperty;</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineminus">-      searchTerm.op = nsMsgSearchOp.IsGreaterThan;</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+      // use != 0 if we're allow pre-bad ids.</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+      searchTerm.op = aAllowPreBadIds ? nsMsgSearchOp.Isnt</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+                                      : nsMsgSearchOp.IsGreaterThan;</span>
<a href="#l3.70"></a><span id="l3.70">       let value = searchTerm.value;</span>
<a href="#l3.71"></a><span id="l3.71">       value.attrib = searchTerm.attrib;</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineminus">-      value.status = GLODA_FIRST_VALID_MESSAGE_ID - 1;</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+      value.status = aAllowPreBadIds ? 0 : (GLODA_FIRST_VALID_MESSAGE_ID - 1);</span>
<a href="#l3.74"></a><span id="l3.74">       searchTerm.value = value;</span>
<a href="#l3.75"></a><span id="l3.75">       searchTerm.hdrProperty = GLODA_MESSAGE_ID_PROPERTY;</span>
<a href="#l3.76"></a><span id="l3.76">       searchTerms.appendElement(searchTerm, false);</span>
<a href="#l3.77"></a><span id="l3.77"> </span>
<a href="#l3.78"></a><span id="l3.78">       //  second term: &amp;&amp; GLODA_DIRTY_PROPERTY Isnt kMessageFilthy)</span>
<a href="#l3.79"></a><span id="l3.79">       searchTerm = searchSession.createTerm();</span>
<a href="#l3.80"></a><span id="l3.80">       searchTerm.booleanAnd = true;</span>
<a href="#l3.81"></a><span id="l3.81">       searchTerm.endsGrouping = true;</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineat">@@ -834,16 +826,18 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.83"></a><span id="l3.83">       this._indexerCompletePendingFolderEntry();</span>
<a href="#l3.84"></a><span id="l3.84">   },</span>
<a href="#l3.85"></a><span id="l3.85"> </span>
<a href="#l3.86"></a><span id="l3.86">   // it's a getter so we can reference 'this'.  we could memoize.</span>
<a href="#l3.87"></a><span id="l3.87">   get workers() {</span>
<a href="#l3.88"></a><span id="l3.88">     return [</span>
<a href="#l3.89"></a><span id="l3.89">       [&quot;folderSweep&quot;, {</span>
<a href="#l3.90"></a><span id="l3.90">          worker: this._worker_indexingSweep,</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+         jobCanceled: this._cleanup_indexingSweep,</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+         cleanup: this._cleanup_indexingSweep,</span>
<a href="#l3.93"></a><span id="l3.93">        }],</span>
<a href="#l3.94"></a><span id="l3.94">       [&quot;folder&quot;, {</span>
<a href="#l3.95"></a><span id="l3.95">          worker: this._worker_folderIndex,</span>
<a href="#l3.96"></a><span id="l3.96">          recover: this._recover_indexMessage,</span>
<a href="#l3.97"></a><span id="l3.97">          cleanup: this._cleanup_indexing,</span>
<a href="#l3.98"></a><span id="l3.98">        }],</span>
<a href="#l3.99"></a><span id="l3.99">       [&quot;folderCompact&quot;, {</span>
<a href="#l3.100"></a><span id="l3.100">          worker: this._worker_folderCompactionPass,</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineat">@@ -930,44 +924,59 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.102"></a><span id="l3.102">       // sort the folders by priority (descending)</span>
<a href="#l3.103"></a><span id="l3.103">       foldersToProcess.sort(function (a, b) {</span>
<a href="#l3.104"></a><span id="l3.104">         return b.indexingPriority - a.indexingPriority;</span>
<a href="#l3.105"></a><span id="l3.105">       });</span>
<a href="#l3.106"></a><span id="l3.106"> </span>
<a href="#l3.107"></a><span id="l3.107">       aJob.mappedFolders = true;</span>
<a href="#l3.108"></a><span id="l3.108">     }</span>
<a href="#l3.109"></a><span id="l3.109"> </span>
<a href="#l3.110"></a><span id="l3.110" class="difflineminus">-    // - process the folders (in sorted order)</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+    // -- process the folders (in sorted order)</span>
<a href="#l3.112"></a><span id="l3.112">     while (aJob.foldersToProcess.length) {</span>
<a href="#l3.113"></a><span id="l3.113">       let glodaFolder = aJob.foldersToProcess.shift();</span>
<a href="#l3.114"></a><span id="l3.114">       // ignore folders that:</span>
<a href="#l3.115"></a><span id="l3.115">       // - have been deleted out of existence!</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineminus">-      // - are not dirty</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+      // - are not dirty/have not been compacted</span>
<a href="#l3.118"></a><span id="l3.118">       // - are actively being compacted</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineminus">-      if (glodaFolder._deleted || !glodaFolder.dirtyStatus ||</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+      if (glodaFolder._deleted ||</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+          (!glodaFolder.dirtyStatus &amp;&amp; !glodaFolder.compacted) ||</span>
<a href="#l3.122"></a><span id="l3.122">           glodaFolder.compacting)</span>
<a href="#l3.123"></a><span id="l3.123">         continue;</span>
<a href="#l3.124"></a><span id="l3.124"> </span>
<a href="#l3.125"></a><span id="l3.125" class="difflineminus">-      // add a job for the folder indexing</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineminus">-      GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+      // If the folder is marked as compacted, give it a compaction job.</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+      if (glodaFolder.compacted)</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+        GlodaIndexer.indexJob(new IndexingJob(&quot;folderCompact&quot;, glodaFolder.id));</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+      // add a job for the folder indexing if it was dirty</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+      if (glodaFolder.dirtyStatus)</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+        GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+</span>
<a href="#l3.135"></a><span id="l3.135">       // re-schedule this job (although this worker will die)</span>
<a href="#l3.136"></a><span id="l3.136">       GlodaIndexer.indexJob(aJob);</span>
<a href="#l3.137"></a><span id="l3.137">       yield this.kWorkDone;</span>
<a href="#l3.138"></a><span id="l3.138">     }</span>
<a href="#l3.139"></a><span id="l3.139"> </span>
<a href="#l3.140"></a><span id="l3.140">     // consider deletion</span>
<a href="#l3.141"></a><span id="l3.141">     if (this.pendingDeletions || this.pendingDeletions === null)</span>
<a href="#l3.142"></a><span id="l3.142">       GlodaIndexer.indexJob(new IndexingJob(&quot;delete&quot;, null));</span>
<a href="#l3.143"></a><span id="l3.143"> </span>
<a href="#l3.144"></a><span id="l3.144">     // we don't have any more work to do...</span>
<a href="#l3.145"></a><span id="l3.145">     this._indexingSweepActive = false;</span>
<a href="#l3.146"></a><span id="l3.146">     yield this.kWorkDone;</span>
<a href="#l3.147"></a><span id="l3.147">   },</span>
<a href="#l3.148"></a><span id="l3.148"> </span>
<a href="#l3.149"></a><span id="l3.149">   /**</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+   * The only state we need to cleanup is that there is no longer an active</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+   *  indexing sweep.</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+   */</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+  _cleanup_indexingSweep: function gloda_canceled_indexingSweep(aJob) {</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineplus">+    this._indexingSweepActive = false;</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+  },</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+  /**</span>
<a href="#l3.158"></a><span id="l3.158">    * The number of headers to look at before yielding with kWorkSync.  This</span>
<a href="#l3.159"></a><span id="l3.159">    *  is for time-slicing purposes so we still yield to the UI periodically.</span>
<a href="#l3.160"></a><span id="l3.160">    */</span>
<a href="#l3.161"></a><span id="l3.161">   HEADER_CHECK_SYNC_BLOCK_SIZE: 25,</span>
<a href="#l3.162"></a><span id="l3.162"> </span>
<a href="#l3.163"></a><span id="l3.163">   /**</span>
<a href="#l3.164"></a><span id="l3.164">    * The number of headers to look at before calling</span>
<a href="#l3.165"></a><span id="l3.165">    */</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineat">@@ -988,39 +997,41 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.167"></a><span id="l3.167">    *  message key per the gloda database, and the message-id header.  We re-fill</span>
<a href="#l3.168"></a><span id="l3.168">    *  the list with batches on-demand.  This allows us to both avoid dispatching</span>
<a href="#l3.169"></a><span id="l3.169">    *  needless UPDATEs as well as deal with messages that were tracked by the</span>
<a href="#l3.170"></a><span id="l3.170">    *  PendingCommitTracker but were discarded by the compaction notification.</span>
<a href="#l3.171"></a><span id="l3.171">    *</span>
<a href="#l3.172"></a><span id="l3.172">    * We end up processing two streams of gloda-id's and some extra info.  In</span>
<a href="#l3.173"></a><span id="l3.173">    *  the normal case we expect these two streams to line up exactly and all</span>
<a href="#l3.174"></a><span id="l3.174">    *  we need to do is update the message key if it has changed.</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineminus">-   * The expected exceptional case is that we will sometimes see a gloda-id from</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineminus">-   *  the gloda database that does not have a corresponding header from the</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineminus">-   *  nsIMsgDBHdr-producing enumerator.  In this case we assume the message was</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineminus">-   *  indexed and tracked by the PendingCommitTracker but got purged by the</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineminus">-   *  compaction.  Since we have the message-id header for the gloda message</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineminus">-   *  we are able to ask the nsIMsgDatabase for the matching message and mark</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineminus">-   *  the header with the gloda-id using the PendingCommitTracker.  (We are</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineminus">-   *  unable to verify that the information has been committed so we need to</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineminus">-   *  wait on the commit again to mark it.)  Although the lookup is O(n)</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineminus">-   *  it is native on the in-memory mork database and is far more preferable</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineminus">-   *  than using an unfiltered iterator in the normal case as well.</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineminus">-   * The unexpected exceptional case is that we will see a gloda-id from the</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineminus">-   *  enumerator that has no corresponding entry in the actual database.</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineminus">-   *  This should not happen.  We are able to differentiate this case from the</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineminus">-   *  previous case by always checking for a message given its message-id</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineminus">-   *  header value when we experience a gloda-id mis-match.  In all cases we</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineminus">-   *  should be able to locate a message header with the message-id.  If</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineminus">-   *  the message header's messageKey is greater than that of the enumerator's</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineminus">-   *  header then we know we are in the unexpected case.  (It implies an</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineminus">-   *  insertion in the enumerator stream which is how we define the unexpected</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineminus">-   *  case.)  If the opposite is true, then that implies the enumerator skipped</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineminus">-   *  over the message header because it never got marked by the</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineminus">-   *  PendingCommitTracker which is the expected case.</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+   *</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+   * There are a few exceptional cases where things do not line up:</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+   * 1) The gloda database knows about a message that the enumerator does not</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+   *    know about...</span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+   *   a) This message exists in the folder (identified using its message-id</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+   *      header).  This means the message got indexed but PendingCommitTracker</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+   *      had to forget about the info when the compaction happened.  We</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+   *      re-establish the link and track the message in PendingCommitTracker</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+   *      again.</span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+   *   b) The message does not exist in the folder.  This means the message got</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+   *      indexed, PendingCommitTracker had to forget about the info, and</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+   *      then the message either got moved or deleted before now.  We mark</span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+   *      the message as deleted; this allows the gloda message to be reused</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+   *      if the move target has not yet been indexed or purged if it already</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+   *      has been and the gloda message is a duplicate.  And obviously, if the</span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+   *      event that happened was actually a delete, then the delete is the</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineplus">+   *      right thing to do.</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineplus">+   * 2) The enumerator knows about a message that the gloda database does not</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+   *    know about.  This is unexpected and should not happen.  We log a</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+   *    warning.  We are able to differentiate this case from case #1a by</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+   *    retrieving the message header associated with the next gloda message</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+   *    (using the message-id header per 1a again).  If the gloda message's</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+   *    message key is after the enumerator's message key then we know this is</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+   *    case #2.  (It implies an insertion in the enumerator stream which is how</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+   *    we define the unexpected case.)</span>
<a href="#l3.223"></a><span id="l3.223">    *</span>
<a href="#l3.224"></a><span id="l3.224">    * Besides updating the database rows, we also need to make sure that</span>
<a href="#l3.225"></a><span id="l3.225">    *  in-memory representations are updated.  Immediately after dispatching</span>
<a href="#l3.226"></a><span id="l3.226">    *  UPDATE changes to the database we use the same set of data to walk the</span>
<a href="#l3.227"></a><span id="l3.227">    *  live collections and update any affected messages.  We are then able to</span>
<a href="#l3.228"></a><span id="l3.228">    *  discard the information.  Although this means that we will have to</span>
<a href="#l3.229"></a><span id="l3.229">    *  potentially walk the live collections multiple times, unless something</span>
<a href="#l3.230"></a><span id="l3.230">    *  has gone horribly wrong, the number of collections should be reasonable</span>
<a href="#l3.231"></a><span id="l3.231" class="difflineat">@@ -1033,16 +1044,23 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.232"></a><span id="l3.232">    *  updates for all values &lt;= K.  Which means our feet are safe no matter</span>
<a href="#l3.233"></a><span id="l3.233">    *  when we issue the update command.  For maximum cache benefit, we issue</span>
<a href="#l3.234"></a><span id="l3.234">    *  our updates prior to our new query since they should still be maximally</span>
<a href="#l3.235"></a><span id="l3.235">    *  hot at that point.</span>
<a href="#l3.236"></a><span id="l3.236">    */</span>
<a href="#l3.237"></a><span id="l3.237">   _worker_folderCompactionPass:</span>
<a href="#l3.238"></a><span id="l3.238">       function gloda_worker_folderCompactionPass(aJob, aCallbackHandle) {</span>
<a href="#l3.239"></a><span id="l3.239">     yield this._indexerEnterFolder(aJob.id);</span>
<a href="#l3.240"></a><span id="l3.240" class="difflineplus">+</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineplus">+    // It's conceivable that with a folder sweep we might end up trying to</span>
<a href="#l3.242"></a><span id="l3.242" class="difflineplus">+    //  compact a folder twice.  Bail early in this case.</span>
<a href="#l3.243"></a><span id="l3.243" class="difflineplus">+    if (!this._indexingGlodaFolder.compacted)</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineplus">+      yield this.kWorkDone;</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineplus">+</span>
<a href="#l3.246"></a><span id="l3.246" class="difflineplus">+    // this is a forward enumeration (sometimes we reverse enumerate; not here)</span>
<a href="#l3.247"></a><span id="l3.247">     this._indexerGetEnumerator(this.kEnumIndexedMsgs);</span>
<a href="#l3.248"></a><span id="l3.248"> </span>
<a href="#l3.249"></a><span id="l3.249">     const HEADER_CHECK_SYNC_BLOCK_SIZE = this.HEADER_CHECK_SYNC_BLOCK_SIZE;</span>
<a href="#l3.250"></a><span id="l3.250">     const HEADER_CHECK_GC_BLOCK_SIZE = this.HEADER_CHECK_GC_BLOCK_SIZE;</span>
<a href="#l3.251"></a><span id="l3.251">     const FOLDER_COMPACTION_PASS_BATCH_SIZE =</span>
<a href="#l3.252"></a><span id="l3.252">       this.FOLDER_COMPACTION_PASS_BATCH_SIZE;</span>
<a href="#l3.253"></a><span id="l3.253"> </span>
<a href="#l3.254"></a><span id="l3.254">     // Tuples of [gloda id, message key, message-id header] from</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineat">@@ -1050,16 +1068,18 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.256"></a><span id="l3.256">     let glodaIdsMsgKeysHeaderIds = [];</span>
<a href="#l3.257"></a><span id="l3.257">     // Unpack each tuple from glodaIdsMsgKeysHeaderIds into these guys.</span>
<a href="#l3.258"></a><span id="l3.258">     // (Initialize oldMessageKey because we use it to kickstart our query.)</span>
<a href="#l3.259"></a><span id="l3.259">     let oldGlodaId, oldMessageKey = -1, oldHeaderMessageId;</span>
<a href="#l3.260"></a><span id="l3.260">     // parallel lists of gloda ids and message keys to pass to</span>
<a href="#l3.261"></a><span id="l3.261">     //  GlodaDatastore.updateMessageLocations</span>
<a href="#l3.262"></a><span id="l3.262">     let updateGlodaIds = [];</span>
<a href="#l3.263"></a><span id="l3.263">     let updateMessageKeys = [];</span>
<a href="#l3.264"></a><span id="l3.264" class="difflineplus">+    // list of gloda id's to mark deleted</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineplus">+    let deleteGlodaIds = [];</span>
<a href="#l3.266"></a><span id="l3.266">     let exceptionalMessages = {};</span>
<a href="#l3.267"></a><span id="l3.267"> </span>
<a href="#l3.268"></a><span id="l3.268">     // for GC reasons we need to track the number of headers seen</span>
<a href="#l3.269"></a><span id="l3.269">     let numHeadersSeen = 0;</span>
<a href="#l3.270"></a><span id="l3.270"> </span>
<a href="#l3.271"></a><span id="l3.271">     // We are consuming two lists; our loop structure has to reflect that.</span>
<a href="#l3.272"></a><span id="l3.272">     let headerIter = Iterator(fixIterator(this._indexingEnumerator,</span>
<a href="#l3.273"></a><span id="l3.273">                                           nsIMsgDBHdr));</span>
<a href="#l3.274"></a><span id="l3.274" class="difflineat">@@ -1107,16 +1127,21 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.275"></a><span id="l3.275">         if (updateGlodaIds.length) {</span>
<a href="#l3.276"></a><span id="l3.276">           GlodaDatastore.updateMessageLocations(updateGlodaIds,</span>
<a href="#l3.277"></a><span id="l3.277">                                                 updateMessageKeys,</span>
<a href="#l3.278"></a><span id="l3.278">                                                 aJob.id, true);</span>
<a href="#l3.279"></a><span id="l3.279">           updateGlodaIds = [];</span>
<a href="#l3.280"></a><span id="l3.280">           updateMessageKeys = [];</span>
<a href="#l3.281"></a><span id="l3.281">         }</span>
<a href="#l3.282"></a><span id="l3.282"> </span>
<a href="#l3.283"></a><span id="l3.283" class="difflineplus">+        if (deleteGlodaIds.length) {</span>
<a href="#l3.284"></a><span id="l3.284" class="difflineplus">+          GlodaDatastore.markMessagesDeletedByIDs(deleteGlodaIds);</span>
<a href="#l3.285"></a><span id="l3.285" class="difflineplus">+          deleteGlodaIds = [];</span>
<a href="#l3.286"></a><span id="l3.286" class="difflineplus">+        }</span>
<a href="#l3.287"></a><span id="l3.287" class="difflineplus">+</span>
<a href="#l3.288"></a><span id="l3.288">         GlodaDatastore.folderCompactionPassBlockFetch(</span>
<a href="#l3.289"></a><span id="l3.289">           aJob.id, oldMessageKey + 1, FOLDER_COMPACTION_PASS_BATCH_SIZE,</span>
<a href="#l3.290"></a><span id="l3.290">           aCallbackHandle.wrappedCallback);</span>
<a href="#l3.291"></a><span id="l3.291">         glodaIdsMsgKeysHeaderIds = yield this.kWorkAsync;</span>
<a href="#l3.292"></a><span id="l3.292">         // Reverse so we can use pop instead of shift and I don't need to be</span>
<a href="#l3.293"></a><span id="l3.293">         //  paranoid about performance.</span>
<a href="#l3.294"></a><span id="l3.294">         glodaIdsMsgKeysHeaderIds.reverse();</span>
<a href="#l3.295"></a><span id="l3.295"> </span>
<a href="#l3.296"></a><span id="l3.296" class="difflineat">@@ -1135,57 +1160,61 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.297"></a><span id="l3.297">             glodaIdsMsgKeysHeaderIds.pop();</span>
<a href="#l3.298"></a><span id="l3.298">         else</span>
<a href="#l3.299"></a><span id="l3.299">           oldGlodaId = oldMessageKey = oldHeaderMessageId = null;</span>
<a href="#l3.300"></a><span id="l3.300">       }</span>
<a href="#l3.301"></a><span id="l3.301">       else {</span>
<a href="#l3.302"></a><span id="l3.302">         keepGlodaTuple = false;</span>
<a href="#l3.303"></a><span id="l3.303">       }</span>
<a href="#l3.304"></a><span id="l3.304"> </span>
<a href="#l3.305"></a><span id="l3.305" class="difflineminus">-      // normal expected case</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineplus">+      // -- normal expected case</span>
<a href="#l3.307"></a><span id="l3.307">       if (glodaId == oldGlodaId) {</span>
<a href="#l3.308"></a><span id="l3.308">         // only need to do something if the key is not right</span>
<a href="#l3.309"></a><span id="l3.309">         if (msgHdr.messageKey != oldMessageKey) {</span>
<a href="#l3.310"></a><span id="l3.310">           updateGlodaIds.push(glodaId);</span>
<a href="#l3.311"></a><span id="l3.311">           updateMessageKeys.push(msgHdr.messageKey);</span>
<a href="#l3.312"></a><span id="l3.312">         }</span>
<a href="#l3.313"></a><span id="l3.313">       }</span>
<a href="#l3.314"></a><span id="l3.314" class="difflineminus">-      // exceptional case;</span>
<a href="#l3.315"></a><span id="l3.315" class="difflineplus">+      // -- exceptional cases</span>
<a href="#l3.316"></a><span id="l3.316">       else {</span>
<a href="#l3.317"></a><span id="l3.317">         // This should always return a value unless something is very wrong.</span>
<a href="#l3.318"></a><span id="l3.318">         //  We do not want to catch the exception if one happens.</span>
<a href="#l3.319"></a><span id="l3.319">         let idBasedHeader = oldHeaderMessageId ?</span>
<a href="#l3.320"></a><span id="l3.320">           this._indexingDatabase.getMsgHdrForMessageID(oldHeaderMessageId) :</span>
<a href="#l3.321"></a><span id="l3.321">           false;</span>
<a href="#l3.322"></a><span id="l3.322" class="difflineminus">-        if (idBasedHeader == null)</span>
<a href="#l3.323"></a><span id="l3.323" class="difflineminus">-          throw new Error(&quot;Compaction pass failure; unable to locate header &quot; +</span>
<a href="#l3.324"></a><span id="l3.324" class="difflineminus">-                          &quot;with message-id &quot; + oldHeaderMessageId);</span>
<a href="#l3.325"></a><span id="l3.325" class="difflineplus">+        // - Case 1b.</span>
<a href="#l3.326"></a><span id="l3.326" class="difflineplus">+        // We want to mark the message as deleted.</span>
<a href="#l3.327"></a><span id="l3.327" class="difflineplus">+        if (idBasedHeader == null) {</span>
<a href="#l3.328"></a><span id="l3.328" class="difflineplus">+          deleteGlodaIds.push(oldGlodaId);</span>
<a href="#l3.329"></a><span id="l3.329" class="difflineplus">+        }</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineplus">+        // - Case 1a</span>
<a href="#l3.331"></a><span id="l3.331">         // The expected case is that the message referenced by the gloda</span>
<a href="#l3.332"></a><span id="l3.332">         //  database precedes the header the enumerator told us about.  This</span>
<a href="#l3.333"></a><span id="l3.333">         //  is expected because if PendingCommitTracker did not mark the</span>
<a href="#l3.334"></a><span id="l3.334">         //  message as indexed/clean then the enumerator would not tell us</span>
<a href="#l3.335"></a><span id="l3.335">         //  about it.</span>
<a href="#l3.336"></a><span id="l3.336">         // Also, if we ran out of headers from the enumerator, this is a dead</span>
<a href="#l3.337"></a><span id="l3.337">         //  giveaway that this is the expected case.</span>
<a href="#l3.338"></a><span id="l3.338" class="difflineminus">-        if (idBasedHeader &amp;&amp;</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineplus">+        else if (idBasedHeader &amp;&amp;</span>
<a href="#l3.340"></a><span id="l3.340">              ((msgHdr &amp;&amp;</span>
<a href="#l3.341"></a><span id="l3.341">                idBasedHeader.messageKey &lt; msgHdr.messageKey) ||</span>
<a href="#l3.342"></a><span id="l3.342">               !msgHdr)) {</span>
<a href="#l3.343"></a><span id="l3.343">           // tell the pending commit tracker about the gloda database one</span>
<a href="#l3.344"></a><span id="l3.344">           PendingCommitTracker.track(idBasedHeader, oldGlodaId);</span>
<a href="#l3.345"></a><span id="l3.345">           // and we might need to update the message key too</span>
<a href="#l3.346"></a><span id="l3.346">           if (idBasedHeader.messageKey != oldMessageKey) {</span>
<a href="#l3.347"></a><span id="l3.347">             updateGlodaIds.push(oldGlodaId);</span>
<a href="#l3.348"></a><span id="l3.348">             updateMessageKeys.push(idBasedHeader.messageKey);</span>
<a href="#l3.349"></a><span id="l3.349">           }</span>
<a href="#l3.350"></a><span id="l3.350">           // Take another pass through the loop so that we check the</span>
<a href="#l3.351"></a><span id="l3.351">           //  enumerator header against the next message in the gloda</span>
<a href="#l3.352"></a><span id="l3.352">           //  database.</span>
<a href="#l3.353"></a><span id="l3.353">           keepIterHeader = true;</span>
<a href="#l3.354"></a><span id="l3.354">         }</span>
<a href="#l3.355"></a><span id="l3.355" class="difflineplus">+        // - Case 2</span>
<a href="#l3.356"></a><span id="l3.356">         // Whereas if the message referenced by gloda has a message key</span>
<a href="#l3.357"></a><span id="l3.357">         //  greater than the one returned by the enumerator, then we have a</span>
<a href="#l3.358"></a><span id="l3.358">         //  header claiming to be indexed by gloda that gloda does not</span>
<a href="#l3.359"></a><span id="l3.359">         //  actually know about.  This is exceptional and gets a warning.</span>
<a href="#l3.360"></a><span id="l3.360">         else if (msgHdr) {</span>
<a href="#l3.361"></a><span id="l3.361">           this._log.warn(&quot;Observed header that claims to be gloda indexed &quot; +</span>
<a href="#l3.362"></a><span id="l3.362">                          &quot;but that gloda has never heard of during &quot; +</span>
<a href="#l3.363"></a><span id="l3.363">                          &quot;compaction.&quot; +</span>
<a href="#l3.364"></a><span id="l3.364" class="difflineat">@@ -1197,16 +1226,20 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.365"></a><span id="l3.365">         }</span>
<a href="#l3.366"></a><span id="l3.366">       }</span>
<a href="#l3.367"></a><span id="l3.367">     }</span>
<a href="#l3.368"></a><span id="l3.368">     // If we don't flush the update, no one will!</span>
<a href="#l3.369"></a><span id="l3.369">     if (updateGlodaIds.length)</span>
<a href="#l3.370"></a><span id="l3.370">       GlodaDatastore.updateMessageLocations(updateGlodaIds,</span>
<a href="#l3.371"></a><span id="l3.371">                                             updateMessageKeys,</span>
<a href="#l3.372"></a><span id="l3.372">                                             aJob.id, true);</span>
<a href="#l3.373"></a><span id="l3.373" class="difflineplus">+    if (deleteGlodaIds.length)</span>
<a href="#l3.374"></a><span id="l3.374" class="difflineplus">+      GlodaDatastore.markMessagesDeletedByIDs(deleteGlodaIds);</span>
<a href="#l3.375"></a><span id="l3.375" class="difflineplus">+</span>
<a href="#l3.376"></a><span id="l3.376" class="difflineplus">+    this._indexingGlodaFolder._setCompactedState(false);</span>
<a href="#l3.377"></a><span id="l3.377"> </span>
<a href="#l3.378"></a><span id="l3.378">     this._indexerLeaveFolder();</span>
<a href="#l3.379"></a><span id="l3.379">     yield this.kWorkDone;</span>
<a href="#l3.380"></a><span id="l3.380">   },</span>
<a href="#l3.381"></a><span id="l3.381"> </span>
<a href="#l3.382"></a><span id="l3.382">   /**</span>
<a href="#l3.383"></a><span id="l3.383">    * Index the contents of a folder.</span>
<a href="#l3.384"></a><span id="l3.384">    */</span>
<a href="#l3.385"></a><span id="l3.385" class="difflineat">@@ -1237,17 +1270,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.386"></a><span id="l3.386">     //  dirty property.  Once we have done this, we can downgrade the folder's</span>
<a href="#l3.387"></a><span id="l3.387">     //  dirty status to plain dirty.  We do this rather than trying to process</span>
<a href="#l3.388"></a><span id="l3.388">     //  everyone in one go in a filthy context because if we have to terminate</span>
<a href="#l3.389"></a><span id="l3.389">     //  indexing before we quit, we don't want to have to re-index messages next</span>
<a href="#l3.390"></a><span id="l3.390">     //  time.  (This could even lead to never completing indexing in a</span>
<a href="#l3.391"></a><span id="l3.391">     //  pathological situation.)</span>
<a href="#l3.392"></a><span id="l3.392">     let glodaFolder = GlodaDatastore._mapFolder(this._indexingFolder);</span>
<a href="#l3.393"></a><span id="l3.393">     if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy) {</span>
<a href="#l3.394"></a><span id="l3.394" class="difflineminus">-      this._indexerGetEnumerator(this.kEnumIndexedMsgs);</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineplus">+      this._indexerGetEnumerator(this.kEnumIndexedMsgs, true);</span>
<a href="#l3.396"></a><span id="l3.396">       let count = 0;</span>
<a href="#l3.397"></a><span id="l3.397">       for (let msgHdr in fixIterator(this._indexingEnumerator, nsIMsgDBHdr)) {</span>
<a href="#l3.398"></a><span id="l3.398">         // we still need to avoid locking up the UI, pause periodically...</span>
<a href="#l3.399"></a><span id="l3.399">         if (++count % HEADER_CHECK_SYNC_BLOCK_SIZE == 0)</span>
<a href="#l3.400"></a><span id="l3.400">           yield this.kWorkSync;</span>
<a href="#l3.401"></a><span id="l3.401"> </span>
<a href="#l3.402"></a><span id="l3.402">         if (count % HEADER_CHECK_GC_BLOCK_SIZE == 0)</span>
<a href="#l3.403"></a><span id="l3.403">           GlodaUtils.considerHeaderBasedGC(HEADER_CHECK_GC_BLOCK_SIZE);</span>
<a href="#l3.404"></a><span id="l3.404" class="difflineat">@@ -1259,17 +1292,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.405"></a><span id="l3.405">           msgHdr.setUint32Property(GLODA_DIRTY_PROPERTY, this.kMessageFilthy);</span>
<a href="#l3.406"></a><span id="l3.406">         // if it doesn't have a gloda message id, we will definitely index it,</span>
<a href="#l3.407"></a><span id="l3.407">         //  so no action is required.</span>
<a href="#l3.408"></a><span id="l3.408">       }</span>
<a href="#l3.409"></a><span id="l3.409">       // Commit the filthy status changes to the message database.</span>
<a href="#l3.410"></a><span id="l3.410">       this._indexingDatabase.Commit(Ci.nsMsgDBCommitType.kLargeCommit);</span>
<a href="#l3.411"></a><span id="l3.411"> </span>
<a href="#l3.412"></a><span id="l3.412">       // this will automatically persist to the database</span>
<a href="#l3.413"></a><span id="l3.413" class="difflineminus">-      glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l3.414"></a><span id="l3.414" class="difflineplus">+      glodaFolder._downgradeDirtyStatus(glodaFolder.kFolderDirty);</span>
<a href="#l3.415"></a><span id="l3.415">     }</span>
<a href="#l3.416"></a><span id="l3.416"> </span>
<a href="#l3.417"></a><span id="l3.417">     // Pass 1: count the number of messages to index.</span>
<a href="#l3.418"></a><span id="l3.418">     //  We do this in order to be able to report to the user what we're doing.</span>
<a href="#l3.419"></a><span id="l3.419">     // TODO: give up after reaching a certain number of messages in folders</span>
<a href="#l3.420"></a><span id="l3.420">     //  with ridiculous numbers of messages and make the interface just say</span>
<a href="#l3.421"></a><span id="l3.421">     //  something like &quot;over N messages to go.&quot;</span>
<a href="#l3.422"></a><span id="l3.422"> </span>
<a href="#l3.423"></a><span id="l3.423" class="difflineat">@@ -1328,17 +1361,23 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.424"></a><span id="l3.424">         yield aCallbackHandle.pushAndGo(</span>
<a href="#l3.425"></a><span id="l3.425">           this._indexMessage(msgHdr, aCallbackHandle),</span>
<a href="#l3.426"></a><span id="l3.426">           {what: &quot;indexMessage&quot;, msgHdr: msgHdr});</span>
<a href="#l3.427"></a><span id="l3.427">         if (logDebug)</span>
<a href="#l3.428"></a><span id="l3.428">           this._log.debug(&quot;&lt;&lt;&lt;  _indexMessage&quot;);</span>
<a href="#l3.429"></a><span id="l3.429">       }</span>
<a href="#l3.430"></a><span id="l3.430">     }</span>
<a href="#l3.431"></a><span id="l3.431"> </span>
<a href="#l3.432"></a><span id="l3.432" class="difflineminus">-    glodaFolder.dirtyStatus = glodaFolder.kFolderClean;</span>
<a href="#l3.433"></a><span id="l3.433" class="difflineplus">+    // This will trigger an (async) db update which cannot hit the disk prior to</span>
<a href="#l3.434"></a><span id="l3.434" class="difflineplus">+    //  the actual database records that constitute the clean state.</span>
<a href="#l3.435"></a><span id="l3.435" class="difflineplus">+    // XXX There is the slight possibility that, in the event of a crash, this</span>
<a href="#l3.436"></a><span id="l3.436" class="difflineplus">+    //  will hit the disk but the gloda-id properties on the headers will not</span>
<a href="#l3.437"></a><span id="l3.437" class="difflineplus">+    //  get set.  This should ideally be resolved by detecting a non-clean</span>
<a href="#l3.438"></a><span id="l3.438" class="difflineplus">+    //  shutdown and marking all folders as dirty.</span>
<a href="#l3.439"></a><span id="l3.439" class="difflineplus">+    glodaFolder._downgradeDirtyStatus(glodaFolder.kFolderClean);</span>
<a href="#l3.440"></a><span id="l3.440"> </span>
<a href="#l3.441"></a><span id="l3.441">     // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l3.442"></a><span id="l3.442">     this._indexerLeaveFolder();</span>
<a href="#l3.443"></a><span id="l3.443"> </span>
<a href="#l3.444"></a><span id="l3.444">     yield this.kWorkDone;</span>
<a href="#l3.445"></a><span id="l3.445">   },</span>
<a href="#l3.446"></a><span id="l3.446"> </span>
<a href="#l3.447"></a><span id="l3.447">   /**</span>
<a href="#l3.448"></a><span id="l3.448" class="difflineat">@@ -1380,20 +1419,21 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.449"></a><span id="l3.449"> </span>
<a href="#l3.450"></a><span id="l3.450">       let glodaFolderId = item[0];</span>
<a href="#l3.451"></a><span id="l3.451">       // If the folder has been deleted since we queued, skip this message</span>
<a href="#l3.452"></a><span id="l3.452">       if (!GlodaDatastore._folderIdKnown(glodaFolderId))</span>
<a href="#l3.453"></a><span id="l3.453">         continue;</span>
<a href="#l3.454"></a><span id="l3.454">       let glodaFolder = GlodaDatastore._mapFolderID(glodaFolderId);</span>
<a href="#l3.455"></a><span id="l3.455"> </span>
<a href="#l3.456"></a><span id="l3.456">       // Stay out of folders that:</span>
<a href="#l3.457"></a><span id="l3.457" class="difflineminus">-      // - are compacting</span>
<a href="#l3.458"></a><span id="l3.458" class="difflineplus">+      // - are compacting / compacted and not yet processed</span>
<a href="#l3.459"></a><span id="l3.459">       // - got deleted (this would be redundant if we had a stance on id nukage)</span>
<a href="#l3.460"></a><span id="l3.460">       // (these things could have changed since we queued the event)</span>
<a href="#l3.461"></a><span id="l3.461" class="difflineminus">-      if (glodaFolder.compacting || glodaFolder._deleted)</span>
<a href="#l3.462"></a><span id="l3.462" class="difflineplus">+      if (glodaFolder.compacting || glodaFolder.compacted ||</span>
<a href="#l3.463"></a><span id="l3.463" class="difflineplus">+          glodaFolder._deleted)</span>
<a href="#l3.464"></a><span id="l3.464">         continue;</span>
<a href="#l3.465"></a><span id="l3.465"> </span>
<a href="#l3.466"></a><span id="l3.466">       // get in the folder</span>
<a href="#l3.467"></a><span id="l3.467">       if (this._indexingGlodaFolder != glodaFolder) {</span>
<a href="#l3.468"></a><span id="l3.468">         yield this._indexerEnterFolder(glodaFolderId);</span>
<a href="#l3.469"></a><span id="l3.469"> </span>
<a href="#l3.470"></a><span id="l3.470">         // Now that we have the real nsIMsgFolder, sanity-check that we should</span>
<a href="#l3.471"></a><span id="l3.471">         //  be indexing it.  (There are some checks that require the</span>
<a href="#l3.472"></a><span id="l3.472" class="difflineat">@@ -1597,18 +1637,18 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.473"></a><span id="l3.473">     }</span>
<a href="#l3.474"></a><span id="l3.474">   },</span>
<a href="#l3.475"></a><span id="l3.475"> </span>
<a href="#l3.476"></a><span id="l3.476">   /**</span>
<a href="#l3.477"></a><span id="l3.477">    * Queue a single folder for indexing given an nsIMsgFolder.</span>
<a href="#l3.478"></a><span id="l3.478">    */</span>
<a href="#l3.479"></a><span id="l3.479">   indexFolder: function glodaIndexFolder(aMsgFolder) {</span>
<a href="#l3.480"></a><span id="l3.480">     let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineminus">-    // stay out of compacting folders</span>
<a href="#l3.482"></a><span id="l3.482" class="difflineminus">-    if (glodaFolder.compacting)</span>
<a href="#l3.483"></a><span id="l3.483" class="difflineplus">+    // stay out of compacting/compacted folders</span>
<a href="#l3.484"></a><span id="l3.484" class="difflineplus">+    if (glodaFolder.compacting || glodaFolder.compacted)</span>
<a href="#l3.485"></a><span id="l3.485">       return;</span>
<a href="#l3.486"></a><span id="l3.486"> </span>
<a href="#l3.487"></a><span id="l3.487">     this._log.info(&quot;Queue-ing folder for indexing: &quot; +</span>
<a href="#l3.488"></a><span id="l3.488">                    aMsgFolder.prettiestName);</span>
<a href="#l3.489"></a><span id="l3.489">     GlodaIndexer.indexJob(new IndexingJob(&quot;folder&quot;, glodaFolder.id));</span>
<a href="#l3.490"></a><span id="l3.490">   },</span>
<a href="#l3.491"></a><span id="l3.491"> </span>
<a href="#l3.492"></a><span id="l3.492">   /**</span>
<a href="#l3.493"></a><span id="l3.493" class="difflineat">@@ -1660,16 +1700,22 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.494"></a><span id="l3.494">     aMsgHdrs) {</span>
<a href="#l3.495"></a><span id="l3.495">     let glodaIdsNeedingDeletion = null;</span>
<a href="#l3.496"></a><span id="l3.496">     for each (let msgHdr in fixIterator(aMsgHdrs, nsIMsgDBHdr)) {</span>
<a href="#l3.497"></a><span id="l3.497">       // -- Index this folder?</span>
<a href="#l3.498"></a><span id="l3.498">       let msgFolder = msgHdr.folder;</span>
<a href="#l3.499"></a><span id="l3.499">       if (!this.shouldIndexFolder(msgFolder)) {</span>
<a href="#l3.500"></a><span id="l3.500">         continue;</span>
<a href="#l3.501"></a><span id="l3.501">       }</span>
<a href="#l3.502"></a><span id="l3.502" class="difflineplus">+      // -- Ignore messages in filthy folders!</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineplus">+      // A filthy folder can only be processed by an indexing sweep, and at</span>
<a href="#l3.504"></a><span id="l3.504" class="difflineplus">+      //  that point the message will get indexed.</span>
<a href="#l3.505"></a><span id="l3.505" class="difflineplus">+      let glodaFolder = GlodaDatastore._mapFolder(msgHdr.folder);</span>
<a href="#l3.506"></a><span id="l3.506" class="difflineplus">+      if (glodaFolder.dirtyStatus == glodaFolder.kFolderFilthy)</span>
<a href="#l3.507"></a><span id="l3.507" class="difflineplus">+        continue;</span>
<a href="#l3.508"></a><span id="l3.508"> </span>
<a href="#l3.509"></a><span id="l3.509">       // -- Index this message?</span>
<a href="#l3.510"></a><span id="l3.510">       // We index local messages, IMAP messages that are offline, and IMAP</span>
<a href="#l3.511"></a><span id="l3.511">       // messages that aren't offline but whose folders aren't offline either</span>
<a href="#l3.512"></a><span id="l3.512">       let isFolderLocal = msgFolder instanceof nsIMsgLocalMailFolder;</span>
<a href="#l3.513"></a><span id="l3.513">       if (!isFolderLocal) {</span>
<a href="#l3.514"></a><span id="l3.514">         if (!(msgHdr.flags &amp; nsMsgMessageFlags.Offline) &amp;&amp;</span>
<a href="#l3.515"></a><span id="l3.515">             (msgFolder.flags &amp; nsMsgFolderFlags.Offline)) {</span>
<a href="#l3.516"></a><span id="l3.516" class="difflineat">@@ -1708,18 +1754,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.517"></a><span id="l3.517">       }</span>
<a href="#l3.518"></a><span id="l3.518">       // If it's not indexed but is spam, ignore it.</span>
<a href="#l3.519"></a><span id="l3.519">       else if (isSpam) {</span>
<a href="#l3.520"></a><span id="l3.520">         continue;</span>
<a href="#l3.521"></a><span id="l3.521">       }</span>
<a href="#l3.522"></a><span id="l3.522">       // (we want to index the message if we are here)</span>
<a href="#l3.523"></a><span id="l3.523"> </span>
<a href="#l3.524"></a><span id="l3.524">       // mark the folder dirty too, so we know to look inside</span>
<a href="#l3.525"></a><span id="l3.525" class="difflineminus">-      let glodaFolder = GlodaDatastore._mapFolder(msgFolder);</span>
<a href="#l3.526"></a><span id="l3.526" class="difflineminus">-      glodaFolder.dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l3.527"></a><span id="l3.527" class="difflineplus">+      glodaFolder._ensureFolderDirty();</span>
<a href="#l3.528"></a><span id="l3.528"> </span>
<a href="#l3.529"></a><span id="l3.529">       if (this._pendingAddJob == null) {</span>
<a href="#l3.530"></a><span id="l3.530">         this._pendingAddJob = new IndexingJob(&quot;message&quot;, null);</span>
<a href="#l3.531"></a><span id="l3.531">         GlodaIndexer.indexJob(this._pendingAddJob);</span>
<a href="#l3.532"></a><span id="l3.532">       }</span>
<a href="#l3.533"></a><span id="l3.533">       // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l3.534"></a><span id="l3.534">       if (this._pendingAddJob.items.length &lt;</span>
<a href="#l3.535"></a><span id="l3.535">           this._indexMaxEventQueueMessages) {</span>
<a href="#l3.536"></a><span id="l3.536" class="difflineat">@@ -1829,17 +1874,30 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.537"></a><span id="l3.537">      *  supposed to be indexed by clearing the pending attributes for the header</span>
<a href="#l3.538"></a><span id="l3.538">      *  being tracked by the destination IMAP folder.</span>
<a href="#l3.539"></a><span id="l3.539">      * XXX We will receive a msgsClassified event for each message, so the</span>
<a href="#l3.540"></a><span id="l3.540">      *  main thing we need to do is provide a hint to the indexing logic that</span>
<a href="#l3.541"></a><span id="l3.541">      *  the gloda message in question should be reused and is not a duplicate.</span>
<a href="#l3.542"></a><span id="l3.542">      * We could fast-path the IMAP move case in msgsClassified by noticing that</span>
<a href="#l3.543"></a><span id="l3.543">      *  a message is showing up with a gloda-id header already and just</span>
<a href="#l3.544"></a><span id="l3.544">      *  performing an async location update.</span>
<a href="#l3.545"></a><span id="l3.545" class="difflineminus">-</span>
<a href="#l3.546"></a><span id="l3.546" class="difflineplus">+     *</span>
<a href="#l3.547"></a><span id="l3.547" class="difflineplus">+     * Moves that occur involving 'compacted' folders are fine and do not</span>
<a href="#l3.548"></a><span id="l3.548" class="difflineplus">+     *  require special handling here.  The one tricky super-edge-case that</span>
<a href="#l3.549"></a><span id="l3.549" class="difflineplus">+     *  can happen (and gets handled by the compaction pass) is the move of a</span>
<a href="#l3.550"></a><span id="l3.550" class="difflineplus">+     *  message that got gloda indexed that did not already have a gloda-id and</span>
<a href="#l3.551"></a><span id="l3.551" class="difflineplus">+     *  PendingCommitTracker did not get to flush the gloda-id before the</span>
<a href="#l3.552"></a><span id="l3.552" class="difflineplus">+     *  compaction happened.  In that case our move logic cannot know to do</span>
<a href="#l3.553"></a><span id="l3.553" class="difflineplus">+     *  anything and the gloda database still thinks the message lives in our</span>
<a href="#l3.554"></a><span id="l3.554" class="difflineplus">+     *  folder.  The compaction pass will deal with this by marking the message</span>
<a href="#l3.555"></a><span id="l3.555" class="difflineplus">+     *  as deleted.  The rationale being that marking it deleted allows the</span>
<a href="#l3.556"></a><span id="l3.556" class="difflineplus">+     *  message to be re-used if it gets indexed in the target location, or if</span>
<a href="#l3.557"></a><span id="l3.557" class="difflineplus">+     *  the target location has already been indexed, we no longer need the</span>
<a href="#l3.558"></a><span id="l3.558" class="difflineplus">+     *  duplicate and it should be deleted.  (Also, it is unable to distinguish</span>
<a href="#l3.559"></a><span id="l3.559" class="difflineplus">+     *  between a case where the message got deleted versus moved.)</span>
<a href="#l3.560"></a><span id="l3.560">      *</span>
<a href="#l3.561"></a><span id="l3.561">      * Because copied messages are, by their nature, duplicate messages, we</span>
<a href="#l3.562"></a><span id="l3.562">      *  do not particularly care about them.  As such, we defer their processing</span>
<a href="#l3.563"></a><span id="l3.563">      *  to the automatic sync logic that will happen much later on.  This is</span>
<a href="#l3.564"></a><span id="l3.564">      *  potentially desirable in case the user deletes some of the original</span>
<a href="#l3.565"></a><span id="l3.565">      *  messages, allowing us to reuse the gloda message representations when</span>
<a href="#l3.566"></a><span id="l3.566">      *  we finally get around to indexing the messages.  We do need to mark the</span>
<a href="#l3.567"></a><span id="l3.567">      *  folder as dirty, though, to clue in the sync logic.</span>
<a href="#l3.568"></a><span id="l3.568" class="difflineat">@@ -1925,37 +1983,51 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.569"></a><span id="l3.569">           // --- Have destination headers (local case):</span>
<a href="#l3.570"></a><span id="l3.570">           if (aDestMsgHdrs) {</span>
<a href="#l3.571"></a><span id="l3.571">             // -- Update message keys for valid gloda-id's.</span>
<a href="#l3.572"></a><span id="l3.572">             // (Which means ignore filthy gloda-id's.)</span>
<a href="#l3.573"></a><span id="l3.573">             let glodaIds = [];</span>
<a href="#l3.574"></a><span id="l3.574">             let newMessageKeys = [];</span>
<a href="#l3.575"></a><span id="l3.575">             aSrcMsgHdrs.QueryInterface(nsIArray);</span>
<a href="#l3.576"></a><span id="l3.576">             aDestMsgHdrs.QueryInterface(nsIArray);</span>
<a href="#l3.577"></a><span id="l3.577" class="difflineplus">+            // Track whether we see any messages that are not gloda indexed so</span>
<a href="#l3.578"></a><span id="l3.578" class="difflineplus">+            //  we know if we have to mark the destination folder dirty.</span>
<a href="#l3.579"></a><span id="l3.579" class="difflineplus">+            let sawNonGlodaMessage = false;</span>
<a href="#l3.580"></a><span id="l3.580">             for (let iMsg = 0; iMsg &lt; aSrcMsgHdrs.length; iMsg++) {</span>
<a href="#l3.581"></a><span id="l3.581">               let srcMsgHdr = aSrcMsgHdrs.queryElementAt(iMsg, nsIMsgDBHdr);</span>
<a href="#l3.582"></a><span id="l3.582">               let destMsgHdr = aDestMsgHdrs.queryElementAt(iMsg, nsIMsgDBHdr);</span>
<a href="#l3.583"></a><span id="l3.583"> </span>
<a href="#l3.584"></a><span id="l3.584">               let [glodaId, dirtyStatus] =</span>
<a href="#l3.585"></a><span id="l3.585">                 PendingCommitTracker.getGlodaState(srcMsgHdr);</span>
<a href="#l3.586"></a><span id="l3.586">               if (glodaId &gt;= GLODA_FIRST_VALID_MESSAGE_ID &amp;&amp;</span>
<a href="#l3.587"></a><span id="l3.587">                   dirtyStatus != GlodaMsgIndexer.kMessageFilthy) {</span>
<a href="#l3.588"></a><span id="l3.588">                 // we may need to update the pending commit map (it checks)</span>
<a href="#l3.589"></a><span id="l3.589">                 PendingCommitTracker.noteMove(srcMsgHdr, destMsgHdr);</span>
<a href="#l3.590"></a><span id="l3.590">                 // but we always need to update our database</span>
<a href="#l3.591"></a><span id="l3.591">                 glodaIds.push(glodaId);</span>
<a href="#l3.592"></a><span id="l3.592">                 newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l3.593"></a><span id="l3.593">               }</span>
<a href="#l3.594"></a><span id="l3.594" class="difflineplus">+              else {</span>
<a href="#l3.595"></a><span id="l3.595" class="difflineplus">+                sawNonGlodaMessage = true;</span>
<a href="#l3.596"></a><span id="l3.596" class="difflineplus">+              }</span>
<a href="#l3.597"></a><span id="l3.597">             }</span>
<a href="#l3.598"></a><span id="l3.598"> </span>
<a href="#l3.599"></a><span id="l3.599">             // this method takes care to update the in-memory representations</span>
<a href="#l3.600"></a><span id="l3.600">             //  too; we don't need to do anything</span>
<a href="#l3.601"></a><span id="l3.601">             if (glodaIds.length)</span>
<a href="#l3.602"></a><span id="l3.602">               GlodaDatastore.updateMessageLocations(glodaIds, newMessageKeys,</span>
<a href="#l3.603"></a><span id="l3.603">                                                     aDestFolder);</span>
<a href="#l3.604"></a><span id="l3.604" class="difflineplus">+</span>
<a href="#l3.605"></a><span id="l3.605" class="difflineplus">+            // Mark the destination folder dirty if we saw any messages that</span>
<a href="#l3.606"></a><span id="l3.606" class="difflineplus">+            //  were not already gloda indexed.</span>
<a href="#l3.607"></a><span id="l3.607" class="difflineplus">+            if (sawNonGlodaMessage) {</span>
<a href="#l3.608"></a><span id="l3.608" class="difflineplus">+              let destGlodaFolder = GlodaDatastore._mapFolder(aDestFolder);</span>
<a href="#l3.609"></a><span id="l3.609" class="difflineplus">+              destGlodaFolder._ensureFolderDirty();</span>
<a href="#l3.610"></a><span id="l3.610" class="difflineplus">+              this.indexer.indexingSweepNeeded = true;</span>
<a href="#l3.611"></a><span id="l3.611" class="difflineplus">+            }</span>
<a href="#l3.612"></a><span id="l3.612">           }</span>
<a href="#l3.613"></a><span id="l3.613">           // --- No dest headers (IMAP case):</span>
<a href="#l3.614"></a><span id="l3.614">           // Update any valid gloda indexed messages into their new folder to</span>
<a href="#l3.615"></a><span id="l3.615">           //  make the indexer's life easier when it sees the messages in their</span>
<a href="#l3.616"></a><span id="l3.616">           //  new folder.</span>
<a href="#l3.617"></a><span id="l3.617">           else {</span>
<a href="#l3.618"></a><span id="l3.618">             let glodaIds = [];</span>
<a href="#l3.619"></a><span id="l3.619"> </span>
<a href="#l3.620"></a><span id="l3.620" class="difflineat">@@ -1991,17 +2063,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.621"></a><span id="l3.621">                 GLODA_MESSAGE_ID_PROPERTY);</span>
<a href="#l3.622"></a><span id="l3.622">               if (glodaId)</span>
<a href="#l3.623"></a><span id="l3.623">                 destMsgHdr.setUint32Property(GLODA_MESSAGE_ID_PROPERTY, 0);</span>
<a href="#l3.624"></a><span id="l3.624">             }</span>
<a href="#l3.625"></a><span id="l3.625">           }</span>
<a href="#l3.626"></a><span id="l3.626"> </span>
<a href="#l3.627"></a><span id="l3.627">           // mark the folder as dirty; we'll get to it later.</span>
<a href="#l3.628"></a><span id="l3.628">           let destGlodaFolder = GlodaDatastore._mapFolder(aDestFolder);</span>
<a href="#l3.629"></a><span id="l3.629" class="difflineminus">-          destGlodaFolder.dirtyStatus = destGlodaFolder.kFolderDirty;</span>
<a href="#l3.630"></a><span id="l3.630" class="difflineplus">+          destGlodaFolder._ensureFolderDirty();</span>
<a href="#l3.631"></a><span id="l3.631">           this.indexer.indexingSweepNeeded = true;</span>
<a href="#l3.632"></a><span id="l3.632">         }</span>
<a href="#l3.633"></a><span id="l3.633">       } catch (ex) {</span>
<a href="#l3.634"></a><span id="l3.634">         this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l3.635"></a><span id="l3.635">           &quot;: &quot; + ex + &quot;\n\n&quot; + ex.stack + &quot;\n\n&quot;);</span>
<a href="#l3.636"></a><span id="l3.636">       }</span>
<a href="#l3.637"></a><span id="l3.637">     },</span>
<a href="#l3.638"></a><span id="l3.638"> </span>
<a href="#l3.639"></a><span id="l3.639" class="difflineat">@@ -2160,16 +2232,17 @@ var GlodaMsgIndexer = {</span>
<a href="#l3.640"></a><span id="l3.640">       else if (aEvent == &quot;FolderCompactFinish&quot;) {</span>
<a href="#l3.641"></a><span id="l3.641">         let aMsgFolder = aItem.QueryInterface(nsIMsgFolder);</span>
<a href="#l3.642"></a><span id="l3.642">         // ignore folders we ignore...</span>
<a href="#l3.643"></a><span id="l3.643">         if (!GlodaMsgIndexer.shouldIndexFolder(aMsgFolder))</span>
<a href="#l3.644"></a><span id="l3.644">           return;</span>
<a href="#l3.645"></a><span id="l3.645"> </span>
<a href="#l3.646"></a><span id="l3.646">         let glodaFolder = GlodaDatastore._mapFolder(aMsgFolder);</span>
<a href="#l3.647"></a><span id="l3.647">         glodaFolder.compacting = false;</span>
<a href="#l3.648"></a><span id="l3.648" class="difflineplus">+        glodaFolder._setCompactedState(true);</span>
<a href="#l3.649"></a><span id="l3.649"> </span>
<a href="#l3.650"></a><span id="l3.650">         // Queue compaction unless the folder was filthy (in which case there</span>
<a href="#l3.651"></a><span id="l3.651">         //  are no valid gloda-id's to update.)</span>
<a href="#l3.652"></a><span id="l3.652">         if (glodaFolder.dirtyStatus != glodaFolder.kFolderFilthy)</span>
<a href="#l3.653"></a><span id="l3.653">           GlodaIndexer.indexJob(</span>
<a href="#l3.654"></a><span id="l3.654">             new IndexingJob(&quot;folderCompact&quot;, glodaFolder.id));</span>
<a href="#l3.655"></a><span id="l3.655"> </span>
<a href="#l3.656"></a><span id="l3.656">         // Queue indexing of the folder if it is dirty.  We are doing this</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/base_index_messages.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -201,22 +201,55 @@ function test_indexing_sweep() {</span>
<a href="#l4.4"></a><span id="l4.4">   // IMPORTANT!  The trick of marking the folder filthy only works because</span>
<a href="#l4.5"></a><span id="l4.5">   //  we flushed/committed the database above; the PendingCommitTracker</span>
<a href="#l4.6"></a><span id="l4.6">   //  is not aware of bogus filthy-marking of folders.</span>
<a href="#l4.7"></a><span id="l4.7">   // We leave the verification of the implementation details to</span>
<a href="#l4.8"></a><span id="l4.8">   //  test_index_sweep_folder.js.</span>
<a href="#l4.9"></a><span id="l4.9">   mark_sub_test_start(&quot;filthy folder indexing&quot;);</span>
<a href="#l4.10"></a><span id="l4.10">   let glodaFolderC = Gloda.getFolderForFolder(</span>
<a href="#l4.11"></a><span id="l4.11">                        get_real_injection_folder(folderC));</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  glodaFolderC.dirtyStatus = glodaFolderC.kFolderFilthy;</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+  glodaFolderC._dirtyStatus = glodaFolderC.kFolderFilthy;</span>
<a href="#l4.14"></a><span id="l4.14">   mark_action(&quot;actual&quot;, &quot;marked gloda folder dirty&quot;, [glodaFolderC]);</span>
<a href="#l4.15"></a><span id="l4.15">   GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l4.16"></a><span id="l4.16">   yield wait_for_gloda_indexer([setC1, setC2]);</span>
<a href="#l4.17"></a><span id="l4.17"> }</span>
<a href="#l4.18"></a><span id="l4.18"> </span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+/**</span>
<a href="#l4.20"></a><span id="l4.20" class="difflineplus">+ * We used to screw up and downgrade filthy folders to dirty if we saw an event</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineplus">+ *  happen in the folder before we got to the folder; this tests that we no</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineplus">+ *  longer do that.</span>
<a href="#l4.23"></a><span id="l4.23" class="difflineplus">+ */</span>
<a href="#l4.24"></a><span id="l4.24" class="difflineplus">+function test_event_driven_indexing_does_not_mess_with_filthy_folders() {</span>
<a href="#l4.25"></a><span id="l4.25" class="difflineplus">+  // add a folder with a message.</span>
<a href="#l4.26"></a><span id="l4.26" class="difflineplus">+  let [folder, msgSet] = make_folder_with_sets([{count: 1}]);</span>
<a href="#l4.27"></a><span id="l4.27" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineplus">+  yield wait_for_gloda_indexer([msgSet]);</span>
<a href="#l4.29"></a><span id="l4.29" class="difflineplus">+</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineplus">+  // fake marking the folder filthy.</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+  let glodaFolder = Gloda.getFolderForFolder(get_real_injection_folder(folder));</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+  glodaFolder._dirtyStatus = glodaFolder.kFolderFilthy;</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+  // generate an event in the folder</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+  msgSet.setRead(true);</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+  // make sure the indexer did not do anything and the folder is still filthy.</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+  do_check_eq(glodaFolder._dirtyStatus, glodaFolder.kFolderFilthy);</span>
<a href="#l4.39"></a><span id="l4.39" class="difflineplus">+  // also, the message should not have actually gotten marked dirty</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineplus">+  do_check_eq(msgSet.getMsgHdr(0).getUint32Property(&quot;gloda-dirty&quot;), 0);</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineplus">+</span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+  // let's make the message un-read again for consistency with the gloda state</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineplus">+  msgSet.setRead(false);</span>
<a href="#l4.44"></a><span id="l4.44" class="difflineplus">+  // make the folder dirty and let an indexing sweep take care of this so we</span>
<a href="#l4.45"></a><span id="l4.45" class="difflineplus">+  //  don't get extra events in subsequent tests.</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineplus">+  glodaFolder._dirtyStatus = glodaFolder.kFolderDirty;</span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l4.48"></a><span id="l4.48" class="difflineplus">+  // (the message won't get indexed though)</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineplus">+  yield wait_for_gloda_indexer([]);</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+}</span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+</span>
<a href="#l4.52"></a><span id="l4.52"> /* ===== Threading / Conversation Grouping ===== */</span>
<a href="#l4.53"></a><span id="l4.53"> </span>
<a href="#l4.54"></a><span id="l4.54"> var gSynMessages = [];</span>
<a href="#l4.55"></a><span id="l4.55"> function allMessageInSameConversation(aSynthMessage, aGlodaMessage, aConvID) {</span>
<a href="#l4.56"></a><span id="l4.56">   if (aConvID === undefined)</span>
<a href="#l4.57"></a><span id="l4.57">     return aGlodaMessage.conversationID;</span>
<a href="#l4.58"></a><span id="l4.58">   do_check_eq(aConvID, aGlodaMessage.conversationID);</span>
<a href="#l4.59"></a><span id="l4.59">   // Cheat and stash the synthetic message (we need them for one of the IMAP</span>
<a href="#l4.60"></a><span id="l4.60" class="difflineat">@@ -808,16 +841,17 @@ function test_filthy_moves_slash_move_fr</span>
<a href="#l4.61"></a><span id="l4.61">   configure_gloda_indexing({});</span>
<a href="#l4.62"></a><span id="l4.62">   yield wait_for_gloda_indexer([msgSet]);</span>
<a href="#l4.63"></a><span id="l4.63"> }</span>
<a href="#l4.64"></a><span id="l4.64"> </span>
<a href="#l4.65"></a><span id="l4.65"> var tests = [</span>
<a href="#l4.66"></a><span id="l4.66">   test_pending_commit_tracker_flushes_correctly,</span>
<a href="#l4.67"></a><span id="l4.67">   test_pending_commit_causes_msgdb_commit,</span>
<a href="#l4.68"></a><span id="l4.68">   test_indexing_sweep,</span>
<a href="#l4.69"></a><span id="l4.69" class="difflineplus">+  test_event_driven_indexing_does_not_mess_with_filthy_folders,</span>
<a href="#l4.70"></a><span id="l4.70"> </span>
<a href="#l4.71"></a><span id="l4.71">   test_threading,</span>
<a href="#l4.72"></a><span id="l4.72">   test_attributes_fundamental,</span>
<a href="#l4.73"></a><span id="l4.73">   test_attributes_fundamental_from_disk,</span>
<a href="#l4.74"></a><span id="l4.74">   test_attributes_explicit,</span>
<a href="#l4.75"></a><span id="l4.75"> </span>
<a href="#l4.76"></a><span id="l4.76">   test_message_moving,</span>
<a href="#l4.77"></a><span id="l4.77"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/resources/glodaTestHelper.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -119,16 +119,32 @@ let throwingAppender = new Log4Moz.Throw</span>
<a href="#l5.4"></a><span id="l5.4"> throwingAppender.level = Log4Moz.Level.Warn;</span>
<a href="#l5.5"></a><span id="l5.5"> Log4Moz.repository.rootLogger.addAppender(throwingAppender);</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7"> var LOG = Log4Moz.repository.getLogger(&quot;gloda.test&quot;);</span>
<a href="#l5.8"></a><span id="l5.8"> </span>
<a href="#l5.9"></a><span id="l5.9"> // index_msg does not export this, so we need to provide it.</span>
<a href="#l5.10"></a><span id="l5.10"> const GLODA_BAD_MESSAGE_ID = 1;</span>
<a href="#l5.11"></a><span id="l5.11"> </span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+// -- Add a hook that makes folders not filthy when we first see them.</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+register_message_injection_listener({</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+  /**</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+   * By default all folders start out filthy.  This is great in the real world</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+   *  but I went and wrote all the unit tests without entirely thinking about</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+   *  how this affected said unit tests.  So we add a listener so that we can</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+   *  force the folders to be clean.</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+   * This is okay and safe because messageInjection always creates the folders</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+   *  without any messages in them.</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+   */</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+  onRealFolderCreated: function gth_onRealFolderCreated(aRealFolder) {</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+    let glodaFolder = Gloda.getFolderForFolder(aRealFolder);</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+    glodaFolder._downgradeDirtyStatus(glodaFolder.kFolderClean);</span>
<a href="#l5.25"></a><span id="l5.25" class="difflineplus">+  }</span>
<a href="#l5.26"></a><span id="l5.26" class="difflineplus">+});</span>
<a href="#l5.27"></a><span id="l5.27" class="difflineplus">+</span>
<a href="#l5.28"></a><span id="l5.28"> function _prepareIndexerForTesting() {</span>
<a href="#l5.29"></a><span id="l5.29">   if (!GlodaIndexer.enabled)</span>
<a href="#l5.30"></a><span id="l5.30">     do_throw(&quot;The gloda indexer is somehow not enabled.  This is problematic.&quot;);</span>
<a href="#l5.31"></a><span id="l5.31"> </span>
<a href="#l5.32"></a><span id="l5.32">   // Make the indexer be more verbose about indexing for us...</span>
<a href="#l5.33"></a><span id="l5.33">   GlodaIndexer._unitTestSuperVerbose = true;</span>
<a href="#l5.34"></a><span id="l5.34">   GlodaMsgIndexer._unitTestSuperVerbose = true;</span>
<a href="#l5.35"></a><span id="l5.35"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/db/gloda/test/unit/test_index_compaction.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/db/gloda/test/unit/test_index_compaction.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -41,16 +41,24 @@</span>
<a href="#l6.4"></a><span id="l6.4">  * - Compaction occurs while we are in the process of indexing a folder.  We</span>
<a href="#l6.5"></a><span id="l6.5">  *    want to make sure we stop indexing cleanly</span>
<a href="#l6.6"></a><span id="l6.6">  *</span>
<a href="#l6.7"></a><span id="l6.7">  * - A folder that we have already indexed gets compacted.  We want to make sure</span>
<a href="#l6.8"></a><span id="l6.8">  *    that we update the message keys for all involved.  This means verifying</span>
<a href="#l6.9"></a><span id="l6.9">  *    that both the on-disk representations and in-memory representations are</span>
<a href="#l6.10"></a><span id="l6.10">  *    correct.</span>
<a href="#l6.11"></a><span id="l6.11">  *</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineplus">+ * - Make sure that an indexing sweep performs a compaction pass if we kill the</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+ *    compaction job automatically scheduled by the conclusion of the</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+ *    compaction.  (Simulating the user quitting before all compactions have</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+ *    been processed.)</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+ *</span>
<a href="#l6.17"></a><span id="l6.17" class="difflineplus">+ * - Moves/deletes that happen after a compaction but before we process the</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineplus">+ *    compaction generate a special type of edge case that we need to check.</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+ *</span>
<a href="#l6.20"></a><span id="l6.20">  * There is also a less interesting case:</span>
<a href="#l6.21"></a><span id="l6.21">  *</span>
<a href="#l6.22"></a><span id="l6.22">  * - Make sure that the indexer does not try and start indexing a folder that is</span>
<a href="#l6.23"></a><span id="l6.23">  *    in the process of being compacted.</span>
<a href="#l6.24"></a><span id="l6.24">  */</span>
<a href="#l6.25"></a><span id="l6.25"> </span>
<a href="#l6.26"></a><span id="l6.26"> load(&quot;resources/glodaTestHelper.js&quot;);</span>
<a href="#l6.27"></a><span id="l6.27"> </span>
<a href="#l6.28"></a><span id="l6.28" class="difflineat">@@ -116,16 +124,115 @@ function test_compaction_indexing_pass(a</span>
<a href="#l6.29"></a><span id="l6.29">   // wait for the compaction job to complete</span>
<a href="#l6.30"></a><span id="l6.30">   yield wait_for_gloda_indexer();</span>
<a href="#l6.31"></a><span id="l6.31"> </span>
<a href="#l6.32"></a><span id="l6.32">   verify_message_keys(sameSet);</span>
<a href="#l6.33"></a><span id="l6.33">   verify_message_keys(shiftSet);</span>
<a href="#l6.34"></a><span id="l6.34"> }</span>
<a href="#l6.35"></a><span id="l6.35"> </span>
<a href="#l6.36"></a><span id="l6.36"> /**</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineplus">+ * Make sure that an indexing sweep performs a compaction pass if we kill the</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+ *  compaction job automatically scheduled by the conclusion of the compaction.</span>
<a href="#l6.39"></a><span id="l6.39" class="difflineplus">+ *  (Simulating the user quitting before all compactions have been processed.)</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+ */</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+function test_sweep_performs_compaction() {</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+  let [folder, moveSet, staySet] = make_folder_with_sets([</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+    {count: 1}, {count: 1}]);</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l6.45"></a><span id="l6.45" class="difflineplus">+  yield wait_for_gloda_indexer([moveSet, staySet], {augment: true});</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineplus">+</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+  // move the message to another folder</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+  let otherFolder = make_empty_folder();</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+  yield async_move_messages(moveSet, otherFolder);</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+  yield wait_for_gloda_indexer([moveSet]);</span>
<a href="#l6.51"></a><span id="l6.51" class="difflineplus">+</span>
<a href="#l6.52"></a><span id="l6.52" class="difflineplus">+  // compact</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineplus">+  let msgFolder = get_real_injection_folder(folder);</span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;triggering compaction&quot;,</span>
<a href="#l6.55"></a><span id="l6.55" class="difflineplus">+              [&quot;folder&quot;, msgFolder,</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineplus">+               &quot;gloda folder&quot;, Gloda.getFolderForFolder(msgFolder)]);</span>
<a href="#l6.57"></a><span id="l6.57" class="difflineplus">+  msgFolder.compact(asyncUrlListener, null);</span>
<a href="#l6.58"></a><span id="l6.58" class="difflineplus">+  yield false;</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineplus">+</span>
<a href="#l6.60"></a><span id="l6.60" class="difflineplus">+  // The gloda compaction job should not have started yet.  Kill it!  Kill them</span>
<a href="#l6.61"></a><span id="l6.61" class="difflineplus">+  //  all!</span>
<a href="#l6.62"></a><span id="l6.62" class="difflineplus">+  GlodaIndexer.purgeJobsUsingFilter(function() true);</span>
<a href="#l6.63"></a><span id="l6.63" class="difflineplus">+  GlodaIndexer.killActiveJob();</span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+  // Make sure the folder is marked compacted...</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineplus">+  let glodaFolder = Gloda.getFolderForFolder(msgFolder);</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineplus">+  do_check_true(glodaFolder.compacted);</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+  // Firing up an indexing pass</span>
<a href="#l6.70"></a><span id="l6.70" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+  yield wait_for_gloda_indexer();</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+  // Make sure the compaction happened</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+  verify_message_keys(staySet);</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+}</span>
<a href="#l6.76"></a><span id="l6.76" class="difflineplus">+</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineplus">+/**</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineplus">+ * Make sure that if we compact a folder then move messages out of it and/or</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineplus">+ *  delete messages from it before its compaction pass happens that the</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineplus">+ *  compaction pass properly marks the messages deleted.</span>
<a href="#l6.81"></a><span id="l6.81" class="difflineplus">+ */</span>
<a href="#l6.82"></a><span id="l6.82" class="difflineplus">+function test_moves_and_deletions_on_compacted_folder_edge_case() {</span>
<a href="#l6.83"></a><span id="l6.83" class="difflineplus">+  let [folder, compactMoveSet, moveSet, delSet, staySet] =</span>
<a href="#l6.84"></a><span id="l6.84" class="difflineplus">+    make_folder_with_sets([{count: 1}, {count: 1}, {count: 1}, {count: 1}]);</span>
<a href="#l6.85"></a><span id="l6.85" class="difflineplus">+  yield wait_for_message_injection();</span>
<a href="#l6.86"></a><span id="l6.86" class="difflineplus">+  yield wait_for_gloda_indexer([compactMoveSet, moveSet, delSet, staySet],</span>
<a href="#l6.87"></a><span id="l6.87" class="difflineplus">+                               {augment: true});</span>
<a href="#l6.88"></a><span id="l6.88" class="difflineplus">+</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineplus">+  // move the message to another folder</span>
<a href="#l6.90"></a><span id="l6.90" class="difflineplus">+  let otherFolder = make_empty_folder();</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineplus">+  yield async_move_messages(compactMoveSet, otherFolder);</span>
<a href="#l6.92"></a><span id="l6.92" class="difflineplus">+  yield wait_for_gloda_indexer([compactMoveSet]);</span>
<a href="#l6.93"></a><span id="l6.93" class="difflineplus">+</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineplus">+  // compact</span>
<a href="#l6.95"></a><span id="l6.95" class="difflineplus">+  let msgFolder = get_real_injection_folder(folder);</span>
<a href="#l6.96"></a><span id="l6.96" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;triggering compaction&quot;,</span>
<a href="#l6.97"></a><span id="l6.97" class="difflineplus">+              [&quot;folder&quot;, msgFolder,</span>
<a href="#l6.98"></a><span id="l6.98" class="difflineplus">+               &quot;gloda folder&quot;, Gloda.getFolderForFolder(msgFolder)]);</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineplus">+  msgFolder.compact(asyncUrlListener, null);</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineplus">+  yield false;</span>
<a href="#l6.101"></a><span id="l6.101" class="difflineplus">+</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineplus">+  // The gloda compaction job should not have started yet.  Kill it!  Kill them</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineplus">+  //  all!</span>
<a href="#l6.104"></a><span id="l6.104" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;killing all indexing jobs&quot;, []);</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineplus">+  GlodaIndexer.purgeJobsUsingFilter(function() true);</span>
<a href="#l6.106"></a><span id="l6.106" class="difflineplus">+  GlodaIndexer.killActiveJob();</span>
<a href="#l6.107"></a><span id="l6.107" class="difflineplus">+</span>
<a href="#l6.108"></a><span id="l6.108" class="difflineplus">+  // - Delete</span>
<a href="#l6.109"></a><span id="l6.109" class="difflineplus">+  // Becaus of the compaction, the PendingCommitTracker forgot that the message</span>
<a href="#l6.110"></a><span id="l6.110" class="difflineplus">+  //  we are deleting got indexed; we will receive no event.</span>
<a href="#l6.111"></a><span id="l6.111" class="difflineplus">+  yield async_delete_messages(delSet);</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineplus">+</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineplus">+  // - Move</span>
<a href="#l6.114"></a><span id="l6.114" class="difflineplus">+  // Same deal on the move, except that it will try and trigger event-based</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineplus">+  //  indexing in the target folder...</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineplus">+  yield async_move_messages(moveSet, otherFolder);</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineplus">+  // Kill the event-based indexing of the target; we want the indexing sweep</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineplus">+  //  to see it as a move.</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;killing all indexing jobs&quot;, []);</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+  GlodaIndexer.purgeJobsUsingFilter(function() true);</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineplus">+  GlodaIndexer.killActiveJob();</span>
<a href="#l6.122"></a><span id="l6.122" class="difflineplus">+</span>
<a href="#l6.123"></a><span id="l6.123" class="difflineplus">+  // - Indexing pass</span>
<a href="#l6.124"></a><span id="l6.124" class="difflineplus">+  // This will trigger compaction (per the previous unit test) which should mark</span>
<a href="#l6.125"></a><span id="l6.125" class="difflineplus">+  //  moveSet and delSet as deleted.  Then it should happen in to the next</span>
<a href="#l6.126"></a><span id="l6.126" class="difflineplus">+  //  folder and add moveSet again...</span>
<a href="#l6.127"></a><span id="l6.127" class="difflineplus">+  mark_action(&quot;actual&quot;, &quot;triggering indexing sweep&quot;, []);</span>
<a href="#l6.128"></a><span id="l6.128" class="difflineplus">+  GlodaMsgIndexer.indexingSweepNeeded = true;</span>
<a href="#l6.129"></a><span id="l6.129" class="difflineplus">+  yield wait_for_gloda_indexer([moveSet], {deleted: [moveSet, delSet]});</span>
<a href="#l6.130"></a><span id="l6.130" class="difflineplus">+</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineplus">+  // Sanity check the compaction for giggles.</span>
<a href="#l6.132"></a><span id="l6.132" class="difflineplus">+  verify_message_keys(staySet);</span>
<a href="#l6.133"></a><span id="l6.133" class="difflineplus">+}</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineplus">+</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineplus">+/**</span>
<a href="#l6.136"></a><span id="l6.136">  * Induce a compaction while we are in the middle of indexing.  Make sure we</span>
<a href="#l6.137"></a><span id="l6.137">  *  clean up and that the folder ends</span>
<a href="#l6.138"></a><span id="l6.138">  *</span>
<a href="#l6.139"></a><span id="l6.139">  * Note that in order for compaction to happen there has to be something for</span>
<a href="#l6.140"></a><span id="l6.140">  *  compaction to do, so our prep involves moving a message to another folder.</span>
<a href="#l6.141"></a><span id="l6.141">  *  (Deletion actually produces more legwork for gloda whereas a local move is</span>
<a href="#l6.142"></a><span id="l6.142">  *  almost entirely free.)</span>
<a href="#l6.143"></a><span id="l6.143">  */</span>
<a href="#l6.144"></a><span id="l6.144" class="difflineat">@@ -187,16 +294,18 @@ function test_do_not_enter_compacting_fo</span>
<a href="#l6.145"></a><span id="l6.145">   configure_gloda_indexing({event: true});</span>
<a href="#l6.146"></a><span id="l6.146"> </span>
<a href="#l6.147"></a><span id="l6.147">   // verify that the indexer completes without having indexed anything</span>
<a href="#l6.148"></a><span id="l6.148">   yield wait_for_gloda_indexer([]);</span>
<a href="#l6.149"></a><span id="l6.149"> }</span>
<a href="#l6.150"></a><span id="l6.150"> </span>
<a href="#l6.151"></a><span id="l6.151"> var tests = [</span>
<a href="#l6.152"></a><span id="l6.152">   parameterizeTest(test_compaction_indexing_pass, indexingPassPermutations),</span>
<a href="#l6.153"></a><span id="l6.153" class="difflineplus">+  test_sweep_performs_compaction,</span>
<a href="#l6.154"></a><span id="l6.154" class="difflineplus">+  test_moves_and_deletions_on_compacted_folder_edge_case,</span>
<a href="#l6.155"></a><span id="l6.155">   test_compaction_interrupting_indexing,</span>
<a href="#l6.156"></a><span id="l6.156">   test_do_not_enter_compacting_folders,</span>
<a href="#l6.157"></a><span id="l6.157"> ];</span>
<a href="#l6.158"></a><span id="l6.158"> </span>
<a href="#l6.159"></a><span id="l6.159"> function run_test() {</span>
<a href="#l6.160"></a><span id="l6.160">   configure_message_injection({mode: &quot;local&quot;});</span>
<a href="#l6.161"></a><span id="l6.161">   glodaHelperRunTests(tests);</span>
<a href="#l6.162"></a><span id="l6.162"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/test/resources/messageInjection.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/test/resources/messageInjection.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -107,16 +107,18 @@ function configure_message_injection(aIn</span>
<a href="#l7.4"></a><span id="l7.4">     mis.incomingServer = acctMgr.localFoldersServer;</span>
<a href="#l7.5"></a><span id="l7.5">     // Note: Inbox is not created automatically when there is no deferred server,</span>
<a href="#l7.6"></a><span id="l7.6">     // so we need to create it.</span>
<a href="#l7.7"></a><span id="l7.7">     mis.rootFolder = mis.incomingServer.rootMsgFolder;</span>
<a href="#l7.8"></a><span id="l7.8">     mis.inboxFolder = mis.rootFolder.addSubfolder(&quot;Inbox&quot;);</span>
<a href="#l7.9"></a><span id="l7.9">     // a local inbox should have a Mail flag!</span>
<a href="#l7.10"></a><span id="l7.10">     mis.inboxFolder.setFlag(Ci.nsMsgFolderFlags.Mail);</span>
<a href="#l7.11"></a><span id="l7.11">     mis.inboxFolder.setFlag(Ci.nsMsgFolderFlags.Inbox);</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+    _messageInjectionSetup.notifyListeners(&quot;onRealFolderCreated&quot;,</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+                                           [mis.inboxFolder]);</span>
<a href="#l7.14"></a><span id="l7.14"> </span>
<a href="#l7.15"></a><span id="l7.15">     // Force an initialization of the Inbox folder database.</span>
<a href="#l7.16"></a><span id="l7.16">     let unused = mis.inboxFolder.prettiestName;</span>
<a href="#l7.17"></a><span id="l7.17">   }</span>
<a href="#l7.18"></a><span id="l7.18">   else if (mis.injectionConfig.mode == &quot;imap&quot;) {</span>
<a href="#l7.19"></a><span id="l7.19">     const gPrefs = Cc[&quot;@mozilla.org/preferences-service;1&quot;]</span>
<a href="#l7.20"></a><span id="l7.20">                      .getService(Ci.nsIPrefBranch);</span>
<a href="#l7.21"></a><span id="l7.21">     // Disable autosync in favor of our explicitly forcing downloads of all</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -168,16 +170,18 @@ function configure_message_injection(aIn</span>
<a href="#l7.23"></a><span id="l7.23"> </span>
<a href="#l7.24"></a><span id="l7.24">     mis.inboxFolder = mis.rootFolder.getChildNamed(&quot;Inbox&quot;);</span>
<a href="#l7.25"></a><span id="l7.25">     // make sure the inbox's offline state is correct. (may be excessive now</span>
<a href="#l7.26"></a><span id="l7.26">     //  that we set the pref above?)</span>
<a href="#l7.27"></a><span id="l7.27">     if (mis.injectionConfig.offline)</span>
<a href="#l7.28"></a><span id="l7.28">       mis.inboxFolder.setFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l7.29"></a><span id="l7.29">     else</span>
<a href="#l7.30"></a><span id="l7.30">       mis.inboxFolder.clearFlag(Ci.nsMsgFolderFlags.Offline);</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineplus">+    _messageInjectionSetup.notifyListeners(&quot;onRealFolderCreated&quot;,</span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+                                           [mis.inboxFolder]);</span>
<a href="#l7.33"></a><span id="l7.33"> </span>
<a href="#l7.34"></a><span id="l7.34">     mis.mainThread = Cc[&quot;@mozilla.org/thread-manager;1&quot;]</span>
<a href="#l7.35"></a><span id="l7.35">                        .getService()</span>
<a href="#l7.36"></a><span id="l7.36">                        .mainThread;</span>
<a href="#l7.37"></a><span id="l7.37">     mis.imapService = Cc[&quot;@mozilla.org/messenger/imapservice;1&quot;]</span>
<a href="#l7.38"></a><span id="l7.38">                         .getService(Ci.nsIImapService);</span>
<a href="#l7.39"></a><span id="l7.39"> </span>
<a href="#l7.40"></a><span id="l7.40">     mis.handleUriToRealFolder = {};</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

