<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 4505:4b63c4badb42c8b08b4212f195659943630b95cc</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 4b63c4badb42c8b08b4212f195659943630b95cc" />
<meta property="og:url" content="/comm-central/rev/4b63c4badb42c8b08b4212f195659943630b95cc" />
<meta property="og:description" content="Bug 517726 Update history viewers to deal with Places API changes r=IanN" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 4b63c4badb42c8b08b4212f195659943630b95cc 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/4b63c4badb42c8b08b4212f195659943630b95cc">shortlog</a> |
<a href="/comm-central/log/4b63c4badb42c8b08b4212f195659943630b95cc">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/4b63c4badb42c8b08b4212f195659943630b95cc">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/4b63c4badb42c8b08b4212f195659943630b95cc">files</a> |
changeset |
<a href="/comm-central/raw-rev/4b63c4badb42c8b08b4212f195659943630b95cc">raw</a>  | <a href="/comm-central/archive/4b63c4badb42c8b08b4212f195659943630b95cc.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=517726">Bug 517726</a> Update history viewers to deal with Places API changes r=IanN
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#78;&#101;&#105;&#108;&#32;&#82;&#97;&#115;&#104;&#98;&#114;&#111;&#111;&#107;&#32;&#60;&#110;&#101;&#105;&#108;&#64;&#112;&#97;&#114;&#107;&#119;&#97;&#121;&#99;&#99;&#46;&#99;&#111;&#46;&#117;&#107;&#62;</td></tr>
<tr><td></td><td class="date age">Tue, 08 Dec 2009 23:51:38 +0000</td></tr>

<tr>
 <td>changeset 4505</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/4b63c4badb42c8b08b4212f195659943630b95cc">4b63c4badb42c8b08b4212f195659943630b95cc</a></td>
</tr>



<tr>
<td>parent 4504</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/70338c4e8c39191878da1b5da8fa9bc367c4755d">70338c4e8c39191878da1b5da8fa9bc367c4755d</a>
</td>
</tr>

<tr>
<td>child 4506</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/3a201e2872acc7c3b40d379d991b6aa84da4dc27">3a201e2872acc7c3b40d379d991b6aa84da4dc27</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=4b63c4badb42c8b08b4212f195659943630b95cc">3515</a></td></tr>
<tr><td>push user</td><td>neil@parkwaycc.co.uk</td></tr>
<tr><td>push date</td><td class="date age">Tue, 08 Dec 2009 23:51:42 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@4b63c4badb42 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4b63c4badb42c8b08b4212f195659943630b95cc">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=4b63c4badb42c8b08b4212f195659943630b95cc&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4b63c4badb42c8b08b4212f195659943630b95cc&newProject=comm-central&newRevision=4b63c4badb42c8b08b4212f195659943630b95cc&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4b63c4badb42c8b08b4212f195659943630b95cc&newProject=comm-central&newRevision=4b63c4badb42c8b08b4212f195659943630b95cc&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=4b63c4badb42c8b08b4212f195659943630b95cc&newProject=comm-central&newRevision=4b63c4badb42c8b08b4212f195659943630b95cc&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28IanN%29&revcount=50">IanN</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=517726">517726</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=517726">Bug 517726</a> Update history viewers to deal with Places API changes r=IanN</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/4b63c4badb42c8b08b4212f195659943630b95cc/suite/common/history/treeView.js">suite/common/history/treeView.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/4b63c4badb42c8b08b4212f195659943630b95cc/suite/common/history/treeView.js">file</a> |
<a href="/comm-central/annotate/4b63c4badb42c8b08b4212f195659943630b95cc/suite/common/history/treeView.js">annotate</a> |
<a href="/comm-central/diff/4b63c4badb42c8b08b4212f195659943630b95cc/suite/common/history/treeView.js">diff</a> |
<a href="/comm-central/comparison/4b63c4badb42c8b08b4212f195659943630b95cc/suite/common/history/treeView.js">comparison</a> |
<a href="/comm-central/log/4b63c4badb42c8b08b4212f195659943630b95cc/suite/common/history/treeView.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/suite/common/history/treeView.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/suite/common/history/treeView.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -95,17 +95,17 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">     var qoInt = Components.interfaces.nsINavHistoryQueryOptions;</span>
<a href="#l1.5"></a><span id="l1.5">     var options = asQuery(this._result.root).queryOptions;</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7">     // if there is no tree, BuildVisibleList will clear everything for us</span>
<a href="#l1.8"></a><span id="l1.8">     this._buildVisibleList();</span>
<a href="#l1.9"></a><span id="l1.9">   },</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11">   /**</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-   * Call to completely rebuild the list of visible items. Note if there is no</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+   * Call to completely rebuild the list of visible nodes. Note if there is no</span>
<a href="#l1.14"></a><span id="l1.14">    * tree or root this will just clear out the list, so you can also call this</span>
<a href="#l1.15"></a><span id="l1.15">    * when a tree is detached to clear the list.</span>
<a href="#l1.16"></a><span id="l1.16">    */</span>
<a href="#l1.17"></a><span id="l1.17">   _buildVisibleList: function PTV__buildVisibleList() {</span>
<a href="#l1.18"></a><span id="l1.18">     var selection = this.selection;</span>
<a href="#l1.19"></a><span id="l1.19">     if (selection)</span>
<a href="#l1.20"></a><span id="l1.20">       selection.selectEventsSuppressed = true;</span>
<a href="#l1.21"></a><span id="l1.21"> </span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -152,17 +152,17 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.23"></a><span id="l1.23">     const openLiteral = PlacesUIUtils.RDF.GetResource(&quot;http://home.netscape.com/NC-rdf#open&quot;);</span>
<a href="#l1.24"></a><span id="l1.24">     const trueLiteral = PlacesUIUtils.RDF.GetLiteral(&quot;true&quot;);</span>
<a href="#l1.25"></a><span id="l1.25"> </span>
<a href="#l1.26"></a><span id="l1.26">     var cc = aContainer.childCount;</span>
<a href="#l1.27"></a><span id="l1.27">     for (var i=0; i &lt; cc; i++) {</span>
<a href="#l1.28"></a><span id="l1.28">       var curChild = aContainer.getChild(i);</span>
<a href="#l1.29"></a><span id="l1.29">       var curChildType = curChild.type;</span>
<a href="#l1.30"></a><span id="l1.30"> </span>
<a href="#l1.31"></a><span id="l1.31" class="difflineminus">-      // add item</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+      // add node</span>
<a href="#l1.33"></a><span id="l1.33">       curChild.viewIndex = aVisibleStartIndex + aVisible.length;</span>
<a href="#l1.34"></a><span id="l1.34">       aVisible.push({ node: curChild, properties: null });</span>
<a href="#l1.35"></a><span id="l1.35"> </span>
<a href="#l1.36"></a><span id="l1.36">       // recursively do containers</span>
<a href="#l1.37"></a><span id="l1.37">       if (PlacesUtils.containerTypes.indexOf(curChildType) != -1) {</span>
<a href="#l1.38"></a><span id="l1.38">         asContainer(curChild);</span>
<a href="#l1.39"></a><span id="l1.39"> </span>
<a href="#l1.40"></a><span id="l1.40">         var resource = this._getResourceForNode(curChild);</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineat">@@ -173,27 +173,27 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.42"></a><span id="l1.42">           aToOpen.push(curChild);</span>
<a href="#l1.43"></a><span id="l1.43">         else if (curChild.containerOpen &amp;&amp; curChild.childCount &gt; 0)</span>
<a href="#l1.44"></a><span id="l1.44">           this._buildVisibleSection(curChild, aVisible, aToOpen, aVisibleStartIndex);</span>
<a href="#l1.45"></a><span id="l1.45">       }</span>
<a href="#l1.46"></a><span id="l1.46">     }</span>
<a href="#l1.47"></a><span id="l1.47">   },</span>
<a href="#l1.48"></a><span id="l1.48"> </span>
<a href="#l1.49"></a><span id="l1.49">   /**</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineminus">-   * This counts how many rows an item takes in the tree, that is, the</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineminus">-   * item itself plus any nodes following it with an increased indent.</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineminus">-   * This allows you to figure out how many rows an item (=1) or a</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+   * This counts how many rows a node takes in the tree, that is, the</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+   * node itself plus any nodes following it with an increased indent.</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+   * This allows you to figure out how many rows a node (=1) or a</span>
<a href="#l1.56"></a><span id="l1.56">    * container with all of its children takes.</span>
<a href="#l1.57"></a><span id="l1.57">    */</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineminus">-  _countVisibleRowsForItem: function PTV__countVisibleRowsForItem(aNode) {</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+  _countVisibleRowsForNode: function PTV__countVisibleRowsForNode(aNode) {</span>
<a href="#l1.60"></a><span id="l1.60">     if (aNode == this._result.root)</span>
<a href="#l1.61"></a><span id="l1.61">       return this._visibleElements.length;</span>
<a href="#l1.62"></a><span id="l1.62"> </span>
<a href="#l1.63"></a><span id="l1.63">     var viewIndex = aNode.viewIndex;</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineminus">-    NS_ASSERT(viewIndex &gt;= 0, &quot;Item is not visible, no rows to count&quot;);</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+    NS_ASSERT(viewIndex &gt;= 0, &quot;Node is not visible, no rows to count&quot;);</span>
<a href="#l1.66"></a><span id="l1.66">     var outerLevel = aNode.indentLevel;</span>
<a href="#l1.67"></a><span id="l1.67">     for (var i = viewIndex + 1; i &lt; this._visibleElements.length; i++) {</span>
<a href="#l1.68"></a><span id="l1.68">       if (this._visibleElements[i].node.indentLevel &lt;= outerLevel)</span>
<a href="#l1.69"></a><span id="l1.69">         return i - viewIndex;</span>
<a href="#l1.70"></a><span id="l1.70">     }</span>
<a href="#l1.71"></a><span id="l1.71">     // this node plus its children occupy the bottom of the list</span>
<a href="#l1.72"></a><span id="l1.72">     return this._visibleElements.length - viewIndex;</span>
<a href="#l1.73"></a><span id="l1.73">   },</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineat">@@ -218,20 +218,20 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.75"></a><span id="l1.75">           aContainer.viewIndex &gt; this._visibleElements.length)</span>
<a href="#l1.76"></a><span id="l1.76">         throw &quot;Trying to expand a node that is not visible&quot;;</span>
<a href="#l1.77"></a><span id="l1.77"> </span>
<a href="#l1.78"></a><span id="l1.78">       NS_ASSERT(this._visibleElements[aContainer.viewIndex].node == aContainer,</span>
<a href="#l1.79"></a><span id="l1.79">                 &quot;Visible index is out of sync!&quot;);</span>
<a href="#l1.80"></a><span id="l1.80">     }</span>
<a href="#l1.81"></a><span id="l1.81"> </span>
<a href="#l1.82"></a><span id="l1.82">     var startReplacement = aContainer.viewIndex + 1;</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineminus">-    var replaceCount = this._countVisibleRowsForItem(aContainer);</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+    var replaceCount = this._countVisibleRowsForNode(aContainer);</span>
<a href="#l1.85"></a><span id="l1.85"> </span>
<a href="#l1.86"></a><span id="l1.86" class="difflineminus">-    // We don't replace the container item itself so we decrease the</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineminus">-    // replaceCount by 1. We don't do so though if there is no visible item</span>
<a href="#l1.88"></a><span id="l1.88" class="difflineplus">+    // We don't replace the container node itself so we decrease the</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+    // replaceCount by 1. We don't do so though if there is no visible node</span>
<a href="#l1.90"></a><span id="l1.90">     // for the container. This happens when aContainer is the root node</span>
<a href="#l1.91"></a><span id="l1.91">     if (aContainer.viewIndex != -1)</span>
<a href="#l1.92"></a><span id="l1.92">       replaceCount-=1;</span>
<a href="#l1.93"></a><span id="l1.93"> </span>
<a href="#l1.94"></a><span id="l1.94">     // Persist selection state</span>
<a href="#l1.95"></a><span id="l1.95">     var previouslySelectedNodes = [];</span>
<a href="#l1.96"></a><span id="l1.96">     var selection = this.selection;</span>
<a href="#l1.97"></a><span id="l1.97">     var rc = selection.getRangeCount();</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineat">@@ -277,32 +277,32 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.99"></a><span id="l1.99"> </span>
<a href="#l1.100"></a><span id="l1.100">     if (replaceCount)</span>
<a href="#l1.101"></a><span id="l1.101">       this._tree.rowCountChanged(startReplacement, -replaceCount);</span>
<a href="#l1.102"></a><span id="l1.102">     if (newElements.length)</span>
<a href="#l1.103"></a><span id="l1.103">       this._tree.rowCountChanged(startReplacement, newElements.length);</span>
<a href="#l1.104"></a><span id="l1.104"> </span>
<a href="#l1.105"></a><span id="l1.105">     // now, open any containers that were persisted</span>
<a href="#l1.106"></a><span id="l1.106">     for (var i = 0; i &lt; toOpenElements.length; i++) {</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineminus">-      var item = toOpenElements[i];</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineminus">-      var parent = item.parent;</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+      var node = toOpenElements[i];</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+      var parent = node.parent;</span>
<a href="#l1.111"></a><span id="l1.111">       // avoid recursively opening containers</span>
<a href="#l1.112"></a><span id="l1.112">       while (parent) {</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineminus">-        if (parent.uri == item.uri)</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineplus">+        if (parent.uri == node.uri)</span>
<a href="#l1.115"></a><span id="l1.115">           break;</span>
<a href="#l1.116"></a><span id="l1.116">         parent = parent.parent;</span>
<a href="#l1.117"></a><span id="l1.117">       }</span>
<a href="#l1.118"></a><span id="l1.118">       // if we don't have a parent, we made it all the way to the root</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineminus">-      // and didn't find a match, so we can open our item</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineminus">-      if (!parent &amp;&amp; !item.containerOpen) {</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineplus">+      // and didn't find a match, so we can open our node</span>
<a href="#l1.122"></a><span id="l1.122" class="difflineplus">+      if (!parent &amp;&amp; !node.containerOpen) {</span>
<a href="#l1.123"></a><span id="l1.123">         // 474287 Places enforces title sorting for groups, which we don't want.</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-        if (asQuery(item).queryOptions.resultType ==</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+        if (asQuery(node).queryOptions.resultType ==</span>
<a href="#l1.126"></a><span id="l1.126">             Components.interfaces.nsINavHistoryQueryOptions.RESULTS_AS_URI)</span>
<a href="#l1.127"></a><span id="l1.127" class="difflineminus">-          item.queryOptions.sortingMode = this._result.sortingMode;</span>
<a href="#l1.128"></a><span id="l1.128" class="difflineminus">-        item.containerOpen = true;</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineplus">+          node.queryOptions.sortingMode = this._result.sortingMode;</span>
<a href="#l1.130"></a><span id="l1.130" class="difflineplus">+        node.containerOpen = true;</span>
<a href="#l1.131"></a><span id="l1.131">       }</span>
<a href="#l1.132"></a><span id="l1.132">     }</span>
<a href="#l1.133"></a><span id="l1.133"> </span>
<a href="#l1.134"></a><span id="l1.134">     this._tree.endUpdateBatch();</span>
<a href="#l1.135"></a><span id="l1.135"> </span>
<a href="#l1.136"></a><span id="l1.136">     // restore selection</span>
<a href="#l1.137"></a><span id="l1.137">     if (previouslySelectedNodes.length &gt; 0) {</span>
<a href="#l1.138"></a><span id="l1.138">       for (var i = 0; i &lt; previouslySelectedNodes.length; i++) {</span>
<a href="#l1.139"></a><span id="l1.139" class="difflineat">@@ -369,156 +369,156 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.140"></a><span id="l1.140">     return (this._dateService.FormatDateTime(&quot;&quot;, dateFormat,</span>
<a href="#l1.141"></a><span id="l1.141">       Components.interfaces.nsIScriptableDateFormat.timeFormatNoSeconds,</span>
<a href="#l1.142"></a><span id="l1.142">       timeObj.getFullYear(), timeObj.getMonth() + 1,</span>
<a href="#l1.143"></a><span id="l1.143">       timeObj.getDate(), timeObj.getHours(),</span>
<a href="#l1.144"></a><span id="l1.144">       timeObj.getMinutes(), timeObj.getSeconds()));</span>
<a href="#l1.145"></a><span id="l1.145">   },</span>
<a href="#l1.146"></a><span id="l1.146"> </span>
<a href="#l1.147"></a><span id="l1.147">   // nsINavHistoryResultViewer</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineminus">-  itemInserted: function PTV_itemInserted(aParent, aItem, aNewIndex) {</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineplus">+  nodeInserted: function PTV_nodeInserted(aParent, aNode, aNewIndex) {</span>
<a href="#l1.150"></a><span id="l1.150">     if (!this._tree)</span>
<a href="#l1.151"></a><span id="l1.151">       return;</span>
<a href="#l1.152"></a><span id="l1.152">     if (!this._result)</span>
<a href="#l1.153"></a><span id="l1.153">       throw Components.results.NS_ERROR_UNEXPECTED;</span>
<a href="#l1.154"></a><span id="l1.154"> </span>
<a href="#l1.155"></a><span id="l1.155" class="difflineminus">-    // update parent when inserting the first item because twisty may</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineplus">+    // update parent when inserting the first node because twisty may</span>
<a href="#l1.157"></a><span id="l1.157">     // have changed</span>
<a href="#l1.158"></a><span id="l1.158">     if (aParent.childCount == 1)</span>
<a href="#l1.159"></a><span id="l1.159" class="difflineminus">-      this.itemChanged(aParent);</span>
<a href="#l1.160"></a><span id="l1.160" class="difflineplus">+      this.invalidateNode(aParent);</span>
<a href="#l1.161"></a><span id="l1.161"> </span>
<a href="#l1.162"></a><span id="l1.162" class="difflineminus">-    // compute the new view index of the item</span>
<a href="#l1.163"></a><span id="l1.163" class="difflineplus">+    // compute the new view index of the node</span>
<a href="#l1.164"></a><span id="l1.164">     var newViewIndex = -1;</span>
<a href="#l1.165"></a><span id="l1.165">     if (aNewIndex == 0) {</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineminus">-      // item is the first thing in our child list, it takes our index +1. Note</span>
<a href="#l1.167"></a><span id="l1.167" class="difflineplus">+      // node is the first thing in our child list, it takes our index +1. Note</span>
<a href="#l1.168"></a><span id="l1.168">       // that this computation still works if the parent is an invisible root</span>
<a href="#l1.169"></a><span id="l1.169">       // node, because root_index + 1 = -1 + 1 = 0</span>
<a href="#l1.170"></a><span id="l1.170">       newViewIndex = aParent.viewIndex + 1;</span>
<a href="#l1.171"></a><span id="l1.171">     }</span>
<a href="#l1.172"></a><span id="l1.172">     else {</span>
<a href="#l1.173"></a><span id="l1.173">       // Here, we try to find the next visible element in the child list so we</span>
<a href="#l1.174"></a><span id="l1.174">       // can set the new visible index to be right before that. Note that we</span>
<a href="#l1.175"></a><span id="l1.175">       // have to search DOWN instead of up, because some siblings could have</span>
<a href="#l1.176"></a><span id="l1.176">       // children themselves that would be in the way.</span>
<a href="#l1.177"></a><span id="l1.177">       for (var i = aNewIndex + 1; i &lt; aParent.childCount; i ++) {</span>
<a href="#l1.178"></a><span id="l1.178">         var viewIndex = aParent.getChild(i).viewIndex;</span>
<a href="#l1.179"></a><span id="l1.179">         if (viewIndex &gt;= 0) {</span>
<a href="#l1.180"></a><span id="l1.180">           // the view indices of subsequent children have not been shifted so</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineminus">-          // the next item will have what should be our index</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineplus">+          // the next node will have what should be our index</span>
<a href="#l1.183"></a><span id="l1.183">           newViewIndex = viewIndex;</span>
<a href="#l1.184"></a><span id="l1.184">           break;</span>
<a href="#l1.185"></a><span id="l1.185">         }</span>
<a href="#l1.186"></a><span id="l1.186">       }</span>
<a href="#l1.187"></a><span id="l1.187">       if (newViewIndex &lt; 0) {</span>
<a href="#l1.188"></a><span id="l1.188">         // At the end of the child list without finding a visible sibling: This</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineminus">-        // is a little harder because we don't know how many rows the last item</span>
<a href="#l1.190"></a><span id="l1.190" class="difflineplus">+        // is a little harder because we don't know how many rows the last node</span>
<a href="#l1.191"></a><span id="l1.191">         // in our list takes up (it could be a container with many children).</span>
<a href="#l1.192"></a><span id="l1.192">         var prevChild = aParent.getChild(aNewIndex - 1);</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineminus">-        newViewIndex = prevChild.viewIndex + this._countVisibleRowsForItem(prevChild);</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineplus">+        newViewIndex = prevChild.viewIndex + this._countVisibleRowsForNode(prevChild);</span>
<a href="#l1.195"></a><span id="l1.195">       }</span>
<a href="#l1.196"></a><span id="l1.196">     }</span>
<a href="#l1.197"></a><span id="l1.197"> </span>
<a href="#l1.198"></a><span id="l1.198" class="difflineminus">-    aItem.viewIndex = newViewIndex;</span>
<a href="#l1.199"></a><span id="l1.199" class="difflineplus">+    aNode.viewIndex = newViewIndex;</span>
<a href="#l1.200"></a><span id="l1.200">     this._visibleElements.splice(newViewIndex, 0,</span>
<a href="#l1.201"></a><span id="l1.201" class="difflineminus">-                                 { node: aItem, properties: null });</span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+                                 { node: aNode, properties: null });</span>
<a href="#l1.203"></a><span id="l1.203">     for (var i = newViewIndex + 1;</span>
<a href="#l1.204"></a><span id="l1.204">          i &lt; this._visibleElements.length; i ++) {</span>
<a href="#l1.205"></a><span id="l1.205">       this._visibleElements[i].node.viewIndex = i;</span>
<a href="#l1.206"></a><span id="l1.206">     }</span>
<a href="#l1.207"></a><span id="l1.207">     this._tree.rowCountChanged(newViewIndex, 1);</span>
<a href="#l1.208"></a><span id="l1.208"> </span>
<a href="#l1.209"></a><span id="l1.209" class="difflineminus">-    if (PlacesUtils.nodeIsContainer(aItem) &amp;&amp; asContainer(aItem).containerOpen)</span>
<a href="#l1.210"></a><span id="l1.210" class="difflineminus">-      this._refreshVisibleSection(aItem);</span>
<a href="#l1.211"></a><span id="l1.211" class="difflineplus">+    if (PlacesUtils.nodeIsContainer(aNode) &amp;&amp; asContainer(aNode).containerOpen)</span>
<a href="#l1.212"></a><span id="l1.212" class="difflineplus">+      this._refreshVisibleSection(aNode);</span>
<a href="#l1.213"></a><span id="l1.213">   },</span>
<a href="#l1.214"></a><span id="l1.214"> </span>
<a href="#l1.215"></a><span id="l1.215" class="difflineminus">-  // this is used in itemRemoved and itemMoved to fix viewIndex values</span>
<a href="#l1.216"></a><span id="l1.216" class="difflineminus">-  // throw if the item has an invalid viewIndex</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineminus">-  _fixViewIndexOnRemove: function PTV_fixViewIndexOnRemove(aItem, aParent) {</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineminus">-    var oldViewIndex = aItem.viewIndex;</span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+  // this is used in nodeRemoved and nodeMoved to fix viewIndex values</span>
<a href="#l1.220"></a><span id="l1.220" class="difflineplus">+  // throw if the node has an invalid viewIndex</span>
<a href="#l1.221"></a><span id="l1.221" class="difflineplus">+  _fixViewIndexOnRemove: function PTV_fixViewIndexOnRemove(aNode, aParent) {</span>
<a href="#l1.222"></a><span id="l1.222" class="difflineplus">+    var oldViewIndex = aNode.viewIndex;</span>
<a href="#l1.223"></a><span id="l1.223">     // this may have been a container, in which case it has a lot of rows</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineminus">-    var count = this._countVisibleRowsForItem(aItem);</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineplus">+    var count = this._countVisibleRowsForNode(aNode);</span>
<a href="#l1.226"></a><span id="l1.226"> </span>
<a href="#l1.227"></a><span id="l1.227">     if (oldViewIndex &gt; this._visibleElements.length)</span>
<a href="#l1.228"></a><span id="l1.228" class="difflineminus">-      throw(&quot;Trying to remove an item with an invalid viewIndex&quot;);</span>
<a href="#l1.229"></a><span id="l1.229" class="difflineplus">+      throw(&quot;Trying to remove a node with an invalid viewIndex&quot;);</span>
<a href="#l1.230"></a><span id="l1.230"> </span>
<a href="#l1.231"></a><span id="l1.231">     this._visibleElements.splice(oldViewIndex, count);</span>
<a href="#l1.232"></a><span id="l1.232">     for (var i = oldViewIndex; i &lt; this._visibleElements.length; i++)</span>
<a href="#l1.233"></a><span id="l1.233">       this._visibleElements[i].node.viewIndex = i;</span>
<a href="#l1.234"></a><span id="l1.234"> </span>
<a href="#l1.235"></a><span id="l1.235">     this._tree.rowCountChanged(oldViewIndex, -count);</span>
<a href="#l1.236"></a><span id="l1.236"> </span>
<a href="#l1.237"></a><span id="l1.237">     // redraw parent because twisty may have changed</span>
<a href="#l1.238"></a><span id="l1.238">     if (!aParent.hasChildren)</span>
<a href="#l1.239"></a><span id="l1.239" class="difflineminus">-      this.itemChanged(aParent);</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineplus">+      this.invalidateNode(aParent);</span>
<a href="#l1.241"></a><span id="l1.241"> </span>
<a href="#l1.242"></a><span id="l1.242">     return;</span>
<a href="#l1.243"></a><span id="l1.243">   },</span>
<a href="#l1.244"></a><span id="l1.244"> </span>
<a href="#l1.245"></a><span id="l1.245">   /**</span>
<a href="#l1.246"></a><span id="l1.246">    * THIS FUNCTION DOES NOT HANDLE cases where a collapsed node is being</span>
<a href="#l1.247"></a><span id="l1.247">    * removed but the node it is collapsed with is not being removed (this then</span>
<a href="#l1.248"></a><span id="l1.248">    * just swap out the removee with its collapsing partner). The only time</span>
<a href="#l1.249"></a><span id="l1.249">    * when we really remove things is when deleting URIs, which will apply to</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineminus">-   * all collapsees. This function is called sometimes when resorting items.</span>
<a href="#l1.251"></a><span id="l1.251" class="difflineplus">+   * all collapsees. This function is called sometimes when resorting nodes.</span>
<a href="#l1.252"></a><span id="l1.252">    * However, we won't do this when sorted by date because dates will never</span>
<a href="#l1.253"></a><span id="l1.253">    * change for visits, and date sorting is the only time things are collapsed.</span>
<a href="#l1.254"></a><span id="l1.254">    */</span>
<a href="#l1.255"></a><span id="l1.255" class="difflineminus">-  itemRemoved: function PTV_itemRemoved(aParent, aItem, aOldIndex) {</span>
<a href="#l1.256"></a><span id="l1.256" class="difflineplus">+  nodeRemoved: function PTV_nodeRemoved(aParent, aNode, aOldIndex) {</span>
<a href="#l1.257"></a><span id="l1.257">     NS_ASSERT(this._result, &quot;Got a notification but have no result!&quot;);</span>
<a href="#l1.258"></a><span id="l1.258">     if (!this._tree)</span>
<a href="#l1.259"></a><span id="l1.259">       return; // nothing to do</span>
<a href="#l1.260"></a><span id="l1.260"> </span>
<a href="#l1.261"></a><span id="l1.261" class="difflineminus">-    var oldViewIndex = aItem.viewIndex;</span>
<a href="#l1.262"></a><span id="l1.262" class="difflineplus">+    var oldViewIndex = aNode.viewIndex;</span>
<a href="#l1.263"></a><span id="l1.263">     if (oldViewIndex &lt; 0)</span>
<a href="#l1.264"></a><span id="l1.264" class="difflineminus">-      return; // item was already invisible, nothing to do</span>
<a href="#l1.265"></a><span id="l1.265" class="difflineplus">+      return; // node was already invisible, nothing to do</span>
<a href="#l1.266"></a><span id="l1.266"> </span>
<a href="#l1.267"></a><span id="l1.267" class="difflineminus">-    // if the item was exclusively selected, the node next to it will be</span>
<a href="#l1.268"></a><span id="l1.268" class="difflineplus">+    // if the node was exclusively selected, the node next to it will be</span>
<a href="#l1.269"></a><span id="l1.269">     // selected</span>
<a href="#l1.270"></a><span id="l1.270">     var selectNext = false;</span>
<a href="#l1.271"></a><span id="l1.271">     var selection = this.selection;</span>
<a href="#l1.272"></a><span id="l1.272">     if (selection.getRangeCount() == 1) {</span>
<a href="#l1.273"></a><span id="l1.273">       var min = { }, max = { };</span>
<a href="#l1.274"></a><span id="l1.274">       selection.getRangeAt(0, min, max);</span>
<a href="#l1.275"></a><span id="l1.275">       if (min.value == max.value &amp;&amp;</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineminus">-          this.nodeForTreeIndex(min.value) == aItem)</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineplus">+          this.nodeForTreeIndex(min.value) == aNode)</span>
<a href="#l1.278"></a><span id="l1.278">         selectNext = true;</span>
<a href="#l1.279"></a><span id="l1.279">     }</span>
<a href="#l1.280"></a><span id="l1.280"> </span>
<a href="#l1.281"></a><span id="l1.281" class="difflineminus">-    // remove the item and fix viewIndex values</span>
<a href="#l1.282"></a><span id="l1.282" class="difflineminus">-    this._fixViewIndexOnRemove(aItem, aParent);</span>
<a href="#l1.283"></a><span id="l1.283" class="difflineplus">+    // remove the node and fix viewIndex values</span>
<a href="#l1.284"></a><span id="l1.284" class="difflineplus">+    this._fixViewIndexOnRemove(aNode, aParent);</span>
<a href="#l1.285"></a><span id="l1.285"> </span>
<a href="#l1.286"></a><span id="l1.286" class="difflineminus">-    // restore selection if the item was exclusively selected</span>
<a href="#l1.287"></a><span id="l1.287" class="difflineplus">+    // restore selection if the node was exclusively selected</span>
<a href="#l1.288"></a><span id="l1.288">     if (!selectNext)</span>
<a href="#l1.289"></a><span id="l1.289">       return;</span>
<a href="#l1.290"></a><span id="l1.290">     // restore selection</span>
<a href="#l1.291"></a><span id="l1.291">     if (this._visibleElements.length &gt; oldViewIndex)</span>
<a href="#l1.292"></a><span id="l1.292">       selection.rangedSelect(oldViewIndex, oldViewIndex, true);</span>
<a href="#l1.293"></a><span id="l1.293">     else if (this._visibleElements.length &gt; 0) {</span>
<a href="#l1.294"></a><span id="l1.294">       // if we removed the last child, we select the new last child if exists</span>
<a href="#l1.295"></a><span id="l1.295">       selection.rangedSelect(this._visibleElements.length - 1,</span>
<a href="#l1.296"></a><span id="l1.296">                              this._visibleElements.length - 1, true);</span>
<a href="#l1.297"></a><span id="l1.297">     }</span>
<a href="#l1.298"></a><span id="l1.298">   },</span>
<a href="#l1.299"></a><span id="l1.299"> </span>
<a href="#l1.300"></a><span id="l1.300">   /**</span>
<a href="#l1.301"></a><span id="l1.301">    * Be careful, aOldIndex and aNewIndex specify the index in the</span>
<a href="#l1.302"></a><span id="l1.302">    * corresponding parent nodes, not the visible indexes.</span>
<a href="#l1.303"></a><span id="l1.303">    */</span>
<a href="#l1.304"></a><span id="l1.304" class="difflineminus">-  itemMoved:</span>
<a href="#l1.305"></a><span id="l1.305" class="difflineminus">-  function PTV_itemMoved(aItem, aOldParent, aOldIndex, aNewParent, aNewIndex) {</span>
<a href="#l1.306"></a><span id="l1.306" class="difflineplus">+  nodeMoved:</span>
<a href="#l1.307"></a><span id="l1.307" class="difflineplus">+  function PTV_nodeMoved(aNode, aOldParent, aOldIndex, aNewParent, aNewIndex) {</span>
<a href="#l1.308"></a><span id="l1.308">     NS_ASSERT(this._result, &quot;Got a notification but have no result!&quot;);</span>
<a href="#l1.309"></a><span id="l1.309">     if (!this._tree)</span>
<a href="#l1.310"></a><span id="l1.310">       return; // nothing to do</span>
<a href="#l1.311"></a><span id="l1.311"> </span>
<a href="#l1.312"></a><span id="l1.312" class="difflineminus">-    var oldViewIndex = aItem.viewIndex;</span>
<a href="#l1.313"></a><span id="l1.313" class="difflineplus">+    var oldViewIndex = aNode.viewIndex;</span>
<a href="#l1.314"></a><span id="l1.314">     if (oldViewIndex &lt; 0)</span>
<a href="#l1.315"></a><span id="l1.315" class="difflineminus">-      return; // item was already invisible, nothing to do</span>
<a href="#l1.316"></a><span id="l1.316" class="difflineplus">+      return; // node was already invisible, nothing to do</span>
<a href="#l1.317"></a><span id="l1.317"> </span>
<a href="#l1.318"></a><span id="l1.318">     // this may have been a container, in which case it has a lot of rows</span>
<a href="#l1.319"></a><span id="l1.319" class="difflineminus">-    var count = this._countVisibleRowsForItem(aItem);</span>
<a href="#l1.320"></a><span id="l1.320" class="difflineplus">+    var count = this._countVisibleRowsForNode(aNode);</span>
<a href="#l1.321"></a><span id="l1.321"> </span>
<a href="#l1.322"></a><span id="l1.322">     // Persist selection state</span>
<a href="#l1.323"></a><span id="l1.323">     var nodesToSelect = [];</span>
<a href="#l1.324"></a><span id="l1.324">     var selection = this.selection;</span>
<a href="#l1.325"></a><span id="l1.325">     var rc = selection.getRangeCount();</span>
<a href="#l1.326"></a><span id="l1.326">     for (var rangeIndex = 0; rangeIndex &lt; rc; rangeIndex++) {</span>
<a href="#l1.327"></a><span id="l1.327">       var min = { }, max = { };</span>
<a href="#l1.328"></a><span id="l1.328">       selection.getRangeAt(rangeIndex, min, max);</span>
<a href="#l1.329"></a><span id="l1.329" class="difflineat">@@ -527,82 +527,104 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.330"></a><span id="l1.330">         continue;</span>
<a href="#l1.331"></a><span id="l1.331"> </span>
<a href="#l1.332"></a><span id="l1.332">       for (var nodeIndex = min.value; nodeIndex &lt;= lastIndex; nodeIndex++)</span>
<a href="#l1.333"></a><span id="l1.333">         nodesToSelect.push(this._visibleElements[nodeIndex].node);</span>
<a href="#l1.334"></a><span id="l1.334">     }</span>
<a href="#l1.335"></a><span id="l1.335">     if (nodesToSelect.length &gt; 0)</span>
<a href="#l1.336"></a><span id="l1.336">       selection.selectEventsSuppressed = true;</span>
<a href="#l1.337"></a><span id="l1.337"> </span>
<a href="#l1.338"></a><span id="l1.338" class="difflineminus">-    // remove item from the old position</span>
<a href="#l1.339"></a><span id="l1.339" class="difflineminus">-    this._fixViewIndexOnRemove(aItem, aOldParent);</span>
<a href="#l1.340"></a><span id="l1.340" class="difflineplus">+    // remove node from the old position</span>
<a href="#l1.341"></a><span id="l1.341" class="difflineplus">+    this._fixViewIndexOnRemove(aNode, aOldParent);</span>
<a href="#l1.342"></a><span id="l1.342"> </span>
<a href="#l1.343"></a><span id="l1.343" class="difflineminus">-    // insert the item into the new position</span>
<a href="#l1.344"></a><span id="l1.344" class="difflineminus">-    this.itemInserted(aNewParent, aItem, aNewIndex);</span>
<a href="#l1.345"></a><span id="l1.345" class="difflineplus">+    // insert the node into the new position</span>
<a href="#l1.346"></a><span id="l1.346" class="difflineplus">+    this.nodeInserted(aNewParent, aNode, aNewIndex);</span>
<a href="#l1.347"></a><span id="l1.347"> </span>
<a href="#l1.348"></a><span id="l1.348">     // restore selection</span>
<a href="#l1.349"></a><span id="l1.349">     if (nodesToSelect.length &gt; 0) {</span>
<a href="#l1.350"></a><span id="l1.350">       for (var i = 0; i &lt; nodesToSelect.length; i++) {</span>
<a href="#l1.351"></a><span id="l1.351">         var node = nodesToSelect[i];</span>
<a href="#l1.352"></a><span id="l1.352">         var index = node.viewIndex;</span>
<a href="#l1.353"></a><span id="l1.353">         selection.rangedSelect(index, index, true);</span>
<a href="#l1.354"></a><span id="l1.354">       }</span>
<a href="#l1.355"></a><span id="l1.355">       selection.selectEventsSuppressed = false;</span>
<a href="#l1.356"></a><span id="l1.356">     }</span>
<a href="#l1.357"></a><span id="l1.357">   },</span>
<a href="#l1.358"></a><span id="l1.358"> </span>
<a href="#l1.359"></a><span id="l1.359">   /**</span>
<a href="#l1.360"></a><span id="l1.360">    * Be careful, the parameter 'aIndex' here specifies the index in the parent</span>
<a href="#l1.361"></a><span id="l1.361" class="difflineminus">-   * node of the item, not the visible index.</span>
<a href="#l1.362"></a><span id="l1.362" class="difflineplus">+   * node of the node, not the visible index.</span>
<a href="#l1.363"></a><span id="l1.363">    *</span>
<a href="#l1.364"></a><span id="l1.364" class="difflineminus">-   * This is called from the result when the item is replaced, but this object</span>
<a href="#l1.365"></a><span id="l1.365" class="difflineplus">+   * This is called from the result when the node is replaced, but this object</span>
<a href="#l1.366"></a><span id="l1.366">    * calls this function internally also when duplicate collapsing changes. In</span>
<a href="#l1.367"></a><span id="l1.367">    * this case, aIndex will be 0, so we should be careful not to use the value.</span>
<a href="#l1.368"></a><span id="l1.368">    */</span>
<a href="#l1.369"></a><span id="l1.369" class="difflineminus">-  itemReplaced:</span>
<a href="#l1.370"></a><span id="l1.370" class="difflineminus">-  function PTV_itemReplaced(aParent, aOldItem, aNewItem, aIndexDoNotUse) {</span>
<a href="#l1.371"></a><span id="l1.371" class="difflineplus">+  nodeReplaced:</span>
<a href="#l1.372"></a><span id="l1.372" class="difflineplus">+  function PTV_nodeReplaced(aParent, aOldNode, aNewNode, aIndexDoNotUse) {</span>
<a href="#l1.373"></a><span id="l1.373">     if (!this._tree)</span>
<a href="#l1.374"></a><span id="l1.374">       return;</span>
<a href="#l1.375"></a><span id="l1.375"> </span>
<a href="#l1.376"></a><span id="l1.376" class="difflineminus">-    var viewIndex = aOldItem.viewIndex;</span>
<a href="#l1.377"></a><span id="l1.377" class="difflineminus">-    aNewItem.viewIndex = viewIndex;</span>
<a href="#l1.378"></a><span id="l1.378" class="difflineplus">+    var viewIndex = aOldNode.viewIndex;</span>
<a href="#l1.379"></a><span id="l1.379" class="difflineplus">+    aNewNode.viewIndex = viewIndex;</span>
<a href="#l1.380"></a><span id="l1.380">     if (viewIndex &gt;= 0 &amp;&amp;</span>
<a href="#l1.381"></a><span id="l1.381">         viewIndex &lt; this._visibleElements.length) {</span>
<a href="#l1.382"></a><span id="l1.382" class="difflineminus">-      this._visibleElements[viewIndex].node = aNewItem;</span>
<a href="#l1.383"></a><span id="l1.383" class="difflineplus">+      this._visibleElements[viewIndex].node = aNewNode;</span>
<a href="#l1.384"></a><span id="l1.384">       this._visibleElements[viewIndex].properties = null;</span>
<a href="#l1.385"></a><span id="l1.385">     }</span>
<a href="#l1.386"></a><span id="l1.386" class="difflineminus">-    aOldItem.viewIndex = -1;</span>
<a href="#l1.387"></a><span id="l1.387" class="difflineplus">+    aOldNode.viewIndex = -1;</span>
<a href="#l1.388"></a><span id="l1.388">     this._tree.invalidateRow(viewIndex);</span>
<a href="#l1.389"></a><span id="l1.389">   },</span>
<a href="#l1.390"></a><span id="l1.390"> </span>
<a href="#l1.391"></a><span id="l1.391" class="difflineminus">-  itemChanged: function PTV_itemChanged(aItem) {</span>
<a href="#l1.392"></a><span id="l1.392" class="difflineplus">+  nodeTitleChanged: function PTV_nodeTitleChanged(aNode) {</span>
<a href="#l1.393"></a><span id="l1.393" class="difflineplus">+    this.invalidateNode(aNode);</span>
<a href="#l1.394"></a><span id="l1.394" class="difflineplus">+  },</span>
<a href="#l1.395"></a><span id="l1.395" class="difflineplus">+</span>
<a href="#l1.396"></a><span id="l1.396" class="difflineplus">+  nodeURIChanged: function PTV_nodeURIChanged(aNode) { },</span>
<a href="#l1.397"></a><span id="l1.397" class="difflineplus">+</span>
<a href="#l1.398"></a><span id="l1.398" class="difflineplus">+  nodeIconChanged: function PTV_nodeIconChanged(aNode) { },</span>
<a href="#l1.399"></a><span id="l1.399" class="difflineplus">+</span>
<a href="#l1.400"></a><span id="l1.400" class="difflineplus">+  nodeHistoryDetailsChanged: function PTV_nodeHistoryDetailsChanged(aNode) {</span>
<a href="#l1.401"></a><span id="l1.401" class="difflineplus">+    this.invalidateNode(aNode);</span>
<a href="#l1.402"></a><span id="l1.402" class="difflineplus">+  },</span>
<a href="#l1.403"></a><span id="l1.403" class="difflineplus">+</span>
<a href="#l1.404"></a><span id="l1.404" class="difflineplus">+  nodeTagsChanged: function PTV_nodeTagsChanged(aNode) { },</span>
<a href="#l1.405"></a><span id="l1.405" class="difflineplus">+</span>
<a href="#l1.406"></a><span id="l1.406" class="difflineplus">+  nodeKeywordChanged: function PTV_nodeKeywordChanged(aNode) { },</span>
<a href="#l1.407"></a><span id="l1.407" class="difflineplus">+</span>
<a href="#l1.408"></a><span id="l1.408" class="difflineplus">+  nodeAnnotationhanged: function PTV_nodeAnnotationhanged(aNode) { },</span>
<a href="#l1.409"></a><span id="l1.409" class="difflineplus">+</span>
<a href="#l1.410"></a><span id="l1.410" class="difflineplus">+  nodeDateAddedChanged: function PTV_nodeDateAddedChanged(aNode) { },</span>
<a href="#l1.411"></a><span id="l1.411" class="difflineplus">+</span>
<a href="#l1.412"></a><span id="l1.412" class="difflineplus">+  nodeLastModifiedChanged: function PTV_nodeLastModifiedChanged(aNode) { },</span>
<a href="#l1.413"></a><span id="l1.413" class="difflineplus">+</span>
<a href="#l1.414"></a><span id="l1.414" class="difflineplus">+  invalidateNode: function PTV_invalidateNode(aNode) {</span>
<a href="#l1.415"></a><span id="l1.415">     NS_ASSERT(this._result, &quot;Got a notification but have no result!&quot;);</span>
<a href="#l1.416"></a><span id="l1.416" class="difflineminus">-    var viewIndex = aItem.viewIndex;</span>
<a href="#l1.417"></a><span id="l1.417" class="difflineplus">+    var viewIndex = aNode.viewIndex;</span>
<a href="#l1.418"></a><span id="l1.418">     if (this._tree &amp;&amp; viewIndex &gt;= 0)</span>
<a href="#l1.419"></a><span id="l1.419">       this._tree.invalidateRow(viewIndex);</span>
<a href="#l1.420"></a><span id="l1.420">   },</span>
<a href="#l1.421"></a><span id="l1.421"> </span>
<a href="#l1.422"></a><span id="l1.422" class="difflineminus">-  containerOpened: function PTV_containerOpened(aItem) {</span>
<a href="#l1.423"></a><span id="l1.423" class="difflineminus">-    this.invalidateContainer(aItem);</span>
<a href="#l1.424"></a><span id="l1.424" class="difflineplus">+  containerOpened: function PTV_containerOpened(aNode) {</span>
<a href="#l1.425"></a><span id="l1.425" class="difflineplus">+    this.invalidateContainer(aNode);</span>
<a href="#l1.426"></a><span id="l1.426">   },</span>
<a href="#l1.427"></a><span id="l1.427"> </span>
<a href="#l1.428"></a><span id="l1.428" class="difflineminus">-  containerClosed: function PTV_containerClosed(aItem) {</span>
<a href="#l1.429"></a><span id="l1.429" class="difflineminus">-    this.invalidateContainer(aItem);</span>
<a href="#l1.430"></a><span id="l1.430" class="difflineplus">+  containerClosed: function PTV_containerClosed(aNode) {</span>
<a href="#l1.431"></a><span id="l1.431" class="difflineplus">+    this.invalidateContainer(aNode);</span>
<a href="#l1.432"></a><span id="l1.432">   },</span>
<a href="#l1.433"></a><span id="l1.433"> </span>
<a href="#l1.434"></a><span id="l1.434" class="difflineminus">-  invalidateContainer: function PTV_invalidateContainer(aItem) {</span>
<a href="#l1.435"></a><span id="l1.435" class="difflineplus">+  invalidateContainer: function PTV_invalidateContainer(aNode) {</span>
<a href="#l1.436"></a><span id="l1.436">     NS_ASSERT(this._result, &quot;Got a notification but have no result!&quot;);</span>
<a href="#l1.437"></a><span id="l1.437">     if (!this._tree)</span>
<a href="#l1.438"></a><span id="l1.438">       return; // nothing to do, container is not visible</span>
<a href="#l1.439"></a><span id="l1.439" class="difflineminus">-    var viewIndex = aItem.viewIndex;</span>
<a href="#l1.440"></a><span id="l1.440" class="difflineplus">+    var viewIndex = aNode.viewIndex;</span>
<a href="#l1.441"></a><span id="l1.441">     if (viewIndex &gt;= this._visibleElements.length) {</span>
<a href="#l1.442"></a><span id="l1.442">       // be paranoid about visible indices since others can change it</span>
<a href="#l1.443"></a><span id="l1.443">       throw Components.results.NS_ERROR_UNEXPECTED;</span>
<a href="#l1.444"></a><span id="l1.444">     }</span>
<a href="#l1.445"></a><span id="l1.445" class="difflineminus">-    this._refreshVisibleSection(aItem);</span>
<a href="#l1.446"></a><span id="l1.446" class="difflineplus">+    this._refreshVisibleSection(aNode);</span>
<a href="#l1.447"></a><span id="l1.447">   },</span>
<a href="#l1.448"></a><span id="l1.448"> </span>
<a href="#l1.449"></a><span id="l1.449">   invalidateAll: function PTV_invalidateAll() {</span>
<a href="#l1.450"></a><span id="l1.450">     NS_ASSERT(this._result, &quot;Got message but don't have a result!&quot;);</span>
<a href="#l1.451"></a><span id="l1.451">     if (!this._tree)</span>
<a href="#l1.452"></a><span id="l1.452">       return;</span>
<a href="#l1.453"></a><span id="l1.453"> </span>
<a href="#l1.454"></a><span id="l1.454">     var oldRowCount = this._visibleElements.length;</span>
<a href="#l1.455"></a><span id="l1.455" class="difflineat">@@ -836,32 +858,32 @@ PlacesTreeView.prototype = {</span>
<a href="#l1.456"></a><span id="l1.456">   getCellValue: function(aRow, aColumn) { },</span>
<a href="#l1.457"></a><span id="l1.457"> </span>
<a href="#l1.458"></a><span id="l1.458">   getCellText: function PTV_getCellText(aRow, aColumn) {</span>
<a href="#l1.459"></a><span id="l1.459">     this._ensureValidRow(aRow);</span>
<a href="#l1.460"></a><span id="l1.460"> </span>
<a href="#l1.461"></a><span id="l1.461">     var node = this._visibleElements[aRow].node;</span>
<a href="#l1.462"></a><span id="l1.462">     switch (aColumn.id) {</span>
<a href="#l1.463"></a><span id="l1.463">       case &quot;Name&quot;:</span>
<a href="#l1.464"></a><span id="l1.464" class="difflineminus">-        // normally, this is just the title, but we don't want empty items in</span>
<a href="#l1.465"></a><span id="l1.465" class="difflineplus">+        // normally, this is just the title, but we don't want empty nodes in</span>
<a href="#l1.466"></a><span id="l1.466">         // the tree view so return a special string if the title is empty.</span>
<a href="#l1.467"></a><span id="l1.467">         // Do it here so that callers can still get at the 0 length title</span>
<a href="#l1.468"></a><span id="l1.468">         // if they go through the &quot;result&quot; API.</span>
<a href="#l1.469"></a><span id="l1.469">         return PlacesUIUtils.getBestTitle(node);</span>
<a href="#l1.470"></a><span id="l1.470">       case &quot;URL&quot;:</span>
<a href="#l1.471"></a><span id="l1.471">         if (PlacesUtils.nodeIsURI(node))</span>
<a href="#l1.472"></a><span id="l1.472">           return node.uri;</span>
<a href="#l1.473"></a><span id="l1.473">         return &quot;&quot;;</span>
<a href="#l1.474"></a><span id="l1.474">       case &quot;Date&quot;:</span>
<a href="#l1.475"></a><span id="l1.475">         if (node.time == 0 || !PlacesUtils.nodeIsURI(node)) {</span>
<a href="#l1.476"></a><span id="l1.476">           // hosts and days shouldn't have a value for the date column.</span>
<a href="#l1.477"></a><span id="l1.477">           // Actually, you could argue this point, but looking at the</span>
<a href="#l1.478"></a><span id="l1.478">           // results, seeing the most recently visited date is not what</span>
<a href="#l1.479"></a><span id="l1.479">           // I expect, and gives me no information I know how to use.</span>
<a href="#l1.480"></a><span id="l1.480" class="difflineminus">-          // Only show this for URI-based items.</span>
<a href="#l1.481"></a><span id="l1.481" class="difflineplus">+          // Only show this for URI-based nodes.</span>
<a href="#l1.482"></a><span id="l1.482">           return &quot;&quot;;</span>
<a href="#l1.483"></a><span id="l1.483">         }</span>
<a href="#l1.484"></a><span id="l1.484">         return this._convertPRTimeToString(node.time);</span>
<a href="#l1.485"></a><span id="l1.485">       case &quot;VisitCount&quot;:</span>
<a href="#l1.486"></a><span id="l1.486">         return node.accessCount || &quot;&quot;;</span>
<a href="#l1.487"></a><span id="l1.487">     }</span>
<a href="#l1.488"></a><span id="l1.488">     return &quot;&quot;;</span>
<a href="#l1.489"></a><span id="l1.489">   },</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

