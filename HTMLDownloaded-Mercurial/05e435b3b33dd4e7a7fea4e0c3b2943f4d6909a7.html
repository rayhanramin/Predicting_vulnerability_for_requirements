<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/4b0de666d1a4/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/4b0de666d1a4/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/4b0de666d1a4/mercurial.js"></script>

<meta property="og:image" content="/static/4b0de666d1a4/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 29868:05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7" />
<meta property="og:url" content="/comm-central/rev/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7" />
<meta property="og:description" content="Bug 1644705 - Update RNP to snapshot from 2020-06-09. r=rjl DONTBUILD" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/4b0de666d1a4/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">shortlog</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">files</a> |
changeset |
<a href="/comm-central/raw-rev/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">raw</a>  | <a href="/comm-central/archive/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1644705">Bug 1644705</a> - Update RNP to snapshot from 2020-06-09. r=rjl DONTBUILD
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#75;&#97;&#105;&#32;&#69;&#110;&#103;&#101;&#114;&#116;&#32;&#60;&#107;&#97;&#105;&#101;&#64;&#107;&#117;&#105;&#120;&#46;&#100;&#101;&#62;</td></tr>
<tr><td></td><td class="date age">Wed, 10 Jun 2020 13:44:53 +0200</td></tr>

<tr>
 <td>changeset 29868</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7</a></td>
</tr>



<tr>
<td>parent 29867</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/43b5533bb521ce912d1e6efd63ba1a8b85b4689e">43b5533bb521ce912d1e6efd63ba1a8b85b4689e</a>
</td>
</tr>

<tr>
<td>child 29869</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/389202b5f371f97e2f68c1c036d641f518008ef6">389202b5f371f97e2f68c1c036d641f518008ef6</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">17572</a></td></tr>
<tr><td>push user</td><td>kaie@kuix.de</td></tr>
<tr><td>push date</td><td class="date age">Mon, 15 Jun 2020 11:09:24 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@05e435b3b33d [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7&newProject=comm-central&newRevision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7&newProject=comm-central&newRevision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7&newProject=comm-central&newRevision=05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28rjl%29&revcount=50">rjl</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1644705">1644705</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1644705">Bug 1644705</a> - Update RNP to snapshot from 2020-06-09. r=rjl DONTBUILD

Differential Revision: <a href="https://phabricator.services.mozilla.com/D79104">https://phabricator.services.mozilla.com/D79104</a></div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/README.rnp">third_party/README.rnp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/README.rnp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/README.rnp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/README.rnp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/README.rnp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/README.rnp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rekey/rnp_key_store.h">third_party/rnp/include/rekey/rnp_key_store.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rekey/rnp_key_store.h">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rekey/rnp_key_store.h">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rekey/rnp_key_store.h">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rekey/rnp_key_store.h">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rekey/rnp_key_store.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rnp/rnp.h">third_party/rnp/include/rnp/rnp.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rnp/rnp.h">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rnp/rnp.h">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rnp/rnp.h">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rnp/rnp.h">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/include/rnp/rnp.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/config.h.in">third_party/rnp/src/lib/config.h.in</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/config.h.in">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/config.h.in">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/config.h.in">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/config.h.in">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/config.h.in">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/elgamal.cpp">third_party/rnp/src/lib/crypto/elgamal.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/elgamal.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/elgamal.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/elgamal.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/elgamal.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/elgamal.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/signatures.cpp">third_party/rnp/src/lib/crypto/signatures.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/signatures.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/signatures.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/signatures.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/signatures.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/crypto/signatures.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/rnp.cpp">third_party/rnp/src/lib/rnp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/rnp.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/rnp.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/rnp.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/rnp.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/rnp.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/utils.h">third_party/rnp/src/lib/utils.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/utils.h">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/utils.h">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/utils.h">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/utils.h">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/utils.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/version.h">third_party/rnp/src/lib/version.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/version.h">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/version.h">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/version.h">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/version.h">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/lib/version.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/key_store_pgp.cpp">third_party/rnp/src/librekey/key_store_pgp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/key_store_pgp.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/key_store_pgp.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/key_store_pgp.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/key_store_pgp.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/key_store_pgp.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/rnp_key_store.cpp">third_party/rnp/src/librekey/rnp_key_store.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/rnp_key_store.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/rnp_key_store.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/rnp_key_store.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/rnp_key_store.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librekey/rnp_key_store.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.cpp">third_party/rnp/src/librepgp/stream-key.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.h">third_party/rnp/src/librepgp/stream-key.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.h">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.h">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.h">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.h">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-key.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-packet.cpp">third_party/rnp/src/librepgp/stream-packet.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-packet.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-packet.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-packet.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-packet.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/librepgp/stream-packet.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-pub.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-pub.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-pub.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-pub.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-pub.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-pub.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-pub.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-sec.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-sec.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-sec.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-sec.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-sec.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-sec.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/key-eg-4096-sec.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-cert.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-cert.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-cert.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-cert.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-cert.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-cert.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-cert.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0-sub0.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/pubring-malf-key0.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key0.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key0.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key0.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key0.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key0.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key0.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key0.pgp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key1.pgp">third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key1.pgp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key1.pgp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key1.pgp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key1.pgp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key1.pgp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_edge_cases/secring-malf-key1.pgp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp">third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/ffi.cpp">third_party/rnp/src/tests/ffi.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/ffi.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/ffi.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/ffi.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/ffi.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/ffi.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/key-validate.cpp">third_party/rnp/src/tests/key-validate.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/key-validate.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/key-validate.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/key-validate.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/key-validate.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/key-validate.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/large-mpi.cpp">third_party/rnp/src/tests/large-mpi.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/large-mpi.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/large-mpi.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/large-mpi.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/large-mpi.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/large-mpi.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/load-pgp.cpp">third_party/rnp/src/tests/load-pgp.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/load-pgp.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/load-pgp.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/load-pgp.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/load-pgp.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/load-pgp.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/rnp_tests.h">third_party/rnp/src/tests/rnp_tests.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/rnp_tests.h">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/rnp_tests.h">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/rnp_tests.h">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/rnp_tests.h">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/rnp_tests.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/streams.cpp">third_party/rnp/src/tests/streams.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/streams.cpp">file</a> |
<a href="/comm-central/annotate/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/streams.cpp">annotate</a> |
<a href="/comm-central/diff/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/streams.cpp">diff</a> |
<a href="/comm-central/comparison/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/streams.cpp">comparison</a> |
<a href="/comm-central/log/05e435b3b33dd4e7a7fea4e0c3b2943f4d6909a7/third_party/rnp/src/tests/streams.cpp">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/third_party/README.rnp</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/third_party/README.rnp</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -1,12 +1,12 @@</span>
<a href="#l1.4"></a><span id="l1.4"> Directory ./rnp contains a copy of rnp which has been obtained from:</span>
<a href="#l1.5"></a><span id="l1.5"> https://github.com/rnpgp/rnp</span>
<a href="#l1.6"></a><span id="l1.6"> </span>
<a href="#l1.7"></a><span id="l1.7" class="difflineminus">-[commit 6e74b75242e093ee12f0d630840b7a3fc1cd43ed]</span>
<a href="#l1.8"></a><span id="l1.8" class="difflineplus">+[commit b9335cee8cb346b567b8bfdb93e851618c6deb4a]</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> For licensing information, please refer to the included documentation.</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12"> To update this copy, run &quot;update_rnp.sh&quot; in this directory from this directory</span>
<a href="#l1.13"></a><span id="l1.13"> within a complete build tree (including mozilla-central) as &quot;mach python&quot; is</span>
<a href="#l1.14"></a><span id="l1.14"> used.</span>
<a href="#l1.15"></a><span id="l1.15"> </span>
<a href="#l1.16"></a><span id="l1.16"> update_rnp.sh will generate rnp/src/lib/version.h from rnp/src/lib/version.h.in</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/third_party/rnp/include/rekey/rnp_key_store.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/third_party/rnp/include/rekey/rnp_key_store.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -132,17 +132,18 @@ typedef enum pgp_sig_import_status_t {</span>
<a href="#l2.4"></a><span id="l2.4">     PGP_SIG_IMPORT_STATUS_NEW</span>
<a href="#l2.5"></a><span id="l2.5"> } pgp_sig_import_status_t;</span>
<a href="#l2.6"></a><span id="l2.6"> </span>
<a href="#l2.7"></a><span id="l2.7"> typedef std::map&lt;pgp_key_grip_t, std::list&lt;pgp_key_t&gt;::iterator&gt; pgp_key_grip_map_t;</span>
<a href="#l2.8"></a><span id="l2.8"> </span>
<a href="#l2.9"></a><span id="l2.9"> typedef struct rnp_key_store_t {</span>
<a href="#l2.10"></a><span id="l2.10">     std::string            path;</span>
<a href="#l2.11"></a><span id="l2.11">     pgp_key_store_format_t format;</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-    bool disable_validation; /* do not automatically validate keys, added to this key store */</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+    bool disable_validation;  /* do not automatically validate keys, added to this key store */</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+    bool skip_parsing_errors; /* do not fail on parsing errors */</span>
<a href="#l2.15"></a><span id="l2.15"> </span>
<a href="#l2.16"></a><span id="l2.16">     std::list&lt;pgp_key_t&gt; keys;</span>
<a href="#l2.17"></a><span id="l2.17">     pgp_key_grip_map_t   keybygrip;</span>
<a href="#l2.18"></a><span id="l2.18"> </span>
<a href="#l2.19"></a><span id="l2.19">     list blobs; // list of kbx_blob_t</span>
<a href="#l2.20"></a><span id="l2.20"> </span>
<a href="#l2.21"></a><span id="l2.21">     ~rnp_key_store_t();</span>
<a href="#l2.22"></a><span id="l2.22">     rnp_key_store_t() = default;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/third_party/rnp/include/rnp/rnp.h</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/third_party/rnp/include/rnp/rnp.h</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -69,16 +69,17 @@ typedef uint32_t rnp_result_t;</span>
<a href="#l3.4"></a><span id="l3.4"> #define RNP_DUMP_RAW (1U &lt;&lt; 1)</span>
<a href="#l3.5"></a><span id="l3.5"> #define RNP_DUMP_GRIP (1U &lt;&lt; 2)</span>
<a href="#l3.6"></a><span id="l3.6"> </span>
<a href="#l3.7"></a><span id="l3.7"> /**</span>
<a href="#l3.8"></a><span id="l3.8">  * Flags for the key loading/saving functions.</span>
<a href="#l3.9"></a><span id="l3.9">  */</span>
<a href="#l3.10"></a><span id="l3.10"> #define RNP_LOAD_SAVE_PUBLIC_KEYS (1U &lt;&lt; 0)</span>
<a href="#l3.11"></a><span id="l3.11"> #define RNP_LOAD_SAVE_SECRET_KEYS (1U &lt;&lt; 1)</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+#define RNP_LOAD_SAVE_PERMISSIVE (1U &lt;&lt; 8)</span>
<a href="#l3.13"></a><span id="l3.13"> </span>
<a href="#l3.14"></a><span id="l3.14"> /**</span>
<a href="#l3.15"></a><span id="l3.15">  * Flags for output structure creation.</span>
<a href="#l3.16"></a><span id="l3.16">  */</span>
<a href="#l3.17"></a><span id="l3.17"> #define RNP_OUTPUT_FILE_OVERWRITE (1U &lt;&lt; 0)</span>
<a href="#l3.18"></a><span id="l3.18"> #define RNP_OUTPUT_FILE_RANDOM (1U &lt;&lt; 1)</span>
<a href="#l3.19"></a><span id="l3.19"> </span>
<a href="#l3.20"></a><span id="l3.20"> /**</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineat">@@ -411,17 +412,19 @@ rnp_result_t rnp_load_keys(rnp_ffi_t   f</span>
<a href="#l3.22"></a><span id="l3.22">  * @return RNP_SUCCESS on success, or any other value on error.</span>
<a href="#l3.23"></a><span id="l3.23">  */</span>
<a href="#l3.24"></a><span id="l3.24"> rnp_result_t rnp_unload_keys(rnp_ffi_t ffi, uint32_t flags);</span>
<a href="#l3.25"></a><span id="l3.25"> </span>
<a href="#l3.26"></a><span id="l3.26"> /** import keys to the keyring and receive JSON list of the new/updated keys.</span>
<a href="#l3.27"></a><span id="l3.27">  *  Note: this will work only with keys in OpenPGP format, use rnp_load_keys for other formats.</span>
<a href="#l3.28"></a><span id="l3.28">  * @param ffi</span>
<a href="#l3.29"></a><span id="l3.29">  * @param input source to read from. Cannot be NULL.</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">- * @param flags see RNP_LOAD_SAVE_* constants.</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+ * @param flags see RNP_LOAD_SAVE_* constants. If RNP_LOAD_SAVE_PERMISSIVE is specified</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+ *              then import process will skip unrecognized or bad keys/signatures instead of</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+ *              failing the whole operation.</span>
<a href="#l3.34"></a><span id="l3.34">  * @param results if not NULL then after the successfull execution will contain JSON with</span>
<a href="#l3.35"></a><span id="l3.35">  *                information about new and updated keys. You must free it using the</span>
<a href="#l3.36"></a><span id="l3.36">  *                rnp_buffer_destroy() function.</span>
<a href="#l3.37"></a><span id="l3.37">  * @return RNP_SUCCESS on success, or any other value on error.</span>
<a href="#l3.38"></a><span id="l3.38">  */</span>
<a href="#l3.39"></a><span id="l3.39"> rnp_result_t rnp_import_keys(rnp_ffi_t ffi, rnp_input_t input, uint32_t flags, char **results);</span>
<a href="#l3.40"></a><span id="l3.40"> </span>
<a href="#l3.41"></a><span id="l3.41"> /** import standalone signatures to the keyring and receive JSON list of the updated keys.</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/third_party/rnp/src/lib/config.h.in</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/third_party/rnp/src/lib/config.h.in</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -19,17 +19,17 @@</span>
<a href="#l4.4"></a><span id="l4.4">  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a href="#l4.5"></a><span id="l4.5">  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a href="#l4.6"></a><span id="l4.6">  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a href="#l4.7"></a><span id="l4.7">  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a href="#l4.8"></a><span id="l4.8">  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a href="#l4.9"></a><span id="l4.9">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l4.10"></a><span id="l4.10">  */</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-#define PACKAGE_STRING    &quot;rnp 0.13.1+git20200530.6e74b752.MZLA&quot;</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+#define PACKAGE_STRING    &quot;rnp 0.13.1+git20200609.b9335cee.MZLA&quot;</span>
<a href="#l4.14"></a><span id="l4.14"> #define PACKAGE_BUGREPORT &quot;https://bugzilla.mozilla.org/enter_bug.cgi?product=Thunderbird&quot;</span>
<a href="#l4.15"></a><span id="l4.15"> </span>
<a href="#l4.16"></a><span id="l4.16"> #undef HAVE_BZLIB_H</span>
<a href="#l4.17"></a><span id="l4.17"> #undef HAVE_ZLIB_H</span>
<a href="#l4.18"></a><span id="l4.18"> </span>
<a href="#l4.19"></a><span id="l4.19"> #undef HAVE_FCNTL_H</span>
<a href="#l4.20"></a><span id="l4.20"> #undef HAVE_INTTYPES_H</span>
<a href="#l4.21"></a><span id="l4.21"> #undef HAVE_LIMITS_H</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/elgamal.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/elgamal.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -79,17 +79,17 @@</span>
<a href="#l5.4"></a><span id="l5.4"> #include &lt;stdlib.h&gt;</span>
<a href="#l5.5"></a><span id="l5.5"> #include &lt;string.h&gt;</span>
<a href="#l5.6"></a><span id="l5.6"> #include &lt;botan/ffi.h&gt;</span>
<a href="#l5.7"></a><span id="l5.7"> #include &lt;rnp/rnp_def.h&gt;</span>
<a href="#l5.8"></a><span id="l5.8"> #include &quot;elgamal.h&quot;</span>
<a href="#l5.9"></a><span id="l5.9"> #include &quot;utils.h&quot;</span>
<a href="#l5.10"></a><span id="l5.10"> </span>
<a href="#l5.11"></a><span id="l5.11"> // Max supported key byte size</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-#define ELGAMAL_MAX_P_BYTELEN BITS_TO_BYTES(DSA_MAX_P_BITLEN)</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+#define ELGAMAL_MAX_P_BYTELEN BITS_TO_BYTES(PGP_MPINT_BITS)</span>
<a href="#l5.14"></a><span id="l5.14"> </span>
<a href="#l5.15"></a><span id="l5.15"> static bool</span>
<a href="#l5.16"></a><span id="l5.16"> elgamal_load_public_key(botan_pubkey_t *pubkey, const pgp_eg_key_t *keydata)</span>
<a href="#l5.17"></a><span id="l5.17"> {</span>
<a href="#l5.18"></a><span id="l5.18">     bignum_t *p = NULL;</span>
<a href="#l5.19"></a><span id="l5.19">     bignum_t *g = NULL;</span>
<a href="#l5.20"></a><span id="l5.20">     bignum_t *y = NULL;</span>
<a href="#l5.21"></a><span id="l5.21">     bool      res = false;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/third_party/rnp/src/lib/crypto/signatures.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/third_party/rnp/src/lib/crypto/signatures.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -192,17 +192,19 @@ signature_validate(const pgp_signature_t</span>
<a href="#l6.4"></a><span id="l6.4"> </span>
<a href="#l6.5"></a><span id="l6.5">     const pgp_hash_alg_t hash_alg = pgp_hash_alg_type(hash);</span>
<a href="#l6.6"></a><span id="l6.6"> </span>
<a href="#l6.7"></a><span id="l6.7">     if (!key) {</span>
<a href="#l6.8"></a><span id="l6.8">         return RNP_ERROR_NULL_POINTER;</span>
<a href="#l6.9"></a><span id="l6.9">     }</span>
<a href="#l6.10"></a><span id="l6.10"> </span>
<a href="#l6.11"></a><span id="l6.11">     if (sig-&gt;palg != key-&gt;alg) {</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-        RNP_LOG(&quot;Signature and public key do not agree on algorithm type&quot;);</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+        RNP_LOG(&quot;Signature and key do not agree on algorithm type: %d vs %d&quot;,</span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+                (int) sig-&gt;palg,</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+                (int) key-&gt;alg);</span>
<a href="#l6.16"></a><span id="l6.16">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l6.17"></a><span id="l6.17">     }</span>
<a href="#l6.18"></a><span id="l6.18"> </span>
<a href="#l6.19"></a><span id="l6.19">     /* Finalize hash */</span>
<a href="#l6.20"></a><span id="l6.20">     ret = signature_hash_finish(sig, hash, hval, &amp;hlen);</span>
<a href="#l6.21"></a><span id="l6.21">     if (ret != RNP_SUCCESS) {</span>
<a href="#l6.22"></a><span id="l6.22">         return ret;</span>
<a href="#l6.23"></a><span id="l6.23">     }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/third_party/rnp/src/lib/rnp.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/third_party/rnp/src/lib/rnp.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -1248,16 +1248,21 @@ rnp_import_keys(rnp_ffi_t ffi, rnp_input</span>
<a href="#l7.4"></a><span id="l7.4">     if (flags &amp; RNP_LOAD_SAVE_PUBLIC_KEYS) {</span>
<a href="#l7.5"></a><span id="l7.5">         pub = true;</span>
<a href="#l7.6"></a><span id="l7.6">         flags &amp;= ~RNP_LOAD_SAVE_PUBLIC_KEYS;</span>
<a href="#l7.7"></a><span id="l7.7">     }</span>
<a href="#l7.8"></a><span id="l7.8">     if (!pub &amp;&amp; !sec) {</span>
<a href="#l7.9"></a><span id="l7.9">         FFI_LOG(ffi, &quot;bad flags: need to specify public and/or secret keys&quot;);</span>
<a href="#l7.10"></a><span id="l7.10">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l7.11"></a><span id="l7.11">     }</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+    bool skipbad = false;</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+    if (flags &amp; RNP_LOAD_SAVE_PERMISSIVE) {</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineplus">+        skipbad = true;</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+        flags &amp;= ~RNP_LOAD_SAVE_PERMISSIVE;</span>
<a href="#l7.16"></a><span id="l7.16" class="difflineplus">+    }</span>
<a href="#l7.17"></a><span id="l7.17">     if (flags) {</span>
<a href="#l7.18"></a><span id="l7.18">         FFI_LOG(ffi, &quot;unexpected flags remaining: 0x%X&quot;, flags);</span>
<a href="#l7.19"></a><span id="l7.19">         return RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l7.20"></a><span id="l7.20">     }</span>
<a href="#l7.21"></a><span id="l7.21"> </span>
<a href="#l7.22"></a><span id="l7.22">     rnp_result_t     ret = RNP_ERROR_GENERIC;</span>
<a href="#l7.23"></a><span id="l7.23">     rnp_key_store_t *tmp_store = NULL;</span>
<a href="#l7.24"></a><span id="l7.24">     rnp_result_t     tmpret;</span>
<a href="#l7.25"></a><span id="l7.25" class="difflineat">@@ -1267,19 +1272,19 @@ rnp_import_keys(rnp_ffi_t ffi, rnp_input</span>
<a href="#l7.26"></a><span id="l7.26">     // load keys to temporary keystore.</span>
<a href="#l7.27"></a><span id="l7.27">     try {</span>
<a href="#l7.28"></a><span id="l7.28">         tmp_store = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;&quot;);</span>
<a href="#l7.29"></a><span id="l7.29">     } catch (const std::exception &amp;e) {</span>
<a href="#l7.30"></a><span id="l7.30">         FFI_LOG(ffi, &quot;Failed to create key store: %s.&quot;, e.what());</span>
<a href="#l7.31"></a><span id="l7.31">         return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.32"></a><span id="l7.32">     }</span>
<a href="#l7.33"></a><span id="l7.33"> </span>
<a href="#l7.34"></a><span id="l7.34" class="difflineminus">-    tmpret = load_keys_from_input(ffi, input, tmp_store);</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineminus">-    if (tmpret) {</span>
<a href="#l7.36"></a><span id="l7.36" class="difflineminus">-        ret = tmpret;</span>
<a href="#l7.37"></a><span id="l7.37" class="difflineplus">+    tmp_store-&gt;skip_parsing_errors = skipbad;</span>
<a href="#l7.38"></a><span id="l7.38" class="difflineplus">+    if (!rnp_key_store_load_from_src(tmp_store, &amp;input-&gt;src, NULL)) {</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineplus">+        ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l7.40"></a><span id="l7.40">         goto done;</span>
<a href="#l7.41"></a><span id="l7.41">     }</span>
<a href="#l7.42"></a><span id="l7.42">     jsores = json_object_new_object();</span>
<a href="#l7.43"></a><span id="l7.43">     if (!jsores) {</span>
<a href="#l7.44"></a><span id="l7.44">         ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l7.45"></a><span id="l7.45">         goto done;</span>
<a href="#l7.46"></a><span id="l7.46">     }</span>
<a href="#l7.47"></a><span id="l7.47">     jsokeys = json_object_new_array();</span>
<a href="#l7.48"></a><span id="l7.48" class="difflineat">@@ -1291,19 +1296,21 @@ rnp_import_keys(rnp_ffi_t ffi, rnp_input</span>
<a href="#l7.49"></a><span id="l7.49">     // import keys to the main keystore.</span>
<a href="#l7.50"></a><span id="l7.50">     for (auto &amp;key : tmp_store-&gt;keys) {</span>
<a href="#l7.51"></a><span id="l7.51">         pgp_key_import_status_t pub_status = PGP_KEY_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l7.52"></a><span id="l7.52">         pgp_key_import_status_t sec_status = PGP_KEY_IMPORT_STATUS_UNKNOWN;</span>
<a href="#l7.53"></a><span id="l7.53">         if (!pub &amp;&amp; pgp_key_is_public(&amp;key)) {</span>
<a href="#l7.54"></a><span id="l7.54">             continue;</span>
<a href="#l7.55"></a><span id="l7.55">         }</span>
<a href="#l7.56"></a><span id="l7.56">         if (validate_pgp_key_material(pgp_key_get_material(&amp;key), &amp;ffi-&gt;rng)) {</span>
<a href="#l7.57"></a><span id="l7.57" class="difflineminus">-            FFI_LOG(ffi, &quot;attempt to import key with invalid material&quot;);</span>
<a href="#l7.58"></a><span id="l7.58" class="difflineminus">-            ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l7.59"></a><span id="l7.59" class="difflineminus">-            goto done;</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineplus">+            char hex[PGP_KEY_ID_SIZE * 2 + 1] = {0};</span>
<a href="#l7.61"></a><span id="l7.61" class="difflineplus">+            rnp_hex_encode(</span>
<a href="#l7.62"></a><span id="l7.62" class="difflineplus">+              pgp_key_get_keyid(&amp;key), PGP_KEY_ID_SIZE, hex, sizeof(hex), RNP_HEX_LOWERCASE);</span>
<a href="#l7.63"></a><span id="l7.63" class="difflineplus">+            FFI_LOG(ffi, &quot;warning! attempt to import key %s with invalid material.&quot;, hex);</span>
<a href="#l7.64"></a><span id="l7.64" class="difflineplus">+            continue;</span>
<a href="#l7.65"></a><span id="l7.65">         }</span>
<a href="#l7.66"></a><span id="l7.66">         // if we got here then we add public key itself or public part of the secret key</span>
<a href="#l7.67"></a><span id="l7.67">         if (!rnp_key_store_import_key(ffi-&gt;pubring, &amp;key, true, &amp;pub_status)) {</span>
<a href="#l7.68"></a><span id="l7.68">             ret = RNP_ERROR_BAD_PARAMETERS;</span>
<a href="#l7.69"></a><span id="l7.69">             goto done;</span>
<a href="#l7.70"></a><span id="l7.70">         }</span>
<a href="#l7.71"></a><span id="l7.71">         // import secret key part if available and requested</span>
<a href="#l7.72"></a><span id="l7.72">         if (sec &amp;&amp; pgp_key_is_secret(&amp;key)) {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/third_party/rnp/src/lib/utils.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/third_party/rnp/src/lib/utils.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -41,16 +41,40 @@ void set_rnp_log_switch(int8_t);</span>
<a href="#l8.4"></a><span id="l8.4">             break;                                                           \</span>
<a href="#l8.5"></a><span id="l8.5">         (void) fprintf((fd), &quot;[%s() %s:%d] &quot;, __func__, __FILE__, __LINE__); \</span>
<a href="#l8.6"></a><span id="l8.6">         (void) fprintf((fd), __VA_ARGS__);                                   \</span>
<a href="#l8.7"></a><span id="l8.7">         (void) fprintf((fd), &quot;\n&quot;);                                          \</span>
<a href="#l8.8"></a><span id="l8.8">     } while (0)</span>
<a href="#l8.9"></a><span id="l8.9"> </span>
<a href="#l8.10"></a><span id="l8.10"> #define RNP_LOG(...) RNP_LOG_FD(stderr, __VA_ARGS__)</span>
<a href="#l8.11"></a><span id="l8.11"> </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+#define RNP_LOG_KEY(msg, key)                                                                \</span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+    do {                                                                                     \</span>
<a href="#l8.14"></a><span id="l8.14" class="difflineplus">+        if (!key) {                                                                          \</span>
<a href="#l8.15"></a><span id="l8.15" class="difflineplus">+            RNP_LOG(msg, &quot;(null)&quot;);                                                          \</span>
<a href="#l8.16"></a><span id="l8.16" class="difflineplus">+            break;                                                                           \</span>
<a href="#l8.17"></a><span id="l8.17" class="difflineplus">+        }                                                                                    \</span>
<a href="#l8.18"></a><span id="l8.18" class="difflineplus">+        char keyid[PGP_KEY_ID_SIZE * 2 + 1] = {0};                                           \</span>
<a href="#l8.19"></a><span id="l8.19" class="difflineplus">+        rnp_hex_encode(                                                                      \</span>
<a href="#l8.20"></a><span id="l8.20" class="difflineplus">+          pgp_key_get_keyid(key), PGP_KEY_ID_SIZE, keyid, sizeof(keyid), RNP_HEX_LOWERCASE); \</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineplus">+        RNP_LOG(msg, keyid);                                                                 \</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineplus">+    } while (0)</span>
<a href="#l8.23"></a><span id="l8.23" class="difflineplus">+</span>
<a href="#l8.24"></a><span id="l8.24" class="difflineplus">+#define RNP_LOG_KEY_PKT(msg, key)                                                            \</span>
<a href="#l8.25"></a><span id="l8.25" class="difflineplus">+    do {                                                                                     \</span>
<a href="#l8.26"></a><span id="l8.26" class="difflineplus">+        uint8_t keyid[PGP_KEY_ID_SIZE] = {0};                                                \</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineplus">+        if (pgp_keyid(keyid, PGP_KEY_ID_SIZE, (key))) {                                      \</span>
<a href="#l8.28"></a><span id="l8.28" class="difflineplus">+            RNP_LOG(msg, &quot;unknown&quot;);                                                         \</span>
<a href="#l8.29"></a><span id="l8.29" class="difflineplus">+            break;                                                                           \</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineplus">+        };                                                                                   \</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+        char keyidhex[PGP_KEY_ID_SIZE * 2 + 1] = {0};                                        \</span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+        rnp_hex_encode(keyid, sizeof(keyid), keyidhex, sizeof(keyidhex), RNP_HEX_LOWERCASE); \</span>
<a href="#l8.33"></a><span id="l8.33" class="difflineplus">+        RNP_LOG(msg, keyidhex);                                                              \</span>
<a href="#l8.34"></a><span id="l8.34" class="difflineplus">+    } while (0)</span>
<a href="#l8.35"></a><span id="l8.35" class="difflineplus">+</span>
<a href="#l8.36"></a><span id="l8.36"> #define RNP_DLOG(...)                    \</span>
<a href="#l8.37"></a><span id="l8.37">     if (rnp_get_debug(__FILE__)) {       \</span>
<a href="#l8.38"></a><span id="l8.38">         RNP_LOG_FD(stderr, __VA_ARGS__); \</span>
<a href="#l8.39"></a><span id="l8.39">     }</span>
<a href="#l8.40"></a><span id="l8.40"> </span>
<a href="#l8.41"></a><span id="l8.41"> #define RNP_DHEX(msg, mem, len)         \</span>
<a href="#l8.42"></a><span id="l8.42">     if (rnp_get_debug(__FILE__)) {      \</span>
<a href="#l8.43"></a><span id="l8.43">         hexdump(stderr, msg, mem, len); \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/third_party/rnp/src/lib/version.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/third_party/rnp/src/lib/version.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -23,19 +23,19 @@</span>
<a href="#l9.4"></a><span id="l9.4">  * POSSIBILITY OF SUCH DAMAGE.</span>
<a href="#l9.5"></a><span id="l9.5">  */</span>
<a href="#l9.6"></a><span id="l9.6"> </span>
<a href="#l9.7"></a><span id="l9.7"> #define RNP_VERSION_MAJOR 0</span>
<a href="#l9.8"></a><span id="l9.8"> #define RNP_VERSION_MINOR 13</span>
<a href="#l9.9"></a><span id="l9.9"> #define RNP_VERSION_PATCH 1</span>
<a href="#l9.10"></a><span id="l9.10"> </span>
<a href="#l9.11"></a><span id="l9.11"> #define RNP_VERSION_STRING &quot;0.13.1&quot;</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-#define RNP_VERSION_STRING_FULL &quot;0.13.1+git20200530.6e74b752.MZLA&quot;</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+#define RNP_VERSION_STRING_FULL &quot;0.13.1+git20200609.b9335cee.MZLA&quot;</span>
<a href="#l9.14"></a><span id="l9.14"> </span>
<a href="#l9.15"></a><span id="l9.15" class="difflineminus">-#define RNP_VERSION_COMMIT_TIMESTAMP 1590833119</span>
<a href="#l9.16"></a><span id="l9.16" class="difflineplus">+#define RNP_VERSION_COMMIT_TIMESTAMP 1591722904</span>
<a href="#l9.17"></a><span id="l9.17"> </span>
<a href="#l9.18"></a><span id="l9.18"> // using a 32-bit version with 10 bits per component</span>
<a href="#l9.19"></a><span id="l9.19"> #define RNP_VERSION_COMPONENT_MASK 0x3ff</span>
<a href="#l9.20"></a><span id="l9.20"> #define RNP_VERSION_MAJOR_SHIFT 20</span>
<a href="#l9.21"></a><span id="l9.21"> #define RNP_VERSION_MINOR_SHIFT 10</span>
<a href="#l9.22"></a><span id="l9.22"> #define RNP_VERSION_PATCH_SHIFT 0</span>
<a href="#l9.23"></a><span id="l9.23"> #define RNP_VERSION_CODE_FOR(major, minor, patch)                        \</span>
<a href="#l9.24"></a><span id="l9.24">     (((major &amp; RNP_VERSION_COMPONENT_MASK) &lt;&lt; RNP_VERSION_MAJOR_SHIFT) | \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/third_party/rnp/src/librekey/key_store_pgp.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/key_store_pgp.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -98,26 +98,23 @@ bool</span>
<a href="#l10.4"></a><span id="l10.4"> rnp_key_store_add_transferable_subkey(rnp_key_store_t *          keyring,</span>
<a href="#l10.5"></a><span id="l10.5">                                       pgp_transferable_subkey_t *tskey,</span>
<a href="#l10.6"></a><span id="l10.6">                                       pgp_key_t *                pkey)</span>
<a href="#l10.7"></a><span id="l10.7"> {</span>
<a href="#l10.8"></a><span id="l10.8">     pgp_key_t skey = {};</span>
<a href="#l10.9"></a><span id="l10.9"> </span>
<a href="#l10.10"></a><span id="l10.10">     /* create subkey */</span>
<a href="#l10.11"></a><span id="l10.11">     if (!rnp_key_from_transferable_subkey(&amp;skey, tskey, pkey)) {</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-        RNP_LOG(&quot;failed to create subkey&quot;);</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+        RNP_LOG_KEY_PKT(&quot;failed to create subkey %s&quot;, &amp;tskey-&gt;subkey);</span>
<a href="#l10.14"></a><span id="l10.14" class="difflineplus">+        RNP_LOG_KEY(&quot;primary key is %s&quot;, pkey);</span>
<a href="#l10.15"></a><span id="l10.15">         return false;</span>
<a href="#l10.16"></a><span id="l10.16">     }</span>
<a href="#l10.17"></a><span id="l10.17"> </span>
<a href="#l10.18"></a><span id="l10.18">     /* add it to the storage */</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineminus">-    bool res = rnp_key_store_add_key(keyring, &amp;skey);</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineminus">-    if (!res) {</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineminus">-        RNP_LOG(&quot;Failed to add subkey to key store.&quot;);</span>
<a href="#l10.22"></a><span id="l10.22" class="difflineminus">-    }</span>
<a href="#l10.23"></a><span id="l10.23" class="difflineminus">-    return res;</span>
<a href="#l10.24"></a><span id="l10.24" class="difflineplus">+    return rnp_key_store_add_key(keyring, &amp;skey);</span>
<a href="#l10.25"></a><span id="l10.25"> }</span>
<a href="#l10.26"></a><span id="l10.26"> </span>
<a href="#l10.27"></a><span id="l10.27"> bool</span>
<a href="#l10.28"></a><span id="l10.28"> rnp_key_add_transferable_userid(pgp_key_t *key, pgp_transferable_userid_t *uid)</span>
<a href="#l10.29"></a><span id="l10.29"> {</span>
<a href="#l10.30"></a><span id="l10.30">     pgp_userid_t *userid = pgp_key_add_userid(key);</span>
<a href="#l10.31"></a><span id="l10.31">     if (!userid) {</span>
<a href="#l10.32"></a><span id="l10.32">         RNP_LOG(&quot;Failed to add userid&quot;);</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineat">@@ -157,17 +154,17 @@ rnp_key_add_transferable_userid(pgp_key_</span>
<a href="#l10.34"></a><span id="l10.34"> bool</span>
<a href="#l10.35"></a><span id="l10.35"> rnp_key_store_add_transferable_key(rnp_key_store_t *keyring, pgp_transferable_key_t *tkey)</span>
<a href="#l10.36"></a><span id="l10.36"> {</span>
<a href="#l10.37"></a><span id="l10.37">     pgp_key_t  key = {};</span>
<a href="#l10.38"></a><span id="l10.38">     pgp_key_t *addkey = NULL;</span>
<a href="#l10.39"></a><span id="l10.39"> </span>
<a href="#l10.40"></a><span id="l10.40">     /* create key from transferable key */</span>
<a href="#l10.41"></a><span id="l10.41">     if (!rnp_key_from_transferable_key(&amp;key, tkey)) {</span>
<a href="#l10.42"></a><span id="l10.42" class="difflineminus">-        RNP_LOG(&quot;failed to create key&quot;);</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineplus">+        RNP_LOG_KEY_PKT(&quot;failed to create key %s&quot;, &amp;tkey-&gt;key);</span>
<a href="#l10.44"></a><span id="l10.44">         return false;</span>
<a href="#l10.45"></a><span id="l10.45">     }</span>
<a href="#l10.46"></a><span id="l10.46"> </span>
<a href="#l10.47"></a><span id="l10.47">     /* temporary disable key validation */</span>
<a href="#l10.48"></a><span id="l10.48">     keyring-&gt;disable_validation = true;</span>
<a href="#l10.49"></a><span id="l10.49"> </span>
<a href="#l10.50"></a><span id="l10.50">     /* add key to the storage before subkeys */</span>
<a href="#l10.51"></a><span id="l10.51">     addkey = rnp_key_store_add_key(keyring, &amp;key);</span>
<a href="#l10.52"></a><span id="l10.52" class="difflineat">@@ -250,28 +247,28 @@ rnp_result_t</span>
<a href="#l10.53"></a><span id="l10.53"> rnp_key_store_pgp_read_from_src(rnp_key_store_t *keyring, pgp_source_t *src)</span>
<a href="#l10.54"></a><span id="l10.54"> {</span>
<a href="#l10.55"></a><span id="l10.55">     pgp_key_sequence_t        keys = {};</span>
<a href="#l10.56"></a><span id="l10.56">     pgp_transferable_subkey_t tskey = {};</span>
<a href="#l10.57"></a><span id="l10.57">     rnp_result_t              ret = RNP_ERROR_GENERIC;</span>
<a href="#l10.58"></a><span id="l10.58"> </span>
<a href="#l10.59"></a><span id="l10.59">     /* check whether we have transferable subkey in source */</span>
<a href="#l10.60"></a><span id="l10.60">     if (is_subkey_pkt(stream_pkt_type(src))) {</span>
<a href="#l10.61"></a><span id="l10.61" class="difflineminus">-        if ((ret = process_pgp_subkey(src, &amp;tskey))) {</span>
<a href="#l10.62"></a><span id="l10.62" class="difflineplus">+        if ((ret = process_pgp_subkey(src, &amp;tskey, keyring-&gt;skip_parsing_errors))) {</span>
<a href="#l10.63"></a><span id="l10.63">             return ret;</span>
<a href="#l10.64"></a><span id="l10.64">         }</span>
<a href="#l10.65"></a><span id="l10.65">         ret = rnp_key_store_add_transferable_subkey(keyring, &amp;tskey, NULL) ?</span>
<a href="#l10.66"></a><span id="l10.66">                 RNP_SUCCESS :</span>
<a href="#l10.67"></a><span id="l10.67">                 RNP_ERROR_BAD_STATE;</span>
<a href="#l10.68"></a><span id="l10.68">         transferable_subkey_destroy(&amp;tskey);</span>
<a href="#l10.69"></a><span id="l10.69">         return ret;</span>
<a href="#l10.70"></a><span id="l10.70">     }</span>
<a href="#l10.71"></a><span id="l10.71"> </span>
<a href="#l10.72"></a><span id="l10.72">     /* process armored or raw transferable key packets sequence(s) */</span>
<a href="#l10.73"></a><span id="l10.73" class="difflineminus">-    if ((ret = process_pgp_keys(src, &amp;keys))) {</span>
<a href="#l10.74"></a><span id="l10.74" class="difflineplus">+    if ((ret = process_pgp_keys(src, &amp;keys, keyring-&gt;skip_parsing_errors))) {</span>
<a href="#l10.75"></a><span id="l10.75">         return ret;</span>
<a href="#l10.76"></a><span id="l10.76">     }</span>
<a href="#l10.77"></a><span id="l10.77"> </span>
<a href="#l10.78"></a><span id="l10.78">     for (list_item *key = list_front(keys.keys); key; key = list_next(key)) {</span>
<a href="#l10.79"></a><span id="l10.79">         if (!rnp_key_store_add_transferable_key(keyring, (pgp_transferable_key_t *) key)) {</span>
<a href="#l10.80"></a><span id="l10.80">             ret = RNP_ERROR_BAD_STATE;</span>
<a href="#l10.81"></a><span id="l10.81">             goto done;</span>
<a href="#l10.82"></a><span id="l10.82">         }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/third_party/rnp/src/librekey/rnp_key_store.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/third_party/rnp/src/librekey/rnp_key_store.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -432,46 +432,50 @@ rnp_key_store_add_subkey(rnp_key_store_t</span>
<a href="#l11.4"></a><span id="l11.4">     pgp_key_t *primary = rnp_key_store_get_primary_key(keyring, srckey);</span>
<a href="#l11.5"></a><span id="l11.5">     if (!primary &amp;&amp; oldkey) {</span>
<a href="#l11.6"></a><span id="l11.6">         primary = rnp_key_store_get_primary_key(keyring, oldkey);</span>
<a href="#l11.7"></a><span id="l11.7">     }</span>
<a href="#l11.8"></a><span id="l11.8"> </span>
<a href="#l11.9"></a><span id="l11.9">     if (oldkey) {</span>
<a href="#l11.10"></a><span id="l11.10">         /* in case we already have key let's merge it in */</span>
<a href="#l11.11"></a><span id="l11.11">         if (!rnp_key_store_merge_subkey(oldkey, srckey, primary)) {</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-            RNP_LOG(&quot;failed to merge subkey&quot;);</span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+            RNP_LOG_KEY(&quot;failed to merge subkey %s&quot;, srckey);</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineplus">+            RNP_LOG_KEY(&quot;primary key is %s&quot;, primary);</span>
<a href="#l11.15"></a><span id="l11.15">             return NULL;</span>
<a href="#l11.16"></a><span id="l11.16">         }</span>
<a href="#l11.17"></a><span id="l11.17">     } else {</span>
<a href="#l11.18"></a><span id="l11.18">         try {</span>
<a href="#l11.19"></a><span id="l11.19">             keyring-&gt;keys.emplace_back();</span>
<a href="#l11.20"></a><span id="l11.20">             oldkey = &amp;keyring-&gt;keys.back();</span>
<a href="#l11.21"></a><span id="l11.21">             keyring-&gt;keybygrip[pgp_key_get_grip(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l11.22"></a><span id="l11.22">         } catch (const std::exception &amp;e) {</span>
<a href="#l11.23"></a><span id="l11.23">             RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l11.24"></a><span id="l11.24">             return NULL;</span>
<a href="#l11.25"></a><span id="l11.25">         }</span>
<a href="#l11.26"></a><span id="l11.26">         if (pgp_key_copy(oldkey, srckey, false)) {</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineminus">-            RNP_LOG(&quot;key copying failed&quot;);</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineplus">+            RNP_LOG_KEY(&quot;key %s copying failed&quot;, srckey);</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineplus">+            RNP_LOG_KEY(&quot;primary key is %s&quot;, primary);</span>
<a href="#l11.30"></a><span id="l11.30">             keyring-&gt;keys.pop_back();</span>
<a href="#l11.31"></a><span id="l11.31">             keyring-&gt;keybygrip.erase(pgp_key_get_grip(srckey));</span>
<a href="#l11.32"></a><span id="l11.32">             return NULL;</span>
<a href="#l11.33"></a><span id="l11.33">         }</span>
<a href="#l11.34"></a><span id="l11.34">         if (primary &amp;&amp; !pgp_key_link_subkey_grip(primary, oldkey)) {</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineminus">-            RNP_LOG(&quot;failed to link subkey grip&quot;);</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineplus">+            RNP_LOG_KEY(&quot;failed to link subkey %s grip&quot;, oldkey);</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineplus">+            RNP_LOG_KEY(&quot;primary key is %s&quot;, primary);</span>
<a href="#l11.38"></a><span id="l11.38">         }</span>
<a href="#l11.39"></a><span id="l11.39">     }</span>
<a href="#l11.40"></a><span id="l11.40"> </span>
<a href="#l11.41"></a><span id="l11.41">     RNP_DLOG(&quot;keyc %lu&quot;, (long unsigned) rnp_key_store_get_key_count(keyring));</span>
<a href="#l11.42"></a><span id="l11.42">     /* validate all added keys if not disabled */</span>
<a href="#l11.43"></a><span id="l11.43">     if (!keyring-&gt;disable_validation &amp;&amp; !oldkey-&gt;validated) {</span>
<a href="#l11.44"></a><span id="l11.44">         pgp_key_validate_subkey(oldkey, primary);</span>
<a href="#l11.45"></a><span id="l11.45">     }</span>
<a href="#l11.46"></a><span id="l11.46">     if (!pgp_subkey_refresh_data(oldkey, primary)) {</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineminus">-        RNP_LOG(&quot;Failed to refresh subkey data&quot;);</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineplus">+        RNP_LOG_KEY(&quot;Failed to refresh subkey %s data&quot;, srckey);</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineplus">+        RNP_LOG_KEY(&quot;primary key is %s&quot;, primary);</span>
<a href="#l11.50"></a><span id="l11.50">     }</span>
<a href="#l11.51"></a><span id="l11.51">     return oldkey;</span>
<a href="#l11.52"></a><span id="l11.52"> }</span>
<a href="#l11.53"></a><span id="l11.53"> </span>
<a href="#l11.54"></a><span id="l11.54"> /* add a key to keyring */</span>
<a href="#l11.55"></a><span id="l11.55"> pgp_key_t *</span>
<a href="#l11.56"></a><span id="l11.56"> rnp_key_store_add_key(rnp_key_store_t *keyring, pgp_key_t *srckey)</span>
<a href="#l11.57"></a><span id="l11.57"> {</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineat">@@ -483,46 +487,46 @@ rnp_key_store_add_key(rnp_key_store_t *k</span>
<a href="#l11.59"></a><span id="l11.59">     }</span>
<a href="#l11.60"></a><span id="l11.60">     /* different processing for subkeys */</span>
<a href="#l11.61"></a><span id="l11.61">     if (pgp_key_is_subkey(srckey)) {</span>
<a href="#l11.62"></a><span id="l11.62">         return rnp_key_store_add_subkey(keyring, srckey, added_key);</span>
<a href="#l11.63"></a><span id="l11.63">     }</span>
<a href="#l11.64"></a><span id="l11.64"> </span>
<a href="#l11.65"></a><span id="l11.65">     if (added_key) {</span>
<a href="#l11.66"></a><span id="l11.66">         if (!rnp_key_store_merge_key(added_key, srckey)) {</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineminus">-            RNP_LOG(&quot;failed to merge key&quot;);</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineplus">+            RNP_LOG_KEY(&quot;failed to merge key %s&quot;, srckey);</span>
<a href="#l11.69"></a><span id="l11.69">             return NULL;</span>
<a href="#l11.70"></a><span id="l11.70">         }</span>
<a href="#l11.71"></a><span id="l11.71">     } else {</span>
<a href="#l11.72"></a><span id="l11.72">         try {</span>
<a href="#l11.73"></a><span id="l11.73">             keyring-&gt;keys.emplace_back();</span>
<a href="#l11.74"></a><span id="l11.74">             added_key = &amp;keyring-&gt;keys.back();</span>
<a href="#l11.75"></a><span id="l11.75">             keyring-&gt;keybygrip[pgp_key_get_grip(srckey)] = std::prev(keyring-&gt;keys.end());</span>
<a href="#l11.76"></a><span id="l11.76">         } catch (const std::exception &amp;e) {</span>
<a href="#l11.77"></a><span id="l11.77">             RNP_LOG(&quot;%s&quot;, e.what());</span>
<a href="#l11.78"></a><span id="l11.78">             return NULL;</span>
<a href="#l11.79"></a><span id="l11.79">         }</span>
<a href="#l11.80"></a><span id="l11.80">         if (pgp_key_copy(added_key, srckey, false)) {</span>
<a href="#l11.81"></a><span id="l11.81" class="difflineminus">-            RNP_LOG(&quot;key copying failed&quot;);</span>
<a href="#l11.82"></a><span id="l11.82" class="difflineplus">+            RNP_LOG_KEY(&quot;key %s copying failed&quot;, srckey);</span>
<a href="#l11.83"></a><span id="l11.83">             keyring-&gt;keys.pop_back();</span>
<a href="#l11.84"></a><span id="l11.84">             keyring-&gt;keybygrip.erase(pgp_key_get_grip(srckey));</span>
<a href="#l11.85"></a><span id="l11.85">             return NULL;</span>
<a href="#l11.86"></a><span id="l11.86">         }</span>
<a href="#l11.87"></a><span id="l11.87">         /* primary key may be added after subkeys, so let's handle this case correctly */</span>
<a href="#l11.88"></a><span id="l11.88">         if (!rnp_key_store_refresh_subkey_grips(keyring, added_key)) {</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineminus">-            RNP_LOG(&quot;failed to refresh subkey grips&quot;);</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineplus">+            RNP_LOG_KEY(&quot;failed to refresh subkey grips for %s&quot;, added_key);</span>
<a href="#l11.91"></a><span id="l11.91">         }</span>
<a href="#l11.92"></a><span id="l11.92">     }</span>
<a href="#l11.93"></a><span id="l11.93"> </span>
<a href="#l11.94"></a><span id="l11.94">     RNP_DLOG(&quot;keyc %lu&quot;, (long unsigned) rnp_key_store_get_key_count(keyring));</span>
<a href="#l11.95"></a><span id="l11.95">     /* validate all added keys if not disabled or already validated */</span>
<a href="#l11.96"></a><span id="l11.96">     if (!keyring-&gt;disable_validation &amp;&amp; !added_key-&gt;validated) {</span>
<a href="#l11.97"></a><span id="l11.97">         pgp_key_revalidate_updated(added_key, keyring);</span>
<a href="#l11.98"></a><span id="l11.98">     } else if (!pgp_key_refresh_data(added_key)) {</span>
<a href="#l11.99"></a><span id="l11.99" class="difflineminus">-        RNP_LOG(&quot;Failed to refresh key data&quot;);</span>
<a href="#l11.100"></a><span id="l11.100" class="difflineplus">+        RNP_LOG_KEY(&quot;Failed to refresh key %s data&quot;, srckey);</span>
<a href="#l11.101"></a><span id="l11.101">     }</span>
<a href="#l11.102"></a><span id="l11.102">     return added_key;</span>
<a href="#l11.103"></a><span id="l11.103"> }</span>
<a href="#l11.104"></a><span id="l11.104"> </span>
<a href="#l11.105"></a><span id="l11.105"> pgp_key_t *</span>
<a href="#l11.106"></a><span id="l11.106"> rnp_key_store_import_key(rnp_key_store_t *        keyring,</span>
<a href="#l11.107"></a><span id="l11.107">                          pgp_key_t *              srckey,</span>
<a href="#l11.108"></a><span id="l11.108">                          bool                     pubkey,</span>
<a href="#l11.109"></a><span id="l11.109" class="difflineat">@@ -530,17 +534,17 @@ rnp_key_store_import_key(rnp_key_store_t</span>
<a href="#l11.110"></a><span id="l11.110"> {</span>
<a href="#l11.111"></a><span id="l11.111">     pgp_key_t  keycp = {};</span>
<a href="#l11.112"></a><span id="l11.112">     pgp_key_t *exkey = NULL;</span>
<a href="#l11.113"></a><span id="l11.113">     size_t     expackets = 0;</span>
<a href="#l11.114"></a><span id="l11.114">     bool       changed = false;</span>
<a href="#l11.115"></a><span id="l11.115"> </span>
<a href="#l11.116"></a><span id="l11.116">     /* add public key */</span>
<a href="#l11.117"></a><span id="l11.117">     if (pgp_key_copy(&amp;keycp, srckey, pubkey)) {</span>
<a href="#l11.118"></a><span id="l11.118" class="difflineminus">-        RNP_LOG(&quot;failed to create key copy&quot;);</span>
<a href="#l11.119"></a><span id="l11.119" class="difflineplus">+        RNP_LOG_KEY(&quot;failed to create key %s copy&quot;, srckey);</span>
<a href="#l11.120"></a><span id="l11.120">         return NULL;</span>
<a href="#l11.121"></a><span id="l11.121">     }</span>
<a href="#l11.122"></a><span id="l11.122">     exkey = rnp_key_store_get_key_by_grip(keyring, pgp_key_get_grip(srckey));</span>
<a href="#l11.123"></a><span id="l11.123">     expackets = exkey ? pgp_key_get_rawpacket_count(exkey) : 0;</span>
<a href="#l11.124"></a><span id="l11.124">     keyring-&gt;disable_validation = true;</span>
<a href="#l11.125"></a><span id="l11.125">     exkey = rnp_key_store_add_key(keyring, &amp;keycp);</span>
<a href="#l11.126"></a><span id="l11.126">     keyring-&gt;disable_validation = false;</span>
<a href="#l11.127"></a><span id="l11.127">     if (!exkey) {</span>
<a href="#l11.128"></a><span id="l11.128" class="difflineat">@@ -962,15 +966,16 @@ rnp_key_store_t::rnp_key_store_t(pgp_key</span>
<a href="#l11.129"></a><span id="l11.129"> {</span>
<a href="#l11.130"></a><span id="l11.130">     if (_format == PGP_KEY_STORE_UNKNOWN) {</span>
<a href="#l11.131"></a><span id="l11.131">         RNP_LOG(&quot;Invalid key store format&quot;);</span>
<a href="#l11.132"></a><span id="l11.132">         throw std::invalid_argument(&quot;format&quot;);</span>
<a href="#l11.133"></a><span id="l11.133">     }</span>
<a href="#l11.134"></a><span id="l11.134">     format = _format;</span>
<a href="#l11.135"></a><span id="l11.135">     path = _path;</span>
<a href="#l11.136"></a><span id="l11.136">     disable_validation = false;</span>
<a href="#l11.137"></a><span id="l11.137" class="difflineplus">+    skip_parsing_errors = false;</span>
<a href="#l11.138"></a><span id="l11.138">     blobs = NULL;</span>
<a href="#l11.139"></a><span id="l11.139"> }</span>
<a href="#l11.140"></a><span id="l11.140"> </span>
<a href="#l11.141"></a><span id="l11.141"> rnp_key_store_t::~rnp_key_store_t()</span>
<a href="#l11.142"></a><span id="l11.142"> {</span>
<a href="#l11.143"></a><span id="l11.143">     rnp_key_store_clear(this);</span>
<a href="#l11.144"></a><span id="l11.144"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-key.cpp</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-key.cpp</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -26,28 +26,30 @@</span>
<a href="#l12.4"></a><span id="l12.4"> </span>
<a href="#l12.5"></a><span id="l12.5"> #include &quot;config.h&quot;</span>
<a href="#l12.6"></a><span id="l12.6"> #include &lt;sys/stat.h&gt;</span>
<a href="#l12.7"></a><span id="l12.7"> #include &lt;stdlib.h&gt;</span>
<a href="#l12.8"></a><span id="l12.8"> #include &lt;stdio.h&gt;</span>
<a href="#l12.9"></a><span id="l12.9"> #include &lt;unistd.h&gt;</span>
<a href="#l12.10"></a><span id="l12.10"> #include &lt;string.h&gt;</span>
<a href="#l12.11"></a><span id="l12.11"> #include &lt;time.h&gt;</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+#include &lt;inttypes.h&gt;</span>
<a href="#l12.13"></a><span id="l12.13"> #include &quot;stream-def.h&quot;</span>
<a href="#l12.14"></a><span id="l12.14"> #include &quot;stream-key.h&quot;</span>
<a href="#l12.15"></a><span id="l12.15"> #include &quot;stream-armor.h&quot;</span>
<a href="#l12.16"></a><span id="l12.16"> #include &quot;stream-packet.h&quot;</span>
<a href="#l12.17"></a><span id="l12.17"> #include &quot;stream-sig.h&quot;</span>
<a href="#l12.18"></a><span id="l12.18"> #include &quot;types.h&quot;</span>
<a href="#l12.19"></a><span id="l12.19"> #include &quot;fingerprint.h&quot;</span>
<a href="#l12.20"></a><span id="l12.20"> #include &quot;pgp-key.h&quot;</span>
<a href="#l12.21"></a><span id="l12.21"> #include &quot;list.h&quot;</span>
<a href="#l12.22"></a><span id="l12.22"> #include &quot;crypto.h&quot;</span>
<a href="#l12.23"></a><span id="l12.23"> #include &quot;crypto/signatures.h&quot;</span>
<a href="#l12.24"></a><span id="l12.24"> #include &quot;../librekey/key_store_pgp.h&quot;</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+#include &lt;set&gt;</span>
<a href="#l12.26"></a><span id="l12.26"> </span>
<a href="#l12.27"></a><span id="l12.27"> void</span>
<a href="#l12.28"></a><span id="l12.28"> transferable_subkey_destroy(pgp_transferable_subkey_t *subkey)</span>
<a href="#l12.29"></a><span id="l12.29"> {</span>
<a href="#l12.30"></a><span id="l12.30">     forget_secret_key_fields(&amp;subkey-&gt;subkey.material);</span>
<a href="#l12.31"></a><span id="l12.31">     free_key_pkt(&amp;subkey-&gt;subkey);</span>
<a href="#l12.32"></a><span id="l12.32">     signature_list_destroy(&amp;subkey-&gt;signatures);</span>
<a href="#l12.33"></a><span id="l12.33"> }</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineat">@@ -162,17 +164,17 @@ transferable_subkey_from_key(pgp_transfe</span>
<a href="#l12.35"></a><span id="l12.35"> {</span>
<a href="#l12.36"></a><span id="l12.36">     pgp_source_t memsrc = {};</span>
<a href="#l12.37"></a><span id="l12.37">     rnp_result_t ret = RNP_ERROR_GENERIC;</span>
<a href="#l12.38"></a><span id="l12.38"> </span>
<a href="#l12.39"></a><span id="l12.39">     if (!rnp_key_to_src(key, &amp;memsrc)) {</span>
<a href="#l12.40"></a><span id="l12.40">         return RNP_ERROR_BAD_STATE;</span>
<a href="#l12.41"></a><span id="l12.41">     }</span>
<a href="#l12.42"></a><span id="l12.42"> </span>
<a href="#l12.43"></a><span id="l12.43" class="difflineminus">-    ret = process_pgp_subkey(&amp;memsrc, dst);</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+    ret = process_pgp_subkey(&amp;memsrc, dst, false);</span>
<a href="#l12.45"></a><span id="l12.45">     src_close(&amp;memsrc);</span>
<a href="#l12.46"></a><span id="l12.46">     return ret;</span>
<a href="#l12.47"></a><span id="l12.47"> }</span>
<a href="#l12.48"></a><span id="l12.48"> </span>
<a href="#l12.49"></a><span id="l12.49"> rnp_result_t</span>
<a href="#l12.50"></a><span id="l12.50"> transferable_subkey_merge(pgp_transferable_subkey_t *dst, const pgp_transferable_subkey_t *src)</span>
<a href="#l12.51"></a><span id="l12.51"> {</span>
<a href="#l12.52"></a><span id="l12.52">     rnp_result_t ret = RNP_ERROR_GENERIC;</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineat">@@ -234,17 +236,17 @@ transferable_key_from_key(pgp_transferab</span>
<a href="#l12.54"></a><span id="l12.54"> {</span>
<a href="#l12.55"></a><span id="l12.55">     pgp_source_t memsrc = {};</span>
<a href="#l12.56"></a><span id="l12.56">     rnp_result_t ret = RNP_ERROR_GENERIC;</span>
<a href="#l12.57"></a><span id="l12.57"> </span>
<a href="#l12.58"></a><span id="l12.58">     if (!rnp_key_to_src(key, &amp;memsrc)) {</span>
<a href="#l12.59"></a><span id="l12.59">         return RNP_ERROR_BAD_STATE;</span>
<a href="#l12.60"></a><span id="l12.60">     }</span>
<a href="#l12.61"></a><span id="l12.61"> </span>
<a href="#l12.62"></a><span id="l12.62" class="difflineminus">-    ret = process_pgp_key(&amp;memsrc, dst);</span>
<a href="#l12.63"></a><span id="l12.63" class="difflineplus">+    ret = process_pgp_key(&amp;memsrc, dst, false);</span>
<a href="#l12.64"></a><span id="l12.64">     src_close(&amp;memsrc);</span>
<a href="#l12.65"></a><span id="l12.65">     return ret;</span>
<a href="#l12.66"></a><span id="l12.66"> }</span>
<a href="#l12.67"></a><span id="l12.67"> </span>
<a href="#l12.68"></a><span id="l12.68"> static pgp_transferable_userid_t *</span>
<a href="#l12.69"></a><span id="l12.69"> transferable_key_has_userid(const pgp_transferable_key_t *src, const pgp_userid_pkt_t *userid)</span>
<a href="#l12.70"></a><span id="l12.70"> {</span>
<a href="#l12.71"></a><span id="l12.71">     for (list_item *uid = list_front(src-&gt;userids); uid; uid = list_next(uid)) {</span>
<a href="#l12.72"></a><span id="l12.72" class="difflineat">@@ -760,118 +762,130 @@ void</span>
<a href="#l12.73"></a><span id="l12.73"> key_sequence_destroy(pgp_key_sequence_t *keys)</span>
<a href="#l12.74"></a><span id="l12.74"> {</span>
<a href="#l12.75"></a><span id="l12.75">     for (list_item *li = list_front(keys-&gt;keys); li; li = list_next(li)) {</span>
<a href="#l12.76"></a><span id="l12.76">         transferable_key_destroy((pgp_transferable_key_t *) li);</span>
<a href="#l12.77"></a><span id="l12.77">     }</span>
<a href="#l12.78"></a><span id="l12.78">     list_destroy(&amp;keys-&gt;keys);</span>
<a href="#l12.79"></a><span id="l12.79"> }</span>
<a href="#l12.80"></a><span id="l12.80"> </span>
<a href="#l12.81"></a><span id="l12.81" class="difflineminus">-static rnp_result_t</span>
<a href="#l12.82"></a><span id="l12.82" class="difflineminus">-process_pgp_key_trusts(pgp_source_t *src)</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineplus">+static bool</span>
<a href="#l12.84"></a><span id="l12.84" class="difflineplus">+skip_pgp_packets(pgp_source_t *src, const std::set&lt;pgp_pkt_type_t&gt; &amp;pkts)</span>
<a href="#l12.85"></a><span id="l12.85"> {</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineminus">-    rnp_result_t ret;</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineminus">-    while (stream_pkt_type(src) == PGP_PKT_TRUST) {</span>
<a href="#l12.88"></a><span id="l12.88" class="difflineminus">-        if ((ret = stream_skip_packet(src))) {</span>
<a href="#l12.89"></a><span id="l12.89" class="difflineminus">-            RNP_LOG(&quot;failed to skip trust packet&quot;);</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineminus">-            return ret;</span>
<a href="#l12.91"></a><span id="l12.91" class="difflineplus">+    do {</span>
<a href="#l12.92"></a><span id="l12.92" class="difflineplus">+        int pkt = stream_pkt_type(src);</span>
<a href="#l12.93"></a><span id="l12.93" class="difflineplus">+        if (pkt &lt;= 0) {</span>
<a href="#l12.94"></a><span id="l12.94" class="difflineplus">+            break;</span>
<a href="#l12.95"></a><span id="l12.95" class="difflineplus">+        }</span>
<a href="#l12.96"></a><span id="l12.96" class="difflineplus">+        if (pkts.find((pgp_pkt_type_t) pkt) == pkts.end()) {</span>
<a href="#l12.97"></a><span id="l12.97" class="difflineplus">+            return true;</span>
<a href="#l12.98"></a><span id="l12.98">         }</span>
<a href="#l12.99"></a><span id="l12.99" class="difflineminus">-    }</span>
<a href="#l12.100"></a><span id="l12.100" class="difflineminus">-    return RNP_SUCCESS;</span>
<a href="#l12.101"></a><span id="l12.101" class="difflineplus">+        uint64_t ppos = src-&gt;readb;</span>
<a href="#l12.102"></a><span id="l12.102" class="difflineplus">+        if (stream_skip_packet(src)) {</span>
<a href="#l12.103"></a><span id="l12.103" class="difflineplus">+            RNP_LOG(&quot;failed to skip packet at %&quot; PRIu64, ppos);</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineplus">+            return false;</span>
<a href="#l12.105"></a><span id="l12.105" class="difflineplus">+        }</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineplus">+    } while (1);</span>
<a href="#l12.107"></a><span id="l12.107" class="difflineplus">+</span>
<a href="#l12.108"></a><span id="l12.108" class="difflineplus">+    return true;</span>
<a href="#l12.109"></a><span id="l12.109"> }</span>
<a href="#l12.110"></a><span id="l12.110"> </span>
<a href="#l12.111"></a><span id="l12.111"> static rnp_result_t</span>
<a href="#l12.112"></a><span id="l12.112" class="difflineminus">-process_pgp_key_signatures(pgp_source_t *src, list *sigs)</span>
<a href="#l12.113"></a><span id="l12.113" class="difflineplus">+process_pgp_key_signatures(pgp_source_t *src, list *sigs, bool skiperrors)</span>
<a href="#l12.114"></a><span id="l12.114"> {</span>
<a href="#l12.115"></a><span id="l12.115">     int          ptag;</span>
<a href="#l12.116"></a><span id="l12.116">     rnp_result_t ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.117"></a><span id="l12.117"> </span>
<a href="#l12.118"></a><span id="l12.118">     while ((ptag = stream_pkt_type(src)) == PGP_PKT_SIGNATURE) {</span>
<a href="#l12.119"></a><span id="l12.119">         pgp_signature_t *sig = (pgp_signature_t *) list_append(sigs, NULL, sizeof(*sig));</span>
<a href="#l12.120"></a><span id="l12.120">         if (!sig) {</span>
<a href="#l12.121"></a><span id="l12.121">             RNP_LOG(&quot;sig alloc failed&quot;);</span>
<a href="#l12.122"></a><span id="l12.122">             return RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l12.123"></a><span id="l12.123">         }</span>
<a href="#l12.124"></a><span id="l12.124"> </span>
<a href="#l12.125"></a><span id="l12.125" class="difflineplus">+        uint64_t sigpos = src-&gt;readb;</span>
<a href="#l12.126"></a><span id="l12.126">         if ((ret = stream_parse_signature(src, sig))) {</span>
<a href="#l12.127"></a><span id="l12.127" class="difflineplus">+            RNP_LOG(&quot;failed to parse signature at %&quot; PRIu64, sigpos);</span>
<a href="#l12.128"></a><span id="l12.128">             list_remove((list_item *) sig);</span>
<a href="#l12.129"></a><span id="l12.129" class="difflineminus">-            return ret;</span>
<a href="#l12.130"></a><span id="l12.130" class="difflineplus">+            if (!skiperrors) {</span>
<a href="#l12.131"></a><span id="l12.131" class="difflineplus">+                return ret;</span>
<a href="#l12.132"></a><span id="l12.132" class="difflineplus">+            }</span>
<a href="#l12.133"></a><span id="l12.133">         }</span>
<a href="#l12.134"></a><span id="l12.134"> </span>
<a href="#l12.135"></a><span id="l12.135" class="difflineminus">-        if ((ret = process_pgp_key_trusts(src))) {</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineminus">-            return ret;</span>
<a href="#l12.137"></a><span id="l12.137" class="difflineplus">+        if (!skip_pgp_packets(src, {PGP_PKT_TRUST})) {</span>
<a href="#l12.138"></a><span id="l12.138" class="difflineplus">+            return RNP_ERROR_READ;</span>
<a href="#l12.139"></a><span id="l12.139">         }</span>
<a href="#l12.140"></a><span id="l12.140">     }</span>
<a href="#l12.141"></a><span id="l12.141"> </span>
<a href="#l12.142"></a><span id="l12.142">     return ptag &lt; 0 ? RNP_ERROR_BAD_FORMAT : RNP_SUCCESS;</span>
<a href="#l12.143"></a><span id="l12.143"> }</span>
<a href="#l12.144"></a><span id="l12.144"> </span>
<a href="#l12.145"></a><span id="l12.145" class="difflineminus">-rnp_result_t</span>
<a href="#l12.146"></a><span id="l12.146" class="difflineminus">-process_pgp_userid(pgp_source_t *src, pgp_transferable_userid_t *uid)</span>
<a href="#l12.147"></a><span id="l12.147" class="difflineplus">+static rnp_result_t</span>
<a href="#l12.148"></a><span id="l12.148" class="difflineplus">+process_pgp_userid(pgp_source_t *src, pgp_transferable_userid_t *uid, bool skiperrors)</span>
<a href="#l12.149"></a><span id="l12.149"> {</span>
<a href="#l12.150"></a><span id="l12.150">     int          ptag;</span>
<a href="#l12.151"></a><span id="l12.151">     rnp_result_t ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.152"></a><span id="l12.152"> </span>
<a href="#l12.153"></a><span id="l12.153">     memset(uid, 0, sizeof(*uid));</span>
<a href="#l12.154"></a><span id="l12.154">     ptag = stream_pkt_type(src);</span>
<a href="#l12.155"></a><span id="l12.155"> </span>
<a href="#l12.156"></a><span id="l12.156" class="difflineminus">-    if ((ptag != PGP_PKT_USER_ID) &amp;&amp; (ptag != PGP_PKT_USER_ATTR)) {</span>
<a href="#l12.157"></a><span id="l12.157" class="difflineminus">-        RNP_LOG(&quot;wrong uid ptag: %d&quot;, ptag);</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineminus">-        return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.159"></a><span id="l12.159" class="difflineminus">-    }</span>
<a href="#l12.160"></a><span id="l12.160" class="difflineminus">-</span>
<a href="#l12.161"></a><span id="l12.161" class="difflineplus">+    uint64_t uidpos = src-&gt;readb;</span>
<a href="#l12.162"></a><span id="l12.162">     if ((ret = stream_parse_userid(src, &amp;uid-&gt;uid))) {</span>
<a href="#l12.163"></a><span id="l12.163" class="difflineplus">+        RNP_LOG(&quot;failed to parse userid at %&quot; PRIu64, uidpos);</span>
<a href="#l12.164"></a><span id="l12.164">         goto done;</span>
<a href="#l12.165"></a><span id="l12.165">     }</span>
<a href="#l12.166"></a><span id="l12.166"> </span>
<a href="#l12.167"></a><span id="l12.167" class="difflineminus">-    if ((ret = process_pgp_key_trusts(src))) {</span>
<a href="#l12.168"></a><span id="l12.168" class="difflineplus">+    if (!skip_pgp_packets(src, {PGP_PKT_TRUST})) {</span>
<a href="#l12.169"></a><span id="l12.169" class="difflineplus">+        ret = RNP_ERROR_READ;</span>
<a href="#l12.170"></a><span id="l12.170">         goto done;</span>
<a href="#l12.171"></a><span id="l12.171">     }</span>
<a href="#l12.172"></a><span id="l12.172"> </span>
<a href="#l12.173"></a><span id="l12.173" class="difflineminus">-    ret = process_pgp_key_signatures(src, &amp;uid-&gt;signatures);</span>
<a href="#l12.174"></a><span id="l12.174" class="difflineplus">+    ret = process_pgp_key_signatures(src, &amp;uid-&gt;signatures, skiperrors);</span>
<a href="#l12.175"></a><span id="l12.175"> done:</span>
<a href="#l12.176"></a><span id="l12.176">     if (ret) {</span>
<a href="#l12.177"></a><span id="l12.177">         transferable_userid_destroy(uid);</span>
<a href="#l12.178"></a><span id="l12.178">         memset(uid, 0, sizeof(*uid));</span>
<a href="#l12.179"></a><span id="l12.179">     }</span>
<a href="#l12.180"></a><span id="l12.180">     return ret;</span>
<a href="#l12.181"></a><span id="l12.181"> }</span>
<a href="#l12.182"></a><span id="l12.182"> </span>
<a href="#l12.183"></a><span id="l12.183"> rnp_result_t</span>
<a href="#l12.184"></a><span id="l12.184" class="difflineminus">-process_pgp_subkey(pgp_source_t *src, pgp_transferable_subkey_t *subkey)</span>
<a href="#l12.185"></a><span id="l12.185" class="difflineplus">+process_pgp_subkey(pgp_source_t *src, pgp_transferable_subkey_t *subkey, bool skiperrors)</span>
<a href="#l12.186"></a><span id="l12.186"> {</span>
<a href="#l12.187"></a><span id="l12.187">     int          ptag;</span>
<a href="#l12.188"></a><span id="l12.188">     rnp_result_t ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.189"></a><span id="l12.189"> </span>
<a href="#l12.190"></a><span id="l12.190">     memset(subkey, 0, sizeof(*subkey));</span>
<a href="#l12.191"></a><span id="l12.191" class="difflineplus">+    uint64_t keypos = src-&gt;readb;</span>
<a href="#l12.192"></a><span id="l12.192">     if (!is_subkey_pkt(ptag = stream_pkt_type(src))) {</span>
<a href="#l12.193"></a><span id="l12.193" class="difflineminus">-        RNP_LOG(&quot;wrong subkey ptag: %d&quot;, ptag);</span>
<a href="#l12.194"></a><span id="l12.194" class="difflineplus">+        RNP_LOG(&quot;wrong subkey ptag: %d at %&quot; PRIu64, ptag, keypos);</span>
<a href="#l12.195"></a><span id="l12.195">         return RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.196"></a><span id="l12.196">     }</span>
<a href="#l12.197"></a><span id="l12.197"> </span>
<a href="#l12.198"></a><span id="l12.198">     if ((ret = stream_parse_key(src, &amp;subkey-&gt;subkey))) {</span>
<a href="#l12.199"></a><span id="l12.199" class="difflineminus">-        RNP_LOG(&quot;failed to parse subkey&quot;);</span>
<a href="#l12.200"></a><span id="l12.200" class="difflineplus">+        RNP_LOG(&quot;failed to parse subkey at %&quot; PRIu64, keypos);</span>
<a href="#l12.201"></a><span id="l12.201">         goto done;</span>
<a href="#l12.202"></a><span id="l12.202">     }</span>
<a href="#l12.203"></a><span id="l12.203"> </span>
<a href="#l12.204"></a><span id="l12.204" class="difflineminus">-    if ((ret = process_pgp_key_trusts(src))) {</span>
<a href="#l12.205"></a><span id="l12.205" class="difflineplus">+    if (!skip_pgp_packets(src, {PGP_PKT_TRUST})) {</span>
<a href="#l12.206"></a><span id="l12.206" class="difflineplus">+        ret = RNP_ERROR_READ;</span>
<a href="#l12.207"></a><span id="l12.207">         goto done;</span>
<a href="#l12.208"></a><span id="l12.208">     }</span>
<a href="#l12.209"></a><span id="l12.209"> </span>
<a href="#l12.210"></a><span id="l12.210" class="difflineminus">-    ret = process_pgp_key_signatures(src, &amp;subkey-&gt;signatures);</span>
<a href="#l12.211"></a><span id="l12.211" class="difflineplus">+    ret = process_pgp_key_signatures(src, &amp;subkey-&gt;signatures, skiperrors);</span>
<a href="#l12.212"></a><span id="l12.212"> done:</span>
<a href="#l12.213"></a><span id="l12.213">     if (ret) {</span>
<a href="#l12.214"></a><span id="l12.214">         transferable_subkey_destroy(subkey);</span>
<a href="#l12.215"></a><span id="l12.215">         memset(subkey, 0, sizeof(*subkey));</span>
<a href="#l12.216"></a><span id="l12.216">     }</span>
<a href="#l12.217"></a><span id="l12.217">     return ret;</span>
<a href="#l12.218"></a><span id="l12.218"> }</span>
<a href="#l12.219"></a><span id="l12.219"> </span>
<a href="#l12.220"></a><span id="l12.220"> rnp_result_t</span>
<a href="#l12.221"></a><span id="l12.221" class="difflineminus">-process_pgp_keys(pgp_source_t *src, pgp_key_sequence_t *keys)</span>
<a href="#l12.222"></a><span id="l12.222" class="difflineplus">+process_pgp_keys(pgp_source_t *src, pgp_key_sequence_t *keys, bool skiperrors)</span>
<a href="#l12.223"></a><span id="l12.223"> {</span>
<a href="#l12.224"></a><span id="l12.224">     int                     ptag;</span>
<a href="#l12.225"></a><span id="l12.225">     bool                    armored = false;</span>
<a href="#l12.226"></a><span id="l12.226">     pgp_source_t            armorsrc = {0};</span>
<a href="#l12.227"></a><span id="l12.227">     pgp_source_t *          origsrc = src;</span>
<a href="#l12.228"></a><span id="l12.228">     bool                    has_secret = false;</span>
<a href="#l12.229"></a><span id="l12.229">     bool                    has_public = false;</span>
<a href="#l12.230"></a><span id="l12.230">     pgp_transferable_key_t *curkey = NULL;</span>
<a href="#l12.231"></a><span id="l12.231" class="difflineat">@@ -888,31 +902,42 @@ armoredpass:</span>
<a href="#l12.232"></a><span id="l12.232">         }</span>
<a href="#l12.233"></a><span id="l12.233">         armored = true;</span>
<a href="#l12.234"></a><span id="l12.234">         src = &amp;armorsrc;</span>
<a href="#l12.235"></a><span id="l12.235">     }</span>
<a href="#l12.236"></a><span id="l12.236"> </span>
<a href="#l12.237"></a><span id="l12.237">     /* read sequence of transferable OpenPGP keys as described in RFC 4880, 11.1 - 11.2 */</span>
<a href="#l12.238"></a><span id="l12.238">     while (!src_eof(src) &amp;&amp; !src_error(src)) {</span>
<a href="#l12.239"></a><span id="l12.239">         ptag = stream_pkt_type(src);</span>
<a href="#l12.240"></a><span id="l12.240" class="difflineminus">-</span>
<a href="#l12.241"></a><span id="l12.241" class="difflineminus">-        if ((ptag &lt; 0) || !is_primary_key_pkt(ptag)) {</span>
<a href="#l12.242"></a><span id="l12.242" class="difflineminus">-            RNP_LOG(&quot;wrong key tag: %d&quot;, ptag);</span>
<a href="#l12.243"></a><span id="l12.243" class="difflineplus">+        if (!is_primary_key_pkt(ptag)) {</span>
<a href="#l12.244"></a><span id="l12.244" class="difflineplus">+            RNP_LOG(&quot;wrong key tag: %d at pos %&quot; PRIu64, ptag, src-&gt;readb);</span>
<a href="#l12.245"></a><span id="l12.245">             ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.246"></a><span id="l12.246">             goto finish;</span>
<a href="#l12.247"></a><span id="l12.247">         }</span>
<a href="#l12.248"></a><span id="l12.248"> </span>
<a href="#l12.249"></a><span id="l12.249">         if (!(curkey =</span>
<a href="#l12.250"></a><span id="l12.250">                 (pgp_transferable_key_t *) list_append(&amp;keys-&gt;keys, NULL, sizeof(*curkey)))) {</span>
<a href="#l12.251"></a><span id="l12.251">             RNP_LOG(&quot;key alloc failed&quot;);</span>
<a href="#l12.252"></a><span id="l12.252">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l12.253"></a><span id="l12.253">             goto finish;</span>
<a href="#l12.254"></a><span id="l12.254">         }</span>
<a href="#l12.255"></a><span id="l12.255"> </span>
<a href="#l12.256"></a><span id="l12.256" class="difflineminus">-        if ((ret = process_pgp_key(src, curkey))) {</span>
<a href="#l12.257"></a><span id="l12.257" class="difflineplus">+        ret = process_pgp_key(src, curkey, skiperrors);</span>
<a href="#l12.258"></a><span id="l12.258" class="difflineplus">+        if ((ret == RNP_ERROR_BAD_FORMAT) &amp;&amp; skiperrors &amp;&amp;</span>
<a href="#l12.259"></a><span id="l12.259" class="difflineplus">+            skip_pgp_packets(src,</span>
<a href="#l12.260"></a><span id="l12.260" class="difflineplus">+                             {PGP_PKT_TRUST,</span>
<a href="#l12.261"></a><span id="l12.261" class="difflineplus">+                              PGP_PKT_SIGNATURE,</span>
<a href="#l12.262"></a><span id="l12.262" class="difflineplus">+                              PGP_PKT_USER_ID,</span>
<a href="#l12.263"></a><span id="l12.263" class="difflineplus">+                              PGP_PKT_USER_ATTR,</span>
<a href="#l12.264"></a><span id="l12.264" class="difflineplus">+                              PGP_PKT_PUBLIC_SUBKEY,</span>
<a href="#l12.265"></a><span id="l12.265" class="difflineplus">+                              PGP_PKT_SECRET_SUBKEY})) {</span>
<a href="#l12.266"></a><span id="l12.266" class="difflineplus">+            list_remove((list_item *) curkey);</span>
<a href="#l12.267"></a><span id="l12.267" class="difflineplus">+            continue;</span>
<a href="#l12.268"></a><span id="l12.268" class="difflineplus">+        }</span>
<a href="#l12.269"></a><span id="l12.269" class="difflineplus">+        if (ret) {</span>
<a href="#l12.270"></a><span id="l12.270">             goto finish;</span>
<a href="#l12.271"></a><span id="l12.271">         }</span>
<a href="#l12.272"></a><span id="l12.272"> </span>
<a href="#l12.273"></a><span id="l12.273">         has_secret |= (ptag == PGP_PKT_SECRET_KEY);</span>
<a href="#l12.274"></a><span id="l12.274">         has_public |= (ptag == PGP_PKT_PUBLIC_KEY);</span>
<a href="#l12.275"></a><span id="l12.275">     }</span>
<a href="#l12.276"></a><span id="l12.276"> </span>
<a href="#l12.277"></a><span id="l12.277">     /* file may have multiple armored keys */</span>
<a href="#l12.278"></a><span id="l12.278" class="difflineat">@@ -934,17 +959,17 @@ finish:</span>
<a href="#l12.279"></a><span id="l12.279">     }</span>
<a href="#l12.280"></a><span id="l12.280">     if (ret) {</span>
<a href="#l12.281"></a><span id="l12.281">         key_sequence_destroy(keys);</span>
<a href="#l12.282"></a><span id="l12.282">     }</span>
<a href="#l12.283"></a><span id="l12.283">     return ret;</span>
<a href="#l12.284"></a><span id="l12.284"> }</span>
<a href="#l12.285"></a><span id="l12.285"> </span>
<a href="#l12.286"></a><span id="l12.286"> rnp_result_t</span>
<a href="#l12.287"></a><span id="l12.287" class="difflineminus">-process_pgp_key(pgp_source_t *src, pgp_transferable_key_t *key)</span>
<a href="#l12.288"></a><span id="l12.288" class="difflineplus">+process_pgp_key(pgp_source_t *src, pgp_transferable_key_t *key, bool skiperrors)</span>
<a href="#l12.289"></a><span id="l12.289"> {</span>
<a href="#l12.290"></a><span id="l12.290">     pgp_source_t armorsrc = {0};</span>
<a href="#l12.291"></a><span id="l12.291">     bool         armored = false;</span>
<a href="#l12.292"></a><span id="l12.292">     int          ptag;</span>
<a href="#l12.293"></a><span id="l12.293">     rnp_result_t ret = RNP_ERROR_GENERIC;</span>
<a href="#l12.294"></a><span id="l12.294"> </span>
<a href="#l12.295"></a><span id="l12.295">     memset(key, 0, sizeof(*key));</span>
<a href="#l12.296"></a><span id="l12.296"> </span>
<a href="#l12.297"></a><span id="l12.297" class="difflineat">@@ -954,72 +979,86 @@ process_pgp_key(pgp_source_t *src, pgp_t</span>
<a href="#l12.298"></a><span id="l12.298">             RNP_LOG(&quot;failed to parse armored data&quot;);</span>
<a href="#l12.299"></a><span id="l12.299">             return ret;</span>
<a href="#l12.300"></a><span id="l12.300">         }</span>
<a href="#l12.301"></a><span id="l12.301">         armored = true;</span>
<a href="#l12.302"></a><span id="l12.302">         src = &amp;armorsrc;</span>
<a href="#l12.303"></a><span id="l12.303">     }</span>
<a href="#l12.304"></a><span id="l12.304"> </span>
<a href="#l12.305"></a><span id="l12.305">     /* main key packet */</span>
<a href="#l12.306"></a><span id="l12.306" class="difflineplus">+    uint64_t keypos = src-&gt;readb;</span>
<a href="#l12.307"></a><span id="l12.307">     ptag = stream_pkt_type(src);</span>
<a href="#l12.308"></a><span id="l12.308">     if ((ptag &lt;= 0) || !is_primary_key_pkt(ptag)) {</span>
<a href="#l12.309"></a><span id="l12.309" class="difflineminus">-        RNP_LOG(&quot;wrong key packet tag: %d&quot;, ptag);</span>
<a href="#l12.310"></a><span id="l12.310" class="difflineplus">+        RNP_LOG(&quot;wrong key packet tag: %d at %&quot; PRIu64, ptag, keypos);</span>
<a href="#l12.311"></a><span id="l12.311">         ret = RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.312"></a><span id="l12.312">         goto finish;</span>
<a href="#l12.313"></a><span id="l12.313">     }</span>
<a href="#l12.314"></a><span id="l12.314"> </span>
<a href="#l12.315"></a><span id="l12.315">     if ((ret = stream_parse_key(src, &amp;key-&gt;key))) {</span>
<a href="#l12.316"></a><span id="l12.316" class="difflineminus">-        RNP_LOG(&quot;failed to parse key pkt&quot;);</span>
<a href="#l12.317"></a><span id="l12.317" class="difflineplus">+        RNP_LOG(&quot;failed to parse key pkt at %&quot; PRIu64, keypos);</span>
<a href="#l12.318"></a><span id="l12.318">         goto finish;</span>
<a href="#l12.319"></a><span id="l12.319">     }</span>
<a href="#l12.320"></a><span id="l12.320"> </span>
<a href="#l12.321"></a><span id="l12.321" class="difflineminus">-    if ((ret = process_pgp_key_trusts(src))) {</span>
<a href="#l12.322"></a><span id="l12.322" class="difflineplus">+    if (!skip_pgp_packets(src, {PGP_PKT_TRUST})) {</span>
<a href="#l12.323"></a><span id="l12.323" class="difflineplus">+        ret = RNP_ERROR_READ;</span>
<a href="#l12.324"></a><span id="l12.324">         goto finish;</span>
<a href="#l12.325"></a><span id="l12.325">     }</span>
<a href="#l12.326"></a><span id="l12.326"> </span>
<a href="#l12.327"></a><span id="l12.327">     /* direct-key signatures */</span>
<a href="#l12.328"></a><span id="l12.328" class="difflineminus">-    if ((ret = process_pgp_key_signatures(src, &amp;key-&gt;signatures))) {</span>
<a href="#l12.329"></a><span id="l12.329" class="difflineminus">-        RNP_LOG(&quot;failed to parse key sigs&quot;);</span>
<a href="#l12.330"></a><span id="l12.330" class="difflineplus">+    if ((ret = process_pgp_key_signatures(src, &amp;key-&gt;signatures, skiperrors))) {</span>
<a href="#l12.331"></a><span id="l12.331">         goto finish;</span>
<a href="#l12.332"></a><span id="l12.332">     }</span>
<a href="#l12.333"></a><span id="l12.333"> </span>
<a href="#l12.334"></a><span id="l12.334">     /* user ids/attrs with signatures */</span>
<a href="#l12.335"></a><span id="l12.335" class="difflineminus">-    while ((ptag = stream_pkt_type(src))) {</span>
<a href="#l12.336"></a><span id="l12.336" class="difflineplus">+    while ((ptag = stream_pkt_type(src)) &gt; 0) {</span>
<a href="#l12.337"></a><span id="l12.337">         if ((ptag != PGP_PKT_USER_ID) &amp;&amp; (ptag != PGP_PKT_USER_ATTR)) {</span>
<a href="#l12.338"></a><span id="l12.338">             break;</span>
<a href="#l12.339"></a><span id="l12.339">         }</span>
<a href="#l12.340"></a><span id="l12.340"> </span>
<a href="#l12.341"></a><span id="l12.341">         pgp_transferable_userid_t *uid =</span>
<a href="#l12.342"></a><span id="l12.342">           (pgp_transferable_userid_t *) list_append(&amp;key-&gt;userids, NULL, sizeof(*uid));</span>
<a href="#l12.343"></a><span id="l12.343">         if (!uid) {</span>
<a href="#l12.344"></a><span id="l12.344">             RNP_LOG(&quot;uid alloc failed&quot;);</span>
<a href="#l12.345"></a><span id="l12.345">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l12.346"></a><span id="l12.346">             goto finish;</span>
<a href="#l12.347"></a><span id="l12.347">         }</span>
<a href="#l12.348"></a><span id="l12.348"> </span>
<a href="#l12.349"></a><span id="l12.349" class="difflineminus">-        if ((ret = process_pgp_userid(src, uid))) {</span>
<a href="#l12.350"></a><span id="l12.350" class="difflineplus">+        ret = process_pgp_userid(src, uid, skiperrors);</span>
<a href="#l12.351"></a><span id="l12.351" class="difflineplus">+        if ((ret == RNP_ERROR_BAD_FORMAT) &amp;&amp; skiperrors &amp;&amp;</span>
<a href="#l12.352"></a><span id="l12.352" class="difflineplus">+            skip_pgp_packets(src, {PGP_PKT_TRUST, PGP_PKT_SIGNATURE})) {</span>
<a href="#l12.353"></a><span id="l12.353" class="difflineplus">+            /* skip malformed uid */</span>
<a href="#l12.354"></a><span id="l12.354" class="difflineplus">+            continue;</span>
<a href="#l12.355"></a><span id="l12.355" class="difflineplus">+        }</span>
<a href="#l12.356"></a><span id="l12.356" class="difflineplus">+        if (ret) {</span>
<a href="#l12.357"></a><span id="l12.357">             goto finish;</span>
<a href="#l12.358"></a><span id="l12.358">         }</span>
<a href="#l12.359"></a><span id="l12.359">     }</span>
<a href="#l12.360"></a><span id="l12.360"> </span>
<a href="#l12.361"></a><span id="l12.361">     /* subkeys with signatures */</span>
<a href="#l12.362"></a><span id="l12.362" class="difflineminus">-    while ((ptag = stream_pkt_type(src))) {</span>
<a href="#l12.363"></a><span id="l12.363" class="difflineplus">+    while ((ptag = stream_pkt_type(src)) &gt; 0) {</span>
<a href="#l12.364"></a><span id="l12.364">         if (!is_subkey_pkt(ptag)) {</span>
<a href="#l12.365"></a><span id="l12.365">             break;</span>
<a href="#l12.366"></a><span id="l12.366">         }</span>
<a href="#l12.367"></a><span id="l12.367"> </span>
<a href="#l12.368"></a><span id="l12.368">         pgp_transferable_subkey_t *subkey =</span>
<a href="#l12.369"></a><span id="l12.369">           (pgp_transferable_subkey_t *) list_append(&amp;key-&gt;subkeys, NULL, sizeof(*subkey));</span>
<a href="#l12.370"></a><span id="l12.370">         if (!subkey) {</span>
<a href="#l12.371"></a><span id="l12.371">             RNP_LOG(&quot;subkey alloc failed&quot;);</span>
<a href="#l12.372"></a><span id="l12.372">             ret = RNP_ERROR_OUT_OF_MEMORY;</span>
<a href="#l12.373"></a><span id="l12.373">             goto finish;</span>
<a href="#l12.374"></a><span id="l12.374">         }</span>
<a href="#l12.375"></a><span id="l12.375"> </span>
<a href="#l12.376"></a><span id="l12.376" class="difflineminus">-        if ((ret = process_pgp_subkey(src, subkey))) {</span>
<a href="#l12.377"></a><span id="l12.377" class="difflineplus">+        ret = process_pgp_subkey(src, subkey, skiperrors);</span>
<a href="#l12.378"></a><span id="l12.378" class="difflineplus">+        if ((ret == RNP_ERROR_BAD_FORMAT) &amp;&amp; skiperrors &amp;&amp;</span>
<a href="#l12.379"></a><span id="l12.379" class="difflineplus">+            skip_pgp_packets(src, {PGP_PKT_TRUST, PGP_PKT_SIGNATURE})) {</span>
<a href="#l12.380"></a><span id="l12.380" class="difflineplus">+            list_remove((list_item *) subkey);</span>
<a href="#l12.381"></a><span id="l12.381" class="difflineplus">+            /* skip malformed subkey */</span>
<a href="#l12.382"></a><span id="l12.382" class="difflineplus">+            continue;</span>
<a href="#l12.383"></a><span id="l12.383" class="difflineplus">+        }</span>
<a href="#l12.384"></a><span id="l12.384" class="difflineplus">+        if (ret) {</span>
<a href="#l12.385"></a><span id="l12.385">             goto finish;</span>
<a href="#l12.386"></a><span id="l12.386">         }</span>
<a href="#l12.387"></a><span id="l12.387">     }</span>
<a href="#l12.388"></a><span id="l12.388"> </span>
<a href="#l12.389"></a><span id="l12.389">     ret = ptag &gt;= 0 ? RNP_SUCCESS : RNP_ERROR_BAD_FORMAT;</span>
<a href="#l12.390"></a><span id="l12.390"> finish:</span>
<a href="#l12.391"></a><span id="l12.391">     if (armored) {</span>
<a href="#l12.392"></a><span id="l12.392">         src_close(&amp;armorsrc);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-key.h</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-key.h</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -100,23 +100,23 @@ pgp_signature_t *transferable_subkey_bin</span>
<a href="#l13.4"></a><span id="l13.4"> </span>
<a href="#l13.5"></a><span id="l13.5"> pgp_signature_t *transferable_key_revoke(const pgp_key_pkt_t *key,</span>
<a href="#l13.6"></a><span id="l13.6">                                          const pgp_key_pkt_t *signer,</span>
<a href="#l13.7"></a><span id="l13.7">                                          pgp_hash_alg_t       hash_alg,</span>
<a href="#l13.8"></a><span id="l13.8">                                          const pgp_revoke_t * revoke);</span>
<a href="#l13.9"></a><span id="l13.9"> </span>
<a href="#l13.10"></a><span id="l13.10"> void key_sequence_destroy(pgp_key_sequence_t *keys);</span>
<a href="#l13.11"></a><span id="l13.11"> </span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-rnp_result_t process_pgp_keys(pgp_source_t *src, pgp_key_sequence_t *keys);</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+rnp_result_t process_pgp_keys(pgp_source_t *src, pgp_key_sequence_t *keys, bool skiperrors);</span>
<a href="#l13.14"></a><span id="l13.14"> </span>
<a href="#l13.15"></a><span id="l13.15" class="difflineminus">-rnp_result_t process_pgp_key(pgp_source_t *src, pgp_transferable_key_t *key);</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+rnp_result_t process_pgp_key(pgp_source_t *src, pgp_transferable_key_t *key, bool skiperrors);</span>
<a href="#l13.17"></a><span id="l13.17"> </span>
<a href="#l13.18"></a><span id="l13.18" class="difflineminus">-rnp_result_t process_pgp_subkey(pgp_source_t *src, pgp_transferable_subkey_t *subkey);</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineminus">-</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineminus">-rnp_result_t process_pgp_userid(pgp_source_t *src, pgp_transferable_userid_t *uid);</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+rnp_result_t process_pgp_subkey(pgp_source_t *             src,</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineplus">+                                pgp_transferable_subkey_t *subkey,</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+                                bool                       skiperrors);</span>
<a href="#l13.24"></a><span id="l13.24"> </span>
<a href="#l13.25"></a><span id="l13.25"> rnp_result_t write_pgp_key(pgp_transferable_key_t *key, pgp_dest_t *dst, bool armor);</span>
<a href="#l13.26"></a><span id="l13.26"> </span>
<a href="#l13.27"></a><span id="l13.27"> rnp_result_t write_pgp_keys(pgp_key_sequence_t *keys, pgp_dest_t *dst, bool armor);</span>
<a href="#l13.28"></a><span id="l13.28"> </span>
<a href="#l13.29"></a><span id="l13.29"> rnp_result_t decrypt_secret_key(pgp_key_pkt_t *key, const char *password);</span>
<a href="#l13.30"></a><span id="l13.30"> </span>
<a href="#l13.31"></a><span id="l13.31"> rnp_result_t encrypt_secret_key(pgp_key_pkt_t *key, const char *password, rng_t *rng);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/third_party/rnp/src/librepgp/stream-packet.cpp</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/third_party/rnp/src/librepgp/stream-packet.cpp</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -956,29 +956,35 @@ stream_write_signature(const pgp_signatu</span>
<a href="#l14.4"></a><span id="l14.4">               add_packet_body_subpackets(&amp;pktbody, sig, false);</span>
<a href="#l14.5"></a><span id="l14.5">     }</span>
<a href="#l14.6"></a><span id="l14.6"> </span>
<a href="#l14.7"></a><span id="l14.7">     res &amp;= add_packet_body(&amp;pktbody, sig-&gt;lbits, 2);</span>
<a href="#l14.8"></a><span id="l14.8"> </span>
<a href="#l14.9"></a><span id="l14.9">     /* write mpis */</span>
<a href="#l14.10"></a><span id="l14.10">     switch (sig-&gt;palg) {</span>
<a href="#l14.11"></a><span id="l14.11">     case PGP_PKA_RSA:</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+    case PGP_PKA_RSA_SIGN_ONLY:</span>
<a href="#l14.13"></a><span id="l14.13">         res &amp;= add_packet_body_mpi(&amp;pktbody, &amp;sig-&gt;material.rsa.s);</span>
<a href="#l14.14"></a><span id="l14.14">         break;</span>
<a href="#l14.15"></a><span id="l14.15">     case PGP_PKA_DSA:</span>
<a href="#l14.16"></a><span id="l14.16">         res &amp;= add_packet_body_mpi(&amp;pktbody, &amp;sig-&gt;material.dsa.r) &amp;&amp;</span>
<a href="#l14.17"></a><span id="l14.17">                add_packet_body_mpi(&amp;pktbody, &amp;sig-&gt;material.dsa.s);</span>
<a href="#l14.18"></a><span id="l14.18">         break;</span>
<a href="#l14.19"></a><span id="l14.19">     case PGP_PKA_EDDSA:</span>
<a href="#l14.20"></a><span id="l14.20">     case PGP_PKA_ECDSA:</span>
<a href="#l14.21"></a><span id="l14.21">     case PGP_PKA_SM2:</span>
<a href="#l14.22"></a><span id="l14.22">     case PGP_PKA_ECDH:</span>
<a href="#l14.23"></a><span id="l14.23">         res &amp;= add_packet_body_mpi(&amp;pktbody, &amp;sig-&gt;material.ecc.r) &amp;&amp;</span>
<a href="#l14.24"></a><span id="l14.24">                add_packet_body_mpi(&amp;pktbody, &amp;sig-&gt;material.ecc.s);</span>
<a href="#l14.25"></a><span id="l14.25">         break;</span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+    case PGP_PKA_ELGAMAL: /* we support writing it but will not generate */</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+    case PGP_PKA_ELGAMAL_ENCRYPT_OR_SIGN:</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+        res &amp;= add_packet_body_mpi(&amp;pktbody, &amp;sig-&gt;material.eg.r) &amp;&amp;</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+               add_packet_body_mpi(&amp;pktbody, &amp;sig-&gt;material.eg.s);</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+        break;</span>
<a href="#l14.31"></a><span id="l14.31">     default:</span>
<a href="#l14.32"></a><span id="l14.32">         RNP_LOG(&quot;Unknown pk algorithm : %d&quot;, (int) sig-&gt;palg);</span>
<a href="#l14.33"></a><span id="l14.33">         res = false;</span>
<a href="#l14.34"></a><span id="l14.34">     }</span>
<a href="#l14.35"></a><span id="l14.35"> </span>
<a href="#l14.36"></a><span id="l14.36">     if (res) {</span>
<a href="#l14.37"></a><span id="l14.37">         stream_flush_packet_body(&amp;pktbody, dst);</span>
<a href="#l14.38"></a><span id="l14.38">         return dst-&gt;werr == RNP_SUCCESS;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..c7fd4ca65b6b0080593a405d5572b9177c1114b3</span>
<a href="#l15.3"></a><span id="l15.3">GIT binary patch
literal 2138
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
Q-=(+9-Ozv8&amp;in}x{u;{t7ytkO</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1">new file mode 100644</span>
<a href="#l16.2"></a><span id="l16.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..cf31e20e6cb4a7fc1b9375008b0f39c54a7f9801</span>
<a href="#l16.3"></a><span id="l16.3">GIT binary patch
literal 2330
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
A`v3p{</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1">new file mode 100644</span>
<a href="#l17.2"></a><span id="l17.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..04acb2f9b8efe05d187ac32b22f5d07df039b9b4</span>
<a href="#l17.3"></a><span id="l17.3">GIT binary patch
literal 3535
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
CYW*kx</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1">new file mode 100644</span>
<a href="#l18.2"></a><span id="l18.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..21eb20f89501f82959c0881d8e9b0766230b071f</span>
<a href="#l18.3"></a><span id="l18.3">GIT binary patch
literal 3535
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
C0{$ET</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1">new file mode 100644</span>
<a href="#l19.2"></a><span id="l19.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..b5f1ff9d24fd11ce3ecb170ade8c7c3cd14acd83</span>
<a href="#l19.3"></a><span id="l19.3">GIT binary patch
literal 3535
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
E1ilyjC;$Ke</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1">new file mode 100644</span>
<a href="#l20.2"></a><span id="l20.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..8d11977af4be0bd7dbb1bf611f0242212b8b04c0</span>
<a href="#l20.3"></a><span id="l20.3">GIT binary patch
literal 3535
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
B{VxCj</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1">new file mode 100644</span>
<a href="#l21.2"></a><span id="l21.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..cfd1c0cbae679c2da9a24bc6cf203dcb66756ce5</span>
<a href="#l21.3"></a><span id="l21.3">GIT binary patch
literal 4909
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
Q$Yle?{&gt;t&gt;n@Sjcn3u}_H4FCWD</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1">new file mode 100644</span>
<a href="#l22.2"></a><span id="l22.2">index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..4a6bf8d7b5b624b721773693705a9c9e6f495bfe</span>
<a href="#l22.3"></a><span id="l22.3">GIT binary patch
literal 4909
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
PuNo*0R%g1xe&gt;U|G+Yhl3</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/third_party/rnp/src/tests/data/test_key_validity/case5/generate.cpp</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -31,17 +31,17 @@</span>
<a href="#l23.4"></a><span id="l23.4"> #include &quot;fingerprint.h&quot;</span>
<a href="#l23.5"></a><span id="l23.5"> #include &quot;pgp-key.h&quot;</span>
<a href="#l23.6"></a><span id="l23.6"> #include &quot;crypto/signatures.h&quot;</span>
<a href="#l23.7"></a><span id="l23.7"> </span>
<a href="#l23.8"></a><span id="l23.8"> static bool</span>
<a href="#l23.9"></a><span id="l23.9"> load_transferable_key(pgp_transferable_key_t *key, const char *fname)</span>
<a href="#l23.10"></a><span id="l23.10"> {</span>
<a href="#l23.11"></a><span id="l23.11">     pgp_source_t src = {};</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-    bool         res = !init_file_src(&amp;src, fname) &amp;&amp; !process_pgp_key(&amp;src, key);</span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+    bool         res = !init_file_src(&amp;src, fname) &amp;&amp; !process_pgp_key(&amp;src, key, false);</span>
<a href="#l23.14"></a><span id="l23.14">     src_close(&amp;src);</span>
<a href="#l23.15"></a><span id="l23.15">     return res;</span>
<a href="#l23.16"></a><span id="l23.16"> }</span>
<a href="#l23.17"></a><span id="l23.17"> </span>
<a href="#l23.18"></a><span id="l23.18"> bool calculate_primary_binding(const pgp_key_pkt_t *key,</span>
<a href="#l23.19"></a><span id="l23.19">                                const pgp_key_pkt_t *subkey,</span>
<a href="#l23.20"></a><span id="l23.20">                                pgp_hash_alg_t       halg,</span>
<a href="#l23.21"></a><span id="l23.21">                                pgp_signature_t *    sig,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/third_party/rnp/src/tests/ffi.cpp</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/third_party/rnp/src/tests/ffi.cpp</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -5497,16 +5497,167 @@ TEST_F(rnp_tests, test_ffi_keys_import)</span>
<a href="#l24.4"></a><span id="l24.4">     jsokey = json_object_array_get_idx(jsokeys, 2);</span>
<a href="#l24.5"></a><span id="l24.5">     assert_true(check_key_status(</span>
<a href="#l24.6"></a><span id="l24.6">       jsokey, &quot;unchanged&quot;, &quot;unchanged&quot;, &quot;5fe514a54816e1b331686c2c16cd16f267ccdd4f&quot;));</span>
<a href="#l24.7"></a><span id="l24.7">     json_object_put(jso);</span>
<a href="#l24.8"></a><span id="l24.8">     // cleanup</span>
<a href="#l24.9"></a><span id="l24.9">     rnp_ffi_destroy(ffi);</span>
<a href="#l24.10"></a><span id="l24.10"> }</span>
<a href="#l24.11"></a><span id="l24.11"> </span>
<a href="#l24.12"></a><span id="l24.12" class="difflineplus">+TEST_F(rnp_tests, test_ffi_malformed_keys_import)</span>
<a href="#l24.13"></a><span id="l24.13" class="difflineplus">+{</span>
<a href="#l24.14"></a><span id="l24.14" class="difflineplus">+    rnp_ffi_t   ffi = NULL;</span>
<a href="#l24.15"></a><span id="l24.15" class="difflineplus">+    rnp_input_t input = NULL;</span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineplus">+    /* import keys with bad key0-uid0 certification, first without flag */</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.20"></a><span id="l24.20" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/pubring-malf-cert.pgp&quot;));</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineplus">+    assert_rnp_failure(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, NULL));</span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l24.23"></a><span id="l24.23" class="difflineplus">+    size_t keycount = 255;</span>
<a href="#l24.24"></a><span id="l24.24" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.25"></a><span id="l24.25" class="difflineplus">+    assert_int_equal(keycount, 0);</span>
<a href="#l24.26"></a><span id="l24.26" class="difflineplus">+    /* now try with RNP_LOAD_SAVE_PERMISSIVE */</span>
<a href="#l24.27"></a><span id="l24.27" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.28"></a><span id="l24.28" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/pubring-malf-cert.pgp&quot;));</span>
<a href="#l24.29"></a><span id="l24.29" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.30"></a><span id="l24.30" class="difflineplus">+      rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS | RNP_LOAD_SAVE_PERMISSIVE, NULL));</span>
<a href="#l24.31"></a><span id="l24.31" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.33"></a><span id="l24.33" class="difflineplus">+    assert_int_equal(keycount, 7);</span>
<a href="#l24.34"></a><span id="l24.34" class="difflineplus">+    rnp_key_handle_t key = NULL;</span>
<a href="#l24.35"></a><span id="l24.35" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7bc6709b15c23a4a&quot;, &amp;key));</span>
<a href="#l24.36"></a><span id="l24.36" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+    size_t uidcount = 255;</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+    assert_rnp_success(rnp_key_get_uid_count(key, &amp;uidcount));</span>
<a href="#l24.39"></a><span id="l24.39" class="difflineplus">+    assert_int_equal(uidcount, 3);</span>
<a href="#l24.40"></a><span id="l24.40" class="difflineplus">+    size_t subcount = 255;</span>
<a href="#l24.41"></a><span id="l24.41" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_count(key, &amp;subcount));</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineplus">+    assert_int_equal(subcount, 3);</span>
<a href="#l24.43"></a><span id="l24.43" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.44"></a><span id="l24.44" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;2fcadf05ffa501bb&quot;, &amp;key));</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.47"></a><span id="l24.47" class="difflineplus">+</span>
<a href="#l24.48"></a><span id="l24.48" class="difflineplus">+    /* import keys with bad key0-sub0 binding */</span>
<a href="#l24.49"></a><span id="l24.49" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC));</span>
<a href="#l24.50"></a><span id="l24.50" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.51"></a><span id="l24.51" class="difflineplus">+    assert_int_equal(keycount, 0);</span>
<a href="#l24.52"></a><span id="l24.52" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.53"></a><span id="l24.53" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/pubring-malf-key0-sub0-bind.pgp&quot;));</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+      rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS | RNP_LOAD_SAVE_PERMISSIVE, NULL));</span>
<a href="#l24.56"></a><span id="l24.56" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l24.57"></a><span id="l24.57" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.58"></a><span id="l24.58" class="difflineplus">+    assert_int_equal(keycount, 7);</span>
<a href="#l24.59"></a><span id="l24.59" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7bc6709b15c23a4a&quot;, &amp;key));</span>
<a href="#l24.60"></a><span id="l24.60" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.61"></a><span id="l24.61" class="difflineplus">+    uidcount = 255;</span>
<a href="#l24.62"></a><span id="l24.62" class="difflineplus">+    assert_rnp_success(rnp_key_get_uid_count(key, &amp;uidcount));</span>
<a href="#l24.63"></a><span id="l24.63" class="difflineplus">+    assert_int_equal(uidcount, 3);</span>
<a href="#l24.64"></a><span id="l24.64" class="difflineplus">+    subcount = 255;</span>
<a href="#l24.65"></a><span id="l24.65" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_count(key, &amp;subcount));</span>
<a href="#l24.66"></a><span id="l24.66" class="difflineplus">+    assert_int_equal(subcount, 3);</span>
<a href="#l24.67"></a><span id="l24.67" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.68"></a><span id="l24.68" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;2fcadf05ffa501bb&quot;, &amp;key));</span>
<a href="#l24.69"></a><span id="l24.69" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.70"></a><span id="l24.70" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.71"></a><span id="l24.71" class="difflineplus">+</span>
<a href="#l24.72"></a><span id="l24.72" class="difflineplus">+    /* import keys with bad key0-sub0 packet */</span>
<a href="#l24.73"></a><span id="l24.73" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC));</span>
<a href="#l24.74"></a><span id="l24.74" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.75"></a><span id="l24.75" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/pubring-malf-key0-sub0.pgp&quot;));</span>
<a href="#l24.76"></a><span id="l24.76" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.77"></a><span id="l24.77" class="difflineplus">+      rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS | RNP_LOAD_SAVE_PERMISSIVE, NULL));</span>
<a href="#l24.78"></a><span id="l24.78" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l24.79"></a><span id="l24.79" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.80"></a><span id="l24.80" class="difflineplus">+    assert_int_equal(keycount, 6);</span>
<a href="#l24.81"></a><span id="l24.81" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7bc6709b15c23a4a&quot;, &amp;key));</span>
<a href="#l24.82"></a><span id="l24.82" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.83"></a><span id="l24.83" class="difflineplus">+    uidcount = 255;</span>
<a href="#l24.84"></a><span id="l24.84" class="difflineplus">+    assert_rnp_success(rnp_key_get_uid_count(key, &amp;uidcount));</span>
<a href="#l24.85"></a><span id="l24.85" class="difflineplus">+    assert_int_equal(uidcount, 3);</span>
<a href="#l24.86"></a><span id="l24.86" class="difflineplus">+    subcount = 255;</span>
<a href="#l24.87"></a><span id="l24.87" class="difflineplus">+    assert_rnp_success(rnp_key_get_subkey_count(key, &amp;subcount));</span>
<a href="#l24.88"></a><span id="l24.88" class="difflineplus">+    assert_int_equal(subcount, 2);</span>
<a href="#l24.89"></a><span id="l24.89" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.90"></a><span id="l24.90" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;2fcadf05ffa501bb&quot;, &amp;key));</span>
<a href="#l24.91"></a><span id="l24.91" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.92"></a><span id="l24.92" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.93"></a><span id="l24.93" class="difflineplus">+</span>
<a href="#l24.94"></a><span id="l24.94" class="difflineplus">+    /* import keys with bad key0 packet */</span>
<a href="#l24.95"></a><span id="l24.95" class="difflineplus">+    assert_rnp_success(rnp_unload_keys(ffi, RNP_KEY_UNLOAD_PUBLIC));</span>
<a href="#l24.96"></a><span id="l24.96" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.97"></a><span id="l24.97" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/pubring-malf-key0.pgp&quot;));</span>
<a href="#l24.98"></a><span id="l24.98" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.99"></a><span id="l24.99" class="difflineplus">+      rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS | RNP_LOAD_SAVE_PERMISSIVE, NULL));</span>
<a href="#l24.100"></a><span id="l24.100" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l24.101"></a><span id="l24.101" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.102"></a><span id="l24.102" class="difflineplus">+    assert_int_equal(keycount, 3);</span>
<a href="#l24.103"></a><span id="l24.103" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7bc6709b15c23a4a&quot;, &amp;key));</span>
<a href="#l24.104"></a><span id="l24.104" class="difflineplus">+    assert_null(key);</span>
<a href="#l24.105"></a><span id="l24.105" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;2fcadf05ffa501bb&quot;, &amp;key));</span>
<a href="#l24.106"></a><span id="l24.106" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.107"></a><span id="l24.107" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.108"></a><span id="l24.108" class="difflineplus">+</span>
<a href="#l24.109"></a><span id="l24.109" class="difflineplus">+    /* import secret keys with bad key1 packet - public should be added as well */</span>
<a href="#l24.110"></a><span id="l24.110" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.111"></a><span id="l24.111" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/secring-malf-key1.pgp&quot;));</span>
<a href="#l24.112"></a><span id="l24.112" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.113"></a><span id="l24.113" class="difflineplus">+      rnp_import_keys(ffi, input, RNP_LOAD_SAVE_SECRET_KEYS | RNP_LOAD_SAVE_PERMISSIVE, NULL));</span>
<a href="#l24.114"></a><span id="l24.114" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l24.115"></a><span id="l24.115" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.116"></a><span id="l24.116" class="difflineplus">+    assert_int_equal(keycount, 7);</span>
<a href="#l24.117"></a><span id="l24.117" class="difflineplus">+    assert_rnp_success(rnp_get_secret_key_count(ffi, &amp;keycount));</span>
<a href="#l24.118"></a><span id="l24.118" class="difflineplus">+    assert_int_equal(keycount, 4);</span>
<a href="#l24.119"></a><span id="l24.119" class="difflineplus">+</span>
<a href="#l24.120"></a><span id="l24.120" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7bc6709b15c23a4a&quot;, &amp;key));</span>
<a href="#l24.121"></a><span id="l24.121" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.122"></a><span id="l24.122" class="difflineplus">+    bool secret = false;</span>
<a href="#l24.123"></a><span id="l24.123" class="difflineplus">+    assert_rnp_success(rnp_key_have_secret(key, &amp;secret));</span>
<a href="#l24.124"></a><span id="l24.124" class="difflineplus">+    assert_true(secret);</span>
<a href="#l24.125"></a><span id="l24.125" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.126"></a><span id="l24.126" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;326ef111425d14a5&quot;, &amp;key));</span>
<a href="#l24.127"></a><span id="l24.127" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.128"></a><span id="l24.128" class="difflineplus">+    assert_rnp_success(rnp_key_have_secret(key, &amp;secret));</span>
<a href="#l24.129"></a><span id="l24.129" class="difflineplus">+    assert_false(secret);</span>
<a href="#l24.130"></a><span id="l24.130" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.131"></a><span id="l24.131" class="difflineplus">+</span>
<a href="#l24.132"></a><span id="l24.132" class="difflineplus">+    /* import secret keys with bad key0 packet */</span>
<a href="#l24.133"></a><span id="l24.133" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.134"></a><span id="l24.134" class="difflineplus">+      rnp_input_from_path(&amp;input, &quot;data/test_key_edge_cases/secring-malf-key0.pgp&quot;));</span>
<a href="#l24.135"></a><span id="l24.135" class="difflineplus">+    assert_rnp_success(</span>
<a href="#l24.136"></a><span id="l24.136" class="difflineplus">+      rnp_import_keys(ffi, input, RNP_LOAD_SAVE_SECRET_KEYS | RNP_LOAD_SAVE_PERMISSIVE, NULL));</span>
<a href="#l24.137"></a><span id="l24.137" class="difflineplus">+    rnp_input_destroy(input);</span>
<a href="#l24.138"></a><span id="l24.138" class="difflineplus">+    assert_rnp_success(rnp_get_public_key_count(ffi, &amp;keycount));</span>
<a href="#l24.139"></a><span id="l24.139" class="difflineplus">+    assert_int_equal(keycount, 7);</span>
<a href="#l24.140"></a><span id="l24.140" class="difflineplus">+    assert_rnp_success(rnp_get_secret_key_count(ffi, &amp;keycount));</span>
<a href="#l24.141"></a><span id="l24.141" class="difflineplus">+    assert_int_equal(keycount, 7);</span>
<a href="#l24.142"></a><span id="l24.142" class="difflineplus">+</span>
<a href="#l24.143"></a><span id="l24.143" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;7bc6709b15c23a4a&quot;, &amp;key));</span>
<a href="#l24.144"></a><span id="l24.144" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.145"></a><span id="l24.145" class="difflineplus">+    assert_rnp_success(rnp_key_have_secret(key, &amp;secret));</span>
<a href="#l24.146"></a><span id="l24.146" class="difflineplus">+    assert_true(secret);</span>
<a href="#l24.147"></a><span id="l24.147" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.148"></a><span id="l24.148" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;userid&quot;, &quot;key1-uid2&quot;, &amp;key));</span>
<a href="#l24.149"></a><span id="l24.149" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.150"></a><span id="l24.150" class="difflineplus">+    assert_rnp_success(rnp_key_have_secret(key, &amp;secret));</span>
<a href="#l24.151"></a><span id="l24.151" class="difflineplus">+    assert_true(secret);</span>
<a href="#l24.152"></a><span id="l24.152" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.153"></a><span id="l24.153" class="difflineplus">+    assert_rnp_success(rnp_locate_key(ffi, &quot;keyid&quot;, &quot;326ef111425d14a5&quot;, &amp;key));</span>
<a href="#l24.154"></a><span id="l24.154" class="difflineplus">+    assert_non_null(key);</span>
<a href="#l24.155"></a><span id="l24.155" class="difflineplus">+    assert_rnp_success(rnp_key_have_secret(key, &amp;secret));</span>
<a href="#l24.156"></a><span id="l24.156" class="difflineplus">+    assert_true(secret);</span>
<a href="#l24.157"></a><span id="l24.157" class="difflineplus">+    assert_rnp_success(rnp_key_handle_destroy(key));</span>
<a href="#l24.158"></a><span id="l24.158" class="difflineplus">+</span>
<a href="#l24.159"></a><span id="l24.159" class="difflineplus">+    /* cleanup */</span>
<a href="#l24.160"></a><span id="l24.160" class="difflineplus">+    rnp_ffi_destroy(ffi);</span>
<a href="#l24.161"></a><span id="l24.161" class="difflineplus">+}</span>
<a href="#l24.162"></a><span id="l24.162" class="difflineplus">+</span>
<a href="#l24.163"></a><span id="l24.163"> TEST_F(rnp_tests, test_ffi_stripped_keys_import)</span>
<a href="#l24.164"></a><span id="l24.164"> {</span>
<a href="#l24.165"></a><span id="l24.165">     rnp_ffi_t   ffi = NULL;</span>
<a href="#l24.166"></a><span id="l24.166">     rnp_input_t input = NULL;</span>
<a href="#l24.167"></a><span id="l24.167"> </span>
<a href="#l24.168"></a><span id="l24.168">     assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l24.169"></a><span id="l24.169">     /* load stripped key as keyring */</span>
<a href="#l24.170"></a><span id="l24.170">     assert_rnp_success(</span>
<a href="#l24.171"></a><span id="l24.171" class="difflineat">@@ -5607,16 +5758,49 @@ TEST_F(rnp_tests, test_ffi_stripped_keys</span>
<a href="#l24.172"></a><span id="l24.172">     /* signature 2 - by subkey */</span>
<a href="#l24.173"></a><span id="l24.173">     assert_rnp_success(rnp_op_verify_get_signature_at(verify, 1, &amp;sig));</span>
<a href="#l24.174"></a><span id="l24.174">     assert_int_equal(rnp_op_verify_signature_get_status(sig), RNP_ERROR_SIGNATURE_INVALID);</span>
<a href="#l24.175"></a><span id="l24.175">     rnp_op_verify_destroy(verify);</span>
<a href="#l24.176"></a><span id="l24.176"> </span>
<a href="#l24.177"></a><span id="l24.177">     rnp_ffi_destroy(ffi);</span>
<a href="#l24.178"></a><span id="l24.178"> }</span>
<a href="#l24.179"></a><span id="l24.179"> </span>
<a href="#l24.180"></a><span id="l24.180" class="difflineplus">+TEST_F(rnp_tests, test_ffi_elgamal4096)</span>
<a href="#l24.181"></a><span id="l24.181" class="difflineplus">+{</span>
<a href="#l24.182"></a><span id="l24.182" class="difflineplus">+    rnp_ffi_t ffi = NULL;</span>
<a href="#l24.183"></a><span id="l24.183" class="difflineplus">+</span>
<a href="#l24.184"></a><span id="l24.184" class="difflineplus">+    assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l24.185"></a><span id="l24.185" class="difflineplus">+    /* load public key */</span>
<a href="#l24.186"></a><span id="l24.186" class="difflineplus">+    json_object *jso = NULL;</span>
<a href="#l24.187"></a><span id="l24.187" class="difflineplus">+    json_object *jsokeys = NULL;</span>
<a href="#l24.188"></a><span id="l24.188" class="difflineplus">+    assert_true(check_import_keys(</span>
<a href="#l24.189"></a><span id="l24.189" class="difflineplus">+      ffi, &amp;jso, &amp;jsokeys, &quot;data/test_key_edge_cases/key-eg-4096-pub.pgp&quot;, 2, 0));</span>
<a href="#l24.190"></a><span id="l24.190" class="difflineplus">+    assert_int_equal(json_object_array_length(jsokeys), 2);</span>
<a href="#l24.191"></a><span id="l24.191" class="difflineplus">+    json_object *jsokey = json_object_array_get_idx(jsokeys, 0);</span>
<a href="#l24.192"></a><span id="l24.192" class="difflineplus">+    assert_true(</span>
<a href="#l24.193"></a><span id="l24.193" class="difflineplus">+      check_key_status(jsokey, &quot;new&quot;, &quot;none&quot;, &quot;6541db10cdfcdba89db2dffea8f0408eb3369d8e&quot;));</span>
<a href="#l24.194"></a><span id="l24.194" class="difflineplus">+    jsokey = json_object_array_get_idx(jsokeys, 1);</span>
<a href="#l24.195"></a><span id="l24.195" class="difflineplus">+    assert_true(</span>
<a href="#l24.196"></a><span id="l24.196" class="difflineplus">+      check_key_status(jsokey, &quot;new&quot;, &quot;none&quot;, &quot;c402a09b74acd0c11efc0527a3d630b457a0b15b&quot;));</span>
<a href="#l24.197"></a><span id="l24.197" class="difflineplus">+    json_object_put(jso);</span>
<a href="#l24.198"></a><span id="l24.198" class="difflineplus">+    /* load secret key */</span>
<a href="#l24.199"></a><span id="l24.199" class="difflineplus">+    assert_true(check_import_keys(</span>
<a href="#l24.200"></a><span id="l24.200" class="difflineplus">+      ffi, &amp;jso, &amp;jsokeys, &quot;data/test_key_edge_cases/key-eg-4096-sec.pgp&quot;, 2, 2));</span>
<a href="#l24.201"></a><span id="l24.201" class="difflineplus">+    assert_int_equal(json_object_array_length(jsokeys), 2);</span>
<a href="#l24.202"></a><span id="l24.202" class="difflineplus">+    jsokey = json_object_array_get_idx(jsokeys, 0);</span>
<a href="#l24.203"></a><span id="l24.203" class="difflineplus">+    assert_true(check_key_status(</span>
<a href="#l24.204"></a><span id="l24.204" class="difflineplus">+      jsokey, &quot;unchanged&quot;, &quot;new&quot;, &quot;6541db10cdfcdba89db2dffea8f0408eb3369d8e&quot;));</span>
<a href="#l24.205"></a><span id="l24.205" class="difflineplus">+    jsokey = json_object_array_get_idx(jsokeys, 1);</span>
<a href="#l24.206"></a><span id="l24.206" class="difflineplus">+    assert_true(check_key_status(</span>
<a href="#l24.207"></a><span id="l24.207" class="difflineplus">+      jsokey, &quot;unchanged&quot;, &quot;new&quot;, &quot;c402a09b74acd0c11efc0527a3d630b457a0b15b&quot;));</span>
<a href="#l24.208"></a><span id="l24.208" class="difflineplus">+    json_object_put(jso);</span>
<a href="#l24.209"></a><span id="l24.209" class="difflineplus">+    // cleanup</span>
<a href="#l24.210"></a><span id="l24.210" class="difflineplus">+    rnp_ffi_destroy(ffi);</span>
<a href="#l24.211"></a><span id="l24.211" class="difflineplus">+}</span>
<a href="#l24.212"></a><span id="l24.212" class="difflineplus">+</span>
<a href="#l24.213"></a><span id="l24.213"> static std::vector&lt;uint8_t&gt;</span>
<a href="#l24.214"></a><span id="l24.214"> read_file_to_vector(const char *valid_key_path)</span>
<a href="#l24.215"></a><span id="l24.215"> {</span>
<a href="#l24.216"></a><span id="l24.216">     std::ifstream        stream(valid_key_path, std::ios::in | std::ios::binary);</span>
<a href="#l24.217"></a><span id="l24.217">     std::vector&lt;uint8_t&gt; contents((std::istreambuf_iterator&lt;char&gt;(stream)),</span>
<a href="#l24.218"></a><span id="l24.218">                                   std::istreambuf_iterator&lt;char&gt;());</span>
<a href="#l24.219"></a><span id="l24.219">     return contents;</span>
<a href="#l24.220"></a><span id="l24.220"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/third_party/rnp/src/tests/key-validate.cpp</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/third_party/rnp/src/tests/key-validate.cpp</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -120,17 +120,17 @@ TEST_F(rnp_tests, test_key_validate)</span>
<a href="#l25.4"></a><span id="l25.4"> </span>
<a href="#l25.5"></a><span id="l25.5"> static void</span>
<a href="#l25.6"></a><span id="l25.6"> key_store_add(rnp_key_store_t *keyring, const char *keypath)</span>
<a href="#l25.7"></a><span id="l25.7"> {</span>
<a href="#l25.8"></a><span id="l25.8">     pgp_source_t           keysrc = {};</span>
<a href="#l25.9"></a><span id="l25.9">     pgp_transferable_key_t tkey = {};</span>
<a href="#l25.10"></a><span id="l25.10"> </span>
<a href="#l25.11"></a><span id="l25.11">     assert_rnp_success(init_file_src(&amp;keysrc, keypath));</span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-    assert_rnp_success(process_pgp_key(&amp;keysrc, &amp;tkey));</span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+    assert_rnp_success(process_pgp_key(&amp;keysrc, &amp;tkey, false));</span>
<a href="#l25.14"></a><span id="l25.14">     assert_true(rnp_key_store_add_transferable_key(keyring, &amp;tkey));</span>
<a href="#l25.15"></a><span id="l25.15">     transferable_key_destroy(&amp;tkey);</span>
<a href="#l25.16"></a><span id="l25.16">     src_close(&amp;keysrc);</span>
<a href="#l25.17"></a><span id="l25.17"> }</span>
<a href="#l25.18"></a><span id="l25.18"> </span>
<a href="#l25.19"></a><span id="l25.19"> static bool</span>
<a href="#l25.20"></a><span id="l25.20"> key_check(rnp_key_store_t *keyring, const std::string &amp;keyid, bool valid)</span>
<a href="#l25.21"></a><span id="l25.21"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/third_party/rnp/src/tests/large-mpi.cpp</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/third_party/rnp/src/tests/large-mpi.cpp</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -34,17 +34,17 @@ TEST_F(rnp_tests, test_large_mpi_rsa_pub</span>
<a href="#l26.4"></a><span id="l26.4">     pgp_key_sequence_t keyseq;</span>
<a href="#l26.5"></a><span id="l26.5">     rnp_ffi_t          ffi = NULL;</span>
<a href="#l26.6"></a><span id="l26.6">     rnp_input_t        input = NULL;</span>
<a href="#l26.7"></a><span id="l26.7">     rnp_input_t        signature = NULL;</span>
<a href="#l26.8"></a><span id="l26.8">     rnp_op_verify_t    verify;</span>
<a href="#l26.9"></a><span id="l26.9"> </span>
<a href="#l26.10"></a><span id="l26.10">     /* Load RSA pubkey packet with 65535 bit modulus MPI. Must fail. */</span>
<a href="#l26.11"></a><span id="l26.11">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_large_MPIs/rsa-pub-65535bits.pgp&quot;));</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-    assert_rnp_failure(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+    assert_rnp_failure(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l26.14"></a><span id="l26.14">     assert_int_equal(list_length(keyseq.keys), 0);</span>
<a href="#l26.15"></a><span id="l26.15">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l26.16"></a><span id="l26.16">     src_close(&amp;keysrc);</span>
<a href="#l26.17"></a><span id="l26.17"> </span>
<a href="#l26.18"></a><span id="l26.18">     assert_rnp_success(rnp_ffi_create(&amp;ffi, &quot;GPG&quot;, &quot;GPG&quot;));</span>
<a href="#l26.19"></a><span id="l26.19">     assert_rnp_success(</span>
<a href="#l26.20"></a><span id="l26.20">       rnp_input_from_path(&amp;input, &quot;data/test_large_MPIs/rsa-pub-65535bits.pgp&quot;));</span>
<a href="#l26.21"></a><span id="l26.21">     assert_rnp_failure(rnp_import_keys(ffi, input, RNP_LOAD_SAVE_PUBLIC_KEYS, NULL));</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/third_party/rnp/src/tests/load-pgp.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/third_party/rnp/src/tests/load-pgp.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -441,26 +441,26 @@ TEST_F(rnp_tests, test_load_armored_pub_</span>
<a href="#l27.4"></a><span id="l27.4"> </span>
<a href="#l27.5"></a><span id="l27.5">     delete key_store;</span>
<a href="#l27.6"></a><span id="l27.6"> }</span>
<a href="#l27.7"></a><span id="l27.7"> </span>
<a href="#l27.8"></a><span id="l27.8"> static bool</span>
<a href="#l27.9"></a><span id="l27.9"> load_transferable_key(pgp_transferable_key_t *key, const char *fname)</span>
<a href="#l27.10"></a><span id="l27.10"> {</span>
<a href="#l27.11"></a><span id="l27.11">     pgp_source_t src = {};</span>
<a href="#l27.12"></a><span id="l27.12" class="difflineminus">-    bool         res = !init_file_src(&amp;src, fname) &amp;&amp; !process_pgp_key(&amp;src, key);</span>
<a href="#l27.13"></a><span id="l27.13" class="difflineplus">+    bool         res = !init_file_src(&amp;src, fname) &amp;&amp; !process_pgp_key(&amp;src, key, false);</span>
<a href="#l27.14"></a><span id="l27.14">     src_close(&amp;src);</span>
<a href="#l27.15"></a><span id="l27.15">     return res;</span>
<a href="#l27.16"></a><span id="l27.16"> }</span>
<a href="#l27.17"></a><span id="l27.17"> </span>
<a href="#l27.18"></a><span id="l27.18"> static bool</span>
<a href="#l27.19"></a><span id="l27.19"> load_transferable_subkey(pgp_transferable_subkey_t *key, const char *fname)</span>
<a href="#l27.20"></a><span id="l27.20"> {</span>
<a href="#l27.21"></a><span id="l27.21">     pgp_source_t src = {};</span>
<a href="#l27.22"></a><span id="l27.22" class="difflineminus">-    bool         res = !init_file_src(&amp;src, fname) &amp;&amp; !process_pgp_subkey(&amp;src, key);</span>
<a href="#l27.23"></a><span id="l27.23" class="difflineplus">+    bool         res = !init_file_src(&amp;src, fname) &amp;&amp; !process_pgp_subkey(&amp;src, key, false);</span>
<a href="#l27.24"></a><span id="l27.24">     src_close(&amp;src);</span>
<a href="#l27.25"></a><span id="l27.25">     return res;</span>
<a href="#l27.26"></a><span id="l27.26"> }</span>
<a href="#l27.27"></a><span id="l27.27"> </span>
<a href="#l27.28"></a><span id="l27.28"> static bool</span>
<a href="#l27.29"></a><span id="l27.29"> load_keystore(rnp_key_store_t *keystore, const char *fname)</span>
<a href="#l27.30"></a><span id="l27.30"> {</span>
<a href="#l27.31"></a><span id="l27.31">     pgp_source_t src = {};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/third_party/rnp/src/tests/rnp_tests.h</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/third_party/rnp/src/tests/rnp_tests.h</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -242,18 +242,22 @@ void test_ffi_revocations(void **state);</span>
<a href="#l28.4"></a><span id="l28.4"> void test_ffi_file_output(void **state);</span>
<a href="#l28.5"></a><span id="l28.5"> </span>
<a href="#l28.6"></a><span id="l28.6"> void test_ffi_key_signatures(void **state);</span>
<a href="#l28.7"></a><span id="l28.7"> </span>
<a href="#l28.8"></a><span id="l28.8"> void test_ffi_keys_import(void **state);</span>
<a href="#l28.9"></a><span id="l28.9"> </span>
<a href="#l28.10"></a><span id="l28.10"> void test_ffi_stripped_keys_import(void **state);</span>
<a href="#l28.11"></a><span id="l28.11"> </span>
<a href="#l28.12"></a><span id="l28.12" class="difflineplus">+void test_ffi_malformed_keys_import(void **state);</span>
<a href="#l28.13"></a><span id="l28.13" class="difflineplus">+</span>
<a href="#l28.14"></a><span id="l28.14"> void test_ffi_import_keys_check_pktlen(void **state);</span>
<a href="#l28.15"></a><span id="l28.15"> </span>
<a href="#l28.16"></a><span id="l28.16" class="difflineplus">+void test_ffi_elgamal4096(void **state);</span>
<a href="#l28.17"></a><span id="l28.17" class="difflineplus">+</span>
<a href="#l28.18"></a><span id="l28.18"> void test_ffi_calculate_iterations(void **state);</span>
<a href="#l28.19"></a><span id="l28.19"> </span>
<a href="#l28.20"></a><span id="l28.20"> void test_ffi_supported_features(void **state);</span>
<a href="#l28.21"></a><span id="l28.21"> </span>
<a href="#l28.22"></a><span id="l28.22"> void test_ffi_enable_debug(void **state);</span>
<a href="#l28.23"></a><span id="l28.23"> </span>
<a href="#l28.24"></a><span id="l28.24"> void test_ffi_rnp_key_get_primary_grip(void **state);</span>
<a href="#l28.25"></a><span id="l28.25"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/third_party/rnp/src/tests/streams.cpp</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/third_party/rnp/src/tests/streams.cpp</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -449,335 +449,335 @@ TEST_F(rnp_tests, test_stream_key_load)</span>
<a href="#l29.4"></a><span id="l29.4">     pgp_key_sequence_t         keyseq;</span>
<a href="#l29.5"></a><span id="l29.5">     uint8_t                    keyid[PGP_KEY_ID_SIZE];</span>
<a href="#l29.6"></a><span id="l29.6">     pgp_fingerprint_t          keyfp;</span>
<a href="#l29.7"></a><span id="l29.7">     pgp_transferable_key_t *   key = NULL;</span>
<a href="#l29.8"></a><span id="l29.8">     pgp_transferable_subkey_t *skey = NULL;</span>
<a href="#l29.9"></a><span id="l29.9"> </span>
<a href="#l29.10"></a><span id="l29.10">     /* public keyring, read-save-read-save armored-read */</span>
<a href="#l29.11"></a><span id="l29.11">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.14"></a><span id="l29.14">     assert_true(list_length(keyseq.keys) &gt; 1);</span>
<a href="#l29.15"></a><span id="l29.15">     src_close(&amp;keysrc);</span>
<a href="#l29.16"></a><span id="l29.16"> </span>
<a href="#l29.17"></a><span id="l29.17">     assert_rnp_success(init_file_dest(&amp;keydst, &quot;keyout.gpg&quot;, true));</span>
<a href="#l29.18"></a><span id="l29.18">     assert_rnp_success(write_pgp_keys(&amp;keyseq, &amp;keydst, false));</span>
<a href="#l29.19"></a><span id="l29.19">     dst_close(&amp;keydst, false);</span>
<a href="#l29.20"></a><span id="l29.20">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.21"></a><span id="l29.21"> </span>
<a href="#l29.22"></a><span id="l29.22">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;keyout.gpg&quot;));</span>
<a href="#l29.23"></a><span id="l29.23" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.24"></a><span id="l29.24" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.25"></a><span id="l29.25">     src_close(&amp;keysrc);</span>
<a href="#l29.26"></a><span id="l29.26"> </span>
<a href="#l29.27"></a><span id="l29.27">     assert_rnp_success(init_file_dest(&amp;keydst, &quot;keyout.asc&quot;, true));</span>
<a href="#l29.28"></a><span id="l29.28">     assert_rnp_success(write_pgp_keys(&amp;keyseq, &amp;keydst, true));</span>
<a href="#l29.29"></a><span id="l29.29">     dst_close(&amp;keydst, false);</span>
<a href="#l29.30"></a><span id="l29.30">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.31"></a><span id="l29.31"> </span>
<a href="#l29.32"></a><span id="l29.32">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;keyout.asc&quot;));</span>
<a href="#l29.33"></a><span id="l29.33" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.34"></a><span id="l29.34" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.35"></a><span id="l29.35">     src_close(&amp;keysrc);</span>
<a href="#l29.36"></a><span id="l29.36">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.37"></a><span id="l29.37"> </span>
<a href="#l29.38"></a><span id="l29.38">     /* secret keyring */</span>
<a href="#l29.39"></a><span id="l29.39">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/1/secring.gpg&quot;));</span>
<a href="#l29.40"></a><span id="l29.40" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.41"></a><span id="l29.41" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.42"></a><span id="l29.42">     assert_true(list_length(keyseq.keys) &gt; 1);</span>
<a href="#l29.43"></a><span id="l29.43">     src_close(&amp;keysrc);</span>
<a href="#l29.44"></a><span id="l29.44"> </span>
<a href="#l29.45"></a><span id="l29.45">     assert_rnp_success(init_file_dest(&amp;keydst, &quot;keyout-sec.gpg&quot;, true));</span>
<a href="#l29.46"></a><span id="l29.46">     assert_rnp_success(write_pgp_keys(&amp;keyseq, &amp;keydst, false));</span>
<a href="#l29.47"></a><span id="l29.47">     dst_close(&amp;keydst, false);</span>
<a href="#l29.48"></a><span id="l29.48">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.49"></a><span id="l29.49"> </span>
<a href="#l29.50"></a><span id="l29.50">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;keyout-sec.gpg&quot;));</span>
<a href="#l29.51"></a><span id="l29.51" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.52"></a><span id="l29.52" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.53"></a><span id="l29.53">     src_close(&amp;keysrc);</span>
<a href="#l29.54"></a><span id="l29.54"> </span>
<a href="#l29.55"></a><span id="l29.55">     assert_rnp_success(init_file_dest(&amp;keydst, &quot;keyout-sec.asc&quot;, true));</span>
<a href="#l29.56"></a><span id="l29.56">     assert_rnp_success(write_pgp_keys(&amp;keyseq, &amp;keydst, true));</span>
<a href="#l29.57"></a><span id="l29.57">     dst_close(&amp;keydst, false);</span>
<a href="#l29.58"></a><span id="l29.58">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.59"></a><span id="l29.59"> </span>
<a href="#l29.60"></a><span id="l29.60">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;keyout-sec.asc&quot;));</span>
<a href="#l29.61"></a><span id="l29.61" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.62"></a><span id="l29.62" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.63"></a><span id="l29.63">     src_close(&amp;keysrc);</span>
<a href="#l29.64"></a><span id="l29.64">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.65"></a><span id="l29.65"> </span>
<a href="#l29.66"></a><span id="l29.66">     /* armored v3 public key */</span>
<a href="#l29.67"></a><span id="l29.67">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/4/rsav3-p.asc&quot;));</span>
<a href="#l29.68"></a><span id="l29.68" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.69"></a><span id="l29.69" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.70"></a><span id="l29.70">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.71"></a><span id="l29.71">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.72"></a><span id="l29.72">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l29.73"></a><span id="l29.73">     assert_true(cmp_keyid(keyid, &quot;7D0BC10E933404C9&quot;));</span>
<a href="#l29.74"></a><span id="l29.74">     assert_false(cmp_keyid(keyid, &quot;1D0BC10E933404C9&quot;));</span>
<a href="#l29.75"></a><span id="l29.75">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.76"></a><span id="l29.76">     src_close(&amp;keysrc);</span>
<a href="#l29.77"></a><span id="l29.77"> </span>
<a href="#l29.78"></a><span id="l29.78">     /* armored v3 secret key */</span>
<a href="#l29.79"></a><span id="l29.79">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/4/rsav3-s.asc&quot;));</span>
<a href="#l29.80"></a><span id="l29.80" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.81"></a><span id="l29.81" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.82"></a><span id="l29.82">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.83"></a><span id="l29.83">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.84"></a><span id="l29.84">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l29.85"></a><span id="l29.85">     assert_true(cmp_keyid(keyid, &quot;7D0BC10E933404C9&quot;));</span>
<a href="#l29.86"></a><span id="l29.86">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.87"></a><span id="l29.87">     src_close(&amp;keysrc);</span>
<a href="#l29.88"></a><span id="l29.88"> </span>
<a href="#l29.89"></a><span id="l29.89">     /* rsa/rsa public key */</span>
<a href="#l29.90"></a><span id="l29.90">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/rsa-rsa-pub.asc&quot;));</span>
<a href="#l29.91"></a><span id="l29.91" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.92"></a><span id="l29.92" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.93"></a><span id="l29.93">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.94"></a><span id="l29.94">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.95"></a><span id="l29.95">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.96"></a><span id="l29.96">     assert_true(cmp_keyfp(&amp;keyfp, &quot;6BC04A5A3DDB35766B9A40D82FB9179118898E8B&quot;));</span>
<a href="#l29.97"></a><span id="l29.97">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l29.98"></a><span id="l29.98">     assert_true(cmp_keyid(keyid, &quot;2FB9179118898E8B&quot;));</span>
<a href="#l29.99"></a><span id="l29.99">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.100"></a><span id="l29.100">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.101"></a><span id="l29.101">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.102"></a><span id="l29.102">     src_close(&amp;keysrc);</span>
<a href="#l29.103"></a><span id="l29.103"> </span>
<a href="#l29.104"></a><span id="l29.104">     /* rsa/rsa secret key */</span>
<a href="#l29.105"></a><span id="l29.105">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/rsa-rsa-sec.asc&quot;));</span>
<a href="#l29.106"></a><span id="l29.106" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.107"></a><span id="l29.107" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.108"></a><span id="l29.108">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.109"></a><span id="l29.109">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.110"></a><span id="l29.110">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.111"></a><span id="l29.111">     assert_true(cmp_keyfp(&amp;keyfp, &quot;6BC04A5A3DDB35766B9A40D82FB9179118898E8B&quot;));</span>
<a href="#l29.112"></a><span id="l29.112">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;key-&gt;key));</span>
<a href="#l29.113"></a><span id="l29.113">     assert_true(cmp_keyid(keyid, &quot;2FB9179118898E8B&quot;));</span>
<a href="#l29.114"></a><span id="l29.114">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.115"></a><span id="l29.115">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.116"></a><span id="l29.116">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.117"></a><span id="l29.117">     src_close(&amp;keysrc);</span>
<a href="#l29.118"></a><span id="l29.118"> </span>
<a href="#l29.119"></a><span id="l29.119">     /* dsa/el-gamal public key */</span>
<a href="#l29.120"></a><span id="l29.120">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/dsa-eg-pub.asc&quot;));</span>
<a href="#l29.121"></a><span id="l29.121" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.122"></a><span id="l29.122" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.123"></a><span id="l29.123">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.124"></a><span id="l29.124">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.125"></a><span id="l29.125">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.126"></a><span id="l29.126">     assert_true(cmp_keyfp(&amp;keyfp, &quot;091C44CE9CFBC3FF7EC7A64DC8A10A7D78273E10&quot;));</span>
<a href="#l29.127"></a><span id="l29.127">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.128"></a><span id="l29.128">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.129"></a><span id="l29.129">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.130"></a><span id="l29.130">     assert_true(cmp_keyid(keyid, &quot;02A5715C3537717E&quot;));</span>
<a href="#l29.131"></a><span id="l29.131">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.132"></a><span id="l29.132">     src_close(&amp;keysrc);</span>
<a href="#l29.133"></a><span id="l29.133"> </span>
<a href="#l29.134"></a><span id="l29.134">     /* dsa/el-gamal secret key */</span>
<a href="#l29.135"></a><span id="l29.135">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/dsa-eg-sec.asc&quot;));</span>
<a href="#l29.136"></a><span id="l29.136" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.137"></a><span id="l29.137" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.138"></a><span id="l29.138">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.139"></a><span id="l29.139">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.140"></a><span id="l29.140">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.141"></a><span id="l29.141">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.142"></a><span id="l29.142">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.143"></a><span id="l29.143">     src_close(&amp;keysrc);</span>
<a href="#l29.144"></a><span id="l29.144"> </span>
<a href="#l29.145"></a><span id="l29.145">     /* curve 25519 ecc public key */</span>
<a href="#l29.146"></a><span id="l29.146">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-25519-pub.asc&quot;));</span>
<a href="#l29.147"></a><span id="l29.147" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.148"></a><span id="l29.148" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.149"></a><span id="l29.149">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.150"></a><span id="l29.150">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.151"></a><span id="l29.151">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.152"></a><span id="l29.152">     assert_true(cmp_keyfp(&amp;keyfp, &quot;21FC68274AAE3B5DE39A4277CC786278981B0728&quot;));</span>
<a href="#l29.153"></a><span id="l29.153">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.154"></a><span id="l29.154">     src_close(&amp;keysrc);</span>
<a href="#l29.155"></a><span id="l29.155"> </span>
<a href="#l29.156"></a><span id="l29.156">     /* curve 25519 ecc secret key */</span>
<a href="#l29.157"></a><span id="l29.157">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-25519-sec.asc&quot;));</span>
<a href="#l29.158"></a><span id="l29.158" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.159"></a><span id="l29.159" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.160"></a><span id="l29.160">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.161"></a><span id="l29.161">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.162"></a><span id="l29.162">     assert_int_equal(list_length(key-&gt;subkeys), 0);</span>
<a href="#l29.163"></a><span id="l29.163">     assert_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.164"></a><span id="l29.164">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.165"></a><span id="l29.165">     src_close(&amp;keysrc);</span>
<a href="#l29.166"></a><span id="l29.166"> </span>
<a href="#l29.167"></a><span id="l29.167">     /* eddsa/x25519 ecc public key */</span>
<a href="#l29.168"></a><span id="l29.168">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-x25519-pub.asc&quot;));</span>
<a href="#l29.169"></a><span id="l29.169" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.170"></a><span id="l29.170" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.171"></a><span id="l29.171">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.172"></a><span id="l29.172">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.173"></a><span id="l29.173">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.174"></a><span id="l29.174">     assert_true(cmp_keyfp(&amp;keyfp, &quot;4C9738A6F2BE4E1A796C9B7B941822A0FC1B30A5&quot;));</span>
<a href="#l29.175"></a><span id="l29.175">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.176"></a><span id="l29.176">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.177"></a><span id="l29.177">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.178"></a><span id="l29.178">     assert_true(cmp_keyid(keyid, &quot;C711187E594376AF&quot;));</span>
<a href="#l29.179"></a><span id="l29.179">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.180"></a><span id="l29.180">     src_close(&amp;keysrc);</span>
<a href="#l29.181"></a><span id="l29.181"> </span>
<a href="#l29.182"></a><span id="l29.182">     /* eddsa/x25519 ecc secret key */</span>
<a href="#l29.183"></a><span id="l29.183">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-x25519-sec.asc&quot;));</span>
<a href="#l29.184"></a><span id="l29.184" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.185"></a><span id="l29.185" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.186"></a><span id="l29.186">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.187"></a><span id="l29.187">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.188"></a><span id="l29.188">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.189"></a><span id="l29.189">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.190"></a><span id="l29.190">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.191"></a><span id="l29.191">     src_close(&amp;keysrc);</span>
<a href="#l29.192"></a><span id="l29.192"> </span>
<a href="#l29.193"></a><span id="l29.193">     /* p-256 ecc public key */</span>
<a href="#l29.194"></a><span id="l29.194">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256-pub.asc&quot;));</span>
<a href="#l29.195"></a><span id="l29.195" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.196"></a><span id="l29.196" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.197"></a><span id="l29.197">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.198"></a><span id="l29.198">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.199"></a><span id="l29.199">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.200"></a><span id="l29.200">     assert_true(cmp_keyfp(&amp;keyfp, &quot;B54FDEBBB673423A5D0AA54423674F21B2441527&quot;));</span>
<a href="#l29.201"></a><span id="l29.201">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.202"></a><span id="l29.202">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.203"></a><span id="l29.203">     assert_true(cmp_keyid(keyid, &quot;37E285E9E9851491&quot;));</span>
<a href="#l29.204"></a><span id="l29.204">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.205"></a><span id="l29.205">     src_close(&amp;keysrc);</span>
<a href="#l29.206"></a><span id="l29.206"> </span>
<a href="#l29.207"></a><span id="l29.207">     /* p-256 ecc secret key */</span>
<a href="#l29.208"></a><span id="l29.208">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256-sec.asc&quot;));</span>
<a href="#l29.209"></a><span id="l29.209" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.210"></a><span id="l29.210" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.211"></a><span id="l29.211">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.212"></a><span id="l29.212">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.213"></a><span id="l29.213">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.214"></a><span id="l29.214">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.215"></a><span id="l29.215">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.216"></a><span id="l29.216">     src_close(&amp;keysrc);</span>
<a href="#l29.217"></a><span id="l29.217"> </span>
<a href="#l29.218"></a><span id="l29.218">     /* p-384 ecc public key */</span>
<a href="#l29.219"></a><span id="l29.219">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p384-pub.asc&quot;));</span>
<a href="#l29.220"></a><span id="l29.220" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.221"></a><span id="l29.221" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.222"></a><span id="l29.222">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.223"></a><span id="l29.223">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.224"></a><span id="l29.224">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.225"></a><span id="l29.225">     assert_true(cmp_keyfp(&amp;keyfp, &quot;AB25CBA042DD924C3ACC3ED3242A3AA5EA85F44A&quot;));</span>
<a href="#l29.226"></a><span id="l29.226">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.227"></a><span id="l29.227">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.228"></a><span id="l29.228">     assert_true(cmp_keyid(keyid, &quot;E210E3D554A4FAD9&quot;));</span>
<a href="#l29.229"></a><span id="l29.229">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.230"></a><span id="l29.230">     src_close(&amp;keysrc);</span>
<a href="#l29.231"></a><span id="l29.231"> </span>
<a href="#l29.232"></a><span id="l29.232">     /* p-384 ecc secret key */</span>
<a href="#l29.233"></a><span id="l29.233">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p384-sec.asc&quot;));</span>
<a href="#l29.234"></a><span id="l29.234" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.235"></a><span id="l29.235" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.236"></a><span id="l29.236">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.237"></a><span id="l29.237">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.238"></a><span id="l29.238">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.239"></a><span id="l29.239">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.240"></a><span id="l29.240">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.241"></a><span id="l29.241">     src_close(&amp;keysrc);</span>
<a href="#l29.242"></a><span id="l29.242"> </span>
<a href="#l29.243"></a><span id="l29.243">     /* p-521 ecc public key */</span>
<a href="#l29.244"></a><span id="l29.244">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p521-pub.asc&quot;));</span>
<a href="#l29.245"></a><span id="l29.245" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.246"></a><span id="l29.246" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.247"></a><span id="l29.247">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.248"></a><span id="l29.248">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.249"></a><span id="l29.249">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.250"></a><span id="l29.250">     assert_true(cmp_keyfp(&amp;keyfp, &quot;4FB39FF6FA4857A4BD7EF5B42092CA8324263B6A&quot;));</span>
<a href="#l29.251"></a><span id="l29.251">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.252"></a><span id="l29.252">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.253"></a><span id="l29.253">     assert_true(cmp_keyid(keyid, &quot;9853DF2F6D297442&quot;));</span>
<a href="#l29.254"></a><span id="l29.254">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.255"></a><span id="l29.255">     src_close(&amp;keysrc);</span>
<a href="#l29.256"></a><span id="l29.256"> </span>
<a href="#l29.257"></a><span id="l29.257">     /* p-521 ecc secret key */</span>
<a href="#l29.258"></a><span id="l29.258">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p521-sec.asc&quot;));</span>
<a href="#l29.259"></a><span id="l29.259" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.260"></a><span id="l29.260" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.261"></a><span id="l29.261">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.262"></a><span id="l29.262">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.263"></a><span id="l29.263">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.264"></a><span id="l29.264">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.265"></a><span id="l29.265">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.266"></a><span id="l29.266">     src_close(&amp;keysrc);</span>
<a href="#l29.267"></a><span id="l29.267"> </span>
<a href="#l29.268"></a><span id="l29.268">     /* Brainpool P256 ecc public key */</span>
<a href="#l29.269"></a><span id="l29.269">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp256-pub.asc&quot;));</span>
<a href="#l29.270"></a><span id="l29.270" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.271"></a><span id="l29.271" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.272"></a><span id="l29.272">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.273"></a><span id="l29.273">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.274"></a><span id="l29.274">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.275"></a><span id="l29.275">     assert_true(cmp_keyfp(&amp;keyfp, &quot;0633C5F72A198F51E650E4ABD0C8A3DAF9E0634A&quot;));</span>
<a href="#l29.276"></a><span id="l29.276">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.277"></a><span id="l29.277">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.278"></a><span id="l29.278">     assert_true(cmp_keyid(keyid, &quot;2EDABB94D3055F76&quot;));</span>
<a href="#l29.279"></a><span id="l29.279">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.280"></a><span id="l29.280">     src_close(&amp;keysrc);</span>
<a href="#l29.281"></a><span id="l29.281"> </span>
<a href="#l29.282"></a><span id="l29.282">     /* Brainpool P256 ecc secret key */</span>
<a href="#l29.283"></a><span id="l29.283">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp256-sec.asc&quot;));</span>
<a href="#l29.284"></a><span id="l29.284" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.285"></a><span id="l29.285" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.286"></a><span id="l29.286">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.287"></a><span id="l29.287">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.288"></a><span id="l29.288">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.289"></a><span id="l29.289">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.290"></a><span id="l29.290">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.291"></a><span id="l29.291">     src_close(&amp;keysrc);</span>
<a href="#l29.292"></a><span id="l29.292"> </span>
<a href="#l29.293"></a><span id="l29.293">     /* Brainpool P384 ecc public key */</span>
<a href="#l29.294"></a><span id="l29.294">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp384-pub.asc&quot;));</span>
<a href="#l29.295"></a><span id="l29.295" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.296"></a><span id="l29.296" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.297"></a><span id="l29.297">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.298"></a><span id="l29.298">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.299"></a><span id="l29.299">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.300"></a><span id="l29.300">     assert_true(cmp_keyfp(&amp;keyfp, &quot;5B8A254C823CED98DECD10ED6CF2DCE85599ADA2&quot;));</span>
<a href="#l29.301"></a><span id="l29.301">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.302"></a><span id="l29.302">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.303"></a><span id="l29.303">     assert_true(cmp_keyid(keyid, &quot;CFF1BB6F16D28191&quot;));</span>
<a href="#l29.304"></a><span id="l29.304">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.305"></a><span id="l29.305">     src_close(&amp;keysrc);</span>
<a href="#l29.306"></a><span id="l29.306"> </span>
<a href="#l29.307"></a><span id="l29.307">     /* Brainpool P384 ecc secret key */</span>
<a href="#l29.308"></a><span id="l29.308">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp384-sec.asc&quot;));</span>
<a href="#l29.309"></a><span id="l29.309" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.310"></a><span id="l29.310" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.311"></a><span id="l29.311">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.312"></a><span id="l29.312">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.313"></a><span id="l29.313">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.314"></a><span id="l29.314">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.315"></a><span id="l29.315">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.316"></a><span id="l29.316">     src_close(&amp;keysrc);</span>
<a href="#l29.317"></a><span id="l29.317"> </span>
<a href="#l29.318"></a><span id="l29.318">     /* Brainpool P512 ecc public key */</span>
<a href="#l29.319"></a><span id="l29.319">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp512-pub.asc&quot;));</span>
<a href="#l29.320"></a><span id="l29.320" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.321"></a><span id="l29.321" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.322"></a><span id="l29.322">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.323"></a><span id="l29.323">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.324"></a><span id="l29.324">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.325"></a><span id="l29.325">     assert_true(cmp_keyfp(&amp;keyfp, &quot;4C59AB9272AA6A1F60B85BD0AA5C58D14F7B8F48&quot;));</span>
<a href="#l29.326"></a><span id="l29.326">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.327"></a><span id="l29.327">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.328"></a><span id="l29.328">     assert_true(cmp_keyid(keyid, &quot;20CDAA1482BA79CE&quot;));</span>
<a href="#l29.329"></a><span id="l29.329">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.330"></a><span id="l29.330">     src_close(&amp;keysrc);</span>
<a href="#l29.331"></a><span id="l29.331"> </span>
<a href="#l29.332"></a><span id="l29.332">     /* Brainpool P512 ecc secret key */</span>
<a href="#l29.333"></a><span id="l29.333">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-bp512-sec.asc&quot;));</span>
<a href="#l29.334"></a><span id="l29.334" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.335"></a><span id="l29.335" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.336"></a><span id="l29.336">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.337"></a><span id="l29.337">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.338"></a><span id="l29.338">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.339"></a><span id="l29.339">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.340"></a><span id="l29.340">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.341"></a><span id="l29.341">     src_close(&amp;keysrc);</span>
<a href="#l29.342"></a><span id="l29.342"> </span>
<a href="#l29.343"></a><span id="l29.343">     /* secp256k1 ecc public key, not supported now */</span>
<a href="#l29.344"></a><span id="l29.344">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256k1-pub.asc&quot;));</span>
<a href="#l29.345"></a><span id="l29.345" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.346"></a><span id="l29.346" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.347"></a><span id="l29.347">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.348"></a><span id="l29.348">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.349"></a><span id="l29.349">     assert_rnp_success(pgp_fingerprint(&amp;keyfp, &amp;key-&gt;key));</span>
<a href="#l29.350"></a><span id="l29.350">     assert_true(cmp_keyfp(&amp;keyfp, &quot;81F772B57D4EBFE7000A66233EA5BB6F9692C1A0&quot;));</span>
<a href="#l29.351"></a><span id="l29.351">     assert_non_null(skey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.352"></a><span id="l29.352">     assert_rnp_success(pgp_keyid(keyid, PGP_KEY_ID_SIZE, &amp;skey-&gt;subkey));</span>
<a href="#l29.353"></a><span id="l29.353">     assert_true(cmp_keyid(keyid, &quot;7635401F90D3E533&quot;));</span>
<a href="#l29.354"></a><span id="l29.354">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.355"></a><span id="l29.355">     src_close(&amp;keysrc);</span>
<a href="#l29.356"></a><span id="l29.356"> </span>
<a href="#l29.357"></a><span id="l29.357">     /* secp256k1 ecc secret key */</span>
<a href="#l29.358"></a><span id="l29.358">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256k1-sec.asc&quot;));</span>
<a href="#l29.359"></a><span id="l29.359" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.360"></a><span id="l29.360" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.361"></a><span id="l29.361">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.362"></a><span id="l29.362">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.363"></a><span id="l29.363">     assert_int_equal(list_length(key-&gt;subkeys), 1);</span>
<a href="#l29.364"></a><span id="l29.364">     assert_non_null(list_front(key-&gt;subkeys));</span>
<a href="#l29.365"></a><span id="l29.365">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.366"></a><span id="l29.366">     src_close(&amp;keysrc);</span>
<a href="#l29.367"></a><span id="l29.367"> }</span>
<a href="#l29.368"></a><span id="l29.368"> </span>
<a href="#l29.369"></a><span id="l29.369" class="difflineat">@@ -787,32 +787,32 @@ buggy_key_load_single(const void *keydat</span>
<a href="#l29.370"></a><span id="l29.370">     pgp_source_t       memsrc = {0};</span>
<a href="#l29.371"></a><span id="l29.371">     pgp_key_sequence_t keyseq;</span>
<a href="#l29.372"></a><span id="l29.372">     size_t             partlen;</span>
<a href="#l29.373"></a><span id="l29.373">     uint8_t *          dataptr;</span>
<a href="#l29.374"></a><span id="l29.374"> </span>
<a href="#l29.375"></a><span id="l29.375">     /* try truncated load */</span>
<a href="#l29.376"></a><span id="l29.376">     for (partlen = 1; partlen &lt; keylen; partlen += 15) {</span>
<a href="#l29.377"></a><span id="l29.377">         assert_rnp_success(init_mem_src(&amp;memsrc, keydata, partlen, false));</span>
<a href="#l29.378"></a><span id="l29.378" class="difflineminus">-        if (!process_pgp_keys(&amp;memsrc, &amp;keyseq)) {</span>
<a href="#l29.379"></a><span id="l29.379" class="difflineplus">+        if (!process_pgp_keys(&amp;memsrc, &amp;keyseq, false)) {</span>
<a href="#l29.380"></a><span id="l29.380">             /* it may succeed if we accidentally hit some packet boundary */</span>
<a href="#l29.381"></a><span id="l29.381">             assert_non_null(list_front(keyseq.keys));</span>
<a href="#l29.382"></a><span id="l29.382">             key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.383"></a><span id="l29.383">         } else {</span>
<a href="#l29.384"></a><span id="l29.384">             assert_null(list_front(keyseq.keys));</span>
<a href="#l29.385"></a><span id="l29.385">         }</span>
<a href="#l29.386"></a><span id="l29.386">         src_close(&amp;memsrc);</span>
<a href="#l29.387"></a><span id="l29.387">     }</span>
<a href="#l29.388"></a><span id="l29.388"> </span>
<a href="#l29.389"></a><span id="l29.389">     /* try modified load */</span>
<a href="#l29.390"></a><span id="l29.390">     dataptr = (uint8_t *) keydata;</span>
<a href="#l29.391"></a><span id="l29.391">     for (partlen = 1; partlen &lt; keylen; partlen++) {</span>
<a href="#l29.392"></a><span id="l29.392">         dataptr[partlen] ^= 0xff;</span>
<a href="#l29.393"></a><span id="l29.393">         assert_rnp_success(init_mem_src(&amp;memsrc, keydata, keylen, false));</span>
<a href="#l29.394"></a><span id="l29.394" class="difflineminus">-        if (!process_pgp_keys(&amp;memsrc, &amp;keyseq)) {</span>
<a href="#l29.395"></a><span id="l29.395" class="difflineplus">+        if (!process_pgp_keys(&amp;memsrc, &amp;keyseq, false)) {</span>
<a href="#l29.396"></a><span id="l29.396">             /* it may succeed if we accidentally hit some packet boundary */</span>
<a href="#l29.397"></a><span id="l29.397">             assert_non_null(list_front(keyseq.keys));</span>
<a href="#l29.398"></a><span id="l29.398">             key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.399"></a><span id="l29.399">         } else {</span>
<a href="#l29.400"></a><span id="l29.400">             assert_null(list_front(keyseq.keys));</span>
<a href="#l29.401"></a><span id="l29.401">         }</span>
<a href="#l29.402"></a><span id="l29.402">         src_close(&amp;memsrc);</span>
<a href="#l29.403"></a><span id="l29.403">         dataptr[partlen] ^= 0xff;</span>
<a href="#l29.404"></a><span id="l29.404" class="difflineat">@@ -870,101 +870,101 @@ TEST_F(rnp_tests, test_stream_key_decryp</span>
<a href="#l29.405"></a><span id="l29.405"> {</span>
<a href="#l29.406"></a><span id="l29.406">     pgp_source_t               keysrc = {0};</span>
<a href="#l29.407"></a><span id="l29.407">     pgp_key_sequence_t         keyseq;</span>
<a href="#l29.408"></a><span id="l29.408">     pgp_transferable_key_t *   key = NULL;</span>
<a href="#l29.409"></a><span id="l29.409">     pgp_transferable_subkey_t *subkey = NULL;</span>
<a href="#l29.410"></a><span id="l29.410"> </span>
<a href="#l29.411"></a><span id="l29.411">     /* load and decrypt secret keyring */</span>
<a href="#l29.412"></a><span id="l29.412">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/1/secring.gpg&quot;));</span>
<a href="#l29.413"></a><span id="l29.413" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.414"></a><span id="l29.414" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.415"></a><span id="l29.415">     for (list_item *li = list_front(keyseq.keys); li; li = list_next(li)) {</span>
<a href="#l29.416"></a><span id="l29.416">         key = (pgp_transferable_key_t *) li;</span>
<a href="#l29.417"></a><span id="l29.417">         assert_rnp_failure(decrypt_secret_key(&amp;key-&gt;key, &quot;passw0rd&quot;));</span>
<a href="#l29.418"></a><span id="l29.418">         assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.419"></a><span id="l29.419"> </span>
<a href="#l29.420"></a><span id="l29.420">         for (list_item *sli = list_front(key-&gt;subkeys); sli; sli = list_next(sli)) {</span>
<a href="#l29.421"></a><span id="l29.421">             subkey = (pgp_transferable_subkey_t *) sli;</span>
<a href="#l29.422"></a><span id="l29.422">             assert_rnp_failure(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;passw0rd&quot;));</span>
<a href="#l29.423"></a><span id="l29.423">             assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.424"></a><span id="l29.424">         }</span>
<a href="#l29.425"></a><span id="l29.425">     }</span>
<a href="#l29.426"></a><span id="l29.426">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.427"></a><span id="l29.427">     src_close(&amp;keysrc);</span>
<a href="#l29.428"></a><span id="l29.428"> </span>
<a href="#l29.429"></a><span id="l29.429">     /* armored v3 secret key */</span>
<a href="#l29.430"></a><span id="l29.430">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/4/rsav3-s.asc&quot;));</span>
<a href="#l29.431"></a><span id="l29.431" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.432"></a><span id="l29.432" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.433"></a><span id="l29.433">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.434"></a><span id="l29.434">     assert_rnp_failure(decrypt_secret_key(&amp;key-&gt;key, &quot;passw0rd&quot;));</span>
<a href="#l29.435"></a><span id="l29.435">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.436"></a><span id="l29.436">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.437"></a><span id="l29.437">     src_close(&amp;keysrc);</span>
<a href="#l29.438"></a><span id="l29.438"> </span>
<a href="#l29.439"></a><span id="l29.439">     /* rsa/rsa secret key */</span>
<a href="#l29.440"></a><span id="l29.440">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/rsa-rsa-sec.asc&quot;));</span>
<a href="#l29.441"></a><span id="l29.441" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.442"></a><span id="l29.442" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.443"></a><span id="l29.443">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.444"></a><span id="l29.444">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.445"></a><span id="l29.445">     assert_non_null(subkey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.446"></a><span id="l29.446">     assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.447"></a><span id="l29.447">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.448"></a><span id="l29.448">     src_close(&amp;keysrc);</span>
<a href="#l29.449"></a><span id="l29.449"> </span>
<a href="#l29.450"></a><span id="l29.450">     /* dsa/el-gamal secret key */</span>
<a href="#l29.451"></a><span id="l29.451">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/dsa-eg-sec.asc&quot;));</span>
<a href="#l29.452"></a><span id="l29.452" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.453"></a><span id="l29.453" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.454"></a><span id="l29.454">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.455"></a><span id="l29.455">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.456"></a><span id="l29.456">     assert_non_null(subkey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.457"></a><span id="l29.457">     assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.458"></a><span id="l29.458">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.459"></a><span id="l29.459">     src_close(&amp;keysrc);</span>
<a href="#l29.460"></a><span id="l29.460"> </span>
<a href="#l29.461"></a><span id="l29.461">     /* curve 25519 eddsa ecc secret key */</span>
<a href="#l29.462"></a><span id="l29.462">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-25519-sec.asc&quot;));</span>
<a href="#l29.463"></a><span id="l29.463" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.464"></a><span id="l29.464" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.465"></a><span id="l29.465">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.466"></a><span id="l29.466">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.467"></a><span id="l29.467">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.468"></a><span id="l29.468">     src_close(&amp;keysrc);</span>
<a href="#l29.469"></a><span id="l29.469"> </span>
<a href="#l29.470"></a><span id="l29.470">     /* x25519 ecc secret key */</span>
<a href="#l29.471"></a><span id="l29.471">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-x25519-sec.asc&quot;));</span>
<a href="#l29.472"></a><span id="l29.472" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.473"></a><span id="l29.473" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.474"></a><span id="l29.474">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.475"></a><span id="l29.475">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.476"></a><span id="l29.476">     assert_non_null(subkey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.477"></a><span id="l29.477">     assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.478"></a><span id="l29.478">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.479"></a><span id="l29.479">     src_close(&amp;keysrc);</span>
<a href="#l29.480"></a><span id="l29.480"> </span>
<a href="#l29.481"></a><span id="l29.481">     /* p-256 ecc secret key */</span>
<a href="#l29.482"></a><span id="l29.482">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p256-sec.asc&quot;));</span>
<a href="#l29.483"></a><span id="l29.483" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.484"></a><span id="l29.484" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.485"></a><span id="l29.485">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.486"></a><span id="l29.486">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.487"></a><span id="l29.487">     assert_non_null(subkey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.488"></a><span id="l29.488">     assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.489"></a><span id="l29.489">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.490"></a><span id="l29.490">     src_close(&amp;keysrc);</span>
<a href="#l29.491"></a><span id="l29.491"> </span>
<a href="#l29.492"></a><span id="l29.492">     /* p-384 ecc secret key */</span>
<a href="#l29.493"></a><span id="l29.493">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p384-sec.asc&quot;));</span>
<a href="#l29.494"></a><span id="l29.494" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.495"></a><span id="l29.495" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.496"></a><span id="l29.496">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.497"></a><span id="l29.497">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.498"></a><span id="l29.498">     assert_non_null(subkey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.499"></a><span id="l29.499">     assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.500"></a><span id="l29.500">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.501"></a><span id="l29.501">     src_close(&amp;keysrc);</span>
<a href="#l29.502"></a><span id="l29.502"> </span>
<a href="#l29.503"></a><span id="l29.503">     /* p-521 ecc secret key */</span>
<a href="#l29.504"></a><span id="l29.504">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/test_stream_key_load/ecc-p521-sec.asc&quot;));</span>
<a href="#l29.505"></a><span id="l29.505" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.506"></a><span id="l29.506" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.507"></a><span id="l29.507">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.508"></a><span id="l29.508">     assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.509"></a><span id="l29.509">     assert_non_null(subkey = (pgp_transferable_subkey_t *) list_front(key-&gt;subkeys));</span>
<a href="#l29.510"></a><span id="l29.510">     assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.511"></a><span id="l29.511">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.512"></a><span id="l29.512">     src_close(&amp;keysrc);</span>
<a href="#l29.513"></a><span id="l29.513"> }</span>
<a href="#l29.514"></a><span id="l29.514"> </span>
<a href="#l29.515"></a><span id="l29.515" class="difflineat">@@ -980,17 +980,17 @@ TEST_F(rnp_tests, test_stream_key_encryp</span>
<a href="#l29.516"></a><span id="l29.516">     pgp_transferable_subkey_t *subkey = NULL;</span>
<a href="#l29.517"></a><span id="l29.517">     rng_t                      rng;</span>
<a href="#l29.518"></a><span id="l29.518"> </span>
<a href="#l29.519"></a><span id="l29.519">     /* we need rng for key encryption */</span>
<a href="#l29.520"></a><span id="l29.520">     assert_true(rng_init(&amp;rng, RNG_SYSTEM));</span>
<a href="#l29.521"></a><span id="l29.521"> </span>
<a href="#l29.522"></a><span id="l29.522">     /* load and decrypt secret keyring, then re-encrypt and reload keys */</span>
<a href="#l29.523"></a><span id="l29.523">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/1/secring.gpg&quot;));</span>
<a href="#l29.524"></a><span id="l29.524" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.525"></a><span id="l29.525" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.526"></a><span id="l29.526">     src_close(&amp;keysrc);</span>
<a href="#l29.527"></a><span id="l29.527">     for (list_item *li = list_front(keyseq.keys); li; li = list_next(li)) {</span>
<a href="#l29.528"></a><span id="l29.528">         key = (pgp_transferable_key_t *) li;</span>
<a href="#l29.529"></a><span id="l29.529">         assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;password&quot;));</span>
<a href="#l29.530"></a><span id="l29.530"> </span>
<a href="#l29.531"></a><span id="l29.531">         for (list_item *sli = list_front(key-&gt;subkeys); sli; sli = list_next(sli)) {</span>
<a href="#l29.532"></a><span id="l29.532">             subkey = (pgp_transferable_subkey_t *) sli;</span>
<a href="#l29.533"></a><span id="l29.533">             assert_rnp_success(decrypt_secret_key(&amp;subkey-&gt;subkey, &quot;password&quot;));</span>
<a href="#l29.534"></a><span id="l29.534" class="difflineat">@@ -1006,17 +1006,17 @@ TEST_F(rnp_tests, test_stream_key_encryp</span>
<a href="#l29.535"></a><span id="l29.535">         }</span>
<a href="#l29.536"></a><span id="l29.536">         /* write changed key */</span>
<a href="#l29.537"></a><span id="l29.537">         assert_rnp_success(init_mem_dest(&amp;keydst, keybuf, sizeof(keybuf)));</span>
<a href="#l29.538"></a><span id="l29.538">         assert_rnp_success(write_pgp_key(key, &amp;keydst, false));</span>
<a href="#l29.539"></a><span id="l29.539">         keylen = keydst.writeb;</span>
<a href="#l29.540"></a><span id="l29.540">         dst_close(&amp;keydst, false);</span>
<a href="#l29.541"></a><span id="l29.541">         /* load and decrypt changed key */</span>
<a href="#l29.542"></a><span id="l29.542">         assert_rnp_success(init_mem_src(&amp;keysrc, keybuf, keylen, false));</span>
<a href="#l29.543"></a><span id="l29.543" class="difflineminus">-        assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq2));</span>
<a href="#l29.544"></a><span id="l29.544" class="difflineplus">+        assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq2, false));</span>
<a href="#l29.545"></a><span id="l29.545">         src_close(&amp;keysrc);</span>
<a href="#l29.546"></a><span id="l29.546">         assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq2.keys));</span>
<a href="#l29.547"></a><span id="l29.547">         assert_int_equal(key-&gt;key.sec_protection.symm_alg, PGP_SA_CAMELLIA_192);</span>
<a href="#l29.548"></a><span id="l29.548">         assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, &quot;passw0rd&quot;));</span>
<a href="#l29.549"></a><span id="l29.549"> </span>
<a href="#l29.550"></a><span id="l29.550">         for (list_item *sli = list_front(key-&gt;subkeys); sli; sli = list_next(sli)) {</span>
<a href="#l29.551"></a><span id="l29.551">             subkey = (pgp_transferable_subkey_t *) sli;</span>
<a href="#l29.552"></a><span id="l29.552">             assert_int_equal(subkey-&gt;subkey.sec_protection.symm_alg, PGP_SA_CAMELLIA_256);</span>
<a href="#l29.553"></a><span id="l29.553" class="difflineat">@@ -1033,17 +1033,17 @@ TEST_F(rnp_tests, test_stream_key_encryp</span>
<a href="#l29.554"></a><span id="l29.554">         /* write changed key */</span>
<a href="#l29.555"></a><span id="l29.555">         assert_rnp_success(init_mem_dest(&amp;keydst, keybuf, sizeof(keybuf)));</span>
<a href="#l29.556"></a><span id="l29.556">         assert_rnp_success(write_pgp_key(key, &amp;keydst, false));</span>
<a href="#l29.557"></a><span id="l29.557">         keylen = keydst.writeb;</span>
<a href="#l29.558"></a><span id="l29.558">         dst_close(&amp;keydst, false);</span>
<a href="#l29.559"></a><span id="l29.559">         key_sequence_destroy(&amp;keyseq2);</span>
<a href="#l29.560"></a><span id="l29.560">         /* load non-encrypted key */</span>
<a href="#l29.561"></a><span id="l29.561">         assert_rnp_success(init_mem_src(&amp;keysrc, keybuf, keylen, false));</span>
<a href="#l29.562"></a><span id="l29.562" class="difflineminus">-        assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq2));</span>
<a href="#l29.563"></a><span id="l29.563" class="difflineplus">+        assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq2, false));</span>
<a href="#l29.564"></a><span id="l29.564">         src_close(&amp;keysrc);</span>
<a href="#l29.565"></a><span id="l29.565">         assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq2.keys));</span>
<a href="#l29.566"></a><span id="l29.566">         assert_int_equal(key-&gt;key.sec_protection.s2k.usage, PGP_S2KU_NONE);</span>
<a href="#l29.567"></a><span id="l29.567">         assert_rnp_success(decrypt_secret_key(&amp;key-&gt;key, NULL));</span>
<a href="#l29.568"></a><span id="l29.568"> </span>
<a href="#l29.569"></a><span id="l29.569">         for (list_item *sli = list_front(key-&gt;subkeys); sli; sli = list_next(sli)) {</span>
<a href="#l29.570"></a><span id="l29.570">             subkey = (pgp_transferable_subkey_t *) sli;</span>
<a href="#l29.571"></a><span id="l29.571">             assert_int_equal(subkey-&gt;subkey.sec_protection.s2k.usage, PGP_S2KU_NONE);</span>
<a href="#l29.572"></a><span id="l29.572" class="difflineat">@@ -1072,17 +1072,17 @@ TEST_F(rnp_tests, test_stream_key_signat</span>
<a href="#l29.573"></a><span id="l29.573"> </span>
<a href="#l29.574"></a><span id="l29.574">     /* we need rng for key validation */</span>
<a href="#l29.575"></a><span id="l29.575">     assert_true(rng_init(&amp;rng, RNG_SYSTEM));</span>
<a href="#l29.576"></a><span id="l29.576"> </span>
<a href="#l29.577"></a><span id="l29.577">     /* v3 public key */</span>
<a href="#l29.578"></a><span id="l29.578">     pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/4/rsav3-p.asc&quot;);</span>
<a href="#l29.579"></a><span id="l29.579">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l29.580"></a><span id="l29.580">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/4/rsav3-p.asc&quot;));</span>
<a href="#l29.581"></a><span id="l29.581" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.582"></a><span id="l29.582" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.583"></a><span id="l29.583">     src_close(&amp;keysrc);</span>
<a href="#l29.584"></a><span id="l29.584">     assert_int_equal(list_length(keyseq.keys), 1);</span>
<a href="#l29.585"></a><span id="l29.585">     assert_non_null(key = (pgp_transferable_key_t *) list_front(keyseq.keys));</span>
<a href="#l29.586"></a><span id="l29.586">     assert_non_null(uid = (pgp_transferable_userid_t *) list_front(key-&gt;userids));</span>
<a href="#l29.587"></a><span id="l29.587">     assert_non_null(sig = (pgp_signature_t *) list_front(uid-&gt;signatures));</span>
<a href="#l29.588"></a><span id="l29.588">     assert_true(signature_get_keyid(sig, keyid));</span>
<a href="#l29.589"></a><span id="l29.589">     assert_non_null(pkey = rnp_key_store_get_key_by_id(pubring, keyid, NULL));</span>
<a href="#l29.590"></a><span id="l29.590">     /* check certification signature */</span>
<a href="#l29.591"></a><span id="l29.591" class="difflineat">@@ -1094,17 +1094,17 @@ TEST_F(rnp_tests, test_stream_key_signat</span>
<a href="#l29.592"></a><span id="l29.592">     assert_rnp_failure(signature_validate(sig, pgp_key_get_material(pkey), &amp;hash));</span>
<a href="#l29.593"></a><span id="l29.593">     delete pubring;</span>
<a href="#l29.594"></a><span id="l29.594">     key_sequence_destroy(&amp;keyseq);</span>
<a href="#l29.595"></a><span id="l29.595"> </span>
<a href="#l29.596"></a><span id="l29.596">     /* keyring */</span>
<a href="#l29.597"></a><span id="l29.597">     pubring = new rnp_key_store_t(PGP_KEY_STORE_GPG, &quot;data/keyrings/1/pubring.gpg&quot;);</span>
<a href="#l29.598"></a><span id="l29.598">     assert_true(rnp_key_store_load_from_path(pubring, NULL));</span>
<a href="#l29.599"></a><span id="l29.599">     assert_rnp_success(init_file_src(&amp;keysrc, &quot;data/keyrings/1/pubring.gpg&quot;));</span>
<a href="#l29.600"></a><span id="l29.600" class="difflineminus">-    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq));</span>
<a href="#l29.601"></a><span id="l29.601" class="difflineplus">+    assert_rnp_success(process_pgp_keys(&amp;keysrc, &amp;keyseq, false));</span>
<a href="#l29.602"></a><span id="l29.602">     src_close(&amp;keysrc);</span>
<a href="#l29.603"></a><span id="l29.603"> </span>
<a href="#l29.604"></a><span id="l29.604">     /* check key signatures */</span>
<a href="#l29.605"></a><span id="l29.605">     for (list_item *li = list_front(keyseq.keys); li; li = list_next(li)) {</span>
<a href="#l29.606"></a><span id="l29.606">         key = (pgp_transferable_key_t *) li;</span>
<a href="#l29.607"></a><span id="l29.607"> </span>
<a href="#l29.608"></a><span id="l29.608">         for (list_item *uli = list_front(key-&gt;userids); uli; uli = list_next(uli)) {</span>
<a href="#l29.609"></a><span id="l29.609">             uid = (pgp_transferable_userid_t *) uli;</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/4b0de666d1a4">4b0de666d1a4</a> at 2020-07-30T19:32:33Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

